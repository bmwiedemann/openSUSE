From 420e1391b228586efa8546db343e8e6eb50e398b Mon Sep 17 00:00:00 2001
From: Mateusz Jablonski <mateusz.jablonski@intel.com>
Date: Thu, 28 Mar 2024 08:46:55 +0000
Subject: [PATCH] fix: handle not aligned gtt size reported by i915

when i915 reports gtt size between 47 and 48 bits we consider
it as 48 bit VA space

Related-To: GSD-8215
Signed-off-by: Mateusz Jablonski <mateusz.jablonski@intel.com>
---
 .../source/memory_manager/gfx_partition.cpp   |   3 +-
 shared/source/memory_manager/gfx_partition.h  |   4 +-
 .../os_agnostic_memory_manager.cpp            |   3 +-
 .../os_interface/linux/drm_memory_manager.cpp |   6 +-
 shared/source/os_interface/linux/drm_neo.cpp  |  19 ++-
 shared/source/os_interface/linux/drm_neo.h    |   3 +-
 .../os_interface/linux/product_helper_drm.cpp |   2 +-
 shared/test/common/libult/linux/drm_mock.h    |   4 +-
 .../mocks/linux/mock_drm_memory_manager.cpp   |   4 +-
 shared/test/common/mocks/mock_gfx_partition.h |   4 +-
 .../test/common/mocks/mock_memory_manager.cpp |   2 +-
 .../linux/device_command_stream_fixture.h     |   6 +-
 .../fixtures/front_window_fixture.cpp         |   4 +-
 .../memory_manager/gfx_partition_tests.cpp    | 110 +++++++++++-------
 ...m_memory_manager_localmem_prelim_tests.cpp |   2 +-
 ...memory_manager_localmem_upstream_tests.cpp |   2 +-
 .../linux/drm_memory_manager_tests.cpp        |   4 +-
 .../linux/drm_special_heap_test.cpp           |   4 +-
 .../os_interface/linux/drm_tests.cpp          |  37 +++++-
 19 files changed, 150 insertions(+), 73 deletions(-)

diff --git a/shared/source/memory_manager/gfx_partition.cpp b/shared/source/memory_manager/gfx_partition.cpp
index 42a1182360..524f378fbc 100644
--- a/shared/source/memory_manager/gfx_partition.cpp
+++ b/shared/source/memory_manager/gfx_partition.cpp
@@ -190,7 +190,7 @@ uint64_t GfxPartition::getHeapMinimalAddress(HeapIndex heapIndex) {
     }
 }
 
-bool GfxPartition::init(uint64_t gpuAddressSpace, size_t cpuAddressRangeSizeToReserve, uint32_t rootDeviceIndex, size_t numRootDevices, bool useExternalFrontWindowPool, uint64_t systemMemorySize) {
+bool GfxPartition::init(uint64_t gpuAddressSpace, size_t cpuAddressRangeSizeToReserve, uint32_t rootDeviceIndex, size_t numRootDevices, bool useExternalFrontWindowPool, uint64_t systemMemorySize, uint64_t gfxTop) {
 
     /*
      * I. 64-bit builds:
@@ -238,7 +238,6 @@ bool GfxPartition::init(uint64_t gpuAddressSpace, size_t cpuAddressRangeSizeToRe
      *  0x0  0x100000000                                       gpuAddressSpace
      */
 
-    uint64_t gfxTop = gpuAddressSpace + 1;
     uint64_t gfxBase = 0x0ull;
     const uint64_t gfxHeap32Size = 4 * MemoryConstants::gigaByte;
 
diff --git a/shared/source/memory_manager/gfx_partition.h b/shared/source/memory_manager/gfx_partition.h
index ba3607e9c7..ff06a603ea 100644
--- a/shared/source/memory_manager/gfx_partition.h
+++ b/shared/source/memory_manager/gfx_partition.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2019-2023 Intel Corporation
+ * Copyright (C) 2019-2024 Intel Corporation
  *
  * SPDX-License-Identifier: MIT
  *
@@ -39,7 +39,7 @@ class GfxPartition {
     GfxPartition(OSMemory::ReservedCpuAddressRange &reservedCpuAddressRangeForHeapSvm);
     MOCKABLE_VIRTUAL ~GfxPartition();
 
-    MOCKABLE_VIRTUAL bool init(uint64_t gpuAddressSpace, size_t cpuAddressRangeSizeToReserve, uint32_t rootDeviceIndex, size_t numRootDevices, bool useExternalFrontWindowPool, uint64_t systemMemorySize);
+    MOCKABLE_VIRTUAL bool init(uint64_t gpuAddressSpace, size_t cpuAddressRangeSizeToReserve, uint32_t rootDeviceIndex, size_t numRootDevices, bool useExternalFrontWindowPool, uint64_t systemMemorySize, uint64_t gfxTop);
 
     void heapInit(HeapIndex heapIndex, uint64_t base, uint64_t size) {
         getHeap(heapIndex).init(base, size, MemoryConstants::pageSize);
diff --git a/shared/source/memory_manager/os_agnostic_memory_manager.cpp b/shared/source/memory_manager/os_agnostic_memory_manager.cpp
index 39661b3199..c14c54a655 100644
--- a/shared/source/memory_manager/os_agnostic_memory_manager.cpp
+++ b/shared/source/memory_manager/os_agnostic_memory_manager.cpp
@@ -46,7 +46,8 @@ void OsAgnosticMemoryManager::initialize(bool aubUsage) {
         this->enable64kbpages[rootDeviceIndex] = is64kbPagesEnabled(hwInfo);
         this->localMemorySupported.push_back(gfxCoreHelper.getEnableLocalMemory(*hwInfo));
         auto gpuAddressSpace = executionEnvironment.rootDeviceEnvironments[rootDeviceIndex]->getHardwareInfo()->capabilityTable.gpuAddressSpace;
-        if (!getGfxPartition(rootDeviceIndex)->init(gpuAddressSpace, reservedCpuAddressRangeSize, rootDeviceIndex, gfxPartitions.size(), heapAssigners[rootDeviceIndex]->apiAllowExternalHeapForSshAndDsh, OsAgnosticMemoryManager::getSystemSharedMemory(rootDeviceIndex))) {
+        auto gfxTop = gpuAddressSpace + 1;
+        if (!getGfxPartition(rootDeviceIndex)->init(gpuAddressSpace, reservedCpuAddressRangeSize, rootDeviceIndex, gfxPartitions.size(), heapAssigners[rootDeviceIndex]->apiAllowExternalHeapForSshAndDsh, OsAgnosticMemoryManager::getSystemSharedMemory(rootDeviceIndex), gfxTop)) {
             initialized = false;
             return;
         }
diff --git a/shared/source/os_interface/linux/drm_memory_manager.cpp b/shared/source/os_interface/linux/drm_memory_manager.cpp
index a56e56506c..704bd2cb60 100644
--- a/shared/source/os_interface/linux/drm_memory_manager.cpp
+++ b/shared/source/os_interface/linux/drm_memory_manager.cpp
@@ -102,7 +102,9 @@ void DrmMemoryManager::initialize(GemCloseWorkerMode mode) {
 
     for (uint32_t rootDeviceIndex = 0; rootDeviceIndex < gfxPartitions.size(); ++rootDeviceIndex) {
         auto gpuAddressSpace = executionEnvironment.rootDeviceEnvironments[rootDeviceIndex]->getHardwareInfo()->capabilityTable.gpuAddressSpace;
-        if (!getGfxPartition(rootDeviceIndex)->init(gpuAddressSpace, getSizeToReserve(), rootDeviceIndex, gfxPartitions.size(), heapAssigners[rootDeviceIndex]->apiAllowExternalHeapForSshAndDsh, DrmMemoryManager::getSystemSharedMemory(rootDeviceIndex))) {
+        uint64_t gfxTop{};
+        getDrm(rootDeviceIndex).queryGttSize(gfxTop, false);
+        if (!getGfxPartition(rootDeviceIndex)->init(gpuAddressSpace, getSizeToReserve(), rootDeviceIndex, gfxPartitions.size(), heapAssigners[rootDeviceIndex]->apiAllowExternalHeapForSshAndDsh, DrmMemoryManager::getSystemSharedMemory(rootDeviceIndex), gfxTop)) {
             initialized = false;
             return;
         }
@@ -1251,7 +1253,7 @@ uint64_t DrmMemoryManager::getSystemSharedMemory(uint32_t rootDeviceIndex) {
 
     uint64_t gpuMemorySize = 0u;
 
-    [[maybe_unused]] auto ret = getDrm(rootDeviceIndex).queryGttSize(gpuMemorySize);
+    [[maybe_unused]] auto ret = getDrm(rootDeviceIndex).queryGttSize(gpuMemorySize, false);
     DEBUG_BREAK_IF(ret != 0);
 
     return std::min(hostMemorySize, gpuMemorySize);
diff --git a/shared/source/os_interface/linux/drm_neo.cpp b/shared/source/os_interface/linux/drm_neo.cpp
index b15b374339..f07952baef 100644
--- a/shared/source/os_interface/linux/drm_neo.cpp
+++ b/shared/source/os_interface/linux/drm_neo.cpp
@@ -232,13 +232,17 @@ bool Drm::readSysFsAsString(const std::string &relativeFilePath, std::string &re
     return true;
 }
 
-int Drm::queryGttSize(uint64_t &gttSizeOutput) {
+int Drm::queryGttSize(uint64_t &gttSizeOutput, bool alignUpToFullRange) {
     GemContextParam contextParam = {0};
     contextParam.param = ioctlHelper->getDrmParamValue(DrmParam::contextParamGttSize);
 
     int ret = ioctlHelper->ioctl(DrmIoctl::gemContextGetparam, &contextParam);
     if (ret == 0) {
-        gttSizeOutput = contextParam.value;
+        if (alignUpToFullRange) {
+            gttSizeOutput = Drm::alignUpGttSize(contextParam.value);
+        } else {
+            gttSizeOutput = contextParam.value;
+        }
     }
 
     return ret;
@@ -1580,6 +1584,17 @@ void Drm::waitOnUserFences(const OsContextLinux &osContext, uint64_t address, ui
 }
 const HardwareInfo *Drm::getHardwareInfo() const { return rootDeviceEnvironment.getHardwareInfo(); }
 
+uint64_t Drm::alignUpGttSize(uint64_t inputGttSize) {
+
+    constexpr uint64_t gttSize47bit = (1ull << 47);
+    constexpr uint64_t gttSize48bit = (1ull << 48);
+
+    if (inputGttSize > gttSize47bit && inputGttSize < gttSize48bit) {
+        return gttSize48bit;
+    }
+    return inputGttSize;
+}
+
 template std::vector<uint16_t> Drm::query<uint16_t>(uint32_t queryId, uint32_t queryItemFlags);
 template std::vector<uint32_t> Drm::query<uint32_t>(uint32_t queryId, uint32_t queryItemFlags);
 template std::vector<uint64_t> Drm::query<uint64_t>(uint32_t queryId, uint32_t queryItemFlags);
diff --git a/shared/source/os_interface/linux/drm_neo.h b/shared/source/os_interface/linux/drm_neo.h
index bbb961d5dd..451e0f542c 100644
--- a/shared/source/os_interface/linux/drm_neo.h
+++ b/shared/source/os_interface/linux/drm_neo.h
@@ -92,7 +92,7 @@ class Drm : public DriverModel {
     int getTimestampFrequency(int &frequency);
     int getOaTimestampFrequency(int &frequency);
 
-    MOCKABLE_VIRTUAL int queryGttSize(uint64_t &gttSizeOutput);
+    MOCKABLE_VIRTUAL int queryGttSize(uint64_t &gttSizeOutput, bool alignUpToFullRange);
     bool isPreemptionSupported() const { return preemptionSupported; }
 
     MOCKABLE_VIRTUAL void checkPreemptionSupport();
@@ -269,6 +269,7 @@ class Drm : public DriverModel {
     void queryAndSetVmBindPatIndexProgrammingSupport();
     bool queryDeviceIdAndRevision();
     bool queryI915DeviceIdAndRevision();
+    static uint64_t alignUpGttSize(uint64_t inputGttSize);
 
 #pragma pack(1)
     struct PCIConfig {
diff --git a/shared/source/os_interface/linux/product_helper_drm.cpp b/shared/source/os_interface/linux/product_helper_drm.cpp
index cf8de5b656..377d452095 100644
--- a/shared/source/os_interface/linux/product_helper_drm.cpp
+++ b/shared/source/os_interface/linux/product_helper_drm.cpp
@@ -125,7 +125,7 @@ int ProductHelper::configureHwInfoDrm(const HardwareInfo *inHwInfo, HardwareInfo
     uint64_t gttSizeQuery = 0;
     featureTable->flags.ftrSVM = true;
 
-    ret = drm->queryGttSize(gttSizeQuery);
+    ret = drm->queryGttSize(gttSizeQuery, true);
 
     if (ret == 0) {
         featureTable->flags.ftrSVM = (gttSizeQuery > MemoryConstants::max64BitAppAddress);
diff --git a/shared/test/common/libult/linux/drm_mock.h b/shared/test/common/libult/linux/drm_mock.h
index ae204026e5..65a94cd3f5 100644
--- a/shared/test/common/libult/linux/drm_mock.h
+++ b/shared/test/common/libult/linux/drm_mock.h
@@ -174,7 +174,7 @@ class DrmMock : public Drm {
         else
             return Drm::useVMBindImmediate();
     }
-    int queryGttSize(uint64_t &gttSizeOutput) override {
+    int queryGttSize(uint64_t &gttSizeOutput, bool alignUpToFullRange) override {
         gttSizeOutput = storedGTTSize;
         return storedRetValForGetGttSize;
     }
@@ -276,7 +276,7 @@ class DrmMock : public Drm {
     GemVmControl receivedGemVmControl{};
     uint32_t latestCreatedVmId = 0u;
 
-    uint64_t storedGTTSize = 1ull << 47;
+    uint64_t storedGTTSize = defaultHwInfo->capabilityTable.gpuAddressSpace + 1;
     uint64_t storedParamSseu = ULONG_MAX;
 
     Ioctls ioctlCount{};
diff --git a/shared/test/common/mocks/linux/mock_drm_memory_manager.cpp b/shared/test/common/mocks/linux/mock_drm_memory_manager.cpp
index 2673aed71a..6cead9a5b7 100644
--- a/shared/test/common/mocks/linux/mock_drm_memory_manager.cpp
+++ b/shared/test/common/mocks/linux/mock_drm_memory_manager.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2020-2023 Intel Corporation
+ * Copyright (C) 2020-2024 Intel Corporation
  *
  * SPDX-License-Identifier: MIT
  *
@@ -69,7 +69,7 @@ void TestedDrmMemoryManager::injectPinBB(BufferObject *newPinBB, uint32_t rootDe
 DrmGemCloseWorker *TestedDrmMemoryManager::getgemCloseWorker() { return this->gemCloseWorker.get(); }
 void TestedDrmMemoryManager::forceLimitedRangeAllocator(uint64_t range) {
     for (auto &gfxPartition : gfxPartitions) {
-        gfxPartition->init(range, getSizeToReserve(), 0, 1, false, 0u);
+        gfxPartition->init(range, getSizeToReserve(), 0, 1, false, 0u, range + 1);
     }
 }
 void TestedDrmMemoryManager::overrideGfxPartition(GfxPartition *newGfxPartition) { gfxPartitions[0].reset(newGfxPartition); }
diff --git a/shared/test/common/mocks/mock_gfx_partition.h b/shared/test/common/mocks/mock_gfx_partition.h
index 11277d0b12..d2581ee783 100644
--- a/shared/test/common/mocks/mock_gfx_partition.h
+++ b/shared/test/common/mocks/mock_gfx_partition.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2019-2023 Intel Corporation
+ * Copyright (C) 2019-2024 Intel Corporation
  *
  * SPDX-License-Identifier: MIT
  *
@@ -92,7 +92,7 @@ class MockGfxPartitionBasic : public GfxPartition {
 
 class FailedInitGfxPartition : public MockGfxPartition {
   public:
-    bool init(uint64_t gpuAddressSpace, size_t cpuAddressRangeSizeToReserve, uint32_t rootDeviceIndex, size_t numRootDevices, bool useFrontWindowPool, uint64_t systemMemorySize) override {
+    bool init(uint64_t gpuAddressSpace, size_t cpuAddressRangeSizeToReserve, uint32_t rootDeviceIndex, size_t numRootDevices, bool useFrontWindowPool, uint64_t systemMemorySize, uint64_t gfxTop) override {
         return false;
     }
 };
diff --git a/shared/test/common/mocks/mock_memory_manager.cpp b/shared/test/common/mocks/mock_memory_manager.cpp
index 038f545084..62322ca163 100644
--- a/shared/test/common/mocks/mock_memory_manager.cpp
+++ b/shared/test/common/mocks/mock_memory_manager.cpp
@@ -197,7 +197,7 @@ GraphicsAllocation *MockMemoryManager::allocate32BitGraphicsMemoryImpl(const All
 }
 
 void MockMemoryManager::forceLimitedRangeAllocator(uint32_t rootDeviceIndex, uint64_t range) {
-    getGfxPartition(rootDeviceIndex)->init(range, 0, 0, gfxPartitions.size(), false, 0u);
+    getGfxPartition(rootDeviceIndex)->init(range, 0, 0, gfxPartitions.size(), false, 0u, range + 1);
 }
 
 bool MockMemoryManager::hasPageFaultsEnabled(const Device &neoDevice) {
diff --git a/shared/test/common/os_interface/linux/device_command_stream_fixture.h b/shared/test/common/os_interface/linux/device_command_stream_fixture.h
index 71af90069e..998ffe9d50 100644
--- a/shared/test/common/os_interface/linux/device_command_stream_fixture.h
+++ b/shared/test/common/os_interface/linux/device_command_stream_fixture.h
@@ -184,11 +184,11 @@ class DrmMockCustom : public Drm {
 
     virtual void execBufferExtensions(void *execbuf) {
     }
-    int queryGttSize(uint64_t &gttSizeOutput) override {
+    int queryGttSize(uint64_t &gttSizeOutput, bool alignUpToFullRange) override {
         if (callBaseQueryGttSize) {
-            return Drm::queryGttSize(gttSizeOutput);
+            return Drm::queryGttSize(gttSizeOutput, alignUpToFullRange);
         }
-        gttSizeOutput = 1;
+        gttSizeOutput = NEO::defaultHwInfo->capabilityTable.gpuAddressSpace + 1;
         return 0u;
     }
 
diff --git a/shared/test/unit_test/fixtures/front_window_fixture.cpp b/shared/test/unit_test/fixtures/front_window_fixture.cpp
index a8d84700f4..88bbc446f4 100644
--- a/shared/test/unit_test/fixtures/front_window_fixture.cpp
+++ b/shared/test/unit_test/fixtures/front_window_fixture.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2021-2023 Intel Corporation
+ * Copyright (C) 2021-2024 Intel Corporation
  *
  * SPDX-License-Identifier: MIT
  *
@@ -17,7 +17,7 @@
 using namespace NEO;
 
 MemManagerFixture::FrontWindowMemManagerMock::FrontWindowMemManagerMock(NEO::ExecutionEnvironment &executionEnvironment) : MockMemoryManager(executionEnvironment) {}
-void MemManagerFixture::FrontWindowMemManagerMock::forceLimitedRangeAllocator(uint32_t rootDeviceIndex, uint64_t range) { getGfxPartition(rootDeviceIndex)->init(range, 0, 0, gfxPartitions.size(), true, 0u); }
+void MemManagerFixture::FrontWindowMemManagerMock::forceLimitedRangeAllocator(uint32_t rootDeviceIndex, uint64_t range) { getGfxPartition(rootDeviceIndex)->init(range, 0, 0, gfxPartitions.size(), true, 0u, range + 1); }
 
 void MemManagerFixture::setUp() {
     DebugManagerStateRestore dbgRestorer;
diff --git a/shared/test/unit_test/memory_manager/gfx_partition_tests.cpp b/shared/test/unit_test/memory_manager/gfx_partition_tests.cpp
index 6c40f2d67f..4ecf385728 100644
--- a/shared/test/unit_test/memory_manager/gfx_partition_tests.cpp
+++ b/shared/test/unit_test/memory_manager/gfx_partition_tests.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2019-2023 Intel Corporation
+ * Copyright (C) 2019-2024 Intel Corporation
  *
  * SPDX-License-Identifier: MIT
  *
@@ -164,9 +164,19 @@ void testGfxPartition(MockGfxPartition &gfxPartition, uint64_t gfxBase, uint64_t
 
 TEST(GfxPartitionTest, GivenFullRange48BitSvmWhenTestingGfxPartitionThenAllExpectationsAreMet) {
     MockGfxPartition gfxPartition;
-    gfxPartition.init(maxNBitValue(48), reservedCpuAddressRangeSize, 0, 1, false, 0u);
-
     uint64_t gfxTop = maxNBitValue(48) + 1;
+    gfxPartition.init(maxNBitValue(48), reservedCpuAddressRangeSize, 0, 1, false, 0u, gfxTop);
+
+    uint64_t gfxBase = MemoryConstants::maxSvmAddress + 1;
+
+    testGfxPartition(gfxPartition, gfxBase, gfxTop, gfxBase);
+}
+
+TEST(GfxPartitionTest, GivenRange48BitWithoutPageWhenTestingGfxPartitionThenAllExpectationsAreMet) {
+    MockGfxPartition gfxPartition;
+    uint64_t gfxTop = maxNBitValue(48) + 1 - MemoryConstants::pageSize;
+    gfxPartition.init(maxNBitValue(48), reservedCpuAddressRangeSize, 0, 1, false, 0u, gfxTop);
+
     uint64_t gfxBase = MemoryConstants::maxSvmAddress + 1;
 
     testGfxPartition(gfxPartition, gfxBase, gfxTop, gfxBase);
@@ -174,21 +184,21 @@ TEST(GfxPartitionTest, GivenFullRange48BitSvmWhenTestingGfxPartitionThenAllExpec
 
 TEST(GfxPartitionTest, GivenFullRange47BitSvmWhenTestingGfxPartitionThenAllExpectationsAreMet) {
     MockGfxPartition gfxPartition;
-    gfxPartition.init(maxNBitValue(47), reservedCpuAddressRangeSize, 0, 1, false, 0u);
+    gfxPartition.init(maxNBitValue(47), reservedCpuAddressRangeSize, 0, 1, false, 0u, maxNBitValue(47) + 1);
 
+    uint64_t svmTop = MemoryConstants::maxSvmAddress + 1;
     uint64_t gfxBase = is32bit ? MemoryConstants::maxSvmAddress + 1 : (uint64_t)gfxPartition.getReservedCpuAddressRange();
     uint64_t gfxTop = is32bit ? maxNBitValue(47) + 1 : gfxBase + gfxPartition.getReservedCpuAddressRangeSize();
-    uint64_t svmTop = MemoryConstants::maxSvmAddress + 1;
 
     testGfxPartition(gfxPartition, gfxBase, gfxTop, svmTop);
 }
 
 TEST(GfxPartitionTest, GivenLimitedRangeWhenTestingGfxPartitionThenAllExpectationsAreMet) {
     MockGfxPartition gfxPartition;
-    gfxPartition.init(maxNBitValue(47 - 1), reservedCpuAddressRangeSize, 0, 1, false, 0u);
+    uint64_t gfxTop = maxNBitValue(47 - 1) + 1;
+    gfxPartition.init(maxNBitValue(47 - 1), reservedCpuAddressRangeSize, 0, 1, false, 0u, gfxTop);
 
     uint64_t gfxBase = is32bit ? MemoryConstants::maxSvmAddress + 1 : 0ull;
-    uint64_t gfxTop = maxNBitValue(47 - 1) + 1;
     uint64_t svmTop = gfxBase;
 
     testGfxPartition(gfxPartition, gfxBase, gfxTop, svmTop);
@@ -200,7 +210,8 @@ TEST(GfxPartitionTest, GivenUnsupportedGpuRangeThenGfxPartitionIsNotInitialized)
     }
 
     MockGfxPartition gfxPartition;
-    EXPECT_FALSE(gfxPartition.init(maxNBitValue(48 + 1), reservedCpuAddressRangeSize, 0, 1, false, 0u));
+    uint64_t gfxTop = maxNBitValue(48) + 1;
+    EXPECT_FALSE(gfxPartition.init(maxNBitValue(48 + 1), reservedCpuAddressRangeSize, 0, 1, false, 0u, gfxTop));
 }
 
 TEST(GfxPartitionTest, GivenUnsupportedCpuRangeThenGfxPartitionIsNotInitialize) {
@@ -210,7 +221,8 @@ TEST(GfxPartitionTest, GivenUnsupportedCpuRangeThenGfxPartitionIsNotInitialize)
 
     CpuInfoOverrideVirtualAddressSizeAndFlags overrideCpuInfo(48 + 1);
     MockGfxPartition gfxPartition;
-    EXPECT_FALSE(gfxPartition.init(maxNBitValue(48), reservedCpuAddressRangeSize, 0, 1, false, 0u));
+    uint64_t gfxTop = maxNBitValue(48) + 1;
+    EXPECT_FALSE(gfxPartition.init(maxNBitValue(48), reservedCpuAddressRangeSize, 0, 1, false, 0u, gfxTop));
 }
 
 TEST(GfxPartitionTest, GivenFullRange48BitSvmHeap64KbSplitWhenTestingGfxPartitionThenAllExpectationsAreMet) {
@@ -218,10 +230,10 @@ TEST(GfxPartitionTest, GivenFullRange48BitSvmHeap64KbSplitWhenTestingGfxPartitio
     size_t numRootDevices = 5;
 
     MockGfxPartition gfxPartition;
-    gfxPartition.init(maxNBitValue(48), reservedCpuAddressRangeSize, rootDeviceIndex, numRootDevices, false, 0u);
+    uint64_t gfxTop = maxNBitValue(48) + 1;
+    gfxPartition.init(maxNBitValue(48), reservedCpuAddressRangeSize, rootDeviceIndex, numRootDevices, false, 0u, gfxTop);
 
     uint64_t gfxBase = is32bit ? MemoryConstants::maxSvmAddress + 1 : maxNBitValue(48 - 1) + 1;
-    uint64_t gfxTop = maxNBitValue(48) + 1;
 
     constexpr auto numStandardHeaps = static_cast<uint32_t>(HeapIndex::heapStandard2MB) - static_cast<uint32_t>(HeapIndex::heapStandard) + 1;
     constexpr auto maxStandardHeapGranularity = std::max(GfxPartition::heapGranularity, GfxPartition::heapGranularity2MB);
@@ -237,7 +249,7 @@ TEST(GfxPartitionTest, GivenFullRange47BitSvmHeap64KbSplitWhenTestingGfxPartitio
     size_t numRootDevices = 5;
 
     MockGfxPartition gfxPartition;
-    gfxPartition.init(maxNBitValue(47), reservedCpuAddressRangeSize, rootDeviceIndex, numRootDevices, false, 0u);
+    gfxPartition.init(maxNBitValue(47), reservedCpuAddressRangeSize, rootDeviceIndex, numRootDevices, false, 0u, maxNBitValue(47) + 1);
 
     uint64_t gfxBase = is32bit ? MemoryConstants::maxSvmAddress + 1 : (uint64_t)gfxPartition.getReservedCpuAddressRange();
     uint64_t gfxTop = is32bit ? maxNBitValue(47) + 1 : gfxBase + gfxPartition.getReservedCpuAddressRangeSize();
@@ -291,12 +303,13 @@ TEST(GfxPartitionTest, given47bitGpuAddressSpaceWhenInitializingMultipleGfxParti
         GTEST_SKIP();
     }
 
+    uint64_t gfxTop = maxNBitValue(47) + 1;
     OSMemory::ReservedCpuAddressRange reservedCpuAddressRange;
     std::vector<std::unique_ptr<MockGfxPartition>> gfxPartitions;
     for (int i = 0; i < 10; ++i) {
         gfxPartitions.push_back(std::make_unique<MockGfxPartition>(reservedCpuAddressRange));
         gfxPartitions[i]->osMemory.reset(new MockOsMemory);
-        gfxPartitions[i]->init(maxNBitValue(47), reservedCpuAddressRangeSize, i, 10, false, 0u);
+        gfxPartitions[i]->init(maxNBitValue(47), reservedCpuAddressRangeSize, i, 10, false, 0u, gfxTop);
     }
 
     EXPECT_EQ(1u, static_cast<MockOsMemory *>(gfxPartitions[0]->osMemory.get())->getReserveCount());
@@ -308,7 +321,8 @@ TEST(GfxPartitionTest, GivenFullRange47BitSvmAndReservedCpuRangeSizeIsZeroThenGf
     }
 
     MockGfxPartition gfxPartition;
-    EXPECT_FALSE(gfxPartition.init(maxNBitValue(47), 0, 0, 1, false, 0u));
+    uint64_t gfxTop = maxNBitValue(47) + 1;
+    EXPECT_FALSE(gfxPartition.init(maxNBitValue(47), 0, 0, 1, false, 0u, gfxTop));
 }
 
 TEST(GfxPartitionTest, GivenFullRange47BitSvmAndReturnedReservedCpuRangeIsNullThenGfxPartitionIsNotInitialized) {
@@ -320,7 +334,8 @@ TEST(GfxPartitionTest, GivenFullRange47BitSvmAndReturnedReservedCpuRangeIsNullTh
     mockOsMemory->returnAddress = nullptr;
     MockGfxPartition gfxPartition;
     gfxPartition.osMemory.reset(mockOsMemory);
-    EXPECT_FALSE(gfxPartition.init(maxNBitValue(47), reservedCpuAddressRangeSize, 0, 1, false, 0u));
+    uint64_t gfxTop = maxNBitValue(47) + 1;
+    EXPECT_FALSE(gfxPartition.init(maxNBitValue(47), reservedCpuAddressRangeSize, 0, 1, false, 0u, gfxTop));
 }
 
 TEST(GfxPartitionTest, GivenFullRange47BitSvmAndReturnedReservedCpuRangeIsNotAlignedThenGfxPartitionIsNotInitialized) {
@@ -332,12 +347,14 @@ TEST(GfxPartitionTest, GivenFullRange47BitSvmAndReturnedReservedCpuRangeIsNotAli
     mockOsMemory->returnAddress = reinterpret_cast<void *>(0x10001);
     MockGfxPartition gfxPartition;
     gfxPartition.osMemory.reset(mockOsMemory);
-    EXPECT_FALSE(gfxPartition.init(maxNBitValue(47), reservedCpuAddressRangeSize, 0, 1, false, 0u));
+    uint64_t gfxTop = maxNBitValue(47) + 1;
+    EXPECT_FALSE(gfxPartition.init(maxNBitValue(47), reservedCpuAddressRangeSize, 0, 1, false, 0u, gfxTop));
 }
 
 TEST(GfxPartitionTest, givenGfxPartitionWhenInitializedThenInternalFrontWindowHeapIsAllocatedAtInternalHeapFront) {
     MockGfxPartition gfxPartition;
-    gfxPartition.init(maxNBitValue(48), reservedCpuAddressRangeSize, 0, 1, false, 0u);
+    uint64_t gfxTop = maxNBitValue(48) + 1;
+    gfxPartition.init(maxNBitValue(48), reservedCpuAddressRangeSize, 0, 1, false, 0u, gfxTop);
 
     EXPECT_EQ(gfxPartition.getHeapBase(HeapIndex::heapInternalFrontWindow), gfxPartition.getHeapBase(HeapIndex::heapInternal));
     EXPECT_EQ(gfxPartition.getHeapBase(HeapIndex::heapInternalDeviceFrontWindow), gfxPartition.getHeapBase(HeapIndex::heapInternalDeviceMemory));
@@ -360,7 +377,8 @@ TEST(GfxPartitionTest, givenGfxPartitionWhenInitializedThenInternalFrontWindowHe
 
 TEST(GfxPartitionTest, givenInternalFrontWindowHeapWhenAllocatingSmallOrBigChunkThenAddressFromFrontIsReturned) {
     MockGfxPartition gfxPartition;
-    gfxPartition.init(maxNBitValue(48), reservedCpuAddressRangeSize, 0, 1, false, 0u);
+    uint64_t gfxTop = maxNBitValue(48) + 1;
+    gfxPartition.init(maxNBitValue(48), reservedCpuAddressRangeSize, 0, 1, false, 0u, gfxTop);
 
     const size_t sizeSmall = MemoryConstants::pageSize64k;
     const size_t sizeBig = static_cast<size_t>(gfxPartition.getHeapSize(HeapIndex::heapInternalFrontWindow)) - MemoryConstants::pageSize64k;
@@ -385,7 +403,8 @@ TEST(GfxPartitionTest, givenInternalFrontWindowHeapWhenAllocatingSmallOrBigChunk
 
 TEST(GfxPartitionTest, givenInternalHeapWhenAllocatingSmallOrBigChunkThenAddressAfterFrontWindowIsReturned) {
     MockGfxPartition gfxPartition;
-    gfxPartition.init(maxNBitValue(48), reservedCpuAddressRangeSize, 0, 1, false, 0u);
+    uint64_t gfxTop = maxNBitValue(48) + 1;
+    gfxPartition.init(maxNBitValue(48), reservedCpuAddressRangeSize, 0, 1, false, 0u, gfxTop);
 
     const size_t sizeSmall = MemoryConstants::pageSize64k;
     const size_t sizeBig = 4 * MemoryConstants::megaByte + MemoryConstants::pageSize64k;
@@ -413,7 +432,9 @@ using GfxPartitionTestForAllHeapTypes = ::testing::TestWithParam<HeapIndex>;
 
 TEST_P(GfxPartitionTestForAllHeapTypes, givenHeapIndexWhenFreeGpuAddressRangeIsCalledThenFreeMemory) {
     MockGfxPartition gfxPartition;
-    gfxPartition.init(maxNBitValue(48), reservedCpuAddressRangeSize, 0, 1, false, 0u);
+
+    uint64_t gfxTop = maxNBitValue(48) + 1;
+    gfxPartition.init(maxNBitValue(48), reservedCpuAddressRangeSize, 0, 1, false, 0u, gfxTop);
     gfxPartition.callBasefreeGpuAddressRange = true;
     const HeapIndex heapIndex = GetParam();
     const size_t allocationSize = static_cast<size_t>(gfxPartition.getHeapSize(heapIndex)) * 3 / 4;
@@ -589,8 +610,8 @@ TEST_P(GfxPartitionOn57bTest, given48bitCpuAddressWidthWhenInitializingGfxPartit
     CpuInfoOverrideVirtualAddressSizeAndFlags overrideCpuInfo(48);
 
     resetGfxPartition();
-
-    EXPECT_TRUE(gfxPartition->init(maxNBitValue(gpuAddressSpace), 0, 0, 1, false, 0u));
+    uint64_t gfxTop = maxNBitValue(gpuAddressSpace) + 1;
+    EXPECT_TRUE(gfxPartition->init(maxNBitValue(gpuAddressSpace), 0, 0, 1, false, 0u, gfxTop));
     EXPECT_EQ(0u, mockOsMemory->freeCounter);
     EXPECT_EQ(0u, mockOsMemory->reservationSizes.size());
     /* init HEAP_EXTENDED only on 57 bit GPU */
@@ -609,7 +630,8 @@ TEST_P(GfxPartitionOn57bTest, given57bitCpuAddressWidthAndLa57IsNotPresentWhenIn
 
     resetGfxPartition();
 
-    EXPECT_TRUE(gfxPartition->init(maxNBitValue(gpuAddressSpace), 0, 0, 1, false, 0u));
+    uint64_t gfxTop = maxNBitValue(gpuAddressSpace) + 1;
+    EXPECT_TRUE(gfxPartition->init(maxNBitValue(gpuAddressSpace), 0, 0, 1, false, 0u, gfxTop));
     EXPECT_EQ(0u, mockOsMemory->freeCounter);
     EXPECT_EQ(0u, mockOsMemory->reservationSizes.size());
     /* init HEAP_EXTENDED only on 57 bit GPU */
@@ -631,7 +653,8 @@ TEST_F(GfxPartitionOn57bTest, given57bitCpuAddressWidthAndLa57IsPresentWhenIniti
     // Success on first reserve
     resetGfxPartition();
 
-    EXPECT_TRUE(gfxPartition->init(maxNBitValue(gpuAddressSpace), 0, 0, 1, false, 0u));
+    uint64_t gfxTop = maxNBitValue(gpuAddressSpace) + 1;
+    EXPECT_TRUE(gfxPartition->init(maxNBitValue(gpuAddressSpace), 0, 0, 1, false, 0u, gfxTop));
     EXPECT_EQ(0u, mockOsMemory->freeCounter);
     EXPECT_EQ(1u, mockOsMemory->reservationSizes.size());
     EXPECT_EQ(reinterpret_cast<void *>(0x800000000000), mockOsMemory->validReturnAddress);
@@ -645,7 +668,7 @@ TEST_F(GfxPartitionOn57bTest, given57bitCpuAddressWidthAndLa57IsPresentWhenIniti
     mockOsMemory->invalidReturnAddress = nullptr;
     mockOsMemory->returnInvalidAddressFirst = true;
 
-    EXPECT_TRUE(gfxPartition->init(maxNBitValue(gpuAddressSpace), 0, 0, 1, false, 0u));
+    EXPECT_TRUE(gfxPartition->init(maxNBitValue(gpuAddressSpace), 0, 0, 1, false, 0u, gfxTop));
     EXPECT_EQ(2u, mockOsMemory->reservationSizes.size());
     EXPECT_EQ(reservedHighSize, mockOsMemory->reservationSizes[0]);
     EXPECT_EQ(reservedHighSize, mockOsMemory->reservationSizes[1]);
@@ -660,7 +683,7 @@ TEST_F(GfxPartitionOn57bTest, given57bitCpuAddressWidthAndLa57IsPresentWhenIniti
     mockOsMemory->invalidReturnAddress = reinterpret_cast<void *>(maxNBitValue(47) - reservedHighSize + 1);
     mockOsMemory->returnInvalidAddressFirst = true;
 
-    EXPECT_TRUE(gfxPartition->init(maxNBitValue(gpuAddressSpace), 0, 0, 1, false, 0u));
+    EXPECT_TRUE(gfxPartition->init(maxNBitValue(gpuAddressSpace), 0, 0, 1, false, 0u, gfxTop));
     EXPECT_EQ(2u, mockOsMemory->reservationSizes.size());
     EXPECT_EQ(reservedHighSize, mockOsMemory->reservationSizes[0]);
     EXPECT_EQ(reservedHighSize, mockOsMemory->reservationSizes[1]);
@@ -675,7 +698,7 @@ TEST_F(GfxPartitionOn57bTest, given57bitCpuAddressWidthAndLa57IsPresentWhenIniti
     mockOsMemory->invalidReturnAddress = reinterpret_cast<void *>(maxNBitValue(48) - reservedHighSize + 1);
     mockOsMemory->returnInvalidAddressFirst = true;
 
-    EXPECT_TRUE(gfxPartition->init(maxNBitValue(gpuAddressSpace), 0, 0, 1, false, 0u));
+    EXPECT_TRUE(gfxPartition->init(maxNBitValue(gpuAddressSpace), 0, 0, 1, false, 0u, gfxTop));
     EXPECT_EQ(2u, mockOsMemory->reservationSizes.size());
     EXPECT_EQ(reservedHighSize, mockOsMemory->reservationSizes[0]);
     EXPECT_EQ(reservedHighSize, mockOsMemory->reservationSizes[1]);
@@ -690,7 +713,7 @@ TEST_F(GfxPartitionOn57bTest, given57bitCpuAddressWidthAndLa57IsPresentWhenIniti
     mockOsMemory->invalidReturnAddress = reinterpret_cast<void *>(maxNBitValue(48) + 1);
     mockOsMemory->returnInvalidAddressFirst = true;
 
-    EXPECT_TRUE(gfxPartition->init(maxNBitValue(gpuAddressSpace), 0, 0, 1, false, 0u));
+    EXPECT_TRUE(gfxPartition->init(maxNBitValue(gpuAddressSpace), 0, 0, 1, false, 0u, gfxTop));
     EXPECT_EQ(2u, mockOsMemory->reservationSizes.size());
     EXPECT_EQ(reservedHighSize, mockOsMemory->reservationSizes[0]);
     EXPECT_EQ(reservedHighSize, mockOsMemory->reservationSizes[1]);
@@ -705,7 +728,7 @@ TEST_F(GfxPartitionOn57bTest, given57bitCpuAddressWidthAndLa57IsPresentWhenIniti
     mockOsMemory->forceParseMemoryMaps = true;
     mockOsMemory->memoryMaps = {};
 
-    EXPECT_TRUE(gfxPartition->init(maxNBitValue(gpuAddressSpace), 0, 0, 1, false, 0u));
+    EXPECT_TRUE(gfxPartition->init(maxNBitValue(gpuAddressSpace), 0, 0, 1, false, 0u, gfxTop));
     EXPECT_EQ(0u, mockOsMemory->freeCounter);
     EXPECT_EQ(1u, mockOsMemory->reservationSizes.size());
     EXPECT_EQ(MemoryConstants::teraByte, mockOsMemory->reservationSizes[0]);
@@ -719,7 +742,7 @@ TEST_F(GfxPartitionOn57bTest, given57bitCpuAddressWidthAndLa57IsPresentWhenIniti
     mockOsMemory->forceParseMemoryMaps = true;
     mockOsMemory->memoryMaps = {{0x7ffff7ff3000ull, 0x7ffff7ffb000ull}, {0x7ffff7ffc000ull, 0x7ffff7ffd000ull}, {0x7ffff7ffd000ull, 0x7ffff7ffe000ull}, {0x7ffff7ffe000ull, 0x7ffff7fff000ull}, {0x7ffffffde000ull, 0x7ffffffff000ull}};
 
-    EXPECT_TRUE(gfxPartition->init(maxNBitValue(gpuAddressSpace), 0, 0, 1, false, 0u));
+    EXPECT_TRUE(gfxPartition->init(maxNBitValue(gpuAddressSpace), 0, 0, 1, false, 0u, gfxTop));
     EXPECT_EQ(1u, mockOsMemory->reservationSizes.size());
     EXPECT_EQ(reservedHighSize, mockOsMemory->reservationSizes[0]);
     EXPECT_EQ(reinterpret_cast<void *>(0x800000000000), mockOsMemory->validReturnAddress);
@@ -732,7 +755,7 @@ TEST_F(GfxPartitionOn57bTest, given57bitCpuAddressWidthAndLa57IsPresentWhenIniti
     mockOsMemory->forceParseMemoryMaps = true;
     mockOsMemory->memoryMaps = {{0x7ffff7ff3000ull, 0x7ffff7ffb000ull}, {0x7ffff7ffc000ull, 0x7ffff7ffd000ull}, {0x7ffff7ffd000ull, 0x7ffff7ffe000ull}, {0x7ffff7ffe000ull, 0x7ffff7fff000ull}, {0x7ffffffde000ull, 0x7ffffffff000ull}, {0xffffffffff600000ull, 0xffffffffff601000ull}};
 
-    EXPECT_TRUE(gfxPartition->init(maxNBitValue(gpuAddressSpace), 0, 0, 1, false, 0u));
+    EXPECT_TRUE(gfxPartition->init(maxNBitValue(gpuAddressSpace), 0, 0, 1, false, 0u, gfxTop));
     EXPECT_EQ(1u, mockOsMemory->reservationSizes.size());
     EXPECT_EQ(reservedHighSize, mockOsMemory->reservationSizes[0]);
     EXPECT_EQ(reinterpret_cast<void *>(0x800000000000), mockOsMemory->validReturnAddress);
@@ -745,7 +768,7 @@ TEST_F(GfxPartitionOn57bTest, given57bitCpuAddressWidthAndLa57IsPresentWhenIniti
     mockOsMemory->forceParseMemoryMaps = true;
     mockOsMemory->memoryMaps = {{0x7ffff7ff3000ull, 0x7ffff7ffb000ull}, {0x7ffff7ffc000ull, 0x7ffff7ffd000ull}, {0x7ffff7ffd000ull, 0x7ffff7ffe000ull}, {0x7ffff7ffe000ull, 0x7ffff7fff000ull}, {0x7ffffffde000ull, 0x7ffffffff000ull}, {0xffffff600000ull, 0xffffff601000ull}, {0xffffffffff600000ull, 0xffffffffff601000ull}};
 
-    EXPECT_TRUE(gfxPartition->init(maxNBitValue(gpuAddressSpace), 0, 0, 1, false, 0u));
+    EXPECT_TRUE(gfxPartition->init(maxNBitValue(gpuAddressSpace), 0, 0, 1, false, 0u, gfxTop));
     EXPECT_EQ(1u, mockOsMemory->reservationSizes.size());
     EXPECT_EQ(reservedHighSize, mockOsMemory->reservationSizes[0]);
     EXPECT_EQ(reinterpret_cast<void *>(0x800000000000), mockOsMemory->validReturnAddress);
@@ -758,7 +781,7 @@ TEST_F(GfxPartitionOn57bTest, given57bitCpuAddressWidthAndLa57IsPresentWhenIniti
     mockOsMemory->forceParseMemoryMaps = true;
     mockOsMemory->memoryMaps = {{0x7ffff7ff3000ull, 0x7ffff7ffb000ull}, {0x7ffff7ffc000ull, 0x7ffff7ffd000ull}, {0x7ffff7ffd000ull, 0x7ffff7ffe000ull}, {0x7ffff7ffe000ull, 0x7ffff7fff000ull}, {0x80000013e000ull, 0x800000141000ull}, {0x800000141000ull, 0x800000142000ull}, {0x7ffffffde000ull, 0x7ffffffff000ull}, {0xffffff600000ull, 0xffffff601000ull}, {0xffffffffff600000ull, 0xffffffffff601000ull}};
 
-    EXPECT_TRUE(gfxPartition->init(maxNBitValue(gpuAddressSpace), 0, 0, 1, false, 0u));
+    EXPECT_TRUE(gfxPartition->init(maxNBitValue(gpuAddressSpace), 0, 0, 1, false, 0u, gfxTop));
     EXPECT_EQ(1u, mockOsMemory->reservationSizes.size());
     EXPECT_EQ(reservedHighSize, mockOsMemory->reservationSizes[0]);
     EXPECT_EQ(reinterpret_cast<void *>(0x800000142000), mockOsMemory->validReturnAddress);
@@ -772,7 +795,7 @@ TEST_F(GfxPartitionOn57bTest, given57bitCpuAddressWidthAndLa57IsPresentWhenIniti
     mockOsMemory->forceParseMemoryMaps = true;
     mockOsMemory->memoryMaps = {{0x7ffff7ff3000ull, 0x7ffff7ffb000ull}, {0x7ffff7ffc000ull, 0x7ffff7ffd000ull}, {0x7ffff7ffd000ull, 0x7ffff7ffe000ull}, {0x7ffff7ffe000ull, 0x7ffff7fff000ull}, {0x800000000000ull, 0x1000000000000ull}, {0xffffffffff600000ull, 0xffffffffff601000ull}};
 
-    EXPECT_TRUE(gfxPartition->init(maxNBitValue(gpuAddressSpace), 0, 0, 1, false, 0u));
+    EXPECT_TRUE(gfxPartition->init(maxNBitValue(gpuAddressSpace), 0, 0, 1, false, 0u, gfxTop));
     EXPECT_EQ(1u, mockOsMemory->reservationSizes.size());
     EXPECT_EQ(reservedLowSize, mockOsMemory->reservationSizes[0]);
     EXPECT_EQ(reinterpret_cast<void *>(0x10000), mockOsMemory->validReturnAddress);
@@ -789,7 +812,7 @@ TEST_F(GfxPartitionOn57bTest, given57bitCpuAddressWidthAndLa57IsPresentWhenIniti
     mockOsMemory->invalidReturnAddress = nullptr;
     mockOsMemory->returnInvalidAddressFirst = true;
 
-    EXPECT_TRUE(gfxPartition->init(maxNBitValue(gpuAddressSpace), 0, 0, 1, false, 0u));
+    EXPECT_TRUE(gfxPartition->init(maxNBitValue(gpuAddressSpace), 0, 0, 1, false, 0u, gfxTop));
     EXPECT_EQ(2u, mockOsMemory->reservationSizes.size());
     EXPECT_EQ(reservedLowSize, mockOsMemory->reservationSizes[0]);
     EXPECT_EQ(reservedLowSize2, mockOsMemory->reservationSizes[1]);
@@ -806,7 +829,7 @@ TEST_F(GfxPartitionOn57bTest, given57bitCpuAddressWidthAndLa57IsPresentWhenIniti
     mockOsMemory->invalidReturnAddress = nullptr;
     mockOsMemory->returnInvalidAddressAlways = true;
 
-    EXPECT_FALSE(gfxPartition->init(maxNBitValue(gpuAddressSpace), 0, 0, 1, false, 0u));
+    EXPECT_FALSE(gfxPartition->init(maxNBitValue(gpuAddressSpace), 0, 0, 1, false, 0u, gfxTop));
 }
 
 TEST_F(GfxPartitionOn57bTest, given48bitGpuAddressSpaceAnd57bitCpuAddressWidthWhenInitializingMultipleGfxPartitionsThenReserveSpaceForSvmHeapOnlyOnce) {
@@ -818,13 +841,14 @@ TEST_F(GfxPartitionOn57bTest, given48bitGpuAddressSpaceAnd57bitCpuAddressWidthWh
 
     // 57 bit CPU VA, la57 is present - reserve high or low CPU address range depending of memory maps
     CpuInfoOverrideVirtualAddressSizeAndFlags overrideCpuInfo(57, "la57");
+    uint64_t gfxTop = maxNBitValue(gpuAddressSpace) + 1;
 
     OSMemory::ReservedCpuAddressRange reservedCpuAddressRange;
     std::vector<std::unique_ptr<MockGfxPartition>> gfxPartitions;
     for (int i = 0; i < 10; ++i) {
         gfxPartitions.push_back(std::make_unique<MockGfxPartition>(reservedCpuAddressRange));
         gfxPartitions[i]->osMemory.reset(new MockOsMemory);
-        EXPECT_TRUE(gfxPartitions[i]->init(maxNBitValue(gpuAddressSpace), 0, i, 10, false, 0u));
+        EXPECT_TRUE(gfxPartitions[i]->init(maxNBitValue(gpuAddressSpace), 0, i, 10, false, 0u, gfxTop));
     }
 
     EXPECT_EQ(1u, static_cast<MockOsMemory *>(gfxPartitions[0]->osMemory.get())->getReserveCount());
@@ -840,12 +864,13 @@ TEST_F(GfxPartitionOn57bTest, given57bitGpuAddressSpaceAnd57bitCpuAddressWidthWh
     // 57 bit CPU VA, la57 is present - reserve high or low CPU address range depending of memory maps
     CpuInfoOverrideVirtualAddressSizeAndFlags overrideCpuInfo(57, "la57");
 
+    uint64_t gfxTop = maxNBitValue(gpuAddressSpace) + 1;
     OSMemory::ReservedCpuAddressRange reservedCpuAddressRange;
     std::vector<std::unique_ptr<MockGfxPartition>> gfxPartitions;
     for (int i = 0; i < 10; ++i) {
         gfxPartitions.push_back(std::make_unique<MockGfxPartition>(reservedCpuAddressRange));
         gfxPartitions[i]->osMemory.reset(new MockOsMemory);
-        EXPECT_TRUE(gfxPartitions[i]->init(maxNBitValue(gpuAddressSpace), 0, i, 10, false, 0u));
+        EXPECT_TRUE(gfxPartitions[i]->init(maxNBitValue(gpuAddressSpace), 0, i, 10, false, 0u, gfxTop));
     }
 
     EXPECT_EQ(11u, static_cast<MockOsMemory *>(gfxPartitions[0]->osMemory.get())->getReserveCount());
@@ -859,6 +884,7 @@ TEST(GfxPartitionTest, givenGpuAddressSpaceIs57BitAndSeveralRootDevicesThenHeapE
     uint32_t rootDeviceIndex = 3;
     size_t numRootDevices = 5;
 
+    uint64_t gfxTop = maxNBitValue(57) + 1;
     {
         // 57 bit CPU VA, la57 flag is present
         CpuInfoOverrideVirtualAddressSizeAndFlags overrideCpuInfo(57, "la57");
@@ -866,7 +892,7 @@ TEST(GfxPartitionTest, givenGpuAddressSpaceIs57BitAndSeveralRootDevicesThenHeapE
 
         MockGfxPartition gfxPartition;
         auto systemMemorySize = MemoryConstants::teraByte;
-        EXPECT_TRUE(gfxPartition.init(maxNBitValue(57), reservedCpuAddressRangeSize, rootDeviceIndex, numRootDevices, false, systemMemorySize));
+        EXPECT_TRUE(gfxPartition.init(maxNBitValue(57), reservedCpuAddressRangeSize, rootDeviceIndex, numRootDevices, false, systemMemorySize, gfxTop));
 
         auto heapExtendedSize = 4 * systemMemorySize;
 
@@ -879,7 +905,7 @@ TEST(GfxPartitionTest, givenGpuAddressSpaceIs57BitAndSeveralRootDevicesThenHeapE
         CpuInfoOverrideVirtualAddressSizeAndFlags overrideCpuInfo(57);
 
         MockGfxPartition gfxPartition;
-        EXPECT_TRUE(gfxPartition.init(maxNBitValue(57), reservedCpuAddressRangeSize, rootDeviceIndex, numRootDevices, false, 0u));
+        EXPECT_TRUE(gfxPartition.init(maxNBitValue(57), reservedCpuAddressRangeSize, rootDeviceIndex, numRootDevices, false, 0u, gfxTop));
 
         auto heapExtendedTotalSize = maxNBitValue(48) + 1;
         auto heapExtendedSize = alignDown(heapExtendedTotalSize / numRootDevices, GfxPartition::heapGranularity);
@@ -893,7 +919,7 @@ TEST(GfxPartitionTest, givenGpuAddressSpaceIs57BitAndSeveralRootDevicesThenHeapE
         CpuInfoOverrideVirtualAddressSizeAndFlags overrideCpuInfo(48);
 
         MockGfxPartition gfxPartition;
-        EXPECT_TRUE(gfxPartition.init(maxNBitValue(57), reservedCpuAddressRangeSize, rootDeviceIndex, numRootDevices, false, 0u));
+        EXPECT_TRUE(gfxPartition.init(maxNBitValue(57), reservedCpuAddressRangeSize, rootDeviceIndex, numRootDevices, false, 0u, gfxTop));
 
         auto heapExtendedTotalSize = maxNBitValue(48) + 1;
         auto heapExtendedSize = alignDown(heapExtendedTotalSize / numRootDevices, GfxPartition::heapGranularity);
@@ -929,4 +955,4 @@ TEST(GfxPartitionTest, givenHeapIndexWhenCheckingIsAnyHeap32ThenTrueIsReturnedFo
     for (size_t i = 0; i < sizeof(heapsOther) / sizeof(heapsOther[0]); i++) {
         EXPECT_FALSE(GfxPartition::isAnyHeap32(heapsOther[i]));
     }
-}
\ No newline at end of file
+}
diff --git a/shared/test/unit_test/os_interface/linux/drm_memory_manager_localmem_prelim_tests.cpp b/shared/test/unit_test/os_interface/linux/drm_memory_manager_localmem_prelim_tests.cpp
index b11d2fe2e1..c52117090a 100644
--- a/shared/test/unit_test/os_interface/linux/drm_memory_manager_localmem_prelim_tests.cpp
+++ b/shared/test/unit_test/os_interface/linux/drm_memory_manager_localmem_prelim_tests.cpp
@@ -2147,7 +2147,7 @@ TEST_F(DrmMemoryManagerFailInjectionPrelimTest, givenEnabledLocalMemoryWhenNewFa
     class MockGfxPartition : public GfxPartition {
       public:
         MockGfxPartition() : GfxPartition(reservedCpuAddressRange) {
-            init(defaultHwInfo->capabilityTable.gpuAddressSpace, getSizeToReserve(), 0, 1, false, 0u);
+            init(defaultHwInfo->capabilityTable.gpuAddressSpace, getSizeToReserve(), 0, 1, false, 0u, defaultHwInfo->capabilityTable.gpuAddressSpace + 1);
         }
         ~MockGfxPartition() override {
             for (const auto &heap : heaps) {
diff --git a/shared/test/unit_test/os_interface/linux/drm_memory_manager_localmem_upstream_tests.cpp b/shared/test/unit_test/os_interface/linux/drm_memory_manager_localmem_upstream_tests.cpp
index c215d77f80..d176bee536 100644
--- a/shared/test/unit_test/os_interface/linux/drm_memory_manager_localmem_upstream_tests.cpp
+++ b/shared/test/unit_test/os_interface/linux/drm_memory_manager_localmem_upstream_tests.cpp
@@ -663,7 +663,7 @@ HWTEST2_F(DrmMemoryManagerFailInjectionTest, givenEnabledLocalMemoryWhenNewFails
     class MockGfxPartition : public GfxPartition {
       public:
         MockGfxPartition() : GfxPartition(reservedCpuAddressRange) {
-            init(defaultHwInfo->capabilityTable.gpuAddressSpace, getSizeToReserve(), 0, 1, false, 0u);
+            init(defaultHwInfo->capabilityTable.gpuAddressSpace, getSizeToReserve(), 0, 1, false, 0u, defaultHwInfo->capabilityTable.gpuAddressSpace + 1);
         }
         ~MockGfxPartition() override {
             for (const auto &heap : heaps) {
diff --git a/shared/test/unit_test/os_interface/linux/drm_memory_manager_tests.cpp b/shared/test/unit_test/os_interface/linux/drm_memory_manager_tests.cpp
index f2f54393ad..006a0a7abf 100644
--- a/shared/test/unit_test/os_interface/linux/drm_memory_manager_tests.cpp
+++ b/shared/test/unit_test/os_interface/linux/drm_memory_manager_tests.cpp
@@ -3854,7 +3854,7 @@ TEST_F(DrmMemoryManagerTest, givenDrmMemoryManagerAndReleaseGpuRangeIsCalledThen
     constexpr size_t reservedCpuAddressRangeSize = is64bit ? (6 * 4 * MemoryConstants::gigaByte) : 0;
     auto hwInfo = defaultHwInfo.get();
     auto mockGfxPartition = std::make_unique<MockGfxPartition>();
-    mockGfxPartition->init(hwInfo->capabilityTable.gpuAddressSpace, reservedCpuAddressRangeSize, 0, 1, false, 0u);
+    mockGfxPartition->init(hwInfo->capabilityTable.gpuAddressSpace, reservedCpuAddressRangeSize, 0, 1, false, 0u, hwInfo->capabilityTable.gpuAddressSpace + 1);
     auto size = 2 * MemoryConstants::megaByte;
     auto gpuAddress = mockGfxPartition->heapAllocate(HeapIndex::heapStandard, size);
     auto gmmHelper = device->getGmmHelper();
@@ -5193,7 +5193,7 @@ TEST(DrmMemoryManagerSimpleTest, givenDrmMemoryManagerWhenDeviceHeapIsDepletedTh
     executionEnvironment.rootDeviceEnvironments[0]->memoryOperationsInterface = DrmMemoryOperationsHandler::create(*drm, 0u, false);
 
     auto mockGfxPartition = std::make_unique<MockGfxPartition>();
-    mockGfxPartition->init(hwInfo->capabilityTable.gpuAddressSpace, reservedCpuAddressRangeSize, 0, 1, false, 0u);
+    mockGfxPartition->init(hwInfo->capabilityTable.gpuAddressSpace, reservedCpuAddressRangeSize, 0, 1, false, 0u, hwInfo->capabilityTable.gpuAddressSpace + 1);
 
     auto status = MemoryManager::AllocationStatus::Success;
     AllocationData allocData;
diff --git a/shared/test/unit_test/os_interface/linux/drm_special_heap_test.cpp b/shared/test/unit_test/os_interface/linux/drm_special_heap_test.cpp
index 70cd11208b..cc0c3451c8 100644
--- a/shared/test/unit_test/os_interface/linux/drm_special_heap_test.cpp
+++ b/shared/test/unit_test/os_interface/linux/drm_special_heap_test.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2020-2023 Intel Corporation
+ * Copyright (C) 2020-2024 Intel Corporation
  *
  * SPDX-License-Identifier: MIT
  *
@@ -21,7 +21,7 @@ class DrmMemManagerFixture {
     struct FrontWindowMemManagerMock : public TestedDrmMemoryManager {
         using MemoryManager::allocate32BitGraphicsMemoryImpl;
         FrontWindowMemManagerMock(NEO::ExecutionEnvironment &executionEnvironment) : TestedDrmMemoryManager(executionEnvironment) {}
-        void forceLimitedRangeAllocator(uint32_t rootDeviceIndex, uint64_t range) { getGfxPartition(rootDeviceIndex)->init(range, 0, 0, gfxPartitions.size(), true, 0u); }
+        void forceLimitedRangeAllocator(uint32_t rootDeviceIndex, uint64_t range) { getGfxPartition(rootDeviceIndex)->init(range, 0, 0, gfxPartitions.size(), true, 0u, range + 1); }
     };
 
     void setUp() {
diff --git a/shared/test/unit_test/os_interface/linux/drm_tests.cpp b/shared/test/unit_test/os_interface/linux/drm_tests.cpp
index 024ed89683..256b9201b1 100644
--- a/shared/test/unit_test/os_interface/linux/drm_tests.cpp
+++ b/shared/test/unit_test/os_interface/linux/drm_tests.cpp
@@ -309,12 +309,45 @@ TEST(DrmTest, GivenDrmWhenAskedForGttSizeThenReturnCorrectValue) {
 
     drm->storedRetValForGetGttSize = 0;
     drm->storedGTTSize = 1ull << 31;
-    EXPECT_EQ(0, drm->Drm::queryGttSize(queryGttSize));
+    EXPECT_EQ(0, drm->Drm::queryGttSize(queryGttSize, true));
+    EXPECT_EQ(drm->storedGTTSize, queryGttSize);
+
+    queryGttSize = 0;
+    drm->storedRetValForGetGttSize = 0;
+    drm->storedGTTSize = 1ull << 47;
+    EXPECT_EQ(0, drm->Drm::queryGttSize(queryGttSize, true));
+    EXPECT_EQ(drm->storedGTTSize, queryGttSize);
+    queryGttSize = 0;
+    drm->storedRetValForGetGttSize = 0;
+    drm->storedGTTSize = 1ull << 47;
+    EXPECT_EQ(0, drm->Drm::queryGttSize(queryGttSize, false));
+    EXPECT_EQ(drm->storedGTTSize, queryGttSize);
+
+    queryGttSize = 0;
+    drm->storedRetValForGetGttSize = 0;
+    drm->storedGTTSize = (1ull << 48) - 1;
+    EXPECT_EQ(0, drm->Drm::queryGttSize(queryGttSize, true));
+    EXPECT_EQ(1ull << 48, queryGttSize);
+    queryGttSize = 0;
+    drm->storedRetValForGetGttSize = 0;
+    drm->storedGTTSize = (1ull << 48) - 1;
+    EXPECT_EQ(0, drm->Drm::queryGttSize(queryGttSize, false));
+    EXPECT_EQ(drm->storedGTTSize, queryGttSize);
+
+    queryGttSize = 0;
+    drm->storedRetValForGetGttSize = 0;
+    drm->storedGTTSize = (1ull << 47) + 1;
+    EXPECT_EQ(0, drm->Drm::queryGttSize(queryGttSize, true));
+    EXPECT_EQ(1ull << 48, queryGttSize);
+    queryGttSize = 0;
+    drm->storedRetValForGetGttSize = 0;
+    drm->storedGTTSize = (1ull << 47) + 1;
+    EXPECT_EQ(0, drm->Drm::queryGttSize(queryGttSize, false));
     EXPECT_EQ(drm->storedGTTSize, queryGttSize);
 
     queryGttSize = 0;
     drm->storedRetValForGetGttSize = -1;
-    EXPECT_NE(0, drm->Drm::queryGttSize(queryGttSize));
+    EXPECT_NE(0, drm->Drm::queryGttSize(queryGttSize, true));
     EXPECT_EQ(0u, queryGttSize);
 }
 
-- 
2.44.0

