diff -up uhd_3.9.7-release/examples/network_relay.cpp.boost166 uhd_3.9.7-release/examples/network_relay.cpp
--- uhd_3.9.7-release/examples/network_relay.cpp.boost166	2017-12-28 18:48:58.000000000 +0100
+++ uhd_3.9.7-release/examples/network_relay.cpp	2017-12-28 18:49:55.000000000 +0100
@@ -127,7 +127,7 @@ private:
         wait_for_thread.notify_one();    // notify constructor that this thread has started
         std::vector<char> buff(insane_mtu);
         while (not boost::this_thread::interruption_requested()){
-            if (wait_for_recv_ready(_server_socket->native())){
+            if (wait_for_recv_ready(_server_socket->native_handle())){
                 boost::mutex::scoped_lock lock(_endpoint_mutex);
                 const size_t len = _server_socket->receive_from(asio::buffer(&buff.front(), buff.size()), _endpoint);
                 lock.unlock();
@@ -153,7 +153,7 @@ private:
         wait_for_thread.notify_one();    // notify constructor that this thread has started
         std::vector<char> buff(insane_mtu);
         while (not boost::this_thread::interruption_requested()){
-            if (wait_for_recv_ready(_client_socket->native())){
+            if (wait_for_recv_ready(_client_socket->native_handle())){
                 const size_t len = _client_socket->receive(asio::buffer(&buff.front(), buff.size()));
                 boost::mutex::scoped_lock lock(_endpoint_mutex);
                 _server_socket->send_to(asio::buffer(&buff.front(), len), _endpoint);
diff -up uhd_3.9.7-release/lib/transport/tcp_zero_copy.cpp.boost166 uhd_3.9.7-release/lib/transport/tcp_zero_copy.cpp
--- uhd_3.9.7-release/lib/transport/tcp_zero_copy.cpp.boost166	2017-12-28 18:54:11.000000000 +0100
+++ uhd_3.9.7-release/lib/transport/tcp_zero_copy.cpp	2017-12-28 18:54:30.000000000 +0100
@@ -154,7 +154,7 @@ public:
         //create, open, and connect the socket
         _socket.reset(new asio::ip::tcp::socket(_io_service));
         _socket->connect(receiver_endpoint);
-        _sock_fd = _socket->native();
+        _sock_fd = _socket->native_handle();
 
         //packets go out ASAP
         asio::ip::tcp::no_delay option(true);
diff -up uhd_3.9.7-release/lib/transport/udp_simple.cpp.boost166 uhd_3.9.7-release/lib/transport/udp_simple.cpp
--- uhd_3.9.7-release/lib/transport/udp_simple.cpp.boost166	2017-12-28 19:24:30.000000000 +0100
+++ uhd_3.9.7-release/lib/transport/udp_simple.cpp	2017-12-28 19:24:42.000000000 +0100
@@ -56,7 +56,7 @@ public:
     }
 
     size_t recv(const asio::mutable_buffer &buff, double timeout){
-        if (not wait_for_recv_ready(_socket->native(), timeout)) return 0;
+        if (not wait_for_recv_ready(_socket->native_handle(), timeout)) return 0;
         return _socket->receive_from(asio::buffer(buff), _recv_endpoint);
     }
 
diff -up uhd_3.9.7-release/lib/transport/udp_zero_copy.cpp.boost166 uhd_3.9.7-release/lib/transport/udp_zero_copy.cpp
--- uhd_3.9.7-release/lib/transport/udp_zero_copy.cpp.boost166	2017-12-28 18:50:43.000000000 +0100
+++ uhd_3.9.7-release/lib/transport/udp_zero_copy.cpp	2017-12-28 18:51:09.000000000 +0100
@@ -190,7 +190,7 @@ public:
         _socket = socket_sptr(new asio::ip::udp::socket(_io_service));
         _socket->open(asio::ip::udp::v4());
         _socket->connect(receiver_endpoint);
-        _sock_fd = _socket->native();
+        _sock_fd = _socket->native_handle();
 
         //allocate re-usable managed receive buffers
         for (size_t i = 0; i < get_num_recv_frames(); i++){
