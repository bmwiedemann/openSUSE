gdb: improved EOF handling when using readline 7

In this commit:

  commit a6b413d24ccc5d76179bab866834e11fd6fec294
  Date:   Fri Mar 11 14:44:03 2022 +0000

      gdb: work around prompt corruption caused by bracketed-paste-mode

a change was made to GDB to work around bug PR gdb/28833.  The
consequence of this work around is that, when bracketed paste mode is
enabled in readline, and GDB is quit by sending EOF, then the output
will look like this:

  (gdb)
  quit

The ideal output, which is what we get when bracketed paste mode is
off, is this:

  (gdb) quit

The reason we need to make this change is explained in the original
commit referenced above.  What isn't mentioned in the above commit, is
that the change that motivated this work around was only added in
readline 8, older versions of readline don't require the change.

In later commits in this series I will add a fix to GDB's in-tree copy
of readline (this fix is back-ported from upstream readline), and then
I will change GDB so that, when using the (patched) in-tree readline,
we can have the ideal output in all cases.

However, GDB can be built against the system readline.  When this is
done, and the system readline is version 8, then we will still have to
use the work around (two line) style output.

But, if GDB is built against the system readline, and the system
readline is an older version 7 readline, then there's no reason why we
can't have the ideal output, after all, readline 7 doesn't include the
change that we need to work around.

This commit changes GDB so that, when using readline 7 we get the
ideal output in all cases.  This change is trivial (a simple check
against the readline version number) so I think this should be fine to
include.

For testing this commit, you need to configure GDB including the
'--with-system-readline' flag, and build GDB on a system that uses
readline 7, for example 'Ubuntu 18.04'.  Then run the test
'gdb.base/eof-exit.exp', you should expect everything to PASS.

Bug: https://sourceware.org/bugzilla/show_bug.cgi?id=28833

---
 gdb/event-top.c                     | 3 ++-
 gdb/testsuite/gdb.base/eof-exit.exp | 2 +-
 2 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/gdb/event-top.c b/gdb/event-top.c
index c1a95a4b748..7ddb3e8aee6 100644
--- a/gdb/event-top.c
+++ b/gdb/event-top.c
@@ -783,7 +783,8 @@ command_line_handler (gdb::unique_xmalloc_ptr<char> &&rl)
 	 we first print '\n' to move to the next line, and then print the
 	 quit.  This isn't ideal, but avoids corrupting the prompt.  */
       const char *value = rl_variable_value ("enable-bracketed-paste");
-      if (value != nullptr && strcmp (value, "on") == 0)
+      if (value != nullptr && strcmp (value, "on") == 0
+	  && ((rl_readline_version >> 8) & 0xff) > 0x07)
 	printf_unfiltered ("\n");
       printf_unfiltered ("quit\n");
       execute_command ("quit", 1);
diff --git a/gdb/testsuite/gdb.base/eof-exit.exp b/gdb/testsuite/gdb.base/eof-exit.exp
index c88aced9f35..e04c38bf8d7 100644
--- a/gdb/testsuite/gdb.base/eof-exit.exp
+++ b/gdb/testsuite/gdb.base/eof-exit.exp
@@ -67,7 +67,7 @@ proc run_test {} {
 	    # line after the 'quit', this catches that case.
 	    fail $gdb_test_name
 	}
-	-re "$::gdb_prompt quit\[^\n\]*\r\n\[^\n\]*$" {
+       -re "$::gdb_prompt \[^\n\r\]*quit\[^\n\]*\r\n\[^\n\]*$" {
 	    pass $gdb_test_name
 	}
 	eof {
