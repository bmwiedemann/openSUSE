--- ntpd/ntpd.c.orig
+++ ntpd/ntpd.c
@@ -913,16 +913,17 @@ ntpdmain(
 	/* make sure the FDs are initialised */
 	pipe_fds[0] = -1;
 	pipe_fds[1] = -1;
-	do {					/* 'loop' once */
-		if (!HAVE_OPT( WAIT_SYNC ))
-			break;
+	if (HAVE_OPT( WAIT_SYNC )) {
 		wait_sync = OPT_VALUE_WAIT_SYNC;
-		if (wait_sync <= 0) {
-			wait_sync = 0;
-			break;
-		}
+	}
+       	if (wait_sync <= 0) {
+		wait_sync = 0;
+	}
+	if (wait_sync > 0) {
 		/* -w requires a fork() even with debug > 0 */
 		nofork = FALSE;
+	}
+	if (!nofork) {
 		if (pipe(pipe_fds)) {
 			exit_code = (errno) ? errno : -1;
 			msyslog(LOG_ERR,
@@ -930,7 +931,7 @@ ntpdmain(
 			exit(exit_code);
 		}
 		waitsync_fd_to_close = pipe_fds[1];
-	} while (0);				/* 'loop' once */
+	}
 # endif	/* HAVE_WORKING_FORK */
 
 	init_lib();
@@ -1351,6 +1352,20 @@ int scmp_sc[] = {
 	ntservice_isup();
 #endif
 
+#ifdef HAVE_WORKING_FORK
+	if (!nofork && wait_sync == 0 && waitsync_fd_to_close != -1) {
+		/*
+		 * Initialisation of the daemon is complete and the
+		 * user does not want to wait for synchronisation, so
+		 * tell the forground process to exit successfully.
+		 */
+		char ret = 0;
+		write(waitsync_fd_to_close, &ret, 1);
+		close(waitsync_fd_to_close);
+		waitsync_fd_to_close = -1;
+	}
+#endif
+
 # ifdef HAVE_IO_COMPLETION_PORT
 
 	for (;;) {
@@ -1547,11 +1562,17 @@ wait_child_sync_if(
 	fd_set	readset;
 	struct timeval wtimeout;
 
-	if (0 == wait_sync) 
-		return 0;
-
 	/* waitsync_fd_to_close used solely by child */
 	close(waitsync_fd_to_close);
+
+	if (0 == wait_sync) {
+		/* Wait for the daemon to finish initialisation and
+		   exit with success or failure accordingly */
+		char ret = 1;
+		(void) read(pipe_read_fd, &ret, 1);
+		return ret;
+	}
+
 	wait_end_time = time(NULL) + wait_sync;
 	do {
 		cur_time = time(NULL);
