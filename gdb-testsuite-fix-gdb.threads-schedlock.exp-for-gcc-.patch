From f168a48adf97a36c88c65a075b42e6b7083063df Mon Sep 17 00:00:00 2001
From: Tom de Vries <tdevries@suse.de>
Date: Mon, 20 Feb 2023 11:16:02 +0100
Subject: [PATCH] [gdb/testsuite] Fix gdb.threads/schedlock.exp for gcc 4.8.5

Since commit 9af467b8240 ("[gdb/testsuite] Fix gdb.threads/schedlock.exp on
fast cpu"), the test-case fails for gcc 4.8.5.

The problem is that for gcc 4.8.5, the commit turned a two-line loop:
...
(gdb) next
78          while (*myp > 0)
(gdb) next
81              MAYBE_CALL_SOME_FUNCTION(); (*myp) ++;
(gdb) next
78          while (*myp > 0)
...
into a three-line loop:
...
(gdb) next
83              MAYBE_CALL_SOME_FUNCTION(); (*myp) ++;
(gdb) next
84              cnt++;
(gdb) next
85            }
(gdb) next
83              MAYBE_CALL_SOME_FUNCTION(); (*myp) ++;
(gdb)
...
and the test-case doesn't expect this.

Fix this by reverting back to the original loop shape as much as possible by:
- removing the cnt++ line
- replacing "while (1)" with "while (one)", where one is a volatile variable
  set to 1.

Tested on x86_64-linux, using compilers:
- gcc 4.8.5, 7.5.0, 12.2.1
- clang 4.0.1, 13.0.1
---
 gdb/testsuite/gdb.threads/schedlock.c | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/gdb/testsuite/gdb.threads/schedlock.c b/gdb/testsuite/gdb.threads/schedlock.c
index 9859885b1a3..af3ca3e4c87 100644
--- a/gdb/testsuite/gdb.threads/schedlock.c
+++ b/gdb/testsuite/gdb.threads/schedlock.c
@@ -75,13 +75,12 @@ volatile int call_function = 0;
 void *thread_function(void *arg) {
     int my_number =  (long) arg;
     unsigned long long int *myp = (unsigned long long int *) &args[my_number];
-    volatile unsigned int cnt = 0;
+    volatile unsigned int one = 1;
 
-    while (1)
+    while (one)
       {
 	/* schedlock.exp: main loop.  */
 	MAYBE_CALL_SOME_FUNCTION(); (*myp) ++;
-	cnt++;
       }
 
     pthread_exit(NULL);

base-commit: 4d69e6ec1a8ddd008f34af363dab73c014823074
-- 
2.35.3

