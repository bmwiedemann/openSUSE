From: Egbert Eich <eich@suse.com>
Date: Mon May 13 20:51:42 2019 +0200
Subject: Support multi-line bootdef settings
Patch-mainline: Not yet
Git-commit: d1b5a61230552bddce91e72c4061b5ab429f7d91
References: 

If lines are separated by a '\' in a bootdef setting definition
concatenate them. If the characters before the trailing '\' are
'\n', replace by a newline.

Signed-off-by: Egbert Eich <eich@suse.com>
---
 .../singularity/pkg/build/types/parser/deffile.go  | 28 ++++++++++++++++++----
 1 file changed, 23 insertions(+), 5 deletions(-)
diff --git a/src/github.com/sylabs/singularity/pkg/build/types/parser/deffile.go b/src/github.com/sylabs/singularity/pkg/build/types/parser/deffile.go
index b79c7a1..b490831 100644
--- a/src/github.com/sylabs/singularity/pkg/build/types/parser/deffile.go
+++ b/src/github.com/sylabs/singularity/pkg/build/types/parser/deffile.go
@@ -334,22 +334,40 @@ func doHeader(h string, d *types.Definition) (err error) {
 	h = strings.TrimSpace(h)
 	toks := strings.Split(h, "\n")
 	header := make(map[string]string)
+	cont_key, cont_val := "", ""
 
 	for _, line := range toks {
 		// skip empty or comment lines
 		if line = strings.TrimSpace(line); line == "" || strings.Index(line, "#") == 0 {
+			if len(cont_key) > 0 {
+				d.Header[cont_key] = cont_val
+				cont_key, cont_val = "", "";
+			}
 			continue
 		}
 
 		// trim any comments on header lines
 		trimLine := strings.Split(line, "#")[0]
+		if len(cont_val) == 0 {
+			linetoks := strings.SplitN(trimLine, ":", 2)
+			if len(linetoks) == 1 {
+				return fmt.Errorf("header key %s had no val", linetoks[0])
+			}
 
-		linetoks := strings.SplitN(trimLine, ":", 2)
-		if len(linetoks) == 1 {
-			return fmt.Errorf("header key %s had no val", linetoks[0])
+			key, val := strings.ToLower(strings.TrimSpace(linetoks[0])), strings.TrimSpace(linetoks[1])
+		} else {
+		        key, val := cont_key, cont_val + strings.TrimSpace(trimLine)
+			cont_key, cont_val = "", ""
+		}
+		// continuation
+		if strings.HasSuffix(val, "\\") {
+			cont_key = key
+			cont_val = strings.TrimSuffix(val, "\\")
+			if strings.HasSuffix(cont_val, "\\n") {
+				cont_val = strings.TrimSuffix(cont_val, "\\n") + "\n";
+			}
+			continue
 		}
-
-		key, val := strings.ToLower(strings.TrimSpace(linetoks[0])), strings.TrimSpace(linetoks[1])
 		if _, ok := validHeaders[key]; !ok {
 			return fmt.Errorf("invalid header keyword found: %s", key)
 		}
