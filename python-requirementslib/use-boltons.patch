--- requirementslib-1.4.2-orig/src/requirementslib/utils.py	2019-03-05 00:47:47.000000000 +0700
+++ requirementslib-1.4.2/src/requirementslib/utils.py	2019-03-09 15:51:46.185636626 +0700
@@ -382,84 +382,7 @@
 #   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 #   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-
-class PathAccessError(KeyError, IndexError, TypeError):
-    """An amalgamation of KeyError, IndexError, and TypeError,
-    representing what can occur when looking up a path in a nested
-    object.
-    """
-
-    def __init__(self, exc, seg, path):
-        self.exc = exc
-        self.seg = seg
-        self.path = path
-
-    def __repr__(self):
-        cn = self.__class__.__name__
-        return "%s(%r, %r, %r)" % (cn, self.exc, self.seg, self.path)
-
-    def __str__(self):
-        return "could not access %r from path %r, got error: %r" % (
-            self.seg,
-            self.path,
-            self.exc,
-        )
-
-
-def get_path(root, path, default=_UNSET):
-    """Retrieve a value from a nested object via a tuple representing the
-    lookup path.
-    >>> root = {'a': {'b': {'c': [[1], [2], [3]]}}}
-    >>> get_path(root, ('a', 'b', 'c', 2, 0))
-    3
-    The path format is intentionally consistent with that of
-    :func:`remap`.
-    One of get_path's chief aims is improved error messaging. EAFP is
-    great, but the error messages are not.
-    For instance, ``root['a']['b']['c'][2][1]`` gives back
-    ``IndexError: list index out of range``
-    What went out of range where? get_path currently raises
-    ``PathAccessError: could not access 2 from path ('a', 'b', 'c', 2,
-    1), got error: IndexError('list index out of range',)``, a
-    subclass of IndexError and KeyError.
-    You can also pass a default that covers the entire operation,
-    should the lookup fail at any level.
-    Args:
-       root: The target nesting of dictionaries, lists, or other
-          objects supporting ``__getitem__``.
-       path (tuple): A list of strings and integers to be successively
-          looked up within *root*.
-       default: The value to be returned should any
-          ``PathAccessError`` exceptions be raised.
-    """
-    if isinstance(path, six.string_types):
-        path = path.split(".")
-    cur = root
-    try:
-        for seg in path:
-            try:
-                cur = cur[seg]
-            except (KeyError, IndexError) as exc:
-                raise PathAccessError(exc, seg, path)
-            except TypeError as exc:
-                # either string index in a list, or a parent that
-                # doesn't support indexing
-                try:
-                    seg = int(seg)
-                    cur = cur[seg]
-                except (ValueError, KeyError, IndexError, TypeError):
-                    if not getattr(cur, "__iter__", None):
-                        exc = TypeError("%r object is not indexable" % type(cur).__name__)
-                    raise PathAccessError(exc, seg, path)
-    except PathAccessError:
-        if default is _UNSET:
-            raise
-        return default
-    return cur
-
-
-def default_visit(path, key, value):
-    return key, value
+from boltons.iterutils import PathAccessError, get_path, default_visit, remap
 
 
 _orig_default_visit = default_visit
@@ -471,6 +394,7 @@
         return value, False
     elif isinstance(value, (Mapping, dict)):
         return value.__class__(), ItemsView(value)
+    # Handle toml containers specifically
     elif isinstance(value, tomlkit.items.Array):
         return value.__class__([], value.trivia), enumerate(value)
     elif isinstance(value, (Sequence, list)):
@@ -517,160 +441,7 @@
     return ret
 
 
-def remap(
-    root, visit=default_visit, enter=dict_path_enter, exit=dict_path_exit, **kwargs
-):
-    """The remap ("recursive map") function is used to traverse and
-    transform nested structures. Lists, tuples, sets, and dictionaries
-    are just a few of the data structures nested into heterogenous
-    tree-like structures that are so common in programming.
-    Unfortunately, Python's built-in ways to manipulate collections
-    are almost all flat. List comprehensions may be fast and succinct,
-    but they do not recurse, making it tedious to apply quick changes
-    or complex transforms to real-world data.
-    remap goes where list comprehensions cannot.
-    Here's an example of removing all Nones from some data:
-    >>> from pprint import pprint
-    >>> reviews = {'Star Trek': {'TNG': 10, 'DS9': 8.5, 'ENT': None},
-    ...            'Babylon 5': 6, 'Dr. Who': None}
-    >>> pprint(remap(reviews, lambda p, k, v: v is not None))
-    {'Babylon 5': 6, 'Star Trek': {'DS9': 8.5, 'TNG': 10}}
-    Notice how both Nones have been removed despite the nesting in the
-    dictionary. Not bad for a one-liner, and that's just the beginning.
-    See `this remap cookbook`_ for more delicious recipes.
-    .. _this remap cookbook: http://sedimental.org/remap.html
-    remap takes four main arguments: the object to traverse and three
-    optional callables which determine how the remapped object will be
-    created.
-    Args:
-        root: The target object to traverse. By default, remap
-            supports iterables like :class:`list`, :class:`tuple`,
-            :class:`dict`, and :class:`set`, but any object traversable by
-            *enter* will work.
-        visit (callable): This function is called on every item in
-            *root*. It must accept three positional arguments, *path*,
-            *key*, and *value*. *path* is simply a tuple of parents'
-            keys. *visit* should return the new key-value pair. It may
-            also return ``True`` as shorthand to keep the old item
-            unmodified, or ``False`` to drop the item from the new
-            structure. *visit* is called after *enter*, on the new parent.
-            The *visit* function is called for every item in root,
-            including duplicate items. For traversable values, it is
-            called on the new parent object, after all its children
-            have been visited. The default visit behavior simply
-            returns the key-value pair unmodified.
-        enter (callable): This function controls which items in *root*
-            are traversed. It accepts the same arguments as *visit*: the
-            path, the key, and the value of the current item. It returns a
-            pair of the blank new parent, and an iterator over the items
-            which should be visited. If ``False`` is returned instead of
-            an iterator, the value will not be traversed.
-            The *enter* function is only called once per unique value. The
-            default enter behavior support mappings, sequences, and
-            sets. Strings and all other iterables will not be traversed.
-        exit (callable): This function determines how to handle items
-            once they have been visited. It gets the same three
-            arguments as the other functions -- *path*, *key*, *value*
-            -- plus two more: the blank new parent object returned
-            from *enter*, and a list of the new items, as remapped by
-            *visit*.
-            Like *enter*, the *exit* function is only called once per
-            unique value. The default exit behavior is to simply add
-            all new items to the new parent, e.g., using
-            :meth:`list.extend` and :meth:`dict.update` to add to the
-            new parent. Immutable objects, such as a :class:`tuple` or
-            :class:`namedtuple`, must be recreated from scratch, but
-            use the same type as the new parent passed back from the
-            *enter* function.
-        reraise_visit (bool): A pragmatic convenience for the *visit*
-            callable. When set to ``False``, remap ignores any errors
-            raised by the *visit* callback. Items causing exceptions
-            are kept. See examples for more details.
-    remap is designed to cover the majority of cases with just the
-    *visit* callable. While passing in multiple callables is very
-    empowering, remap is designed so very few cases should require
-    passing more than one function.
-    When passing *enter* and *exit*, it's common and easiest to build
-    on the default behavior. Simply add ``from boltons.iterutils import
-    default_enter`` (or ``default_exit``), and have your enter/exit
-    function call the default behavior before or after your custom
-    logic. See `this example`_.
-    Duplicate and self-referential objects (aka reference loops) are
-    automatically handled internally, `as shown here`_.
-    .. _this example: http://sedimental.org/remap.html#sort_all_lists
-    .. _as shown here: http://sedimental.org/remap.html#corner_cases
-    """
-    # TODO: improve argument formatting in sphinx doc
-    # TODO: enter() return (False, items) to continue traverse but cancel copy?
-    if not callable(visit):
-        raise TypeError("visit expected callable, not: %r" % visit)
-    if not callable(enter):
-        raise TypeError("enter expected callable, not: %r" % enter)
-    if not callable(exit):
-        raise TypeError("exit expected callable, not: %r" % exit)
-    reraise_visit = kwargs.pop("reraise_visit", True)
-    if kwargs:
-        raise TypeError("unexpected keyword arguments: %r" % kwargs.keys())
-
-    path, registry, stack = (), {}, [(None, root)]
-    new_items_stack = []
-    while stack:
-        key, value = stack.pop()
-        id_value = id(value)
-        if key is _REMAP_EXIT:
-            key, new_parent, old_parent = value
-            id_value = id(old_parent)
-            path, new_items = new_items_stack.pop()
-            value = exit(path, key, old_parent, new_parent, new_items)
-            registry[id_value] = value
-            if not new_items_stack:
-                continue
-        elif id_value in registry:
-            value = registry[id_value]
-        else:
-            res = enter(path, key, value)
-            try:
-                new_parent, new_items = res
-            except TypeError:
-                # TODO: handle False?
-                raise TypeError(
-                    "enter should return a tuple of (new_parent,"
-                    " items_iterator), not: %r" % res
-                )
-            if new_items is not False:
-                # traverse unless False is explicitly passed
-                registry[id_value] = new_parent
-                new_items_stack.append((path, []))
-                if value is not root:
-                    path += (key,)
-                stack.append((_REMAP_EXIT, (key, new_parent, value)))
-                if new_items:
-                    stack.extend(reversed(list(new_items)))
-                continue
-        if visit is _orig_default_visit:
-            # avoid function call overhead by inlining identity operation
-            visited_item = (key, value)
-        else:
-            try:
-                visited_item = visit(path, key, value)
-            except Exception:
-                if reraise_visit:
-                    raise
-                visited_item = True
-            if visited_item is False:
-                continue  # drop
-            elif visited_item is True:
-                visited_item = (key, value)
-            # TODO: typecheck?
-            #    raise TypeError('expected (key, value) from visit(),'
-            #                    ' not: %r' % visited_item)
-        try:
-            new_items_stack[-1][1].append(visited_item)
-        except IndexError:
-            raise TypeError("expected remappable root, not: %r" % root)
-    return value
-
-
+# Not sourced from boltons
 def merge_items(target_list, sourced=False):
     if not sourced:
         target_list = [(id(t), t) for t in target_list]
