--- libflatfile/DB.cpp
+++ libflatfile/DB.cpp
@@ -221,7 +221,7 @@
             throw PalmLib::error("list view is corrupt");
 
         // Determine the length of the name string.
-        pi_char_t* null_ptr = reinterpret_cast<pi_char_t*>
+        const pi_char_t* null_ptr = reinterpret_cast<const pi_char_t*>
             (memchr(chunk.data() + 4, 0, 32));
         if (null_ptr)
             lv.name = std::string((char *) (chunk.data() + 4),
@@ -511,7 +511,8 @@
                             f.type = PalmLib::FlatFile::Field::LIST;
                 if (!field(j).argument().empty()) {
                     std::string data = field(j).argument();
-                    unsigned int k, pos = 0;
+                    unsigned int k;
+		    std::string::size_type pos = 0;
                     pi_uint16_t itemID = *ptrs[j]; // TR: a list value is stored on 1 byte
 
                     for (k = 0; k < itemID; k++) {
@@ -716,7 +717,8 @@
         case PalmLib::FlatFile::Field::LIST:
         if (!field(i).argument().empty()) {
             std::string data = field(i).argument();
-            unsigned int pos = 0, next, j = 0;
+            unsigned int j = 0;
+	    std::string::size_type pos = 0, next;
             pi_int16_t itemID = -1;
 
             while ( (next = data.find(charSeperator, pos)) != std::string::npos) {
@@ -920,7 +922,7 @@
             if (!field(i).argument().empty()) {
                 std::string data = field(i).argument();
                 std::vector<std::string> items;
-                unsigned int pos = 0, next;
+                std::string::size_type pos = 0, next;
                 std::vector<std::string>::iterator iter;
                 size = 2 + 2 * sizeof(pi_uint16_t);
                 while ( (next = data.find(charSeperator, pos)) != std::string::npos) {
--- libflatfile/JFile3.cpp
+++ libflatfile/JFile3.cpp
@@ -454,7 +454,7 @@
 void PalmLib::FlatFile::JFile3::JFileAppInfoType::unpack(const PalmLib::Block& block)
 {
     unsigned i;
-    pi_char_t* null_ptr;
+    const pi_char_t* null_ptr;
 
     // Ensure that we have enough space to extract information from.
     if (block.size() < ( (20 * (20+1)) + 20*2 + 2 + 2 + 20*2 + 2
@@ -467,7 +467,7 @@
     // Extract the field names.
     for (i = 0; i < 20; ++i) {
         /* Find the trailing null byte and extract the string. */
-        null_ptr = reinterpret_cast<pi_char_t*> (memchr(p, 0, 21));
+        null_ptr = reinterpret_cast<const pi_char_t*> (memchr(p, 0, 21));
         if (null_ptr)
             fieldNames[i] = std::string((char *) p, null_ptr - p);
         else
@@ -518,7 +518,7 @@
     p += sizeof(pi_uint16_t);
 
     // Extract the string used last by Find.
-    null_ptr = reinterpret_cast<pi_char_t*> (memchr(p, 0, 16));
+    null_ptr = reinterpret_cast<const pi_char_t*> (memchr(p, 0, 16));
     if (null_ptr)
         findString = std::string((char *) p, null_ptr - p);
     else
@@ -526,7 +526,7 @@
     p += 16;
 
     // Extract the string used last by Filter.
-    null_ptr = reinterpret_cast<pi_char_t*> (memchr(p, 0, 16));
+    null_ptr = reinterpret_cast<const pi_char_t*> (memchr(p, 0, 16));
     if (null_ptr)
         filterString = std::string((char *) p, null_ptr - p);
     else
@@ -542,7 +542,7 @@
     p += sizeof(pi_uint16_t);
 
     // Extract the password (if any).
-    null_ptr = reinterpret_cast<pi_char_t*> (memchr(p, 0, 12));
+    null_ptr = reinterpret_cast<const pi_char_t*> (memchr(p, 0, 12));
     if (null_ptr)
         password = std::string((char *) p, null_ptr - p);
     else
--- libflatfile/MobileDB.cpp
+++ libflatfile/MobileDB.cpp
@@ -221,7 +221,7 @@
         if (field + 1 > fields.size()) fields.resize(field + 1);
 
         // Now search for the end of the current field.
-        pi_char_t* q = reinterpret_cast<pi_char_t*>
+        const pi_char_t* q = reinterpret_cast<const pi_char_t*>
             (memchr(p, 0, rec.end() - p));
         if (!q)
             throw PalmLib::error("field terminiator is missing");
