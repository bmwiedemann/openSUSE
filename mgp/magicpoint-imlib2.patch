diff -ur magicpoint-1.13a/configure.in snap-20090219/configure.in
--- magicpoint-1.13a/configure.in	2007-12-28 21:31:26.000000000 +0100
+++ snap-20090219/configure.in	2009-02-15 12:35:19.000000000 +0100
@@ -3,7 +3,7 @@
 dnl independent (using srcdir), however, xmkmf and Imake.tmpl do not
 dnl allow us to switch compilation directory.
 dnl
-dnl $Id: configure.in,v 1.104 2007/12/28 20:31:26 nishida Exp $
+dnl $Id: configure.in,v 1.105 2009/02/15 11:35:19 nishida Exp $
 AC_INIT(image/imagetypes.c)
 
 dnl Checks for programs.
@@ -448,44 +448,44 @@
 AC_SUBST(USE_IMLIB)
 AC_MSG_CHECKING(if imlib is used)
 AC_ARG_ENABLE(imlib,
-	[  --enable-imlib          use imlib exclusively to load images.],
+	[  --enable-imlib          use imlib2 exclusively to load images.],
 	[mgp_imlib="$enableval"],
 	[mgp_imlib="yes"])
 AC_MSG_RESULT($mgp_imlib)
 if test $mgp_imlib = "yes"; then
   if type pkg-config > /dev/null 2>&1; then
-     if pkg-config imlib; then
-        LIBS="$LIBS `pkg-config --libs imlib`"
-        OPTFLAGS="$OPTFLAGS `pkg-config --cflags imlib`"
+     if pkg-config imlib2; then
+        LIBS="$LIBS `pkg-config --libs imlib2`"
+        OPTFLAGS="$OPTFLAGS `pkg-config --cflags imlib2`"
 	AC_DEFINE(USE_IMLIB)
 	USE_IMLIB=1
      fi
   else
-	AC_CHECK_LIB(Imlib, Imlib_init,
+	AC_CHECK_LIB(Imlib2, imlib_load_image,
 		[imlib_ok=yes
-		LIBS="$LIBS -lImlib"
+		LIBS="$LIBS -lImlib2"
 		AC_DEFINE(USE_IMLIB)
 		USE_IMLIB=1],
 		[], [-L$x_libraries -lX11 -lXext])
 	if test "x$imlib_ok" != "xyes"; then
-		echo 'FATAL: You need libImlib to use Imlib loading.  pass proper LIBS to configure.'
+		echo 'FATAL: You need libImlib2 to use Imlib loading.  pass proper LIBS to configure.'
 		exit 1
 	fi
 	for i in /usr/pkg /usr/local; do
-		if test -f $i/include/Imlib.h; then
+		if test -f $i/include/Imlib2.h; then
 			imlib_h_ok=yes
 			OPTFLAGS="$OPTFLAGS -I$i/include"
 			break
 		fi
 	done
-	if test -f /usr/include/Imlib.h; then
+	if test -f /usr/include/Imlib2.h; then
 		imlib_h_ok=yes
 	fi
 	if test "x$gif_h_ok" != "xyes"; then
-		AC_CHECK_HEADER(Imlib.h, imlib_h_ok=yes)
+		AC_CHECK_HEADER(Imlib2.h, imlib_h_ok=yes)
 	fi
 	if test "x$imlib_h_ok" != "xyes"; then
-		echo 'FATAL: cannot find Imlib.h.  pass proper CPPFLAGS to configure.'
+		echo 'FATAL: cannot find Imlib2.h.  pass proper CPPFLAGS to configure.'
 		exit 1
 	fi
   fi
diff -ur magicpoint-1.13a/draw.c snap-20090219/draw.c
--- magicpoint-1.13a/draw.c	2008-01-24 16:43:17.000000000 +0100
+++ snap-20090219/draw.c	2009-02-15 12:35:19.000000000 +0100
@@ -26,12 +26,12 @@
  * SUCH DAMAGE.
  */
 /*
- * $Id: draw.c,v 1.245 2008/01/24 15:43:17 nishida Exp $
+ * $Id: draw.c,v 1.246 2009/02/15 11:35:19 nishida Exp $
  */
 
 #include "mgp.h"
 #ifdef USE_IMLIB
-#include <Imlib.h>
+#include <Imlib2.h>
 #endif
 
 /* state associated with the window - how should we treat this? */
@@ -83,8 +83,8 @@
 	u_int, char *));
 static int obj_new_image __P((struct render_state *, int, int, Image *, int, int));
 #ifdef USE_IMLIB
-ImlibImage *search_imdata __P((char *));
-static int obj_new_image2 __P((struct render_state *, int, int, Image *, int, int, ImlibImage *, int));
+Imlib_Image *search_imdata __P((char *));
+static int obj_new_image2 __P((struct render_state *, int, int, Image *, int, int, Imlib_Image *, int));
 #endif
 static int obj_new_icon __P((struct render_state *, int, int, u_int, u_int, u_long, u_int, XPoint *));
 static Pixel obj_image_color __P((Image *, Image *, Pixel, int *));
@@ -168,7 +168,7 @@
 static void clear_zimage __P((int));
 static void clear_region __P((int, int, int, int));
 #define ZIMAGENUM 100
-static ImlibImage *zimage[ZIMAGENUM];
+static Imlib_Image *zimage[ZIMAGENUM];
 static int zonzoom[ZIMAGENUM];
 static int zpage[ZIMAGENUM];
 static int zx[ZIMAGENUM];
@@ -1819,7 +1819,7 @@
 	int x, y;
 	Image *image;
 	int xzoom, yzoom;
-	ImlibImage *imimage;
+	Imlib_Image *imimage;
 	int zoomonclk;
 {
 	struct render_object *obj;
@@ -3212,7 +3212,7 @@
 	static char backfile[MAXPATHLEN];
 	static int backzoom, backnumcolor, backx, backy;
 #ifdef USE_IMLIB
-	ImlibImage *imimage;
+	Imlib_Image *imimage;
 #endif
 
 	if (!caching){
diff -ur magicpoint-1.13a/image/imlib_loader.c snap-20090219/image/imlib_loader.c
--- magicpoint-1.13a/image/imlib_loader.c	2008-01-16 15:52:14.000000000 +0100
+++ snap-20090219/image/imlib_loader.c	2009-02-18 11:44:31.000000000 +0100
@@ -6,13 +6,14 @@
 #include <X11/Xlib.h>
 #include <X11/Xutil.h>
 #include <X11/extensions/shape.h>
-#include <Imlib.h>
+#include <Imlib2.h>
 
 #define IMFILENUM 500
 static char imfile[IMFILENUM][1024];
-static ImlibImage *imdata[IMFILENUM];
+static Imlib_Image *imdata[IMFILENUM];
+static Image *imagedata[IMFILENUM];
 static int imnum;
-static ImlibData *id;
+static Imlib_Context *id;
 
 int imIdent(char *fullname, char *name)
 {
@@ -22,32 +23,71 @@
 Image *imLoad(char *fullname, char *name, unsigned int verbose)
 {
 	static Display *disp = NULL;
-	Image *image;
-	ImlibImage *im;
-	ImlibColor shape;
-	unsigned int w,h, size;
-	ImlibImage *search_imdata();
+	Image *image = NULL;
+	Imlib_Image *im;
+	unsigned int w,h, size, i;
+	DATA32 * argb_data;
+	byte * rgb_ptr;
+	Imlib_Image *search_imdata();
 	void regist_imdata();
 
 	if (disp == NULL) {
 		disp=XOpenDisplay(NULL);
 	}
-	if (id == NULL) id=Imlib_init(disp);
-	if ((im = search_imdata(fullname)) == NULL) {
-		im = Imlib_load_image(id, fullname);
+	/*    if (id == NULL) id=Imlib_init(disp); */
+	/* might needs more work */
+	if (id == NULL) {
+		/* dither for non-truecolor displays */
+		imlib_context_set_dither(1);
+		imlib_context_set_display(disp);
+		imlib_context_set_visual(DefaultVisual(disp, DefaultScreen(disp)));
+		imlib_context_set_colormap(DefaultColormap(disp, DefaultScreen(disp)));
+	}
+	if ((im = search_imdata(fullname), image) == NULL) {
+		/* im = Imlib_load_image(id, fullname); */
+		im = imlib_load_image(fullname);
 	}
 	if (im == NULL) {
 		return NULL;
 	}
-	w = im->rgb_width;
-	h = im->rgb_height;
-	size = w * h * 3;
-
-	image = newTrueImage(w, h);
-	memcpy(image->data, im->rgb_data, size);
-	
-	Imlib_get_image_shape(id, im, &shape);
-
+	imlib_context_set_image(im);
+	w = imlib_image_get_width();
+	h = imlib_image_get_height();
+	size = w * h;
+
+	if (image == NULL) image = newTrueImage(w, h);
+
+	/* Imlib2 stores images in ARGB format (32 bpp).  MagicPoint
+	 * wants RGB data (24 bpp). So we need a conversion pass. */
+	argb_data = imlib_image_get_data_for_reading_only();
+	rgb_ptr = image->data;
+	for (i = 0; i < size; ++i)
+	{
+		if ((argb_data[i] >> 24) < 128)
+		{
+			/* If this is a transparent pixel, we store #FE00FE. */
+			*rgb_ptr++ = 0xFE;
+			*rgb_ptr++ = 0x00;
+			*rgb_ptr++ = 0xFE;
+			/* Tell mgp we have transparent pixels. */
+			image->trans = 0xFE00FE;
+		}
+		else if ((argb_data[i] & 0x00FFFFFF) == 0x00FE00FE)
+		{
+		/* If that color is actually used, we substitute something close. */
+		*rgb_ptr++ = 0xFF;
+		*rgb_ptr++ = 0x00;
+		*rgb_ptr++ = 0xFE;
+		}
+		else
+		{
+			/* Otherwise, we can copy the pixel. */
+			*rgb_ptr++ = (argb_data[i] >> 16) & 0xFF; /* red */
+			*rgb_ptr++ = (argb_data[i] >> 8) & 0xFF;  /* green */
+			*rgb_ptr++ = argb_data[i] & 0xFF;         /* blue */
+	 	}
+	}
+#if 0
 	/*
 	 * bug fix for transparent gif handling
 	 * suggested by Jose Geraldo Alves Brito Neto <jgabrito@iq.usp.br>
@@ -57,44 +97,52 @@
 	    ((shape.r & 0xff) << 16) |
 	    ((shape.g & 0xff) <<  8) |
 	    ((shape.b & 0xff) <<  0);
+#endif
 
 	image->title = dupString(name);
 #if 0
 	Imlib_kill_image(id, im);
 #else
-	regist_imdata(name, im);
+	regist_imdata(name, im, image);
 #endif
 	
 	return image;
 }
 
-ImlibImage *search_imdata(char *fullname)
+Imlib_Image *search_imdata(char *fullname, Image *image)
 {
 	int i;
 	for (i = 0; i < imnum; i ++){
 		if (!strcmp(imfile[i], fullname)) {
+			image = imagedata[i];
 			return imdata[i];
 		}
 	}
 	return NULL;
 }
 
-void regist_imdata(fullname, im)
+void regist_imdata(fullname, im, image)
 	char *fullname; 
-	ImlibImage *im;
+	Imlib_Image *im;
+	Image *image;
 {
 	strcpy(imfile[imnum], fullname);	
 	imdata[imnum] = im;
+	imagedata[imnum] = image;
 	imnum ++;
 }
 
 Pixmap pixmap_fromimimage(imimage, width, height)
-	ImlibImage *imimage;
+	Imlib_Image *imimage;
 	int width, height;
 {
 	static Pixmap pixmap;
+#if 0
 	Imlib_render(id, imimage, width, height);
 	pixmap = Imlib_move_image(id, imimage);
+#else
+	imlib_render_pixmaps_for_whole_image_at_size(&pixmap, NULL, width, height);
+#endif
 
 	return pixmap;
 }
@@ -125,8 +173,8 @@
 		ppage[i] = page;
 	} else {
 		for (i = 0; i < MAXPMAP; i ++) {
-			if (ppage[i] == page){
-				Imlib_free_pixmap(id, pmap[i]);
+			if (ppage[i] == page && pmap[i] != 0){
+				imlib_free_pixmap_and_mask(pmap[i]);
 				pmap[i] = 0;
 			}
 		}
diff -ur magicpoint-1.13a/image/xloadimage.h snap-20090219/image/xloadimage.h
--- magicpoint-1.13a/image/xloadimage.h	2007-12-28 21:31:26.000000000 +0100
+++ snap-20090219/image/xloadimage.h	2009-02-15 12:35:19.000000000 +0100
@@ -16,7 +16,7 @@
 #include "options.h"
 
 #ifdef USE_IMLIB
-#include <Imlib.h>
+#include <Imlib2.h>
 #endif
 
 /* image name and option structure used when processing arguments
diff -ur magicpoint-1.13a/mgp.h snap-20090219/mgp.h
--- magicpoint-1.13a/mgp.h	2008-01-18 18:43:20.000000000 +0100
+++ snap-20090219/mgp.h	2009-02-18 11:44:30.000000000 +0100
@@ -26,7 +26,7 @@
  * SUCH DAMAGE.
  */
 /*
- * $Id: mgp.h,v 1.146 2008/01/18 17:43:20 nishida Exp $
+ * $Id: mgp.h,v 1.147 2009/02/18 10:44:30 nishida Exp $
  */
 
 #include <stdio.h>
@@ -507,7 +507,7 @@
 			float xzoom, yzoom;
 #ifdef USE_IMLIB
 			int zoomonclk;
-			ImlibImage *imimage;
+			Imlib_Image *imimage;
 #endif
 		} image;
 		struct {
