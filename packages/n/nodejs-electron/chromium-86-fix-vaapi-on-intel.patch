Index: electron-16.0.6/media/gpu/vaapi/vaapi_video_decode_accelerator.cc
===================================================================
--- electron-16.0.6.orig/media/gpu/vaapi/vaapi_video_decode_accelerator.cc	2022-01-10 16:06:52.097311842 +0100
+++ electron-16.0.6/media/gpu/vaapi/vaapi_video_decode_accelerator.cc	2022-01-13 16:03:42.777745377 +0100
@@ -60,6 +60,7 @@ unsigned int GetVaFormatForVideoCodecPro
   return VA_RT_FORMAT_YUV420;
 }
 
+#if defined(OS_ANDROID) || BUILDFLAG(IS_CHROMEOS_ASH)
 // Returns true if the CPU is an Intel Gemini Lake or later (including Kaby
 // Lake) Cpu platform id's are referenced from the following file in kernel
 // source arch/x86/include/asm/intel-family.h
@@ -72,6 +73,7 @@ bool IsGeminiLakeOrLater() {
       cpuid.model() >= kGeminiLakeModelId;
   return is_geminilake_or_later;
 }
+#endif
 
 }  // namespace
 
@@ -1227,6 +1229,8 @@ VaapiVideoDecodeAccelerator::DecideBuffe
   if (output_mode_ == VideoDecodeAccelerator::Config::OutputMode::IMPORT)
     return BufferAllocationMode::kNormal;
 
+#if defined(OS_ANDROID) || BUILDFLAG(IS_CHROMEOS_ASH)
+  // Move this to chromeOs only as it is causing problem in some intel linux drivers
   // On Gemini Lake, Kaby Lake and later we can pass to libva the client's
   // PictureBuffers to decode onto, which skips the use of the Vpp unit and its
   // associated format reconciliation copy, avoiding all internal buffer
@@ -1242,6 +1246,7 @@ VaapiVideoDecodeAccelerator::DecideBuffe
       num_extra_pics_ = 3;
     return BufferAllocationMode::kNone;
   }
+#endif
 
   // For H.264 on older devices, another +1 is experimentally needed for
   // high-to-high resolution changes.
