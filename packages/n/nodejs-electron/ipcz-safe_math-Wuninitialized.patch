Do not put an expression with side effects inside an assert,
as the assert gets entirely removed in an optimized build.

See it for yourself: https://godbolt.org/z/GeG4zefK9

Very safe math, indeed.

--- src/third_party/ipcz/src/util/safe_math.h.old	2022-10-20 19:00:41.567140300 +0200
+++ src/third_party/ipcz/src/util/safe_math.h	2022-10-29 22:46:07.312067200 +0200
@@ -17,8 +17,8 @@
   // This throws a compile-time error on evaluating the constexpr if it can be
   // determined at compile-time as failing, otherwise it will fail an
   // assertion at runtime.
-  ABSL_HARDENING_ASSERT(
-      ABSL_PREDICT_TRUE(value <= std::numeric_limits<Dst>::max()));
+  auto ass=ABSL_PREDICT_TRUE(value <= std::numeric_limits<Dst>::max());
+  ABSL_HARDENING_ASSERT(ass);
   return static_cast<Dst>(value);
 }
 
@@ -38,16 +38,16 @@
 template <typename T>
 constexpr T CheckAdd(T a, T b) {
   T result;
-  ABSL_HARDENING_ASSERT(
-      !ABSL_PREDICT_FALSE(__builtin_add_overflow(a, b, &result)));
+  auto ass=!ABSL_PREDICT_FALSE(__builtin_add_overflow(a, b, &result));
+  ABSL_HARDENING_ASSERT(ass);
   return result;
 }
 
 template <typename T>
 constexpr T CheckMul(T a, T b) {
   T result;
-  ABSL_HARDENING_ASSERT(
-      !ABSL_PREDICT_FALSE(__builtin_mul_overflow(a, b, &result)));
+  auto ass=!ABSL_PREDICT_FALSE(__builtin_mul_overflow(a, b, &result));
+  ABSL_HARDENING_ASSERT(ass);
   return result;
 }
 
