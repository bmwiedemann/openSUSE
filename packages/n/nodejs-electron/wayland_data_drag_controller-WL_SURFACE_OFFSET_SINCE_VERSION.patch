From 758dd0a34bec51430123c25a52a2dc14183e5c6a Mon Sep 17 00:00:00 2001
From: Alexander Dunaev <adunaev@igalia.com>
Date: Wed, 30 Nov 2022 09:26:03 +0000
Subject: [PATCH] [linux/wayland] Adopted the new way of setting the buffer
 offset.

Since version 5, the Wayland compositor wants the client to use the
dedicated method to set the offset for the buffer when attaching it to
the surface.

This patch fixes the logic in one place where Chromium uses non-zero
offset, and adds appropriate notes in other places where the offset is
currently zero.

Bug: 1382126
Change-Id: Ide0fa3c1cbc9326d6fb25cf177da65a590aafa1c
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4061548
Commit-Queue: Alexander Dunaev <adunaev@igalia.com>
Reviewed-by: Maksim Sisov <msisov@igalia.com>
Cr-Commit-Position: refs/heads/main@{#1077345}
---
 ui/ozone/platform/wayland/host/wayland_cursor.cc         | 1 +
 .../wayland/host/wayland_data_drag_controller.cc         | 9 +++++++--
 ui/ozone/platform/wayland/host/wayland_surface.cc        | 1 +
 3 files changed, 9 insertions(+), 2 deletions(-)

diff --git a/ui/ozone/platform/wayland/host/wayland_cursor.cc b/ui/ozone/platform/wayland/host/wayland_cursor.cc
index 891ca2e5e1f3c..ae10e43d93bfa 100644
--- a/ui/ozone/platform/wayland/host/wayland_cursor.cc
+++ b/ui/ozone/platform/wayland/host/wayland_cursor.cc
@@ -157,6 +157,7 @@ void WaylandCursor::AttachAndCommit(wl_buffer* buffer,
                         pointer_surface_.get(), hotspot_x_dip, hotspot_y_dip);
 
   wl_surface_damage(pointer_surface_.get(), 0, 0, buffer_width, buffer_height);
+  // Note: should the offset be non-zero, use wl_surface_offset() to set it.
   wl_surface_attach(pointer_surface_.get(), buffer, 0, 0);
   wl_surface_commit(pointer_surface_.get());
 
diff --git a/ui/ozone/platform/wayland/host/wayland_data_drag_controller.cc b/ui/ozone/platform/wayland/host/wayland_data_drag_controller.cc
index 9fe196023dc18..40b1acd4aab3e 100644
--- a/ui/ozone/platform/wayland/host/wayland_data_drag_controller.cc
+++ b/ui/ozone/platform/wayland/host/wayland_data_drag_controller.cc
@@ -265,9 +265,16 @@ void WaylandDataDragController::DrawIconInternal() {
   DVLOG(3) << "Drawing drag icon. size_px=" << size_px.ToString();
   wl::DrawBitmap(*icon_bitmap_, icon_buffer_.get());
   auto* const surface = icon_surface_->surface();
+  if (wl::get_version_of_object(surface) < WL_SURFACE_OFFSET_SINCE_VERSION) {
     wl_surface_attach(surface, icon_buffer_->get(),
                       pending_icon_offset_.x() - current_icon_offset_.x(),
                       pending_icon_offset_.y() - current_icon_offset_.y());
+  } else {
+    wl_surface_attach(surface, icon_buffer_->get(), 0, 0);
+    wl_surface_offset(surface,
+                      pending_icon_offset_.x() - current_icon_offset_.x(),
+                      pending_icon_offset_.y() - current_icon_offset_.y());
+  }
   if (connection_->UseViewporterSurfaceScaling() && icon_surface_->viewport()) {
     wp_viewport_set_destination(icon_surface_->viewport(), size_dip.width(),
                                 size_dip.height());
diff --git a/ui/ozone/platform/wayland/host/wayland_surface.cc b/ui/ozone/platform/wayland/host/wayland_surface.cc
index c94f30d2f57a0..b0b2701214da3 100644
--- a/ui/ozone/platform/wayland/host/wayland_surface.cc
+++ b/ui/ozone/platform/wayland/host/wayland_surface.cc
@@ -387,6 +387,7 @@ void WaylandSurface::ApplyPendingState() {
     // The logic in DamageBuffer currently relies on attachment coordinates of
     // (0, 0). If this changes, then the calculation in DamageBuffer will also
     // need to be updated.
+    // Note: should the offset be non-zero, use wl_surface_offset() to set it.
     wl_surface_attach(surface_.get(), pending_state_.buffer, 0, 0);
 
     // Do not call GetOrCreateSurfaceSync() if the buffer management doesn't
