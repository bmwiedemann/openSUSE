From 5ed594bfc740a7dd614c0507ff1ac2de7adb0f6b Mon Sep 17 00:00:00 2001
From: Amirali Abdolrashidi <abdolrashidi@google.com>
Date: Wed, 11 Oct 2023 23:25:23 +0000
Subject: [PATCH] Reland "Reland "Update Chromium to use VMA 3.0""

This is a reland of commit 048603b3375064d2f34773bea1eb796882068848

Original change's description:
> Reland "Update Chromium to use VMA 3.0"
>
> This is a reland of commit 39d7f0daabd13c913865b2a583d6da21d77a5f70
>
>   An uninitialized value was causing errors in MSAN tests.
> * Initialized the value of the VmaVulkanFunctions in CreateAllocator()
>   to {}.
>
> Original change's description:
> > Update Chromium to use VMA 3.0
> >
> >   Following the change in ANGLE to add support for VMA 3.0, we must
> > also update the VMA version used in Chromium. Currently ANGLE supports
> > both VMA 2.3 and 3.0, via setting ANGLE_VMA_VERSION which is defined
> > based on the build files. In Chromium, since this parameter is not set,
> > ANGLE defaults to using VMA 2.3, which results in conflict if only the
> > VMA hash is changed.
> >   * ANGLE CL: https://crrev.com/c/4777337
> >
> > * Updated the VMA hash in the dependencies to the 3.0 version.
> > * Updated the usage of some functions and variables in gpu/vulkan/ to
> >   be in line with the new VMA changes.
> > * Added angle_vma_version to the build files. It is set to allow ANGLE
> >   to use VMA 3.0.
> >   * This parameter is added temporarily. When ANGLE removes support for
> >     VMA 2.3, it can be removed.
> >
> > Bug: b/295208838
> > Change-Id: I7a0592291d8d0d9902942d39f83e338647753521
> > Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4794544
> > Reviewed-by: Peng Huang <penghuang@chromium.org>
> > Reviewed-by: Thomas Anderson <thomasanderson@chromium.org>
> > Commit-Queue: Amirali Abdolrashidi <abdolrashidi@google.com>
> > Cr-Commit-Position: refs/heads/main@{#1186061}
>
> Cq-Include-Trybots: luci.chromium.try:linux_chromium_msan_rel_ng
> Bug: b/295208838
> Change-Id: I0e1b36cded6557a717bfb633eed783c1888d3607
> Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4803803
> Reviewed-by: Thomas Anderson <thomasanderson@chromium.org>
> Reviewed-by: Peng Huang <penghuang@chromium.org>
> Commit-Queue: Amirali Abdolrashidi <abdolrashidi@google.com>
> Cr-Commit-Position: refs/heads/main@{#1188566}

Bug: b/295208838
Change-Id: I6a987bae94b936afb9c158bb00ff7888a7db7c5e
Cq-Include-Trybots: luci.chromium.try:linux_chromium_msan_rel_ng
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4911597
Reviewed-by: Thomas Anderson <thomasanderson@chromium.org>
Reviewed-by: Shahbaz Youssefi <syoussefi@chromium.org>
Commit-Queue: Peng Huang <penghuang@chromium.org>
Cr-Commit-Position: refs/heads/main@{#1208563}
---
 DEPS                                          |  2 +-
 build_overrides/angle.gni                     |  5 ++
 .../init/gr_vk_memory_allocator_impl.cc       |  4 +-
 gpu/vulkan/vma_wrapper.cc                     | 65 +++++++++++--------
 third_party/vulkan_memory_allocator           |  2 +-
 5 files changed, 46 insertions(+), 32 deletions(-)

diff --git a/build_overrides/angle.gni b/build_overrides/angle.gni
index d1b56165ec4aaa8..c6f8dba7090263e 100644
--- a/build_overrides/angle.gni
+++ b/build_overrides/angle.gni
@@ -8,6 +8,11 @@ angle_root = "//third_party/angle"
 # True if ANGLE can access build/, testing/ and other Chrome folders.
 angle_has_build = true
 
+# Declares the maximum supported VulkanMemoryAllocator version by the client
+# in format AAABBBCCC, where AAA = major, BBB = minor, CCC = patch.
+# The VulkanMemoryAllocator version may be found in its CHANGELOG.md.
+angle_vma_version = 3000000
+
 # Overrides for ANGLE's dependencies
 angle_glslang_dir = "//third_party/vulkan-deps/glslang/src"
 angle_googletest_dir = "//third_party/googletest/src"
diff --git a/gpu/vulkan/init/gr_vk_memory_allocator_impl.cc b/gpu/vulkan/init/gr_vk_memory_allocator_impl.cc
index 695d169a15599af..9dd6ccb4789f801 100644
--- a/gpu/vulkan/init/gr_vk_memory_allocator_impl.cc
+++ b/gpu/vulkan/init/gr_vk_memory_allocator_impl.cc
@@ -203,8 +203,8 @@ class GrVkMemoryAllocatorImpl : public GrVkMemoryAllocator {
     vmaGetMemoryProperties(allocator_, &physical_device_memory_properties);
     for (uint32_t i = 0; i < physical_device_memory_properties->memoryHeapCount;
          ++i) {
-      total_allocated_memory += budget[i].blockBytes;
-      total_used_memory += budget[i].allocationBytes;
+      total_allocated_memory += budget[i].statistics.blockBytes;
+      total_used_memory += budget[i].statistics.allocationBytes;
     }
     DCHECK_LE(total_used_memory, total_allocated_memory);
     return {total_allocated_memory, total_used_memory};
diff --git a/gpu/vulkan/vma_wrapper.cc b/gpu/vulkan/vma_wrapper.cc
index f185b251b4f310f..b1d05fb51746f9f 100644
--- a/gpu/vulkan/vma_wrapper.cc
+++ b/gpu/vulkan/vma_wrapper.cc
@@ -24,30 +24,39 @@ VkResult CreateAllocator(VkPhysicalDevice physical_device,
                          const bool is_thread_safe,
                          VmaAllocator* pAllocator) {
   auto* function_pointers = gpu::GetVulkanFunctionPointers();
-  VmaVulkanFunctions functions = {
-      function_pointers->vkGetPhysicalDeviceProperties.get(),
-      function_pointers->vkGetPhysicalDeviceMemoryProperties.get(),
-      function_pointers->vkAllocateMemory.get(),
-      function_pointers->vkFreeMemory.get(),
-      function_pointers->vkMapMemory.get(),
-      function_pointers->vkUnmapMemory.get(),
-      function_pointers->vkFlushMappedMemoryRanges.get(),
-      function_pointers->vkInvalidateMappedMemoryRanges.get(),
-      function_pointers->vkBindBufferMemory.get(),
-      function_pointers->vkBindImageMemory.get(),
-      function_pointers->vkGetBufferMemoryRequirements.get(),
-      function_pointers->vkGetImageMemoryRequirements.get(),
-      function_pointers->vkCreateBuffer.get(),
-      function_pointers->vkDestroyBuffer.get(),
-      function_pointers->vkCreateImage.get(),
-      function_pointers->vkDestroyImage.get(),
-      function_pointers->vkCmdCopyBuffer.get(),
-      function_pointers->vkGetBufferMemoryRequirements2.get(),
-      function_pointers->vkGetImageMemoryRequirements2.get(),
-      function_pointers->vkBindBufferMemory2.get(),
-      function_pointers->vkBindImageMemory2.get(),
-      function_pointers->vkGetPhysicalDeviceMemoryProperties2.get(),
-  };
+  VmaVulkanFunctions functions = {};
+  functions.vkGetPhysicalDeviceProperties =
+      function_pointers->vkGetPhysicalDeviceProperties.get();
+  functions.vkGetPhysicalDeviceMemoryProperties =
+      function_pointers->vkGetPhysicalDeviceMemoryProperties.get();
+  functions.vkAllocateMemory = function_pointers->vkAllocateMemory.get();
+  functions.vkFreeMemory = function_pointers->vkFreeMemory.get();
+  functions.vkMapMemory = function_pointers->vkMapMemory.get();
+  functions.vkUnmapMemory = function_pointers->vkUnmapMemory.get();
+  functions.vkFlushMappedMemoryRanges =
+      function_pointers->vkFlushMappedMemoryRanges.get();
+  functions.vkInvalidateMappedMemoryRanges =
+      function_pointers->vkInvalidateMappedMemoryRanges.get();
+  functions.vkBindBufferMemory = function_pointers->vkBindBufferMemory.get();
+  functions.vkBindImageMemory = function_pointers->vkBindImageMemory.get();
+  functions.vkGetBufferMemoryRequirements =
+      function_pointers->vkGetBufferMemoryRequirements.get();
+  functions.vkGetImageMemoryRequirements =
+      function_pointers->vkGetImageMemoryRequirements.get();
+  functions.vkCreateBuffer = function_pointers->vkCreateBuffer.get();
+  functions.vkDestroyBuffer = function_pointers->vkDestroyBuffer.get();
+  functions.vkCreateImage = function_pointers->vkCreateImage.get();
+  functions.vkDestroyImage = function_pointers->vkDestroyImage.get();
+  functions.vkCmdCopyBuffer = function_pointers->vkCmdCopyBuffer.get();
+  functions.vkGetBufferMemoryRequirements2KHR =
+      function_pointers->vkGetBufferMemoryRequirements2.get();
+  functions.vkGetImageMemoryRequirements2KHR =
+      function_pointers->vkGetImageMemoryRequirements2.get();
+  functions.vkBindBufferMemory2KHR =
+      function_pointers->vkBindBufferMemory2.get();
+  functions.vkBindImageMemory2KHR = function_pointers->vkBindImageMemory2.get();
+  functions.vkGetPhysicalDeviceMemoryProperties2KHR =
+      function_pointers->vkGetPhysicalDeviceMemoryProperties2.get();
 
   static_assert(kVulkanRequiredApiVersion >= VK_API_VERSION_1_1, "");
   VmaAllocatorCreateInfo allocator_info = {
@@ -175,7 +184,7 @@ void GetPhysicalDeviceProperties(
 }
 
 void GetBudget(VmaAllocator allocator, VmaBudget* budget) {
-  vmaGetBudget(allocator, budget);
+  vmaGetHeapBudgets(allocator, budget);
 }
 
 std::pair<uint64_t, uint64_t> GetTotalAllocatedAndUsedMemory(
@@ -183,14 +192,14 @@ std::pair<uint64_t, uint64_t> GetTotalAllocatedAndUsedMemory(
   // See GrVkMemoryAllocatorImpl::totalAllocatedAndUsedMemory() in skia for
   // reference.
   VmaBudget budget[VK_MAX_MEMORY_HEAPS];
-  vmaGetBudget(allocator, budget);
+  GetBudget(allocator, budget);
   const VkPhysicalDeviceMemoryProperties* pPhysicalDeviceMemoryProperties;
   vmaGetMemoryProperties(allocator, &pPhysicalDeviceMemoryProperties);
   uint64_t total_allocated_memory = 0, total_used_memory = 0;
   for (uint32_t i = 0; i < pPhysicalDeviceMemoryProperties->memoryHeapCount;
        ++i) {
-    total_allocated_memory += budget[i].blockBytes;
-    total_used_memory += budget[i].allocationBytes;
+    total_allocated_memory += budget[i].statistics.blockBytes;
+    total_used_memory += budget[i].statistics.allocationBytes;
   }
   DCHECK_LE(total_used_memory, total_allocated_memory);
 
