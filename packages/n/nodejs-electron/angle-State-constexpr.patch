From 0508fc9b920b001115f80790e4942ff69d3f5de1 Mon Sep 17 00:00:00 2001
From: Roman Lavrov <romanl@google.com>
Date: Tue, 23 Apr 2024 15:32:52 -0400
Subject: [PATCH] Reland "Cleanup: replace DirtyObjectType check with constexpr
 generator"

Avoid using lambdas with member function pointers which caused issues
on MSVC C++17.

This is a reland of commit 89caa0e1d99e45f3d6f355f6e14c147f8de3e0e5

Original change's description:
> Cleanup: replace DirtyObjectType check with constexpr generator
>
> Static assert was meant to avoid kDirtyObjectHandlers getting out of
> sync, but it doesn't achieve that goal as it's just comparing values
> with ints which is confusing.
>
> Replacing with constexpr generated std::array. C++20 allows to easily
> validate that all values are set by _not_ default-initializing
> `handlers`. C++17 makes it trickier, addeded static_assert on an
> additional static constexpr bool (silly but I can't find a more concise
> way)
>
> Bug: angleproject:8666
> Bug: b/335295728
> Change-Id: Idf9bbd087d09d5ba253a7587ce0503cae3fcf3a7
> Reviewed-on: https://chromium-review.googlesource.com/c/angle/angle/+/5478231
> Reviewed-by: Shahbaz Youssefi <syoussefi@chromium.org>
> Commit-Queue: Roman Lavrov <romanl@google.com>

Bug: angleproject:8666
Bug: b/335295728
Change-Id: I62e66b700512e072ef10cc57a17e8837a534c0d5
Reviewed-on: https://chromium-review.googlesource.com/c/angle/angle/+/5589285
Commit-Queue: Roman Lavrov <romanl@google.com>
Reviewed-by: Shahbaz Youssefi <syoussefi@chromium.org>
---
 src/libANGLE/State.cpp |  2 --
 src/libANGLE/State.h   | 67 +++++++++++++++++++++++++-----------------
 2 files changed, 40 insertions(+), 29 deletions(-)

diff --git a/src/libANGLE/State.h b/src/libANGLE/State.h
index b2aa6749060..38a219f489d 100644
--- src/third_party/angle/src/libANGLE/State.h.orig	2024-07-24 12:51:20.205804675 +0200
+++ src/third_party/angle/src/libANGLE/State.h	2024-07-26 14:11:54.188991370 +0200
@@ -1447,41 +1447,46 @@ class State : angle::NonCopyable
     angle::Result syncProgramPipelineObject(const Context *context, Command command);
 
     using DirtyObjectHandler = angle::Result (State::*)(const Context *context, Command command);
+    using DirtyObjectHandlerArray = std::array<DirtyObjectHandler, state::DIRTY_OBJECT_MAX>;
 
-    static constexpr std::array<DirtyObjectHandler, state::DIRTY_OBJECT_MAX> kDirtyObjectHandlers =
-        []() {
-            // Work around C++'s lack of array element support in designated initializers
-            std::array<DirtyObjectHandler, state::DIRTY_OBJECT_MAX> handlers{};
-
-            handlers[state::DIRTY_OBJECT_ACTIVE_TEXTURES]  = &State::syncActiveTextures;
-            handlers[state::DIRTY_OBJECT_TEXTURES_INIT]    = &State::syncTexturesInit;
-            handlers[state::DIRTY_OBJECT_IMAGES_INIT]      = &State::syncImagesInit;
-            handlers[state::DIRTY_OBJECT_READ_ATTACHMENTS] = &State::syncReadAttachments;
-            handlers[state::DIRTY_OBJECT_DRAW_ATTACHMENTS] = &State::syncDrawAttachments;
-            handlers[state::DIRTY_OBJECT_READ_FRAMEBUFFER] = &State::syncReadFramebuffer;
-            handlers[state::DIRTY_OBJECT_DRAW_FRAMEBUFFER] = &State::syncDrawFramebuffer;
-            handlers[state::DIRTY_OBJECT_VERTEX_ARRAY]     = &State::syncVertexArray;
-            handlers[state::DIRTY_OBJECT_TEXTURES]         = &State::syncTextures;
-            handlers[state::DIRTY_OBJECT_IMAGES]           = &State::syncImages;
-            handlers[state::DIRTY_OBJECT_SAMPLERS]         = &State::syncSamplers;
-            handlers[state::DIRTY_OBJECT_PROGRAM_PIPELINE_OBJECT] =
-                &State::syncProgramPipelineObject;
-
-            return handlers;
-        }();
-
-    static_assert(
-        []() {
-            for (auto handler : kDirtyObjectHandlers)
+    static constexpr DirtyObjectHandlerArray MakeDirtyObjectHandlers()
+    {
+        // Work around C++'s lack of array element support in designated initializers
+        // This function cannot be a lambda due to MSVC C++17 limitations b/330910097#comment5
+        DirtyObjectHandlerArray handlers{};
+
+        handlers[state::DIRTY_OBJECT_ACTIVE_TEXTURES]         = &State::syncActiveTextures;
+        handlers[state::DIRTY_OBJECT_TEXTURES_INIT]           = &State::syncTexturesInit;
+        handlers[state::DIRTY_OBJECT_IMAGES_INIT]             = &State::syncImagesInit;
+        handlers[state::DIRTY_OBJECT_READ_ATTACHMENTS]        = &State::syncReadAttachments;
+        handlers[state::DIRTY_OBJECT_DRAW_ATTACHMENTS]        = &State::syncDrawAttachments;
+        handlers[state::DIRTY_OBJECT_READ_FRAMEBUFFER]        = &State::syncReadFramebuffer;
+        handlers[state::DIRTY_OBJECT_DRAW_FRAMEBUFFER]        = &State::syncDrawFramebuffer;
+        handlers[state::DIRTY_OBJECT_VERTEX_ARRAY]            = &State::syncVertexArray;
+        handlers[state::DIRTY_OBJECT_TEXTURES]                = &State::syncTextures;
+        handlers[state::DIRTY_OBJECT_IMAGES]                  = &State::syncImages;
+        handlers[state::DIRTY_OBJECT_SAMPLERS]                = &State::syncSamplers;
+        handlers[state::DIRTY_OBJECT_PROGRAM_PIPELINE_OBJECT] = &State::syncProgramPipelineObject;
+
+        // If a handler is missing, reset everything for ease of static_assert
+        for (auto handler : handlers)
+        {
+            if (handler == nullptr)
             {
-                if (handler == nullptr)
-                {
-                    return false;
-                }
+                return DirtyObjectHandlerArray();
             }
-            return true;
-        }(),
-        "kDirtyObjectHandlers missing a handler");
+        }
+
+        return handlers;
+    }
+
+    angle::Result dirtyObjectHandler(size_t dirtyObject, const Context *context, Command command)
+    {
+        static constexpr DirtyObjectHandlerArray handlers = MakeDirtyObjectHandlers();
+        static_assert(handlers[0] != nullptr, "MakeDirtyObjectHandlers missing a handler");
+
+        return (this->*handlers[dirtyObject])(context, command);
+    }
 
     // Robust init must happen before Framebuffer init for the Vulkan back-end.
     static_assert(state::DIRTY_OBJECT_ACTIVE_TEXTURES < state::DIRTY_OBJECT_TEXTURES_INIT,
@@ -1606,7 +1611,7 @@ ANGLE_INLINE angle::Result State::syncDi
 
     for (size_t dirtyObject : dirtyObjects)
     {
-        ANGLE_TRY((this->*kDirtyObjectHandlers[dirtyObject])(context, command));
+        ANGLE_TRY(dirtyObjectHandler(dirtyObject, context, command));
     }
 
     mDirtyObjects &= ~dirtyObjects;
