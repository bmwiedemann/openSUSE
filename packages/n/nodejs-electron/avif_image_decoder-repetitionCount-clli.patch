--- src/third_party/blink/renderer/platform/image-decoders/avif/avif_image_decoder.cc.old	2023-09-03 08:00:30.283599000 +0200
+++ src/third_party/blink/renderer/platform/image-decoders/avif/avif_image_decoder.cc	2023-09-04 22:18:55.656557200 +0200
@@ -40,6 +40,20 @@
 #error Blink assumes a little-endian target.
 #endif

+#include <type_traits>
+#define define_has_member(member_name)                                         \
+    template <typename T>                                                      \
+    class has_member_##member_name                                             \
+    {                                                                          \
+        template <typename U> static std::true_type test(decltype(&U::member_name)); \
+        template <typename U> static std::false_type  test(...);                       \
+    public:                                                                    \
+        static constexpr bool v = decltype(test<T>(0))::value;  \
+    };
+
+define_has_member(clli)
+define_has_member(repetitionCount)
+
 namespace {

 // The maximum AVIF file size we are willing to decode. This helps libavif
@@ -463,6 +477,8 @@ void AVIFImageDecoder::DecodeToYUV() {
 }

 int AVIFImageDecoder::RepetitionCount() const {
+#ifdef AVIF_REPETITION_COUNT_INFINITE
+[](auto &decoder_, auto &decoded_frame_count_) { if constexpr(has_member_repetitionCount<avifDecoder>::v) {
   if (decoded_frame_count_ > 1) {
     switch (decoder_->repetitionCount) {
       case AVIF_REPETITION_COUNT_INFINITE:
@@ -477,6 +493,13 @@ int AVIFImageDecoder::RepetitionCount()
     }
   }
   return kAnimationNone;
+} else {
+#endif
+  return decoded_frame_count_ > 1 ? kAnimationLoopInfinite : kAnimationNone;
+#ifdef AVIF_REPETITION_COUNT_INFINITE
+}
+}(decoder_, decoded_frame_count_);
+#endif
 }

 bool AVIFImageDecoder::FrameIsReceivedAtIndex(wtf_size_t index) const {
@@ -872,11 +895,13 @@ bool AVIFImageDecoder::UpdateDemuxer() {
   chroma_shift_x_ = format_info.chromaShiftX;
   chroma_shift_y_ = format_info.chromaShiftY;

+[](auto &container, auto &hdr_metadata_) { if constexpr(has_member_clli<avifImage>::v) {
   if (container->clli.maxCLL || container->clli.maxPALL) {
     hdr_metadata_ = gfx::HDRMetadata();
     hdr_metadata_->max_content_light_level = container->clli.maxCLL;
     hdr_metadata_->max_frame_average_light_level = container->clli.maxPALL;
   }
+}}(container, hdr_metadata_);

   // SetEmbeddedColorProfile() must be called before IsSizeAvailable() becomes
   // true. So call SetEmbeddedColorProfile() before calling SetSize(). The color
