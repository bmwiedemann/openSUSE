commit 1f9b181c2090d83b93d3edda98296856427d13d1
Author: Michaël Zasso <targos@protonmail.com>
Date:   Tue Oct 25 16:13:17 2022 +0200

    deps: update ICU to 72.1
    
    Refs: https://github.com/unicode-org/icu/releases/tag/release-72-1
    PR-URL: https://github.com/nodejs/node/pull/45068
    Reviewed-By: Richard Lau <rlau@redhat.com>
    Reviewed-By: Mohammed Keyvanzadeh <mohammadkeyvanzade94@gmail.com>
    Reviewed-By: Steven R Loomis <srloomis@us.ibm.com>
    Reviewed-By: James M Snell <jasnell@gmail.com>
    Reviewed-By: Tobias Nießen <tniessen@tnie.de>

diff --git a/deps/icu-small/README-FULL-ICU.txt b/deps/icu-small/README-FULL-ICU.txt
index 0c33485768..8ca7dfb864 100644
--- a/deps/icu-small/README-FULL-ICU.txt
+++ b/deps/icu-small/README-FULL-ICU.txt
@@ -1,8 +1,8 @@
 ICU sources - auto generated by shrink-icu-src.py
 
 This directory contains the ICU subset used by --with-intl=full-icu
-It is a strict subset of ICU 71 source files with the following exception(s):
-* deps/icu-small/source/data/in/icudt71l.dat.bz2 : compressed data file
+It is a strict subset of ICU 72 source files with the following exception(s):
+* deps/icu-small/source/data/in/icudt72l.dat.bz2 : compressed data file
 
 
 To rebuild this directory, see ../../tools/icu/README.md
diff --git a/deps/icu-small/source/common/appendable.cpp b/deps/icu-small/source/common/appendable.cpp
index fca3c1e413..f9b20180eb 100644
--- a/deps/icu-small/source/common/appendable.cpp
+++ b/deps/icu-small/source/common/appendable.cpp
@@ -37,23 +37,23 @@ Appendable::appendString(const UChar *s, int32_t length) {
         UChar c;
         while((c=*s++)!=0) {
             if(!appendCodeUnit(c)) {
-                return FALSE;
+                return false;
             }
         }
     } else if(length>0) {
         const UChar *limit=s+length;
         do {
             if(!appendCodeUnit(*s++)) {
-                return FALSE;
+                return false;
             }
         } while(s<limit);
     }
-    return TRUE;
+    return true;
 }
 
 UBool
 Appendable::reserveAppendCapacity(int32_t /*appendCapacity*/) {
-    return TRUE;
+    return true;
 }
 
 UChar *
diff --git a/deps/icu-small/source/common/bmpset.cpp b/deps/icu-small/source/common/bmpset.cpp
index bc79f5e5a6..14ab894267 100644
--- a/deps/icu-small/source/common/bmpset.cpp
+++ b/deps/icu-small/source/common/bmpset.cpp
@@ -309,9 +309,9 @@ BMPSet::contains(UChar32 c) const {
         // surrogate or supplementary code point
         return containsSlow(c, list4kStarts[0xd], list4kStarts[0x11]);
     } else {
-        // Out-of-range code points get FALSE, consistent with long-standing
+        // Out-of-range code points get false, consistent with long-standing
         // behavior of UnicodeSet::contains(c).
-        return FALSE;
+        return false;
     }
 }
 
diff --git a/deps/icu-small/source/common/brkeng.cpp b/deps/icu-small/source/common/brkeng.cpp
index dc9fb99bf1..bd6abbb55a 100644
--- a/deps/icu-small/source/common/brkeng.cpp
+++ b/deps/icu-small/source/common/brkeng.cpp
@@ -261,10 +261,10 @@ ICULanguageBreakFactory::loadDictionaryMatcherFor(UScriptCode script) {
     const UChar *extStart = u_memrchr(dictfname, 0x002e, dictnlength);  // last dot
     if (extStart != NULL) {
         int32_t len = (int32_t)(extStart - dictfname);
-        ext.appendInvariantChars(UnicodeString(FALSE, extStart + 1, dictnlength - len - 1), status);
+        ext.appendInvariantChars(UnicodeString(false, extStart + 1, dictnlength - len - 1), status);
         dictnlength = len;
     }
-    dictnbuf.appendInvariantChars(UnicodeString(FALSE, dictfname, dictnlength), status);
+    dictnbuf.appendInvariantChars(UnicodeString(false, dictfname, dictnlength), status);
     ures_close(b);
 
     UDataMemory *file = udata_open(U_ICUDATA_BRKITR, ext.data(), dictnbuf.data(), &status);
diff --git a/deps/icu-small/source/common/brkiter.cpp b/deps/icu-small/source/common/brkiter.cpp
index 8a1915880e..d6996734e3 100644
--- a/deps/icu-small/source/common/brkiter.cpp
+++ b/deps/icu-small/source/common/brkiter.cpp
@@ -279,7 +279,7 @@ ICUBreakIteratorService::~ICUBreakIteratorService() {}
 // defined in ucln_cmn.h
 U_NAMESPACE_END
 
-static icu::UInitOnce gInitOnceBrkiter = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gInitOnceBrkiter {};
 static icu::ICULocaleService* gService = NULL;
 
 
@@ -296,7 +296,7 @@ static UBool U_CALLCONV breakiterator_cleanup(void) {
     }
     gInitOnceBrkiter.reset();
 #endif
-    return TRUE;
+    return true;
 }
 U_CDECL_END
 U_NAMESPACE_BEGIN
@@ -347,7 +347,7 @@ BreakIterator::unregister(URegistryKey key, UErrorCode& status)
         }
         status = U_MEMORY_ALLOCATION_ERROR;
     }
-    return FALSE;
+    return false;
 }
 
 // -------------------------------------
diff --git a/deps/icu-small/source/common/bytesinkutil.cpp b/deps/icu-small/source/common/bytesinkutil.cpp
index c64a845f87..a32254a7db 100644
--- a/deps/icu-small/source/common/bytesinkutil.cpp
+++ b/deps/icu-small/source/common/bytesinkutil.cpp
@@ -20,7 +20,7 @@ U_NAMESPACE_BEGIN
 UBool
 ByteSinkUtil::appendChange(int32_t length, const char16_t *s16, int32_t s16Length,
                            ByteSink &sink, Edits *edits, UErrorCode &errorCode) {
-    if (U_FAILURE(errorCode)) { return FALSE; }
+    if (U_FAILURE(errorCode)) { return false; }
     char scratch[200];
     int32_t s8Length = 0;
     for (int32_t i = 0; i < s16Length;) {
@@ -44,7 +44,7 @@ ByteSinkUtil::appendChange(int32_t length, const char16_t *s16, int32_t s16Lengt
         }
         if (j > (INT32_MAX - s8Length)) {
             errorCode = U_INDEX_OUTOFBOUNDS_ERROR;
-            return FALSE;
+            return false;
         }
         sink.Append(buffer, j);
         s8Length += j;
@@ -52,17 +52,17 @@ ByteSinkUtil::appendChange(int32_t length, const char16_t *s16, int32_t s16Lengt
     if (edits != nullptr) {
         edits->addReplace(length, s8Length);
     }
-    return TRUE;
+    return true;
 }
 
 UBool
 ByteSinkUtil::appendChange(const uint8_t *s, const uint8_t *limit,
                            const char16_t *s16, int32_t s16Length,
                            ByteSink &sink, Edits *edits, UErrorCode &errorCode) {
-    if (U_FAILURE(errorCode)) { return FALSE; }
+    if (U_FAILURE(errorCode)) { return false; }
     if ((limit - s) > INT32_MAX) {
         errorCode = U_INDEX_OUTOFBOUNDS_ERROR;
-        return FALSE;
+        return false;
     }
     return appendChange((int32_t)(limit - s), s16, s16Length, sink, edits, errorCode);
 }
@@ -109,16 +109,16 @@ UBool
 ByteSinkUtil::appendUnchanged(const uint8_t *s, const uint8_t *limit,
                               ByteSink &sink, uint32_t options, Edits *edits,
                               UErrorCode &errorCode) {
-    if (U_FAILURE(errorCode)) { return FALSE; }
+    if (U_FAILURE(errorCode)) { return false; }
     if ((limit - s) > INT32_MAX) {
         errorCode = U_INDEX_OUTOFBOUNDS_ERROR;
-        return FALSE;
+        return false;
     }
     int32_t length = (int32_t)(limit - s);
     if (length > 0) {
         appendNonEmptyUnchanged(s, length, sink, options, edits);
     }
-    return TRUE;
+    return true;
 }
 
 CharStringByteSink::CharStringByteSink(CharString* dest) : dest_(*dest) {
diff --git a/deps/icu-small/source/common/bytesinkutil.h b/deps/icu-small/source/common/bytesinkutil.h
index ab2516432d..929c71fbee 100644
--- a/deps/icu-small/source/common/bytesinkutil.h
+++ b/deps/icu-small/source/common/bytesinkutil.h
@@ -4,6 +4,9 @@
 // bytesinkutil.h
 // created: 2017sep14 Markus W. Scherer
 
+#ifndef BYTESINKUTIL_H
+#define BYTESINKUTIL_H
+
 #include "unicode/utypes.h"
 #include "unicode/bytestream.h"
 #include "unicode/edits.h"
@@ -81,3 +84,5 @@ private:
 };
 
 U_NAMESPACE_END
+
+#endif //BYTESINKUTIL_H
diff --git a/deps/icu-small/source/common/bytestream.cpp b/deps/icu-small/source/common/bytestream.cpp
index 0d0e4dda39..c14f206dfe 100644
--- a/deps/icu-small/source/common/bytestream.cpp
+++ b/deps/icu-small/source/common/bytestream.cpp
@@ -30,14 +30,14 @@ void ByteSink::Flush() {}
 
 CheckedArrayByteSink::CheckedArrayByteSink(char* outbuf, int32_t capacity)
     : outbuf_(outbuf), capacity_(capacity < 0 ? 0 : capacity),
-      size_(0), appended_(0), overflowed_(FALSE) {
+      size_(0), appended_(0), overflowed_(false) {
 }
 
 CheckedArrayByteSink::~CheckedArrayByteSink() {}
 
 CheckedArrayByteSink& CheckedArrayByteSink::Reset() {
   size_ = appended_ = 0;
-  overflowed_ = FALSE;
+  overflowed_ = false;
   return *this;
 }
 
@@ -48,14 +48,14 @@ void CheckedArrayByteSink::Append(const char* bytes, int32_t n) {
   if (n > (INT32_MAX - appended_)) {
     // TODO: Report as integer overflow, not merely buffer overflow.
     appended_ = INT32_MAX;
-    overflowed_ = TRUE;
+    overflowed_ = true;
     return;
   }
   appended_ += n;
   int32_t available = capacity_ - size_;
   if (n > available) {
     n = available;
-    overflowed_ = TRUE;
+    overflowed_ = true;
   }
   if (n > 0 && bytes != (outbuf_ + size_)) {
     uprv_memcpy(outbuf_ + size_, bytes, n);
diff --git a/deps/icu-small/source/common/bytestrie.cpp b/deps/icu-small/source/common/bytestrie.cpp
index c4d498c4bf..c272cc4022 100644
--- a/deps/icu-small/source/common/bytestrie.cpp
+++ b/deps/icu-small/source/common/bytestrie.cpp
@@ -337,13 +337,13 @@ BytesTrie::findUniqueValueFromBranch(const uint8_t *pos, int32_t length,
                 }
             } else {
                 uniqueValue=value;
-                haveUniqueValue=TRUE;
+                haveUniqueValue=true;
             }
         } else {
             if(!findUniqueValue(pos+value, haveUniqueValue, uniqueValue)) {
                 return NULL;
             }
-            haveUniqueValue=TRUE;
+            haveUniqueValue=true;
         }
     } while(--length>1);
     return pos+1;  // ignore the last comparison byte
@@ -359,9 +359,9 @@ BytesTrie::findUniqueValue(const uint8_t *pos, UBool haveUniqueValue, int32_t &u
             }
             pos=findUniqueValueFromBranch(pos, node+1, haveUniqueValue, uniqueValue);
             if(pos==NULL) {
-                return FALSE;
+                return false;
             }
-            haveUniqueValue=TRUE;
+            haveUniqueValue=true;
         } else if(node<kMinValueLead) {
             // linear-match node
             pos+=node-kMinLinearMatch+1;  // Ignore the match bytes.
@@ -370,14 +370,14 @@ BytesTrie::findUniqueValue(const uint8_t *pos, UBool haveUniqueValue, int32_t &u
             int32_t value=readValue(pos, node>>1);
             if(haveUniqueValue) {
                 if(value!=uniqueValue) {
-                    return FALSE;
+                    return false;
                 }
             } else {
                 uniqueValue=value;
-                haveUniqueValue=TRUE;
+                haveUniqueValue=true;
             }
             if(isFinal) {
-                return TRUE;
+                return true;
             }
             pos=skipValue(pos, node);
         }
diff --git a/deps/icu-small/source/common/bytestriebuilder.cpp b/deps/icu-small/source/common/bytestriebuilder.cpp
index 82dad42ca5..ac7d3d867e 100644
--- a/deps/icu-small/source/common/bytestriebuilder.cpp
+++ b/deps/icu-small/source/common/bytestriebuilder.cpp
@@ -231,7 +231,7 @@ BytesTrieBuilder::buildBytes(UStringTrieBuildOption buildOption, UErrorCode &err
         }
         uprv_sortArray(elements, elementsLength, (int32_t)sizeof(BytesTrieElement),
                       compareElementStrings, strings,
-                      FALSE,  // need not be a stable sort
+                      false,  // need not be a stable sort
                       &errorCode);
         if(U_FAILURE(errorCode)) {
             return;
@@ -375,7 +375,7 @@ BytesTrieBuilder::createLinearMatchNode(int32_t i, int32_t byteIndex, int32_t le
 UBool
 BytesTrieBuilder::ensureCapacity(int32_t length) {
     if(bytes==NULL) {
-        return FALSE;  // previous memory allocation had failed
+        return false;  // previous memory allocation had failed
     }
     if(length>bytesCapacity) {
         int32_t newCapacity=bytesCapacity;
@@ -388,7 +388,7 @@ BytesTrieBuilder::ensureCapacity(int32_t length) {
             uprv_free(bytes);
             bytes=NULL;
             bytesCapacity=0;
-            return FALSE;
+            return false;
         }
         uprv_memcpy(newBytes+(newCapacity-bytesLength),
                     bytes+(bytesCapacity-bytesLength), bytesLength);
@@ -396,7 +396,7 @@ BytesTrieBuilder::ensureCapacity(int32_t length) {
         bytes=newBytes;
         bytesCapacity=newCapacity;
     }
-    return TRUE;
+    return true;
 }
 
 int32_t
@@ -463,7 +463,7 @@ int32_t
 BytesTrieBuilder::writeValueAndType(UBool hasValue, int32_t value, int32_t node) {
     int32_t offset=write(node);
     if(hasValue) {
-        offset=writeValueAndFinal(value, FALSE);
+        offset=writeValueAndFinal(value, false);
     }
     return offset;
 }
diff --git a/deps/icu-small/source/common/bytestrieiterator.cpp b/deps/icu-small/source/common/bytestrieiterator.cpp
index e64961a1f1..eacb7eedb0 100644
--- a/deps/icu-small/source/common/bytestrieiterator.cpp
+++ b/deps/icu-small/source/common/bytestrieiterator.cpp
@@ -101,12 +101,12 @@ BytesTrie::Iterator::hasNext() const { return pos_!=NULL || !stack_->isEmpty();
 UBool
 BytesTrie::Iterator::next(UErrorCode &errorCode) {
     if(U_FAILURE(errorCode)) {
-        return FALSE;
+        return false;
     }
     const uint8_t *pos=pos_;
     if(pos==NULL) {
         if(stack_->isEmpty()) {
-            return FALSE;
+            return false;
         }
         // Pop the state off the stack and continue with the next outbound edge of
         // the branch node.
@@ -119,7 +119,7 @@ BytesTrie::Iterator::next(UErrorCode &errorCode) {
         if(length>1) {
             pos=branchNext(pos, length, errorCode);
             if(pos==NULL) {
-                return TRUE;  // Reached a final value.
+                return true;  // Reached a final value.
             }
         } else {
             str_->append((char)*pos++, errorCode);
@@ -141,7 +141,7 @@ BytesTrie::Iterator::next(UErrorCode &errorCode) {
             } else {
                 pos_=skipValue(pos, node);
             }
-            return TRUE;
+            return true;
         }
         if(maxLength_>0 && str_->length()==maxLength_) {
             return truncateAndStop();
@@ -152,7 +152,7 @@ BytesTrie::Iterator::next(UErrorCode &errorCode) {
             }
             pos=branchNext(pos, node+1, errorCode);
             if(pos==NULL) {
-                return TRUE;  // Reached a final value.
+                return true;  // Reached a final value.
             }
         } else {
             // Linear-match node, append length bytes to str_.
@@ -177,7 +177,7 @@ UBool
 BytesTrie::Iterator::truncateAndStop() {
     pos_=NULL;
     value_=-1;  // no real value for str
-    return TRUE;
+    return true;
 }
 
 // Branch node, needs to take the first outbound edge and push state for the rest.
diff --git a/deps/icu-small/source/common/caniter.cpp b/deps/icu-small/source/common/caniter.cpp
index a2083afde3..81f17265fb 100644
--- a/deps/icu-small/source/common/caniter.cpp
+++ b/deps/icu-small/source/common/caniter.cpp
@@ -119,7 +119,7 @@ UnicodeString CanonicalIterator::getSource() {
  * Resets the iterator so that one can start again from the beginning.
  */
 void CanonicalIterator::reset() {
-    done = FALSE;
+    done = false;
     for (int i = 0; i < current_length; ++i) {
         current[i] = 0;
     }
@@ -151,7 +151,7 @@ UnicodeString CanonicalIterator::next() {
 
     for (i = current_length - 1; ; --i) {
         if (i < 0) {
-            done = TRUE;
+            done = true;
             break;
         }
         current[i]++;
@@ -176,7 +176,7 @@ void CanonicalIterator::setSource(const UnicodeString &newSource, UErrorCode &st
     if(U_FAILURE(status)) {
       return;
     }
-    done = FALSE;
+    done = false;
 
     cleanPieces();
 
@@ -521,7 +521,7 @@ Hashtable *CanonicalIterator::extract(Hashtable *fillinResult, UChar32 comp, con
     int32_t decompLen=decompString.length();
 
     // See if it matches the start of segment (at segmentPos)
-    UBool ok = FALSE;
+    UBool ok = false;
     UChar32 cp;
     int32_t decompPos = 0;
     UChar32 decompCp;
@@ -537,7 +537,7 @@ Hashtable *CanonicalIterator::extract(Hashtable *fillinResult, UChar32 comp, con
 
             if (decompPos == decompLen) { // done, have all decomp characters!
                 temp.append(segment+i, segLen-i);
-                ok = TRUE;
+                ok = true;
                 break;
             }
             U16_NEXT(decomp, decompPos, decompLen, decompCp);
diff --git a/deps/icu-small/source/common/characterproperties.cpp b/deps/icu-small/source/common/characterproperties.cpp
index a84996b47c..2316a391a3 100644
--- a/deps/icu-small/source/common/characterproperties.cpp
+++ b/deps/icu-small/source/common/characterproperties.cpp
@@ -36,11 +36,11 @@ namespace {
 
 UBool U_CALLCONV characterproperties_cleanup();
 
-constexpr int32_t NUM_INCLUSIONS = UPROPS_SRC_COUNT + UCHAR_INT_LIMIT - UCHAR_INT_START;
+constexpr int32_t NUM_INCLUSIONS = UPROPS_SRC_COUNT + (UCHAR_INT_LIMIT - UCHAR_INT_START);
 
 struct Inclusion {
     UnicodeSet  *fSet = nullptr;
-    UInitOnce    fInitOnce = U_INITONCE_INITIALIZER;
+    UInitOnce    fInitOnce {};
 };
 Inclusion gInclusions[NUM_INCLUSIONS]; // cached getInclusions()
 
@@ -85,7 +85,7 @@ UBool U_CALLCONV characterproperties_cleanup() {
         ucptrie_close(reinterpret_cast<UCPTrie *>(maps[i]));
         maps[i] = nullptr;
     }
-    return TRUE;
+    return true;
 }
 
 void U_CALLCONV initInclusion(UPropertySource src, UErrorCode &errorCode) {
@@ -210,7 +210,7 @@ const UnicodeSet *getInclusionsForSource(UPropertySource src, UErrorCode &errorC
 void U_CALLCONV initIntPropInclusion(UProperty prop, UErrorCode &errorCode) {
     // This function is invoked only via umtx_initOnce().
     U_ASSERT(UCHAR_INT_START <= prop && prop < UCHAR_INT_LIMIT);
-    int32_t inclIndex = UPROPS_SRC_COUNT + prop - UCHAR_INT_START;
+    int32_t inclIndex = UPROPS_SRC_COUNT + (prop - UCHAR_INT_START);
     U_ASSERT(gInclusions[inclIndex].fSet == nullptr);
     UPropertySource src = uprops_getSource(prop);
     const UnicodeSet *incl = getInclusionsForSource(src, errorCode);
@@ -255,7 +255,7 @@ const UnicodeSet *CharacterProperties::getInclusionsForProperty(
         UProperty prop, UErrorCode &errorCode) {
     if (U_FAILURE(errorCode)) { return nullptr; }
     if (UCHAR_INT_START <= prop && prop < UCHAR_INT_LIMIT) {
-        int32_t inclIndex = UPROPS_SRC_COUNT + prop - UCHAR_INT_START;
+        int32_t inclIndex = UPROPS_SRC_COUNT + (prop - UCHAR_INT_START);
         Inclusion &i = gInclusions[inclIndex];
         umtx_initOnce(i.fInitOnce, &initIntPropInclusion, prop, errorCode);
         return i.fSet;
diff --git a/deps/icu-small/source/common/charstr.cpp b/deps/icu-small/source/common/charstr.cpp
index c35622882c..8a0994c737 100644
--- a/deps/icu-small/source/common/charstr.cpp
+++ b/deps/icu-small/source/common/charstr.cpp
@@ -220,7 +220,7 @@ UBool CharString::ensureCapacity(int32_t capacity,
                                  int32_t desiredCapacityHint,
                                  UErrorCode &errorCode) {
     if(U_FAILURE(errorCode)) {
-        return FALSE;
+        return false;
     }
     if(capacity>buffer.getCapacity()) {
         if(desiredCapacityHint==0) {
@@ -230,10 +230,10 @@ UBool CharString::ensureCapacity(int32_t capacity,
             buffer.resize(capacity, len+1)==NULL
         ) {
             errorCode=U_MEMORY_ALLOCATION_ERROR;
-            return FALSE;
+            return false;
         }
     }
-    return TRUE;
+    return true;
 }
 
 CharString &CharString::appendPathPart(StringPiece s, UErrorCode &errorCode) {
diff --git a/deps/icu-small/source/common/charstr.h b/deps/icu-small/source/common/charstr.h
index 175acd1c0a..92a75d3d2f 100644
--- a/deps/icu-small/source/common/charstr.h
+++ b/deps/icu-small/source/common/charstr.h
@@ -177,8 +177,8 @@ private:
 
     UBool ensureCapacity(int32_t capacity, int32_t desiredCapacityHint, UErrorCode &errorCode);
 
-    CharString(const CharString &other); // forbid copying of this class
-    CharString &operator=(const CharString &other); // forbid copying of this class
+    CharString(const CharString &other) = delete; // forbid copying of this class
+    CharString &operator=(const CharString &other) = delete; // forbid copying of this class
 
     /**
      * Returns U_FILE_ALT_SEP_CHAR if found in string, and U_FILE_SEP_CHAR is not found.
diff --git a/deps/icu-small/source/common/cmemory.cpp b/deps/icu-small/source/common/cmemory.cpp
index 663c1411e4..64f5034921 100644
--- a/deps/icu-small/source/common/cmemory.cpp
+++ b/deps/icu-small/source/common/cmemory.cpp
@@ -134,5 +134,5 @@ U_CFUNC UBool cmemory_cleanup(void) {
     pAlloc     = NULL;
     pRealloc   = NULL;
     pFree      = NULL;
-    return TRUE;
+    return true;
 }
diff --git a/deps/icu-small/source/common/cstr.h b/deps/icu-small/source/common/cstr.h
index c7a77a0ae5..be21d910bb 100644
--- a/deps/icu-small/source/common/cstr.h
+++ b/deps/icu-small/source/common/cstr.h
@@ -51,8 +51,8 @@ class U_COMMON_API CStr : public UMemory {
 
   private:
     CharString s;
-    CStr(const CStr &other);               //  Forbid copying of this class.
-    CStr &operator =(const CStr &other);   //  Forbid assignment.
+    CStr(const CStr &other) = delete;               //  Forbid copying of this class.
+    CStr &operator =(const CStr &other) = delete;   //  Forbid assignment.
 };
 
 U_NAMESPACE_END
diff --git a/deps/icu-small/source/common/dictbe.cpp b/deps/icu-small/source/common/dictbe.cpp
index 4fdbdf2760..768eb49b95 100644
--- a/deps/icu-small/source/common/dictbe.cpp
+++ b/deps/icu-small/source/common/dictbe.cpp
@@ -119,7 +119,7 @@ public:
     // Select the currently marked candidate, point after it in the text, and invalidate self
     int32_t   acceptMarked( UText *text );
   
-    // Back up from the current candidate to the next shorter one; return TRUE if that exists
+    // Back up from the current candidate to the next shorter one; return true if that exists
     // and point the text after it
     UBool     backUp( UText *text );
   
@@ -165,9 +165,9 @@ UBool
 PossibleWord::backUp( UText *text ) {
     if (current > 0) {
         utext_setNativeIndex(text, offset + cuLengths[--current]);
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 /*
@@ -1146,7 +1146,7 @@ CjkBreakEngine::divideUpDictionaryRange( UText *inText,
 
         // Input UText is in one contiguous UTF-16 chunk.
         // Use Read-only aliasing UnicodeString.
-        inString.setTo(FALSE,
+        inString.setTo(false,
                        inText->chunkContents + rangeStart - inText->chunkNativeStart,
                        rangeEnd - rangeStart);
     } else {
diff --git a/deps/icu-small/source/common/edits.cpp b/deps/icu-small/source/common/edits.cpp
index 92ca36fb5d..21d7c3f006 100644
--- a/deps/icu-small/source/common/edits.cpp
+++ b/deps/icu-small/source/common/edits.cpp
@@ -221,7 +221,7 @@ UBool Edits::growArray() {
         // Not U_BUFFER_OVERFLOW_ERROR because that could be confused on a string transform API
         // with a result-string-buffer overflow.
         errorCode_ = U_INDEX_OUTOFBOUNDS_ERROR;
-        return FALSE;
+        return false;
     } else if (capacity >= (INT32_MAX / 2)) {
         newCapacity = INT32_MAX;
     } else {
@@ -230,25 +230,25 @@ UBool Edits::growArray() {
     // Grow by at least 5 units so that a maximal change record will fit.
     if ((newCapacity - capacity) < 5) {
         errorCode_ = U_INDEX_OUTOFBOUNDS_ERROR;
-        return FALSE;
+        return false;
     }
     uint16_t *newArray = (uint16_t *)uprv_malloc((size_t)newCapacity * 2);
     if (newArray == NULL) {
         errorCode_ = U_MEMORY_ALLOCATION_ERROR;
-        return FALSE;
+        return false;
     }
     uprv_memcpy(newArray, array, (size_t)length * 2);
     releaseArray();
     array = newArray;
     capacity = newCapacity;
-    return TRUE;
+    return true;
 }
 
 UBool Edits::copyErrorTo(UErrorCode &outErrorCode) const {
-    if (U_FAILURE(outErrorCode)) { return TRUE; }
-    if (U_SUCCESS(errorCode_)) { return FALSE; }
+    if (U_FAILURE(outErrorCode)) { return true; }
+    if (U_SUCCESS(errorCode_)) { return false; }
     outErrorCode = errorCode_;
-    return TRUE;
+    return true;
 }
 
 Edits &Edits::mergeAndAppend(const Edits &ab, const Edits &bc, UErrorCode &errorCode) {
@@ -257,7 +257,7 @@ Edits &Edits::mergeAndAppend(const Edits &ab, const Edits &bc, UErrorCode &error
     // Parallel iteration over both Edits.
     Iterator abIter = ab.getFineIterator();
     Iterator bcIter = bc.getFineIterator();
-    UBool abHasNext = TRUE, bcHasNext = TRUE;
+    UBool abHasNext = true, bcHasNext = true;
     // Copy iterator state into local variables, so that we can modify and subdivide spans.
     // ab old & new length, bc old & new length
     int32_t aLength = 0, ab_bLength = 0, bc_bLength = 0, cLength = 0;
@@ -400,7 +400,7 @@ Edits &Edits::mergeAndAppend(const Edits &ab, const Edits &bc, UErrorCode &error
 Edits::Iterator::Iterator(const uint16_t *a, int32_t len, UBool oc, UBool crs) :
         array(a), index(0), length(len), remaining(0),
         onlyChanges_(oc), coarse(crs),
-        dir(0), changed(FALSE), oldLength_(0), newLength_(0),
+        dir(0), changed(false), oldLength_(0), newLength_(0),
         srcIndex(0), replIndex(0), destIndex(0) {}
 
 int32_t Edits::Iterator::readLength(int32_t head) {
@@ -441,16 +441,16 @@ void Edits::Iterator::updatePreviousIndexes() {
 UBool Edits::Iterator::noNext() {
     // No change before or beyond the string.
     dir = 0;
-    changed = FALSE;
+    changed = false;
     oldLength_ = newLength_ = 0;
-    return FALSE;
+    return false;
 }
 
 UBool Edits::Iterator::next(UBool onlyChanges, UErrorCode &errorCode) {
     // Forward iteration: Update the string indexes to the limit of the current span,
     // and post-increment-read array units to assemble a new span.
     // Leaves the array index one after the last unit of that span.
-    if (U_FAILURE(errorCode)) { return FALSE; }
+    if (U_FAILURE(errorCode)) { return false; }
     // We have an errorCode in case we need to start guarding against integer overflows.
     // It is also convenient for caller loops if we bail out when an error was set elsewhere.
     if (dir > 0) {
@@ -464,7 +464,7 @@ UBool Edits::Iterator::next(UBool onlyChanges, UErrorCode &errorCode) {
                 // Stay on the current one of a sequence of compressed changes.
                 ++index;  // next() rests on the index after the sequence unit.
                 dir = 1;
-                return TRUE;
+                return true;
             }
         }
         dir = 1;
@@ -473,7 +473,7 @@ UBool Edits::Iterator::next(UBool onlyChanges, UErrorCode &errorCode) {
         // Fine-grained iterator: Continue a sequence of compressed changes.
         if (remaining > 1) {
             --remaining;
-            return TRUE;
+            return true;
         }
         remaining = 0;
     }
@@ -483,7 +483,7 @@ UBool Edits::Iterator::next(UBool onlyChanges, UErrorCode &errorCode) {
     int32_t u = array[index++];
     if (u <= MAX_UNCHANGED) {
         // Combine adjacent unchanged ranges.
-        changed = FALSE;
+        changed = false;
         oldLength_ = u + 1;
         while (index < length && (u = array[index]) <= MAX_UNCHANGED) {
             ++index;
@@ -498,10 +498,10 @@ UBool Edits::Iterator::next(UBool onlyChanges, UErrorCode &errorCode) {
             // already fetched u > MAX_UNCHANGED at index
             ++index;
         } else {
-            return TRUE;
+            return true;
         }
     }
-    changed = TRUE;
+    changed = true;
     if (u <= MAX_SHORT_CHANGE) {
         int32_t oldLen = u >> 12;
         int32_t newLen = (u >> 9) & MAX_SHORT_CHANGE_NEW_LENGTH;
@@ -516,14 +516,14 @@ UBool Edits::Iterator::next(UBool onlyChanges, UErrorCode &errorCode) {
             if (num > 1) {
                 remaining = num;  // This is the first of two or more changes.
             }
-            return TRUE;
+            return true;
         }
     } else {
         U_ASSERT(u <= 0x7fff);
         oldLength_ = readLength((u >> 6) & 0x3f);
         newLength_ = readLength(u & 0x3f);
         if (!coarse) {
-            return TRUE;
+            return true;
         }
     }
     // Combine adjacent changes.
@@ -539,14 +539,14 @@ UBool Edits::Iterator::next(UBool onlyChanges, UErrorCode &errorCode) {
             newLength_ += readLength(u & 0x3f);
         }
     }
-    return TRUE;
+    return true;
 }
 
 UBool Edits::Iterator::previous(UErrorCode &errorCode) {
     // Backward iteration: Pre-decrement-read array units to assemble a new span,
     // then update the string indexes to the start of that span.
     // Leaves the array index on the head unit of that span.
-    if (U_FAILURE(errorCode)) { return FALSE; }
+    if (U_FAILURE(errorCode)) { return false; }
     // We have an errorCode in case we need to start guarding against integer overflows.
     // It is also convenient for caller loops if we bail out when an error was set elsewhere.
     if (dir >= 0) {
@@ -559,7 +559,7 @@ UBool Edits::Iterator::previous(UErrorCode &errorCode) {
                 // Stay on the current one of a sequence of compressed changes.
                 --index;  // previous() rests on the sequence unit.
                 dir = -1;
-                return TRUE;
+                return true;
             }
             updateNextIndexes();
         }
@@ -572,7 +572,7 @@ UBool Edits::Iterator::previous(UErrorCode &errorCode) {
         if (remaining <= (u & SHORT_CHANGE_NUM_MASK)) {
             ++remaining;
             updatePreviousIndexes();
-            return TRUE;
+            return true;
         }
         remaining = 0;
     }
@@ -582,7 +582,7 @@ UBool Edits::Iterator::previous(UErrorCode &errorCode) {
     int32_t u = array[--index];
     if (u <= MAX_UNCHANGED) {
         // Combine adjacent unchanged ranges.
-        changed = FALSE;
+        changed = false;
         oldLength_ = u + 1;
         while (index > 0 && (u = array[index - 1]) <= MAX_UNCHANGED) {
             --index;
@@ -591,9 +591,9 @@ UBool Edits::Iterator::previous(UErrorCode &errorCode) {
         newLength_ = oldLength_;
         // No need to handle onlyChanges as long as previous() is called only from findIndex().
         updatePreviousIndexes();
-        return TRUE;
+        return true;
     }
-    changed = TRUE;
+    changed = true;
     if (u <= MAX_SHORT_CHANGE) {
         int32_t oldLen = u >> 12;
         int32_t newLen = (u >> 9) & MAX_SHORT_CHANGE_NEW_LENGTH;
@@ -609,7 +609,7 @@ UBool Edits::Iterator::previous(UErrorCode &errorCode) {
                 remaining = 1;  // This is the last of two or more changes.
             }
             updatePreviousIndexes();
-            return TRUE;
+            return true;
         }
     } else {
         if (u <= 0x7fff) {
@@ -629,7 +629,7 @@ UBool Edits::Iterator::previous(UErrorCode &errorCode) {
         }
         if (!coarse) {
             updatePreviousIndexes();
-            return TRUE;
+            return true;
         }
     }
     // Combine adjacent changes.
@@ -648,7 +648,7 @@ UBool Edits::Iterator::previous(UErrorCode &errorCode) {
         }
     }
     updatePreviousIndexes();
-    return TRUE;
+    return true;
 }
 
 int32_t Edits::Iterator::findIndex(int32_t i, UBool findSource, UErrorCode &errorCode) {
@@ -705,7 +705,7 @@ int32_t Edits::Iterator::findIndex(int32_t i, UBool findSource, UErrorCode &erro
         // The index is in the current span.
         return 0;
     }
-    while (next(FALSE, errorCode)) {
+    while (next(false, errorCode)) {
         if (findSource) {
             spanStart = srcIndex;
             spanLength = oldLength_;
@@ -739,7 +739,7 @@ int32_t Edits::Iterator::findIndex(int32_t i, UBool findSource, UErrorCode &erro
 }
 
 int32_t Edits::Iterator::destinationIndexFromSourceIndex(int32_t i, UErrorCode &errorCode) {
-    int32_t where = findIndex(i, TRUE, errorCode);
+    int32_t where = findIndex(i, true, errorCode);
     if (where < 0) {
         // Error or before the string.
         return 0;
@@ -758,7 +758,7 @@ int32_t Edits::Iterator::destinationIndexFromSourceIndex(int32_t i, UErrorCode &
 }
 
 int32_t Edits::Iterator::sourceIndexFromDestinationIndex(int32_t i, UErrorCode &errorCode) {
-    int32_t where = findIndex(i, FALSE, errorCode);
+    int32_t where = findIndex(i, false, errorCode);
     if (where < 0) {
         // Error or before the string.
         return 0;
diff --git a/deps/icu-small/source/common/emojiprops.cpp b/deps/icu-small/source/common/emojiprops.cpp
index 2a05e8602d..d07e07c6cc 100644
--- a/deps/icu-small/source/common/emojiprops.cpp
+++ b/deps/icu-small/source/common/emojiprops.cpp
@@ -22,7 +22,7 @@ U_NAMESPACE_BEGIN
 namespace {
 
 EmojiProps *singleton = nullptr;
-icu::UInitOnce emojiInitOnce = U_INITONCE_INITIALIZER;
+icu::UInitOnce emojiInitOnce {};
 
 UBool U_CALLCONV emojiprops_cleanup() {
     delete singleton;
diff --git a/deps/icu-small/source/common/filteredbrk.cpp b/deps/icu-small/source/common/filteredbrk.cpp
index e4817367a5..baa1d4e42d 100644
--- a/deps/icu-small/source/common/filteredbrk.cpp
+++ b/deps/icu-small/source/common/filteredbrk.cpp
@@ -58,7 +58,7 @@ static int32_t U_CALLCONV compareUnicodeString(UElement t1, UElement t2) {
 /**
  * A UVector which implements a set of strings.
  */
-class U_COMMON_API UStringSet : public UVector {
+class UStringSet : public UVector {
  public:
   UStringSet(UErrorCode &status) : UVector(uprv_deleteUObject,
                                            uhash_compareUnicodeString,
@@ -482,7 +482,7 @@ SimpleFilteredSentenceBreakIterator::last(void) {
 /**
  * Concrete implementation of builder class.
  */
-class U_COMMON_API SimpleFilteredBreakIteratorBuilder : public FilteredBreakIteratorBuilder {
+class SimpleFilteredBreakIteratorBuilder : public FilteredBreakIteratorBuilder {
 public:
   virtual ~SimpleFilteredBreakIteratorBuilder();
   SimpleFilteredBreakIteratorBuilder(const Locale &fromLocale, UErrorCode &status);
@@ -614,11 +614,11 @@ SimpleFilteredBreakIteratorBuilder::build(BreakIterator* adoptBreakIterator, UEr
         i++) {
     const UnicodeString *abbr = fSet.getStringAt(i);
     if(abbr) {
-      FB_TRACE("build",abbr,TRUE,i);
+      FB_TRACE("build",abbr,true,i);
       ustrs[n] = *abbr; // copy by value
-      FB_TRACE("ustrs[n]",&ustrs[n],TRUE,i);
+      FB_TRACE("ustrs[n]",&ustrs[n],true,i);
     } else {
-      FB_TRACE("build",abbr,FALSE,i);
+      FB_TRACE("build",abbr,false,i);
       status = U_MEMORY_ALLOCATION_ERROR;
       return NULL;
     }
@@ -629,37 +629,37 @@ SimpleFilteredBreakIteratorBuilder::build(BreakIterator* adoptBreakIterator, UEr
   for(int i=0;i<subCount;i++) {
     int nn = ustrs[i].indexOf(kFULLSTOP); // TODO: non-'.' abbreviations
     if(nn>-1 && (nn+1)!=ustrs[i].length()) {
-      FB_TRACE("partial",&ustrs[i],FALSE,i);
+      FB_TRACE("partial",&ustrs[i],false,i);
       // is partial.
       // is it unique?
       int sameAs = -1;
       for(int j=0;j<subCount;j++) {
         if(j==i) continue;
         if(ustrs[i].compare(0,nn+1,ustrs[j],0,nn+1)==0) {
-          FB_TRACE("prefix",&ustrs[j],FALSE,nn+1);
+          FB_TRACE("prefix",&ustrs[j],false,nn+1);
           //UBool otherIsPartial = ((nn+1)!=ustrs[j].length());  // true if ustrs[j] doesn't end at nn
           if(partials[j]==0) { // hasn't been processed yet
             partials[j] = kSuppressInReverse | kAddToForward;
-            FB_TRACE("suppressing",&ustrs[j],FALSE,j);
+            FB_TRACE("suppressing",&ustrs[j],false,j);
           } else if(partials[j] & kSuppressInReverse) {
             sameAs = j; // the other entry is already in the reverse table.
           }
         }
       }
-      FB_TRACE("for partial same-",&ustrs[i],FALSE,sameAs);
-      FB_TRACE(" == partial #",&ustrs[i],FALSE,partials[i]);
+      FB_TRACE("for partial same-",&ustrs[i],false,sameAs);
+      FB_TRACE(" == partial #",&ustrs[i],false,partials[i]);
       UnicodeString prefix(ustrs[i], 0, nn+1);
       if(sameAs == -1 && partials[i] == 0) {
         // first one - add the prefix to the reverse table.
         prefix.reverse();
         builder->add(prefix, kPARTIAL, status);
         revCount++;
-        FB_TRACE("Added partial",&prefix,FALSE, i);
-        FB_TRACE(u_errorName(status),&ustrs[i],FALSE,i);
+        FB_TRACE("Added partial",&prefix,false, i);
+        FB_TRACE(u_errorName(status),&ustrs[i],false,i);
         partials[i] = kSuppressInReverse | kAddToForward;
       } else {
-        FB_TRACE("NOT adding partial",&prefix,FALSE, i);
-        FB_TRACE(u_errorName(status),&ustrs[i],FALSE,i);
+        FB_TRACE("NOT adding partial",&prefix,false, i);
+        FB_TRACE(u_errorName(status),&ustrs[i],false,i);
       }
     }
   }
@@ -668,9 +668,9 @@ SimpleFilteredBreakIteratorBuilder::build(BreakIterator* adoptBreakIterator, UEr
       ustrs[i].reverse();
       builder->add(ustrs[i], kMATCH, status);
       revCount++;
-      FB_TRACE(u_errorName(status), &ustrs[i], FALSE, i);
+      FB_TRACE(u_errorName(status), &ustrs[i], false, i);
     } else {
-      FB_TRACE("Adding fwd",&ustrs[i], FALSE, i);
+      FB_TRACE("Adding fwd",&ustrs[i], false, i);
 
       // an optimization would be to only add the portion after the '.'
       // for example, for "Ph.D." we store ".hP" in the reverse table. We could just store "D." in the forward,
@@ -682,12 +682,12 @@ SimpleFilteredBreakIteratorBuilder::build(BreakIterator* adoptBreakIterator, UEr
       ////if(debug2) u_printf("SUPPRESS- not Added(%d):  /%S/ status=%s\n",partials[i], ustrs[i].getTerminatedBuffer(), u_errorName(status));
     }
   }
-  FB_TRACE("AbbrCount",NULL,FALSE, subCount);
+  FB_TRACE("AbbrCount",NULL,false, subCount);
 
   if(revCount>0) {
     backwardsTrie.adoptInstead(builder->build(USTRINGTRIE_BUILD_FAST, status));
     if(U_FAILURE(status)) {
-      FB_TRACE(u_errorName(status),NULL,FALSE, -1);
+      FB_TRACE(u_errorName(status),NULL,false, -1);
       return NULL;
     }
   }
@@ -695,7 +695,7 @@ SimpleFilteredBreakIteratorBuilder::build(BreakIterator* adoptBreakIterator, UEr
   if(fwdCount>0) {
     forwardsPartialTrie.adoptInstead(builder2->build(USTRINGTRIE_BUILD_FAST, status));
     if(U_FAILURE(status)) {
-      FB_TRACE(u_errorName(status),NULL,FALSE, -1);
+      FB_TRACE(u_errorName(status),NULL,false, -1);
       return NULL;
     }
   }
diff --git a/deps/icu-small/source/common/filterednormalizer2.cpp b/deps/icu-small/source/common/filterednormalizer2.cpp
index 1a0914d3f7..63f01206e9 100644
--- a/deps/icu-small/source/common/filterednormalizer2.cpp
+++ b/deps/icu-small/source/common/filterednormalizer2.cpp
@@ -137,14 +137,14 @@ UnicodeString &
 FilteredNormalizer2::normalizeSecondAndAppend(UnicodeString &first,
                                               const UnicodeString &second,
                                               UErrorCode &errorCode) const {
-    return normalizeSecondAndAppend(first, second, TRUE, errorCode);
+    return normalizeSecondAndAppend(first, second, true, errorCode);
 }
 
 UnicodeString &
 FilteredNormalizer2::append(UnicodeString &first,
                             const UnicodeString &second,
                             UErrorCode &errorCode) const {
-    return normalizeSecondAndAppend(first, second, FALSE, errorCode);
+    return normalizeSecondAndAppend(first, second, false, errorCode);
 }
 
 UnicodeString &
@@ -224,7 +224,7 @@ UBool
 FilteredNormalizer2::isNormalized(const UnicodeString &s, UErrorCode &errorCode) const {
     uprv_checkCanGetBuffer(s, errorCode);
     if(U_FAILURE(errorCode)) {
-        return FALSE;
+        return false;
     }
     USetSpanCondition spanCondition=USET_SPAN_SIMPLE;
     for(int32_t prevSpanLimit=0; prevSpanLimit<s.length();) {
@@ -235,19 +235,19 @@ FilteredNormalizer2::isNormalized(const UnicodeString &s, UErrorCode &errorCode)
             if( !norm2.isNormalized(s.tempSubStringBetween(prevSpanLimit, spanLimit), errorCode) ||
                 U_FAILURE(errorCode)
             ) {
-                return FALSE;
+                return false;
             }
             spanCondition=USET_SPAN_NOT_CONTAINED;
         }
         prevSpanLimit=spanLimit;
     }
-    return TRUE;
+    return true;
 }
 
 UBool
 FilteredNormalizer2::isNormalizedUTF8(StringPiece sp, UErrorCode &errorCode) const {
     if(U_FAILURE(errorCode)) {
-        return FALSE;
+        return false;
     }
     const char *s = sp.data();
     int32_t length = sp.length();
@@ -259,14 +259,14 @@ FilteredNormalizer2::isNormalizedUTF8(StringPiece sp, UErrorCode &errorCode) con
         } else {
             if (!norm2.isNormalizedUTF8(StringPiece(s, spanLength), errorCode) ||
                     U_FAILURE(errorCode)) {
-                return FALSE;
+                return false;
             }
             spanCondition = USET_SPAN_NOT_CONTAINED;
         }
         s += spanLength;
         length -= spanLength;
     }
-    return TRUE;
+    return true;
 }
 
 UNormalizationCheckResult
diff --git a/deps/icu-small/source/common/hash.h b/deps/icu-small/source/common/hash.h
index b927ddb3c3..c9afeaf562 100644
--- a/deps/icu-small/source/common/hash.h
+++ b/deps/icu-small/source/common/hash.h
@@ -115,8 +115,8 @@ public:
 
     inline UBool equals(const Hashtable& that) const;
 private:
-    Hashtable(const Hashtable &other); // forbid copying of this class
-    Hashtable &operator=(const Hashtable &other); // forbid copying of this class
+    Hashtable(const Hashtable &other) = delete; // forbid copying of this class
+    Hashtable &operator=(const Hashtable &other) = delete; // forbid copying of this class
 };
 
 /*********************************************************************
diff --git a/deps/icu-small/source/common/icuplug.cpp b/deps/icu-small/source/common/icuplug.cpp
index 52a0deced6..72b5d27175 100644
--- a/deps/icu-small/source/common/icuplug.cpp
+++ b/deps/icu-small/source/common/icuplug.cpp
@@ -59,8 +59,8 @@ struct UPlugData {
   void *context;          /**< user context data */
   char name[UPLUG_NAME_MAX];   /**< name of plugin */
   UPlugLevel  level; /**< level of plugin */
-  UBool   awaitingLoad; /**< TRUE if the plugin is awaiting a load call */
-  UBool   dontUnload; /**< TRUE if plugin must stay resident (leak plugin and lib) */
+  UBool   awaitingLoad; /**< true if the plugin is awaiting a load call */
+  UBool   dontUnload; /**< true if plugin must stay resident (leak plugin and lib) */
   UErrorCode pluginStatus; /**< status code of plugin */
 };
 
@@ -304,11 +304,11 @@ static void uplug_queryPlug(UPlugData *plug, UErrorCode *status) {
   if(U_SUCCESS(*status)) { 
     if(plug->level == UPLUG_LEVEL_INVALID) {
       plug->pluginStatus = U_PLUGIN_DIDNT_SET_LEVEL;
-      plug->awaitingLoad = FALSE;
+      plug->awaitingLoad = false;
     }
   } else {
     plug->pluginStatus = U_INTERNAL_PROGRAM_ERROR;
-    plug->awaitingLoad = FALSE;
+    plug->awaitingLoad = false;
   }
 }
 
@@ -322,7 +322,7 @@ static void uplug_loadPlug(UPlugData *plug, UErrorCode *status) {
     return;
   }
   uplug_callPlug(plug, UPLUG_REASON_LOAD, status);
-  plug->awaitingLoad = FALSE;
+  plug->awaitingLoad = false;
   if(!U_SUCCESS(*status)) {
     plug->pluginStatus = U_INTERNAL_PROGRAM_ERROR;
   }
@@ -347,8 +347,8 @@ static UPlugData *uplug_allocateEmptyPlug(UErrorCode *status)
   plug->structSize = sizeof(UPlugData);
   plug->name[0]=0;
   plug->level = UPLUG_LEVEL_UNKNOWN; /* initialize to null state */
-  plug->awaitingLoad = TRUE;
-  plug->dontUnload = FALSE;
+  plug->awaitingLoad = true;
+  plug->dontUnload = false;
   plug->pluginStatus = U_ZERO_ERROR;
   plug->libName[0] = 0;
   plug->config[0]=0;
@@ -403,9 +403,9 @@ static void uplug_deallocatePlug(UPlugData *plug, UErrorCode *status) {
     pluginCount = uplug_removeEntryAt(pluginList, pluginCount, sizeof(plug[0]), uplug_pluginNumber(plug));
   } else {
     /* not ok- leave as a message. */
-    plug->awaitingLoad=FALSE;
+    plug->awaitingLoad=false;
     plug->entrypoint=0;
-    plug->dontUnload=TRUE;
+    plug->dontUnload=true;
   }
 }
 
@@ -558,8 +558,8 @@ uplug_initErrorPlug(const char *libName, const char *sym, const char *config, co
   if(U_FAILURE(*status)) return NULL;
 
   plug->pluginStatus = loadStatus;
-  plug->awaitingLoad = FALSE; /* Won't load. */
-  plug->dontUnload = TRUE; /* cannot unload. */
+  plug->awaitingLoad = false; /* Won't load. */
+  plug->dontUnload = true; /* cannot unload. */
 
   if(sym!=NULL) {
     uprv_strncpy(plug->sym, sym, UPLUG_NAME_MAX);
@@ -646,7 +646,7 @@ static UBool U_CALLCONV uplug_cleanup(void)
   }
   /* close other held libs? */
   gCurrentLevel = UPLUG_LEVEL_LOW;
-  return TRUE;
+  return true;
 }
 
 #if U_ENABLE_DYLOAD
@@ -678,7 +678,7 @@ static void uplug_loadWaitingPlugs(UErrorCode *status) {
             currentLevel = newLevel;
           }
         }
-        pluginToLoad->awaitingLoad = FALSE;
+        pluginToLoad->awaitingLoad = false;
       } 
     }
   }    
@@ -694,7 +694,7 @@ static void uplug_loadWaitingPlugs(UErrorCode *status) {
       } else {
         uplug_loadPlug(pluginToLoad, &subStatus);
       }
-      pluginToLoad->awaitingLoad = FALSE;
+      pluginToLoad->awaitingLoad = false;
     }
   }
     
diff --git a/deps/icu-small/source/common/loadednormalizer2impl.cpp b/deps/icu-small/source/common/loadednormalizer2impl.cpp
index 905fc1decc..24ff629f84 100644
--- a/deps/icu-small/source/common/loadednormalizer2impl.cpp
+++ b/deps/icu-small/source/common/loadednormalizer2impl.cpp
@@ -67,9 +67,9 @@ LoadedNormalizer2Impl::isAcceptable(void * /*context*/,
     ) {
         // Normalizer2Impl *me=(Normalizer2Impl *)context;
         // uprv_memcpy(me->dataVersion, pInfo->dataVersion, 4);
-        return TRUE;
+        return true;
     } else {
-        return FALSE;
+        return false;
     }
 }
 
@@ -134,14 +134,14 @@ U_CDECL_END
 
 #if !NORM2_HARDCODE_NFC_DATA
 static Norm2AllModes *nfcSingleton;
-static icu::UInitOnce nfcInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce nfcInitOnce {};
 #endif
 
 static Norm2AllModes *nfkcSingleton;
-static icu::UInitOnce nfkcInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce nfkcInitOnce {};
 
 static Norm2AllModes *nfkc_cfSingleton;
-static icu::UInitOnce nfkc_cfInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce nfkc_cfInitOnce {};
 
 static UHashtable    *cache=NULL;
 
@@ -185,7 +185,7 @@ static UBool U_CALLCONV uprv_loaded_normalizer2_cleanup() {
 
     uhash_close(cache);
     cache=NULL;
-    return TRUE;
+    return true;
 }
 
 U_CDECL_END
diff --git a/deps/icu-small/source/common/localebuilder.cpp b/deps/icu-small/source/common/localebuilder.cpp
index a5f201e847..c1e1f2ad68 100644
--- a/deps/icu-small/source/common/localebuilder.cpp
+++ b/deps/icu-small/source/common/localebuilder.cpp
@@ -15,7 +15,7 @@ U_NAMESPACE_BEGIN
 #define UPRV_ISDIGIT(c) (((c) >= '0') && ((c) <= '9'))
 #define UPRV_ISALPHANUM(c) (uprv_isASCIILetter(c) || UPRV_ISDIGIT(c) )
 
-const char* kAttributeKey = "attribute";
+constexpr const char* kAttributeKey = "attribute";
 
 static bool _isExtensionSubtags(char key, const char* s, int32_t len) {
     switch (uprv_tolower(key)) {
@@ -459,7 +459,7 @@ Locale LocaleBuilder::build(UErrorCode& errorCode)
 UBool LocaleBuilder::copyErrorTo(UErrorCode &outErrorCode) const {
     if (U_FAILURE(outErrorCode)) {
         // Do not overwrite the older error code
-        return TRUE;
+        return true;
     }
     outErrorCode = status_;
     return U_FAILURE(outErrorCode);
diff --git a/deps/icu-small/source/common/localefallback_data.h b/deps/icu-small/source/common/localefallback_data.h
new file mode 100644
index 0000000000..da725de42d
--- /dev/null
+++ b/deps/icu-small/source/common/localefallback_data.h
@@ -0,0 +1,632 @@
+// © 2022 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html
+//
+// Internal static data tables used by uresbund.cpp
+// WARNING: This file is mechanically generated by the CLDR-to-ICU tool
+// (see tools/cldr/cldr-to-icu/src/main/java/org/unicode/tool/cldrtoicu/generator/ResourcFallbackCodeGenerator.java).
+// DO NOT HAND EDIT!!!
+
+#ifdef INCLUDED_FROM_URESBUND_CPP
+
+//======================================================================
+// Default script table
+const char scriptCodeChars[] =
+    "Aghb\0Ahom\0Arab\0Armi\0Armn\0Avst\0Bamu\0Bass\0Beng\0Brah\0Cakm\0"
+    "Cans\0Cari\0Cham\0Cher\0Chrs\0Copt\0Cprt\0Cyrl\0Deva\0Egyp\0Ethi\0"
+    "Geor\0Gong\0Gonm\0Goth\0Grek\0Gujr\0Guru\0Hans\0Hant\0Hebr\0Hluw\0"
+    "Hmnp\0Ital\0Jpan\0Kali\0Kana\0Kawi\0Khar\0Khmr\0Kits\0Knda\0Kore\0"
+    "Lana\0Laoo\0Lepc\0Lina\0Lisu\0Lyci\0Lydi\0Mand\0Mani\0Medf\0Merc\0"
+    "Mlym\0Mong\0Mroo\0Mymr\0Narb\0Nkoo\0Nshu\0Ogam\0Olck\0Orkh\0Orya\0"
+    "Osge\0Ougr\0Pauc\0Phli\0Phnx\0Plrd\0Prti\0Rohg\0Runr\0Samr\0Sarb\0"
+    "Saur\0Sgnw\0Sinh\0Sogd\0Sora\0Soyo\0Syrc\0Tale\0Talu\0Taml\0Tang\0"
+    "Tavt\0Telu\0Tfng\0Thaa\0Thai\0Tibt\0Tnsa\0Toto\0Ugar\0Vaii\0Wcho\0"
+    "Xpeo\0Xsux\0Yiii\0";
+
+const char dsLocaleIDChars[] =
+    "ab\0abq\0adp\0ady\0ae\0aeb\0aho\0ajt\0akk\0alt\0am\0apc\0apd\0"
+    "ar\0arc\0arq\0ars\0ary\0arz\0as\0ase\0av\0avl\0awa\0az_IQ\0az_IR\0"
+    "az_RU\0ba\0bal\0bap\0bax\0bcq\0be\0bej\0bfq\0bft\0bfy\0bg\0bgc\0"
+    "bgn\0bgx\0bhb\0bhi\0bho\0bji\0bjj\0blt\0bn\0bo\0bpy\0bqi\0bra\0"
+    "brh\0brx\0bsq\0bst\0btv\0bua\0byn\0ccp\0ce\0chm\0chr\0cja\0cjm\0"
+    "ckb\0cmg\0cop\0cr\0crh\0crk\0crl\0csw\0ctd\0cu\0cv\0dar\0dcc\0"
+    "dgl\0dmf\0doi\0drh\0drs\0dty\0dv\0dz\0egy\0eky\0el\0esg\0ett\0"
+    "fa\0fia\0fub\0gan\0gbm\0gbz\0gez\0ggn\0gjk\0gju\0glk\0gmv\0gof\0"
+    "gom\0gon\0got\0grc\0grt\0gu\0gvr\0gwc\0gwt\0ha_CM\0ha_SD\0hak\0"
+    "haz\0hdy\0he\0hi\0hlu\0hmd\0hnd\0hne\0hnj\0hno\0hoc\0hoj\0hsn\0"
+    "hy\0ii\0inh\0iu\0iw\0ja\0ji\0jml\0ka\0kaa\0kaw\0kbd\0kby\0kdt\0"
+    "kfr\0kfy\0khb\0khn\0kht\0khw\0kjg\0kk\0kk_AF\0kk_CN\0kk_IR\0kk_MN\0"
+    "km\0kn\0ko\0koi\0kok\0kqy\0krc\0kru\0ks\0ktb\0ku_LB\0kum\0kv\0"
+    "kvx\0kxc\0kxl\0kxm\0kxp\0ky\0ky_CN\0kzh\0lab\0lad\0lah\0lbe\0"
+    "lcp\0lep\0lez\0lif\0lis\0lki\0lmn\0lo\0lrc\0luz\0lwl\0lzh\0mag\0"
+    "mai\0man_GN\0mde\0mdf\0mdx\0mfa\0mgp\0mk\0mki\0ml\0mn\0mn_CN\0"
+    "mni\0mnw\0mr\0mrd\0mrj\0mro\0ms_CC\0mtr\0mvy\0mwr\0mww\0my\0mym\0"
+    "myv\0myz\0mzn\0nan\0ne\0new\0nnp\0nod\0noe\0non\0nqo\0nsk\0nst\0"
+    "oj\0ojs\0or\0oru\0os\0osa\0ota\0otk\0oui\0pa\0pa_PK\0pal\0peo\0"
+    "phl\0phn\0pka\0pnt\0ppa\0pra\0prd\0ps\0raj\0rhg\0rif\0rjs\0rkt\0"
+    "rmt\0ru\0rue\0ryu\0sa\0sah\0sat\0saz\0sck\0scl\0sd\0sd_IN\0sdh\0"
+    "sga\0sgw\0shi\0shn\0shu\0si\0skr\0smp\0sog\0sou\0sr\0srb\0srx\0"
+    "swb\0swv\0syl\0syr\0ta\0taj\0tcy\0tdd\0tdg\0tdh\0te\0tg\0tg_PK\0"
+    "th\0thl\0thq\0thr\0ti\0tig\0tkt\0trw\0tsd\0tsf\0tsj\0tt\0tts\0"
+    "txg\0txo\0tyv\0udi\0udm\0ug\0ug_KZ\0ug_MN\0uga\0uk\0unr\0unr_NP\0"
+    "unx\0ur\0uz_AF\0uz_CN\0vai\0wal\0wbq\0wbr\0wni\0wsg\0wtm\0wuu\0"
+    "xco\0xcr\0xlc\0xld\0xmf\0xmn\0xmr\0xna\0xnr\0xpr\0xsa\0xsr\0yi\0"
+    "yue\0yue_CN\0zdj\0zgh\0zh\0zh_AU\0zh_BN\0zh_GB\0zh_GF\0zh_HK\0"
+    "zh_ID\0zh_MO\0zh_PA\0zh_PF\0zh_PH\0zh_SR\0zh_TH\0zh_TW\0zh_US\0"
+    "zh_VN\0zhx\0zkt\0";
+
+const int32_t defaultScriptTable[] = {
+    0, 90,  // ab -> Cyrl
+    3, 90,  // abq -> Cyrl
+    7, 465,  // adp -> Tibt
+    11, 90,  // ady -> Cyrl
+    15, 25,  // ae -> Avst
+    18, 10,  // aeb -> Arab
+    22, 5,  // aho -> Ahom
+    26, 10,  // ajt -> Arab
+    30, 500,  // akk -> Xsux
+    34, 90,  // alt -> Cyrl
+    38, 105,  // am -> Ethi
+    41, 10,  // apc -> Arab
+    45, 10,  // apd -> Arab
+    49, 10,  // ar -> Arab
+    52, 15,  // arc -> Armi
+    56, 10,  // arq -> Arab
+    60, 10,  // ars -> Arab
+    64, 10,  // ary -> Arab
+    68, 10,  // arz -> Arab
+    72, 40,  // as -> Beng
+    75, 390,  // ase -> Sgnw
+    79, 90,  // av -> Cyrl
+    82, 10,  // avl -> Arab
+    86, 95,  // awa -> Deva
+    90, 10,  // az_IQ -> Arab
+    96, 10,  // az_IR -> Arab
+    102, 90,  // az_RU -> Cyrl
+    108, 90,  // ba -> Cyrl
+    111, 10,  // bal -> Arab
+    115, 95,  // bap -> Deva
+    119, 30,  // bax -> Bamu
+    123, 105,  // bcq -> Ethi
+    127, 90,  // be -> Cyrl
+    130, 10,  // bej -> Arab
+    134, 430,  // bfq -> Taml
+    138, 10,  // bft -> Arab
+    142, 95,  // bfy -> Deva
+    146, 90,  // bg -> Cyrl
+    149, 95,  // bgc -> Deva
+    153, 10,  // bgn -> Arab
+    157, 130,  // bgx -> Grek
+    161, 95,  // bhb -> Deva
+    165, 95,  // bhi -> Deva
+    169, 95,  // bho -> Deva
+    173, 105,  // bji -> Ethi
+    177, 95,  // bjj -> Deva
+    181, 440,  // blt -> Tavt
+    185, 40,  // bn -> Beng
+    188, 465,  // bo -> Tibt
+    191, 40,  // bpy -> Beng
+    195, 10,  // bqi -> Arab
+    199, 95,  // bra -> Deva
+    203, 10,  // brh -> Arab
+    207, 95,  // brx -> Deva
+    211, 35,  // bsq -> Bass
+    215, 105,  // bst -> Ethi
+    219, 95,  // btv -> Deva
+    223, 90,  // bua -> Cyrl
+    227, 105,  // byn -> Ethi
+    231, 50,  // ccp -> Cakm
+    235, 90,  // ce -> Cyrl
+    238, 90,  // chm -> Cyrl
+    242, 70,  // chr -> Cher
+    246, 10,  // cja -> Arab
+    250, 65,  // cjm -> Cham
+    254, 10,  // ckb -> Arab
+    258, 410,  // cmg -> Soyo
+    262, 80,  // cop -> Copt
+    266, 55,  // cr -> Cans
+    269, 90,  // crh -> Cyrl
+    273, 55,  // crk -> Cans
+    277, 55,  // crl -> Cans
+    281, 55,  // csw -> Cans
+    285, 340,  // ctd -> Pauc
+    289, 90,  // cu -> Cyrl
+    292, 90,  // cv -> Cyrl
+    295, 90,  // dar -> Cyrl
+    299, 10,  // dcc -> Arab
+    303, 10,  // dgl -> Arab
+    307, 265,  // dmf -> Medf
+    311, 95,  // doi -> Deva
+    315, 280,  // drh -> Mong
+    319, 105,  // drs -> Ethi
+    323, 95,  // dty -> Deva
+    327, 455,  // dv -> Thaa
+    330, 465,  // dz -> Tibt
+    333, 100,  // egy -> Egyp
+    337, 180,  // eky -> Kali
+    341, 130,  // el -> Grek
+    344, 120,  // esg -> Gonm
+    348, 170,  // ett -> Ital
+    352, 10,  // fa -> Arab
+    355, 10,  // fia -> Arab
+    359, 10,  // fub -> Arab
+    363, 145,  // gan -> Hans
+    367, 95,  // gbm -> Deva
+    371, 10,  // gbz -> Arab
+    375, 105,  // gez -> Ethi
+    379, 95,  // ggn -> Deva
+    383, 10,  // gjk -> Arab
+    387, 10,  // gju -> Arab
+    391, 10,  // glk -> Arab
+    395, 105,  // gmv -> Ethi
+    399, 105,  // gof -> Ethi
+    403, 95,  // gom -> Deva
+    407, 445,  // gon -> Telu
+    411, 125,  // got -> Goth
+    415, 85,  // grc -> Cprt
+    419, 40,  // grt -> Beng
+    423, 135,  // gu -> Gujr
+    426, 95,  // gvr -> Deva
+    430, 10,  // gwc -> Arab
+    434, 10,  // gwt -> Arab
+    438, 10,  // ha_CM -> Arab
+    444, 10,  // ha_SD -> Arab
+    450, 145,  // hak -> Hans
+    454, 10,  // haz -> Arab
+    458, 105,  // hdy -> Ethi
+    462, 155,  // he -> Hebr
+    465, 95,  // hi -> Deva
+    468, 160,  // hlu -> Hluw
+    472, 355,  // hmd -> Plrd
+    476, 10,  // hnd -> Arab
+    480, 95,  // hne -> Deva
+    484, 165,  // hnj -> Hmnp
+    488, 10,  // hno -> Arab
+    492, 95,  // hoc -> Deva
+    496, 95,  // hoj -> Deva
+    500, 145,  // hsn -> Hans
+    504, 20,  // hy -> Armn
+    507, 505,  // ii -> Yiii
+    510, 90,  // inh -> Cyrl
+    514, 55,  // iu -> Cans
+    517, 155,  // iw -> Hebr
+    520, 175,  // ja -> Jpan
+    523, 155,  // ji -> Hebr
+    526, 95,  // jml -> Deva
+    530, 110,  // ka -> Geor
+    533, 90,  // kaa -> Cyrl
+    537, 190,  // kaw -> Kawi
+    541, 90,  // kbd -> Cyrl
+    545, 10,  // kby -> Arab
+    549, 460,  // kdt -> Thai
+    553, 95,  // kfr -> Deva
+    557, 95,  // kfy -> Deva
+    561, 425,  // khb -> Talu
+    565, 95,  // khn -> Deva
+    569, 290,  // kht -> Mymr
+    573, 10,  // khw -> Arab
+    577, 225,  // kjg -> Laoo
+    581, 90,  // kk -> Cyrl
+    584, 10,  // kk_AF -> Arab
+    590, 10,  // kk_CN -> Arab
+    596, 10,  // kk_IR -> Arab
+    602, 10,  // kk_MN -> Arab
+    608, 200,  // km -> Khmr
+    611, 210,  // kn -> Knda
+    614, 215,  // ko -> Kore
+    617, 90,  // koi -> Cyrl
+    621, 95,  // kok -> Deva
+    625, 105,  // kqy -> Ethi
+    629, 90,  // krc -> Cyrl
+    633, 95,  // kru -> Deva
+    637, 10,  // ks -> Arab
+    640, 105,  // ktb -> Ethi
+    644, 10,  // ku_LB -> Arab
+    650, 90,  // kum -> Cyrl
+    654, 90,  // kv -> Cyrl
+    657, 10,  // kvx -> Arab
+    661, 105,  // kxc -> Ethi
+    665, 95,  // kxl -> Deva
+    669, 460,  // kxm -> Thai
+    673, 10,  // kxp -> Arab
+    677, 90,  // ky -> Cyrl
+    680, 10,  // ky_CN -> Arab
+    686, 10,  // kzh -> Arab
+    690, 235,  // lab -> Lina
+    694, 155,  // lad -> Hebr
+    698, 10,  // lah -> Arab
+    702, 90,  // lbe -> Cyrl
+    706, 460,  // lcp -> Thai
+    710, 230,  // lep -> Lepc
+    714, 90,  // lez -> Cyrl
+    718, 95,  // lif -> Deva
+    722, 240,  // lis -> Lisu
+    726, 10,  // lki -> Arab
+    730, 445,  // lmn -> Telu
+    734, 225,  // lo -> Laoo
+    737, 10,  // lrc -> Arab
+    741, 10,  // luz -> Arab
+    745, 460,  // lwl -> Thai
+    749, 145,  // lzh -> Hans
+    753, 95,  // mag -> Deva
+    757, 95,  // mai -> Deva
+    761, 300,  // man_GN -> Nkoo
+    768, 10,  // mde -> Arab
+    772, 90,  // mdf -> Cyrl
+    776, 105,  // mdx -> Ethi
+    780, 10,  // mfa -> Arab
+    784, 95,  // mgp -> Deva
+    788, 90,  // mk -> Cyrl
+    791, 10,  // mki -> Arab
+    795, 275,  // ml -> Mlym
+    798, 90,  // mn -> Cyrl
+    801, 280,  // mn_CN -> Mong
+    807, 40,  // mni -> Beng
+    811, 290,  // mnw -> Mymr
+    815, 95,  // mr -> Deva
+    818, 95,  // mrd -> Deva
+    822, 90,  // mrj -> Cyrl
+    826, 285,  // mro -> Mroo
+    830, 10,  // ms_CC -> Arab
+    836, 95,  // mtr -> Deva
+    840, 10,  // mvy -> Arab
+    844, 95,  // mwr -> Deva
+    848, 165,  // mww -> Hmnp
+    852, 290,  // my -> Mymr
+    855, 105,  // mym -> Ethi
+    859, 90,  // myv -> Cyrl
+    863, 255,  // myz -> Mand
+    867, 10,  // mzn -> Arab
+    871, 145,  // nan -> Hans
+    875, 95,  // ne -> Deva
+    878, 95,  // new -> Deva
+    882, 490,  // nnp -> Wcho
+    886, 220,  // nod -> Lana
+    890, 95,  // noe -> Deva
+    894, 370,  // non -> Runr
+    898, 300,  // nqo -> Nkoo
+    902, 55,  // nsk -> Cans
+    906, 470,  // nst -> Tnsa
+    910, 55,  // oj -> Cans
+    913, 55,  // ojs -> Cans
+    917, 325,  // or -> Orya
+    920, 10,  // oru -> Arab
+    924, 90,  // os -> Cyrl
+    927, 330,  // osa -> Osge
+    931, 10,  // ota -> Arab
+    935, 320,  // otk -> Orkh
+    939, 335,  // oui -> Ougr
+    943, 140,  // pa -> Guru
+    946, 10,  // pa_PK -> Arab
+    952, 345,  // pal -> Phli
+    956, 495,  // peo -> Xpeo
+    960, 10,  // phl -> Arab
+    964, 350,  // phn -> Phnx
+    968, 45,  // pka -> Brah
+    972, 130,  // pnt -> Grek
+    976, 95,  // ppa -> Deva
+    980, 195,  // pra -> Khar
+    984, 10,  // prd -> Arab
+    988, 10,  // ps -> Arab
+    991, 95,  // raj -> Deva
+    995, 365,  // rhg -> Rohg
+    999, 450,  // rif -> Tfng
+    1003, 95,  // rjs -> Deva
+    1007, 40,  // rkt -> Beng
+    1011, 10,  // rmt -> Arab
+    1015, 90,  // ru -> Cyrl
+    1018, 90,  // rue -> Cyrl
+    1022, 185,  // ryu -> Kana
+    1026, 95,  // sa -> Deva
+    1029, 90,  // sah -> Cyrl
+    1033, 315,  // sat -> Olck
+    1037, 385,  // saz -> Saur
+    1041, 95,  // sck -> Deva
+    1045, 10,  // scl -> Arab
+    1049, 10,  // sd -> Arab
+    1052, 95,  // sd_IN -> Deva
+    1058, 10,  // sdh -> Arab
+    1062, 310,  // sga -> Ogam
+    1066, 105,  // sgw -> Ethi
+    1070, 450,  // shi -> Tfng
+    1074, 290,  // shn -> Mymr
+    1078, 10,  // shu -> Arab
+    1082, 395,  // si -> Sinh
+    1085, 10,  // skr -> Arab
+    1089, 375,  // smp -> Samr
+    1093, 400,  // sog -> Sogd
+    1097, 460,  // sou -> Thai
+    1101, 90,  // sr -> Cyrl
+    1104, 405,  // srb -> Sora
+    1108, 95,  // srx -> Deva
+    1112, 10,  // swb -> Arab
+    1116, 95,  // swv -> Deva
+    1120, 40,  // syl -> Beng
+    1124, 415,  // syr -> Syrc
+    1128, 430,  // ta -> Taml
+    1131, 95,  // taj -> Deva
+    1135, 210,  // tcy -> Knda
+    1139, 420,  // tdd -> Tale
+    1143, 95,  // tdg -> Deva
+    1147, 95,  // tdh -> Deva
+    1151, 445,  // te -> Telu
+    1154, 90,  // tg -> Cyrl
+    1157, 10,  // tg_PK -> Arab
+    1163, 460,  // th -> Thai
+    1166, 95,  // thl -> Deva
+    1170, 95,  // thq -> Deva
+    1174, 95,  // thr -> Deva
+    1178, 105,  // ti -> Ethi
+    1181, 105,  // tig -> Ethi
+    1185, 95,  // tkt -> Deva
+    1189, 10,  // trw -> Arab
+    1193, 130,  // tsd -> Grek
+    1197, 95,  // tsf -> Deva
+    1201, 465,  // tsj -> Tibt
+    1205, 90,  // tt -> Cyrl
+    1208, 460,  // tts -> Thai
+    1212, 435,  // txg -> Tang
+    1216, 475,  // txo -> Toto
+    1220, 90,  // tyv -> Cyrl
+    1224, 0,  // udi -> Aghb
+    1228, 90,  // udm -> Cyrl
+    1232, 10,  // ug -> Arab
+    1235, 90,  // ug_KZ -> Cyrl
+    1241, 90,  // ug_MN -> Cyrl
+    1247, 480,  // uga -> Ugar
+    1251, 90,  // uk -> Cyrl
+    1254, 40,  // unr -> Beng
+    1258, 95,  // unr_NP -> Deva
+    1265, 40,  // unx -> Beng
+    1269, 10,  // ur -> Arab
+    1272, 10,  // uz_AF -> Arab
+    1278, 90,  // uz_CN -> Cyrl
+    1284, 485,  // vai -> Vaii
+    1288, 105,  // wal -> Ethi
+    1292, 445,  // wbq -> Telu
+    1296, 95,  // wbr -> Deva
+    1300, 10,  // wni -> Arab
+    1304, 115,  // wsg -> Gong
+    1308, 95,  // wtm -> Deva
+    1312, 145,  // wuu -> Hans
+    1316, 75,  // xco -> Chrs
+    1320, 60,  // xcr -> Cari
+    1324, 245,  // xlc -> Lyci
+    1328, 250,  // xld -> Lydi
+    1332, 110,  // xmf -> Geor
+    1336, 260,  // xmn -> Mani
+    1340, 270,  // xmr -> Merc
+    1344, 295,  // xna -> Narb
+    1348, 95,  // xnr -> Deva
+    1352, 360,  // xpr -> Prti
+    1356, 380,  // xsa -> Sarb
+    1360, 95,  // xsr -> Deva
+    1364, 155,  // yi -> Hebr
+    1367, 150,  // yue -> Hant
+    1371, 145,  // yue_CN -> Hans
+    1378, 10,  // zdj -> Arab
+    1382, 450,  // zgh -> Tfng
+    1386, 145,  // zh -> Hans
+    1389, 150,  // zh_AU -> Hant
+    1395, 150,  // zh_BN -> Hant
+    1401, 150,  // zh_GB -> Hant
+    1407, 150,  // zh_GF -> Hant
+    1413, 150,  // zh_HK -> Hant
+    1419, 150,  // zh_ID -> Hant
+    1425, 150,  // zh_MO -> Hant
+    1431, 150,  // zh_PA -> Hant
+    1437, 150,  // zh_PF -> Hant
+    1443, 150,  // zh_PH -> Hant
+    1449, 150,  // zh_SR -> Hant
+    1455, 150,  // zh_TH -> Hant
+    1461, 150,  // zh_TW -> Hant
+    1467, 150,  // zh_US -> Hant
+    1473, 150,  // zh_VN -> Hant
+    1479, 305,  // zhx -> Nshu
+    1483, 205,  // zkt -> Kits
+};
+
+//======================================================================
+// Parent locale table
+const char parentLocaleChars[] =
+    "az_Arab\0az_Cyrl\0bal_Latn\0blt_Latn\0bm_Nkoo\0bs_Cyrl\0byn_Latn\0"
+    "cu_Glag\0dje_Arab\0dyo_Arab\0en_001\0en_150\0en_AG\0en_AI\0en_AT\0"
+    "en_AU\0en_BB\0en_BE\0en_BM\0en_BS\0en_BW\0en_BZ\0en_CC\0en_CH\0"
+    "en_CK\0en_CM\0en_CX\0en_CY\0en_DE\0en_DG\0en_DK\0en_DM\0en_Dsrt\0"
+    "en_ER\0en_FI\0en_FJ\0en_FK\0en_FM\0en_GB\0en_GD\0en_GG\0en_GH\0"
+    "en_GI\0en_GM\0en_GY\0en_HK\0en_IE\0en_IL\0en_IM\0en_IN\0en_IO\0"
+    "en_JE\0en_JM\0en_KE\0en_KI\0en_KN\0en_KY\0en_LC\0en_LR\0en_LS\0"
+    "en_MG\0en_MO\0en_MS\0en_MT\0en_MU\0en_MV\0en_MW\0en_MY\0en_NA\0"
+    "en_NF\0en_NG\0en_NL\0en_NR\0en_NU\0en_NZ\0en_PG\0en_PK\0en_PN\0"
+    "en_PW\0en_RW\0en_SB\0en_SC\0en_SD\0en_SE\0en_SG\0en_SH\0en_SI\0"
+    "en_SL\0en_SS\0en_SX\0en_SZ\0en_Shaw\0en_TC\0en_TK\0en_TO\0en_TT\0"
+    "en_TV\0en_TZ\0en_UG\0en_VC\0en_VG\0en_VU\0en_WS\0en_ZA\0en_ZM\0"
+    "en_ZW\0es_419\0es_AR\0es_BO\0es_BR\0es_BZ\0es_CL\0es_CO\0es_CR\0"
+    "es_CU\0es_DO\0es_EC\0es_GT\0es_HN\0es_MX\0es_NI\0es_PA\0es_PE\0"
+    "es_PR\0es_PY\0es_SV\0es_US\0es_UY\0es_VE\0ff_Adlm\0ff_Arab\0fr_HT\0"
+    "ha_Arab\0hi_Latn\0ht\0iu_Latn\0kk_Arab\0ks_Deva\0ku_Arab\0ky_Arab\0"
+    "ky_Latn\0ml_Arab\0mn_Mong\0mni_Mtei\0ms_Arab\0nb\0nn\0no\0pa_Arab\0"
+    "pt_AO\0pt_CH\0pt_CV\0pt_FR\0pt_GQ\0pt_GW\0pt_LU\0pt_MO\0pt_MZ\0"
+    "pt_PT\0pt_ST\0pt_TL\0root\0sat_Deva\0sd_Deva\0sd_Khoj\0sd_Sind\0"
+    "shi_Latn\0so_Arab\0sr_Latn\0sw_Arab\0tg_Arab\0ug_Cyrl\0uz_Arab\0"
+    "uz_Cyrl\0vai_Latn\0wo_Arab\0yo_Arab\0yue_Hans\0zh_Hant\0zh_Hant_HK\0"
+    "zh_Hant_MO\0";
+
+const int32_t parentLocaleTable[] = {
+    0, 1017,  // az_Arab -> root
+    8, 1017,  // az_Cyrl -> root
+    16, 1017,  // bal_Latn -> root
+    25, 1017,  // blt_Latn -> root
+    34, 1017,  // bm_Nkoo -> root
+    42, 1017,  // bs_Cyrl -> root
+    50, 1017,  // byn_Latn -> root
+    59, 1017,  // cu_Glag -> root
+    67, 1017,  // dje_Arab -> root
+    76, 1017,  // dyo_Arab -> root
+    92, 85,  // en_150 -> en_001
+    99, 85,  // en_AG -> en_001
+    105, 85,  // en_AI -> en_001
+    111, 92,  // en_AT -> en_150
+    117, 85,  // en_AU -> en_001
+    123, 85,  // en_BB -> en_001
+    129, 92,  // en_BE -> en_150
+    135, 85,  // en_BM -> en_001
+    141, 85,  // en_BS -> en_001
+    147, 85,  // en_BW -> en_001
+    153, 85,  // en_BZ -> en_001
+    159, 85,  // en_CC -> en_001
+    165, 92,  // en_CH -> en_150
+    171, 85,  // en_CK -> en_001
+    177, 85,  // en_CM -> en_001
+    183, 85,  // en_CX -> en_001
+    189, 85,  // en_CY -> en_001
+    195, 92,  // en_DE -> en_150
+    201, 85,  // en_DG -> en_001
+    207, 92,  // en_DK -> en_150
+    213, 85,  // en_DM -> en_001
+    219, 1017,  // en_Dsrt -> root
+    227, 85,  // en_ER -> en_001
+    233, 92,  // en_FI -> en_150
+    239, 85,  // en_FJ -> en_001
+    245, 85,  // en_FK -> en_001
+    251, 85,  // en_FM -> en_001
+    257, 85,  // en_GB -> en_001
+    263, 85,  // en_GD -> en_001
+    269, 85,  // en_GG -> en_001
+    275, 85,  // en_GH -> en_001
+    281, 85,  // en_GI -> en_001
+    287, 85,  // en_GM -> en_001
+    293, 85,  // en_GY -> en_001
+    299, 85,  // en_HK -> en_001
+    305, 85,  // en_IE -> en_001
+    311, 85,  // en_IL -> en_001
+    317, 85,  // en_IM -> en_001
+    323, 85,  // en_IN -> en_001
+    329, 85,  // en_IO -> en_001
+    335, 85,  // en_JE -> en_001
+    341, 85,  // en_JM -> en_001
+    347, 85,  // en_KE -> en_001
+    353, 85,  // en_KI -> en_001
+    359, 85,  // en_KN -> en_001
+    365, 85,  // en_KY -> en_001
+    371, 85,  // en_LC -> en_001
+    377, 85,  // en_LR -> en_001
+    383, 85,  // en_LS -> en_001
+    389, 85,  // en_MG -> en_001
+    395, 85,  // en_MO -> en_001
+    401, 85,  // en_MS -> en_001
+    407, 85,  // en_MT -> en_001
+    413, 85,  // en_MU -> en_001
+    419, 85,  // en_MV -> en_001
+    425, 85,  // en_MW -> en_001
+    431, 85,  // en_MY -> en_001
+    437, 85,  // en_NA -> en_001
+    443, 85,  // en_NF -> en_001
+    449, 85,  // en_NG -> en_001
+    455, 92,  // en_NL -> en_150
+    461, 85,  // en_NR -> en_001
+    467, 85,  // en_NU -> en_001
+    473, 85,  // en_NZ -> en_001
+    479, 85,  // en_PG -> en_001
+    485, 85,  // en_PK -> en_001
+    491, 85,  // en_PN -> en_001
+    497, 85,  // en_PW -> en_001
+    503, 85,  // en_RW -> en_001
+    509, 85,  // en_SB -> en_001
+    515, 85,  // en_SC -> en_001
+    521, 85,  // en_SD -> en_001
+    527, 92,  // en_SE -> en_150
+    533, 85,  // en_SG -> en_001
+    539, 85,  // en_SH -> en_001
+    545, 92,  // en_SI -> en_150
+    551, 85,  // en_SL -> en_001
+    557, 85,  // en_SS -> en_001
+    563, 85,  // en_SX -> en_001
+    569, 85,  // en_SZ -> en_001
+    575, 1017,  // en_Shaw -> root
+    583, 85,  // en_TC -> en_001
+    589, 85,  // en_TK -> en_001
+    595, 85,  // en_TO -> en_001
+    601, 85,  // en_TT -> en_001
+    607, 85,  // en_TV -> en_001
+    613, 85,  // en_TZ -> en_001
+    619, 85,  // en_UG -> en_001
+    625, 85,  // en_VC -> en_001
+    631, 85,  // en_VG -> en_001
+    637, 85,  // en_VU -> en_001
+    643, 85,  // en_WS -> en_001
+    649, 85,  // en_ZA -> en_001
+    655, 85,  // en_ZM -> en_001
+    661, 85,  // en_ZW -> en_001
+    674, 667,  // es_AR -> es_419
+    680, 667,  // es_BO -> es_419
+    686, 667,  // es_BR -> es_419
+    692, 667,  // es_BZ -> es_419
+    698, 667,  // es_CL -> es_419
+    704, 667,  // es_CO -> es_419
+    710, 667,  // es_CR -> es_419
+    716, 667,  // es_CU -> es_419
+    722, 667,  // es_DO -> es_419
+    728, 667,  // es_EC -> es_419
+    734, 667,  // es_GT -> es_419
+    740, 667,  // es_HN -> es_419
+    746, 667,  // es_MX -> es_419
+    752, 667,  // es_NI -> es_419
+    758, 667,  // es_PA -> es_419
+    764, 667,  // es_PE -> es_419
+    770, 667,  // es_PR -> es_419
+    776, 667,  // es_PY -> es_419
+    782, 667,  // es_SV -> es_419
+    788, 667,  // es_US -> es_419
+    794, 667,  // es_UY -> es_419
+    800, 667,  // es_VE -> es_419
+    806, 1017,  // ff_Adlm -> root
+    814, 1017,  // ff_Arab -> root
+    828, 1017,  // ha_Arab -> root
+    836, 323,  // hi_Latn -> en_IN
+    844, 822,  // ht -> fr_HT
+    847, 1017,  // iu_Latn -> root
+    855, 1017,  // kk_Arab -> root
+    863, 1017,  // ks_Deva -> root
+    871, 1017,  // ku_Arab -> root
+    879, 1017,  // ky_Arab -> root
+    887, 1017,  // ky_Latn -> root
+    895, 1017,  // ml_Arab -> root
+    903, 1017,  // mn_Mong -> root
+    911, 1017,  // mni_Mtei -> root
+    920, 1017,  // ms_Arab -> root
+    928, 934,  // nb -> no
+    931, 934,  // nn -> no
+    937, 1017,  // pa_Arab -> root
+    945, 999,  // pt_AO -> pt_PT
+    951, 999,  // pt_CH -> pt_PT
+    957, 999,  // pt_CV -> pt_PT
+    963, 999,  // pt_FR -> pt_PT
+    969, 999,  // pt_GQ -> pt_PT
+    975, 999,  // pt_GW -> pt_PT
+    981, 999,  // pt_LU -> pt_PT
+    987, 999,  // pt_MO -> pt_PT
+    993, 999,  // pt_MZ -> pt_PT
+    1005, 999,  // pt_ST -> pt_PT
+    1011, 999,  // pt_TL -> pt_PT
+    1022, 1017,  // sat_Deva -> root
+    1031, 1017,  // sd_Deva -> root
+    1039, 1017,  // sd_Khoj -> root
+    1047, 1017,  // sd_Sind -> root
+    1055, 1017,  // shi_Latn -> root
+    1064, 1017,  // so_Arab -> root
+    1072, 1017,  // sr_Latn -> root
+    1080, 1017,  // sw_Arab -> root
+    1088, 1017,  // tg_Arab -> root
+    1096, 1017,  // ug_Cyrl -> root
+    1104, 1017,  // uz_Arab -> root
+    1112, 1017,  // uz_Cyrl -> root
+    1120, 1017,  // vai_Latn -> root
+    1129, 1017,  // wo_Arab -> root
+    1137, 1017,  // yo_Arab -> root
+    1145, 1017,  // yue_Hans -> root
+    1154, 1017,  // zh_Hant -> root
+    1173, 1162,  // zh_Hant_MO -> zh_Hant_HK
+};
+
+
+#endif  // INCLUDED_FROM_URESBUND_CPP
diff --git a/deps/icu-small/source/common/localematcher.cpp b/deps/icu-small/source/common/localematcher.cpp
index 2cad708d99..2f8664b6f7 100644
--- a/deps/icu-small/source/common/localematcher.cpp
+++ b/deps/icu-small/source/common/localematcher.cpp
@@ -60,7 +60,7 @@ LocaleMatcher::Result::Result(LocaleMatcher::Result &&src) U_NOEXCEPT :
     if (desiredIsOwned) {
         src.desiredLocale = nullptr;
         src.desiredIndex = -1;
-        src.desiredIsOwned = FALSE;
+        src.desiredIsOwned = false;
     }
 }
 
@@ -82,7 +82,7 @@ LocaleMatcher::Result &LocaleMatcher::Result::operator=(LocaleMatcher::Result &&
     if (desiredIsOwned) {
         src.desiredLocale = nullptr;
         src.desiredIndex = -1;
-        src.desiredIsOwned = FALSE;
+        src.desiredIsOwned = false;
     }
     return *this;
 }
@@ -287,10 +287,10 @@ LocaleMatcher::Builder &LocaleMatcher::Builder::internalSetThresholdDistance(int
 #endif
 
 UBool LocaleMatcher::Builder::copyErrorTo(UErrorCode &outErrorCode) const {
-    if (U_FAILURE(outErrorCode)) { return TRUE; }
-    if (U_SUCCESS(errorCode_)) { return FALSE; }
+    if (U_FAILURE(outErrorCode)) { return true; }
+    if (U_SUCCESS(errorCode_)) { return false; }
     outErrorCode = errorCode_;
-    return TRUE;
+    return true;
 }
 
 LocaleMatcher LocaleMatcher::Builder::build(UErrorCode &errorCode) const {
@@ -632,30 +632,30 @@ const Locale *LocaleMatcher::getBestMatchForListString(
 LocaleMatcher::Result LocaleMatcher::getBestMatchResult(
         const Locale &desiredLocale, UErrorCode &errorCode) const {
     if (U_FAILURE(errorCode)) {
-        return Result(nullptr, defaultLocale, -1, -1, FALSE);
+        return Result(nullptr, defaultLocale, -1, -1, false);
     }
     int32_t suppIndex = getBestSuppIndex(
         getMaximalLsrOrUnd(likelySubtags, desiredLocale, errorCode),
         nullptr, errorCode);
     if (U_FAILURE(errorCode) || suppIndex < 0) {
-        return Result(nullptr, defaultLocale, -1, -1, FALSE);
+        return Result(nullptr, defaultLocale, -1, -1, false);
     } else {
-        return Result(&desiredLocale, supportedLocales[suppIndex], 0, suppIndex, FALSE);
+        return Result(&desiredLocale, supportedLocales[suppIndex], 0, suppIndex, false);
     }
 }
 
 LocaleMatcher::Result LocaleMatcher::getBestMatchResult(
         Locale::Iterator &desiredLocales, UErrorCode &errorCode) const {
     if (U_FAILURE(errorCode) || !desiredLocales.hasNext()) {
-        return Result(nullptr, defaultLocale, -1, -1, FALSE);
+        return Result(nullptr, defaultLocale, -1, -1, false);
     }
     LocaleLsrIterator lsrIter(likelySubtags, desiredLocales, ULOCMATCH_TEMPORARY_LOCALES);
     int32_t suppIndex = getBestSuppIndex(lsrIter.next(errorCode), &lsrIter, errorCode);
     if (U_FAILURE(errorCode) || suppIndex < 0) {
-        return Result(nullptr, defaultLocale, -1, -1, FALSE);
+        return Result(nullptr, defaultLocale, -1, -1, false);
     } else {
         return Result(lsrIter.orphanRemembered(), supportedLocales[suppIndex],
-                      lsrIter.getBestDesiredIndex(), suppIndex, TRUE);
+                      lsrIter.getBestDesiredIndex(), suppIndex, true);
     }
 }
 
diff --git a/deps/icu-small/source/common/localeprioritylist.cpp b/deps/icu-small/source/common/localeprioritylist.cpp
index 4455eedb75..e5ba0a3c77 100644
--- a/deps/icu-small/source/common/localeprioritylist.cpp
+++ b/deps/icu-small/source/common/localeprioritylist.cpp
@@ -234,7 +234,7 @@ void LocalePriorityList::sort(UErrorCode &errorCode) {
     // The comparator forces a stable sort via the item index.
     if (U_FAILURE(errorCode) || getLength() <= 1 || !hasWeights) { return; }
     uprv_sortArray(list->array.getAlias(), listLength, sizeof(LocaleAndWeight),
-                   compareLocaleAndWeight, nullptr, FALSE, &errorCode);
+                   compareLocaleAndWeight, nullptr, false, &errorCode);
 }
 
 U_NAMESPACE_END
diff --git a/deps/icu-small/source/common/locavailable.cpp b/deps/icu-small/source/common/locavailable.cpp
index e8ec512e37..cf341e1f74 100644
--- a/deps/icu-small/source/common/locavailable.cpp
+++ b/deps/icu-small/source/common/locavailable.cpp
@@ -37,7 +37,7 @@ U_NAMESPACE_BEGIN
 
 static icu::Locale*  availableLocaleList = NULL;
 static int32_t  availableLocaleListCount;
-static icu::UInitOnce gInitOnceLocale = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gInitOnceLocale {};
 
 U_NAMESPACE_END
 
@@ -54,7 +54,7 @@ static UBool U_CALLCONV locale_available_cleanup(void)
     availableLocaleListCount = 0;
     gInitOnceLocale.reset();
 
-    return TRUE;
+    return true;
 }
 
 U_CDECL_END
@@ -102,7 +102,7 @@ namespace {
 // Enough capacity for the two lists in the res_index.res file
 const char** gAvailableLocaleNames[2] = {};
 int32_t gAvailableLocaleCounts[2] = {};
-icu::UInitOnce ginstalledLocalesInitOnce = U_INITONCE_INITIALIZER;
+icu::UInitOnce ginstalledLocalesInitOnce {};
 
 class AvailableLocalesSink : public ResourceSink {
   public:
@@ -203,7 +203,7 @@ static UBool U_CALLCONV uloc_cleanup(void) {
         gAvailableLocaleCounts[i] = 0;
     }
     ginstalledLocalesInitOnce.reset();
-    return TRUE;
+    return true;
 }
 
 // Load Installed Locales. This function will be called exactly once
diff --git a/deps/icu-small/source/common/locdispnames.cpp b/deps/icu-small/source/common/locdispnames.cpp
index c512a0164c..637556cc71 100644
--- a/deps/icu-small/source/common/locdispnames.cpp
+++ b/deps/icu-small/source/common/locdispnames.cpp
@@ -514,11 +514,11 @@ uloc_getDisplayName(const char *locale,
     UChar formatCloseParen        = 0x0029; // )
     UChar formatReplaceCloseParen = 0x005D; // ]
 
-    UBool haveLang = TRUE; /* assume true, set false if we find we don't have
+    UBool haveLang = true; /* assume true, set false if we find we don't have
                               a lang component in the locale */
-    UBool haveRest = TRUE; /* assume true, set false if we find we don't have
+    UBool haveRest = true; /* assume true, set false if we find we don't have
                               any other component in the locale */
-    UBool retry = FALSE; /* set true if we need to retry, see below */
+    UBool retry = false; /* set true if we need to retry, see below */
 
     int32_t langi = 0; /* index of the language substitution (0 or 1), virtually always 0 */
 
@@ -625,7 +625,7 @@ uloc_getDisplayName(const char *locale,
         }
 
         for(int32_t subi=0,resti=0;subi<2;) { /* iterate through patterns 0 and 1*/
-            UBool subdone = FALSE; /* set true when ready to move to next substitution */
+            UBool subdone = false; /* set true when ready to move to next substitution */
 
             /* prep p and cap for calls to get display components, pin cap to 0 since
                they complain if cap is negative */
@@ -643,10 +643,10 @@ uloc_getDisplayName(const char *locale,
                     length+=langLen;
                     haveLang=langLen>0;
                 }
-                subdone=TRUE;
+                subdone=true;
             } else { /* {1} */
                 if(!haveRest) {
-                    subdone=TRUE;
+                    subdone=true;
                 } else {
                     int32_t len; /* length of component (plus other stuff) we just fetched */
                     switch(resti++) {
@@ -667,7 +667,7 @@ uloc_getDisplayName(const char *locale,
                             const char* kw=uenum_next(kenum.getAlias(), &len, pErrorCode);
                             if (kw == NULL) {
                                 len=0; /* mark that we didn't add a component */
-                                subdone=TRUE;
+                                subdone=true;
                             } else {
                                 /* incorporating this behavior into the loop made it even more complex,
                                    so just special case it here */
@@ -772,7 +772,7 @@ uloc_getDisplayName(const char *locale,
                             /* would have fit, but didn't because of pattern prefix. */
                             sub0Pos=0; /* stops initial padding (and a second retry,
                                           so we won't end up here again) */
-                            retry=TRUE;
+                            retry=true;
                         }
                     }
                 }
diff --git a/deps/icu-small/source/common/locdistance.cpp b/deps/icu-small/source/common/locdistance.cpp
index ff8892791b..fb22fe79ed 100644
--- a/deps/icu-small/source/common/locdistance.cpp
+++ b/deps/icu-small/source/common/locdistance.cpp
@@ -45,13 +45,13 @@ enum {
 };
 
 LocaleDistance *gLocaleDistance = nullptr;
-UInitOnce gInitOnce = U_INITONCE_INITIALIZER;
+UInitOnce gInitOnce {};
 
 UBool U_CALLCONV cleanup() {
     delete gLocaleDistance;
     gLocaleDistance = nullptr;
     gInitOnce.reset();
-    return TRUE;
+    return true;
 }
 
 }  // namespace
diff --git a/deps/icu-small/source/common/locdspnm.cpp b/deps/icu-small/source/common/locdspnm.cpp
index f73cedd728..401f1fecbf 100644
--- a/deps/icu-small/source/common/locdspnm.cpp
+++ b/deps/icu-small/source/common/locdspnm.cpp
@@ -403,7 +403,7 @@ struct LocaleDisplayNamesImpl::CapitalizationContextSink : public ResourceSink {
     LocaleDisplayNamesImpl& parent;
 
     CapitalizationContextSink(LocaleDisplayNamesImpl& _parent)
-      : hasCapitalizationUsage(FALSE), parent(_parent) {}
+      : hasCapitalizationUsage(false), parent(_parent) {}
     virtual ~CapitalizationContextSink();
 
     virtual void put(const char *key, ResourceValue &value, UBool /*noFallback*/,
@@ -437,8 +437,8 @@ struct LocaleDisplayNamesImpl::CapitalizationContextSink : public ResourceSink {
             int32_t titlecaseInt = (parent.capitalizationContext == UDISPCTX_CAPITALIZATION_FOR_UI_LIST_OR_MENU) ? intVector[0] : intVector[1];
             if (titlecaseInt == 0) { continue; }
 
-            parent.fCapitalization[usageEnum] = TRUE;
-            hasCapitalizationUsage = TRUE;
+            parent.fCapitalization[usageEnum] = true;
+            hasCapitalizationUsage = true;
         }
     }
 };
@@ -490,7 +490,7 @@ LocaleDisplayNamesImpl::initialize(void) {
 #if !UCONFIG_NO_BREAK_ITERATION
     // Only get the context data if we need it! This is a const object so we know now...
     // Also check whether we will need a break iterator (depends on the data)
-    UBool needBrkIter = FALSE;
+    UBool needBrkIter = false;
     if (capitalizationContext == UDISPCTX_CAPITALIZATION_FOR_UI_LIST_OR_MENU || capitalizationContext == UDISPCTX_CAPITALIZATION_FOR_STANDALONE) {
         LocalUResourceBundlePointer resource(ures_open(NULL, locale.getName(), &status));
         if (U_FAILURE(status)) { return; }
@@ -593,8 +593,8 @@ LocaleDisplayNamesImpl::localeDisplayName(const Locale& loc,
         ncat(buffer, ULOC_FULLNAME_CAPACITY, lang, "_", script, "_", country, (char *)0);
         localeIdName(buffer, resultName, false);
         if (!resultName.isBogus()) {
-          hasScript = FALSE;
-          hasCountry = FALSE;
+          hasScript = false;
+          hasCountry = false;
           break;
         }
       }
@@ -602,7 +602,7 @@ LocaleDisplayNamesImpl::localeDisplayName(const Locale& loc,
         ncat(buffer, ULOC_FULLNAME_CAPACITY, lang, "_", script, (char *)0);
         localeIdName(buffer, resultName, false);
         if (!resultName.isBogus()) {
-          hasScript = FALSE;
+          hasScript = false;
           break;
         }
       }
@@ -610,11 +610,11 @@ LocaleDisplayNamesImpl::localeDisplayName(const Locale& loc,
         ncat(buffer, ULOC_FULLNAME_CAPACITY, lang, "_", country, (char*)0);
         localeIdName(buffer, resultName, false);
         if (!resultName.isBogus()) {
-          hasCountry = FALSE;
+          hasCountry = false;
           break;
         }
       }
-    } while (FALSE);
+    } while (false);
   }
   if (resultName.isBogus() || resultName.isEmpty()) {
     localeIdName(lang, resultName, substitute == UDISPCTX_SUBSTITUTE);
@@ -629,7 +629,7 @@ LocaleDisplayNamesImpl::localeDisplayName(const Locale& loc,
   UErrorCode status = U_ZERO_ERROR;
 
   if (hasScript) {
-    UnicodeString script_str = scriptDisplayName(script, temp, TRUE);
+    UnicodeString script_str = scriptDisplayName(script, temp, true);
     if (script_str.isBogus()) {
       result.setToBogus();
       return result;
@@ -637,7 +637,7 @@ LocaleDisplayNamesImpl::localeDisplayName(const Locale& loc,
     resultRemainder.append(script_str);
   }
   if (hasCountry) {
-    UnicodeString region_str = regionDisplayName(country, temp, TRUE);
+    UnicodeString region_str = regionDisplayName(country, temp, true);
     if (region_str.isBogus()) {
       result.setToBogus();
       return result;
@@ -645,7 +645,7 @@ LocaleDisplayNamesImpl::localeDisplayName(const Locale& loc,
     appendWithSep(resultRemainder, region_str);
   }
   if (hasVariant) {
-    UnicodeString variant_str = variantDisplayName(variant, temp, TRUE);
+    UnicodeString variant_str = variantDisplayName(variant, temp, true);
     if (variant_str.isBogus()) {
       result.setToBogus();
       return result;
@@ -666,10 +666,10 @@ LocaleDisplayNamesImpl::localeDisplayName(const Locale& loc,
       if (U_FAILURE(status) || status == U_STRING_NOT_TERMINATED_WARNING) {
         return result;
       }
-      keyDisplayName(key, temp, TRUE);
+      keyDisplayName(key, temp, true);
       temp.findAndReplace(formatOpenParen, formatReplaceOpenParen);
       temp.findAndReplace(formatCloseParen, formatReplaceCloseParen);
-      keyValueDisplayName(key, value, temp2, TRUE);
+      keyValueDisplayName(key, value, temp2, true);
       temp2.findAndReplace(formatOpenParen, formatReplaceOpenParen);
       temp2.findAndReplace(formatCloseParen, formatReplaceCloseParen);
       if (temp2 != UnicodeString(value, -1, US_INV)) {
@@ -797,13 +797,13 @@ LocaleDisplayNamesImpl::scriptDisplayName(const char* script,
 UnicodeString&
 LocaleDisplayNamesImpl::scriptDisplayName(const char* script,
                                           UnicodeString& result) const {
-    return scriptDisplayName(script, result, FALSE);
+    return scriptDisplayName(script, result, false);
 }
 
 UnicodeString&
 LocaleDisplayNamesImpl::scriptDisplayName(UScriptCode scriptCode,
                                           UnicodeString& result) const {
-    return scriptDisplayName(uscript_getName(scriptCode), result, FALSE);
+    return scriptDisplayName(uscript_getName(scriptCode), result, false);
 }
 
 UnicodeString&
@@ -827,7 +827,7 @@ LocaleDisplayNamesImpl::regionDisplayName(const char* region,
 UnicodeString&
 LocaleDisplayNamesImpl::regionDisplayName(const char* region,
                                           UnicodeString& result) const {
-    return regionDisplayName(region, result, FALSE);
+    return regionDisplayName(region, result, false);
 }
 
 
@@ -847,7 +847,7 @@ LocaleDisplayNamesImpl::variantDisplayName(const char* variant,
 UnicodeString&
 LocaleDisplayNamesImpl::variantDisplayName(const char* variant,
                                            UnicodeString& result) const {
-    return variantDisplayName(variant, result, FALSE);
+    return variantDisplayName(variant, result, false);
 }
 
 UnicodeString&
@@ -866,7 +866,7 @@ LocaleDisplayNamesImpl::keyDisplayName(const char* key,
 UnicodeString&
 LocaleDisplayNamesImpl::keyDisplayName(const char* key,
                                        UnicodeString& result) const {
-    return keyDisplayName(key, result, FALSE);
+    return keyDisplayName(key, result, false);
 }
 
 UnicodeString&
@@ -908,7 +908,7 @@ UnicodeString&
 LocaleDisplayNamesImpl::keyValueDisplayName(const char* key,
                                             const char* value,
                                             UnicodeString& result) const {
-    return keyValueDisplayName(key, value, result, FALSE);
+    return keyValueDisplayName(key, value, result, false);
 }
 
 ////////////////////////////////////////////////////////////////////////////////////////////////////
diff --git a/deps/icu-small/source/common/locid.cpp b/deps/icu-small/source/common/locid.cpp
index 73bb8d8aec..5cd083866c 100644
--- a/deps/icu-small/source/common/locid.cpp
+++ b/deps/icu-small/source/common/locid.cpp
@@ -64,7 +64,7 @@ U_CDECL_END
 U_NAMESPACE_BEGIN
 
 static Locale   *gLocaleCache = NULL;
-static UInitOnce gLocaleCacheInitOnce = U_INITONCE_INITIALIZER;
+static UInitOnce gLocaleCacheInitOnce {};
 
 // gDefaultLocaleMutex protects all access to gDefaultLocalesHashT and gDefaultLocale.
 static UMutex gDefaultLocaleMutex;
@@ -128,7 +128,7 @@ static UBool U_CALLCONV locale_cleanup(void)
         gDefaultLocalesHashT = NULL;
     }
     gDefaultLocale = NULL;
-    return TRUE;
+    return true;
 }
 
 
@@ -171,7 +171,7 @@ Locale *locale_set_default_internal(const char *id, UErrorCode& status) {
     // Synchronize this entire function.
     Mutex lock(&gDefaultLocaleMutex);
 
-    UBool canonicalize = FALSE;
+    UBool canonicalize = false;
 
     // If given a NULL string for the locale id, grab the default
     //   name from the system.
@@ -179,7 +179,7 @@ Locale *locale_set_default_internal(const char *id, UErrorCode& status) {
     //    the current ICU default locale.)
     if (id == NULL) {
         id = uprv_getDefaultLocaleID();   // This function not thread safe? TODO: verify.
-        canonicalize = TRUE; // always canonicalize host ID
+        canonicalize = true; // always canonicalize host ID
     }
 
     CharString localeNameBuf;
@@ -212,7 +212,7 @@ Locale *locale_set_default_internal(const char *id, UErrorCode& status) {
             status = U_MEMORY_ALLOCATION_ERROR;
             return gDefaultLocale;
         }
-        newDefault->init(localeNameBuf.data(), FALSE);
+        newDefault->init(localeNameBuf.data(), false);
         uhash_put(gDefaultLocalesHashT, (char*) newDefault->getName(), newDefault, &status);
         if (U_FAILURE(status)) {
             return gDefaultLocale;
@@ -269,7 +269,7 @@ Locale::~Locale()
 Locale::Locale()
     : UObject(), fullName(fullNameBuffer), baseName(NULL)
 {
-    init(NULL, FALSE);
+    init(NULL, false);
 }
 
 /*
@@ -292,7 +292,7 @@ Locale::Locale( const   char * newLanguage,
 {
     if( (newLanguage==NULL) && (newCountry == NULL) && (newVariant == NULL) )
     {
-        init(NULL, FALSE); /* shortcut */
+        init(NULL, false); /* shortcut */
     }
     else
     {
@@ -397,7 +397,7 @@ Locale::Locale( const   char * newLanguage,
         }
         // Parse it, because for example 'language' might really be a complete
         // string.
-        init(togo.data(), FALSE);
+        init(togo.data(), false);
     }
 }
 
@@ -491,7 +491,7 @@ Locale::operator==( const   Locale& other) const
 
 namespace {
 
-UInitOnce gKnownCanonicalizedInitOnce = U_INITONCE_INITIALIZER;
+UInitOnce gKnownCanonicalizedInitOnce {};
 UHashtable *gKnownCanonicalized = nullptr;
 
 static const char* const KNOWN_CANONICALIZED[] = {
@@ -521,7 +521,7 @@ static const char* const KNOWN_CANONICALIZED[] = {
 static UBool U_CALLCONV cleanupKnownCanonicalized() {
     gKnownCanonicalizedInitOnce.reset();
     if (gKnownCanonicalized) { uhash_close(gKnownCanonicalized); }
-    return TRUE;
+    return true;
 }
 
 static void U_CALLCONV loadKnownCanonicalized(UErrorCode &status) {
@@ -682,14 +682,14 @@ private:
 
 
 const AliasData* AliasData::gSingleton = nullptr;
-UInitOnce AliasData::gInitOnce = U_INITONCE_INITIALIZER;
+UInitOnce AliasData::gInitOnce {};
 
 UBool U_CALLCONV
 AliasData::cleanup()
 {
     gInitOnce.reset();
     delete gSingleton;
-    return TRUE;
+    return true;
 }
 
 void
@@ -716,20 +716,19 @@ AliasDataBuilder::readAlias(
         status = U_MEMORY_ALLOCATION_ERROR;
         return;
     }
-    int i = 0;
-    while (ures_hasNext(alias)) {
+    for (int i = 0; U_SUCCESS(status) && ures_hasNext(alias); i++) {
         LocalUResourceBundlePointer res(
             ures_getNextResource(alias, nullptr, &status));
         const char* aliasFrom = ures_getKey(res.getAlias());
         UnicodeString aliasTo =
             ures_getUnicodeStringByKey(res.getAlias(), "replacement", &status);
+        if (U_FAILURE(status)) return;
 
         checkType(aliasFrom);
         checkReplacement(aliasTo);
 
         rawTypes[i] = aliasFrom;
         rawIndexes[i] = strings->add(aliasTo, status);
-        i++;
     }
 }
 
@@ -1818,7 +1817,7 @@ ulocimp_isCanonicalizedLocaleForTest(const char* localeName)
 /*This function initializes a Locale from a C locale ID*/
 Locale& Locale::init(const char* localeID, UBool canonicalize)
 {
-    fIsBogus = FALSE;
+    fIsBogus = false;
     /* Free our current storage */
     if ((baseName != fullName) && (baseName != fullNameBuffer)) {
         uprv_free(baseName);
@@ -2022,7 +2021,7 @@ Locale::setToBogus() {
     *language = 0;
     *script = 0;
     *country = 0;
-    fIsBogus = TRUE;
+    fIsBogus = true;
     variantBegin = 0;
 }
 
@@ -2072,7 +2071,7 @@ Locale::addLikelySubtags(UErrorCode& status) {
         return;
     }
 
-    init(maximizedLocaleID.data(), /*canonicalize=*/FALSE);
+    init(maximizedLocaleID.data(), /*canonicalize=*/false);
     if (isBogus()) {
         status = U_ILLEGAL_ARGUMENT_ERROR;
     }
@@ -2094,7 +2093,7 @@ Locale::minimizeSubtags(UErrorCode& status) {
         return;
     }
 
-    init(minimizedLocaleID.data(), /*canonicalize=*/FALSE);
+    init(minimizedLocaleID.data(), /*canonicalize=*/false);
     if (isBogus()) {
         status = U_ILLEGAL_ARGUMENT_ERROR;
     }
@@ -2113,7 +2112,7 @@ Locale::canonicalize(UErrorCode& status) {
     if (U_FAILURE(status)) {
         return;
     }
-    init(uncanonicalized.data(), /*canonicalize=*/TRUE);
+    init(uncanonicalized.data(), /*canonicalize=*/true);
     if (isBogus()) {
         status = U_ILLEGAL_ARGUMENT_ERROR;
     }
@@ -2160,7 +2159,7 @@ Locale::forLanguageTag(StringPiece tag, UErrorCode& status)
         return result;
     }
 
-    result.init(localeID.data(), /*canonicalize=*/FALSE);
+    result.init(localeID.data(), /*canonicalize=*/false);
     if (result.isBogus()) {
         status = U_ILLEGAL_ARGUMENT_ERROR;
     }
@@ -2179,7 +2178,7 @@ Locale::toLanguageTag(ByteSink& sink, UErrorCode& status) const
         return;
     }
 
-    ulocimp_toLanguageTag(fullName, sink, /*strict=*/FALSE, &status);
+    ulocimp_toLanguageTag(fullName, sink, /*strict=*/false, &status);
 }
 
 Locale U_EXPORT2
@@ -2187,7 +2186,7 @@ Locale::createFromName (const char *name)
 {
     if (name) {
         Locale l("");
-        l.init(name, FALSE);
+        l.init(name, false);
         return l;
     }
     else {
@@ -2198,7 +2197,7 @@ Locale::createFromName (const char *name)
 Locale U_EXPORT2
 Locale::createCanonical(const char* name) {
     Locale loc("");
-    loc.init(name, TRUE);
+    loc.init(name, true);
     return loc;
 }
 
@@ -2241,7 +2240,7 @@ const char* const* U_EXPORT2 Locale::getISOLanguages()
 // Set the locale's data based on a posix id.
 void Locale::setFromPOSIXID(const char *posixID)
 {
-    init(posixID, TRUE);
+    init(posixID, true);
 }
 
 const Locale & U_EXPORT2
@@ -2531,7 +2530,7 @@ Locale::createKeywords(UErrorCode &status) const
         if(assignment > variantStart) {
             CharString keywords;
             CharStringByteSink sink(&keywords);
-            ulocimp_getKeywords(variantStart+1, '@', sink, FALSE, &status);
+            ulocimp_getKeywords(variantStart+1, '@', sink, false, &status);
             if (U_SUCCESS(status) && !keywords.isEmpty()) {
                 result = new KeywordEnumeration(keywords.data(), keywords.length(), 0, status);
                 if (!result) {
@@ -2560,7 +2559,7 @@ Locale::createUnicodeKeywords(UErrorCode &status) const
         if(assignment > variantStart) {
             CharString keywords;
             CharStringByteSink sink(&keywords);
-            ulocimp_getKeywords(variantStart+1, '@', sink, FALSE, &status);
+            ulocimp_getKeywords(variantStart+1, '@', sink, false, &status);
             if (U_SUCCESS(status) && !keywords.isEmpty()) {
                 result = new UnicodeKeywordEnumeration(keywords.data(), keywords.length(), 0, status);
                 if (!result) {
diff --git a/deps/icu-small/source/common/loclikely.cpp b/deps/icu-small/source/common/loclikely.cpp
index d80096b588..ec0dca28a4 100644
--- a/deps/icu-small/source/common/loclikely.cpp
+++ b/deps/icu-small/source/common/loclikely.cpp
@@ -201,7 +201,7 @@ createTagStringWithAlternates(
          **/
         char tagBuffer[ULOC_FULLNAME_CAPACITY];
         int32_t tagLength = 0;
-        UBool regionAppended = FALSE;
+        UBool regionAppended = false;
 
         if (langLength > 0) {
             appendTag(
@@ -209,7 +209,7 @@ createTagStringWithAlternates(
                 langLength,
                 tagBuffer,
                 &tagLength,
-                /*withSeparator=*/FALSE);
+                /*withSeparator=*/false);
         }
         else if (alternateTags == NULL) {
             /*
@@ -246,7 +246,7 @@ createTagStringWithAlternates(
                     alternateLangLength,
                     tagBuffer,
                     &tagLength,
-                    /*withSeparator=*/FALSE);
+                    /*withSeparator=*/false);
             }
         }
 
@@ -256,7 +256,7 @@ createTagStringWithAlternates(
                 scriptLength,
                 tagBuffer,
                 &tagLength,
-                /*withSeparator=*/TRUE);
+                /*withSeparator=*/true);
         }
         else if (alternateTags != NULL) {
             /*
@@ -281,7 +281,7 @@ createTagStringWithAlternates(
                     alternateScriptLength,
                     tagBuffer,
                     &tagLength,
-                    /*withSeparator=*/TRUE);
+                    /*withSeparator=*/true);
             }
         }
 
@@ -291,9 +291,9 @@ createTagStringWithAlternates(
                 regionLength,
                 tagBuffer,
                 &tagLength,
-                /*withSeparator=*/TRUE);
+                /*withSeparator=*/true);
 
-            regionAppended = TRUE;
+            regionAppended = true;
         }
         else if (alternateTags != NULL) {
             /*
@@ -317,9 +317,9 @@ createTagStringWithAlternates(
                     alternateRegionLength,
                     tagBuffer,
                     &tagLength,
-                    /*withSeparator=*/TRUE);
+                    /*withSeparator=*/true);
 
-                regionAppended = TRUE;
+                regionAppended = true;
             }
         }
 
@@ -622,7 +622,7 @@ createLikelySubtagsString(
                         likelySubtags,
                         sink,
                         err);
-            return TRUE;
+            return true;
         }
     }
 
@@ -678,7 +678,7 @@ createLikelySubtagsString(
                         likelySubtags,
                         sink,
                         err);
-            return TRUE;
+            return true;
         }
     }
 
@@ -734,7 +734,7 @@ createLikelySubtagsString(
                         likelySubtags,
                         sink,
                         err);
-            return TRUE;
+            return true;
         }
     }
 
@@ -789,11 +789,11 @@ createLikelySubtagsString(
                         likelySubtags,
                         sink,
                         err);
-            return TRUE;
+            return true;
         }
     }
 
-    return FALSE;
+    return false;
 
 error:
 
@@ -801,7 +801,7 @@ error:
         *err = U_ILLEGAL_ARGUMENT_ERROR;
     }
 
-    return FALSE;
+    return false;
 }
 
 #define CHECK_TRAILING_VARIANT_SIZE(trailing, trailingLength) UPRV_BLOCK_MACRO_BEGIN { \
@@ -836,7 +836,7 @@ _uloc_addLikelySubtags(const char* localeID,
     const char* trailing = "";
     int32_t trailingLength = 0;
     int32_t trailingIndex = 0;
-    UBool success = FALSE;
+    UBool success = false;
 
     if(U_FAILURE(*err)) {
         goto error;
@@ -901,7 +901,7 @@ error:
     if (!U_FAILURE(*err)) {
         *err = U_ILLEGAL_ARGUMENT_ERROR;
     }
-    return FALSE;
+    return false;
 }
 
 // Add likely subtags to the sink
@@ -925,7 +925,7 @@ _uloc_minimizeSubtags(const char* localeID,
     const char* trailing = "";
     int32_t trailingLength = 0;
     int32_t trailingIndex = 0;
-    UBool successGetMax = FALSE;
+    UBool successGetMax = false;
 
     if(U_FAILURE(*err)) {
         goto error;
@@ -1248,7 +1248,7 @@ _ulocimp_addLikelySubtags(const char* localeID,
     if (U_SUCCESS(*status)) {
         return _uloc_addLikelySubtags(localeBuffer.getBuffer(), sink, status);
     } else {
-        return FALSE;
+        return false;
     }
 }
 
@@ -1320,14 +1320,14 @@ uloc_isRightToLeft(const char *locale) {
         char lang[8];
         int32_t langLength = uloc_getLanguage(locale, lang, UPRV_LENGTHOF(lang), &errorCode);
         if (U_FAILURE(errorCode) || errorCode == U_STRING_NOT_TERMINATED_WARNING) {
-            return FALSE;
+            return false;
         }
         if (langLength > 0) {
             const char* langPtr = uprv_strstr(LANG_DIR_STRING, lang);
             if (langPtr != NULL) {
                 switch (langPtr[langLength]) {
-                case '-': return FALSE;
-                case '+': return TRUE;
+                case '-': return false;
+                case '+': return true;
                 default: break;  // partial match of a longer code
                 }
             }
@@ -1340,12 +1340,12 @@ uloc_isRightToLeft(const char *locale) {
             ulocimp_addLikelySubtags(locale, sink, &errorCode);
         }
         if (U_FAILURE(errorCode) || errorCode == U_STRING_NOT_TERMINATED_WARNING) {
-            return FALSE;
+            return false;
         }
         scriptLength = uloc_getScript(likely.data(), script, UPRV_LENGTHOF(script), &errorCode);
         if (U_FAILURE(errorCode) || errorCode == U_STRING_NOT_TERMINATED_WARNING ||
                 scriptLength == 0) {
-            return FALSE;
+            return false;
         }
     }
     UScriptCode scriptCode = (UScriptCode)u_getPropertyValueEnum(UCHAR_SCRIPT, script);
@@ -1392,7 +1392,7 @@ ulocimp_getRegionForSupplementalData(const char *localeID, UBool inferRegion,
         if (U_FAILURE(*status)) {
             rgLen = 0;
         } else if (rgLen == 0 && inferRegion) {
-            // no unicode_region_subtag but inferRegion TRUE, try likely subtags
+            // no unicode_region_subtag but inferRegion true, try likely subtags
             rgStatus = U_ZERO_ERROR;
             icu::CharString locBuf;
             {
diff --git a/deps/icu-small/source/common/loclikelysubtags.cpp b/deps/icu-small/source/common/loclikelysubtags.cpp
index aa592e6ea8..e913c66a35 100644
--- a/deps/icu-small/source/common/loclikelysubtags.cpp
+++ b/deps/icu-small/source/common/loclikelysubtags.cpp
@@ -233,7 +233,7 @@ private:
                 return false;
             }
             for (int i = 0; i < length; ++i) {
-                stringArray.getValue(i, value);  // returns TRUE because i < length
+                stringArray.getValue(i, value);  // returns true because i < length
                 rawIndexes[i] = strings.add(value.getUnicodeString(errorCode), errorCode);
                 if (U_FAILURE(errorCode)) { return false; }
             }
@@ -245,13 +245,13 @@ private:
 namespace {
 
 XLikelySubtags *gLikelySubtags = nullptr;
-UInitOnce gInitOnce = U_INITONCE_INITIALIZER;
+UInitOnce gInitOnce {};
 
 UBool U_CALLCONV cleanup() {
     delete gLikelySubtags;
     gLikelySubtags = nullptr;
     gInitOnce.reset();
-    return TRUE;
+    return true;
 }
 
 }  // namespace
diff --git a/deps/icu-small/source/common/locmap.cpp b/deps/icu-small/source/common/locmap.cpp
index 29a5646385..78cfd1ca86 100644
--- a/deps/icu-small/source/common/locmap.cpp
+++ b/deps/icu-small/source/common/locmap.cpp
@@ -1053,7 +1053,7 @@ uprv_convertToPosix(uint32_t hostid, char *posixID, int32_t posixIDCapacity, UEr
 {
     uint16_t langID;
     uint32_t localeIndex;
-    UBool bLookup = TRUE;
+    UBool bLookup = true;
     const char *pPosixID = NULL;
 
 #if U_PLATFORM_HAS_WIN32_API && UCONFIG_USE_WINDOWS_LCID_MAPPING_API
@@ -1074,7 +1074,7 @@ uprv_convertToPosix(uint32_t hostid, char *posixID, int32_t posixIDCapacity, UEr
         if (tmpLen > 1) {
             int32_t i = 0;
             // Only need to look up in table if have _, eg for de-de_phoneb type alternate sort.
-            bLookup = FALSE;
+            bLookup = false;
             for (i = 0; i < UPRV_LENGTHOF(locName); i++)
             {
                 locName[i] = (char)(windowsLocaleName[i]);
@@ -1088,7 +1088,7 @@ uprv_convertToPosix(uint32_t hostid, char *posixID, int32_t posixIDCapacity, UEr
                     // TODO: Should these be mapped from _phoneb to @collation=phonebook, etc.?
                     locName[i] = '\0';
                     tmpLen = i;
-                    bLookup = TRUE;
+                    bLookup = true;
                     break;
                 }
                 else if (windowsLocaleName[i] == L'-')
@@ -1201,7 +1201,7 @@ uprv_convertToLCIDPlatform(const char* localeID, UErrorCode* status)
 
     char asciiBCP47Tag[LOCALE_NAME_MAX_LENGTH] = {};
     // this will change it from de_DE@collation=phonebook to de-DE-u-co-phonebk form
-    (void)uloc_toLanguageTag(mylocaleID, asciiBCP47Tag, UPRV_LENGTHOF(asciiBCP47Tag), FALSE, status);
+    (void)uloc_toLanguageTag(mylocaleID, asciiBCP47Tag, UPRV_LENGTHOF(asciiBCP47Tag), false, status);
 
     if (U_SUCCESS(*status))
     {
diff --git a/deps/icu-small/source/common/locutil.cpp b/deps/icu-small/source/common/locutil.cpp
index 3d9d69ff7e..6e2bd497f8 100644
--- a/deps/icu-small/source/common/locutil.cpp
+++ b/deps/icu-small/source/common/locutil.cpp
@@ -21,7 +21,7 @@
 #include "umutex.h"
 
 // see LocaleUtility::getAvailableLocaleNames
-static icu::UInitOnce   LocaleUtilityInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce   LocaleUtilityInitOnce {};
 static icu::Hashtable * LocaleUtility_cache = NULL;
 
 #define UNDERSCORE_CHAR ((UChar)0x005f)
@@ -41,7 +41,7 @@ static UBool U_CALLCONV service_cleanup(void) {
         delete LocaleUtility_cache;
         LocaleUtility_cache = NULL;
     }
-    return TRUE;
+    return true;
 }
 
 
diff --git a/deps/icu-small/source/common/messageimpl.h b/deps/icu-small/source/common/messageimpl.h
index a56479066b..061df9189d 100644
--- a/deps/icu-small/source/common/messageimpl.h
+++ b/deps/icu-small/source/common/messageimpl.h
@@ -55,7 +55,7 @@ public:
                                                             UnicodeString &result);
 
 private:
-    MessageImpl();  // no constructor: all static methods
+    MessageImpl() = delete;  // no constructor: all static methods
 };
 
 U_NAMESPACE_END
diff --git a/deps/icu-small/source/common/messagepattern.cpp b/deps/icu-small/source/common/messagepattern.cpp
index 66fd2f4c93..52afab5f02 100644
--- a/deps/icu-small/source/common/messagepattern.cpp
+++ b/deps/icu-small/source/common/messagepattern.cpp
@@ -97,9 +97,9 @@ public:
     UBool ensureCapacityForOneMore(int32_t oldLength, UErrorCode &errorCode);
     UBool equals(const MessagePatternList<T, stackCapacity> &other, int32_t length) const {
         for(int32_t i=0; i<length; ++i) {
-            if(a[i]!=other.a[i]) { return FALSE; }
+            if(a[i]!=other.a[i]) { return false; }
         }
-        return TRUE;
+        return true;
     }
 
     MaybeStackArray<T, stackCapacity> a;
@@ -124,13 +124,13 @@ template<typename T, int32_t stackCapacity>
 UBool
 MessagePatternList<T, stackCapacity>::ensureCapacityForOneMore(int32_t oldLength, UErrorCode &errorCode) {
     if(U_FAILURE(errorCode)) {
-        return FALSE;
+        return false;
     }
     if(a.getCapacity()>oldLength || a.resize(2*oldLength, oldLength)!=NULL) {
-        return TRUE;
+        return true;
     }
     errorCode=U_MEMORY_ALLOCATION_ERROR;
-    return FALSE;
+    return false;
 }
 
 // MessagePatternList specializations -------------------------------------- ***
@@ -147,7 +147,7 @@ MessagePattern::MessagePattern(UErrorCode &errorCode)
         : aposMode(UCONFIG_MSGPAT_DEFAULT_APOSTROPHE_MODE),
           partsList(NULL), parts(NULL), partsLength(0),
           numericValuesList(NULL), numericValues(NULL), numericValuesLength(0),
-          hasArgNames(FALSE), hasArgNumbers(FALSE), needsAutoQuoting(FALSE) {
+          hasArgNames(false), hasArgNumbers(false), needsAutoQuoting(false) {
     init(errorCode);
 }
 
@@ -155,7 +155,7 @@ MessagePattern::MessagePattern(UMessagePatternApostropheMode mode, UErrorCode &e
         : aposMode(mode),
           partsList(NULL), parts(NULL), partsLength(0),
           numericValuesList(NULL), numericValues(NULL), numericValuesLength(0),
-          hasArgNames(FALSE), hasArgNumbers(FALSE), needsAutoQuoting(FALSE) {
+          hasArgNames(false), hasArgNumbers(false), needsAutoQuoting(false) {
     init(errorCode);
 }
 
@@ -163,7 +163,7 @@ MessagePattern::MessagePattern(const UnicodeString &pattern, UParseError *parseE
         : aposMode(UCONFIG_MSGPAT_DEFAULT_APOSTROPHE_MODE),
           partsList(NULL), parts(NULL), partsLength(0),
           numericValuesList(NULL), numericValues(NULL), numericValuesLength(0),
-          hasArgNames(FALSE), hasArgNumbers(FALSE), needsAutoQuoting(FALSE) {
+          hasArgNames(false), hasArgNumbers(false), needsAutoQuoting(false) {
     if(init(errorCode)) {
         parse(pattern, parseError, errorCode);
     }
@@ -172,15 +172,15 @@ MessagePattern::MessagePattern(const UnicodeString &pattern, UParseError *parseE
 UBool
 MessagePattern::init(UErrorCode &errorCode) {
     if(U_FAILURE(errorCode)) {
-        return FALSE;
+        return false;
     }
     partsList=new MessagePatternPartsList();
     if(partsList==NULL) {
         errorCode=U_MEMORY_ALLOCATION_ERROR;
-        return FALSE;
+        return false;
     }
     parts=partsList->a.getAlias();
-    return TRUE;
+    return true;
 }
 
 MessagePattern::MessagePattern(const MessagePattern &other)
@@ -215,7 +215,7 @@ MessagePattern::operator=(const MessagePattern &other) {
 UBool
 MessagePattern::copyStorage(const MessagePattern &other, UErrorCode &errorCode) {
     if(U_FAILURE(errorCode)) {
-        return FALSE;
+        return false;
     }
     parts=NULL;
     partsLength=0;
@@ -225,14 +225,14 @@ MessagePattern::copyStorage(const MessagePattern &other, UErrorCode &errorCode)
         partsList=new MessagePatternPartsList();
         if(partsList==NULL) {
             errorCode=U_MEMORY_ALLOCATION_ERROR;
-            return FALSE;
+            return false;
         }
         parts=partsList->a.getAlias();
     }
     if(other.partsLength>0) {
         partsList->copyFrom(*other.partsList, other.partsLength, errorCode);
         if(U_FAILURE(errorCode)) {
-            return FALSE;
+            return false;
         }
         parts=partsList->a.getAlias();
         partsLength=other.partsLength;
@@ -242,19 +242,19 @@ MessagePattern::copyStorage(const MessagePattern &other, UErrorCode &errorCode)
             numericValuesList=new MessagePatternDoubleList();
             if(numericValuesList==NULL) {
                 errorCode=U_MEMORY_ALLOCATION_ERROR;
-                return FALSE;
+                return false;
             }
             numericValues=numericValuesList->a.getAlias();
         }
         numericValuesList->copyFrom(
             *other.numericValuesList, other.numericValuesLength, errorCode);
         if(U_FAILURE(errorCode)) {
-            return FALSE;
+            return false;
         }
         numericValues=numericValuesList->a.getAlias();
         numericValuesLength=other.numericValuesLength;
     }
-    return TRUE;
+    return true;
 }
 
 MessagePattern::~MessagePattern() {
@@ -303,8 +303,8 @@ void
 MessagePattern::clear() {
     // Mostly the same as preParse().
     msg.remove();
-    hasArgNames=hasArgNumbers=FALSE;
-    needsAutoQuoting=FALSE;
+    hasArgNames=hasArgNumbers=false;
+    needsAutoQuoting=false;
     partsLength=0;
     numericValuesLength=0;
 }
@@ -414,8 +414,8 @@ MessagePattern::preParse(const UnicodeString &pattern, UParseError *parseError,
         parseError->postContext[0]=0;
     }
     msg=pattern;
-    hasArgNames=hasArgNumbers=FALSE;
-    needsAutoQuoting=FALSE;
+    hasArgNames=hasArgNumbers=false;
+    needsAutoQuoting=false;
     partsLength=0;
     numericValuesLength=0;
 }
@@ -458,7 +458,7 @@ MessagePattern::parseMessage(int32_t index, int32_t msgStartLength,
                 // Add a Part for auto-quoting.
                 addPart(UMSGPAT_PART_TYPE_INSERT_CHAR, index, 0,
                         u_apos, errorCode);  // value=char to be inserted
-                needsAutoQuoting=TRUE;
+                needsAutoQuoting=true;
             } else {
                 c=msg.charAt(index);
                 if(c==u_apos) {
@@ -491,7 +491,7 @@ MessagePattern::parseMessage(int32_t index, int32_t msgStartLength,
                             // Add a Part for auto-quoting.
                             addPart(UMSGPAT_PART_TYPE_INSERT_CHAR, index, 0,
                                     u_apos, errorCode);  // value=char to be inserted
-                            needsAutoQuoting=TRUE;
+                            needsAutoQuoting=true;
                             break;
                         }
                     }
@@ -500,7 +500,7 @@ MessagePattern::parseMessage(int32_t index, int32_t msgStartLength,
                     // Add a Part for auto-quoting.
                     addPart(UMSGPAT_PART_TYPE_INSERT_CHAR, index, 0,
                             u_apos, errorCode);  // value=char to be inserted
-                    needsAutoQuoting=TRUE;
+                    needsAutoQuoting=true;
                 }
             }
         } else if(UMSGPAT_ARG_TYPE_HAS_PLURAL_STYLE(parentType) && c==u_pound) {
@@ -560,7 +560,7 @@ MessagePattern::parseArg(int32_t index, int32_t argStartLength, int32_t nestingL
             errorCode=U_INDEX_OUTOFBOUNDS_ERROR;
             return 0;
         }
-        hasArgNumbers=TRUE;
+        hasArgNumbers=true;
         addPart(UMSGPAT_PART_TYPE_ARG_NUMBER, nameIndex, length, number, errorCode);
     } else if(number==UMSGPAT_ARG_NAME_NOT_NUMBER) {
         int32_t length=index-nameIndex;
@@ -569,7 +569,7 @@ MessagePattern::parseArg(int32_t index, int32_t argStartLength, int32_t nestingL
             errorCode=U_INDEX_OUTOFBOUNDS_ERROR;
             return 0;
         }
-        hasArgNames=TRUE;
+        hasArgNames=true;
         addPart(UMSGPAT_PART_TYPE_ARG_NAME, nameIndex, length, 0, errorCode);
     } else {  // number<-1 (ARG_NAME_NOT_VALID)
         setParseError(parseError, nameIndex);  // Bad argument syntax.
@@ -727,7 +727,7 @@ MessagePattern::parseChoiceStyle(int32_t index, int32_t nestingLevel,
             errorCode=U_INDEX_OUTOFBOUNDS_ERROR;
             return 0;
         }
-        parseDouble(numberIndex, index, TRUE, parseError, errorCode);  // adds ARG_INT or ARG_DOUBLE
+        parseDouble(numberIndex, index, true, parseError, errorCode);  // adds ARG_INT or ARG_DOUBLE
         if(U_FAILURE(errorCode)) {
             return 0;
         }
@@ -774,8 +774,8 @@ MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType argType,
         return 0;
     }
     int32_t start=index;
-    UBool isEmpty=TRUE;
-    UBool hasOther=FALSE;
+    UBool isEmpty=true;
+    UBool hasOther=false;
     for(;;) {
         // First, collect the selector looking for a small set of terminators.
         // It would be a little faster to consider the syntax of each possible
@@ -811,7 +811,7 @@ MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType argType,
                 return 0;
             }
             addPart(UMSGPAT_PART_TYPE_ARG_SELECTOR, selectorIndex, length, 0, errorCode);
-            parseDouble(selectorIndex+1, index, FALSE,
+            parseDouble(selectorIndex+1, index, false,
                         parseError, errorCode);  // adds ARG_INT or ARG_DOUBLE
         } else {
             index=skipIdentifier(index);
@@ -845,12 +845,12 @@ MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType argType,
                     errorCode=U_INDEX_OUTOFBOUNDS_ERROR;
                     return 0;
                 }
-                parseDouble(valueIndex, index, FALSE,
+                parseDouble(valueIndex, index, false,
                             parseError, errorCode);  // adds ARG_INT or ARG_DOUBLE
                 if(U_FAILURE(errorCode)) {
                     return 0;
                 }
-                isEmpty=FALSE;
+                isEmpty=false;
                 continue;  // no message fragment after the offset
             } else {
                 // normal selector word
@@ -861,7 +861,7 @@ MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType argType,
                 }
                 addPart(UMSGPAT_PART_TYPE_ARG_SELECTOR, selectorIndex, length, 0, errorCode);
                 if(0==msg.compare(selectorIndex, length, kOther, 0, 5)) {
-                    hasOther=TRUE;
+                    hasOther=true;
                 }
             }
         }
@@ -880,7 +880,7 @@ MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType argType,
         if(U_FAILURE(errorCode)) {
             return 0;
         }
-        isEmpty=FALSE;
+        isEmpty=false;
     }
 }
 
@@ -901,11 +901,11 @@ MessagePattern::parseArgNumber(const UnicodeString &s, int32_t start, int32_t li
             return 0;
         } else {
             number=0;
-            badNumber=TRUE;  // leading zero
+            badNumber=true;  // leading zero
         }
     } else if(0x31<=c && c<=0x39) {
         number=c-0x30;
-        badNumber=FALSE;
+        badNumber=false;
     } else {
         return UMSGPAT_ARG_NAME_NOT_NUMBER;
     }
@@ -913,7 +913,7 @@ MessagePattern::parseArgNumber(const UnicodeString &s, int32_t start, int32_t li
         c=s.charAt(start++);
         if(0x30<=c && c<=0x39) {
             if(number>=INT32_MAX/10) {
-                badNumber=TRUE;  // overflow
+                badNumber=true;  // overflow
             }
             number=number*10+(c-0x30);
         } else {
diff --git a/deps/icu-small/source/common/norm2_nfc_data.h b/deps/icu-small/source/common/norm2_nfc_data.h
index a774868981..ebe3e6ba90 100644
--- a/deps/icu-small/source/common/norm2_nfc_data.h
+++ b/deps/icu-small/source/common/norm2_nfc_data.h
@@ -10,14 +10,14 @@
 #ifdef INCLUDED_FROM_NORMALIZER2_CPP
 
 static const UVersionInfo norm2_nfc_data_formatVersion={4,0,0,0};
-static const UVersionInfo norm2_nfc_data_dataVersion={0xe,0,0,0};
+static const UVersionInfo norm2_nfc_data_dataVersion={0xf,0,0,0};
 
 static const int32_t norm2_nfc_data_indexes[Normalizer2Impl::IX_COUNT]={
-0x50,0x4c54,0x88bc,0x89bc,0x89bc,0x89bc,0x89bc,0x89bc,0xc0,0x300,0xae2,0x29e0,0x3c66,0xfc00,0x1288,0x3b9c,
+0x50,0x4cb8,0x8920,0x8a20,0x8a20,0x8a20,0x8a20,0x8a20,0xc0,0x300,0xae2,0x29e0,0x3c66,0xfc00,0x1288,0x3b9c,
 0x3c34,0x3c66,0x300,0
 };
 
-static const uint16_t norm2_nfc_data_trieIndex[1748]={
+static const uint16_t norm2_nfc_data_trieIndex[1788]={
 0,0x40,0x7b,0xbb,0xfb,0x13a,0x17a,0x1b2,0x1f2,0x226,0x254,0x226,0x294,0x2d4,0x313,0x353,
 0x393,0x3d2,0x40f,0x44e,0x226,0x226,0x488,0x4c8,0x4f8,0x530,0x226,0x570,0x59f,0x5de,0x226,0x5f3,
 0x631,0x65f,0x687,0x6bd,0x6fd,0x73a,0x75a,0x799,0x7d8,0x815,0x834,0x871,0x75a,0x8aa,0x8d8,0x917,
@@ -82,14 +82,14 @@ static const uint16_t norm2_nfc_data_trieIndex[1748]={
 0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,
 0x226,0x226,0x226,0x226,0x1880,0x18c0,0x1900,0x1940,0x1980,0x19c0,0x1a00,0x1a40,0x1a63,0x1aa3,0x226,0x226,
 0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x1ac3,0x226,0x226,0x226,0x226,0x226,0x226,0x226,
-0x657,0x666,0x67e,0x69d,0x6b2,0x6b2,0x6b2,0x6b6,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,
+0x67e,0x68e,0x6a6,0x6c5,0x6da,0x6da,0x6da,0x6de,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,
 0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,
 0x226,0x226,0x226,0x226,0x226,0x226,0x226,0xc0b,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,
 0x226,0x226,0x226,0x226,0x226,0x226,0x54f,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x40c,
 0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x1af6,0x226,0x226,0x1b06,0x226,0x226,0x226,0x226,
 0x226,0x226,0x226,0x226,0x226,0x226,0xdf7,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,
 0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x1b16,0x226,0x226,0x226,0x226,0x226,0x226,
-0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x1607,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,
+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x1607,0x226,0x226,0x226,0x226,0x66b,0x226,0x226,0x226,
 0x226,0x1b20,0x54f,0x226,0x226,0x1b30,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x81c,0x226,0x226,
 0x1b40,0x226,0x1b50,0x1b5d,0x1b69,0x226,0x226,0x226,0x226,0x414,0x226,0x1b74,0x1b84,0x226,0x226,0x226,
 0x811,0x226,0x226,0x226,0x226,0x1b94,0x226,0x226,0x226,0x1b9f,0x226,0x226,0x226,0x226,0x226,0x226,
@@ -104,33 +104,35 @@ static const uint16_t norm2_nfc_data_trieIndex[1748]={
 0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x9eb,0x226,0x226,0x226,0x226,
 0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0xc05,0x226,0x226,0x226,
 0x226,0x81b,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,
-0x226,0x1c3d,0x226,0x226,0x226,0xf2c,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,
+0x226,0x226,0x226,0x226,0x226,0x226,0xc08,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,
+0x226,0x226,0x226,0x226,0x226,0x226,0x1c3d,0x226,0x226,0x226,0xf2c,0x226,0x226,0x226,0x226,0x226,
 0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,
-0x226,0x226,0x226,0x226,0x226,0x1c4d,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x1c4f,
+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x1c4d,0x226,0x226,0x226,0x226,0x226,
+0x226,0x226,0x226,0x226,0x1c4f,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,
+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x1c5e,0x1c6e,0x1c7c,0x1c89,0x226,
+0x1c95,0x1ca3,0x1cb3,0x226,0x226,0x226,0x226,0xd1b,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,
 0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,
-0x226,0x226,0x226,0x226,0x226,0x226,0x1c5e,0x1c6e,0x1c7c,0x1c89,0x226,0x1c95,0x1ca3,0x1cb3,0x226,0x226,
-0x226,0x226,0xd1b,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,
-0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x1cc3,0x1ccb,
-0x1cd9,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,
-0x226,0xf2c,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x7c9,0x226,
-0x226,0x226,0x4fc,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,
-0x226,0x226,0x226,0x226,0x1ce9,0x226,0x226,0x226,0x226,0x226,0x226,0x1cf5,0x226,0x226,0x226,0x226,
-0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x1d05,0x1d15,0x1d25,0x1d35,0x1d45,0x1d55,0x1d65,0x1d75,0x1d85,
-0x1d95,0x1da5,0x1db5,0x1dc5,0x1dd5,0x1de5,0x1df5,0x1e05,0x1e15,0x1e25,0x1e35,0x1e45,0x1e55,0x1e65,0x1e75,0x1e85,
-0x1e95,0x1ea5,0x1eb5,0x1ec5,0x1ed5,0x1ee5,0x1ef5,0x1f05,0x1f15,0x226,0x226,0x226,0x226,0x226,0x226,0x226,
+0x226,0x226,0x226,0x1cc3,0x1ccb,0x1cd9,0x226,0x226,0x226,0x226,0x226,0x4f9,0x226,0x226,0x226,0x226,
+0x226,0x226,0x226,0x226,0x226,0x226,0xf2c,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,
+0x226,0x226,0x226,0x7c9,0x226,0x226,0x226,0x4fc,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,
+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x1ce4,0x226,0x226,0x226,0x226,0x226,0x226,
+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x1cf4,0x226,0x226,0x226,0x226,
+0x226,0x226,0x1d00,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x1d10,0x1d20,
+0x1d30,0x1d40,0x1d50,0x1d60,0x1d70,0x1d80,0x1d90,0x1da0,0x1db0,0x1dc0,0x1dd0,0x1de0,0x1df0,0x1e00,0x1e10,0x1e20,
+0x1e30,0x1e40,0x1e50,0x1e60,0x1e70,0x1e80,0x1e90,0x1ea0,0x1eb0,0x1ec0,0x1ed0,0x1ee0,0x1ef0,0x1f00,0x1f10,0x1f20,
 0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,
-0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x408,0x428,0xc4,0xc4,0xc4,0x448,0x457,0x46d,0x489,
-0x4a6,0x4c2,0x4df,0x4fc,0x51b,0x538,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,
-0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0x552,0xc4,0x566,0xc4,0xc4,
+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x408,0x428,
+0xc4,0xc4,0xc4,0x448,0x457,0x46d,0x489,0x4a6,0x4c2,0x4df,0x4fc,0x51b,0x538,0x552,0xc4,0xc4,
 0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,
-0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0x586,0xc4,0xc4,0xc4,
-0xc4,0xc4,0xc4,0xc4,0xc4,0x591,0x5ae,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0x5ce,0x5e4,0xc4,
-0xc4,0x5f7,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,
+0xc4,0xc4,0xc4,0x567,0xc4,0x57b,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,
 0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,
-0xc4,0xc4,0x617,0x637
+0xc4,0xc4,0xc4,0xc4,0x59b,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0x5a6,0x5c3,0xc4,
+0xc4,0xc4,0xc4,0xc4,0xc4,0x5e3,0x5f9,0x60b,0xc4,0x61e,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,
+0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,
+0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0x63e,0x65e
 };
 
-static const uint16_t norm2_nfc_data_trieData[7974]={
+static const uint16_t norm2_nfc_data_trieData[7984]={
 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
@@ -518,7 +520,7 @@ static const uint16_t norm2_nfc_data_trieData[7974]={
 1,1,1,1,1,0x3c66,1,0x3c66,0x3c66,0x3c66,0x3c66,0x3c66,0x3c66,1,1,1,
 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0x3c66,
 0x3c66,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-1,1,1,1,0x3c66,1,1,1,1,0x3c66,1,1,1,0x3c66,1,0x3c66,
+1,1,1,1,0x3c66,1,1,1,1,0x3c66,1,1,1,0x3c66,0x3c66,0x3c66,
 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
@@ -593,49 +595,49 @@ static const uint16_t norm2_nfc_data_trieData[7974]={
 0x3304,0x331c,0x3334,0x334c,1,1,1,1,1,1,1,1,1,1,1,1,
 1,1,1,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,1,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,
 0xffcc,0xffcc,0xffcc,0xffcc,1,1,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,1,0xffcc,0xffcc,1,0xffcc,
-0xffcc,0xffcc,0xffcc,0xffcc,1,1,1,1,1,0xffb8,0xffb8,0xffb8,0xffb8,0xffb8,0xffb8,0xffb8,
-1,1,1,1,1,1,1,1,1,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xfe0e,
-1,1,1,1,1,0x335b,0x335f,0x3363,0x3367,0x336d,0x2f4d,0x3371,0x3375,0x3379,0x337d,0x2f51,
-0x3381,0x3385,0x3389,0x2f55,0x338f,0x3393,0x3397,0x339b,0x33a1,0x33a5,0x33a9,0x33ad,0x33b3,0x33b7,0x33bb,0x33bf,
-0x303f,0x33c3,0x33c9,0x33cd,0x33d1,0x33d5,0x33d9,0x33dd,0x33e1,0x33e5,0x3053,0x2f59,0x2f5d,0x3057,0x33e9,0x33ed,
-0x2c59,0x33f1,0x2f61,0x33f5,0x33f9,0x33fd,0x3401,0x3401,0x3401,0x3405,0x340b,0x340f,0x3413,0x3417,0x341d,0x3421,
-0x3425,0x3429,0x342d,0x3431,0x3435,0x3439,0x343d,0x3441,0x3445,0x3449,0x344d,0x344d,0x305f,0x3451,0x3455,0x3459,
-0x345d,0x2f69,0x3461,0x3465,0x3469,0x2ebd,0x346d,0x3471,0x3475,0x3479,0x347d,0x3481,0x3485,0x3489,0x348d,0x3493,
-0x3497,0x349b,0x349f,0x34a3,0x34a7,0x34ab,0x34b1,0x34b7,0x34bb,0x34bf,0x34c3,0x34c7,0x34cb,0x34cf,0x34d3,0x34d7,
-0x34d7,0x34db,0x34e1,0x34e5,0x2c49,0x34e9,0x34ed,0x34f3,0x34f7,0x34fb,0x34ff,0x3503,0x3507,0x2f7d,0x350b,0x350f,
-0x3513,0x3519,0x351d,0x3523,0x3527,0x352b,0x352f,0x3533,0x3537,0x353b,0x353f,0x3543,0x3547,0x354b,0x354f,0x3555,
-0x3559,0x355d,0x3561,0x2b71,0x3565,0x356b,0x356f,0x356f,0x3575,0x3579,0x3579,0x357d,0x3581,0x3587,0x358d,0x3591,
-0x3595,0x3599,0x359d,0x35a1,0x35a5,0x35a9,0x35ad,0x35b1,0x2f81,0x35b5,0x35bb,0x35bf,0x35c3,0x308f,0x35c3,0x35c7,
-0x2f89,0x35cb,0x35cf,0x35d3,0x35d7,0x2f8d,0x2b05,0x35db,0x35df,0x35e3,0x35e7,0x35eb,0x35ef,0x35f3,0x35f9,0x35fd,
-0x3601,0x3605,0x3609,0x360d,0x3613,0x3617,0x361b,0x361f,0x3623,0x3627,0x362b,0x362f,0x3633,0x2f91,0x3637,0x363b,
-0x3641,0x3645,0x3649,0x364d,0x2f99,0x3651,0x3655,0x3659,0x365d,0x3661,0x3665,0x3669,0x366d,0x2b75,0x30af,0x3671,
-0x3675,0x3679,0x367d,0x3683,0x3687,0x368b,0x368f,0x2f9d,0x3693,0x3699,0x369d,0x36a1,0x3161,0x36a5,0x36a9,0x36ad,
-0x36b1,0x36b5,0x36bb,0x36bf,0x36c3,0x36c7,0x36cd,0x36d1,0x36d5,0x36d9,0x2c8d,0x36dd,0x36e1,0x36e7,0x36ed,0x36f3,
-0x36f7,0x36fd,0x3701,0x3705,0x3709,0x370d,0x2fa1,0x2de9,0x3711,0x3715,0x3719,0x371d,0x3723,0x3727,0x372b,0x372f,
-0x30bf,0x3733,0x3737,0x373d,0x3741,0x3745,0x374b,0x3751,0x3755,0x30c3,0x3759,0x375d,0x3761,0x3765,0x3769,0x376d,
-0x3771,0x3777,0x377b,0x3781,0x3785,0x378b,0x30cb,0x378f,0x3793,0x3799,0x379d,0x37a1,0x37a7,0x37ad,0x37b1,0x37b5,
-0x37b9,0x37bd,0x37bd,0x37c1,0x37c5,0x30d3,0x37c9,0x37cd,0x37d1,0x37d5,0x37d9,0x37df,0x37e3,0x2c55,0x37e9,0x37ef,
-0x37f3,0x37f9,0x37ff,0x3805,0x3809,0x30eb,0x380d,0x3813,0x3819,0x381f,0x3825,0x3829,0x3829,0x30ef,0x3169,0x382d,
-0x3831,0x3835,0x3839,0x383f,0x2bbd,0x30f7,0x3843,0x3847,0x2fcd,0x384d,0x3853,0x2f15,0x3859,0x385d,0x2fdd,0x3861,
-0x3865,0x3869,0x386f,0x386f,0x3875,0x3879,0x387d,0x3883,0x3887,0x388b,0x388f,0x3895,0x3899,0x389d,0x38a1,0x38a5,
-0x38a9,0x38af,0x38b3,0x38b7,0x38bb,0x38bf,0x38c3,0x38c7,0x38cd,0x38d3,0x38d7,0x38dd,0x38e1,0x38e7,0x38eb,0x2ff5,
-0x38ef,0x38f5,0x38fb,0x38ff,0x3905,0x3909,0x390f,0x3913,0x3917,0x391b,0x391f,0x3923,0x3927,0x392d,0x3933,0x3939,
-0x3575,0x393f,0x3943,0x3947,0x394b,0x394f,0x3953,0x3957,0x395b,0x395f,0x3963,0x3967,0x396b,0x2c9d,0x3971,0x3975,
-0x3979,0x397d,0x3981,0x3985,0x3001,0x3989,0x398d,0x3991,0x3995,0x3999,0x399f,0x39a5,0x39ab,0x39af,0x39b3,0x39b7,
-0x39bb,0x39c1,0x39c5,0x39cb,0x39cf,0x39d3,0x39d9,0x39df,0x39e3,0x2ba9,0x39e7,0x39eb,0x39ef,0x39f3,0x39f7,0x39fb,
-0x3113,0x39ff,0x3a03,0x3a07,0x3a0b,0x3a0f,0x3a13,0x3a17,0x3a1b,0x3a1f,0x3a23,0x3a29,0x3a2d,0x3a31,0x3a35,0x3a39,
-0x3a3d,0x3a43,0x3a49,0x3a4d,0x3a51,0x3127,0x312b,0x3a55,0x3a59,0x3a5f,0x3a63,0x3a67,0x3a6b,0x3a6f,0x3a75,0x3a7b,
-0x3a7f,0x3a83,0x3a87,0x3a8d,0x312f,0x3a91,0x3a97,0x3a9d,0x3aa1,0x3aa5,0x3aa9,0x3aaf,0x3ab3,0x3ab7,0x3abb,0x3abf,
-0x3ac3,0x3ac7,0x3acb,0x3ad1,0x3ad5,0x3ad9,0x3add,0x3ae3,0x3ae7,0x3aeb,0x3aef,0x3af3,0x3af9,0x3aff,0x3b03,0x3b07,
-0x3b0b,0x3b11,0x3b15,0x3147,0x3147,0x3b1b,0x3b1f,0x3b25,0x3b29,0x3b2d,0x3b31,0x3b35,0x3b39,0x3b3d,0x3b41,0x314b,
-0x3b47,0x3b4b,0x3b4f,0x3b53,0x3b57,0x3b5b,0x3b61,0x3b65,0x3b6b,0x3b71,0x3b77,0x3b7b,0x3b7f,0x3b83,0x3b87,0x3b8b,
-0x3b8f,0x3b93,0x3b97,1,1,1
+0xffcc,0xffcc,0xffcc,0xffcc,1,1,1,1,1,1,1,1,1,1,1,1,
+0xffd0,0xffd0,0xffb8,0xffcc,0xffb8,0xffb8,0xffb8,0xffb8,0xffb8,0xffb8,0xffb8,1,1,1,1,1,
+1,1,1,1,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xfe0e,1,1,1,1,1,
+0x335b,0x335f,0x3363,0x3367,0x336d,0x2f4d,0x3371,0x3375,0x3379,0x337d,0x2f51,0x3381,0x3385,0x3389,0x2f55,0x338f,
+0x3393,0x3397,0x339b,0x33a1,0x33a5,0x33a9,0x33ad,0x33b3,0x33b7,0x33bb,0x33bf,0x303f,0x33c3,0x33c9,0x33cd,0x33d1,
+0x33d5,0x33d9,0x33dd,0x33e1,0x33e5,0x3053,0x2f59,0x2f5d,0x3057,0x33e9,0x33ed,0x2c59,0x33f1,0x2f61,0x33f5,0x33f9,
+0x33fd,0x3401,0x3401,0x3401,0x3405,0x340b,0x340f,0x3413,0x3417,0x341d,0x3421,0x3425,0x3429,0x342d,0x3431,0x3435,
+0x3439,0x343d,0x3441,0x3445,0x3449,0x344d,0x344d,0x305f,0x3451,0x3455,0x3459,0x345d,0x2f69,0x3461,0x3465,0x3469,
+0x2ebd,0x346d,0x3471,0x3475,0x3479,0x347d,0x3481,0x3485,0x3489,0x348d,0x3493,0x3497,0x349b,0x349f,0x34a3,0x34a7,
+0x34ab,0x34b1,0x34b7,0x34bb,0x34bf,0x34c3,0x34c7,0x34cb,0x34cf,0x34d3,0x34d7,0x34d7,0x34db,0x34e1,0x34e5,0x2c49,
+0x34e9,0x34ed,0x34f3,0x34f7,0x34fb,0x34ff,0x3503,0x3507,0x2f7d,0x350b,0x350f,0x3513,0x3519,0x351d,0x3523,0x3527,
+0x352b,0x352f,0x3533,0x3537,0x353b,0x353f,0x3543,0x3547,0x354b,0x354f,0x3555,0x3559,0x355d,0x3561,0x2b71,0x3565,
+0x356b,0x356f,0x356f,0x3575,0x3579,0x3579,0x357d,0x3581,0x3587,0x358d,0x3591,0x3595,0x3599,0x359d,0x35a1,0x35a5,
+0x35a9,0x35ad,0x35b1,0x2f81,0x35b5,0x35bb,0x35bf,0x35c3,0x308f,0x35c3,0x35c7,0x2f89,0x35cb,0x35cf,0x35d3,0x35d7,
+0x2f8d,0x2b05,0x35db,0x35df,0x35e3,0x35e7,0x35eb,0x35ef,0x35f3,0x35f9,0x35fd,0x3601,0x3605,0x3609,0x360d,0x3613,
+0x3617,0x361b,0x361f,0x3623,0x3627,0x362b,0x362f,0x3633,0x2f91,0x3637,0x363b,0x3641,0x3645,0x3649,0x364d,0x2f99,
+0x3651,0x3655,0x3659,0x365d,0x3661,0x3665,0x3669,0x366d,0x2b75,0x30af,0x3671,0x3675,0x3679,0x367d,0x3683,0x3687,
+0x368b,0x368f,0x2f9d,0x3693,0x3699,0x369d,0x36a1,0x3161,0x36a5,0x36a9,0x36ad,0x36b1,0x36b5,0x36bb,0x36bf,0x36c3,
+0x36c7,0x36cd,0x36d1,0x36d5,0x36d9,0x2c8d,0x36dd,0x36e1,0x36e7,0x36ed,0x36f3,0x36f7,0x36fd,0x3701,0x3705,0x3709,
+0x370d,0x2fa1,0x2de9,0x3711,0x3715,0x3719,0x371d,0x3723,0x3727,0x372b,0x372f,0x30bf,0x3733,0x3737,0x373d,0x3741,
+0x3745,0x374b,0x3751,0x3755,0x30c3,0x3759,0x375d,0x3761,0x3765,0x3769,0x376d,0x3771,0x3777,0x377b,0x3781,0x3785,
+0x378b,0x30cb,0x378f,0x3793,0x3799,0x379d,0x37a1,0x37a7,0x37ad,0x37b1,0x37b5,0x37b9,0x37bd,0x37bd,0x37c1,0x37c5,
+0x30d3,0x37c9,0x37cd,0x37d1,0x37d5,0x37d9,0x37df,0x37e3,0x2c55,0x37e9,0x37ef,0x37f3,0x37f9,0x37ff,0x3805,0x3809,
+0x30eb,0x380d,0x3813,0x3819,0x381f,0x3825,0x3829,0x3829,0x30ef,0x3169,0x382d,0x3831,0x3835,0x3839,0x383f,0x2bbd,
+0x30f7,0x3843,0x3847,0x2fcd,0x384d,0x3853,0x2f15,0x3859,0x385d,0x2fdd,0x3861,0x3865,0x3869,0x386f,0x386f,0x3875,
+0x3879,0x387d,0x3883,0x3887,0x388b,0x388f,0x3895,0x3899,0x389d,0x38a1,0x38a5,0x38a9,0x38af,0x38b3,0x38b7,0x38bb,
+0x38bf,0x38c3,0x38c7,0x38cd,0x38d3,0x38d7,0x38dd,0x38e1,0x38e7,0x38eb,0x2ff5,0x38ef,0x38f5,0x38fb,0x38ff,0x3905,
+0x3909,0x390f,0x3913,0x3917,0x391b,0x391f,0x3923,0x3927,0x392d,0x3933,0x3939,0x3575,0x393f,0x3943,0x3947,0x394b,
+0x394f,0x3953,0x3957,0x395b,0x395f,0x3963,0x3967,0x396b,0x2c9d,0x3971,0x3975,0x3979,0x397d,0x3981,0x3985,0x3001,
+0x3989,0x398d,0x3991,0x3995,0x3999,0x399f,0x39a5,0x39ab,0x39af,0x39b3,0x39b7,0x39bb,0x39c1,0x39c5,0x39cb,0x39cf,
+0x39d3,0x39d9,0x39df,0x39e3,0x2ba9,0x39e7,0x39eb,0x39ef,0x39f3,0x39f7,0x39fb,0x3113,0x39ff,0x3a03,0x3a07,0x3a0b,
+0x3a0f,0x3a13,0x3a17,0x3a1b,0x3a1f,0x3a23,0x3a29,0x3a2d,0x3a31,0x3a35,0x3a39,0x3a3d,0x3a43,0x3a49,0x3a4d,0x3a51,
+0x3127,0x312b,0x3a55,0x3a59,0x3a5f,0x3a63,0x3a67,0x3a6b,0x3a6f,0x3a75,0x3a7b,0x3a7f,0x3a83,0x3a87,0x3a8d,0x312f,
+0x3a91,0x3a97,0x3a9d,0x3aa1,0x3aa5,0x3aa9,0x3aaf,0x3ab3,0x3ab7,0x3abb,0x3abf,0x3ac3,0x3ac7,0x3acb,0x3ad1,0x3ad5,
+0x3ad9,0x3add,0x3ae3,0x3ae7,0x3aeb,0x3aef,0x3af3,0x3af9,0x3aff,0x3b03,0x3b07,0x3b0b,0x3b11,0x3b15,0x3147,0x3147,
+0x3b1b,0x3b1f,0x3b25,0x3b29,0x3b2d,0x3b31,0x3b35,0x3b39,0x3b3d,0x3b41,0x314b,0x3b47,0x3b4b,0x3b4f,0x3b53,0x3b57,
+0x3b5b,0x3b61,0x3b65,0x3b6b,0x3b71,0x3b77,0x3b7b,0x3b7f,0x3b83,0x3b87,0x3b8b,0x3b8f,0x3b93,0x3b97,1,1
 };
 
 static const UCPTrie norm2_nfc_data_trie={
     norm2_nfc_data_trieIndex,
     { norm2_nfc_data_trieData },
-    1748, 7974,
+    1788, 7984,
     0x2fc00, 0x30,
     0, 0,
     0, 0,
diff --git a/deps/icu-small/source/common/normalizer2.cpp b/deps/icu-small/source/common/normalizer2.cpp
index 6be7e0b21a..3617264490 100644
--- a/deps/icu-small/source/common/normalizer2.cpp
+++ b/deps/icu-small/source/common/normalizer2.cpp
@@ -62,7 +62,7 @@ Normalizer2::normalizeUTF8(uint32_t /*options*/, StringPiece src, ByteSink &sink
 
 UBool
 Normalizer2::getRawDecomposition(UChar32, UnicodeString &) const {
-    return FALSE;
+    return false;
 }
 
 UChar32
@@ -142,7 +142,7 @@ class NoopNormalizer2 : public Normalizer2 {
     }
     virtual UBool
     getDecomposition(UChar32, UnicodeString &) const U_OVERRIDE {
-        return FALSE;
+        return false;
     }
     // No need to U_OVERRIDE the default getRawDecomposition().
     virtual UBool
@@ -161,9 +161,9 @@ class NoopNormalizer2 : public Normalizer2 {
     spanQuickCheckYes(const UnicodeString &s, UErrorCode &) const U_OVERRIDE {
         return s.length();
     }
-    virtual UBool hasBoundaryBefore(UChar32) const U_OVERRIDE { return TRUE; }
-    virtual UBool hasBoundaryAfter(UChar32) const U_OVERRIDE { return TRUE; }
-    virtual UBool isInert(UChar32) const U_OVERRIDE { return TRUE; }
+    virtual UBool hasBoundaryBefore(UChar32) const U_OVERRIDE { return true; }
+    virtual UBool hasBoundaryAfter(UChar32) const U_OVERRIDE { return true; }
+    virtual UBool isInert(UChar32) const U_OVERRIDE { return true; }
 };
 
 NoopNormalizer2::~NoopNormalizer2() {}
@@ -183,7 +183,7 @@ static UBool U_CALLCONV uprv_normalizer2_cleanup();
 U_CDECL_END
 
 static Normalizer2   *noopSingleton;
-static icu::UInitOnce noopInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce noopInitOnce {};
 
 static void U_CALLCONV initNoopSingleton(UErrorCode &errorCode) {
     if(U_FAILURE(errorCode)) {
@@ -245,7 +245,7 @@ Norm2AllModes::createNFCInstance(UErrorCode &errorCode) {
 
 static Norm2AllModes *nfcSingleton;
 
-static icu::UInitOnce nfcInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce nfcInitOnce {};
 
 static void U_CALLCONV initNFCSingleton(UErrorCode &errorCode) {
     nfcSingleton=Norm2AllModes::createNFCInstance(errorCode);
@@ -299,7 +299,7 @@ static UBool U_CALLCONV uprv_normalizer2_cleanup() {
     nfcSingleton = NULL;
     nfcInitOnce.reset(); 
 #endif
-    return TRUE;
+    return true;
 }
 
 U_CDECL_END
@@ -423,7 +423,7 @@ unorm2_normalizeSecondAndAppend(const UNormalizer2 *norm2,
     return normalizeSecondAndAppend(norm2,
                                     first, firstLength, firstCapacity,
                                     second, secondLength,
-                                    TRUE, pErrorCode);
+                                    true, pErrorCode);
 }
 
 U_CAPI int32_t U_EXPORT2
@@ -434,7 +434,7 @@ unorm2_append(const UNormalizer2 *norm2,
     return normalizeSecondAndAppend(norm2,
                                     first, firstLength, firstCapacity,
                                     second, secondLength,
-                                    FALSE, pErrorCode);
+                                    false, pErrorCode);
 }
 
 U_CAPI int32_t U_EXPORT2
diff --git a/deps/icu-small/source/common/normalizer2impl.cpp b/deps/icu-small/source/common/normalizer2impl.cpp
index e6bd75e717..d7e05e44d7 100644
--- a/deps/icu-small/source/common/normalizer2impl.cpp
+++ b/deps/icu-small/source/common/normalizer2impl.cpp
@@ -185,7 +185,7 @@ UBool ReorderingBuffer::init(int32_t destCapacity, UErrorCode &errorCode) {
     if(start==NULL) {
         // getBuffer() already did str.setToBogus()
         errorCode=U_MEMORY_ALLOCATION_ERROR;
-        return FALSE;
+        return false;
     }
     limit=start+length;
     remainingCapacity=str.getCapacity()-length;
@@ -201,7 +201,7 @@ UBool ReorderingBuffer::init(int32_t destCapacity, UErrorCode &errorCode) {
         }
         reorderStart=codePointLimit;
     }
-    return TRUE;
+    return true;
 }
 
 UBool ReorderingBuffer::equals(const UChar *otherStart, const UChar *otherLimit) const {
@@ -217,7 +217,7 @@ UBool ReorderingBuffer::equals(const uint8_t *otherStart, const uint8_t *otherLi
     int32_t otherLength = (int32_t)(otherLimit - otherStart);
     // For equal strings, UTF-8 is at least as long as UTF-16, and at most three times as long.
     if (otherLength < length || (otherLength / 3) > length) {
-        return FALSE;
+        return false;
     }
     // Compare valid strings from between normalization boundaries.
     // (Invalid sequences are normalization-inert.)
@@ -225,21 +225,21 @@ UBool ReorderingBuffer::equals(const uint8_t *otherStart, const uint8_t *otherLi
         if (i >= length) {
             return j >= otherLength;
         } else if (j >= otherLength) {
-            return FALSE;
+            return false;
         }
         // Not at the end of either string yet.
         UChar32 c, other;
         U16_NEXT_UNSAFE(start, i, c);
         U8_NEXT_UNSAFE(otherStart, j, other);
         if (c != other) {
-            return FALSE;
+            return false;
         }
     }
 }
 
 UBool ReorderingBuffer::appendSupplementary(UChar32 c, uint8_t cc, UErrorCode &errorCode) {
     if(remainingCapacity<2 && !resize(2, errorCode)) {
-        return FALSE;
+        return false;
     }
     if(lastCC<=cc || cc==0) {
         limit[0]=U16_LEAD(c);
@@ -253,17 +253,17 @@ UBool ReorderingBuffer::appendSupplementary(UChar32 c, uint8_t cc, UErrorCode &e
         insert(c, cc);
     }
     remainingCapacity-=2;
-    return TRUE;
+    return true;
 }
 
 UBool ReorderingBuffer::append(const UChar *s, int32_t length, UBool isNFD,
                                uint8_t leadCC, uint8_t trailCC,
                                UErrorCode &errorCode) {
     if(length==0) {
-        return TRUE;
+        return true;
     }
     if(remainingCapacity<length && !resize(length, errorCode)) {
-        return FALSE;
+        return false;
     }
     remainingCapacity-=length;
     if(lastCC<=leadCC || leadCC==0) {
@@ -294,13 +294,13 @@ UBool ReorderingBuffer::append(const UChar *s, int32_t length, UBool isNFD,
             append(c, leadCC, errorCode);
         }
     }
-    return TRUE;
+    return true;
 }
 
 UBool ReorderingBuffer::appendZeroCC(UChar32 c, UErrorCode &errorCode) {
     int32_t cpLength=U16_LENGTH(c);
     if(remainingCapacity<cpLength && !resize(cpLength, errorCode)) {
-        return FALSE;
+        return false;
     }
     remainingCapacity-=cpLength;
     if(cpLength==1) {
@@ -312,23 +312,23 @@ UBool ReorderingBuffer::appendZeroCC(UChar32 c, UErrorCode &errorCode) {
     }
     lastCC=0;
     reorderStart=limit;
-    return TRUE;
+    return true;
 }
 
 UBool ReorderingBuffer::appendZeroCC(const UChar *s, const UChar *sLimit, UErrorCode &errorCode) {
     if(s==sLimit) {
-        return TRUE;
+        return true;
     }
     int32_t length=(int32_t)(sLimit-s);
     if(remainingCapacity<length && !resize(length, errorCode)) {
-        return FALSE;
+        return false;
     }
     u_memcpy(limit, s, length);
     limit+=length;
     remainingCapacity-=length;
     lastCC=0;
     reorderStart=limit;
-    return TRUE;
+    return true;
 }
 
 void ReorderingBuffer::remove() {
@@ -365,12 +365,12 @@ UBool ReorderingBuffer::resize(int32_t appendLength, UErrorCode &errorCode) {
     if(start==NULL) {
         // getBuffer() already did str.setToBogus()
         errorCode=U_MEMORY_ALLOCATION_ERROR;
-        return FALSE;
+        return false;
     }
     reorderStart=start+reorderStartIndex;
     limit=start+length;
     remainingCapacity=str.getCapacity()-length;
-    return TRUE;
+    return true;
 }
 
 void ReorderingBuffer::skipPrevious() {
@@ -728,7 +728,7 @@ UBool Normalizer2Impl::decompose(UChar32 c, uint16_t norm16,
     } else {
         leadCC=0;
     }
-    return buffer.append((const UChar *)mapping+1, length, TRUE, leadCC, trailCC, errorCode);
+    return buffer.append((const UChar *)mapping+1, length, true, leadCC, trailCC, errorCode);
 }
 
 // Dual functionality:
@@ -820,11 +820,11 @@ Normalizer2Impl::decomposeUTF8(uint32_t options,
         if (U_FAILURE(errorCode)) {
             break;
         }
-        decomposeShort(prevBoundary, src, STOP_AT_LIMIT, FALSE /* onlyContiguous */,
+        decomposeShort(prevBoundary, src, STOP_AT_LIMIT, false /* onlyContiguous */,
                        buffer, errorCode);
         // Decompose until the next boundary.
         if (buffer.getLastCC() > 1) {
-            src = decomposeShort(src, limit, STOP_AT_DECOMP_BOUNDARY, FALSE /* onlyContiguous */,
+            src = decomposeShort(src, limit, STOP_AT_DECOMP_BOUNDARY, false /* onlyContiguous */,
                                  buffer, errorCode);
         }
         if (U_FAILURE(errorCode)) {
@@ -931,7 +931,7 @@ Normalizer2Impl::decomposeShort(const uint8_t *src, const uint8_t *limit,
             if (leadCC == 0 && stopAt == STOP_AT_DECOMP_BOUNDARY) {
                 return prevSrc;
             }
-            if (!buffer.append((const char16_t *)mapping+1, length, TRUE, leadCC, trailCC, errorCode)) {
+            if (!buffer.append((const char16_t *)mapping+1, length, true, leadCC, trailCC, errorCode)) {
                 return nullptr;
             }
         }
@@ -1052,7 +1052,7 @@ void Normalizer2Impl::decomposeAndAppend(const UChar *src, const UChar *limit,
         limit=u_strchr(p, 0);
     }
 
-    if (buffer.append(src, (int32_t)(p - src), FALSE, firstCC, prevCC, errorCode)) {
+    if (buffer.append(src, (int32_t)(p - src), false, firstCC, prevCC, errorCode)) {
         buffer.appendZeroCC(p, limit, errorCode);
     }
 }
@@ -1064,7 +1064,7 @@ UBool Normalizer2Impl::hasDecompBoundaryBefore(UChar32 c) const {
 
 UBool Normalizer2Impl::norm16HasDecompBoundaryBefore(uint16_t norm16) const {
     if (norm16 < minNoNoCompNoMaybeCC) {
-        return TRUE;
+        return true;
     }
     if (norm16 >= limitNoNo) {
         return norm16 <= MIN_NORMAL_MAYBE_YES || norm16 == JAMO_VT;
@@ -1072,23 +1072,23 @@ UBool Normalizer2Impl::norm16HasDecompBoundaryBefore(uint16_t norm16) const {
     // c decomposes, get everything from the variable-length extra data
     const uint16_t *mapping=getMapping(norm16);
     uint16_t firstUnit=*mapping;
-    // TRUE if leadCC==0 (hasFCDBoundaryBefore())
+    // true if leadCC==0 (hasFCDBoundaryBefore())
     return (firstUnit&MAPPING_HAS_CCC_LCCC_WORD)==0 || (*(mapping-1)&0xff00)==0;
 }
 
 UBool Normalizer2Impl::hasDecompBoundaryAfter(UChar32 c) const {
     if (c < minDecompNoCP) {
-        return TRUE;
+        return true;
     }
     if (c <= 0xffff && !singleLeadMightHaveNonZeroFCD16(c)) {
-        return TRUE;
+        return true;
     }
     return norm16HasDecompBoundaryAfter(getNorm16(c));
 }
 
 UBool Normalizer2Impl::norm16HasDecompBoundaryAfter(uint16_t norm16) const {
     if(norm16 <= minYesNo || isHangulLVT(norm16)) {
-        return TRUE;
+        return true;
     }
     if (norm16 >= limitNoNo) {
         if (isMaybeOrNonZeroCC(norm16)) {
@@ -1103,13 +1103,13 @@ UBool Normalizer2Impl::norm16HasDecompBoundaryAfter(uint16_t norm16) const {
     // decomp after-boundary: same as hasFCDBoundaryAfter(),
     // fcd16<=1 || trailCC==0
     if(firstUnit>0x1ff) {
-        return FALSE;  // trailCC>1
+        return false;  // trailCC>1
     }
     if(firstUnit<=0xff) {
-        return TRUE;  // trailCC==0
+        return true;  // trailCC==0
     }
     // if(trailCC==1) test leadCC==0, same as checking for before-boundary
-    // TRUE if leadCC==0 (hasFCDBoundaryBefore())
+    // true if leadCC==0 (hasFCDBoundaryBefore())
     return (firstUnit&MAPPING_HAS_CCC_LCCC_WORD)==0 || (*(mapping-1)&0xff00)==0;
 }
 
@@ -1235,7 +1235,7 @@ void Normalizer2Impl::recompose(ReorderingBuffer &buffer, int32_t recomposeStart
     // and are only initialized now to avoid compiler warnings.
     compositionsList=NULL;  // used as indicator for whether we have a forward-combining starter
     starter=NULL;
-    starterIsSupplementary=FALSE;
+    starterIsSupplementary=false;
     prevCC=0;
 
     for(;;) {
@@ -1301,7 +1301,7 @@ void Normalizer2Impl::recompose(ReorderingBuffer &buffer, int32_t recomposeStart
                         *starter=(UChar)composite;
                         // The composite is shorter than the starter,
                         // move the intermediate characters forward one.
-                        starterIsSupplementary=FALSE;
+                        starterIsSupplementary=false;
                         q=starter+1;
                         r=q+1;
                         while(r<pRemove) {
@@ -1312,7 +1312,7 @@ void Normalizer2Impl::recompose(ReorderingBuffer &buffer, int32_t recomposeStart
                 } else if(U_IS_SUPPLEMENTARY(composite)) {
                     // The composite is longer than the starter,
                     // move the intermediate characters back one.
-                    starterIsSupplementary=TRUE;
+                    starterIsSupplementary=true;
                     ++starter;  // temporarily increment for the loop boundary
                     q=pRemove;
                     r=++pRemove;
@@ -1366,10 +1366,10 @@ void Normalizer2Impl::recompose(ReorderingBuffer &buffer, int32_t recomposeStart
             if((compositionsList=getCompositionsListForDecompYes(norm16))!=NULL) {
                 // It may combine with something, prepare for it.
                 if(U_IS_BMP(c)) {
-                    starterIsSupplementary=FALSE;
+                    starterIsSupplementary=false;
                     starter=p-1;
                 } else {
-                    starterIsSupplementary=TRUE;
+                    starterIsSupplementary=true;
                     starter=p-2;
                 }
             }
@@ -1447,7 +1447,7 @@ Normalizer2Impl::compose(const UChar *src, const UChar *limit,
                                            doCompose ? &buffer : NULL,
                                            errorCode);
         if(U_FAILURE(errorCode)) {
-            return FALSE;
+            return false;
         }
         limit=u_strchr(src, 0);
         if (prevBoundary != src) {
@@ -1471,7 +1471,7 @@ Normalizer2Impl::compose(const UChar *src, const UChar *limit,
                 if (prevBoundary != limit && doCompose) {
                     buffer.appendZeroCC(prevBoundary, limit, errorCode);
                 }
-                return TRUE;
+                return true;
             }
             if( (c=*src)<minNoMaybeCP ||
                 isCompYesAndZeroCC(norm16=UCPTRIE_FAST_BMP_GET(normTrie, UCPTRIE_16, c))
@@ -1503,7 +1503,7 @@ Normalizer2Impl::compose(const UChar *src, const UChar *limit,
         // Medium-fast path: Handle cases that do not require full decomposition and recomposition.
         if (!isMaybeOrNonZeroCC(norm16)) {  // minNoNo <= norm16 < minMaybeYes
             if (!doCompose) {
-                return FALSE;
+                return false;
             }
             // Fast path for mapping a character that is immediately surrounded by boundaries.
             // In this case, we need not decompose around the current character.
@@ -1559,7 +1559,7 @@ Normalizer2Impl::compose(const UChar *src, const UChar *limit,
                 UChar l = (UChar)(prev-Hangul::JAMO_L_BASE);
                 if(l<Hangul::JAMO_L_COUNT) {
                     if (!doCompose) {
-                        return FALSE;
+                        return false;
                     }
                     int32_t t;
                     if (src != limit &&
@@ -1599,7 +1599,7 @@ Normalizer2Impl::compose(const UChar *src, const UChar *limit,
                 // The current character is a Jamo Trailing consonant,
                 // compose with previous Hangul LV that does not contain a Jamo T.
                 if (!doCompose) {
-                    return FALSE;
+                    return false;
                 }
                 UChar32 syllable = prev + c - Hangul::JAMO_T_BASE;
                 --prevSrc;  // Replace the Hangul LV as well.
@@ -1622,7 +1622,7 @@ Normalizer2Impl::compose(const UChar *src, const UChar *limit,
             if (onlyContiguous /* FCC */ && getPreviousTrailCC(prevBoundary, prevSrc) > cc) {
                 // Fails FCD test, need to decompose and contiguously recompose.
                 if (!doCompose) {
-                    return FALSE;
+                    return false;
                 }
             } else {
                 // If !onlyContiguous (not FCC), then we ignore the tccc of
@@ -1634,7 +1634,7 @@ Normalizer2Impl::compose(const UChar *src, const UChar *limit,
                         if (doCompose) {
                             buffer.appendZeroCC(prevBoundary, limit, errorCode);
                         }
-                        return TRUE;
+                        return true;
                     }
                     uint8_t prevCC = cc;
                     nextSrc = src;
@@ -1643,7 +1643,7 @@ Normalizer2Impl::compose(const UChar *src, const UChar *limit,
                         cc = getCCFromNormalYesOrMaybe(n16);
                         if (prevCC > cc) {
                             if (!doCompose) {
-                                return FALSE;
+                                return false;
                             }
                             break;
                         }
@@ -1678,28 +1678,28 @@ Normalizer2Impl::compose(const UChar *src, const UChar *limit,
         }
         int32_t recomposeStartIndex=buffer.length();
         // We know there is not a boundary here.
-        decomposeShort(prevSrc, src, FALSE /* !stopAtCompBoundary */, onlyContiguous,
+        decomposeShort(prevSrc, src, false /* !stopAtCompBoundary */, onlyContiguous,
                        buffer, errorCode);
         // Decompose until the next boundary.
-        src = decomposeShort(src, limit, TRUE /* stopAtCompBoundary */, onlyContiguous,
+        src = decomposeShort(src, limit, true /* stopAtCompBoundary */, onlyContiguous,
                              buffer, errorCode);
         if (U_FAILURE(errorCode)) {
             break;
         }
         if ((src - prevSrc) > INT32_MAX) {  // guard before buffer.equals()
             errorCode = U_INDEX_OUTOFBOUNDS_ERROR;
-            return TRUE;
+            return true;
         }
         recompose(buffer, recomposeStartIndex, onlyContiguous);
         if(!doCompose) {
             if(!buffer.equals(prevSrc, src)) {
-                return FALSE;
+                return false;
             }
             buffer.remove();
         }
         prevBoundary=src;
     }
-    return TRUE;
+    return true;
 }
 
 // Very similar to compose(): Make the same changes in both places if relevant.
@@ -1846,7 +1846,7 @@ void Normalizer2Impl::composeAndAppend(const UChar *src, const UChar *limit,
             middle.append(src, (int32_t)(firstStarterInSrc-src));
             const UChar *middleStart=middle.getBuffer();
             compose(middleStart, middleStart+middle.length(), onlyContiguous,
-                    TRUE, buffer, errorCode);
+                    true, buffer, errorCode);
             if(U_FAILURE(errorCode)) {
                 return;
             }
@@ -1854,7 +1854,7 @@ void Normalizer2Impl::composeAndAppend(const UChar *src, const UChar *limit,
         }
     }
     if(doCompose) {
-        compose(src, limit, onlyContiguous, TRUE, buffer, errorCode);
+        compose(src, limit, onlyContiguous, true, buffer, errorCode);
     } else {
         if(limit==NULL) {  // appendZeroCC() needs limit!=NULL
             limit=u_strchr(src, 0);
@@ -1883,7 +1883,7 @@ Normalizer2Impl::composeUTF8(uint32_t options, UBool onlyContiguous,
                     ByteSinkUtil::appendUnchanged(prevBoundary, limit,
                                                   *sink, options, edits, errorCode);
                 }
-                return TRUE;
+                return true;
             }
             if (*src < minNoMaybeLead) {
                 ++src;
@@ -1904,7 +1904,7 @@ Normalizer2Impl::composeUTF8(uint32_t options, UBool onlyContiguous,
         // Medium-fast path: Handle cases that do not require full decomposition and recomposition.
         if (!isMaybeOrNonZeroCC(norm16)) {  // minNoNo <= norm16 < minMaybeYes
             if (sink == nullptr) {
-                return FALSE;
+                return false;
             }
             // Fast path for mapping a character that is immediately surrounded by boundaries.
             // In this case, we need not decompose around the current character.
@@ -1972,7 +1972,7 @@ Normalizer2Impl::composeUTF8(uint32_t options, UBool onlyContiguous,
                 UChar32 l = prev - Hangul::JAMO_L_BASE;
                 if ((uint32_t)l < Hangul::JAMO_L_COUNT) {
                     if (sink == nullptr) {
-                        return FALSE;
+                        return false;
                     }
                     int32_t t = getJamoTMinusBase(src, limit);
                     if (t >= 0) {
@@ -2008,7 +2008,7 @@ Normalizer2Impl::composeUTF8(uint32_t options, UBool onlyContiguous,
                 // The current character is a Jamo Trailing consonant,
                 // compose with previous Hangul LV that does not contain a Jamo T.
                 if (sink == nullptr) {
-                    return FALSE;
+                    return false;
                 }
                 UChar32 syllable = prev + getJamoTMinusBase(prevSrc, src);
                 prevSrc -= 3;  // Replace the Hangul LV as well.
@@ -2031,7 +2031,7 @@ Normalizer2Impl::composeUTF8(uint32_t options, UBool onlyContiguous,
             if (onlyContiguous /* FCC */ && getPreviousTrailCC(prevBoundary, prevSrc) > cc) {
                 // Fails FCD test, need to decompose and contiguously recompose.
                 if (sink == nullptr) {
-                    return FALSE;
+                    return false;
                 }
             } else {
                 // If !onlyContiguous (not FCC), then we ignore the tccc of
@@ -2044,7 +2044,7 @@ Normalizer2Impl::composeUTF8(uint32_t options, UBool onlyContiguous,
                             ByteSinkUtil::appendUnchanged(prevBoundary, limit,
                                                           *sink, options, edits, errorCode);
                         }
-                        return TRUE;
+                        return true;
                     }
                     uint8_t prevCC = cc;
                     nextSrc = src;
@@ -2053,7 +2053,7 @@ Normalizer2Impl::composeUTF8(uint32_t options, UBool onlyContiguous,
                         cc = getCCFromNormalYesOrMaybe(n16);
                         if (prevCC > cc) {
                             if (sink == nullptr) {
-                                return FALSE;
+                                return false;
                             }
                             break;
                         }
@@ -2098,12 +2098,12 @@ Normalizer2Impl::composeUTF8(uint32_t options, UBool onlyContiguous,
         }
         if ((src - prevSrc) > INT32_MAX) {  // guard before buffer.equals()
             errorCode = U_INDEX_OUTOFBOUNDS_ERROR;
-            return TRUE;
+            return true;
         }
         recompose(buffer, 0, onlyContiguous);
         if (!buffer.equals(prevSrc, src)) {
             if (sink == nullptr) {
-                return FALSE;
+                return false;
             }
             if (prevBoundary != prevSrc &&
                     !ByteSinkUtil::appendUnchanged(prevBoundary, prevSrc,
@@ -2117,12 +2117,12 @@ Normalizer2Impl::composeUTF8(uint32_t options, UBool onlyContiguous,
             prevBoundary = src;
         }
     }
-    return TRUE;
+    return true;
 }
 
 UBool Normalizer2Impl::hasCompBoundaryBefore(const UChar *src, const UChar *limit) const {
     if (src == limit || *src < minCompNoMaybeCP) {
-        return TRUE;
+        return true;
     }
     UChar32 c;
     uint16_t norm16;
@@ -2132,7 +2132,7 @@ UBool Normalizer2Impl::hasCompBoundaryBefore(const UChar *src, const UChar *limi
 
 UBool Normalizer2Impl::hasCompBoundaryBefore(const uint8_t *src, const uint8_t *limit) const {
     if (src == limit) {
-        return TRUE;
+        return true;
     }
     uint16_t norm16;
     UCPTRIE_FAST_U8_NEXT(normTrie, UCPTRIE_16, src, limit, norm16);
@@ -2142,7 +2142,7 @@ UBool Normalizer2Impl::hasCompBoundaryBefore(const uint8_t *src, const uint8_t *
 UBool Normalizer2Impl::hasCompBoundaryAfter(const UChar *start, const UChar *p,
                                             UBool onlyContiguous) const {
     if (start == p) {
-        return TRUE;
+        return true;
     }
     UChar32 c;
     uint16_t norm16;
@@ -2153,7 +2153,7 @@ UBool Normalizer2Impl::hasCompBoundaryAfter(const UChar *start, const UChar *p,
 UBool Normalizer2Impl::hasCompBoundaryAfter(const uint8_t *start, const uint8_t *p,
                                             UBool onlyContiguous) const {
     if (start == p) {
-        return TRUE;
+        return true;
     }
     uint16_t norm16;
     UCPTRIE_FAST_U8_PREV(normTrie, UCPTRIE_16, start, p, norm16);
@@ -2399,7 +2399,7 @@ Normalizer2Impl::makeFCD(const UChar *src, const UChar *limit,
              * The source text does not fulfill the conditions for FCD.
              * Decompose and reorder a limited piece of the text.
              */
-            decomposeShort(prevBoundary, src, FALSE, FALSE, *buffer, errorCode);
+            decomposeShort(prevBoundary, src, false, false, *buffer, errorCode);
             if (U_FAILURE(errorCode)) {
                 break;
             }
@@ -2665,7 +2665,7 @@ UBool Normalizer2Impl::isCanonSegmentStarter(UChar32 c) const {
 UBool Normalizer2Impl::getCanonStartSet(UChar32 c, UnicodeSet &set) const {
     int32_t canonValue=getCanonValue(c)&~CANON_NOT_SEGMENT_STARTER;
     if(canonValue==0) {
-        return FALSE;
+        return false;
     }
     set.clear();
     int32_t value=canonValue&CANON_VALUE_MASK;
@@ -2684,7 +2684,7 @@ UBool Normalizer2Impl::getCanonStartSet(UChar32 c, UnicodeSet &set) const {
             addComposites(getCompositionsList(norm16), set);
         }
     }
-    return TRUE;
+    return true;
 }
 
 U_NAMESPACE_END
diff --git a/deps/icu-small/source/common/normalizer2impl.h b/deps/icu-small/source/common/normalizer2impl.h
index 7c85448b71..449e778384 100644
--- a/deps/icu-small/source/common/normalizer2impl.h
+++ b/deps/icu-small/source/common/normalizer2impl.h
@@ -131,7 +131,7 @@ public:
         }
     }
 private:
-    Hangul();  // no instantiation
+    Hangul() = delete;  // no instantiation
 };
 
 class Normalizer2Impl;
@@ -730,7 +730,7 @@ private:
     const uint16_t *extraData;  // mappings and/or compositions for yesYes, yesNo & noNo characters
     const uint8_t *smallFCD;  // [0x100] one bit per 32 BMP code points, set if any FCD!=0
 
-    UInitOnce       fCanonIterDataInitOnce = U_INITONCE_INITIALIZER;
+    UInitOnce       fCanonIterDataInitOnce {};
     CanonIterData  *fCanonIterData;
 };
 
@@ -759,7 +759,7 @@ public:
     // Must be used only when it is known that norm2 is a Normalizer2WithImpl instance.
     static const Normalizer2Impl *getImpl(const Normalizer2 *norm2);
 private:
-    Normalizer2Factory();  // No instantiation.
+    Normalizer2Factory() = delete;  // No instantiation.
 };
 
 U_NAMESPACE_END
diff --git a/deps/icu-small/source/common/normlzr.cpp b/deps/icu-small/source/common/normlzr.cpp
index 1f4fa15179..58de61591f 100644
--- a/deps/icu-small/source/common/normlzr.cpp
+++ b/deps/icu-small/source/common/normlzr.cpp
@@ -205,7 +205,7 @@ Normalizer::isNormalized(const UnicodeString& source,
             return n2->isNormalized(source, status);
         }
     } else {
-        return FALSE;
+        return false;
     }
 }
 
@@ -483,7 +483,7 @@ Normalizer::nextNormalize() {
     currentIndex=nextIndex;
     text->setIndex(nextIndex);
     if(!text->hasNext()) {
-        return FALSE;
+        return false;
     }
     // Skip at least one character so we make progress.
     UnicodeString segment(text->next32PostInc());
@@ -507,7 +507,7 @@ Normalizer::previousNormalize() {
     nextIndex=currentIndex;
     text->setIndex(currentIndex);
     if(!text->hasPrevious()) {
-        return FALSE;
+        return false;
     }
     UnicodeString segment;
     while(text->hasPrevious()) {
diff --git a/deps/icu-small/source/common/patternprops.cpp b/deps/icu-small/source/common/patternprops.cpp
index c38a7e276d..da3243d301 100644
--- a/deps/icu-small/source/common/patternprops.cpp
+++ b/deps/icu-small/source/common/patternprops.cpp
@@ -118,49 +118,49 @@ static const uint32_t syntaxOrWhiteSpace2000[]={
 UBool
 PatternProps::isSyntax(UChar32 c) {
     if(c<0) {
-        return FALSE;
+        return false;
     } else if(c<=0xff) {
         return (UBool)(latin1[c]>>1)&1;
     } else if(c<0x2010) {
-        return FALSE;
+        return false;
     } else if(c<=0x3030) {
         uint32_t bits=syntax2000[index2000[(c-0x2000)>>5]];
         return (UBool)((bits>>(c&0x1f))&1);
     } else if(0xfd3e<=c && c<=0xfe46) {
         return c<=0xfd3f || 0xfe45<=c;
     } else {
-        return FALSE;
+        return false;
     }
 }
 
 UBool
 PatternProps::isSyntaxOrWhiteSpace(UChar32 c) {
     if(c<0) {
-        return FALSE;
+        return false;
     } else if(c<=0xff) {
         return (UBool)(latin1[c]&1);
     } else if(c<0x200e) {
-        return FALSE;
+        return false;
     } else if(c<=0x3030) {
         uint32_t bits=syntaxOrWhiteSpace2000[index2000[(c-0x2000)>>5]];
         return (UBool)((bits>>(c&0x1f))&1);
     } else if(0xfd3e<=c && c<=0xfe46) {
         return c<=0xfd3f || 0xfe45<=c;
     } else {
-        return FALSE;
+        return false;
     }
 }
 
 UBool
 PatternProps::isWhiteSpace(UChar32 c) {
     if(c<0) {
-        return FALSE;
+        return false;
     } else if(c<=0xff) {
         return (UBool)(latin1[c]>>2)&1;
     } else if(0x200e<=c && c<=0x2029) {
         return c<=0x200f || 0x2028<=c;
     } else {
-        return FALSE;
+        return false;
     }
 }
 
@@ -207,15 +207,15 @@ PatternProps::trimWhiteSpace(const UChar *s, int32_t &length) {
 UBool
 PatternProps::isIdentifier(const UChar *s, int32_t length) {
     if(length<=0) {
-        return FALSE;
+        return false;
     }
     const UChar *limit=s+length;
     do {
         if(isSyntaxOrWhiteSpace(*s++)) {
-            return FALSE;
+            return false;
         }
     } while(s<limit);
-    return TRUE;
+    return true;
 }
 
 const UChar *
diff --git a/deps/icu-small/source/common/patternprops.h b/deps/icu-small/source/common/patternprops.h
index 95898d580c..4ead56e1cd 100644
--- a/deps/icu-small/source/common/patternprops.h
+++ b/deps/icu-small/source/common/patternprops.h
@@ -90,7 +90,7 @@ public:
     static const UChar *skipIdentifier(const UChar *s, int32_t length);
 
 private:
-    PatternProps();  // no constructor: all static methods
+    PatternProps() = delete;  // no constructor: all static methods
 };
 
 U_NAMESPACE_END
diff --git a/deps/icu-small/source/common/propname.cpp b/deps/icu-small/source/common/propname.cpp
index a12eb7d913..8f0045fdac 100644
--- a/deps/icu-small/source/common/propname.cpp
+++ b/deps/icu-small/source/common/propname.cpp
@@ -218,7 +218,7 @@ const char *PropNameData::getName(const char *nameGroup, int32_t nameIndex) {
 
 UBool PropNameData::containsName(BytesTrie &trie, const char *name) {
     if(name==NULL) {
-        return FALSE;
+        return false;
     }
     UStringTrieResult result=USTRINGTRIE_NO_VALUE;
     char c;
@@ -229,7 +229,7 @@ UBool PropNameData::containsName(BytesTrie &trie, const char *name) {
             continue;
         }
         if(!USTRINGTRIE_HAS_NEXT(result)) {
-            return FALSE;
+            return false;
         }
         result=trie.next((uint8_t)c);
     }
diff --git a/deps/icu-small/source/common/propname_data.h b/deps/icu-small/source/common/propname_data.h
index c98a0f790b..1e247874b6 100644
--- a/deps/icu-small/source/common/propname_data.h
+++ b/deps/icu-small/source/common/propname_data.h
@@ -11,9 +11,9 @@
 
 U_NAMESPACE_BEGIN
 
-const int32_t PropNameData::indexes[8]={0x20,0x163c,0x521b,0xab62,0xab62,0xab62,0x31,0};
+const int32_t PropNameData::indexes[8]={0x20,0x1660,0x5294,0xacd0,0xacd0,0xacd0,0x31,0};
 
-const int32_t PropNameData::valueMaps[1415]={
+const int32_t PropNameData::valueMaps[1424]={
 6,0,0x48,0,0xf1,0x368,0xf1,0x37e,0xf1,0x393,0xf1,0x3a9,0xf1,0x3b4,0xf1,0x3d5,
 0xf1,0x3e5,0xf1,0x3f4,0xf1,0x402,0xf1,0x426,0xf1,0x43d,0xf1,0x455,0xf1,0x46c,0xf1,0x47b,
 0xf1,0x48a,0xf1,0x49b,0xf1,0x4a9,0xf1,0x4bb,0xf1,0x4d5,0xf1,0x4f0,0xf1,0x505,0xf1,0x522,
@@ -23,12 +23,12 @@ const int32_t PropNameData::valueMaps[1415]={
 0xf1,0x71a,0xf1,0x722,0xf1,0x72b,0xf1,0x738,0xf1,0x74b,0xf1,0x768,0xf1,0x785,0xf1,0x7a2,
 0xf1,0x7c0,0xf1,0x7de,0xf1,0x802,0xf1,0x80f,0xf1,0x829,0xf1,0x83e,0xf1,0x859,0xf1,0x870,
 0xf1,0x887,0xf1,0x8a9,0xf1,0x8c8,0xf1,0x8e1,0xf1,0x90e,0xf1,0x947,0xf1,0x978,0xf1,0x9a7,
-0xf1,0x9d6,0xf1,0x1000,0x1019,0x9eb,0x16d,0xc0b,0x188,0x3196,0xf7,0x31b5,0x2cd,0x32f3,0x2e3,0x334d,
-0x2ed,0x35aa,0x30f,0x3ed5,0x37b,0x3f45,0x385,0x41df,0x3b4,0x421d,0x3bc,0x4d50,0x486,0x4dce,0x490,0x4df3,
-0x496,0x4e0d,0x49c,0x4e2e,0x4a3,0x4e48,0xf7,0x4e6d,0xf7,0x4e93,0x4aa,0x4f3d,0x4c0,0x4fb6,0x4d3,0x5068,
-0x4ee,0x509f,0x4f5,0x527f,0x509,0x56ff,0x531,0x2000,0x2001,0x575e,0x539,0x3000,0x3001,0x57ea,0,0x4000,
-0x400e,0x57fc,0,0x5805,0,0x581f,0,0x5830,0,0x5841,0,0x5857,0,0x5860,0,0x587d,
-0,0x589b,0,0x58b9,0,0x58d7,0,0x58ed,0,0x5901,0,0x5917,0,0x7000,0x7001,0x5930,
+0xf1,0x9d6,0xf1,0x1000,0x1019,0x9eb,0x16d,0xc0b,0x188,0x3279,0xf7,0x3298,0x2d4,0x33d6,0x2ea,0x3430,
+0x2f4,0x368d,0x316,0x3fb8,0x382,0x4028,0x38c,0x42c2,0x3bb,0x4300,0x3c3,0x4e45,0x48f,0x4ec3,0x499,0x4ee8,
+0x49f,0x4f02,0x4a5,0x4f23,0x4ac,0x4f3d,0xf7,0x4f62,0xf7,0x4f88,0x4b3,0x5032,0x4c9,0x50ab,0x4dc,0x515d,
+0x4f7,0x5194,0x4fe,0x5374,0x512,0x57f4,0x53a,0x2000,0x2001,0x5853,0x542,0x3000,0x3001,0x58df,0,0x4000,
+0x400e,0x58f1,0,0x58fa,0,0x5914,0,0x5925,0,0x5936,0,0x594c,0,0x5955,0,0x5972,
+0,0x5990,0,0x59ae,0,0x59cc,0,0x59e2,0,0x59f6,0,0x5a0c,0,0x7000,0x7001,0x5a25,
 0,0x844,0x12,0,1,0x12,0x20,0x862,0x4a,0,1,6,7,8,9,0xa,
 0xb,0xc,0xd,0xe,0xf,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,
 0x1b,0x1c,0x1d,0x1e,0x1f,0x20,0x21,0x22,0x23,0x24,0x54,0x5b,0x67,0x6b,0x76,0x7a,
@@ -38,7 +38,7 @@ const int32_t PropNameData::valueMaps[1415]={
 0x1af,0x1bc,0x1c9,0x1d6,0x1e3,0x1f0,0x1fd,0x20c,0x21b,0x22a,0x239,0x248,0x257,0x266,0x275,0x28f,
 0x2a3,0x2b7,0x2d2,0x2e1,0x2ea,0x2fa,0x302,0x30b,0x31a,0x323,0x333,0x344,0x355,0xa03,1,0,
 0x17,0x9fa,0xa0b,0xa1c,0xa30,0xa47,0xa5f,0xa71,0xa86,0xa9d,0xab2,0xac2,0xad4,0xaf1,0xb0d,0xb1f,
-0xb3c,0xb58,0xb74,0xb89,0xb9e,0xbb8,0xbd3,0xbee,0xba5,1,0,0x141,0xc16,0xc23,0xc36,0xc5e,
+0xb3c,0xb58,0xb74,0xb89,0xb9e,0xbb8,0xbd3,0xbee,0xba5,1,0,0x148,0xc16,0xc23,0xc36,0xc5e,
 0xc7c,0xc9a,0xcb2,0xcdd,0xd07,0xd1f,0xd32,0xd45,0xd54,0xd63,0xd72,0xd81,0xd98,0xda9,0xdbc,0xdcf,
 0xddc,0xde9,0xdf8,0xe09,0xe1e,0xe2f,0xe3a,0xe43,0xe54,0xe65,0xe78,0xe8a,0xe9d,0xeb0,0xeef,0xefc,
 0xf09,0xf16,0xf2b,0xf5b,0xf75,0xf96,0xfc1,0xfe4,0x1042,0x1069,0x1084,0x1093,0x10ba,0x10e2,0x1105,0x1128,
@@ -58,54 +58,54 @@ const int32_t PropNameData::valueMaps[1415]={
 0x2a34,0x2a51,0x2a93,0x2aba,0x2ac7,0x2adc,0x2b00,0x2b26,0x2b5f,0x2b70,0x2b94,0x2b9f,0x2bac,0x2bbb,0x2be0,0x2c0e,
 0x2c2a,0x2c47,0x2c54,0x2c65,0x2c83,0x2ca6,0x2cc3,0x2cd0,0x2cf0,0x2d0d,0x2d2e,0x2d57,0x2d68,0x2d87,0x2da0,0x2db9,
 0x2dca,0x2e13,0x2e24,0x2e3d,0x2e6c,0x2e99,0x2ebe,0x2f00,0x2f1c,0x2f2b,0x2f42,0x2f70,0x2f89,0x2fb2,0x2fcc,0x3007,
-0x3025,0x3034,0x3054,0x306f,0x3093,0x30af,0x30cd,0x30eb,0x3102,0x3111,0x311c,0x3159,0x316c,0x1f6b,1,0,
-0x12,0x31cc,0x31dc,0x31ef,0x31ff,0x320f,0x321e,0x322e,0x3240,0x3253,0x3265,0x3275,0x3285,0x3294,0x32a3,0x32b3,
-0x32c0,0x32cf,0x32e3,0x2029,1,0,6,0x3308,0x3313,0x3320,0x332d,0x333a,0x3345,0x206d,1,0,
-0x1e,0x3362,0x3371,0x3386,0x339b,0x33b0,0x33c4,0x33d5,0x33e9,0x33fc,0x340d,0x3426,0x3438,0x3449,0x345d,0x3470,
-0x3488,0x349a,0x34a5,0x34b5,0x34c3,0x34d8,0x34ed,0x3503,0x351d,0x3533,0x3543,0x3557,0x356b,0x357c,0x3594,0x2298,
-1,0,0x68,0x35bc,0x35df,0x35e8,0x35f5,0x3600,0x3609,0x3614,0x361d,0x3636,0x363b,0x3644,0x3661,0x366a,
-0x3677,0x3680,0x36a4,0x36ab,0x36b4,0x36c7,0x36d2,0x36db,0x36e6,0x36ff,0x3708,0x3717,0x3722,0x372b,0x3736,0x373f,
-0x3746,0x374f,0x375a,0x3763,0x377c,0x3785,0x3792,0x379d,0x37ae,0x37b9,0x37ce,0x37e5,0x37ee,0x37f7,0x3810,0x381b,
-0x3824,0x382d,0x3844,0x3861,0x386c,0x387d,0x3888,0x388f,0x389c,0x38a9,0x38d6,0x38eb,0x38f4,0x390f,0x3932,0x3953,
-0x3974,0x3999,0x39c0,0x39e1,0x3a04,0x3a25,0x3a4c,0x3a6d,0x3a92,0x3ab1,0x3ad0,0x3aef,0x3b0c,0x3b2d,0x3b4e,0x3b71,
-0x3b96,0x3bb5,0x3bd4,0x3bf5,0x3c1c,0x3c41,0x3c60,0x3c81,0x3ca4,0x3cbf,0x3cd8,0x3cf3,0x3d0c,0x3d29,0x3d44,0x3d61,
-0x3d80,0x3d9d,0x3dba,0x3dd9,0x3df6,0x3e11,0x3e2e,0x3e4b,0x3e7e,0x3ea5,0x3eb8,0x25fb,1,0,6,0x3ee6,
-0x3ef5,0x3f05,0x3f15,0x3f25,0x3f36,0x2659,1,0,0x2b,0x3f54,0x3f60,0x3f6e,0x3f7d,0x3f8c,0x3f9c,0x3fad,
-0x3fc1,0x3fd6,0x3fec,0x3fff,0x4013,0x4023,0x402c,0x4037,0x4047,0x4063,0x4075,0x4083,0x4092,0x409e,0x40b3,0x40c7,
-0x40da,0x40e8,0x40fc,0x410a,0x4114,0x4126,0x4132,0x4140,0x4150,0x4157,0x415e,0x4165,0x416c,0x4173,0x4189,0x41aa,
-0x870,0x41bc,0x41c7,0x41d6,0x28b2,1,0,4,0x41f0,0x41fb,0x4207,0x4211,0x28d8,1,0,0xc6,
-0x4228,0x4235,0x424a,0x4257,0x4266,0x4274,0x4283,0x4292,0x42a4,0x42b3,0x42c1,0x42d2,0x42e1,0x42f0,0x42fd,0x4309,
-0x4318,0x4327,0x4331,0x433e,0x434b,0x435a,0x4368,0x4377,0x4383,0x438d,0x4399,0x43a9,0x43b9,0x43c7,0x43d3,0x43e4,
-0x43f0,0x43fc,0x440a,0x4417,0x4423,0x4430,0xe2f,0x443d,0x444b,0x4465,0x446e,0x447c,0x448a,0x4496,0x44a5,0x44b3,
-0x44c1,0x44cd,0x44dc,0x44ea,0x44f8,0x4505,0x4514,0x452f,0x453e,0x454f,0x4560,0x4573,0x4585,0x4594,0x45a6,0x45b5,
-0x45c1,0x45cc,0x1f3f,0x45d9,0x45e4,0x45ef,0x45fa,0x4605,0x4620,0x462b,0x4636,0x4641,0x4654,0x4668,0x4673,0x4682,
-0x4691,0x469c,0x46a7,0x46b4,0x46c3,0x46d1,0x46dc,0x46f7,0x4701,0x4712,0x4723,0x4732,0x4743,0x474e,0x4759,0x4764,
-0x476f,0x477a,0x4785,0x4790,0x479a,0x47a5,0x47b5,0x47c0,0x47ce,0x47db,0x47e6,0x47f5,0x4802,0x480f,0x481e,0x482b,
-0x483c,0x484e,0x485e,0x4869,0x487c,0x4893,0x48a1,0x48ae,0x48b9,0x48c6,0x48d7,0x48f3,0x4909,0x4914,0x4931,0x4941,
-0x4950,0x495b,0x4966,0x2059,0x4972,0x497d,0x4995,0x49a5,0x49b4,0x49c2,0x49d0,0x49db,0x49e6,0x49fa,0x4a11,0x4a29,
-0x4a39,0x4a49,0x4a59,0x4a6b,0x4a76,0x4a81,0x4a8b,0x4a97,0x4aa5,0x4ab8,0x4ac4,0x4ad1,0x4adc,0x4af8,0x4b05,0x4b13,
-0x4b2c,0x2959,0x4b3b,0x277a,0x4b48,0x4b56,0x4b68,0x4b76,0x4b82,0x4b92,0x2b94,0x4ba0,0x4bac,0x4bb7,0x4bc2,0x4bcd,
-0x4be1,0x4bef,0x4c06,0x4c12,0x4c26,0x4c34,0x4c46,0x4c5c,0x4c6a,0x4c7c,0x4c8a,0x4ca7,0x4cb9,0x4cc6,0x4cd7,0x4ce9,
-0x4d03,0x4d10,0x4d23,0x4d34,0x3111,0x4d41,0x331b,1,0,6,0x4d6a,0x4d7d,0x4d8d,0x4d9b,0x4dac,0x4dbc,
-0x3377,0x12,0,1,0x4de6,0x4dec,0x3384,0x12,0,1,0x4de6,0x4dec,0x3391,1,0,3,
-0x4de6,0x4dec,0x4e25,0x33a7,1,0,3,0x4de6,0x4dec,0x4e25,0x33bd,1,0,0x12,0x4eaf,0x4eb9,
-0x4ec5,0x4ecc,0x4ed7,0x4edc,0x4ee3,0x4eea,0x4ef3,0x4ef8,0x4efd,0x4f0d,0x870,0x41bc,0x4f19,0x41c7,0x4f29,0x41d6,
-0x3466,1,0,0xf,0x4eaf,0x4f50,0x4f5a,0x4f64,0x4f6f,0x4092,0x4f79,0x4f85,0x4f8d,0x4f94,0x4f9e,0x4ec5,
-0x4ecc,0x4edc,0x4fa8,0x34ed,1,0,0x17,0x4eaf,0x4fc5,0x4f64,0x4fd1,0x4fde,0x4fec,0x4092,0x4ff7,0x4ec5,
-0x5008,0x4edc,0x5017,0x5025,0x870,0x41aa,0x5031,0x5042,0x41bc,0x4f19,0x41c7,0x4f29,0x41d6,0x5053,0x360a,1,
-0,3,0x5086,0x508e,0x5096,0x3623,1,0,0x10,0x50bf,0x50c6,0x50d5,0x50f6,0x5119,0x5124,0x5143,
-0x515a,0x5167,0x5170,0x518f,0x51c2,0x51dd,0x520c,0x5229,0x524e,0x36bc,1,0,0x24,0x529d,0x52aa,0x52bd,
-0x52ca,0x52f7,0x531c,0x5331,0x5350,0x5371,0x539e,0x53d7,0x53fa,0x541d,0x544a,0x547f,0x54a6,0x54cf,0x5506,0x5535,
-0x5556,0x557b,0x558a,0x55ad,0x55c4,0x55d1,0x55e0,0x55fd,0x5616,0x5639,0x565e,0x5677,0x568c,0x569b,0x56ac,0x56b9,
-0x56da,0x388c,1,0,4,0x5718,0x5723,0x573b,0x5753,0x38c8,0x36,1,2,4,8,0xe,
-0x10,0x20,0x3e,0x40,0x80,0x100,0x1c0,0x200,0x400,0x800,0xe00,0x1000,0x2000,0x4000,0x7000,0x8000,
-0x10000,0x20000,0x40000,0x78001,0x80000,0x100000,0x200000,0x400000,0x800000,0x1000000,0x2000000,0x4000000,0x8000000,0xf000000,0x10000000,0x20000000,
-0x30f80000,0x3362,0x3371,0x3386,0x339b,0x578c,0x33b0,0x33c4,0x5782,0x33d5,0x33e9,0x33fc,0x579d,0x340d,0x3426,0x3438,
-0x57b4,0x3449,0x345d,0x3470,0x57dd,0x3488,0x349a,0x34a5,0x34b5,0x5779,0x34c3,0x34d8,0x34ed,0x3503,0x351d,0x3533,
-0x3543,0x3557,0x356b,0x57d3,0x357c,0x3594,0x57be
+0x3025,0x3034,0x3054,0x306f,0x3093,0x30af,0x30cd,0x30eb,0x3102,0x3111,0x311c,0x3159,0x316c,0x3196,0x31b6,0x31e4,
+0x3208,0x3230,0x3255,0x3260,0x1fa9,1,0,0x12,0x32af,0x32bf,0x32d2,0x32e2,0x32f2,0x3301,0x3311,0x3323,
+0x3336,0x3348,0x3358,0x3368,0x3377,0x3386,0x3396,0x33a3,0x33b2,0x33c6,0x2067,1,0,6,0x33eb,0x33f6,
+0x3403,0x3410,0x341d,0x3428,0x20ab,1,0,0x1e,0x3445,0x3454,0x3469,0x347e,0x3493,0x34a7,0x34b8,0x34cc,
+0x34df,0x34f0,0x3509,0x351b,0x352c,0x3540,0x3553,0x356b,0x357d,0x3588,0x3598,0x35a6,0x35bb,0x35d0,0x35e6,0x3600,
+0x3616,0x3626,0x363a,0x364e,0x365f,0x3677,0x22d6,1,0,0x68,0x369f,0x36c2,0x36cb,0x36d8,0x36e3,0x36ec,
+0x36f7,0x3700,0x3719,0x371e,0x3727,0x3744,0x374d,0x375a,0x3763,0x3787,0x378e,0x3797,0x37aa,0x37b5,0x37be,0x37c9,
+0x37e2,0x37eb,0x37fa,0x3805,0x380e,0x3819,0x3822,0x3829,0x3832,0x383d,0x3846,0x385f,0x3868,0x3875,0x3880,0x3891,
+0x389c,0x38b1,0x38c8,0x38d1,0x38da,0x38f3,0x38fe,0x3907,0x3910,0x3927,0x3944,0x394f,0x3960,0x396b,0x3972,0x397f,
+0x398c,0x39b9,0x39ce,0x39d7,0x39f2,0x3a15,0x3a36,0x3a57,0x3a7c,0x3aa3,0x3ac4,0x3ae7,0x3b08,0x3b2f,0x3b50,0x3b75,
+0x3b94,0x3bb3,0x3bd2,0x3bef,0x3c10,0x3c31,0x3c54,0x3c79,0x3c98,0x3cb7,0x3cd8,0x3cff,0x3d24,0x3d43,0x3d64,0x3d87,
+0x3da2,0x3dbb,0x3dd6,0x3def,0x3e0c,0x3e27,0x3e44,0x3e63,0x3e80,0x3e9d,0x3ebc,0x3ed9,0x3ef4,0x3f11,0x3f2e,0x3f61,
+0x3f88,0x3f9b,0x2639,1,0,6,0x3fc9,0x3fd8,0x3fe8,0x3ff8,0x4008,0x4019,0x2697,1,0,0x2b,
+0x4037,0x4043,0x4051,0x4060,0x406f,0x407f,0x4090,0x40a4,0x40b9,0x40cf,0x40e2,0x40f6,0x4106,0x410f,0x411a,0x412a,
+0x4146,0x4158,0x4166,0x4175,0x4181,0x4196,0x41aa,0x41bd,0x41cb,0x41df,0x41ed,0x41f7,0x4209,0x4215,0x4223,0x4233,
+0x423a,0x4241,0x4248,0x424f,0x4256,0x426c,0x428d,0x870,0x429f,0x42aa,0x42b9,0x28f0,1,0,4,0x42d3,
+0x42de,0x42ea,0x42f4,0x2916,1,0,0xc8,0x430b,0x4318,0x432d,0x433a,0x4349,0x4357,0x4366,0x4375,0x4387,
+0x4396,0x43a4,0x43b5,0x43c4,0x43d3,0x43e0,0x43ec,0x43fb,0x440a,0x4414,0x4421,0x442e,0x443d,0x444b,0x445a,0x4466,
+0x4470,0x447c,0x448c,0x449c,0x44aa,0x44b6,0x44c7,0x44d3,0x44df,0x44ed,0x44fa,0x4506,0x4513,0xe2f,0x4520,0x452e,
+0x4548,0x4551,0x455f,0x456d,0x4579,0x4588,0x4596,0x45a4,0x45b0,0x45bf,0x45cd,0x45db,0x45e8,0x45f7,0x4612,0x4621,
+0x4632,0x4643,0x4656,0x4668,0x4677,0x4689,0x4698,0x46a4,0x46af,0x1f3f,0x46bc,0x46c7,0x46d2,0x46dd,0x46e8,0x4703,
+0x470e,0x4719,0x4724,0x4737,0x474b,0x4756,0x4765,0x4774,0x477f,0x478a,0x4797,0x47a6,0x47b4,0x47bf,0x47da,0x47e4,
+0x47f5,0x4806,0x4815,0x4826,0x4831,0x483c,0x4847,0x4852,0x485d,0x4868,0x4873,0x487d,0x4888,0x4898,0x48a3,0x48b1,
+0x48be,0x48c9,0x48d8,0x48e5,0x48f2,0x4901,0x490e,0x491f,0x4931,0x4941,0x494c,0x495f,0x4976,0x4984,0x4991,0x499c,
+0x49a9,0x49ba,0x49d6,0x49ec,0x49f7,0x4a14,0x4a24,0x4a33,0x4a3e,0x4a49,0x2059,0x4a55,0x4a60,0x4a78,0x4a88,0x4a97,
+0x4aa5,0x4ab3,0x4abe,0x4ac9,0x4add,0x4af4,0x4b0c,0x4b1c,0x4b2c,0x4b3c,0x4b4e,0x4b59,0x4b64,0x4b6e,0x4b7a,0x4b88,
+0x4b9b,0x4ba7,0x4bb4,0x4bbf,0x4bdb,0x4be8,0x4bf6,0x4c0f,0x2959,0x4c1e,0x277a,0x4c2b,0x4c39,0x4c4b,0x4c59,0x4c65,
+0x4c75,0x2b94,0x4c83,0x4c8f,0x4c9a,0x4ca5,0x4cb0,0x4cc4,0x4cd2,0x4ce9,0x4cf5,0x4d09,0x4d17,0x4d29,0x4d3f,0x4d4d,
+0x4d5f,0x4d6d,0x4d8a,0x4d9c,0x4da9,0x4dba,0x4dcc,0x4de6,0x4df3,0x4e06,0x4e17,0x3111,0x4e24,0x3255,0x4e33,0x3370,
+1,0,6,0x4e5f,0x4e72,0x4e82,0x4e90,0x4ea1,0x4eb1,0x33cc,0x12,0,1,0x4edb,0x4ee1,0x33d9,
+0x12,0,1,0x4edb,0x4ee1,0x33e6,1,0,3,0x4edb,0x4ee1,0x4f1a,0x33fc,1,0,3,
+0x4edb,0x4ee1,0x4f1a,0x3412,1,0,0x12,0x4fa4,0x4fae,0x4fba,0x4fc1,0x4fcc,0x4fd1,0x4fd8,0x4fdf,0x4fe8,
+0x4fed,0x4ff2,0x5002,0x870,0x429f,0x500e,0x42aa,0x501e,0x42b9,0x34bb,1,0,0xf,0x4fa4,0x5045,0x504f,
+0x5059,0x5064,0x4175,0x506e,0x507a,0x5082,0x5089,0x5093,0x4fba,0x4fc1,0x4fd1,0x509d,0x3542,1,0,0x17,
+0x4fa4,0x50ba,0x5059,0x50c6,0x50d3,0x50e1,0x4175,0x50ec,0x4fba,0x50fd,0x4fd1,0x510c,0x511a,0x870,0x428d,0x5126,
+0x5137,0x429f,0x500e,0x42aa,0x501e,0x42b9,0x5148,0x365f,1,0,3,0x517b,0x5183,0x518b,0x3678,1,
+0,0x10,0x51b4,0x51bb,0x51ca,0x51eb,0x520e,0x5219,0x5238,0x524f,0x525c,0x5265,0x5284,0x52b7,0x52d2,0x5301,
+0x531e,0x5343,0x3711,1,0,0x24,0x5392,0x539f,0x53b2,0x53bf,0x53ec,0x5411,0x5426,0x5445,0x5466,0x5493,
+0x54cc,0x54ef,0x5512,0x553f,0x5574,0x559b,0x55c4,0x55fb,0x562a,0x564b,0x5670,0x567f,0x56a2,0x56b9,0x56c6,0x56d5,
+0x56f2,0x570b,0x572e,0x5753,0x576c,0x5781,0x5790,0x57a1,0x57ae,0x57cf,0x38e1,1,0,4,0x580d,0x5818,
+0x5830,0x5848,0x391d,0x36,1,2,4,8,0xe,0x10,0x20,0x3e,0x40,0x80,0x100,0x1c0,
+0x200,0x400,0x800,0xe00,0x1000,0x2000,0x4000,0x7000,0x8000,0x10000,0x20000,0x40000,0x78001,0x80000,0x100000,0x200000,
+0x400000,0x800000,0x1000000,0x2000000,0x4000000,0x8000000,0xf000000,0x10000000,0x20000000,0x30f80000,0x3445,0x3454,0x3469,0x347e,0x5881,0x3493,
+0x34a7,0x5877,0x34b8,0x34cc,0x34df,0x5892,0x34f0,0x3509,0x351b,0x58a9,0x352c,0x3540,0x3553,0x58d2,0x356b,0x357d,
+0x3588,0x3598,0x586e,0x35a6,0x35bb,0x35d0,0x35e6,0x3600,0x3616,0x3626,0x363a,0x364e,0x58c8,0x365f,0x3677,0x58b3
 };
 
-const uint8_t PropNameData::bytesTries[15327]={
+const uint8_t PropNameData::bytesTries[15412]={
 0,0x15,0x6d,0xc3,0xc7,0x73,0xc2,0x12,0x76,0x7a,0x76,0x6a,0x77,0xa2,0x52,0x78,
 1,0x64,0x50,0x69,0x10,0x64,1,0x63,0x30,0x73,0x62,0x13,0x74,0x61,0x72,0x74,
 0x63,0x60,0x16,0x6f,0x6e,0x74,0x69,0x6e,0x75,0x65,0x61,0x13,0x69,0x67,0x69,0x74,
@@ -292,7 +292,7 @@ const uint8_t PropNameData::bytesTries[15327]={
 0x74,0x6f,0x72,0x2d,2,0x6c,0x3b,0x6e,0x2b,0x72,0x13,0x61,0x62,0x69,0x63,1,
 0x6c,0x30,0x6e,0x14,0x75,0x6d,0x62,0x65,0x72,0x2b,0x14,0x65,0x74,0x74,0x65,0x72,
 0x3b,0x2e,1,0x6e,0x45,0x6f,0x1c,0x75,0x6e,0x64,0x61,0x72,0x79,0x6e,0x65,0x75,
-0x74,0x72,0x61,0x6c,0x45,0,0x16,0x6d,0xc9,0x14,0x74,0xc2,0x30,0x77,0x89,0x77,
+0x74,0x72,0x61,0x6c,0x45,0,0x16,0x6d,0xc9,0x20,0x74,0xc2,0x30,0x77,0x89,0x77,
 0x86,0x79,0xa2,0x46,0x7a,1,0x61,0x58,0x6e,0x1a,0x61,0x6d,0x65,0x6e,0x6e,0x79,
 0x6d,0x75,0x73,0x69,0x63,0xa4,0x40,0x19,0x61,0x6c,0x6e,0x6f,0x74,0x61,0x74,0x69,
 0x6f,0x6e,0xa5,0x40,0x1c,0x6e,0x61,0x62,0x61,0x7a,0x61,0x72,0x73,0x71,0x75,0x61,
@@ -436,637 +436,643 @@ const uint8_t PropNameData::bytesTries[15327]={
 0x6e,0x67,0xa5,0x27,0x10,0x6f,0xa3,0x92,0x14,0x62,0x6c,0x6f,0x63,0x6b,0x21,1,
 0x6d,0x2c,0x73,0x11,0x68,0x75,0xa5,0x15,0x17,0x62,0x65,0x72,0x66,0x6f,0x72,0x6d,
 0x73,0x7b,0x61,0x44,0x62,0x21,0x65,0x10,0x77,1,0x61,0xa5,0xe,0x74,0x14,0x61,
-0x69,0x6c,0x75,0x65,0xa3,0x8b,1,0x62,0x38,0x6e,0x17,0x64,0x69,0x6e,0x61,0x67,
-0x61,0x72,0x69,0xa5,0x26,0x15,0x61,0x74,0x61,0x65,0x61,0x6e,0xa3,0xef,0x67,0xc4,
-0x43,0x6a,0xc1,0xca,0x6a,0xa2,0xdf,0x6b,0xa2,0xf8,0x6c,4,0x61,0x54,0x65,0xa2,
-0x6b,0x69,0xa2,0x82,0x6f,0xa2,0xc1,0x79,1,0x63,0x2e,0x64,0x12,0x69,0x61,0x6e,
-0xa3,0xa9,0x12,0x69,0x61,0x6e,0xa3,0xa7,1,0x6f,0x55,0x74,0x11,0x69,0x6e,1,
-0x31,0x96,0x65,0x11,0x78,0x74,6,0x64,0x21,0x64,0xa3,0x95,0x65,0x2c,0x66,0xa5,
-0x39,0x67,0xa5,0x3a,0xa2,0xe7,0x13,0x6e,0x64,0x65,0x64,6,0x64,0xc,0x64,0xa3,
-0x95,0x65,0xa3,0xe7,0x66,0xa5,0x39,0x67,0xa5,0x3a,0x61,0x2a,0x62,0x29,0x63,0xa3,
-0x94,0x26,0x18,0x64,0x64,0x69,0x74,0x69,0x6f,0x6e,0x61,0x6c,0x6d,0x24,0x12,0x73,
-0x75,0x70,0x24,0x16,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x25,1,0x70,0x42,0x74,
-0x1d,0x74,0x65,0x72,0x6c,0x69,0x6b,0x65,0x73,0x79,0x6d,0x62,0x6f,0x6c,0x73,0x79,
-0x12,0x63,0x68,0x61,0xa3,0x9c,2,0x6d,0x4e,0x6e,0x54,0x73,0x10,0x75,0xa2,0xb0,
-0x12,0x73,0x75,0x70,0xa4,0x31,0x16,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0xa5,0x31,
-0x11,0x62,0x75,0xa3,0x6f,0x12,0x65,0x61,0x72,1,0x61,0xa3,0xe8,0x62,1,0x69,
-0x38,0x73,0x17,0x79,0x6c,0x6c,0x61,0x62,0x61,0x72,0x79,0xa3,0x75,0x17,0x64,0x65,
-0x6f,0x67,0x72,0x61,0x6d,0x73,0xa3,0x76,0x1a,0x77,0x73,0x75,0x72,0x72,0x6f,0x67,
-0x61,0x74,0x65,0x73,0xa3,0x4d,0x10,0x61,1,0x6d,0x32,0x76,0x14,0x61,0x6e,0x65,
-0x73,0x65,0xa3,0xb5,0x10,0x6f,0x5c,0x12,0x65,0x78,0x74,1,0x61,0xa3,0xb4,0x62,
-0xa3,0xb9,1,0x61,0xa2,0x43,0x68,4,0x61,0x40,0x69,0x50,0x6d,0x6e,0x6f,0x86,
-0x75,0x15,0x64,0x61,0x77,0x61,0x64,0x69,0xa3,0xe6,0x16,0x72,0x6f,0x73,0x68,0x74,
-0x68,0x69,0xa3,0x89,0x1d,0x74,0x61,0x6e,0x73,0x6d,0x61,0x6c,0x6c,0x73,0x63,0x72,
-0x69,0x70,0x74,0xa5,0x30,0x11,0x65,0x72,0x68,0x16,0x73,0x79,0x6d,0x62,0x6f,0x6c,
-0x73,0xa3,0x71,0x12,0x6a,0x6b,0x69,0xa3,0xe5,3,0x69,0x3a,0x6e,0x42,0x74,0xa2,
-0x58,0x79,0x13,0x61,0x68,0x6c,0x69,0xa3,0xa2,0x12,0x74,0x68,0x69,0xa3,0xc1,3,
-0x61,0x34,0x62,0x84,0x67,0x8a,0x6e,0x12,0x61,0x64,0x61,0x4d,1,0x65,0x40,0x73,
-0x11,0x75,0x70,0xa2,0xcb,0x16,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0xa3,0xcb,0x11,
-0x78,0x74,2,0x61,0xa5,0x13,0x62,0xa5,0x38,0x65,0x13,0x6e,0x64,0x65,0x64,1,
-0x61,0xa5,0x13,0x62,0xa5,0x38,0x11,0x75,0x6e,0xa3,0x42,0x11,0x78,0x69,0x96,0x17,
-0x72,0x61,0x64,0x69,0x63,0x61,0x6c,0x73,0x97,0x14,0x61,0x6b,0x61,0x6e,0x61,0x9e,
-1,0x65,0x4c,0x70,0x10,0x68,0x1f,0x6f,0x6e,0x65,0x74,0x69,0x63,0x65,0x78,0x74,
-0x65,0x6e,0x73,0x69,0x6f,0x6e,0x73,0xa3,0x6b,0x11,0x78,0x74,0xa3,0x6b,0x67,0xa2,
-0xb5,0x68,0xa4,0x84,0x69,3,0x64,0x4c,0x6d,0xa2,0x55,0x6e,0xa2,0x62,0x70,0x13,
-0x61,0x65,0x78,0x74,0x2a,0x16,0x65,0x6e,0x73,0x69,0x6f,0x6e,0x73,0x2b,1,0x63,
-0x99,0x65,0x17,0x6f,0x67,0x72,0x61,0x70,0x68,0x69,0x63,1,0x64,0x56,0x73,0x15,
-0x79,0x6d,0x62,0x6f,0x6c,0x73,0xa4,0xb,0x1d,0x61,0x6e,0x64,0x70,0x75,0x6e,0x63,
-0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0xa5,0xb,0x13,0x65,0x73,0x63,0x72,0x1f,0x69,
-0x70,0x74,0x69,0x6f,0x6e,0x63,0x68,0x61,0x72,0x61,0x63,0x74,0x65,0x72,0x73,0x99,
-0x1c,0x70,0x65,0x72,0x69,0x61,0x6c,0x61,0x72,0x61,0x6d,0x61,0x69,0x63,0xa3,0xba,
-1,0x64,0x62,0x73,0x1b,0x63,0x72,0x69,0x70,0x74,0x69,0x6f,0x6e,0x61,0x6c,0x70,
-0x61,1,0x68,0x32,0x72,0x14,0x74,0x68,0x69,0x61,0x6e,0xa3,0xbd,0x13,0x6c,0x61,
-0x76,0x69,0xa3,0xbe,0x11,0x69,0x63,1,0x6e,0x3e,0x73,0x1a,0x69,0x79,0x61,0x71,
-0x6e,0x75,0x6d,0x62,0x65,0x72,0x73,0xa5,0x1e,0x19,0x75,0x6d,0x62,0x65,0x72,0x66,
-0x6f,0x72,0x6d,0x73,0xa3,0xb2,4,0x65,0x74,0x6c,0xa2,0x82,0x6f,0xa2,0x9a,0x72,
-0xa2,0x9e,0x75,2,0x6a,0x34,0x6e,0x3e,0x72,0x14,0x6d,0x75,0x6b,0x68,0x69,0x43,
-0x14,0x61,0x72,0x61,0x74,0x69,0x45,0x18,0x6a,0x61,0x6c,0x61,0x67,0x6f,0x6e,0x64,
-0x69,0xa5,0x1c,1,0x6e,0xa2,0x46,0x6f,1,0x6d,0x6e,0x72,0x13,0x67,0x69,0x61,
-0x6e,0x5a,1,0x65,0x40,0x73,0x11,0x75,0x70,0xa2,0x87,0x16,0x70,0x6c,0x65,0x6d,
-0x65,0x6e,0x74,0xa3,0x87,0x11,0x78,0x74,0xa4,0x1b,0x14,0x65,0x6e,0x64,0x65,0x64,
-0xa5,0x1b,0x1a,0x65,0x74,0x72,0x69,0x63,0x73,0x68,0x61,0x70,0x65,0x73,0x8c,0x12,
-0x65,0x78,0x74,0xa2,0xe3,0x14,0x65,0x6e,0x64,0x65,0x64,0xa3,0xe3,0x1e,0x65,0x72,
-0x61,0x6c,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0x71,0x17,0x61,
-0x67,0x6f,0x6c,0x69,0x74,0x69,0x63,0xa2,0x88,0x12,0x73,0x75,0x70,0xa4,0xa,0x16,
-0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0xa5,0xa,0x13,0x74,0x68,0x69,0x63,0xa3,0x59,
-1,0x61,0x5c,0x65,0x11,0x65,0x6b,0x30,1,0x61,0x38,0x65,0x11,0x78,0x74,0x6e,
-0x14,0x65,0x6e,0x64,0x65,0x64,0x6f,0x17,0x6e,0x64,0x63,0x6f,0x70,0x74,0x69,0x63,
-0x31,0x13,0x6e,0x74,0x68,0x61,0xa3,0xe4,2,0x61,0xa2,0x48,0x65,0xa2,0xdf,0x69,
-1,0x67,0x30,0x72,0x14,0x61,0x67,0x61,0x6e,0x61,0x9d,0x10,0x68,1,0x70,0x3a,
-0x73,0x18,0x75,0x72,0x72,0x6f,0x67,0x61,0x74,0x65,0x73,0xa3,0x4b,1,0x72,0x3c,
-0x75,0x19,0x73,0x75,0x72,0x72,0x6f,0x67,0x61,0x74,0x65,0x73,0xa3,0x4c,0x11,0x69,
-0x76,0x1f,0x61,0x74,0x65,0x75,0x73,0x65,0x73,0x75,0x72,0x72,0x6f,0x67,0x61,0x74,
-0x65,0x73,0xa3,0x4c,2,0x6c,0x32,0x6e,0x9a,0x74,0x12,0x72,0x61,0x6e,0xa5,2,
-0x10,0x66,2,0x61,0x58,0x6d,0x70,0x77,0x14,0x69,0x64,0x74,0x68,0x61,0x1f,0x6e,
-0x64,0x66,0x75,0x6c,0x6c,0x77,0x69,0x64,0x74,0x68,0x66,0x6f,0x72,0x6d,0x73,0xa3,
-0x57,0x1a,0x6e,0x64,0x66,0x75,0x6c,0x6c,0x66,0x6f,0x72,0x6d,0x73,0xa3,0x57,0x13,
-0x61,0x72,0x6b,0x73,0xa3,0x52,2,0x67,0x34,0x69,0xa2,0x45,0x75,0x12,0x6e,0x6f,
-0x6f,0xa3,0x63,0x11,0x75,0x6c,0xa2,0x4a,2,0x63,0x3c,0x6a,0x5e,0x73,0x17,0x79,
-0x6c,0x6c,0x61,0x62,0x6c,0x65,0x73,0xa3,0x4a,0x1f,0x6f,0x6d,0x70,0x61,0x74,0x69,
-0x62,0x69,0x6c,0x69,0x74,0x79,0x6a,0x61,0x6d,0x6f,0xa3,0x41,0x12,0x61,0x6d,0x6f,
-0x5c,0x17,0x65,0x78,0x74,0x65,0x6e,0x64,0x65,0x64,1,0x61,0xa3,0xb4,0x62,0xa3,
-0xb9,0x19,0x66,0x69,0x72,0x6f,0x68,0x69,0x6e,0x67,0x79,0x61,0xa5,0x1d,0x13,0x62,
-0x72,0x65,0x77,0x37,0x61,0xa4,0xc,0x62,0xa6,0x53,0x63,0xa8,0x28,0x64,0xac,0xd3,
-0x65,5,0x6d,0xa9,0x6d,0x94,0x6e,0xa2,0x41,0x74,0x15,0x68,0x69,0x6f,0x70,0x69,
-0x63,0x5e,1,0x65,0x40,0x73,0x11,0x75,0x70,0xa2,0x86,0x16,0x70,0x6c,0x65,0x6d,
-0x65,0x6e,0x74,0xa3,0x86,0x11,0x78,0x74,0xa2,0x85,2,0x61,0xa3,0xc8,0x62,0xa5,
-0x37,0x65,0x13,0x6e,0x64,0x65,0x64,0xa2,0x85,1,0x61,0xa3,0xc8,0x62,0xa5,0x37,
-0x16,0x6f,0x74,0x69,0x63,0x6f,0x6e,0x73,0xa3,0xce,0x15,0x63,0x6c,0x6f,0x73,0x65,
-0x64,2,0x61,0x5a,0x63,0x9e,0x69,0x1c,0x64,0x65,0x6f,0x67,0x72,0x61,0x70,0x68,
-0x69,0x63,0x73,0x75,0x70,0xa2,0xc4,0x16,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0xa3,
-0xc4,0x16,0x6c,0x70,0x68,0x61,0x6e,0x75,0x6d,0x86,1,0x65,0x2c,0x73,0x11,0x75,
-0x70,0xa3,0xc3,0x13,0x72,0x69,0x63,0x73,0x86,0x18,0x75,0x70,0x70,0x6c,0x65,0x6d,
-0x65,0x6e,0x74,0xa3,0xc3,0x11,0x6a,0x6b,0xa2,0x44,0x1f,0x6c,0x65,0x74,0x74,0x65,
-0x72,0x73,0x61,0x6e,0x64,0x6d,0x6f,0x6e,0x74,0x68,0x73,0xa3,0x44,0x61,0x4a,0x67,
-0x76,0x6c,1,0x62,0x30,0x79,0x13,0x6d,0x61,0x69,0x63,0xa5,0x25,0x13,0x61,0x73,
-0x61,0x6e,0xa3,0xe2,0x13,0x72,0x6c,0x79,0x64,0x1f,0x79,0x6e,0x61,0x73,0x74,0x69,
-0x63,0x63,0x75,0x6e,0x65,0x69,0x66,0x6f,0x72,0x6d,0xa5,1,0x1f,0x79,0x70,0x74,
-0x69,0x61,0x6e,0x68,0x69,0x65,0x72,0x6f,0x67,0x6c,0x79,0x70,0x68,1,0x66,0x26,
-0x73,0xa3,0xc2,0x1c,0x6f,0x72,0x6d,0x61,0x74,0x63,0x6f,0x6e,0x74,0x72,0x6f,0x6c,
-0x73,0xa5,0x24,7,0x6e,0xc0,0xec,0x6e,0x3e,0x72,0xa2,0x5d,0x73,0xa2,0xdf,0x76,
-0x14,0x65,0x73,0x74,0x61,0x6e,0xa3,0xbc,1,0x61,0x92,0x63,0x13,0x69,0x65,0x6e,
-0x74,1,0x67,0x34,0x73,0x15,0x79,0x6d,0x62,0x6f,0x6c,0x73,0xa3,0xa5,0x13,0x72,
-0x65,0x65,0x6b,1,0x6d,0x34,0x6e,0x15,0x75,0x6d,0x62,0x65,0x72,0x73,0xa3,0x7f,
-0x13,0x75,0x73,0x69,0x63,0xa2,0x7e,0x19,0x61,0x6c,0x6e,0x6f,0x74,0x61,0x74,0x69,
-0x6f,0x6e,0xa3,0x7e,0x10,0x74,0x1f,0x6f,0x6c,0x69,0x61,0x6e,0x68,0x69,0x65,0x72,
-0x6f,0x67,0x6c,0x79,0x70,0x68,0x73,0xa3,0xfe,2,0x61,0x32,0x6d,0xa2,0x78,0x72,
-0x12,0x6f,0x77,0x73,0x7d,0x12,0x62,0x69,0x63,0x38,3,0x65,0x4a,0x6d,0x74,0x70,
-0xa2,0x4a,0x73,0x11,0x75,0x70,0xa2,0x80,0x16,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,
-0xa3,0x80,0x11,0x78,0x74,2,0x61,0xa3,0xd2,0x62,0xa5,0x35,0x65,0x13,0x6e,0x64,
-0x65,0x64,1,0x61,0xa3,0xd2,0x62,0xa5,0x35,0x12,0x61,0x74,0x68,0xa2,0xd3,0x18,
-0x65,0x6d,0x61,0x74,0x69,0x63,0x61,0x6c,0x61,0x1f,0x6c,0x70,0x68,0x61,0x62,0x65,
-0x74,0x69,0x63,0x73,0x79,0x6d,0x62,0x6f,0x6c,0x73,0xa3,0xd3,1,0x66,0x42,0x72,
-0x1e,0x65,0x73,0x65,0x6e,0x74,0x61,0x74,0x69,0x6f,0x6e,0x66,0x6f,0x72,0x6d,0x73,
-1,0x61,0xa3,0x51,0x62,0xa3,0x55,0x14,0x65,0x6e,0x69,0x61,0x6e,0x35,0x12,0x63,
-0x69,0x69,0x23,0x64,0x9e,0x65,0xa2,0x42,0x68,0xa2,0x4d,0x6c,1,0x63,0x62,0x70,
-0x17,0x68,0x61,0x62,0x65,0x74,0x69,0x63,0x70,1,0x66,0xa3,0x50,0x72,0x1e,0x65,
-0x73,0x65,0x6e,0x74,0x61,0x74,0x69,0x6f,0x6e,0x66,0x6f,0x72,0x6d,0x73,0xa3,0x50,
-0x16,0x68,0x65,0x6d,0x69,0x63,0x61,0x6c,0xa2,0xd0,0x16,0x73,0x79,0x6d,0x62,0x6f,
-0x6c,0x73,0xa3,0xd0,0x12,0x6c,0x61,0x6d,0xa5,7,0x1a,0x67,0x65,0x61,0x6e,0x6e,
-0x75,0x6d,0x62,0x65,0x72,0x73,0xa3,0x77,0x11,0x6f,0x6d,0xa3,0xfd,7,0x6f,0x71,
-0x6f,0x64,0x72,0xa2,0x41,0x75,0xa2,0x58,0x79,0x1b,0x7a,0x61,0x6e,0x74,0x69,0x6e,
-0x65,0x6d,0x75,0x73,0x69,0x63,0xa2,0x5b,0x18,0x61,0x6c,0x73,0x79,0x6d,0x62,0x6f,
-0x6c,0x73,0xa3,0x5b,1,0x70,0x34,0x78,0x16,0x64,0x72,0x61,0x77,0x69,0x6e,0x67,
-0x89,0x14,0x6f,0x6d,0x6f,0x66,0x6f,0xa0,0x12,0x65,0x78,0x74,0xa2,0x43,0x14,0x65,
-0x6e,0x64,0x65,0x64,0xa3,0x43,0x10,0x61,1,0x68,0x40,0x69,0x12,0x6c,0x6c,0x65,
-0x92,0x17,0x70,0x61,0x74,0x74,0x65,0x72,0x6e,0x73,0x93,0x11,0x6d,0x69,0xa3,0xc9,
-1,0x67,0x2c,0x68,0x11,0x69,0x64,0xa3,0x64,0x14,0x69,0x6e,0x65,0x73,0x65,0xa3,
-0x81,0x61,0x48,0x65,0xa2,0x4e,0x68,0xa2,0x52,0x6c,0x1a,0x6f,0x63,0x6b,0x65,0x6c,
-0x65,0x6d,0x65,0x6e,0x74,0x73,0x8b,3,0x6c,0x34,0x6d,0x40,0x73,0x66,0x74,0x11,
-0x61,0x6b,0xa3,0xc7,0x14,0x69,0x6e,0x65,0x73,0x65,0xa3,0x93,0x11,0x75,0x6d,0xa2,
-0xb1,0x12,0x73,0x75,0x70,0xa2,0xca,0x16,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0xa3,
-0xca,1,0x69,0x30,0x73,0x13,0x61,0x76,0x61,0x68,0xa3,0xdd,0x15,0x63,0x6c,0x61,
-0x74,0x69,0x6e,0x23,0x14,0x6e,0x67,0x61,0x6c,0x69,0x41,0x16,0x61,0x69,0x6b,0x73,
-0x75,0x6b,0x69,0xa5,8,5,0x6f,0xc1,0x59,0x6f,0xa2,0x62,0x75,0xa4,0x1d,0x79,
-1,0x70,0x9c,0x72,0x14,0x69,0x6c,0x6c,0x69,0x63,0x32,1,0x65,0x4c,0x73,0x11,
-0x75,0x70,0xa2,0x61,0x16,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0xa2,0x61,0x12,0x61,
-0x72,0x79,0xa3,0x61,0x11,0x78,0x74,3,0x61,0xa3,0x9e,0x62,0xa3,0xa0,0x63,0xa5,
-9,0x65,0x13,0x6e,0x64,0x65,0x64,2,0x61,0xa3,0x9e,0x62,0xa3,0xa0,0x63,0xa5,
-9,0x10,0x72,1,0x69,0x34,0x6f,0x15,0x6d,0x69,0x6e,0x6f,0x61,0x6e,0xa5,0x36,
-0x1a,0x6f,0x74,0x73,0x79,0x6c,0x6c,0x61,0x62,0x61,0x72,0x79,0xa3,0x7b,3,0x6d,
-0x5a,0x6e,0xa2,0x95,0x70,0xa2,0xa0,0x75,0x17,0x6e,0x74,0x69,0x6e,0x67,0x72,0x6f,
-0x64,0xa2,0x9a,0x17,0x6e,0x75,0x6d,0x65,0x72,0x61,0x6c,0x73,0xa3,0x9a,2,0x62,
-0x3a,0x6d,0xa2,0x5f,0x70,0x15,0x61,0x74,0x6a,0x61,0x6d,0x6f,0xa3,0x41,0x14,0x69,
-0x6e,0x69,0x6e,0x67,2,0x64,0x46,0x68,0x9e,0x6d,0x1d,0x61,0x72,0x6b,0x73,0x66,
-0x6f,0x72,0x73,0x79,0x6d,0x62,0x6f,0x6c,0x73,0x77,0x1e,0x69,0x61,0x63,0x72,0x69,
-0x74,0x69,0x63,0x61,0x6c,0x6d,0x61,0x72,0x6b,0x73,0x2e,2,0x65,0x40,0x66,0xa6,
-0x41,0x73,0x18,0x75,0x70,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0xa3,0x83,0x16,0x78,
-0x74,0x65,0x6e,0x64,0x65,0x64,0xa3,0xe0,0x17,0x61,0x6c,0x66,0x6d,0x61,0x72,0x6b,
-0x73,0xa3,0x52,0x11,0x6f,0x6e,0x1f,0x69,0x6e,0x64,0x69,0x63,0x6e,0x75,0x6d,0x62,
-0x65,0x72,0x66,0x6f,0x72,0x6d,0x73,0xa3,0xb2,0x1b,0x74,0x72,0x6f,0x6c,0x70,0x69,
-0x63,0x74,0x75,0x72,0x65,0x73,0x83,0x12,0x74,0x69,0x63,0xa2,0x84,0x1b,0x65,0x70,
-0x61,0x63,0x74,0x6e,0x75,0x6d,0x62,0x65,0x72,0x73,0xa3,0xdf,1,0x6e,0x3e,0x72,
-0x1b,0x72,0x65,0x6e,0x63,0x79,0x73,0x79,0x6d,0x62,0x6f,0x6c,0x73,0x75,0x15,0x65,
-0x69,0x66,0x6f,0x72,0x6d,0xa2,0x98,0x16,0x6e,0x75,0x6d,0x62,0x65,0x72,0x73,0xa2,
-0x99,0x1d,0x61,0x6e,0x64,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,
-0xa3,0x99,0x61,0xa2,0xe1,0x68,0xa4,0xb,0x6a,0x10,0x6b,0xa2,0x47,4,0x63,0x8c,
-0x65,0xa2,0x80,0x72,0xa2,0x98,0x73,0xa2,0xaa,0x75,0x1f,0x6e,0x69,0x66,0x69,0x65,
-0x64,0x69,0x64,0x65,0x6f,0x67,0x72,0x61,0x70,0x68,0x73,0xa2,0x47,0x18,0x65,0x78,
-0x74,0x65,0x6e,0x73,0x69,0x6f,0x6e,6,0x64,0x6b,0x64,0xa3,0xd1,0x65,0xa5,0,
-0x66,0xa5,0x12,0x67,0xa5,0x2e,0x14,0x6f,0x6d,0x70,0x61,0x74,0xa2,0x45,1,0x66,
-0x96,0x69,1,0x62,0x44,0x64,0x17,0x65,0x6f,0x67,0x72,0x61,0x70,0x68,0x73,0xa2,
-0x4f,0x12,0x73,0x75,0x70,0xa3,0x5f,0x14,0x69,0x6c,0x69,0x74,0x79,0xa2,0x45,1,
-0x66,0x54,0x69,0x18,0x64,0x65,0x6f,0x67,0x72,0x61,0x70,0x68,0x73,0xa2,0x4f,0x19,
-0x73,0x75,0x70,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0xa3,0x5f,0x13,0x6f,0x72,0x6d,
-0x73,0xa3,0x53,0x11,0x78,0x74,6,0x64,0xc,0x64,0xa3,0xd1,0x65,0xa5,0,0x66,
-0xa5,0x12,0x67,0xa5,0x2e,0x61,0xa3,0x46,0x62,0xa3,0x5e,0x63,0xa3,0xc5,0x19,0x61,
-0x64,0x69,0x63,0x61,0x6c,0x73,0x73,0x75,0x70,0x94,0x16,0x70,0x6c,0x65,0x6d,0x65,
-0x6e,0x74,0x95,1,0x74,0x50,0x79,0x14,0x6d,0x62,0x6f,0x6c,0x73,0x9a,0x1d,0x61,
-0x6e,0x64,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0x9b,0x14,0x72,
-0x6f,0x6b,0x65,0x73,0xa3,0x82,2,0x6e,0x48,0x72,0x64,0x75,0x1d,0x63,0x61,0x73,
-0x69,0x61,0x6e,0x61,0x6c,0x62,0x61,0x6e,0x69,0x61,0x6e,0xa3,0xde,0x1d,0x61,0x64,
-0x69,0x61,0x6e,0x73,0x79,0x6c,0x6c,0x61,0x62,0x69,0x63,0x73,0x63,0x12,0x69,0x61,
-0x6e,0xa3,0xa8,2,0x61,0x3a,0x65,0x4c,0x6f,0x16,0x72,0x61,0x73,0x6d,0x69,0x61,
-0x6e,0xa5,0x2d,1,0x6b,0x26,0x6d,0xa3,0xa4,0x11,0x6d,0x61,0xa3,0xd4,1,0x72,
-0x38,0x73,0x17,0x73,0x73,0x79,0x6d,0x62,0x6f,0x6c,0x73,0xa5,0x19,0x13,0x6f,0x6b,
-0x65,0x65,0x60,0x12,0x73,0x75,0x70,0xa2,0xff,0x16,0x70,0x6c,0x65,0x6d,0x65,0x6e,
-0x74,0xa3,0xff,3,0x65,0x3e,0x69,0x7e,0x6f,0xa2,0x69,0x75,0x15,0x70,0x6c,0x6f,
-0x79,0x61,0x6e,0xa3,0xe1,1,0x73,0x50,0x76,0x16,0x61,0x6e,0x61,0x67,0x61,0x72,
-0x69,0x3e,0x12,0x65,0x78,0x74,0xa2,0xb3,0x14,0x65,0x6e,0x64,0x65,0x64,0xa3,0xb3,
-0x13,0x65,0x72,0x65,0x74,0xa3,0x5a,2,0x61,0x3a,0x6e,0x82,0x76,0x16,0x65,0x73,
-0x61,0x6b,0x75,0x72,0x75,0xa5,0x2f,0x18,0x63,0x72,0x69,0x74,0x69,0x63,0x61,0x6c,
-0x73,0x2e,2,0x65,0x30,0x66,0x36,0x73,0x11,0x75,0x70,0xa3,0x83,0x11,0x78,0x74,
-0xa3,0xe0,0x18,0x6f,0x72,0x73,0x79,0x6d,0x62,0x6f,0x6c,0x73,0x77,0x14,0x67,0x62,
-0x61,0x74,0x73,0x91,1,0x67,0x3e,0x6d,0x12,0x69,0x6e,0x6f,0xa2,0xab,0x14,0x74,
-0x69,0x6c,0x65,0x73,0xa3,0xab,0x11,0x72,0x61,0xa5,0x1a,8,0x6d,0x5f,0x6d,0x3a,
-0x6e,0x48,0x73,0x7a,0x76,0xa2,0x4b,0x77,0x12,0x69,0x64,0x65,0x43,0x11,0x65,0x64,
-0x32,0x12,0x69,0x61,0x6c,0x33,2,0x61,0x40,0x62,0x37,0x6f,1,0x62,0x28,0x6e,
-0x10,0x65,0x21,0x13,0x72,0x65,0x61,0x6b,0x37,0x10,0x72,0x34,0x12,0x72,0x6f,0x77,
-0x35,2,0x6d,0x38,0x71,0x46,0x75,1,0x62,0x3d,0x70,0x3e,0x11,0x65,0x72,0x3f,
-1,0x61,0x24,0x6c,0x39,0x11,0x6c,0x6c,0x39,1,0x72,0x3b,0x75,0x12,0x61,0x72,
-0x65,0x3b,0x12,0x65,0x72,0x74,0x40,0x13,0x69,0x63,0x61,0x6c,0x41,0x63,0x58,0x65,
-0x92,0x66,0x96,0x69,1,0x6e,0x36,0x73,0x10,0x6f,0x30,0x14,0x6c,0x61,0x74,0x65,
-0x64,0x31,0x11,0x69,0x74,0x2e,0x12,0x69,0x61,0x6c,0x2f,2,0x61,0x36,0x69,0x48,
-0x6f,0x10,0x6d,0x24,0x12,0x70,0x61,0x74,0x25,0x10,0x6e,0x22,0x15,0x6f,0x6e,0x69,
-0x63,0x61,0x6c,0x23,0x13,0x72,0x63,0x6c,0x65,0x27,0x11,0x6e,0x63,0x27,2,0x69,
-0x3a,0x6f,0x44,0x72,0x10,0x61,0x2c,0x14,0x63,0x74,0x69,0x6f,0x6e,0x2d,0x10,0x6e,
-0x28,0x11,0x61,0x6c,0x29,0x11,0x6e,0x74,0x2b,4,0x61,0x3a,0x66,0x4c,0x68,0x5e,
-0x6e,0x70,0x77,0x2a,0x12,0x69,0x64,0x65,0x2b,0x22,0x17,0x6d,0x62,0x69,0x67,0x75,
-0x6f,0x75,0x73,0x23,0x26,0x17,0x75,0x6c,0x6c,0x77,0x69,0x64,0x74,0x68,0x27,0x24,
-0x17,0x61,0x6c,0x66,0x77,0x69,0x64,0x74,0x68,0x25,0x20,1,0x61,0x30,0x65,0x14,
-0x75,0x74,0x72,0x61,0x6c,0x21,0x28,0x13,0x72,0x72,0x6f,0x77,0x29,0xd,0x6e,0xc0,
-0xfb,0x73,0x6d,0x73,0x3a,0x74,0x98,0x75,0xa2,0x49,0x7a,2,0x6c,0x3b,0x70,0x3d,
-0x73,0x39,5,0x6f,0x28,0x6f,0x57,0x70,0x34,0x75,0x16,0x72,0x72,0x6f,0x67,0x61,
-0x74,0x65,0x45,0x11,0x61,0x63,1,0x65,0x32,0x69,0x15,0x6e,0x67,0x6d,0x61,0x72,
-0x6b,0x31,0x18,0x73,0x65,0x70,0x61,0x72,0x61,0x74,0x6f,0x72,0x39,0x63,0x53,0x6b,
-0x55,0x6d,0x51,0x1d,0x69,0x74,0x6c,0x65,0x63,0x61,0x73,0x65,0x6c,0x65,0x74,0x74,
-0x65,0x72,0x27,1,0x6e,0x40,0x70,0x1c,0x70,0x65,0x72,0x63,0x61,0x73,0x65,0x6c,
-0x65,0x74,0x74,0x65,0x72,0x23,0x17,0x61,0x73,0x73,0x69,0x67,0x6e,0x65,0x64,0x21,
-0x6e,0x8a,0x6f,0xa2,0x47,0x70,8,0x66,0x14,0x66,0x5b,0x69,0x59,0x6f,0x4f,0x72,
-0x24,0x73,0x49,0x17,0x69,0x76,0x61,0x74,0x65,0x75,0x73,0x65,0x43,0x61,0x2c,0x63,
-0x4d,0x64,0x47,0x65,0x4b,0x1f,0x72,0x61,0x67,0x72,0x61,0x70,0x68,0x73,0x65,0x70,
-0x61,0x72,0x61,0x74,0x6f,0x72,0x3d,2,0x64,0x33,0x6c,0x35,0x6f,0x36,0x1b,0x6e,
-0x73,0x70,0x61,0x63,0x69,0x6e,0x67,0x6d,0x61,0x72,0x6b,0x2d,1,0x70,0x7c,0x74,
-0x12,0x68,0x65,0x72,3,0x6c,0x38,0x6e,0x42,0x70,0x4c,0x73,0x14,0x79,0x6d,0x62,
-0x6f,0x6c,0x57,0x14,0x65,0x74,0x74,0x65,0x72,0x2b,0x14,0x75,0x6d,0x62,0x65,0x72,
-0x37,0x19,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0x4f,0x1c,0x65,0x6e,
-0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0x49,0x66,0x9e,0x66,0x88,
-0x69,0xa2,0x4b,0x6c,0xa2,0x5c,0x6d,4,0x61,0x60,0x63,0x31,0x65,0x2f,0x6e,0x2d,
-0x6f,0x15,0x64,0x69,0x66,0x69,0x65,0x72,1,0x6c,0x30,0x73,0x14,0x79,0x6d,0x62,
-0x6f,0x6c,0x55,0x14,0x65,0x74,0x74,0x65,0x72,0x29,0x17,0x74,0x68,0x73,0x79,0x6d,
-0x62,0x6f,0x6c,0x51,1,0x69,0x2e,0x6f,0x13,0x72,0x6d,0x61,0x74,0x41,0x1d,0x6e,
-0x61,0x6c,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0x5b,0x10,0x6e,
-0x1f,0x69,0x74,0x69,0x61,0x6c,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,
-0x6e,0x59,6,0x6d,0x18,0x6d,0x29,0x6f,0x28,0x74,0x27,0x75,0x23,0x2a,0x1c,0x77,
-0x65,0x72,0x63,0x61,0x73,0x65,0x6c,0x65,0x74,0x74,0x65,0x72,0x25,0x65,0x28,0x69,
-0x3c,0x6c,0x25,0x19,0x74,0x74,0x65,0x72,0x6e,0x75,0x6d,0x62,0x65,0x72,0x35,0x1a,
-0x6e,0x65,0x73,0x65,0x70,0x61,0x72,0x61,0x74,0x6f,0x72,0x3b,0x63,0x44,0x64,0xa2,
-0x60,0x65,0x1b,0x6e,0x63,0x6c,0x6f,0x73,0x69,0x6e,0x67,0x6d,0x61,0x72,0x6b,0x2f,
-6,0x6e,0x39,0x6e,0x46,0x6f,0x4e,0x73,0x45,0x75,0x1b,0x72,0x72,0x65,0x6e,0x63,
-0x79,0x73,0x79,0x6d,0x62,0x6f,0x6c,0x53,0x20,0x12,0x74,0x72,0x6c,0x3f,0x42,0x10,
-0x6e,1,0x6e,0x2c,0x74,0x12,0x72,0x6f,0x6c,0x3f,0x1f,0x65,0x63,0x74,0x6f,0x72,
-0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0x4d,0x63,0x3f,0x66,0x41,
-0x6c,0x1d,0x6f,0x73,0x65,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,
-0x4b,2,0x61,0x30,0x65,0x4a,0x69,0x12,0x67,0x69,0x74,0x33,0x1c,0x73,0x68,0x70,
-0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0x47,0x1a,0x63,0x69,0x6d,0x61,
-0x6c,0x6e,0x75,0x6d,0x62,0x65,0x72,0x33,0,0x13,0x6e,0xc1,0xf,0x74,0x76,0x74,
-0x4c,0x76,0x9a,0x77,0xa2,0x48,0x79,0xa2,0x49,0x7a,1,0x61,0x2c,0x68,0x12,0x61,
-0x69,0x6e,0x8b,0x11,0x69,0x6e,0x85,2,0x61,0x36,0x65,0x3c,0x68,0x14,0x69,0x6e,
-0x79,0x65,0x68,0xa3,0x66,1,0x68,0x71,0x77,0x73,1,0x68,0x28,0x74,0x10,0x68,
-0x77,0x16,0x6d,0x61,0x72,0x62,0x75,0x74,0x61,0x74,0x13,0x67,0x6f,0x61,0x6c,0x3d,
-0x1a,0x65,0x72,0x74,0x69,0x63,0x61,0x6c,0x74,0x61,0x69,0x6c,0xa3,0x67,0x11,0x61,
-0x77,0x79,1,0x65,0x32,0x75,0x11,0x64,0x68,0x80,0x11,0x68,0x65,0x83,0x10,0x68,
-0x7a,1,0x62,0x34,0x77,0x16,0x69,0x74,0x68,0x74,0x61,0x69,0x6c,0x7f,0x14,0x61,
-0x72,0x72,0x65,0x65,0x7d,0x6e,0xa2,0x4c,0x70,0xa2,0x69,0x71,0xa2,0x69,0x72,0xa2,
-0x6f,0x73,5,0x74,0x22,0x74,0x38,0x77,0x4c,0x79,0x16,0x72,0x69,0x61,0x63,0x77,
-0x61,0x77,0x6f,0x18,0x72,0x61,0x69,0x67,0x68,0x74,0x77,0x61,0x77,0xa3,0x55,0x15,
-0x61,0x73,0x68,0x6b,0x61,0x66,0x6d,0x61,0x2e,0x65,0x38,0x68,0x11,0x69,0x6e,0x6b,
-0x10,0x64,0x62,0x11,0x68,0x65,0x65,1,0x65,0x2e,0x6d,0x13,0x6b,0x61,0x74,0x68,
-0x69,0x10,0x6e,0x67,2,0x6f,0x2c,0x75,0x50,0x79,0x10,0x61,0x91,1,0x6a,0x28,
-0x6f,0x10,0x6e,0x55,0x1a,0x6f,0x69,0x6e,0x69,0x6e,0x67,0x67,0x72,0x6f,0x75,0x70,
-0x21,0x10,0x6e,0x57,0x10,0x65,0x59,0x10,0x61,1,0x66,0x5b,0x70,0x10,0x68,0x5d,
-1,0x65,0x38,0x6f,0x18,0x68,0x69,0x6e,0x67,0x79,0x61,0x79,0x65,0x68,0x93,1,
-0x68,0x5f,0x76,0x16,0x65,0x72,0x73,0x65,0x64,0x70,0x65,0x61,0x67,0xc1,0xc7,0x67,
-0xa4,0x52,0x68,0xa4,0x59,0x6b,0xa4,0x99,0x6c,0xa4,0xb2,0x6d,2,0x61,0x2e,0x65,
-0xa4,0x3e,0x69,0x10,0x6d,0x53,1,0x6c,0xa2,0xe7,0x6e,0x16,0x69,0x63,0x68,0x61,
-0x65,0x61,0x6e,0,0x12,0x6e,0x76,0x73,0x51,0x73,0x3e,0x74,0x5c,0x77,0xa0,0x79,
-0xa2,0x42,0x7a,0x13,0x61,0x79,0x69,0x6e,0xa3,0x54,0x10,0x61,1,0x64,0x2e,0x6d,
-0x12,0x65,0x6b,0x68,0xa3,0x4c,0x11,0x68,0x65,0xa3,0x4b,3,0x61,0x38,0x65,0x3c,
-0x68,0x4a,0x77,0x13,0x65,0x6e,0x74,0x79,0xa3,0x51,0x10,0x77,0xa3,0x4d,1,0x6e,
-0xa3,0x4e,0x74,0x10,0x68,0xa3,0x4f,0x14,0x61,0x6d,0x65,0x64,0x68,0xa3,0x50,0x11,
-0x61,0x77,0xa3,0x52,0x12,0x6f,0x64,0x68,0xa3,0x53,0x6e,0x3a,0x6f,0x40,0x70,0x46,
-0x71,0x4a,0x72,0x12,0x65,0x73,0x68,0xa3,0x4a,0x11,0x75,0x6e,0xa3,0x46,0x11,0x6e,
-0x65,0xa3,0x47,0x10,0x65,0xa3,0x48,0x12,0x6f,0x70,0x68,0xa3,0x49,0x67,0x33,0x67,
-0x38,0x68,0x40,0x6b,0x5e,0x6c,0x66,0x6d,0x11,0x65,0x6d,0xa3,0x45,0x13,0x69,0x6d,
-0x65,0x6c,0xa1,1,0x65,0x32,0x75,0x14,0x6e,0x64,0x72,0x65,0x64,0xa3,0x42,0x11,
-0x74,0x68,0xa3,0x41,0x12,0x61,0x70,0x68,0xa3,0x43,0x14,0x61,0x6d,0x65,0x64,0x68,
-0xa3,0x44,0x61,0x34,0x62,0x4a,0x64,0x50,0x66,0x12,0x69,0x76,0x65,0x9f,1,0x6c,
-0x2a,0x79,0x11,0x69,0x6e,0x97,0x12,0x65,0x70,0x68,0x95,0x12,0x65,0x74,0x68,0x99,
-1,0x61,0x30,0x68,0x14,0x61,0x6d,0x65,0x64,0x68,0x9d,0x13,0x6c,0x65,0x74,0x68,
-0x9b,0x15,0x61,0x79,0x61,0x6c,0x61,0x6d,6,0x6e,0x2c,0x6e,0x34,0x72,0x5e,0x73,
-0x62,0x74,0x11,0x74,0x61,0xa3,0x63,2,0x67,0x2e,0x6e,0x32,0x79,0x10,0x61,0xa3,
-0x60,0x10,0x61,0xa3,0x5d,1,0x61,0xa3,0x5e,0x6e,0x10,0x61,0xa3,0x5f,0x10,0x61,
-0xa3,0x61,0x11,0x73,0x61,0xa3,0x62,0x62,0x3c,0x6a,0x42,0x6c,0x10,0x6c,1,0x61,
-0xa3,0x5b,0x6c,0x10,0x61,0xa3,0x5c,0x11,0x68,0x61,0xa3,0x59,0x10,0x61,0xa3,0x5a,
-0x11,0x65,0x6d,0x51,0x10,0x61,1,0x66,0x37,0x6d,0x11,0x61,0x6c,0x39,1,0x61,
-0x40,0x65,0x3e,1,0x68,0x28,0x74,0x10,0x68,0x45,0x40,0x13,0x67,0x6f,0x61,0x6c,
-0x43,2,0x68,0x3b,0x6d,0x5c,0x6e,0x1a,0x69,0x66,0x69,0x72,0x6f,0x68,0x69,0x6e,
-0x67,0x79,0x61,1,0x6b,0x2a,0x70,0x10,0x61,0xa3,0x65,0x15,0x69,0x6e,0x6e,0x61,
-0x79,0x61,0xa3,0x64,0x1a,0x7a,0x61,0x6f,0x6e,0x68,0x65,0x68,0x67,0x6f,0x61,0x6c,
-0x3d,2,0x61,0x3a,0x68,0x44,0x6e,0x17,0x6f,0x74,0x74,0x65,0x64,0x68,0x65,0x68,
-0x4b,1,0x66,0x47,0x70,0x10,0x68,0x49,0x12,0x61,0x70,0x68,0x89,0x11,0x61,0x6d,
-0x4c,0x12,0x61,0x64,0x68,0x4f,0x61,0x6e,0x62,0xa2,0x54,0x64,0xa2,0x70,0x65,0x31,
-0x66,2,0x61,0x3e,0x65,0x4a,0x69,0x19,0x6e,0x61,0x6c,0x73,0x65,0x6d,0x6b,0x61,
-0x74,0x68,0x35,0x15,0x72,0x73,0x69,0x79,0x65,0x68,0x8f,0x86,0x10,0x68,0x33,2,
-0x66,0x3c,0x69,0x70,0x6c,1,0x61,0x28,0x65,0x10,0x66,0x27,0x11,0x70,0x68,0x25,
-0x14,0x72,0x69,0x63,0x61,0x6e,2,0x66,0x30,0x6e,0x36,0x71,0x11,0x61,0x66,0xa3,
-0x58,0x11,0x65,0x68,0xa3,0x56,0x12,0x6f,0x6f,0x6e,0xa3,0x57,0x10,0x6e,0x23,1,
-0x65,0x4a,0x75,0x10,0x72,0x1f,0x75,0x73,0x68,0x61,0x73,0x6b,0x69,0x79,0x65,0x68,
-0x62,0x61,0x72,0x72,0x65,0x65,0x8d,1,0x68,0x29,0x74,0x10,0x68,0x2b,0x11,0x61,
-0x6c,0x2c,0x16,0x61,0x74,0x68,0x72,0x69,0x73,0x68,0x2f,7,0x6e,0x2e,0x6e,0x2c,
-0x72,0x3e,0x74,0x56,0x75,0x21,0x18,0x6f,0x6e,0x6a,0x6f,0x69,0x6e,0x69,0x6e,0x67,
-0x21,0x28,0x1a,0x69,0x67,0x68,0x74,0x6a,0x6f,0x69,0x6e,0x69,0x6e,0x67,0x29,0x2a,
-0x19,0x72,0x61,0x6e,0x73,0x70,0x61,0x72,0x65,0x6e,0x74,0x2b,0x63,0x23,0x64,0x40,
-0x6a,0x56,0x6c,0x26,0x19,0x65,0x66,0x74,0x6a,0x6f,0x69,0x6e,0x69,0x6e,0x67,0x27,
-0x24,0x19,0x75,0x61,0x6c,0x6a,0x6f,0x69,0x6e,0x69,0x6e,0x67,0x25,0x19,0x6f,0x69,
-0x6e,0x63,0x61,0x75,0x73,0x69,0x6e,0x67,0x23,0,0x13,0x6e,0xc0,0xd0,0x73,0x49,
-0x73,0x48,0x75,0x78,0x77,0x84,0x78,0x9c,0x7a,0x10,0x77,0x58,1,0x6a,0x75,0x73,
-0x13,0x70,0x61,0x63,0x65,0x59,4,0x61,0x51,0x67,0x53,0x70,0x28,0x75,0x30,0x79,
-0x57,0x54,0x12,0x61,0x63,0x65,0x55,0x16,0x72,0x72,0x6f,0x67,0x61,0x74,0x65,0x53,
-0x15,0x6e,0x6b,0x6e,0x6f,0x77,0x6e,0x21,1,0x6a,0x5d,0x6f,0x17,0x72,0x64,0x6a,
-0x6f,0x69,0x6e,0x65,0x72,0x5d,0x10,0x78,0x21,0x6e,0x60,0x6f,0xa2,0x41,0x70,0xa2,
-0x50,0x71,0xa2,0x6e,0x72,1,0x65,0x24,0x69,0x6f,0x1e,0x67,0x69,0x6f,0x6e,0x61,
-0x6c,0x69,0x6e,0x64,0x69,0x63,0x61,0x74,0x6f,0x72,0x6f,4,0x65,0x3e,0x6c,0x5b,
-0x6f,0x46,0x73,0x45,0x75,0x46,0x14,0x6d,0x65,0x72,0x69,0x63,0x47,0x15,0x78,0x74,
-0x6c,0x69,0x6e,0x65,0x5b,0x17,0x6e,0x73,0x74,0x61,0x72,0x74,0x65,0x72,0x45,0x10,
-0x70,0x48,0x1c,0x65,0x6e,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,
-0x49,1,0x6f,0x3e,0x72,0x4c,0x1a,0x65,0x66,0x69,0x78,0x6e,0x75,0x6d,0x65,0x72,
-0x69,0x63,0x4d,0x4a,0x1b,0x73,0x74,0x66,0x69,0x78,0x6e,0x75,0x6d,0x65,0x72,0x69,
-0x63,0x4b,0x10,0x75,0x4e,0x16,0x6f,0x74,0x61,0x74,0x69,0x6f,0x6e,0x4f,0x68,0x7b,
-0x68,0x50,0x69,0x86,0x6a,0xa2,0x61,0x6c,0xa2,0x65,0x6d,0x1c,0x61,0x6e,0x64,0x61,
-0x74,0x6f,0x72,0x79,0x62,0x72,0x65,0x61,0x6b,0x2d,4,0x32,0x5f,0x33,0x61,0x65,
-0x34,0x6c,0x6d,0x79,0x3a,0x13,0x70,0x68,0x65,0x6e,0x3b,0x19,0x62,0x72,0x65,0x77,
-0x6c,0x65,0x74,0x74,0x65,0x72,0x6d,2,0x64,0x28,0x6e,0x3c,0x73,0x41,0x3c,0x18,
-0x65,0x6f,0x67,0x72,0x61,0x70,0x68,0x69,0x63,0x3d,0x3e,1,0x66,0x3e,0x73,0x11,
-0x65,0x70,1,0x61,0x22,0x65,0x14,0x72,0x61,0x62,0x6c,0x65,0x3f,0x18,0x69,0x78,
-0x6e,0x75,0x6d,0x65,0x72,0x69,0x63,0x41,2,0x6c,0x63,0x74,0x65,0x76,0x67,1,
-0x66,0x43,0x69,0x15,0x6e,0x65,0x66,0x65,0x65,0x64,0x43,0x61,0x40,0x62,0x70,0x63,
-0xa2,0x55,0x65,0xa2,0xdb,0x67,0x10,0x6c,0x38,0x11,0x75,0x65,0x39,2,0x69,0x23,
-0x6c,0x34,0x6d,0x16,0x62,0x69,0x67,0x75,0x6f,0x75,0x73,0x23,0x24,0x17,0x70,0x68,
-0x61,0x62,0x65,0x74,0x69,0x63,0x25,4,0x32,0x27,0x61,0x29,0x62,0x2b,0x6b,0x2d,
-0x72,0x12,0x65,0x61,0x6b,2,0x61,0x36,0x62,0x3e,0x73,0x15,0x79,0x6d,0x62,0x6f,
-0x6c,0x73,0x57,0x13,0x66,0x74,0x65,0x72,0x29,1,0x65,0x2a,0x6f,0x11,0x74,0x68,
-0x27,0x13,0x66,0x6f,0x72,0x65,0x2b,7,0x6d,0x51,0x6d,0x33,0x6f,0x28,0x70,0x69,
-0x72,0x35,1,0x6d,0x76,0x6e,1,0x64,0x3c,0x74,0x1a,0x69,0x6e,0x67,0x65,0x6e,
-0x74,0x62,0x72,0x65,0x61,0x6b,0x2f,0x15,0x69,0x74,0x69,0x6f,0x6e,0x61,0x1f,0x6c,
-0x6a,0x61,0x70,0x61,0x6e,0x65,0x73,0x65,0x73,0x74,0x61,0x72,0x74,0x65,0x72,0x6b,
-1,0x62,0x3a,0x70,0x19,0x6c,0x65,0x78,0x63,0x6f,0x6e,0x74,0x65,0x78,0x74,0x51,
-0x18,0x69,0x6e,0x69,0x6e,0x67,0x6d,0x61,0x72,0x6b,0x33,0x61,0x6a,0x62,0x2f,0x6a,
-0x6b,0x6c,0x30,0x13,0x6f,0x73,0x65,0x70,1,0x61,0x38,0x75,0x18,0x6e,0x63,0x74,
-0x75,0x61,0x74,0x69,0x6f,0x6e,0x31,0x18,0x72,0x65,0x6e,0x74,0x68,0x65,0x73,0x69,
-0x73,0x69,0x1b,0x72,0x72,0x69,0x61,0x67,0x65,0x72,0x65,0x74,0x75,0x72,0x6e,0x35,
-2,0x62,0x3e,0x6d,0x46,0x78,0x36,0x18,0x63,0x6c,0x61,0x6d,0x61,0x74,0x69,0x6f,
-0x6e,0x37,0x70,0x12,0x61,0x73,0x65,0x71,0x72,0x16,0x6f,0x64,0x69,0x66,0x69,0x65,
-0x72,0x73,1,0x64,0x42,0x6e,1,0x6f,0x32,0x75,0x26,0x14,0x6d,0x65,0x72,0x69,
-0x63,0x27,0x11,0x6e,0x65,0x21,1,0x65,0x2e,0x69,0x24,0x12,0x67,0x69,0x74,0x25,
-0x22,0x14,0x63,0x69,0x6d,0x61,0x6c,0x23,0,0x18,0x6e,0xc4,0x60,0x74,0xc1,0x91,
-0x77,0x96,0x77,0xa2,0x4c,0x78,0xa2,0x70,0x79,0xa2,0x7a,0x7a,6,0x73,0x1e,0x73,
-0x34,0x78,0x42,0x79,0x48,0x7a,0x11,0x7a,0x7a,0xa3,0x67,0x10,0x79,1,0x65,0xa3,
-0xae,0x6d,0xa3,0x81,0x11,0x78,0x78,0xa3,0x66,0x11,0x79,0x79,0x21,0x61,0x30,0x69,
-0x58,0x6d,0x11,0x74,0x68,0xa3,0x80,0x10,0x6e,1,0x61,0x26,0x62,0xa3,0xb1,0x1a,
-0x62,0x61,0x7a,0x61,0x72,0x73,0x71,0x75,0x61,0x72,0x65,0xa3,0xb1,0x11,0x6e,0x68,
-0x23,2,0x61,0x30,0x63,0x5a,0x6f,0x11,0x6c,0x65,0xa3,0x9b,1,0x6e,0x3c,0x72,
-0x10,0x61,0xa2,0x92,0x15,0x6e,0x67,0x63,0x69,0x74,0x69,0xa3,0x92,0x12,0x63,0x68,
-0x6f,0xa3,0xbc,0x11,0x68,0x6f,0xa3,0xbc,1,0x70,0x2c,0x73,0x11,0x75,0x78,0xa3,
-0x65,0x11,0x65,0x6f,0x9b,1,0x65,0x2c,0x69,0x72,0x11,0x69,0x69,0x73,0x11,0x7a,
-0x69,0xa2,0xc0,0x11,0x64,0x69,0xa3,0xc0,0x74,0x66,0x75,0xa2,0xde,0x76,1,0x61,
-0x48,0x69,1,0x73,0x38,0x74,0x10,0x68,0xa2,0xc5,0x13,0x6b,0x75,0x71,0x69,0xa3,
-0xc5,0x10,0x70,0xa3,0x64,0x10,0x69,0xa2,0x63,0x10,0x69,0xa3,0x63,7,0x68,0x3e,
-0x68,0x34,0x69,0x48,0x6e,0x86,0x6f,0x11,0x74,0x6f,0xa3,0xc4,0x10,0x61,1,0x61,
-0x24,0x69,0x6d,0x6a,0x11,0x6e,0x61,0x6b,2,0x62,0x3a,0x66,0x4a,0x72,0x10,0x68,
-0xa2,0x9e,0x12,0x75,0x74,0x61,0xa3,0x9e,1,0x65,0x24,0x74,0x6f,0x12,0x74,0x61,
-0x6e,0x6f,0x14,0x69,0x6e,0x61,0x67,0x68,0x99,0x11,0x73,0x61,0xa3,0xc3,0x61,0x36,
-0x65,0xa2,0x65,0x66,0xa2,0x71,0x67,0x11,0x6c,0x67,0x75,6,0x6c,0x28,0x6c,0x32,
-0x6d,0x38,0x6e,0x44,0x76,0x10,0x74,0xa3,0x7f,1,0x65,0x89,0x75,0x97,1,0x69,
-0x24,0x6c,0x67,0x10,0x6c,0x67,0x10,0x67,0xa2,0x9a,1,0x73,0x2a,0x75,0x10,0x74,
-0xa3,0x9a,0x10,0x61,0xa3,0xc3,0x67,0x36,0x69,0x52,0x6b,0x10,0x72,0xa2,0x99,0x10,
-0x69,0xa3,0x99,1,0x61,0x30,0x62,0x7a,0x13,0x61,0x6e,0x77,0x61,0x7b,0x12,0x6c,
-0x6f,0x67,0x75,2,0x6c,0x32,0x74,0x34,0x76,0x12,0x69,0x65,0x74,0xa3,0x7f,0x10,
-0x65,0x89,0x12,0x68,0x61,0x6d,0xa3,0x6a,1,0x6c,0x2a,0x6e,0x10,0x67,0xa3,0x62,
-0x10,0x75,0x68,0x11,0x67,0x75,0x69,0x11,0x6e,0x67,0x99,1,0x67,0x32,0x6e,0x14,
-0x6b,0x6e,0x6f,0x77,0x6e,0xa3,0x67,0x11,0x61,0x72,0x8a,0x13,0x69,0x74,0x69,0x63,
-0x8b,0x71,0xc1,0x13,0x71,0xa2,0xde,0x72,0xa2,0xe3,0x73,6,0x69,0x8a,0x69,0x72,
-0x6f,0xa2,0x4c,0x75,0xa2,0x75,0x79,1,0x6c,0x46,0x72,4,0x63,0x65,0x65,0xa3,
-0x5f,0x69,0x2c,0x6a,0xa3,0x60,0x6e,0xa3,0x61,0x11,0x61,0x63,0x65,0x10,0x6f,0x94,
-0x16,0x74,0x69,0x6e,0x61,0x67,0x72,0x69,0x95,2,0x64,0x3c,0x67,0x4c,0x6e,1,
-0x64,0xa3,0x91,0x68,0x62,0x12,0x61,0x6c,0x61,0x63,0x10,0x64,0xa2,0xa6,0x12,0x68,
-0x61,0x6d,0xa3,0xa6,0x17,0x6e,0x77,0x72,0x69,0x74,0x69,0x6e,0x67,0xa3,0x70,2,
-0x67,0x3a,0x72,0x52,0x79,0x10,0x6f,0xa2,0xb0,0x12,0x6d,0x62,0x6f,0xa3,0xb0,1,
-0x64,0x26,0x6f,0xa3,0xb8,0xa2,0xb7,0x12,0x69,0x61,0x6e,0xa3,0xb7,0x10,0x61,0xa2,
-0x98,0x16,0x73,0x6f,0x6d,0x70,0x65,0x6e,0x67,0xa3,0x98,0x11,0x6e,0x64,0xa2,0x71,
-0x14,0x61,0x6e,0x65,0x73,0x65,0xa3,0x71,0x61,0x5c,0x67,0xa2,0x43,0x68,1,0x61,
-0x2a,0x72,0x10,0x64,0xa3,0x97,2,0x72,0x28,0x76,0x30,0x77,0x87,0x12,0x61,0x64,
-0x61,0xa3,0x97,0x12,0x69,0x61,0x6e,0x87,2,0x6d,0x40,0x72,0x58,0x75,0x10,0x72,
-0xa2,0x6f,0x15,0x61,0x73,0x68,0x74,0x72,0x61,0xa3,0x6f,1,0x61,0x26,0x72,0xa3,
-0x7e,0x14,0x72,0x69,0x74,0x61,0x6e,0xa3,0x7e,1,0x61,0xa3,0x5e,0x62,0xa3,0x85,
-0x11,0x6e,0x77,0xa3,0x70,0x11,0x61,0x61,1,0x63,0x2f,0x69,0x23,3,0x65,0x3e,
-0x6a,0x48,0x6f,0x4e,0x75,0x10,0x6e,1,0x69,0x24,0x72,0x61,0x10,0x63,0x61,0x13,
-0x6a,0x61,0x6e,0x67,0xa3,0x6e,0x11,0x6e,0x67,0xa3,0x6e,1,0x68,0x2a,0x72,0x10,
-0x6f,0xa3,0x5d,0x10,0x67,0xa3,0xb6,0x6e,0xa2,0x83,0x6f,0xa2,0xf2,0x70,5,0x6c,
-0x1e,0x6c,0x44,0x72,0x4a,0x73,0x1b,0x61,0x6c,0x74,0x65,0x72,0x70,0x61,0x68,0x6c,
-0x61,0x76,0x69,0xa3,0x7b,0x11,0x72,0x64,0xa3,0x5c,0x11,0x74,0x69,0xa3,0x7d,0x61,
-0x7c,0x65,0xa2,0x54,0x68,3,0x61,0x3e,0x6c,0x4e,0x6e,0x5e,0x6f,0x16,0x65,0x6e,
-0x69,0x63,0x69,0x61,0x6e,0xa3,0x5b,0x10,0x67,0xa2,0x5a,0x12,0x73,0x70,0x61,0xa3,
-0x5a,2,0x69,0xa3,0x7a,0x70,0xa3,0x7b,0x76,0xa3,0x7c,0x10,0x78,0xa3,0x5b,2,
-0x68,0x3e,0x6c,0x50,0x75,0x10,0x63,0xa2,0xa5,0x14,0x69,0x6e,0x68,0x61,0x75,0xa3,
-0xa5,0x17,0x61,0x77,0x68,0x68,0x6d,0x6f,0x6e,0x67,0xa3,0x4b,0x10,0x6d,0xa2,0x90,
-0x14,0x79,0x72,0x65,0x6e,0x65,0xa3,0x90,0x11,0x72,0x6d,0xa3,0x59,6,0x6b,0x36,
-0x6b,0x56,0x73,0x6e,0x75,0x74,0x79,0x11,0x69,0x61,0x1f,0x6b,0x65,0x6e,0x67,0x70,
-0x75,0x61,0x63,0x68,0x75,0x65,0x68,0x6d,0x6f,0x6e,0x67,0xa3,0xba,1,0x67,0x2e,
-0x6f,0xa2,0x57,0x10,0x6f,0xa3,0x57,0x10,0x62,0xa3,0x84,0x11,0x68,0x75,0xa3,0x96,
-0x12,0x73,0x68,0x75,0xa3,0x96,0x61,0x42,0x62,0x80,0x65,0x10,0x77,1,0x61,0xa3,
-0xaa,0x74,0x14,0x61,0x69,0x6c,0x75,0x65,0x97,2,0x62,0x2e,0x6e,0x3c,0x72,0x10,
-0x62,0xa3,0x8e,0x15,0x61,0x74,0x61,0x65,0x61,0x6e,0xa3,0x8f,0x10,0x64,0xa2,0xbb,
-0x16,0x69,0x6e,0x61,0x67,0x61,0x72,0x69,0xa3,0xbb,0x11,0x61,0x74,0xa3,0x8f,4,
-0x67,0x3c,0x6c,0x4e,0x72,0xa2,0x8e,0x73,0xa2,0x9c,0x75,0x11,0x67,0x72,0xa3,0xc2,
-1,0x61,0x2a,0x68,0x11,0x61,0x6d,0x5b,0x10,0x6d,0x5b,1,0x63,0xa2,0x6a,0x64,
-6,0x70,0x41,0x70,0x3a,0x73,0x58,0x74,0x86,0x75,0x14,0x79,0x67,0x68,0x75,0x72,
-0xa3,0xc2,0x11,0x65,0x72,1,0x6d,0x2c,0x73,0x12,0x69,0x61,0x6e,0x9b,0x11,0x69,
-0x63,0xa3,0x59,0x10,0x6f,1,0x67,0x3a,0x75,0x18,0x74,0x68,0x61,0x72,0x61,0x62,
-0x69,0x61,0x6e,0xa3,0x85,0x13,0x64,0x69,0x61,0x6e,0xa3,0xb8,0x14,0x75,0x72,0x6b,
-0x69,0x63,0xa3,0x58,0x68,0x42,0x69,0x54,0x6e,0x1a,0x6f,0x72,0x74,0x68,0x61,0x72,
-0x61,0x62,0x69,0x61,0x6e,0xa3,0x8e,0x17,0x75,0x6e,0x67,0x61,0x72,0x69,0x61,0x6e,
-0xa3,0x4c,0x14,0x74,0x61,0x6c,0x69,0x63,0x5d,1,0x68,0x26,0x6b,0xa3,0x6d,0x12,
-0x69,0x6b,0x69,0xa3,0x6d,2,0x69,0x2c,0x6b,0x30,0x79,0x10,0x61,0x5f,0x11,0x79,
-0x61,0x5f,0x10,0x68,0xa3,0x58,2,0x61,0x36,0x67,0x3c,0x6d,0x10,0x61,0x84,0x12,
-0x6e,0x79,0x61,0x85,0x11,0x67,0x65,0xa3,0xab,0x10,0x65,0xa3,0xab,0x68,0xc3,0xd,
-0x6b,0xc2,0x24,0x6b,0xa4,0x17,0x6c,0xa4,0xb2,0x6d,8,0x6f,0x46,0x6f,0x48,0x72,
-0x74,0x74,0x80,0x75,0x86,0x79,1,0x61,0x28,0x6d,0x10,0x72,0x59,0x13,0x6e,0x6d,
-0x61,0x72,0x59,2,0x64,0x2e,0x6e,0x32,0x6f,0x10,0x6e,0xa3,0x72,0x10,0x69,0xa3,
-0xa3,0x10,0x67,0x56,0x14,0x6f,0x6c,0x69,0x61,0x6e,0x57,0x10,0x6f,0xa2,0x95,0x10,
-0x6f,0xa3,0x95,0x11,0x65,0x69,0xa3,0x73,0x11,0x6c,0x74,0xa2,0xa4,0x12,0x61,0x6e,
-0x69,0xa3,0xa4,0x61,0x36,0x65,0xa2,0x67,0x69,0xa2,0xbd,0x6c,0x11,0x79,0x6d,0x55,
-6,0x6e,0x38,0x6e,0x32,0x72,0x5c,0x73,0x6c,0x79,0x10,0x61,0xa3,0x55,1,0x64,
-0x38,0x69,0xa2,0x79,0x15,0x63,0x68,0x61,0x65,0x61,0x6e,0xa3,0x79,0xa2,0x54,0x12,
-0x61,0x69,0x63,0xa3,0x54,0x10,0x63,0xa2,0xa9,0x12,0x68,0x65,0x6e,0xa3,0xa9,0x18,
-0x61,0x72,0x61,0x6d,0x67,0x6f,0x6e,0x64,0x69,0xa3,0xaf,0x68,0x36,0x6b,0x4c,0x6c,
-0x15,0x61,0x79,0x61,0x6c,0x61,0x6d,0x55,1,0x61,0x26,0x6a,0xa3,0xa0,0x13,0x6a,
-0x61,0x6e,0x69,0xa3,0xa0,0x10,0x61,0xa2,0xb4,0x12,0x73,0x61,0x72,0xa3,0xb4,3,
-0x64,0x78,0x65,0x94,0x6e,0xa2,0x42,0x72,1,0x63,0xa3,0x8d,0x6f,0xa2,0x56,0x13,
-0x69,0x74,0x69,0x63,1,0x63,0x3c,0x68,0x19,0x69,0x65,0x72,0x6f,0x67,0x6c,0x79,
-0x70,0x68,0x73,0xa3,0x56,0x15,0x75,0x72,0x73,0x69,0x76,0x65,0xa3,0x8d,1,0x65,
-0x26,0x66,0xa3,0xb5,0x16,0x66,0x61,0x69,0x64,0x72,0x69,0x6e,0xa3,0xb5,0x17,0x74,
-0x65,0x69,0x6d,0x61,0x79,0x65,0x6b,0xa3,0x73,0x10,0x64,0xa2,0x8c,0x17,0x65,0x6b,
-0x69,0x6b,0x61,0x6b,0x75,0x69,0xa3,0x8c,0x11,0x61,0x6f,0xa3,0x5c,6,0x6e,0x1a,
-0x6e,0x34,0x6f,0x38,0x70,0x3e,0x74,0x11,0x68,0x69,0xa3,0x78,0x11,0x64,0x61,0x4b,
-0x11,0x72,0x65,0xa3,0x77,0x11,0x65,0x6c,0xa3,0x8a,0x61,0x30,0x68,0x9a,0x69,0x11,
-0x74,0x73,0xa3,0xbf,4,0x69,0x3c,0x6c,0x44,0x6e,0x48,0x74,0x56,0x79,0x13,0x61,
-0x68,0x6c,0x69,0xa3,0x4f,0x12,0x74,0x68,0x69,0xa3,0x78,0x10,0x69,0xa3,0x4f,1,
-0x61,0x4d,0x6e,0x12,0x61,0x64,0x61,0x4b,0x14,0x61,0x6b,0x61,0x6e,0x61,0x4c,0x19,
-0x6f,0x72,0x68,0x69,0x72,0x61,0x67,0x61,0x6e,0x61,0x8d,4,0x61,0x40,0x69,0x52,
-0x6d,0x70,0x6f,0x7c,0x75,0x15,0x64,0x61,0x77,0x61,0x64,0x69,0xa3,0x91,0x10,0x72,
-0x92,0x15,0x6f,0x73,0x68,0x74,0x68,0x69,0x93,0x1d,0x74,0x61,0x6e,0x73,0x6d,0x61,
-0x6c,0x6c,0x73,0x63,0x72,0x69,0x70,0x74,0xa3,0xbf,1,0x65,0x24,0x72,0x4f,0x10,
-0x72,0x4f,0x10,0x6a,0xa2,0x9d,0x11,0x6b,0x69,0xa3,0x9d,4,0x61,0x5c,0x65,0x90,
-0x69,0xa0,0x6f,0xa2,0x5d,0x79,1,0x63,0x34,0x64,0x10,0x69,0xa2,0x6c,0x11,0x61,
-0x6e,0xa3,0x6c,0x10,0x69,0xa2,0x6b,0x11,0x61,0x6e,0xa3,0x6b,2,0x6e,0x42,0x6f,
-0x46,0x74,3,0x66,0xa3,0x50,0x67,0xa3,0x51,0x69,0x24,0x6e,0x53,0x10,0x6e,0x53,
-0x10,0x61,0xa3,0x6a,0x50,0x10,0x6f,0x51,0x11,0x70,0x63,0xa2,0x52,0x11,0x68,0x61,
-0xa3,0x52,2,0x6d,0x2e,0x6e,0x36,0x73,0x10,0x75,0xa3,0x83,0x10,0x62,0x80,0x10,
-0x75,0x81,2,0x61,0xa3,0x53,0x62,0x83,0x65,0x11,0x61,0x72,1,0x61,0xa3,0x53,
-0x62,0x83,0x11,0x6d,0x61,0xa3,0x8b,0x68,0x6e,0x69,0xa2,0x95,0x6a,2,0x61,0x30,
-0x70,0x52,0x75,0x11,0x72,0x63,0xa3,0x94,1,0x6d,0x38,0x76,0x10,0x61,0xa2,0x4e,
-0x13,0x6e,0x65,0x73,0x65,0xa3,0x4e,0x10,0x6f,0xa3,0xad,0x11,0x61,0x6e,0xa3,0x69,
-6,0x6c,0x1e,0x6c,0x34,0x6d,0x3a,0x72,0x48,0x75,0x11,0x6e,0x67,0xa3,0x4c,0x11,
-0x75,0x77,0xa3,0x9c,0x10,0x6e,1,0x67,0xa3,0x4b,0x70,0xa3,0xba,0x11,0x6b,0x74,
-0x8d,0x61,0x3c,0x65,0xa2,0x43,0x69,0x11,0x72,0x61,0x48,0x13,0x67,0x61,0x6e,0x61,
-0x49,1,0x6e,0x34,0x74,0x10,0x72,0xa2,0xa2,0x11,0x61,0x6e,0xa3,0xa2,0x42,6,
-0x6f,0xe,0x6f,0x77,0x73,0xa3,0x49,0x74,0xa3,0x4a,0x75,0x12,0x6e,0x6f,0x6f,0x77,
-0x62,0xa3,0xac,0x67,0x3e,0x69,0x42,0x19,0x66,0x69,0x72,0x6f,0x68,0x69,0x6e,0x67,
-0x79,0x61,0xa3,0xb6,0x44,0x11,0x75,0x6c,0x45,0x11,0x62,0x72,0x46,0x11,0x65,0x77,
-0x47,2,0x6d,0x2e,0x6e,0x4a,0x74,0x11,0x61,0x6c,0x5d,0x1c,0x70,0x65,0x72,0x69,
-0x61,0x6c,0x61,0x72,0x61,0x6d,0x61,0x69,0x63,0xa3,0x74,2,0x64,0x66,0x68,0x6a,
-0x73,0x1b,0x63,0x72,0x69,0x70,0x74,0x69,0x6f,0x6e,0x61,0x6c,0x70,0x61,1,0x68,
-0x32,0x72,0x14,0x74,0x68,0x69,0x61,0x6e,0xa3,0x7d,0x13,0x6c,0x61,0x76,0x69,0xa3,
-0x7a,0x10,0x73,0xa3,0x4d,0x15,0x65,0x72,0x69,0x74,0x65,0x64,0x23,0x64,0xc1,0xd,
-0x64,0xa2,0x7a,0x65,0xa2,0xc1,0x67,4,0x65,0x82,0x6c,0x9a,0x6f,0xa2,0x46,0x72,
-0xa2,0x55,0x75,2,0x6a,0x3c,0x6e,0x4e,0x72,1,0x6d,0x24,0x75,0x41,0x13,0x75,
-0x6b,0x68,0x69,0x41,1,0x61,0x24,0x72,0x3f,0x13,0x72,0x61,0x74,0x69,0x3f,0x18,
-0x6a,0x61,0x6c,0x61,0x67,0x6f,0x6e,0x64,0x69,0xa3,0xb3,0x10,0x6f,1,0x6b,0xa3,
-0x48,0x72,0x38,0x13,0x67,0x69,0x61,0x6e,0x39,0x11,0x61,0x67,0x90,0x15,0x6f,0x6c,
-0x69,0x74,0x69,0x63,0x91,1,0x6e,0x30,0x74,0x10,0x68,0x3a,0x11,0x69,0x63,0x3b,
-1,0x67,0xa3,0xb3,0x6d,0xa3,0xaf,1,0x61,0x32,0x65,1,0x65,0x24,0x6b,0x3d,
-0x10,0x6b,0x3d,0x10,0x6e,0xa2,0x89,0x12,0x74,0x68,0x61,0xa3,0x89,4,0x65,0x46,
-0x69,0x6c,0x6f,0x8c,0x73,0x9a,0x75,0x11,0x70,0x6c,0xa2,0x87,0x13,0x6f,0x79,0x61,
-0x6e,0xa3,0x87,1,0x73,0x38,0x76,0x10,0x61,0x34,0x15,0x6e,0x61,0x67,0x61,0x72,
-0x69,0x35,0x13,0x65,0x72,0x65,0x74,0x33,1,0x61,0x36,0x76,0x16,0x65,0x73,0x61,
-0x6b,0x75,0x72,0x75,0xa3,0xbe,0x10,0x6b,0xa3,0xbe,0x11,0x67,0x72,0xa2,0xb2,0x10,
-0x61,0xa3,0xb2,0x11,0x72,0x74,0x33,2,0x67,0x3a,0x6c,0x72,0x74,0x11,0x68,0x69,
-0x36,0x13,0x6f,0x70,0x69,0x63,0x37,0x10,0x79,2,0x64,0xa3,0x45,0x68,0xa3,0x46,
-0x70,0xa2,0x47,0x1e,0x74,0x69,0x61,0x6e,0x68,0x69,0x65,0x72,0x6f,0x67,0x6c,0x79,
-0x70,0x68,0x73,0xa3,0x47,1,0x62,0x36,0x79,0x10,0x6d,0xa2,0xb9,0x12,0x61,0x69,
-0x63,0xa3,0xb9,0x10,0x61,0xa2,0x88,0x12,0x73,0x61,0x6e,0xa3,0x88,0x61,0xa2,0xc9,
-0x62,0xa4,0x2e,0x63,6,0x6f,0x52,0x6f,0x76,0x70,0x92,0x75,0xa2,0x41,0x79,1,
-0x70,0x3e,0x72,2,0x69,0x2a,0x6c,0x31,0x73,0xa3,0x44,0x13,0x6c,0x6c,0x69,0x63,
-0x31,0x10,0x72,1,0x69,0x34,0x6f,0x15,0x6d,0x69,0x6e,0x6f,0x61,0x6e,0xa3,0xc1,
-0x11,0x6f,0x74,0x7f,1,0x6d,0x30,0x70,0x10,0x74,0x2e,0x11,0x69,0x63,0x2f,0x12,
-0x6d,0x6f,0x6e,0x21,1,0x6d,0x28,0x72,0x10,0x74,0x7f,0x10,0x6e,0xa3,0xc1,0x16,
-0x6e,0x65,0x69,0x66,0x6f,0x72,0x6d,0xa3,0x65,0x61,0x32,0x68,0xa2,0x41,0x69,0x11,
-0x72,0x74,0xa3,0x43,3,0x6b,0x4c,0x6e,0x50,0x72,0x76,0x75,0x1d,0x63,0x61,0x73,
-0x69,0x61,0x6e,0x61,0x6c,0x62,0x61,0x6e,0x69,0x61,0x6e,0xa3,0x9f,0x10,0x6d,0xa3,
-0x76,1,0x61,0x24,0x73,0x71,0x1d,0x64,0x69,0x61,0x6e,0x61,0x62,0x6f,0x72,0x69,
-0x67,0x69,0x6e,0x61,0x6c,0x71,0x10,0x69,0xa2,0x68,0x11,0x61,0x6e,0xa3,0x68,3,
-0x61,0x32,0x65,0x44,0x6f,0x52,0x72,0x10,0x73,0xa3,0xbd,1,0x6b,0x26,0x6d,0xa3,
-0x42,0x11,0x6d,0x61,0xa3,0x76,0x10,0x72,0x2c,0x13,0x6f,0x6b,0x65,0x65,0x2d,0x16,
-0x72,0x61,0x73,0x6d,0x69,0x61,0x6e,0xa3,0xbd,6,0x68,0x4a,0x68,0x48,0x6e,0x4e,
-0x72,0x76,0x76,1,0x65,0x2a,0x73,0x10,0x74,0xa3,0x75,0x13,0x73,0x74,0x61,0x6e,
-0xa3,0x75,0x11,0x6f,0x6d,0xa3,0xa1,0x11,0x61,0x74,0x1f,0x6f,0x6c,0x69,0x61,0x6e,
-0x68,0x69,0x65,0x72,0x6f,0x67,0x6c,0x79,0x70,0x68,0x73,0xa3,0x9c,1,0x61,0x3e,
-0x6d,2,0x65,0x2a,0x69,0xa3,0x74,0x6e,0x27,0x13,0x6e,0x69,0x61,0x6e,0x27,0x10,
-0x62,0x24,0x11,0x69,0x63,0x25,0x64,0x30,0x66,0x44,0x67,0x11,0x68,0x62,0xa3,0x9f,
-0x10,0x6c,1,0x61,0x26,0x6d,0xa3,0xa7,0x10,0x6d,0xa3,0xa7,0x11,0x61,0x6b,0xa3,
-0x93,6,0x6c,0x3c,0x6c,0x52,0x6f,0x56,0x72,0x66,0x75,1,0x67,0x30,0x68,1,
-0x64,0x79,0x69,0x10,0x64,0x79,0x10,0x69,0x8e,0x13,0x6e,0x65,0x73,0x65,0x8f,0x11,
-0x69,0x73,0xa1,0x11,0x70,0x6f,0x2a,0x13,0x6d,0x6f,0x66,0x6f,0x2b,0x10,0x61,1,
-0x68,0x2e,0x69,0x7c,0x12,0x6c,0x6c,0x65,0x7d,0xa2,0x41,0x11,0x6d,0x69,0xa3,0x41,
-0x61,0x48,0x65,0x9c,0x68,1,0x61,0x2a,0x6b,0x10,0x73,0xa3,0xa8,0x15,0x69,0x6b,
-0x73,0x75,0x6b,0x69,0xa3,0xa8,3,0x6c,0x3a,0x6d,0x48,0x73,0x54,0x74,1,0x61,
-0x24,0x6b,0x9f,0x10,0x6b,0x9f,0x10,0x69,0x9c,0x13,0x6e,0x65,0x73,0x65,0x9d,0x10,
-0x75,0xa2,0x82,0x10,0x6d,0xa3,0x82,0x10,0x73,0xa2,0x86,0x13,0x61,0x76,0x61,0x68,
-0xa3,0x86,0x11,0x6e,0x67,0x28,0x12,0x61,0x6c,0x69,0x29,3,0x6c,0x42,0x6e,0x90,
-0x74,0xa2,0x46,0x76,0x24,0x17,0x6f,0x77,0x65,0x6c,0x6a,0x61,0x6d,0x6f,0x25,0x22,
-1,0x65,0x54,0x76,0x28,1,0x73,0x38,0x74,0x2a,0x17,0x73,0x79,0x6c,0x6c,0x61,
-0x62,0x6c,0x65,0x2b,0x16,0x79,0x6c,0x6c,0x61,0x62,0x6c,0x65,0x29,0x18,0x61,0x64,
-0x69,0x6e,0x67,0x6a,0x61,0x6d,0x6f,0x23,1,0x61,0x21,0x6f,0x1a,0x74,0x61,0x70,
-0x70,0x6c,0x69,0x63,0x61,0x62,0x6c,0x65,0x21,0x26,0x1a,0x72,0x61,0x69,0x6c,0x69,
-0x6e,0x67,0x6a,0x61,0x6d,0x6f,0x27,1,0x6e,0x2c,0x79,0x22,0x11,0x65,0x73,0x23,
-0x20,0x10,0x6f,0x21,1,0x6e,0x2c,0x79,0x22,0x11,0x65,0x73,0x23,0x20,0x10,0x6f,
-0x21,2,0x6d,0x30,0x6e,0x3a,0x79,0x22,0x11,0x65,0x73,0x23,0x24,0x13,0x61,0x79,
-0x62,0x65,0x25,0x20,0x10,0x6f,0x21,2,0x6d,0x30,0x6e,0x3a,0x79,0x22,0x11,0x65,
-0x73,0x23,0x24,0x13,0x61,0x79,0x62,0x65,0x25,0x20,0x10,0x6f,0x21,0xb,0x72,0x39,
-0x76,0xc,0x76,0x33,0x78,0x2a,0x7a,0x11,0x77,0x6a,0x43,0x10,0x78,0x21,0x72,0x28,
-0x73,0x50,0x74,0x31,1,0x65,0x24,0x69,0x39,0x1e,0x67,0x69,0x6f,0x6e,0x61,0x6c,
-0x69,0x6e,0x64,0x69,0x63,0x61,0x74,0x6f,0x72,0x39,1,0x6d,0x35,0x70,0x18,0x61,
-0x63,0x69,0x6e,0x67,0x6d,0x61,0x72,0x6b,0x35,0x6c,0x1f,0x6c,0x3c,0x6f,0x4a,0x70,
-1,0x70,0x37,0x72,0x14,0x65,0x70,0x65,0x6e,0x64,0x37,0x28,1,0x66,0x2b,0x76,
-0x2c,0x10,0x74,0x2f,0x13,0x74,0x68,0x65,0x72,0x21,0x63,0x4c,0x65,0x64,0x67,1,
-0x61,0x3a,0x6c,0x19,0x75,0x65,0x61,0x66,0x74,0x65,0x72,0x7a,0x77,0x6a,0x41,0x10,
-0x7a,0x41,2,0x6e,0x23,0x6f,0x24,0x72,0x25,0x14,0x6e,0x74,0x72,0x6f,0x6c,0x23,
-2,0x62,0x34,0x6d,0x4e,0x78,0x26,0x13,0x74,0x65,0x6e,0x64,0x27,0x3a,1,0x61,
-0x24,0x67,0x3d,0x11,0x73,0x65,0x3a,0x12,0x67,0x61,0x7a,0x3d,0x3e,0x16,0x6f,0x64,
-0x69,0x66,0x69,0x65,0x72,0x3f,9,0x6e,0x4a,0x6e,0x34,0x6f,0x44,0x73,0x60,0x75,
-0x94,0x78,0x10,0x78,0x21,0x10,0x75,0x2a,0x14,0x6d,0x65,0x72,0x69,0x63,0x2b,1,
-0x6c,0x2c,0x74,0x12,0x68,0x65,0x72,0x21,0x14,0x65,0x74,0x74,0x65,0x72,0x2d,3,
-0x63,0x36,0x65,0x46,0x70,0x31,0x74,0x32,0x12,0x65,0x72,0x6d,0x33,0x3c,0x16,0x6f,
-0x6e,0x74,0x69,0x6e,0x75,0x65,0x3d,0x2e,0x10,0x70,0x2f,0x10,0x70,0x34,0x12,0x70,
-0x65,0x72,0x35,0x61,0x46,0x63,0x52,0x65,0x64,0x66,0x72,0x6c,2,0x65,0x2d,0x66,
-0x3b,0x6f,0x28,0x12,0x77,0x65,0x72,0x29,0x10,0x74,0x22,0x12,0x65,0x72,0x6d,0x23,
-1,0x6c,0x24,0x72,0x37,0x24,0x12,0x6f,0x73,0x65,0x25,0x10,0x78,0x38,0x13,0x74,
-0x65,0x6e,0x64,0x39,0x10,0x6f,0x26,0x13,0x72,0x6d,0x61,0x74,0x27,0,0x10,0x6c,
-0x88,0x72,0x40,0x72,0x36,0x73,0x5e,0x77,0x7a,0x78,0x8a,0x7a,0x11,0x77,0x6a,0x4b,
-1,0x65,0x24,0x69,0x3b,0x1e,0x67,0x69,0x6f,0x6e,0x61,0x6c,0x69,0x6e,0x64,0x69,
-0x63,0x61,0x74,0x6f,0x72,0x3b,1,0x69,0x24,0x71,0x3f,0x18,0x6e,0x67,0x6c,0x65,
-0x71,0x75,0x6f,0x74,0x65,0x3f,0x17,0x73,0x65,0x67,0x73,0x70,0x61,0x63,0x65,0x4d,
-0x10,0x78,0x21,0x6c,0x36,0x6d,0x3c,0x6e,0x76,0x6f,0x13,0x74,0x68,0x65,0x72,0x21,
-1,0x65,0x23,0x66,0x35,3,0x62,0x37,0x69,0x28,0x6c,0x29,0x6e,0x2b,0x10,0x64,
-1,0x6c,0x34,0x6e,0x11,0x75,0x6d,0x2a,0x12,0x6c,0x65,0x74,0x37,0x14,0x65,0x74,
-0x74,0x65,0x72,0x29,2,0x65,0x36,0x6c,0x39,0x75,0x2c,0x14,0x6d,0x65,0x72,0x69,
-0x63,0x2d,0x14,0x77,0x6c,0x69,0x6e,0x65,0x39,0x66,0x3f,0x66,0x40,0x67,0x4e,0x68,
-0x70,0x6b,0x10,0x61,0x26,0x15,0x74,0x61,0x6b,0x61,0x6e,0x61,0x27,0x10,0x6f,0x24,
-0x13,0x72,0x6d,0x61,0x74,0x25,1,0x61,0x3a,0x6c,0x19,0x75,0x65,0x61,0x66,0x74,
-0x65,0x72,0x7a,0x77,0x6a,0x49,0x10,0x7a,0x49,1,0x65,0x24,0x6c,0x3d,0x19,0x62,
-0x72,0x65,0x77,0x6c,0x65,0x74,0x74,0x65,0x72,0x3d,0x61,0x86,0x63,0x92,0x64,0x94,
-0x65,2,0x62,0x44,0x6d,0x5e,0x78,0x2e,0x13,0x74,0x65,0x6e,0x64,0x32,0x15,0x6e,
-0x75,0x6d,0x6c,0x65,0x74,0x2f,0x42,1,0x61,0x24,0x67,0x45,0x11,0x73,0x65,0x42,
-0x12,0x67,0x61,0x7a,0x45,0x46,0x16,0x6f,0x64,0x69,0x66,0x69,0x65,0x72,0x47,0x15,
-0x6c,0x65,0x74,0x74,0x65,0x72,0x23,0x10,0x72,0x31,1,0x6f,0x24,0x71,0x41,0x18,
-0x75,0x62,0x6c,0x65,0x71,0x75,0x6f,0x74,0x65,0x41,2,0x63,0x32,0x6e,0x3c,0x6f,
-0x22,0x12,0x70,0x65,0x6e,0x23,0x24,0x13,0x6c,0x6f,0x73,0x65,0x25,0x20,0x12,0x6f,
-0x6e,0x65,0x21,6,0x6f,0x65,0x6f,0x4a,0x72,0x5c,0x74,0x64,0x76,0x1d,0x69,0x73,
-0x75,0x61,0x6c,0x6f,0x72,0x64,0x65,0x72,0x6c,0x65,0x66,0x74,0x3d,0x18,0x76,0x65,
-0x72,0x73,0x74,0x72,0x75,0x63,0x6b,0x2d,0x13,0x69,0x67,0x68,0x74,0x2f,0x11,0x6f,
-0x70,0x30,0x12,0x61,0x6e,0x64,2,0x62,0x32,0x6c,0x62,0x72,0x13,0x69,0x67,0x68,
-0x74,0x3b,0x14,0x6f,0x74,0x74,0x6f,0x6d,0x32,0x12,0x61,0x6e,0x64,1,0x6c,0x2e,
-0x72,0x13,0x69,0x67,0x68,0x74,0x35,0x12,0x65,0x66,0x74,0x3f,0x12,0x65,0x66,0x74,
-0x36,0x17,0x61,0x6e,0x64,0x72,0x69,0x67,0x68,0x74,0x39,0x62,0x2c,0x6c,0x5c,0x6e,
-0x10,0x61,0x21,0x14,0x6f,0x74,0x74,0x6f,0x6d,0x22,0x12,0x61,0x6e,0x64,1,0x6c,
-0x2e,0x72,0x13,0x69,0x67,0x68,0x74,0x27,0x12,0x65,0x66,0x74,0x25,0x12,0x65,0x66,
-0x74,0x28,0x17,0x61,0x6e,0x64,0x72,0x69,0x67,0x68,0x74,0x2b,0xd,0x6e,0xaa,0x72,
-0x70,0x72,0x92,0x73,0xa2,0x46,0x74,0xa2,0x54,0x76,1,0x69,0x60,0x6f,0x12,0x77,
-0x65,0x6c,0x62,1,0x64,0x3a,0x69,0x19,0x6e,0x64,0x65,0x70,0x65,0x6e,0x64,0x65,
-0x6e,0x74,0x67,0x17,0x65,0x70,0x65,0x6e,0x64,0x65,0x6e,0x74,0x65,1,0x72,0x2e,
-0x73,0x13,0x61,0x72,0x67,0x61,0x61,0x12,0x61,0x6d,0x61,0x5f,0x1d,0x65,0x67,0x69,
-0x73,0x74,0x65,0x72,0x73,0x68,0x69,0x66,0x74,0x65,0x72,0x57,0x1e,0x79,0x6c,0x6c,
-0x61,0x62,0x6c,0x65,0x6d,0x6f,0x64,0x69,0x66,0x69,0x65,0x72,0x59,0x12,0x6f,0x6e,
-0x65,1,0x6c,0x2c,0x6d,0x12,0x61,0x72,0x6b,0x5d,0x14,0x65,0x74,0x74,0x65,0x72,
-0x5b,0x6e,0x3c,0x6f,0x7c,0x70,0x18,0x75,0x72,0x65,0x6b,0x69,0x6c,0x6c,0x65,0x72,
-0x55,1,0x6f,0x4c,0x75,1,0x6b,0x3c,0x6d,0x12,0x62,0x65,0x72,0x50,0x15,0x6a,
-0x6f,0x69,0x6e,0x65,0x72,0x53,0x11,0x74,0x61,0x4f,0x16,0x6e,0x6a,0x6f,0x69,0x6e,
-0x65,0x72,0x4d,0x13,0x74,0x68,0x65,0x72,0x21,0x67,0x3e,0x67,0x4a,0x69,0x64,0x6a,
-0x82,0x6d,0x1d,0x6f,0x64,0x69,0x66,0x79,0x69,0x6e,0x67,0x6c,0x65,0x74,0x74,0x65,
-0x72,0x4b,0x1c,0x65,0x6d,0x69,0x6e,0x61,0x74,0x69,0x6f,0x6e,0x6d,0x61,0x72,0x6b,
-0x45,0x1e,0x6e,0x76,0x69,0x73,0x69,0x62,0x6c,0x65,0x73,0x74,0x61,0x63,0x6b,0x65,
-0x72,0x47,0x14,0x6f,0x69,0x6e,0x65,0x72,0x49,0x61,0xa2,0xba,0x62,0xa2,0xc0,0x63,
-1,0x61,0xa2,0xa2,0x6f,0x16,0x6e,0x73,0x6f,0x6e,0x61,0x6e,0x74,0x2a,8,0x6b,
-0x67,0x6b,0x48,0x6d,0x52,0x70,0x5c,0x73,0xa2,0x42,0x77,0x19,0x69,0x74,0x68,0x73,
-0x74,0x61,0x63,0x6b,0x65,0x72,0x43,0x14,0x69,0x6c,0x6c,0x65,0x72,0x35,0x14,0x65,
-0x64,0x69,0x61,0x6c,0x37,1,0x6c,0x52,0x72,0x10,0x65,1,0x63,0x2e,0x66,0x13,
-0x69,0x78,0x65,0x64,0x3d,0x19,0x65,0x64,0x69,0x6e,0x67,0x72,0x65,0x70,0x68,0x61,
-0x3b,0x18,0x61,0x63,0x65,0x68,0x6f,0x6c,0x64,0x65,0x72,0x39,0x10,0x75,1,0x62,
-0x3e,0x63,0x1b,0x63,0x65,0x65,0x64,0x69,0x6e,0x67,0x72,0x65,0x70,0x68,0x61,0x41,
-0x15,0x6a,0x6f,0x69,0x6e,0x65,0x64,0x3f,0x64,0x4c,0x66,0x52,0x68,0x5a,0x69,0x1e,
-0x6e,0x69,0x74,0x69,0x61,0x6c,0x70,0x6f,0x73,0x74,0x66,0x69,0x78,0x65,0x64,0x33,
-0x12,0x65,0x61,0x64,0x2d,0x13,0x69,0x6e,0x61,0x6c,0x2f,0x18,0x65,0x61,0x64,0x6c,
-0x65,0x74,0x74,0x65,0x72,0x31,0x1d,0x6e,0x74,0x69,0x6c,0x6c,0x61,0x74,0x69,0x6f,
-0x6e,0x6d,0x61,0x72,0x6b,0x29,0x16,0x76,0x61,0x67,0x72,0x61,0x68,0x61,0x23,1,
-0x69,0x4a,0x72,0x10,0x61,0x1f,0x68,0x6d,0x69,0x6a,0x6f,0x69,0x6e,0x69,0x6e,0x67,
-0x6e,0x75,0x6d,0x62,0x65,0x72,0x27,0x12,0x6e,0x64,0x75,0x25,2,0x72,0x38,0x74,
-0x46,0x75,0x26,0x15,0x70,0x72,0x69,0x67,0x68,0x74,0x27,0x20,0x15,0x6f,0x74,0x61,
-0x74,0x65,0x64,0x21,1,0x72,0x24,0x75,0x25,0x22,0x18,0x61,0x6e,0x73,0x66,0x6f,
-0x72,0x6d,0x65,0x64,1,0x72,0x32,0x75,0x15,0x70,0x72,0x69,0x67,0x68,0x74,0x25,
-0x15,0x6f,0x74,0x61,0x74,0x65,0x64,0x23,0xd,0x6e,0xc1,0x86,0x73,0xa8,0x73,0x4c,
-0x74,0xa2,0x76,0x75,0xa2,0x83,0x7a,0xd8,0x70,0,2,0x6c,0xd9,0x20,0,0x70,
-0xd9,0x40,0,0x73,0xc3,0,0xfe,0xf,0,0,0,7,0x6f,0x3c,0x6f,0xff,
-8,0,0,0,0x70,0x3a,0x75,0x6e,0x79,0x13,0x6d,0x62,0x6f,0x6c,0xff,0xf,
-0,0,0,0x11,0x61,0x63,1,0x65,0x34,0x69,0x15,0x6e,0x67,0x6d,0x61,0x72,
-0x6b,0xa5,0,0x18,0x73,0x65,0x70,0x61,0x72,0x61,0x74,0x6f,0x72,0xc3,0,0x16,
-0x72,0x72,0x6f,0x67,0x61,0x74,0x65,0xe1,0,0,0x63,0xff,2,0,0,0,
-0x65,0x38,0x6b,0xff,4,0,0,0,0x6d,0xff,1,0,0,0,0x16,0x70,
-0x61,0x72,0x61,0x74,0x6f,0x72,0xd9,0x70,0,0x1d,0x69,0x74,0x6c,0x65,0x63,0x61,
-0x73,0x65,0x6c,0x65,0x74,0x74,0x65,0x72,0x31,1,0x6e,0x40,0x70,0x1c,0x70,0x65,
-0x72,0x63,0x61,0x73,0x65,0x6c,0x65,0x74,0x74,0x65,0x72,0x25,0x17,0x61,0x73,0x73,
-0x69,0x67,0x6e,0x65,0x64,0x23,0x6e,0xa2,0x69,0x6f,0xa2,0x89,0x70,0xfe,0x30,0xf8,
-0,0,9,0x69,0x33,0x69,0xff,0x10,0,0,0,0x6f,0xfd,0x80,0,0,
-0x72,0x54,0x73,0xf9,0,0,0x75,0x12,0x6e,0x63,0x74,0xfe,0x30,0xf8,0,0,
-0x15,0x75,0x61,0x74,0x69,0x6f,0x6e,0xff,0x30,0xf8,0,0,0x17,0x69,0x76,0x61,
-0x74,0x65,0x75,0x73,0x65,0xdd,0,0,0x61,0x48,0x63,0xfd,0x40,0,0,0x64,
-0xe9,0,0,0x65,0xfd,0x20,0,0,0x66,0xff,0x20,0,0,0,0x1f,0x72,
-0x61,0x67,0x72,0x61,0x70,0x68,0x73,0x65,0x70,0x61,0x72,0x61,0x74,0x6f,0x72,0xd9,
-0x40,0,0xbe,0,3,0x64,0xa7,0,0x6c,0xab,0,0x6f,0x30,0x75,0x13,0x6d,
-0x62,0x65,0x72,0xbf,0,0xb2,0,0x1b,0x6e,0x73,0x70,0x61,0x63,0x69,0x6e,0x67,
-0x6d,0x61,0x72,0x6b,0xa1,1,0x70,0x92,0x74,0x12,0x68,0x65,0x72,0xe6,0x80,1,
-3,0x6c,0x40,0x6e,0x4a,0x70,0x56,0x73,0x14,0x79,0x6d,0x62,0x6f,0x6c,0xff,8,
-0,0,0,0x14,0x65,0x74,0x74,0x65,0x72,0x61,0x14,0x75,0x6d,0x62,0x65,0x72,
-0xb3,0,0x19,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0xfd,0x80,0,
-0,0x1c,0x65,0x6e,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0xf9,
-0,0,0x66,0xc0,0xc4,0x66,0xa2,0x47,0x69,0xa2,0x64,0x6c,0xa2,0x79,0x6d,0xa4,
-0xc0,4,0x61,0x6c,0x63,0xa5,0,0x65,0xa3,0x80,0x6e,0xa1,0x6f,0x15,0x64,0x69,
-0x66,0x69,0x65,0x72,1,0x6c,0x38,0x73,0x14,0x79,0x6d,0x62,0x6f,0x6c,0xff,4,
-0,0,0,0x14,0x65,0x74,0x74,0x65,0x72,0x41,1,0x72,0x3c,0x74,0x16,0x68,
-0x73,0x79,0x6d,0x62,0x6f,0x6c,0xff,1,0,0,0,0x10,0x6b,0xa5,0xc0,1,
-0x69,0x32,0x6f,0x13,0x72,0x6d,0x61,0x74,0xdb,0,0,0x1d,0x6e,0x61,0x6c,0x70,
-0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0xff,0x20,0,0,0,0x10,
-0x6e,0x1f,0x69,0x74,0x69,0x61,0x6c,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,
-0x6f,0x6e,0xff,0x10,0,0,0,0x9c,7,0x6d,0x18,0x6d,0x41,0x6f,0x28,0x74,
-0x31,0x75,0x25,0x60,0x1c,0x77,0x65,0x72,0x63,0x61,0x73,0x65,0x6c,0x65,0x74,0x74,
-0x65,0x72,0x29,0x63,0x3d,0x65,0x28,0x69,0x42,0x6c,0x29,0x13,0x74,0x74,0x65,0x72,
-0x9c,0x15,0x6e,0x75,0x6d,0x62,0x65,0x72,0xab,0,0x1a,0x6e,0x65,0x73,0x65,0x70,
-0x61,0x72,0x61,0x74,0x6f,0x72,0xd9,0x20,0,0x63,0x46,0x64,0xa2,0x96,0x65,0x1b,
-0x6e,0x63,0x6c,0x6f,0x73,0x69,0x6e,0x67,0x6d,0x61,0x72,0x6b,0xa3,0x80,0xe6,0x80,
-1,7,0x6e,0x57,0x6e,0x52,0x6f,0x5e,0x73,0xe1,0,0,0x75,0x1b,0x72,0x72,
-0x65,0x6e,0x63,0x79,0x73,0x79,0x6d,0x62,0x6f,0x6c,0xff,2,0,0,0,0x22,
-0x12,0x74,0x72,0x6c,0xd9,0x80,0,0xdc,0,0,1,0x6d,0x62,0x6e,1,0x6e,
-0x30,0x74,0x12,0x72,0x6f,0x6c,0xd9,0x80,0,0x1f,0x65,0x63,0x74,0x6f,0x72,0x70,
-0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0xfd,0x40,0,0,0x19,0x62,
-0x69,0x6e,0x69,0x6e,0x67,0x6d,0x61,0x72,0x6b,0xa5,0xc0,0x61,0x58,0x63,0xd9,0x80,
-0,0x66,0xdb,0,0,0x6c,0x1d,0x6f,0x73,0x65,0x70,0x75,0x6e,0x63,0x74,0x75,
-0x61,0x74,0x69,0x6f,0x6e,0xfd,0x20,0,0,0x18,0x73,0x65,0x64,0x6c,0x65,0x74,
-0x74,0x65,0x72,0x3d,2,0x61,0x32,0x65,0x50,0x69,0x12,0x67,0x69,0x74,0xa7,0,
-0x1c,0x73,0x68,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0xe9,0,
-0,0x1a,0x63,0x69,0x6d,0x61,0x6c,0x6e,0x75,0x6d,0x62,0x65,0x72,0xa7,0
+0x69,0x6c,0x75,0x65,0xa3,0x8b,2,0x62,0x3c,0x67,0x4a,0x6e,0x17,0x64,0x69,0x6e,
+0x61,0x67,0x61,0x72,0x69,0xa5,0x26,0x15,0x61,0x74,0x61,0x65,0x61,0x6e,0xa3,0xef,
+0x16,0x6d,0x75,0x6e,0x64,0x61,0x72,0x69,0xa5,0x47,0x67,0xc4,0x5d,0x6a,0xc1,0xe4,
+0x6a,0xa2,0xdf,0x6b,0xa2,0xf8,0x6c,4,0x61,0x54,0x65,0xa2,0x6b,0x69,0xa2,0x82,
+0x6f,0xa2,0xc1,0x79,1,0x63,0x2e,0x64,0x12,0x69,0x61,0x6e,0xa3,0xa9,0x12,0x69,
+0x61,0x6e,0xa3,0xa7,1,0x6f,0x55,0x74,0x11,0x69,0x6e,1,0x31,0x96,0x65,0x11,
+0x78,0x74,6,0x64,0x21,0x64,0xa3,0x95,0x65,0x2c,0x66,0xa5,0x39,0x67,0xa5,0x3a,
+0xa2,0xe7,0x13,0x6e,0x64,0x65,0x64,6,0x64,0xc,0x64,0xa3,0x95,0x65,0xa3,0xe7,
+0x66,0xa5,0x39,0x67,0xa5,0x3a,0x61,0x2a,0x62,0x29,0x63,0xa3,0x94,0x26,0x18,0x64,
+0x64,0x69,0x74,0x69,0x6f,0x6e,0x61,0x6c,0x6d,0x24,0x12,0x73,0x75,0x70,0x24,0x16,
+0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x25,1,0x70,0x42,0x74,0x1d,0x74,0x65,0x72,
+0x6c,0x69,0x6b,0x65,0x73,0x79,0x6d,0x62,0x6f,0x6c,0x73,0x79,0x12,0x63,0x68,0x61,
+0xa3,0x9c,2,0x6d,0x4e,0x6e,0x54,0x73,0x10,0x75,0xa2,0xb0,0x12,0x73,0x75,0x70,
+0xa4,0x31,0x16,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0xa5,0x31,0x11,0x62,0x75,0xa3,
+0x6f,0x12,0x65,0x61,0x72,1,0x61,0xa3,0xe8,0x62,1,0x69,0x38,0x73,0x17,0x79,
+0x6c,0x6c,0x61,0x62,0x61,0x72,0x79,0xa3,0x75,0x17,0x64,0x65,0x6f,0x67,0x72,0x61,
+0x6d,0x73,0xa3,0x76,0x1a,0x77,0x73,0x75,0x72,0x72,0x6f,0x67,0x61,0x74,0x65,0x73,
+0xa3,0x4d,0x10,0x61,1,0x6d,0x32,0x76,0x14,0x61,0x6e,0x65,0x73,0x65,0xa3,0xb5,
+0x10,0x6f,0x5c,0x12,0x65,0x78,0x74,1,0x61,0xa3,0xb4,0x62,0xa3,0xb9,1,0x61,
+0xa2,0x43,0x68,4,0x61,0x40,0x69,0x50,0x6d,0x6e,0x6f,0x86,0x75,0x15,0x64,0x61,
+0x77,0x61,0x64,0x69,0xa3,0xe6,0x16,0x72,0x6f,0x73,0x68,0x74,0x68,0x69,0xa3,0x89,
+0x1d,0x74,0x61,0x6e,0x73,0x6d,0x61,0x6c,0x6c,0x73,0x63,0x72,0x69,0x70,0x74,0xa5,
+0x30,0x11,0x65,0x72,0x68,0x16,0x73,0x79,0x6d,0x62,0x6f,0x6c,0x73,0xa3,0x71,0x12,
+0x6a,0x6b,0x69,0xa3,0xe5,5,0x74,0x35,0x74,0x34,0x77,0x7a,0x79,0x13,0x61,0x68,
+0x6c,0x69,0xa3,0xa2,0x14,0x61,0x6b,0x61,0x6e,0x61,0x9e,1,0x65,0x4c,0x70,0x10,
+0x68,0x1f,0x6f,0x6e,0x65,0x74,0x69,0x63,0x65,0x78,0x74,0x65,0x6e,0x73,0x69,0x6f,
+0x6e,0x73,0xa3,0x6b,0x11,0x78,0x74,0xa3,0x6b,0x10,0x69,0xa5,0x46,0x69,0xa2,0x4e,
+0x6b,0xa2,0x51,0x6e,3,0x61,0x34,0x62,0x84,0x67,0x8a,0x6e,0x12,0x61,0x64,0x61,
+0x4d,1,0x65,0x40,0x73,0x11,0x75,0x70,0xa2,0xcb,0x16,0x70,0x6c,0x65,0x6d,0x65,
+0x6e,0x74,0xa3,0xcb,0x11,0x78,0x74,2,0x61,0xa5,0x13,0x62,0xa5,0x38,0x65,0x13,
+0x6e,0x64,0x65,0x64,1,0x61,0xa5,0x13,0x62,0xa5,0x38,0x11,0x75,0x6e,0xa3,0x42,
+0x11,0x78,0x69,0x96,0x17,0x72,0x61,0x64,0x69,0x63,0x61,0x6c,0x73,0x97,0x12,0x74,
+0x68,0x69,0xa3,0xc1,0x1c,0x74,0x6f,0x76,0x69,0x6b,0x6e,0x75,0x6d,0x65,0x72,0x61,
+0x6c,0x73,0xa5,0x45,0x67,0xa2,0xb5,0x68,0xa4,0x84,0x69,3,0x64,0x4c,0x6d,0xa2,
+0x55,0x6e,0xa2,0x62,0x70,0x13,0x61,0x65,0x78,0x74,0x2a,0x16,0x65,0x6e,0x73,0x69,
+0x6f,0x6e,0x73,0x2b,1,0x63,0x99,0x65,0x17,0x6f,0x67,0x72,0x61,0x70,0x68,0x69,
+0x63,1,0x64,0x56,0x73,0x15,0x79,0x6d,0x62,0x6f,0x6c,0x73,0xa4,0xb,0x1d,0x61,
+0x6e,0x64,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0xa5,0xb,0x13,
+0x65,0x73,0x63,0x72,0x1f,0x69,0x70,0x74,0x69,0x6f,0x6e,0x63,0x68,0x61,0x72,0x61,
+0x63,0x74,0x65,0x72,0x73,0x99,0x1c,0x70,0x65,0x72,0x69,0x61,0x6c,0x61,0x72,0x61,
+0x6d,0x61,0x69,0x63,0xa3,0xba,1,0x64,0x62,0x73,0x1b,0x63,0x72,0x69,0x70,0x74,
+0x69,0x6f,0x6e,0x61,0x6c,0x70,0x61,1,0x68,0x32,0x72,0x14,0x74,0x68,0x69,0x61,
+0x6e,0xa3,0xbd,0x13,0x6c,0x61,0x76,0x69,0xa3,0xbe,0x11,0x69,0x63,1,0x6e,0x3e,
+0x73,0x1a,0x69,0x79,0x61,0x71,0x6e,0x75,0x6d,0x62,0x65,0x72,0x73,0xa5,0x1e,0x19,
+0x75,0x6d,0x62,0x65,0x72,0x66,0x6f,0x72,0x6d,0x73,0xa3,0xb2,4,0x65,0x74,0x6c,
+0xa2,0x82,0x6f,0xa2,0x9a,0x72,0xa2,0x9e,0x75,2,0x6a,0x34,0x6e,0x3e,0x72,0x14,
+0x6d,0x75,0x6b,0x68,0x69,0x43,0x14,0x61,0x72,0x61,0x74,0x69,0x45,0x18,0x6a,0x61,
+0x6c,0x61,0x67,0x6f,0x6e,0x64,0x69,0xa5,0x1c,1,0x6e,0xa2,0x46,0x6f,1,0x6d,
+0x6e,0x72,0x13,0x67,0x69,0x61,0x6e,0x5a,1,0x65,0x40,0x73,0x11,0x75,0x70,0xa2,
+0x87,0x16,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0xa3,0x87,0x11,0x78,0x74,0xa4,0x1b,
+0x14,0x65,0x6e,0x64,0x65,0x64,0xa5,0x1b,0x1a,0x65,0x74,0x72,0x69,0x63,0x73,0x68,
+0x61,0x70,0x65,0x73,0x8c,0x12,0x65,0x78,0x74,0xa2,0xe3,0x14,0x65,0x6e,0x64,0x65,
+0x64,0xa3,0xe3,0x1e,0x65,0x72,0x61,0x6c,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,
+0x69,0x6f,0x6e,0x71,0x17,0x61,0x67,0x6f,0x6c,0x69,0x74,0x69,0x63,0xa2,0x88,0x12,
+0x73,0x75,0x70,0xa4,0xa,0x16,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0xa5,0xa,0x13,
+0x74,0x68,0x69,0x63,0xa3,0x59,1,0x61,0x5c,0x65,0x11,0x65,0x6b,0x30,1,0x61,
+0x38,0x65,0x11,0x78,0x74,0x6e,0x14,0x65,0x6e,0x64,0x65,0x64,0x6f,0x17,0x6e,0x64,
+0x63,0x6f,0x70,0x74,0x69,0x63,0x31,0x13,0x6e,0x74,0x68,0x61,0xa3,0xe4,2,0x61,
+0xa2,0x48,0x65,0xa2,0xdf,0x69,1,0x67,0x30,0x72,0x14,0x61,0x67,0x61,0x6e,0x61,
+0x9d,0x10,0x68,1,0x70,0x3a,0x73,0x18,0x75,0x72,0x72,0x6f,0x67,0x61,0x74,0x65,
+0x73,0xa3,0x4b,1,0x72,0x3c,0x75,0x19,0x73,0x75,0x72,0x72,0x6f,0x67,0x61,0x74,
+0x65,0x73,0xa3,0x4c,0x11,0x69,0x76,0x1f,0x61,0x74,0x65,0x75,0x73,0x65,0x73,0x75,
+0x72,0x72,0x6f,0x67,0x61,0x74,0x65,0x73,0xa3,0x4c,2,0x6c,0x32,0x6e,0x9a,0x74,
+0x12,0x72,0x61,0x6e,0xa5,2,0x10,0x66,2,0x61,0x58,0x6d,0x70,0x77,0x14,0x69,
+0x64,0x74,0x68,0x61,0x1f,0x6e,0x64,0x66,0x75,0x6c,0x6c,0x77,0x69,0x64,0x74,0x68,
+0x66,0x6f,0x72,0x6d,0x73,0xa3,0x57,0x1a,0x6e,0x64,0x66,0x75,0x6c,0x6c,0x66,0x6f,
+0x72,0x6d,0x73,0xa3,0x57,0x13,0x61,0x72,0x6b,0x73,0xa3,0x52,2,0x67,0x34,0x69,
+0xa2,0x45,0x75,0x12,0x6e,0x6f,0x6f,0xa3,0x63,0x11,0x75,0x6c,0xa2,0x4a,2,0x63,
+0x3c,0x6a,0x5e,0x73,0x17,0x79,0x6c,0x6c,0x61,0x62,0x6c,0x65,0x73,0xa3,0x4a,0x1f,
+0x6f,0x6d,0x70,0x61,0x74,0x69,0x62,0x69,0x6c,0x69,0x74,0x79,0x6a,0x61,0x6d,0x6f,
+0xa3,0x41,0x12,0x61,0x6d,0x6f,0x5c,0x17,0x65,0x78,0x74,0x65,0x6e,0x64,0x65,0x64,
+1,0x61,0xa3,0xb4,0x62,0xa3,0xb9,0x19,0x66,0x69,0x72,0x6f,0x68,0x69,0x6e,0x67,
+0x79,0x61,0xa5,0x1d,0x13,0x62,0x72,0x65,0x77,0x37,0x61,0xa4,0xc,0x62,0xa6,0x59,
+0x63,0xa8,0x2e,0x64,0xac,0xe3,0x65,5,0x6d,0xa9,0x6d,0x94,0x6e,0xa2,0x41,0x74,
+0x15,0x68,0x69,0x6f,0x70,0x69,0x63,0x5e,1,0x65,0x40,0x73,0x11,0x75,0x70,0xa2,
+0x86,0x16,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0xa3,0x86,0x11,0x78,0x74,0xa2,0x85,
+2,0x61,0xa3,0xc8,0x62,0xa5,0x37,0x65,0x13,0x6e,0x64,0x65,0x64,0xa2,0x85,1,
+0x61,0xa3,0xc8,0x62,0xa5,0x37,0x16,0x6f,0x74,0x69,0x63,0x6f,0x6e,0x73,0xa3,0xce,
+0x15,0x63,0x6c,0x6f,0x73,0x65,0x64,2,0x61,0x5a,0x63,0x9e,0x69,0x1c,0x64,0x65,
+0x6f,0x67,0x72,0x61,0x70,0x68,0x69,0x63,0x73,0x75,0x70,0xa2,0xc4,0x16,0x70,0x6c,
+0x65,0x6d,0x65,0x6e,0x74,0xa3,0xc4,0x16,0x6c,0x70,0x68,0x61,0x6e,0x75,0x6d,0x86,
+1,0x65,0x2c,0x73,0x11,0x75,0x70,0xa3,0xc3,0x13,0x72,0x69,0x63,0x73,0x86,0x18,
+0x75,0x70,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0xa3,0xc3,0x11,0x6a,0x6b,0xa2,0x44,
+0x1f,0x6c,0x65,0x74,0x74,0x65,0x72,0x73,0x61,0x6e,0x64,0x6d,0x6f,0x6e,0x74,0x68,
+0x73,0xa3,0x44,0x61,0x4a,0x67,0x76,0x6c,1,0x62,0x30,0x79,0x13,0x6d,0x61,0x69,
+0x63,0xa5,0x25,0x13,0x61,0x73,0x61,0x6e,0xa3,0xe2,0x13,0x72,0x6c,0x79,0x64,0x1f,
+0x79,0x6e,0x61,0x73,0x74,0x69,0x63,0x63,0x75,0x6e,0x65,0x69,0x66,0x6f,0x72,0x6d,
+0xa5,1,0x1f,0x79,0x70,0x74,0x69,0x61,0x6e,0x68,0x69,0x65,0x72,0x6f,0x67,0x6c,
+0x79,0x70,0x68,1,0x66,0x26,0x73,0xa3,0xc2,0x1c,0x6f,0x72,0x6d,0x61,0x74,0x63,
+0x6f,0x6e,0x74,0x72,0x6f,0x6c,0x73,0xa5,0x24,7,0x6e,0xc0,0xf2,0x6e,0x3e,0x72,
+0xa2,0x5d,0x73,0xa2,0xe5,0x76,0x14,0x65,0x73,0x74,0x61,0x6e,0xa3,0xbc,1,0x61,
+0x92,0x63,0x13,0x69,0x65,0x6e,0x74,1,0x67,0x34,0x73,0x15,0x79,0x6d,0x62,0x6f,
+0x6c,0x73,0xa3,0xa5,0x13,0x72,0x65,0x65,0x6b,1,0x6d,0x34,0x6e,0x15,0x75,0x6d,
+0x62,0x65,0x72,0x73,0xa3,0x7f,0x13,0x75,0x73,0x69,0x63,0xa2,0x7e,0x19,0x61,0x6c,
+0x6e,0x6f,0x74,0x61,0x74,0x69,0x6f,0x6e,0xa3,0x7e,0x10,0x74,0x1f,0x6f,0x6c,0x69,
+0x61,0x6e,0x68,0x69,0x65,0x72,0x6f,0x67,0x6c,0x79,0x70,0x68,0x73,0xa3,0xfe,2,
+0x61,0x32,0x6d,0xa2,0x7e,0x72,0x12,0x6f,0x77,0x73,0x7d,0x12,0x62,0x69,0x63,0x38,
+3,0x65,0x4a,0x6d,0x80,0x70,0xa2,0x50,0x73,0x11,0x75,0x70,0xa2,0x80,0x16,0x70,
+0x6c,0x65,0x6d,0x65,0x6e,0x74,0xa3,0x80,0x11,0x78,0x74,3,0x61,0xa3,0xd2,0x62,
+0xa5,0x35,0x63,0xa5,0x41,0x65,0x13,0x6e,0x64,0x65,0x64,2,0x61,0xa3,0xd2,0x62,
+0xa5,0x35,0x63,0xa5,0x41,0x12,0x61,0x74,0x68,0xa2,0xd3,0x18,0x65,0x6d,0x61,0x74,
+0x69,0x63,0x61,0x6c,0x61,0x1f,0x6c,0x70,0x68,0x61,0x62,0x65,0x74,0x69,0x63,0x73,
+0x79,0x6d,0x62,0x6f,0x6c,0x73,0xa3,0xd3,1,0x66,0x42,0x72,0x1e,0x65,0x73,0x65,
+0x6e,0x74,0x61,0x74,0x69,0x6f,0x6e,0x66,0x6f,0x72,0x6d,0x73,1,0x61,0xa3,0x51,
+0x62,0xa3,0x55,0x14,0x65,0x6e,0x69,0x61,0x6e,0x35,0x12,0x63,0x69,0x69,0x23,0x64,
+0x9e,0x65,0xa2,0x42,0x68,0xa2,0x4d,0x6c,1,0x63,0x62,0x70,0x17,0x68,0x61,0x62,
+0x65,0x74,0x69,0x63,0x70,1,0x66,0xa3,0x50,0x72,0x1e,0x65,0x73,0x65,0x6e,0x74,
+0x61,0x74,0x69,0x6f,0x6e,0x66,0x6f,0x72,0x6d,0x73,0xa3,0x50,0x16,0x68,0x65,0x6d,
+0x69,0x63,0x61,0x6c,0xa2,0xd0,0x16,0x73,0x79,0x6d,0x62,0x6f,0x6c,0x73,0xa3,0xd0,
+0x12,0x6c,0x61,0x6d,0xa5,7,0x1a,0x67,0x65,0x61,0x6e,0x6e,0x75,0x6d,0x62,0x65,
+0x72,0x73,0xa3,0x77,0x11,0x6f,0x6d,0xa3,0xfd,7,0x6f,0x71,0x6f,0x64,0x72,0xa2,
+0x41,0x75,0xa2,0x58,0x79,0x1b,0x7a,0x61,0x6e,0x74,0x69,0x6e,0x65,0x6d,0x75,0x73,
+0x69,0x63,0xa2,0x5b,0x18,0x61,0x6c,0x73,0x79,0x6d,0x62,0x6f,0x6c,0x73,0xa3,0x5b,
+1,0x70,0x34,0x78,0x16,0x64,0x72,0x61,0x77,0x69,0x6e,0x67,0x89,0x14,0x6f,0x6d,
+0x6f,0x66,0x6f,0xa0,0x12,0x65,0x78,0x74,0xa2,0x43,0x14,0x65,0x6e,0x64,0x65,0x64,
+0xa3,0x43,0x10,0x61,1,0x68,0x40,0x69,0x12,0x6c,0x6c,0x65,0x92,0x17,0x70,0x61,
+0x74,0x74,0x65,0x72,0x6e,0x73,0x93,0x11,0x6d,0x69,0xa3,0xc9,1,0x67,0x2c,0x68,
+0x11,0x69,0x64,0xa3,0x64,0x14,0x69,0x6e,0x65,0x73,0x65,0xa3,0x81,0x61,0x48,0x65,
+0xa2,0x4e,0x68,0xa2,0x52,0x6c,0x1a,0x6f,0x63,0x6b,0x65,0x6c,0x65,0x6d,0x65,0x6e,
+0x74,0x73,0x8b,3,0x6c,0x34,0x6d,0x40,0x73,0x66,0x74,0x11,0x61,0x6b,0xa3,0xc7,
+0x14,0x69,0x6e,0x65,0x73,0x65,0xa3,0x93,0x11,0x75,0x6d,0xa2,0xb1,0x12,0x73,0x75,
+0x70,0xa2,0xca,0x16,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0xa3,0xca,1,0x69,0x30,
+0x73,0x13,0x61,0x76,0x61,0x68,0xa3,0xdd,0x15,0x63,0x6c,0x61,0x74,0x69,0x6e,0x23,
+0x14,0x6e,0x67,0x61,0x6c,0x69,0x41,0x16,0x61,0x69,0x6b,0x73,0x75,0x6b,0x69,0xa5,
+8,5,0x6f,0xc1,0x60,0x6f,0xa2,0x69,0x75,0xa4,0x24,0x79,1,0x70,0xa2,0x44,
+0x72,0x14,0x69,0x6c,0x6c,0x69,0x63,0x32,1,0x65,0x4c,0x73,0x11,0x75,0x70,0xa2,
+0x61,0x16,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0xa2,0x61,0x12,0x61,0x72,0x79,0xa3,
+0x61,0x11,0x78,0x74,4,0x61,0xa3,0x9e,0x62,0xa3,0xa0,0x63,0xa5,9,0x64,0xa5,
+0x43,0x65,0x13,0x6e,0x64,0x65,0x64,3,0x61,0xa3,0x9e,0x62,0xa3,0xa0,0x63,0xa5,
+9,0x64,0xa5,0x43,0x10,0x72,1,0x69,0x34,0x6f,0x15,0x6d,0x69,0x6e,0x6f,0x61,
+0x6e,0xa5,0x36,0x1a,0x6f,0x74,0x73,0x79,0x6c,0x6c,0x61,0x62,0x61,0x72,0x79,0xa3,
+0x7b,3,0x6d,0x5a,0x6e,0xa2,0x95,0x70,0xa2,0xa0,0x75,0x17,0x6e,0x74,0x69,0x6e,
+0x67,0x72,0x6f,0x64,0xa2,0x9a,0x17,0x6e,0x75,0x6d,0x65,0x72,0x61,0x6c,0x73,0xa3,
+0x9a,2,0x62,0x3a,0x6d,0xa2,0x5f,0x70,0x15,0x61,0x74,0x6a,0x61,0x6d,0x6f,0xa3,
+0x41,0x14,0x69,0x6e,0x69,0x6e,0x67,2,0x64,0x46,0x68,0x9e,0x6d,0x1d,0x61,0x72,
+0x6b,0x73,0x66,0x6f,0x72,0x73,0x79,0x6d,0x62,0x6f,0x6c,0x73,0x77,0x1e,0x69,0x61,
+0x63,0x72,0x69,0x74,0x69,0x63,0x61,0x6c,0x6d,0x61,0x72,0x6b,0x73,0x2e,2,0x65,
+0x40,0x66,0xa6,0x4c,0x73,0x18,0x75,0x70,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0xa3,
+0x83,0x16,0x78,0x74,0x65,0x6e,0x64,0x65,0x64,0xa3,0xe0,0x17,0x61,0x6c,0x66,0x6d,
+0x61,0x72,0x6b,0x73,0xa3,0x52,0x11,0x6f,0x6e,0x1f,0x69,0x6e,0x64,0x69,0x63,0x6e,
+0x75,0x6d,0x62,0x65,0x72,0x66,0x6f,0x72,0x6d,0x73,0xa3,0xb2,0x1b,0x74,0x72,0x6f,
+0x6c,0x70,0x69,0x63,0x74,0x75,0x72,0x65,0x73,0x83,0x12,0x74,0x69,0x63,0xa2,0x84,
+0x1b,0x65,0x70,0x61,0x63,0x74,0x6e,0x75,0x6d,0x62,0x65,0x72,0x73,0xa3,0xdf,1,
+0x6e,0x3e,0x72,0x1b,0x72,0x65,0x6e,0x63,0x79,0x73,0x79,0x6d,0x62,0x6f,0x6c,0x73,
+0x75,0x15,0x65,0x69,0x66,0x6f,0x72,0x6d,0xa2,0x98,0x16,0x6e,0x75,0x6d,0x62,0x65,
+0x72,0x73,0xa2,0x99,0x1d,0x61,0x6e,0x64,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,
+0x69,0x6f,0x6e,0xa3,0x99,0x61,0xa2,0xe4,0x68,0xa4,0xe,0x6a,0x10,0x6b,0xa2,0x47,
+4,0x63,0x8c,0x65,0xa2,0x80,0x72,0xa2,0x9b,0x73,0xa2,0xad,0x75,0x1f,0x6e,0x69,
+0x66,0x69,0x65,0x64,0x69,0x64,0x65,0x6f,0x67,0x72,0x61,0x70,0x68,0x73,0xa2,0x47,
+0x18,0x65,0x78,0x74,0x65,0x6e,0x73,0x69,0x6f,0x6e,7,0x65,0x6b,0x65,0xa5,0,
+0x66,0xa5,0x12,0x67,0xa5,0x2e,0x68,0xa5,0x42,0x14,0x6f,0x6d,0x70,0x61,0x74,0xa2,
+0x45,1,0x66,0x96,0x69,1,0x62,0x44,0x64,0x17,0x65,0x6f,0x67,0x72,0x61,0x70,
+0x68,0x73,0xa2,0x4f,0x12,0x73,0x75,0x70,0xa3,0x5f,0x14,0x69,0x6c,0x69,0x74,0x79,
+0xa2,0x45,1,0x66,0x54,0x69,0x18,0x64,0x65,0x6f,0x67,0x72,0x61,0x70,0x68,0x73,
+0xa2,0x4f,0x19,0x73,0x75,0x70,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0xa3,0x5f,0x13,
+0x6f,0x72,0x6d,0x73,0xa3,0x53,0x11,0x78,0x74,7,0x65,0xc,0x65,0xa5,0,0x66,
+0xa5,0x12,0x67,0xa5,0x2e,0x68,0xa5,0x42,0x61,0xa3,0x46,0x62,0xa3,0x5e,0x63,0xa3,
+0xc5,0x64,0xa3,0xd1,0x19,0x61,0x64,0x69,0x63,0x61,0x6c,0x73,0x73,0x75,0x70,0x94,
+0x16,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x95,1,0x74,0x50,0x79,0x14,0x6d,0x62,
+0x6f,0x6c,0x73,0x9a,0x1d,0x61,0x6e,0x64,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,
+0x69,0x6f,0x6e,0x9b,0x14,0x72,0x6f,0x6b,0x65,0x73,0xa3,0x82,2,0x6e,0x48,0x72,
+0x64,0x75,0x1d,0x63,0x61,0x73,0x69,0x61,0x6e,0x61,0x6c,0x62,0x61,0x6e,0x69,0x61,
+0x6e,0xa3,0xde,0x1d,0x61,0x64,0x69,0x61,0x6e,0x73,0x79,0x6c,0x6c,0x61,0x62,0x69,
+0x63,0x73,0x63,0x12,0x69,0x61,0x6e,0xa3,0xa8,2,0x61,0x3a,0x65,0x4c,0x6f,0x16,
+0x72,0x61,0x73,0x6d,0x69,0x61,0x6e,0xa5,0x2d,1,0x6b,0x26,0x6d,0xa3,0xa4,0x11,
+0x6d,0x61,0xa3,0xd4,1,0x72,0x38,0x73,0x17,0x73,0x73,0x79,0x6d,0x62,0x6f,0x6c,
+0x73,0xa5,0x19,0x13,0x6f,0x6b,0x65,0x65,0x60,0x12,0x73,0x75,0x70,0xa2,0xff,0x16,
+0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0xa3,0xff,3,0x65,0x3e,0x69,0x8e,0x6f,0xa2,
+0x71,0x75,0x15,0x70,0x6c,0x6f,0x79,0x61,0x6e,0xa3,0xe1,1,0x73,0x60,0x76,0x16,
+0x61,0x6e,0x61,0x67,0x61,0x72,0x69,0x3e,0x12,0x65,0x78,0x74,0xa2,0xb3,1,0x61,
+0xa5,0x44,0x65,0x13,0x6e,0x64,0x65,0x64,0xa2,0xb3,0x10,0x61,0xa5,0x44,0x13,0x65,
+0x72,0x65,0x74,0xa3,0x5a,2,0x61,0x3a,0x6e,0x82,0x76,0x16,0x65,0x73,0x61,0x6b,
+0x75,0x72,0x75,0xa5,0x2f,0x18,0x63,0x72,0x69,0x74,0x69,0x63,0x61,0x6c,0x73,0x2e,
+2,0x65,0x30,0x66,0x36,0x73,0x11,0x75,0x70,0xa3,0x83,0x11,0x78,0x74,0xa3,0xe0,
+0x18,0x6f,0x72,0x73,0x79,0x6d,0x62,0x6f,0x6c,0x73,0x77,0x14,0x67,0x62,0x61,0x74,
+0x73,0x91,1,0x67,0x3e,0x6d,0x12,0x69,0x6e,0x6f,0xa2,0xab,0x14,0x74,0x69,0x6c,
+0x65,0x73,0xa3,0xab,0x11,0x72,0x61,0xa5,0x1a,8,0x6d,0x5f,0x6d,0x3a,0x6e,0x48,
+0x73,0x7a,0x76,0xa2,0x4b,0x77,0x12,0x69,0x64,0x65,0x43,0x11,0x65,0x64,0x32,0x12,
+0x69,0x61,0x6c,0x33,2,0x61,0x40,0x62,0x37,0x6f,1,0x62,0x28,0x6e,0x10,0x65,
+0x21,0x13,0x72,0x65,0x61,0x6b,0x37,0x10,0x72,0x34,0x12,0x72,0x6f,0x77,0x35,2,
+0x6d,0x38,0x71,0x46,0x75,1,0x62,0x3d,0x70,0x3e,0x11,0x65,0x72,0x3f,1,0x61,
+0x24,0x6c,0x39,0x11,0x6c,0x6c,0x39,1,0x72,0x3b,0x75,0x12,0x61,0x72,0x65,0x3b,
+0x12,0x65,0x72,0x74,0x40,0x13,0x69,0x63,0x61,0x6c,0x41,0x63,0x58,0x65,0x92,0x66,
+0x96,0x69,1,0x6e,0x36,0x73,0x10,0x6f,0x30,0x14,0x6c,0x61,0x74,0x65,0x64,0x31,
+0x11,0x69,0x74,0x2e,0x12,0x69,0x61,0x6c,0x2f,2,0x61,0x36,0x69,0x48,0x6f,0x10,
+0x6d,0x24,0x12,0x70,0x61,0x74,0x25,0x10,0x6e,0x22,0x15,0x6f,0x6e,0x69,0x63,0x61,
+0x6c,0x23,0x13,0x72,0x63,0x6c,0x65,0x27,0x11,0x6e,0x63,0x27,2,0x69,0x3a,0x6f,
+0x44,0x72,0x10,0x61,0x2c,0x14,0x63,0x74,0x69,0x6f,0x6e,0x2d,0x10,0x6e,0x28,0x11,
+0x61,0x6c,0x29,0x11,0x6e,0x74,0x2b,4,0x61,0x3a,0x66,0x4c,0x68,0x5e,0x6e,0x70,
+0x77,0x2a,0x12,0x69,0x64,0x65,0x2b,0x22,0x17,0x6d,0x62,0x69,0x67,0x75,0x6f,0x75,
+0x73,0x23,0x26,0x17,0x75,0x6c,0x6c,0x77,0x69,0x64,0x74,0x68,0x27,0x24,0x17,0x61,
+0x6c,0x66,0x77,0x69,0x64,0x74,0x68,0x25,0x20,1,0x61,0x30,0x65,0x14,0x75,0x74,
+0x72,0x61,0x6c,0x21,0x28,0x13,0x72,0x72,0x6f,0x77,0x29,0xd,0x6e,0xc0,0xfb,0x73,
+0x6d,0x73,0x3a,0x74,0x98,0x75,0xa2,0x49,0x7a,2,0x6c,0x3b,0x70,0x3d,0x73,0x39,
+5,0x6f,0x28,0x6f,0x57,0x70,0x34,0x75,0x16,0x72,0x72,0x6f,0x67,0x61,0x74,0x65,
+0x45,0x11,0x61,0x63,1,0x65,0x32,0x69,0x15,0x6e,0x67,0x6d,0x61,0x72,0x6b,0x31,
+0x18,0x73,0x65,0x70,0x61,0x72,0x61,0x74,0x6f,0x72,0x39,0x63,0x53,0x6b,0x55,0x6d,
+0x51,0x1d,0x69,0x74,0x6c,0x65,0x63,0x61,0x73,0x65,0x6c,0x65,0x74,0x74,0x65,0x72,
+0x27,1,0x6e,0x40,0x70,0x1c,0x70,0x65,0x72,0x63,0x61,0x73,0x65,0x6c,0x65,0x74,
+0x74,0x65,0x72,0x23,0x17,0x61,0x73,0x73,0x69,0x67,0x6e,0x65,0x64,0x21,0x6e,0x8a,
+0x6f,0xa2,0x47,0x70,8,0x66,0x14,0x66,0x5b,0x69,0x59,0x6f,0x4f,0x72,0x24,0x73,
+0x49,0x17,0x69,0x76,0x61,0x74,0x65,0x75,0x73,0x65,0x43,0x61,0x2c,0x63,0x4d,0x64,
+0x47,0x65,0x4b,0x1f,0x72,0x61,0x67,0x72,0x61,0x70,0x68,0x73,0x65,0x70,0x61,0x72,
+0x61,0x74,0x6f,0x72,0x3d,2,0x64,0x33,0x6c,0x35,0x6f,0x36,0x1b,0x6e,0x73,0x70,
+0x61,0x63,0x69,0x6e,0x67,0x6d,0x61,0x72,0x6b,0x2d,1,0x70,0x7c,0x74,0x12,0x68,
+0x65,0x72,3,0x6c,0x38,0x6e,0x42,0x70,0x4c,0x73,0x14,0x79,0x6d,0x62,0x6f,0x6c,
+0x57,0x14,0x65,0x74,0x74,0x65,0x72,0x2b,0x14,0x75,0x6d,0x62,0x65,0x72,0x37,0x19,
+0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0x4f,0x1c,0x65,0x6e,0x70,0x75,
+0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0x49,0x66,0x9e,0x66,0x88,0x69,0xa2,
+0x4b,0x6c,0xa2,0x5c,0x6d,4,0x61,0x60,0x63,0x31,0x65,0x2f,0x6e,0x2d,0x6f,0x15,
+0x64,0x69,0x66,0x69,0x65,0x72,1,0x6c,0x30,0x73,0x14,0x79,0x6d,0x62,0x6f,0x6c,
+0x55,0x14,0x65,0x74,0x74,0x65,0x72,0x29,0x17,0x74,0x68,0x73,0x79,0x6d,0x62,0x6f,
+0x6c,0x51,1,0x69,0x2e,0x6f,0x13,0x72,0x6d,0x61,0x74,0x41,0x1d,0x6e,0x61,0x6c,
+0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0x5b,0x10,0x6e,0x1f,0x69,
+0x74,0x69,0x61,0x6c,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0x59,
+6,0x6d,0x18,0x6d,0x29,0x6f,0x28,0x74,0x27,0x75,0x23,0x2a,0x1c,0x77,0x65,0x72,
+0x63,0x61,0x73,0x65,0x6c,0x65,0x74,0x74,0x65,0x72,0x25,0x65,0x28,0x69,0x3c,0x6c,
+0x25,0x19,0x74,0x74,0x65,0x72,0x6e,0x75,0x6d,0x62,0x65,0x72,0x35,0x1a,0x6e,0x65,
+0x73,0x65,0x70,0x61,0x72,0x61,0x74,0x6f,0x72,0x3b,0x63,0x44,0x64,0xa2,0x60,0x65,
+0x1b,0x6e,0x63,0x6c,0x6f,0x73,0x69,0x6e,0x67,0x6d,0x61,0x72,0x6b,0x2f,6,0x6e,
+0x39,0x6e,0x46,0x6f,0x4e,0x73,0x45,0x75,0x1b,0x72,0x72,0x65,0x6e,0x63,0x79,0x73,
+0x79,0x6d,0x62,0x6f,0x6c,0x53,0x20,0x12,0x74,0x72,0x6c,0x3f,0x42,0x10,0x6e,1,
+0x6e,0x2c,0x74,0x12,0x72,0x6f,0x6c,0x3f,0x1f,0x65,0x63,0x74,0x6f,0x72,0x70,0x75,
+0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0x4d,0x63,0x3f,0x66,0x41,0x6c,0x1d,
+0x6f,0x73,0x65,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0x4b,2,
+0x61,0x30,0x65,0x4a,0x69,0x12,0x67,0x69,0x74,0x33,0x1c,0x73,0x68,0x70,0x75,0x6e,
+0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0x47,0x1a,0x63,0x69,0x6d,0x61,0x6c,0x6e,
+0x75,0x6d,0x62,0x65,0x72,0x33,0,0x13,0x6e,0xc1,0xf,0x74,0x76,0x74,0x4c,0x76,
+0x9a,0x77,0xa2,0x48,0x79,0xa2,0x49,0x7a,1,0x61,0x2c,0x68,0x12,0x61,0x69,0x6e,
+0x8b,0x11,0x69,0x6e,0x85,2,0x61,0x36,0x65,0x3c,0x68,0x14,0x69,0x6e,0x79,0x65,
+0x68,0xa3,0x66,1,0x68,0x71,0x77,0x73,1,0x68,0x28,0x74,0x10,0x68,0x77,0x16,
+0x6d,0x61,0x72,0x62,0x75,0x74,0x61,0x74,0x13,0x67,0x6f,0x61,0x6c,0x3d,0x1a,0x65,
+0x72,0x74,0x69,0x63,0x61,0x6c,0x74,0x61,0x69,0x6c,0xa3,0x67,0x11,0x61,0x77,0x79,
+1,0x65,0x32,0x75,0x11,0x64,0x68,0x80,0x11,0x68,0x65,0x83,0x10,0x68,0x7a,1,
+0x62,0x34,0x77,0x16,0x69,0x74,0x68,0x74,0x61,0x69,0x6c,0x7f,0x14,0x61,0x72,0x72,
+0x65,0x65,0x7d,0x6e,0xa2,0x4c,0x70,0xa2,0x69,0x71,0xa2,0x69,0x72,0xa2,0x6f,0x73,
+5,0x74,0x22,0x74,0x38,0x77,0x4c,0x79,0x16,0x72,0x69,0x61,0x63,0x77,0x61,0x77,
+0x6f,0x18,0x72,0x61,0x69,0x67,0x68,0x74,0x77,0x61,0x77,0xa3,0x55,0x15,0x61,0x73,
+0x68,0x6b,0x61,0x66,0x6d,0x61,0x2e,0x65,0x38,0x68,0x11,0x69,0x6e,0x6b,0x10,0x64,
+0x62,0x11,0x68,0x65,0x65,1,0x65,0x2e,0x6d,0x13,0x6b,0x61,0x74,0x68,0x69,0x10,
+0x6e,0x67,2,0x6f,0x2c,0x75,0x50,0x79,0x10,0x61,0x91,1,0x6a,0x28,0x6f,0x10,
+0x6e,0x55,0x1a,0x6f,0x69,0x6e,0x69,0x6e,0x67,0x67,0x72,0x6f,0x75,0x70,0x21,0x10,
+0x6e,0x57,0x10,0x65,0x59,0x10,0x61,1,0x66,0x5b,0x70,0x10,0x68,0x5d,1,0x65,
+0x38,0x6f,0x18,0x68,0x69,0x6e,0x67,0x79,0x61,0x79,0x65,0x68,0x93,1,0x68,0x5f,
+0x76,0x16,0x65,0x72,0x73,0x65,0x64,0x70,0x65,0x61,0x67,0xc1,0xc7,0x67,0xa4,0x52,
+0x68,0xa4,0x59,0x6b,0xa4,0x99,0x6c,0xa4,0xb2,0x6d,2,0x61,0x2e,0x65,0xa4,0x3e,
+0x69,0x10,0x6d,0x53,1,0x6c,0xa2,0xe7,0x6e,0x16,0x69,0x63,0x68,0x61,0x65,0x61,
+0x6e,0,0x12,0x6e,0x76,0x73,0x51,0x73,0x3e,0x74,0x5c,0x77,0xa0,0x79,0xa2,0x42,
+0x7a,0x13,0x61,0x79,0x69,0x6e,0xa3,0x54,0x10,0x61,1,0x64,0x2e,0x6d,0x12,0x65,
+0x6b,0x68,0xa3,0x4c,0x11,0x68,0x65,0xa3,0x4b,3,0x61,0x38,0x65,0x3c,0x68,0x4a,
+0x77,0x13,0x65,0x6e,0x74,0x79,0xa3,0x51,0x10,0x77,0xa3,0x4d,1,0x6e,0xa3,0x4e,
+0x74,0x10,0x68,0xa3,0x4f,0x14,0x61,0x6d,0x65,0x64,0x68,0xa3,0x50,0x11,0x61,0x77,
+0xa3,0x52,0x12,0x6f,0x64,0x68,0xa3,0x53,0x6e,0x3a,0x6f,0x40,0x70,0x46,0x71,0x4a,
+0x72,0x12,0x65,0x73,0x68,0xa3,0x4a,0x11,0x75,0x6e,0xa3,0x46,0x11,0x6e,0x65,0xa3,
+0x47,0x10,0x65,0xa3,0x48,0x12,0x6f,0x70,0x68,0xa3,0x49,0x67,0x33,0x67,0x38,0x68,
+0x40,0x6b,0x5e,0x6c,0x66,0x6d,0x11,0x65,0x6d,0xa3,0x45,0x13,0x69,0x6d,0x65,0x6c,
+0xa1,1,0x65,0x32,0x75,0x14,0x6e,0x64,0x72,0x65,0x64,0xa3,0x42,0x11,0x74,0x68,
+0xa3,0x41,0x12,0x61,0x70,0x68,0xa3,0x43,0x14,0x61,0x6d,0x65,0x64,0x68,0xa3,0x44,
+0x61,0x34,0x62,0x4a,0x64,0x50,0x66,0x12,0x69,0x76,0x65,0x9f,1,0x6c,0x2a,0x79,
+0x11,0x69,0x6e,0x97,0x12,0x65,0x70,0x68,0x95,0x12,0x65,0x74,0x68,0x99,1,0x61,
+0x30,0x68,0x14,0x61,0x6d,0x65,0x64,0x68,0x9d,0x13,0x6c,0x65,0x74,0x68,0x9b,0x15,
+0x61,0x79,0x61,0x6c,0x61,0x6d,6,0x6e,0x2c,0x6e,0x34,0x72,0x5e,0x73,0x62,0x74,
+0x11,0x74,0x61,0xa3,0x63,2,0x67,0x2e,0x6e,0x32,0x79,0x10,0x61,0xa3,0x60,0x10,
+0x61,0xa3,0x5d,1,0x61,0xa3,0x5e,0x6e,0x10,0x61,0xa3,0x5f,0x10,0x61,0xa3,0x61,
+0x11,0x73,0x61,0xa3,0x62,0x62,0x3c,0x6a,0x42,0x6c,0x10,0x6c,1,0x61,0xa3,0x5b,
+0x6c,0x10,0x61,0xa3,0x5c,0x11,0x68,0x61,0xa3,0x59,0x10,0x61,0xa3,0x5a,0x11,0x65,
+0x6d,0x51,0x10,0x61,1,0x66,0x37,0x6d,0x11,0x61,0x6c,0x39,1,0x61,0x40,0x65,
+0x3e,1,0x68,0x28,0x74,0x10,0x68,0x45,0x40,0x13,0x67,0x6f,0x61,0x6c,0x43,2,
+0x68,0x3b,0x6d,0x5c,0x6e,0x1a,0x69,0x66,0x69,0x72,0x6f,0x68,0x69,0x6e,0x67,0x79,
+0x61,1,0x6b,0x2a,0x70,0x10,0x61,0xa3,0x65,0x15,0x69,0x6e,0x6e,0x61,0x79,0x61,
+0xa3,0x64,0x1a,0x7a,0x61,0x6f,0x6e,0x68,0x65,0x68,0x67,0x6f,0x61,0x6c,0x3d,2,
+0x61,0x3a,0x68,0x44,0x6e,0x17,0x6f,0x74,0x74,0x65,0x64,0x68,0x65,0x68,0x4b,1,
+0x66,0x47,0x70,0x10,0x68,0x49,0x12,0x61,0x70,0x68,0x89,0x11,0x61,0x6d,0x4c,0x12,
+0x61,0x64,0x68,0x4f,0x61,0x6e,0x62,0xa2,0x54,0x64,0xa2,0x70,0x65,0x31,0x66,2,
+0x61,0x3e,0x65,0x4a,0x69,0x19,0x6e,0x61,0x6c,0x73,0x65,0x6d,0x6b,0x61,0x74,0x68,
+0x35,0x15,0x72,0x73,0x69,0x79,0x65,0x68,0x8f,0x86,0x10,0x68,0x33,2,0x66,0x3c,
+0x69,0x70,0x6c,1,0x61,0x28,0x65,0x10,0x66,0x27,0x11,0x70,0x68,0x25,0x14,0x72,
+0x69,0x63,0x61,0x6e,2,0x66,0x30,0x6e,0x36,0x71,0x11,0x61,0x66,0xa3,0x58,0x11,
+0x65,0x68,0xa3,0x56,0x12,0x6f,0x6f,0x6e,0xa3,0x57,0x10,0x6e,0x23,1,0x65,0x4a,
+0x75,0x10,0x72,0x1f,0x75,0x73,0x68,0x61,0x73,0x6b,0x69,0x79,0x65,0x68,0x62,0x61,
+0x72,0x72,0x65,0x65,0x8d,1,0x68,0x29,0x74,0x10,0x68,0x2b,0x11,0x61,0x6c,0x2c,
+0x16,0x61,0x74,0x68,0x72,0x69,0x73,0x68,0x2f,7,0x6e,0x2e,0x6e,0x2c,0x72,0x3e,
+0x74,0x56,0x75,0x21,0x18,0x6f,0x6e,0x6a,0x6f,0x69,0x6e,0x69,0x6e,0x67,0x21,0x28,
+0x1a,0x69,0x67,0x68,0x74,0x6a,0x6f,0x69,0x6e,0x69,0x6e,0x67,0x29,0x2a,0x19,0x72,
+0x61,0x6e,0x73,0x70,0x61,0x72,0x65,0x6e,0x74,0x2b,0x63,0x23,0x64,0x40,0x6a,0x56,
+0x6c,0x26,0x19,0x65,0x66,0x74,0x6a,0x6f,0x69,0x6e,0x69,0x6e,0x67,0x27,0x24,0x19,
+0x75,0x61,0x6c,0x6a,0x6f,0x69,0x6e,0x69,0x6e,0x67,0x25,0x19,0x6f,0x69,0x6e,0x63,
+0x61,0x75,0x73,0x69,0x6e,0x67,0x23,0,0x13,0x6e,0xc0,0xd0,0x73,0x49,0x73,0x48,
+0x75,0x78,0x77,0x84,0x78,0x9c,0x7a,0x10,0x77,0x58,1,0x6a,0x75,0x73,0x13,0x70,
+0x61,0x63,0x65,0x59,4,0x61,0x51,0x67,0x53,0x70,0x28,0x75,0x30,0x79,0x57,0x54,
+0x12,0x61,0x63,0x65,0x55,0x16,0x72,0x72,0x6f,0x67,0x61,0x74,0x65,0x53,0x15,0x6e,
+0x6b,0x6e,0x6f,0x77,0x6e,0x21,1,0x6a,0x5d,0x6f,0x17,0x72,0x64,0x6a,0x6f,0x69,
+0x6e,0x65,0x72,0x5d,0x10,0x78,0x21,0x6e,0x60,0x6f,0xa2,0x41,0x70,0xa2,0x50,0x71,
+0xa2,0x6e,0x72,1,0x65,0x24,0x69,0x6f,0x1e,0x67,0x69,0x6f,0x6e,0x61,0x6c,0x69,
+0x6e,0x64,0x69,0x63,0x61,0x74,0x6f,0x72,0x6f,4,0x65,0x3e,0x6c,0x5b,0x6f,0x46,
+0x73,0x45,0x75,0x46,0x14,0x6d,0x65,0x72,0x69,0x63,0x47,0x15,0x78,0x74,0x6c,0x69,
+0x6e,0x65,0x5b,0x17,0x6e,0x73,0x74,0x61,0x72,0x74,0x65,0x72,0x45,0x10,0x70,0x48,
+0x1c,0x65,0x6e,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0x49,1,
+0x6f,0x3e,0x72,0x4c,0x1a,0x65,0x66,0x69,0x78,0x6e,0x75,0x6d,0x65,0x72,0x69,0x63,
+0x4d,0x4a,0x1b,0x73,0x74,0x66,0x69,0x78,0x6e,0x75,0x6d,0x65,0x72,0x69,0x63,0x4b,
+0x10,0x75,0x4e,0x16,0x6f,0x74,0x61,0x74,0x69,0x6f,0x6e,0x4f,0x68,0x7b,0x68,0x50,
+0x69,0x86,0x6a,0xa2,0x61,0x6c,0xa2,0x65,0x6d,0x1c,0x61,0x6e,0x64,0x61,0x74,0x6f,
+0x72,0x79,0x62,0x72,0x65,0x61,0x6b,0x2d,4,0x32,0x5f,0x33,0x61,0x65,0x34,0x6c,
+0x6d,0x79,0x3a,0x13,0x70,0x68,0x65,0x6e,0x3b,0x19,0x62,0x72,0x65,0x77,0x6c,0x65,
+0x74,0x74,0x65,0x72,0x6d,2,0x64,0x28,0x6e,0x3c,0x73,0x41,0x3c,0x18,0x65,0x6f,
+0x67,0x72,0x61,0x70,0x68,0x69,0x63,0x3d,0x3e,1,0x66,0x3e,0x73,0x11,0x65,0x70,
+1,0x61,0x22,0x65,0x14,0x72,0x61,0x62,0x6c,0x65,0x3f,0x18,0x69,0x78,0x6e,0x75,
+0x6d,0x65,0x72,0x69,0x63,0x41,2,0x6c,0x63,0x74,0x65,0x76,0x67,1,0x66,0x43,
+0x69,0x15,0x6e,0x65,0x66,0x65,0x65,0x64,0x43,0x61,0x40,0x62,0x70,0x63,0xa2,0x55,
+0x65,0xa2,0xdb,0x67,0x10,0x6c,0x38,0x11,0x75,0x65,0x39,2,0x69,0x23,0x6c,0x34,
+0x6d,0x16,0x62,0x69,0x67,0x75,0x6f,0x75,0x73,0x23,0x24,0x17,0x70,0x68,0x61,0x62,
+0x65,0x74,0x69,0x63,0x25,4,0x32,0x27,0x61,0x29,0x62,0x2b,0x6b,0x2d,0x72,0x12,
+0x65,0x61,0x6b,2,0x61,0x36,0x62,0x3e,0x73,0x15,0x79,0x6d,0x62,0x6f,0x6c,0x73,
+0x57,0x13,0x66,0x74,0x65,0x72,0x29,1,0x65,0x2a,0x6f,0x11,0x74,0x68,0x27,0x13,
+0x66,0x6f,0x72,0x65,0x2b,7,0x6d,0x51,0x6d,0x33,0x6f,0x28,0x70,0x69,0x72,0x35,
+1,0x6d,0x76,0x6e,1,0x64,0x3c,0x74,0x1a,0x69,0x6e,0x67,0x65,0x6e,0x74,0x62,
+0x72,0x65,0x61,0x6b,0x2f,0x15,0x69,0x74,0x69,0x6f,0x6e,0x61,0x1f,0x6c,0x6a,0x61,
+0x70,0x61,0x6e,0x65,0x73,0x65,0x73,0x74,0x61,0x72,0x74,0x65,0x72,0x6b,1,0x62,
+0x3a,0x70,0x19,0x6c,0x65,0x78,0x63,0x6f,0x6e,0x74,0x65,0x78,0x74,0x51,0x18,0x69,
+0x6e,0x69,0x6e,0x67,0x6d,0x61,0x72,0x6b,0x33,0x61,0x6a,0x62,0x2f,0x6a,0x6b,0x6c,
+0x30,0x13,0x6f,0x73,0x65,0x70,1,0x61,0x38,0x75,0x18,0x6e,0x63,0x74,0x75,0x61,
+0x74,0x69,0x6f,0x6e,0x31,0x18,0x72,0x65,0x6e,0x74,0x68,0x65,0x73,0x69,0x73,0x69,
+0x1b,0x72,0x72,0x69,0x61,0x67,0x65,0x72,0x65,0x74,0x75,0x72,0x6e,0x35,2,0x62,
+0x3e,0x6d,0x46,0x78,0x36,0x18,0x63,0x6c,0x61,0x6d,0x61,0x74,0x69,0x6f,0x6e,0x37,
+0x70,0x12,0x61,0x73,0x65,0x71,0x72,0x16,0x6f,0x64,0x69,0x66,0x69,0x65,0x72,0x73,
+1,0x64,0x42,0x6e,1,0x6f,0x32,0x75,0x26,0x14,0x6d,0x65,0x72,0x69,0x63,0x27,
+0x11,0x6e,0x65,0x21,1,0x65,0x2e,0x69,0x24,0x12,0x67,0x69,0x74,0x25,0x22,0x14,
+0x63,0x69,0x6d,0x61,0x6c,0x23,0,0x18,0x6e,0xc4,0x6f,0x74,0xc1,0x91,0x77,0x96,
+0x77,0xa2,0x4c,0x78,0xa2,0x70,0x79,0xa2,0x7a,0x7a,6,0x73,0x1e,0x73,0x34,0x78,
+0x42,0x79,0x48,0x7a,0x11,0x7a,0x7a,0xa3,0x67,0x10,0x79,1,0x65,0xa3,0xae,0x6d,
+0xa3,0x81,0x11,0x78,0x78,0xa3,0x66,0x11,0x79,0x79,0x21,0x61,0x30,0x69,0x58,0x6d,
+0x11,0x74,0x68,0xa3,0x80,0x10,0x6e,1,0x61,0x26,0x62,0xa3,0xb1,0x1a,0x62,0x61,
+0x7a,0x61,0x72,0x73,0x71,0x75,0x61,0x72,0x65,0xa3,0xb1,0x11,0x6e,0x68,0x23,2,
+0x61,0x30,0x63,0x5a,0x6f,0x11,0x6c,0x65,0xa3,0x9b,1,0x6e,0x3c,0x72,0x10,0x61,
+0xa2,0x92,0x15,0x6e,0x67,0x63,0x69,0x74,0x69,0xa3,0x92,0x12,0x63,0x68,0x6f,0xa3,
+0xbc,0x11,0x68,0x6f,0xa3,0xbc,1,0x70,0x2c,0x73,0x11,0x75,0x78,0xa3,0x65,0x11,
+0x65,0x6f,0x9b,1,0x65,0x2c,0x69,0x72,0x11,0x69,0x69,0x73,0x11,0x7a,0x69,0xa2,
+0xc0,0x11,0x64,0x69,0xa3,0xc0,0x74,0x66,0x75,0xa2,0xde,0x76,1,0x61,0x48,0x69,
+1,0x73,0x38,0x74,0x10,0x68,0xa2,0xc5,0x13,0x6b,0x75,0x71,0x69,0xa3,0xc5,0x10,
+0x70,0xa3,0x64,0x10,0x69,0xa2,0x63,0x10,0x69,0xa3,0x63,7,0x68,0x3e,0x68,0x34,
+0x69,0x48,0x6e,0x86,0x6f,0x11,0x74,0x6f,0xa3,0xc4,0x10,0x61,1,0x61,0x24,0x69,
+0x6d,0x6a,0x11,0x6e,0x61,0x6b,2,0x62,0x3a,0x66,0x4a,0x72,0x10,0x68,0xa2,0x9e,
+0x12,0x75,0x74,0x61,0xa3,0x9e,1,0x65,0x24,0x74,0x6f,0x12,0x74,0x61,0x6e,0x6f,
+0x14,0x69,0x6e,0x61,0x67,0x68,0x99,0x11,0x73,0x61,0xa3,0xc3,0x61,0x36,0x65,0xa2,
+0x65,0x66,0xa2,0x71,0x67,0x11,0x6c,0x67,0x75,6,0x6c,0x28,0x6c,0x32,0x6d,0x38,
+0x6e,0x44,0x76,0x10,0x74,0xa3,0x7f,1,0x65,0x89,0x75,0x97,1,0x69,0x24,0x6c,
+0x67,0x10,0x6c,0x67,0x10,0x67,0xa2,0x9a,1,0x73,0x2a,0x75,0x10,0x74,0xa3,0x9a,
+0x10,0x61,0xa3,0xc3,0x67,0x36,0x69,0x52,0x6b,0x10,0x72,0xa2,0x99,0x10,0x69,0xa3,
+0x99,1,0x61,0x30,0x62,0x7a,0x13,0x61,0x6e,0x77,0x61,0x7b,0x12,0x6c,0x6f,0x67,
+0x75,2,0x6c,0x32,0x74,0x34,0x76,0x12,0x69,0x65,0x74,0xa3,0x7f,0x10,0x65,0x89,
+0x12,0x68,0x61,0x6d,0xa3,0x6a,1,0x6c,0x2a,0x6e,0x10,0x67,0xa3,0x62,0x10,0x75,
+0x68,0x11,0x67,0x75,0x69,0x11,0x6e,0x67,0x99,1,0x67,0x32,0x6e,0x14,0x6b,0x6e,
+0x6f,0x77,0x6e,0xa3,0x67,0x11,0x61,0x72,0x8a,0x13,0x69,0x74,0x69,0x63,0x8b,0x71,
+0xc1,0x13,0x71,0xa2,0xde,0x72,0xa2,0xe3,0x73,6,0x69,0x8a,0x69,0x72,0x6f,0xa2,
+0x4c,0x75,0xa2,0x75,0x79,1,0x6c,0x46,0x72,4,0x63,0x65,0x65,0xa3,0x5f,0x69,
+0x2c,0x6a,0xa3,0x60,0x6e,0xa3,0x61,0x11,0x61,0x63,0x65,0x10,0x6f,0x94,0x16,0x74,
+0x69,0x6e,0x61,0x67,0x72,0x69,0x95,2,0x64,0x3c,0x67,0x4c,0x6e,1,0x64,0xa3,
+0x91,0x68,0x62,0x12,0x61,0x6c,0x61,0x63,0x10,0x64,0xa2,0xa6,0x12,0x68,0x61,0x6d,
+0xa3,0xa6,0x17,0x6e,0x77,0x72,0x69,0x74,0x69,0x6e,0x67,0xa3,0x70,2,0x67,0x3a,
+0x72,0x52,0x79,0x10,0x6f,0xa2,0xb0,0x12,0x6d,0x62,0x6f,0xa3,0xb0,1,0x64,0x26,
+0x6f,0xa3,0xb8,0xa2,0xb7,0x12,0x69,0x61,0x6e,0xa3,0xb7,0x10,0x61,0xa2,0x98,0x16,
+0x73,0x6f,0x6d,0x70,0x65,0x6e,0x67,0xa3,0x98,0x11,0x6e,0x64,0xa2,0x71,0x14,0x61,
+0x6e,0x65,0x73,0x65,0xa3,0x71,0x61,0x5c,0x67,0xa2,0x43,0x68,1,0x61,0x2a,0x72,
+0x10,0x64,0xa3,0x97,2,0x72,0x28,0x76,0x30,0x77,0x87,0x12,0x61,0x64,0x61,0xa3,
+0x97,0x12,0x69,0x61,0x6e,0x87,2,0x6d,0x40,0x72,0x58,0x75,0x10,0x72,0xa2,0x6f,
+0x15,0x61,0x73,0x68,0x74,0x72,0x61,0xa3,0x6f,1,0x61,0x26,0x72,0xa3,0x7e,0x14,
+0x72,0x69,0x74,0x61,0x6e,0xa3,0x7e,1,0x61,0xa3,0x5e,0x62,0xa3,0x85,0x11,0x6e,
+0x77,0xa3,0x70,0x11,0x61,0x61,1,0x63,0x2f,0x69,0x23,3,0x65,0x3e,0x6a,0x48,
+0x6f,0x4e,0x75,0x10,0x6e,1,0x69,0x24,0x72,0x61,0x10,0x63,0x61,0x13,0x6a,0x61,
+0x6e,0x67,0xa3,0x6e,0x11,0x6e,0x67,0xa3,0x6e,1,0x68,0x2a,0x72,0x10,0x6f,0xa3,
+0x5d,0x10,0x67,0xa3,0xb6,0x6e,0xa2,0x83,0x6f,0xa4,1,0x70,5,0x6c,0x1e,0x6c,
+0x44,0x72,0x4a,0x73,0x1b,0x61,0x6c,0x74,0x65,0x72,0x70,0x61,0x68,0x6c,0x61,0x76,
+0x69,0xa3,0x7b,0x11,0x72,0x64,0xa3,0x5c,0x11,0x74,0x69,0xa3,0x7d,0x61,0x7c,0x65,
+0xa2,0x54,0x68,3,0x61,0x3e,0x6c,0x4e,0x6e,0x5e,0x6f,0x16,0x65,0x6e,0x69,0x63,
+0x69,0x61,0x6e,0xa3,0x5b,0x10,0x67,0xa2,0x5a,0x12,0x73,0x70,0x61,0xa3,0x5a,2,
+0x69,0xa3,0x7a,0x70,0xa3,0x7b,0x76,0xa3,0x7c,0x10,0x78,0xa3,0x5b,2,0x68,0x3e,
+0x6c,0x50,0x75,0x10,0x63,0xa2,0xa5,0x14,0x69,0x6e,0x68,0x61,0x75,0xa3,0xa5,0x17,
+0x61,0x77,0x68,0x68,0x6d,0x6f,0x6e,0x67,0xa3,0x4b,0x10,0x6d,0xa2,0x90,0x14,0x79,
+0x72,0x65,0x6e,0x65,0xa3,0x90,0x11,0x72,0x6d,0xa3,0x59,6,0x6b,0x36,0x6b,0x56,
+0x73,0x6e,0x75,0x74,0x79,0x11,0x69,0x61,0x1f,0x6b,0x65,0x6e,0x67,0x70,0x75,0x61,
+0x63,0x68,0x75,0x65,0x68,0x6d,0x6f,0x6e,0x67,0xa3,0xba,1,0x67,0x2e,0x6f,0xa2,
+0x57,0x10,0x6f,0xa3,0x57,0x10,0x62,0xa3,0x84,0x11,0x68,0x75,0xa3,0x96,0x12,0x73,
+0x68,0x75,0xa3,0x96,0x61,0x42,0x62,0x9e,0x65,0x10,0x77,1,0x61,0xa3,0xaa,0x74,
+0x14,0x61,0x69,0x6c,0x75,0x65,0x97,3,0x62,0x32,0x67,0x40,0x6e,0x56,0x72,0x10,
+0x62,0xa3,0x8e,0x15,0x61,0x74,0x61,0x65,0x61,0x6e,0xa3,0x8f,0x10,0x6d,0xa2,0xc7,
+0x15,0x75,0x6e,0x64,0x61,0x72,0x69,0xa3,0xc7,0x10,0x64,0xa2,0xbb,0x16,0x69,0x6e,
+0x61,0x67,0x61,0x72,0x69,0xa3,0xbb,0x11,0x61,0x74,0xa3,0x8f,4,0x67,0x3c,0x6c,
+0x4e,0x72,0xa2,0x8e,0x73,0xa2,0x9c,0x75,0x11,0x67,0x72,0xa3,0xc2,1,0x61,0x2a,
+0x68,0x11,0x61,0x6d,0x5b,0x10,0x6d,0x5b,1,0x63,0xa2,0x6a,0x64,6,0x70,0x41,
+0x70,0x3a,0x73,0x58,0x74,0x86,0x75,0x14,0x79,0x67,0x68,0x75,0x72,0xa3,0xc2,0x11,
+0x65,0x72,1,0x6d,0x2c,0x73,0x12,0x69,0x61,0x6e,0x9b,0x11,0x69,0x63,0xa3,0x59,
+0x10,0x6f,1,0x67,0x3a,0x75,0x18,0x74,0x68,0x61,0x72,0x61,0x62,0x69,0x61,0x6e,
+0xa3,0x85,0x13,0x64,0x69,0x61,0x6e,0xa3,0xb8,0x14,0x75,0x72,0x6b,0x69,0x63,0xa3,
+0x58,0x68,0x42,0x69,0x54,0x6e,0x1a,0x6f,0x72,0x74,0x68,0x61,0x72,0x61,0x62,0x69,
+0x61,0x6e,0xa3,0x8e,0x17,0x75,0x6e,0x67,0x61,0x72,0x69,0x61,0x6e,0xa3,0x4c,0x14,
+0x74,0x61,0x6c,0x69,0x63,0x5d,1,0x68,0x26,0x6b,0xa3,0x6d,0x12,0x69,0x6b,0x69,
+0xa3,0x6d,2,0x69,0x2c,0x6b,0x30,0x79,0x10,0x61,0x5f,0x11,0x79,0x61,0x5f,0x10,
+0x68,0xa3,0x58,2,0x61,0x36,0x67,0x3c,0x6d,0x10,0x61,0x84,0x12,0x6e,0x79,0x61,
+0x85,0x11,0x67,0x65,0xa3,0xab,0x10,0x65,0xa3,0xab,0x68,0xc3,0x15,0x6b,0xc2,0x2c,
+0x6b,0xa4,0x17,0x6c,0xa4,0xba,0x6d,8,0x6f,0x46,0x6f,0x48,0x72,0x74,0x74,0x80,
+0x75,0x86,0x79,1,0x61,0x28,0x6d,0x10,0x72,0x59,0x13,0x6e,0x6d,0x61,0x72,0x59,
+2,0x64,0x2e,0x6e,0x32,0x6f,0x10,0x6e,0xa3,0x72,0x10,0x69,0xa3,0xa3,0x10,0x67,
+0x56,0x14,0x6f,0x6c,0x69,0x61,0x6e,0x57,0x10,0x6f,0xa2,0x95,0x10,0x6f,0xa3,0x95,
+0x11,0x65,0x69,0xa3,0x73,0x11,0x6c,0x74,0xa2,0xa4,0x12,0x61,0x6e,0x69,0xa3,0xa4,
+0x61,0x36,0x65,0xa2,0x67,0x69,0xa2,0xbd,0x6c,0x11,0x79,0x6d,0x55,6,0x6e,0x38,
+0x6e,0x32,0x72,0x5c,0x73,0x6c,0x79,0x10,0x61,0xa3,0x55,1,0x64,0x38,0x69,0xa2,
+0x79,0x15,0x63,0x68,0x61,0x65,0x61,0x6e,0xa3,0x79,0xa2,0x54,0x12,0x61,0x69,0x63,
+0xa3,0x54,0x10,0x63,0xa2,0xa9,0x12,0x68,0x65,0x6e,0xa3,0xa9,0x18,0x61,0x72,0x61,
+0x6d,0x67,0x6f,0x6e,0x64,0x69,0xa3,0xaf,0x68,0x36,0x6b,0x4c,0x6c,0x15,0x61,0x79,
+0x61,0x6c,0x61,0x6d,0x55,1,0x61,0x26,0x6a,0xa3,0xa0,0x13,0x6a,0x61,0x6e,0x69,
+0xa3,0xa0,0x10,0x61,0xa2,0xb4,0x12,0x73,0x61,0x72,0xa3,0xb4,3,0x64,0x78,0x65,
+0x94,0x6e,0xa2,0x42,0x72,1,0x63,0xa3,0x8d,0x6f,0xa2,0x56,0x13,0x69,0x74,0x69,
+0x63,1,0x63,0x3c,0x68,0x19,0x69,0x65,0x72,0x6f,0x67,0x6c,0x79,0x70,0x68,0x73,
+0xa3,0x56,0x15,0x75,0x72,0x73,0x69,0x76,0x65,0xa3,0x8d,1,0x65,0x26,0x66,0xa3,
+0xb5,0x16,0x66,0x61,0x69,0x64,0x72,0x69,0x6e,0xa3,0xb5,0x17,0x74,0x65,0x69,0x6d,
+0x61,0x79,0x65,0x6b,0xa3,0x73,0x10,0x64,0xa2,0x8c,0x17,0x65,0x6b,0x69,0x6b,0x61,
+0x6b,0x75,0x69,0xa3,0x8c,0x11,0x61,0x6f,0xa3,0x5c,6,0x6e,0x1a,0x6e,0x34,0x6f,
+0x38,0x70,0x3e,0x74,0x11,0x68,0x69,0xa3,0x78,0x11,0x64,0x61,0x4b,0x11,0x72,0x65,
+0xa3,0x77,0x11,0x65,0x6c,0xa3,0x8a,0x61,0x32,0x68,0xa2,0x44,0x69,0x11,0x74,0x73,
+0xa3,0xbf,5,0x74,0x23,0x74,0x34,0x77,0x56,0x79,0x13,0x61,0x68,0x6c,0x69,0xa3,
+0x4f,0x14,0x61,0x6b,0x61,0x6e,0x61,0x4c,0x19,0x6f,0x72,0x68,0x69,0x72,0x61,0x67,
+0x61,0x6e,0x61,0x8d,0x10,0x69,0xa3,0xc6,0x69,0x38,0x6c,0x40,0x6e,1,0x61,0x4d,
+0x6e,0x12,0x61,0x64,0x61,0x4b,0x12,0x74,0x68,0x69,0xa3,0x78,0x10,0x69,0xa3,0x4f,
+4,0x61,0x40,0x69,0x52,0x6d,0x70,0x6f,0x7c,0x75,0x15,0x64,0x61,0x77,0x61,0x64,
+0x69,0xa3,0x91,0x10,0x72,0x92,0x15,0x6f,0x73,0x68,0x74,0x68,0x69,0x93,0x1d,0x74,
+0x61,0x6e,0x73,0x6d,0x61,0x6c,0x6c,0x73,0x63,0x72,0x69,0x70,0x74,0xa3,0xbf,1,
+0x65,0x24,0x72,0x4f,0x10,0x72,0x4f,0x10,0x6a,0xa2,0x9d,0x11,0x6b,0x69,0xa3,0x9d,
+4,0x61,0x5c,0x65,0x90,0x69,0xa0,0x6f,0xa2,0x5d,0x79,1,0x63,0x34,0x64,0x10,
+0x69,0xa2,0x6c,0x11,0x61,0x6e,0xa3,0x6c,0x10,0x69,0xa2,0x6b,0x11,0x61,0x6e,0xa3,
+0x6b,2,0x6e,0x42,0x6f,0x46,0x74,3,0x66,0xa3,0x50,0x67,0xa3,0x51,0x69,0x24,
+0x6e,0x53,0x10,0x6e,0x53,0x10,0x61,0xa3,0x6a,0x50,0x10,0x6f,0x51,0x11,0x70,0x63,
+0xa2,0x52,0x11,0x68,0x61,0xa3,0x52,2,0x6d,0x2e,0x6e,0x36,0x73,0x10,0x75,0xa3,
+0x83,0x10,0x62,0x80,0x10,0x75,0x81,2,0x61,0xa3,0x53,0x62,0x83,0x65,0x11,0x61,
+0x72,1,0x61,0xa3,0x53,0x62,0x83,0x11,0x6d,0x61,0xa3,0x8b,0x68,0x6e,0x69,0xa2,
+0x95,0x6a,2,0x61,0x30,0x70,0x52,0x75,0x11,0x72,0x63,0xa3,0x94,1,0x6d,0x38,
+0x76,0x10,0x61,0xa2,0x4e,0x13,0x6e,0x65,0x73,0x65,0xa3,0x4e,0x10,0x6f,0xa3,0xad,
+0x11,0x61,0x6e,0xa3,0x69,6,0x6c,0x1e,0x6c,0x34,0x6d,0x3a,0x72,0x48,0x75,0x11,
+0x6e,0x67,0xa3,0x4c,0x11,0x75,0x77,0xa3,0x9c,0x10,0x6e,1,0x67,0xa3,0x4b,0x70,
+0xa3,0xba,0x11,0x6b,0x74,0x8d,0x61,0x3c,0x65,0xa2,0x43,0x69,0x11,0x72,0x61,0x48,
+0x13,0x67,0x61,0x6e,0x61,0x49,1,0x6e,0x34,0x74,0x10,0x72,0xa2,0xa2,0x11,0x61,
+0x6e,0xa3,0xa2,0x42,6,0x6f,0xe,0x6f,0x77,0x73,0xa3,0x49,0x74,0xa3,0x4a,0x75,
+0x12,0x6e,0x6f,0x6f,0x77,0x62,0xa3,0xac,0x67,0x3e,0x69,0x42,0x19,0x66,0x69,0x72,
+0x6f,0x68,0x69,0x6e,0x67,0x79,0x61,0xa3,0xb6,0x44,0x11,0x75,0x6c,0x45,0x11,0x62,
+0x72,0x46,0x11,0x65,0x77,0x47,2,0x6d,0x2e,0x6e,0x4a,0x74,0x11,0x61,0x6c,0x5d,
+0x1c,0x70,0x65,0x72,0x69,0x61,0x6c,0x61,0x72,0x61,0x6d,0x61,0x69,0x63,0xa3,0x74,
+2,0x64,0x66,0x68,0x6a,0x73,0x1b,0x63,0x72,0x69,0x70,0x74,0x69,0x6f,0x6e,0x61,
+0x6c,0x70,0x61,1,0x68,0x32,0x72,0x14,0x74,0x68,0x69,0x61,0x6e,0xa3,0x7d,0x13,
+0x6c,0x61,0x76,0x69,0xa3,0x7a,0x10,0x73,0xa3,0x4d,0x15,0x65,0x72,0x69,0x74,0x65,
+0x64,0x23,0x64,0xc1,0xd,0x64,0xa2,0x7a,0x65,0xa2,0xc1,0x67,4,0x65,0x82,0x6c,
+0x9a,0x6f,0xa2,0x46,0x72,0xa2,0x55,0x75,2,0x6a,0x3c,0x6e,0x4e,0x72,1,0x6d,
+0x24,0x75,0x41,0x13,0x75,0x6b,0x68,0x69,0x41,1,0x61,0x24,0x72,0x3f,0x13,0x72,
+0x61,0x74,0x69,0x3f,0x18,0x6a,0x61,0x6c,0x61,0x67,0x6f,0x6e,0x64,0x69,0xa3,0xb3,
+0x10,0x6f,1,0x6b,0xa3,0x48,0x72,0x38,0x13,0x67,0x69,0x61,0x6e,0x39,0x11,0x61,
+0x67,0x90,0x15,0x6f,0x6c,0x69,0x74,0x69,0x63,0x91,1,0x6e,0x30,0x74,0x10,0x68,
+0x3a,0x11,0x69,0x63,0x3b,1,0x67,0xa3,0xb3,0x6d,0xa3,0xaf,1,0x61,0x32,0x65,
+1,0x65,0x24,0x6b,0x3d,0x10,0x6b,0x3d,0x10,0x6e,0xa2,0x89,0x12,0x74,0x68,0x61,
+0xa3,0x89,4,0x65,0x46,0x69,0x6c,0x6f,0x8c,0x73,0x9a,0x75,0x11,0x70,0x6c,0xa2,
+0x87,0x13,0x6f,0x79,0x61,0x6e,0xa3,0x87,1,0x73,0x38,0x76,0x10,0x61,0x34,0x15,
+0x6e,0x61,0x67,0x61,0x72,0x69,0x35,0x13,0x65,0x72,0x65,0x74,0x33,1,0x61,0x36,
+0x76,0x16,0x65,0x73,0x61,0x6b,0x75,0x72,0x75,0xa3,0xbe,0x10,0x6b,0xa3,0xbe,0x11,
+0x67,0x72,0xa2,0xb2,0x10,0x61,0xa3,0xb2,0x11,0x72,0x74,0x33,2,0x67,0x3a,0x6c,
+0x72,0x74,0x11,0x68,0x69,0x36,0x13,0x6f,0x70,0x69,0x63,0x37,0x10,0x79,2,0x64,
+0xa3,0x45,0x68,0xa3,0x46,0x70,0xa2,0x47,0x1e,0x74,0x69,0x61,0x6e,0x68,0x69,0x65,
+0x72,0x6f,0x67,0x6c,0x79,0x70,0x68,0x73,0xa3,0x47,1,0x62,0x36,0x79,0x10,0x6d,
+0xa2,0xb9,0x12,0x61,0x69,0x63,0xa3,0xb9,0x10,0x61,0xa2,0x88,0x12,0x73,0x61,0x6e,
+0xa3,0x88,0x61,0xa2,0xc9,0x62,0xa4,0x2e,0x63,6,0x6f,0x52,0x6f,0x76,0x70,0x92,
+0x75,0xa2,0x41,0x79,1,0x70,0x3e,0x72,2,0x69,0x2a,0x6c,0x31,0x73,0xa3,0x44,
+0x13,0x6c,0x6c,0x69,0x63,0x31,0x10,0x72,1,0x69,0x34,0x6f,0x15,0x6d,0x69,0x6e,
+0x6f,0x61,0x6e,0xa3,0xc1,0x11,0x6f,0x74,0x7f,1,0x6d,0x30,0x70,0x10,0x74,0x2e,
+0x11,0x69,0x63,0x2f,0x12,0x6d,0x6f,0x6e,0x21,1,0x6d,0x28,0x72,0x10,0x74,0x7f,
+0x10,0x6e,0xa3,0xc1,0x16,0x6e,0x65,0x69,0x66,0x6f,0x72,0x6d,0xa3,0x65,0x61,0x32,
+0x68,0xa2,0x41,0x69,0x11,0x72,0x74,0xa3,0x43,3,0x6b,0x4c,0x6e,0x50,0x72,0x76,
+0x75,0x1d,0x63,0x61,0x73,0x69,0x61,0x6e,0x61,0x6c,0x62,0x61,0x6e,0x69,0x61,0x6e,
+0xa3,0x9f,0x10,0x6d,0xa3,0x76,1,0x61,0x24,0x73,0x71,0x1d,0x64,0x69,0x61,0x6e,
+0x61,0x62,0x6f,0x72,0x69,0x67,0x69,0x6e,0x61,0x6c,0x71,0x10,0x69,0xa2,0x68,0x11,
+0x61,0x6e,0xa3,0x68,3,0x61,0x32,0x65,0x44,0x6f,0x52,0x72,0x10,0x73,0xa3,0xbd,
+1,0x6b,0x26,0x6d,0xa3,0x42,0x11,0x6d,0x61,0xa3,0x76,0x10,0x72,0x2c,0x13,0x6f,
+0x6b,0x65,0x65,0x2d,0x16,0x72,0x61,0x73,0x6d,0x69,0x61,0x6e,0xa3,0xbd,6,0x68,
+0x4a,0x68,0x48,0x6e,0x4e,0x72,0x76,0x76,1,0x65,0x2a,0x73,0x10,0x74,0xa3,0x75,
+0x13,0x73,0x74,0x61,0x6e,0xa3,0x75,0x11,0x6f,0x6d,0xa3,0xa1,0x11,0x61,0x74,0x1f,
+0x6f,0x6c,0x69,0x61,0x6e,0x68,0x69,0x65,0x72,0x6f,0x67,0x6c,0x79,0x70,0x68,0x73,
+0xa3,0x9c,1,0x61,0x3e,0x6d,2,0x65,0x2a,0x69,0xa3,0x74,0x6e,0x27,0x13,0x6e,
+0x69,0x61,0x6e,0x27,0x10,0x62,0x24,0x11,0x69,0x63,0x25,0x64,0x30,0x66,0x44,0x67,
+0x11,0x68,0x62,0xa3,0x9f,0x10,0x6c,1,0x61,0x26,0x6d,0xa3,0xa7,0x10,0x6d,0xa3,
+0xa7,0x11,0x61,0x6b,0xa3,0x93,6,0x6c,0x3c,0x6c,0x52,0x6f,0x56,0x72,0x66,0x75,
+1,0x67,0x30,0x68,1,0x64,0x79,0x69,0x10,0x64,0x79,0x10,0x69,0x8e,0x13,0x6e,
+0x65,0x73,0x65,0x8f,0x11,0x69,0x73,0xa1,0x11,0x70,0x6f,0x2a,0x13,0x6d,0x6f,0x66,
+0x6f,0x2b,0x10,0x61,1,0x68,0x2e,0x69,0x7c,0x12,0x6c,0x6c,0x65,0x7d,0xa2,0x41,
+0x11,0x6d,0x69,0xa3,0x41,0x61,0x48,0x65,0x9c,0x68,1,0x61,0x2a,0x6b,0x10,0x73,
+0xa3,0xa8,0x15,0x69,0x6b,0x73,0x75,0x6b,0x69,0xa3,0xa8,3,0x6c,0x3a,0x6d,0x48,
+0x73,0x54,0x74,1,0x61,0x24,0x6b,0x9f,0x10,0x6b,0x9f,0x10,0x69,0x9c,0x13,0x6e,
+0x65,0x73,0x65,0x9d,0x10,0x75,0xa2,0x82,0x10,0x6d,0xa3,0x82,0x10,0x73,0xa2,0x86,
+0x13,0x61,0x76,0x61,0x68,0xa3,0x86,0x11,0x6e,0x67,0x28,0x12,0x61,0x6c,0x69,0x29,
+3,0x6c,0x42,0x6e,0x90,0x74,0xa2,0x46,0x76,0x24,0x17,0x6f,0x77,0x65,0x6c,0x6a,
+0x61,0x6d,0x6f,0x25,0x22,1,0x65,0x54,0x76,0x28,1,0x73,0x38,0x74,0x2a,0x17,
+0x73,0x79,0x6c,0x6c,0x61,0x62,0x6c,0x65,0x2b,0x16,0x79,0x6c,0x6c,0x61,0x62,0x6c,
+0x65,0x29,0x18,0x61,0x64,0x69,0x6e,0x67,0x6a,0x61,0x6d,0x6f,0x23,1,0x61,0x21,
+0x6f,0x1a,0x74,0x61,0x70,0x70,0x6c,0x69,0x63,0x61,0x62,0x6c,0x65,0x21,0x26,0x1a,
+0x72,0x61,0x69,0x6c,0x69,0x6e,0x67,0x6a,0x61,0x6d,0x6f,0x27,1,0x6e,0x2c,0x79,
+0x22,0x11,0x65,0x73,0x23,0x20,0x10,0x6f,0x21,1,0x6e,0x2c,0x79,0x22,0x11,0x65,
+0x73,0x23,0x20,0x10,0x6f,0x21,2,0x6d,0x30,0x6e,0x3a,0x79,0x22,0x11,0x65,0x73,
+0x23,0x24,0x13,0x61,0x79,0x62,0x65,0x25,0x20,0x10,0x6f,0x21,2,0x6d,0x30,0x6e,
+0x3a,0x79,0x22,0x11,0x65,0x73,0x23,0x24,0x13,0x61,0x79,0x62,0x65,0x25,0x20,0x10,
+0x6f,0x21,0xb,0x72,0x39,0x76,0xc,0x76,0x33,0x78,0x2a,0x7a,0x11,0x77,0x6a,0x43,
+0x10,0x78,0x21,0x72,0x28,0x73,0x50,0x74,0x31,1,0x65,0x24,0x69,0x39,0x1e,0x67,
+0x69,0x6f,0x6e,0x61,0x6c,0x69,0x6e,0x64,0x69,0x63,0x61,0x74,0x6f,0x72,0x39,1,
+0x6d,0x35,0x70,0x18,0x61,0x63,0x69,0x6e,0x67,0x6d,0x61,0x72,0x6b,0x35,0x6c,0x1f,
+0x6c,0x3c,0x6f,0x4a,0x70,1,0x70,0x37,0x72,0x14,0x65,0x70,0x65,0x6e,0x64,0x37,
+0x28,1,0x66,0x2b,0x76,0x2c,0x10,0x74,0x2f,0x13,0x74,0x68,0x65,0x72,0x21,0x63,
+0x4c,0x65,0x64,0x67,1,0x61,0x3a,0x6c,0x19,0x75,0x65,0x61,0x66,0x74,0x65,0x72,
+0x7a,0x77,0x6a,0x41,0x10,0x7a,0x41,2,0x6e,0x23,0x6f,0x24,0x72,0x25,0x14,0x6e,
+0x74,0x72,0x6f,0x6c,0x23,2,0x62,0x34,0x6d,0x4e,0x78,0x26,0x13,0x74,0x65,0x6e,
+0x64,0x27,0x3a,1,0x61,0x24,0x67,0x3d,0x11,0x73,0x65,0x3a,0x12,0x67,0x61,0x7a,
+0x3d,0x3e,0x16,0x6f,0x64,0x69,0x66,0x69,0x65,0x72,0x3f,9,0x6e,0x4a,0x6e,0x34,
+0x6f,0x44,0x73,0x60,0x75,0x94,0x78,0x10,0x78,0x21,0x10,0x75,0x2a,0x14,0x6d,0x65,
+0x72,0x69,0x63,0x2b,1,0x6c,0x2c,0x74,0x12,0x68,0x65,0x72,0x21,0x14,0x65,0x74,
+0x74,0x65,0x72,0x2d,3,0x63,0x36,0x65,0x46,0x70,0x31,0x74,0x32,0x12,0x65,0x72,
+0x6d,0x33,0x3c,0x16,0x6f,0x6e,0x74,0x69,0x6e,0x75,0x65,0x3d,0x2e,0x10,0x70,0x2f,
+0x10,0x70,0x34,0x12,0x70,0x65,0x72,0x35,0x61,0x46,0x63,0x52,0x65,0x64,0x66,0x72,
+0x6c,2,0x65,0x2d,0x66,0x3b,0x6f,0x28,0x12,0x77,0x65,0x72,0x29,0x10,0x74,0x22,
+0x12,0x65,0x72,0x6d,0x23,1,0x6c,0x24,0x72,0x37,0x24,0x12,0x6f,0x73,0x65,0x25,
+0x10,0x78,0x38,0x13,0x74,0x65,0x6e,0x64,0x39,0x10,0x6f,0x26,0x13,0x72,0x6d,0x61,
+0x74,0x27,0,0x10,0x6c,0x88,0x72,0x40,0x72,0x36,0x73,0x5e,0x77,0x7a,0x78,0x8a,
+0x7a,0x11,0x77,0x6a,0x4b,1,0x65,0x24,0x69,0x3b,0x1e,0x67,0x69,0x6f,0x6e,0x61,
+0x6c,0x69,0x6e,0x64,0x69,0x63,0x61,0x74,0x6f,0x72,0x3b,1,0x69,0x24,0x71,0x3f,
+0x18,0x6e,0x67,0x6c,0x65,0x71,0x75,0x6f,0x74,0x65,0x3f,0x17,0x73,0x65,0x67,0x73,
+0x70,0x61,0x63,0x65,0x4d,0x10,0x78,0x21,0x6c,0x36,0x6d,0x3c,0x6e,0x76,0x6f,0x13,
+0x74,0x68,0x65,0x72,0x21,1,0x65,0x23,0x66,0x35,3,0x62,0x37,0x69,0x28,0x6c,
+0x29,0x6e,0x2b,0x10,0x64,1,0x6c,0x34,0x6e,0x11,0x75,0x6d,0x2a,0x12,0x6c,0x65,
+0x74,0x37,0x14,0x65,0x74,0x74,0x65,0x72,0x29,2,0x65,0x36,0x6c,0x39,0x75,0x2c,
+0x14,0x6d,0x65,0x72,0x69,0x63,0x2d,0x14,0x77,0x6c,0x69,0x6e,0x65,0x39,0x66,0x3f,
+0x66,0x40,0x67,0x4e,0x68,0x70,0x6b,0x10,0x61,0x26,0x15,0x74,0x61,0x6b,0x61,0x6e,
+0x61,0x27,0x10,0x6f,0x24,0x13,0x72,0x6d,0x61,0x74,0x25,1,0x61,0x3a,0x6c,0x19,
+0x75,0x65,0x61,0x66,0x74,0x65,0x72,0x7a,0x77,0x6a,0x49,0x10,0x7a,0x49,1,0x65,
+0x24,0x6c,0x3d,0x19,0x62,0x72,0x65,0x77,0x6c,0x65,0x74,0x74,0x65,0x72,0x3d,0x61,
+0x86,0x63,0x92,0x64,0x94,0x65,2,0x62,0x44,0x6d,0x5e,0x78,0x2e,0x13,0x74,0x65,
+0x6e,0x64,0x32,0x15,0x6e,0x75,0x6d,0x6c,0x65,0x74,0x2f,0x42,1,0x61,0x24,0x67,
+0x45,0x11,0x73,0x65,0x42,0x12,0x67,0x61,0x7a,0x45,0x46,0x16,0x6f,0x64,0x69,0x66,
+0x69,0x65,0x72,0x47,0x15,0x6c,0x65,0x74,0x74,0x65,0x72,0x23,0x10,0x72,0x31,1,
+0x6f,0x24,0x71,0x41,0x18,0x75,0x62,0x6c,0x65,0x71,0x75,0x6f,0x74,0x65,0x41,2,
+0x63,0x32,0x6e,0x3c,0x6f,0x22,0x12,0x70,0x65,0x6e,0x23,0x24,0x13,0x6c,0x6f,0x73,
+0x65,0x25,0x20,0x12,0x6f,0x6e,0x65,0x21,6,0x6f,0x65,0x6f,0x4a,0x72,0x5c,0x74,
+0x64,0x76,0x1d,0x69,0x73,0x75,0x61,0x6c,0x6f,0x72,0x64,0x65,0x72,0x6c,0x65,0x66,
+0x74,0x3d,0x18,0x76,0x65,0x72,0x73,0x74,0x72,0x75,0x63,0x6b,0x2d,0x13,0x69,0x67,
+0x68,0x74,0x2f,0x11,0x6f,0x70,0x30,0x12,0x61,0x6e,0x64,2,0x62,0x32,0x6c,0x62,
+0x72,0x13,0x69,0x67,0x68,0x74,0x3b,0x14,0x6f,0x74,0x74,0x6f,0x6d,0x32,0x12,0x61,
+0x6e,0x64,1,0x6c,0x2e,0x72,0x13,0x69,0x67,0x68,0x74,0x35,0x12,0x65,0x66,0x74,
+0x3f,0x12,0x65,0x66,0x74,0x36,0x17,0x61,0x6e,0x64,0x72,0x69,0x67,0x68,0x74,0x39,
+0x62,0x2c,0x6c,0x5c,0x6e,0x10,0x61,0x21,0x14,0x6f,0x74,0x74,0x6f,0x6d,0x22,0x12,
+0x61,0x6e,0x64,1,0x6c,0x2e,0x72,0x13,0x69,0x67,0x68,0x74,0x27,0x12,0x65,0x66,
+0x74,0x25,0x12,0x65,0x66,0x74,0x28,0x17,0x61,0x6e,0x64,0x72,0x69,0x67,0x68,0x74,
+0x2b,0xd,0x6e,0xaa,0x72,0x70,0x72,0x92,0x73,0xa2,0x46,0x74,0xa2,0x54,0x76,1,
+0x69,0x60,0x6f,0x12,0x77,0x65,0x6c,0x62,1,0x64,0x3a,0x69,0x19,0x6e,0x64,0x65,
+0x70,0x65,0x6e,0x64,0x65,0x6e,0x74,0x67,0x17,0x65,0x70,0x65,0x6e,0x64,0x65,0x6e,
+0x74,0x65,1,0x72,0x2e,0x73,0x13,0x61,0x72,0x67,0x61,0x61,0x12,0x61,0x6d,0x61,
+0x5f,0x1d,0x65,0x67,0x69,0x73,0x74,0x65,0x72,0x73,0x68,0x69,0x66,0x74,0x65,0x72,
+0x57,0x1e,0x79,0x6c,0x6c,0x61,0x62,0x6c,0x65,0x6d,0x6f,0x64,0x69,0x66,0x69,0x65,
+0x72,0x59,0x12,0x6f,0x6e,0x65,1,0x6c,0x2c,0x6d,0x12,0x61,0x72,0x6b,0x5d,0x14,
+0x65,0x74,0x74,0x65,0x72,0x5b,0x6e,0x3c,0x6f,0x7c,0x70,0x18,0x75,0x72,0x65,0x6b,
+0x69,0x6c,0x6c,0x65,0x72,0x55,1,0x6f,0x4c,0x75,1,0x6b,0x3c,0x6d,0x12,0x62,
+0x65,0x72,0x50,0x15,0x6a,0x6f,0x69,0x6e,0x65,0x72,0x53,0x11,0x74,0x61,0x4f,0x16,
+0x6e,0x6a,0x6f,0x69,0x6e,0x65,0x72,0x4d,0x13,0x74,0x68,0x65,0x72,0x21,0x67,0x3e,
+0x67,0x4a,0x69,0x64,0x6a,0x82,0x6d,0x1d,0x6f,0x64,0x69,0x66,0x79,0x69,0x6e,0x67,
+0x6c,0x65,0x74,0x74,0x65,0x72,0x4b,0x1c,0x65,0x6d,0x69,0x6e,0x61,0x74,0x69,0x6f,
+0x6e,0x6d,0x61,0x72,0x6b,0x45,0x1e,0x6e,0x76,0x69,0x73,0x69,0x62,0x6c,0x65,0x73,
+0x74,0x61,0x63,0x6b,0x65,0x72,0x47,0x14,0x6f,0x69,0x6e,0x65,0x72,0x49,0x61,0xa2,
+0xba,0x62,0xa2,0xc0,0x63,1,0x61,0xa2,0xa2,0x6f,0x16,0x6e,0x73,0x6f,0x6e,0x61,
+0x6e,0x74,0x2a,8,0x6b,0x67,0x6b,0x48,0x6d,0x52,0x70,0x5c,0x73,0xa2,0x42,0x77,
+0x19,0x69,0x74,0x68,0x73,0x74,0x61,0x63,0x6b,0x65,0x72,0x43,0x14,0x69,0x6c,0x6c,
+0x65,0x72,0x35,0x14,0x65,0x64,0x69,0x61,0x6c,0x37,1,0x6c,0x52,0x72,0x10,0x65,
+1,0x63,0x2e,0x66,0x13,0x69,0x78,0x65,0x64,0x3d,0x19,0x65,0x64,0x69,0x6e,0x67,
+0x72,0x65,0x70,0x68,0x61,0x3b,0x18,0x61,0x63,0x65,0x68,0x6f,0x6c,0x64,0x65,0x72,
+0x39,0x10,0x75,1,0x62,0x3e,0x63,0x1b,0x63,0x65,0x65,0x64,0x69,0x6e,0x67,0x72,
+0x65,0x70,0x68,0x61,0x41,0x15,0x6a,0x6f,0x69,0x6e,0x65,0x64,0x3f,0x64,0x4c,0x66,
+0x52,0x68,0x5a,0x69,0x1e,0x6e,0x69,0x74,0x69,0x61,0x6c,0x70,0x6f,0x73,0x74,0x66,
+0x69,0x78,0x65,0x64,0x33,0x12,0x65,0x61,0x64,0x2d,0x13,0x69,0x6e,0x61,0x6c,0x2f,
+0x18,0x65,0x61,0x64,0x6c,0x65,0x74,0x74,0x65,0x72,0x31,0x1d,0x6e,0x74,0x69,0x6c,
+0x6c,0x61,0x74,0x69,0x6f,0x6e,0x6d,0x61,0x72,0x6b,0x29,0x16,0x76,0x61,0x67,0x72,
+0x61,0x68,0x61,0x23,1,0x69,0x4a,0x72,0x10,0x61,0x1f,0x68,0x6d,0x69,0x6a,0x6f,
+0x69,0x6e,0x69,0x6e,0x67,0x6e,0x75,0x6d,0x62,0x65,0x72,0x27,0x12,0x6e,0x64,0x75,
+0x25,2,0x72,0x38,0x74,0x46,0x75,0x26,0x15,0x70,0x72,0x69,0x67,0x68,0x74,0x27,
+0x20,0x15,0x6f,0x74,0x61,0x74,0x65,0x64,0x21,1,0x72,0x24,0x75,0x25,0x22,0x18,
+0x61,0x6e,0x73,0x66,0x6f,0x72,0x6d,0x65,0x64,1,0x72,0x32,0x75,0x15,0x70,0x72,
+0x69,0x67,0x68,0x74,0x25,0x15,0x6f,0x74,0x61,0x74,0x65,0x64,0x23,0xd,0x6e,0xc1,
+0x86,0x73,0xa8,0x73,0x4c,0x74,0xa2,0x76,0x75,0xa2,0x83,0x7a,0xd8,0x70,0,2,
+0x6c,0xd9,0x20,0,0x70,0xd9,0x40,0,0x73,0xc3,0,0xfe,0xf,0,0,0,
+7,0x6f,0x3c,0x6f,0xff,8,0,0,0,0x70,0x3a,0x75,0x6e,0x79,0x13,0x6d,
+0x62,0x6f,0x6c,0xff,0xf,0,0,0,0x11,0x61,0x63,1,0x65,0x34,0x69,0x15,
+0x6e,0x67,0x6d,0x61,0x72,0x6b,0xa5,0,0x18,0x73,0x65,0x70,0x61,0x72,0x61,0x74,
+0x6f,0x72,0xc3,0,0x16,0x72,0x72,0x6f,0x67,0x61,0x74,0x65,0xe1,0,0,0x63,
+0xff,2,0,0,0,0x65,0x38,0x6b,0xff,4,0,0,0,0x6d,0xff,1,
+0,0,0,0x16,0x70,0x61,0x72,0x61,0x74,0x6f,0x72,0xd9,0x70,0,0x1d,0x69,
+0x74,0x6c,0x65,0x63,0x61,0x73,0x65,0x6c,0x65,0x74,0x74,0x65,0x72,0x31,1,0x6e,
+0x40,0x70,0x1c,0x70,0x65,0x72,0x63,0x61,0x73,0x65,0x6c,0x65,0x74,0x74,0x65,0x72,
+0x25,0x17,0x61,0x73,0x73,0x69,0x67,0x6e,0x65,0x64,0x23,0x6e,0xa2,0x69,0x6f,0xa2,
+0x89,0x70,0xfe,0x30,0xf8,0,0,9,0x69,0x33,0x69,0xff,0x10,0,0,0,
+0x6f,0xfd,0x80,0,0,0x72,0x54,0x73,0xf9,0,0,0x75,0x12,0x6e,0x63,0x74,
+0xfe,0x30,0xf8,0,0,0x15,0x75,0x61,0x74,0x69,0x6f,0x6e,0xff,0x30,0xf8,0,
+0,0x17,0x69,0x76,0x61,0x74,0x65,0x75,0x73,0x65,0xdd,0,0,0x61,0x48,0x63,
+0xfd,0x40,0,0,0x64,0xe9,0,0,0x65,0xfd,0x20,0,0,0x66,0xff,0x20,
+0,0,0,0x1f,0x72,0x61,0x67,0x72,0x61,0x70,0x68,0x73,0x65,0x70,0x61,0x72,
+0x61,0x74,0x6f,0x72,0xd9,0x40,0,0xbe,0,3,0x64,0xa7,0,0x6c,0xab,0,
+0x6f,0x30,0x75,0x13,0x6d,0x62,0x65,0x72,0xbf,0,0xb2,0,0x1b,0x6e,0x73,0x70,
+0x61,0x63,0x69,0x6e,0x67,0x6d,0x61,0x72,0x6b,0xa1,1,0x70,0x92,0x74,0x12,0x68,
+0x65,0x72,0xe6,0x80,1,3,0x6c,0x40,0x6e,0x4a,0x70,0x56,0x73,0x14,0x79,0x6d,
+0x62,0x6f,0x6c,0xff,8,0,0,0,0x14,0x65,0x74,0x74,0x65,0x72,0x61,0x14,
+0x75,0x6d,0x62,0x65,0x72,0xb3,0,0x19,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,
+0x6f,0x6e,0xfd,0x80,0,0,0x1c,0x65,0x6e,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,
+0x74,0x69,0x6f,0x6e,0xf9,0,0,0x66,0xc0,0xc4,0x66,0xa2,0x47,0x69,0xa2,0x64,
+0x6c,0xa2,0x79,0x6d,0xa4,0xc0,4,0x61,0x6c,0x63,0xa5,0,0x65,0xa3,0x80,0x6e,
+0xa1,0x6f,0x15,0x64,0x69,0x66,0x69,0x65,0x72,1,0x6c,0x38,0x73,0x14,0x79,0x6d,
+0x62,0x6f,0x6c,0xff,4,0,0,0,0x14,0x65,0x74,0x74,0x65,0x72,0x41,1,
+0x72,0x3c,0x74,0x16,0x68,0x73,0x79,0x6d,0x62,0x6f,0x6c,0xff,1,0,0,0,
+0x10,0x6b,0xa5,0xc0,1,0x69,0x32,0x6f,0x13,0x72,0x6d,0x61,0x74,0xdb,0,0,
+0x1d,0x6e,0x61,0x6c,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0xff,
+0x20,0,0,0,0x10,0x6e,0x1f,0x69,0x74,0x69,0x61,0x6c,0x70,0x75,0x6e,0x63,
+0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0xff,0x10,0,0,0,0x9c,7,0x6d,0x18,
+0x6d,0x41,0x6f,0x28,0x74,0x31,0x75,0x25,0x60,0x1c,0x77,0x65,0x72,0x63,0x61,0x73,
+0x65,0x6c,0x65,0x74,0x74,0x65,0x72,0x29,0x63,0x3d,0x65,0x28,0x69,0x42,0x6c,0x29,
+0x13,0x74,0x74,0x65,0x72,0x9c,0x15,0x6e,0x75,0x6d,0x62,0x65,0x72,0xab,0,0x1a,
+0x6e,0x65,0x73,0x65,0x70,0x61,0x72,0x61,0x74,0x6f,0x72,0xd9,0x20,0,0x63,0x46,
+0x64,0xa2,0x96,0x65,0x1b,0x6e,0x63,0x6c,0x6f,0x73,0x69,0x6e,0x67,0x6d,0x61,0x72,
+0x6b,0xa3,0x80,0xe6,0x80,1,7,0x6e,0x57,0x6e,0x52,0x6f,0x5e,0x73,0xe1,0,
+0,0x75,0x1b,0x72,0x72,0x65,0x6e,0x63,0x79,0x73,0x79,0x6d,0x62,0x6f,0x6c,0xff,
+2,0,0,0,0x22,0x12,0x74,0x72,0x6c,0xd9,0x80,0,0xdc,0,0,1,
+0x6d,0x62,0x6e,1,0x6e,0x30,0x74,0x12,0x72,0x6f,0x6c,0xd9,0x80,0,0x1f,0x65,
+0x63,0x74,0x6f,0x72,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0xfd,
+0x40,0,0,0x19,0x62,0x69,0x6e,0x69,0x6e,0x67,0x6d,0x61,0x72,0x6b,0xa5,0xc0,
+0x61,0x58,0x63,0xd9,0x80,0,0x66,0xdb,0,0,0x6c,0x1d,0x6f,0x73,0x65,0x70,
+0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0xfd,0x20,0,0,0x18,0x73,
+0x65,0x64,0x6c,0x65,0x74,0x74,0x65,0x72,0x3d,2,0x61,0x32,0x65,0x50,0x69,0x12,
+0x67,0x69,0x74,0xa7,0,0x1c,0x73,0x68,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,
+0x69,0x6f,0x6e,0xe9,0,0,0x1a,0x63,0x69,0x6d,0x61,0x6c,0x6e,0x75,0x6d,0x62,
+0x65,0x72,0xa7,0
 };
 
-const char PropNameData::nameGroups[22855]={
+const char PropNameData::nameGroups[23100]={
 2,'A','l','p','h','a',0,'A','l','p','h','a','b','e','t','i','c',0,
 4,'N',0,'N','o',0,'F',0,'F','a','l','s','e',0,4,'Y',0,'Y','e','s',0,'T',0,'T','r','u','e',0,
 2,'N','R',0,'N','o','t','_','R','e','o','r','d','e','r','e','d',0,
@@ -1553,9 +1559,18 @@ const char PropNameData::nameGroups[22855]={
 'r','i','g','i','n','a','l','_','S','y','l','l','a','b','i','c','s','_','E','x','t','e','n','d','e','d','_','A',0,
 2,'V','i','t','h','k','u','q','i',0,'V','i','t','h','k','u','q','i',0,
 2,'Z','n','a','m','e','n','n','y','_','M','u','s','i','c',0,'Z','n','a','m','e','n','n','y','_','M','u','s','i','c','a','l',
-'_','N','o','t','a','t','i','o','n',0,2,'c','c','c',0,'C','a','n','o','n','i','c','a','l','_','C','o','m','b','i','n','i',
-'n','g','_','C','l','a','s','s',0,2,'d','t',0,'D','e','c','o','m','p','o','s','i','t','i','o','n','_','T','y','p','e',0,
-3,'N','o','n','e',0,'N','o','n','e',0,'n','o','n','e',0,
+'_','N','o','t','a','t','i','o','n',0,2,'A','r','a','b','i','c','_','E','x','t','_','C',0,
+'A','r','a','b','i','c','_','E','x','t','e','n','d','e','d','_','C',0,
+2,'C','J','K','_','E','x','t','_','H',0,'C','J','K','_','U','n','i','f','i','e','d','_','I','d','e','o','g','r','a','p','h',
+'s','_','E','x','t','e','n','s','i','o','n','_','H',0,2,'C','y','r','i','l','l','i','c','_','E','x','t','_','D',0,
+'C','y','r','i','l','l','i','c','_','E','x','t','e','n','d','e','d','_','D',0,
+2,'D','e','v','a','n','a','g','a','r','i','_','E','x','t','_','A',0,'D','e','v','a','n','a','g','a','r','i','_','E','x','t',
+'e','n','d','e','d','_','A',0,2,'K','a','k','t','o','v','i','k','_','N','u','m','e','r','a','l','s',0,
+'K','a','k','t','o','v','i','k','_','N','u','m','e','r','a','l','s',0,
+2,'K','a','w','i',0,'K','a','w','i',0,2,'N','a','g','_','M','u','n','d','a','r','i',0,
+'N','a','g','_','M','u','n','d','a','r','i',0,2,'c','c','c',0,'C','a','n','o','n','i','c','a','l','_','C','o','m','b','i',
+'n','i','n','g','_','C','l','a','s','s',0,2,'d','t',0,'D','e','c','o','m','p','o','s','i','t','i','o','n','_','T','y','p',
+'e',0,3,'N','o','n','e',0,'N','o','n','e',0,'n','o','n','e',0,
 3,'C','a','n',0,'C','a','n','o','n','i','c','a','l',0,'c','a','n',0,
 3,'C','o','m',0,'C','o','m','p','a','t',0,'c','o','m',0,
 3,'E','n','c',0,'C','i','r','c','l','e',0,'e','n','c',0,
@@ -1844,6 +1859,7 @@ const char PropNameData::nameGroups[22855]={
 2,'Y','e','z','i',0,'Y','e','z','i','d','i',0,2,'C','p','m','n',0,'C','y','p','r','o','_','M','i','n','o','a','n',0,
 2,'O','u','g','r',0,'O','l','d','_','U','y','g','h','u','r',0,
 2,'T','n','s','a',0,'T','a','n','g','s','a',0,2,'V','i','t','h',0,'V','i','t','h','k','u','q','i',0,
+2,'N','a','g','m',0,'N','a','g','_','M','u','n','d','a','r','i',0,
 2,'h','s','t',0,'H','a','n','g','u','l','_','S','y','l','l','a','b','l','e','_','T','y','p','e',0,
 2,'N','A',0,'N','o','t','_','A','p','p','l','i','c','a','b','l','e',0,
 2,'L',0,'L','e','a','d','i','n','g','_','J','a','m','o',0,
diff --git a/deps/icu-small/source/common/propsvec.cpp b/deps/icu-small/source/common/propsvec.cpp
index 056fcda9cf..e5caa4b9d2 100644
--- a/deps/icu-small/source/common/propsvec.cpp
+++ b/deps/icu-small/source/common/propsvec.cpp
@@ -351,7 +351,7 @@ upvec_compact(UPropsVectors *pv, UPVecCompactHandler *handler, void *context, UE
     }
 
     /* Set the flag now: Sorting and compacting destroys the builder data structure. */
-    pv->isCompacted=TRUE;
+    pv->isCompacted=true;
 
     rows=pv->rows;
     columns=pv->columns;
@@ -360,7 +360,7 @@ upvec_compact(UPropsVectors *pv, UPVecCompactHandler *handler, void *context, UE
 
     /* sort the properties vectors to find unique vector values */
     uprv_sortArray(pv->v, rows, columns*4,
-                   upvec_compareRows, pv, FALSE, pErrorCode);
+                   upvec_compareRows, pv, false, pErrorCode);
     if(U_FAILURE(*pErrorCode)) {
         return;
     }
@@ -503,7 +503,7 @@ upvec_compactToUTrie2Handler(void *context,
     (void)columns;
     UPVecToUTrie2Context *toUTrie2=(UPVecToUTrie2Context *)context;
     if(start<UPVEC_FIRST_SPECIAL_CP) {
-        utrie2_setRange32(toUTrie2->trie, start, end, (uint32_t)rowIndex, TRUE, pErrorCode);
+        utrie2_setRange32(toUTrie2->trie, start, end, (uint32_t)rowIndex, true, pErrorCode);
     } else {
         switch(start) {
         case UPVEC_INITIAL_VALUE_CP:
diff --git a/deps/icu-small/source/common/punycode.cpp b/deps/icu-small/source/common/punycode.cpp
index 4832938ff7..f95722da27 100644
--- a/deps/icu-small/source/common/punycode.cpp
+++ b/deps/icu-small/source/common/punycode.cpp
@@ -573,7 +573,7 @@ u_strFromPunycode(const UChar *src, int32_t srcLength,
                 /* Case of last character determines uppercase flag: */
                 caseFlags[codeUnitIndex]=IS_BASIC_UPPERCASE(src[in-1]);
                 if(cpLength==2) {
-                    caseFlags[codeUnitIndex+1]=FALSE;
+                    caseFlags[codeUnitIndex+1]=false;
                 }
             }
         }
diff --git a/deps/icu-small/source/common/putil.cpp b/deps/icu-small/source/common/putil.cpp
index 68be079b3a..f27c8737d2 100644
--- a/deps/icu-small/source/common/putil.cpp
+++ b/deps/icu-small/source/common/putil.cpp
@@ -244,7 +244,7 @@ u_signBit(double d) {
  */
 UDate fakeClock_t0 = 0; /** Time to start the clock from **/
 UDate fakeClock_dt = 0; /** Offset (fake time - real time) **/
-UBool fakeClock_set = FALSE; /** True if fake clock has spun up **/
+UBool fakeClock_set = false; /** True if fake clock has spun up **/
 
 static UDate getUTCtime_real() {
     struct timeval posixTime;
@@ -269,7 +269,7 @@ static UDate getUTCtime_fake() {
             fprintf(stderr,"U_DEBUG_FAKETIME was set at compile time, but U_FAKETIME_START was not set.\n"
                     "Set U_FAKETIME_START to the number of milliseconds since 1/1/1970 to set the ICU clock.\n");
         }
-        fakeClock_set = TRUE;
+        fakeClock_set = true;
     }
     umtx_unlock(&fakeClockMutex);
 
@@ -905,7 +905,7 @@ static UBool compareBinaryFiles(const char* defaultTZFileName, const char* TZFil
     int32_t sizeFileRead;
     int32_t sizeFileToRead;
     char bufferFile[MAX_READ_SIZE];
-    UBool result = TRUE;
+    UBool result = true;
 
     if (tzInfo->defaultTZFilePtr == NULL) {
         tzInfo->defaultTZFilePtr = fopen(defaultTZFileName, "r");
@@ -925,7 +925,7 @@ static UBool compareBinaryFiles(const char* defaultTZFileName, const char* TZFil
         sizeFileLeft = sizeFile;
 
         if (sizeFile != tzInfo->defaultTZFileSize) {
-            result = FALSE;
+            result = false;
         } else {
             /* Store the data from the files in separate buffers and
              * compare each byte to determine equality.
@@ -942,7 +942,7 @@ static UBool compareBinaryFiles(const char* defaultTZFileName, const char* TZFil
 
                 sizeFileRead = fread(bufferFile, 1, sizeFileToRead, file);
                 if (memcmp(tzInfo->defaultTZBuffer + tzInfo->defaultTZPosition, bufferFile, sizeFileRead) != 0) {
-                    result = FALSE;
+                    result = false;
                     break;
                 }
                 sizeFileLeft -= sizeFileRead;
@@ -950,7 +950,7 @@ static UBool compareBinaryFiles(const char* defaultTZFileName, const char* TZFil
             }
         }
     } else {
-        result = FALSE;
+        result = false;
     }
 
     if (file != NULL) {
@@ -1189,7 +1189,7 @@ uprv_tzname(int n)
                 tzInfo->defaultTZBuffer = NULL;
                 tzInfo->defaultTZFileSize = 0;
                 tzInfo->defaultTZFilePtr = NULL;
-                tzInfo->defaultTZstatus = FALSE;
+                tzInfo->defaultTZstatus = false;
                 tzInfo->defaultTZPosition = 0;
 
                 gTimeZoneBufferPtr = searchForTZFile(TZZONEINFO, tzInfo);
@@ -1260,10 +1260,10 @@ uprv_tzname(int n)
 
 /* Get and set the ICU data directory --------------------------------------- */
 
-static icu::UInitOnce gDataDirInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gDataDirInitOnce {};
 static char *gDataDirectory = NULL;
 
-UInitOnce gTimeZoneFilesInitOnce = U_INITONCE_INITIALIZER;
+UInitOnce gTimeZoneFilesInitOnce {};
 static CharString *gTimeZoneFilesDirectory = NULL;
 
 #if U_POSIX_LOCALE || U_PLATFORM_USES_ONLY_WIN32_API
@@ -1295,7 +1295,7 @@ static UBool U_CALLCONV putil_cleanup(void)
         gCorrectedPOSIXLocaleHeapAllocated = false;
     }
 #endif
-    return TRUE;
+    return true;
 }
 
 /*
@@ -1344,16 +1344,16 @@ U_CAPI UBool U_EXPORT2
 uprv_pathIsAbsolute(const char *path)
 {
   if(!path || !*path) {
-    return FALSE;
+    return false;
   }
 
   if(*path == U_FILE_SEP_CHAR) {
-    return TRUE;
+    return true;
   }
 
 #if (U_FILE_SEP_CHAR != U_FILE_ALT_SEP_CHAR)
   if(*path == U_FILE_ALT_SEP_CHAR) {
-    return TRUE;
+    return true;
   }
 #endif
 
@@ -1361,11 +1361,11 @@ uprv_pathIsAbsolute(const char *path)
   if( (((path[0] >= 'A') && (path[0] <= 'Z')) ||
        ((path[0] >= 'a') && (path[0] <= 'z'))) &&
       path[1] == ':' ) {
-    return TRUE;
+    return true;
   }
 #endif
 
-  return FALSE;
+  return false;
 }
 
 /* Backup setting of ICU_DATA_DIR_PREFIX_ENV_VAR
@@ -1402,12 +1402,12 @@ static BOOL U_CALLCONV getIcuDataDirectoryUnderWindowsDirectory(char* directoryB
             if ((windowsPathUtf8Len + UPRV_LENGTHOF(ICU_DATA_DIR_WINDOWS)) < bufferLength) {
                 uprv_strcpy(directoryBuffer, windowsPathUtf8);
                 uprv_strcat(directoryBuffer, ICU_DATA_DIR_WINDOWS);
-                return TRUE;
+                return true;
             }
         }
     }
 
-    return FALSE;
+    return false;
 }
 #endif
 
diff --git a/deps/icu-small/source/common/rbbi.cpp b/deps/icu-small/source/common/rbbi.cpp
index cae8d154b3..2769263894 100644
--- a/deps/icu-small/source/common/rbbi.cpp
+++ b/deps/icu-small/source/common/rbbi.cpp
@@ -39,7 +39,7 @@
 #include "uvectr32.h"
 
 #ifdef RBBI_DEBUG
-static UBool gTrace = FALSE;
+static UBool gTrace = false;
 #endif
 
 U_NAMESPACE_BEGIN
@@ -267,7 +267,7 @@ RuleBasedBreakIterator::operator=(const RuleBasedBreakIterator& that) {
     }
     // TODO: clone fLanguageBreakEngines from "that"
     UErrorCode status = U_ZERO_ERROR;
-    utext_clone(&fText, &that.fText, FALSE, TRUE, &status);
+    utext_clone(&fText, &that.fText, false, true, &status);
 
     if (fCharIter != &fSCharIter) {
         delete fCharIter;
@@ -354,13 +354,13 @@ void RuleBasedBreakIterator::init(UErrorCode &status) {
     }
 
 #ifdef RBBI_DEBUG
-    static UBool debugInitDone = FALSE;
-    if (debugInitDone == FALSE) {
+    static UBool debugInitDone = false;
+    if (debugInitDone == false) {
         char *debugEnv = getenv("U_RBBIDEBUG");
         if (debugEnv && uprv_strstr(debugEnv, "trace")) {
-            gTrace = TRUE;
+            gTrace = true;
         }
-        debugInitDone = TRUE;
+        debugInitDone = true;
     }
 #endif
 }
@@ -439,7 +439,7 @@ void RuleBasedBreakIterator::setText(UText *ut, UErrorCode &status) {
     }
     fBreakCache->reset();
     fDictionaryCache->reset();
-    utext_clone(&fText, ut, FALSE, TRUE, &status);
+    utext_clone(&fText, ut, false, true, &status);
 
     // Set up a dummy CharacterIterator to be returned if anyone
     //   calls getText().  With input from UText, there is no reasonable
@@ -460,7 +460,7 @@ void RuleBasedBreakIterator::setText(UText *ut, UErrorCode &status) {
 
 
 UText *RuleBasedBreakIterator::getUText(UText *fillIn, UErrorCode &status) const {
-    UText *result = utext_clone(fillIn, &fText, FALSE, TRUE, &status);
+    UText *result = utext_clone(fillIn, &fText, false, true, &status);
     return result;
 }
 
@@ -548,7 +548,7 @@ RuleBasedBreakIterator &RuleBasedBreakIterator::refreshInputText(UText *input, U
     }
     int64_t pos = utext_getNativeIndex(&fText);
     //  Shallow read-only clone of the new UText into the existing input UText
-    utext_clone(&fText, input, FALSE, TRUE, &status);
+    utext_clone(&fText, input, false, true, &status);
     if (U_FAILURE(status)) {
         return *this;
     }
@@ -696,7 +696,7 @@ UBool RuleBasedBreakIterator::isBoundary(int32_t offset) {
     // out-of-range indexes are never boundary positions
     if (offset < 0) {
         first();       // For side effects on current position, tag values.
-        return FALSE;
+        return false;
     }
 
     // Adjust offset to be on a code point boundary and not beyond the end of the text.
@@ -713,9 +713,9 @@ UBool RuleBasedBreakIterator::isBoundary(int32_t offset) {
     }
 
     if (result && adjustedOffset < offset && utext_char32At(&fText, offset) == U_SENTINEL) {
-        // Original offset is beyond the end of the text. Return FALSE, it's not a boundary,
+        // Original offset is beyond the end of the text. Return false, it's not a boundary,
         // but the iteration position remains set to the end of the text, which is a boundary.
-        return FALSE;
+        return false;
     }
     if (!result) {
         // Not on a boundary. isBoundary() must leave iterator on the following boundary.
@@ -838,7 +838,7 @@ int32_t RuleBasedBreakIterator::handleNext() {
     result          = initialPosition;
     c               = UTEXT_NEXT32(&fText);
     if (c==U_SENTINEL) {
-        fDone = TRUE;
+        fDone = true;
         return UBRK_DONE;
     }
 
@@ -1153,8 +1153,8 @@ U_NAMESPACE_END
 
 static icu::UStack *gLanguageBreakFactories = nullptr;
 static const icu::UnicodeString *gEmptyString = nullptr;
-static icu::UInitOnce gLanguageBreakFactoriesInitOnce = U_INITONCE_INITIALIZER;
-static icu::UInitOnce gRBBIInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gLanguageBreakFactoriesInitOnce {};
+static icu::UInitOnce gRBBIInitOnce {};
 
 /**
  * Release all static memory held by breakiterator.
@@ -1167,7 +1167,7 @@ UBool U_CALLCONV rbbi_cleanup(void) {
     gEmptyString = nullptr;
     gLanguageBreakFactoriesInitOnce.reset();
     gRBBIInitOnce.reset();
-    return TRUE;
+    return true;
 }
 U_CDECL_END
 
diff --git a/deps/icu-small/source/common/rbbi_cache.cpp b/deps/icu-small/source/common/rbbi_cache.cpp
index 26d82df781..45e02528cf 100644
--- a/deps/icu-small/source/common/rbbi_cache.cpp
+++ b/deps/icu-small/source/common/rbbi_cache.cpp
@@ -45,7 +45,7 @@ void RuleBasedBreakIterator::DictionaryCache::reset() {
 UBool RuleBasedBreakIterator::DictionaryCache::following(int32_t fromPos, int32_t *result, int32_t *statusIndex) {
     if (fromPos >= fLimit || fromPos < fStart) {
         fPositionInCache = -1;
-        return FALSE;
+        return false;
     }
 
     // Sequential iteration, move from previous boundary to the following
@@ -55,13 +55,13 @@ UBool RuleBasedBreakIterator::DictionaryCache::following(int32_t fromPos, int32_
         ++fPositionInCache;
         if (fPositionInCache >= fBreaks.size()) {
             fPositionInCache = -1;
-            return FALSE;
+            return false;
         }
         r = fBreaks.elementAti(fPositionInCache);
         U_ASSERT(r > fromPos);
         *result = r;
         *statusIndex = fOtherRuleStatusIndex;
-        return TRUE;
+        return true;
     }
 
     // Random indexing. Linear search for the boundary following the given position.
@@ -71,7 +71,7 @@ UBool RuleBasedBreakIterator::DictionaryCache::following(int32_t fromPos, int32_
         if (r > fromPos) {
             *result = r;
             *statusIndex = fOtherRuleStatusIndex;
-            return TRUE;
+            return true;
         }
     }
     UPRV_UNREACHABLE_EXIT;
@@ -81,7 +81,7 @@ UBool RuleBasedBreakIterator::DictionaryCache::following(int32_t fromPos, int32_
 UBool RuleBasedBreakIterator::DictionaryCache::preceding(int32_t fromPos, int32_t *result, int32_t *statusIndex) {
     if (fromPos <= fStart || fromPos > fLimit) {
         fPositionInCache = -1;
-        return FALSE;
+        return false;
     }
 
     if (fromPos == fLimit) {
@@ -98,12 +98,12 @@ UBool RuleBasedBreakIterator::DictionaryCache::preceding(int32_t fromPos, int32_
         U_ASSERT(r < fromPos);
         *result = r;
         *statusIndex = ( r== fStart) ? fFirstRuleStatusIndex : fOtherRuleStatusIndex;
-        return TRUE;
+        return true;
     }
 
     if (fPositionInCache == 0) {
         fPositionInCache = -1;
-        return FALSE;
+        return false;
     }
 
     for (fPositionInCache = fBreaks.size()-1; fPositionInCache >= 0; --fPositionInCache) {
@@ -111,7 +111,7 @@ UBool RuleBasedBreakIterator::DictionaryCache::preceding(int32_t fromPos, int32_
         if (r < fromPos) {
             *result = r;
             *statusIndex = ( r == fStart) ? fFirstRuleStatusIndex : fOtherRuleStatusIndex;
-            return TRUE;
+            return true;
         }
     }
     UPRV_UNREACHABLE_EXIT;
@@ -227,7 +227,7 @@ void RuleBasedBreakIterator::BreakCache::reset(int32_t pos, int32_t ruleStatus)
 int32_t  RuleBasedBreakIterator::BreakCache::current() {
     fBI->fPosition = fTextIdx;
     fBI->fRuleStatusIndex = fStatuses[fBufIdx];
-    fBI->fDone = FALSE;
+    fBI->fDone = false;
     return fTextIdx;
 }
 
@@ -302,18 +302,18 @@ void RuleBasedBreakIterator::BreakCache::previous(UErrorCode &status) {
 
 UBool RuleBasedBreakIterator::BreakCache::seek(int32_t pos) {
     if (pos < fBoundaries[fStartBufIdx] || pos > fBoundaries[fEndBufIdx]) {
-        return FALSE;
+        return false;
     }
     if (pos == fBoundaries[fStartBufIdx]) {
         // Common case: seek(0), from BreakIterator::first()
         fBufIdx = fStartBufIdx;
         fTextIdx = fBoundaries[fBufIdx];
-        return TRUE;
+        return true;
     }
     if (pos == fBoundaries[fEndBufIdx]) {
         fBufIdx = fEndBufIdx;
         fTextIdx = fBoundaries[fBufIdx];
-        return TRUE;
+        return true;
     }
 
     int32_t min = fStartBufIdx;
@@ -331,51 +331,97 @@ UBool RuleBasedBreakIterator::BreakCache::seek(int32_t pos) {
     fBufIdx = modChunkSize(max - 1);
     fTextIdx = fBoundaries[fBufIdx];
     U_ASSERT(fTextIdx <= pos);
-    return TRUE;
+    return true;
 }
 
 
 UBool RuleBasedBreakIterator::BreakCache::populateNear(int32_t position, UErrorCode &status) {
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
     U_ASSERT(position < fBoundaries[fStartBufIdx] || position > fBoundaries[fEndBufIdx]);
 
-    // Find a boundary somewhere in the vicinity of the requested position.
-    // Depending on the safe rules and the text data, it could be either before, at, or after
-    // the requested position.
-
+    // Add boundaries to the cache near the specified position.
+    // The given position need not be a boundary itself.
+    // The input position must be within the range of the text, and
+    // on a code point boundary.
+    // If the requested position is a break boundary, leave the iteration
+    // position on it.
+    // If the requested position is not a boundary, leave the iteration
+    // position on the preceding boundary and include both the
+    // preceding and following boundaries in the cache.
+    // Additional boundaries, either preceding or following, may be added
+    // to the cache as a side effect.
 
     // If the requested position is not near already cached positions, clear the existing cache,
     // find a near-by boundary and begin new cache contents there.
 
-    if ((position < fBoundaries[fStartBufIdx] - 15) || position > (fBoundaries[fEndBufIdx] + 15)) {
-        int32_t aBoundary = 0;
-        int32_t ruleStatusIndex = 0;
-        if (position > 20) {
-            int32_t backupPos = fBI->handleSafePrevious(position);
-
-            if (backupPos > 0) {
-                // Advance to the boundary following the backup position.
-                // There is a complication: the safe reverse rules identify pairs of code points
-                // that are safe. If advancing from the safe point moves forwards by less than
-                // two code points, we need to advance one more time to ensure that the boundary
-                // is good, including a correct rules status value.
-                //
-                fBI->fPosition = backupPos;
-                aBoundary = fBI->handleNext();
-                if (aBoundary <= backupPos + 4) {
-                    // +4 is a quick test for possibly having advanced only one codepoint.
-                    // Four being the length of the longest potential code point, a supplementary in UTF-8
-                    utext_setNativeIndex(&fBI->fText, aBoundary);
-                    if (backupPos == utext_getPreviousNativeIndex(&fBI->fText)) {
-                        // The initial handleNext() only advanced by a single code point. Go again.
-                        aBoundary = fBI->handleNext();   // Safe rules identify safe pairs.
-                    }
+    // Threshold for a text position to be considered near to existing cache contents.
+    // TODO: See issue ICU-22024 "perf tuning of Cache needed."
+    //       This value is subject to change. See the ticket for more details.
+    static constexpr int32_t CACHE_NEAR = 15;
+
+    int32_t aBoundary = -1;
+    int32_t ruleStatusIndex = 0;
+    bool retainCache = false;
+    if ((position > fBoundaries[fStartBufIdx] - CACHE_NEAR) && position < (fBoundaries[fEndBufIdx] + CACHE_NEAR)) {
+        // Requested position is near the existing cache. Retain it.
+        retainCache = true;
+    } else if (position <= CACHE_NEAR) {
+        // Requested position is near the start of the text. Fill cache from start, skipping
+        // the need to find a safe point.
+        retainCache = false;
+        aBoundary = 0;
+    } else {
+        // Requested position is not near the existing cache.
+        // Find a safe point to refill the cache from.
+        int32_t backupPos = fBI->handleSafePrevious(position);
+
+        if (fBoundaries[fEndBufIdx] < position && fBoundaries[fEndBufIdx] >= (backupPos - CACHE_NEAR)) {
+            // The requested position is beyond the end of the existing cache, but the
+            // reverse rules produced a position near or before the cached region.
+            // Retain the existing cache, and fill from the end of it.
+            retainCache = true;
+        } else if (backupPos < CACHE_NEAR) {
+            // The safe reverse rules moved us to near the start of text.
+            // Take that (index 0) as the backup boundary, avoiding the complication
+            // (in the following block) of moving forward from the safe point to a known boundary.
+            //
+            // Retain the cache if it begins not too far from the requested position.
+            aBoundary = 0;
+            retainCache = (fBoundaries[fStartBufIdx] <= (position + CACHE_NEAR));
+        } else {
+            // The safe reverse rules produced a position that is neither near the existing
+            // cache, nor near the start of text.
+            // Advance to the boundary following.
+            // There is a complication: the safe reverse rules identify pairs of code points
+            // that are safe. If advancing from the safe point moves forwards by less than
+            // two code points, we need to advance one more time to ensure that the boundary
+            // is good, including a correct rules status value.
+            retainCache = false;
+            fBI->fPosition = backupPos;
+            aBoundary = fBI->handleNext();
+            if (aBoundary != UBRK_DONE && aBoundary <= backupPos + 4) {
+                // +4 is a quick test for possibly having advanced only one codepoint.
+                // Four being the length of the longest potential code point, a supplementary in UTF-8
+                utext_setNativeIndex(&fBI->fText, aBoundary);
+                if (backupPos == utext_getPreviousNativeIndex(&fBI->fText)) {
+                    // The initial handleNext() only advanced by a single code point. Go again.
+                    aBoundary = fBI->handleNext();   // Safe rules identify safe pairs.
                 }
-                ruleStatusIndex = fBI->fRuleStatusIndex;
             }
+            if (aBoundary == UBRK_DONE) {
+                // Note (Andy Heninger): I don't think this condition can occur, but it's hard
+                // to prove that it can't. We ran off the end of the string looking a boundary
+                // following a safe point; choose the end of the string as that boundary.
+                aBoundary = utext_nativeLength(&fBI->fText);
+            }
+            ruleStatusIndex = fBI->fRuleStatusIndex;
         }
+    }
+
+    if (!retainCache) {
+        U_ASSERT(aBoundary != -1);
         reset(aBoundary, ruleStatusIndex);        // Reset cache to hold aBoundary as a single starting point.
     }
 
@@ -430,13 +476,13 @@ UBool RuleBasedBreakIterator::BreakCache::populateFollowing() {
 
     if (fBI->fDictionaryCache->following(fromPosition, &pos, &ruleStatusIdx)) {
         addFollowing(pos, ruleStatusIdx, UpdateCachePosition);
-        return TRUE;
+        return true;
     }
 
     fBI->fPosition = fromPosition;
     pos = fBI->handleNext();
     if (pos == UBRK_DONE) {
-        return FALSE;
+        return false;
     }
 
     ruleStatusIdx = fBI->fRuleStatusIndex;
@@ -446,7 +492,7 @@ UBool RuleBasedBreakIterator::BreakCache::populateFollowing() {
         fBI->fDictionaryCache->populateDictionary(fromPosition, pos, fromRuleStatusIdx, ruleStatusIdx);
         if (fBI->fDictionaryCache->following(fromPosition, &pos, &ruleStatusIdx)) {
             addFollowing(pos, ruleStatusIdx, UpdateCachePosition);
-            return TRUE;
+            return true;
             // TODO: may want to move a sizable chunk of dictionary cache to break cache at this point.
             //       But be careful with interactions with populateNear().
         }
@@ -469,18 +515,18 @@ UBool RuleBasedBreakIterator::BreakCache::populateFollowing() {
         addFollowing(pos, fBI->fRuleStatusIndex, RetainCachePosition);
     }
 
-    return TRUE;
+    return true;
 }
 
 
 UBool RuleBasedBreakIterator::BreakCache::populatePreceding(UErrorCode &status) {
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
 
     int32_t fromPosition = fBoundaries[fStartBufIdx];
     if (fromPosition == 0) {
-        return FALSE;
+        return false;
     }
 
     int32_t position = 0;
@@ -488,7 +534,7 @@ UBool RuleBasedBreakIterator::BreakCache::populatePreceding(UErrorCode &status)
 
     if (fBI->fDictionaryCache->preceding(fromPosition, &position, &positionStatusIdx)) {
         addPreceding(position, positionStatusIdx, UpdateCachePosition);
-        return TRUE;
+        return true;
     }
 
     int32_t backupPosition = fromPosition;
@@ -542,7 +588,7 @@ UBool RuleBasedBreakIterator::BreakCache::populatePreceding(UErrorCode &status)
             break;
         }
 
-        UBool segmentHandledByDictionary = FALSE;
+        UBool segmentHandledByDictionary = false;
         if (fBI->fDictionaryCharCount != 0) {
             // Segment from the rules includes dictionary characters.
             // Subdivide it, with subdivided results going into the dictionary cache.
@@ -569,12 +615,12 @@ UBool RuleBasedBreakIterator::BreakCache::populatePreceding(UErrorCode &status)
     } while (position < fromPosition);
 
     // Move boundaries from the side buffer to the main circular buffer.
-    UBool success = FALSE;
+    UBool success = false;
     if (!fSideBuffer.isEmpty()) {
         positionStatusIdx = fSideBuffer.popi();
         position = fSideBuffer.popi();
         addPreceding(position, positionStatusIdx, UpdateCachePosition);
-        success = TRUE;
+        success = true;
     }
 
     while (!fSideBuffer.isEmpty()) {
diff --git a/deps/icu-small/source/common/rbbicst.pl b/deps/icu-small/source/common/rbbicst.pl
index 1a01386c7c..65907b0f63 100755
--- a/deps/icu-small/source/common/rbbicst.pl
+++ b/deps/icu-small/source/common/rbbicst.pl
@@ -111,9 +111,9 @@ line_loop: while (<>) {
     #
     # do the 'n' flag
     #
-    $state_flag[$num_states] = $javaOutput? "false" : "FALSE";
+    $state_flag[$num_states] = "false";
     if ($fields[0] eq "n") {
-        $state_flag[$num_states] = $javaOutput? "true": "TRUE";
+        $state_flag[$num_states] = "true";
         shift @fields;
     }
 
@@ -403,7 +403,7 @@ else
     # emit the state transition table
     #
     print "static const struct RBBIRuleTableEl gRuleParseStateTable[] = {\n";
-    print "    {doNOP, 0, 0, 0, TRUE}\n";    # State 0 is a dummy.  Real states start with index = 1.
+    print "    {doNOP, 0, 0, 0, true}\n";    # State 0 is a dummy.  Real states start with index = 1.
     for ($state=1; $state < $num_states; $state++) {
         print "    , {$state_func_name[$state],";
         if ($state_literal_chars[$state] ne "") {
diff --git a/deps/icu-small/source/common/rbbidata.cpp b/deps/icu-small/source/common/rbbidata.cpp
index 6338ed3ed8..f50fc458a5 100644
--- a/deps/icu-small/source/common/rbbidata.cpp
+++ b/deps/icu-small/source/common/rbbidata.cpp
@@ -38,7 +38,7 @@ RBBIDataWrapper::RBBIDataWrapper(const RBBIDataHeader *data, UErrorCode &status)
 RBBIDataWrapper::RBBIDataWrapper(const RBBIDataHeader *data, enum EDontAdopt, UErrorCode &status) {
     init0();
     init(data, status);
-    fDontFreeData = TRUE;
+    fDontFreeData = true;
 }
 
 RBBIDataWrapper::RBBIDataWrapper(UDataMemory* udm, UErrorCode &status) {
@@ -86,7 +86,7 @@ void RBBIDataWrapper::init0() {
     fTrie         = NULL;
     fUDataMem     = NULL;
     fRefCount     = 0;
-    fDontFreeData = TRUE;
+    fDontFreeData = true;
 }
 
 void RBBIDataWrapper::init(const RBBIDataHeader *data, UErrorCode &status) {
@@ -102,7 +102,7 @@ void RBBIDataWrapper::init(const RBBIDataHeader *data, UErrorCode &status) {
     //       that is no longer supported.  At that time fFormatVersion was
     //       an int32_t field, rather than an array of 4 bytes.
 
-    fDontFreeData = FALSE;
+    fDontFreeData = false;
     if (data->fFTableLen != 0) {
         fForwardTable = (RBBIStateTable *)((char *)data + fHeader->fFTable);
     }
diff --git a/deps/icu-small/source/common/rbbinode.cpp b/deps/icu-small/source/common/rbbinode.cpp
index 27bcd8f8fe..da5937cafd 100644
--- a/deps/icu-small/source/common/rbbinode.cpp
+++ b/deps/icu-small/source/common/rbbinode.cpp
@@ -58,10 +58,10 @@ RBBINode::RBBINode(NodeType t) : UMemory() {
     fInputSet     = NULL;
     fFirstPos     = 0;
     fLastPos      = 0;
-    fNullable     = FALSE;
-    fLookAheadEnd = FALSE;
-    fRuleRoot     = FALSE;
-    fChainIn      = FALSE;
+    fNullable     = false;
+    fLookAheadEnd = false;
+    fRuleRoot     = false;
+    fChainIn      = false;
     fVal          = 0;
     fPrecedence   = precZero;
 
@@ -92,7 +92,7 @@ RBBINode::RBBINode(const RBBINode &other) : UMemory(other) {
     fLastPos     = other.fLastPos;
     fNullable    = other.fNullable;
     fVal         = other.fVal;
-    fRuleRoot    = FALSE;
+    fRuleRoot    = false;
     fChainIn     = other.fChainIn;
     UErrorCode     status = U_ZERO_ERROR;
     fFirstPosSet = new UVector(status);   // TODO - get a real status from somewhere
@@ -355,11 +355,11 @@ void RBBINode::printTree(const RBBINode *node, UBool printHeading) {
         // Unconditionally dump children of all other node types.
         if (node->fType != varRef) {
             if (node->fLeftChild != NULL) {
-                printTree(node->fLeftChild, FALSE);
+                printTree(node->fLeftChild, false);
             }
             
             if (node->fRightChild != NULL) {
-                printTree(node->fRightChild, FALSE);
+                printTree(node->fRightChild, false);
             }
         }
     }
diff --git a/deps/icu-small/source/common/rbbirb.cpp b/deps/icu-small/source/common/rbbirb.cpp
index e5c250dfe4..a9d76f2482 100644
--- a/deps/icu-small/source/common/rbbirb.cpp
+++ b/deps/icu-small/source/common/rbbirb.cpp
@@ -65,9 +65,9 @@ RBBIRuleBuilder::RBBIRuleBuilder(const UnicodeString   &rules,
     fDefaultTree        = &fForwardTree;
     fForwardTable       = NULL;
     fRuleStatusVals     = NULL;
-    fChainRules         = FALSE;
-    fLBCMNoChain        = FALSE;
-    fLookAheadHardBreak = FALSE;
+    fChainRules         = false;
+    fLBCMNoChain        = false;
+    fLookAheadHardBreak = false;
     fUSetNodes          = NULL;
     fRuleStatusVals     = NULL;
     fScanner            = NULL;
diff --git a/deps/icu-small/source/common/rbbirb.h b/deps/icu-small/source/common/rbbirb.h
index 11dbf343ec..d983a184b6 100644
--- a/deps/icu-small/source/common/rbbirb.h
+++ b/deps/icu-small/source/common/rbbirb.h
@@ -54,8 +54,8 @@ public:                                       //   of these structs for each ent
     ~RBBISymbolTableEntry();
 
 private:
-    RBBISymbolTableEntry(const RBBISymbolTableEntry &other); // forbid copying of this class
-    RBBISymbolTableEntry &operator=(const RBBISymbolTableEntry &other); // forbid copying of this class
+    RBBISymbolTableEntry(const RBBISymbolTableEntry &other) = delete; // forbid copying of this class
+    RBBISymbolTableEntry &operator=(const RBBISymbolTableEntry &other) = delete; // forbid copying of this class
 };
 
 
@@ -177,8 +177,8 @@ public:
     RBBIDataHeader                *flattenData();    // Create the flattened (runtime format)
                                                      // data tables..
 private:
-    RBBIRuleBuilder(const RBBIRuleBuilder &other); // forbid copying of this class
-    RBBIRuleBuilder &operator=(const RBBIRuleBuilder &other); // forbid copying of this class
+    RBBIRuleBuilder(const RBBIRuleBuilder &other) = delete; // forbid copying of this class
+    RBBIRuleBuilder &operator=(const RBBIRuleBuilder &other) = delete; // forbid copying of this class
 };
 
 
diff --git a/deps/icu-small/source/common/rbbirpt.h b/deps/icu-small/source/common/rbbirpt.h
index 586953c90c..ca1bcf45dc 100644
--- a/deps/icu-small/source/common/rbbirpt.h
+++ b/deps/icu-small/source/common/rbbirpt.h
@@ -79,110 +79,110 @@ struct RBBIRuleTableEl {
 };
 
 static const struct RBBIRuleTableEl gRuleParseStateTable[] = {
-    {doNOP, 0, 0, 0, TRUE}
-    , {doExprStart, 254, 29, 9, FALSE}     //  1      start
-    , {doNOP, 132, 1,0,  TRUE}     //  2 
-    , {doNoChain, 94 /* ^ */, 12, 9, TRUE}     //  3 
-    , {doExprStart, 36 /* $ */, 88, 98, FALSE}     //  4 
-    , {doNOP, 33 /* ! */, 19,0,  TRUE}     //  5 
-    , {doNOP, 59 /* ; */, 1,0,  TRUE}     //  6 
-    , {doNOP, 252, 0,0,  FALSE}     //  7 
-    , {doExprStart, 255, 29, 9, FALSE}     //  8 
-    , {doEndOfRule, 59 /* ; */, 1,0,  TRUE}     //  9      break-rule-end
-    , {doNOP, 132, 9,0,  TRUE}     //  10 
-    , {doRuleError, 255, 103,0,  FALSE}     //  11 
-    , {doExprStart, 254, 29,0,  FALSE}     //  12      start-after-caret
-    , {doNOP, 132, 12,0,  TRUE}     //  13 
-    , {doRuleError, 94 /* ^ */, 103,0,  FALSE}     //  14 
-    , {doExprStart, 36 /* $ */, 88, 37, FALSE}     //  15 
-    , {doRuleError, 59 /* ; */, 103,0,  FALSE}     //  16 
-    , {doRuleError, 252, 103,0,  FALSE}     //  17 
-    , {doExprStart, 255, 29,0,  FALSE}     //  18 
-    , {doNOP, 33 /* ! */, 21,0,  TRUE}     //  19      rev-option
-    , {doReverseDir, 255, 28, 9, FALSE}     //  20 
-    , {doOptionStart, 130, 23,0,  TRUE}     //  21      option-scan1
-    , {doRuleError, 255, 103,0,  FALSE}     //  22 
-    , {doNOP, 129, 23,0,  TRUE}     //  23      option-scan2
-    , {doOptionEnd, 255, 25,0,  FALSE}     //  24 
-    , {doNOP, 59 /* ; */, 1,0,  TRUE}     //  25      option-scan3
-    , {doNOP, 132, 25,0,  TRUE}     //  26 
-    , {doRuleError, 255, 103,0,  FALSE}     //  27 
-    , {doExprStart, 255, 29, 9, FALSE}     //  28      reverse-rule
-    , {doRuleChar, 254, 38,0,  TRUE}     //  29      term
-    , {doNOP, 132, 29,0,  TRUE}     //  30 
-    , {doRuleChar, 131, 38,0,  TRUE}     //  31 
-    , {doNOP, 91 /* [ */, 94, 38, FALSE}     //  32 
-    , {doLParen, 40 /* ( */, 29, 38, TRUE}     //  33 
-    , {doNOP, 36 /* $ */, 88, 37, FALSE}     //  34 
-    , {doDotAny, 46 /* . */, 38,0,  TRUE}     //  35 
-    , {doRuleError, 255, 103,0,  FALSE}     //  36 
-    , {doCheckVarDef, 255, 38,0,  FALSE}     //  37      term-var-ref
-    , {doNOP, 132, 38,0,  TRUE}     //  38      expr-mod
-    , {doUnaryOpStar, 42 /* * */, 43,0,  TRUE}     //  39 
-    , {doUnaryOpPlus, 43 /* + */, 43,0,  TRUE}     //  40 
-    , {doUnaryOpQuestion, 63 /* ? */, 43,0,  TRUE}     //  41 
-    , {doNOP, 255, 43,0,  FALSE}     //  42 
-    , {doExprCatOperator, 254, 29,0,  FALSE}     //  43      expr-cont
-    , {doNOP, 132, 43,0,  TRUE}     //  44 
-    , {doExprCatOperator, 131, 29,0,  FALSE}     //  45 
-    , {doExprCatOperator, 91 /* [ */, 29,0,  FALSE}     //  46 
-    , {doExprCatOperator, 40 /* ( */, 29,0,  FALSE}     //  47 
-    , {doExprCatOperator, 36 /* $ */, 29,0,  FALSE}     //  48 
-    , {doExprCatOperator, 46 /* . */, 29,0,  FALSE}     //  49 
-    , {doExprCatOperator, 47 /* / */, 55,0,  FALSE}     //  50 
-    , {doExprCatOperator, 123 /* { */, 67,0,  TRUE}     //  51 
-    , {doExprOrOperator, 124 /* | */, 29,0,  TRUE}     //  52 
-    , {doExprRParen, 41 /* ) */, 255,0,  TRUE}     //  53 
-    , {doExprFinished, 255, 255,0,  FALSE}     //  54 
-    , {doSlash, 47 /* / */, 57,0,  TRUE}     //  55      look-ahead
-    , {doNOP, 255, 103,0,  FALSE}     //  56 
-    , {doExprCatOperator, 254, 29,0,  FALSE}     //  57      expr-cont-no-slash
-    , {doNOP, 132, 43,0,  TRUE}     //  58 
-    , {doExprCatOperator, 131, 29,0,  FALSE}     //  59 
-    , {doExprCatOperator, 91 /* [ */, 29,0,  FALSE}     //  60 
-    , {doExprCatOperator, 40 /* ( */, 29,0,  FALSE}     //  61 
-    , {doExprCatOperator, 36 /* $ */, 29,0,  FALSE}     //  62 
-    , {doExprCatOperator, 46 /* . */, 29,0,  FALSE}     //  63 
-    , {doExprOrOperator, 124 /* | */, 29,0,  TRUE}     //  64 
-    , {doExprRParen, 41 /* ) */, 255,0,  TRUE}     //  65 
-    , {doExprFinished, 255, 255,0,  FALSE}     //  66 
-    , {doNOP, 132, 67,0,  TRUE}     //  67      tag-open
-    , {doStartTagValue, 128, 70,0,  FALSE}     //  68 
-    , {doTagExpectedError, 255, 103,0,  FALSE}     //  69 
-    , {doNOP, 132, 74,0,  TRUE}     //  70      tag-value
-    , {doNOP, 125 /* } */, 74,0,  FALSE}     //  71 
-    , {doTagDigit, 128, 70,0,  TRUE}     //  72 
-    , {doTagExpectedError, 255, 103,0,  FALSE}     //  73 
-    , {doNOP, 132, 74,0,  TRUE}     //  74      tag-close
-    , {doTagValue, 125 /* } */, 77,0,  TRUE}     //  75 
-    , {doTagExpectedError, 255, 103,0,  FALSE}     //  76 
-    , {doExprCatOperator, 254, 29,0,  FALSE}     //  77      expr-cont-no-tag
-    , {doNOP, 132, 77,0,  TRUE}     //  78 
-    , {doExprCatOperator, 131, 29,0,  FALSE}     //  79 
-    , {doExprCatOperator, 91 /* [ */, 29,0,  FALSE}     //  80 
-    , {doExprCatOperator, 40 /* ( */, 29,0,  FALSE}     //  81 
-    , {doExprCatOperator, 36 /* $ */, 29,0,  FALSE}     //  82 
-    , {doExprCatOperator, 46 /* . */, 29,0,  FALSE}     //  83 
-    , {doExprCatOperator, 47 /* / */, 55,0,  FALSE}     //  84 
-    , {doExprOrOperator, 124 /* | */, 29,0,  TRUE}     //  85 
-    , {doExprRParen, 41 /* ) */, 255,0,  TRUE}     //  86 
-    , {doExprFinished, 255, 255,0,  FALSE}     //  87 
-    , {doStartVariableName, 36 /* $ */, 90,0,  TRUE}     //  88      scan-var-name
-    , {doNOP, 255, 103,0,  FALSE}     //  89 
-    , {doNOP, 130, 92,0,  TRUE}     //  90      scan-var-start
-    , {doVariableNameExpectedErr, 255, 103,0,  FALSE}     //  91 
-    , {doNOP, 129, 92,0,  TRUE}     //  92      scan-var-body
-    , {doEndVariableName, 255, 255,0,  FALSE}     //  93 
-    , {doScanUnicodeSet, 91 /* [ */, 255,0,  TRUE}     //  94      scan-unicode-set
-    , {doScanUnicodeSet, 112 /* p */, 255,0,  TRUE}     //  95 
-    , {doScanUnicodeSet, 80 /* P */, 255,0,  TRUE}     //  96 
-    , {doNOP, 255, 103,0,  FALSE}     //  97 
-    , {doNOP, 132, 98,0,  TRUE}     //  98      assign-or-rule
-    , {doStartAssign, 61 /* = */, 29, 101, TRUE}     //  99 
-    , {doNOP, 255, 37, 9, FALSE}     //  100 
-    , {doEndAssign, 59 /* ; */, 1,0,  TRUE}     //  101      assign-end
-    , {doRuleErrorAssignExpr, 255, 103,0,  FALSE}     //  102 
-    , {doExit, 255, 103,0,  TRUE}     //  103      errorDeath
+    {doNOP, 0, 0, 0, true}
+    , {doExprStart, 254, 29, 9, false}     //  1      start
+    , {doNOP, 132, 1,0,  true}     //  2 
+    , {doNoChain, 94 /* ^ */, 12, 9, true}     //  3 
+    , {doExprStart, 36 /* $ */, 88, 98, false}     //  4 
+    , {doNOP, 33 /* ! */, 19,0,  true}     //  5 
+    , {doNOP, 59 /* ; */, 1,0,  true}     //  6 
+    , {doNOP, 252, 0,0,  false}     //  7 
+    , {doExprStart, 255, 29, 9, false}     //  8 
+    , {doEndOfRule, 59 /* ; */, 1,0,  true}     //  9      break-rule-end
+    , {doNOP, 132, 9,0,  true}     //  10 
+    , {doRuleError, 255, 103,0,  false}     //  11 
+    , {doExprStart, 254, 29,0,  false}     //  12      start-after-caret
+    , {doNOP, 132, 12,0,  true}     //  13 
+    , {doRuleError, 94 /* ^ */, 103,0,  false}     //  14 
+    , {doExprStart, 36 /* $ */, 88, 37, false}     //  15 
+    , {doRuleError, 59 /* ; */, 103,0,  false}     //  16 
+    , {doRuleError, 252, 103,0,  false}     //  17 
+    , {doExprStart, 255, 29,0,  false}     //  18 
+    , {doNOP, 33 /* ! */, 21,0,  true}     //  19      rev-option
+    , {doReverseDir, 255, 28, 9, false}     //  20 
+    , {doOptionStart, 130, 23,0,  true}     //  21      option-scan1
+    , {doRuleError, 255, 103,0,  false}     //  22 
+    , {doNOP, 129, 23,0,  true}     //  23      option-scan2
+    , {doOptionEnd, 255, 25,0,  false}     //  24 
+    , {doNOP, 59 /* ; */, 1,0,  true}     //  25      option-scan3
+    , {doNOP, 132, 25,0,  true}     //  26 
+    , {doRuleError, 255, 103,0,  false}     //  27 
+    , {doExprStart, 255, 29, 9, false}     //  28      reverse-rule
+    , {doRuleChar, 254, 38,0,  true}     //  29      term
+    , {doNOP, 132, 29,0,  true}     //  30 
+    , {doRuleChar, 131, 38,0,  true}     //  31 
+    , {doNOP, 91 /* [ */, 94, 38, false}     //  32 
+    , {doLParen, 40 /* ( */, 29, 38, true}     //  33 
+    , {doNOP, 36 /* $ */, 88, 37, false}     //  34 
+    , {doDotAny, 46 /* . */, 38,0,  true}     //  35 
+    , {doRuleError, 255, 103,0,  false}     //  36 
+    , {doCheckVarDef, 255, 38,0,  false}     //  37      term-var-ref
+    , {doNOP, 132, 38,0,  true}     //  38      expr-mod
+    , {doUnaryOpStar, 42 /* * */, 43,0,  true}     //  39 
+    , {doUnaryOpPlus, 43 /* + */, 43,0,  true}     //  40 
+    , {doUnaryOpQuestion, 63 /* ? */, 43,0,  true}     //  41 
+    , {doNOP, 255, 43,0,  false}     //  42 
+    , {doExprCatOperator, 254, 29,0,  false}     //  43      expr-cont
+    , {doNOP, 132, 43,0,  true}     //  44 
+    , {doExprCatOperator, 131, 29,0,  false}     //  45 
+    , {doExprCatOperator, 91 /* [ */, 29,0,  false}     //  46 
+    , {doExprCatOperator, 40 /* ( */, 29,0,  false}     //  47 
+    , {doExprCatOperator, 36 /* $ */, 29,0,  false}     //  48 
+    , {doExprCatOperator, 46 /* . */, 29,0,  false}     //  49 
+    , {doExprCatOperator, 47 /* / */, 55,0,  false}     //  50 
+    , {doExprCatOperator, 123 /* { */, 67,0,  true}     //  51 
+    , {doExprOrOperator, 124 /* | */, 29,0,  true}     //  52 
+    , {doExprRParen, 41 /* ) */, 255,0,  true}     //  53 
+    , {doExprFinished, 255, 255,0,  false}     //  54 
+    , {doSlash, 47 /* / */, 57,0,  true}     //  55      look-ahead
+    , {doNOP, 255, 103,0,  false}     //  56 
+    , {doExprCatOperator, 254, 29,0,  false}     //  57      expr-cont-no-slash
+    , {doNOP, 132, 43,0,  true}     //  58 
+    , {doExprCatOperator, 131, 29,0,  false}     //  59 
+    , {doExprCatOperator, 91 /* [ */, 29,0,  false}     //  60 
+    , {doExprCatOperator, 40 /* ( */, 29,0,  false}     //  61 
+    , {doExprCatOperator, 36 /* $ */, 29,0,  false}     //  62 
+    , {doExprCatOperator, 46 /* . */, 29,0,  false}     //  63 
+    , {doExprOrOperator, 124 /* | */, 29,0,  true}     //  64 
+    , {doExprRParen, 41 /* ) */, 255,0,  true}     //  65 
+    , {doExprFinished, 255, 255,0,  false}     //  66 
+    , {doNOP, 132, 67,0,  true}     //  67      tag-open
+    , {doStartTagValue, 128, 70,0,  false}     //  68 
+    , {doTagExpectedError, 255, 103,0,  false}     //  69 
+    , {doNOP, 132, 74,0,  true}     //  70      tag-value
+    , {doNOP, 125 /* } */, 74,0,  false}     //  71 
+    , {doTagDigit, 128, 70,0,  true}     //  72 
+    , {doTagExpectedError, 255, 103,0,  false}     //  73 
+    , {doNOP, 132, 74,0,  true}     //  74      tag-close
+    , {doTagValue, 125 /* } */, 77,0,  true}     //  75 
+    , {doTagExpectedError, 255, 103,0,  false}     //  76 
+    , {doExprCatOperator, 254, 29,0,  false}     //  77      expr-cont-no-tag
+    , {doNOP, 132, 77,0,  true}     //  78 
+    , {doExprCatOperator, 131, 29,0,  false}     //  79 
+    , {doExprCatOperator, 91 /* [ */, 29,0,  false}     //  80 
+    , {doExprCatOperator, 40 /* ( */, 29,0,  false}     //  81 
+    , {doExprCatOperator, 36 /* $ */, 29,0,  false}     //  82 
+    , {doExprCatOperator, 46 /* . */, 29,0,  false}     //  83 
+    , {doExprCatOperator, 47 /* / */, 55,0,  false}     //  84 
+    , {doExprOrOperator, 124 /* | */, 29,0,  true}     //  85 
+    , {doExprRParen, 41 /* ) */, 255,0,  true}     //  86 
+    , {doExprFinished, 255, 255,0,  false}     //  87 
+    , {doStartVariableName, 36 /* $ */, 90,0,  true}     //  88      scan-var-name
+    , {doNOP, 255, 103,0,  false}     //  89 
+    , {doNOP, 130, 92,0,  true}     //  90      scan-var-start
+    , {doVariableNameExpectedErr, 255, 103,0,  false}     //  91 
+    , {doNOP, 129, 92,0,  true}     //  92      scan-var-body
+    , {doEndVariableName, 255, 255,0,  false}     //  93 
+    , {doScanUnicodeSet, 91 /* [ */, 255,0,  true}     //  94      scan-unicode-set
+    , {doScanUnicodeSet, 112 /* p */, 255,0,  true}     //  95 
+    , {doScanUnicodeSet, 80 /* P */, 255,0,  true}     //  96 
+    , {doNOP, 255, 103,0,  false}     //  97 
+    , {doNOP, 132, 98,0,  true}     //  98      assign-or-rule
+    , {doStartAssign, 61 /* = */, 29, 101, true}     //  99 
+    , {doNOP, 255, 37, 9, false}     //  100 
+    , {doEndAssign, 59 /* ; */, 1,0,  true}     //  101      assign-end
+    , {doRuleErrorAssignExpr, 255, 103,0,  false}     //  102 
+    , {doExit, 255, 103,0,  true}     //  103      errorDeath
  };
 #ifdef RBBI_DEBUG
 static const char * const RBBIRuleStateNames[] = {    0,
diff --git a/deps/icu-small/source/common/rbbiscan.cpp b/deps/icu-small/source/common/rbbiscan.cpp
index 1304f7e37e..92cf77664f 100644
--- a/deps/icu-small/source/common/rbbiscan.cpp
+++ b/deps/icu-small/source/common/rbbiscan.cpp
@@ -92,7 +92,7 @@ RBBIRuleScanner::RBBIRuleScanner(RBBIRuleBuilder *rb)
     fRB                 = rb;
     fScanIndex          = 0;
     fNextIndex          = 0;
-    fQuoteMode          = FALSE;
+    fQuoteMode          = false;
     fLineNum            = 1;
     fCharNum            = 0;
     fLastChar           = 0;
@@ -103,9 +103,9 @@ RBBIRuleScanner::RBBIRuleScanner(RBBIRuleBuilder *rb)
     fNodeStack[0]       = NULL;
     fNodeStackPtr       = 0;
 
-    fReverseRule        = FALSE;
-    fLookAheadRule      = FALSE;
-    fNoChainInRule      = FALSE;
+    fReverseRule        = false;
+    fLookAheadRule      = false;
+    fNoChainInRule      = false;
 
     fSymbolTable        = NULL;
     fSetTable           = NULL;
@@ -201,7 +201,7 @@ UBool RBBIRuleScanner::doParseActions(int32_t action)
 {
     RBBINode *n       = NULL;
 
-    UBool   returnVal = TRUE;
+    UBool   returnVal = true;
 
     switch (action) {
 
@@ -213,7 +213,7 @@ UBool RBBIRuleScanner::doParseActions(int32_t action)
 
     case doNoChain:
         // Scanned a '^' while on the rule start state.
-        fNoChainInRule = TRUE;
+        fNoChainInRule = true;
         break;
 
 
@@ -345,7 +345,7 @@ UBool RBBIRuleScanner::doParseActions(int32_t action)
             catNode->fRightChild      = endNode;
             fNodeStack[fNodeStackPtr] = catNode;
             endNode->fVal             = fRuleNum;
-            endNode->fLookAheadEnd    = TRUE;
+            endNode->fLookAheadEnd    = true;
             thisRule                  = catNode;
 
             // TODO: Disable chaining out of look-ahead (hard break) rules.
@@ -354,13 +354,13 @@ UBool RBBIRuleScanner::doParseActions(int32_t action)
         }
 
         // Mark this node as being the root of a rule.
-        thisRule->fRuleRoot = TRUE;
+        thisRule->fRuleRoot = true;
 
         // Flag if chaining into this rule is wanted.
         //    
         if (fRB->fChainRules &&         // If rule chaining is enabled globally via !!chain
                 !fNoChainInRule) {      //     and no '^' chain-in inhibit was on this rule
-            thisRule->fChainIn = TRUE;
+            thisRule->fChainIn = true;
         }
 
 
@@ -398,9 +398,9 @@ UBool RBBIRuleScanner::doParseActions(int32_t action)
             // Just move its parse tree from the stack to *destRules.
             *destRules = fNodeStack[fNodeStackPtr];
         }
-        fReverseRule   = FALSE;   // in preparation for the next rule.
-        fLookAheadRule = FALSE;
-        fNoChainInRule = FALSE;
+        fReverseRule   = false;   // in preparation for the next rule.
+        fLookAheadRule = false;
+        fNoChainInRule = false;
         fNodeStackPtr  = 0;
         }
         break;
@@ -408,7 +408,7 @@ UBool RBBIRuleScanner::doParseActions(int32_t action)
 
     case doRuleError:
         error(U_BRK_RULE_SYNTAX);
-        returnVal = FALSE;
+        returnVal = false;
         break;
 
 
@@ -484,7 +484,7 @@ UBool RBBIRuleScanner::doParseActions(int32_t action)
             if (U_FAILURE(*fRB->fStatus)) {
                 break;
             }
-            findSetFor(UnicodeString(TRUE, kAny, 3), n);
+            findSetFor(UnicodeString(true, kAny, 3), n);
             n->fFirstPos = fScanIndex;
             n->fLastPos  = fNextIndex;
             fRB->fRules.extractBetween(n->fFirstPos, n->fLastPos, n->fText);
@@ -501,7 +501,7 @@ UBool RBBIRuleScanner::doParseActions(int32_t action)
         n->fFirstPos = fScanIndex;
         n->fLastPos  = fNextIndex;
         fRB->fRules.extractBetween(n->fFirstPos, n->fLastPos, n->fText);
-        fLookAheadRule = TRUE;
+        fLookAheadRule = true;
         break;
 
 
@@ -534,7 +534,7 @@ UBool RBBIRuleScanner::doParseActions(int32_t action)
 
     case doTagExpectedError:
         error(U_BRK_MALFORMED_RULE_TAG);
-        returnVal = FALSE;
+        returnVal = false;
         break;
 
     case doOptionStart:
@@ -546,9 +546,9 @@ UBool RBBIRuleScanner::doParseActions(int32_t action)
         {
             UnicodeString opt(fRB->fRules, fOptionStart, fScanIndex-fOptionStart);
             if (opt == UNICODE_STRING("chain", 5)) {
-                fRB->fChainRules = TRUE;
+                fRB->fChainRules = true;
             } else if (opt == UNICODE_STRING("LBCMNoChain", 11)) {
-                fRB->fLBCMNoChain = TRUE;
+                fRB->fLBCMNoChain = true;
             } else if (opt == UNICODE_STRING("forward", 7)) {
                 fRB->fDefaultTree   = &fRB->fForwardTree;
             } else if (opt == UNICODE_STRING("reverse", 7)) {
@@ -558,7 +558,7 @@ UBool RBBIRuleScanner::doParseActions(int32_t action)
             } else if (opt == UNICODE_STRING("safe_reverse", 12)) {
                 fRB->fDefaultTree   = &fRB->fSafeRevTree;
             } else if (opt == UNICODE_STRING("lookAheadHardBreak", 18)) {
-                fRB->fLookAheadHardBreak = TRUE;
+                fRB->fLookAheadHardBreak = true;
             } else if (opt == UNICODE_STRING("quoted_literals_only", 20)) {
                 fRuleSets[kRuleSet_rule_char-128].clear();
             } else if (opt == UNICODE_STRING("unquoted_literals",  17)) {
@@ -570,7 +570,7 @@ UBool RBBIRuleScanner::doParseActions(int32_t action)
         break;
 
     case doReverseDir:
-        fReverseRule = TRUE;
+        fReverseRule = true;
         break;
 
     case doStartVariableName:
@@ -600,7 +600,7 @@ UBool RBBIRuleScanner::doParseActions(int32_t action)
         n = fNodeStack[fNodeStackPtr];
         if (n->fLeftChild == NULL) {
             error(U_BRK_UNDEFINED_VARIABLE);
-            returnVal = FALSE;
+            returnVal = false;
         }
         break;
 
@@ -609,11 +609,11 @@ UBool RBBIRuleScanner::doParseActions(int32_t action)
 
     case doRuleErrorAssignExpr:
         error(U_BRK_ASSIGN_ERROR);
-        returnVal = FALSE;
+        returnVal = false;
         break;
 
     case doExit:
-        returnVal = FALSE;
+        returnVal = false;
         break;
 
     case doScanUnicodeSet:
@@ -622,7 +622,7 @@ UBool RBBIRuleScanner::doParseActions(int32_t action)
 
     default:
         error(U_BRK_INTERNAL_ERROR);
-        returnVal = FALSE;
+        returnVal = false;
         break;
     }
     return returnVal && U_SUCCESS(*fRB->fStatus);
@@ -872,7 +872,7 @@ UChar32  RBBIRuleScanner::nextCharLL() {
         fCharNum=0;
         if (fQuoteMode) {
             error(U_BRK_NEW_LINE_IN_QUOTED_STRING);
-            fQuoteMode = FALSE;
+            fQuoteMode = false;
         }
     }
     else {
@@ -901,7 +901,7 @@ void RBBIRuleScanner::nextChar(RBBIRuleChar &c) {
 
     fScanIndex = fNextIndex;
     c.fChar    = nextCharLL();
-    c.fEscaped = FALSE;
+    c.fEscaped = false;
 
     //
     //  check for '' sequence.
@@ -910,7 +910,7 @@ void RBBIRuleScanner::nextChar(RBBIRuleChar &c) {
     if (c.fChar == chApos) {
         if (fRB->fRules.char32At(fNextIndex) == chApos) {
             c.fChar    = nextCharLL();        // get nextChar officially so character counts
-            c.fEscaped = TRUE;                //   stay correct.
+            c.fEscaped = true;                //   stay correct.
         }
         else
         {
@@ -918,18 +918,18 @@ void RBBIRuleScanner::nextChar(RBBIRuleChar &c) {
             //   Toggle quoting mode.
             //   Return either '('  or ')', because quotes cause a grouping of the quoted text.
             fQuoteMode = !fQuoteMode;
-            if (fQuoteMode == TRUE) {
+            if (fQuoteMode == true) {
                 c.fChar = chLParen;
             } else {
                 c.fChar = chRParen;
             }
-            c.fEscaped = FALSE;      // The paren that we return is not escaped.
+            c.fEscaped = false;      // The paren that we return is not escaped.
             return;
         }
     }
 
     if (fQuoteMode) {
-        c.fEscaped = TRUE;
+        c.fEscaped = true;
     }
     else
     {
@@ -963,7 +963,7 @@ void RBBIRuleScanner::nextChar(RBBIRuleChar &c) {
         //  Use UnicodeString::unescapeAt() to handle them.
         //
         if (c.fChar == chBackSlash) {
-            c.fEscaped = TRUE;
+            c.fEscaped = true;
             int32_t startX = fNextIndex;
             c.fChar = fRB->fRules.unescapeAt(fNextIndex);
             if (fNextIndex == startX) {
@@ -1032,7 +1032,7 @@ void RBBIRuleScanner::parse() {
             #ifdef RBBI_DEBUG
                 if (fRB->fDebugEnv && uprv_strstr(fRB->fDebugEnv, "scan")) { RBBIDebugPrintf("."); fflush(stdout);}
             #endif
-            if (tableEl->fCharClass < 127 && fC.fEscaped == FALSE &&   tableEl->fCharClass == fC.fChar) {
+            if (tableEl->fCharClass < 127 && fC.fEscaped == false &&   tableEl->fCharClass == fC.fChar) {
                 // Table row specified an individual character, not a set, and
                 //   the input character is not escaped, and
                 //   the input character matched it.
@@ -1057,7 +1057,7 @@ void RBBIRuleScanner::parse() {
             }
 
             if (tableEl->fCharClass >= 128 && tableEl->fCharClass < 240 &&   // Table specs a char class &&
-                fC.fEscaped == FALSE &&                                      //   char is not escaped &&
+                fC.fEscaped == false &&                                      //   char is not escaped &&
                 fC.fChar != (UChar32)-1) {                                   //   char is not EOF
                 U_ASSERT((tableEl->fCharClass-128) < UPRV_LENGTHOF(fRuleSets));
                 if (fRuleSets[tableEl->fCharClass-128].contains(fC.fChar)) {
@@ -1076,7 +1076,7 @@ void RBBIRuleScanner::parse() {
         // We've found the row of the state table that matches the current input
         //   character from the rules string.
         // Perform any action specified  by this row in the state table.
-        if (doParseActions((int32_t)tableEl->fAction) == FALSE) {
+        if (doParseActions((int32_t)tableEl->fAction) == false) {
             // Break out of the state machine loop if the
             //   the action signalled some kind of error, or
             //   the action was to exit, occurs on normal end-of-rules-input.
@@ -1133,13 +1133,13 @@ void RBBIRuleScanner::parse() {
     if (fRB->fDebugEnv && uprv_strstr(fRB->fDebugEnv, "symbols")) {fSymbolTable->rbbiSymtablePrint();}
     if (fRB->fDebugEnv && uprv_strstr(fRB->fDebugEnv, "ptree")) {
         RBBIDebugPrintf("Completed Forward Rules Parse Tree...\n");
-        RBBINode::printTree(fRB->fForwardTree, TRUE);
+        RBBINode::printTree(fRB->fForwardTree, true);
         RBBIDebugPrintf("\nCompleted Reverse Rules Parse Tree...\n");
-        RBBINode::printTree(fRB->fReverseTree, TRUE);
+        RBBINode::printTree(fRB->fReverseTree, true);
         RBBIDebugPrintf("\nCompleted Safe Point Forward Rules Parse Tree...\n");
-        RBBINode::printTree(fRB->fSafeFwdTree, TRUE);
+        RBBINode::printTree(fRB->fSafeFwdTree, true);
         RBBIDebugPrintf("\nCompleted Safe Point Reverse Rules Parse Tree...\n");
-        RBBINode::printTree(fRB->fSafeRevTree, TRUE);
+        RBBINode::printTree(fRB->fSafeRevTree, true);
     }
 #endif
 }
@@ -1154,7 +1154,7 @@ void RBBIRuleScanner::parse() {
 void RBBIRuleScanner::printNodeStack(const char *title) {
     int i;
     RBBIDebugPrintf("%s.  Dumping node stack...\n", title);
-    for (i=fNodeStackPtr; i>0; i--) {RBBINode::printTree(fNodeStack[i], TRUE);}
+    for (i=fNodeStackPtr; i>0; i--) {RBBINode::printTree(fNodeStack[i], true);}
 }
 #endif
 
diff --git a/deps/icu-small/source/common/rbbiscan.h b/deps/icu-small/source/common/rbbiscan.h
index 33fdf03354..bf3203880b 100644
--- a/deps/icu-small/source/common/rbbiscan.h
+++ b/deps/icu-small/source/common/rbbiscan.h
@@ -158,8 +158,8 @@ private:
     UnicodeSet *gRuleSet_name_char;
     UnicodeSet *gRuleSet_name_start_char;
 
-    RBBIRuleScanner(const RBBIRuleScanner &other); // forbid copying of this class
-    RBBIRuleScanner &operator=(const RBBIRuleScanner &other); // forbid copying of this class
+    RBBIRuleScanner(const RBBIRuleScanner &other) = delete; // forbid copying of this class
+    RBBIRuleScanner &operator=(const RBBIRuleScanner &other) = delete; // forbid copying of this class
 };
 
 U_NAMESPACE_END
diff --git a/deps/icu-small/source/common/rbbisetb.cpp b/deps/icu-small/source/common/rbbisetb.cpp
index 29faeb8c45..11c47156d6 100644
--- a/deps/icu-small/source/common/rbbisetb.cpp
+++ b/deps/icu-small/source/common/rbbisetb.cpp
@@ -261,7 +261,7 @@ void RBBISetBuilder::buildRanges() {
         }
         if (inputSet->contains(bofString)) {
             addValToSet(usetNode, 2);
-            fSawBOF = TRUE;
+            fSawBOF = true;
         }
     }
 
@@ -569,7 +569,7 @@ void RBBISetBuilder::printSets() {
         RBBI_DEBUG_printUnicodeString(usetNode->fText);
         RBBIDebugPrintf("\n");
         if (usetNode->fLeftChild != NULL) {
-            RBBINode::printTree(usetNode->fLeftChild, TRUE);
+            RBBINode::printTree(usetNode->fLeftChild, true);
         }
     }
     RBBIDebugPrintf("\n");
diff --git a/deps/icu-small/source/common/rbbisetb.h b/deps/icu-small/source/common/rbbisetb.h
index 6409a4ea57..cd09d3317a 100644
--- a/deps/icu-small/source/common/rbbisetb.h
+++ b/deps/icu-small/source/common/rbbisetb.h
@@ -134,8 +134,8 @@ private:
 
     UBool                 fSawBOF;
 
-    RBBISetBuilder(const RBBISetBuilder &other); // forbid copying of this class
-    RBBISetBuilder &operator=(const RBBISetBuilder &other); // forbid copying of this class
+    RBBISetBuilder(const RBBISetBuilder &other) = delete; // forbid copying of this class
+    RBBISetBuilder &operator=(const RBBISetBuilder &other) = delete; // forbid copying of this class
 };
 
 
diff --git a/deps/icu-small/source/common/rbbistbl.cpp b/deps/icu-small/source/common/rbbistbl.cpp
index 627ec1827c..554aeb793f 100644
--- a/deps/icu-small/source/common/rbbistbl.cpp
+++ b/deps/icu-small/source/common/rbbistbl.cpp
@@ -254,8 +254,8 @@ void RBBISymbolTable::rbbiSymtablePrint() const {
         }
         RBBISymbolTableEntry  *s   = (RBBISymbolTableEntry *)e->value.pointer;
         RBBIDebugPrintf("%s\n", CStr(s->key)());
-        RBBINode::printTree(s->val, TRUE);
-        RBBINode::printTree(s->val->fLeftChild, FALSE);
+        RBBINode::printTree(s->val, true);
+        RBBINode::printTree(s->val->fLeftChild, false);
         RBBIDebugPrintf("\n");
     }
 }
diff --git a/deps/icu-small/source/common/rbbitblb.cpp b/deps/icu-small/source/common/rbbitblb.cpp
index a495f17a87..0e3ec7999f 100644
--- a/deps/icu-small/source/common/rbbitblb.cpp
+++ b/deps/icu-small/source/common/rbbitblb.cpp
@@ -85,7 +85,7 @@ void  RBBITableBuilder::buildForwardTable() {
 #ifdef RBBI_DEBUG
     if (fRB->fDebugEnv && uprv_strstr(fRB->fDebugEnv, "ftree")) {
         RBBIDebugPuts("\nParse tree after flattening variable references.");
-        RBBINode::printTree(fTree, TRUE);
+        RBBINode::printTree(fTree, true);
     }
 #endif
 
@@ -143,7 +143,7 @@ void  RBBITableBuilder::buildForwardTable() {
 #ifdef RBBI_DEBUG
     if (fRB->fDebugEnv && uprv_strstr(fRB->fDebugEnv, "stree")) {
         RBBIDebugPuts("\nParse tree after flattening Unicode Set references.");
-        RBBINode::printTree(fTree, TRUE);
+        RBBINode::printTree(fTree, true);
     }
 #endif
 
@@ -209,14 +209,14 @@ void RBBITableBuilder::calcNullable(RBBINode *n) {
     if (n->fType == RBBINode::setRef ||
         n->fType == RBBINode::endMark ) {
         // These are non-empty leaf node types.
-        n->fNullable = FALSE;
+        n->fNullable = false;
         return;
     }
 
     if (n->fType == RBBINode::lookAhead || n->fType == RBBINode::tag) {
         // Lookahead marker node.  It's a leaf, so no recursion on children.
         // It's nullable because it does not match any literal text from the input stream.
-        n->fNullable = TRUE;
+        n->fNullable = true;
         return;
     }
 
@@ -234,10 +234,10 @@ void RBBITableBuilder::calcNullable(RBBINode *n) {
         n->fNullable = n->fLeftChild->fNullable && n->fRightChild->fNullable;
     }
     else if (n->fType == RBBINode::opStar || n->fType == RBBINode::opQuestion) {
-        n->fNullable = TRUE;
+        n->fNullable = true;
     }
     else {
-        n->fNullable = FALSE;
+        n->fNullable = false;
     }
 }
 
@@ -618,7 +618,7 @@ void RBBITableBuilder::buildStateTable() {
         for (tx=1; tx<fDStates->size(); tx++) {
             RBBIStateDescriptor *temp;
             temp = (RBBIStateDescriptor *)fDStates->elementAt(tx);
-            if (temp->fMarked == FALSE) {
+            if (temp->fMarked == false) {
                 T = temp;
                 break;
             }
@@ -628,7 +628,7 @@ void RBBITableBuilder::buildStateTable() {
         }
 
         // mark T;
-        T->fMarked = TRUE;
+        T->fMarked = true;
 
         // for each input symbol a do begin
         int32_t  a;
@@ -655,7 +655,7 @@ void RBBITableBuilder::buildStateTable() {
 
             // if U is not empty and not in DStates then
             int32_t  ux = 0;
-            UBool    UinDstates = FALSE;
+            UBool    UinDstates = false;
             if (U != NULL) {
                 U_ASSERT(U->size() > 0);
                 int  ix;
@@ -666,7 +666,7 @@ void RBBITableBuilder::buildStateTable() {
                         delete U;
                         U  = temp2->fPositions;
                         ux = ix;
-                        UinDstates = TRUE;
+                        UinDstates = true;
                         break;
                     }
                 }
@@ -1131,7 +1131,7 @@ void RBBITableBuilder::printPosSets(RBBINode *n) {
     printf("\n");
     RBBINode::printNodeHeader();
     RBBINode::printNode(n);
-    RBBIDebugPrintf("         Nullable:  %s\n", n->fNullable?"TRUE":"FALSE");
+    RBBIDebugPrintf("         Nullable:  %s\n", n->fNullable?"true":"false");
 
     RBBIDebugPrintf("         firstpos:  ");
     printSet(n->fFirstPosSet);
@@ -1773,7 +1773,7 @@ void RBBITableBuilder::printRuleStatusTable() {
 //-----------------------------------------------------------------------------
 
 RBBIStateDescriptor::RBBIStateDescriptor(int lastInputSymbol, UErrorCode *fStatus) {
-    fMarked    = FALSE;
+    fMarked    = false;
     fAccepting = 0;
     fLookAhead = 0;
     fTagsIdx   = 0;
diff --git a/deps/icu-small/source/common/rbbitblb.h b/deps/icu-small/source/common/rbbitblb.h
index 38607a819a..2ac66da11f 100644
--- a/deps/icu-small/source/common/rbbitblb.h
+++ b/deps/icu-small/source/common/rbbitblb.h
@@ -219,8 +219,8 @@ public:
     ~RBBIStateDescriptor();
 
 private:
-    RBBIStateDescriptor(const RBBIStateDescriptor &other); // forbid copying of this class
-    RBBIStateDescriptor &operator=(const RBBIStateDescriptor &other); // forbid copying of this class
+    RBBIStateDescriptor(const RBBIStateDescriptor &other) = delete; // forbid copying of this class
+    RBBIStateDescriptor &operator=(const RBBIStateDescriptor &other) = delete; // forbid copying of this class
 };
 
 
diff --git a/deps/icu-small/source/common/resbund.cpp b/deps/icu-small/source/common/resbund.cpp
index 47c0fe1c6e..8591a625f9 100644
--- a/deps/icu-small/source/common/resbund.cpp
+++ b/deps/icu-small/source/common/resbund.cpp
@@ -254,7 +254,7 @@ ResourceBundle::clone() const {
 UnicodeString ResourceBundle::getString(UErrorCode& status) const {
     int32_t len = 0;
     const UChar *r = ures_getString(fResource, &len, &status);
-    return UnicodeString(TRUE, r, len);
+    return UnicodeString(true, r, len);
 }
 
 const uint8_t *ResourceBundle::getBinary(int32_t& len, UErrorCode& status) const {
@@ -312,13 +312,13 @@ ResourceBundle ResourceBundle::getNext(UErrorCode& status) {
 UnicodeString ResourceBundle::getNextString(UErrorCode& status) {
     int32_t len = 0;
     const UChar* r = ures_getNextString(fResource, &len, 0, &status);
-    return UnicodeString(TRUE, r, len);
+    return UnicodeString(true, r, len);
 }
 
 UnicodeString ResourceBundle::getNextString(const char ** key, UErrorCode& status) {
     int32_t len = 0;
     const UChar* r = ures_getNextString(fResource, &len, key, &status);
-    return UnicodeString(TRUE, r, len);
+    return UnicodeString(true, r, len);
 }
 
 ResourceBundle ResourceBundle::get(int32_t indexR, UErrorCode& status) const {
@@ -336,7 +336,7 @@ ResourceBundle ResourceBundle::get(int32_t indexR, UErrorCode& status) const {
 UnicodeString ResourceBundle::getStringEx(int32_t indexS, UErrorCode& status) const {
     int32_t len = 0;
     const UChar* r = ures_getStringByIndex(fResource, indexS, &len, &status);
-    return UnicodeString(TRUE, r, len);
+    return UnicodeString(true, r, len);
 }
 
 ResourceBundle ResourceBundle::get(const char* key, UErrorCode& status) const {
@@ -364,7 +364,7 @@ ResourceBundle ResourceBundle::getWithFallback(const char* key, UErrorCode& stat
 UnicodeString ResourceBundle::getStringEx(const char* key, UErrorCode& status) const {
     int32_t len = 0;
     const UChar* r = ures_getStringByKey(fResource, key, &len, &status);
-    return UnicodeString(TRUE, r, len);
+    return UnicodeString(true, r, len);
 }
 
 const char*
diff --git a/deps/icu-small/source/common/resource.h b/deps/icu-small/source/common/resource.h
index 48f5b9fa6e..1483f7d6bc 100644
--- a/deps/icu-small/source/common/resource.h
+++ b/deps/icu-small/source/common/resource.h
@@ -286,8 +286,8 @@ public:
                      UErrorCode &errorCode) = 0;
 
 private:
-    ResourceSink(const ResourceSink &);  // no copy constructor
-    ResourceSink &operator=(const ResourceSink &);  // no assignment operator
+    ResourceSink(const ResourceSink &) = delete;  // no copy constructor
+    ResourceSink &operator=(const ResourceSink &) = delete;  // no assignment operator
 };
 
 U_NAMESPACE_END
diff --git a/deps/icu-small/source/common/ruleiter.cpp b/deps/icu-small/source/common/ruleiter.cpp
index 41eea23c0d..33ffd3d833 100644
--- a/deps/icu-small/source/common/ruleiter.cpp
+++ b/deps/icu-small/source/common/ruleiter.cpp
@@ -39,7 +39,7 @@ UChar32 RuleCharacterIterator::next(int32_t options, UBool& isEscaped, UErrorCod
     if (U_FAILURE(ec)) return DONE;
 
     UChar32 c = DONE;
-    isEscaped = FALSE;
+    isEscaped = false;
 
     for (;;) {
         c = _current();
@@ -75,7 +75,7 @@ UChar32 RuleCharacterIterator::next(int32_t options, UBool& isEscaped, UErrorCod
             int32_t offset = 0;
             c = lookahead(tempEscape, MAX_U_NOTATION_LEN).unescapeAt(offset);
             jumpahead(offset);
-            isEscaped = TRUE;
+            isEscaped = true;
             if (c < 0) {
                 ec = U_MALFORMED_UNICODE_ESCAPE;
                 return DONE;
diff --git a/deps/icu-small/source/common/ruleiter.h b/deps/icu-small/source/common/ruleiter.h
index 09af129784..41731407da 100644
--- a/deps/icu-small/source/common/ruleiter.h
+++ b/deps/icu-small/source/common/ruleiter.h
@@ -66,28 +66,28 @@ public:
     /**
      * Value returned when there are no more characters to iterate.
      */
-    enum { DONE = -1 };
+    static constexpr int32_t DONE = -1;
 
     /**
      * Bitmask option to enable parsing of variable names.  If (options &
      * PARSE_VARIABLES) != 0, then an embedded variable will be expanded to
      * its value.  Variables are parsed using the SymbolTable API.
      */
-    enum { PARSE_VARIABLES = 1 };
+    static constexpr int32_t PARSE_VARIABLES = 1;
 
     /**
      * Bitmask option to enable parsing of escape sequences.  If (options &
      * PARSE_ESCAPES) != 0, then an embedded escape sequence will be expanded
      * to its value.  Escapes are parsed using Utility.unescapeAt().
      */
-    enum { PARSE_ESCAPES   = 2 };
+    static constexpr int32_t PARSE_ESCAPES   = 2;
 
     /**
      * Bitmask option to enable skipping of whitespace.  If (options &
      * SKIP_WHITESPACE) != 0, then Pattern_White_Space characters will be silently
      * skipped, as if they were not present in the input.
      */
-    enum { SKIP_WHITESPACE = 4 };
+    static constexpr int32_t SKIP_WHITESPACE = 4;
 
     /**
      * Constructs an iterator over the given text, starting at the given
diff --git a/deps/icu-small/source/common/serv.cpp b/deps/icu-small/source/common/serv.cpp
index c26dbca1a9..9d8c04149c 100644
--- a/deps/icu-small/source/common/serv.cpp
+++ b/deps/icu-small/source/common/serv.cpp
@@ -64,7 +64,7 @@ ICUServiceKey::currentDescriptor(UnicodeString& result) const
 UBool 
 ICUServiceKey::fallback() 
 {
-    return FALSE;
+    return false;
 }
 
 UBool 
@@ -249,7 +249,7 @@ public:
     }
 
     /**
-    * Return TRUE if there is at least one reference to this and the
+    * Return true if there is at least one reference to this and the
     * resource has not been released.
     */
     UBool isShared() const {
@@ -454,11 +454,11 @@ ICUService::getKey(ICUServiceKey& key, UnicodeString* actualReturn, const ICUSer
 
         UnicodeString currentDescriptor;
         LocalPointer<UVector> cacheDescriptorList;
-        UBool putInCache = FALSE;
+        UBool putInCache = false;
 
         int32_t startIndex = 0;
         int32_t limit = factories->size();
-        UBool cacheResult = TRUE;
+        UBool cacheResult = true;
 
         if (factory != NULL) {
             for (int32_t i = 0; i < limit; ++i) {
@@ -472,7 +472,7 @@ ICUService::getKey(ICUServiceKey& key, UnicodeString* actualReturn, const ICUSer
                 status = U_ILLEGAL_ARGUMENT_ERROR;
                 return NULL;
             }
-            cacheResult = FALSE;
+            cacheResult = false;
         }
 
         do {
@@ -486,7 +486,7 @@ ICUService::getKey(ICUServiceKey& key, UnicodeString* actualReturn, const ICUSer
             // first test of cache failed, so we'll have to update
             // the cache if we eventually succeed-- that is, if we're 
             // going to update the cache at all.
-            putInCache = TRUE;
+            putInCache = true;
 
             int32_t index = startIndex;
             while (index < limit) {
@@ -796,7 +796,7 @@ ICUService::getDisplayNames(UVector& result,
 URegistryKey
 ICUService::registerInstance(UObject* objToAdopt, const UnicodeString& id, UErrorCode& status) 
 {
-    return registerInstance(objToAdopt, id, TRUE, status);
+    return registerInstance(objToAdopt, id, true, status);
 }
 
 URegistryKey
@@ -864,13 +864,13 @@ UBool
 ICUService::unregister(URegistryKey rkey, UErrorCode& status) 
 {
     ICUServiceFactory *factory = (ICUServiceFactory*)rkey;
-    UBool result = FALSE;
+    UBool result = false;
     if (factory != NULL && factories != NULL) {
         Mutex mutex(&lock);
 
         if (factories->removeElement(factory)) {
             clearCaches();
-            result = TRUE;
+            result = true;
         } else {
             status = U_ILLEGAL_ARGUMENT_ERROR;
             delete factory;
diff --git a/deps/icu-small/source/common/servlk.cpp b/deps/icu-small/source/common/servlk.cpp
index 538982ca36..7021806659 100644
--- a/deps/icu-small/source/common/servlk.cpp
+++ b/deps/icu-small/source/common/servlk.cpp
@@ -126,24 +126,24 @@ LocaleKey::fallback() {
         int x = _currentID.lastIndexOf(UNDERSCORE_CHAR);
         if (x != -1) {
             _currentID.remove(x); // truncate current or fallback, whichever we're pointing to
-            return TRUE;
+            return true;
         }
 
         if (!_fallbackID.isBogus()) {
             _currentID = _fallbackID;
             _fallbackID.setToBogus();
-            return TRUE;
+            return true;
         }
 
         if (_currentID.length() > 0) {
             _currentID.remove(0); // completely truncate
-            return TRUE;
+            return true;
         }
 
         _currentID.setToBogus();
     }
 
-    return FALSE;
+    return false;
 }
 
 UBool
diff --git a/deps/icu-small/source/common/servlkf.cpp b/deps/icu-small/source/common/servlkf.cpp
index 84f2347cdd..7ccb0c72aa 100644
--- a/deps/icu-small/source/common/servlkf.cpp
+++ b/deps/icu-small/source/common/servlkf.cpp
@@ -65,7 +65,7 @@ LocaleKeyFactory::handlesKey(const ICUServiceKey& key, UErrorCode& status) const
         key.currentID(id);
         return supported->get(id) != NULL;
     }
-    return FALSE;
+    return false;
 }
 
 void
diff --git a/deps/icu-small/source/common/servls.cpp b/deps/icu-small/source/common/servls.cpp
index 98f0a8a12b..19481122ef 100644
--- a/deps/icu-small/source/common/servls.cpp
+++ b/deps/icu-small/source/common/servls.cpp
@@ -215,11 +215,11 @@ public:
     UBool upToDate(UErrorCode& status) const {
         if (U_SUCCESS(status)) {
             if (_timestamp == _service->getTimestamp()) {
-                return TRUE;
+                return true;
             }
             status = U_ENUM_OUT_OF_SYNC_ERROR;
         }
-        return FALSE;
+        return false;
     }
 
     virtual int32_t count(UErrorCode& status) const override {
diff --git a/deps/icu-small/source/common/sharedobject.h b/deps/icu-small/source/common/sharedobject.h
index 6ccfb27b01..6298662bba 100644
--- a/deps/icu-small/source/common/sharedobject.h
+++ b/deps/icu-small/source/common/sharedobject.h
@@ -38,8 +38,8 @@ public:
 
     virtual ~UnifiedCacheBase();
 private:
-    UnifiedCacheBase(const UnifiedCacheBase &);
-    UnifiedCacheBase &operator=(const UnifiedCacheBase &);
+    UnifiedCacheBase(const UnifiedCacheBase &) = delete;
+    UnifiedCacheBase &operator=(const UnifiedCacheBase &) = delete;
 };
 
 /**
diff --git a/deps/icu-small/source/common/simpleformatter.cpp b/deps/icu-small/source/common/simpleformatter.cpp
index f7f7aead61..01d3024cfc 100644
--- a/deps/icu-small/source/common/simpleformatter.cpp
+++ b/deps/icu-small/source/common/simpleformatter.cpp
@@ -65,7 +65,7 @@ UBool SimpleFormatter::applyPatternMinMaxArguments(
         int32_t min, int32_t max,
         UErrorCode &errorCode) {
     if (U_FAILURE(errorCode)) {
-        return FALSE;
+        return false;
     }
     // Parse consistent with MessagePattern, but
     // - support only simple numbered arguments
@@ -76,7 +76,7 @@ UBool SimpleFormatter::applyPatternMinMaxArguments(
     compiledPattern.setTo((UChar)0);
     int32_t textLength = 0;
     int32_t maxArg = -1;
-    UBool inQuote = FALSE;
+    UBool inQuote = false;
     for (int32_t i = 0; i < patternLength;) {
         UChar c = patternBuffer[i++];
         if (c == APOS) {
@@ -85,12 +85,12 @@ UBool SimpleFormatter::applyPatternMinMaxArguments(
                 ++i;
             } else if (inQuote) {
                 // skip the quote-ending apostrophe
-                inQuote = FALSE;
+                inQuote = false;
                 continue;
             } else if (c == OPEN_BRACE || c == CLOSE_BRACE) {
                 // Skip the quote-starting apostrophe, find the end of the quoted literal text.
                 ++i;
-                inQuote = TRUE;
+                inQuote = true;
             } else {
                 // The apostrophe is part of literal text.
                 c = APOS;
@@ -123,7 +123,7 @@ UBool SimpleFormatter::applyPatternMinMaxArguments(
                 }
                 if (argNumber < 0 || c != CLOSE_BRACE) {
                     errorCode = U_ILLEGAL_ARGUMENT_ERROR;
-                    return FALSE;
+                    return false;
                 }
             }
             if (argNumber > maxArg) {
@@ -149,10 +149,10 @@ UBool SimpleFormatter::applyPatternMinMaxArguments(
     int32_t argCount = maxArg + 1;
     if (argCount < min || max < argCount) {
         errorCode = U_ILLEGAL_ARGUMENT_ERROR;
-        return FALSE;
+        return false;
     }
     compiledPattern.setCharAt(0, (UChar)argCount);
-    return TRUE;
+    return true;
 }
 
 UnicodeString& SimpleFormatter::format(
@@ -192,7 +192,7 @@ UnicodeString& SimpleFormatter::formatAndAppend(
         return appendTo;
     }
     return format(compiledPattern.getBuffer(), compiledPattern.length(), values,
-                  appendTo, NULL, TRUE,
+                  appendTo, NULL, true,
                   offsets, offsetsLength, errorCode);
 }
 
@@ -241,7 +241,7 @@ UnicodeString &SimpleFormatter::formatAndReplace(
         result.remove();
     }
     return format(cp, cpLength, values,
-                  result, &resultCopy, FALSE,
+                  result, &resultCopy, false,
                   offsets, offsetsLength, errorCode);
 }
 
diff --git a/deps/icu-small/source/common/static_unicode_sets.cpp b/deps/icu-small/source/common/static_unicode_sets.cpp
index 5dab3931a7..db9432f49a 100644
--- a/deps/icu-small/source/common/static_unicode_sets.cpp
+++ b/deps/icu-small/source/common/static_unicode_sets.cpp
@@ -31,7 +31,7 @@ alignas(UnicodeSet)
 char gEmptyUnicodeSet[sizeof(UnicodeSet)];
 
 // Whether the gEmptyUnicodeSet is initialized and ready to use.
-UBool gEmptyUnicodeSetInitialized = FALSE;
+UBool gEmptyUnicodeSetInitialized = false;
 
 inline UnicodeSet* getImpl(Key key) {
     UnicodeSet* candidate = gUnicodeSets[key];
@@ -118,7 +118,7 @@ class ParseDataSink : public ResourceSink {
                         } else {
                             // Unknown class of parse lenients
                             // TODO(ICU-20428): Make ICU automatically accept new classes?
-                            U_ASSERT(FALSE);
+                            U_ASSERT(false);
                         }
                         if (U_FAILURE(status)) { return; }
                     }
@@ -129,19 +129,19 @@ class ParseDataSink : public ResourceSink {
 };
 
 
-icu::UInitOnce gNumberParseUniSetsInitOnce = U_INITONCE_INITIALIZER;
+icu::UInitOnce gNumberParseUniSetsInitOnce {};
 
 UBool U_CALLCONV cleanupNumberParseUniSets() {
     if (gEmptyUnicodeSetInitialized) {
         reinterpret_cast<UnicodeSet*>(gEmptyUnicodeSet)->~UnicodeSet();
-        gEmptyUnicodeSetInitialized = FALSE;
+        gEmptyUnicodeSetInitialized = false;
     }
     for (int32_t i = 0; i < UNISETS_KEY_COUNT; i++) {
         delete gUnicodeSets[i];
         gUnicodeSets[i] = nullptr;
     }
     gNumberParseUniSetsInitOnce.reset();
-    return TRUE;
+    return true;
 }
 
 void U_CALLCONV initNumberParseUniSets(UErrorCode& status) {
@@ -150,7 +150,7 @@ void U_CALLCONV initNumberParseUniSets(UErrorCode& status) {
     // Initialize the empty instance for well-defined fallback behavior
     new(gEmptyUnicodeSet) UnicodeSet();
     reinterpret_cast<UnicodeSet*>(gEmptyUnicodeSet)->freeze();
-    gEmptyUnicodeSetInitialized = TRUE;
+    gEmptyUnicodeSetInitialized = true;
 
     // These sets were decided after discussion with icu-design@. See tickets #13084 and #13309.
     // Zs+TAB is "horizontal whitespace" according to UTS #18 (blank property).
diff --git a/deps/icu-small/source/common/stringtriebuilder.cpp b/deps/icu-small/source/common/stringtriebuilder.cpp
index 4d52a88af7..e6670d1cb7 100644
--- a/deps/icu-small/source/common/stringtriebuilder.cpp
+++ b/deps/icu-small/source/common/stringtriebuilder.cpp
@@ -85,16 +85,16 @@ StringTrieBuilder::build(UStringTrieBuildOption buildOption, int32_t elementsLen
 // have a common prefix of length unitIndex.
 int32_t
 StringTrieBuilder::writeNode(int32_t start, int32_t limit, int32_t unitIndex) {
-    UBool hasValue=FALSE;
+    UBool hasValue=false;
     int32_t value=0;
     int32_t type;
     if(unitIndex==getElementStringLength(start)) {
         // An intermediate or final value.
         value=getElementValue(start++);
         if(start==limit) {
-            return writeValueAndFinal(value, TRUE);  // final-value node
+            return writeValueAndFinal(value, true);  // final-value node
         }
-        hasValue=TRUE;
+        hasValue=true;
     }
     // Now all [start..limit[ strings are longer than unitIndex.
     int32_t minUnit=getElementUnit(start, unitIndex);
@@ -209,7 +209,7 @@ StringTrieBuilder::makeNode(int32_t start, int32_t limit, int32_t unitIndex, UEr
     if(U_FAILURE(errorCode)) {
         return NULL;
     }
-    UBool hasValue=FALSE;
+    UBool hasValue=false;
     int32_t value=0;
     if(unitIndex==getElementStringLength(start)) {
         // An intermediate or final value.
@@ -217,7 +217,7 @@ StringTrieBuilder::makeNode(int32_t start, int32_t limit, int32_t unitIndex, UEr
         if(start==limit) {
             return registerFinalValue(value, errorCode);
         }
-        hasValue=TRUE;
+        hasValue=true;
     }
     Node *node;
     // Now all [start..limit[ strings are longer than unitIndex.
@@ -410,7 +410,7 @@ StringTrieBuilder::FinalValueNode::operator==(const Node &other) const {
 
 void
 StringTrieBuilder::FinalValueNode::write(StringTrieBuilder &builder) {
-    offset=builder.writeValueAndFinal(value, TRUE);
+    offset=builder.writeValueAndFinal(value, true);
 }
 
 bool
@@ -448,7 +448,7 @@ StringTrieBuilder::IntermediateValueNode::markRightEdgesFirst(int32_t edgeNumber
 void
 StringTrieBuilder::IntermediateValueNode::write(StringTrieBuilder &builder) {
     next->write(builder);
-    offset=builder.writeValueAndFinal(value, FALSE);
+    offset=builder.writeValueAndFinal(value, false);
 }
 
 bool
@@ -526,7 +526,7 @@ StringTrieBuilder::ListBranchNode::write(StringTrieBuilder &builder) {
     // not jump for it at all.
     unitNumber=length-1;
     if(rightEdge==NULL) {
-        builder.writeValueAndFinal(values[unitNumber], TRUE);
+        builder.writeValueAndFinal(values[unitNumber], true);
     } else {
         rightEdge->write(builder);
     }
@@ -538,12 +538,12 @@ StringTrieBuilder::ListBranchNode::write(StringTrieBuilder &builder) {
         if(equal[unitNumber]==NULL) {
             // Write the final value for the one string ending with this unit.
             value=values[unitNumber];
-            isFinal=TRUE;
+            isFinal=true;
         } else {
             // Write the delta to the start position of the sub-node.
             U_ASSERT(equal[unitNumber]->getOffset()>0);
             value=offset-equal[unitNumber]->getOffset();
-            isFinal=FALSE;
+            isFinal=false;
         }
         builder.writeValueAndFinal(value, isFinal);
         offset=builder.write(units[unitNumber]);
diff --git a/deps/icu-small/source/common/uarrsort.cpp b/deps/icu-small/source/common/uarrsort.cpp
index c17dbb2e2b..17b6964ffe 100644
--- a/deps/icu-small/source/common/uarrsort.cpp
+++ b/deps/icu-small/source/common/uarrsort.cpp
@@ -75,7 +75,7 @@ U_CAPI int32_t U_EXPORT2
 uprv_stableBinarySearch(char *array, int32_t limit, void *item, int32_t itemSize,
                         UComparator *cmp, const void *context) {
     int32_t start=0;
-    UBool found=FALSE;
+    UBool found=false;
 
     /* Binary search until we get down to a tiny sub-array. */
     while((limit-start)>=MIN_QSORT) {
@@ -90,10 +90,10 @@ uprv_stableBinarySearch(char *array, int32_t limit, void *item, int32_t itemSize
              * However, if there are many equal items, then it should be
              * faster to continue with the binary search.
              * It seems likely that we either have all unique items
-             * (where found will never become TRUE in the insertion sort)
+             * (where found will never become true in the insertion sort)
              * or potentially many duplicates.
              */
-            found=TRUE;
+            found=true;
             start=i+1;
         } else if(diff<0) {
             limit=i;
@@ -106,7 +106,7 @@ uprv_stableBinarySearch(char *array, int32_t limit, void *item, int32_t itemSize
     while(start<limit) {
         int32_t diff=cmp(context, item, array+start*itemSize);
         if(diff==0) {
-            found=TRUE;
+            found=true;
         } else if(diff<0) {
             break;
         }
diff --git a/deps/icu-small/source/common/ubidi.cpp b/deps/icu-small/source/common/ubidi.cpp
index 6d27827c50..eb40a212e1 100644
--- a/deps/icu-small/source/common/ubidi.cpp
+++ b/deps/icu-small/source/common/ubidi.cpp
@@ -149,7 +149,7 @@ ubidi_openSized(int32_t maxLength, int32_t maxRunCount, UErrorCode *pErrorCode)
         return NULL;
     }
 
-    /* reset the object, all pointers NULL, all flags FALSE, all sizes 0 */
+    /* reset the object, all pointers NULL, all flags false, all sizes 0 */
     uprv_memset(pBiDi, 0, sizeof(UBiDi));
 
     /* allocate memory for arrays as requested */
@@ -160,7 +160,7 @@ ubidi_openSized(int32_t maxLength, int32_t maxRunCount, UErrorCode *pErrorCode)
             *pErrorCode=U_MEMORY_ALLOCATION_ERROR;
         }
     } else {
-        pBiDi->mayAllocateText=TRUE;
+        pBiDi->mayAllocateText=true;
     }
 
     if(maxRunCount>0) {
@@ -171,7 +171,7 @@ ubidi_openSized(int32_t maxLength, int32_t maxRunCount, UErrorCode *pErrorCode)
             *pErrorCode=U_MEMORY_ALLOCATION_ERROR;
         }
     } else {
-        pBiDi->mayAllocateRuns=TRUE;
+        pBiDi->mayAllocateRuns=true;
     }
 
     if(U_SUCCESS(*pErrorCode)) {
@@ -184,7 +184,7 @@ ubidi_openSized(int32_t maxLength, int32_t maxRunCount, UErrorCode *pErrorCode)
 
 /*
  * We are allowed to allocate memory if memory==NULL or
- * mayAllocate==TRUE for each array that we need.
+ * mayAllocate==true for each array that we need.
  * We also try to grow memory as needed if we
  * allocate it.
  *
@@ -203,18 +203,18 @@ ubidi_getMemory(BidiMemoryForAllocation *bidiMem, int32_t *pSize, UBool mayAlloc
         /* we need to allocate memory */
         if(mayAllocate && (*pMemory=uprv_malloc(sizeNeeded))!=NULL) {
             *pSize=sizeNeeded;
-            return TRUE;
+            return true;
         } else {
-            return FALSE;
+            return false;
         }
     } else {
         if(sizeNeeded<=*pSize) {
             /* there is already enough memory */
-            return TRUE;
+            return true;
         }
         else if(!mayAllocate) {
             /* not enough memory, and we must not allocate */
-            return FALSE;
+            return false;
         } else {
             /* we try to grow */
             void *memory;
@@ -225,10 +225,10 @@ ubidi_getMemory(BidiMemoryForAllocation *bidiMem, int32_t *pSize, UBool mayAlloc
             if((memory=uprv_realloc(*pMemory, sizeNeeded))!=NULL) {
                 *pMemory=memory;
                 *pSize=sizeNeeded;
-                return TRUE;
+                return true;
             } else {
                 /* we failed to grow */
-                return FALSE;
+                return false;
             }
         }
     }
@@ -280,7 +280,7 @@ ubidi_isInverse(UBiDi *pBiDi) {
     if(pBiDi!=NULL) {
         return pBiDi->isInverse;
     } else {
-        return FALSE;
+        return false;
     }
 }
 
@@ -403,17 +403,17 @@ checkParaCount(UBiDi *pBiDi) {
     int32_t count=pBiDi->paraCount;
     if(pBiDi->paras==pBiDi->simpleParas) {
         if(count<=SIMPLE_PARAS_COUNT)
-            return TRUE;
+            return true;
         if(!getInitialParasMemory(pBiDi, SIMPLE_PARAS_COUNT * 2))
-            return FALSE;
+            return false;
         pBiDi->paras=pBiDi->parasMemory;
         uprv_memcpy(pBiDi->parasMemory, pBiDi->simpleParas, SIMPLE_PARAS_COUNT * sizeof(Para));
-        return TRUE;
+        return true;
     }
     if(!getInitialParasMemory(pBiDi, count * 2))
-        return FALSE;
+        return false;
     pBiDi->paras=pBiDi->parasMemory;
-    return TRUE;
+    return true;
 }
 
 /*
@@ -579,8 +579,8 @@ getDirProps(UBiDi *pBiDi) {
             }
             if(i<originalLength) {              /* B not last char in text */
                 pBiDi->paraCount++;
-                if(checkParaCount(pBiDi)==FALSE)    /* not enough memory for a new para entry */
-                    return FALSE;
+                if(checkParaCount(pBiDi)==false)    /* not enough memory for a new para entry */
+                    return false;
                 if(isDefaultLevel) {
                     pBiDi->paras[pBiDi->paraCount-1].level=defaultParaLevel;
                     state=SEEKING_STRONG_FOR_PARA;
@@ -636,7 +636,7 @@ getDirProps(UBiDi *pBiDi) {
     }
     pBiDi->flags=flags;
     pBiDi->lastArabicPos=lastArabicPos;
-    return TRUE;
+    return true;
 }
 
 /* determine the paragraph level at position index */
@@ -743,14 +743,14 @@ bracketProcessPDI(BracketData *bd) {
 }
 
 /* newly found opening bracket: create an openings entry */
-static UBool                            /* return TRUE if success */
+static UBool                            /* return true if success */
 bracketAddOpening(BracketData *bd, UChar match, int32_t position) {
     IsoRun *pLastIsoRun=&bd->isoRuns[bd->isoRunLast];
     Opening *pOpening;
     if(pLastIsoRun->limit>=bd->openingsCount) {  /* no available new entry */
         UBiDi *pBiDi=bd->pBiDi;
         if(!getInitialOpeningsMemory(pBiDi, pLastIsoRun->limit * 2))
-            return FALSE;
+            return false;
         if(bd->openings==bd->simpleOpenings)
             uprv_memcpy(pBiDi->openingsMemory, bd->simpleOpenings,
                         SIMPLE_OPENINGS_COUNT * sizeof(Opening));
@@ -764,7 +764,7 @@ bracketAddOpening(BracketData *bd, UChar match, int32_t position) {
     pOpening->contextPos=pLastIsoRun->contextPos;
     pOpening->flags=0;
     pLastIsoRun->limit++;
-    return TRUE;
+    return true;
 }
 
 /* change N0c1 to N0c2 when a preceding bracket is assigned the embedding level */
@@ -804,7 +804,7 @@ bracketProcessClosing(BracketData *bd, int32_t openIdx, int32_t position) {
     DirProp newProp;
     pOpening=&bd->openings[openIdx];
     direction=(UBiDiDirection)(pLastIsoRun->level&1);
-    stable=TRUE;            /* assume stable until proved otherwise */
+    stable=true;            /* assume stable until proved otherwise */
 
     /* The stable flag is set when brackets are paired and their
        level is resolved and cannot be changed by what will be
@@ -873,7 +873,7 @@ bracketProcessClosing(BracketData *bd, int32_t openIdx, int32_t position) {
 }
 
 /* handle strong characters, digits and candidates for closing brackets */
-static UBool                            /* return TRUE if success */
+static UBool                            /* return true if success */
 bracketProcessChar(BracketData *bd, int32_t position) {
     IsoRun *pLastIsoRun=&bd->isoRuns[bd->isoRunLast];
     DirProp *dirProps, dirProp, newProp;
@@ -912,7 +912,7 @@ bracketProcessChar(BracketData *bd, int32_t position) {
             }
             /* matching brackets are not overridden by LRO/RLO */
             bd->pBiDi->levels[bd->openings[idx].position]&=~UBIDI_LEVEL_OVERRIDE;
-            return TRUE;
+            return true;
         }
         /* We get here only if the ON character is not a matching closing
            bracket or it is a case of N0d */
@@ -927,14 +927,14 @@ bracketProcessChar(BracketData *bd, int32_t position) {
                create an opening entry for each synonym */
             if(match==0x232A) {     /* RIGHT-POINTING ANGLE BRACKET */
                 if(!bracketAddOpening(bd, 0x3009, position))
-                    return FALSE;
+                    return false;
             }
             else if(match==0x3009) {         /* RIGHT ANGLE BRACKET */
                 if(!bracketAddOpening(bd, 0x232A, position))
-                    return FALSE;
+                    return false;
             }
             if(!bracketAddOpening(bd, match, position))
-                return FALSE;
+                return false;
         }
     }
     level=bd->pBiDi->levels[position];
@@ -998,7 +998,7 @@ bracketProcessChar(BracketData *bd, int32_t position) {
             if(position>bd->openings[i].position)
                 bd->openings[i].flags|=flag;
     }
-    return TRUE;
+    return true;
 }
 
 /* perform (X1)..(X9) ------------------------------------------------------- */
@@ -2432,11 +2432,11 @@ setParaRunsOnly(UBiDi *pBiDi, const UChar *text, int32_t length,
      * than the original text. But we don't want the levels memory to be
      * reallocated shorter than the original length, since we need to restore
      * the levels as after the first call to ubidi_setpara() before returning.
-     * We will force mayAllocateText to FALSE before the second call to
+     * We will force mayAllocateText to false before the second call to
      * ubidi_setpara(), and will restore it afterwards.
      */
     saveMayAllocateText=pBiDi->mayAllocateText;
-    pBiDi->mayAllocateText=FALSE;
+    pBiDi->mayAllocateText=false;
     ubidi_setPara(pBiDi, visualText, visualLength, paraLevel, NULL, pErrorCode);
     pBiDi->mayAllocateText=saveMayAllocateText;
     ubidi_getRuns(pBiDi, pErrorCode);
@@ -2866,7 +2866,7 @@ ubidi_isOrderParagraphsLTR(UBiDi *pBiDi) {
     if(pBiDi!=NULL) {
         return pBiDi->orderParagraphsLTR;
     } else {
-        return FALSE;
+        return false;
     }
 }
 
diff --git a/deps/icu-small/source/common/ubidi_props.cpp b/deps/icu-small/source/common/ubidi_props.cpp
index afcc4aaf4f..3ba58f7af9 100644
--- a/deps/icu-small/source/common/ubidi_props.cpp
+++ b/deps/icu-small/source/common/ubidi_props.cpp
@@ -53,7 +53,7 @@ _enumPropertyStartsRange(const void *context, UChar32 start, UChar32 end, uint32
     /* add the start code point to the USet */
     const USetAdder *sa=(const USetAdder *)context;
     sa->add(sa->set, start);
-    return TRUE;
+    return true;
 }
 
 U_CFUNC void
diff --git a/deps/icu-small/source/common/ubidi_props_data.h b/deps/icu-small/source/common/ubidi_props_data.h
index aad919fa2e..01fcc968cb 100644
--- a/deps/icu-small/source/common/ubidi_props_data.h
+++ b/deps/icu-small/source/common/ubidi_props_data.h
@@ -9,11 +9,11 @@
 
 #ifdef INCLUDED_FROM_UBIDI_PROPS_C
 
-static const UVersionInfo ubidi_props_dataVersion={0xe,0,0,0};
+static const UVersionInfo ubidi_props_dataVersion={0xf,0,0,0};
 
-static const int32_t ubidi_props_indexes[UBIDI_IX_TOP]={0x10,0x6a98,0x64a8,0x28,0x620,0x8cc,0x10ac0,0x10d24,0,0,0,0,0,0,0,0x6702b6};
+static const int32_t ubidi_props_indexes[UBIDI_IX_TOP]={0x10,0x6bc0,0x65d0,0x28,0x620,0x8cc,0x10ac0,0x10d24,0,0,0,0,0,0,0,0x6702b6};
 
-static const uint16_t ubidi_props_trieIndex[12876]={
+static const uint16_t ubidi_props_trieIndex[13024]={
 0x387,0x38f,0x397,0x39f,0x3b7,0x3bf,0x3c7,0x3cf,0x3a7,0x3af,0x3a7,0x3af,0x3a7,0x3af,0x3a7,0x3af,
 0x3a7,0x3af,0x3a7,0x3af,0x3d5,0x3dd,0x3e5,0x3ed,0x3f5,0x3fd,0x3f9,0x401,0x409,0x411,0x40c,0x414,
 0x3a7,0x3af,0x3a7,0x3af,0x41c,0x424,0x3a7,0x3af,0x3a7,0x3af,0x3a7,0x3af,0x42a,0x432,0x43a,0x442,
@@ -185,61 +185,61 @@ static const uint16_t ubidi_props_trieIndex[12876]={
 0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x9a6,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,
 0x9ae,0x9b2,0x43c,0x43c,0x43c,0x43c,0x9c2,0x9ba,0x43c,0x9ca,0x43c,0x43c,0x9d2,0x9d8,0x43c,0x43c,
 0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x9e8,0x9e0,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,
-0x43c,0x43c,0x43c,0x9f0,0x43c,0x9f8,0x43c,0x43c,0x43c,0x9fc,0xa03,0xa09,0xa11,0xa15,0xa1d,0x43c,
-0x51b,0xa25,0xa2c,0xa33,0x41e,0xa3b,0x569,0x3a7,0x501,0xa42,0x3a7,0xa48,0x41e,0xa4d,0xa55,0x3a7,
-0x3a7,0xa5a,0x3a7,0x3a7,0x3a7,0x3a7,0x836,0xa62,0x41e,0x5a3,0x57e,0xa69,0x3a7,0x3a7,0x3a7,0x3a7,
-0x3a7,0xa25,0xa71,0x3a7,0x3a7,0xa79,0xa81,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0xa85,0xa8d,0x3a7,
-0x3a7,0xa95,0x57e,0xa9d,0x3a7,0xaa3,0x3a7,0x3a7,0x60f,0xaab,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
-0xab0,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0xab7,0xabf,0x3a7,0x3a7,0x3a7,0xac2,0x57e,0xaca,
-0xace,0xad6,0x3a7,0xadd,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
-0xae4,0x3a7,0x3a7,0xaf2,0xaec,0x3a7,0x3a7,0x3a7,0xafa,0xb02,0x3a7,0xb06,0x3a7,0x3a7,0x3a7,0x3a7,
-0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x5a5,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0xb13,0xb0e,0x3a7,
+0x43c,0x43c,0x43c,0x9f0,0x43c,0x9f8,0x4a6,0xa00,0x43c,0xa08,0xa0f,0xa15,0xa1d,0xa21,0xa29,0x43c,
+0x51b,0xa31,0xa38,0xa3f,0x41e,0xa47,0x569,0x3a7,0x501,0xa4e,0x3a7,0xa54,0x41e,0xa59,0xa61,0x3a7,
+0x3a7,0xa66,0x51b,0x3a7,0x3a7,0x3a7,0x836,0xa6e,0x41e,0x5a3,0x57e,0xa75,0x3a7,0x3a7,0x3a7,0x3a7,
+0x3a7,0xa31,0xa7d,0x3a7,0x3a7,0xa85,0xa8d,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0xa91,0xa99,0x3a7,
+0x3a7,0xaa1,0x57e,0xaa9,0x3a7,0xaaf,0x3a7,0x3a7,0x60f,0xab7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
+0xabc,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0xac3,0xacb,0x3a7,0x3a7,0x3a7,0xace,0x57e,0xad6,
+0xada,0xae2,0x3a7,0xae9,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
+0xaf0,0x3a7,0x3a7,0xafe,0xaf8,0x3a7,0x3a7,0x3a7,0xb06,0xb0e,0x3a7,0xb12,0x3a7,0x3a7,0x3a7,0x3a7,
+0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x5a5,0x41e,0x99e,0xb1a,0x3a7,0x3a7,0x3a7,0xb27,0xb22,0x3a7,
 0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
 0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
-0xb1b,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
-0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0xb22,
-0x3a7,0xb28,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
+0xb2f,0xb37,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
+0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0xb3d,
+0x3a7,0xb43,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
 0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
-0x3a7,0x3a7,0xa49,0x3a7,0xb2e,0x3a7,0x3a7,0xb36,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
+0x3a7,0x3a7,0xa55,0x3a7,0xb49,0x3a7,0x3a7,0xb51,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
 0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
-0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x535,0xb3e,0x3a7,0x3a7,
+0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x535,0xb59,0x3a7,0x3a7,
 0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
 0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
 0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
-0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3f5,0xb46,0x500,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
-0x3a7,0x3a7,0x3a7,0x3a7,0xb4e,0xb56,0xb5c,0x3a7,0xb62,0x67c,0x67c,0xb6a,0x3a7,0x3a7,0x3a7,0x3a7,
-0x3a7,0x67c,0x67c,0xb72,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
-0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0xb78,
-0x3a7,0xb7f,0x3a7,0xb7b,0x3a7,0xb82,0x3a7,0xb8a,0xb8e,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
-0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3f5,0xb96,0x3f5,0xb9d,0xba4,0xbac,0x3a7,
+0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3f5,0xb61,0x500,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
+0x3a7,0x3a7,0x3a7,0x3a7,0xb69,0xb71,0xb77,0x3a7,0xb7d,0x67c,0x67c,0xb85,0x3a7,0x3a7,0x3a7,0x3a7,
+0x3a7,0x67c,0x67c,0xb8d,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
+0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0xb93,
+0x3a7,0xb9a,0x3a7,0xb96,0x3a7,0xb9d,0x3a7,0xba5,0xba9,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
+0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3f5,0xbb1,0x3f5,0xbb8,0xbbf,0xbc7,0x3a7,
 0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
 0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
-0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0xbb4,0xbbc,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
-0x3a7,0x3a7,0xb28,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0xa75,0x3a7,
-0xbc1,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
-0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
-0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0xbc9,
-0x43c,0xbd1,0xbd1,0xbd8,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,
+0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0xbcf,0xbd7,0x3a7,0x3a7,0xa55,0x3a7,0x3a7,
+0x3a7,0x3a7,0xb43,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0xa81,0x3a7,
+0xbdc,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
+0xbe4,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
+0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0xbec,
+0x43c,0xbf4,0xbf4,0xbfb,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,
 0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x91e,0x4a6,0x4a6,0x43c,
-0x43c,0x4a6,0x4a6,0xbe0,0x43c,0x43c,0x43c,0x43c,0x43c,0x4a6,0x4a6,0x4a6,0x4a6,0x4a6,0x4a6,0x4a6,
-0xbe8,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x67c,0xbf0,0x67c,0x67c,0x67f,0xbf5,0xbf9,
-0x858,0xc01,0x3c9,0x3a7,0xc07,0x3a7,0xc0c,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x783,0x3a7,0x3a7,0x3a7,
+0x43c,0x4a6,0x4a6,0xc03,0x43c,0x43c,0x43c,0x43c,0x43c,0x4a6,0x4a6,0x4a6,0x4a6,0x4a6,0x4a6,0x4a6,
+0xc0b,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x43c,0x67c,0xc13,0x67c,0x67c,0x67f,0xc18,0xc1c,
+0x858,0xc24,0x3c9,0x3a7,0xc2a,0x3a7,0xc2f,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x783,0x3a7,0x3a7,0x3a7,
 0x3a7,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,
-0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0xc14,
-0x98f,0x67c,0x67c,0x67c,0x67f,0x67c,0x67c,0xc1c,0xc24,0xbf0,0x67c,0xc2c,0x67c,0xc34,0xc39,0x3a7,
-0x3a7,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67f,0xc41,0xc4d,0xc52,0xc5a,
-0xc49,0x67c,0x67c,0x67c,0x67c,0xc62,0x67c,0x792,0xc6a,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
+0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0xc37,
+0x98f,0x67c,0x67c,0x67c,0xc3e,0x67c,0x67c,0xc45,0xc4d,0xc13,0x67c,0xc55,0x67c,0xc5d,0xc62,0x3a7,
+0x3a7,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67c,0x67f,0xc6a,0xc73,0xc77,0xc7f,
+0xc6f,0x67c,0x67c,0x67c,0x67c,0xc87,0x67c,0x792,0xc8f,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
 0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
-0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0xc71,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
+0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0xc96,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
 0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
 0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
 0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,
-0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0xc71,0xc81,0xc79,0xc79,0xc79,0xc82,0xc82,0xc82,
-0xc82,0x3f5,0x3f5,0x3f5,0x3f5,0x3f5,0x3f5,0x3f5,0xc8a,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,
-0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,
-0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,
-0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,
-0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0xc82,0x386,0x386,0x386,0x12,0x12,0x12,0x12,
+0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0x3a7,0xc96,0xca6,0xc9e,0xc9e,0xc9e,0xca7,0xca7,0xca7,
+0xca7,0x3f5,0x3f5,0x3f5,0x3f5,0x3f5,0x3f5,0x3f5,0xcaf,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,
+0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,
+0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,
+0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,
+0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0xca7,0x386,0x386,0x386,0x12,0x12,0x12,0x12,
 0x12,0x12,0x12,0x12,0x12,8,7,8,9,7,0x12,0x12,0x12,0x12,0x12,0x12,
 0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,7,7,7,8,9,0xa,0xa,4,
 4,4,0xa,0xa,0x310a,0xf20a,0xa,3,6,3,6,6,2,2,2,2,
@@ -384,7 +384,7 @@ static const uint16_t ubidi_props_trieIndex[12876]={
 0xb1,0xb1,0xb1,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0xb1,0,0,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,
 0xb1,0,0,0,0,0,0,0,0,0,0,0,0xb1,0xb1,0xb1,0xb1,
-0xb1,0xb1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0xb1,0xb1,0xb1,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0xb1,0xb1,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0xb1,0,0xb1,0,0xb1,0x310a,0xf20a,0x310a,0xf20a,0,0,
@@ -654,6 +654,9 @@ static const uint16_t ubidi_props_trieIndex[12876]={
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,
 1,1,1,1,1,1,1,1,1,1,1,0xb1,0xb1,1,1,1,
 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,
+0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xb1,0xb1,0xb1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
 0x4d,0x4d,0x4d,0x8d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,
 0x4d,0xd,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0x4d,0x4d,0x4d,
 0x8d,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,
@@ -721,104 +724,110 @@ static const uint16_t ubidi_props_trieIndex[12876]={
 0,0,0xb1,0,0xb1,0xb1,0,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0,0xb1,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0xb1,0xb1,0,0,0,0xb1,0,0xb1,
+0,0,0,0,0,0,0,0,0xb1,0,0xb1,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,4,0xa,0xa,0xa,0xa,0xa,0xa,0xa,
 0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,4,4,4,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0xa0,0xa0,0xa0,0xa0,
-0xa0,0xa0,0xa0,0xa0,0xa0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0xb1,0xb1,0xb1,0xb1,0xb1,0,0,0,
+0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0xb1,0,0,0,
+0,0,0,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,
+0xb1,0xb1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0xb1,0xb1,0xb1,0xb1,0xb1,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0xb1,0xb1,0xb1,0xb1,
+0xb1,0xb1,0xb1,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0xb1,0xb1,0xb1,0xb1,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0xa,0,0xb1,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0xb1,0xb1,0xb1,0xb1,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0xa,0,0xb1,0,0,0,
+0,0,0,0,0xb2,0xb2,0xb2,0xb2,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0xb2,0xb2,0xb2,0xb2,0,0,0,0,
+0,0,0,0,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,
+0xb1,0xb1,0,0,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,
+0xb1,0xb1,0xb1,0xb1,0,0,0,0,0,0,0,0xb1,0xb1,0xb1,0,0,
+0,0,0,0,0,0,0,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb1,
+0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0,0,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,
-0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0,0,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,
-0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0,0,0,0,0,0,0,0xb1,
-0xb1,0xb1,0,0,0,0,0,0,0,0,0,0xb2,0xb2,0xb2,0xb2,0xb2,
-0xb2,0xb2,0xb2,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0,0,0xb1,0xb1,0xb1,
-0xb1,0xb1,0xb1,0xb1,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0xb1,0xb1,0xb1,0xb1,0,0,
+0,0,0,0,0,0,0xb1,0xb1,0xb1,0xb1,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0xa,0xa,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0xa,0xa,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0xa,0xa,0xb1,0xb1,0xb1,0xa,0,0,
+0,0,0,0,0xa,0xa,0xb1,0xb1,0xb1,0xa,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,
-0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0,
+0,0,0,0,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,
+0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0x100a,0,0,0,0,
+0,0,0,0,0,0,0,0x100a,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0x100a,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0x100a,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0x100a,0,0,0,0,
-0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,
+0,0,0,0,0,0,0,0x100a,0,0,0,0,0,0,0,0,
+0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-2,2,2,2,2,2,2,2,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,
-0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0,
-0,0,0,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,
-0xb1,0,0,0,0,0,0,0,0,0xb1,0,0,0,0,0,0,
-0,0,0,0,0xb1,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0xb1,0xb1,0xb1,0xb1,0xb1,
-0,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,
-0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0,0,0xb1,0xb1,0xb1,0xb1,0xb1,
-0xb1,0xb1,0,0xb1,0xb1,0,0xb1,0xb1,0xb1,0xb1,0xb1,0,0,0,0,0,
+2,2,2,2,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,
+0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0,0,0,0,0xb1,
+0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0,0,0,
+0,0,0,0,0,0xb1,0,0,0,0,0,0,0,0,0,0,
+0xb1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0xb1,0xb1,0xb1,0xb1,0xb1,0,0xb1,0xb1,0xb1,
+0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0xb1,0xb1,0xb1,0xb1,
+0xb1,0xb1,0xb1,0,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,
+0xb1,0xb1,0xb1,0xb1,0xb1,0,0,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0,0xb1,
+0xb1,0,0xb1,0xb1,0xb1,0xb1,0xb1,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0xb1,0xb1,0xb1,0xb1,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,
+0,0,0,0,0,0,0,0,0,0,0,0,0xb1,0xb1,0xb1,0xb1,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0xb1,0xb1,0xb1,0xb1,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,4,1,1,1,1,1,1,1,1,1,1,1,1,
-1,1,1,1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,1,1,1,1,1,
-1,1,1,1,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,
-0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,
-0x41,0x41,0x41,0x41,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xa1,1,1,1,1,
 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,
-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,
-0xa,0xa,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,
-0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0,0,0,0,
-0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,
-0xa,0xa,0xa,0,0,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,
-0xa,0xa,0xa,0xa,0,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,
-0xa,0xa,0xa,0xa,2,2,2,2,2,2,2,2,2,2,2,0xa,
-0xa,0xa,0xa,0xa,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0xa,0xa,0xa,0xa,0xa,0xa,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0xa,0,0,
+0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,1,1,1,1,1,1,1,1,1,
+0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,
+0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,
+0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xa1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,0xd,0xd,0xd,0xd,
+0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,0xd,0xd,0xd,0xd,
+0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xa,0xa,0xd,0xd,
+0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xd,0xa,0xa,0xa,0xa,
+0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0,0,0,0,0xa,0xa,0xa,0xa,
+0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0,
+0,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,
+0,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,
+2,2,2,2,2,2,2,2,2,2,2,0xa,0xa,0xa,0xa,0xa,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0xa,0xa,0xa,0xa,0xa,0xa,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0xa,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0xa,0xa,0xa,0xa,
 0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,
-0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0,0,0,0,0,0xa,0xa,0xa,
-0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,
-0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0,0,0,0,0,0,0,
-0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0,0,0,0,
-0xa,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0,0,0,0,0,0,0,0,
-0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0,0,0,0,0,0,
-0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0,0,0,0,0,0,0,0,
-0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,
-0xa,0xa,0,0,0xa,0xa,0,0,0,0,0,0,0,0,0,0,
+0xa,0xa,0xa,0xa,0,0,0,0,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,
+0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0,
+0,0,0,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,
+0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0,0,
 0,0,0,0,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,
-0xa,0xa,0,0,0xa,0xa,0xa,0xa,0xa,0,0,0,0xa,0xa,0xa,0xa,
-0xa,0,0,0,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0,0,0,0,
-0,0,0,0,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0,0,0,0,0,
+0,0,0,0,0xa,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0,0,0,0,
+0,0,0,0,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0,0,
+0,0,0,0,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0,0,0,0,
 0,0,0,0,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,
-0xa,0xa,0xa,0xa,0xa,0,0,0,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,
-0xa,0xa,0xa,0,0,0,0,0,0xa,0xa,0xa,0xa,0xa,0xa,0,0,
+0xa,0xa,0xa,0xa,0xa,0xa,0,0,0xa,0xa,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,
-0xa,0xa,0,0,0,0,0,0,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,
-0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0,0xa,0xa,0xa,0xa,
-0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,
-2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0xa,0xa,0xa,0xa,0xa,0xa,0,0,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,
+0xa,0xa,0xa,0xa,0xa,0,0,0,0,0,0,0,0xa,0xa,0xa,0xa,
+0xa,0xa,0xa,0xa,0xa,0,0,0,0,0,0,0,0xa,0xa,0xa,0xa,
+0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,
+0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0,0xa,0xa,0xa,0xa,0xa,
+0xa,0xa,0,0,0,0,0,0,0,0,0xa,0xa,0xa,0xa,0xa,0xa,
+0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0,0,0,0,0xa,0xa,0xa,0xa,
+0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0,
+0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0xa,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,
+2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0x12,0x12,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,
+0,0,0,0,0,0,0x12,0x12,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,
 0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,
-0xb2,0xb2,0xb2,0xb2,0x12,0xb2,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
+0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0x12,0xb2,0x12,0x12,0x12,0x12,0x12,0x12,
 0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
-0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,
-0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
-0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0,0,0,0
+0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0xb1,0xb1,0xb1,0xb1,
+0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0x12,0x12,0x12,0x12,
+0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0,0,0,0
 };
 
 static const uint32_t ubidi_props_mirrors[40]={
@@ -926,14 +935,14 @@ static const UBiDiProps ubidi_props_singleton={
     ubidi_props_trieIndex+3612,
     NULL,
     3612,
-    9264,
+    9412,
     0x1a0,
     0xe9c,
     0x0,
     0x0,
     0x110000,
-    0x3248,
-    NULL, 0, FALSE, FALSE, 0, NULL
+    0x32dc,
+    NULL, 0, false, false, 0, NULL
   },
   { 2,2,0,0 }
 };
diff --git a/deps/icu-small/source/common/ubidiln.cpp b/deps/icu-small/source/common/ubidiln.cpp
index fea239380a..430ece39d2 100644
--- a/deps/icu-small/source/common/ubidiln.cpp
+++ b/deps/icu-small/source/common/ubidiln.cpp
@@ -101,7 +101,7 @@ setTrailingWSStart(UBiDi *pBiDi) {
        are already set to paragraph level.
        Setting trailingWSStart to pBidi->length will avoid changing the
        level of B chars from 0 to paraLevel in ubidi_getLevels when
-       orderParagraphsLTR==TRUE.
+       orderParagraphsLTR==true.
      */
     if(dirProps[start-1]==B) {
         pBiDi->trailingWSStart=start;   /* currently == pBiDi->length */
@@ -535,7 +535,7 @@ static int32_t getRunFromLogicalIndex(UBiDi *pBiDi, int32_t logicalIndex) {
 
 /*
  * Compute the runs array from the levels array.
- * After ubidi_getRuns() returns TRUE, runCount is guaranteed to be >0
+ * After ubidi_getRuns() returns true, runCount is guaranteed to be >0
  * and the runs are reordered.
  * Odd-level runs have visualStart on their visual right edge and
  * they progress visually to the left.
@@ -551,7 +551,7 @@ ubidi_getRuns(UBiDi *pBiDi, UErrorCode*) {
      * includes the case of length==0 (handled in setPara)..
      */
     if (pBiDi->runCount>=0) {
-        return TRUE;
+        return true;
     }
 
     if(pBiDi->direction!=UBIDI_MIXED) {
@@ -608,7 +608,7 @@ ubidi_getRuns(UBiDi *pBiDi, UErrorCode*) {
             if(getRunsMemory(pBiDi, runCount)) {
                 runs=pBiDi->runsMemory;
             } else {
-                return FALSE;
+                return false;
             }
 
             /* set the runs */
@@ -703,7 +703,7 @@ ubidi_getRuns(UBiDi *pBiDi, UErrorCode*) {
         }
     }
 
-    return TRUE;
+    return true;
 }
 
 static UBool
@@ -714,7 +714,7 @@ prepareReorder(const UBiDiLevel *levels, int32_t length,
     UBiDiLevel level, minLevel, maxLevel;
 
     if(levels==NULL || length<=0) {
-        return FALSE;
+        return false;
     }
 
     /* determine minLevel and maxLevel */
@@ -723,7 +723,7 @@ prepareReorder(const UBiDiLevel *levels, int32_t length,
     for(start=length; start>0;) {
         level=levels[--start];
         if(level>UBIDI_MAX_EXPLICIT_LEVEL+1) {
-            return FALSE;
+            return false;
         }
         if(level<minLevel) {
             minLevel=level;
@@ -741,7 +741,7 @@ prepareReorder(const UBiDiLevel *levels, int32_t length,
         indexMap[start]=start;
     }
 
-    return TRUE;
+    return true;
 }
 
 /* reorder a line based on a levels array (L2) ------------------------------ */
diff --git a/deps/icu-small/source/common/ubiditransform.cpp b/deps/icu-small/source/common/ubiditransform.cpp
index d56bf1518b..24fffd9c46 100644
--- a/deps/icu-small/source/common/ubiditransform.cpp
+++ b/deps/icu-small/source/common/ubiditransform.cpp
@@ -130,7 +130,7 @@ action_resolve(UBiDiTransform *pTransform, UErrorCode *pErrorCode)
 {
     ubidi_setPara(pTransform->pBidi, pTransform->src, pTransform->srcLength,
             pTransform->pActiveScheme->baseLevel, NULL, pErrorCode);
-    return FALSE;
+    return false;
 }
 
 /**
@@ -150,7 +150,7 @@ action_reorder(UBiDiTransform *pTransform, UErrorCode *pErrorCode)
 
     *pTransform->pDestLength = pTransform->srcLength;
     pTransform->reorderingOptions = UBIDI_REORDER_DEFAULT;
-    return TRUE;
+    return true;
 }
 
 /**
@@ -166,9 +166,9 @@ static UBool
 action_setInverse(UBiDiTransform *pTransform, UErrorCode *pErrorCode)
 {
     (void)pErrorCode;
-    ubidi_setInverse(pTransform->pBidi, TRUE);
+    ubidi_setInverse(pTransform->pBidi, true);
     ubidi_setReorderingMode(pTransform->pBidi, UBIDI_REORDER_INVERSE_LIKE_DIRECT);
-    return FALSE;
+    return false;
 }
 
 /**
@@ -186,7 +186,7 @@ action_setRunsOnly(UBiDiTransform *pTransform, UErrorCode *pErrorCode)
 {
     (void)pErrorCode;
     ubidi_setReorderingMode(pTransform->pBidi, UBIDI_REORDER_RUNS_ONLY);
-    return FALSE;
+    return false;
 }
 
 /**
@@ -205,7 +205,7 @@ action_reverse(UBiDiTransform *pTransform, UErrorCode *pErrorCode)
             pTransform->dest, pTransform->destSize,
             UBIDI_REORDER_DEFAULT, pErrorCode);
     *pTransform->pDestLength = pTransform->srcLength;
-    return TRUE;
+    return true;
 }
 
 /**
@@ -274,7 +274,7 @@ static UBool
 action_shapeArabic(UBiDiTransform *pTransform, UErrorCode *pErrorCode)
 {
     if ((pTransform->letters | pTransform->digits) == 0) {
-        return FALSE;
+        return false;
     }
     if (pTransform->pActiveScheme->lettersDir == pTransform->pActiveScheme->digitsDir) {
         doShape(pTransform, pTransform->letters | pTransform->digits | pTransform->pActiveScheme->lettersDir,
@@ -288,7 +288,7 @@ action_shapeArabic(UBiDiTransform *pTransform, UErrorCode *pErrorCode)
                     pErrorCode);
         }
     }
-    return TRUE;
+    return true;
 }
 
 /**
@@ -306,11 +306,11 @@ action_mirror(UBiDiTransform *pTransform, UErrorCode *pErrorCode)
     UChar32 c;
     uint32_t i = 0, j = 0;
     if (0 == (pTransform->reorderingOptions & UBIDI_DO_MIRRORING)) {
-        return FALSE;
+        return false;
     }
     if (pTransform->destSize < pTransform->srcLength) {
         *pErrorCode = U_BUFFER_OVERFLOW_ERROR;
-        return FALSE;
+        return false;
     }
     do {
         UBool isOdd = ubidi_getLevelAt(pTransform->pBidi, i) & 1;
@@ -320,7 +320,7 @@ action_mirror(UBiDiTransform *pTransform, UErrorCode *pErrorCode)
     
     *pTransform->pDestLength = pTransform->srcLength;
     pTransform->reorderingOptions = UBIDI_REORDER_DEFAULT;
-    return TRUE;
+    return true;
 }
 
 /**
@@ -444,7 +444,7 @@ ubiditransform_transform(UBiDiTransform *pBiDiTransform,
             UErrorCode *pErrorCode)
 {
     uint32_t destLength = 0;
-    UBool textChanged = FALSE;
+    UBool textChanged = false;
     const UBiDiTransform *pOrigTransform = pBiDiTransform;
     const UBiDiAction *action = NULL;
 
@@ -503,10 +503,10 @@ ubiditransform_transform(UBiDiTransform *pBiDiTransform,
                 updateSrc(pBiDiTransform, pBiDiTransform->dest, *pBiDiTransform->pDestLength,
                         *pBiDiTransform->pDestLength, pErrorCode);
             }
-            textChanged = TRUE;
+            textChanged = true;
         }
     }
-    ubidi_setInverse(pBiDiTransform->pBidi, FALSE);
+    ubidi_setInverse(pBiDiTransform->pBidi, false);
 
     if (!textChanged && U_SUCCESS(*pErrorCode)) {
         /* Text was not changed - just copy src to dest */
diff --git a/deps/icu-small/source/common/ucase.cpp b/deps/icu-small/source/common/ucase.cpp
index 388c86b1bb..3d1750265b 100644
--- a/deps/icu-small/source/common/ucase.cpp
+++ b/deps/icu-small/source/common/ucase.cpp
@@ -40,7 +40,7 @@ _enumPropertyStartsRange(const void *context, UChar32 start, UChar32 /*end*/, ui
     /* add the start code point to the USet */
     const USetAdder *sa=(const USetAdder *)context;
     sa->add(sa->set, start);
-    return TRUE;
+    return true;
 }
 
 U_CFUNC void U_EXPORT2
@@ -354,7 +354,7 @@ ucase_addStringCaseClosure(const UChar *s, int32_t length, const USetAdder *sa)
     int32_t i, start, limit, result, unfoldRows, unfoldRowWidth, unfoldStringWidth;
 
     if(ucase_props_singleton.unfold==NULL || s==NULL) {
-        return FALSE; /* no reverse case folding data, or no string */
+        return false; /* no reverse case folding data, or no string */
     }
     if(length<=1) {
         /* the string is too short to find any match */
@@ -364,7 +364,7 @@ ucase_addStringCaseClosure(const UChar *s, int32_t length, const USetAdder *sa)
          * but this does not make much practical difference because
          * a single supplementary code point would just not be found
          */
-        return FALSE;
+        return false;
     }
 
     const uint16_t *unfold=ucase_props_singleton.unfold;
@@ -375,7 +375,7 @@ ucase_addStringCaseClosure(const UChar *s, int32_t length, const USetAdder *sa)
 
     if(length>unfoldStringWidth) {
         /* the string is too long to find any match */
-        return FALSE;
+        return false;
     }
 
     /* do a binary search for the string */
@@ -395,7 +395,7 @@ ucase_addStringCaseClosure(const UChar *s, int32_t length, const USetAdder *sa)
                 sa->add(sa->set, c);
                 ucase_addCaseClosure(c, sa);
             }
-            return TRUE;
+            return true;
         } else if(result<0) {
             limit=i;
         } else /* result>0 */ {
@@ -403,7 +403,7 @@ ucase_addStringCaseClosure(const UChar *s, int32_t length, const USetAdder *sa)
         }
     }
 
-    return FALSE; /* string not found */
+    return false; /* string not found */
 }
 
 U_NAMESPACE_BEGIN
@@ -431,7 +431,7 @@ FullCaseFoldingIterator::next(UnicodeString &full) {
     // Set "full" to the NUL-terminated string in the first unfold column.
     int32_t length=unfoldStringWidth;
     while(length>0 && p[length-1]==0) { --length; }
-    full.setTo(FALSE, p, length);
+    full.setTo(false, p, length);
     // Return the code point.
     UChar32 c;
     U16_NEXT_UNSAFE(p, rowCpIndex, c);
@@ -905,7 +905,7 @@ isFollowedByCasedLetter(UCaseContextIterator *iter, void *context, int8_t dir) {
     UChar32 c;
 
     if(iter==NULL) {
-        return FALSE;
+        return false;
     }
 
     for(/* dir!=0 sets direction */; (c=iter(context, dir))>=0; dir=0) {
@@ -913,13 +913,13 @@ isFollowedByCasedLetter(UCaseContextIterator *iter, void *context, int8_t dir) {
         if(type&4) {
             /* case-ignorable, continue with the loop */
         } else if(type!=UCASE_NONE) {
-            return TRUE; /* followed by cased letter */
+            return true; /* followed by cased letter */
         } else {
-            return FALSE; /* uncased and not case-ignorable */
+            return false; /* uncased and not case-ignorable */
         }
     }
 
-    return FALSE; /* not followed by cased letter */
+    return false; /* not followed by cased letter */
 }
 
 /* Is preceded by Soft_Dotted character with no intervening cc=230 ? */
@@ -930,19 +930,19 @@ isPrecededBySoftDotted(UCaseContextIterator *iter, void *context) {
     int8_t dir;
 
     if(iter==NULL) {
-        return FALSE;
+        return false;
     }
 
     for(dir=-1; (c=iter(context, dir))>=0; dir=0) {
         dotType=getDotType(c);
         if(dotType==UCASE_SOFT_DOTTED) {
-            return TRUE; /* preceded by TYPE_i */
+            return true; /* preceded by TYPE_i */
         } else if(dotType!=UCASE_OTHER_ACCENT) {
-            return FALSE; /* preceded by different base character (not TYPE_i), or intervening cc==230 */
+            return false; /* preceded by different base character (not TYPE_i), or intervening cc==230 */
         }
     }
 
-    return FALSE; /* not preceded by TYPE_i */
+    return false; /* not preceded by TYPE_i */
 }
 
 /*
@@ -987,20 +987,20 @@ isPrecededBy_I(UCaseContextIterator *iter, void *context) {
     int8_t dir;
 
     if(iter==NULL) {
-        return FALSE;
+        return false;
     }
 
     for(dir=-1; (c=iter(context, dir))>=0; dir=0) {
         if(c==0x49) {
-            return TRUE; /* preceded by I */
+            return true; /* preceded by I */
         }
         dotType=getDotType(c);
         if(dotType!=UCASE_OTHER_ACCENT) {
-            return FALSE; /* preceded by different base character (not I), or intervening cc==230 */
+            return false; /* preceded by different base character (not I), or intervening cc==230 */
         }
     }
 
-    return FALSE; /* not preceded by I */
+    return false; /* not preceded by I */
 }
 
 /* Is followed by one or more cc==230 ? */
@@ -1011,19 +1011,19 @@ isFollowedByMoreAbove(UCaseContextIterator *iter, void *context) {
     int8_t dir;
 
     if(iter==NULL) {
-        return FALSE;
+        return false;
     }
 
     for(dir=1; (c=iter(context, dir))>=0; dir=0) {
         dotType=getDotType(c);
         if(dotType==UCASE_ABOVE) {
-            return TRUE; /* at least one cc==230 following */
+            return true; /* at least one cc==230 following */
         } else if(dotType!=UCASE_OTHER_ACCENT) {
-            return FALSE; /* next base character, no more cc==230 following */
+            return false; /* next base character, no more cc==230 following */
         }
     }
 
-    return FALSE; /* no more cc==230 following */
+    return false; /* no more cc==230 following */
 }
 
 /* Is followed by a dot above (without cc==230 in between) ? */
@@ -1034,20 +1034,20 @@ isFollowedByDotAbove(UCaseContextIterator *iter, void *context) {
     int8_t dir;
 
     if(iter==NULL) {
-        return FALSE;
+        return false;
     }
 
     for(dir=1; (c=iter(context, dir))>=0; dir=0) {
         if(c==0x307) {
-            return TRUE;
+            return true;
         }
         dotType=getDotType(c);
         if(dotType!=UCASE_OTHER_ACCENT) {
-            return FALSE; /* next base character or cc==230 in between */
+            return false; /* next base character or cc==230 in between */
         }
     }
 
-    return FALSE; /* no dot above following */
+    return false; /* no dot above following */
 }
 
 U_CAPI int32_t U_EXPORT2
@@ -1317,7 +1317,7 @@ ucase_toFullUpper(UChar32 c,
                   UCaseContextIterator *iter, void *context,
                   const UChar **pString,
                   int32_t caseLocale) {
-    return toUpperOrTitle(c, iter, context, pString, caseLocale, TRUE);
+    return toUpperOrTitle(c, iter, context, pString, caseLocale, true);
 }
 
 U_CAPI int32_t U_EXPORT2
@@ -1325,7 +1325,7 @@ ucase_toFullTitle(UChar32 c,
                   UCaseContextIterator *iter, void *context,
                   const UChar **pString,
                   int32_t caseLocale) {
-    return toUpperOrTitle(c, iter, context, pString, caseLocale, FALSE);
+    return toUpperOrTitle(c, iter, context, pString, caseLocale, false);
 }
 
 /* case folding ------------------------------------------------------------- */
@@ -1601,6 +1601,6 @@ ucase_hasBinaryProperty(UChar32 c, UProperty which) {
             ucase_toFullUpper(c, NULL, NULL, &resultString, UCASE_LOC_ROOT)>=0 ||
             ucase_toFullTitle(c, NULL, NULL, &resultString, UCASE_LOC_ROOT)>=0);
     default:
-        return FALSE;
+        return false;
     }
 }
diff --git a/deps/icu-small/source/common/ucase.h b/deps/icu-small/source/common/ucase.h
index 7bf57fd370..049f042912 100644
--- a/deps/icu-small/source/common/ucase.h
+++ b/deps/icu-small/source/common/ucase.h
@@ -139,8 +139,8 @@ public:
      */
     UChar32 next(UnicodeString &full);
 private:
-    FullCaseFoldingIterator(const FullCaseFoldingIterator &);  // no copy
-    FullCaseFoldingIterator &operator=(const FullCaseFoldingIterator &);  // no assignment
+    FullCaseFoldingIterator(const FullCaseFoldingIterator &) = delete;  // no copy
+    FullCaseFoldingIterator &operator=(const FullCaseFoldingIterator &) = delete;  // no assignment
 
     const UChar *unfold;
     int32_t unfoldRows;
diff --git a/deps/icu-small/source/common/ucase_props_data.h b/deps/icu-small/source/common/ucase_props_data.h
index 8bbf403cdc..b7797d14d7 100644
--- a/deps/icu-small/source/common/ucase_props_data.h
+++ b/deps/icu-small/source/common/ucase_props_data.h
@@ -9,145 +9,145 @@
 
 #ifdef INCLUDED_FROM_UCASE_CPP
 
-static const UVersionInfo ucase_props_dataVersion={0xe,0,0,0};
+static const UVersionInfo ucase_props_dataVersion={0xf,0,0,0};
 
-static const int32_t ucase_props_indexes[UCASE_IX_TOP]={0x10,0x7512,0x64e8,0x683,0x172,0,0,0,0,0,0,0,0,0,0,3};
+static const int32_t ucase_props_indexes[UCASE_IX_TOP]={0x10,0x76f2,0x66c8,0x683,0x172,0,0,0,0,0,0,0,0,0,0,3};
 
-static const uint16_t ucase_props_trieIndex[12908]={
-0x354,0x35c,0x364,0x36c,0x37a,0x382,0x38a,0x392,0x39a,0x3a2,0x3a9,0x3b1,0x3b9,0x3c1,0x3c9,0x3d1,
-0x3d7,0x3df,0x3e7,0x3ef,0x3f7,0x3ff,0x407,0x40f,0x417,0x41f,0x427,0x42f,0x437,0x43f,0x447,0x44f,
-0x457,0x45f,0x467,0x46f,0x477,0x47f,0x487,0x48f,0x48b,0x493,0x498,0x4a0,0x4a7,0x4af,0x4b7,0x4bf,
-0x4c7,0x4cf,0x4d7,0x4df,0x373,0x37b,0x4e4,0x4ec,0x4f1,0x4f9,0x501,0x509,0x508,0x510,0x515,0x51d,
-0x525,0x52c,0x530,0x373,0x537,0x354,0x547,0x53f,0x54f,0x551,0x559,0x561,0x565,0x566,0x56e,0x576,
-0x57e,0x566,0x586,0x58b,0x57e,0x566,0x593,0x59b,0x565,0x5a3,0x5ab,0x5b3,0x5bb,0x373,0x5c3,0x373,
-0x5cb,0x5cd,0x5d5,0x5b3,0x565,0x5a3,0x5dc,0x5b3,0x5e4,0x5e6,0x56e,0x5b3,0x565,0x373,0x5ee,0x373,
-0x373,0x5f4,0x5fb,0x373,0x373,0x5ff,0x607,0x373,0x60b,0x612,0x373,0x619,0x621,0x628,0x630,0x373,
-0x373,0x635,0x63d,0x645,0x64d,0x655,0x65c,0x664,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x66c,0x373,0x373,0x67c,0x67c,0x674,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x684,0x68a,0x572,0x572,0x373,0x690,0x698,0x373,
-0x6a0,0x373,0x6a8,0x373,0x6af,0x6b5,0x373,0x373,0x373,0x6bd,0x373,0x373,0x373,0x373,0x373,0x373,
-0x6c4,0x373,0x6cb,0x6d3,0x373,0x6db,0x6e3,0x373,0x5a2,0x6e7,0x6ef,0x6f5,0x5e4,0x6fd,0x373,0x704,
-0x373,0x709,0x373,0x70f,0x717,0x71b,0x723,0x72b,0x733,0x738,0x73b,0x743,0x753,0x74b,0x763,0x75b,
-0x39a,0x76b,0x39a,0x773,0x776,0x39a,0x77e,0x39a,0x786,0x78e,0x796,0x79e,0x7a6,0x7ae,0x7b6,0x7be,
-0x7c6,0x7cd,0x373,0x7d5,0x7dd,0x373,0x7e5,0x7ed,0x7f5,0x7fd,0x805,0x80d,0x815,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x818,0x81e,0x824,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x82c,0x830,0x834,0x83c,0x39a,0x39a,0x39a,0x844,0x84c,0x853,0x373,0x858,0x373,0x373,0x373,0x860,
-0x373,0x6a5,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x564,0x868,0x373,0x373,0x86f,0x373,0x373,0x877,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x87f,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x70f,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x885,0x373,0x88d,0x892,0x89a,0x373,0x373,0x8a2,0x8aa,0x8b2,0x39a,0x8b7,0x8bf,0x8c5,0x8cc,0x8d3,
-0x8db,0x8e2,0x373,0x373,0x373,0x373,0x8e9,0x8f1,0x373,0x8f9,0x900,0x373,0x54f,0x905,0x90d,0x6af,
-0x373,0x913,0x91b,0x91f,0x373,0x927,0x92f,0x937,0x373,0x93d,0x941,0x949,0x959,0x951,0x373,0x961,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x969,0x373,0x373,0x373,0x373,0x971,0x54f,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x976,0x97e,0x982,0x373,0x373,0x373,0x373,0x356,0x35c,0x98a,0x992,0x999,0x50a,0x373,0x373,0x9a1,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0xdd0,0xdd0,0xde8,0xe28,0xe68,0xea4,0xee4,0xf24,0xf5c,0xf9c,0xfdc,0x101c,0x105c,0x109c,0x10dc,0x111c,
-0x115c,0x119c,0x11dc,0x121c,0x122c,0x1260,0x129c,0x12dc,0x131c,0x135c,0xdcc,0x1390,0x13c4,0x1404,0x1420,0x1454,
-0x9e1,0xa1f,0xa5f,0xa9e,0x188,0x188,0xad6,0x188,0x188,0x188,0x188,0x188,0x188,0xaff,0x188,0x188,
-0x188,0x188,0x188,0x188,0x188,0xb3f,0x188,0xb7f,0x188,0xba5,0xbe0,0xc1f,0xc5f,0xc99,0xcd0,0x188,
+static const uint16_t ucase_props_trieIndex[13148]={
+0x355,0x35d,0x365,0x36d,0x37b,0x383,0x38b,0x393,0x39b,0x3a3,0x3aa,0x3b2,0x3ba,0x3c2,0x3ca,0x3d2,
+0x3d8,0x3e0,0x3e8,0x3f0,0x3f8,0x400,0x408,0x410,0x418,0x420,0x428,0x430,0x438,0x440,0x448,0x450,
+0x458,0x460,0x468,0x470,0x478,0x480,0x488,0x490,0x48c,0x494,0x499,0x4a1,0x4a8,0x4b0,0x4b8,0x4c0,
+0x4c8,0x4d0,0x4d8,0x4e0,0x374,0x37c,0x4e5,0x4ed,0x4f2,0x4fa,0x502,0x50a,0x509,0x511,0x516,0x51e,
+0x526,0x52d,0x531,0x374,0x538,0x355,0x548,0x540,0x550,0x552,0x55a,0x562,0x566,0x567,0x56f,0x577,
+0x57f,0x567,0x587,0x58c,0x57f,0x567,0x594,0x59c,0x566,0x5a4,0x5ac,0x5b4,0x5bc,0x374,0x5c4,0x374,
+0x5cc,0x5ce,0x5d6,0x5b4,0x566,0x5a4,0x5dd,0x5b4,0x5e5,0x5e7,0x56f,0x5b4,0x566,0x374,0x5ef,0x374,
+0x374,0x5f5,0x5fc,0x374,0x374,0x600,0x608,0x374,0x60c,0x613,0x374,0x61a,0x622,0x629,0x631,0x374,
+0x374,0x636,0x63e,0x646,0x64e,0x656,0x65d,0x665,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x66d,0x374,0x374,0x67d,0x67d,0x675,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x685,0x68b,0x573,0x573,0x374,0x691,0x699,0x374,
+0x6a1,0x374,0x6a9,0x374,0x6b0,0x6b6,0x374,0x374,0x374,0x6be,0x374,0x374,0x374,0x374,0x374,0x374,
+0x6c5,0x374,0x6cc,0x6d4,0x374,0x6dc,0x6e4,0x374,0x5a3,0x6e8,0x6f0,0x6f6,0x5e5,0x6fe,0x374,0x705,
+0x374,0x70a,0x374,0x710,0x718,0x71c,0x724,0x72c,0x734,0x739,0x73c,0x744,0x754,0x74c,0x764,0x75c,
+0x39b,0x76c,0x39b,0x774,0x777,0x39b,0x77f,0x39b,0x787,0x78f,0x797,0x79f,0x7a7,0x7af,0x7b7,0x7bf,
+0x7c7,0x7ce,0x374,0x7d6,0x7de,0x374,0x7e6,0x7ee,0x7f6,0x7fe,0x806,0x80e,0x816,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x819,0x81f,0x825,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x82d,0x831,0x835,0x83d,0x39b,0x39b,0x39b,0x845,0x84d,0x854,0x374,0x859,0x374,0x374,0x374,0x861,
+0x374,0x6a6,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x565,0x869,0x374,0x374,0x870,0x374,0x374,0x878,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x880,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x710,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x886,0x374,0x88e,0x893,0x89b,0x374,0x374,0x8a3,0x8ab,0x8b3,0x39b,0x8b8,0x8c0,0x8c6,0x8cd,0x8d4,
+0x8dc,0x8e3,0x374,0x374,0x374,0x374,0x8ea,0x8f2,0x374,0x8fa,0x901,0x374,0x550,0x906,0x90e,0x6b0,
+0x374,0x914,0x91c,0x920,0x374,0x928,0x930,0x938,0x374,0x93e,0x942,0x94a,0x95a,0x952,0x374,0x962,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x96a,0x374,0x374,0x374,0x374,0x972,0x550,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x977,0x97f,0x983,0x374,0x374,0x374,0x374,0x357,0x35d,0x98b,0x993,0x99a,0x50b,0x374,0x374,0x9a2,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0xdd4,0xdd4,0xdec,0xe2c,0xe6c,0xea8,0xee8,0xf28,0xf60,0xfa0,0xfe0,0x1020,0x1060,0x10a0,0x10e0,0x1120,
+0x1160,0x11a0,0x11e0,0x1220,0x1230,0x1264,0x12a0,0x12e0,0x1320,0x1360,0xdd0,0x1394,0x13c8,0x1408,0x1424,0x1458,
+0x9e1,0xa1f,0xa5f,0xa9e,0x188,0x188,0xad9,0x188,0x188,0x188,0x188,0x188,0x188,0xb02,0x188,0x188,
+0x188,0x188,0x188,0x188,0x188,0xb42,0x188,0xb82,0x188,0xba8,0xbe3,0xc22,0xc62,0xc9c,0xcd3,0x188,
 0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,
 0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,
 0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,
@@ -172,642 +172,657 @@ static const uint16_t ucase_props_trieIndex[12908]={
 0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,
 0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,
 0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,
-0xd10,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x9a8,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x9b0,0x373,0x373,0x373,0x9b3,0x373,0x373,0x373,
-0x373,0x9bb,0x9c1,0x9c5,0x373,0x373,0x9c9,0x9cd,0x9d3,0x373,0x373,0x373,0x9da,0x9de,0x9e6,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x9f6,0x9ee,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x9fe,
-0xa02,0x373,0x373,0x373,0x373,0x373,0xa0a,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0xa12,0xa16,0xa1e,0xa22,0x373,0xa29,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0xa2f,0x373,0x373,0x373,0x373,0xa36,0x373,0xa3e,0x373,0x373,0x373,0x565,
-0xa40,0xa47,0xa4b,0x5e4,0xa53,0xa5b,0x373,0xa63,0xa6a,0x373,0xa70,0x5e4,0xa75,0xa7d,0x373,0x373,
-0xa82,0x373,0x373,0x373,0x373,0x356,0xa8a,0x5e4,0x5e6,0xa92,0xa99,0x373,0x373,0x373,0x373,0x373,
-0xa40,0xaa1,0x373,0x373,0xaa9,0xab1,0x373,0x373,0x373,0x373,0x373,0x373,0xab5,0xabd,0x373,0x373,
-0xac5,0x4ce,0x373,0x373,0xacd,0x373,0x373,0xad3,0xadb,0x373,0x373,0x373,0x373,0x373,0x373,0xae0,
-0x373,0x373,0x373,0xae8,0xaf0,0x373,0x373,0xaf8,0xb00,0x373,0x373,0x373,0xb03,0x9b0,0xb0b,0xb0f,
-0xb17,0x373,0xb1e,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0xb25,
-0x373,0x373,0x971,0xb2d,0x373,0x373,0x373,0xb33,0xb3b,0x373,0xb3f,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0xb45,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0xb4b,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0xb52,0x373,0xb58,0x5a2,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0xae8,0xaf0,0x373,0x373,0x373,0x373,0x373,0x373,0x6a5,0x373,0xb5e,0x373,0x373,0xb66,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0xb6b,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0xb73,0x5a2,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x8aa,0xb7b,0xb82,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0xb89,0xb91,0xb97,0x373,0x373,
-0x373,0x373,0xb9f,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0xba7,0xbaf,0xbb4,0xbba,0xbc2,0xbca,0xbd2,0xbab,0xbda,0xbe2,0xbea,0xbf1,0xbac,0xba7,0xbaf,0xbaa,
-0xbba,0xbad,0xba8,0xbf9,0xbab,0xc01,0xc09,0xc11,0xc18,0xc04,0xc0c,0xc14,0xc1b,0xc07,0xc23,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x8aa,
-0xc2b,0x8aa,0xc32,0xc39,0xc41,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0xc51,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0xc49,
-0xc59,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0xc5d,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0xaa5,0x373,0xa27,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0xc65,
-0x373,0xc6d,0xc75,0xc7c,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0xba3,0xc84,0xc84,0xc8a,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0xa65,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x565,0x8aa,0x8aa,0x8aa,0x373,0x373,0x373,0x373,0x8aa,0x8aa,0x8aa,0x8aa,0x8aa,0x8aa,0x8aa,0xc92,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,0x373,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,4,0,0,0,0,0,0,4,0,
-0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,
-0,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0xa,0x5a,0x7a,0x1012,0x1012,0x1012,0x1012,
-0x1012,0x1012,0x1012,0xba,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0,0,0,4,0,
-4,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf9,0xf031,0x149,0xf011,0xf011,0xf011,0xf011,
-0xf011,0xf011,0xf011,0x189,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-4,0,1,0,0,4,0,4,0,0,0,0,4,0x1c9,0,4,
-4,0,1,0,0,0,0,0,0x1012,0x1012,0x1012,0x1012,0x1012,0x1fa,0x1012,0x1012,
-0x1012,0x1012,0x1012,0x1012,0x5a,0x5a,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0,
-0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x239,0xf011,0xf011,0xf011,0xf011,0xf011,0x2d9,0xf011,0xf011,
-0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0,
-0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0x3c91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
+0xd13,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x9a9,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x9b1,0x374,0x374,0x374,0x9b4,0x374,0x374,0x374,
+0x374,0x9bc,0x9c2,0x9c6,0x374,0x374,0x9ca,0x9ce,0x9d4,0x374,0x374,0x374,0x9db,0x9df,0x9e7,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x9f7,0x9ef,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x9ff,
+0xa03,0x374,0x374,0x374,0x374,0x374,0xa0b,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0xa13,0xa17,0xa1f,0xa23,0x374,0xa2a,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0xa30,0x374,0xa34,0x374,0x374,0xa3c,0x374,0xa44,0x374,0x374,0x374,0x566,
+0xa46,0xa4d,0xa51,0x5e5,0xa59,0xa61,0x374,0xa69,0xa70,0x374,0xa76,0x5e5,0xa7b,0xa83,0x374,0x374,
+0xa88,0x566,0x374,0x374,0x374,0x357,0xa90,0x5e5,0x5e7,0xa98,0xa9f,0x374,0x374,0x374,0x374,0x374,
+0xa46,0xaa7,0x374,0x374,0xaaf,0xab7,0x374,0x374,0x374,0x374,0x374,0x374,0xabb,0xac3,0x374,0x374,
+0xacb,0x4cf,0x374,0x374,0xad3,0x374,0x374,0xad9,0xae1,0x374,0x374,0x374,0x374,0x374,0x374,0xae6,
+0x374,0x374,0x374,0xaee,0xaf6,0x374,0x374,0xafe,0xb06,0x374,0x374,0x374,0xb09,0x9b1,0xb11,0xb15,
+0xb1d,0x374,0xb24,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0xb2b,
+0x374,0x374,0x972,0xb33,0x374,0x374,0x374,0xb39,0xb41,0x374,0xb45,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0xb4b,0x5e5,0xb51,0xb59,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0xb5d,0xb65,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0xb6b,0x374,0xb71,0x5a3,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0xaee,0xaf6,0x374,0x374,0x374,0x374,0x374,0x374,0x6a6,0x374,0xb77,0x374,
+0x374,0xb7f,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0xb84,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0xb8c,0x5a3,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x8ab,0xb94,0xb9b,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0xba2,0xbaa,
+0xbb0,0x374,0x374,0x374,0x374,0xbb8,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0xbc0,0xbc8,0xbcd,0xbd3,0xbdb,0xbe3,0xbeb,0xbc4,0xbf3,0xbfb,0xc03,0xc0a,0xbc5,
+0xbc0,0xbc8,0xbc3,0xbd3,0xbc6,0xbc1,0xc12,0xbc4,0xc1a,0xc22,0xc2a,0xc31,0xc1d,0xc25,0xc2d,0xc34,
+0xc20,0xc3c,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x8ab,0xc44,0x8ab,0xc4b,0xc52,0xc5a,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0xc6a,0xc72,0x374,0x374,0x374,0x374,
+0x374,0x374,0xc62,0xc7a,0xc8d,0xc80,0xc85,0x374,0x374,0x374,0x374,0xc95,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0xaab,0x374,0xa28,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0xc9d,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0xca1,0x374,0xca9,0xcb1,0xcb8,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0xbbc,0xcc0,0xcc0,0xcc6,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0xa6b,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x566,0x8ab,0x8ab,0x8ab,0x374,0x374,0x374,0x374,0x8ab,0x8ab,0x8ab,0x8ab,0x8ab,
+0x8ab,0x8ab,0xcce,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,0x374,
+0x374,0x374,0x374,0x354,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,
+0,0,4,0,0,0,0,0,0,0,0,0,0,0,4,0,
+0,0,0,0,0,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0xa,0x5a,0x7a,
+0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0xba,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0,
+0,0,4,0,4,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf9,0xf031,0x149,
+0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0x189,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,4,0,1,0,0,4,0,4,0,0,0,0,
+4,0x1c9,0,4,4,0,1,0,0,0,0,0,0x1012,0x1012,0x1012,0x1012,
+0x1012,0x1fa,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x5a,0x5a,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,
+0x1012,0x1012,0x1012,0,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x239,0xf011,0xf011,0xf011,0xf011,
+0xf011,0x2d9,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,
+0xf011,0xf011,0xf011,0,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0x3c91,0x92,0xff91,0x92,0xff91,
 0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
 0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
-0x31a,0xff91,0x92,0xff91,0x92,0xff91,0x31a,0xffb1,0x33a,0x389,0x92,0xff91,0x92,0xff91,0x92,0xff91,
-1,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x3d9,0x92,0xff91,
+0x92,0xff91,0x92,0xff91,0x31a,0xff91,0x92,0xff91,0x92,0xff91,0x31a,0xffb1,0x33a,0x389,0x92,0xff91,
+0x92,0xff91,0x92,0xff91,1,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,
+0xff91,0x3d9,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
 0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
 0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
-0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0xc392,0x92,0xff91,0x92,
-0xff91,0x92,0xff91,0x459,0x6191,0x6912,0x92,0xff91,0x92,0xff91,0x6712,0x92,0xff91,0x6692,0x6692,0x92,
-0xff91,1,0x2792,0x6512,0x6592,0x92,0xff91,0x6692,0x6792,0x3091,0x6992,0x6892,0x92,0xff91,0x5191,1,
-0x6992,0x6a92,0x4111,0x6b12,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x6d12,0x92,0xff91,0x6d12,1,1,
-0x92,0xff91,0x6d12,0x92,0xff91,0x6c92,0x6c92,0x92,0xff91,0x92,0xff91,0x6d92,0x92,0xff91,1,0,
-0x92,0xff91,1,0x1c11,0,0,0,0,0x48a,0x4bb,0x4f9,0x52a,0x55b,0x599,0x5ca,0x5fb,
-0x639,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,
-0xff91,0xd891,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
-0x92,0xff91,0x92,0xff91,0x669,0x6ea,0x71b,0x759,0x92,0xff91,0xcf92,0xe412,0x92,0xff91,0x92,0xff91,
+0xc392,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x459,0x6191,0x6912,0x92,0xff91,0x92,0xff91,0x6712,0x92,
+0xff91,0x6692,0x6692,0x92,0xff91,1,0x2792,0x6512,0x6592,0x92,0xff91,0x6692,0x6792,0x3091,0x6992,0x6892,
+0x92,0xff91,0x5191,1,0x6992,0x6a92,0x4111,0x6b12,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x6d12,0x92,
+0xff91,0x6d12,1,1,0x92,0xff91,0x6d12,0x92,0xff91,0x6c92,0x6c92,0x92,0xff91,0x92,0xff91,0x6d92,
+0x92,0xff91,1,0,0x92,0xff91,1,0x1c11,0,0,0,0,0x48a,0x4bb,0x4f9,0x52a,
+0x55b,0x599,0x5ca,0x5fb,0x639,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,
+0xff91,0x92,0xff91,0x92,0xff91,0xd891,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
+0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x669,0x6ea,0x71b,0x759,0x92,0xff91,0xcf92,0xe412,
 0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
-0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0xbf12,1,0x92,0xff91,
 0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
-1,1,1,1,1,1,0x78a,0x92,0xff91,0xae92,0x7aa,0x7c9,0x7c9,0x92,0xff91,0x9e92,
-0x2292,0x2392,0x92,0xff91,0x92,0xffb1,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x7e9,0x809,0x829,0x9711,
-0x9911,1,0x9991,0x9991,1,0x9b11,1,0x9a91,0x849,1,1,1,0x9991,0x869,1,0x9891,
-1,0x889,0x8a9,1,0x97b1,0x9691,0x8a9,0x8c9,0x8e9,1,1,0x9691,1,0x909,0x9591,1,
-1,0x9511,1,1,1,1,1,1,1,0x929,1,1,0x9311,1,0x949,0x9311,
-1,1,1,0x969,0x9311,0xdd91,0x9391,0x9391,0xdc91,1,1,1,1,1,0x9291,1,
-0,1,1,1,1,1,1,1,1,0x989,0x9a9,1,1,1,1,1,
-1,1,1,1,1,1,1,1,1,1,1,1,5,5,0x25,5,
-5,5,5,5,5,4,4,4,0x14,4,0x14,4,5,5,4,4,
+0xbf12,1,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
+0x92,0xff91,0x92,0xff91,1,1,1,1,1,1,0x78a,0x92,0xff91,0xae92,0x7aa,0x7c9,
+0x7c9,0x92,0xff91,0x9e92,0x2292,0x2392,0x92,0xff91,0x92,0xffb1,0x92,0xff91,0x92,0xff91,0x92,0xff91,
+0x7e9,0x809,0x829,0x9711,0x9911,1,0x9991,0x9991,1,0x9b11,1,0x9a91,0x849,1,1,1,
+0x9991,0x869,1,0x9891,1,0x889,0x8a9,1,0x97b1,0x9691,0x8a9,0x8c9,0x8e9,1,1,0x9691,
+1,0x909,0x9591,1,1,0x9511,1,1,1,1,1,1,1,0x929,1,1,
+0x9311,1,0x949,0x9311,1,1,1,0x969,0x9311,0xdd91,0x9391,0x9391,0xdc91,1,1,1,
+1,1,0x9291,1,0,1,1,1,1,1,1,1,1,0x989,0x9a9,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+5,5,0x25,5,5,5,5,5,5,4,4,4,0x14,4,0x14,4,
+5,5,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
 4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
-4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,
-5,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
-4,4,4,4,4,4,4,4,4,4,4,4,0x54,0x54,0x44,0x44,
-0x44,0x44,0x44,0x9cc,0x54,0x44,0x54,0x44,0x54,0x44,0x44,0x44,0x44,0x44,0x44,0x54,
-0x44,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,
-0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x74,0x64,0x64,
-0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x44,0x44,0x44,0x44,0x44,0x54,0x44,
-0x44,0x9dd,0x44,0x64,0x64,0x64,0x44,0x44,0x44,0x64,0x64,4,0x44,0x44,0x44,0x64,
-0x64,0x64,0x64,0x44,0x64,0x64,0x64,0x44,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x44,
-0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x92,0xff91,0x92,0xff91,
-4,4,0x92,0xff91,0,0,5,0x4111,0x4111,0x4111,0,0x3a12,0,0,0,0,
-4,4,0x1312,4,0x1292,0x1292,0x1292,0,0x2012,0,0x1f92,0x1f92,0xa29,0x1012,0xafa,0x1012,
-0x1012,0xb3a,0x1012,0x1012,0xb7a,0xbca,0xc1a,0x1012,0xc5a,0x1012,0x1012,0x1012,0xc9a,0xcda,0,0xd1a,
-0x1012,0x1012,0xd5a,0x1012,0x1012,0xd9a,0x1012,0x1012,0xed11,0xed91,0xed91,0xed91,0xdd9,0xf011,0xea9,0xf011,
-0xf011,0xee9,0xf011,0xf011,0xf29,0xf79,0xfc9,0xf011,0x1009,0xf011,0xf011,0xf011,0x1049,0x1089,0x10c9,0x10f9,
-0xf011,0xf011,0x1139,0xf011,0xf011,0x1179,0xf011,0xf011,0xe011,0xe091,0xe091,0x412,0x11b9,0x11e9,2,2,
-2,0x1239,0x1269,0xfc11,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
-0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x1299,0x12c9,0x391,0xc631,
-0x12fa,0x1349,0,0x92,0xff91,0xfc92,0x92,0xff91,1,0xbf12,0xbf12,0xbf12,0x2812,0x2812,0x2812,0x2812,
-0x2812,0x2812,0x2812,0x2812,0x2812,0x2812,0x2812,0x2812,0x2812,0x2812,0x2812,0x2812,0x1012,0x1012,0x137a,0x1012,
-0x13ba,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x13fa,0x1012,0x1012,0x143a,0x147a,0x1012,
-0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x14ca,0x1012,0x1012,0x1012,0x1012,0x1012,0xf011,0xf011,0x1509,0xf011,
-0x1549,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0x1589,0xf011,0xf011,0x15c9,0x1609,0xf011,
-0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0x1659,0xf011,0xf011,0xf011,0xf011,0xf011,0xd811,0xd811,0xd811,0xd811,
-0xd811,0xd811,0xd831,0xd811,0xd831,0xd811,0xd811,0xd811,0xd811,0xd811,0xd811,0xd811,0x92,0xff91,0x169a,0x16d9,
+5,5,5,5,5,4,4,4,4,4,4,4,4,4,4,4,
+4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
+0x54,0x54,0x44,0x44,0x44,0x44,0x44,0x9cc,0x54,0x44,0x54,0x44,0x54,0x44,0x44,0x44,
+0x44,0x44,0x44,0x54,0x44,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,
+0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,
+0x64,0x74,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x44,0x44,0x44,
+0x44,0x44,0x54,0x44,0x44,0x9dd,0x44,0x64,0x64,0x64,0x44,0x44,0x44,0x64,0x64,4,
+0x44,0x44,0x44,0x64,0x64,0x64,0x64,0x44,0x64,0x64,0x64,0x44,0x64,0x64,0x64,0x64,
+0x64,0x64,0x64,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,
+0x92,0xff91,0x92,0xff91,4,4,0x92,0xff91,0,0,5,0x4111,0x4111,0x4111,0,0x3a12,
+0,0,0,0,4,4,0x1312,4,0x1292,0x1292,0x1292,0,0x2012,0,0x1f92,0x1f92,
+0xa29,0x1012,0xafa,0x1012,0x1012,0xb3a,0x1012,0x1012,0xb7a,0xbca,0xc1a,0x1012,0xc5a,0x1012,0x1012,0x1012,
+0xc9a,0xcda,0,0xd1a,0x1012,0x1012,0xd5a,0x1012,0x1012,0xd9a,0x1012,0x1012,0xed11,0xed91,0xed91,0xed91,
+0xdd9,0xf011,0xea9,0xf011,0xf011,0xee9,0xf011,0xf011,0xf29,0xf79,0xfc9,0xf011,0x1009,0xf011,0xf011,0xf011,
+0x1049,0x1089,0x10c9,0x10f9,0xf011,0xf011,0x1139,0xf011,0xf011,0x1179,0xf011,0xf011,0xe011,0xe091,0xe091,0x412,
+0x11b9,0x11e9,2,2,2,0x1239,0x1269,0xfc11,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
 0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
-0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0,0x44,
-0x44,0x44,0x44,0x44,4,4,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
+0x1299,0x12c9,0x391,0xc631,0x12fa,0x1349,0,0x92,0xff91,0xfc92,0x92,0xff91,1,0xbf12,0xbf12,0xbf12,
+0x2812,0x2812,0x2812,0x2812,0x2812,0x2812,0x2812,0x2812,0x2812,0x2812,0x2812,0x2812,0x2812,0x2812,0x2812,0x2812,
+0x1012,0x1012,0x137a,0x1012,0x13ba,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x13fa,0x1012,
+0x1012,0x143a,0x147a,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x14ca,0x1012,0x1012,0x1012,0x1012,0x1012,
+0xf011,0xf011,0x1509,0xf011,0x1549,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0x1589,0xf011,
+0xf011,0x15c9,0x1609,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0x1659,0xf011,0xf011,0xf011,0xf011,0xf011,
+0xd811,0xd811,0xd811,0xd811,0xd811,0xd811,0xd831,0xd811,0xd831,0xd811,0xd811,0xd811,0xd811,0xd811,0xd811,0xd811,
+0x92,0xff91,0x169a,0x16d9,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
 0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
+0x92,0xff91,0,0x44,0x44,0x44,0x44,0x44,4,4,0x92,0xff91,0x92,0xff91,0x92,0xff91,
 0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
-0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x792,0x92,0xff91,0x92,
-0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0xf891,0x92,0xff91,0x92,0xff91,
 0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
 0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
-0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0,0x1812,0x1812,0x1812,
-0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,
-0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0,0,4,0,0,0,0,0,4,
-1,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,
+0x792,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0xf891,
+0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
+0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
+0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
+0,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,
+0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0,0,4,0,0,
+0,0,0,4,1,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,
 0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,
-0xe811,0xe811,0xe811,0x1719,1,0,0,0,0,0,0,0,0,0x64,0x44,0x44,
-0x44,0x44,0x64,0x44,0x44,0x44,0x64,0x64,0x44,0x44,0x44,0x44,0x44,0x44,0x64,0x64,
-0x64,0x64,0x64,0x64,0x44,0x44,0x64,0x44,0x44,0x64,0x64,0x44,0x64,0x64,0x64,0x64,
-0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0,0x64,0,0x64,0x64,0,
-0x44,0x64,0,0x64,0,0,0,0,0,0,0,0,0,0,0,0,
+0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0x1719,1,0,0,0,0,0,0,0,
+0,0x64,0x44,0x44,0x44,0x44,0x64,0x44,0x44,0x44,0x64,0x64,0x44,0x44,0x44,0x44,
+0x44,0x44,0x64,0x64,0x64,0x64,0x64,0x64,0x44,0x44,0x64,0x44,0x44,0x64,0x64,0x44,
+0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0,0x64,
+0,0x64,0x64,0,0x44,0x64,0,0x64,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-4,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,
-4,4,0,0,0,0,0,0,0,0,0,0,0x44,0x44,0x44,0x44,
-0x44,0x44,0x44,0x44,0x64,0x64,0x64,0,4,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,
-0,0,0,0,0,0,0,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x44,
-0x44,0x64,0x64,0x44,0x44,0x44,0x44,0x44,0x64,0x44,0x44,0x64,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0x64,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0x44,0x44,0x44,0x44,0x44,0x44,0x44,4,0,0x44,
-0x44,0x44,0x44,0x64,0x44,4,4,0x44,0x44,0,0x64,0x44,0x44,0x64,0,0,
+0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,
+4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,
+0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x64,0x64,0x64,0,4,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,4,0,0x64,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0x44,0x64,0x44,0x44,0x64,0x44,0x44,0x64,0x64,0x64,0x44,0x64,
-0x64,0x44,0x64,0x44,0x44,0x44,0x64,0x44,0x64,0x44,0x64,0x44,0x64,0x44,0x44,0,
+4,0,0,0,0,0,0,0,0,0,0,0x64,0x64,0x64,0x64,0x64,
+0x64,0x64,0x64,0x44,0x44,0x64,0x64,0x44,0x44,0x44,0x44,0x44,0x64,0x44,0x44,0x64,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0x44,0x44,0x44,0x44,0x44,0x44,
+0x44,4,0,0x44,0x44,0x44,0x44,0x64,0x44,4,4,0x44,0x44,0,0x64,0x44,
+0x44,0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,4,0,0x64,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0x44,0x64,0x44,0x44,0x64,0x44,0x44,0x64,
+0x64,0x64,0x44,0x64,0x64,0x44,0x64,0x44,0x44,0x44,0x64,0x44,0x64,0x44,0x64,0x44,
+0x64,0x44,0x44,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,
-4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0x44,
-0x44,0x44,0x44,0x44,0x44,0x44,0x64,0x44,4,4,0,0,0,0,4,0,
-0,0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0x44,0x44,0x44,0x44,4,0x44,
-0x44,0x44,0x44,0x44,4,0x44,0x44,0x44,4,0x44,0x44,0x44,0x44,0x44,0,0,
+0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,
+4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0x64,0x64,0x64,0,0,0,0,
-0,0,0,0,4,0,0,0,0,0,0,0,4,4,0,0,
-0,0,0,0,0x44,0x64,0x64,0x64,0x44,0x44,0x44,0x44,0x44,0x44,4,0x64,
-0x44,0x44,0x64,0x44,0x44,0x64,0x44,0x44,0x44,0x64,0x64,0x64,0x64,0x64,0x64,0x44,
-0x44,0x44,0x64,0x44,0x44,0x64,0x64,0x44,0x44,0x44,0x44,0x44,0,0,0,0,
-0,0,0,0,0,4,0x44,0x44,0x44,0x44,0x44,0x64,0x64,0x64,0x64,0x64,
-0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,4,4,4,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,
-0x64,0,0,0,0,4,4,4,4,4,4,4,4,0,0,0,
-0,0x64,0,0,0,0x44,0x64,0x44,0x44,4,4,4,0,0,0,0,
-0,0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,
-0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x64,0x44,4,4,0,0,
+0,0,4,0,0,0x64,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0x44,0x44,
+0x44,0x44,4,0x44,0x44,0x44,0x44,0x44,4,0x44,0x44,0x44,4,0x44,0x44,0x44,
+0x44,0x44,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0x64,0x64,0x64,
+0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,
+4,4,0,0,0,0,0,0,0x44,0x64,0x64,0x64,0x44,0x44,0x44,0x44,
+0x44,0x44,4,0x64,0x44,0x44,0x64,0x44,0x44,0x64,0x44,0x44,0x44,0x64,0x64,0x64,
+0x64,0x64,0x64,0x44,0x44,0x44,0x64,0x44,0x44,0x64,0x64,0x44,0x44,0x44,0x44,0x44,
+0,0,0,0,0,0,0,0,0,4,0x44,0x44,0x44,0x44,0x44,0x64,
+0x64,0x64,0x64,0x64,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,
+4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0x64,0,0,0,0,4,4,4,4,0,0,0,
-0,0,0,0,0,0x64,0,0,0,0,0,0,0,0,0,0,
+0,0,4,0,0x64,0,0,0,0,4,4,4,4,4,4,4,
+4,0,0,0,0,0x64,0,0,0,0x44,0x64,0x44,0x44,4,4,4,
 0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,
+0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0x44,0,0,4,4,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,4,
-4,0,0,4,4,0x64,0,0,0,4,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,
-0,4,0,0,0,0,0,0,0,0,0,0,0,4,4,4,
-4,4,0,4,4,0,0,0,0,0x64,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0x64,0,0,0,0,4,4,4,
+4,0,0,0,0,0,0,0,0,0x64,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,4,4,4,4,4,4,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0x44,0,0,4,4,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0x64,0,0,4,0,4,4,4,
-4,0,0,0,0,0,0,0,0,0x64,0,0,0,0,0,0,
-0,4,4,0,0,0,0,0,0,0,0,0,0,0,4,4,
+0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,
+0,0,0,4,4,0,0,4,4,0x64,0,0,0,4,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,
+4,4,0,0,0,4,0,0,0,0,0,0,0,0,0,0,
+0,4,4,4,4,4,0,4,4,0,0,0,0,0x64,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,
-0,0,0,0,0,0,0,0,0,0x64,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,
-4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0x64,0,4,4,4,0,0,0,0,0,4,4,4,0,4,4,
-4,0x64,0,0,0,0,0,0,0,0x64,0x64,0,0,0,0,0,
-0,0,0,0,0,0,4,0,0,0,0,0,4,0x64,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0x64,0,0,4,
+0,4,4,4,4,0,0,0,0,0,0,0,0,0x64,0,0,
+0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,
+0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0x64,0x64,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0x64,0,0,0,0,0,0,0,4,4,4,0,4,0,
+4,0,0,0,0,0,0,0,0,0,0,0,0,0x64,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,4,0,0,4,4,4,4,0x64,0x64,0x64,0,0,0,0,0,
-0,0,4,4,0x64,0x64,0x64,0x64,4,4,4,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,
-4,4,4,4,0x64,0x64,0x64,4,4,0,0,0,0,0,0,0,
-0,0,4,0,0x64,0x64,0x64,0x64,4,4,0,0,0,0,0,0,
+4,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0x64,0x64,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0x64,0,0x64,
-0,0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0x64,0x64,4,0x64,4,4,4,4,4,0x64,0x64,
-0x64,0x64,4,0,0x64,4,0x44,0x44,0x64,0,0x44,0x44,0,0,0,0,
-0,4,4,4,4,4,4,4,4,4,4,4,0,4,4,4,
-4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
-4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,
-0,0,0,0,0,0,0x64,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0x64,0,4,4,4,0,0,0,0,0,4,4,
+4,0,4,4,4,0x64,0,0,0,0,0,0,0,0x64,0x64,0,
+0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,
+4,0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,4,4,4,4,0,4,4,4,4,4,0x64,0,0x64,0x64,0,
-0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,
-0,0,4,4,4,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,4,4,4,4,0,0,0,0,0,0,0,
-0,0,0,0,0,0,4,0,0,4,4,0,0,0,0,0,
-0,0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,4,0,0,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,
-0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,
-0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0,0x175a,0,0,0,0,0,0x175a,0,0,
-0x1779,0x17a9,0x17d9,0x1809,0x1839,0x1869,0x1899,0x18c9,0x18f9,0x1929,0x1959,0x1989,0x19b9,0x19e9,0x1a19,0x1a49,
-0x1a79,0x1aa9,0x1ad9,0x1b09,0x1b39,0x1b69,0x1b99,0x1bc9,0x1bf9,0x1c29,0x1c59,0x1c89,0x1cb9,0x1ce9,0x1d19,0x1d49,
-0x1d79,0x1da9,0x1dd9,0x1e09,0x1e39,0x1e69,0x1e99,0x1ec9,0x1ef9,0x1f29,0x1f59,0,4,0x1f89,0x1fb9,0x1fe9,
+0,0,0,0,0,0,0,0x64,0x64,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0x64,0,0,0,0,0,0,0,4,4,
+4,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,4,0,0,4,4,4,4,0x64,0x64,0x64,0,
+0,0,0,0,0,0,4,4,0x64,0x64,0x64,0x64,4,4,4,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0x44,0x44,0x44,
-0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,
-0x203a,0x203a,0x203a,0x203a,0x203a,0x203a,0,0,0x2059,0x2089,0x20b9,0x20e9,0x2119,0x2149,0,0,
-0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,
-0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,
+0,4,0,0,4,4,4,4,0x64,0x64,0x64,4,4,0,0,0,
+0,0,0,0,0,0,4,0,0x64,0x64,0x64,0x64,4,4,4,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,4,4,0x64,0x60,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,4,4,0x60,0,0,0,
+0,0,0,0,0,0,0,0,0x64,0x64,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,4,4,0,4,4,4,4,4,4,4,0,0,
-0,0,0,0,0,0,4,0,0,4,4,4,4,4,4,4,
-4,4,0x64,4,0,0,0,4,0,0,0,0,0,0x44,0,0,
-0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,
+0,0x64,0,0x64,0,0x64,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0x64,0x64,4,0x64,4,4,4,
+4,4,0x64,0x64,0x64,0x64,4,0,0x64,4,0x44,0x44,0x64,0,0x44,0x44,
+0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,
+0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
+4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
+4,0,0,0,0,0,0,0,0,0,0x64,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,4,4,4,4,0,4,4,4,4,4,0x64,
+0,0x64,0x64,0,0,4,4,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0x64,0,0,
+4,4,0,0,0,0,4,4,4,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,4,4,4,4,0,0,0,
+0,0,0,0,0,0,0,0,0,0,4,0,0,4,4,0,
+0,0,0,0,0,0x64,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,4,0,0,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,
+0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,
+0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0x175a,0,0x175a,0,0,0,0,
+0,0x175a,0,0,0x1779,0x17a9,0x17d9,0x1809,0x1839,0x1869,0x1899,0x18c9,0x18f9,0x1929,0x1959,0x1989,
+0x19b9,0x19e9,0x1a19,0x1a49,0x1a79,0x1aa9,0x1ad9,0x1b09,0x1b39,0x1b69,0x1b99,0x1bc9,0x1bf9,0x1c29,0x1c59,0x1c89,
+0x1cb9,0x1ce9,0x1d19,0x1d49,0x1d79,0x1da9,0x1dd9,0x1e09,0x1e39,0x1e69,0x1e99,0x1ec9,0x1ef9,0x1f29,0x1f59,0,
+5,0x1f89,0x1fb9,0x1fe9,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0x44,0x44,0x44,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,
+0x201a,0x201a,0x201a,0x201a,0x203a,0x203a,0x203a,0x203a,0x203a,0x203a,0,0,0x2059,0x2089,0x20b9,0x20e9,
+0x2119,0x2149,0,0,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,
+0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,0x201a,
+0x201a,0x201a,0x201a,0x201a,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,4,4,0x64,0x60,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,
+0x60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,4,4,0,4,4,4,4,4,
+4,4,0,0,0,0,0,0,0,0,4,0,0,4,4,4,
+4,4,4,4,4,4,0x64,4,0,0,0,4,0,0,0,0,
+0,0x44,0,0,0,0,0,0,0,0,0,0,0,0,0,4,
+4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,4,4,4,0,0,0,0,4,4,0,0,0,
-0,0,0,0,0,0,4,0,0,0,0,0,0,0x64,0x44,0x64,
+0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0x44,0x64,0,0,4,0,0,0,0,
+0,0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,4,4,4,0,0,0,0,4,
+4,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,
+0,0x64,0x44,0x64,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0x44,0x64,0,0,4,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,4,0,4,4,4,4,4,4,4,0,
+0x64,0,4,0,0,4,4,4,4,4,4,4,4,0,0,0,
+0,0,0,4,4,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0,0,0x64,
+0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,
+0x44,0x44,0x44,0x44,0x44,0x64,0x64,0x64,0x64,0x64,0x64,0x44,0x44,0x64,4,0x64,
+0x64,0x44,0x44,0x64,0x64,0x44,0x44,0x44,0x44,0x44,0x64,0x44,0x44,0x44,0x44,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,4,0,4,4,4,4,4,4,4,0,0x64,0,4,0,
-0,4,4,4,4,4,4,4,4,0,0,0,0,0,0,4,
-4,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0,0,0x64,0,0,0,0,
-0,0,0,4,0,0,0,0,0,0,0,0,0x44,0x44,0x44,0x44,
-0x44,0x64,0x64,0x64,0x64,0x64,0x64,0x44,0x44,0x64,4,0x64,0x64,0x44,0x44,0x64,
-0x64,0x44,0x44,0x44,0x44,0x44,0x64,0x44,0x44,0x44,0x44,0,0,0,0,0,
+0,0,0,0,0x64,0,4,4,4,4,4,0,4,0,0,0,
+0,0,4,0,0x60,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0x64,0,4,4,4,4,4,0,4,0,0,0,0,0,4,0,
-0x60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0x44,
-0x64,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,4,4,4,4,0,0,4,4,0x60,0x64,
-4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0x64,0,4,4,0,0,0,4,0,4,
-4,4,0x60,0x60,0,0,0,0,0,0,0,0,0,0,0,0,
-4,4,4,4,4,4,4,4,0,0,4,0x64,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,4,4,4,4,4,4,0,0,0x2179,0x21a9,0x21d9,0x2209,
-0x2239,0x2289,0x22d9,0x2309,0x2339,0,0,0,0,0,0,0,0x236a,0x236a,0x236a,0x236a,
+0,0,0,0x44,0x64,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,4,4,4,4,0,0,
+4,4,0x60,0x64,4,4,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0x64,0,4,4,0,0,
+0,4,0,4,4,4,0x60,0x60,0,0,0,0,0,0,0,0,
+0,0,0,0,4,4,4,4,4,4,4,4,0,0,4,0x64,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,4,4,4,4,4,4,0,0,
+0x2179,0x21a9,0x21d9,0x2209,0x2239,0x2289,0x22d9,0x2309,0x2339,0,0,0,0,0,0,0,
 0x236a,0x236a,0x236a,0x236a,0x236a,0x236a,0x236a,0x236a,0x236a,0x236a,0x236a,0x236a,0x236a,0x236a,0x236a,0x236a,
-0x236a,0x236a,0x236a,0x236a,0x236a,0x236a,0x236a,0,0,0x236a,0x236a,0x236a,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0x44,0x44,0x44,0,
-0x64,0x64,0x64,0x64,0x64,0x64,0x44,0x44,0x64,0x64,0x64,0x64,0x44,0,0x64,0x64,
-0x64,0x64,0x64,0x64,0x64,0,0,0,0,0x64,0,0,0,0,0,0,
-0x44,0,0,0,0x44,0x44,0,0,0,0,0,0,1,1,1,1,
+0x236a,0x236a,0x236a,0x236a,0x236a,0x236a,0x236a,0x236a,0x236a,0x236a,0x236a,0,0,0x236a,0x236a,0x236a,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0x44,0x44,0x44,0,0x64,0x64,0x64,0x64,0x64,0x64,0x44,0x44,0x64,0x64,0x64,0x64,
+0x44,0,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0,0,0,0,0x64,0,0,
+0,0,0,0,0x44,0,0,0,0x44,0x44,0,0,0,0,0,0,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-1,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x25,5,
-5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,
-1,1,1,1,5,0x2389,1,1,1,0x23a9,1,1,5,5,5,5,
-0x25,5,5,5,0x25,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,
-1,1,1,1,1,1,1,1,1,1,0x23c9,1,1,1,1,1,
-1,1,0x21,1,1,1,1,5,5,5,5,5,0x44,0x44,0x44,0x44,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,0x25,5,5,5,5,5,5,5,5,1,1,1,1,1,
+1,1,1,1,1,1,1,1,5,0x2389,1,1,1,0x23a9,1,1,
+5,5,5,5,0x25,5,5,5,0x25,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,0x23c9,1,
+1,1,1,1,1,1,0x21,1,1,1,1,5,5,5,5,5,
 0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,
-0x44,0x44,0x64,0x64,0x64,0x64,0x64,0x44,0x64,0x64,0x44,0x64,0x44,0x44,0x64,0x44,
-0x44,0x44,0x44,0x44,0x44,0x44,0x64,0x44,0x44,0x64,0x64,0x64,0x64,0x44,0x44,0x44,
-0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x92,0xff91,0x92,0xff91,
-0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xffb1,0x92,0xff91,0x92,0xff91,0x92,0xff91,
-0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x23ea,0x2429,0x92,0xff91,
+0x44,0x44,0x44,0x44,0x44,0x44,0x64,0x64,0x64,0x64,0x64,0x44,0x64,0x64,0x44,0x64,
+0x44,0x44,0x64,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x64,0x44,0x44,0x64,0x64,0x64,
+0x64,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,
+0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xffb1,0x92,0xff91,
 0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
-0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x2469,0x24e9,
-0x2569,0x25e9,0x2669,0x26e9,1,1,0x271a,1,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
-0x92,0xff91,0x92,0xffb1,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
-0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x411,0x411,0x411,0x411,0x411,0x411,0x411,0x411,
-0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0x411,0x411,0x411,0x411,0x411,0x411,0,0,
-0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0,0,0x411,0x411,0x411,0x411,0x411,0x411,0x411,0x411,
-0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0x411,0x411,0x411,0x411,0x411,0x411,0x411,0x411,
-0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0x411,0x411,0x411,0x411,0x411,0x411,0,0,
-0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0,0,0x2769,0x411,0x27e9,0x411,0x2899,0x411,0x2949,0x411,
-0,0xfc12,0,0xfc12,0,0xfc12,0,0xfc12,0x411,0x411,0x411,0x411,0x411,0x411,0x411,0x411,
-0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0x2511,0x2511,0x2b11,0x2b11,0x2b11,0x2b11,0x3211,0x3211,
-0x4011,0x4011,0x3811,0x3811,0x3f11,0x3f11,0,0,0x29f9,0x2a69,0x2ad9,0x2b49,0x2bb9,0x2c29,0x2c99,0x2d09,
-0x2d7b,0x2deb,0x2e5b,0x2ecb,0x2f3b,0x2fab,0x301b,0x308b,0x30f9,0x3169,0x31d9,0x3249,0x32b9,0x3329,0x3399,0x3409,
-0x347b,0x34eb,0x355b,0x35cb,0x363b,0x36ab,0x371b,0x378b,0x37f9,0x3869,0x38d9,0x3949,0x39b9,0x3a29,0x3a99,0x3b09,
-0x3b7b,0x3beb,0x3c5b,0x3ccb,0x3d3b,0x3dab,0x3e1b,0x3e8b,0x411,0x411,0x3ef9,0x3f79,0x3fe9,0,0x4069,0x40e9,
-0xfc12,0xfc12,0xdb12,0xdb12,0x419b,4,0x4209,4,4,4,0x4259,0x42d9,0x4349,0,0x43c9,0x4449,
-0xd512,0xd512,0xd512,0xd512,0x44fb,4,4,4,0x411,0x411,0x4569,0x4619,0,0,0x46e9,0x4769,
-0xfc12,0xfc12,0xce12,0xce12,0,4,4,4,0x411,0x411,0x4819,0x48c9,0x4999,0x391,0x4a19,0x4a99,
-0xfc12,0xfc12,0xc812,0xc812,0xfc92,4,4,4,0,0,0x4b49,0x4bc9,0x4c39,0,0x4cb9,0x4d39,
-0xc012,0xc012,0xc112,0xc112,0x4deb,4,4,0,0,0,0,0,0,0,0,0,
-0,0,0,4,4,4,4,4,0,0,0,0,0,0,0,0,
-4,4,0,0,0,0,0,0,4,0,0,4,0,0,4,4,
-4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,4,4,4,4,4,0,4,4,4,4,4,4,
-4,4,4,4,0,0x25,0,0,0,0,0,0,0,0,0,0,
-0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
-5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0x44,0x44,0x64,0x64,0x44,0x44,0x44,0x44,0x64,0x64,0x64,0x44,
-0x44,4,4,4,4,0x44,4,4,4,0x64,0x64,0x44,0x64,0x44,0x64,0x64,
-0x64,0x64,0x64,0x64,0x44,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,2,0,0,0,0,2,0,0,1,2,
-2,2,1,1,2,2,2,1,0,2,0,0,0,2,2,2,
-2,2,0,0,0,0,0,0,2,0,0x4e5a,0,2,0,0x4e9a,0x4eda,
-2,2,0,1,2,2,0xe12,2,1,0,0,0,0,1,0,0,
-1,1,2,2,0,0,0,0,0,2,1,1,0x21,0x21,0,0,
-0,0,0xf211,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0x812,0x812,0x812,0x812,0x812,0x812,0x812,0x812,0x812,0x812,0x812,0x812,
-0x812,0x812,0x812,0x812,0xf811,0xf811,0xf811,0xf811,0xf811,0xf811,0xf811,0xf811,0xf811,0xf811,0xf811,0xf811,
-0xf811,0xf811,0xf811,0xf811,0,0,0,0x92,0xff91,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0xd12,0xd12,0xd12,0xd12,0xd12,0xd12,0xd12,0xd12,0xd12,0xd12,
-0xd12,0xd12,0xd12,0xd12,0xd12,0xd12,0xd12,0xd12,0xf311,0xf311,0xf311,0xf311,0xf311,0xf311,0xf311,0xf311,
-0xf311,0xf311,0xf311,0xf311,0xf311,0xf311,0xf311,0xf311,0xf311,0xf311,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,
+0x23ea,0x2429,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
+0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
+0x92,0xff91,0x2469,0x24e9,0x2569,0x25e9,0x2669,0x26e9,1,1,0x271a,1,0x92,0xff91,0x92,0xff91,
+0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xffb1,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
+0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x411,0x411,0x411,0x411,
+0x411,0x411,0x411,0x411,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0x411,0x411,0x411,0x411,
+0x411,0x411,0,0,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0,0,0x411,0x411,0x411,0x411,
+0x411,0x411,0x411,0x411,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0x411,0x411,0x411,0x411,
+0x411,0x411,0x411,0x411,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0x411,0x411,0x411,0x411,
+0x411,0x411,0,0,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0,0,0x2769,0x411,0x27e9,0x411,
+0x2899,0x411,0x2949,0x411,0,0xfc12,0,0xfc12,0,0xfc12,0,0xfc12,0x411,0x411,0x411,0x411,
+0x411,0x411,0x411,0x411,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0xfc12,0x2511,0x2511,0x2b11,0x2b11,
+0x2b11,0x2b11,0x3211,0x3211,0x4011,0x4011,0x3811,0x3811,0x3f11,0x3f11,0,0,0x29f9,0x2a69,0x2ad9,0x2b49,
+0x2bb9,0x2c29,0x2c99,0x2d09,0x2d7b,0x2deb,0x2e5b,0x2ecb,0x2f3b,0x2fab,0x301b,0x308b,0x30f9,0x3169,0x31d9,0x3249,
+0x32b9,0x3329,0x3399,0x3409,0x347b,0x34eb,0x355b,0x35cb,0x363b,0x36ab,0x371b,0x378b,0x37f9,0x3869,0x38d9,0x3949,
+0x39b9,0x3a29,0x3a99,0x3b09,0x3b7b,0x3beb,0x3c5b,0x3ccb,0x3d3b,0x3dab,0x3e1b,0x3e8b,0x411,0x411,0x3ef9,0x3f79,
+0x3fe9,0,0x4069,0x40e9,0xfc12,0xfc12,0xdb12,0xdb12,0x419b,4,0x4209,4,4,4,0x4259,0x42d9,
+0x4349,0,0x43c9,0x4449,0xd512,0xd512,0xd512,0xd512,0x44fb,4,4,4,0x411,0x411,0x4569,0x4619,
+0,0,0x46e9,0x4769,0xfc12,0xfc12,0xce12,0xce12,0,4,4,4,0x411,0x411,0x4819,0x48c9,
+0x4999,0x391,0x4a19,0x4a99,0xfc12,0xfc12,0xc812,0xc812,0xfc92,4,4,4,0,0,0x4b49,0x4bc9,
+0x4c39,0,0x4cb9,0x4d39,0xc012,0xc012,0xc112,0xc112,0x4deb,4,4,0,0,0,0,0,
+0,0,0,0,0,0,0,4,4,4,4,4,0,0,0,0,
+0,0,0,0,4,4,0,0,0,0,0,0,4,0,0,4,
+0,0,4,4,4,4,4,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,4,4,4,4,4,0,4,4,
+4,4,4,4,4,4,4,4,0,0x25,0,0,0,0,0,0,
+0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,
+5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0x44,0x44,0x64,0x64,0x44,0x44,0x44,0x44,
+0x64,0x64,0x64,0x44,0x44,4,4,4,4,0x44,4,4,4,0x64,0x64,0x44,
+0x64,0x44,0x64,0x64,0x64,0x64,0x64,0x64,0x44,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,2,
+0,0,1,2,2,2,1,1,2,2,2,1,0,2,0,0,
+0,2,2,2,2,2,0,0,0,0,0,0,2,0,0x4e5a,0,
+2,0,0x4e9a,0x4eda,2,2,0,1,2,2,0xe12,2,1,0,0,0,
+0,1,0,0,1,1,2,2,0,0,0,0,0,2,1,1,
+0x21,0x21,0,0,0,0,0xf211,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0x812,0x812,0x812,0x812,0x812,0x812,0x812,0x812,
+0x812,0x812,0x812,0x812,0x812,0x812,0x812,0x812,0xf811,0xf811,0xf811,0xf811,0xf811,0xf811,0xf811,0xf811,
+0xf811,0xf811,0xf811,0xf811,0xf811,0xf811,0xf811,0xf811,0,0,0,0x92,0xff91,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0xd12,0xd12,0xd12,0xd12,0xd12,0xd12,
+0xd12,0xd12,0xd12,0xd12,0xd12,0xd12,0xd12,0xd12,0xd12,0xd12,0xd12,0xd12,0xf311,0xf311,0xf311,0xf311,
+0xf311,0xf311,0xf311,0xf311,0xf311,0xf311,0xf311,0xf311,0xf311,0xf311,0xf311,0xf311,0xf311,0xf311,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,
 0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,
+0x1812,0x1812,0x1812,0x1812,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,
 0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,
-0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,
-0x92,0xff91,0x4f1a,0x4f3a,0x4f5a,0x4f79,0x4f99,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x4fba,0x4fda,0x4ffa,
-0x501a,1,0x92,0xff91,1,0x92,0xff91,1,1,1,1,1,0x25,5,0x503a,0x503a,
-0x92,0xff91,0x92,0xff91,1,0,0,0,0,0,0,0x92,0xff91,0x92,0xff91,0x44,
-0x44,0x44,0x92,0xff91,0,0,0,0,0,0,0,0,0,0,0,0,
-0x5059,0x5059,0x5059,0x5059,0x5059,0x5059,0x5059,0x5059,0x5059,0x5059,0x5059,0x5059,0x5059,0x5059,0x5059,0x5059,
+0xe811,0xe811,0xe811,0xe811,0x92,0xff91,0x4f1a,0x4f3a,0x4f5a,0x4f79,0x4f99,0x92,0xff91,0x92,0xff91,0x92,
+0xff91,0x4fba,0x4fda,0x4ffa,0x501a,1,0x92,0xff91,1,0x92,0xff91,1,1,1,1,1,
+0x25,5,0x503a,0x503a,0x92,0xff91,0x92,0xff91,1,0,0,0,0,0,0,0x92,
+0xff91,0x92,0xff91,0x44,0x44,0x44,0x92,0xff91,0,0,0,0,0,0,0,0,
+0,0,0,0,0x5059,0x5059,0x5059,0x5059,0x5059,0x5059,0x5059,0x5059,0x5059,0x5059,0x5059,0x5059,
 0x5059,0x5059,0x5059,0x5059,0x5059,0x5059,0x5059,0x5059,0x5059,0x5059,0x5059,0x5059,0x5059,0x5059,0x5059,0x5059,
-0x5059,0x5059,0,0x5059,0,0,0,0,0,0x5059,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0x64,
-0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,
+0x5059,0x5059,0x5059,0x5059,0x5059,0x5059,0,0x5059,0,0,0,0,0,0x5059,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0x64,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,
 0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,
-0,0,0,0,0,0,0,0,0,0,0x64,0x64,0x64,0x64,0x60,0x60,
-0,4,4,4,4,4,0,0,0,0,0,4,0,0,0,0,
+0x44,0x44,0x44,0x44,0,0,0,0,0,0,0,0,0,0,0x64,0x64,
+0x64,0x64,0x60,0x60,0,4,4,4,4,4,0,0,0,0,0,4,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0x64,0x64,4,4,4,4,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0x64,0x64,4,4,4,4,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,4,4,4,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x507a,0x50b9,
-0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
-0x92,0xff91,0x92,0xff91,0x92,0xff91,0,0x44,4,4,4,0,0x44,0x44,0x44,0x44,
-0x44,0x44,0x44,0x44,0x44,0x44,0,4,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
+0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
+0x92,0xff91,0x507a,0x50b9,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
+0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0,0x44,4,4,4,0,
+0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0,4,0x92,0xff91,0x92,0xff91,
 0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
-0x92,0xff91,0x92,0xff91,5,5,0x44,0x44,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0x44,0x44,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,
+0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,5,5,0x44,0x44,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0x44,0x44,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,
 4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
-4,4,4,4,4,4,4,4,4,4,0x92,0xff91,0x92,0xff91,0x92,0xff91,
-0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,1,1,0x92,0xff91,0x92,0xff91,0x92,0xff91,
-0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,5,1,1,1,
-1,1,1,1,1,0x92,0xff91,0x92,0xff91,0x50fa,0x92,0xff91,0x92,0xff91,0x92,0xff91,
-0x92,0xff91,0x92,0xff91,4,4,4,0x92,0xff91,0x511a,1,0,0x92,0xff91,0x92,0xff91,
-0x1811,1,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x513a,0x515a,
-0x517a,0x519a,0x513a,1,0x51ba,0x51da,0x51fa,0x521a,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
-0x92,0xff91,0x92,0xff91,0xe812,0x523a,0x525a,0x92,0xff91,0x92,0xff91,0,0,0,0,0,
-0x92,0xff91,0,1,0,1,0x92,0xff91,0x92,0xff91,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,
-4,0x92,0xff91,0,5,5,1,0,0,0,0,0,0,0,4,0,
-0,0,0x64,0,0,0,0,4,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,
-0,0,0,0,0x64,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0x64,4,0,0,0,0,0,0,
+4,4,4,4,4,4,4,4,4,4,4,4,4,4,0x92,0xff91,
+0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,1,1,0x92,0xff91,
+0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
+5,1,1,1,1,1,1,1,1,0x92,0xff91,0x92,0xff91,0x50fa,0x92,0xff91,
+0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,4,4,4,0x92,0xff91,0x511a,1,0,
+0x92,0xff91,0x92,0xff91,0x1811,1,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
+0x92,0xff91,0x513a,0x515a,0x517a,0x519a,0x513a,1,0x51ba,0x51da,0x51fa,0x521a,0x92,0xff91,0x92,0xff91,
+0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0xe812,0x523a,0x525a,0x92,0xff91,0x92,0xff91,0,
+0,0,0,0,0x92,0xff91,0,1,0,1,0x92,0xff91,0x92,0xff91,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,5,5,5,0x92,0xff91,0,5,5,1,0,0,0,0,0,
+0,0,4,0,0,0,0x64,0,0,0,0,4,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,4,4,0,0,0,0,0,0x64,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0x64,4,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,
+0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0,0,0,0,0,0,
+0,0,0,0,0,0,0,4,0,0,0,0,0,0,4,4,
+4,4,4,0x64,0x64,0x64,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,
+4,4,4,4,4,4,0,0x60,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0x64,0,0,4,4,
+4,4,0,0,4,4,0,0,0x60,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,0,
+0,4,4,0,0,4,4,0,0,0,0,0,0,0,0,0,
+0,0,0,4,0,0,0,0,0,0,0,0,4,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,
-0x44,0x44,0x44,0x44,0x44,0x44,0,0,0,0,0,0,0,0,0,0,
-0,0,0,4,0,0,0,0,0,0,4,4,4,4,4,0x64,
-0x64,0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,
-4,4,0,0x60,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0x64,0,0,4,4,4,4,0,0,
-4,4,0,0,0x60,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,4,4,4,4,4,4,0,0,4,4,0,
-0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,4,
-0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,
-0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0x44,0,0x44,0x44,
-0x64,0,0,0x44,0x44,0,0,0,0,0,0x44,0x44,0,0x44,0,0,
+4,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,4,4,0,0,0,0,0,4,
-4,0,0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,
-1,1,1,1,1,1,1,0x5279,1,1,1,1,1,1,1,4,
-5,5,5,5,1,1,1,1,1,1,1,1,1,4,4,4,
-0,0,0,0,0x5299,0x52c9,0x52f9,0x5329,0x5359,0x5389,0x53b9,0x53e9,0x5419,0x5449,0x5479,0x54a9,
-0x54d9,0x5509,0x5539,0x5569,0x5b99,0x5bc9,0x5bf9,0x5c29,0x5c59,0x5c89,0x5cb9,0x5ce9,0x5d19,0x5d49,0x5d79,0x5da9,
-0x5dd9,0x5e09,0x5e39,0x5e69,0x5e99,0x5ec9,0x5ef9,0x5f29,0x5f59,0x5f89,0x5fb9,0x5fe9,0x6019,0x6049,0x6079,0x60a9,
-0x60d9,0x6109,0x6139,0x6169,0x5599,0x55c9,0x55f9,0x5629,0x5659,0x5689,0x56b9,0x56e9,0x5719,0x5749,0x5779,0x57a9,
-0x57d9,0x5809,0x5839,0x5869,0x5899,0x58c9,0x58f9,0x5929,0x5959,0x5989,0x59b9,0x59e9,0x5a19,0x5a49,0x5a79,0x5aa9,
-0x5ad9,0x5b09,0x5b39,0x5b69,0,0,0,0,0,4,0,0,4,0,0,0,
-0,0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0x6199,0x6219,0x6299,0x6319,0x63c9,0x6479,0x6519,0,0,0,0,0,
-0,0,0,0,0,0,0,0x65b9,0x6639,0x66b9,0x6739,0x67b9,0,0,0,0,
-0,0,0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,
-4,4,4,4,4,4,4,4,0,0,0,4,0,0,0,0,
-0,0,0,0,0,0,0,0,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x64,
-0x64,0x64,0x64,0x64,0x64,0x64,0x44,0x44,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,4,0,0,4,0,0,
-0,0,0,0,0,0,0,0,0,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,
+0x44,0,0x44,0x44,0x64,0,0,0x44,0x44,0,0,0,0,0,0x44,0x44,
+0,0x44,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,
+0,0,0,4,4,0,0x64,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,0x5279,1,1,1,1,
+1,1,1,4,5,5,5,5,1,1,1,1,1,1,1,1,
+1,5,4,4,0,0,0,0,0x5299,0x52c9,0x52f9,0x5329,0x5359,0x5389,0x53b9,0x53e9,
+0x5419,0x5449,0x5479,0x54a9,0x54d9,0x5509,0x5539,0x5569,0x5b99,0x5bc9,0x5bf9,0x5c29,0x5c59,0x5c89,0x5cb9,0x5ce9,
+0x5d19,0x5d49,0x5d79,0x5da9,0x5dd9,0x5e09,0x5e39,0x5e69,0x5e99,0x5ec9,0x5ef9,0x5f29,0x5f59,0x5f89,0x5fb9,0x5fe9,
+0x6019,0x6049,0x6079,0x60a9,0x60d9,0x6109,0x6139,0x6169,0x5599,0x55c9,0x55f9,0x5629,0x5659,0x5689,0x56b9,0x56e9,
+0x5719,0x5749,0x5779,0x57a9,0x57d9,0x5809,0x5839,0x5869,0x5899,0x58c9,0x58f9,0x5929,0x5959,0x5989,0x59b9,0x59e9,
+0x5a19,0x5a49,0x5a79,0x5aa9,0x5ad9,0x5b09,0x5b39,0x5b69,0,0,0,0,0,4,0,0,
+4,0,0,0,0,0x64,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0x6199,0x6219,0x6299,0x6319,0x63c9,0x6479,0x6519,0,
+0,0,0,0,0,0,0,0,0,0,0,0x65b9,0x6639,0x66b9,0x6739,0x67b9,
+0,0,0,0,0,0,0x64,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,
+4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,4,
+0,0,0,0,0,0,0,0,0,0,0,0,0x44,0x44,0x44,0x44,
+0x44,0x44,0x44,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x44,0x44,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,
+0,4,0,0,0,0,0,0,0,0,0,0,0,0x1012,0x1012,0x1012,
 0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,
-0x1012,0x1012,0x1012,0,0,0,4,0,4,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,
+0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0,0,0,4,0,4,0xf011,0xf011,0xf011,
 0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,
-0xf011,0xf011,0xf011,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,
+0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0x64,0,0,
-0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0x44,0x44,0x44,0x44,0x44,0,0,0,0,0,0x1412,0x1412,0x1412,0x1412,
+0,0x64,0,0,0x64,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0x44,0x44,0x44,0x44,0x44,0,0,0,0,0,
+0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,
 0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,
-0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0xec11,0xec11,0xec11,0xec11,
-0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,
-0xec11,0xec11,0xec11,0xec11,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,
-0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0,0,0,0,0xec11,0xec11,0xec11,0xec11,
 0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,
 0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,
-0x1392,0x1392,0x1392,0,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0,0x1392,0x1392,0,0xec91,
-0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0,0xec91,0xec91,0xec91,0xec91,0xec91,
-0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0,0xec91,0xec91,0xec91,0xec91,0xec91,
-0xec91,0xec91,0,0xec91,0xec91,0,0,0,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,0,5,5,5,5,5,5,
-5,5,5,0,0,0,0,0,5,4,4,5,5,5,0,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,0,4,4,4,0,4,4,0,
-0,0,0,0,4,0x64,4,0x44,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0x44,0x64,0x64,0,0,0,0,0x64,0,0,0,0,0,0x44,0x64,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,
+0,0,0,0,0,0,0,0,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,
+0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0,0,0,0,
+0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,
+0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0x1392,0x1392,0x1392,0x1392,
+0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0,
+0x1392,0x1392,0,0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0,0xec91,
+0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0,0xec91,
+0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0,0xec91,0xec91,0,0,0,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,0,5,5,
+5,5,5,5,5,5,5,0,0,0,0,0,5,4,4,5,
+5,5,0,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,0,4,4,4,
+0,4,4,0,0,0,0,0,4,0x64,4,0x44,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0x44,0x64,0x64,0,0,0,0,0x64,0,0,0,0,
+0,0x44,0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0x2012,0x2012,0x2012,0x2012,
 0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,
-0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,
+0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0xe011,0xe011,0xe011,0xe011,
 0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,
-0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0x44,0x44,0x44,0x44,0,0,0,0,
+0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0x44,0x44,0x44,0x44,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0x44,0x44,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0x64,0x64,
-0x44,0x44,0x44,0x64,0x44,0x64,0x64,0x64,0x64,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0x44,0x64,0x44,0x64,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0x44,0x44,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,
-4,4,0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0x64,0,0,4,
-4,0,0,0,0,0,0,0,0,0,0,0x64,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,
-4,4,4,0,0,0x64,0x64,0,0,4,0,0,0,0,4,0,
-0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0x44,0x44,0x44,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0x64,0x64,0x64,
+0,0,0,0,0,0,0x64,0x64,0x44,0x44,0x44,0x64,0x44,0x64,0x64,0x64,
+0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0x44,0x64,0x44,0x64,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,
-4,4,4,4,0,4,4,4,4,4,4,0x64,0x64,0,0,0,
+4,4,4,4,4,4,4,4,4,4,0x64,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0x64,0,0,4,4,0,0,0,0,0,0,0,
 0,0,0,0x64,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,
-4,4,4,0,0x60,0,0,0,0,0,0,0,0,4,0x64,4,
-4,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,4,4,4,0,0,4,0x60,0x64,4,
-0,0,0,0,0,0,4,0,0,0,0,4,4,4,4,4,
-4,0x64,0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,
-0,0,0,0,0,0x60,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0x44,0x44,0x44,0x44,0x44,0x44,
-0x44,0,0,0,0x44,0x44,0x44,0x44,0x44,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0x64,4,4,0,0x64,0,0,0,0,0,
+0,0,0,0,0,0,0,4,4,4,4,0,0,0x64,0x64,0,
+0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,0,
+0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0x44,0x44,0x44,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0x44,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,4,4,4,4,4,4,0,4,0,
-0,0,0,4,4,0,0x64,0x64,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,4,4,4,4,4,0,4,4,4,
+4,4,4,0x64,0x64,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0x64,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,4,4,4,4,0,0,0,0,0,0,
-4,4,0,0x64,0x64,0,0,0,0,0,0,0,0,0,0,0,
+0,0,4,4,4,4,4,4,4,4,4,0,0x60,0,0,0,
+0,0,0,0,0,4,0x64,4,4,0,0,4,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,
+4,4,0,0,4,0x60,0x64,4,0,0,0,0,0,0,4,0,
+0,0,0,4,4,4,4,4,4,0x64,0x64,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,0,
-0,4,0,0x64,0,0,0,0,0,0,0,0,0,0,0,4,
-0,4,0,0,4,4,4,4,4,4,0x60,0x64,0,0,0,0,
+4,0,0,0,0,0,0,0,0,0,0,0,0,0x60,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,4,4,4,0,0,4,4,
-4,4,0,4,4,4,4,0x64,0,0,0,0,0,0,0,0,
+0,0,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0,0,0,0x44,0x44,0x44,0x44,
+0x44,0,0,0,0,0,0,0,0,0,0,0,0,0,0x64,4,
+4,0,0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0x44,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,
-4,4,4,4,4,4,4,4,0,0x64,0x64,0,0,0,0,0,
-0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,
-0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,
-0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,
-0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,
+4,4,4,4,4,0,4,0,0,0,0,4,4,0,0x64,0x64,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,4,4,0x60,0x64,0,
-0,0,0,0x64,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,
+4,4,0,0,0,0,0,0,4,4,0,0x64,0x64,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-4,4,4,4,0,0,4,4,0,0,0,0,0,4,4,4,
-4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,4,4,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,
-0x64,4,4,4,4,0,0,4,4,4,4,0,0,0,0,0,
-0,0,0,0x64,0,0,0,0,0,0,0,0,0,4,4,4,
-4,4,4,0,0,4,4,4,0,0,0,0,0,0,0,0,
-0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,0,
-4,0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,4,4,4,4,4,4,4,0,4,4,4,4,
-4,4,0,0x64,4,4,4,4,4,4,4,4,0,0,4,4,
-4,4,4,4,4,0,4,4,0,4,4,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,
-4,4,4,0,0,0,4,0,4,4,0,4,4,4,0x64,4,
-0x64,0x64,0,4,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,
-0,4,0,0x64,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,4,4,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,
-4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0x64,0x64,0x64,0x64,0x64,0,0,0,
+4,4,4,4,4,4,4,0,0,4,0,0x64,0,0,0,0,
+0,0,0,0,0,0,0,4,0,4,0,0,4,4,4,4,
+4,4,0x60,0x64,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,4,4,4,0,0,4,4,4,4,0,4,4,4,4,0x64,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0x44,0x44,0x44,0x44,0x44,0x44,0x44,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,
-4,4,4,4,4,4,4,4,4,4,0,4,4,0,0,0,
-0,0,0,0,0,0,0,0,0x60,0x60,0,0,0,0,0,0,
+0,0x64,0x64,0,0,0,0,0,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,
+0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,
+0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,
+0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,
+0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,4,4,0x60,0x64,0,0,0,0,0x64,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,4,4,4,4,0,0,4,4,
+0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,4,0x64,4,4,4,4,0,0,4,
+4,4,4,0,0,0,0,0,0,0,0,0x64,0,0,0,0,
+0,0,0,0,0,4,4,4,4,4,4,0,0,4,4,4,
+0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,
+4,4,4,4,4,4,4,0,4,0x64,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,
-0,4,4,4,4,4,4,4,0,4,4,0,0,0,0,0,
+4,4,4,0,4,4,4,4,4,4,0,0x64,4,4,4,4,
+4,4,4,4,0,0,4,4,4,4,4,4,4,0,4,4,
+0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,4,4,4,4,4,4,0,0,0,4,0,
+4,4,0,4,4,4,0x64,4,0x64,0x64,0,4,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,4,0x64,0,4,4,4,4,
-4,4,4,4,4,4,4,4,4,4,0,0,4,4,4,4,
-4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,
+0,0,0,0,4,4,0,0,0,4,0,0x64,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,
+4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,0,
+0,0,0,0,4,0x60,0x64,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0x60,0x60,0x64,0x64,0x64,0,0,
-0,0x60,0x60,0x60,0x60,0x60,0x60,4,4,4,4,4,4,4,4,0x64,
-0x64,0x64,0x64,0x64,0x64,0x64,0x64,0,0,0x44,0x44,0x44,0x44,0x44,0x64,0x64,
+0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,
+4,4,4,4,4,0,0,0,0,0,0,4,4,4,4,4,
+4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0x64,0x64,0x64,0x64,
+0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,
+4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,4,
+4,0,0,0,0,0,0,0,0,0,0,0,0x60,0x60,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+4,4,4,4,0,4,4,4,4,4,4,4,0,4,4,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,4,0x64,0,
+4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,
+4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
+4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0x60,0x60,0x64,
+0x64,0x64,0,0,0,0x60,0x60,0x60,0x60,0x60,0x60,4,4,4,4,4,
+4,4,4,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0,0,0x44,0x44,0x44,
+0x44,0x44,0x64,0x64,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0x44,0x44,0x44,0x44,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0x44,0x44,0x44,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0x44,0x44,0x44,0x44,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0x44,0x44,
-0x44,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,
-2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-2,2,2,2,2,2,1,1,1,1,1,1,1,1,0x21,0x21,
-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,
-1,1,1,1,1,0,0x21,0x21,1,1,1,1,1,1,1,1,
 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
 2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,
 1,1,0x21,0x21,1,1,1,1,1,1,1,1,1,1,1,1,
-1,1,1,1,2,0,2,2,0,0,2,0,0,2,2,0,
-0,2,2,2,2,0,2,2,2,2,2,2,2,2,1,1,
-1,1,0,1,0,1,0x21,0x21,1,1,1,1,0,1,1,1,
-1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,
-2,2,2,2,2,2,2,2,1,1,1,1,2,2,0,2,
-2,2,2,0,0,2,2,2,2,2,2,2,2,0,2,2,
-2,2,2,2,2,0,1,1,1,1,1,1,1,1,0x21,0x21,
-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-2,2,0,2,2,2,2,0,2,2,2,2,2,0,2,0,
-0,0,2,2,2,2,2,2,2,0,1,1,1,1,1,1,
+1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,
+2,2,1,1,1,1,1,1,1,0,0x21,0x21,1,1,1,1,
+1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,
+2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,
+1,1,1,1,1,1,0x21,0x21,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,2,0,2,2,0,0,2,0,
+0,2,2,0,0,2,2,2,2,0,2,2,2,2,2,2,
+2,2,1,1,1,1,0,1,0,1,0x21,0x21,1,1,1,1,
+0,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,
+2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,
+2,2,0,2,2,2,2,0,0,2,2,2,2,2,2,2,
+2,0,2,2,2,2,2,2,2,0,1,1,1,1,1,1,
 1,1,0x21,0x21,1,1,1,1,1,1,1,1,1,1,1,1,
-2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,2,2,0,2,2,2,2,0,2,2,2,2,
+2,0,2,0,0,0,2,2,2,2,2,2,2,0,1,1,
+1,1,1,1,1,1,0x21,0x21,1,1,1,1,1,1,1,1,
 1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,
-2,2,2,2,1,1,1,1,1,1,0,0,2,2,2,2,
+2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,
+2,2,2,2,2,2,2,2,1,1,1,1,1,1,0,0,
 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-2,2,2,2,2,0,1,1,1,1,1,1,1,1,1,1,
-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
-1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,
-2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,
+2,2,2,2,2,2,2,2,2,0,1,1,1,1,1,1,
 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-1,1,1,1,1,0,1,1,1,1,1,1,2,2,2,2,
-2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,0,
-1,1,1,1,1,1,2,1,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,
+1,1,1,0,1,1,1,1,1,1,2,2,2,2,2,2,
+2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
+2,2,2,0,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,
+2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
+1,1,1,0,1,1,1,1,1,1,2,1,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
-4,4,4,0,0,0,0,4,4,4,4,4,4,4,4,4,
-4,4,4,4,4,0,0,0,0,0,0,0,0,4,0,0,
-0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,
-4,4,4,4,0,4,4,4,4,4,4,4,4,4,4,4,
-4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0,0x44,0x44,0x44,0x44,
-0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0,0,0x44,
-0x44,0x44,0x44,0x44,1,1,1,1,1,1,1,1,1,1,0,1,
-1,1,1,1,1,1,1,1,1,1,1,1,1,1,0x21,1,
-1,1,1,0,0x44,0x44,0,0x44,0x44,0,0x44,0x44,0x44,0x44,0x44,0,
+4,4,4,4,4,4,4,0,0,0,0,4,4,4,4,4,
+4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,
+0,4,0,0,0,0,0,0,0,0,0,0,4,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,4,4,4,4,4,0,4,4,4,4,4,4,4,
+4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0,
+0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,
+0x44,0,0,0x44,0x44,0x44,0x44,0x44,1,1,1,1,1,1,1,1,
+1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,0x21,1,1,1,1,0,0,0,0,0,0,1,1,1,
+1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0x44,0x44,0,0x44,0x44,0,0x44,0x44,
+0x44,0x44,0x44,0,0,0,0,0,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,0x25,5,5,5,5,5,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0x44,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
+0x25,0x25,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0x44,0x44,0x44,0x44,0x44,0x44,0x44,4,4,4,4,4,
-4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,4,
+0x64,0x64,0x64,0x44,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0,0,0,0,0,
 0,0,0,0,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,
 0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,
@@ -965,17 +980,17 @@ static const UCaseProps ucase_props_singleton={
   ucase_props_unfold,
   {
     ucase_props_trieIndex,
-    ucase_props_trieIndex+3408,
+    ucase_props_trieIndex+3412,
     NULL,
-    3408,
-    9500,
+    3412,
+    9736,
     0x188,
-    0xdcc,
+    0xdd0,
     0x0,
     0x0,
     0xe0800,
-    0x3268,
-    NULL, 0, FALSE, FALSE, 0, NULL
+    0x3358,
+    NULL, 0, false, false, 0, NULL
   },
   { 4,0,0,0 }
 };
diff --git a/deps/icu-small/source/common/ucasemap.cpp b/deps/icu-small/source/common/ucasemap.cpp
index 95b55d56a0..fc0439db0f 100644
--- a/deps/icu-small/source/common/ucasemap.cpp
+++ b/deps/icu-small/source/common/ucasemap.cpp
@@ -157,7 +157,7 @@ appendResult(int32_t cpLength, int32_t result, const UChar *s,
             ByteSinkUtil::appendCodePoint(cpLength, result, sink, edits);
         }
     }
-    return TRUE;
+    return true;
 }
 
 // See unicode/utf8.h U8_APPEND_UNSAFE().
@@ -525,14 +525,14 @@ ucasemap_internalUTF8ToTitle(
     csc.p=(void *)src;
     csc.limit=srcLength;
     int32_t prev=0;
-    UBool isFirstIndex=TRUE;
+    UBool isFirstIndex=true;
 
     /* titlecasing loop */
     while(prev<srcLength) {
         /* find next index where to titlecase */
         int32_t index;
         if(isFirstIndex) {
-            isFirstIndex=FALSE;
+            isFirstIndex=false;
             index=iter->first();
         } else {
             index=iter->next();
@@ -643,12 +643,12 @@ UBool isFollowedByCasedLetter(const uint8_t *s, int32_t i, int32_t length) {
         if ((type & UCASE_IGNORABLE) != 0) {
             // Case-ignorable, continue with the loop.
         } else if (type != UCASE_NONE) {
-            return TRUE;  // Followed by cased letter.
+            return true;  // Followed by cased letter.
         } else {
-            return FALSE;  // Uncased and not case-ignorable.
+            return false;  // Uncased and not case-ignorable.
         }
     }
-    return FALSE;  // Not followed by cased letter.
+    return false;  // Not followed by cased letter.
 }
 
 // Keep this consistent with the UTF-16 version in ustrcase.cpp and the Java version in CaseMap.java.
@@ -707,7 +707,7 @@ void toUpper(uint32_t options,
                 nextState |= AFTER_VOWEL_WITH_ACCENT;
             }
             // Map according to Greek rules.
-            UBool addTonos = FALSE;
+            UBool addTonos = false;
             if (upper == 0x397 &&
                     (data & HAS_ACCENT) != 0 &&
                     numYpogegrammeni == 0 &&
@@ -718,7 +718,7 @@ void toUpper(uint32_t options,
                 if (i == nextIndex) {
                     upper = 0x389;  // Preserve the precomposed form.
                 } else {
-                    addTonos = TRUE;
+                    addTonos = true;
                 }
             } else if ((data & HAS_DIALYTIKA) != 0) {
                 // Preserve a vowel with dialytika in precomposed form if it exists.
@@ -733,7 +733,7 @@ void toUpper(uint32_t options,
 
             UBool change;
             if (edits == nullptr && (options & U_OMIT_UNCHANGED_TEXT) == 0) {
-                change = TRUE;  // common, simple usage
+                change = true;  // common, simple usage
             } else {
                 // Find out first whether we are changing the text.
                 U_ASSERT(0x370 <= upper && upper <= 0x3ff);  // 2-byte UTF-8, main Greek block
diff --git a/deps/icu-small/source/common/uchar.cpp b/deps/icu-small/source/common/uchar.cpp
index 61e9c3d900..7789a3b88a 100644
--- a/deps/icu-small/source/common/uchar.cpp
+++ b/deps/icu-small/source/common/uchar.cpp
@@ -126,7 +126,7 @@ u_isxdigit(UChar32 c) {
         (c<=0x66 && c>=0x41 && (c<=0x46 || c>=0x61)) ||
         (c>=0xff21 && c<=0xff46 && (c<=0xff26 || c>=0xff41))
     ) {
-        return TRUE;
+        return true;
     }
 
     GET_PROPS(c, props);
@@ -249,7 +249,7 @@ U_CAPI UBool U_EXPORT2
 u_isprint(UChar32 c) {
     uint32_t props;
     GET_PROPS(c, props);
-    /* comparing ==0 returns FALSE for the categories mentioned */
+    /* comparing ==0 returns false for the categories mentioned */
     return (UBool)((CAT_MASK(props)&U_GC_C_MASK)==0);
 }
 
@@ -273,7 +273,7 @@ U_CAPI UBool U_EXPORT2
 u_isgraph(UChar32 c) {
     uint32_t props;
     GET_PROPS(c, props);
-    /* comparing ==0 returns FALSE for the categories mentioned */
+    /* comparing ==0 returns false for the categories mentioned */
     return (UBool)((CAT_MASK(props)&
                     (U_GC_CC_MASK|U_GC_CF_MASK|U_GC_CS_MASK|U_GC_CN_MASK|U_GC_Z_MASK))
                    ==0);
@@ -291,7 +291,7 @@ u_isgraphPOSIX(UChar32 c) {
     uint32_t props;
     GET_PROPS(c, props);
     /* \p{space}\p{gc=Control} == \p{gc=Z}\p{Control} */
-    /* comparing ==0 returns FALSE for the categories mentioned */
+    /* comparing ==0 returns false for the categories mentioned */
     return (UBool)((CAT_MASK(props)&
                     (U_GC_CC_MASK|U_GC_CS_MASK|U_GC_CN_MASK|U_GC_Z_MASK))
                    ==0);
@@ -591,7 +591,7 @@ uscript_hasScript(UChar32 c, UScriptCode sc) {
     uint32_t sc32=sc;
     if(sc32>0x7fff) {
         /* Guard against bogus input that would make us go past the Script_Extensions terminator. */
-        return FALSE;
+        return false;
     }
     while(sc32>*scx) {
         ++scx;
@@ -654,7 +654,7 @@ _enumPropertyStartsRange(const void *context, UChar32 start, UChar32 end, uint32
     sa->add(sa->set, start);
     (void)end;
     (void)value;
-    return TRUE;
+    return true;
 }
 
 #define USET_ADD_CP_AND_NEXT(sa, cp) sa->add(sa->set, cp); sa->add(sa->set, cp+1)
diff --git a/deps/icu-small/source/common/uchar_props_data.h b/deps/icu-small/source/common/uchar_props_data.h
index c45b9da3fd..acbeadd249 100644
--- a/deps/icu-small/source/common/uchar_props_data.h
+++ b/deps/icu-small/source/common/uchar_props_data.h
@@ -9,146 +9,146 @@
 
 #ifdef INCLUDED_FROM_UCHAR_C
 
-static const UVersionInfo dataVersion={0xe,0,0,0};
+static const UVersionInfo dataVersion={0xf,0,0,0};
 
-static const uint16_t propsTrie_index[22688]={
-0x48c,0x494,0x49c,0x4a4,0x4bc,0x4c4,0x4cc,0x4d4,0x4dc,0x4e4,0x4ea,0x4f2,0x4fa,0x502,0x50a,0x512,
-0x518,0x520,0x528,0x530,0x533,0x53b,0x543,0x54b,0x553,0x55b,0x557,0x55f,0x567,0x56f,0x574,0x57c,
-0x584,0x58c,0x590,0x598,0x5a0,0x5a8,0x5b0,0x5b8,0x5b4,0x5bc,0x5c1,0x5c9,0x5cf,0x5d7,0x5df,0x5e7,
-0x5ef,0x5f7,0x5ff,0x607,0x60c,0x614,0x617,0x61f,0x627,0x62f,0x635,0x63d,0x63c,0x644,0x64c,0x654,
-0x664,0x65c,0x66c,0x674,0x67a,0x5f7,0x68a,0x682,0x69a,0x69c,0x6a4,0x692,0x6b4,0x6ba,0x6c2,0x6ac,
-0x6d2,0x6d8,0x6e0,0x6ca,0x6f0,0x6f6,0x6fe,0x6e8,0x70e,0x714,0x71c,0x706,0x72c,0x734,0x73c,0x724,
-0x74c,0x752,0x75a,0x744,0x76a,0x770,0x778,0x762,0x788,0x78d,0x795,0x780,0x7a5,0x7ac,0x7b4,0x79d,
-0x638,0x7bc,0x7c4,0x4ac,0x7cc,0x7d3,0x7db,0x4ac,0x7e3,0x7eb,0x7f3,0x7f8,0x800,0x807,0x80f,0x4ac,
-0x5f7,0x817,0x81f,0x827,0x82f,0x584,0x83f,0x837,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x847,0x5f7,0x84f,0x853,0x85b,0x5f7,0x861,0x5f7,0x867,0x86f,0x877,0x584,0x584,0x87f,
-0x887,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x88c,0x894,0x5f7,0x5f7,0x89c,0x8a4,0x8ac,0x8b4,0x8bc,0x5f7,0x8c4,0x8cc,0x8d4,
-0x8e4,0x5f7,0x8ec,0x8ee,0x8f6,0x8dc,0x5f7,0x8f9,0x90d,0x901,0x909,0x915,0x5f7,0x91d,0x923,0x92b,
-0x933,0x5f7,0x943,0x94b,0x953,0x93b,0x963,0x4ac,0x96b,0x96e,0x976,0x95b,0x986,0x97e,0x5f7,0x98d,
-0x5f7,0x99c,0x995,0x9a4,0x9ac,0x9b0,0x9b8,0x9c0,0x52c,0x9c8,0x9cb,0x9d1,0x9d8,0x9cb,0x553,0x553,
-0x4dc,0x4dc,0x4dc,0x4dc,0x9e0,0x4dc,0x4dc,0x4dc,0x9f0,0x9f8,0xa00,0xa08,0xa10,0xa14,0xa1c,0x9e8,
-0xa34,0xa3c,0xa24,0xa2c,0xa44,0xa4c,0xa54,0xa5c,0xa74,0xa64,0xa6c,0xa7c,0xa84,0xa93,0xa98,0xa8b,
-0xaa0,0xaa0,0xaa0,0xaa0,0xaa0,0xaa0,0xaa0,0xaa0,0xaa8,0xab0,0x92b,0xab3,0xabb,0xac2,0xac7,0xacf,
-0x92b,0xad6,0xad5,0xae6,0xae9,0x92b,0x92b,0xade,0x92b,0x92b,0x92b,0x92b,0x92b,0xaf8,0xb00,0xaf0,
-0x92b,0x92b,0x92b,0xb05,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0xb0b,0xb13,0x92b,0xb1b,0xb22,
-0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0xaa0,0xaa0,0xaa0,0xaa0,0xb2a,0xaa0,0xb31,0xb38,
-0xaa0,0xaa0,0xaa0,0xaa0,0xaa0,0xaa0,0xaa0,0xaa0,0x92b,0xb40,0xb47,0xb4b,0xb51,0x92b,0x92b,0x92b,
-0x584,0x58c,0x52c,0xb59,0x4dc,0x4dc,0x4dc,0xb61,0x52c,0xb69,0x5f7,0xb6f,0xb7f,0xb77,0xb77,0x553,
-0xb87,0xb8f,0xb97,0x4ac,0xb9f,0x92b,0x92b,0xba6,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0xbae,0xbb4,
-0xbc4,0xbbc,0x638,0x5f7,0xbcc,0x887,0x5f7,0xbd4,0xbdc,0xbe0,0x5f7,0x5f7,0xbe5,0x5f7,0x92b,0xbec,
-0xad0,0xbf4,0xbfa,0x92b,0xbf4,0xc02,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,
-0xc0a,0x5f7,0x5f7,0x5f7,0xc12,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0xc18,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0xc1d,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x92b,0x92b,
-0xc25,0x5f7,0xc28,0x5f7,0xc30,0xc36,0xc3e,0xc46,0xc4b,0x5f7,0x5f7,0xc4f,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0xc56,0x5f7,0xc5d,0xc63,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0xc6b,0x5f7,0x5f7,0x5f7,0xc73,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0xc75,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0xc7c,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0xc83,0x5f7,0x5f7,0x5f7,0xc8a,0xc92,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0xc97,0x5f7,0x5f7,0xc9f,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0xca3,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0xca6,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0xca9,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0xcaf,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0xcb7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0xcbc,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0xcc1,0x5f7,0x5f7,0x5f7,0xcc6,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0xcce,0xcd5,0xcd9,0x5f7,0x5f7,0x5f7,0xce0,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0xcee,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0xce6,0x92b,0xcf6,0x9a4,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0xcfb,0xd03,0x4dc,0xd13,0xd0b,0x5f7,0x5f7,0xd1b,0xd23,0xd33,0x4dc,0xd38,0xd40,0xd46,0xd4d,0xd2b,
-0xd55,0xd5d,0x5f7,0xd65,0xd75,0xd78,0xd6d,0xd80,0x64c,0xd88,0xd8f,0x8ed,0x69a,0xd9f,0xd97,0xda7,
-0x5f7,0xdaf,0xdb7,0xdbf,0x5f7,0xdc7,0xdcf,0xdd7,0xddf,0xde7,0xdeb,0xdf3,0x52c,0x52c,0x5f7,0xdfb,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0xe03,0xe0f,0xe07,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,
-0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,
-0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,
-0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,
-0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,
-0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,
-0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,
-0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,
-0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,
-0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,
-0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,
-0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,
-0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,
-0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,
-0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0x5f7,0x5f7,0x5f7,0xe27,0x5f7,0xce1,0xe2e,0xe33,
-0x5f7,0x5f7,0x5f7,0xe3b,0x5f7,0x5f7,0x8f8,0x4ac,0xe51,0xe41,0xe49,0x5f7,0x5f7,0xe59,0xe61,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0xe66,0x92f,0x5f7,0xe6e,0x5f7,0xe74,0xe78,
-0xe80,0xe88,0xe8f,0xe97,0x5f7,0x5f7,0x5f7,0xe9d,0xeb5,0x49c,0xebd,0xec5,0xeca,0x90d,0xea5,0xead,
-0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,
-0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,0xe17,
-0x12b0,0x12b0,0x12f0,0x1330,0x1370,0x13a8,0x13e8,0x1428,0x1460,0x14a0,0x14cc,0x150c,0x154c,0x155c,0x159c,0x15d0,
-0x1610,0x1640,0x1680,0x16c0,0x16d0,0x1704,0x173c,0x177c,0x17bc,0x17fc,0x1830,0x185c,0x189c,0x18d4,0x18f0,0x1930,
-0xa80,0xac0,0xb00,0xb40,0xb80,0xbab,0xbeb,0xa40,0xc0d,0xa40,0xa40,0xa40,0xa40,0xc4d,0x1db,0x1db,
-0xc8d,0xccd,0xa40,0xa40,0xa40,0xcf6,0xd36,0xd56,0xa40,0xd7c,0xdbc,0xdfc,0xe3c,0xe7c,0xebc,0xefc,
-0xf3c,0xf73,0x1db,0x1db,0xf97,0xfcb,0x1db,0xff3,0x1db,0x1db,0x1db,0x1db,0x1020,0x1db,0x1db,0x1db,
-0x1db,0x1db,0x1db,0x1db,0x1034,0x1db,0x106c,0x10ac,0x1db,0x10b7,0x1db,0x1db,0x1db,0x10ed,0xa40,0x112d,
-0x1db,0x1db,0x116d,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
+static const uint16_t propsTrie_index[23016]={
+0x495,0x49d,0x4a5,0x4ad,0x4c5,0x4cd,0x4d5,0x4dd,0x4e5,0x4ed,0x4f3,0x4fb,0x503,0x50b,0x513,0x51b,
+0x521,0x529,0x531,0x539,0x53c,0x544,0x54c,0x554,0x55c,0x564,0x560,0x568,0x570,0x578,0x57d,0x585,
+0x58d,0x595,0x599,0x5a1,0x5a9,0x5b1,0x5b9,0x5c1,0x5bd,0x5c5,0x5ca,0x5d2,0x5d8,0x5e0,0x5e8,0x5f0,
+0x5f8,0x600,0x608,0x610,0x615,0x61d,0x620,0x628,0x630,0x638,0x63e,0x646,0x645,0x64d,0x655,0x65d,
+0x66d,0x665,0x675,0x67d,0x683,0x600,0x693,0x68b,0x6a3,0x6a5,0x6ad,0x69b,0x6bd,0x6c3,0x6cb,0x6b5,
+0x6db,0x6e1,0x6e9,0x6d3,0x6f9,0x6ff,0x707,0x6f1,0x717,0x71d,0x725,0x70f,0x735,0x73d,0x745,0x72d,
+0x755,0x75b,0x763,0x74d,0x773,0x779,0x781,0x76b,0x791,0x796,0x79e,0x789,0x7ae,0x7b5,0x7bd,0x7a6,
+0x641,0x7c5,0x7cd,0x4b5,0x7d5,0x7dc,0x7e4,0x4b5,0x7ec,0x7f4,0x7fc,0x801,0x809,0x810,0x818,0x4b5,
+0x600,0x820,0x828,0x830,0x838,0x58d,0x848,0x840,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x850,0x600,0x858,0x85c,0x864,0x600,0x86a,0x600,0x870,0x878,0x880,0x58d,0x58d,0x888,
+0x890,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x895,0x89d,0x600,0x600,0x8a5,0x8ad,0x8b5,0x8bd,0x8c5,0x600,0x8cd,0x8d5,0x8dd,
+0x8ed,0x600,0x8f5,0x8f7,0x8ff,0x8e5,0x600,0x902,0x916,0x90a,0x912,0x91e,0x600,0x926,0x92c,0x934,
+0x93c,0x600,0x94c,0x954,0x95c,0x944,0x96c,0x4b5,0x974,0x977,0x97f,0x964,0x98f,0x987,0x600,0x996,
+0x600,0x9a5,0x99e,0x9ad,0x9b5,0x9b9,0x9c1,0x9c9,0x535,0x9d1,0x9d4,0x9da,0x9e1,0x9d4,0x55c,0x55c,
+0x4e5,0x4e5,0x4e5,0x4e5,0x9e9,0x4e5,0x4e5,0x4e5,0x9f9,0xa01,0xa09,0xa11,0xa19,0xa1d,0xa25,0x9f1,
+0xa3d,0xa45,0xa2d,0xa35,0xa4d,0xa55,0xa5d,0xa65,0xa7d,0xa6d,0xa75,0xa85,0xa8d,0xa9c,0xaa1,0xa94,
+0xaa9,0xaa9,0xaa9,0xaa9,0xaa9,0xaa9,0xaa9,0xaa9,0xab1,0xab9,0x934,0xabc,0xac4,0xacb,0xad0,0xad8,
+0x934,0xadf,0xade,0xaef,0xaf2,0x934,0x934,0xae7,0x934,0x934,0x934,0x934,0x934,0xb01,0xb09,0xaf9,
+0x934,0x934,0x934,0xb0e,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0xb14,0xb1c,0x934,0xb24,0xb2b,
+0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0xaa9,0xaa9,0xaa9,0xaa9,0xb33,0xaa9,0xb3a,0xb41,
+0xaa9,0xaa9,0xaa9,0xaa9,0xaa9,0xaa9,0xaa9,0xaa9,0x934,0xb49,0xb50,0xb54,0xb5a,0x934,0x934,0x934,
+0x58d,0x595,0x535,0xb62,0x4e5,0x4e5,0x4e5,0xb6a,0x535,0xb72,0x600,0xb78,0xb88,0xb80,0xb80,0x55c,
+0xb90,0xb98,0xba0,0x4b5,0xba8,0x934,0x934,0xbaf,0x934,0x934,0x934,0x934,0x934,0x934,0xbb7,0xbbd,
+0xbcd,0xbc5,0x641,0x600,0xbd5,0x890,0x600,0xbdd,0xbe5,0xbe9,0x600,0x600,0xbee,0x600,0x934,0xbf5,
+0xad9,0xbfd,0xc03,0x934,0xbfd,0xc0b,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,
+0xc13,0x600,0x600,0x600,0xc1b,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0xc21,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0xc26,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x934,0x934,
+0xc2e,0x600,0xc31,0x600,0xc39,0xc3f,0xc47,0xc4f,0xc54,0x600,0x600,0xc58,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0xc5f,0x600,0xc66,0xc6c,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0xc74,0x600,0x600,0x600,0xc7c,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0xc7e,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0xc85,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0xc8c,0x600,0x600,0x600,0xc93,0xc9b,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0xca0,0x600,0x600,0xca8,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0xcac,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0xcaf,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0xcb2,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0xcb8,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0xcc0,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0xcc5,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0xcca,0x600,0x600,0x600,0xccf,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0xcd7,0xcde,0xce2,0x600,0x600,0x600,0xce9,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0xcf7,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0xcef,0x934,0xcff,0x9ad,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0xd04,0xd0c,0x4e5,0xd1c,0xd14,0x600,0x600,0xd24,0xd2c,0xd3c,0x4e5,0xd41,0xd49,0xd4f,0xd56,0xd34,
+0xd5e,0xd66,0x600,0xd6e,0xd7e,0xd81,0xd76,0xd89,0x655,0xd91,0xd98,0x8f6,0x6a3,0xda8,0xda0,0xdb0,
+0x600,0xdb8,0xdc0,0xdc8,0x600,0xdd0,0xdd8,0xde0,0xde8,0xdf0,0xdf4,0xdfc,0x535,0x535,0x600,0xe04,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0xe0c,0xe18,0xe10,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,
+0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,
+0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
+0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
+0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
+0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
+0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
+0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
+0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
+0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
+0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
+0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
+0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
+0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
+0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0x600,0x600,0x600,0xe30,0x600,0xcea,0xe37,0xe3c,
+0x600,0x600,0x600,0xe44,0x600,0x600,0x901,0x4b5,0xe5a,0xe4a,0xe52,0x600,0x600,0xe62,0xe6a,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0xe6f,0x938,0x600,0xe77,0x600,0xe7d,0xe81,
+0xe89,0xe91,0xe98,0xea0,0x600,0x600,0x600,0xea6,0xebe,0x4a5,0xec6,0xece,0xed3,0x916,0xeae,0xeb6,
+0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,
+0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,
+0x12d4,0x12d4,0x1314,0x1354,0x1394,0x13cc,0x140c,0x144c,0x1484,0x14c4,0x14f0,0x1530,0x1570,0x1580,0x15c0,0x15f4,
+0x1634,0x1664,0x16a4,0x16e4,0x16f4,0x1728,0x1760,0x17a0,0x17e0,0x1820,0x1854,0x1880,0x18c0,0x18f8,0x1914,0x1954,
+0xa80,0xac0,0xb00,0xb40,0xb80,0xbab,0xbeb,0xa40,0xc0e,0xa40,0xa40,0xa40,0xa40,0xc4e,0x1db,0x1db,
+0xc8e,0xcce,0xa40,0xa40,0xa40,0xcf7,0xd37,0xd57,0xa40,0xd7d,0xdbd,0xdfd,0xe3d,0xe7d,0xebd,0xefd,
+0xf3d,0xf74,0x1db,0x1db,0xf98,0xfcc,0x1db,0xff4,0x1db,0x1db,0x1db,0x1db,0x1021,0x1db,0x1db,0x1db,
+0x1db,0x1db,0x1db,0x1db,0x1035,0x1db,0x106d,0x10ad,0x1db,0x10b8,0x1db,0x1db,0x1db,0x10ee,0xa40,0x112e,
+0x1db,0x1db,0x116e,0x1db,0x1191,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
 0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
 0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
 0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
@@ -170,1033 +170,1044 @@ static const uint16_t propsTrie_index[22688]={
 0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
 0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
 0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
-0x11ad,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
+0x11d1,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
 0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
 0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,
-0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x11ed,
+0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x1211,
 0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,
-0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x11ed,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0xed2,0xed9,0xee1,0x4ac,0x5f7,0x5f7,0x5f7,0xee9,0xef9,0xef1,0xf10,0xf01,0xf08,0xf18,0xf1c,0xf20,
-0x4ac,0x4ac,0x4ac,0x4ac,0x8ed,0x5f7,0xf28,0xf30,0x5f7,0xf38,0xf40,0xf44,0xf4c,0x5f7,0xf54,0x4ac,
-0x584,0x58e,0xf5c,0x5f7,0xf60,0xf68,0xf78,0xf70,0x5f7,0xf80,0x5f7,0xf87,0xf97,0xf8f,0x4ac,0x4ac,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0xb7f,0x8f9,0xf9f,0xfaf,0xfa7,0x4ac,0x4ac,
-0xfbf,0xfb7,0xfc2,0xfca,0x90d,0xfd2,0x4ac,0xfda,0xfe2,0xfea,0x4ac,0x4ac,0x5f7,0xffa,0x1002,0xff2,
-0x1012,0x1019,0x100a,0x1021,0x1029,0x4ac,0x1039,0x1031,0x5f7,0x103c,0x1044,0x104c,0x1054,0x105c,0x4ac,0x4ac,
-0x5f7,0x5f7,0x1064,0x4ac,0x584,0x106c,0x52c,0x1074,0x5f7,0x107c,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x1084,0x5f7,0x108c,0x4ac,0x4ac,0x1094,0x109c,0x10a3,0xfd6,0x10ab,0xfd6,0x10b3,0xb7f,
-0x10c3,0x62d,0x10cb,0x10bb,0x986,0x10d3,0x10db,0x10e1,0x10f9,0x10e9,0x10f1,0x10fd,0x986,0x110d,0x1105,0x1115,
-0x1125,0x111d,0x4ac,0x4ac,0x112c,0x1134,0x64f,0x113c,0x114c,0x1152,0x115a,0x1144,0x4ac,0x4ac,0x4ac,0x4ac,
-0x5f7,0x1162,0x116a,0x1172,0x5f7,0x117a,0x1182,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x5f7,0x118a,0x1192,0x4ac,
-0x5f7,0x119a,0x11a2,0x11aa,0x5f7,0x11ba,0x11b2,0x4ac,0x867,0x11c2,0x11ca,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x5f7,0x11d2,0x4ac,0x4ac,0x4ac,0x584,0x52c,0x11da,0x11ea,0x11f0,0x11e2,0x4ac,0x4ac,0x1200,0x1204,0x11f8,
-0x121c,0x120c,0x1214,0x5f7,0x122a,0x1224,0x5f7,0x8ee,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x1240,0x1245,0x1232,0x123a,0x1255,0x124d,0x4ac,0x4ac,0x1264,0x1268,0x125c,0x1278,0x1270,0x11b2,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x127c,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x1283,0x1293,0x128b,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x8f8,0x4ac,0x4ac,0x4ac,
-0x12a3,0x12ab,0x12b3,0x129b,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x12bb,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0xfd6,0x5f7,0x5f7,0x12c3,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x12cb,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x11ca,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x8ee,0x90d,
-0xd9b,0x5f7,0x90d,0x12d3,0x12d8,0x5f7,0x12e8,0x12f0,0x12f8,0x12e0,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x584,
-0x52c,0x1300,0x4ac,0x4ac,0x4ac,0x5f7,0x5f7,0x1308,0x130d,0x1313,0x4ac,0x4ac,0x131b,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x1323,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x8f9,0x4ac,0x1064,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x1329,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x1331,
-0x1335,0x133c,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0xe07,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x5f7,0x5f7,0x5f7,0x1342,0x1347,0x134f,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x553,0x135f,0x1366,0x92b,0x92b,0x92b,0x1357,0x4ac,0x92b,0x92b,0x92b,0x92b,
-0x92b,0x92b,0x92b,0xbae,0x92b,0x136d,0x92b,0x1374,0x137c,0x1382,0x92b,0xad5,0x92b,0x92b,0x138a,0x4ac,
-0x4ac,0x4ac,0x4ac,0x1392,0x92b,0x92b,0xad2,0x139a,0x4ac,0x4ac,0x4ac,0x4ac,0x13aa,0x13b1,0x13b6,0x13bc,
-0x13c4,0x13cc,0x13d4,0x13ae,0x13dc,0x13e4,0x13ec,0x13f1,0x13c3,0x13aa,0x13b1,0x13ad,0x13bc,0x13f9,0x13ab,0x13fc,
-0x13ae,0x1404,0x140c,0x1414,0x141b,0x1407,0x140f,0x1417,0x141e,0x140a,0x1426,0x13a2,0x92b,0x92b,0x92b,0x92b,
-0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0x553,0x1436,0x553,0x143d,
-0x1444,0x142e,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x1453,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x144b,0x145b,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x5f7,0x146b,0x1463,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0xfd6,0x1473,0x5f7,0x147b,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x1483,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x148b,0x4ac,0x584,0x149b,0x1493,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x14a3,
-0x14b3,0x14ab,0x4ac,0x4ac,0x14c3,0x14bb,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x14d3,0x14db,0x14e3,0x14eb,
-0x14f3,0x14fb,0x4ac,0x14cb,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x92b,0x1503,0x92b,0x92b,
-0xba6,0x136b,0x150b,0xbae,0x1513,0x92b,0x92b,0x92b,0x92b,0xbb0,0x4ac,0x151b,0x1523,0x1527,0x152f,0x1537,
-0x4ac,0x4ac,0x4ac,0x4ac,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0x153f,0x92b,0x92b,0x92b,0x92b,
-0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,
-0x92b,0x92b,0x1547,0x154f,0x92b,0x92b,0x92b,0xba6,0x92b,0x92b,0x1557,0x155f,0x1503,0x92b,0x1567,0x92b,
-0x156f,0x1574,0x4ac,0x4ac,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0x92b,0xba6,0x157c,
-0x1588,0x158d,0x1595,0x1584,0x92b,0x92b,0x92b,0x92b,0x159d,0x92b,0xad5,0x11ae,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x15a5,0x5f7,0x5f7,0x15ac,
-0x5f7,0x5f7,0x5f7,0x15b4,0x5f7,0x15bc,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0xc87,0x5f7,0x5f7,0x15c4,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x15cc,0x15d4,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0xcc6,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x15db,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x15e2,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x15e9,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x4ac,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x8ee,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0xf60,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x1090,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x15f1,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x5f7,0x5f7,0x5f7,
-0x5f7,0x15f9,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0xf60,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,
-0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x15ff,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x160f,0x1607,0x1607,
-0x1607,0x4ac,0x4ac,0x4ac,0x4ac,0x553,0x553,0x553,0x553,0x553,0x553,0x553,0x1617,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,
-0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0x4ac,0xe1f,0xe1f,0xe1f,
-0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,
-0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,
-0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,
-0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0x161f,0x48b,0x48b,0x48b,
-0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,
+0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x1211,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0xedb,0xee2,0xeea,0x4b5,0x600,0x600,0x600,0xef2,0xf02,0xefa,0xf19,0xf0a,0xf11,0xf21,0xf25,0xf29,
+0x4b5,0x4b5,0x4b5,0x4b5,0x8f6,0x600,0xf31,0xf39,0x600,0xf41,0xf49,0xf4d,0xf55,0x600,0xf5d,0x4b5,
+0x58d,0x597,0xf65,0x600,0xf69,0xf71,0xf81,0xf79,0x600,0xf89,0x600,0xf90,0xfa0,0xf98,0x4b5,0x4b5,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0xb88,0x902,0xfa8,0xfb8,0xfb0,0x4b5,0x4b5,
+0xfc8,0xfc0,0xfcb,0xfd3,0x916,0xfdb,0x4b5,0xfe3,0xfeb,0xff3,0x4b5,0x4b5,0x600,0x1003,0x100b,0xffb,
+0x101b,0x1022,0x1013,0x102a,0x1032,0x4b5,0x1042,0x103a,0x600,0x1045,0x104d,0x1055,0x105d,0x1065,0x4b5,0x4b5,
+0x600,0x600,0x106d,0x4b5,0x58d,0x1075,0x535,0x107d,0x600,0x1085,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x108d,0x600,0x1095,0x4b5,0x109a,0x10a2,0x10aa,0x10b1,0xfdf,0x10b9,0xfdf,0x10c1,0xb88,
+0x10d1,0x636,0x10d9,0x10c9,0x98f,0x10e1,0x10e9,0x10ef,0x1107,0x10f7,0x10ff,0x110b,0x98f,0x111b,0x1113,0x1123,
+0x113b,0x112b,0x1133,0x4b5,0x1142,0x114a,0x658,0x1152,0x1162,0x1168,0x1170,0x115a,0x4b5,0x4b5,0x4b5,0x4b5,
+0x600,0x1178,0x1180,0x1099,0x600,0x1188,0x1190,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x600,0x1198,0x11a0,0x4b5,
+0x600,0x11a8,0x11b0,0x11b8,0x600,0x11c8,0x11c0,0x4b5,0x870,0x11d0,0x11d8,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x600,0x11e0,0x4b5,0x4b5,0x4b5,0x58d,0x535,0x11e8,0x11f8,0x11fe,0x11f0,0x4b5,0x4b5,0x120e,0x1212,0x1206,
+0x122a,0x121a,0x1222,0x600,0x1238,0x1232,0x600,0x8f7,0x1248,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x1256,0x125b,0x1240,0x1250,0x126b,0x1263,0x4b5,0x4b5,0x127a,0x127e,0x1272,0x128e,0x1286,0x11c0,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x1292,0x12a2,0x12a7,0x129a,0x4b5,0x4b5,0x12af,0x12bf,0x12b7,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x901,0x4b5,0x4b5,0x4b5,
+0x12cf,0x12d7,0x12df,0x12c7,0x600,0x600,0x600,0x600,0x600,0x600,0x12e7,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0xfdf,0x600,0x600,0x12ef,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x12f7,0x12ff,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x11d8,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x8f7,
+0x916,0xda4,0x600,0x916,0x1307,0x130c,0x600,0x131c,0x1324,0x132c,0x1314,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x58d,0x535,0x1334,0x4b5,0x4b5,0x4b5,0x600,0x600,0x133c,0x1341,0x1347,0x4b5,0x4b5,0x134f,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x1357,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x902,0x4b5,0x106d,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x135d,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x1365,0x136a,0x1371,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0xe10,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x600,0x600,0x600,0x1377,0x137c,0x1384,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x55c,0x1394,0x139b,0x934,0x934,0x934,0x138c,0x4b5,0x934,0x934,0x934,
+0x934,0x934,0x934,0x934,0xbb7,0x934,0x13a2,0x934,0x13a9,0x13b1,0x13b7,0x934,0xade,0x934,0x934,0x13bf,
+0x4b5,0x4b5,0x4b5,0x13c7,0x13c7,0x934,0x934,0xadb,0x13cf,0x4b5,0x4b5,0x4b5,0x4b5,0x13df,0x13e6,0x13eb,
+0x13f1,0x13f9,0x1401,0x1409,0x13e3,0x1411,0x1419,0x1421,0x1426,0x13f8,0x13df,0x13e6,0x13e2,0x13f1,0x142e,0x13e0,
+0x1431,0x13e3,0x1439,0x1441,0x1449,0x1450,0x143c,0x1444,0x144c,0x1453,0x143f,0x145b,0x13d7,0x934,0x934,0x934,
+0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x55c,0x146b,0x55c,
+0x1472,0x1479,0x1463,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x1488,0x1490,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x1480,0x1498,0x9d4,
+0x14a8,0x14a0,0x4b5,0x4b5,0x4b5,0x600,0x14b8,0x14b0,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0xfdf,0x14c0,0x600,0x14c8,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0xfdf,0x14d0,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x14d8,0x600,0x600,0x600,
+0x600,0x600,0x600,0x14e0,0x4b5,0x58d,0x14f0,0x14e8,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x14f8,0x1508,0x1500,0x4b5,0x4b5,0x1518,0x1510,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x1528,0x1530,0x1538,
+0x1540,0x1548,0x1550,0x4b5,0x1520,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x934,0x1558,0x934,
+0x934,0xbaf,0x13a0,0x1560,0xbb7,0x1568,0x934,0x934,0x934,0x934,0xbb9,0x4b5,0x1570,0x1578,0x157c,0x1584,
+0x158c,0x4b5,0x4b5,0x4b5,0x4b5,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x1594,0x934,0x934,0x934,
+0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,
+0x934,0x934,0x934,0x157d,0x159c,0x934,0x934,0x934,0x15a4,0x934,0x934,0x15ab,0x15b3,0x1558,0x934,0x15bb,
+0x934,0x15c3,0x15c8,0x4b5,0x4b5,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0xbaf,
+0x15d0,0x15d9,0x15dd,0x15e5,0x15d5,0x934,0x934,0x934,0x934,0x15ed,0x934,0xade,0x11bc,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x15f5,0x600,0x600,
+0x15fc,0x600,0x600,0x600,0x1604,0x600,0x160c,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0xc90,0x600,0x600,
+0x1614,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x161c,0x1624,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0xccf,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x162b,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x1632,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x1639,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x4b5,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x901,0x600,0x600,0x600,0x600,0x600,0x600,0xf69,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x1641,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x1649,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x600,0x600,
+0x600,0x600,0x1651,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0xf69,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x67d,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x1314,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x1661,0x1659,0x1659,0x1659,0x4b5,0x4b5,0x4b5,0x4b5,0x55c,0x55c,0x55c,0x55c,0x55c,0x55c,0x55c,
+0x1669,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
+0x4b5,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
+0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
+0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
+0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
+0x1671,0x494,0x494,0x494,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,
 0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,
-0xc,0x17,0x17,0x17,0x19,0x17,0x17,0x17,0x14,0x15,0x17,0x18,0x17,0x13,0x17,0x17,
-0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x17,0x17,0x18,0x18,0x18,0x17,
-0x17,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-1,1,1,1,1,1,1,1,1,1,1,0x14,0x17,0x15,0x1a,0x16,
-0x1a,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-2,2,2,2,2,2,2,2,2,2,2,0x14,0x18,0x15,0x18,0xf,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0xf,0xf,0xf,0xf,0xc,0x17,0x17,0x17,0x19,0x17,0x17,0x17,0x14,0x15,0x17,0x18,
+0x17,0x13,0x17,0x17,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x17,0x17,
+0x18,0x18,0x18,0x17,0x17,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0x14,
+0x17,0x15,0x1a,0x16,0x1a,2,2,2,2,2,2,2,2,2,2,2,
+2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0x14,
+0x18,0x15,0x18,0xf,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,
 0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,
-0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,
-0xc,0x17,0x19,0x19,0x19,0x19,0x1b,0x17,0x1a,0x1b,5,0x1c,0x18,0x10,0x1b,0x1a,
-0x1b,0x18,0x34b,0x38b,0x1a,2,0x17,0x17,0x1a,0x30b,5,0x1d,0x34cb,0x344b,0x3ccb,0x17,
-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-1,1,1,1,1,1,1,0x18,1,1,1,1,1,1,1,2,
-2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-2,2,2,2,2,2,2,0x18,2,2,2,2,2,2,2,2,
-1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
-1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
-1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
-1,2,1,2,1,2,1,2,2,1,2,1,2,1,2,1,
-2,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
+0xf,0xf,0xf,0xf,0xc,0x17,0x19,0x19,0x19,0x19,0x1b,0x17,0x1a,0x1b,5,0x1c,
+0x18,0x10,0x1b,0x1a,0x1b,0x18,0x34b,0x38b,0x1a,2,0x17,0x17,0x1a,0x30b,5,0x1d,
+0x34cb,0x344b,0x3ccb,0x17,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,0x18,1,1,1,1,
+1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,
+2,2,2,2,2,2,2,2,2,2,2,0x18,2,2,2,2,
+2,2,2,2,1,2,1,2,1,2,1,2,1,2,1,2,
 1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
 1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
-1,1,2,1,2,1,2,2,2,1,1,2,1,2,1,1,
-2,1,1,1,2,2,1,1,1,1,2,1,1,2,1,1,
-1,2,2,2,1,1,2,1,1,2,1,2,1,2,1,1,
-2,1,2,2,1,2,1,1,2,1,1,1,2,1,2,1,
-1,2,2,5,1,2,2,2,5,5,5,5,1,3,2,1,
-3,2,1,3,2,1,2,1,2,1,2,1,2,1,2,1,
+1,2,1,2,1,2,1,2,1,2,1,2,2,1,2,1,
 2,1,2,1,2,2,1,2,1,2,1,2,1,2,1,2,
-1,2,1,2,1,2,1,2,2,1,3,2,1,2,1,1,
 1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
 1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
+1,2,1,2,1,1,2,1,2,1,2,2,2,1,1,2,
+1,2,1,1,2,1,1,1,2,2,1,1,1,1,2,1,
+1,2,1,1,1,2,2,2,1,1,2,1,1,2,1,2,
+1,2,1,1,2,1,2,2,1,2,1,1,2,1,1,1,
+2,1,2,1,1,2,2,5,1,2,2,2,5,5,5,5,
+1,3,2,1,3,2,1,3,2,1,2,1,2,1,2,1,
+2,1,2,1,2,1,2,1,2,2,1,2,1,2,1,2,
+1,2,1,2,1,2,1,2,1,2,1,2,2,1,3,2,
+1,2,1,1,1,2,1,2,1,2,1,2,1,2,1,2,
 1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
-1,2,1,2,2,2,2,2,2,2,1,1,2,1,1,2,
-2,1,2,1,1,1,1,2,1,2,1,2,1,2,1,2,
+1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
+1,2,1,2,1,2,1,2,2,2,2,2,2,2,1,1,
+2,1,1,2,2,1,2,1,1,1,1,2,1,2,1,2,
+1,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,
 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
+2,2,2,2,5,2,2,2,2,2,2,2,2,2,2,2,
 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-5,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-2,2,2,2,2,2,2,2,2,2,2,2,4,4,4,4,
-4,4,4,4,4,4,4,4,4,4,4,4,4,4,0x1a,0x1a,
-0x1a,0x1a,4,4,4,4,4,4,4,4,4,4,4,4,0x1a,0x1a,
-0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,4,4,4,4,
-4,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,4,0x1a,4,0x1a,0x1a,0x1a,0x1a,0x1a,
-0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,6,6,6,6,
+4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
+4,4,0x1a,0x1a,0x1a,0x1a,4,4,4,4,4,4,4,4,4,4,
+4,4,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,
+4,4,4,4,4,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,4,0x1a,4,0x1a,
+0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,
+6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
 6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
 6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
 6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
-6,6,6,6,6,6,6,6,6,6,6,6,1,2,1,2,
-4,0x1a,1,2,0,0,4,2,2,2,0x17,1,0,0,0,0,
-0x1a,0x1a,1,0x17,1,1,1,0,1,0,1,1,2,1,1,1,
-1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,
-1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,
-2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,
-2,2,1,1,1,2,2,2,1,2,1,2,1,2,1,2,
+1,2,1,2,4,0x1a,1,2,0,0,4,2,2,2,0x17,1,
+0,0,0,0,0x1a,0x1a,1,0x17,1,1,1,0,1,0,1,1,
+2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,0,1,1,1,1,1,1,1,1,1,2,2,2,2,
+2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
+2,2,2,1,2,2,1,1,1,2,2,2,1,2,1,2,
 1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
-2,2,2,2,1,2,0x18,1,2,1,1,2,2,1,1,1,
-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,2,1,2,2,2,2,2,1,2,0x18,1,2,1,1,2,
+2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,
 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
+2,2,2,2,1,2,1,2,1,2,1,2,1,2,1,2,
 1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
-1,2,0x1b,6,6,6,6,6,7,7,1,2,1,2,1,2,
+1,2,1,2,1,2,0x1b,6,6,6,6,6,7,7,1,2,
 1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
 1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
 1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
-1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,2,
+1,2,1,2,1,1,2,1,2,1,2,1,2,1,2,1,
+2,1,2,2,1,2,1,2,1,2,1,2,1,2,1,2,
 1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
 1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
-1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
-0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-1,1,1,1,1,1,1,1,1,1,1,0,0,4,0x17,0x17,
-0x17,0x17,0x17,0x17,2,2,2,2,2,2,2,2,2,2,2,2,
+1,2,1,2,0,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
+0,4,0x17,0x17,0x17,0x17,0x17,0x17,2,2,2,2,2,2,2,2,
 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-2,2,2,2,2,0x17,0x13,0,0,0x1b,0x1b,0x19,0,6,6,6,
-6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+2,2,2,2,2,2,2,2,2,0x17,0x13,0,0,0x1b,0x1b,0x19,
+0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
 6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
-6,6,6,6,6,6,6,6,6,6,0x13,6,0x17,6,6,0x17,
-6,6,0x17,6,0,0,0,0,0,0,0,0,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,0,0,0,0,5,5,5,5,0x17,
-0x17,0,0,0,0,0,0,0,0,0,0,0,0x10,0x10,0x10,0x10,
-0x10,0x10,0x18,0x18,0x18,0x17,0x17,0x19,0x17,0x17,0x1b,0x1b,6,6,6,6,
-6,6,6,6,6,6,6,0x17,0x10,0x17,0x17,0x17,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,4,5,5,5,
-5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,
-6,6,6,6,6,6,6,6,6,6,6,6,0x49,0x89,0xc9,0x109,
-0x149,0x189,0x1c9,0x209,0x249,0x289,0x17,0x17,0x17,0x17,5,5,6,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+6,6,6,6,6,6,6,6,6,6,6,6,6,6,0x13,6,
+0x17,6,6,0x17,6,6,0x17,6,0,0,0,0,0,0,0,0,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,5,
+5,5,5,0x17,0x17,0,0,0,0,0,0,0,0,0,0,0,
+0x10,0x10,0x10,0x10,0x10,0x10,0x18,0x18,0x18,0x17,0x17,0x19,0x17,0x17,0x1b,0x1b,
+6,6,6,6,6,6,6,6,6,6,6,0x17,0x10,0x17,0x17,0x17,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-0x17,5,6,6,6,6,6,6,6,0x10,0x1b,6,6,6,6,6,
-6,4,4,6,6,0x1b,6,6,6,6,5,5,0x49,0x89,0xc9,0x109,
-0x149,0x189,0x1c9,0x209,0x249,0x289,5,5,5,0x1b,0x1b,5,0x17,0x17,0x17,0x17,
-0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0,0x10,5,6,5,5,
+4,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,
+6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x17,0x17,0x17,0x17,5,5,
+6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,
-6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,
-0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,
-6,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,5,5,5,5,5,5,
+5,5,5,5,0x17,5,6,6,6,6,6,6,6,0x10,0x1b,6,
+6,6,6,6,6,4,4,6,6,0x1b,6,6,6,6,5,5,
+0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,5,5,5,0x1b,0x1b,5,
+0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0,0x10,
+5,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,
-6,6,6,6,4,4,0x1b,0x17,0x17,0x17,4,0,0,6,0x19,0x19,
-6,6,6,6,4,6,6,6,4,6,6,6,6,6,0,0,
-0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0,
+6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+6,6,6,0,0,5,5,5,5,5,5,5,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,6,6,6,6,4,6,6,6,6,6,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,6,6,6,0,0,0x17,0,
-5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,0,
+5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,
+6,6,6,6,6,5,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-0x1a,5,5,5,5,5,5,0,0x10,0x10,0,0,0,0,0,0,
-6,6,6,6,6,6,6,6,6,6,0x10,6,6,6,6,6,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,
+6,6,6,6,6,6,6,6,4,4,0x1b,0x17,0x17,0x17,4,0,
+0,6,0x19,0x19,6,6,6,6,4,6,6,6,4,6,6,6,
+6,6,0,0,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
+0x17,0x17,0x17,0,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,6,6,6,6,4,6,
+6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,
+0,0,0x17,0,5,5,5,5,5,5,5,5,5,5,5,0,
+0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,0x1a,5,5,5,5,5,5,0,0x10,0x10,0,0,
+0,0,0,0,6,6,6,6,6,6,6,6,6,6,0x10,6,
 6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
-6,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,
-5,4,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
-6,6,6,6,6,6,6,6,5,5,6,6,0x17,0x17,0x49,0x89,
-0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x17,4,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,6,6,6,8,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,6,8,6,5,8,8,
-8,6,6,6,6,6,6,6,6,8,8,8,8,6,8,8,
-5,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,
-5,5,6,6,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,
-5,5,0x19,0x19,0x37cb,0x35cb,0x3fcb,0x34cb,0x3ccb,0x94b,0x1b,0x19,5,0x17,6,0,
-5,6,8,8,0,5,5,5,5,5,5,5,5,0,0,5,
-5,0,0,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,0,5,5,5,5,5,5,5,0,5,0,0,0,5,5,
-5,5,0,0,6,5,8,8,8,6,6,6,6,0,0,8,
-8,0,0,8,8,6,5,0,0,0,0,0,0,0,0,8,
-0,0,0,0,5,5,0,5,0,0,0,0,0,0,0x49,0x89,
-0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,6,6,5,5,5,6,0x17,0,
-0,0,0,0,0,0,0,0,0,6,6,8,0,5,5,5,
-5,5,5,0,0,0,0,5,5,0,0,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,0,5,5,5,5,5,5,
-5,0,5,5,0,5,5,0,5,5,0,0,6,0,8,8,
-8,6,6,0,0,0,0,6,6,0,0,6,6,6,0,0,
-0,6,0,0,0,0,0,0,0,5,5,5,5,0,5,0,
-5,5,6,6,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,
-0x17,0x19,0,0,0,0,0,0,0,5,6,6,6,6,6,6,
-0,6,6,8,0,5,5,5,5,5,5,5,5,5,0,5,
-5,5,0,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,0,5,5,5,5,5,5,5,0,5,5,0,5,5,5,
-5,5,0,0,6,5,8,8,8,6,6,6,6,6,0,6,
-6,8,0,8,8,6,0,0,5,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,5,5,6,6,0,0,0x49,0x89,
-0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x1b,5,0x34cb,0x344b,0x3ccb,0x37cb,0x35cb,0x3fcb,
+6,6,6,6,6,6,6,6,6,6,6,6,5,5,5,5,
+5,5,5,5,5,4,6,6,6,6,6,6,6,6,6,6,
+6,6,6,6,6,6,6,6,6,6,6,6,5,5,6,6,
+0x17,0x17,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x17,4,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,8,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,8,
+6,5,8,8,8,6,6,6,6,6,6,6,6,8,8,8,
+8,6,8,8,5,6,6,6,6,6,6,6,5,5,5,5,
+5,5,5,5,5,5,6,6,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,
+0x1c9,0x209,0x249,0x289,5,5,0x19,0x19,0x37cb,0x35cb,0x3fcb,0x34cb,0x3ccb,0x94b,0x1b,0x19,
+5,0x17,6,0,5,6,8,8,0,5,5,5,5,5,5,5,
+5,0,0,5,5,0,0,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,0,5,5,5,5,5,5,5,0,5,0,
+0,0,5,5,5,5,0,0,6,5,8,8,8,6,6,6,
+6,0,0,8,8,0,0,8,8,6,5,0,0,0,0,0,
+0,0,0,8,0,0,0,0,5,5,0,5,0,0,0,0,
+0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,6,6,5,5,
+5,6,0x17,0,0,0,0,0,0,0,0,0,0,6,6,8,
+0,5,5,5,5,5,5,0,0,0,0,5,5,0,0,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,0,5,5,
+5,5,5,5,5,0,5,5,0,5,5,0,5,5,0,0,
+6,0,8,8,8,6,6,0,0,0,0,6,6,0,0,6,
+6,6,0,0,0,6,0,0,0,0,0,0,0,5,5,5,
+5,0,5,0,5,5,6,6,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,
+0x1c9,0x209,0x249,0x289,0x17,0x19,0,0,0,0,0,0,0,5,6,6,
+6,6,6,6,0,6,6,8,0,5,5,5,5,5,5,5,
+5,5,0,5,5,5,0,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,0,5,5,5,5,5,5,5,0,5,5,
+0,5,5,5,5,5,0,0,6,5,8,8,8,6,6,6,
+6,6,0,6,6,8,0,8,8,6,0,0,5,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,5,5,6,6,
+0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x1b,5,0x34cb,0x344b,
+0x3ccb,0x37cb,0x35cb,0x3fcb,0,0,0,0,0,0,0,0,0,6,8,8,
+0,5,5,5,5,5,5,5,5,0,0,5,5,0,0,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,0,5,5,
+5,5,5,5,5,0,5,5,0,5,5,5,5,5,0,0,
+6,5,8,6,8,6,6,6,6,0,0,8,8,0,0,8,
+8,6,0,0,0,0,0,0,0,6,6,8,0,0,0,0,
+5,5,0,5,0,0,0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,
+0x1c9,0x209,0x249,0x289,0x7cb,0x1e4b,0x784b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x19,0x1b,0,
+0,0,0,0,0,0,6,5,0,5,5,5,5,5,5,0,
+0,0,5,5,5,0,5,5,5,5,0,0,0,5,5,0,
+5,0,5,5,0,0,0,5,5,0,0,0,5,5,5,0,
+0,0,5,5,5,5,5,5,5,5,5,5,5,5,0,0,
+0,0,8,8,6,8,8,0,0,0,8,8,8,0,8,8,
+8,6,0,0,5,0,0,0,0,0,0,8,0,0,0,0,
+0,0,0,0,5,5,6,6,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,
+0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,0,0x17,0x54b,0x58b,0x5cb,0x60b,
+0x58b,0x5cb,0x60b,0x1b,6,8,8,8,6,5,5,5,5,5,5,5,
+5,0,5,5,5,0,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,0,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,0,0,6,5,6,6,6,8,8,8,
+8,0,6,6,6,0,6,6,6,6,0,0,0,0,0,0,
+0,6,6,0,5,5,5,0,0,5,0,0,5,5,6,6,
+0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,5,5,8,
+0,0,0,0,0,0,0,0,0,0,0,0,5,6,8,8,
+0x17,5,5,5,5,5,5,5,5,0,5,5,5,0,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,0,5,5,
+5,5,5,5,5,5,5,5,0,5,5,5,5,5,0,0,
+6,5,8,6,8,8,8,8,8,0,6,8,8,0,8,8,
+6,6,0,0,0,0,0,0,0,8,8,0,0,0,0,0,
+0,5,5,0,5,5,6,6,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,
+0x1c9,0x209,0x249,0x289,0x7cb,0x1e4b,0x784b,0x34cb,0x344b,0x3ccb,0x37cb,0x35cb,0x3fcb,0x1b,5,5,
+5,5,5,5,6,6,8,8,5,5,5,5,5,5,5,5,
+5,0,5,5,5,0,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,6,6,5,8,8,8,6,6,6,6,0,8,8,
+8,0,8,8,8,6,5,0x1b,0,0,0,0,5,5,5,8,
+0xcc0b,0xca0b,0xcb4b,0xc90b,0x364b,0xc94b,0x350b,5,0,0,0,0,0,0,0x49,0x89,
+0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,8,8,0x17,0,0,0,
 0,0,0,0,0,0,0,0,0,6,8,8,0,5,5,5,
-5,5,5,5,5,0,0,5,5,0,0,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,0,5,5,5,5,5,5,
-5,0,5,5,0,5,5,5,5,5,0,0,6,5,8,6,
-8,6,6,6,6,0,0,8,8,0,0,8,8,6,0,0,
-0,0,0,0,0,6,6,8,0,0,0,0,5,5,0,5,
-0,0,0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,
-0x7cb,0x1e4b,0x784b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x19,0x1b,0,0,0,0,0,
-0,0,6,5,0,5,5,5,5,5,5,0,0,0,5,5,
-5,0,5,5,5,5,0,0,0,5,5,0,5,0,5,5,
-0,0,0,5,5,0,0,0,5,5,5,0,0,0,5,5,
-5,5,5,5,5,5,5,5,5,5,0,0,0,0,8,8,
-6,8,8,0,0,0,8,8,8,0,8,8,8,6,0,0,
-5,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,
-5,5,6,6,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,
-0,0,0,0,0,0,0,0x17,0x54b,0x58b,0x5cb,0x60b,0x58b,0x5cb,0x60b,0x1b,
-6,8,8,8,6,5,5,5,5,5,5,5,5,0,5,5,
-5,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,0,0,6,5,6,6,6,8,8,8,8,0,6,6,
-6,0,6,6,6,6,0,0,0,0,0,0,0,6,6,0,
-5,5,5,0,0,5,0,0,5,5,6,6,0,0,0x49,0x89,
-0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,5,5,0,0,0,0,0,
-0,0,0,0,0,0,0,0,5,6,8,8,0x17,5,5,5,
-5,5,5,5,5,0,5,5,5,0,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,0,5,5,5,5,5,5,
-5,5,5,5,0,5,5,5,5,5,0,0,6,5,8,6,
-8,8,8,8,8,0,6,8,8,0,8,8,6,6,0,0,
-0,0,0,0,0,8,8,0,0,0,0,0,0,5,5,0,
-5,5,6,6,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,
-0x7cb,0x1e4b,0x784b,0x34cb,0x344b,0x3ccb,0x37cb,0x35cb,0x3fcb,0x1b,5,5,5,5,5,5,
-6,6,8,8,5,5,5,5,5,5,5,5,5,0,5,5,
-5,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,
-6,5,8,8,8,6,6,6,6,0,8,8,8,0,8,8,
-8,6,5,0x1b,0,0,0,0,5,5,5,8,0xcc0b,0xca0b,0xcb4b,0xc90b,
-0x364b,0xc94b,0x350b,5,0,0,0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,
-0x1c9,0x209,0x249,0x289,0,0,8,8,0x17,0,0,0,0,0,0,0,
-0,0,0,0,0,6,8,8,0,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,0,0,0,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,0,5,5,5,5,5,5,5,5,5,0,5,0,0,
-5,5,5,5,5,5,5,0,0,0,6,0,0,0,0,8,
-8,8,6,6,6,0,6,0,8,8,8,8,8,8,8,8,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,6,5,5,6,6,6,6,6,6,6,0,0,0,0,0x19,
-5,5,5,5,5,5,4,6,6,6,6,6,6,6,6,0x17,
-0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x17,0x17,0,0,0,0,
-0,5,5,0,5,0,5,5,5,5,5,0,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-0,5,0,5,5,5,5,5,5,5,5,5,5,6,5,5,
-6,6,6,6,6,6,6,6,6,5,0,0,5,5,5,5,
-5,0,4,0,6,6,6,6,6,6,0,0,0x49,0x89,0xc9,0x109,
-0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,5,5,5,5,5,0x1b,0x1b,0x1b,
-0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x1b,
-0x17,0x1b,0x1b,0x1b,6,6,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x49,0x89,0xc9,0x109,
-0x149,0x189,0x1c9,0x209,0x249,0x289,0x344b,0x3c4b,0x444b,0x4c4b,0x544b,0x5c4b,0x644b,0x6c4b,0x744b,0x2c4b,
-0x1b,6,0x1b,6,0x1b,6,0x14,0x15,0x14,0x15,8,8,5,5,5,5,
-5,5,5,5,0,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,
-0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,8,
-6,6,6,6,6,0x17,6,6,5,5,5,5,5,6,6,6,
-6,6,6,6,6,6,6,6,0,6,6,6,6,6,6,6,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,
+0,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,0,5,5,5,5,5,5,5,5,5,
+0,5,0,0,5,5,5,5,5,5,5,0,0,0,6,0,
+0,0,0,8,8,8,6,6,6,0,6,0,8,8,8,8,
+8,8,8,8,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,6,5,5,6,6,6,6,6,6,6,0,
+0,0,0,0x19,5,5,5,5,5,5,4,6,6,6,6,6,
+6,6,6,0x17,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x17,0x17,
+0,0,0,0,0,5,5,0,5,0,5,5,5,5,5,0,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,0,5,0,5,5,5,5,5,5,5,5,5,
+5,6,5,5,6,6,6,6,6,6,6,6,6,5,0,0,
+5,5,5,5,5,0,4,0,6,6,6,6,6,6,6,0,
+0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,5,5,5,5,
+5,0x1b,0x1b,0x1b,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
+0x17,0x17,0x17,0x1b,0x17,0x1b,0x1b,0x1b,6,6,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
+0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x344b,0x3c4b,0x444b,0x4c4b,0x544b,0x5c4b,
+0x644b,0x6c4b,0x744b,0x2c4b,0x1b,6,0x1b,6,0x1b,6,0x14,0x15,0x14,0x15,8,8,
+5,5,5,5,5,5,5,5,0,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,
+6,6,6,8,6,6,6,6,6,0x17,6,6,5,5,5,5,
+5,6,6,6,6,6,6,6,6,6,6,6,0,6,6,6,
 6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
-6,6,6,6,6,6,6,6,6,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,6,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0x1b,0x1b,0x17,0x17,0x17,0x17,
-0x17,0x1b,0x1b,0x1b,0x1b,0x17,0x17,0,0,0,0,0,5,5,5,5,
-5,5,5,5,5,5,5,8,8,6,6,6,6,8,6,6,
-6,6,6,6,8,6,6,8,8,6,6,5,0x49,0x89,0xc9,0x109,
-0x149,0x189,0x1c9,0x209,0x249,0x289,0x17,0x17,0x17,0x17,0x17,0x17,5,5,5,5,
-5,5,8,8,6,6,5,5,5,5,6,6,6,5,8,8,
-8,5,5,8,8,8,8,8,8,8,5,5,5,6,6,6,
-6,5,5,5,5,5,5,5,5,5,5,5,5,5,6,8,
-8,6,6,8,8,8,8,8,8,6,5,8,0x49,0x89,0xc9,0x109,
-0x149,0x189,0x1c9,0x209,0x249,0x289,8,8,8,6,0x1b,0x1b,2,2,2,2,
+6,6,6,6,6,6,6,6,6,6,6,6,6,0,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,6,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0x1b,0x1b,
+0x17,0x17,0x17,0x17,0x17,0x1b,0x1b,0x1b,0x1b,0x17,0x17,0,0,0,0,0,
+5,5,5,5,5,5,5,5,5,5,5,8,8,6,6,6,
+6,8,6,6,6,6,6,6,8,6,6,8,8,6,6,5,
+0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x17,0x17,0x17,0x17,0x17,0x17,
+5,5,5,5,5,5,8,8,6,6,5,5,5,5,6,6,
+6,5,8,8,8,5,5,8,8,8,8,8,8,8,5,5,
+5,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,
+5,5,6,8,8,6,6,8,8,8,8,8,8,6,5,8,
+0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,8,8,8,6,0x1b,0x1b,
 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-2,2,2,2,2,2,2,0x17,4,2,2,2,1,1,1,1,
-1,1,0,1,0,0,0,0,0,1,0,0,2,2,2,2,
-2,2,2,2,2,2,2,2,2,2,2,2,5,5,5,5,
-5,5,5,5,5,0,5,5,5,5,0,0,5,5,5,5,
-5,5,5,0,5,0,5,5,5,5,0,0,5,5,5,5,
-5,5,5,5,5,0,5,5,5,5,0,0,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,0,5,5,
-5,5,0,0,5,5,5,5,5,5,5,0,5,0,5,5,
-5,5,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,0,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,0,5,5,5,5,0,0,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,0,0,6,6,6,0x17,0x17,0x17,0x17,
-0x17,0x17,0x17,0x17,0x17,0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x7cb,0xa4b,
-0xccb,0xf4b,0x11cb,0x144b,0x16cb,0x194b,0x1bcb,0x1e4b,0x788b,0,0,0,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,1,1,1,1,
-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-1,1,0,0,2,2,2,2,2,2,0,0,0x13,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,0x1b,0x17,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-0xc,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,0x14,0x15,0,0,0,
-5,5,5,5,5,5,5,5,5,5,5,0x17,0x17,0x17,0x98a,0x9ca,
-0xa0a,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,6,6,6,8,0,0,0,0,0,0,0,0,0,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,6,6,8,0x17,0x17,0,0,0,0,0,0,0,0,0,
+2,2,2,2,2,2,2,2,2,2,2,0x17,4,2,2,2,
+1,1,1,1,1,1,0,1,0,0,0,0,0,1,0,0,
+2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
+5,5,5,5,5,5,5,5,5,0,5,5,5,5,0,0,
+5,5,5,5,5,5,5,0,5,0,5,5,5,5,0,0,
+5,5,5,5,5,5,5,5,5,0,5,5,5,5,0,0,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,6,6,0,0,0,0,0,0,0,0,0,0,0,0,
-5,5,5,5,5,5,5,5,5,5,5,5,5,0,5,5,
-5,0,6,6,0,0,0,0,0,0,0,0,0,0,0,0,
+5,0,5,5,5,5,0,0,5,5,5,5,5,5,5,0,
+5,0,5,5,5,5,0,0,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,0,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,0,5,5,5,5,0,0,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,6,6,8,6,6,6,6,6,6,6,8,8,
-8,8,8,8,8,8,6,8,8,6,6,6,6,6,6,6,
-6,6,6,6,0x17,0x17,0x17,4,0x17,0x17,0x17,0x19,5,6,0,0,
-0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,
-0x54b,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0,0,0,0,0,0,
-5,5,5,5,5,5,5,5,5,6,5,0,0,0,0,0,
+5,5,5,5,5,5,5,5,5,5,5,0,0,6,6,6,
+0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,0x48b,
+0x4cb,0x50b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,0x16cb,0x194b,0x1bcb,0x1e4b,0x788b,0,0,0,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-0x17,0x17,0x17,0x17,0x17,0x17,0x13,0x17,0x17,0x17,0x17,6,6,6,0x10,6,
-0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,
-5,5,5,4,5,5,5,5,5,5,5,5,5,5,5,5,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,0,0,2,2,2,2,2,2,0,0,
+0x13,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,0x1b,0x17,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,0xc,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x14,
+0x15,0,0,0,5,5,5,5,5,5,5,5,5,5,5,0x17,
+0x17,0x17,0x98a,0x9ca,0xa0a,5,5,5,5,5,5,5,5,0,0,0,
+0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,6,6,6,8,0,0,0,0,0,0,
+0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,6,6,8,0x17,0x17,0,0,0,0,0,
+0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,6,6,0,0,0,0,0,0,0,0,
+0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
+5,0,5,5,5,0,6,6,0,0,0,0,0,0,0,0,
+0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,6,6,8,6,6,6,6,6,
+6,6,8,8,8,8,8,8,8,8,6,8,8,6,6,6,
+6,6,6,6,6,6,6,6,0x17,0x17,0x17,4,0x17,0x17,0x17,0x19,
+5,6,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,
+0,0,0,0,0x54b,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0,0,
+0,0,0,0,5,5,5,5,5,5,5,5,5,6,5,0,
+0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,0x17,0x17,0x17,0x17,0x17,0x17,0x13,0x17,0x17,0x17,0x17,6,
+6,6,0x10,6,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,
+0,0,0,0,5,5,5,4,5,5,5,5,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,0,0,0,0,0,0,0,5,5,5,5,5,6,6,5,
+5,5,5,5,5,0,0,0,0,0,0,0,5,5,5,5,
+5,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,
+0,0,0,0,0,0,0,0,6,6,6,8,8,8,8,6,
+6,8,8,8,0,0,0,0,8,8,6,8,8,8,8,8,
+8,6,6,6,0,0,0,0,0x1b,0,0,0,0x17,0x17,0x49,0x89,
+0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,5,5,5,5,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,0,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,0,0,5,5,5,5,5,0,0,0,
+0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,
+5,5,5,5,0,0,0,0,5,5,5,5,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,
-0,0,0,0,6,6,6,8,8,8,8,6,6,8,8,8,
-0,0,0,0,8,8,6,8,8,8,8,8,8,6,6,6,
-0,0,0,0,0x1b,0,0,0,0x17,0x17,0x49,0x89,0xc9,0x109,0x149,0x189,
-0x1c9,0x209,0x249,0x289,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,0,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,0,0,5,5,5,5,5,0,0,0,0,0,0,0,
-0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
-0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,0,0,0,0,0,0,0x49,0x89,0xc9,0x109,
-0x149,0x189,0x1c9,0x209,0x249,0x289,0x30b,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
+0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x30b,0,0,0,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
 0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,6,6,8,8,6,0,0,0x17,0x17,0x17,0x17,0x17,0x17,
-0x17,0x17,0x17,4,0x17,0x17,0x17,0x17,0x17,0x17,0,0,6,6,6,6,
-6,6,6,6,6,6,6,6,6,6,7,6,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,8,6,8,6,6,6,6,6,6,6,0,6,8,6,8,
-8,6,6,6,6,6,6,6,6,8,8,8,8,8,8,6,
-6,6,6,6,6,6,6,6,6,0,0,6,0x49,0x89,0xc9,0x109,
-0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,0x49,0x89,0xc9,0x109,
-0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,0x17,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,6,6,6,6,6,6,6,6,6,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x17,0x17,0,6,6,6,6,
-6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,
-8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,6,8,6,6,
-6,6,6,8,6,8,8,8,8,8,6,8,8,5,5,5,
-5,5,5,5,5,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
-0x249,0x289,0x17,0x17,0x17,0x17,0x17,0x17,5,8,6,6,6,6,8,8,
-6,6,8,6,6,6,5,5,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
-0x249,0x289,5,5,5,5,5,5,6,6,8,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,6,8,6,6,8,8,
-8,6,8,6,6,6,8,8,0,0,0,0,0,0,0,0,
-0x17,0x17,0x17,0x17,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,
-0,5,5,5,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,5,5,
-5,5,5,5,8,8,8,8,8,8,8,8,6,6,6,6,
-6,6,6,6,8,8,6,6,0,0,0,0x17,0x17,0x17,0x17,0x17,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,4,4,4,4,4,4,0x17,0x17,
-2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,
-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,
-0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0,0,0,0,0,0,0,0,
-6,6,6,0x17,6,6,6,6,6,6,6,6,6,6,6,6,
-6,8,6,6,6,6,6,6,6,5,5,5,5,6,5,5,
-5,5,5,5,6,5,5,8,6,6,5,0,0,0,0,0,
-2,2,2,2,2,2,2,2,2,2,2,2,4,4,4,4,
+5,5,5,5,5,5,5,6,6,8,8,6,0,0,0x17,0x17,
+0x17,0x17,0x17,0x17,0x17,0x17,0x17,4,0x17,0x17,0x17,0x17,0x17,0x17,0,0,
+6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,6,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,8,6,8,6,6,6,6,6,6,6,0,
+6,8,6,8,8,6,6,6,6,6,6,6,6,8,8,8,
+8,8,8,6,6,6,6,6,6,6,6,6,6,0,0,6,
+0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,
+0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,
+0x17,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,6,6,6,6,6,
+6,6,6,6,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x17,0x17,0,
+6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+6,6,6,6,8,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+6,8,6,6,6,6,6,8,6,8,8,8,8,8,6,8,
+8,5,5,5,5,5,5,5,5,0,0,0,0x49,0x89,0xc9,0x109,
+0x149,0x189,0x1c9,0x209,0x249,0x289,0x17,0x17,0x17,0x17,0x17,0x17,5,8,6,6,
+6,6,8,8,6,6,8,6,6,6,5,5,0x49,0x89,0xc9,0x109,
+0x149,0x189,0x1c9,0x209,0x249,0x289,5,5,5,5,5,5,6,6,8,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,8,
+6,6,8,8,8,6,8,6,6,6,8,8,0,0,0,0,
+0,0,0,0,0x17,0x17,0x17,0x17,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
+0x249,0x289,0,0,0,5,5,5,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
+0x249,0x289,5,5,5,5,5,5,8,8,8,8,8,8,8,8,
+6,6,6,6,6,6,6,6,8,8,6,6,0,0,0,0x17,
+0x17,0x17,0x17,0x17,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,4,4,4,4,
+4,4,0x17,0x17,2,2,2,2,2,2,2,2,2,0,0,0,
+0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
+0,1,1,1,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0,0,0,0,
+0,0,0,0,6,6,6,0x17,6,6,6,6,6,6,6,6,
+6,6,6,6,6,8,6,6,6,6,6,6,6,5,5,5,
+5,6,5,5,5,5,5,5,6,5,5,8,6,6,5,0,
+0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,
 4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
-4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,2,
-2,2,2,2,2,2,2,2,2,2,2,2,4,2,2,2,
-2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-2,2,2,2,2,2,2,2,2,2,2,4,4,4,4,4,
-1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
-1,2,1,2,1,2,2,2,2,2,2,2,2,2,1,2,
-2,2,2,2,2,2,2,2,1,1,1,1,1,0x1a,0x1a,0x1a,
-0,0,2,2,2,0,2,2,1,1,1,1,3,0x1a,0x1a,0,
-2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,
-2,2,2,2,2,2,0,0,1,1,1,1,1,1,0,0,
-2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,
-2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,
-2,2,2,2,2,2,0,0,1,1,1,1,1,1,0,0,
-2,2,2,2,2,2,2,2,0,1,0,1,0,1,0,1,
-2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,
-2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,
-2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,
-2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,
-2,2,2,2,2,0,2,2,1,1,1,1,3,0x1a,2,0x1a,
-0x1a,0x1a,2,2,2,0,2,2,1,1,1,1,3,0x1a,0x1a,0x1a,
-2,2,2,2,0,0,2,2,1,1,1,1,0,0x1a,0x1a,0x1a,
-0x16,0x17,0x17,0x17,0x18,0x14,0x15,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
-0x17,0x17,0x18,0x17,0x16,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0xc,
-0x10,0x10,0x10,0x10,0x10,0,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
-0x2cb,4,0,0,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x18,0x18,0x18,0x14,0x15,4,
-0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0x10,0x10,0x10,0x10,0x10,
-0x13,0x13,0x13,0x13,0x13,0x13,0x17,0x17,0x1c,0x1d,0x14,0x1c,0x1c,0x1d,0x14,0x1c,
-0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0xd,0xe,0x10,0x10,0x10,0x10,0x10,0xc,
-0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x1c,0x1d,0x17,0x17,0x17,0x17,0x16,
-0x2cb,0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x18,0x18,0x18,0x14,0x15,0,
-4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,
-0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,
+4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
+4,4,4,2,2,2,2,2,2,2,2,2,2,2,2,2,
+4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
+2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,4,
+4,4,4,4,1,2,1,2,1,2,1,2,1,2,1,2,
+1,2,1,2,1,2,1,2,1,2,2,2,2,2,2,2,
+2,2,1,2,2,2,2,2,2,2,2,2,1,1,1,1,
+1,0x1a,0x1a,0x1a,0,0,2,2,2,0,2,2,1,1,1,1,
+3,0x1a,0x1a,0,2,2,2,2,2,2,2,2,1,1,1,1,
+1,1,1,1,2,2,2,2,2,2,0,0,1,1,1,1,
+1,1,0,0,2,2,2,2,2,2,2,2,1,1,1,1,
+1,1,1,1,2,2,2,2,2,2,2,2,1,1,1,1,
+1,1,1,1,2,2,2,2,2,2,0,0,1,1,1,1,
+1,1,0,0,2,2,2,2,2,2,2,2,0,1,0,1,
+0,1,0,1,2,2,2,2,2,2,2,2,1,1,1,1,
+1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,
+2,2,0,0,2,2,2,2,2,2,2,2,3,3,3,3,
+3,3,3,3,2,2,2,2,2,2,2,2,3,3,3,3,
+3,3,3,3,2,2,2,2,2,0,2,2,1,1,1,1,
+3,0x1a,2,0x1a,0x1a,0x1a,2,2,2,0,2,2,1,1,1,1,
+3,0x1a,0x1a,0x1a,2,2,2,2,0,0,2,2,1,1,1,1,
+0,0x1a,0x1a,0x1a,0x16,0x17,0x17,0x17,0x18,0x14,0x15,0x17,0x17,0x17,0x17,0x17,
+0x17,0x17,0x17,0x17,0x17,0x17,0x18,0x17,0x16,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
+0x17,0x17,0x17,0xc,0x10,0x10,0x10,0x10,0x10,0,0x10,0x10,0x10,0x10,0x10,0x10,
+0x10,0x10,0x10,0x10,0x2cb,4,0,0,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x18,0x18,
+0x18,0x14,0x15,4,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0x10,
+0x10,0x10,0x10,0x10,0x13,0x13,0x13,0x13,0x13,0x13,0x17,0x17,0x1c,0x1d,0x14,0x1c,
+0x1c,0x1d,0x14,0x1c,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0xd,0xe,0x10,0x10,
+0x10,0x10,0x10,0xc,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x1c,0x1d,0x17,
+0x17,0x17,0x17,0x16,0x2cb,0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x18,0x18,
+0x18,0x14,0x15,0,4,4,4,4,4,4,4,4,4,4,4,4,
+4,0,0,0,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,
 0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,
-0x19,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,
-7,6,7,7,7,6,6,6,6,6,6,6,6,6,6,6,
-6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0x1b,0x1b,0x1b,0x1b,1,0x1b,1,0x1b,1,0x1b,1,1,1,1,0x1b,2,
-1,1,1,1,2,5,5,5,5,2,0x1b,0x1b,2,2,1,1,
-0x18,0x18,0x18,0x18,0x18,1,2,2,2,2,0x1b,0x18,0x1b,0x1b,2,0x1b,
-0x358b,0x360b,0x364b,0x348b,0x388b,0x350b,0x390b,0x3d0b,0x410b,0x354b,0x454b,0x35cb,0x3dcb,0x45cb,0x4dcb,0x58b,
-0x1b,0x1b,1,0x1b,0x1b,0x1b,0x1b,1,0x1b,0x1b,2,1,1,1,2,2,
-1,1,1,2,0x1b,1,0x1b,0x1b,0x18,1,1,1,1,1,0x1b,0x1b,
-0x58a,0x5ca,0x60a,0x64a,0x68a,0x6ca,0x70a,0x74a,0x78a,0x7ca,0x80a,0x84a,0x11ca,0x1e4a,0x980a,0x784a,
-0x58a,0x5ca,0x60a,0x64a,0x68a,0x6ca,0x70a,0x74a,0x78a,0x7ca,0x80a,0x84a,0x11ca,0x1e4a,0x980a,0x784a,
-0x784a,0x984a,0x788a,1,2,0x6ca,0x11ca,0x988a,0x78ca,0x54b,0x1b,0x1b,0,0,0,0,
-0x18,0x18,0x18,0x18,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x18,0x1b,0x1b,0x1b,0x1b,
+0x19,0x19,0x19,0x19,0x19,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,
+6,7,7,7,7,6,7,7,7,6,6,6,6,6,6,6,
+6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0x1b,0x1b,0x1b,0x1b,1,0x1b,1,0x1b,1,0x1b,1,1,
+1,1,0x1b,2,1,1,1,1,2,5,5,5,5,2,0x1b,0x1b,
+2,2,1,1,0x18,0x18,0x18,0x18,0x18,1,2,2,2,2,0x1b,0x18,
+0x1b,0x1b,2,0x1b,0x358b,0x360b,0x364b,0x348b,0x388b,0x350b,0x390b,0x3d0b,0x410b,0x354b,0x454b,0x35cb,
+0x3dcb,0x45cb,0x4dcb,0x58b,0x1b,0x1b,1,0x1b,0x1b,0x1b,0x1b,1,0x1b,0x1b,2,1,
+1,1,2,2,1,1,1,2,0x1b,1,0x1b,0x1b,0x18,1,1,1,
+1,1,0x1b,0x1b,0x58a,0x5ca,0x60a,0x64a,0x68a,0x6ca,0x70a,0x74a,0x78a,0x7ca,0x80a,0x84a,
+0x11ca,0x1e4a,0x980a,0x784a,0x58a,0x5ca,0x60a,0x64a,0x68a,0x6ca,0x70a,0x74a,0x78a,0x7ca,0x80a,0x84a,
+0x11ca,0x1e4a,0x980a,0x784a,0x784a,0x984a,0x788a,1,2,0x6ca,0x11ca,0x988a,0x78ca,0x54b,0x1b,0x1b,
+0,0,0,0,0x18,0x18,0x18,0x18,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x18,
 0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1b,0x1b,0x18,
-0x1b,0x1b,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x18,
-0x1b,0x1b,0x18,0x1b,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
+0x1b,0x1b,0x1b,0x1b,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
+0x18,0x1b,0x1b,0x18,0x1b,0x1b,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x18,0x18,0x1b,0x1b,0x18,0x1b,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
 0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x14,0x15,0x14,0x15,0x1b,0x1b,0x1b,0x1b,
+0x18,0x18,0x18,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x14,0x15,0x14,0x15,
 0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x18,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x14,0x15,0x1b,0x1b,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x18,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x14,0x15,0x1b,
 0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x1b,0x1b,0x1b,
 0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1b,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x18,0x18,0x18,0x18,
+0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
 0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x18,0x18,0x18,0x18,0x18,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x18,0x18,0x18,
+0x18,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
 0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x2cb,0x80b,0x84b,0x88b,0x8cb,0x90b,0x94b,0x98b,0x9cb,0xa0b,0xa4b,0x30b,0x34b,0x38b,
-0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x7cb,0x2cb,0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,
-0x50b,0x7cb,0x80b,0x84b,0x88b,0x8cb,0x90b,0x94b,0x98b,0x9cb,0xa0b,0xa4b,0x30b,0x34b,0x38b,0x3cb,
+0x1b,0x1b,0x1b,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0x1b,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x2cb,0x80b,0x84b,0x88b,0x8cb,0x90b,0x94b,0x98b,0x9cb,0xa0b,
+0xa4b,0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x7cb,0x2cb,0x30b,0x34b,0x38b,0x3cb,
 0x40b,0x44b,0x48b,0x4cb,0x50b,0x7cb,0x80b,0x84b,0x88b,0x8cb,0x90b,0x94b,0x98b,0x9cb,0xa0b,0xa4b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
+0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x7cb,0x80b,0x84b,0x88b,0x8cb,0x90b,0x94b,
+0x98b,0x9cb,0xa0b,0xa4b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x18,0x18,0x18,
+0x18,0x18,0x18,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x1b,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
 0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
 0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,
-0x14,0x15,0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x7cb,0x30b,0x34b,0x38b,0x3cb,
-0x40b,0x44b,0x48b,0x4cb,0x50b,0x7cb,0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x7cb,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x18,0x18,0x18,
-0x18,0x14,0x15,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x14,0x15,
-0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x14,0x15,0x14,0x15,0x14,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,
+0x14,0x15,0x14,0x15,0x14,0x15,0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x7cb,
+0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x7cb,0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,
+0x48b,0x4cb,0x50b,0x7cb,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
+0x18,0x18,0x18,0x18,0x18,0x14,0x15,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
+0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
+0x18,0x18,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x18,0x18,0x18,0x18,
+0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x14,
 0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x14,
-0x15,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x14,0x15,0x14,0x15,
+0x15,0x14,0x15,0x14,0x15,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
 0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x14,0x15,0x18,0x18,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
+0x14,0x15,0x14,0x15,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
 0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x18,0x1b,0x1b,0x18,0x18,0x18,0x18,0x18,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
+0x14,0x15,0x18,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
+0x18,0x18,0x18,0x18,0x18,0x1b,0x1b,0x18,0x18,0x18,0x18,0x18,0x18,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,1,2,1,1,1,2,2,1,
+2,1,2,1,2,1,1,1,1,2,1,2,2,1,2,2,
+2,2,2,2,4,4,1,1,1,2,1,2,2,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x1b,1,2,1,2,6,6,6,1,2,0,0,0,0,
+0,0x17,0x17,0x17,0x17,0x344b,0x17,0x17,2,2,2,2,2,2,0,2,
+0,0,0,0,0,2,0,0,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,4,
+0x17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,
+5,5,5,5,5,5,5,0,5,5,5,5,5,5,5,0,
+5,5,5,5,5,5,5,0,5,5,5,5,5,5,5,0,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,
+0x17,0x17,0x1c,0x1d,0x1c,0x1d,0x17,0x17,0x17,0x1c,0x1d,0x17,0x1c,0x1d,0x17,0x17,
+0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x13,0x17,0x17,0x13,0x17,0x1c,0x1d,0x17,0x17,
+0x1c,0x1d,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x17,0x17,0x17,0x17,0x17,4,
+0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x13,0x13,0x17,0x17,0x17,0x17,
+0x13,0x17,0x14,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
+0x1b,0x1b,0x17,0x17,0x17,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x13,0,0,
 0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
 0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,1,2,1,1,1,2,2,1,2,1,2,1,
-2,1,1,1,1,2,1,2,2,1,2,2,2,2,2,2,
-4,4,1,1,1,2,1,2,2,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,1,
-2,1,2,6,6,6,1,2,0,0,0,0,0,0x17,0x17,0x17,
-0x17,0x344b,0x17,0x17,2,2,2,2,2,2,0,2,0,0,0,0,
-0,2,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,0,0,0,0,0,0,0,4,0x17,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,6,5,5,5,5,
-5,5,5,0,5,5,5,5,5,5,5,0,5,5,5,5,
-5,5,5,0,5,5,5,5,5,5,5,0,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,0,0,0,0,0,0,0,0,0,0x17,0x17,0x1c,0x1d,
-0x1c,0x1d,0x17,0x17,0x17,0x1c,0x1d,0x17,0x1c,0x1d,0x17,0x17,0x17,0x17,0x17,0x17,
-0x17,0x17,0x17,0x13,0x17,0x17,0x13,0x17,0x1c,0x1d,0x17,0x17,0x1c,0x1d,0x14,0x15,
-0x14,0x15,0x14,0x15,0x14,0x15,0x17,0x17,0x17,0x17,0x17,4,0x17,0x17,0x17,0x17,
-0x17,0x17,0x17,0x17,0x17,0x17,0x13,0x13,0x17,0x17,0x17,0x17,0x13,0x17,0x14,0x17,
-0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x1b,0x1b,0x17,0x17,
-0x17,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x13,0,0,0x1b,0x1b,0x1b,0x1b,
 0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,
-0,0,0,0,0,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,
-0x1b,0x58a,0x5ca,0x60a,0x64a,0x68a,0x6ca,0x70a,0x74a,0x78a,6,6,6,6,8,8,
-0x13,4,4,4,4,4,0x1b,0x1b,0x7ca,0xa4a,0xcca,4,5,0x17,0x1b,0x1b,
-0xc,0x17,0x17,0x17,0x1b,4,5,0x54a,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,
-0x14,0x15,0x1b,0x1b,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x13,0x14,0x15,0x15,
+0,0,0,0,0,0,0,0,0,0,0,0,0x1b,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
+0x1b,0x1b,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
+0,0,0,0,0x1b,0x58a,0x5ca,0x60a,0x64a,0x68a,0x6ca,0x70a,0x74a,0x78a,6,6,
+6,6,8,8,0x13,4,4,4,4,4,0x1b,0x1b,0x7ca,0xa4a,0xcca,4,
+5,0x17,0x1b,0x1b,0xc,0x17,0x17,0x17,0x1b,4,5,0x54a,0x14,0x15,0x14,0x15,
+0x14,0x15,0x14,0x15,0x14,0x15,0x1b,0x1b,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,
+0x13,0x14,0x15,0x15,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,0,0,6,6,0x1a,
+0x1a,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x17,
+4,4,4,5,0,0,0,0,0,5,5,5,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,0,0,6,6,0x1a,0x1a,4,4,5,
+5,5,5,5,0,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,0,0x1b,0x1b,0x58b,0x5cb,0x60b,0x64b,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,0,0,
+0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,0x16cb,0x194b,0x1b,0xa8b,0xacb,0xb0b,
+0xb4b,0xb8b,0xbcb,0xc0b,0xc4b,0xc8b,0xccb,0xd0b,0xd4b,0xd8b,0xdcb,0xe0b,0x1b,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0xe4b,0xe8b,0xecb,
+0xf0b,0xf4b,0xf8b,0xfcb,0x100b,0x104b,0x108b,0x10cb,0x110b,0x114b,0x118b,0x11cb,5,5,5,5,
+5,0x685,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x5c5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,0x17,4,4,4,5,
-0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x685,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,0,0x1b,0x1b,0x58b,0x5cb,0x60b,0x64b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,0,0,0,0,0,0,
+5,5,5,5,5,0x705,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,0x585,5,5,0x705,5,5,5,0x7885,
+5,0x605,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,0x16cb,0x194b,0x1b,0xa8b,0xacb,0xb0b,0xb4b,0xb8b,0xbcb,0xc0b,
-0xc4b,0xc8b,0xccb,0xd0b,0xd4b,0xd8b,0xdcb,0xe0b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0xe4b,0xe8b,0xecb,0xf0b,0xf4b,0xf8b,0xfcb,
-0x100b,0x104b,0x108b,0x10cb,0x110b,0x114b,0x118b,0x11cb,5,5,5,5,5,0x685,5,5,
+5,0x785,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+0x5c5,5,5,5,5,5,5,5,0x685,5,0x645,5,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,0x5c5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,0x7985,0x7c5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,0x685,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,0x7845,5,5,5,5,
+5,5,5,5,0x605,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,0x685,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,0x705,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,0x585,5,5,0x705,5,5,5,0x7885,5,0x605,5,5,
+0x1e45,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+0x7985,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x7a85,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,0x785,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,0x5c5,5,5,5,
-5,5,5,5,0x685,5,0x645,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,0x5c5,5,0x745,5,0x6c5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,0x7985,0x7c5,5,5,5,5,5,5,5,
+5,0x7c5,5,0x7845,0xa45,0xcc5,5,5,5,5,5,5,0xf45,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,0x7845,5,5,5,5,5,5,5,5,
-0x605,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,0x685,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,0x1e45,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,0x7985,5,5,5,
+5,0x605,0x605,0x605,0x605,5,5,5,5,5,5,5,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,0x7a85,5,5,5,5,5,
+5,5,5,0x645,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,0x585,5,5,5,5,5,5,5,0x585,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,0x5c5,5,0x745,5,0x6c5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,0x7c5,5,0x7845,
-0xa45,0xcc5,5,5,5,5,5,5,0xf45,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,0x605,0x605,0x605,
-0x605,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x645,
+5,5,5,5,5,5,5,5,5,5,0x585,5,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,0x585,5,5,5,5,5,5,5,0x585,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,0x785,0xa45,5,5,5,5,
+5,5,5,5,5,5,5,5,0x585,0x5c5,0x605,5,0x5c5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,0x585,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x7c5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,0x745,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,0x785,0xa45,5,5,5,5,5,5,5,5,
-5,5,5,5,0x585,0x5c5,0x605,5,0x5c5,5,5,5,5,5,5,5,
+5,5,0x705,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x785,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,0x7c5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,0x745,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x705,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x1e45,5,
+5,5,5,5,5,5,0x645,5,5,5,5,5,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,0x785,5,5,5,5,5,
+0x7885,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,0x5c5,5,5,5,5,0x5c5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,0x5c5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,0x7845,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,0x1e45,5,5,5,5,5,
-5,5,0x645,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,0x7885,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x6c5,5,
+5,5,5,5,0x1e45,5,5,5,5,5,5,5,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,0x5c5,5,5,5,5,0x5c5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,0x5c5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,0x7845,5,5,5,5,5,5,
+0x6c5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,0x545,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,0,0,0,0x1b,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,0x6c5,5,5,5,5,5,
-0x1e45,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,0x6c5,5,5,5,
+5,4,5,5,5,5,5,5,5,5,5,5,0x1b,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x1b,0,0,0,0,0,0,0,0,0,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,4,0x17,0x17,0x17,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,0x545,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,4,5,5,
-5,5,5,5,5,5,5,5,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,
-0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,4,0x17,0x17,0x17,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,0x49,0x89,0xc9,0x109,
-0x149,0x189,0x1c9,0x209,0x249,0x289,5,5,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,1,2,1,2,
+0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,5,5,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
-1,2,1,2,1,2,1,2,4,4,6,6,1,2,1,2,
-1,2,1,2,1,2,1,2,1,2,5,6,7,7,7,0x17,
-6,6,6,6,6,6,6,6,6,6,0x17,4,5,5,5,5,
-5,5,0x58a,0x5ca,0x60a,0x64a,0x68a,0x6ca,0x70a,0x74a,0x78a,0x54a,6,6,0x17,0x17,
-0x17,0x17,0x17,0x17,0,0,0,0,0,0,0,0,0x1a,0x1a,0x1a,0x1a,
+1,2,1,2,1,2,1,2,1,2,1,2,4,4,6,6,
+1,2,1,2,1,2,1,2,1,2,1,2,1,2,5,6,
+7,7,7,0x17,6,6,6,6,6,6,6,6,6,6,0x17,4,
+5,5,5,5,5,5,0x58a,0x5ca,0x60a,0x64a,0x68a,0x6ca,0x70a,0x74a,0x78a,0x54a,
+6,6,0x17,0x17,0x17,0x17,0x17,0x17,0,0,0,0,0,0,0,0,
 0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,
-0x1a,0x1a,0x1a,4,4,4,4,4,4,4,4,4,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,
-4,1,2,5,4,4,2,5,5,5,5,5,0x1a,0x1a,1,2,
-1,2,1,2,1,2,1,2,1,2,1,2,2,2,1,2,
-1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
-4,2,2,2,2,2,2,2,2,1,2,1,2,1,1,2,
-1,2,1,2,1,2,1,2,4,0x1a,0x1a,1,2,1,2,5,
-1,2,1,2,2,2,1,2,1,2,1,2,1,2,1,2,
-1,2,1,1,1,1,1,2,1,1,1,1,1,2,1,2,
-1,2,1,2,1,2,1,2,1,1,1,1,2,1,2,0,
-0,0,0,0,1,2,0,2,0,2,1,2,1,2,0,0,
-0,0,0,0,5,5,6,5,5,5,6,5,5,5,5,6,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,8,8,6,6,8,0x1b,0x1b,0x1b,0x1b,
-6,0,0,0,0x34cb,0x344b,0x3ccb,0x37cb,0x35cb,0x3fcb,0x1b,0x1b,0x19,0x1b,0,0,
-0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,0x17,0x17,0x17,0x17,0,0,0,0,
-0,0,0,0,8,8,8,8,6,6,0,0,0,0,0,0,
-0,0,0x17,0x17,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,
-0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,8,8,8,8,8,8,8,8,8,8,8,8,
-6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
-6,6,5,5,5,5,5,5,0x17,0x17,0x17,5,0x17,5,5,6,
-5,5,5,5,5,5,6,6,6,6,6,6,6,6,0x17,0x17,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,6,6,6,6,6,6,6,6,6,6,6,8,8,
-0,0,0,0,0,0,0,0,0,0,0,0x17,8,0x17,0x17,0x17,
-0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0,4,0x49,0x89,0xc9,0x109,
-0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0x17,0x17,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,
-8,8,6,6,6,6,8,8,6,6,8,8,5,5,5,5,
-5,6,4,5,5,5,5,5,5,5,5,5,0x49,0x89,0xc9,0x109,
-0x149,0x189,0x1c9,0x209,0x249,0x289,5,5,5,5,5,0,5,5,5,5,
-5,5,5,5,5,6,6,6,6,6,6,8,8,6,6,8,
-8,6,6,0,0,0,0,0,0,0,0,0,5,5,5,6,
-5,5,5,5,5,5,5,5,6,8,0,0,0x49,0x89,0xc9,0x109,
-0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0x17,0x17,0x17,0x17,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,4,5,5,5,
-5,5,5,0x1b,0x1b,0x1b,5,8,6,8,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,6,5,6,6,
-6,5,5,6,6,5,5,5,5,5,6,6,5,6,5,0,
+0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,4,4,4,4,4,4,4,4,4,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,5,5,4,0x17,0x17,5,5,5,5,
-5,5,5,5,5,5,5,8,6,6,8,8,0x17,0x17,5,4,
-4,8,6,0,0,0,0,0,0,0,0,0,0,5,5,5,
-5,5,5,0,0,5,5,5,5,5,5,0,0,5,5,5,
-5,5,5,0,0,0,0,0,0,0,0,0,5,5,5,5,
-5,5,5,0,5,5,5,5,5,5,5,0,2,2,2,2,
+0,0,4,4,4,1,2,5,4,4,2,5,5,5,5,5,
+0x1a,0x1a,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
+2,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
+1,2,1,2,4,2,2,2,2,2,2,2,2,1,2,1,
+2,1,1,2,1,2,1,2,1,2,1,2,4,0x1a,0x1a,1,
+2,1,2,5,1,2,1,2,2,2,1,2,1,2,1,2,
+1,2,1,2,1,2,1,1,1,1,1,2,1,1,1,1,
+1,2,1,2,1,2,1,2,1,2,1,2,1,1,1,1,
+2,1,2,0,0,0,0,0,1,2,0,2,0,2,1,2,
+1,2,0,0,0,0,0,0,5,5,6,5,5,5,6,5,
+5,5,5,6,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,8,8,6,6,8,
+0x1b,0x1b,0x1b,0x1b,6,0,0,0,0x34cb,0x344b,0x3ccb,0x37cb,0x35cb,0x3fcb,0x1b,0x1b,
+0x19,0x1b,0,0,0,0,0,0,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,0x17,0x17,0x17,0x17,
+0,0,0,0,0,0,0,0,8,8,8,8,6,6,0,0,
+0,0,0,0,0,0,0x17,0x17,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
+0x249,0x289,0,0,0,0,0,0,8,8,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,8,8,8,8,8,8,8,8,
+8,8,8,8,6,6,6,6,6,6,6,6,6,6,6,6,
+6,6,6,6,6,6,5,5,5,5,5,5,0x17,0x17,0x17,5,
+0x17,5,5,6,5,5,5,5,5,5,6,6,6,6,6,6,
+6,6,0x17,0x17,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,
+6,6,8,8,0,0,0,0,0,0,0,0,0,0,0,0x17,
+8,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0,4,
+0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0x17,0x17,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,6,8,8,6,6,6,6,8,8,6,6,8,8,
+5,5,5,5,5,6,4,5,5,5,5,5,5,5,5,5,
+0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,5,5,5,5,5,0,
+5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,8,
+8,6,6,8,8,6,6,0,0,0,0,0,0,0,0,0,
+5,5,5,6,5,5,5,5,5,5,5,5,6,8,0,0,
+0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0x17,0x17,0x17,0x17,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+4,5,5,5,5,5,5,0x1b,0x1b,0x1b,5,8,6,8,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+6,5,6,6,6,5,5,6,6,5,5,5,5,5,6,6,
+5,6,5,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,5,5,4,0x17,0x17,
+5,5,5,5,5,5,5,5,5,5,5,8,6,6,8,8,
+0x17,0x17,5,4,4,8,6,0,0,0,0,0,0,0,0,0,
+0,5,5,5,5,5,5,0,0,5,5,5,5,5,5,0,
+0,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,
+5,5,5,5,5,5,5,0,5,5,5,5,5,5,5,0,
 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-2,2,2,2,2,2,2,0x1a,4,4,4,4,2,2,2,2,
-2,2,2,2,2,4,0x1a,0x1a,0,0,0,0,2,2,2,2,
-2,2,2,2,2,2,2,2,2,2,2,2,5,5,5,8,
-8,6,8,8,6,8,8,0x17,8,6,0,0,0x49,0x89,0xc9,0x109,
-0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,5,5,5,5,
-0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,
+2,2,2,2,2,2,2,2,2,2,2,0x1a,4,4,4,4,
+2,2,2,2,2,2,2,2,2,4,0x1a,0x1a,0,0,0,0,
+2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
+5,5,5,8,8,6,8,8,6,8,8,0x17,8,6,0,0,
+0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,
+5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,
+5,5,5,5,5,5,5,0,0,0,0,5,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,0,0,0,0,5,5,5,5,
-5,5,5,0,0,0,0,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,0x12,0x12,0x12,0x12,
 0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
-0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x11,0x11,0x11,0x11,
+0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
 0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
-0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,5,5,5,5,
-5,5,5,5,5,5,5,0x605,5,5,5,5,5,5,5,0x7c5,
-5,5,5,5,0x5c5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,0x6c5,5,0x6c5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,0x7c5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,0,0,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,0x18,5,5,
-5,5,5,5,5,5,5,5,5,5,5,0,5,5,5,5,
-5,0,5,0,5,5,0,5,5,0,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,2,2,2,2,2,2,2,0,0,0,0,0,
-0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,
-0,5,6,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,
-0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,0x15,0x14,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,0,0,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0x1b,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-5,5,5,5,5,5,5,5,5,5,5,5,0x19,0x1b,0x1b,0x1b,
-6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
-0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x14,0x15,0x17,0,0,0,0,0,0,
-6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
-0x17,0x13,0x13,0x16,0x16,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x14,
-0x15,0x17,0x17,0x14,0x15,0x17,0x17,0x17,0x17,0x16,0x16,0x16,0x17,0x17,0x17,0,
-0x17,0x17,0x17,0x17,0x13,0x14,0x15,0x14,0x15,0x14,0x15,0x17,0x17,0x17,0x18,0x13,
-0x18,0x18,0x18,0,0x17,0x19,0x17,0x17,0,0,0,0,5,5,5,5,
-5,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
+5,5,5,5,5,5,5,5,5,5,5,0x605,5,5,5,5,
+5,5,5,0x7c5,5,5,5,5,0x5c5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,0x6c5,5,0x6c5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,0,0,0x10,0,0,5,5,5,5,5,5,0,0,5,5,
-5,5,5,5,0,0,5,5,5,5,5,5,0,0,5,5,
-5,0,0,0,0x19,0x19,0x18,0x1a,0x1b,0x19,0x19,0,0x1b,0x18,0x18,0x18,
-0x18,0x1b,0x1b,0,0,0,0,0,0,0,0,0,0,0x10,0x10,0x10,
-0x1b,0x1b,0,0,0,0x17,0x17,0x17,0x19,0x17,0x17,0x17,0x14,0x15,0x17,0x18,
-0x17,0x13,0x17,0x17,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x17,0x17,
-0x18,0x18,0x18,0x17,0x1a,2,2,2,2,2,2,2,2,2,2,2,
-2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0x14,
-0x18,0x15,0x18,0x14,0x15,0x17,0x14,0x15,0x17,0x17,5,5,5,5,5,5,
-5,5,5,5,4,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,0x7c5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,4,4,5,5,5,5,5,5,5,5,
-5,5,5,5,0,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,0,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,
-5,5,0,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,
-0,0,0,0,0xb00b,0xb80b,0x784b,0x804b,0x884b,0x904b,0x984b,0xa04b,0xa84b,0xb04b,0xb84b,0x788b,
-0x808b,0x888b,0x908b,0x988b,0xa08b,0xa88b,0xb08b,0xb88b,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x17,0x17,0x17,0,0,0,0,0x58b,0x5cb,0x60b,0x64b,0x68b,
-0x6cb,0x70b,0x74b,0x78b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,0x16cb,0x194b,0x1bcb,0x1e4b,0x800b,0x880b,
-0x900b,0x980b,0xa00b,0xa80b,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0xcca,0x11ca,0x11ca,0x11ca,0x11ca,0x1e4a,0x880a,
-0x980a,0x980a,0x980a,0x980a,0x980a,0x784a,0x984a,0x68a,0x11ca,0x344b,0x344b,0x388b,0x3ccb,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x54b,0x34cb,0x1b,0x1b,0x1b,0,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,
-0x34ca,0x344a,0x58a,0x68a,0x11ca,0x980a,0x984a,0x988a,0x68a,0x7ca,0x11ca,0x1e4a,0x980a,0x784a,0x984a,0x68a,
-0x7ca,0x11ca,0x1e4a,0x980a,0x784a,0x788a,0x988a,0x7ca,0x58a,0x58a,0x58a,0x5ca,0x5ca,0x5ca,0x5ca,0x68a,
-0x1b,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,6,0,0,
+5,0x18,5,5,5,5,5,5,5,5,5,5,5,5,5,0,
+5,5,5,5,5,0,5,0,5,5,0,5,5,0,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-6,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,
-0x16cb,0x194b,0x1bcb,0x1e4b,0x800b,0x880b,0x900b,0x980b,0xa00b,0xa80b,0xb00b,0xb80b,0,0,0,0,
-0x58b,0x68b,0x7cb,0x11cb,0,0,0,0,0,0,0,0,0,5,5,5,
+5,5,5,5,5,5,5,5,2,2,2,2,2,2,2,0,
+0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,
+0,0,0,0,0,5,6,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,
+0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,0x1bca,5,5,5,5,5,5,5,5,0xb80a,0,0,0,0,0,
+5,5,5,5,5,5,5,5,5,5,0x15,0x14,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,0,0,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,
+0,0,0,0x1b,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
+0x19,0x1b,0x1b,0x1b,6,6,6,6,6,6,6,6,6,6,6,6,
+6,6,6,6,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x14,0x15,0x17,0,0,
+0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,
+6,6,6,6,0x17,0x13,0x13,0x16,0x16,0x14,0x15,0x14,0x15,0x14,0x15,0x14,
+0x15,0x14,0x15,0x14,0x15,0x17,0x17,0x14,0x15,0x17,0x17,0x17,0x17,0x16,0x16,0x16,
+0x17,0x17,0x17,0,0x17,0x17,0x17,0x17,0x13,0x14,0x15,0x14,0x15,0x14,0x15,0x17,
+0x17,0x17,0x18,0x13,0x18,0x18,0x18,0,0x17,0x19,0x17,0x17,0,0,0,0,
+5,5,5,5,5,0,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,0,0,0x10,0,0,5,5,5,5,5,5,
+0,0,5,5,5,5,5,5,0,0,5,5,5,5,5,5,
+0,0,5,5,5,0,0,0,0x19,0x19,0x18,0x1a,0x1b,0x19,0x19,0,
+0x1b,0x18,0x18,0x18,0x18,0x1b,0x1b,0,0,0,0,0,0,0,0,0,
+0,0x10,0x10,0x10,0x1b,0x1b,0,0,0,0x17,0x17,0x17,0x19,0x17,0x17,0x17,
+0x14,0x15,0x17,0x18,0x17,0x13,0x17,0x17,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
+0x249,0x289,0x17,0x17,0x18,0x18,0x18,0x17,0x1a,2,2,2,2,2,2,2,
+2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
+2,2,2,0x14,0x18,0x15,0x18,0x14,0x15,0x17,0x14,0x15,0x17,0x17,5,5,
+5,5,5,5,5,5,5,5,4,5,5,5,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,6,6,6,6,6,0,0,0,0,0,
+5,5,5,5,5,5,5,5,5,5,4,4,5,5,5,5,
+5,5,5,5,5,5,5,5,0,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0x17,
-5,5,5,5,0,0,0,0,5,5,5,5,5,5,5,5,
-0x17,0x58a,0x5ca,0x7ca,0xa4a,0x1e4a,0,0,0,0,0,0,0,0,0,0,
-2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
+5,5,5,0,5,5,0,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,0,0,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,0,0,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,0,0,0,0,0,0xb00b,0xb80b,0x784b,0x804b,0x884b,0x904b,0x984b,0xa04b,
+0xa84b,0xb04b,0xb84b,0x788b,0x808b,0x888b,0x908b,0x988b,0xa08b,0xa88b,0xb08b,0xb88b,0,0,0,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x17,0x17,0x17,0,0,0,0,0x58b,
+0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,0x16cb,0x194b,
+0x1bcb,0x1e4b,0x800b,0x880b,0x900b,0x980b,0xa00b,0xa80b,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0xcca,0x11ca,0x11ca,
+0x11ca,0x11ca,0x1e4a,0x880a,0x980a,0x980a,0x980a,0x980a,0x980a,0x784a,0x984a,0x68a,0x11ca,0x344b,0x344b,0x388b,
+0x3ccb,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x54b,0x34cb,
+0x1b,0x1b,0x1b,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
+0x1b,0,0,0,0x34ca,0x344a,0x58a,0x68a,0x11ca,0x980a,0x984a,0x988a,0x68a,0x7ca,0x11ca,0x1e4a,
+0x980a,0x784a,0x984a,0x68a,0x7ca,0x11ca,0x1e4a,0x980a,0x784a,0x788a,0x988a,0x7ca,0x58a,0x58a,0x58a,0x5ca,
+0x5ca,0x5ca,0x5ca,0x68a,0x1b,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
+0x1b,6,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,6,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0xa4b,
+0xccb,0xf4b,0x11cb,0x144b,0x16cb,0x194b,0x1bcb,0x1e4b,0x800b,0x880b,0x900b,0x980b,0xa00b,0xa80b,0xb00b,0xb80b,
+0,0,0,0,0x58b,0x68b,0x7cb,0x11cb,0,0,0,0,0,0,0,0,
+0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,0x1bca,5,5,5,5,5,5,5,5,0xb80a,0,
+0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,0,
+0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,
-0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,
-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+5,5,0,0x17,5,5,5,5,0,0,0,0,5,5,5,5,
+5,5,5,5,0x17,0x58a,0x5ca,0x7ca,0xa4a,0x1e4a,0,0,0,0,0,0,
+0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,
+2,2,2,2,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,
+0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,
 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,
-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-1,1,1,1,0,0,0,0,2,2,2,2,2,2,2,2,
+0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,0,0,0,0,2,2,2,2,
+2,2,2,2,5,5,5,5,5,5,5,5,0,0,0,0,
+0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0x17,
+1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,
+2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,
+2,2,0,2,2,2,2,2,2,2,0,2,2,0,0,0,
+1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,
+1,1,1,0,1,1,0,2,2,2,2,2,2,2,2,2,
 5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
+4,0,4,4,4,4,4,4,4,4,4,0,0,0,0,0,
+4,4,4,4,4,4,0,4,4,4,4,4,4,4,4,4,
+4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-0,0,0,0,0,0,0,0,0,0,0,0x17,1,1,1,1,
-1,1,1,1,1,1,1,0,1,1,1,1,2,2,0,2,
-2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,
-2,2,2,2,2,2,0,2,2,0,0,0,1,1,1,1,
-1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,
-1,1,0,2,2,2,2,2,2,2,2,2,5,5,5,5,
-5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,
-4,4,4,4,4,4,4,4,4,4,4,4,4,0,4,4,
-4,4,4,4,4,4,4,0,0,0,0,0,4,4,4,4,
-4,4,0,4,4,4,4,4,4,4,4,4,4,4,4,4,
-4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,0,5,5,0,0,0,5,0,0,5,5,5,5,5,
-5,5,0,0,5,0,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0x17,
-0x58b,0x5cb,0x60b,0x7cb,0xa4b,0x1e4b,0x784b,0x788b,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x1b,
-0x1b,0x58b,0x5cb,0x60b,0x64b,0x68b,0x7cb,0xa4b,0,0,0,0,0,0,0,0x58b,
-0x5cb,0x60b,0x64b,0x64b,0x68b,0x7cb,0xa4b,0x1e4b,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,0,5,5,0,0,
-0,0,0,0x58b,0x68b,0x7cb,0xa4b,0x1e4b,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x58b,0x7cb,
-0xa4b,0x1e4b,0x5cb,0x60b,0,0,0,0x17,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,0,0,0,0,0,0x17,0xa04b,0xa84b,0xb04b,0xb84b,0x788b,0x808b,0x888b,0x908b,
-0x988b,0xa08b,0xa88b,0xb08b,0xb88b,0x78cb,0x80cb,0x88cb,0x90cb,0x98cb,0xa0cb,0xa8cb,0xb0cb,0xb8cb,0x36cb,0x354b,
-0x34cb,0x348b,0x46cb,0x344b,0x4ecb,0x388b,0x3ccb,0x454b,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-0,0,0,0,0x5ecb,0x344b,5,5,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,
-0x78b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,0x16cb,0,0,0x1e4b,0x800b,0x880b,0x900b,0x980b,0xa00b,
-0xa80b,0xb00b,0xb80b,0x784b,0x804b,0x884b,0x904b,0x984b,0x30b,0x34b,0x38b,0x3cb,0x7cb,0xa4b,0x1e4b,0x784b,
-0x344b,0,0,0,0,0,0,0,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
-0x17,0,0,0,0,0,0,0,5,6,6,6,0,6,6,0,
-0,0,0,0,6,6,6,6,5,5,5,5,0,5,5,5,
-0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,0,0,6,6,6,0,
-0,0,0,6,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,0,5,5,0,0,0,5,0,0,5,
+5,5,5,5,5,5,0,0,5,0,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,0,0x17,0x58b,0x5cb,0x60b,0x7cb,0xa4b,0x1e4b,0x784b,0x788b,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,0x58b,0x11cb,0x17,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,0x1b,0x1b,0x58b,0x5cb,0x60b,0x64b,0x68b,0x7cb,0xa4b,0,0,0,0,
+0,0,0,0x58b,0x5cb,0x60b,0x64b,0x64b,0x68b,0x7cb,0xa4b,0x1e4b,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,
+5,5,0,0,0,0,0,0x58b,0x68b,0x7cb,0xa4b,0x1e4b,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,0x58b,0x7cb,0xa4b,5,5,5,5,5,6,6,0,0,0,0,0x58b,
-0x68b,0x7cb,0xa4b,0x1e4b,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0,0,0,0,0,
-0,0,0,0,5,5,5,5,5,5,5,5,0x1b,5,5,5,
+5,5,0x58b,0x7cb,0xa4b,0x1e4b,0x5cb,0x60b,0,0,0,0x17,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,0,0,0,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
+5,5,5,5,5,5,0,0,0,0,0,0x17,0xa04b,0xa84b,0xb04b,0xb84b,
+0x788b,0x808b,0x888b,0x908b,0x988b,0xa08b,0xa88b,0xb08b,0xb88b,0x78cb,0x80cb,0x88cb,0x90cb,0x98cb,0xa0cb,0xa8cb,
+0xb0cb,0xb8cb,0x36cb,0x354b,0x34cb,0x348b,0x46cb,0x344b,0x4ecb,0x388b,0x3ccb,0x454b,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,0,0,0x58b,0x5cb,0x60b,0x64b,0x7cb,0xa4b,0x1e4b,0x784b,
+5,5,5,5,0,0,0,0,0x5ecb,0x344b,5,5,0x58b,0x5cb,0x60b,0x64b,
+0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,0x16cb,0,0,0x1e4b,0x800b,
+0x880b,0x900b,0x980b,0xa00b,0xa80b,0xb00b,0xb80b,0x784b,0x804b,0x884b,0x904b,0x984b,0x30b,0x34b,0x38b,0x3cb,
+0x7cb,0xa4b,0x1e4b,0x784b,0x344b,0,0,0,0,0,0,0,0x17,0x17,0x17,0x17,
+0x17,0x17,0x17,0x17,0x17,0,0,0,0,0,0,0,5,6,6,6,
+0,6,6,0,0,0,0,0,6,6,6,6,5,5,5,5,
+0,5,5,5,0,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,
+6,6,6,0,0,0,0,6,5,5,5,5,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,0,0,0,0,0,0x58b,0x5cb,0x60b,0x64b,0x7cb,0xa4b,0x1e4b,0x784b,
+5,5,5,5,5,0x58b,0x11cb,0x17,5,5,5,5,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,0,0,0,0,0,0,0,0x17,0x17,0x17,0x17,0,0,0,
-0,0,0,0,0,0,0,0,0,0x58b,0x5cb,0x60b,0x64b,0x7cb,0xa4b,0x1e4b,
+5,5,5,5,5,0x58b,0x7cb,0xa4b,5,5,5,5,5,6,6,0,
+0,0,0,0x58b,0x68b,0x7cb,0xa4b,0x1e4b,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0,
+0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,
+0x1b,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,0,0,0,0x17,0x17,0x17,
+0x17,0x17,0x17,0x17,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,0,0,0x58b,0x5cb,0x60b,0x64b,
+0x7cb,0xa4b,0x1e4b,0x784b,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,0,0,0,0,0,0x58b,0x5cb,0x60b,0x64b,
+0x7cb,0xa4b,0x1e4b,0x784b,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,0,0,0,0,0,0,0,0x17,0x17,0x17,
+0x17,0,0,0,0,0,0,0,0,0,0,0,0,0x58b,0x5cb,0x60b,
+0x64b,0x7cb,0xa4b,0x1e4b,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,5,5,5,5,5,5,5,5,5,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,
+0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,
+0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,
+2,2,2,2,2,2,2,0,0,0,0,0,0,0,0x58b,0x68b,
+0x7cb,0x11cb,0x1e4b,0x784b,5,5,5,5,6,6,6,6,0,0,0,0,
+0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,
+0,0,0,0,0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x7cb,0xa4b,0xccb,
+0xf4b,0x11cb,0x144b,0x16cb,0x194b,0x1bcb,0x1e4b,0x800b,0x880b,0x900b,0x980b,0xa00b,0xa80b,0xb00b,0xb80b,0x344b,
+0x34cb,0x348b,0x388b,0,5,5,5,5,5,5,5,5,5,5,0,6,
+6,0x13,0,0,5,5,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
-2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-2,2,2,0,0,0,0,0,0,0,0x58b,0x68b,0x7cb,0x11cb,0x1e4b,0x784b,
-5,5,5,5,6,6,6,6,0,0,0,0,0,0,0,0,
-0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,
-0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,0x16cb,
-0x194b,0x1bcb,0x1e4b,0x800b,0x880b,0x900b,0x980b,0xa00b,0xa80b,0xb00b,0xb80b,0x344b,0x34cb,0x348b,0x388b,0,
-5,5,5,5,5,5,5,5,5,5,0,6,6,0x13,0,0,
-5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,6,6,6,5,5,5,5,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,0x58b,0x5cb,0x60b,
-0x64b,0x68b,0x7cb,0xa4b,0xccb,0x1e4b,0x344b,5,0,0,0,0,0,0,0,0,
+5,5,5,5,5,0x58b,0x5cb,0x60b,0x64b,0x68b,0x7cb,0xa4b,0xccb,0x1e4b,0x344b,5,
+0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,
+6,6,6,6,6,0x58b,0x7cb,0xa4b,0x1e4b,0x17,0x17,0x17,0x17,0x17,0,0,
+0,0,0,0,5,5,6,6,6,6,0x17,0x17,0x17,0x17,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,5,5,5,5,5,0x58b,0x5cb,0x60b,0x64b,0x7cb,0xa4b,0x1e4b,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0x144b,0x16cb,0x194b,0x1bcb,0x1e4b,0x784b,0x49,0x89,0xc9,0x109,0x149,0x189,
+0x1c9,0x209,0x249,0x289,6,5,5,6,6,5,0,0,0,0,0,0,
+0,0,0,6,8,6,8,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,6,6,6,6,6,6,6,0x17,0x17,0x17,0x17,0x17,
+0x17,0x17,0,0,0,0,0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x7cb,
+0xa4b,0xccb,0xf4b,0x11cb,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,8,8,8,6,6,6,6,8,8,6,6,0x17,
+0x17,0x10,0x17,0x17,0x17,0x17,6,0,0,0,0,0,0,0,0,0,
+0,0x10,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,0,0,0,0,0,0,0,0x49,0x89,0xc9,0x109,
+0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,5,5,5,5,
+5,5,5,6,6,6,6,6,8,6,6,6,6,6,6,6,
+6,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x17,0x17,0x17,0x17,
+5,8,8,5,0,0,0,0,0,0,0,0,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,6,6,6,6,6,6,6,6,6,6,6,0x58b,0x7cb,0xa4b,
-0x1e4b,0x17,0x17,0x17,0x17,0x17,0,0,0,0,0,0,5,5,6,6,
-6,6,0x17,0x17,0x17,0x17,0,0,0,0,0,0,0,0,0,0,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,
+0x17,0x17,5,0,0,0,0,0,0,0,0,0,8,5,5,5,
+5,0x17,0x17,0x17,0x17,6,6,6,6,0x17,8,6,0x49,0x89,0xc9,0x109,
+0x149,0x189,0x1c9,0x209,0x249,0x289,5,0x17,5,0x17,0x17,0x17,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,
+8,8,6,6,6,6,6,6,6,6,6,8,0,0x58b,0x5cb,0x60b,
+0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,0x16cb,0x194b,0x1bcb,0x1e4b,
+0x784b,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,
+5,5,5,5,5,5,5,5,8,8,8,6,6,6,8,8,
+6,8,6,6,0x17,0x17,0x17,0x17,0x17,0x17,6,5,5,6,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,
-5,0x58b,0x5cb,0x60b,0x64b,0x7cb,0xa4b,0x1e4b,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0x144b,0x16cb,0x194b,0x1bcb,
-0x1e4b,0x784b,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,6,5,5,6,
-6,5,0,0,0,0,0,0,0,0,0,6,8,6,8,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,
-6,6,6,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0,0,0,0,0x30b,0x34b,
-0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,6,
-6,6,6,8,8,6,6,0x17,0x17,0x10,0x17,0x17,0x17,0x17,6,0,
-0,0,0,0,0,0,0,0,0,0x10,0,0,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,
-0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,
-0,0,0,0,5,5,5,5,5,5,5,6,6,6,6,6,
-8,6,6,6,6,6,6,6,6,0,0x49,0x89,0xc9,0x109,0x149,0x189,
-0x1c9,0x209,0x249,0x289,0x17,0x17,0x17,0x17,5,8,8,5,0,0,0,0,
-0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,6,6,6,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,6,0x17,0x17,5,0,0,0,0,0,
-0,0,0,0,8,5,5,5,5,0x17,0x17,0x17,0x17,6,6,6,
-6,0x17,8,6,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,5,0x17,
-5,0x17,0x17,0x17,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,8,8,8,6,6,6,6,6,6,
-6,6,6,8,0,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0xa4b,
-0xccb,0xf4b,0x11cb,0x144b,0x16cb,0x194b,0x1bcb,0x1e4b,0x784b,0,0,0,0,0,0,0,
-0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
-8,8,8,6,6,6,8,8,6,8,6,6,0x17,0x17,0x17,0x17,
-0x17,0x17,6,0,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,0,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,0,5,0,5,5,5,5,0,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,5,
-5,5,5,5,5,5,5,5,5,0x17,0,0,0,0,0,0,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,
+5,0,5,5,5,5,0,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,0,5,5,5,5,5,5,5,5,5,
+5,0x17,0,0,0,0,0,0,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,8,8,8,6,6,6,6,6,
+6,6,6,0,0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
+0x249,0x289,0,0,0,0,0,0,5,5,8,8,0,0,6,6,
+6,6,6,6,6,0,0,0,6,6,6,6,6,0,0,0,
+0,0,0,0,0,0,0,0,6,6,8,8,0,5,5,5,
+5,5,5,5,5,0,0,5,5,0,0,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,0,5,5,5,5,5,5,
+5,0,5,5,0,5,5,5,5,5,0,6,6,5,8,8,
+6,8,8,8,8,0,0,8,8,0,0,8,8,8,0,0,
+5,0,0,0,0,0,0,8,0,0,0,0,0,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,8,8,8,6,6,6,6,6,6,6,6,
+8,8,6,6,6,8,6,5,5,5,5,0x17,0x17,0x17,0x17,0x17,
+0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x17,0x17,0,0x17,6,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-8,8,8,6,6,6,6,6,6,6,6,0,0,0,0,0,
+8,8,8,6,6,6,6,6,6,8,6,8,8,8,8,6,
+6,8,6,6,5,5,0x17,5,0,0,0,0,0,0,0,0,
 0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,
-5,5,8,8,0,0,6,6,6,6,6,6,6,0,0,0,
-6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0,
-6,6,8,8,0,5,5,5,5,5,5,5,5,0,0,5,
-5,0,0,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,0,5,5,5,5,5,5,5,0,5,5,0,5,5,5,
-5,5,0,6,6,5,8,8,6,8,8,8,8,0,0,8,
-8,0,0,8,8,8,0,0,5,0,0,0,0,0,0,8,
-0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,
-6,6,6,6,6,6,6,6,8,8,6,6,6,8,6,5,
-5,5,5,0x17,0x17,0x17,0x17,0x17,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
-0x249,0x289,0x17,0x17,0,0x17,6,5,5,5,0,0,0,0,0,0,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,
+8,8,6,6,6,6,0,0,8,8,8,8,6,6,8,6,
+6,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
+0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,5,5,5,5,6,6,0,0,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+8,8,8,6,6,6,6,6,6,6,6,8,8,6,8,6,
+6,0x17,0x17,0x17,5,0,0,0,0,0,0,0,0,0,0,0,
+0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,
+0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+5,5,5,5,5,5,5,5,5,5,5,6,8,6,8,8,
+6,6,6,6,6,6,8,6,5,0x17,0,0,0,0,0,0,
+8,8,6,6,6,6,8,6,6,6,6,6,0,0,0,0,
+0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x7cb,0xa4b,0x17,0x17,0x17,0x1b,
+5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,6,
+6,6,6,6,6,6,6,6,8,6,6,0x17,0,0,0,0,
+0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,
+0x16cb,0x194b,0x1bcb,0,0,0,0,0,0,0,0,0,0,0,0,5,
+8,5,8,6,0x17,0x17,0x17,0,0,0,0,0,0,0,0,0,
+0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,
+5,5,5,5,5,5,5,0,0,5,0,0,5,5,5,5,
+5,5,5,5,0,5,5,0,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,8,8,8,8,8,8,0,8,
+8,0,0,6,6,8,6,5,6,5,0x17,5,8,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,8,8,8,6,6,6,6,6,
-6,8,6,8,8,8,8,6,6,8,6,6,5,5,0x17,5,
-0,0,0,0,0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
-0x249,0x289,0,0,0,0,0,0,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,8,8,8,6,6,6,6,0,0,
-8,8,8,8,6,6,8,6,6,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
-0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
-5,5,5,5,6,6,0,0,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,8,8,8,6,6,6,6,6,
-6,6,6,8,8,6,8,6,6,0x17,0x17,0x17,5,0,0,0,
-0,0,0,0,0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
-0x249,0x289,0,0,0,0,0,0,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
-0x17,0x17,0x17,0x17,0x17,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
-0x249,0x289,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,8,8,8,6,6,6,6,
+0,0,6,6,8,8,8,8,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,
+6,8,5,6,6,6,6,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,6,
+0,0,0,0,0,0,0,0,5,6,6,6,6,6,6,8,
+8,6,6,6,5,5,5,5,5,6,6,6,6,6,6,6,
+6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,0x17,0x17,0x17,0,0,0,0,0,
 0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,
-5,5,5,6,8,6,8,8,6,6,6,6,6,6,8,6,
-5,0x17,0,0,0,0,0,0,8,8,6,6,6,6,8,6,
-6,6,6,6,0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
-0x249,0x289,0x7cb,0xa4b,0x17,0x17,0x17,0x1b,5,5,5,5,5,5,5,0,
+5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,
+6,6,6,6,6,6,6,8,6,6,0x17,0x17,0x17,5,0x17,0x17,
+5,0x17,0x17,0x17,0x17,0x17,0,0,0,0,0,0,0,0,0,0,
+0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,
+0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,
-5,5,5,5,8,8,8,6,6,6,6,6,6,6,6,6,
-8,6,6,0x17,0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
-0x249,0x289,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,0x16cb,0x194b,0x1bcb,0,0,0,0,0,
-0,0,0,0,0,0,0,5,8,5,8,6,0x17,0x17,0x17,0,
+0x70b,0x74b,0x78b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,0x16cb,0x194b,0x1bcb,0x1e4b,0,0,0,
+0x17,0x17,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,8,6,6,6,6,
+6,6,6,0,6,6,6,6,6,6,8,6,6,6,6,6,
+6,6,6,6,0,8,6,6,6,6,6,6,6,8,6,6,
+8,6,6,0,0,0,0,0,0,0,0,0,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,0,0,6,6,
+6,6,6,6,6,6,6,6,6,6,6,6,6,6,5,6,
 0,0,0,0,0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
 0x249,0x289,0,0,0,0,0,0,5,5,5,5,5,5,5,0,
-0,5,0,0,5,5,5,5,5,5,5,5,0,5,5,0,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-8,8,8,8,8,8,0,8,8,0,0,6,6,8,6,5,
-6,5,0x17,5,8,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-5,5,5,5,5,5,5,5,0,0,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,8,8,8,6,6,6,6,0,0,6,6,8,8,8,8,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,6,6,6,6,6,6,8,5,6,6,6,6,0x17,
-0x17,0x17,0x17,0x17,0x17,0x17,0x17,6,0,0,0,0,0,0,0,0,
-5,6,6,6,6,6,6,8,8,6,6,6,5,5,5,5,
-5,6,6,6,6,6,6,6,6,6,6,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-0x17,0x17,0x17,0,0,0,0,0,0,0,0,0,0,0,0,0,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,8,
-6,6,0x17,0x17,0x17,5,0x17,0x17,5,0x17,0x17,0x17,0x17,0x17,0,0,
-0,0,0,0,0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
-0x249,0x289,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,
-0x144b,0x16cb,0x194b,0x1bcb,0x1e4b,0,0,0,0x17,0x17,5,5,5,5,5,5,
+5,5,0,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,0,
+0,0,6,0,6,6,0,6,5,5,5,5,5,5,5,5,
+5,5,8,8,8,8,8,0,6,6,0,8,8,6,8,6,
+5,0,0,0,0,0,0,0,5,5,5,5,5,5,0,5,
+5,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,6,6,8,8,0x17,
+0x17,0,0,0,0,0,0,0,6,8,6,0x17,0x17,0x17,0x17,0x17,
+0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
+0x249,0x289,0,0,0,0,0,0,6,6,5,8,5,5,5,5,
 5,5,5,5,5,5,5,5,5,0,5,5,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,8,6,6,6,6,6,6,6,0,6,6,6,6,
-6,6,8,6,6,6,6,6,6,6,6,6,0,8,6,6,
-6,6,6,6,6,8,6,6,8,6,6,0,0,0,0,0,
-0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,0,0,6,6,6,6,6,6,6,6,6,6,
-6,6,6,6,6,6,5,6,0,0,0,0,0,0,0,0,
-0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,
-5,5,5,5,5,5,5,0,5,5,0,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,6,6,6,6,6,6,0,0,0,6,0,6,6,0,6,
-5,5,5,5,5,5,5,5,5,5,8,8,8,8,8,0,
-6,6,0,8,8,6,8,6,5,0,0,0,0,0,0,0,
-5,5,5,5,5,5,0,5,5,0,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,6,6,8,8,0x17,0x17,0,0,0,0,0,0,0,
+8,8,6,6,6,6,6,0,0,0,8,8,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0x19,0x1b,0x1b,0x1b,
 0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,
@@ -1215,8 +1226,10 @@ static const uint16_t propsTrie_index[22688]={
 0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,0x17,0x17,0,
 0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,0,0x10,0x10,0x10,0x10,
-0x10,0x10,0x10,0x10,0x10,0,0,0,0,0,0,0,0x49,0x89,0xc9,0x109,
+5,5,5,5,5,5,5,5,5,5,5,5,0x10,0x10,0x10,0x10,
+0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,6,5,5,5,
+5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,
+6,6,0,0,0,0,0,0,0,0,0,0,0x49,0x89,0xc9,0x109,
 0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,5,5,5,5,
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,
 6,6,6,6,6,0x17,0,0,0,0,0,0,0,0,0,0,
@@ -1241,145 +1254,153 @@ static const uint16_t propsTrie_index[22688]={
 5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,4,4,4,4,0,4,4,4,4,4,4,4,
 0,4,4,0,5,5,5,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,5,5,5,0,0,5,0,0,
+0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,
+0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,0,0,0,0,0,5,5,5,5,
+5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,
+5,5,5,5,5,5,5,5,5,5,0,0,0x1b,6,6,0x17,
+0x10,0x10,0x10,0x10,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,5,5,5,0,0,0,0,0,0,0,0,0,
-0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,
-5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,0,0,0,0,0,5,5,5,5,5,5,5,5,
-5,5,5,5,5,0,0,0,0,0,0,0,5,5,5,5,
-5,5,5,5,5,5,0,0,0x1b,6,6,0x17,0x10,0x10,0x10,0x10,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0x1b,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,
-6,6,6,6,6,6,6,6,6,6,0,0,6,6,6,6,
-6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,
-0,0,0,0,0,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,8,8,6,6,6,0x1b,0x1b,0x1b,8,8,8,
-8,8,8,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,6,6,6,6,6,
-6,6,6,0x1b,0x1b,6,6,6,6,6,6,6,0x1b,0x1b,0x1b,0x1b,
+6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,0,
+6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+6,6,6,0,0,0,0,0,0,0,0,0,0x1b,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,
+0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,8,8,6,6,6,0x1b,0x1b,
+0x1b,8,8,8,8,8,8,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,6,
+6,6,6,6,6,6,6,0x1b,0x1b,6,6,6,6,6,6,6,
 0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,6,6,6,6,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,6,6,6,0x1b,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0x54b,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,
-0x74b,0x78b,0x7cb,0x80b,0x84b,0x88b,0x8cb,0x90b,0x94b,0x98b,0x9cb,0xa0b,0,0,0,0,
-0,0,0,0,0,0,0,0,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,
-0x78b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,0x16cb,0x194b,0x1bcb,0x58b,0x5cb,0x60b,0x64b,0x68b,0x58b,
-0x68b,0,0,0,0,0,0,0,0x249,0x289,0x49,0x89,0xc9,0x109,0x149,0x189,
-0x1c9,0x209,0x249,0x289,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x49,0x89,
-0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,1,1,1,1,1,1,1,1,
-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,
-1,1,1,1,1,1,2,2,2,2,2,2,2,0,2,2,
-2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,6,6,6,6,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,6,6,
+6,0x1b,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0x54b,0x58b,0x5cb,0x60b,
+0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0x80b,0x84b,0x88b,0x8cb,0x90b,0x94b,0x98b,0x9cb,0xa0b,
+0,0,0,0,0,0,0,0,0,0,0,0,0x58b,0x5cb,0x60b,0x64b,
+0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,0x16cb,0x194b,0x1bcb,0x58b,0x5cb,
+0x60b,0x64b,0x68b,0x58b,0x68b,0,0,0,0,0,0,0,0x249,0x289,0x49,0x89,
+0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
+0x249,0x289,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,1,1,1,1,
 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-2,2,2,2,2,2,2,2,2,2,2,2,1,0,1,1,
-0,0,1,0,0,1,1,0,0,1,1,1,1,0,1,1,
-1,1,1,1,1,1,2,2,2,2,0,2,0,2,2,2,
-2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,
+1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,
+2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,
+2,0,2,2,2,2,2,2,2,2,2,2,1,1,1,1,
 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-2,2,2,2,1,1,0,1,1,1,1,0,0,1,1,1,
-1,1,1,1,1,0,1,1,1,1,1,1,1,0,2,2,
+1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,
 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-2,2,2,2,2,2,2,2,1,1,0,1,1,1,1,0,
-1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,
+1,0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,
+1,0,1,1,1,1,1,1,1,1,2,2,2,2,0,2,
+0,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,
+2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,2,2,2,2,1,1,0,1,1,1,1,0,
+0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,
 1,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,
+2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,1,
+1,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,
+1,1,1,1,1,0,2,2,2,2,2,2,2,2,2,2,
+2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,
 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
+2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,2,2,2,2,2,2,0,0,1,1,1,1,
 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-2,2,2,2,2,2,0,0,1,1,1,1,1,1,1,1,
-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-1,0x18,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-2,2,2,2,2,2,2,2,2,2,2,0x18,2,2,2,2,
-2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-1,1,1,1,1,1,1,1,1,1,1,0x18,2,2,2,2,
+1,1,1,1,1,0x18,2,2,2,2,2,2,2,2,2,2,
+2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0x18,
+2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0x18,
 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-2,0x18,2,2,2,2,2,2,1,1,1,1,1,1,1,1,
-1,1,1,1,1,1,1,1,2,2,2,0x18,2,2,2,2,
-2,2,1,2,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,
-0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0,6,6,6,6,6,6,6,
-6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,
-6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0x1b,
-0x1b,0x1b,0x1b,6,6,6,6,6,6,6,6,6,6,6,6,6,
-6,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,6,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,6,0x1b,0x1b,0x17,0x17,0x17,0x17,0x17,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,
-6,6,6,0,6,6,6,6,6,6,6,6,6,6,6,6,
-6,6,6,6,6,0,0,6,6,6,6,6,2,2,2,2,
-2,2,2,2,2,2,5,2,2,2,2,2,2,2,2,2,
-2,2,2,2,2,2,2,2,2,2,2,0,6,6,0,6,
-6,0,6,6,6,6,6,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0x49,0x89,0xc9,0x109,
-0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,5,0x1b,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,
-5,5,5,5,5,5,5,5,5,0,0,0,6,6,6,6,
-6,6,6,4,4,4,4,4,4,4,0,0,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,6,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,
-5,5,5,5,5,5,5,5,6,6,6,6,0x49,0x89,0xc9,0x109,
-0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0x19,5,5,5,5,
-5,5,5,0,5,5,5,5,0,5,5,0,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,0,5,5,5,5,
-5,0,0,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,6,6,6,6,
-6,6,6,0,0,0,0,0,0,0,0,0,2,2,2,2,
-6,6,6,6,6,6,6,4,0,0,0,0,0x49,0x89,0xc9,0x109,
-0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0x17,0x17,1,1,2,2,
+2,2,2,2,2,0x18,2,2,2,2,2,2,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,0x18,
+2,2,2,2,2,2,1,2,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,
+0x1c9,0x209,0x249,0x289,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0,6,6,6,
+6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,
+6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+6,6,6,0x1b,0x1b,0x1b,0x1b,6,6,6,6,6,6,6,6,6,
+6,6,6,6,6,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,6,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,6,0x1b,0x1b,0x17,0x17,0x17,0x17,0x17,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,
+6,6,6,6,6,6,6,0,6,6,6,6,6,6,6,6,
+6,6,6,6,6,6,6,6,6,0,0,6,6,6,6,6,
+2,2,2,2,2,2,2,2,2,2,5,2,2,2,2,2,
+2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,
+0,0,0,0,0,2,2,2,2,2,2,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+6,6,0,6,6,0,6,6,6,6,6,0,0,0,0,0,
+4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,5,0x1b,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,
+6,6,6,6,6,6,6,4,4,4,4,4,4,4,0,0,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,
+0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0x19,
+5,5,5,5,5,5,5,5,5,5,5,4,6,6,6,6,
+0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,
+5,5,5,5,5,5,5,0,5,5,5,5,0,5,5,0,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,
+5,5,5,5,5,0,0,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,
+6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,
+2,2,2,2,6,6,6,6,6,6,6,4,0,0,0,0,
+0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0x17,0x17,
+1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0x58b,0x5cb,0x60b,
-0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,0x78cb,0x794b,0x814b,0x58b,
-0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x1b,0x34cb,0x344b,0x3ccb,0x19,0x58b,0x5cb,0x788b,
-0x78cb,0,0,0,0,0,0,0,0,0,0,0,0x16cb,0x194b,0x1bcb,0x1e4b,
-0x800b,0x880b,0x900b,0x980b,0xa00b,0xa80b,0xb00b,0xb80b,0x784b,0x804b,0x884b,0x904b,0x984b,0xa04b,0xa84b,0xb04b,
-0xb84b,0x788b,0x808b,0x888b,0x908b,0x988b,0xa08b,0xa88b,0xb08b,0xb88b,0x78cb,0x80cb,0x984b,0xa04b,0xa84b,0xb04b,
-0xb84b,0x788b,0x808b,0x888b,0x908b,0x988b,0xa08b,0xa88b,0xb08b,0xb88b,0x1b,0x5cb,0x60b,0x64b,0x68b,0x6cb,
-0x70b,0x74b,0x78b,0x7cb,0x900b,0xa00b,0x804b,0x788b,0x344b,0x354b,0,0,0,0x58b,0x5cb,0x60b,
-0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,0x16cb,0x194b,0x1bcb,0x1e4b,
-0x800b,0x880b,0x900b,0x980b,0xa00b,0xa80b,0xb00b,0xb80b,0x784b,0x804b,0x884b,0x904b,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0x18,0x18,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,
-0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,5,5,5,5,0,5,5,0,
-5,0,0,5,0,5,5,5,5,5,5,5,5,5,5,0,
-5,5,5,5,0,5,0,5,0,0,0,0,0,0,5,0,
-0,0,0,5,0,5,0,5,0,5,5,5,0,5,5,0,
-5,0,0,5,0,5,0,5,0,5,0,5,0,5,5,0,
-5,0,0,5,5,5,5,0,5,5,5,5,5,5,5,0,
-5,5,5,5,0,5,5,5,5,0,5,0,5,5,5,5,
-5,5,5,5,5,5,0,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,0,0,0,0,0,5,5,5,
-0,5,5,5,5,5,0,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,5,0,0,0,0,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x2cb,0x2cb,0x30b,0x34b,
-0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x54b,0x54b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,
+0x78cb,0x794b,0x814b,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x1b,0x34cb,0x344b,0x3ccb,
+0x19,0x58b,0x5cb,0x788b,0x78cb,0,0,0,0,0,0,0,0,0,0,0,
+0x16cb,0x194b,0x1bcb,0x1e4b,0x800b,0x880b,0x900b,0x980b,0xa00b,0xa80b,0xb00b,0xb80b,0x784b,0x804b,0x884b,0x904b,
+0x984b,0xa04b,0xa84b,0xb04b,0xb84b,0x788b,0x808b,0x888b,0x908b,0x988b,0xa08b,0xa88b,0xb08b,0xb88b,0x78cb,0x80cb,
+0x984b,0xa04b,0xa84b,0xb04b,0xb84b,0x788b,0x808b,0x888b,0x908b,0x988b,0xa08b,0xa88b,0xb08b,0xb88b,0x1b,0x5cb,
+0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0x900b,0xa00b,0x804b,0x788b,0x344b,0x354b,0,0,
+0,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,
+0x16cb,0x194b,0x1bcb,0x1e4b,0x800b,0x880b,0x900b,0x980b,0xa00b,0xa80b,0xb00b,0xb80b,0x784b,0x804b,0x884b,0x904b,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0x18,0x18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+5,5,5,5,0,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+0,5,5,0,5,0,0,5,0,5,5,5,5,5,5,5,
+5,5,5,0,5,5,5,5,0,5,0,5,0,0,0,0,
+0,0,5,0,0,0,0,5,0,5,0,5,0,5,5,5,
+0,5,5,0,5,0,0,5,0,5,0,5,0,5,0,5,
+0,5,5,0,5,0,0,5,5,5,5,0,5,5,5,5,
+5,5,5,0,5,5,5,5,0,5,5,5,5,0,5,0,
+5,5,5,5,5,5,5,5,5,5,0,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,
+0,5,5,5,0,5,5,5,5,5,0,5,5,5,5,5,
+5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,
 0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,
-0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0x1b,0x1b,0x1b,0x1b,
 0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,0,0x1b,0x1b,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0x1b,0x1b,0x1b,0x1b,
+0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
+0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
+0x2cb,0x2cb,0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x54b,0x54b,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
+0,0,0,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x1b,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,0,
 0x1b,0x1b,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0x1b,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1a,0x1a,0x1a,0x1a,0x1a,0x1b,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1a,0x1a,0x1a,0x1a,0x1a,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,
 0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0x1b,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,
 0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,0,0x1b,0x1b,0x1b,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,0x1b,0x1b,0x1b,0x1b,
 0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0x1b,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0x1b,0x1b,0x1b,0x1b,
 0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,0,0,0x1b,0x1b,0x1b,0x1b,
@@ -1388,13 +1409,12 @@ static const uint16_t propsTrie_index[22688]={
 0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,
 0x1b,0x1b,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,
-0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,0,0,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,0,0,0,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,
+0,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,
+0,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
 0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,
-0,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,
-0,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,
+0x1b,0x1b,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,
+0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
 0,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
 0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
 0x1b,0x1b,0x1b,0x1b,5,0x705,5,5,5,5,5,5,5,5,5,5,
@@ -1416,176 +1436,177 @@ static const uint16_t propsTrie_index[22688]={
 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
 5,5,5,0x605,5,5,5,5,5,5,5,5,5,5,5,5,
 5,0x645,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
 5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
 5,5,5,5,0x785,5,5,5,5,5,5,5,5,5,5,5,
-5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0x10,0x10,0x10,0x10,
+5,5,5,5,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
 0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
-0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0,0x10,0,0,
+0x10,0x10,0x10,0x10,0,0x10,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,
-6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0x11,0x11,0x11,0x11,
+0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,
+6,6,6,6,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
 0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
-0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0,0,0,0,0,0
+0x11,0x11,0,0,0,0,0,0
 };
 
 static const UTrie2 propsTrie={
     propsTrie_index,
-    propsTrie_index+4656,
+    propsTrie_index+4692,
     NULL,
-    4656,
-    18032,
+    4692,
+    18324,
     0xa40,
-    0x12b0,
+    0x12d4,
     0x0,
     0x0,
     0x110000,
-    0x589c,
-    NULL, 0, FALSE, FALSE, 0, NULL
+    0x59e4,
+    NULL, 0, false, false, 0, NULL
 };
 
-static const uint16_t propsVectorsTrie_index[32060]={
-0x511,0x519,0x521,0x529,0x541,0x549,0x551,0x559,0x561,0x569,0x571,0x579,0x581,0x589,0x591,0x599,
-0x5a0,0x5a8,0x5b0,0x5b8,0x5bb,0x5c3,0x5cb,0x5d3,0x5db,0x5e3,0x5eb,0x5f3,0x5fb,0x603,0x60b,0x613,
-0x61b,0x623,0x62a,0x632,0x63a,0x642,0x64a,0x652,0x65a,0x662,0x667,0x66f,0x676,0x67e,0x686,0x68e,
-0x696,0x69e,0x6a6,0x6ae,0x6b5,0x6bd,0x6c5,0x6cd,0x6d5,0x6dd,0x6e5,0x6ed,0x6f5,0x6fd,0x705,0x70d,
-0x1aba,0xd5a,0xe2e,0x1162,0x1299,0x1c7b,0x1e12,0x1c73,0x1367,0x1377,0x135f,0x136f,0x7da,0x7e0,0x7e8,0x7f0,
-0x7f8,0x7fe,0x806,0x80e,0x816,0x81c,0x824,0x82c,0x834,0x83a,0x842,0x84a,0x852,0x85a,0x862,0x869,
-0x871,0x877,0x87f,0x887,0x88f,0x895,0x89d,0x8a5,0x8ad,0x137f,0x8b5,0x8bd,0x8c5,0x8cc,0x8d4,0x8dc,
-0x8e4,0x8e8,0x8f0,0x8f7,0x8ff,0x907,0x90f,0x917,0x169a,0x16a2,0x91f,0x927,0x92f,0x937,0x93f,0x946,
-0x1700,0x16f0,0x16f8,0x19f5,0x19fd,0x138f,0x94e,0x1387,0x15e3,0x15e3,0x15e5,0x13a3,0x13a4,0x1397,0x1399,0x139b,
-0x1708,0x170a,0x956,0x170a,0x95e,0x963,0x96b,0x170f,0x971,0x170a,0x977,0x97f,0xc3a,0x1717,0x1717,0x987,
-0x1727,0x1728,0x1728,0x1728,0x1728,0x1728,0x1728,0x1728,0x1728,0x1728,0x1728,0x1728,0x1728,0x1728,0x1728,0x1728,
-0x1728,0x1728,0x1728,0x171f,0x98f,0x1730,0x1730,0x997,0xb62,0xb6a,0xb72,0xb7a,0x1740,0x1738,0x99f,0x9a7,
-0x9af,0x174a,0x1752,0x9b7,0x1748,0x9bf,0x1ac2,0xd62,0xb82,0xb8a,0xb92,0xb97,0x195b,0xc61,0xc68,0x18b7,
-0xc12,0x1aca,0xd6a,0xd72,0xd7a,0xd82,0xf38,0xf3c,0x19bb,0x19c0,0xca0,0xca8,0x1a31,0x1a39,0x1b93,0xe36,
-0x1a41,0xcee,0xcf6,0x1a49,0x10e2,0x118a,0xf10,0xd8a,0x18d7,0x18bf,0x18cf,0x18c7,0x1973,0x196b,0x1927,0x19b3,
-0x13ac,0x13ac,0x13ac,0x13ac,0x13af,0x13ac,0x13ac,0x13b7,0x9c7,0x13bf,0x9cb,0x9d3,0x13bf,0x9db,0x9e3,0x9eb,
-0x13cf,0x13c7,0x13d7,0x9f3,0x9fb,0x13df,0xa03,0xa0b,0x13e7,0x13ef,0x13f7,0x13ff,0xa13,0x1407,0x140e,0x1416,
-0x141e,0x1426,0x142e,0x1436,0x143e,0x1445,0x144d,0x1455,0x145d,0x1465,0x1468,0x146a,0x175a,0x184d,0x1853,0x19a3,
-0x1472,0xa1b,0xa23,0x1598,0x159d,0x15a0,0x15a6,0x147a,0x15ae,0x15ae,0x148a,0x1482,0x1492,0x149a,0x14a2,0x14aa,
-0x14b2,0x14ba,0x14c2,0x14ca,0x185b,0x18af,0x1a05,0x1b5b,0x14da,0x14e0,0x14e8,0x14f0,0x14d2,0x14f8,0x1863,0x186a,
-0x1762,0x1762,0x1762,0x1762,0x1762,0x1762,0x1762,0x1762,0x1872,0x1872,0x1872,0x1872,0x187a,0x1881,0x1883,0x188a,
-0x1892,0x1896,0x1896,0x1899,0x1896,0x1896,0x189f,0x1896,0x18df,0x19ab,0x1a0d,0xb9f,0xba5,0x1cbf,0x1cc7,0x1d9d,
-0x194b,0x193f,0x1943,0x19c8,0x192f,0x192f,0x192f,0xc22,0x1937,0xc42,0x198b,0xc90,0xc2a,0xc32,0xc32,0x1a51,
-0x197b,0x1a15,0xc78,0xc80,0xa2b,0x176a,0x176a,0xa33,0x1772,0x1772,0x1772,0x1772,0x1772,0x1772,0xa3b,0x715,
-0x15cb,0x15ed,0xa43,0x15f5,0xa4b,0x15fd,0x1605,0x160d,0xa53,0xa58,0x1615,0x161c,0xa5d,0x177a,0x199b,0xc1a,
-0xa65,0x1677,0x167e,0x1624,0x1686,0x168a,0x162c,0x1630,0x1649,0x1649,0x164b,0x1638,0x1640,0x1640,0x1641,0x1692,
-0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,
-0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,
-0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,
-0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,
-0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,
-0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,
-0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,
-0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,
-0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,
-0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,
-0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,
-0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,
-0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1782,0x1785,0x18e7,0x18e7,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
-0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x165a,0x1ab2,0x1e7e,
-0x178d,0x1793,0x1793,0x1793,0x1793,0x1793,0x1793,0x1793,0x1793,0x1793,0x1793,0x1793,0x1793,0x1793,0x1793,0x1793,
-0x1793,0x1793,0x1793,0x1793,0x1793,0x1793,0x1793,0x1793,0x1793,0x1793,0x1793,0x1793,0x1793,0x1793,0x1793,0x1793,
-0x1793,0x1793,0x1793,0x1793,0xa6d,0x179b,0xa75,0x1ad2,0x1a5d,0x1a5d,0x1a5d,0x1a5d,0x1a5d,0x1a5d,0x1a5d,0x1a5d,
-0x1a59,0xcfe,0x1a6d,0x1a65,0x1a6f,0x1ada,0x1ada,0xd92,0x1953,0x19d0,0x1a25,0x1a29,0x1a1d,0x1b8b,0xcb0,0xcb7,
-0x1983,0xc88,0x19d8,0xcbf,0x1a77,0x1a7a,0xd06,0x1ae2,0x1a8a,0x1a82,0xd0e,0xd9a,0x1aea,0x1aee,0xda2,0xfec,
-0x1a92,0xd16,0xd1e,0x1af6,0x1b06,0x1afe,0xdaa,0xee0,0xe3e,0xe46,0x1d0d,0xf9c,0x1dba,0x1dba,0x1b0e,0xdb2,
-0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,
-0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,
-0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,
-0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,
-0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,
-0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,
-0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,
-0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,
-0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,
-0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,
-0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,
-0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,
-0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,
-0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,
-0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,
-0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,
-0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,
-0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,
-0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,
-0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,
-0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,
-0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0x16e8,0x16e2,0x16e3,0x16e4,0x16e5,0x16e6,0x16e7,0xa7d,0xdba,0xdbd,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0x16ba,0x16ba,0x16ba,0x16ba,0x16ba,0x16ba,0x16ba,0x16ba,0x16ba,0x16ba,0x16ba,0x16ba,0x16ba,0x16ba,0x16ba,0x16ba,
-0x16ba,0x16ba,0x16ba,0x16ba,0x16ba,0x16ba,0x16ba,0x16ba,0x16ba,0x16ba,0x16ba,0x16ba,0x16ba,0x16ba,0x16ba,0x16ba,
-0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,
-0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,
-0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,
-0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,
-0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,
-0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,
-0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,
-0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,
-0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,
-0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,
-0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,
-0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,
-0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x15b6,0x1662,0x1662,0x1662,0x1662,0x1662,0x1662,0x1662,0x1662,
-0x1667,0x166f,0x18a7,0x132c,0x1993,0x1993,0x1330,0x1337,0xa85,0xa8d,0xa95,0x1518,0x151f,0x1527,0xa9d,0x152f,
-0x156d,0x156d,0x1500,0x1508,0x1537,0x1564,0x1565,0x1575,0x153f,0x1544,0x154c,0x1554,0xaa5,0x155c,0xaad,0x1510,
-0xc98,0x157d,0xab5,0xabd,0x1585,0x158b,0x1590,0xac5,0xad5,0x15d3,0x15db,0x15be,0x15c3,0xadd,0xae5,0xacd,
-0x16aa,0x16aa,0x16aa,0x16aa,0x16aa,0x16aa,0x16aa,0x16aa,0x16aa,0x16aa,0x16aa,0x16aa,0x16aa,0x16aa,0x16aa,0x16aa,
-0x16aa,0x16aa,0x16aa,0x16aa,0x16aa,0x16aa,0x16aa,0x16aa,0x16aa,0x16aa,0x16aa,0x16aa,0x16b2,0x16b2,0x16b2,0x16b2,
-0x14c4,0x14c4,0x1504,0x1544,0x1584,0x15c4,0x1604,0x1644,0x1680,0x16c0,0x16ec,0x172c,0x176c,0x17ac,0x17ec,0x182c,
-0x186c,0x18a8,0x18e8,0x1928,0x1968,0x199c,0x19d8,0x1a18,0x1a58,0x1a98,0x1ad4,0x1b14,0x1b54,0x1b94,0x1bd4,0x1c14,
-0xe59,0xa80,0xac0,0xb00,0xb40,0xb6b,0xed9,0xa40,0xefb,0xa40,0xa40,0xa40,0xa40,0xbab,0x1381,0x1381,
-0xf3b,0xfbb,0xa40,0xa40,0xa40,0xbeb,0xf7b,0xc2b,0xa40,0xc51,0xc91,0xcd1,0xd11,0xd51,0xe99,0xdc9,
-0x12c1,0x12c1,0x12c1,0x12c1,0x12c1,0x12c1,0x12c1,0x12c1,0x12c1,0x12c1,0x12c1,0x12c1,0x12c1,0x12c1,0x12c1,0x12c1,
-0x12c1,0x12c1,0x12c1,0x12c1,0xffb,0x1301,0x1136,0x1176,0x1341,0x1181,0x13c1,0x13c1,0x13c1,0x103b,0x105b,0x109b,
-0x1401,0x1401,0x10db,0x105b,0x105b,0x105b,0x105b,0x105b,0x105b,0x105b,0x105b,0x105b,0x105b,0x105b,0x105b,0x105b,
-0x105b,0x105b,0x105b,0x105b,0x105b,0x105b,0x105b,0x105b,0x105b,0x105b,0x105b,0x105b,0x105b,0x105b,0x105b,0x10f6,
+static const uint16_t propsVectorsTrie_index[32692]={
+0x539,0x541,0x549,0x551,0x569,0x571,0x579,0x581,0x589,0x591,0x599,0x5a1,0x5a9,0x5b1,0x5b9,0x5c1,
+0x5c8,0x5d0,0x5d8,0x5e0,0x5e3,0x5eb,0x5f3,0x5fb,0x603,0x60b,0x613,0x61b,0x623,0x62b,0x633,0x63b,
+0x643,0x64b,0x652,0x65a,0x662,0x66a,0x672,0x67a,0x682,0x68a,0x68f,0x697,0x69e,0x6a6,0x6ae,0x6b6,
+0x6be,0x6c6,0x6ce,0x6d6,0x6dd,0x6e5,0x6ed,0x6f5,0x6fd,0x705,0x70d,0x715,0x71d,0x725,0x72d,0x735,
+0x1b39,0xd8a,0xe56,0x118d,0x12cc,0x1d01,0x1ea0,0x1cf9,0x13e6,0x13f6,0x13de,0x13ee,0x80a,0x810,0x818,0x820,
+0x828,0x82e,0x836,0x83e,0x846,0x84c,0x854,0x85c,0x864,0x86a,0x872,0x87a,0x882,0x88a,0x892,0x899,
+0x8a1,0x8a7,0x8af,0x8b7,0x8bf,0x8c5,0x8cd,0x8d5,0x8dd,0x13fe,0x8e5,0x8ed,0x8f5,0x8fc,0x904,0x90c,
+0x914,0x918,0x920,0x927,0x92f,0x937,0x93f,0x947,0x1719,0x1721,0x94f,0x957,0x95f,0x967,0x96f,0x976,
+0x177f,0x176f,0x1777,0x1a74,0x1a7c,0x140e,0x97e,0x1406,0x1662,0x1662,0x1664,0x1422,0x1423,0x1416,0x1418,0x141a,
+0x1787,0x1789,0x986,0x1789,0x98e,0x993,0x99b,0x178e,0x9a1,0x1789,0x9a7,0x9af,0xc6a,0x1796,0x1796,0x9b7,
+0x17a6,0x17a7,0x17a7,0x17a7,0x17a7,0x17a7,0x17a7,0x17a7,0x17a7,0x17a7,0x17a7,0x17a7,0x17a7,0x17a7,0x17a7,0x17a7,
+0x17a7,0x17a7,0x17a7,0x179e,0x9bf,0x17af,0x17af,0x9c7,0xb92,0xb9a,0xba2,0xbaa,0x17bf,0x17b7,0x9cf,0x9d7,
+0x9df,0x17c9,0x17d1,0x9e7,0x17c7,0x9ef,0x1b41,0xd92,0xbb2,0xbba,0xbc2,0xbc7,0x19da,0xc91,0xc98,0x1936,
+0xc42,0x1b49,0xd9a,0xda2,0xdaa,0xdb2,0xf60,0xf64,0x1a3a,0x1a3f,0xcd0,0xcd8,0x1ab0,0x1ab8,0x1c19,0xe5e,
+0x1ac0,0xd1e,0xd26,0x1ac8,0x1105,0x11b5,0xf38,0xdba,0x1956,0x193e,0x194e,0x1946,0x19f2,0x19ea,0x19a6,0x1a32,
+0x142b,0x142b,0x142b,0x142b,0x142e,0x142b,0x142b,0x1436,0x9f7,0x143e,0x9fb,0xa03,0x143e,0xa0b,0xa13,0xa1b,
+0x144e,0x1446,0x1456,0xa23,0xa2b,0x145e,0xa33,0xa3b,0x1466,0x146e,0x1476,0x147e,0xa43,0x1486,0x148d,0x1495,
+0x149d,0x14a5,0x14ad,0x14b5,0x14bd,0x14c4,0x14cc,0x14d4,0x14dc,0x14e4,0x14e7,0x14e9,0x17d9,0x18cc,0x18d2,0x1a22,
+0x14f1,0xa4b,0xa53,0x1617,0x161c,0x161f,0x1625,0x14f9,0x162d,0x162d,0x1509,0x1501,0x1511,0x1519,0x1521,0x1529,
+0x1531,0x1539,0x1541,0x1549,0x18da,0x192e,0x1a84,0x1be1,0x1559,0x155f,0x1567,0x156f,0x1551,0x1577,0x18e2,0x18e9,
+0x17e1,0x17e1,0x17e1,0x17e1,0x17e1,0x17e1,0x17e1,0x17e1,0x18f1,0x18f1,0x18f1,0x18f1,0x18f9,0x1900,0x1902,0x1909,
+0x1911,0x1915,0x1915,0x1918,0x1915,0x1915,0x191e,0x1915,0x195e,0x1a2a,0x1a8c,0xbcf,0xbd5,0x1d45,0x1d4d,0x1e2b,
+0x19ca,0x19be,0x19c2,0x1a47,0x19ae,0x19ae,0x19ae,0xc52,0x19b6,0xc72,0x1a0a,0xcc0,0xc5a,0xc62,0xc62,0x1ad0,
+0x19fa,0x1a94,0xca8,0xcb0,0xa5b,0x17e9,0x17e9,0xa63,0x17f1,0x17f1,0x17f1,0x17f1,0x17f1,0x17f1,0xa6b,0x73d,
+0x164a,0x166c,0xa73,0x1674,0xa7b,0x167c,0x1684,0x168c,0xa83,0xa88,0x1694,0x169b,0xa8d,0x17f9,0x1a1a,0xc4a,
+0xa95,0x16f6,0x16fd,0x16a3,0x1705,0x1709,0x16ab,0x16af,0x16c8,0x16c8,0x16ca,0x16b7,0x16bf,0x16bf,0x16c0,0x1711,
+0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,
+0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,
+0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,
+0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,
+0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,
+0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,
+0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,
+0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,
+0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,
+0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,
+0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,
+0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,
+0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1801,0x1804,0x1966,0x1966,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
+0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d9,0x1b31,0x1f0c,
+0x180c,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,
+0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,
+0x1812,0x1812,0x1812,0x1812,0xa9d,0x181a,0xaa5,0x1b51,0x1adc,0x1adc,0x1adc,0x1adc,0x1adc,0x1adc,0x1adc,0x1adc,
+0x1ad8,0xd2e,0x1aec,0x1ae4,0x1aee,0x1b59,0x1b59,0xdc2,0x19d2,0x1a4f,0x1aa4,0x1aa8,0x1a9c,0x1c11,0xce0,0xce7,
+0x1a02,0xcb8,0x1a57,0xcef,0x1af6,0x1af9,0xd36,0x1b61,0x1b09,0x1b01,0xd3e,0xdca,0x1b69,0x1b6d,0xdd2,0x100f,
+0x1b11,0xd46,0xd4e,0x1b75,0x1b85,0x1b7d,0xdda,0xf08,0xe66,0xe6e,0x1d9b,0xfbf,0x1e48,0x1e48,0x1b8d,0xde2,
+0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,
+0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,
+0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,
+0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,
+0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,
+0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,
+0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,
+0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,
+0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,
+0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,
+0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,
+0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,
+0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,
+0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,
+0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,
+0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,
+0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,
+0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,
+0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,
+0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,
+0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,
+0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0x1767,0x1761,0x1762,0x1763,0x1764,0x1765,0x1766,0xaad,0xdea,0xded,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x1739,0x1739,0x1739,0x1739,0x1739,0x1739,0x1739,0x1739,0x1739,0x1739,0x1739,0x1739,0x1739,0x1739,0x1739,0x1739,
+0x1739,0x1739,0x1739,0x1739,0x1739,0x1739,0x1739,0x1739,0x1739,0x1739,0x1739,0x1739,0x1739,0x1739,0x1739,0x1739,
+0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,
+0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,
+0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,
+0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,
+0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,
+0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,
+0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,
+0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,
+0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,
+0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,
+0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,
+0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,
+0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x16e1,0x16e1,0x16e1,0x16e1,0x16e1,0x16e1,0x16e1,0x16e1,
+0x16e6,0x16ee,0x1926,0x13a3,0x1a12,0x1a12,0x13a7,0x13ae,0xab5,0xabd,0xac5,0x1597,0x159e,0x15a6,0xacd,0x15ae,
+0x15ec,0x15ec,0x157f,0x1587,0x15b6,0x15e3,0x15e4,0x15f4,0x15be,0x15c3,0x15cb,0x15d3,0xad5,0x15db,0xadd,0x158f,
+0xcc8,0x15fc,0xae5,0xaed,0x1604,0x160a,0x160f,0xaf5,0xb05,0x1652,0x165a,0x163d,0x1642,0xb0d,0xb15,0xafd,
+0x1729,0x1729,0x1729,0x1729,0x1729,0x1729,0x1729,0x1729,0x1729,0x1729,0x1729,0x1729,0x1729,0x1729,0x1729,0x1729,
+0x1729,0x1729,0x1729,0x1729,0x1729,0x1729,0x1729,0x1729,0x1729,0x1729,0x1729,0x1729,0x1731,0x1731,0x1731,0x1731,
+0x1564,0x1564,0x15a4,0x15e4,0x1624,0x1664,0x16a4,0x16e4,0x1720,0x1760,0x178c,0x17cc,0x180c,0x184c,0x188c,0x18cc,
+0x190c,0x1948,0x1988,0x19c8,0x1a08,0x1a3c,0x1a78,0x1ab8,0x1af8,0x1b38,0x1b74,0x1bb4,0x1bf4,0x1c34,0x1c74,0x1cb4,
+0xe59,0xa80,0xac0,0xb00,0xb40,0xb6b,0xf99,0xa40,0xed9,0xa40,0xa40,0xa40,0xa40,0xbab,0x13e2,0x13e2,
+0xf19,0xfd9,0xa40,0xa40,0xa40,0xbeb,0xf59,0xc2b,0xa40,0xc51,0xc91,0xcd1,0xd11,0xd51,0xe99,0xdc9,
+0x1322,0x1322,0x1322,0x1322,0x1322,0x1322,0x1322,0x1322,0x1322,0x1322,0x1322,0x1322,0x1322,0x1322,0x1322,0x1322,
+0x1322,0x1322,0x1322,0x1322,0x1019,0x1362,0x1157,0x1197,0x13a2,0x11a2,0x1422,0x1422,0x1422,0x1059,0x1079,0x10b9,
+0x1462,0x1462,0x11e2,0x14a2,0x10f9,0x1079,0x1079,0x1079,0x1079,0x1079,0x1079,0x1079,0x1079,0x1079,0x1079,0x1079,
+0x1079,0x1079,0x1079,0x1079,0x1079,0x1079,0x1079,0x1079,0x1079,0x1079,0x1079,0x1079,0x1079,0x1079,0x1079,0x1117,
 0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
 0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xd89,
 0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
@@ -1608,1868 +1629,1908 @@ static const uint16_t propsVectorsTrie_index[32060]={
 0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xd89,
 0xe09,0xe19,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
 0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xd89,
-0x1241,0x1241,0x1241,0x1241,0x1241,0x1241,0x1241,0x1241,0x1241,0x1241,0x1241,0x1241,0x1241,0x1241,0x1241,0x1241,
-0x1241,0x1241,0x1241,0x1241,0x1241,0x1241,0x1241,0x1241,0x1241,0x1241,0x1241,0x1241,0x1241,0x1241,0x1241,0x11c1,
-0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,
-0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1201,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0xbf7,0xbfa,0xdc5,0x1d5d,0xff4,0x71d,0x531,0x108e,0xcc7,0xd46,0x531,0x531,0x1c8b,0xee8,0xef0,0x1da5,
-0xc4a,0xc51,0xc59,0x1b16,0x1d3d,0x531,0x1d1d,0xfc4,0x1b1e,0xdcd,0xdd5,0xddd,0x101c,0x725,0x531,0x531,
-0x1b26,0x1b26,0x72d,0x531,0x1dd2,0x10a6,0x1dca,0x10ae,0x1ebe,0x11a0,0x531,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0xde5,0x1f16,0x1291,0x531,0x531,0x1ede,0x11c8,0x11cf,0x11d6,0x12cd,0x12d1,0x1248,0x11de,
-0x1b9b,0x1b9d,0xe4e,0xe55,0x1b2e,0x1b36,0xded,0xf08,0x1c83,0xed0,0xed8,0xfbc,0x1ca3,0x1ca7,0x1caf,0x103c,
-0xf87,0xf8c,0x735,0x531,0x1096,0x109e,0x1d05,0xf94,0xf69,0xf6f,0xf77,0xf7f,0x531,0x531,0x531,0x531,
-0x1e42,0x1e3a,0x1110,0x1118,0x1d85,0x1d7d,0x1064,0x531,0x531,0x531,0x531,0x531,0x1d6d,0x1024,0x102c,0x1034,
-0x1d35,0x1d2d,0xfd4,0x1108,0x1cb7,0xf18,0x73d,0x531,0x1074,0x107c,0x745,0x531,0x531,0x531,0x531,0x531,
-0x1eb6,0x1182,0x74d,0x531,0x531,0x1d95,0x1d8d,0x106c,0x1250,0x1256,0x125e,0x531,0x531,0x11e6,0x11ea,0x11f2,
-0x1e76,0x1e6e,0x116a,0x1e66,0x1e5e,0x115a,0x1d65,0x1014,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0x10c6,0x10cb,0x10d3,0x10da,0x10fa,0x1100,0x531,0x531,0x113e,0x1142,0x114a,0x1192,0x1198,0x755,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x11b0,0x531,0x531,0x531,0x531,0x531,0x759,0x1efe,0x1238,
-0x19e0,0x19e0,0x19e0,0x19e0,0x19e0,0x19e0,0x19e0,0x19e0,0x19e0,0x19e0,0x19e0,0x19e0,0x19e0,0x19e0,0x19e0,0x19e0,
-0x19e0,0x19e0,0x19e0,0x19e0,0x19e0,0x19e0,0x19e0,0x19e0,0x19e0,0x19e0,0x19e0,0x19e5,0xccf,0xcd6,0xcd6,0xcd6,
-0x19ed,0x19ed,0x19ed,0xcde,0x1dc2,0x1dc2,0x1dc2,0x1dc2,0x1dc2,0x1dc2,0x761,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x765,0x1f2e,0x1f2e,0x12a1,0x1ba5,0x1ba5,0x1ba5,0x1ba5,0x1ba5,
-0x1ba5,0x1ba5,0x1ba5,0x1ba5,0x1ba5,0x1ba5,0x1ba5,0x1ba5,0x1ba5,0x1ba5,0x1ba5,0x1ba5,0xe5d,0xfdc,0xfe4,0x1f36,
-0x12d9,0x12e1,0xf20,0x1d55,0x1d4d,0x1004,0x100c,0x76d,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x1ed6,0x1ece,0x11c0,
-0x531,0x531,0x531,0x1c9b,0x1c9b,0xef8,0x1c93,0xf00,0x531,0x531,0x10f2,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x771,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x1ced,0x1ced,0x1ced,0xf44,0xf49,
-0x779,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x1f46,0x1301,0x1308,0x1f3e,0x1f3e,0x1f3e,0x781,
-0x531,0x17c0,0x17c0,0x17c0,0x17c0,0x17c0,0x17c0,0x17c0,0xafb,0x17d0,0xb03,0x17d1,0x17c8,0x17d9,0x17df,0x17e7,
-0xb0b,0x190f,0x190f,0x789,0x531,0x531,0x531,0x531,0x11b8,0x18ff,0x18ff,0xc02,0xce6,0x531,0x531,0x531,
-0x531,0x1818,0x181f,0xb13,0x1822,0xb1b,0xb23,0xb2b,0x181c,0xb33,0xb3b,0xb43,0x1821,0x1829,0x1818,0x181f,
-0x181b,0x1822,0x182a,0x1819,0x1820,0x181c,0xb4a,0x17ef,0x17f7,0x17fe,0x1805,0x17f2,0x17fa,0x1801,0x1808,0xb52,
-0x1810,0x1dea,0x1dea,0x1dea,0x1dea,0x1dea,0x1dea,0x1dea,0x1dea,0x1dea,0x1dea,0x1dea,0x1dea,0x1dea,0x1dea,0x1dea,
-0x1dea,0x1dda,0x1ddd,0x1dda,0x1de4,0x10b6,0x791,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x12bd,0x12c5,0x12c5,0x12c5,0x12c5,0x12c5,0x12c5,
-0x12c5,0x10ea,0x799,0x531,0x531,0x531,0x531,0x531,0x531,0x1ef6,0x11fa,0x7a1,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x7a5,0x12e9,0x1f06,0x1240,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0x12a9,0x1d25,0x1d25,0x1d25,0x1d25,0x1d25,0x1d25,0xfcc,0x531,0x1e32,0x1e2a,0x10be,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x7ad,0x1ec6,0x11a8,0x531,0x531,0x1202,0x1203,0x7b5,0x531,0x531,0x531,0x531,
-0x531,0xe95,0xe9d,0xea5,0xead,0xeb5,0xebd,0xec4,0xec8,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x7b9,0x1044,0x1d75,0x104a,0x1d75,0x1052,0x1057,0x105c,
-0x105c,0x1dfa,0x1e1a,0x1e22,0x1e8e,0x1e02,0x1ee6,0x1e0a,0x1e96,0x1eee,0x1eee,0x1172,0x117a,0x121a,0x1220,0x1228,
-0x1230,0x1f0e,0x1f0e,0x1f0e,0x1f0e,0x1274,0x1f0e,0x127a,0x127e,0x7c1,0x7c1,0x7c1,0x7c1,0x7c1,0x7c1,0x7c1,
-0x7c1,0x7c1,0x7c1,0x7c1,0x7c1,0x7c1,0x7c1,0x7c1,0x7c1,0x7c1,0x7c1,0x7c1,0x7c1,0x7c1,0x7c1,0x7c1,
-0x7c1,0x7c1,0x7c1,0x7c1,0x7c1,0x7c1,0x7c1,0x7c1,0x7c2,0xb5a,0x1832,0x1832,0x1832,0x7ca,0x7ca,0x7ca,
-0x7ca,0x1907,0x1907,0x1907,0x1907,0x1907,0x1907,0x1907,0x7d2,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,
-0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,
-0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,
-0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,
-0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0xbad,0xbb4,0xbbc,0xbc4,0x18ef,0x18ef,0x18ef,
-0xbcc,0xbd4,0xbd7,0x191f,0x1917,0xc0a,0xd26,0xd2a,0xd2e,0x531,0x531,0x531,0x531,0xd36,0x1a9a,0xd3e,
-0xf30,0x17a3,0xaed,0xaf3,0xffc,0xbdf,0x1963,0xc70,0x531,0x17b8,0x17ab,0x17b0,0x18f7,0xbe7,0xbef,0x1120,
-0x1126,0x1cf5,0xf51,0x1ce5,0xf28,0x12f1,0x12f9,0x531,0x531,0x1d15,0x1d15,0x1d15,0x1d15,0x1d15,0x1d15,0x1d15,
-0x1d15,0x1d15,0xfa4,0xfac,0xfb4,0x12b1,0x12b5,0x531,0x531,0x1aa2,0xd4e,0x1aaa,0x1aaa,0xd52,0xe65,0xe6d,
-0xe75,0x1b6b,0x1b53,0x1b73,0x1b7b,0x1b63,0xdfd,0xe01,0xe08,0xe10,0xe14,0xe1c,0xe24,0xe26,0xe26,0xe26,
-0xe26,0x1bdc,0x1be4,0x1bdc,0x1bea,0x1bf2,0x1bbd,0x1bfa,0x1c02,0x1bdc,0x1c0a,0x1c12,0x1c19,0x1c21,0x1bc5,0x1bdc,
-0x1c26,0x1bcd,0x1bd4,0x1c2e,0x1c34,0x1cd6,0x1cdd,0x1ccf,0x1c3b,0x1c43,0x1c4b,0x1c53,0x1d45,0x1c5b,0x1c63,0xe7d,
-0xe85,0x1bad,0x1bad,0x1bad,0xe8d,0x1cfd,0x1cfd,0xf59,0xf61,0x1b3e,0x1b3e,0x1b3e,0x1b3e,0x1b3e,0x1b3e,0x1b3e,
-0x1b3e,0x1b3e,0x1b3e,0x1b3e,0x1b3e,0x1b3e,0x1b3e,0x1b3e,0x1b3e,0x1b3e,0x1b3e,0x1b40,0x1b3e,0x1b48,0x1b3e,0x1b3e,
-0x1b3e,0x1b3e,0x1b3e,0x1b3e,0x1b4b,0x1b3e,0x1b3e,0x1b3e,0x1b3e,0x1b3e,0xdf5,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x1dad,0x1dad,0x1dad,0x1dad,0x1dad,
-0x1dad,0x1dad,0x1dad,0x1dad,0x1dad,0x1dad,0x1dad,0x1dad,0x1dad,0x1db2,0x1dad,0x1dad,0x1dad,0x1084,0x1086,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,
-0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,
-0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,
-0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,
-0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x112e,0x1bb5,0x1e86,0x1e86,0x1e86,0x1e86,
-0x1e86,0x1e86,0x1e86,0x1ea6,0x1136,0x120b,0x1212,0x1eae,0x1eae,0x1eae,0x1eae,0x1eae,0x1eae,0x1eae,0x1eae,0x1eae,
-0x1eae,0x1eae,0x1152,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x1e52,0x1e52,0x1e52,0x1e52,0x1e52,
-0x1e52,0x1e52,0x1e52,0x1e52,0x1e52,0x1e52,0x1e52,0x1e52,0x1e52,0x1e52,0x1e52,0x1e52,0x1e52,0x1e52,0x1e52,0x1e52,
-0x1e52,0x1e52,0x1e56,0x1f26,0x1f26,0x1f26,0x1f26,0x1f26,0x1f26,0x1f26,0x1f26,0x1f26,0x1f26,0x1f26,0x1f26,0x1f26,
-0x1f26,0x1266,0x126c,0x1286,0x1289,0x1289,0x1289,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,
-0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x183a,0x183a,0x183a,0x183a,0x183a,
-0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,
-0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,
-0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,
-0x183a,0x183d,0x1310,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,
-0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,
-0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1318,0x1310,0x1310,0x1310,0x1310,0x1310,
-0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,
-0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,
-0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,
-0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1845,0x1845,0x1845,0x1845,0x1845,
-0x1845,0x1845,0x1845,0x1845,0x1845,0x1845,0x1845,0x1845,0x1845,0x1845,0x1845,0x133f,0x1310,0x1310,0x1310,0x1310,
-0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,
-0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,
-0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x131c,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,
-0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,
-0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1324,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,
-0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,
-0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,
-0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,0x1310,
-0x1310,0x1310,0x1310,0x1310,0x1310,0x131c,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,
-0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,
-0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,
-0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1347,
-0x1c6b,0x1c6b,0x1c6b,0x1c6b,0x1c6b,0x1c6b,0x134f,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,
-0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,
-0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,
-0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,
-0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1357,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,
-0x1e9e,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
-0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
-0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
-0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
-0x16c2,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,
-0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,
-0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,
-0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,
-0x16ca,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
-0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
-0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
-0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
-0x16d2,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,
-0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,
-0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,
-0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,
-0x16da,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,
-0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,
-0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,
-0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,0x183a,
-0x183a,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,
-0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,
-0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,
-0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,0x1b83,
-0x1b83,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,
-0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,
-0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,
-0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,
-0x1df2,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,
-0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,
-0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,
-0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,0x1e4a,
-0x1e4a,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,
-0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,
-0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,
-0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,0x1e9e,
-0x1e9e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,
-0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,
-0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,
-0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,0x1f1e,
-0x1f1e,0x510,0x510,0x510,0x2d3,0x2d3,0x2d3,0x2d3,0x2d3,0x2d3,0x2d3,0x2d3,0x2d3,0x2d6,0x2df,0x2d9,
-0x2d9,0x2dc,0x2d3,0x2d3,0x2d3,0x2d3,0x2d3,0x2d3,0x2d3,0x2d3,0x2d3,0x2d3,0x2d3,0x2d3,0x2d3,0x2d3,
-0x2d3,0x2d3,0x2d3,0x2d3,0x7cb,0x7c5,0x7aa,0x78f,0x79b,0x798,0x78f,0x7a7,0x795,0x7a1,0x78f,0x7bc,
-0x7b3,0x7a4,0x7c8,0x79e,0x78c,0x78c,0x78c,0x78c,0x78c,0x78c,0x78c,0x78c,0x78c,0x78c,0x7b0,0x7ad,
-0x7b6,0x7b6,0x7b6,0x7c5,0x78f,0x7d7,0x7d7,0x7d7,0x7d7,0x7d7,0x7d7,0x7d1,0x7d1,0x7d1,0x7d1,0x7d1,
-0x7d1,0x7d1,0x7d1,0x7d1,0x7d1,0x7d1,0x7d1,0x7d1,0x7d1,0x7d1,0x7d1,0x7d1,0x7d1,0x7d1,0x7d1,0x795,
-0x79b,0x7a1,0x7c2,0x789,0x7bf,0x7d4,0x7d4,0x7d4,0x7d4,0x7d4,0x7d4,0x7ce,0x7ce,0x7ce,0x7ce,0x7ce,
-0x7ce,0x7ce,0x7ce,0x7ce,0x7ce,0x7ce,0x7ce,0x7ce,0x7ce,0x7ce,0x7ce,0x7ce,0x7ce,0x7ce,0x7ce,0x795,
-0x7b9,0x792,0x7b6,0x2d3,0,0,0,0,0,0,0,0,0,0,0,0,
+0x12a2,0x12a2,0x12a2,0x12a2,0x12a2,0x12a2,0x12a2,0x12a2,0x12a2,0x12a2,0x12a2,0x12a2,0x12a2,0x12a2,0x12a2,0x12a2,
+0x12a2,0x12a2,0x12a2,0x12a2,0x12a2,0x12a2,0x12a2,0x12a2,0x12a2,0x12a2,0x12a2,0x12a2,0x12a2,0x12a2,0x12a2,0x1222,
+0x12e2,0x12e2,0x12e2,0x12e2,0x12e2,0x12e2,0x12e2,0x12e2,0x12e2,0x12e2,0x12e2,0x12e2,0x12e2,0x12e2,0x12e2,0x12e2,
+0x12e2,0x12e2,0x12e2,0x12e2,0x12e2,0x12e2,0x12e2,0x12e2,0x12e2,0x12e2,0x12e2,0x12e2,0x12e2,0x12e2,0x12e2,0x1262,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0xc27,0xc2a,0xdf5,0x1deb,0x1017,0x745,0x559,0x10b1,0xcf7,0xd76,0x559,0x559,0x1d11,0xf10,0xf18,0x1e33,
+0xc7a,0xc81,0xc89,0x1b95,0x1dcb,0x559,0x1dab,0xfe7,0x1b9d,0xdfd,0xe05,0xe0d,0x103f,0x74d,0x559,0x559,
+0x1ba5,0x1ba5,0x755,0x559,0x1e60,0x10c9,0x1e58,0x10d1,0x1f4c,0x11cb,0x559,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0xe15,0x1fa4,0x12c4,0x1346,0x1347,0x1f6c,0x11f3,0x11fa,0x1201,0x1303,0x1307,0x127b,0x1211,
+0x1c21,0x1c23,0xe76,0xe7d,0x1bad,0x1bb5,0xe1d,0xf30,0x1d09,0xef8,0xf00,0xfdf,0x1d29,0x1d2d,0x1d35,0x105f,
+0xfaf,0x1d8b,0x75d,0x559,0x10b9,0x10c1,0x1d93,0xfb7,0xf91,0xf97,0xf9f,0xfa7,0x559,0x559,0x559,0x559,
+0x1ed0,0x1ec8,0x113b,0x1143,0x1e13,0x1e0b,0x1087,0x559,0x559,0x559,0x559,0x559,0x1dfb,0x1047,0x104f,0x1057,
+0x1dc3,0x1dbb,0xff7,0x1133,0x1d3d,0xf40,0x765,0x559,0x1097,0x109f,0x76d,0x559,0x559,0x559,0x559,0x559,
+0x1f44,0x11ad,0x775,0x559,0x559,0x1e23,0x1e1b,0x108f,0x1283,0x1289,0x1291,0x559,0x559,0x1219,0x121d,0x1225,
+0x1f04,0x1efc,0x1195,0x1ef4,0x1eec,0x1185,0x1df3,0x1037,0x1357,0x135a,0x135a,0x559,0x559,0x559,0x559,0x559,
+0x10e9,0x10ee,0x10f6,0x10fd,0x1125,0x112b,0x559,0x559,0x1169,0x116d,0x1175,0x11bd,0x11c3,0x77d,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x11db,0x136a,0x136f,0x1377,0x559,0x559,0x781,0x1f8c,0x126b,
+0x1a5f,0x1a5f,0x1a5f,0x1a5f,0x1a5f,0x1a5f,0x1a5f,0x1a5f,0x1a5f,0x1a5f,0x1a5f,0x1a5f,0x1a5f,0x1a5f,0x1a5f,0x1a5f,
+0x1a5f,0x1a5f,0x1a5f,0x1a5f,0x1a5f,0x1a5f,0x1a5f,0x1a5f,0x1a5f,0x1a5f,0x1a5f,0x1a64,0xcff,0xd06,0xd06,0xd06,
+0x1a6c,0x1a6c,0x1a6c,0xd0e,0x1e50,0x1e50,0x1e50,0x1e50,0x1e50,0x1e50,0x789,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x78d,0x1fbc,0x1fbc,0x12d4,0x1c2b,0x1c2b,0x1c2b,0x1c2b,0x1c2b,
+0x1c2b,0x1c2b,0x1c2b,0x1c2b,0x1c2b,0x1c2b,0x1c2b,0x1c2b,0x1c2b,0x1c2b,0x1c2b,0x1c2b,0xe85,0xfff,0x1007,0x1fc4,
+0x130f,0x1317,0xf48,0x1de3,0x1ddb,0x1027,0x102f,0x795,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x1f64,0x1f5c,0x11eb,
+0x559,0x559,0x559,0x1d21,0x1d21,0xf20,0x1d19,0xf28,0x559,0x559,0x111d,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x799,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x1d73,0x1d73,0x1d73,0xf6c,0xf71,
+0x7a1,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x1fd4,0x1337,0x133e,0x1fcc,0x1fcc,0x1fcc,0x7a9,
+0x559,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0xb2b,0x184f,0xb33,0x1850,0x1847,0x1858,0x185e,0x1866,
+0xb3b,0x198e,0x198e,0x7b1,0x559,0x559,0x559,0x1362,0x11e3,0x197e,0x197e,0xc32,0xd16,0x559,0x559,0x559,
+0x559,0x1897,0x189e,0xb43,0x18a1,0xb4b,0xb53,0xb5b,0x189b,0xb63,0xb6b,0xb73,0x18a0,0x18a8,0x1897,0x189e,
+0x189a,0x18a1,0x18a9,0x1898,0x189f,0x189b,0xb7a,0x186e,0x1876,0x187d,0x1884,0x1871,0x1879,0x1880,0x1887,0xb82,
+0x188f,0x1e78,0x1e78,0x1e78,0x1e78,0x1e78,0x1e78,0x1e78,0x1e78,0x1e78,0x1e78,0x1e78,0x1e78,0x1e78,0x1e78,0x1e78,
+0x1e78,0x1e68,0x1e6b,0x1e68,0x1e72,0x10d9,0x7b9,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x12f0,0x12f8,0x12fb,0x12fb,0x12fb,0x12fb,0x12fb,
+0x12fb,0x110d,0x1115,0x1fdc,0x134f,0x7c1,0x559,0x559,0x559,0x1f84,0x122d,0x7c9,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x7cd,0x131f,0x1f94,0x1273,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x7d5,0x137f,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x12dc,0x1db3,0x1db3,0x1db3,0x1db3,0x1db3,0x1db3,0xfef,0x559,0x1ec0,0x1eb8,0x10e1,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x7dd,0x1f54,0x11d3,0x559,0x559,0x1235,0x1236,0x7e5,0x559,0x559,0x559,0x559,
+0x559,0xebd,0xec5,0xecd,0xed5,0xedd,0xee5,0xeec,0xef0,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x7e9,0x1067,0x1e03,0x106d,0x1e03,0x1075,0x107a,0x107f,
+0x107f,0x1e88,0x1ea8,0x1eb0,0x1f1c,0x1e90,0x1f74,0x1e98,0x1f24,0x1f7c,0x1f7c,0x119d,0x11a5,0x124d,0x1253,0x125b,
+0x1263,0x1f9c,0x1f9c,0x1f9c,0x1f9c,0x12a7,0x1f9c,0x12ad,0x12b1,0x7f1,0x7f1,0x7f1,0x7f1,0x7f1,0x7f1,0x7f1,
+0x7f1,0x7f1,0x7f1,0x7f1,0x7f1,0x7f1,0x7f1,0x7f1,0x7f1,0x7f1,0x7f1,0x7f1,0x7f1,0x7f1,0x7f1,0x7f1,
+0x7f1,0x7f1,0x7f1,0x7f1,0x7f1,0x7f1,0x7f1,0x7f1,0x7f2,0xb8a,0x18b1,0x18b1,0x18b1,0x7fa,0x7fa,0x7fa,
+0x7fa,0x1986,0x1986,0x1986,0x1986,0x1986,0x1986,0x1986,0x802,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,
+0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,
+0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,
+0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,
+0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0x7fa,0xbdd,0xbe4,0xbec,0xbf4,0x196e,0x196e,0x196e,
+0xbfc,0xc04,0xc07,0x199e,0x1996,0xc3a,0xd56,0xd5a,0xd5e,0x559,0x559,0x559,0x559,0xd66,0x1b19,0xd6e,
+0xf58,0x1822,0xb1d,0xb23,0x101f,0xc0f,0x19e2,0xca0,0x559,0x1837,0x182a,0x182f,0x1976,0xc17,0xc1f,0x114b,
+0x1151,0x1d7b,0xf79,0x1d6b,0xf50,0x1327,0x132f,0x559,0x559,0x1da3,0x1da3,0x1da3,0x1da3,0x1da3,0x1da3,0x1da3,
+0x1da3,0x1da3,0xfc7,0xfcf,0xfd7,0x12e4,0x12e8,0x559,0x559,0x1b21,0xd7e,0x1b29,0x1b29,0xd82,0xe8d,0xe95,
+0xe9d,0x1bf1,0x1bd9,0x1bf9,0x1c01,0x1be9,0xe25,0xe29,0xe30,0xe38,0xe3c,0xe44,0xe4c,0xe4e,0xe4e,0xe4e,
+0xe4e,0x1c62,0x1c6a,0x1c62,0x1c70,0x1c78,0x1c43,0x1c80,0x1c88,0x1c62,0x1c90,0x1c98,0x1c9f,0x1ca7,0x1c4b,0x1c62,
+0x1cac,0x1c53,0x1c5a,0x1cb4,0x1cba,0x1d5c,0x1d63,0x1d55,0x1cc1,0x1cc9,0x1cd1,0x1cd9,0x1dd3,0x1ce1,0x1ce9,0xea5,
+0xead,0x1c33,0x1c33,0x1c33,0xeb5,0x1d83,0x1d83,0xf81,0xf89,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x1e3b,0x1e3b,0x1e3b,0x1e3b,0x1e3b,0x1e3b,0x1e3b,
+0x1e3b,0x1e3b,0x1e3b,0x1e3b,0x1e3b,0x1e3b,0x1e3b,0x1e40,0x1e3b,0x1e3b,0x1e3b,0x10a7,0x10a9,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,
+0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,
+0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,
+0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,
+0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1159,0x1c3b,0x1f14,0x1f14,0x1f14,0x1f14,0x1f14,0x1f14,
+0x1f14,0x1f34,0x1161,0x123e,0x1245,0x1f3c,0x1f3c,0x1f3c,0x1f3c,0x1f3c,0x1f3c,0x1f3c,0x1f3c,0x1f3c,0x1f3c,0x1f3c,
+0x117d,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x1bbd,0x1bbd,0x1bbd,0x1bbd,0x1bbd,0x1bbd,0x1bbd,
+0x1bbd,0x1bbd,0x1bbd,0x1bbd,0x1bbd,0x1bbd,0x1bbd,0x1bbd,0x1bbd,0x1bbd,0x1bbd,0x1bbf,0x1bbd,0x1bc7,0x1bbd,0x1bbd,
+0x1bbd,0x1bbd,0x1bbd,0x1bbd,0x1bca,0x1bbd,0x1bbd,0x1bbd,0x1bbd,0x1bbd,0x1bd1,0x1209,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x1ee0,0x1ee0,0x1ee0,0x1ee0,0x1ee0,0x1ee0,0x1ee0,
+0x1ee0,0x1ee0,0x1ee0,0x1ee0,0x1ee0,0x1ee0,0x1ee0,0x1ee0,0x1ee0,0x1ee0,0x1ee0,0x1ee0,0x1ee0,0x1ee0,0x1ee0,0x1ee0,
+0x1ee4,0x1fb4,0x1fb4,0x1fb4,0x1fb4,0x1fb4,0x1fb4,0x1fb4,0x1fb4,0x1fb4,0x1fb4,0x1fb4,0x1fb4,0x1fb4,0x1fb4,0x1299,
+0x129f,0x12b9,0x12bc,0x12bc,0x12bc,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,
+0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x559,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,
+0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,
+0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,
+0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18bc,
+0x1387,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,
+0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,
+0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x138f,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,
+0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,
+0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,
+0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,
+0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x18c4,0x18c4,0x18c4,0x18c4,0x18c4,0x18c4,0x18c4,
+0x18c4,0x18c4,0x18c4,0x18c4,0x18c4,0x18c4,0x18c4,0x18c4,0x18c4,0x13b6,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,
+0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,
+0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,
+0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1393,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,
+0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,
+0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x139b,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,
+0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,
+0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,
+0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,
+0x1387,0x1387,0x1387,0x1387,0x1387,0x1387,0x1393,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,
+0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,
+0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,
+0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,
+0x13be,0x1cf1,0x1cf1,0x1cf1,0x1cf1,0x1cf1,0x1cf1,0x13c6,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,
+0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,
+0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,
+0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,
+0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x13ce,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,
+0x1f2c,0x1f2c,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,
+0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x13d6,0x1fe4,0x1fe4,0x1fe4,
+0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,
+0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,
+0x1fe4,0x1fe4,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,
+0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,
+0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,
+0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,
+0x1751,0x1741,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,
+0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,
+0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,
+0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,
+0x1759,0x1749,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,
+0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,
+0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,
+0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,0x1751,
+0x1751,0x1751,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,
+0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,
+0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,
+0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,0x1759,
+0x1759,0x1759,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,
+0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,
+0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,
+0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,0x18b9,
+0x18b9,0x18b9,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,
+0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,
+0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,
+0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,0x1c09,
+0x1c09,0x1c09,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,
+0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,
+0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,
+0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,0x1e80,
+0x1e80,0x1e80,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,
+0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,
+0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,
+0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,0x1ed8,
+0x1ed8,0x1ed8,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,
+0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,
+0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,
+0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,0x1f2c,
+0x1f2c,0x1f2c,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,
+0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,
+0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,
+0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,0x1fac,
+0x1fac,0x1fac,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,
+0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,
+0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,
+0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,0x1fe4,
+0x1fe4,0x1fe4,0x538,0x538,0x2e2,0x2e2,0x2e2,0x2e2,0x2e2,0x2e2,0x2e2,0x2e2,0x2e2,0x2e5,0x2ee,0x2e8,
+0x2e8,0x2eb,0x2e2,0x2e2,0x2e2,0x2e2,0x2e2,0x2e2,0x2e2,0x2e2,0x2e2,0x2e2,0x2e2,0x2e2,0x2e2,0x2e2,
+0x2e2,0x2e2,0x2e2,0x2e2,0x7da,0x7d4,0x7b9,0x79e,0x7aa,0x7a7,0x79e,0x7b6,0x7a4,0x7b0,0x79e,0x7cb,
+0x7c2,0x7b3,0x7d7,0x7ad,0x79b,0x79b,0x79b,0x79b,0x79b,0x79b,0x79b,0x79b,0x79b,0x79b,0x7bf,0x7bc,
+0x7c5,0x7c5,0x7c5,0x7d4,0x79e,0x7e6,0x7e6,0x7e6,0x7e6,0x7e6,0x7e6,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,
+0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7a4,
+0x7aa,0x7b0,0x7d1,0x798,0x7ce,0x7e3,0x7e3,0x7e3,0x7e3,0x7e3,0x7e3,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,
+0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7a4,
+0x7c8,0x7a1,0x7c5,0x2e2,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0x2e2,0x2e2,0x2e2,0x2e2,0x2e2,0x2f1,0x2e2,0x2e2,0x2e2,0x2e2,0x2e2,0x2e2,
-0x2e2,0x2e2,0x2e2,0x2e2,0x2e2,0x2e2,0x2e2,0x2e2,0x2e2,0x2e2,0x2e2,0x2e2,0x2e2,0x2e2,0x2e2,0x2e2,
-0x2e2,0x2e2,0x2e2,0x2e2,0x2e5,0x63c,0x7e0,0x7e3,0x642,0x7e3,0x7dd,0x636,0x62d,0x2eb,0x64b,0x2ee,
-0x7e6,0x624,0x639,0x7da,0x63f,0x648,0x62a,0x62a,0x630,0x2e8,0x636,0x633,0x62d,0x62a,0x64b,0x2ee,
-0x627,0x627,0x627,0x63c,0x2f7,0x2f7,0x2f7,0x2f7,0x2f7,0x2f7,0x654,0x2f7,0x2f7,0x2f7,0x2f7,0x2f7,
-0x2f7,0x2f7,0x2f7,0x2f7,0x654,0x2f7,0x2f7,0x2f7,0x2f7,0x2f7,0x2f7,0x645,0x654,0x2f7,0x2f7,0x2f7,
-0x2f7,0x2f7,0x654,0x64e,0x651,0x651,0x2f4,0x2f4,0x2f4,0x2f4,0x64e,0x2f4,0x651,0x651,0x651,0x2f4,
-0x651,0x651,0x2f4,0x2f4,0x64e,0x2f4,0x651,0x651,0x2f4,0x2f4,0x2f4,0x645,0x64e,0x651,0x651,0x2f4,
-0x651,0x2f4,0x64e,0x2f4,0x303,0x65a,0x303,0x2fa,0x303,0x2fa,0x303,0x2fa,0x303,0x2fa,0x303,0x2fa,
-0x303,0x2fa,0x303,0x2fa,0x300,0x657,0x303,0x65a,0x303,0x2fa,0x303,0x2fa,0x303,0x2fa,0x303,0x65a,
-0x303,0x2fa,0x303,0x2fa,0x303,0x2fa,0x303,0x2fa,0x303,0x2fa,0x660,0x657,0x303,0x2fa,0x303,0x65a,
-0x303,0x2fa,0x303,0x2fa,0x303,0x657,0x663,0x65d,0x303,0x2fa,0x303,0x2fa,0x657,0x303,0x2fa,0x303,
-0x2fa,0x303,0x2fa,0x663,0x65d,0x660,0x657,0x303,0x65a,0x303,0x2fa,0x303,0x65a,0x666,0x660,0x657,
-0x303,0x65a,0x303,0x2fa,0x303,0x2fa,0x660,0x657,0x303,0x2fa,0x303,0x2fa,0x303,0x2fa,0x303,0x2fa,
-0x303,0x2fa,0x303,0x2fa,0x303,0x2fa,0x303,0x2fa,0x303,0x2fa,0x660,0x657,0x303,0x2fa,0x303,0x65a,
-0x303,0x2fa,0x303,0x2fa,0x303,0x2fa,0x303,0x2fa,0x303,0x2fa,0x303,0x2fa,0x303,0x303,0x2fa,0x303,
-0x2fa,0x303,0x2fa,0x2fd,0x306,0x312,0x312,0x306,0x312,0x306,0x312,0x312,0x306,0x312,0x312,0x312,
-0x306,0x306,0x312,0x312,0x312,0x312,0x306,0x312,0x312,0x306,0x312,0x312,0x312,0x306,0x306,0x306,
-0x312,0x312,0x306,0x312,0x315,0x309,0x312,0x306,0x312,0x306,0x312,0x312,0x306,0x312,0x306,0x306,
-0x312,0x306,0x312,0x315,0x309,0x312,0x312,0x312,0x306,0x312,0x306,0x312,0x312,0x306,0x306,0x30f,
-0x312,0x306,0x306,0x306,0x30f,0x30f,0x30f,0x30f,0x318,0x318,0x30c,0x318,0x318,0x30c,0x318,0x318,
-0x30c,0x315,0x669,0x315,0x669,0x315,0x669,0x315,0x669,0x315,0x669,0x315,0x669,0x315,0x669,0x315,
-0x669,0x306,0x315,0x309,0x315,0x309,0x315,0x309,0x312,0x306,0x315,0x309,0x315,0x309,0x315,0x309,
-0x315,0x309,0x315,0x309,0x309,0x318,0x318,0x30c,0x315,0x309,0x9bd,0x9bd,0x9c0,0x9ba,0x315,0x309,
-0x315,0x309,0x315,0x309,0x315,0x309,0x315,0x309,0x315,0x309,0x315,0x309,0x315,0x309,0x315,0x309,
-0x315,0x309,0x315,0x309,0x315,0x309,0x315,0x309,0x9c0,0x9ba,0x9c0,0x9ba,0x9bd,0x9b7,0x9c0,0x9ba,
-0xb79,0xc72,0x9bd,0x9b7,0x9bd,0x9b7,0x9c0,0x9ba,0x9c0,0x9ba,0x9c0,0x9ba,0x9c0,0x9ba,0x9c0,0x9ba,
-0x9c0,0x9ba,0x9c0,0x9ba,0xc72,0xc72,0xc72,0xd6b,0xd6b,0xd6b,0xd6e,0xd6e,0xd6b,0xd6e,0xd6e,0xd6b,
-0xd6b,0xd6e,0xeac,0xeaf,0xeaf,0xeaf,0xeaf,0xeac,0xeaf,0xeac,0xeaf,0xeac,0xeaf,0xeac,0xeaf,0xeac,
-0x31b,0x66c,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,
-0x31b,0x66c,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,
-0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,
-0x31e,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,0x31b,
-0x31b,0x31b,0x31b,0x31b,0x31b,0x9c3,0x9c3,0x9c3,0x9c3,0x9c3,0xc75,0xc75,0x333,0x333,0x333,0x333,
-0x333,0x333,0x333,0x333,0x333,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x327,0x327,0x324,0x324,
-0x672,0x324,0x32a,0x675,0x32d,0x675,0x675,0x675,0x32d,0x675,0x32a,0x32a,0x678,0x330,0x324,0x324,
-0x324,0x324,0x324,0x324,0x66f,0x66f,0x66f,0x66f,0x321,0x66f,0x324,0xaef,0x333,0x333,0x333,0x333,
-0x333,0x324,0x324,0x324,0x324,0x324,0x9cc,0x9cc,0x9c9,0x9c6,0x9c9,0xc78,0xc78,0xc78,0xc78,0xc78,
-0xc78,0xc78,0xc78,0xc78,0xc78,0xc78,0xc78,0xc78,0xc78,0xc78,0xc78,0xc78,0x67b,0x67b,0x67b,0x67b,
-0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,
-0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,
-0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,
-0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67b,0x67e,0x67e,0x91e,0x67e,
-0x67e,0x921,0xaf2,0xaf2,0xaf2,0xaf2,0xaf2,0xaf2,0xaf2,0xaf2,0xaf2,0xc2a,0xd35,0xd35,0xd35,0xd35,
-0xd35,0xd35,0xd35,0xd35,0xe70,0xe70,0xe70,0xe70,0xe73,0xd38,0xd38,0xd38,0x681,0x681,0xaf5,0xc6f,
-0xc6f,0xc6f,0xc6f,0xc6f,0xc6f,0xc6f,0xc6f,0xc6f,0xc6f,0xc6f,0xc6f,0xc6f,0xf5a,0xf57,0xf5a,0xf57,
-0x33f,0x348,0xf5a,0xf57,9,9,0x34e,0xeb2,0xeb2,0xeb2,0x336,0x149d,9,9,9,9,
-0x34b,0x339,0x35d,0x33c,0x35d,0x35d,0x35d,9,0x35d,9,0x35d,0x35d,0x354,0x687,0x687,0x687,
-0x687,0x687,0x687,0x687,0x687,0x687,0x687,0x687,0x687,0x687,0x687,0x687,0x687,0x687,9,0x687,
-0x687,0x687,0x687,0x687,0x687,0x687,0x35d,0x35d,0x354,0x354,0x354,0x354,0x354,0x684,0x684,0x684,
-0x684,0x684,0x684,0x684,0x684,0x684,0x684,0x684,0x684,0x684,0x684,0x684,0x684,0x684,0x351,0x684,
-0x684,0x684,0x684,0x684,0x684,0x684,0x354,0x354,0x354,0x354,0x354,0xf5a,0x360,0x360,0x363,0x35d,
-0x35d,0x360,0x357,0x9cf,0xb82,0xb7f,0x35a,0x9cf,0x35a,0x9cf,0x35a,0x9cf,0x35a,0x9cf,0x345,0x342,
-0x345,0x342,0x345,0x342,0x345,0x342,0x345,0x342,0x345,0x342,0x345,0x342,0x360,0x360,0x357,0x351,
-0xb31,0xb2e,0xb7c,0xc7e,0xc7b,0xc81,0xc7e,0xc7b,0xd71,0xd74,0xd74,0xd74,0x9de,0x693,0x36f,0x372,
-0x36f,0x36f,0x36f,0x372,0x36f,0x36f,0x36f,0x36f,0x372,0x9de,0x372,0x36f,0x690,0x690,0x690,0x690,
-0x690,0x690,0x690,0x690,0x690,0x693,0x690,0x690,0x690,0x690,0x690,0x690,0x690,0x690,0x690,0x690,
-0x690,0x690,0x690,0x690,0x690,0x690,0x690,0x690,0x690,0x690,0x690,0x690,0x68a,0x68a,0x68a,0x68a,
-0x68a,0x68a,0x68a,0x68a,0x68a,0x68d,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,
-0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x9d8,0x68d,0x369,0x36c,0x369,0x369,0x369,0x36c,
-0x369,0x369,0x369,0x369,0x36c,0x9d8,0x36c,0x369,0x36f,0x369,0x36f,0x369,0x36f,0x369,0x36f,0x369,
-0x36f,0x369,0x36f,0x369,0x36f,0x369,0x36f,0x369,0x36f,0x369,0x36f,0x369,0x36f,0x369,0x372,0x36c,
-0x36f,0x369,0x36f,0x369,0x36f,0x369,0x36f,0x369,0x36f,0x369,0x366,0x92a,0x92d,0x90f,0x90f,0x1101,
-0x9d2,0x9d2,0xb88,0xb85,0x9db,0x9d5,0x9db,0x9d5,0x36f,0x369,0x36f,0x369,0x36f,0x369,0x36f,0x369,
-0x36f,0x369,0x36f,0x369,0x36f,0x369,0x36f,0x369,0x36f,0x369,0x36f,0x369,0x36f,0x369,0x36f,0x369,
-0x36f,0x369,0x36f,0x369,0x36f,0x369,0x36f,0x369,0x36f,0x369,0x36f,0x369,0x36f,0x369,0x36f,0x369,
-0x36f,0x369,0x36f,0x369,0x36f,0x369,0x36f,0x369,0x36f,0x372,0x36c,0x36f,0x369,0xb88,0xb85,0x36f,
-0x369,0xb88,0xb85,0x36f,0x369,0xb88,0xb85,0xeb5,0x372,0x36c,0x372,0x36c,0x36f,0x369,0x372,0x36c,
-0x36f,0x369,0x372,0x36c,0x372,0x36c,0x372,0x36c,0x36f,0x369,0x372,0x36c,0x372,0x36c,0x372,0x36c,
-0x36f,0x369,0x372,0x36c,0x9de,0x9d8,0x372,0x36c,0x372,0x36c,0x372,0x36c,0x372,0x36c,0xd7a,0xd77,
-0x372,0x36c,0xeb8,0xeb5,0xeb8,0xeb5,0xeb8,0xeb5,0xbee,0xbeb,0xbee,0xbeb,0xbee,0xbeb,0xbee,0xbeb,
-0xbee,0xbeb,0xbee,0xbeb,0xbee,0xbeb,0xbee,0xbeb,0xee5,0xee2,0xee5,0xee2,0xfd5,0xfd2,0xfd5,0xfd2,
-0xfd5,0xfd2,0xfd5,0xfd2,0xfd5,0xfd2,0xfd5,0xfd2,0xfd5,0xfd2,0xfd5,0xfd2,0x113a,0x1137,0x1317,0x1314,
-0x14d3,0x14d0,0x14d3,0x14d0,0x14d3,0x14d0,0x14d3,0x14d0,0xc,0x384,0x384,0x384,0x384,0x384,0x384,0x384,
-0x384,0x384,0x384,0x384,0x384,0x384,0x384,0x384,0x384,0x384,0x384,0x384,0x384,0x384,0x384,0x384,
-0x384,0x384,0x384,0xc,0xc,0x387,0x375,0x375,0x375,0x37b,0x375,0x378,0x18d8,0x37e,0x37e,0x37e,
-0x37e,0x37e,0x37e,0x37e,0x37e,0x37e,0x37e,0x37e,0x37e,0x37e,0x37e,0x37e,0x37e,0x37e,0x37e,0x37e,
-0x37e,0x37e,0x37e,0x37e,0x37e,0x37e,0x37e,0x37e,0x37e,0x37e,0x37e,0x37e,0x37e,0x37e,0x37e,0x381,
-0x18d8,0x38a,0x9e1,0xc,0xc,0x14a0,0x14a0,0x13bc,0xf,0x951,0x951,0x951,0x951,0x951,0x951,0x951,
-0x951,0x951,0x951,0x951,0x951,0x951,0x951,0x951,0x951,0x951,0xd7d,0x951,0x951,0x951,0x951,0x951,
-0x951,0x951,0x951,0x951,0x951,0x951,0x951,0x951,0x38d,0x38d,0x38d,0x38d,0x38d,0x38d,0x38d,0x38d,
-0x38d,0x38d,0xebb,0x38d,0x38d,0x38d,0x399,0x38d,0x390,0x38d,0x38d,0x39c,0x954,0xd80,0xd83,0xd80,
-0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,
-0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,
-0x39f,0x39f,0x39f,0xf,0xf,0xf,0xf,0x18db,0x39f,0x39f,0x39f,0x396,0x393,0xf,0xf,0xf,
-0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xc96,0xc96,0xc96,0xc96,0x13bf,0x14a3,0xf63,0xf63,
-0xf63,0xf60,0xf60,0xd89,0x897,0xc90,0xc8d,0xc8d,0xc84,0xc84,0xc84,0xc84,0xc84,0xc84,0xf5d,0xf5d,
-0xf5d,0xf5d,0xf5d,0x894,0x149a,0x1aeb,0xd8c,0x89a,0x12de,0x3ba,0x3bd,0x3bd,0x3bd,0x3bd,0x3bd,0x3ba,
-0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,
-0x3ba,0x3ba,0x3ba,0xf66,0xf66,0xf66,0xf66,0xf66,0x89d,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,
-0x3ba,0x3ba,0x3ba,0x915,0x915,0x915,0x915,0x915,0x915,0x915,0x915,0xb28,0xb28,0xb28,0xc84,0xc8a,
-0xc87,0xd86,0xd86,0xd86,0xd86,0xd86,0xd86,0x12db,0x930,0x930,0x930,0x930,0x930,0x930,0x930,0x930,
-0x930,0x930,0x3b4,0x3b1,0x3ae,0x3ab,0xb8b,0xb8b,0x912,0x3ba,0x3ba,0x3c6,0x3ba,0x3c0,0x3c0,0x3c0,
-0x3c0,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,
-0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,
-0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,
-0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x9e7,0x9e7,0x3ba,0x3ba,
-0x3ba,0x3ba,0x3ba,0x9e7,0x3bd,0x3ba,0x3bd,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,0x3ba,
-0x3ba,0x3ba,0x3ba,0x9e7,0x3ba,0x3ba,0x3ba,0x3bd,0x933,0x3ba,0x3a5,0x3a5,0x3a5,0x3a5,0x3a5,0x3a5,
-0x3a5,0x3a2,0x3ab,0x3a8,0x3a8,0x3a5,0x3a5,0x3a5,0x3a5,0x3c3,0x3c3,0x3a5,0x3a5,0x3ab,0x3a8,0x3a8,
-0x3a8,0x3a5,0xc93,0xc93,0x3b7,0x3b7,0x3b7,0x3b7,0x3b7,0x3b7,0x3b7,0x3b7,0x3b7,0x3b7,0x9e7,0x9e7,
-0x9e7,0x9e4,0x9e4,0xc93,0x9fc,0x9fc,0x9fc,0x9f6,0x9f6,0x9f6,0x9f6,0x9f6,0x9f6,0x9f6,0x9f6,0x9f3,
-0x9f6,0x9f3,0x12,0x9ff,0x9f9,0x9ea,0x9f9,0x9f9,0x9f9,0x9f9,0x9f9,0x9f9,0x9f9,0x9f9,0x9f9,0x9f9,
-0x9f9,0x9f9,0x9f9,0x9f9,0x9f9,0x9f9,0x9f9,0x9f9,0x9f9,0x9f9,0x9f9,0x9f9,0x9f9,0x9f9,0x9f9,0x9f9,
-0x9f9,0xc99,0xc99,0xc99,0x9f0,0x9f0,0x9f0,0x9f0,0x9f0,0x9f0,0x9f0,0x9f0,0x9f0,0x9f0,0x9f0,0x9f0,
-0x9f0,0x9f0,0x9f0,0x9f0,0x9ed,0x9ed,0x9ed,0x9ed,0x9ed,0x9ed,0x9ed,0x9ed,0x9ed,0x9ed,0x9ed,0x12,
-0x12,0xc99,0xc99,0xc99,0xde9,0xde9,0xde9,0xde9,0xde9,0xde9,0xde9,0xde9,0xde9,0xde9,0xde9,0xde9,
-0xde9,0xde9,0xde9,0xde9,0xde9,0xde9,0xde9,0xde9,0xde9,0xde9,0xde9,0xde9,0xde9,0xde9,0xde9,0xde9,
-0xde9,0xde9,0xfe7,0xfe7,0xfe7,0xfe7,0xfe7,0xfe7,0xfe7,0xfe7,0xfe7,0xfe7,0xfe7,0xfe7,0xfe7,0xfe7,
-0xfe7,0xfe7,0xfe7,0xfe7,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,
-0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,
-0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa02,0xa02,0xa02,0xa02,0xa02,0xa02,
-0xa02,0xa02,0xa02,0xa02,0xa02,0xb8e,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
-0x15,0x15,0x15,0x15,0xefd,0xefd,0xefd,0xefd,0xefd,0xefd,0xefd,0xefd,0xefd,0xefd,0xf00,0xf00,
-0xf00,0xf00,0xf00,0xf00,0xf00,0xf00,0xf00,0xf00,0xf00,0xf00,0xf00,0xf00,0xf00,0xf00,0xf00,0xf00,
-0xf00,0xf00,0xf00,0xf00,0xf00,0xf00,0xf00,0xf00,0xf00,0xf00,0xf00,0xf00,0xf00,0xf00,0xf00,0xef4,
-0xef4,0xef4,0xef4,0xef4,0xef4,0xef4,0xef4,0xef4,0xf03,0xf03,0xef7,0xef7,0xefa,0xf09,0xf06,0x102,
-0x102,0x18ff,0x1902,0x1902,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0xb01,0xb01,0xb04,0xb04,0xb01,0xb01,0xb01,0xb01,0xb01,0xb01,0xb01,0xb01,
-0x6f,0x6f,0x6f,0x6f,0x1e3,0x1e3,0x1e3,0x1e3,0x1e3,0x1e3,0x1e3,0x1605,0x1605,0x1605,0x1605,0x1605,
-0x1605,0x1605,0x1605,0x1605,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0x1ef,0x1ef,0x1ef,0x1ef,0x1ef,0x1ef,0x1ef,0x1ef,0x1ef,0x163e,0x163e,0x163e,
-0x163e,0x163e,0x163e,0x163e,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0x122d,0x122d,0x122d,0x122d,0x122d,0x122d,0x122d,0x122d,0x122d,0x16b,0x16b,0x16b,
+0,0,0,0,0x2f1,0x2f1,0x2f1,0x2f1,0x2f1,0x300,0x2f1,0x2f1,0x2f1,0x2f1,0x2f1,0x2f1,
+0x2f1,0x2f1,0x2f1,0x2f1,0x2f1,0x2f1,0x2f1,0x2f1,0x2f1,0x2f1,0x2f1,0x2f1,0x2f1,0x2f1,0x2f1,0x2f1,
+0x2f1,0x2f1,0x2f1,0x2f1,0x2f4,0x64b,0x7ef,0x7f2,0x651,0x7f2,0x7ec,0x645,0x63c,0x2fa,0x65a,0x2fd,
+0x7f5,0x633,0x648,0x7e9,0x64e,0x657,0x639,0x639,0x63f,0x2f7,0x645,0x642,0x63c,0x639,0x65a,0x2fd,
+0x636,0x636,0x636,0x64b,0x306,0x306,0x306,0x306,0x306,0x306,0x663,0x306,0x306,0x306,0x306,0x306,
+0x306,0x306,0x306,0x306,0x663,0x306,0x306,0x306,0x306,0x306,0x306,0x654,0x663,0x306,0x306,0x306,
+0x306,0x306,0x663,0x65d,0x660,0x660,0x303,0x303,0x303,0x303,0x65d,0x303,0x660,0x660,0x660,0x303,
+0x660,0x660,0x303,0x303,0x65d,0x303,0x660,0x660,0x303,0x303,0x303,0x654,0x65d,0x660,0x660,0x303,
+0x660,0x303,0x65d,0x303,0x312,0x669,0x312,0x309,0x312,0x309,0x312,0x309,0x312,0x309,0x312,0x309,
+0x312,0x309,0x312,0x309,0x30f,0x666,0x312,0x669,0x312,0x309,0x312,0x309,0x312,0x309,0x312,0x669,
+0x312,0x309,0x312,0x309,0x312,0x309,0x312,0x309,0x312,0x309,0x66f,0x666,0x312,0x309,0x312,0x669,
+0x312,0x309,0x312,0x309,0x312,0x666,0x672,0x66c,0x312,0x309,0x312,0x309,0x666,0x312,0x309,0x312,
+0x309,0x312,0x309,0x672,0x66c,0x66f,0x666,0x312,0x669,0x312,0x309,0x312,0x669,0x675,0x66f,0x666,
+0x312,0x669,0x312,0x309,0x312,0x309,0x66f,0x666,0x312,0x309,0x312,0x309,0x312,0x309,0x312,0x309,
+0x312,0x309,0x312,0x309,0x312,0x309,0x312,0x309,0x312,0x309,0x66f,0x666,0x312,0x309,0x312,0x669,
+0x312,0x309,0x312,0x309,0x312,0x309,0x312,0x309,0x312,0x309,0x312,0x309,0x312,0x312,0x309,0x312,
+0x309,0x312,0x309,0x30c,0x315,0x321,0x321,0x315,0x321,0x315,0x321,0x321,0x315,0x321,0x321,0x321,
+0x315,0x315,0x321,0x321,0x321,0x321,0x315,0x321,0x321,0x315,0x321,0x321,0x321,0x315,0x315,0x315,
+0x321,0x321,0x315,0x321,0x324,0x318,0x321,0x315,0x321,0x315,0x321,0x321,0x315,0x321,0x315,0x315,
+0x321,0x315,0x321,0x324,0x318,0x321,0x321,0x321,0x315,0x321,0x315,0x321,0x321,0x315,0x315,0x31e,
+0x321,0x315,0x315,0x315,0x31e,0x31e,0x31e,0x31e,0x327,0x327,0x31b,0x327,0x327,0x31b,0x327,0x327,
+0x31b,0x324,0x678,0x324,0x678,0x324,0x678,0x324,0x678,0x324,0x678,0x324,0x678,0x324,0x678,0x324,
+0x678,0x315,0x324,0x318,0x324,0x318,0x324,0x318,0x321,0x315,0x324,0x318,0x324,0x318,0x324,0x318,
+0x324,0x318,0x324,0x318,0x318,0x327,0x327,0x31b,0x324,0x318,0x9cf,0x9cf,0x9d2,0x9cc,0x324,0x318,
+0x324,0x318,0x324,0x318,0x324,0x318,0x324,0x318,0x324,0x318,0x324,0x318,0x324,0x318,0x324,0x318,
+0x324,0x318,0x324,0x318,0x324,0x318,0x324,0x318,0x9d2,0x9cc,0x9d2,0x9cc,0x9cf,0x9c9,0x9d2,0x9cc,
+0xb8b,0xc84,0x9cf,0x9c9,0x9cf,0x9c9,0x9d2,0x9cc,0x9d2,0x9cc,0x9d2,0x9cc,0x9d2,0x9cc,0x9d2,0x9cc,
+0x9d2,0x9cc,0x9d2,0x9cc,0xc84,0xc84,0xc84,0xd7d,0xd7d,0xd7d,0xd80,0xd80,0xd7d,0xd80,0xd80,0xd7d,
+0xd7d,0xd80,0xebe,0xec1,0xec1,0xec1,0xec1,0xebe,0xec1,0xebe,0xec1,0xebe,0xec1,0xebe,0xec1,0xebe,
+0x32a,0x67b,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,
+0x32a,0x67b,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,
+0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,
+0x32d,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,0x32a,
+0x32a,0x32a,0x32a,0x32a,0x32a,0x9d5,0x9d5,0x9d5,0x9d5,0x9d5,0xc87,0xc87,0x342,0x342,0x342,0x342,
+0x342,0x342,0x342,0x342,0x342,0x339,0x339,0x339,0x339,0x339,0x339,0x339,0x336,0x336,0x333,0x333,
+0x681,0x333,0x339,0x684,0x33c,0x684,0x684,0x684,0x33c,0x684,0x339,0x339,0x687,0x33f,0x333,0x333,
+0x333,0x333,0x333,0x333,0x67e,0x67e,0x67e,0x67e,0x330,0x67e,0x333,0xb01,0x342,0x342,0x342,0x342,
+0x342,0x333,0x333,0x333,0x333,0x333,0x9de,0x9de,0x9db,0x9d8,0x9db,0xc8a,0xc8a,0xc8a,0xc8a,0xc8a,
+0xc8a,0xc8a,0xc8a,0xc8a,0xc8a,0xc8a,0xc8a,0xc8a,0xc8a,0xc8a,0xc8a,0xc8a,0x68a,0x68a,0x68a,0x68a,
+0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,
+0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,
+0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,
+0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68a,0x68d,0x68d,0x92d,0x68d,
+0x68d,0x930,0xb04,0xb04,0xb04,0xb04,0xb04,0xb04,0xb04,0xb04,0xb04,0xc3c,0xd47,0xd47,0xd47,0xd47,
+0xd47,0xd47,0xd47,0xd47,0xe82,0xe82,0xe82,0xe82,0xe85,0xd4a,0xd4a,0xd4a,0x690,0x690,0xb07,0xc81,
+0xc81,0xc81,0xc81,0xc81,0xc81,0xc81,0xc81,0xc81,0xc81,0xc81,0xc81,0xc81,0xf6c,0xf69,0xf6c,0xf69,
+0x34e,0x357,0xf6c,0xf69,9,9,0x35d,0xec4,0xec4,0xec4,0x345,0x14af,9,9,9,9,
+0x35a,0x348,0x36c,0x34b,0x36c,0x36c,0x36c,9,0x36c,9,0x36c,0x36c,0x363,0x696,0x696,0x696,
+0x696,0x696,0x696,0x696,0x696,0x696,0x696,0x696,0x696,0x696,0x696,0x696,0x696,0x696,9,0x696,
+0x696,0x696,0x696,0x696,0x696,0x696,0x36c,0x36c,0x363,0x363,0x363,0x363,0x363,0x693,0x693,0x693,
+0x693,0x693,0x693,0x693,0x693,0x693,0x693,0x693,0x693,0x693,0x693,0x693,0x693,0x693,0x360,0x693,
+0x693,0x693,0x693,0x693,0x693,0x693,0x363,0x363,0x363,0x363,0x363,0xf6c,0x36f,0x36f,0x372,0x36c,
+0x36c,0x36f,0x366,0x9e1,0xb94,0xb91,0x369,0x9e1,0x369,0x9e1,0x369,0x9e1,0x369,0x9e1,0x354,0x351,
+0x354,0x351,0x354,0x351,0x354,0x351,0x354,0x351,0x354,0x351,0x354,0x351,0x36f,0x36f,0x366,0x360,
+0xb43,0xb40,0xb8e,0xc90,0xc8d,0xc93,0xc90,0xc8d,0xd83,0xd86,0xd86,0xd86,0x9f0,0x6a2,0x37e,0x381,
+0x37e,0x37e,0x37e,0x381,0x37e,0x37e,0x37e,0x37e,0x381,0x9f0,0x381,0x37e,0x69f,0x69f,0x69f,0x69f,
+0x69f,0x69f,0x69f,0x69f,0x69f,0x6a2,0x69f,0x69f,0x69f,0x69f,0x69f,0x69f,0x69f,0x69f,0x69f,0x69f,
+0x69f,0x69f,0x69f,0x69f,0x69f,0x69f,0x69f,0x69f,0x69f,0x69f,0x69f,0x69f,0x699,0x699,0x699,0x699,
+0x699,0x699,0x699,0x699,0x699,0x69c,0x699,0x699,0x699,0x699,0x699,0x699,0x699,0x699,0x699,0x699,
+0x699,0x699,0x699,0x699,0x699,0x699,0x699,0x699,0x9ea,0x69c,0x378,0x37b,0x378,0x378,0x378,0x37b,
+0x378,0x378,0x378,0x378,0x37b,0x9ea,0x37b,0x378,0x37e,0x378,0x37e,0x378,0x37e,0x378,0x37e,0x378,
+0x37e,0x378,0x37e,0x378,0x37e,0x378,0x37e,0x378,0x37e,0x378,0x37e,0x378,0x37e,0x378,0x381,0x37b,
+0x37e,0x378,0x37e,0x378,0x37e,0x378,0x37e,0x378,0x37e,0x378,0x375,0x939,0x93c,0x91e,0x91e,0x1116,
+0x9e4,0x9e4,0xb9a,0xb97,0x9ed,0x9e7,0x9ed,0x9e7,0x37e,0x378,0x37e,0x378,0x37e,0x378,0x37e,0x378,
+0x37e,0x378,0x37e,0x378,0x37e,0x378,0x37e,0x378,0x37e,0x378,0x37e,0x378,0x37e,0x378,0x37e,0x378,
+0x37e,0x378,0x37e,0x378,0x37e,0x378,0x37e,0x378,0x37e,0x378,0x37e,0x378,0x37e,0x378,0x37e,0x378,
+0x37e,0x378,0x37e,0x378,0x37e,0x378,0x37e,0x378,0x37e,0x381,0x37b,0x37e,0x378,0xb9a,0xb97,0x37e,
+0x378,0xb9a,0xb97,0x37e,0x378,0xb9a,0xb97,0xec7,0x381,0x37b,0x381,0x37b,0x37e,0x378,0x381,0x37b,
+0x37e,0x378,0x381,0x37b,0x381,0x37b,0x381,0x37b,0x37e,0x378,0x381,0x37b,0x381,0x37b,0x381,0x37b,
+0x37e,0x378,0x381,0x37b,0x9f0,0x9ea,0x381,0x37b,0x381,0x37b,0x381,0x37b,0x381,0x37b,0xd8c,0xd89,
+0x381,0x37b,0xeca,0xec7,0xeca,0xec7,0xeca,0xec7,0xc00,0xbfd,0xc00,0xbfd,0xc00,0xbfd,0xc00,0xbfd,
+0xc00,0xbfd,0xc00,0xbfd,0xc00,0xbfd,0xc00,0xbfd,0xef7,0xef4,0xef7,0xef4,0xfe7,0xfe4,0xfe7,0xfe4,
+0xfe7,0xfe4,0xfe7,0xfe4,0xfe7,0xfe4,0xfe7,0xfe4,0xfe7,0xfe4,0xfe7,0xfe4,0x114f,0x114c,0x1329,0x1326,
+0x14e5,0x14e2,0x14e5,0x14e2,0x14e5,0x14e2,0x14e5,0x14e2,0xc,0x393,0x393,0x393,0x393,0x393,0x393,0x393,
+0x393,0x393,0x393,0x393,0x393,0x393,0x393,0x393,0x393,0x393,0x393,0x393,0x393,0x393,0x393,0x393,
+0x393,0x393,0x393,0xc,0xc,0x396,0x384,0x384,0x384,0x38a,0x384,0x387,0x18ea,0x38d,0x38d,0x38d,
+0x38d,0x38d,0x38d,0x38d,0x38d,0x38d,0x38d,0x38d,0x38d,0x38d,0x38d,0x38d,0x38d,0x38d,0x38d,0x38d,
+0x38d,0x38d,0x38d,0x38d,0x38d,0x38d,0x38d,0x38d,0x38d,0x38d,0x38d,0x38d,0x38d,0x38d,0x38d,0x390,
+0x18ea,0x399,0x9f3,0xc,0xc,0x14b2,0x14b2,0x13ce,0xf,0x960,0x960,0x960,0x960,0x960,0x960,0x960,
+0x960,0x960,0x960,0x960,0x960,0x960,0x960,0x960,0x960,0x960,0xd8f,0x960,0x960,0x960,0x960,0x960,
+0x960,0x960,0x960,0x960,0x960,0x960,0x960,0x960,0x39c,0x39c,0x39c,0x39c,0x39c,0x39c,0x39c,0x39c,
+0x39c,0x39c,0xecd,0x39c,0x39c,0x39c,0x3a8,0x39c,0x39f,0x39c,0x39c,0x3ab,0x963,0xd92,0xd95,0xd92,
+0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0x3ae,0x3ae,0x3ae,0x3ae,0x3ae,0x3ae,0x3ae,0x3ae,
+0x3ae,0x3ae,0x3ae,0x3ae,0x3ae,0x3ae,0x3ae,0x3ae,0x3ae,0x3ae,0x3ae,0x3ae,0x3ae,0x3ae,0x3ae,0x3ae,
+0x3ae,0x3ae,0x3ae,0xf,0xf,0xf,0xf,0x18ed,0x3ae,0x3ae,0x3ae,0x3a5,0x3a2,0xf,0xf,0xf,
+0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xca8,0xca8,0xca8,0xca8,0x13d1,0x14b5,0xf75,0xf75,
+0xf75,0xf72,0xf72,0xd9b,0x8a6,0xca2,0xc9f,0xc9f,0xc96,0xc96,0xc96,0xc96,0xc96,0xc96,0xf6f,0xf6f,
+0xf6f,0xf6f,0xf6f,0x8a3,0x14ac,0x1afd,0xd9e,0x8a9,0x12f0,0x3c9,0x3cc,0x3cc,0x3cc,0x3cc,0x3cc,0x3c9,
+0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,
+0x3c9,0x3c9,0x3c9,0xf78,0xf78,0xf78,0xf78,0xf78,0x8ac,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,
+0x3c9,0x3c9,0x3c9,0x924,0x924,0x924,0x924,0x924,0x924,0x924,0x924,0xb3a,0xb3a,0xb3a,0xc96,0xc9c,
+0xc99,0xd98,0xd98,0xd98,0xd98,0xd98,0xd98,0x12ed,0x93f,0x93f,0x93f,0x93f,0x93f,0x93f,0x93f,0x93f,
+0x93f,0x93f,0x3c3,0x3c0,0x3bd,0x3ba,0xb9d,0xb9d,0x921,0x3c9,0x3c9,0x3d5,0x3c9,0x3cf,0x3cf,0x3cf,
+0x3cf,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,
+0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,
+0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,
+0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x9f9,0x9f9,0x3c9,0x3c9,
+0x3c9,0x3c9,0x3c9,0x9f9,0x3cc,0x3c9,0x3cc,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,0x3c9,
+0x3c9,0x3c9,0x3c9,0x9f9,0x3c9,0x3c9,0x3c9,0x3cc,0x942,0x3c9,0x3b4,0x3b4,0x3b4,0x3b4,0x3b4,0x3b4,
+0x3b4,0x3b1,0x3ba,0x3b7,0x3b7,0x3b4,0x3b4,0x3b4,0x3b4,0x3d2,0x3d2,0x3b4,0x3b4,0x3ba,0x3b7,0x3b7,
+0x3b7,0x3b4,0xca5,0xca5,0x3c6,0x3c6,0x3c6,0x3c6,0x3c6,0x3c6,0x3c6,0x3c6,0x3c6,0x3c6,0x9f9,0x9f9,
+0x9f9,0x9f6,0x9f6,0xca5,0xa0e,0xa0e,0xa0e,0xa08,0xa08,0xa08,0xa08,0xa08,0xa08,0xa08,0xa08,0xa05,
+0xa08,0xa05,0x12,0xa11,0xa0b,0x9fc,0xa0b,0xa0b,0xa0b,0xa0b,0xa0b,0xa0b,0xa0b,0xa0b,0xa0b,0xa0b,
+0xa0b,0xa0b,0xa0b,0xa0b,0xa0b,0xa0b,0xa0b,0xa0b,0xa0b,0xa0b,0xa0b,0xa0b,0xa0b,0xa0b,0xa0b,0xa0b,
+0xa0b,0xcab,0xcab,0xcab,0xa02,0xa02,0xa02,0xa02,0xa02,0xa02,0xa02,0xa02,0xa02,0xa02,0xa02,0xa02,
+0xa02,0xa02,0xa02,0xa02,0x9ff,0x9ff,0x9ff,0x9ff,0x9ff,0x9ff,0x9ff,0x9ff,0x9ff,0x9ff,0x9ff,0x12,
+0x12,0xcab,0xcab,0xcab,0xdfb,0xdfb,0xdfb,0xdfb,0xdfb,0xdfb,0xdfb,0xdfb,0xdfb,0xdfb,0xdfb,0xdfb,
+0xdfb,0xdfb,0xdfb,0xdfb,0xdfb,0xdfb,0xdfb,0xdfb,0xdfb,0xdfb,0xdfb,0xdfb,0xdfb,0xdfb,0xdfb,0xdfb,
+0xdfb,0xdfb,0xff9,0xff9,0xff9,0xff9,0xff9,0xff9,0xff9,0xff9,0xff9,0xff9,0xff9,0xff9,0xff9,0xff9,
+0xff9,0xff9,0xff9,0xff9,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,
+0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,
+0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa14,0xa14,0xa14,0xa14,0xa14,0xa14,
+0xa14,0xa14,0xa14,0xa14,0xa14,0xba0,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
+0x15,0x15,0x15,0x15,0xf0f,0xf0f,0xf0f,0xf0f,0xf0f,0xf0f,0xf0f,0xf0f,0xf0f,0xf0f,0xf12,0xf12,
+0xf12,0xf12,0xf12,0xf12,0xf12,0xf12,0xf12,0xf12,0xf12,0xf12,0xf12,0xf12,0xf12,0xf12,0xf12,0xf12,
+0xf12,0xf12,0xf12,0xf12,0xf12,0xf12,0xf12,0xf12,0xf12,0xf12,0xf12,0xf12,0xf12,0xf12,0xf12,0xf06,
+0xf06,0xf06,0xf06,0xf06,0xf06,0xf06,0xf06,0xf06,0xf15,0xf15,0xf09,0xf09,0xf0c,0xf1b,0xf18,0x102,
+0x102,0x1911,0x1914,0x1914,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0xb13,0xb13,0xb16,0xb16,0xb13,0xb13,0xb13,0xb13,0xb13,0xb13,0xb13,0xb13,
+0x6f,0x6f,0x6f,0x6f,0x1e0,0x1e0,0x1e0,0x1e0,0x1e0,0x1e0,0x1e0,0x1617,0x1617,0x1617,0x1617,0x1617,
+0x1617,0x1617,0x1617,0x1617,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0x1ec,0x1ec,0x1ec,0x1ec,0x1ec,0x1ec,0x1ec,0x1ec,0x1ec,0x1650,0x1650,0x1650,
+0x1650,0x1650,0x1650,0x1650,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0x1242,0x1242,0x1242,0x1242,0x1242,0x1242,0x1242,0x1242,0x1242,0x16b,0x16b,0x16b,
 0x16b,0x16b,0x16b,0x16b,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0x1c5,0x1c5,0x1c5,0x1c5,0x1c5,0x1c5,0x1c5,0x1c5,0x1c5,0x1c5,0x1c5,0x1c5,
-0x1c5,0x1c5,0x1c5,0x1c5,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0x1476,0x1476,0x1476,0x1476,0x1476,0x1476,0x1476,0x1476,0x1476,0x1476,0x1aa,0x1aa,
-0x1aa,0x1aa,0x1aa,0x1aa,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0x1b48,0x1b48,0x1b48,0x1b48,0x1b48,0x1b48,0x1b48,0x204,0x204,0x204,0x204,0x204,
-0x204,0x204,0x204,0x204,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0x24c,0x24c,0x24c,0x24c,0x24c,0x24c,0x24c,0x24c,0x24c,0x24c,0x24c,0x24c,
-0x24c,0x24c,0x24c,0x24c,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0x194d,0x194d,0x194d,0x194d,0x194d,0x194d,0x194d,0x194d,0x194d,0x194d,0x252,0x252,
-0x252,0x252,0x252,0x252,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0x1aaf,0x28e,0x28e,0x28e,0x28e,0x28e,0x28e,0x28e,0x28e,0x28e,0x28e,0x28e,
-0x28e,0x28e,0x28e,0x28e,0x1740,0x1740,0x1740,0x1740,0x20a,0x20a,0x20a,0x20a,0x20a,0x20a,0x20a,0x20a,
-0x20a,0x20a,0x20a,0x20a,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,
-0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,
-0x162c,0x162c,0x162c,0x162c,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0x1bb1,0x1bb1,0x1bb1,0x1bb1,0x2a3,0x1bb1,0x1bb1,0x1bb1,0x1bb1,0x1bb1,0x1bb1,0x1bb1,
-0x2a3,0x1bb1,0x1bb1,0x2a3,0x16a4,0x16a4,0x16a4,0x16a4,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,
-0x1f2,0x1f2,0x1f2,0x1f2,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,
-0x2b8,0x2b8,0x2b8,0x2b8,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0xde0,0xde0,0xddd,0xddd,0xddd,0xde0,0xd5,0xd5,0xd5,0xd5,0xd5,0xd5,
+0,0,0,0,0x1bdb,0x1bd8,0x1c2,0x1c2,0x1c2,0x1c2,0x1c2,0x1c2,0x1c2,0x1c2,0x1c2,0x1c2,
+0x1c2,0x1c2,0x1c2,0x1c2,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0x1488,0x1488,0x1488,0x1488,0x1488,0x1488,0x1488,0x1488,0x1488,0x1488,0x1a7,0x1a7,
+0x1a7,0x1a7,0x1a7,0x1a7,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x201,0x201,0x201,0x201,0x201,
+0x201,0x201,0x201,0x201,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0x249,0x249,0x249,0x249,0x249,0x249,0x249,0x249,0x249,0x249,0x249,0x249,
+0x249,0x249,0x249,0x249,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0x195f,0x195f,0x195f,0x195f,0x195f,0x195f,0x195f,0x195f,0x195f,0x195f,0x24f,0x24f,
+0x24f,0x24f,0x24f,0x24f,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0x1ac1,0x28b,0x28b,0x28b,0x28b,0x28b,0x28b,0x28b,0x28b,0x28b,0x28b,0x28b,
+0x28b,0x28b,0x28b,0x28b,0x1752,0x1752,0x1752,0x1752,0x207,0x207,0x207,0x207,0x207,0x207,0x207,0x207,
+0x207,0x207,0x207,0x207,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,
+0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,
+0x163e,0x163e,0x163e,0x163e,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0x1bc3,0x1bc3,0x1bc3,0x1bc3,0x2a0,0x1bc3,0x1bc3,0x1bc3,0x1bc3,0x1bc3,0x1bc3,0x1bc3,
+0x2a0,0x1bc3,0x1bc3,0x2a0,0x16b6,0x16b6,0x16b6,0x16b6,0x1ef,0x1ef,0x1ef,0x1ef,0x1ef,0x1ef,0x1ef,0x1ef,
+0x1ef,0x1ef,0x1ef,0x1ef,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x2b5,0x2b5,0x2b5,0x2b5,0x2b5,0x2b5,0x2b5,0x2b5,
+0x2b5,0x2b5,0x2b5,0x2b5,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0xdf2,0xdf2,0xdef,0xdef,0xdef,0xdf2,0xd5,0xd5,0xd5,0xd5,0xd5,0xd5,
 0xd5,0xd5,0xd5,0xd5,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0x216,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,
-0x1758,0x1758,0x1758,0x1758,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0x17dc,0x17dc,0x222,0x17dc,0x17dc,0x222,0x17dc,0x17dc,0x17dc,0x17dc,0x17dc,0x222,
-0x222,0x222,0x222,0x222,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0x1a01,0x1a01,0x1a01,0x1a01,0x1a01,0x1a01,0x1a01,0x1a01,0x1a01,0x1a01,0x273,0x273,
-0x273,0x273,0x1a04,0x19fe,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0x1b81,0x1b81,0x1b81,0x1b81,0x1b81,0x1b81,0x1b81,0x1b81,0x1b81,0x1b81,0x1b81,0x1b81,
-0x1b81,0x1b81,0x1b81,0x1b81,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0x258,0x1962,0x1962,0x1962,0x1962,0x1962,0x1962,0x1962,0x1962,0x1962,0x1962,0x1962,
-0x1962,0x1962,0x1962,0x1962,0x276,0x276,0x276,0x276,0x276,0x276,0x276,0x276,0x276,0x276,0x276,0x276,
-0x276,0x276,0x276,0x276,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0x213,0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,
+0x176a,0x176a,0x176a,0x176a,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,
+0x2bb,0x2bb,0x2bb,0x1bf6,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0x1a13,0x1a13,0x1a13,0x1a13,0x1a13,0x1a13,0x1a13,0x1a13,0x1a13,0x1a13,0x270,0x270,
+0x270,0x270,0x1a16,0x1a10,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0x1b93,0x1b93,0x1b93,0x1b93,0x1b93,0x1b93,0x1b93,0x1b93,0x1b93,0x1b93,0x1b93,0x1b93,
+0x1b93,0x1b93,0x1b93,0x1b93,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0x1c26,0x1c26,0x1c26,0x1c26,0x1c26,0x1c26,0x1c26,0x1c26,0x1c26,0x1c26,0x1c26,0x1c26,
+0x1c26,0x1c26,0x1c26,0x1c26,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0x255,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,
+0x1974,0x1974,0x1974,0x1974,0x273,0x273,0x273,0x273,0x273,0x273,0x273,0x273,0x273,0x273,0x273,0x273,
+0x273,0x273,0x273,0x273,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0x94e,0x94e,3,3,3,3,3,3,3,3,3,3,3,3,
+0,0,0x95d,0x95d,3,3,3,3,3,3,3,3,3,3,3,3,
 3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
-3,3,3,3,3,3,0x94e,0x94e,6,6,6,6,6,6,6,6,
+3,3,3,3,3,3,0x95d,0x95d,6,6,6,6,6,6,6,6,
 6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
-6,6,6,6,6,6,6,6,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,
-0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,6,6,6,6,6,6,6,6,
-6,6,6,6,6,6,6,6,0x14a9,0x3e1,0x3f0,0x3f0,0x18,0x3f6,0x3f6,0x3f6,
-0x3f6,0x3f6,0x3f6,0x3f6,0x3f6,0x18,0x18,0x3f6,0x3f6,0x18,0x18,0x3f6,0x3f6,0x3f6,0x3f6,0x3f6,
-0x3f6,0x3f6,0x3f6,0x3f6,0x3f6,0x3f6,0x3f6,0x3f6,0x3f6,0x18,0x3f6,0x3f6,0x3f6,0x3f6,0x3f6,0x3f6,
-0x3f6,0x18,0x3f6,0x18,0x18,0x18,0x3f6,0x3f6,0x3f6,0x3f6,0x18,0x18,0x3e4,0xc9f,0x3e1,0x3f0,
-0x3f0,0x3e1,0x3e1,0x3e1,0x3e1,0x18,0x18,0x3f0,0x3f0,0x18,0x18,0x3f3,0x3f3,0x3e7,0xd92,0x18,
-0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3e1,0x18,0x18,0x18,0x18,0x3f9,0x3f9,0x18,0x3f9,
-0x3f6,0x3f6,0x3e1,0x3e1,0x18,0x18,0x939,0x939,0x939,0x939,0x939,0x939,0x939,0x939,0x939,0x939,
-0x3f6,0x3f6,0x3ed,0x3ed,0x3ea,0x3ea,0x3ea,0x3ea,0x3ea,0x3ed,0x3ea,0x1110,0x1839,0x1836,0x18de,0x18,
-0x1b,0xca2,0x3fc,0xca5,0x1b,0x408,0x408,0x408,0x408,0x408,0x408,0x1b,0x1b,0x1b,0x1b,0x408,
-0x408,0x1b,0x1b,0x408,0x408,0x408,0x408,0x408,0x408,0x408,0x408,0x408,0x408,0x408,0x408,0x408,
-0x408,0x1b,0x408,0x408,0x408,0x408,0x408,0x408,0x408,0x1b,0x408,0x40b,0x1b,0x408,0x40b,0x1b,
-0x408,0x408,0x1b,0x1b,0x3ff,0x1b,0x405,0x405,0x405,0x3fc,0x3fc,0x1b,0x1b,0x1b,0x1b,0x3fc,
-0x3fc,0x1b,0x1b,0x3fc,0x3fc,0x402,0x1b,0x1b,0x1b,0xf6f,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
-0x1b,0x40b,0x40b,0x40b,0x408,0x1b,0x40b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x93c,0x93c,
-0x93c,0x93c,0x93c,0x93c,0x93c,0x93c,0x93c,0x93c,0x3fc,0x3fc,0x408,0x408,0x408,0xf6f,0x18e1,0x1b,
-0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1e,0x40e,0x40e,0x417,0x1e,0x41a,0x41a,0x41a,
-0x41a,0x41a,0x41a,0x41a,0xcae,0x41a,0x1e,0x41a,0x41a,0x41a,0x1e,0x41a,0x41a,0x41a,0x41a,0x41a,
-0x41a,0x41a,0x41a,0x41a,0x41a,0x41a,0x41a,0x41a,0x41a,0x1e,0x41a,0x41a,0x41a,0x41a,0x41a,0x41a,
-0x41a,0x1e,0x41a,0x41a,0x1e,0x41a,0x41a,0x41a,0x41a,0x41a,0x1e,0x1e,0x411,0x41a,0x417,0x417,
-0x417,0x40e,0x40e,0x40e,0x40e,0x40e,0x1e,0x40e,0x40e,0x417,0x1e,0x417,0x417,0x414,0x1e,0x1e,
-0x41a,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,
-0x41a,0xcae,0xca8,0xca8,0x1e,0x1e,0x93f,0x93f,0x93f,0x93f,0x93f,0x93f,0x93f,0x93f,0x93f,0x93f,
-0x13c2,0xcab,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x16b9,0x183c,0x183c,0x183c,0x183f,0x183f,0x183f,
-0x21,0x41d,0x42c,0x42c,0x21,0x432,0x432,0x432,0x432,0x432,0x432,0x432,0x432,0x21,0x21,0x432,
-0x432,0x21,0x21,0x432,0x432,0x432,0x432,0x432,0x432,0x432,0x432,0x432,0x432,0x432,0x432,0x432,
-0x432,0x21,0x432,0x432,0x432,0x432,0x432,0x432,0x432,0x21,0x432,0x432,0x21,0xcb1,0x432,0x432,
-0x432,0x432,0x21,0x21,0x420,0x432,0x41d,0x41d,0x42c,0x41d,0x41d,0x41d,0xf72,0x21,0x21,0x42c,
-0x42f,0x21,0x21,0x42f,0x42f,0x423,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x1a49,0x41d,0x41d,
-0x21,0x21,0x21,0x21,0x435,0x435,0x21,0x432,0x432,0x432,0xf72,0xf72,0x21,0x21,0x429,0x429,
-0x429,0x429,0x429,0x429,0x429,0x429,0x429,0x429,0x426,0xcb1,0x12ea,0x12ea,0x12ea,0x12ea,0x12ea,0x12ea,
-0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x24,0x24,0x438,0x444,0x24,0x444,0x444,0x444,
-0x444,0x444,0x444,0x24,0x24,0x24,0x444,0x444,0x444,0x24,0x444,0x444,0x447,0x444,0x24,0x24,
-0x24,0x444,0x444,0x24,0x444,0x24,0x444,0x444,0x24,0x24,0x24,0x444,0x444,0x24,0x24,0x24,
-0x444,0x444,0x444,0x24,0x24,0x24,0x444,0x444,0x444,0x444,0x444,0x444,0x444,0x444,0xd95,0x444,
-0x444,0x444,0x24,0x24,0x24,0x24,0x438,0x43e,0x438,0x43e,0x43e,0x24,0x24,0x24,0x43e,0x43e,
-0x43e,0x24,0x441,0x441,0x441,0x43b,0x24,0x24,0xf75,0x24,0x24,0x24,0x24,0x24,0x24,0x438,
-0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0xea9,0x945,0x945,0x945,0x945,0x945,
-0x945,0x945,0x945,0x945,0x942,0x942,0x942,0xd65,0xcb4,0xcb4,0xcb4,0xcb4,0xcb4,0xcb7,0xcb4,0x24,
-0x24,0x24,0x24,0x24,0x14ac,0x456,0x456,0x456,0x18e4,0x459,0x459,0x459,0x459,0x459,0x459,0x459,
-0x459,0x27,0x459,0x459,0x459,0x27,0x459,0x459,0x459,0x459,0x459,0x459,0x459,0x459,0x459,0x459,
-0x459,0x459,0x459,0x459,0x459,0x27,0x459,0x459,0x459,0x459,0x459,0x459,0x459,0x459,0x459,0x459,
-0x14af,0x459,0x459,0x459,0x459,0x459,0x27,0x27,0x1aee,0xf7e,0x44a,0x44a,0x44a,0x456,0x456,0x456,
-0x456,0x27,0x44a,0x44a,0x44d,0x27,0x44a,0x44a,0x44a,0x450,0x27,0x27,0x27,0x27,0x27,0x27,
-0x27,0x44a,0x44a,0x27,0xf7e,0xf7e,0x16bc,0x27,0x27,0x1af1,0x27,0x27,0x459,0x459,0xf78,0xf78,
-0x27,0x27,0x453,0x453,0x453,0x453,0x453,0x453,0x453,0x453,0x453,0x453,0x27,0x27,0x27,0x27,
-0x27,0x27,0x27,0x19ad,0xf7b,0xf7b,0xf7b,0xf7b,0xf7b,0xf7b,0xf7b,0xf7b,0x177c,0x14b2,0x462,0x462,
-0x18e7,0x468,0x468,0x468,0x468,0x468,0x468,0x468,0x468,0x2a,0x468,0x468,0x468,0x2a,0x468,0x468,
-0x468,0x468,0x468,0x468,0x468,0x468,0x468,0x468,0x468,0x468,0x468,0x468,0x468,0x2a,0x468,0x468,
-0x468,0x468,0x468,0x468,0x468,0x468,0x468,0x468,0x2a,0x468,0x468,0x468,0x468,0x468,0x2a,0x2a,
-0xcba,0xcbd,0x462,0x45c,0x465,0x462,0x45c,0x462,0x462,0x2a,0x45c,0x465,0x465,0x2a,0x465,0x465,
-0x45c,0x45f,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x45c,0x45c,0x2a,0x2a,0x2a,0x2a,0x2a,
-0x2a,0x1af4,0x468,0x2a,0x468,0x468,0xec1,0xec1,0x2a,0x2a,0x948,0x948,0x948,0x948,0x948,0x948,
-0x948,0x948,0x948,0x948,0x2a,0xec4,0xec4,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,
-0x2a,0x2a,0x2a,0x2a,0x1842,0x14b5,0x474,0x474,0x1a4c,0x47a,0x47a,0x47a,0x47a,0x47a,0x47a,0x47a,
-0x47a,0x2d,0x47a,0x47a,0x47a,0x2d,0x47a,0x47a,0x47a,0x47a,0x47a,0x47a,0x47a,0x47a,0x47a,0x47a,
-0x47a,0x47a,0x47a,0x47a,0x474,0x46b,0x46b,0x46b,0xf81,0x2d,0x474,0x474,0x474,0x2d,0x477,0x477,
-0x477,0x46e,0x12f0,0x177f,0x2d,0x2d,0x2d,0x2d,0x1782,0x1782,0x1782,0x46b,0x177f,0x177f,0x177f,0x177f,
-0x177f,0x177f,0x177f,0x16bf,0x47a,0x47a,0xf81,0xf81,0x2d,0x2d,0x471,0x471,0x471,0x471,0x471,0x471,
-0x471,0x471,0x471,0x471,0xf84,0xf84,0xf84,0xf84,0xf84,0xf84,0x177f,0x177f,0x177f,0xf87,0xf8a,0xf8a,
-0xf8a,0xf8a,0xf8a,0xf8a,0x30,0x1a4f,0xa11,0xa11,0x30,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,
-0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0x30,0x30,0x30,0xa17,0xa17,
-0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,
-0xa17,0xa17,0x30,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0x30,0xa17,0x30,0x30,
-0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0xa17,0x30,0x30,0x30,0xa0b,0x30,0x30,0x30,0x30,0xa08,
-0xa11,0xa11,0xa08,0xa08,0xa08,0x30,0xa08,0x30,0xa11,0xa11,0xa14,0xa11,0xa14,0xa14,0xa14,0xa08,
-0x30,0x30,0x30,0x30,0x30,0x30,0x14b8,0x14b8,0x14b8,0x14b8,0x14b8,0x14b8,0x14b8,0x14b8,0x14b8,0x14b8,
-0x30,0x30,0xa11,0xa11,0xa0e,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
-0x33,0x495,0x495,0x495,0x495,0x495,0x495,0x495,0x495,0x495,0x495,0x495,0x495,0x495,0x495,0x495,
-0x495,0x495,0x495,0x495,0x495,0x495,0x495,0x495,0x495,0x495,0x495,0x495,0x495,0x495,0x495,0x495,
-0x495,0x480,0x495,0x492,0x480,0x480,0x480,0x480,0x480,0x480,0x486,0x33,0x33,0x33,0x33,0x47d,
-0x49b,0x49b,0x49b,0x49b,0x49b,0x495,0x498,0x483,0x483,0x483,0x483,0x483,0x483,0x480,0x483,0x489,
-0x48f,0x48f,0x48f,0x48f,0x48f,0x48f,0x48f,0x48f,0x48f,0x48f,0x48c,0x48c,0x33,0x33,0x33,0x33,
+6,6,6,6,6,6,6,6,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,
+0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,6,6,6,6,6,6,6,6,
+6,6,6,6,6,6,6,6,0x14bb,0x3f0,0x3ff,0x3ff,0x18,0x405,0x405,0x405,
+0x405,0x405,0x405,0x405,0x405,0x18,0x18,0x405,0x405,0x18,0x18,0x405,0x405,0x405,0x405,0x405,
+0x405,0x405,0x405,0x405,0x405,0x405,0x405,0x405,0x405,0x18,0x405,0x405,0x405,0x405,0x405,0x405,
+0x405,0x18,0x405,0x18,0x18,0x18,0x405,0x405,0x405,0x405,0x18,0x18,0x3f3,0xcb1,0x3f0,0x3ff,
+0x3ff,0x3f0,0x3f0,0x3f0,0x3f0,0x18,0x18,0x3ff,0x3ff,0x18,0x18,0x402,0x402,0x3f6,0xda4,0x18,
+0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3f0,0x18,0x18,0x18,0x18,0x408,0x408,0x18,0x408,
+0x405,0x405,0x3f0,0x3f0,0x18,0x18,0x948,0x948,0x948,0x948,0x948,0x948,0x948,0x948,0x948,0x948,
+0x405,0x405,0x3fc,0x3fc,0x3f9,0x3f9,0x3f9,0x3f9,0x3f9,0x3fc,0x3f9,0x1125,0x184b,0x1848,0x18f0,0x18,
+0x1b,0xcb4,0x40b,0xcb7,0x1b,0x417,0x417,0x417,0x417,0x417,0x417,0x1b,0x1b,0x1b,0x1b,0x417,
+0x417,0x1b,0x1b,0x417,0x417,0x417,0x417,0x417,0x417,0x417,0x417,0x417,0x417,0x417,0x417,0x417,
+0x417,0x1b,0x417,0x417,0x417,0x417,0x417,0x417,0x417,0x1b,0x417,0x41a,0x1b,0x417,0x41a,0x1b,
+0x417,0x417,0x1b,0x1b,0x40e,0x1b,0x414,0x414,0x414,0x40b,0x40b,0x1b,0x1b,0x1b,0x1b,0x40b,
+0x40b,0x1b,0x1b,0x40b,0x40b,0x411,0x1b,0x1b,0x1b,0xf81,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
+0x1b,0x41a,0x41a,0x41a,0x417,0x1b,0x41a,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x94b,0x94b,
+0x94b,0x94b,0x94b,0x94b,0x94b,0x94b,0x94b,0x94b,0x40b,0x40b,0x417,0x417,0x417,0xf81,0x18f3,0x1b,
+0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1e,0x41d,0x41d,0x426,0x1e,0x429,0x429,0x429,
+0x429,0x429,0x429,0x429,0xcc0,0x429,0x1e,0x429,0x429,0x429,0x1e,0x429,0x429,0x429,0x429,0x429,
+0x429,0x429,0x429,0x429,0x429,0x429,0x429,0x429,0x429,0x1e,0x429,0x429,0x429,0x429,0x429,0x429,
+0x429,0x1e,0x429,0x429,0x1e,0x429,0x429,0x429,0x429,0x429,0x1e,0x1e,0x420,0x429,0x426,0x426,
+0x426,0x41d,0x41d,0x41d,0x41d,0x41d,0x1e,0x41d,0x41d,0x426,0x1e,0x426,0x426,0x423,0x1e,0x1e,
+0x429,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,
+0x429,0xcc0,0xcba,0xcba,0x1e,0x1e,0x94e,0x94e,0x94e,0x94e,0x94e,0x94e,0x94e,0x94e,0x94e,0x94e,
+0x13d4,0xcbd,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x16cb,0x184e,0x184e,0x184e,0x1851,0x1851,0x1851,
+0x21,0x42c,0x43b,0x43b,0x21,0x441,0x441,0x441,0x441,0x441,0x441,0x441,0x441,0x21,0x21,0x441,
+0x441,0x21,0x21,0x441,0x441,0x441,0x441,0x441,0x441,0x441,0x441,0x441,0x441,0x441,0x441,0x441,
+0x441,0x21,0x441,0x441,0x441,0x441,0x441,0x441,0x441,0x21,0x441,0x441,0x21,0xcc3,0x441,0x441,
+0x441,0x441,0x21,0x21,0x42f,0x441,0x42c,0x42c,0x43b,0x42c,0x42c,0x42c,0xf84,0x21,0x21,0x43b,
+0x43e,0x21,0x21,0x43e,0x43e,0x432,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x1a5b,0x42c,0x42c,
+0x21,0x21,0x21,0x21,0x444,0x444,0x21,0x441,0x441,0x441,0xf84,0xf84,0x21,0x21,0x438,0x438,
+0x438,0x438,0x438,0x438,0x438,0x438,0x438,0x438,0x435,0xcc3,0x12fc,0x12fc,0x12fc,0x12fc,0x12fc,0x12fc,
+0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x24,0x24,0x447,0x453,0x24,0x453,0x453,0x453,
+0x453,0x453,0x453,0x24,0x24,0x24,0x453,0x453,0x453,0x24,0x453,0x453,0x456,0x453,0x24,0x24,
+0x24,0x453,0x453,0x24,0x453,0x24,0x453,0x453,0x24,0x24,0x24,0x453,0x453,0x24,0x24,0x24,
+0x453,0x453,0x453,0x24,0x24,0x24,0x453,0x453,0x453,0x453,0x453,0x453,0x453,0x453,0xda7,0x453,
+0x453,0x453,0x24,0x24,0x24,0x24,0x447,0x44d,0x447,0x44d,0x44d,0x24,0x24,0x24,0x44d,0x44d,
+0x44d,0x24,0x450,0x450,0x450,0x44a,0x24,0x24,0xf87,0x24,0x24,0x24,0x24,0x24,0x24,0x447,
+0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0xebb,0x954,0x954,0x954,0x954,0x954,
+0x954,0x954,0x954,0x954,0x951,0x951,0x951,0xd77,0xcc6,0xcc6,0xcc6,0xcc6,0xcc6,0xcc9,0xcc6,0x24,
+0x24,0x24,0x24,0x24,0x14be,0x465,0x465,0x465,0x18f6,0x468,0x468,0x468,0x468,0x468,0x468,0x468,
+0x468,0x27,0x468,0x468,0x468,0x27,0x468,0x468,0x468,0x468,0x468,0x468,0x468,0x468,0x468,0x468,
+0x468,0x468,0x468,0x468,0x468,0x27,0x468,0x468,0x468,0x468,0x468,0x468,0x468,0x468,0x468,0x468,
+0x14c1,0x468,0x468,0x468,0x468,0x468,0x27,0x27,0x1b00,0xf90,0x459,0x459,0x459,0x465,0x465,0x465,
+0x465,0x27,0x459,0x459,0x45c,0x27,0x459,0x459,0x459,0x45f,0x27,0x27,0x27,0x27,0x27,0x27,
+0x27,0x459,0x459,0x27,0xf90,0xf90,0x16ce,0x27,0x27,0x1b03,0x27,0x27,0x468,0x468,0xf8a,0xf8a,
+0x27,0x27,0x462,0x462,0x462,0x462,0x462,0x462,0x462,0x462,0x462,0x462,0x27,0x27,0x27,0x27,
+0x27,0x27,0x27,0x19bf,0xf8d,0xf8d,0xf8d,0xf8d,0xf8d,0xf8d,0xf8d,0xf8d,0x178e,0x14c4,0x471,0x471,
+0x18f9,0x477,0x477,0x477,0x477,0x477,0x477,0x477,0x477,0x2a,0x477,0x477,0x477,0x2a,0x477,0x477,
+0x477,0x477,0x477,0x477,0x477,0x477,0x477,0x477,0x477,0x477,0x477,0x477,0x477,0x2a,0x477,0x477,
+0x477,0x477,0x477,0x477,0x477,0x477,0x477,0x477,0x2a,0x477,0x477,0x477,0x477,0x477,0x2a,0x2a,
+0xccc,0xccf,0x471,0x46b,0x474,0x471,0x46b,0x471,0x471,0x2a,0x46b,0x474,0x474,0x2a,0x474,0x474,
+0x46b,0x46e,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x46b,0x46b,0x2a,0x2a,0x2a,0x2a,0x2a,
+0x2a,0x1b06,0x477,0x2a,0x477,0x477,0xed3,0xed3,0x2a,0x2a,0x957,0x957,0x957,0x957,0x957,0x957,
+0x957,0x957,0x957,0x957,0x2a,0xed6,0xed6,0x1bc9,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,
+0x2a,0x2a,0x2a,0x2a,0x1854,0x14c7,0x483,0x483,0x1a5e,0x489,0x489,0x489,0x489,0x489,0x489,0x489,
+0x489,0x2d,0x489,0x489,0x489,0x2d,0x489,0x489,0x489,0x489,0x489,0x489,0x489,0x489,0x489,0x489,
+0x489,0x489,0x489,0x489,0x483,0x47a,0x47a,0x47a,0xf93,0x2d,0x483,0x483,0x483,0x2d,0x486,0x486,
+0x486,0x47d,0x1302,0x1791,0x2d,0x2d,0x2d,0x2d,0x1794,0x1794,0x1794,0x47a,0x1791,0x1791,0x1791,0x1791,
+0x1791,0x1791,0x1791,0x16d1,0x489,0x489,0xf93,0xf93,0x2d,0x2d,0x480,0x480,0x480,0x480,0x480,0x480,
+0x480,0x480,0x480,0x480,0xf96,0xf96,0xf96,0xf96,0xf96,0xf96,0x1791,0x1791,0x1791,0xf99,0xf9c,0xf9c,
+0xf9c,0xf9c,0xf9c,0xf9c,0x30,0x1a61,0xa23,0xa23,0x30,0xa29,0xa29,0xa29,0xa29,0xa29,0xa29,0xa29,
+0xa29,0xa29,0xa29,0xa29,0xa29,0xa29,0xa29,0xa29,0xa29,0xa29,0xa29,0x30,0x30,0x30,0xa29,0xa29,
+0xa29,0xa29,0xa29,0xa29,0xa29,0xa29,0xa29,0xa29,0xa29,0xa29,0xa29,0xa29,0xa29,0xa29,0xa29,0xa29,
+0xa29,0xa29,0x30,0xa29,0xa29,0xa29,0xa29,0xa29,0xa29,0xa29,0xa29,0xa29,0x30,0xa29,0x30,0x30,
+0xa29,0xa29,0xa29,0xa29,0xa29,0xa29,0xa29,0x30,0x30,0x30,0xa1d,0x30,0x30,0x30,0x30,0xa1a,
+0xa23,0xa23,0xa1a,0xa1a,0xa1a,0x30,0xa1a,0x30,0xa23,0xa23,0xa26,0xa23,0xa26,0xa26,0xa26,0xa1a,
+0x30,0x30,0x30,0x30,0x30,0x30,0x14ca,0x14ca,0x14ca,0x14ca,0x14ca,0x14ca,0x14ca,0x14ca,0x14ca,0x14ca,
+0x30,0x30,0xa23,0xa23,0xa20,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
+0x33,0x4a4,0x4a4,0x4a4,0x4a4,0x4a4,0x4a4,0x4a4,0x4a4,0x4a4,0x4a4,0x4a4,0x4a4,0x4a4,0x4a4,0x4a4,
+0x4a4,0x4a4,0x4a4,0x4a4,0x4a4,0x4a4,0x4a4,0x4a4,0x4a4,0x4a4,0x4a4,0x4a4,0x4a4,0x4a4,0x4a4,0x4a4,
+0x4a4,0x48f,0x4a4,0x4a1,0x48f,0x48f,0x48f,0x48f,0x48f,0x48f,0x495,0x33,0x33,0x33,0x33,0x48c,
+0x4aa,0x4aa,0x4aa,0x4aa,0x4aa,0x4a4,0x4a7,0x492,0x492,0x492,0x492,0x492,0x492,0x48f,0x492,0x498,
+0x49e,0x49e,0x49e,0x49e,0x49e,0x49e,0x49e,0x49e,0x49e,0x49e,0x49b,0x49b,0x33,0x33,0x33,0x33,
 0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
-0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x36,0x4aa,0x4aa,0x36,
-0x4aa,0x36,0x19b3,0x4aa,0x4aa,0x19b3,0x4aa,0x36,0x19b3,0x4aa,0x19b3,0x19b3,0x19b3,0x19b3,0x19b3,0x19b3,
-0x4aa,0x4aa,0x4aa,0x4aa,0x19b3,0x4aa,0x4aa,0x4aa,0x4aa,0x4aa,0x4aa,0x4aa,0x19b3,0x4aa,0x4aa,0x4aa,
-0x36,0x4aa,0x36,0x4aa,0x19b3,0x19b3,0x4aa,0x4aa,0x19b3,0x4aa,0x4aa,0x4aa,0x4aa,0x49e,0x4aa,0x4a7,
-0x49e,0x49e,0x49e,0x49e,0x49e,0x49e,0x19b0,0x49e,0x49e,0x4aa,0x36,0x36,0x4b3,0x4b3,0x4b3,0x4b3,
-0x4b3,0x36,0x4b0,0x36,0x4a1,0x4a1,0x4a1,0x4a1,0x4a1,0x49e,0x36,0x36,0x4a4,0x4a4,0x4a4,0x4a4,
-0x4a4,0x4a4,0x4a4,0x4a4,0x4a4,0x4a4,0x36,0x36,0x4ad,0x4ad,0x13c5,0x13c5,0x36,0x36,0x36,0x36,
+0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x36,0x4b9,0x4b9,0x36,
+0x4b9,0x36,0x19c5,0x4b9,0x4b9,0x19c5,0x4b9,0x36,0x19c5,0x4b9,0x19c5,0x19c5,0x19c5,0x19c5,0x19c5,0x19c5,
+0x4b9,0x4b9,0x4b9,0x4b9,0x19c5,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x19c5,0x4b9,0x4b9,0x4b9,
+0x36,0x4b9,0x36,0x4b9,0x19c5,0x19c5,0x4b9,0x4b9,0x19c5,0x4b9,0x4b9,0x4b9,0x4b9,0x4ad,0x4b9,0x4b6,
+0x4ad,0x4ad,0x4ad,0x4ad,0x4ad,0x4ad,0x19c2,0x4ad,0x4ad,0x4b9,0x36,0x36,0x4c2,0x4c2,0x4c2,0x4c2,
+0x4c2,0x36,0x4bf,0x36,0x4b0,0x4b0,0x4b0,0x4b0,0x4b0,0x4ad,0x1bcc,0x36,0x4b3,0x4b3,0x4b3,0x4b3,
+0x4b3,0x4b3,0x4b3,0x4b3,0x4b3,0x4b3,0x36,0x36,0x4bc,0x4bc,0x13d7,0x13d7,0x36,0x36,0x36,0x36,
 0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
-0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x98a,0x98a,0x98a,0x98d,
-0x98a,0x98a,0x98a,0x98a,0x39,0x98a,0x98a,0x98a,0x98a,0x98d,0x98a,0x98a,0x98a,0x98a,0x98d,0x98a,
-0x98a,0x98a,0x98a,0x98d,0x98a,0x98a,0x98a,0x98a,0x98d,0x98a,0x98a,0x98a,0x98a,0x98a,0x98a,0x98a,
-0x98a,0x98a,0x98a,0x98a,0x98a,0x98d,0xa26,0xf96,0xf96,0x39,0x39,0x39,0x39,0x957,0x957,0x95a,
-0x957,0x95a,0x95a,0x963,0x95a,0x963,0x957,0x957,0x957,0x957,0x957,0x984,0x957,0x95a,0x95d,0x95d,
-0x960,0x969,0x95d,0x95d,0x98a,0x98a,0x98a,0x98a,0x12f9,0x12f3,0x12f3,0x12f3,0x957,0x957,0x957,0x95a,
-0x957,0x957,0xa1a,0x957,0x39,0x957,0x957,0x957,0x957,0x95a,0x957,0x957,0x957,0x957,0x95a,0x957,
-0x957,0x957,0x957,0x95a,0x957,0x957,0x957,0x957,0x95a,0x957,0xa1a,0xa1a,0xa1a,0x957,0x957,0x957,
-0x957,0x957,0x957,0x957,0xa1a,0x95a,0xa1a,0xa1a,0xa1a,0x39,0xa23,0xa23,0xa20,0xa20,0xa20,0xa20,
-0xa20,0xa20,0xa1d,0xa20,0xa20,0xa20,0xa20,0xa20,0xa20,0x39,0xf8d,0xa20,0xd98,0xd98,0xf90,0xf93,
-0xf8d,0x1113,0x1113,0x1113,0x1113,0x12f6,0x12f6,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,
+0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x99c,0x99c,0x99c,0x99f,
+0x99c,0x99c,0x99c,0x99c,0x39,0x99c,0x99c,0x99c,0x99c,0x99f,0x99c,0x99c,0x99c,0x99c,0x99f,0x99c,
+0x99c,0x99c,0x99c,0x99f,0x99c,0x99c,0x99c,0x99c,0x99f,0x99c,0x99c,0x99c,0x99c,0x99c,0x99c,0x99c,
+0x99c,0x99c,0x99c,0x99c,0x99c,0x99f,0xa38,0xfa8,0xfa8,0x39,0x39,0x39,0x39,0x966,0x966,0x969,
+0x966,0x969,0x969,0x975,0x969,0x975,0x966,0x966,0x966,0x966,0x966,0x996,0x966,0x969,0x96f,0x96f,
+0x972,0x97b,0x96c,0x96c,0x99c,0x99c,0x99c,0x99c,0x130b,0x1305,0x1305,0x1305,0x966,0x966,0x966,0x969,
+0x966,0x966,0xa2c,0x966,0x39,0x966,0x966,0x966,0x966,0x969,0x966,0x966,0x966,0x966,0x969,0x966,
+0x966,0x966,0x966,0x969,0x966,0x966,0x966,0x966,0x969,0x966,0xa2c,0xa2c,0xa2c,0x966,0x966,0x966,
+0x966,0x966,0x966,0x966,0xa2c,0x969,0xa2c,0xa2c,0xa2c,0x39,0xa35,0xa35,0xa32,0xa32,0xa32,0xa32,
+0xa32,0xa32,0xa2f,0xa32,0xa32,0xa32,0xa32,0xa32,0xa32,0x39,0xf9f,0xa32,0xdaa,0xdaa,0xfa2,0xfa5,
+0xf9f,0x1128,0x1128,0x1128,0x1128,0x1308,0x1308,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,
 0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,
-0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x3c,0x13cb,
-0x3c,0x3c,0x3c,0x3c,0x3c,0x13cb,0x3c,0x3c,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,
-0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xda7,
-0xa50,0x3f,0xa50,0xa50,0xa50,0xa50,0x3f,0x3f,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0x3f,
-0xa50,0x3f,0xa50,0xa50,0xa50,0xa50,0x3f,0x3f,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xda7,
-0xa50,0x3f,0xa50,0xa50,0xa50,0xa50,0x3f,0x3f,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,
-0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xda7,0xa50,0x3f,0xa50,0xa50,
-0xa50,0xa50,0x3f,0x3f,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0x3f,0xa50,0x3f,0xa50,0xa50,
-0xa50,0xa50,0x3f,0x3f,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xda7,0xa50,0xa50,0xa50,0xa50,
-0xa50,0xa50,0xa50,0x3f,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,
-0xa50,0xa50,0xa50,0xda7,0xa50,0x3f,0xa50,0xa50,0xa50,0xa50,0x3f,0x3f,0xa50,0xa50,0xa50,0xa50,
-0xa50,0xa50,0xa50,0xda7,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,
-0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0x3f,0x3f,0x12fc,0x12fc,0xda1,0xda4,0xa4a,0xa53,0xa47,
-0xa47,0xa47,0xa47,0xa53,0xa53,0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,0xa44,0xa44,
-0xa44,0xa44,0xa44,0xa44,0xa44,0xa44,0xa44,0xa44,0xa44,0x3f,0x3f,0x3f,0xa56,0xa56,0xa56,0xa56,
-0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,
-0xa56,0x16c5,0x42,0x42,0x16c2,0x16c2,0x16c2,0x16c2,0x16c2,0x16c2,0x42,0x42,0xa68,0xa6b,0xa6b,0xa6b,
-0xa6b,0xa6b,0xa6b,0xa6b,0xa6b,0xa6b,0xa6b,0xa6b,0xa6b,0xa6b,0xa6b,0xa6b,0xa6b,0xa6b,0xa6b,0xa6b,
-0xa6b,0xa6b,0xa6b,0xa6b,0xa6b,0xa6b,0xa6b,0xa65,0xa62,0x45,0x45,0x45,0xa71,0xa71,0xa71,0xa71,
-0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa6e,0xa6e,0xa6e,0xa71,0xa71,0xa71,0x14bb,0x14bb,0x14bb,
-0x14bb,0x14bb,0x14bb,0x14bb,0x14bb,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0xa92,0xa92,0xa92,0xa92,
-0xa92,0xa92,0xa74,0xa92,0xa92,0xa77,0xa77,0xa77,0xa77,0xa77,0xa77,0xa77,0xa77,0xa77,0xa7a,0xa77,
-0xa89,0xa89,0xa8c,0xa95,0xa83,0xa80,0xa89,0xa86,0xa95,0xcc0,0x4b,0x4b,0xa8f,0xa8f,0xa8f,0xa8f,
-0xa8f,0xa8f,0xa8f,0xa8f,0xa8f,0xa8f,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0xcc3,0xcc3,0xcc3,0xcc3,
-0xcc3,0xcc3,0xcc3,0xcc3,0xcc3,0xcc3,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0xaa4,0xaa4,0xb1c,0xb1f,
-0xaaa,0xb19,0xaa7,0xaa4,0xaad,0xabc,0xab0,0xabf,0xabf,0xabf,0xa9b,0x1af7,0xab3,0xab3,0xab3,0xab3,
-0xab3,0xab3,0xab3,0xab3,0xab3,0xab3,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0xab6,0xab6,0xab6,0xab6,
-0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,
-0xab6,0xab6,0xab6,0xab6,0x18ea,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0xab6,0xab6,0xab6,0xab6,
-0xab6,0xab6,0xab6,0xab6,0xab6,0xa9e,0xfb4,0x4e,0x4e,0x4e,0x4e,0x4e,0x116a,0x116a,0x116a,0x116a,
-0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x4d7,0x4d7,0x4d7,0x4d7,
-0x4d7,0x4d7,0x4d7,0x4d7,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x4d7,0x4d7,0x4d7,0x4d7,
-0x4d7,0x4d7,0x51,0x51,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x51,0x51,0x4d7,0x4d7,0x4d7,0x4d7,
-0x4d7,0x4d7,0x4d7,0x4d7,0x51,0x4da,0x51,0x4da,0x51,0x4da,0x51,0x4da,0x4d7,0x4d7,0x4d7,0x4d7,
-0x4d7,0x4d7,0x4d7,0x4d7,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x4d7,0x4d7,0x4d7,0x4d7,
-0x4d7,0x4d7,0x4d7,0x4d7,0x4d7,0x4d7,0x4d7,0x4d7,0x4d7,0x4d7,0x51,0x51,0x4d7,0x4d7,0x4d7,0x4d7,
-0x4d7,0x4d7,0x4d7,0x4d7,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x4d7,0x4d7,0x4d7,0x4d7,
-0x4d7,0x51,0x4d7,0x4d7,0x4da,0x4da,0x4da,0x4da,0x4da,0x4d1,0x4d7,0x4d1,0x4d1,0x4ce,0x4d7,0x4d7,
-0x4d7,0x51,0x4d7,0x4d7,0x4da,0x4da,0x4da,0x4da,0x4da,0x4ce,0x4ce,0x4ce,0x4d7,0x4d7,0x4d7,0x4d7,
-0x51,0x51,0x4d7,0x4d7,0x4da,0x4da,0x4da,0x4da,0x51,0x4ce,0x4ce,0x4ce,0x4d7,0x4d7,0x4d7,0x4d7,
-0x4d7,0x4d7,0x4d7,0x4d7,0x4da,0x4da,0x4da,0x4da,0x4da,0x4ce,0x4ce,0x4ce,0x51,0x51,0x4d7,0x4d7,
-0x4d7,0x51,0x4d7,0x4d7,0x4da,0x4da,0x4da,0x4da,0x4da,0x4d4,0x4d1,0x51,0xb94,0xb97,0xb97,0xb97,
-0xfbd,0x54,0x1497,0x1497,0x1497,0x1497,0x4e3,0x4e3,0x4e3,0x4e3,0x4e3,0x4e3,0x52e,0xba9,0x57,0x57,
-0x6c9,0x52e,0x52e,0x52e,0x52e,0x52e,0x534,0x546,0x534,0x540,0x53a,0x6cc,0x52b,0x6c6,0x6c6,0x6c6,
-0x6c6,0x52b,0x52b,0x52b,0x52b,0x52b,0x531,0x543,0x531,0x53d,0x537,0x57,0xdb0,0xdb0,0xdb0,0xdb0,
-0xdb0,0x12ff,0x12ff,0x12ff,0x12ff,0x12ff,0x12ff,0x12ff,0x12ff,0x57,0x57,0x57,0x1afa,0x5a,0x5a,0x5a,
-0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x555,0x555,0x555,0x555,
-0x555,0x555,0x555,0x555,0x555,0x555,0x555,0x555,0x555,0x552,0x552,0x552,0x552,0x555,0xacb,0xacb,
-0xbaf,0xbb5,0xbb5,0xbb2,0xbb2,0xbb2,0xbb2,0xdb6,0xec7,0xec7,0xec7,0xec7,0x10fe,0x5d,0x5d,0x5d,
-0x5d,0x5d,0x5d,0x5d,0x5d,0x5d,0x5d,0x5d,0x5d,0x5d,0x5d,0x5d,0x585,0x585,0x585,0xad4,
-0xed0,0xfc3,0xfc3,0xfc3,0xfc3,0x125d,0x16cb,0x16cb,0x60,0x60,0x60,0x60,0x6f3,0x6f3,0x6f3,0x6f3,
-0x6f3,0x6f3,0x6f3,0x6f3,0x6f3,0x6f3,0x591,0x591,0x58e,0x58e,0x58e,0x58e,0x5b2,0x5b2,0x5b2,0x5b2,
-0x5b2,0xadd,0xadd,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,
-0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x5b5,0x5b5,0x5b5,0x5b5,
-0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
-0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0xaf8,0xaf8,0xaf8,0xaf8,
-0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,
-0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0x69,0xaf8,0xaf8,0xaf8,0xaf8,0xafb,0xaf8,0xaf8,0xaf8,0xaf8,
-0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xafb,
-0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0xafe,0xafe,0xafe,0xafe,
-0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,
-0xafe,0xafe,0x6c,0x6c,0x6c,0x6c,0x6c,0x6c,0x6c,0x6c,0x6c,0x6c,0x72,0x813,0x80d,0x813,
-0x80d,0x813,0x80d,0x813,0x80d,0x813,0x80d,0x80d,0x810,0x80d,0x810,0x80d,0x810,0x80d,0x810,0x80d,
-0x810,0x80d,0x810,0x80d,0x810,0x80d,0x810,0x80d,0x810,0x80d,0x810,0x80d,0x80d,0x80d,0x80d,0x813,
-0x80d,0x813,0x80d,0x813,0x80d,0x80d,0x80d,0x80d,0x80d,0x80d,0x813,0x80d,0x80d,0x80d,0x80d,0x80d,
-0x810,0xc4e,0xc4e,0x72,0x72,0x927,0x927,0x8ee,0x8ee,0x816,0x819,0xc4b,0x75,0x75,0x75,0x75,
-0x75,0x82b,0x82b,0x82b,0x82b,0x82b,0x82b,0x82b,0x82b,0x82b,0x82b,0x82b,0x82b,0x82b,0x82b,0x82b,
-0x82b,0x82b,0x82b,0x82b,0x82b,0x82b,0x82b,0x82b,0x82b,0x82b,0x82b,0x82b,0x82b,0x10ec,0x18b1,0x1998,
-0x78,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,
-0x82e,0x82e,0x82e,0x78,0x8f7,0x8f7,0x8fa,0x8fa,0x8fa,0x8fa,0x8fa,0x8fa,0x8fa,0x8fa,0x8fa,0x8fa,
-0x8fa,0x8fa,0x8fa,0x8fa,0x837,0x837,0x837,0x837,0x837,0x837,0x837,0x837,0x837,0x837,0x837,0x837,
-0x837,0x837,0x837,0x837,0x837,0x837,0x837,0x837,0x837,0x837,0x837,0x837,0x837,0x837,0x837,0x837,
-0x837,0xd4a,0xd4a,0x7b,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,
-0xb10,0x7e,0x7e,0x7e,0xb16,0xb16,0xb16,0xb16,0xb16,0xb16,0xb16,0xb16,0xb16,0xb16,0xb16,0xb16,
-0xb16,0xb16,0xb16,0xb16,0xb16,0xc57,0xb16,0xb16,0xb16,0xc57,0xb16,0x81,0x81,0x81,0x81,0x81,
-0x81,0x81,0x81,0x81,0x1191,0x1191,0x1191,0x1191,0x1191,0x1191,0x1191,0x1191,0x1191,0x1191,0x1191,0x1191,
-0x1191,0x1191,0x1191,0x1191,0x9ae,0x9ae,0x9ae,0x9ae,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
-0x84,0x84,0x84,0x84,0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,
-0x1206,0x1206,0x1206,0x1206,0x5fa,0x5fa,0x5fa,0x5fa,0x5fa,0x5fa,0x5fa,0x87,0x87,0x87,0x87,0x87,
-0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x87,0x87,0x87,0x87,
-0x87,0xae9,0x5eb,0x5f1,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x5ee,0x5f1,0x5f1,
-0x5f1,0x5f1,0x5f1,0x5f1,0x5f1,0x5f1,0x5f1,0x5f1,0x5f1,0x5f1,0x5f1,0x87,0x5f1,0x5f1,0x5f1,0x5f1,
-0x5f1,0x87,0x5f1,0x87,0x5f1,0x5f1,0x87,0x5f1,0x5f1,0x87,0x5f1,0x5f1,0x5f1,0x5f1,0x5f1,0x5f1,
-0x5f1,0x5f1,0x5f1,0x5f4,0x606,0x600,0x606,0x600,0x603,0x609,0x606,0x600,0x603,0x609,0x606,0x600,
-0x603,0x609,0x606,0x600,0x1311,0x1311,0x1afd,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
-0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x606,0x600,0x603,0x609,0x606,0x600,0x606,0x600,0x606,
-0x600,0x606,0x606,0x600,0x600,0x600,0x600,0x603,0x600,0x600,0x603,0x600,0x603,0x603,0x603,0x600,
-0x603,0x603,0x603,0x603,0x8a,0x8a,0x603,0x603,0x603,0x603,0x600,0x600,0x603,0x600,0x600,0x600,
-0x600,0x603,0x600,0x600,0x600,0x600,0x600,0x603,0x603,0x603,0x600,0x600,0x8a,0x8a,0x8a,0x8a,
-0x8a,0x8a,0x8a,0x1afd,0xb34,0xb34,0xb34,0xb34,0xb34,0xb34,0xb34,0xb34,0xb34,0xb34,0xb34,0xb34,
-0xb34,0xb34,0xb34,0xb34,0x84f,0x861,0x85e,0x861,0x85e,0xc6c,0xc6c,0xd56,0xd53,0x852,0x852,0x852,
-0x852,0x864,0x864,0x864,0x87c,0x87f,0x88e,0x8d,0x882,0x885,0x891,0x891,0x879,0x870,0x86a,0x870,
-0x86a,0x870,0x86a,0x86d,0x86d,0x888,0x888,0x88b,0x888,0x888,0x888,0x8d,0x888,0x876,0x873,0x86d,
-0x8d,0x8d,0x8d,0x8d,0x612,0x61e,0x612,0xbe8,0x612,0x90,0x612,0x61e,0x612,0x61e,0x612,0x61e,
-0x612,0x61e,0x612,0x61e,0x61e,0x61b,0x615,0x618,0x61e,0x61b,0x615,0x618,0x61e,0x61b,0x615,0x618,
-0x61e,0x61b,0x615,0x61b,0x615,0x61b,0x615,0x618,0x61e,0x61b,0x615,0x61b,0x615,0x61b,0x615,0x61b,
-0x615,0x90,0x90,0x60f,0x750,0x753,0x768,0x76b,0x74a,0x753,0x753,0x96,0x732,0x735,0x735,0x735,
-0x735,0x732,0x732,0x96,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0xaec,0xaec,0xaec,
-0x9b1,0x72c,0x621,0x621,0x96,0x77a,0x759,0x74a,0x753,0x750,0x74a,0x75c,0x74d,0x747,0x74a,0x768,
-0x75f,0x756,0x777,0x74a,0x774,0x774,0x774,0x774,0x774,0x774,0x774,0x774,0x774,0x774,0x765,0x762,
-0x768,0x768,0x768,0x77a,0x73b,0x738,0x738,0x738,0x738,0x738,0x738,0x738,0x738,0x738,0x738,0x738,
-0x738,0x738,0x738,0x738,0x738,0x738,0x738,0x738,0x738,0x738,0x738,0x738,0x738,0x738,0x738,0x738,
-0x738,0x738,0x738,0x96,0x96,0x96,0x738,0x738,0x738,0x738,0x738,0x738,0x96,0x96,0x738,0x738,
-0x738,0x738,0x738,0x738,0x96,0x96,0x738,0x738,0x738,0x738,0x738,0x738,0x96,0x96,0x738,0x738,
-0x738,0x96,0x96,0x96,0xb37,0xb37,0xb37,0xb37,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,
-0x99,0x184e,0x184e,0x184e,0xb3d,0xb3d,0xb3d,0xb3d,0xb3d,0xb3d,0xb3d,0xb3d,0xb3d,0xb3d,0xb3d,0xb3d,
-0xb3d,0xb3d,0xb3d,0xb3d,0xb3d,0xb3d,0xb3d,0x9c,0x9c,0x9c,0x9c,0x9c,0x1614,0x1614,0x1614,0x1614,
-0x1614,0x1614,0x1614,0x1614,0x1614,0x1614,0x1614,0x1614,0x1614,0x1614,0x1614,0x1614,0xb46,0xb46,0xb46,0xb46,
-0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,
-0xb46,0xb46,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0xb52,0xb52,0xb52,0xb52,
-0xb52,0xb52,0xb52,0xa2,0xa2,0xfcf,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,
-0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0x16d1,0x16d1,0x16d1,0x16d1,
-0x16d1,0x16d1,0x16d1,0x16d1,0x16d1,0x1b00,0x1b00,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,
-0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xb6a,0xb6a,0xb6a,0xb6a,
-0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,
-0xb67,0xa5,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb6a,0xb6a,0xb67,0xb67,
-0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,
-0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb6a,0xa5,0xb6a,0xb6a,0xa5,0xa5,0xb6a,0xa5,
-0xa5,0xb6a,0xb6a,0xa5,0xa5,0xb6a,0xb6a,0xb6a,0xb6a,0xa5,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,
-0xb6a,0xb6a,0xb67,0xb67,0xb67,0xb67,0xa5,0xb67,0xa5,0xb67,0xb67,0xb67,0xb67,0xcde,0xb67,0xb67,
-0xa5,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb6a,0xb6a,0xb6a,0xb6a,
-0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb67,0xb67,0xb67,0xb67,
-0xb6a,0xb6a,0xa5,0xb6a,0xb6a,0xb6a,0xb6a,0xa5,0xa5,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,
-0xb6a,0xa5,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xa5,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,
-0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,
-0xb67,0xb67,0xb67,0xb67,0xb6a,0xb6a,0xa5,0xb6a,0xb6a,0xb6a,0xb6a,0xa5,0xb6a,0xb6a,0xb6a,0xb6a,
-0xb6a,0xa5,0xb6a,0xa5,0xa5,0xa5,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xa5,0xb67,0xb67,
-0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xdc8,0xdc8,0xa5,0xa5,
-0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,
-0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb67,0xb67,0xb67,0xb61,0xb67,0xb67,0xb67,0xb67,
-0xb67,0xb67,0xedf,0xedc,0xa5,0xa5,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,
-0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xa8,0xb70,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,
+0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x4c8,0x4c8,0x4c8,0x4c8,0x4c8,0x4c8,0x3c,0x13dd,
+0x3c,0x3c,0x3c,0x3c,0x3c,0x13dd,0x3c,0x3c,0x4c5,0x4c5,0x4c5,0x4c5,0x4c5,0x4c5,0x4c5,0x4c5,
+0x4c5,0x4c5,0x4c5,0x4c5,0x4c5,0x4c5,0x4c5,0x4c5,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xdb9,
+0xa62,0x3f,0xa62,0xa62,0xa62,0xa62,0x3f,0x3f,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0x3f,
+0xa62,0x3f,0xa62,0xa62,0xa62,0xa62,0x3f,0x3f,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xdb9,
+0xa62,0x3f,0xa62,0xa62,0xa62,0xa62,0x3f,0x3f,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,
+0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xdb9,0xa62,0x3f,0xa62,0xa62,
+0xa62,0xa62,0x3f,0x3f,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0x3f,0xa62,0x3f,0xa62,0xa62,
+0xa62,0xa62,0x3f,0x3f,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xdb9,0xa62,0xa62,0xa62,0xa62,
+0xa62,0xa62,0xa62,0x3f,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,
+0xa62,0xa62,0xa62,0xdb9,0xa62,0x3f,0xa62,0xa62,0xa62,0xa62,0x3f,0x3f,0xa62,0xa62,0xa62,0xa62,
+0xa62,0xa62,0xa62,0xdb9,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,
+0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0x3f,0x3f,0x130e,0x130e,0xdb3,0xdb6,0xa5c,0xa65,0xa59,
+0xa59,0xa59,0xa59,0xa65,0xa65,0xa5f,0xa5f,0xa5f,0xa5f,0xa5f,0xa5f,0xa5f,0xa5f,0xa5f,0xa56,0xa56,
+0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,0x3f,0x3f,0x3f,0xa68,0xa68,0xa68,0xa68,
+0xa68,0xa68,0xa68,0xa68,0xa68,0xa68,0xa68,0xa68,0xa68,0xa68,0xa68,0xa68,0xa68,0xa68,0xa68,0xa68,
+0xa68,0x16d7,0x42,0x42,0x16d4,0x16d4,0x16d4,0x16d4,0x16d4,0x16d4,0x42,0x42,0xa7a,0xa7d,0xa7d,0xa7d,
+0xa7d,0xa7d,0xa7d,0xa7d,0xa7d,0xa7d,0xa7d,0xa7d,0xa7d,0xa7d,0xa7d,0xa7d,0xa7d,0xa7d,0xa7d,0xa7d,
+0xa7d,0xa7d,0xa7d,0xa7d,0xa7d,0xa7d,0xa7d,0xa77,0xa74,0x45,0x45,0x45,0xa83,0xa83,0xa83,0xa83,
+0xa83,0xa83,0xa83,0xa83,0xa83,0xa83,0xa83,0xa80,0xa80,0xa80,0xa83,0xa83,0xa83,0x14cd,0x14cd,0x14cd,
+0x14cd,0x14cd,0x14cd,0x14cd,0x14cd,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0xaa4,0xaa4,0xaa4,0xaa4,
+0xaa4,0xaa4,0xa86,0xaa4,0xaa4,0xa89,0xa89,0xa89,0xa89,0xa89,0xa89,0xa89,0xa89,0xa89,0xa8c,0xa89,
+0xa9b,0xa9b,0xa9e,0xaa7,0xa95,0xa92,0xa9b,0xa98,0xaa7,0xcd2,0x4b,0x4b,0xaa1,0xaa1,0xaa1,0xaa1,
+0xaa1,0xaa1,0xaa1,0xaa1,0xaa1,0xaa1,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0xcd5,0xcd5,0xcd5,0xcd5,
+0xcd5,0xcd5,0xcd5,0xcd5,0xcd5,0xcd5,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0xab6,0xab6,0xb2e,0xb31,
+0xabc,0xb2b,0xab9,0xab6,0xabf,0xace,0xac2,0xad1,0xad1,0xad1,0xaad,0x1b09,0xac5,0xac5,0xac5,0xac5,
+0xac5,0xac5,0xac5,0xac5,0xac5,0xac5,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0xac8,0xac8,0xac8,0xac8,
+0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,
+0xac8,0xac8,0xac8,0xac8,0x18fc,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0xac8,0xac8,0xac8,0xac8,
+0xac8,0xac8,0xac8,0xac8,0xac8,0xab0,0xfc6,0x4e,0x4e,0x4e,0x4e,0x4e,0x117f,0x117f,0x117f,0x117f,
+0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x4e6,0x4e6,0x4e6,0x4e6,
+0x4e6,0x4e6,0x4e6,0x4e6,0x4e9,0x4e9,0x4e9,0x4e9,0x4e9,0x4e9,0x4e9,0x4e9,0x4e6,0x4e6,0x4e6,0x4e6,
+0x4e6,0x4e6,0x51,0x51,0x4e9,0x4e9,0x4e9,0x4e9,0x4e9,0x4e9,0x51,0x51,0x4e6,0x4e6,0x4e6,0x4e6,
+0x4e6,0x4e6,0x4e6,0x4e6,0x51,0x4e9,0x51,0x4e9,0x51,0x4e9,0x51,0x4e9,0x4e6,0x4e6,0x4e6,0x4e6,
+0x4e6,0x4e6,0x4e6,0x4e6,0x4e9,0x4e9,0x4e9,0x4e9,0x4e9,0x4e9,0x4e9,0x4e9,0x4e6,0x4e6,0x4e6,0x4e6,
+0x4e6,0x4e6,0x4e6,0x4e6,0x4e6,0x4e6,0x4e6,0x4e6,0x4e6,0x4e6,0x51,0x51,0x4e6,0x4e6,0x4e6,0x4e6,
+0x4e6,0x4e6,0x4e6,0x4e6,0x4e9,0x4e9,0x4e9,0x4e9,0x4e9,0x4e9,0x4e9,0x4e9,0x4e6,0x4e6,0x4e6,0x4e6,
+0x4e6,0x51,0x4e6,0x4e6,0x4e9,0x4e9,0x4e9,0x4e9,0x4e9,0x4e0,0x4e6,0x4e0,0x4e0,0x4dd,0x4e6,0x4e6,
+0x4e6,0x51,0x4e6,0x4e6,0x4e9,0x4e9,0x4e9,0x4e9,0x4e9,0x4dd,0x4dd,0x4dd,0x4e6,0x4e6,0x4e6,0x4e6,
+0x51,0x51,0x4e6,0x4e6,0x4e9,0x4e9,0x4e9,0x4e9,0x51,0x4dd,0x4dd,0x4dd,0x4e6,0x4e6,0x4e6,0x4e6,
+0x4e6,0x4e6,0x4e6,0x4e6,0x4e9,0x4e9,0x4e9,0x4e9,0x4e9,0x4dd,0x4dd,0x4dd,0x51,0x51,0x4e6,0x4e6,
+0x4e6,0x51,0x4e6,0x4e6,0x4e9,0x4e9,0x4e9,0x4e9,0x4e9,0x4e3,0x4e0,0x51,0xba6,0xba9,0xba9,0xba9,
+0xfcf,0x54,0x14a9,0x14a9,0x14a9,0x14a9,0x4f2,0x4f2,0x4f2,0x4f2,0x4f2,0x4f2,0x53d,0xbbb,0x57,0x57,
+0x6d8,0x53d,0x53d,0x53d,0x53d,0x53d,0x543,0x555,0x543,0x54f,0x549,0x6db,0x53a,0x6d5,0x6d5,0x6d5,
+0x6d5,0x53a,0x53a,0x53a,0x53a,0x53a,0x540,0x552,0x540,0x54c,0x546,0x57,0xdc2,0xdc2,0xdc2,0xdc2,
+0xdc2,0x1311,0x1311,0x1311,0x1311,0x1311,0x1311,0x1311,0x1311,0x57,0x57,0x57,0x1b0c,0x5a,0x5a,0x5a,
+0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x564,0x564,0x564,0x564,
+0x564,0x564,0x564,0x564,0x564,0x564,0x564,0x564,0x564,0x561,0x561,0x561,0x561,0x564,0xadd,0xadd,
+0xbc1,0xbc7,0xbc7,0xbc4,0xbc4,0xbc4,0xbc4,0xdc8,0xed9,0xed9,0xed9,0xed9,0x1113,0x5d,0x5d,0x5d,
+0x5d,0x5d,0x5d,0x5d,0x5d,0x5d,0x5d,0x5d,0x5d,0x5d,0x5d,0x5d,0x594,0x594,0x594,0xae6,
+0xee2,0xfd5,0xfd5,0xfd5,0xfd5,0x126f,0x16dd,0x16dd,0x60,0x60,0x60,0x60,0x702,0x702,0x702,0x702,
+0x702,0x702,0x702,0x702,0x702,0x702,0x5a0,0x5a0,0x59d,0x59d,0x59d,0x59d,0x5c1,0x5c1,0x5c1,0x5c1,
+0x5c1,0xaef,0xaef,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,
+0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x5c4,0x5c4,0x5c4,0x5c4,
+0x5c4,0x5c4,0x5c4,0x5c4,0x5c4,0x5c4,0x5c4,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
+0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0xb0a,0xb0a,0xb0a,0xb0a,
+0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,
+0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0x69,0xb0a,0xb0a,0xb0a,0xb0a,0xb0d,0xb0a,0xb0a,0xb0a,0xb0a,
+0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0d,
+0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0xb10,0xb10,0xb10,0xb10,
+0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,
+0xb10,0xb10,0x6c,0x6c,0x6c,0x6c,0x6c,0x6c,0x6c,0x6c,0x6c,0x6c,0x72,0x822,0x81c,0x822,
+0x81c,0x822,0x81c,0x822,0x81c,0x822,0x81c,0x81c,0x81f,0x81c,0x81f,0x81c,0x81f,0x81c,0x81f,0x81c,
+0x81f,0x81c,0x81f,0x81c,0x81f,0x81c,0x81f,0x81c,0x81f,0x81c,0x81f,0x81c,0x81c,0x81c,0x81c,0x822,
+0x81c,0x822,0x81c,0x822,0x81c,0x81c,0x81c,0x81c,0x81c,0x81c,0x822,0x81c,0x81c,0x81c,0x81c,0x81c,
+0x81f,0xc60,0xc60,0x72,0x72,0x936,0x936,0x8fd,0x8fd,0x825,0x828,0xc5d,0x75,0x75,0x75,0x75,
+0x75,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,
+0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x1101,0x18c3,0x19aa,
+0x78,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,
+0x83d,0x83d,0x83d,0x78,0x906,0x906,0x909,0x909,0x909,0x909,0x909,0x909,0x909,0x909,0x909,0x909,
+0x909,0x909,0x909,0x909,0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,
+0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,
+0x846,0xd5c,0xd5c,0x7b,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,
+0xb22,0x7e,0x7e,0x7e,0xb28,0xb28,0xb28,0xb28,0xb28,0xb28,0xb28,0xb28,0xb28,0xb28,0xb28,0xb28,
+0xb28,0xb28,0xb28,0xb28,0xb28,0xc69,0xb28,0xb28,0xb28,0xc69,0xb28,0x81,0x81,0x81,0x81,0x81,
+0x81,0x81,0x81,0x81,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,
+0x11a6,0x11a6,0x11a6,0x11a6,0x9c0,0x9c0,0x9c0,0x9c0,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
+0x84,0x84,0x84,0x84,0x121b,0x121b,0x121b,0x121b,0x121b,0x121b,0x121b,0x121b,0x121b,0x121b,0x121b,0x121b,
+0x121b,0x121b,0x121b,0x121b,0x609,0x609,0x609,0x609,0x609,0x609,0x609,0x87,0x87,0x87,0x87,0x87,
+0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x5f7,0x5f7,0x5f7,0x5f7,0x5f7,0x87,0x87,0x87,0x87,
+0x87,0xafb,0x5fa,0x600,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x5fd,0x600,0x600,
+0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x87,0x600,0x600,0x600,0x600,
+0x600,0x87,0x600,0x87,0x600,0x600,0x87,0x600,0x600,0x87,0x600,0x600,0x600,0x600,0x600,0x600,
+0x600,0x600,0x600,0x603,0x615,0x60f,0x615,0x60f,0x612,0x618,0x615,0x60f,0x612,0x618,0x615,0x60f,
+0x612,0x618,0x615,0x60f,0x1323,0x1323,0x1b0f,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
+0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x615,0x60f,0x612,0x618,0x615,0x60f,0x615,0x60f,0x615,
+0x60f,0x615,0x615,0x60f,0x60f,0x60f,0x60f,0x612,0x60f,0x60f,0x612,0x60f,0x612,0x612,0x612,0x60f,
+0x612,0x612,0x612,0x612,0x8a,0x8a,0x612,0x612,0x612,0x612,0x60f,0x60f,0x612,0x60f,0x60f,0x60f,
+0x60f,0x612,0x60f,0x60f,0x60f,0x60f,0x60f,0x612,0x612,0x612,0x60f,0x60f,0x8a,0x8a,0x8a,0x8a,
+0x8a,0x8a,0x8a,0x1b0f,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,
+0xb46,0xb46,0xb46,0xb46,0x85e,0x870,0x86d,0x870,0x86d,0xc7e,0xc7e,0xd68,0xd65,0x861,0x861,0x861,
+0x861,0x873,0x873,0x873,0x88b,0x88e,0x89d,0x8d,0x891,0x894,0x8a0,0x8a0,0x888,0x87f,0x879,0x87f,
+0x879,0x87f,0x879,0x87c,0x87c,0x897,0x897,0x89a,0x897,0x897,0x897,0x8d,0x897,0x885,0x882,0x87c,
+0x8d,0x8d,0x8d,0x8d,0x621,0x62d,0x621,0xbfa,0x621,0x90,0x621,0x62d,0x621,0x62d,0x621,0x62d,
+0x621,0x62d,0x621,0x62d,0x62d,0x62a,0x624,0x627,0x62d,0x62a,0x624,0x627,0x62d,0x62a,0x624,0x627,
+0x62d,0x62a,0x624,0x62a,0x624,0x62a,0x624,0x627,0x62d,0x62a,0x624,0x62a,0x624,0x62a,0x624,0x62a,
+0x624,0x90,0x90,0x61e,0x75f,0x762,0x777,0x77a,0x759,0x762,0x762,0x96,0x741,0x744,0x744,0x744,
+0x744,0x741,0x741,0x96,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0xafe,0xafe,0xafe,
+0x9c3,0x73b,0x630,0x630,0x96,0x789,0x768,0x759,0x762,0x75f,0x759,0x76b,0x75c,0x756,0x759,0x777,
+0x76e,0x765,0x786,0x759,0x783,0x783,0x783,0x783,0x783,0x783,0x783,0x783,0x783,0x783,0x774,0x771,
+0x777,0x777,0x777,0x789,0x74a,0x747,0x747,0x747,0x747,0x747,0x747,0x747,0x747,0x747,0x747,0x747,
+0x747,0x747,0x747,0x747,0x747,0x747,0x747,0x747,0x747,0x747,0x747,0x747,0x747,0x747,0x747,0x747,
+0x747,0x747,0x747,0x96,0x96,0x96,0x747,0x747,0x747,0x747,0x747,0x747,0x96,0x96,0x747,0x747,
+0x747,0x747,0x747,0x747,0x96,0x96,0x747,0x747,0x747,0x747,0x747,0x747,0x96,0x96,0x747,0x747,
+0x747,0x96,0x96,0x96,0xb49,0xb49,0xb49,0xb49,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,
+0x99,0x1860,0x1860,0x1860,0xb4f,0xb4f,0xb4f,0xb4f,0xb4f,0xb4f,0xb4f,0xb4f,0xb4f,0xb4f,0xb4f,0xb4f,
+0xb4f,0xb4f,0xb4f,0xb4f,0xb4f,0xb4f,0xb4f,0x9c,0x9c,0x9c,0x9c,0x9c,0x1626,0x1626,0x1626,0x1626,
+0x1626,0x1626,0x1626,0x1626,0x1626,0x1626,0x1626,0x1626,0x1626,0x1626,0x1626,0x1626,0xb58,0xb58,0xb58,0xb58,
+0xb58,0xb58,0xb58,0xb58,0xb58,0xb58,0xb58,0xb58,0xb58,0xb58,0xb58,0xb58,0xb58,0xb58,0xb58,0xb58,
+0xb58,0xb58,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0xb64,0xb64,0xb64,0xb64,
+0xb64,0xb64,0xb64,0xa2,0xa2,0xfe1,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,
+0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0x16e3,0x16e3,0x16e3,0x16e3,
+0x16e3,0x16e3,0x16e3,0x16e3,0x16e3,0x1b12,0x1b12,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,
+0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xb7c,0xb7c,0xb7c,0xb7c,
+0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,
+0xb79,0xa5,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb7c,0xb7c,0xb79,0xb79,
+0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,
+0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb7c,0xa5,0xb7c,0xb7c,0xa5,0xa5,0xb7c,0xa5,
+0xa5,0xb7c,0xb7c,0xa5,0xa5,0xb7c,0xb7c,0xb7c,0xb7c,0xa5,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,
+0xb7c,0xb7c,0xb79,0xb79,0xb79,0xb79,0xa5,0xb79,0xa5,0xb79,0xb79,0xb79,0xb79,0xcf0,0xb79,0xb79,
+0xa5,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb7c,0xb7c,0xb7c,0xb7c,
+0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb79,0xb79,0xb79,0xb79,
+0xb7c,0xb7c,0xa5,0xb7c,0xb7c,0xb7c,0xb7c,0xa5,0xa5,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,
+0xb7c,0xa5,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xa5,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,
+0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,
+0xb79,0xb79,0xb79,0xb79,0xb7c,0xb7c,0xa5,0xb7c,0xb7c,0xb7c,0xb7c,0xa5,0xb7c,0xb7c,0xb7c,0xb7c,
+0xb7c,0xa5,0xb7c,0xa5,0xa5,0xa5,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xa5,0xb79,0xb79,
+0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xdda,0xdda,0xa5,0xa5,
+0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,
+0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb79,0xb79,0xb79,0xb73,0xb79,0xb79,0xb79,0xb79,
+0xb79,0xb79,0xef1,0xeee,0xa5,0xa5,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,
+0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xa8,0xb82,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,
 0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,
-0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xbf7,0xbf7,0xbf7,0xbf7,0xbf7,0xbf7,0xbf7,0xbf7,
-0xbf7,0xbf7,0xbf7,0xbf7,0xbf7,0x1b06,0xbf7,0xbf7,0xbf7,0xbf7,0xbf1,0xbf1,0xbf4,0x1b03,0xab,0xab,
-0xab,0xab,0xab,0xab,0xab,0xab,0xab,0x1b06,0xc00,0xc00,0xc00,0xc00,0xc00,0xc00,0xc00,0xc00,
-0xc00,0xc00,0xc00,0xc00,0xc00,0xc00,0xc00,0xc00,0xc00,0xc00,0xbfa,0xbfa,0xbfd,0xc60,0xc60,0xae,
-0xae,0xae,0xae,0xae,0xae,0xae,0xae,0xae,0xc06,0xc06,0xc06,0xc06,0xc06,0xc06,0xc06,0xc06,
-0xc06,0xc06,0xc06,0xc06,0xc06,0xc06,0xc06,0xc06,0xc06,0xc06,0xc03,0xc03,0xb1,0xb1,0xb1,0xb1,
-0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xc0c,0xc0c,0xc0c,0xc0c,0xc0c,0xc0c,0xc0c,0xc0c,
-0xc0c,0xc0c,0xc0c,0xc0c,0xc0c,0xb4,0xc0c,0xc0c,0xc0c,0xb4,0xc09,0xc09,0xb4,0xb4,0xb4,0xb4,
-0xb4,0xb4,0xb4,0xb4,0xb4,0xb4,0xb4,0xb4,0xcf0,0xcf0,0xcf0,0xcf0,0xcf0,0xcf0,0xcf0,0xcf0,
-0xcf0,0xcf0,0xcf0,0xcf0,0xcf0,0xcf0,0xcf0,0xcf0,0xcf0,0xcf0,0xcf0,0xcf0,0xcf0,0xcf0,0xcf0,0xcf0,
-0xcf0,0xcf0,0xcf0,0xcf0,0xcf0,0x14d6,0x14d6,0xb7,0xce1,0xce1,0xce1,0xced,0xced,0xced,0xced,0xce1,
-0xce1,0xced,0xced,0xced,0xb7,0xb7,0xb7,0xb7,0xced,0xced,0xce1,0xced,0xced,0xced,0xced,0xced,
-0xced,0xce4,0xce4,0xce4,0xb7,0xb7,0xb7,0xb7,0xce7,0xb7,0xb7,0xb7,0xcf3,0xcf3,0xcea,0xcea,
-0xcea,0xcea,0xcea,0xcea,0xcea,0xcea,0xcea,0xcea,0xcf6,0xcf6,0xcf6,0xcf6,0xcf6,0xcf6,0xcf6,0xcf6,
-0xcf6,0xcf6,0xcf6,0xcf6,0xcf6,0xcf6,0xcf6,0xcf6,0xcf6,0xcf6,0xba,0xba,0xcf6,0xcf6,0xcf6,0xcf6,
-0xcf6,0xba,0xba,0xba,0xba,0xba,0xba,0xba,0xba,0xba,0xba,0xba,0x14d9,0x14d9,0x14d9,0x14d9,
-0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,
-0xbd,0xbd,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,
-0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0xbd,0x1a52,0x14d9,0x14d9,0x14d9,0x14d9,
-0x14d9,0x14d9,0x14d9,0x14d9,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,
-0xc0,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,
-0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xc0,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,
-0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xc0,0xd1a,0xd1a,0xc0,0xd1a,
-0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xc0,0xc0,
-0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xc0,0xc0,
+0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xc09,0xc09,0xc09,0xc09,0xc09,0xc09,0xc09,0xc09,
+0xc09,0xc09,0xc09,0xc09,0xc09,0x1b18,0xc09,0xc09,0xc09,0xc09,0xc03,0xc03,0xc06,0x1b15,0xab,0xab,
+0xab,0xab,0xab,0xab,0xab,0xab,0xab,0x1b18,0xc12,0xc12,0xc12,0xc12,0xc12,0xc12,0xc12,0xc12,
+0xc12,0xc12,0xc12,0xc12,0xc12,0xc12,0xc12,0xc12,0xc12,0xc12,0xc0c,0xc0c,0xc0f,0xc72,0xc72,0xae,
+0xae,0xae,0xae,0xae,0xae,0xae,0xae,0xae,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,
+0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc15,0xc15,0xb1,0xb1,0xb1,0xb1,
+0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xc1e,0xc1e,0xc1e,0xc1e,0xc1e,0xc1e,0xc1e,0xc1e,
+0xc1e,0xc1e,0xc1e,0xc1e,0xc1e,0xb4,0xc1e,0xc1e,0xc1e,0xb4,0xc1b,0xc1b,0xb4,0xb4,0xb4,0xb4,
+0xb4,0xb4,0xb4,0xb4,0xb4,0xb4,0xb4,0xb4,0xd02,0xd02,0xd02,0xd02,0xd02,0xd02,0xd02,0xd02,
+0xd02,0xd02,0xd02,0xd02,0xd02,0xd02,0xd02,0xd02,0xd02,0xd02,0xd02,0xd02,0xd02,0xd02,0xd02,0xd02,
+0xd02,0xd02,0xd02,0xd02,0xd02,0x14e8,0x14e8,0xb7,0xcf3,0xcf3,0xcf3,0xcff,0xcff,0xcff,0xcff,0xcf3,
+0xcf3,0xcff,0xcff,0xcff,0xb7,0xb7,0xb7,0xb7,0xcff,0xcff,0xcf3,0xcff,0xcff,0xcff,0xcff,0xcff,
+0xcff,0xcf6,0xcf6,0xcf6,0xb7,0xb7,0xb7,0xb7,0xcf9,0xb7,0xb7,0xb7,0xd05,0xd05,0xcfc,0xcfc,
+0xcfc,0xcfc,0xcfc,0xcfc,0xcfc,0xcfc,0xcfc,0xcfc,0xd08,0xd08,0xd08,0xd08,0xd08,0xd08,0xd08,0xd08,
+0xd08,0xd08,0xd08,0xd08,0xd08,0xd08,0xd08,0xd08,0xd08,0xd08,0xba,0xba,0xd08,0xd08,0xd08,0xd08,
+0xd08,0xba,0xba,0xba,0xba,0xba,0xba,0xba,0xba,0xba,0xba,0xba,0x14eb,0x14eb,0x14eb,0x14eb,
+0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,
+0xbd,0xbd,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,
+0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0xbd,0x1a64,0x14eb,0x14eb,0x14eb,0x14eb,
+0x14eb,0x14eb,0x14eb,0x14eb,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,
+0xc0,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,
+0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xc0,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,
+0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xc0,0xd2c,0xd2c,0xc0,0xd2c,
+0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xc0,0xc0,
+0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xc0,0xc0,
 0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,
 0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,
-0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,
-0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xc3,0xc3,0xc3,0xc3,0xc3,
-0xd5c,0xd5c,0xd62,0xc6,0xc6,0xc6,0xc6,0xd59,0xd59,0xd59,0xd59,0xd59,0xd59,0xd59,0xd59,0xd59,
-0xd59,0xd59,0xd59,0xd59,0xd59,0xd59,0xd59,0xd59,0xd59,0xd59,0xd59,0xd59,0xd59,0xd59,0xd59,0xd59,
-0xc6,0xc6,0xc6,0xd5f,0xd5f,0xd5f,0xd5f,0xd5f,0xd5f,0xd5f,0xd5f,0xd5f,0xd23,0xd23,0xd23,0xd23,
-0xd23,0xd23,0xd23,0xd23,0xd23,0xd23,0xd23,0xd23,0xd23,0xd23,0xd23,0xd23,0xd23,0xd23,0xd23,0xd23,
-0xd23,0xd23,0xd23,0xd23,0xd23,0xd23,0xd23,0xd23,0xd23,0xd23,0xc9,0xd20,0xd2c,0xd2c,0xd2c,0xd2c,
-0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,
-0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xd2c,0xcc,0xcc,0xd29,0xd29,0xd29,0xd29,
-0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0x1812,0x1812,0x1812,0x1812,
-0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0xd2f,0xd2f,0xd2f,0xd2f,
-0xd2f,0xd2f,0xcf,0xcf,0xd2f,0xcf,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,
-0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xcf,0xd2f,
-0xd2f,0xcf,0xcf,0xcf,0xd2f,0xcf,0xcf,0xd2f,0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,
-0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,0xd2,
-0xd2,0xd2,0xd2,0xd2,0xd2,0xd2,0xd2,0xd2,0xde3,0xde3,0xde3,0xde3,0xde3,0xde3,0xde3,0xde3,
-0xde3,0xde3,0xde3,0x14dc,0x14dc,0x1788,0x1788,0xd8,0x10cb,0x10cb,0x10cb,0x10cb,0x10cb,0x10cb,0x10cb,0x10cb,
-0x10cb,0x10cb,0x10cb,0x10cb,0x1a61,0x129,0x129,0x129,0xdf5,0xdf5,0xdf5,0xdf5,0xdf5,0xdf5,0xdf5,0xdf5,
-0xdf5,0xdf5,0xdf5,0xdf5,0xdf5,0xdf5,0xdf5,0xdf5,0xdf5,0xdf5,0xdf5,0xdf5,0xdf5,0xdf5,0xdf5,0xdec,
-0xdec,0xdf2,0xdf2,0xdec,0xdb,0xdb,0xdef,0xdef,0x10fb,0x10fb,0x10fb,0x10fb,0xde,0xde,0xde,0xde,
-0xde,0xde,0xde,0xde,0xde,0xde,0xde,0xde,0xc5d,0xc5d,0xc5d,0xc5d,0xc5d,0xc5d,0xc5d,0xc5d,
-0xc5d,0xc5d,0xc5d,0xc5d,0xc5d,0xc5d,0xc5d,0xc5d,0xe07,0xe04,0xe07,0xe04,0xe04,0xdfb,0xdfb,0xdfb,
-0xdfb,0xdfb,0xdfb,0x1146,0x1143,0x1146,0x1143,0x1140,0x1140,0x1140,0x13d4,0x13d1,0xe1,0xe1,0xe1,0xe1,
-0xe1,0xe01,0xdfe,0xdfe,0xdfe,0xdfb,0xe01,0xdfe,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,
-0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe4,
-0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe4,
-0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe4,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe4,
-0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe4,0xe10,0xe10,0xe10,0xe10,0xe10,0xe10,0xe10,0xe10,
-0xe10,0xe10,0xe10,0xe10,0xe10,0xe10,0xe10,0xe10,0xe0d,0xe0d,0xe0d,0xe0d,0xe0d,0xe0d,0xe0d,0xe0d,
-0xe0d,0xe0d,0xe7,0xe7,0xe7,0xe7,0xe7,0xe7,0xe13,0xe13,0xe13,0xe13,0xe13,0xe13,0xea,0x13d7,
-0xea,0xea,0xea,0xea,0xea,0x13d7,0xea,0xea,0xe6a,0xe6a,0xe6a,0xe6a,0xe6a,0xe6a,0xe6a,0xe6a,
-0xe6a,0xe6a,0xe6a,0xe6a,0xe6a,0xe6a,0xe6a,0xe6a,0xe2b,0xe1f,0xe1f,0xe1f,0xed,0xe1f,0xe1f,0xed,
-0xed,0xed,0xed,0xed,0xe1f,0xe1f,0xe1f,0xe1f,0xe2b,0xe2b,0xe2b,0xe2b,0xed,0xe2b,0xe2b,0xe2b,
-0xed,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,
-0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0x18f3,0x18f3,0xed,0xed,0xe1c,0xe1c,0xe1c,0xed,
-0xed,0xed,0xed,0xe22,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0x18f0,0xed,0xed,0xed,
-0xed,0xed,0xed,0xed,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe2e,0xe2e,0xe25,0xed,0xed,0xed,
-0xed,0xed,0xed,0xed,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0x114c,0x114c,
-0xf0,0xf0,0xf0,0xf0,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe3d,0xe3d,0xe3d,0xe3a,0xe3a,0xe3d,0xe3a,
-0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,
-0xe37,0xe37,0xe37,0xe37,0xe37,0xe37,0xe37,0xe37,0xe37,0xe37,0x1149,0xf0,0xf0,0xf0,0xe34,0xe34,
-0xe43,0xe43,0xe43,0xe43,0xf3,0xf3,0xf3,0xf3,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,
-0xe40,0xe43,0xe43,0xe43,0xe43,0xe43,0xf3,0xf3,0xf3,0xf3,0xf3,0xf3,0xf3,0xf3,0xf3,0xf3,
-0x14eb,0x14f1,0x14ee,0x1833,0x178e,0x1857,0x1857,0x1857,0x1857,0x1857,0x18f9,0x18f6,0x18fc,0x18f6,0x18fc,0x19b9,
-0x1a55,0x1a55,0x1a55,0x1b18,0x1b18,0x1b12,0x1b0f,0x1b12,0x1b0f,0x1b12,0x1b0f,0x1b12,0x1b0f,0x1b15,0xf6,0xf6,
+0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,
+0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xc3,0xc3,0xc3,0xc3,0xc3,
+0xd6e,0xd6e,0xd74,0xc6,0xc6,0xc6,0xc6,0xd6b,0xd6b,0xd6b,0xd6b,0xd6b,0xd6b,0xd6b,0xd6b,0xd6b,
+0xd6b,0xd6b,0xd6b,0xd6b,0xd6b,0xd6b,0xd6b,0xd6b,0xd6b,0xd6b,0xd6b,0xd6b,0xd6b,0xd6b,0xd6b,0xd6b,
+0xc6,0xc6,0xc6,0xd71,0xd71,0xd71,0xd71,0xd71,0xd71,0xd71,0xd71,0xd71,0xd35,0xd35,0xd35,0xd35,
+0xd35,0xd35,0xd35,0xd35,0xd35,0xd35,0xd35,0xd35,0xd35,0xd35,0xd35,0xd35,0xd35,0xd35,0xd35,0xd35,
+0xd35,0xd35,0xd35,0xd35,0xd35,0xd35,0xd35,0xd35,0xd35,0xd35,0xc9,0xd32,0xd3e,0xd3e,0xd3e,0xd3e,
+0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,
+0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xcc,0xcc,0xd3b,0xd3b,0xd3b,0xd3b,
+0xd3b,0xd3b,0xd3b,0xd3b,0xd3b,0xd3b,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0x1824,0x1824,0x1824,0x1824,
+0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0xd41,0xd41,0xd41,0xd41,
+0xd41,0xd41,0xcf,0xcf,0xd41,0xcf,0xd41,0xd41,0xd41,0xd41,0xd41,0xd41,0xd41,0xd41,0xd41,0xd41,
+0xd41,0xd41,0xd41,0xd41,0xd41,0xd41,0xd41,0xd41,0xd41,0xd41,0xd41,0xd41,0xd41,0xd41,0xcf,0xd41,
+0xd41,0xcf,0xcf,0xcf,0xd41,0xcf,0xcf,0xd41,0xd44,0xd44,0xd44,0xd44,0xd44,0xd44,0xd44,0xd44,
+0xd44,0xd44,0xd44,0xd44,0xd44,0xd44,0xd44,0xd44,0xd44,0xd44,0xd44,0xd44,0xd44,0xd44,0xd44,0xd2,
+0xd2,0xd2,0xd2,0xd2,0xd2,0xd2,0xd2,0xd2,0xdf5,0xdf5,0xdf5,0xdf5,0xdf5,0xdf5,0xdf5,0xdf5,
+0xdf5,0xdf5,0xdf5,0x14ee,0x14ee,0x179a,0x179a,0xd8,0x10e0,0x10e0,0x10e0,0x10e0,0x10e0,0x10e0,0x10e0,0x10e0,
+0x10e0,0x10e0,0x10e0,0x10e0,0x1a73,0x129,0x129,0x129,0xe07,0xe07,0xe07,0xe07,0xe07,0xe07,0xe07,0xe07,
+0xe07,0xe07,0xe07,0xe07,0xe07,0xe07,0xe07,0xe07,0xe07,0xe07,0xe07,0xe07,0xe07,0xe07,0xe07,0xdfe,
+0xdfe,0xe04,0xe04,0xdfe,0xdb,0xdb,0xe01,0xe01,0x1110,0x1110,0x1110,0x1110,0xde,0xde,0xde,0xde,
+0xde,0xde,0xde,0xde,0xde,0xde,0xde,0xde,0xc6f,0xc6f,0xc6f,0xc6f,0xc6f,0xc6f,0xc6f,0xc6f,
+0xc6f,0xc6f,0xc6f,0xc6f,0xc6f,0xc6f,0xc6f,0xc6f,0xe19,0xe16,0xe19,0xe16,0xe16,0xe0d,0xe0d,0xe0d,
+0xe0d,0xe0d,0xe0d,0x115b,0x1158,0x115b,0x1158,0x1155,0x1155,0x1155,0x13e6,0x13e3,0xe1,0xe1,0xe1,0xe1,
+0xe1,0xe13,0xe10,0xe10,0xe10,0xe0d,0xe13,0xe10,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,
+0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe4,
+0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe4,
+0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe4,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe4,
+0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe4,0xe22,0xe22,0xe22,0xe22,0xe22,0xe22,0xe22,0xe22,
+0xe22,0xe22,0xe22,0xe22,0xe22,0xe22,0xe22,0xe22,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,0xe1f,
+0xe1f,0xe1f,0xe7,0xe7,0xe7,0xe7,0xe7,0xe7,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xea,0x13e9,
+0xea,0xea,0xea,0xea,0xea,0x13e9,0xea,0xea,0xe7c,0xe7c,0xe7c,0xe7c,0xe7c,0xe7c,0xe7c,0xe7c,
+0xe7c,0xe7c,0xe7c,0xe7c,0xe7c,0xe7c,0xe7c,0xe7c,0xe3d,0xe31,0xe31,0xe31,0xed,0xe31,0xe31,0xed,
+0xed,0xed,0xed,0xed,0xe31,0xe31,0xe31,0xe31,0xe3d,0xe3d,0xe3d,0xe3d,0xed,0xe3d,0xe3d,0xe3d,
+0xed,0xe3d,0xe3d,0xe3d,0xe3d,0xe3d,0xe3d,0xe3d,0xe3d,0xe3d,0xe3d,0xe3d,0xe3d,0xe3d,0xe3d,0xe3d,
+0xe3d,0xe3d,0xe3d,0xe3d,0xe3d,0xe3d,0xe3d,0xe3d,0x1905,0x1905,0xed,0xed,0xe2e,0xe2e,0xe2e,0xed,
+0xed,0xed,0xed,0xe34,0xe37,0xe37,0xe37,0xe37,0xe37,0xe37,0xe37,0xe37,0x1902,0xed,0xed,0xed,
+0xed,0xed,0xed,0xed,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe40,0xe40,0xe37,0xed,0xed,0xed,
+0xed,0xed,0xed,0xed,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0x1161,0x1161,
+0xf0,0xf0,0xf0,0xf0,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4f,0xe4f,0xe4f,0xe4c,0xe4c,0xe4f,0xe4c,
+0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,
+0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0x115e,0xf0,0xf0,0xf0,0xe46,0xe46,
+0xe55,0xe55,0xe55,0xe55,0xf3,0xf3,0xf3,0xf3,0xe55,0xe55,0xe55,0xe55,0xe55,0xe55,0xe55,0xe55,
+0xe52,0xe55,0xe55,0xe55,0xe55,0xe55,0xf3,0xf3,0xf3,0xf3,0xf3,0xf3,0xf3,0xf3,0xf3,0xf3,
+0x14fd,0x1503,0x1500,0x1845,0x17a0,0x1869,0x1869,0x1869,0x1869,0x1869,0x190b,0x1908,0x190e,0x1908,0x190e,0x19cb,
+0x1a67,0x1a67,0x1a67,0x1b2a,0x1b2a,0x1b24,0x1b21,0x1b24,0x1b21,0x1b24,0x1b21,0x1b24,0x1b21,0x1b27,0xf6,0xf6,
 0xf6,0xf6,0xf6,0xf6,0xf6,0xf6,0xf6,0xf6,0xf6,0xf6,0xf6,0xf6,0xf6,0xf6,0xf6,0xf6,
 0xf6,0xf6,0xf6,0xf6,0xf6,0xf6,0xf6,0xf6,0xf6,0xf6,0xf6,0xf6,0xf6,0xf6,0xf6,0xf6,
-0xe67,0xe67,0xe67,0xe64,0xe64,0xe5b,0xe5b,0xe64,0xe61,0xe61,0xe61,0xe61,0x1a58,0xf9,0xf9,0xf9,
-0x12ba,0x12ba,0x12ba,0x12bd,0x12bd,0x12bd,0x12b4,0x12b4,0x12b7,0x12b4,0x14d,0x14d,0x14d,0x14d,0x14d,0x14d,
-0xe6a,0xe6a,0xe6a,0xe6a,0xe6a,0xe6a,0x13e3,0x13e3,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xe6d,
-0x1323,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0x1320,
-0xc30,0xc30,0xc30,0xc30,0xc30,0xc30,0xc30,0xc30,0xc30,0xc30,0xc30,0xc30,0xc30,0xc30,0xc30,0xc30,
-0xe9a,0xe8b,0xe85,0xe97,0xe94,0xe8e,0xe8e,0xe9d,0xe88,0xe91,0xff,0xff,0xff,0xff,0xff,0xff,
-0xf21,0xf21,0xf0c,0xf21,0xf24,0xf27,0xf27,0xf27,0xf27,0xf27,0xf27,0xf27,0x1b1b,0x105,0x105,0x105,
-0xf1b,0xf1b,0xf1b,0xf1b,0xf1b,0xf1b,0xf1b,0xf1b,0xf1b,0xf1b,0xf2d,0xf2d,0xf12,0xf18,0xf2d,0xf2d,
-0xf15,0xf12,0xf12,0xf12,0xf12,0xf12,0xf12,0xf12,0xf12,0xf12,0xf12,0xf0f,0xf0f,0xf0f,0xf0f,0xf0f,
-0xf0f,0xf0f,0xf0f,0xf0f,0xf12,0xf12,0xf12,0xf12,0xf12,0xf12,0xf12,0xf12,0xf12,0x1b1e,0x1b1e,0x105,
-0x1b27,0x1b21,0x19bf,0x19bc,0x19bf,0x19bf,0x19bf,0x1a5e,0x1a5b,0x1a5e,0x1a5b,0x108,0x108,0x108,0x108,0x108,
-0x1b27,0x1b21,0x108,0x1b21,0x108,0x1b21,0x1b27,0x1b21,0x1b27,0x1b21,0x108,0x108,0x108,0x108,0x108,0x108,
-0x108,0x108,0x108,0x108,0x108,0x108,0x108,0x108,0x108,0x108,0x108,0x108,0x108,0x108,0x1b24,0x1b24,
-0x1b24,0x1a5e,0x1a5b,0x14fa,0x13ec,0x13ec,0x1326,0x1026,0x1026,0x1026,0x1026,0x1026,0xf3c,0xf3c,0xf3c,0xf3c,
-0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,
-0xf39,0xf39,0xf3f,0xf3f,0x10b,0x10b,0x10b,0x10b,0x10b,0x10b,0x10b,0x10b,0xf48,0xf48,0xf48,0xf48,
-0xf48,0xf48,0xf48,0xf48,0xf48,0xf48,0xf48,0xf48,0xf48,0xf48,0xf48,0xf48,0xf48,0xf48,0xf48,0xf48,
-0xf48,0xf48,0xf42,0xf42,0xf42,0xf42,0x1155,0x1155,0x10e,0x10e,0x10e,0xf45,0x1500,0x1500,0x1500,0x1500,
-0x1500,0x1500,0x1500,0x1500,0x1500,0x1500,0x1500,0x1500,0x1500,0x1500,0x1500,0x1500,0x1500,0x1500,0x1500,0x1500,
-0x1500,0x1500,0x1500,0x1500,0x1500,0x16e0,0x111,0x111,0x111,0x111,0x111,0x111,0x111,0x111,0x111,0x111,
+0xe79,0xe79,0xe79,0xe76,0xe76,0xe6d,0xe6d,0xe76,0xe73,0xe73,0xe73,0xe73,0x1a6a,0xf9,0xf9,0xf9,
+0x12cc,0x12cc,0x12cc,0x12cf,0x12cf,0x12cf,0x12c6,0x12c6,0x12c9,0x12c6,0x14d,0x14d,0x14d,0x14d,0x14d,0x14d,
+0xe7c,0xe7c,0xe7c,0xe7c,0xe7c,0xe7c,0x13f5,0x13f5,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xe7f,
+0x1335,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0x1332,
+0xc42,0xc42,0xc42,0xc42,0xc42,0xc42,0xc42,0xc42,0xc42,0xc42,0xc42,0xc42,0xc42,0xc42,0xc42,0xc42,
+0xeac,0xe9d,0xe97,0xea9,0xea6,0xea0,0xea0,0xeaf,0xe9a,0xea3,0xff,0xff,0xff,0xff,0xff,0xff,
+0xf33,0xf33,0xf1e,0xf33,0xf36,0xf39,0xf39,0xf39,0xf39,0xf39,0xf39,0xf39,0x1b2d,0x105,0x105,0x105,
+0xf2d,0xf2d,0xf2d,0xf2d,0xf2d,0xf2d,0xf2d,0xf2d,0xf2d,0xf2d,0xf3f,0xf3f,0xf24,0xf2a,0xf3f,0xf3f,
+0xf27,0xf24,0xf24,0xf24,0xf24,0xf24,0xf24,0xf24,0xf24,0xf24,0xf24,0xf21,0xf21,0xf21,0xf21,0xf21,
+0xf21,0xf21,0xf21,0xf21,0xf24,0xf24,0xf24,0xf24,0xf24,0xf24,0xf24,0xf24,0xf24,0x1b30,0x1b30,0x105,
+0x1b39,0x1b33,0x19d1,0x19ce,0x19d1,0x19d1,0x19d1,0x1a70,0x1a6d,0x1a70,0x1a6d,0x108,0x108,0x108,0x108,0x108,
+0x1b39,0x1b33,0x108,0x1b33,0x108,0x1b33,0x1b39,0x1b33,0x1b39,0x1b33,0x108,0x108,0x108,0x108,0x108,0x108,
+0x108,0x108,0x108,0x108,0x108,0x108,0x108,0x108,0x108,0x108,0x108,0x108,0x108,0x108,0x1b36,0x1b36,
+0x1b36,0x1a70,0x1a6d,0x150c,0x13fe,0x13fe,0x1338,0x103b,0x103b,0x103b,0x103b,0x103b,0xf4e,0xf4e,0xf4e,0xf4e,
+0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,
+0xf4b,0xf4b,0xf51,0xf51,0x10b,0x10b,0x10b,0x10b,0x10b,0x10b,0x10b,0x10b,0xf5a,0xf5a,0xf5a,0xf5a,
+0xf5a,0xf5a,0xf5a,0xf5a,0xf5a,0xf5a,0xf5a,0xf5a,0xf5a,0xf5a,0xf5a,0xf5a,0xf5a,0xf5a,0xf5a,0xf5a,
+0xf5a,0xf5a,0xf54,0xf54,0xf54,0xf54,0x116a,0x116a,0x10e,0x10e,0x10e,0xf57,0x1512,0x1512,0x1512,0x1512,
+0x1512,0x1512,0x1512,0x1512,0x1512,0x1512,0x1512,0x1512,0x1512,0x1512,0x1512,0x1512,0x1512,0x1512,0x1512,0x1512,
+0x1512,0x1512,0x1512,0x1512,0x1512,0x16f2,0x111,0x111,0x111,0x111,0x111,0x111,0x111,0x111,0x111,0x111,
 0x111,0x111,0x111,0x111,0x111,0x111,0x111,0x111,0x111,0x111,0x111,0x111,0x111,0x111,0x111,0x111,
-0x111,0x111,0x111,0x111,0x111,0x111,0x111,0x111,0xf51,0xf51,0xf51,0x1506,0x1506,0x1506,0x1506,0x1506,
-0x1506,0x1506,0x1506,0x1506,0x1506,0x1506,0x1506,0x114,0xf4e,0xf4e,0xf4e,0xf4e,0x1503,0x114,0x114,0x114,
-0x114,0x114,0x114,0x114,0x114,0x114,0x114,0x114,0xf54,0xf54,0xf54,0xf54,0xf54,0xf54,0xf54,0xf54,
-0xf54,0xf54,0xf54,0xf54,0xf54,0xf54,0xf54,0xf54,0xf54,0xf54,0x190b,0x190b,0x190b,0x190b,0x190b,0x190b,
-0x190b,0x117,0x117,0x117,0x117,0x117,0x117,0x117,0x104d,0x104d,0x104d,0x104d,0x104a,0x104a,0x104a,0x104a,
-0x104a,0x104a,0x104a,0x104a,0x103b,0x103b,0x103b,0x103b,0x103b,0x103b,0x103b,0x103b,0x104a,0x104a,0x1041,0x103e,
-0x11a,0x11a,0x11a,0x1050,0x1050,0x1044,0x1044,0x1044,0x1047,0x1047,0x1047,0x1047,0x1047,0x1047,0x1047,0x1047,
-0x1047,0x1047,0x11a,0x11a,0x11a,0x104d,0x104d,0x104d,0x1053,0x1053,0x1053,0x1053,0x1053,0x1053,0x1053,0x1053,
-0x1053,0x1053,0x1056,0x1056,0x1056,0x1056,0x1056,0x1056,0x1068,0x1068,0x1068,0x1068,0x1068,0x1068,0x1068,0x1068,
-0x1068,0x1068,0x106b,0x106b,0x11d,0x11d,0x11d,0x11d,0x11d,0x11d,0x11d,0x11d,0x11d,0x11d,0x11d,0x11d,
-0x11d,0x11d,0x11d,0x11d,0x11d,0x11d,0x11d,0x11d,0x1092,0x1092,0x1092,0x1092,0x108c,0x1794,0x120,0x120,
-0x120,0x120,0x120,0x120,0x120,0x120,0x1098,0x1098,0x108f,0x108f,0x108f,0x108f,0x108f,0x108f,0x108f,0x108f,
-0x108f,0x108f,0x120,0x120,0x120,0x120,0x120,0x120,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10aa,
-0x10aa,0x10aa,0x10aa,0x10aa,0x10aa,0x10aa,0x10aa,0x10aa,0x10aa,0x10aa,0x10b0,0x10b3,0x123,0x123,0x123,0x123,
-0x123,0x123,0x123,0x123,0x123,0x123,0x123,0x10ad,0x10c5,0x10c5,0x10c5,0x10c5,0x10c5,0x10c5,0x10c5,0x10c5,
-0x10c5,0x10b9,0x10b9,0x10b9,0x10b9,0x10b9,0x10b9,0x10c2,0x10c2,0x10b9,0x10b9,0x10c2,0x10c2,0x10b9,0x10b9,0x126,
-0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x10c5,0x10c5,0x10c5,0x10b9,0x10c5,0x10c5,0x10c5,0x10c5,
-0x10c5,0x10c5,0x10c5,0x10c5,0x10b9,0x10c2,0x126,0x126,0x10bf,0x10bf,0x10bf,0x10bf,0x10bf,0x10bf,0x10bf,0x10bf,
-0x10bf,0x10bf,0x126,0x126,0x10bc,0x10c8,0x10c8,0x10c8,0x1512,0x129,0x129,0x129,0x129,0x129,0x129,0x129,
+0x111,0x111,0x111,0x111,0x111,0x111,0x111,0x111,0xf63,0xf63,0xf63,0x1518,0x1518,0x1518,0x1518,0x1518,
+0x1518,0x1518,0x1518,0x1518,0x1518,0x1518,0x1518,0x114,0xf60,0xf60,0xf60,0xf60,0x1515,0x114,0x114,0x114,
+0x114,0x114,0x114,0x114,0x114,0x114,0x114,0x114,0xf66,0xf66,0xf66,0xf66,0xf66,0xf66,0xf66,0xf66,
+0xf66,0xf66,0xf66,0xf66,0xf66,0xf66,0xf66,0xf66,0xf66,0xf66,0x191d,0x191d,0x191d,0x191d,0x191d,0x191d,
+0x191d,0x117,0x117,0x117,0x117,0x117,0x117,0x117,0x1062,0x1062,0x1062,0x1062,0x105f,0x105f,0x105f,0x105f,
+0x105f,0x105f,0x105f,0x105f,0x1050,0x1050,0x1050,0x1050,0x1050,0x1050,0x1050,0x1050,0x105f,0x105f,0x1056,0x1053,
+0x11a,0x11a,0x11a,0x1065,0x1065,0x1059,0x1059,0x1059,0x105c,0x105c,0x105c,0x105c,0x105c,0x105c,0x105c,0x105c,
+0x105c,0x105c,0x11a,0x11a,0x11a,0x1062,0x1062,0x1062,0x1068,0x1068,0x1068,0x1068,0x1068,0x1068,0x1068,0x1068,
+0x1068,0x1068,0x106b,0x106b,0x106b,0x106b,0x106b,0x106b,0x107d,0x107d,0x107d,0x107d,0x107d,0x107d,0x107d,0x107d,
+0x107d,0x107d,0x1080,0x1080,0x11d,0x11d,0x11d,0x11d,0x11d,0x11d,0x11d,0x11d,0x11d,0x11d,0x11d,0x11d,
+0x11d,0x11d,0x11d,0x11d,0x11d,0x11d,0x11d,0x11d,0x10a7,0x10a7,0x10a7,0x10a7,0x10a1,0x17a6,0x120,0x120,
+0x120,0x120,0x120,0x120,0x120,0x120,0x10ad,0x10ad,0x10a4,0x10a4,0x10a4,0x10a4,0x10a4,0x10a4,0x10a4,0x10a4,
+0x10a4,0x10a4,0x120,0x120,0x120,0x120,0x120,0x120,0x10cb,0x10cb,0x10cb,0x10cb,0x10cb,0x10cb,0x10cb,0x10bf,
+0x10bf,0x10bf,0x10bf,0x10bf,0x10bf,0x10bf,0x10bf,0x10bf,0x10bf,0x10bf,0x10c5,0x10c8,0x123,0x123,0x123,0x123,
+0x123,0x123,0x123,0x123,0x123,0x123,0x123,0x10c2,0x10da,0x10da,0x10da,0x10da,0x10da,0x10da,0x10da,0x10da,
+0x10da,0x10ce,0x10ce,0x10ce,0x10ce,0x10ce,0x10ce,0x10d7,0x10d7,0x10ce,0x10ce,0x10d7,0x10d7,0x10ce,0x10ce,0x126,
+0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x10da,0x10da,0x10da,0x10ce,0x10da,0x10da,0x10da,0x10da,
+0x10da,0x10da,0x10da,0x10da,0x10ce,0x10d7,0x126,0x126,0x10d4,0x10d4,0x10d4,0x10d4,0x10d4,0x10d4,0x10d4,0x10d4,
+0x10d4,0x10d4,0x126,0x126,0x10d1,0x10dd,0x10dd,0x10dd,0x1524,0x129,0x129,0x129,0x129,0x129,0x129,0x129,
 0x129,0x129,0x129,0x129,0x129,0x129,0x129,0x129,0x129,0x129,0x129,0x129,0x129,0x129,0x129,0x129,
-0x129,0x129,0x129,0x129,0x129,0x129,0x129,0x129,0x10ce,0x10ce,0x10ce,0x10ce,0x10ce,0x10ce,0x10ce,0x10ce,
-0x10ce,0x10ce,0x10ce,0x10ce,0x10ce,0x10ce,0x10ce,0x10ce,0x10ce,0x10ce,0x10ce,0x10ce,0x10ce,0x10ce,0x10ce,0x10ce,
-0x10ce,0x10ce,0x10ce,0x10ce,0x10ce,0x10d1,0x12c,0x12c,0x10d4,0x10d4,0x10d4,0x10d4,0x10d4,0x10d4,0x10d4,0x10d4,
-0x10d4,0x10d4,0x10d4,0x10d4,0x10d4,0x10d4,0x10d4,0x10d4,0x10d4,0x10d4,0x10d4,0x10d4,0x10d4,0x10d4,0x10d4,0x10d4,
-0x10d4,0x10d4,0x10d4,0x10d4,0x10d4,0x12f,0x12f,0x12f,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,
-0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x132,0x132,0x132,0x132,0x132,0x132,0x132,
-0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,
-0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,
-0x10dd,0x10dd,0x135,0x135,0x135,0x135,0x135,0x10da,0x10e0,0x10e0,0x10e0,0x10e0,0x10e0,0x10e0,0x10e0,0x10e0,
-0x10e0,0x10e0,0x10e0,0x10e0,0x138,0x138,0x138,0x138,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,
-0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x13b,0x13b,0x13b,0x13b,
-0x13b,0x13b,0x13b,0x13b,0x13b,0x13b,0x13b,0x13b,0x115b,0x115b,0x115b,0x115b,0x1164,0x115b,0x115b,0x115b,
-0x1164,0x115b,0x115b,0x115b,0x115b,0x1158,0x13e,0x13e,0x1161,0x1161,0x1161,0x1161,0x1161,0x1161,0x1161,0x1167,
-0x1161,0x1167,0x1161,0x1161,0x1161,0x1167,0x1167,0x13e,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,
-0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x141,0x141,
-0x141,0x141,0x141,0x141,0x141,0x141,0x141,0x141,0x1185,0x1185,0x1185,0x1185,0x1185,0x1185,0x1185,0x1185,
-0x1185,0x1185,0x1185,0x1185,0x1185,0x1185,0x1185,0x1185,0x1185,0x1185,0x1185,0x1185,0x1185,0x1182,0x116d,0x1182,
-0x116d,0x116d,0x116d,0x116d,0x116d,0x116d,0x116d,0x144,0x1176,0x117f,0x116d,0x117f,0x117f,0x116d,0x116d,0x116d,
-0x116d,0x116d,0x116d,0x116d,0x116d,0x1182,0x1182,0x1182,0x1182,0x1182,0x1182,0x116d,0x116d,0x1173,0x1173,0x1173,
-0x1173,0x1173,0x1173,0x1173,0x1173,0x144,0x144,0x1170,0x117c,0x117c,0x117c,0x117c,0x117c,0x117c,0x117c,0x117c,
-0x117c,0x117c,0x144,0x144,0x144,0x144,0x144,0x144,0x117c,0x117c,0x117c,0x117c,0x117c,0x117c,0x117c,0x117c,
-0x117c,0x117c,0x144,0x144,0x144,0x144,0x144,0x144,0x1179,0x1179,0x1179,0x1179,0x1179,0x1179,0x1179,0x1188,
-0x118b,0x118b,0x118b,0x118b,0x1179,0x1179,0x144,0x144,0x1551,0x1551,0x1551,0x1551,0x1551,0x1551,0x1551,0x1551,
-0x1551,0x1551,0x1551,0x1551,0x1551,0x1551,0x154e,0x1a73,0x12cf,0x12a8,0x12c6,0x12c6,0x12c6,0x12c6,0x12c6,0x12c6,
-0x12c6,0x12ae,0x12ab,0x12a2,0x12a2,0x12cc,0x12a2,0x12a2,0x12a2,0x12a2,0x12b1,0x148b,0x1491,0x148e,0x148e,0x18d2,
-0x16a7,0x16a7,0x1a40,0x147,0x147,0x147,0x147,0x147,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,
-0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x1197,0x1197,0x119a,0x11a3,0x119d,0x119d,0x119d,0x11a3,
-0x14a,0x14a,0x14a,0x14a,0x14a,0x14a,0x14a,0x14a,0x1293,0x1293,0x1293,0x1293,0x1293,0x1293,0x1293,0x1293,
-0x1293,0x1293,0x1293,0x1293,0x1293,0x1293,0x1293,0x1293,0x1293,0x1293,0x1293,0x1293,0x1293,0x1293,0x1293,0x1293,
-0x1293,0x1293,0x1293,0x1293,0x1293,0x150,0x150,0x150,0x11c1,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0x11b8,
-0x11c7,0x11c7,0x11b5,0x11b5,0x11b5,0x11b5,0x153,0x12c3,0x11bb,0x11bb,0x11bb,0x11bb,0x11bb,0x11bb,0x11bb,0x11bb,
-0x11bb,0x11bb,0x153,0x153,0x153,0x153,0x11b5,0x11b5,0x11e5,0x11d9,0x11e5,0x156,0x156,0x156,0x156,0x156,
+0x129,0x129,0x129,0x129,0x129,0x129,0x129,0x129,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,
+0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,
+0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e6,0x12c,0x12c,0x10e9,0x10e9,0x10e9,0x10e9,0x10e9,0x10e9,0x10e9,0x10e9,
+0x10e9,0x10e9,0x10e9,0x10e9,0x10e9,0x10e9,0x10e9,0x10e9,0x10e9,0x10e9,0x10e9,0x10e9,0x10e9,0x10e9,0x10e9,0x10e9,
+0x10e9,0x10e9,0x10e9,0x10e9,0x10e9,0x12f,0x12f,0x12f,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,
+0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x132,0x132,0x132,0x132,0x132,0x132,0x132,
+0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x10f2,0x10f2,0x10f2,0x10f2,0x10f2,0x10f2,0x10f2,0x10f2,
+0x10f2,0x10f2,0x10f2,0x10f2,0x10f2,0x10f2,0x10f2,0x10f2,0x10f2,0x10f2,0x10f2,0x10f2,0x10f2,0x10f2,0x10f2,0x10f2,
+0x10f2,0x10f2,0x135,0x135,0x135,0x135,0x135,0x10ef,0x10f5,0x10f5,0x10f5,0x10f5,0x10f5,0x10f5,0x10f5,0x10f5,
+0x10f5,0x10f5,0x10f5,0x10f5,0x138,0x138,0x138,0x138,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,
+0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x13b,0x13b,0x13b,0x13b,
+0x13b,0x13b,0x13b,0x13b,0x13b,0x13b,0x13b,0x13b,0x1170,0x1170,0x1170,0x1170,0x1179,0x1170,0x1170,0x1170,
+0x1179,0x1170,0x1170,0x1170,0x1170,0x116d,0x13e,0x13e,0x1176,0x1176,0x1176,0x1176,0x1176,0x1176,0x1176,0x117c,
+0x1176,0x117c,0x1176,0x1176,0x1176,0x117c,0x117c,0x13e,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,
+0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x141,0x141,
+0x141,0x141,0x141,0x141,0x141,0x141,0x141,0x141,0x119a,0x119a,0x119a,0x119a,0x119a,0x119a,0x119a,0x119a,
+0x119a,0x119a,0x119a,0x119a,0x119a,0x119a,0x119a,0x119a,0x119a,0x119a,0x119a,0x119a,0x119a,0x1197,0x1182,0x1197,
+0x1182,0x1182,0x1182,0x1182,0x1182,0x1182,0x1182,0x144,0x118b,0x1194,0x1182,0x1194,0x1194,0x1182,0x1182,0x1182,
+0x1182,0x1182,0x1182,0x1182,0x1182,0x1197,0x1197,0x1197,0x1197,0x1197,0x1197,0x1182,0x1182,0x1188,0x1188,0x1188,
+0x1188,0x1188,0x1188,0x1188,0x1188,0x144,0x144,0x1185,0x1191,0x1191,0x1191,0x1191,0x1191,0x1191,0x1191,0x1191,
+0x1191,0x1191,0x144,0x144,0x144,0x144,0x144,0x144,0x1191,0x1191,0x1191,0x1191,0x1191,0x1191,0x1191,0x1191,
+0x1191,0x1191,0x144,0x144,0x144,0x144,0x144,0x144,0x118e,0x118e,0x118e,0x118e,0x118e,0x118e,0x118e,0x119d,
+0x11a0,0x11a0,0x11a0,0x11a0,0x118e,0x118e,0x144,0x144,0x1563,0x1563,0x1563,0x1563,0x1563,0x1563,0x1563,0x1563,
+0x1563,0x1563,0x1563,0x1563,0x1563,0x1563,0x1560,0x1a85,0x12e1,0x12ba,0x12d8,0x12d8,0x12d8,0x12d8,0x12d8,0x12d8,
+0x12d8,0x12c0,0x12bd,0x12b4,0x12b4,0x12de,0x12b4,0x12b4,0x12b4,0x12b4,0x12c3,0x149d,0x14a3,0x14a0,0x14a0,0x18e4,
+0x16b9,0x16b9,0x1a52,0x147,0x147,0x147,0x147,0x147,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,
+0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0x11ac,0x11ac,0x11af,0x11b8,0x11b2,0x11b2,0x11b2,0x11b8,
+0x14a,0x14a,0x14a,0x14a,0x14a,0x14a,0x14a,0x14a,0x12a5,0x12a5,0x12a5,0x12a5,0x12a5,0x12a5,0x12a5,0x12a5,
+0x12a5,0x12a5,0x12a5,0x12a5,0x12a5,0x12a5,0x12a5,0x12a5,0x12a5,0x12a5,0x12a5,0x12a5,0x12a5,0x12a5,0x12a5,0x12a5,
+0x12a5,0x12a5,0x12a5,0x12a5,0x12a5,0x150,0x150,0x150,0x11d6,0x11ca,0x11ca,0x11ca,0x11ca,0x11ca,0x11ca,0x11cd,
+0x11dc,0x11dc,0x11ca,0x11ca,0x11ca,0x11ca,0x153,0x12d5,0x11d0,0x11d0,0x11d0,0x11d0,0x11d0,0x11d0,0x11d0,0x11d0,
+0x11d0,0x11d0,0x153,0x153,0x153,0x153,0x11ca,0x11ca,0x11fa,0x11ee,0x11fa,0x156,0x156,0x156,0x156,0x156,
 0x156,0x156,0x156,0x156,0x156,0x156,0x156,0x156,0x156,0x156,0x156,0x156,0x156,0x156,0x156,0x156,
-0x156,0x156,0x156,0x11e2,0x11e2,0x11e8,0x11dc,0x11df,0x11fd,0x11fd,0x11fd,0x11f7,0x11f7,0x11ee,0x11f7,0x11f7,
-0x11ee,0x11f7,0x11f7,0x1200,0x11fa,0x11f1,0x159,0x159,0x11f4,0x11f4,0x11f4,0x11f4,0x11f4,0x11f4,0x11f4,0x11f4,
-0x11f4,0x11f4,0x159,0x159,0x159,0x159,0x159,0x159,0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,0x15c,
-0x15c,0x15c,0x15c,0x1203,0x1203,0x1203,0x1203,0x1203,0x1203,0x1203,0x1203,0x1203,0x1203,0x1203,0x1203,0x1203,
-0x1203,0x1203,0x1203,0x1203,0x1203,0x1203,0x1203,0x1203,0x1203,0x1203,0x1203,0x1203,0x1203,0x1203,0x1203,0x1203,
-0x15c,0x15c,0x15c,0x15c,0x120f,0x120f,0x120f,0x120f,0x120f,0x120f,0x120f,0x120f,0x120f,0x120f,0x120f,0x120f,
-0x120f,0x120f,0x120f,0x120f,0x120f,0x120f,0x120f,0x120f,0x120f,0x120f,0x15f,0x120c,0x1209,0x1209,0x1209,0x1209,
-0x1209,0x1209,0x1209,0x1209,0x121e,0x121e,0x121e,0x121e,0x121e,0x121e,0x121e,0x121e,0x121e,0x121e,0x121e,0x121e,
-0x121e,0x121e,0x121e,0x121e,0x121e,0x121e,0x121e,0x121e,0x121e,0x121e,0x162,0x162,0x162,0x1218,0x121b,0x121b,
-0x121b,0x121b,0x121b,0x121b,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,
-0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x165,0x165,0x1221,0x1221,0x1221,0x1221,
-0x1221,0x1221,0x1221,0x1221,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,
-0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x168,0x168,0x168,0x168,0x168,0x1227,0x1227,0x1227,0x1227,
-0x1227,0x1227,0x1227,0x1227,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,
-0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,
-0x1230,0x1230,0x1230,0x16e,0x124b,0x124b,0x1b2a,0x171,0x171,0x171,0x171,0x171,0x171,0x171,0x171,0x171,
-0x171,0x1914,0x171,0x171,0x146a,0x146a,0x146a,0x146a,0x146a,0x146a,0x146a,0x146a,0x146a,0x146a,0x146a,0x146a,
-0x146a,0x146a,0x146a,0x146a,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,
-0x1251,0x1251,0x1251,0x174,0x19e3,0x19e3,0x19e3,0x19e3,0x19e3,0x19e3,0x19e3,0x19e6,0x19e0,0x26a,0x26a,0x26a,
-0x26a,0x26a,0x26a,0x26a,0x1815,0x1815,0x1815,0x1815,0x1815,0x1815,0x1815,0x1815,0x1815,0x1815,0x1815,0x1815,
-0x1815,0x1a64,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,
+0x156,0x156,0x156,0x11f7,0x11f7,0x11fd,0x11f1,0x11f4,0x1212,0x1212,0x1212,0x120c,0x120c,0x1203,0x120c,0x120c,
+0x1203,0x120c,0x120c,0x1215,0x120f,0x1206,0x159,0x159,0x1209,0x1209,0x1209,0x1209,0x1209,0x1209,0x1209,0x1209,
+0x1209,0x1209,0x159,0x159,0x159,0x159,0x159,0x159,0x121b,0x121b,0x121b,0x121b,0x121b,0x121b,0x121b,0x15c,
+0x15c,0x15c,0x15c,0x1218,0x1218,0x1218,0x1218,0x1218,0x1218,0x1218,0x1218,0x1218,0x1218,0x1218,0x1218,0x1218,
+0x1218,0x1218,0x1218,0x1218,0x1218,0x1218,0x1218,0x1218,0x1218,0x1218,0x1218,0x1218,0x1218,0x1218,0x1218,0x1218,
+0x15c,0x15c,0x15c,0x15c,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,
+0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x15f,0x1221,0x121e,0x121e,0x121e,0x121e,
+0x121e,0x121e,0x121e,0x121e,0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,
+0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,0x162,0x162,0x162,0x122d,0x1230,0x1230,
+0x1230,0x1230,0x1230,0x1230,0x1239,0x1239,0x1239,0x1239,0x1239,0x1239,0x1239,0x1239,0x1239,0x1239,0x1239,0x1239,
+0x1239,0x1239,0x1239,0x1239,0x1239,0x1239,0x1239,0x1239,0x1239,0x1239,0x165,0x165,0x1236,0x1236,0x1236,0x1236,
+0x1236,0x1236,0x1236,0x1236,0x123f,0x123f,0x123f,0x123f,0x123f,0x123f,0x123f,0x123f,0x123f,0x123f,0x123f,0x123f,
+0x123f,0x123f,0x123f,0x123f,0x123f,0x123f,0x123f,0x168,0x168,0x168,0x168,0x168,0x123c,0x123c,0x123c,0x123c,
+0x123c,0x123c,0x123c,0x123c,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,
+0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,
+0x1245,0x1245,0x1245,0x16e,0x125d,0x125d,0x1b3c,0x171,0x171,0x171,0x171,0x171,0x171,0x171,0x171,0x171,
+0x171,0x1926,0x171,0x171,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,
+0x147c,0x147c,0x147c,0x147c,0x1827,0x1827,0x1827,0x1827,0x1827,0x1827,0x1827,0x1827,0x1827,0x1827,0x1827,0x1827,
+0x1827,0x1a76,0x174,0x174,0x174,0x174,0x174,0x174,0x174,0x174,0x174,0x174,0x174,0x174,0x174,0x174,
+0x174,0x174,0x174,0x174,0x174,0x174,0x174,0x174,0x174,0x174,0x174,0x174,0x174,0x174,0x174,0x174,
+0x174,0x174,0x174,0x174,0x174,0x174,0x1344,0x1344,0x1344,0x1344,0x1344,0x1344,0x1344,0x1344,0x1344,0x1344,
+0x1344,0x1344,0x1344,0x1344,0x1344,0x1344,0x1344,0x1344,0x1344,0x1344,0x1344,0x1344,0x1344,0x1344,0x1344,0x1344,
+0x12ae,0x13a7,0x13a7,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,
+0x12ab,0x12ab,0x12ab,0x12ab,0x12ab,0x12ab,0x12ab,0x12ab,0x12ab,0x12ab,0x12ab,0x12ab,0x12ab,0x12ab,0x12ab,0x12ab,
+0x12ab,0x12ab,0x13a7,0x13a7,0x13a7,0x13a7,0x13a7,0x13a7,0x13a7,0x13a7,0x13a7,0x182a,0x177,0x177,0x177,0x177,
+0x12a8,0x12a8,0x12a8,0x12a8,0x12a8,0x12a8,0x12a8,0x12a8,0x12a8,0x177,0x177,0x177,0x177,0x177,0x177,0x177,
+0x13cb,0x13cb,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,
+0x18c9,0x18c9,0x18c9,0x18c9,0x18c9,0x18c9,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,
 0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,
-0x177,0x177,0x177,0x177,0x177,0x177,0x1332,0x1332,0x1332,0x1332,0x1332,0x1332,0x1332,0x1332,0x1332,0x1332,
-0x1332,0x1332,0x1332,0x1332,0x1332,0x1332,0x1332,0x1332,0x1332,0x1332,0x1332,0x1332,0x1332,0x1332,0x1332,0x1332,
-0x129c,0x1395,0x1395,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,
-0x1299,0x1299,0x1299,0x1299,0x1299,0x1299,0x1299,0x1299,0x1299,0x1299,0x1299,0x1299,0x1299,0x1299,0x1299,0x1299,
-0x1299,0x1299,0x1395,0x1395,0x1395,0x1395,0x1395,0x1395,0x1395,0x1395,0x1395,0x1818,0x17a,0x17a,0x17a,0x17a,
-0x1296,0x1296,0x1296,0x1296,0x1296,0x1296,0x1296,0x1296,0x1296,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,
-0x13b9,0x13b9,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,
-0x18b7,0x18b7,0x18b7,0x18b7,0x18b7,0x18b7,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,
-0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,
-0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x17a,0x133b,0x133b,0x133b,0x133b,0x133b,0x133b,0x133b,0x133b,
-0x133b,0x133b,0x133b,0x133b,0x133b,0x133b,0x133b,0x133b,0x133b,0x133b,0x133b,0x133b,0x133b,0x133b,0x133b,0x133b,
-0x133b,0x1335,0x1335,0x1335,0x17d,0x17d,0x1338,0x17d,0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,0x133e,0x1347,
-0x1341,0x1341,0x1347,0x1347,0x1347,0x1341,0x1347,0x1341,0x1341,0x1341,0x134a,0x134a,0x180,0x180,0x180,0x180,
-0x180,0x180,0x180,0x180,0x1344,0x1344,0x1344,0x1344,0x183,0x1350,0x1350,0x1350,0x1350,0x1350,0x1350,0x183,
-0x183,0x1350,0x1350,0x1350,0x1350,0x1350,0x1350,0x183,0x183,0x1350,0x1350,0x1350,0x1350,0x1350,0x1350,0x183,
-0x183,0x183,0x183,0x183,0x183,0x183,0x183,0x183,0x1350,0x1350,0x1350,0x1350,0x1350,0x1350,0x1350,0x183,
-0x1350,0x1350,0x1350,0x1350,0x1350,0x1350,0x1350,0x183,0x15ae,0x15ae,0x15ae,0x15ae,0x15ae,0x15ae,0x15ae,0x15ae,
-0x15ae,0x15ae,0x15ae,0x15ae,0x15ae,0x15ae,0x15ae,0x15ae,0x1353,0x1353,0x1353,0x1353,0x1353,0x1353,0x1356,0x1368,
-0x1368,0x135c,0x135c,0x135c,0x135c,0x135c,0x186,0x186,0x186,0x186,0x1359,0x1359,0x1359,0x1359,0x1359,0x1359,
-0x1359,0x1359,0x1359,0x1359,0x1359,0x1359,0x1359,0x1359,0x1359,0x1359,0x135f,0x135f,0x135f,0x135f,0x135f,0x135f,
-0x135f,0x135f,0x135f,0x135f,0x1b30,0x1b33,0x1b33,0x1b2d,0x1b2d,0x1b33,0x186,0x186,0x186,0x186,0x186,0x186,
-0x186,0x186,0x186,0x1521,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,
-0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x189,0x189,0x189,
-0x189,0x189,0x189,0x189,0x136e,0x136e,0x136e,0x136e,0x136e,0x136e,0x136e,0x136e,0x136e,0x136e,0x136e,0x136e,
-0x136e,0x136e,0x136e,0x18c,0x18c,0x136e,0x136e,0x136e,0x136e,0x136e,0x136e,0x136e,0x136e,0x136e,0x136e,0x136e,
-0x136e,0x136e,0x136e,0x1524,0x18c,0x136e,0x136e,0x136e,0x136e,0x136e,0x136e,0x136e,0x136e,0x136e,0x136e,0x136e,
-0x136e,0x136e,0x136e,0x139e,0x18c,0x136e,0x136e,0x136e,0x136e,0x136e,0x136e,0x136e,0x136e,0x136e,0x136e,0x136e,
-0x136e,0x136e,0x136e,0x136e,0x1524,0x1524,0x1524,0x1524,0x1524,0x1524,0x1524,0x1524,0x1524,0x1524,0x1524,0x1524,
-0x1524,0x1524,0x1524,0x1524,0x1524,0x1524,0x1524,0x1524,0x1524,0x1524,0x18c,0x18c,0x18c,0x18c,0x18c,0x18c,
-0x18c,0x18c,0x18c,0x18c,0x13b3,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x1530,0x1530,0x1530,0x1530,0x1530,0x1530,
-0x169e,0x1530,0x1530,0x1530,0x1770,0x1821,0x1821,0x185a,0x185a,0x1a22,0x1acd,0x1acd,0x18f,0x18f,0x18f,0x18f,
-0x18f,0x1b9c,0x1b9c,0x1b9c,0x1530,0x1530,0x1530,0x1530,0x1530,0x1530,0x1530,0x1530,0x1530,0x1530,0x1530,0x169b,
-0x169b,0x18f,0x18f,0x18f,0x1530,0x1530,0x1530,0x1530,0x1821,0x1821,0x1821,0x18bd,0x18bd,0x199e,0x1a22,0x1acd,
-0x1acd,0x18f,0x18f,0x18f,0x1371,0x1371,0x1371,0x1371,0x1371,0x1371,0x1371,0x1371,0x1371,0x1371,0x1371,0x1371,
-0x1371,0x1371,0x1371,0x1371,0x1371,0x1371,0x1371,0x1371,0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,
-0x192,0x192,0x192,0x192,0x140d,0x140d,0x140d,0x140d,0x195,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,
-0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,
-0x140d,0x140d,0x140d,0x140d,0x195,0x140d,0x140d,0x195,0x140d,0x195,0x195,0x140d,0x195,0x140d,0x140d,0x140d,
-0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x195,0x140d,0x140d,0x140d,0x140d,0x195,0x140d,0x195,0x140d,
-0x195,0x195,0x195,0x195,0x195,0x195,0x140d,0x195,0x195,0x195,0x195,0x140d,0x195,0x140d,0x195,0x140d,
-0x195,0x140d,0x140d,0x140d,0x195,0x140d,0x140d,0x195,0x140d,0x195,0x195,0x140d,0x195,0x140d,0x195,0x140d,
-0x195,0x140d,0x195,0x140d,0x195,0x140d,0x140d,0x195,0x140d,0x195,0x195,0x140d,0x140d,0x140d,0x140d,0x195,
-0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x195,0x140d,0x140d,0x140d,0x140d,0x195,0x140d,0x140d,0x140d,
-0x140d,0x195,0x140d,0x195,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x195,0x140d,
-0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,
-0x195,0x195,0x195,0x195,0x195,0x140d,0x140d,0x140d,0x195,0x140d,0x140d,0x140d,0x140d,0x140d,0x195,0x140d,
-0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,
-0x195,0x195,0x195,0x195,0x195,0x195,0x195,0x195,0x195,0x195,0x195,0x195,0x195,0x195,0x195,0x195,
-0x195,0x195,0x195,0x195,0x195,0x195,0x195,0x195,0x195,0x195,0x195,0x195,0x195,0x195,0x195,0x195,
-0x140a,0x140a,0x195,0x195,0x195,0x195,0x195,0x195,0x195,0x195,0x195,0x195,0x195,0x195,0x195,0x195,
-0x1422,0x1422,0x1422,0x1422,0x1422,0x1422,0x1422,0x1410,0x1410,0x1410,0x1410,0x1410,0x141f,0x1410,0x1413,0x1413,
-0x1410,0x1410,0x1410,0x1416,0x1416,0x198,0x141c,0x141c,0x141c,0x141c,0x141c,0x141c,0x141c,0x141c,0x141c,0x141c,
-0x1419,0x1425,0x1425,0x1425,0x1920,0x191d,0x191d,0x1a6a,0x198,0x198,0x198,0x198,0x198,0x198,0x198,0x198,
-0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,
-0x1431,0x1431,0x1431,0x1431,0x1431,0x1431,0x1431,0x1431,0x1431,0x1431,0x1431,0x142e,0x1428,0x1428,0x142e,0x142e,
-0x1437,0x1437,0x1431,0x1434,0x1434,0x142e,0x142b,0x19b,0x19b,0x19b,0x19b,0x19b,0x19b,0x19b,0x19b,0x19b,
-0x143a,0x143a,0x143a,0x143a,0x143a,0x143a,0x143a,0x143a,0x143a,0x143a,0x143a,0x143a,0x143a,0x143a,0x143a,0x143a,
-0x143a,0x143a,0x143a,0x143a,0x143a,0x143a,0x143a,0x143a,0x19e,0x19e,0x19e,0x19e,0x16f5,0x16f5,0x143a,0x143a,
-0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,
-0x19e,0x19e,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,
-0x1446,0x1446,0x1446,0x1446,0x1446,0x19cb,0x19cb,0x19cb,0x19cb,0x19cb,0x19cb,0x1a1,0x1a1,0x1a1,0x1a1,0x19c5,
-0x1446,0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,
-0x19c8,0x19c8,0x19c8,0x19c8,0x19c8,0x19c8,0x19c8,0x19c8,0x1a1,0x1a1,0x1a1,0x1a1,0x1a1,0x1a1,0x1a1,0x1440,
-0x1440,0x1440,0x1440,0x1449,0x1449,0x1449,0x1449,0x1449,0x1449,0x1449,0x1449,0x1449,0x1449,0x1449,0x1449,0x1449,
-0x146a,0x146a,0x146a,0x146a,0x146a,0x146a,0x146a,0x146a,0x146a,0x1a4,0x1a4,0x1a4,0x1a4,0x1a4,0x1a4,0x1a4,
-0x1467,0x1467,0x1467,0x1467,0x1467,0x1467,0x1467,0x1467,0x1467,0x1467,0x1a4,0x1a4,0x1a4,0x1a4,0x1a4,0x1a4,
-0x146d,0x146d,0x146d,0x146d,0x146d,0x146d,0x146d,0x146d,0x1a7,0x1a7,0x1a7,0x1a7,0x1a7,0x1a7,0x1a7,0x1a7,
-0x12c9,0x12c6,0x12c9,0x12a5,0x12c6,0x12cc,0x12cc,0x12cf,0x12cc,0x12cf,0x12d2,0x12c6,0x12cf,0x12cf,0x12c6,0x12c6,
-0x147f,0x147f,0x147f,0x147f,0x147f,0x147f,0x147f,0x147f,0x147f,0x147f,0x147f,0x1470,0x1479,0x1470,0x1479,0x1479,
-0x1470,0x1470,0x1470,0x1470,0x1470,0x1470,0x147c,0x1473,0x19ce,0x1b3f,0x1aa,0x1aa,0x1aa,0x1aa,0x1aa,0x1aa,
-0x1542,0x1542,0x1542,0x1542,0x1542,0x1542,0x1542,0x1542,0x1542,0x1542,0x1542,0x1542,0x1542,0x1542,0x1ad,0x1ad,
-0x153f,0x153f,0x153f,0x153f,0x153f,0x1545,0x1ad,0x1ad,0x1ad,0x1ad,0x1ad,0x1ad,0x1ad,0x1ad,0x1ad,0x1ad,
-0x154b,0x154b,0x154b,0x154b,0x1b0,0x1b0,0x1b0,0x1b0,0x1b0,0x1b0,0x1b0,0x1b0,0x1b0,0x1b0,0x1b0,0x1548,
-0x1b8a,0x1b8a,0x1b8a,0x1b8a,0x1b8a,0x1b8a,0x1b8a,0x1b8a,0x1b8a,0x1b8a,0x1b8a,0x2b5,0x1b8a,0x1b8a,0x1b8a,0x1b8a,
-0x16aa,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,
-0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x1b3,0x1b3,0x1b3,0x1b3,
-0x1a73,0x1b45,0x1b45,0x1b45,0x1b45,0x1b45,0x1b45,0x1b45,0x1b45,0x1b45,0x1b45,0x1b45,0x1b42,0x1b42,0x1b42,0x1b6,
-0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,
-0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,
-0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x1b9,0x1b9,0x1b9,0x1b9,0x1b9,
-0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x1b9,0x1b9,0x1b9,
-0x1b9,0x1b9,0x1b9,0x1b9,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x1b9,0x1b9,
-0x155a,0x1554,0x1557,0x1560,0x1563,0x1563,0x1563,0x1563,0x1563,0x1563,0x1563,0x1563,0x1bc,0x1bc,0x1bc,0x1bc,
-0x1bc,0x1bc,0x1bc,0x1bc,0x154b,0x154b,0x154b,0x154b,0x154b,0x154b,0x154b,0x154b,0x154b,0x154b,0x154b,0x154b,
-0x154b,0x154b,0x154b,0x154b,0x1566,0x1566,0x1566,0x1566,0x1566,0x1566,0x1566,0x1566,0x1566,0x1566,0x1566,0x1566,
-0x1566,0x1566,0x1566,0x1566,0x1566,0x1566,0x1566,0x1566,0x1566,0x1923,0x1923,0x1923,0x1923,0x1bf,0x1bf,0x1bf,
-0x1bf,0x1bf,0x1bf,0x1bf,0x1a25,0x1a25,0x1a25,0x1a25,0x1a25,0x1a25,0x1a25,0x1a25,0x1a25,0x1a25,0x1a25,0x1a25,
-0x1bf,0x1bf,0x1bf,0x1bf,0x1b9f,0x1bf,0x1bf,0x1bf,0x1bf,0x1bf,0x1bf,0x1bf,0x1bf,0x1bf,0x1bf,0x1bf,
-0x1bf,0x1bf,0x1bf,0x1bf,0x170a,0x16ad,0x156f,0x16b3,0x1c2,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,
-0x1578,0x1c2,0x1c2,0x1578,0x1578,0x1c2,0x1c2,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,
-0x1578,0x1578,0x1578,0x1578,0x1578,0x1c2,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1c2,0x1578,0x1578,
-0x1c2,0x1578,0x1578,0x1578,0x1578,0x1578,0x1c2,0x19aa,0x16b0,0x1578,0x1569,0x156f,0x1569,0x156f,0x156f,0x156f,
-0x156f,0x1c2,0x1c2,0x156f,0x156f,0x1c2,0x1c2,0x1572,0x1572,0x1575,0x1c2,0x1c2,0x170d,0x1c2,0x1c2,0x1c2,
-0x1c2,0x1c2,0x1c2,0x1569,0x1c2,0x1c2,0x1c2,0x1c2,0x1c2,0x157b,0x1578,0x1578,0x1578,0x1578,0x156f,0x156f,
-0x1c2,0x1c2,0x156c,0x156c,0x156c,0x156c,0x156c,0x156c,0x156c,0x1c2,0x1c2,0x1c2,0x156c,0x156c,0x156c,0x156c,
-0x156c,0x1c2,0x1c2,0x1c2,0x1c2,0x1c2,0x1c2,0x1c2,0x1c2,0x1c2,0x1c2,0x1c2,0x1590,0x1590,0x1590,0x1590,
-0x1590,0x1590,0x1590,0x1590,0x1590,0x1590,0x1590,0x1590,0x1590,0x1590,0x1590,0x1590,0x1590,0x1590,0x1c5,0x1590,
-0x1590,0x1590,0x1590,0x1590,0x1590,0x1590,0x1590,0x1590,0x1590,0x1590,0x1590,0x1590,0x158a,0x158a,0x158a,0x157e,
-0x157e,0x157e,0x158a,0x158a,0x157e,0x158d,0x1581,0x157e,0x1593,0x1593,0x1587,0x1593,0x1593,0x1584,0x17a3,0x1c5,
-0x15a2,0x15a2,0x15a2,0x1596,0x1596,0x1596,0x1596,0x1596,0x1596,0x1599,0x159c,0x1c8,0x1c8,0x1c8,0x1c8,0x1c8,
-0x159f,0x159f,0x159f,0x159f,0x159f,0x159f,0x159f,0x159f,0x159f,0x159f,0x1c8,0x1c8,0x1c8,0x1c8,0x1c8,0x1c8,
-0x1710,0x1710,0x1710,0x1710,0x15ae,0x15ab,0x19d1,0x19d1,0x1a79,0x1a7c,0x1a76,0x1a76,0x1cb,0x1cb,0x1cb,0x1cb,
-0x173d,0x173d,0x173d,0x173d,0x173d,0x173d,0x173d,0x173d,0x173d,0x173d,0x173d,0x173d,0x173d,0x173d,0x173d,0x173d,
-0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,
-0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,
-0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,
-0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,
-0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,
-0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,
-0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,
-0x15c0,0x15c0,0x15c0,0x15b7,0x15ba,0x15bd,0x15c0,0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,
-0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15c3,0x15c3,0x1d4,0x1d4,0x1d4,0x1d4,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,
-0x15cc,0x15cc,0x16b6,0x15cc,0x15cc,0x15cc,0x15c9,0x1d4,0x1d4,0x1d4,0x1d4,0x1d4,0x1d4,0x1d4,0x1d4,0x1d4,
-0x15d8,0x15d8,0x15d8,0x15d8,0x15d8,0x1d7,0x1d7,0x15d5,0x15d5,0x15d5,0x15d5,0x15d5,0x15d5,0x15d5,0x15d5,0x15d5,
-0x15d2,0x15d2,0x15d2,0x15d2,0x15d2,0x15d2,0x15d2,0x1d7,0x1d7,0x1d7,0x1d7,0x1d7,0x1d7,0x1d7,0x1d7,0x1d7,
-0x15db,0x15ed,0x15ed,0x15e1,0x15ea,0x1da,0x1da,0x1da,0x1da,0x1da,0x1da,0x1da,0x1da,0x1da,0x1da,0x1da,
-0x15e4,0x15e4,0x15e4,0x15e4,0x15e4,0x15e4,0x15e4,0x15e4,0x15e4,0x15e4,0x1da,0x1da,0x1da,0x1da,0x1da,0x1da,
-0x15f3,0x15f3,0x15f3,0x15f3,0x15f3,0x15f3,0x15f3,0x15f3,0x15f3,0x15f3,0x15f3,0x15f3,0x15f3,0x15f3,0x15f3,0x15f3,
-0x15f3,0x15f3,0x15f3,0x15f3,0x15f3,0x15f3,0x15f3,0x15f3,0x15f3,0x15f3,0x15f3,0x15f3,0x15f3,0x15f3,0x15f3,0x1dd,
-0x15f0,0x15f0,0x15f0,0x15f0,0x15f0,0x15f0,0x15f0,0x15f0,0x15f0,0x15f0,0x1dd,0x1dd,0x1dd,0x1dd,0x15f6,0x15f6,
-0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,
-0x15ff,0x15ff,0x15ff,0x15ff,0x15ff,0x15f9,0x1602,0x15ff,0x15ff,0x15ff,0x15ff,0x15ff,0x15ff,0x15ff,0x15ff,0x15ff,
-0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15ff,0x15ff,0x15ff,0x15ff,0x15ff,0x1e0,
-0x1608,0x1608,0x1608,0x1608,0x1608,0x1608,0x1608,0x1608,0x1608,0x1608,0x1608,0x1608,0x1608,0x1608,0x1608,0x1608,
-0x1608,0x1608,0x1608,0x1608,0x1608,0x1608,0x1608,0x1608,0x1608,0x1608,0x1608,0x1608,0x1608,0x1608,0x1608,0x1e3,
-0x1614,0x1614,0x1614,0x1614,0x1614,0x1614,0x1614,0x1614,0x1614,0x1614,0x1614,0x1614,0x1614,0x1614,0x1614,0x1614,
-0x1614,0x1614,0x1614,0x1614,0x1614,0x1614,0x1611,0x1611,0x1611,0x1611,0x1611,0x1e6,0x1e6,0x1e6,0x1e6,0x1e6,
-0x162c,0x162c,0x162f,0x162f,0x1632,0x1623,0x1e9,0x1e9,0x1e9,0x1e9,0x1e9,0x1e9,0x1e9,0x1e9,0x1e9,0x1e9,
-0x1629,0x1629,0x1629,0x1629,0x1629,0x1629,0x1629,0x1629,0x1629,0x1629,0x1e9,0x1623,0x1623,0x1623,0x1623,0x1623,
-0x1623,0x1623,0x1e9,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,
-0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x1e9,0x1e9,0x1e9,0x1e9,0x1e9,0x162c,0x162c,0x162c,
-0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,
-0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x1ec,0x1ec,0x1ec,0x1ec,0x1ec,0x1ec,0x1ec,
-0x1644,0x1644,0x1644,0x1644,0x1644,0x1644,0x1644,0x1644,0x1644,0x1644,0x1644,0x1644,0x1644,0x1644,0x1644,0x1644,
-0x1644,0x1644,0x1ef,0x1ef,0x1ef,0x1ef,0x1ef,0x1ef,0x1ef,0x1641,0x1641,0x1641,0x1641,0x1ef,0x1ef,0x1ef,
-0x165f,0x165f,0x165f,0x165f,0x165f,0x165f,0x165f,0x165f,0x165f,0x165f,0x165f,0x165f,0x165f,0x165f,0x165f,0x1647,
-0x1659,0x1659,0x1647,0x1647,0x1647,0x1647,0x1f5,0x1f5,0x1659,0x1659,0x165c,0x165c,0x1647,0x1647,0x1659,0x164d,
-0x164a,0x1650,0x1662,0x1662,0x1653,0x1653,0x1656,0x1656,0x1656,0x1662,0x1719,0x1719,0x1719,0x1719,0x1719,0x1719,
-0x1719,0x1719,0x1719,0x1719,0x1719,0x1719,0x1719,0x1719,0x1716,0x1716,0x1716,0x1716,0x1713,0x1713,0x1f5,0x1f5,
-0x1f5,0x1f5,0x1f5,0x1f5,0x1f5,0x1f5,0x1f5,0x1f5,0x1f5,0x1f5,0x1f5,0x1f5,0x1f5,0x1f5,0x1f5,0x1f5,
-0x1f5,0x1f5,0x1f5,0x1f5,0x1f5,0x1f5,0x1f5,0x1f5,0x1f5,0x1f5,0x1f5,0x1f5,0x1f5,0x1f5,0x1f5,0x1f5,
-0x1f8,0x1665,0x1665,0x1665,0x1665,0x1665,0x1665,0x1665,0x1665,0x1665,0x1665,0x1665,0x1665,0x1665,0x1665,0x1665,
-0x1665,0x1665,0x1665,0x1665,0x1665,0x1f8,0x1f8,0x1f8,0x1f8,0x1f8,0x1f8,0x1f8,0x1f8,0x1f8,0x1f8,0x1f8,
-0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1fb,0x1fb,0x1fb,0x1fb,
-0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,
-0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,
-0x1668,0x1668,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,
-0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,
-0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1fb,0x1fb,0x1a7f,0x1a7f,0x1fb,0x1fb,
-0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,
-0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,
-0x166b,0x167a,0x1671,0x166e,0x1680,0x1680,0x1674,0x1680,0x1fe,0x1fe,0x1fe,0x1fe,0x1fe,0x1fe,0x1fe,0x1fe,
-0x1677,0x1677,0x1677,0x1677,0x1677,0x1677,0x1677,0x1677,0x1677,0x1677,0x1fe,0x1fe,0x1fe,0x1fe,0x1fe,0x1fe,
-0x1686,0x1686,0x1686,0x1686,0x1686,0x1686,0x1686,0x1686,0x1686,0x1686,0x1683,0x1683,0x1683,0x1683,0x1683,0x1683,
-0x1683,0x1683,0x1683,0x201,0x201,0x201,0x201,0x201,0x201,0x201,0x201,0x201,0x201,0x201,0x201,0x168c,
-0x172e,0x172e,0x172e,0x172e,0x172e,0x172e,0x172e,0x172e,0x172e,0x172e,0x172e,0x172e,0x172e,0x172e,0x172e,0x172e,
-0x172e,0x172e,0x172e,0x172e,0x172e,0x172e,0x172e,0x172e,0x172e,0x172e,0x1926,0x204,0x204,0x171c,0x171c,0x171c,
-0x1728,0x1728,0x171c,0x171c,0x171c,0x171c,0x172b,0x171c,0x171c,0x171c,0x171c,0x171f,0x204,0x204,0x204,0x204,
-0x1725,0x1725,0x1725,0x1725,0x1725,0x1725,0x1725,0x1725,0x1725,0x1725,0x1722,0x1722,0x1731,0x1731,0x1731,0x1722,
-0x1734,0x1734,0x1734,0x1734,0x1734,0x1734,0x1734,0x207,0x207,0x207,0x207,0x207,0x207,0x207,0x207,0x207,
-0x207,0x207,0x207,0x207,0x207,0x207,0x207,0x207,0x207,0x207,0x207,0x207,0x207,0x207,0x207,0x207,
-0x207,0x207,0x207,0x207,0x207,0x207,0x207,0x207,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,
-0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x20d,0x1746,0x1746,0x20d,0x20d,
-0x20d,0x20d,0x20d,0x1743,0x1743,0x1743,0x1743,0x1743,0x1749,0x1749,0x1749,0x1749,0x1749,0x1749,0x1749,0x210,
-0x1749,0x210,0x1749,0x1749,0x1749,0x1749,0x210,0x1749,0x1749,0x1749,0x1749,0x1749,0x1749,0x1749,0x1749,0x1749,
-0x1749,0x1749,0x1749,0x1749,0x1749,0x1749,0x210,0x1749,0x1749,0x1749,0x1749,0x1749,0x1749,0x1749,0x1749,0x1749,
-0x1749,0x174c,0x210,0x210,0x210,0x210,0x210,0x210,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,
-0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x1755,0x1755,0x1755,0x1755,0x1755,0x1755,0x1755,0x1755,
-0x1755,0x1755,0x1755,0x1755,0x1755,0x1755,0x1755,0x1755,0x1755,0x1755,0x1755,0x213,0x213,0x213,0x213,0x213,
-0x213,0x213,0x213,0x213,0x213,0x213,0x213,0x213,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,
-0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x213,0x213,0x213,0x213,0x213,
-0x213,0x213,0x174f,0x174f,0x174f,0x174f,0x174f,0x174f,0x175b,0x175b,0x175b,0x175b,0x1758,0x175b,0x175b,0x175e,
-0x1761,0x175e,0x175e,0x175b,0x216,0x216,0x216,0x216,0x216,0x216,0x216,0x216,0x216,0x216,0x216,0x216,
-0x216,0x216,0x216,0x1758,0x1758,0x1758,0x1758,0x1758,0x17b8,0x17b8,0x17b8,0x17b8,0x17af,0x17af,0x17af,0x17a9,
-0x17ac,0x17ac,0x17ac,0x19d4,0x219,0x219,0x219,0x219,0x17b5,0x17b5,0x17b5,0x17b5,0x17b5,0x17b5,0x17b5,0x17b5,
-0x17b5,0x17b5,0x219,0x219,0x219,0x219,0x17b2,0x17b2,0x17d3,0x17d3,0x17d3,0x17d3,0x17d3,0x17d3,0x17d3,0x17d3,
-0x17d3,0x21c,0x17d3,0x17d3,0x17d3,0x17d3,0x17d3,0x17d3,0x17d3,0x17d3,0x17d3,0x17d3,0x17d3,0x17d3,0x17d3,0x17d3,
-0x17d3,0x17d3,0x17d3,0x17d3,0x17d3,0x17d3,0x17d3,0x17d3,0x17d3,0x17d3,0x17d3,0x17d0,0x17be,0x17be,0x17be,0x17be,
-0x17be,0x17be,0x17be,0x21c,0x17be,0x17be,0x17be,0x17be,0x17be,0x17be,0x17d0,0x17c1,0x17d3,0x17d6,0x17d6,0x17ca,
-0x17c7,0x17c7,0x21c,0x21c,0x21c,0x21c,0x21c,0x21c,0x21c,0x21c,0x21c,0x21c,0x17cd,0x17cd,0x17cd,0x17cd,
-0x17cd,0x17cd,0x17cd,0x17cd,0x17cd,0x17cd,0x17c4,0x17c4,0x17c4,0x17c4,0x17c4,0x17c4,0x17c4,0x17c4,0x17c4,0x17c4,
-0x17c4,0x17c4,0x17c4,0x17c4,0x17c4,0x21c,0x21c,0x21c,0x17e2,0x17e5,0x17eb,0x17eb,0x17eb,0x17eb,0x17eb,0x17eb,
-0x17eb,0x17eb,0x17eb,0x17eb,0x17eb,0x17eb,0x17eb,0x17eb,0x17d9,0x17d9,0x17d9,0x17d9,0x17d9,0x17d9,0x17d9,0x17d9,
-0x17d9,0x21f,0x21f,0x21f,0x21f,0x21f,0x21f,0x21f,0x1944,0x1944,0x1944,0x1944,0x1944,0x1944,0x1944,0x1944,
-0x1944,0x1944,0x1944,0x1944,0x1944,0x1944,0x1944,0x1944,0x17dc,0x17dc,0x17dc,0x17dc,0x17dc,0x17dc,0x17dc,0x222,
-0x17dc,0x17dc,0x17dc,0x17dc,0x17dc,0x17dc,0x17dc,0x17dc,0x17dc,0x17dc,0x17dc,0x17dc,0x17dc,0x17dc,0x17dc,0x17dc,
-0x17dc,0x222,0x222,0x17dc,0x17dc,0x17dc,0x17dc,0x17dc,0x182a,0x18c6,0x1a2e,0x1a31,0x1ad9,0x225,0x225,0x225,
-0x225,0x225,0x225,0x225,0x225,0x225,0x225,0x225,0x1ad6,0x1ad6,0x225,0x225,0x225,0x225,0x225,0x225,
-0x225,0x225,0x225,0x225,0x225,0x225,0x225,0x225,0x17eb,0x17eb,0x17eb,0x17eb,0x17eb,0x17eb,0x17eb,0x17eb,
-0x17eb,0x17eb,0x17eb,0x17eb,0x17eb,0x17eb,0x17eb,0x17eb,0x228,0x228,0x17df,0x17df,0x17df,0x17df,0x17df,0x17df,
-0x17df,0x17df,0x17df,0x17df,0x17df,0x17df,0x17df,0x17df,0x228,0x17e8,0x17df,0x17df,0x17df,0x17df,0x17df,0x17df,
-0x17df,0x17e8,0x17df,0x17df,0x17e8,0x17df,0x17df,0x228,0x228,0x228,0x228,0x228,0x228,0x228,0x228,0x228,
-0x17ee,0x17ee,0x17ee,0x17ee,0x17ee,0x17ee,0x17ee,0x17ee,0x17ee,0x17ee,0x17ee,0x17ee,0x17ee,0x22b,0x22b,0x22b,
+0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x177,0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,
+0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,
+0x134d,0x1347,0x1347,0x1347,0x17a,0x17a,0x134a,0x17a,0x135f,0x135f,0x135f,0x135f,0x135f,0x135f,0x1350,0x1359,
+0x1353,0x1353,0x1359,0x1359,0x1359,0x1353,0x1359,0x1353,0x1353,0x1353,0x135c,0x135c,0x17d,0x17d,0x17d,0x17d,
+0x17d,0x17d,0x17d,0x17d,0x1356,0x1356,0x1356,0x1356,0x180,0x1362,0x1362,0x1362,0x1362,0x1362,0x1362,0x180,
+0x180,0x1362,0x1362,0x1362,0x1362,0x1362,0x1362,0x180,0x180,0x1362,0x1362,0x1362,0x1362,0x1362,0x1362,0x180,
+0x180,0x180,0x180,0x180,0x180,0x180,0x180,0x180,0x1362,0x1362,0x1362,0x1362,0x1362,0x1362,0x1362,0x180,
+0x1362,0x1362,0x1362,0x1362,0x1362,0x1362,0x1362,0x180,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,
+0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x1365,0x1365,0x1365,0x1365,0x1365,0x1365,0x1368,0x137a,
+0x137a,0x136e,0x136e,0x136e,0x136e,0x136e,0x183,0x183,0x183,0x183,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,
+0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x1371,0x1371,0x1371,0x1371,0x1371,0x1371,
+0x1371,0x1371,0x1371,0x1371,0x1b42,0x1b45,0x1b45,0x1b3f,0x1b3f,0x1b45,0x183,0x183,0x183,0x183,0x183,0x183,
+0x183,0x183,0x183,0x1533,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,
+0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x186,0x186,0x186,
+0x186,0x186,0x186,0x186,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,
+0x1380,0x1380,0x1380,0x189,0x189,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,
+0x1380,0x1380,0x1380,0x1536,0x189,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,
+0x1380,0x1380,0x1380,0x13b0,0x189,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,
+0x1380,0x1380,0x1380,0x1380,0x1536,0x1536,0x1536,0x1536,0x1536,0x1536,0x1536,0x1536,0x1536,0x1536,0x1536,0x1536,
+0x1536,0x1536,0x1536,0x1536,0x1536,0x1536,0x1536,0x1536,0x1536,0x1536,0x189,0x189,0x189,0x189,0x189,0x189,
+0x189,0x189,0x189,0x189,0x13c5,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x1542,0x1542,0x1542,0x1542,0x1542,0x1542,
+0x16b0,0x1542,0x1542,0x1542,0x1782,0x1833,0x1833,0x186c,0x186c,0x1a34,0x1adf,0x1adf,0x18c,0x18c,0x18c,0x18c,
+0x1c2c,0x1bae,0x1bae,0x1bae,0x1542,0x1542,0x1542,0x1542,0x1542,0x1542,0x1542,0x1542,0x1542,0x1542,0x1542,0x16ad,
+0x16ad,0x18c,0x18c,0x18c,0x1542,0x1542,0x1542,0x1542,0x1833,0x1833,0x1833,0x18cf,0x18cf,0x19b0,0x1a34,0x1adf,
+0x1adf,0x18c,0x18c,0x18c,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,
+0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1bd2,0x1bd2,0x1bd2,0x18f,0x18f,0x18f,0x18f,0x1bd2,
+0x1bd2,0x1bd2,0x1bd2,0x1bd2,0x141f,0x141f,0x141f,0x141f,0x192,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,
+0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,
+0x141f,0x141f,0x141f,0x141f,0x192,0x141f,0x141f,0x192,0x141f,0x192,0x192,0x141f,0x192,0x141f,0x141f,0x141f,
+0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x192,0x141f,0x141f,0x141f,0x141f,0x192,0x141f,0x192,0x141f,
+0x192,0x192,0x192,0x192,0x192,0x192,0x141f,0x192,0x192,0x192,0x192,0x141f,0x192,0x141f,0x192,0x141f,
+0x192,0x141f,0x141f,0x141f,0x192,0x141f,0x141f,0x192,0x141f,0x192,0x192,0x141f,0x192,0x141f,0x192,0x141f,
+0x192,0x141f,0x192,0x141f,0x192,0x141f,0x141f,0x192,0x141f,0x192,0x192,0x141f,0x141f,0x141f,0x141f,0x192,
+0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x192,0x141f,0x141f,0x141f,0x141f,0x192,0x141f,0x141f,0x141f,
+0x141f,0x192,0x141f,0x192,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x192,0x141f,
+0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,
+0x192,0x192,0x192,0x192,0x192,0x141f,0x141f,0x141f,0x192,0x141f,0x141f,0x141f,0x141f,0x141f,0x192,0x141f,
+0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,0x141f,
+0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,
+0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,
+0x141c,0x141c,0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,
+0x1434,0x1434,0x1434,0x1434,0x1434,0x1434,0x1434,0x1422,0x1422,0x1422,0x1422,0x1422,0x1431,0x1422,0x1425,0x1425,
+0x1422,0x1422,0x1422,0x1428,0x1428,0x195,0x142e,0x142e,0x142e,0x142e,0x142e,0x142e,0x142e,0x142e,0x142e,0x142e,
+0x142b,0x1437,0x1437,0x1437,0x1932,0x192f,0x192f,0x1a7c,0x195,0x195,0x195,0x195,0x195,0x195,0x195,0x195,
+0x15d2,0x15d2,0x15d2,0x15d2,0x15d2,0x15d2,0x15d2,0x15d2,0x15d2,0x15d2,0x15d2,0x15d2,0x15d2,0x15d2,0x15d2,0x15d2,
+0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,0x1440,0x143a,0x143a,0x1440,0x1440,
+0x1449,0x1449,0x1443,0x1446,0x1446,0x1440,0x143d,0x198,0x198,0x198,0x198,0x198,0x198,0x198,0x198,0x198,
+0x144c,0x144c,0x144c,0x144c,0x144c,0x144c,0x144c,0x144c,0x144c,0x144c,0x144c,0x144c,0x144c,0x144c,0x144c,0x144c,
+0x144c,0x144c,0x144c,0x144c,0x144c,0x144c,0x144c,0x144c,0x19b,0x19b,0x19b,0x19b,0x1707,0x1707,0x144c,0x144c,
+0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,
+0x19b,0x19b,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,
+0x1458,0x1458,0x1458,0x1458,0x1458,0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,0x19e,0x19e,0x19e,0x19e,0x19d7,
+0x1458,0x1455,0x1455,0x1455,0x1455,0x1455,0x1455,0x1455,0x1455,0x1455,0x1455,0x1455,0x1455,0x1455,0x1455,0x1455,
+0x19da,0x19da,0x19da,0x19da,0x19da,0x19da,0x19da,0x19da,0x19e,0x19e,0x19e,0x19e,0x19e,0x19e,0x19e,0x1452,
+0x1452,0x1452,0x1452,0x145b,0x145b,0x145b,0x145b,0x145b,0x145b,0x145b,0x145b,0x145b,0x145b,0x145b,0x145b,0x145b,
+0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x1a1,0x1a1,0x1a1,0x1a1,0x1a1,0x1a1,0x1a1,
+0x1479,0x1479,0x1479,0x1479,0x1479,0x1479,0x1479,0x1479,0x1479,0x1479,0x1a1,0x1a1,0x1a1,0x1a1,0x1a1,0x1a1,
+0x147f,0x147f,0x147f,0x147f,0x147f,0x147f,0x147f,0x147f,0x1a4,0x1a4,0x1a4,0x1a4,0x1a4,0x1a4,0x1a4,0x1a4,
+0x12db,0x12d8,0x12db,0x12b7,0x12d8,0x12de,0x12de,0x12e1,0x12de,0x12e1,0x12e4,0x12d8,0x12e1,0x12e1,0x12d8,0x12d8,
+0x1491,0x1491,0x1491,0x1491,0x1491,0x1491,0x1491,0x1491,0x1491,0x1491,0x1491,0x1482,0x148b,0x1482,0x148b,0x148b,
+0x1482,0x1482,0x1482,0x1482,0x1482,0x1482,0x148e,0x1485,0x19e0,0x1b51,0x1a7,0x1a7,0x1a7,0x1a7,0x1a7,0x1a7,
+0x1554,0x1554,0x1554,0x1554,0x1554,0x1554,0x1554,0x1554,0x1554,0x1554,0x1554,0x1554,0x1554,0x1554,0x1aa,0x1aa,
+0x1551,0x1551,0x1551,0x1551,0x1551,0x1557,0x1aa,0x1aa,0x1aa,0x1aa,0x1aa,0x1aa,0x1aa,0x1aa,0x1aa,0x1aa,
+0x155d,0x155d,0x155d,0x155d,0x1ad,0x1ad,0x1ad,0x1ad,0x1ad,0x1ad,0x1ad,0x1ad,0x1ad,0x1ad,0x1ad,0x155a,
+0x1b9c,0x1b9c,0x1b9c,0x1b9c,0x1b9c,0x1b9c,0x1b9c,0x1b9c,0x1b9c,0x1b9c,0x1b9c,0x2b2,0x1b9c,0x1b9c,0x1b9c,0x1b9c,
+0x16bc,0x16b3,0x16b3,0x16b3,0x16b3,0x16b3,0x16b3,0x16b3,0x16b3,0x16b3,0x16b3,0x16b3,0x16b3,0x16b3,0x16b3,0x16b3,
+0x16b3,0x16b3,0x16b3,0x16b3,0x16b3,0x16b3,0x16b3,0x16b3,0x16b3,0x16b3,0x16b3,0x16b3,0x1b0,0x1b0,0x1b0,0x1b0,
+0x1a85,0x1b57,0x1b57,0x1b57,0x1b57,0x1b57,0x1b57,0x1b57,0x1b57,0x1b57,0x1b57,0x1b57,0x1b54,0x1b54,0x1b54,0x1b3,
+0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,
+0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,
+0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,
+0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x1b6,0x1b6,0x1b6,
+0x1b6,0x1b6,0x1b6,0x1b6,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x1b6,0x1b6,
+0x156c,0x1566,0x1569,0x1572,0x1575,0x1575,0x1575,0x1575,0x1575,0x1575,0x1575,0x1575,0x1b9,0x1b9,0x1b9,0x1b9,
+0x1b9,0x1b9,0x1b9,0x1b9,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,
+0x155d,0x155d,0x155d,0x155d,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,
+0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1935,0x1935,0x1935,0x1935,0x1bd5,0x1bc,0x1bc,
+0x1bc,0x1bc,0x1bc,0x1bc,0x1a37,0x1a37,0x1a37,0x1a37,0x1a37,0x1a37,0x1a37,0x1a37,0x1a37,0x1a37,0x1a37,0x1a37,
+0x1bc,0x1bc,0x1bc,0x1bc,0x1bb1,0x1bc,0x1bc,0x1bc,0x1bc,0x1bc,0x1bc,0x1bc,0x1bc,0x1bc,0x1bc,0x1bc,
+0x1bc,0x1bc,0x1bc,0x1bc,0x171c,0x16bf,0x1581,0x16c5,0x1bf,0x158a,0x158a,0x158a,0x158a,0x158a,0x158a,0x158a,
+0x158a,0x1bf,0x1bf,0x158a,0x158a,0x1bf,0x1bf,0x158a,0x158a,0x158a,0x158a,0x158a,0x158a,0x158a,0x158a,0x158a,
+0x158a,0x158a,0x158a,0x158a,0x158a,0x1bf,0x158a,0x158a,0x158a,0x158a,0x158a,0x158a,0x158a,0x1bf,0x158a,0x158a,
+0x1bf,0x158a,0x158a,0x158a,0x158a,0x158a,0x1bf,0x19bc,0x16c2,0x158a,0x157b,0x1581,0x157b,0x1581,0x1581,0x1581,
+0x1581,0x1bf,0x1bf,0x1581,0x1581,0x1bf,0x1bf,0x1584,0x1584,0x1587,0x1bf,0x1bf,0x171f,0x1bf,0x1bf,0x1bf,
+0x1bf,0x1bf,0x1bf,0x157b,0x1bf,0x1bf,0x1bf,0x1bf,0x1bf,0x158d,0x158a,0x158a,0x158a,0x158a,0x1581,0x1581,
+0x1bf,0x1bf,0x157e,0x157e,0x157e,0x157e,0x157e,0x157e,0x157e,0x1bf,0x1bf,0x1bf,0x157e,0x157e,0x157e,0x157e,
+0x157e,0x1bf,0x1bf,0x1bf,0x1bf,0x1bf,0x1bf,0x1bf,0x1bf,0x1bf,0x1bf,0x1bf,0x15a2,0x15a2,0x15a2,0x15a2,
+0x15a2,0x15a2,0x15a2,0x15a2,0x15a2,0x15a2,0x15a2,0x15a2,0x15a2,0x15a2,0x15a2,0x15a2,0x15a2,0x15a2,0x1c2,0x15a2,
+0x15a2,0x15a2,0x15a2,0x15a2,0x15a2,0x15a2,0x15a2,0x15a2,0x15a2,0x15a2,0x15a2,0x15a2,0x15b4,0x15b4,0x15b4,0x15a8,
+0x15a8,0x15a8,0x15a8,0x15a8,0x15a8,0x15ab,0x15ae,0x1c5,0x1c5,0x1c5,0x1c5,0x1c5,0x15b1,0x15b1,0x15b1,0x15b1,
+0x15b1,0x15b1,0x15b1,0x15b1,0x15b1,0x15b1,0x1c5,0x1c5,0x1c5,0x1c5,0x1c5,0x1c5,0x1722,0x1722,0x1722,0x1722,
+0x15c0,0x15bd,0x19e3,0x19e3,0x1a8b,0x1a8e,0x1a88,0x1a88,0x1c8,0x1c8,0x1c8,0x1c8,0x174f,0x174f,0x174f,0x174f,
+0x174f,0x174f,0x174f,0x174f,0x174f,0x174f,0x174f,0x174f,0x174f,0x174f,0x174f,0x174f,0x15c6,0x15c6,0x15c6,0x15c6,
+0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,
+0x15c6,0x15c6,0x15c6,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0x15c6,0x15c6,0x15c6,0x15c6,
+0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,
+0x15c6,0x15c6,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0x15c6,0x15c6,0x15c6,0x15c6,
+0x15c6,0x15c6,0x15c6,0x15c6,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,
+0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0x15d2,0x15d2,0x15d2,0x15d2,
+0x15d2,0x15d2,0x15d2,0x15d2,0x15d2,0x15d2,0x15d2,0x15d2,0x15d2,0x15d2,0x15d2,0x15d2,0x15d2,0x15d2,0x15d2,0x15c9,
+0x15cc,0x15cf,0x15d2,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x15e1,0x15e1,0x15e1,0x15e1,
+0x15e1,0x15d5,0x15d5,0x1d1,0x1d1,0x1d1,0x1d1,0x15d8,0x15d8,0x15d8,0x15d8,0x15d8,0x15de,0x15de,0x16c8,0x15de,
+0x15de,0x15de,0x15db,0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,0x15ea,0x15ea,0x15ea,0x15ea,
+0x15ea,0x1d4,0x1d4,0x15e7,0x15e7,0x15e7,0x15e7,0x15e7,0x15e7,0x15e7,0x15e7,0x15e7,0x15e4,0x15e4,0x15e4,0x15e4,
+0x15e4,0x15e4,0x15e4,0x1d4,0x1d4,0x1d4,0x1d4,0x1d4,0x1d4,0x1d4,0x1d4,0x1d4,0x15ed,0x15ff,0x15ff,0x15f3,
+0x15fc,0x1d7,0x1d7,0x1d7,0x1d7,0x1d7,0x1d7,0x1d7,0x1d7,0x1d7,0x1d7,0x1d7,0x15f6,0x15f6,0x15f6,0x15f6,
+0x15f6,0x15f6,0x15f6,0x15f6,0x15f6,0x15f6,0x1d7,0x1d7,0x1d7,0x1d7,0x1d7,0x1d7,0x1605,0x1605,0x1605,0x1605,
+0x1605,0x1605,0x1605,0x1605,0x1605,0x1605,0x1605,0x1605,0x1605,0x1605,0x1605,0x1605,0x1605,0x1605,0x1605,0x1605,
+0x1605,0x1605,0x1605,0x1605,0x1605,0x1605,0x1605,0x1605,0x1605,0x1605,0x1605,0x1da,0x1602,0x1602,0x1602,0x1602,
+0x1602,0x1602,0x1602,0x1602,0x1602,0x1602,0x1da,0x1da,0x1da,0x1da,0x1608,0x1608,0x1b8d,0x1b8d,0x1b8d,0x1b8d,
+0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1611,0x1611,0x1611,0x1611,
+0x1611,0x160b,0x1614,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x160e,0x160e,0x160e,0x160e,
+0x160e,0x160e,0x160e,0x160e,0x160e,0x160e,0x1611,0x1611,0x1611,0x1611,0x1611,0x1dd,0x161a,0x161a,0x161a,0x161a,
+0x161a,0x161a,0x161a,0x161a,0x161a,0x161a,0x161a,0x161a,0x161a,0x161a,0x161a,0x161a,0x161a,0x161a,0x161a,0x161a,
+0x161a,0x161a,0x161a,0x161a,0x161a,0x161a,0x161a,0x161a,0x161a,0x161a,0x161a,0x1e0,0x1626,0x1626,0x1626,0x1626,
+0x1626,0x1626,0x1626,0x1626,0x1626,0x1626,0x1626,0x1626,0x1626,0x1626,0x1626,0x1626,0x1626,0x1626,0x1626,0x1626,
+0x1626,0x1626,0x1623,0x1623,0x1623,0x1623,0x1623,0x1e3,0x1e3,0x1e3,0x1e3,0x1e3,0x163e,0x163e,0x1641,0x1641,
+0x1644,0x1635,0x1e6,0x1e6,0x1e6,0x1e6,0x1e6,0x1e6,0x1e6,0x1e6,0x1e6,0x1e6,0x163b,0x163b,0x163b,0x163b,
+0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x1e6,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x1e6,0x163e,
+0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,
+0x163e,0x163e,0x163e,0x163e,0x1e6,0x1e6,0x1e6,0x1e6,0x1e6,0x163e,0x163e,0x163e,0x164d,0x164d,0x164d,0x164d,
+0x164d,0x164d,0x164d,0x164d,0x164d,0x164d,0x164d,0x164d,0x164d,0x164d,0x164d,0x164d,0x164d,0x164d,0x164d,0x164d,
+0x164d,0x164d,0x164d,0x164d,0x164d,0x1e9,0x1e9,0x1e9,0x1e9,0x1e9,0x1e9,0x1e9,0x1656,0x1656,0x1656,0x1656,
+0x1656,0x1656,0x1656,0x1656,0x1656,0x1656,0x1656,0x1656,0x1656,0x1656,0x1656,0x1656,0x1656,0x1656,0x1ec,0x1ec,
+0x1ec,0x1ec,0x1ec,0x1ec,0x1ec,0x1653,0x1653,0x1653,0x1653,0x1ec,0x1ec,0x1ec,0x1671,0x1671,0x1671,0x1671,
+0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1659,0x166b,0x166b,0x1659,0x1659,
+0x1659,0x1659,0x1f2,0x1f2,0x166b,0x166b,0x166e,0x166e,0x1659,0x1659,0x166b,0x165f,0x165c,0x1662,0x1674,0x1674,
+0x1665,0x1665,0x1668,0x1668,0x1668,0x1674,0x172b,0x172b,0x172b,0x172b,0x172b,0x172b,0x172b,0x172b,0x172b,0x172b,
+0x172b,0x172b,0x172b,0x172b,0x1728,0x1728,0x1728,0x1728,0x1725,0x1725,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,
+0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,
+0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f5,0x1677,0x1677,0x1677,
+0x1677,0x1677,0x1677,0x1677,0x1677,0x1677,0x1677,0x1677,0x1677,0x1677,0x1677,0x1677,0x1677,0x1677,0x1677,0x1677,
+0x1677,0x1f5,0x1f5,0x1f5,0x1f5,0x1f5,0x1f5,0x1f5,0x1f5,0x1f5,0x1f5,0x1f5,0x167a,0x167a,0x167a,0x167a,
+0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x1f8,0x1f8,0x1f8,0x1f8,0x167a,0x167a,0x167a,0x167a,
+0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x1f8,0x1f8,0x1f8,0x1f8,
+0x1f8,0x1f8,0x1f8,0x1f8,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x1f8,0x1f8,
+0x1f8,0x1f8,0x1f8,0x1f8,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x1f8,0x1f8,0x1f8,0x1f8,
+0x1f8,0x1f8,0x1f8,0x1f8,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,
+0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x1f8,0x1f8,0x1a91,0x1a91,0x1f8,0x1f8,0x1f8,0x1f8,0x1f8,0x1f8,
+0x1f8,0x1f8,0x1f8,0x1f8,0x1f8,0x1f8,0x1f8,0x1f8,0x1f8,0x1f8,0x1f8,0x1f8,0x1f8,0x1f8,0x1f8,0x1f8,
+0x1f8,0x1f8,0x1f8,0x1f8,0x1f8,0x1f8,0x1f8,0x1f8,0x1f8,0x1f8,0x1f8,0x1f8,0x167d,0x168c,0x1683,0x1680,
+0x1692,0x1692,0x1686,0x1692,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1689,0x1689,0x1689,0x1689,
+0x1689,0x1689,0x1689,0x1689,0x1689,0x1689,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1698,0x1698,0x1698,0x1698,
+0x1698,0x1698,0x1698,0x1698,0x1698,0x1698,0x1695,0x1695,0x1695,0x1695,0x1695,0x1695,0x1695,0x1695,0x1695,0x1fe,
+0x1fe,0x1fe,0x1fe,0x1fe,0x1fe,0x1fe,0x1fe,0x1fe,0x1fe,0x1fe,0x1fe,0x169e,0x1740,0x1740,0x1740,0x1740,
+0x1740,0x1740,0x1740,0x1740,0x1740,0x1740,0x1740,0x1740,0x1740,0x1740,0x1740,0x1740,0x1740,0x1740,0x1740,0x1740,
+0x1740,0x1740,0x1740,0x1740,0x1740,0x1740,0x1938,0x201,0x201,0x172e,0x172e,0x172e,0x173a,0x173a,0x172e,0x172e,
+0x172e,0x172e,0x173d,0x172e,0x172e,0x172e,0x172e,0x1731,0x201,0x201,0x201,0x201,0x1737,0x1737,0x1737,0x1737,
+0x1737,0x1737,0x1737,0x1737,0x1737,0x1737,0x1734,0x1734,0x1743,0x1743,0x1743,0x1734,0x1746,0x1746,0x1746,0x1746,
+0x1746,0x1746,0x1746,0x204,0x204,0x204,0x204,0x204,0x204,0x204,0x204,0x204,0x204,0x204,0x204,0x204,
+0x204,0x204,0x204,0x204,0x204,0x204,0x204,0x204,0x204,0x204,0x204,0x204,0x204,0x204,0x204,0x204,
+0x204,0x204,0x204,0x204,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,
+0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x20a,0x1758,0x1758,0x20a,0x20a,0x20a,0x20a,0x20a,0x1755,
+0x1755,0x1755,0x1755,0x1755,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x20d,0x175b,0x20d,0x175b,0x175b,
+0x175b,0x175b,0x20d,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,
+0x175b,0x175b,0x20d,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175e,0x20d,0x20d,
+0x20d,0x20d,0x20d,0x20d,0x15b7,0x15b7,0x15b7,0x15b7,0x15b7,0x15b7,0x15b7,0x15b7,0x15b7,0x15b7,0x15b7,0x15b7,
+0x15b7,0x15b7,0x15b7,0x15b7,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,
+0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x210,0x210,0x210,0x210,0x210,0x210,0x210,0x210,0x210,
+0x210,0x210,0x210,0x210,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,
+0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x210,0x210,0x210,0x210,0x210,0x210,0x210,0x1761,0x1761,
+0x1761,0x1761,0x1761,0x1761,0x176d,0x176d,0x176d,0x176d,0x176a,0x176d,0x176d,0x1770,0x1773,0x1770,0x1770,0x176d,
+0x213,0x213,0x213,0x213,0x213,0x213,0x213,0x213,0x213,0x213,0x213,0x213,0x213,0x213,0x213,0x176a,
+0x176a,0x176a,0x176a,0x176a,0x17ca,0x17ca,0x17ca,0x17ca,0x17c1,0x17c1,0x17c1,0x17bb,0x17be,0x17be,0x17be,0x19e6,
+0x216,0x216,0x216,0x216,0x17c7,0x17c7,0x17c7,0x17c7,0x17c7,0x17c7,0x17c7,0x17c7,0x17c7,0x17c7,0x216,0x216,
+0x216,0x216,0x17c4,0x17c4,0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x219,0x17e5,0x17e5,
+0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,
+0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x17e2,0x17d0,0x17d0,0x17d0,0x17d0,0x17d0,0x17d0,0x17d0,0x219,
+0x17d0,0x17d0,0x17d0,0x17d0,0x17d0,0x17d0,0x17e2,0x17d3,0x17e5,0x17e8,0x17e8,0x17dc,0x17d9,0x17d9,0x219,0x219,
+0x219,0x219,0x219,0x219,0x219,0x219,0x219,0x219,0x17df,0x17df,0x17df,0x17df,0x17df,0x17df,0x17df,0x17df,
+0x17df,0x17df,0x17d6,0x17d6,0x17d6,0x17d6,0x17d6,0x17d6,0x17d6,0x17d6,0x17d6,0x17d6,0x17d6,0x17d6,0x17d6,0x17d6,
+0x17d6,0x219,0x219,0x219,0x17f4,0x17f7,0x17fd,0x17fd,0x17fd,0x17fd,0x17fd,0x17fd,0x17fd,0x17fd,0x17fd,0x17fd,
+0x17fd,0x17fd,0x17fd,0x17fd,0x17eb,0x17eb,0x17eb,0x17eb,0x17eb,0x17eb,0x17eb,0x17eb,0x17eb,0x21c,0x21c,0x21c,
+0x21c,0x21c,0x21c,0x21c,0x1956,0x1956,0x1956,0x1956,0x1956,0x1956,0x1956,0x1956,0x1956,0x1956,0x1956,0x1956,
+0x1956,0x1956,0x1956,0x1956,0x17ee,0x17ee,0x17ee,0x17ee,0x17ee,0x17ee,0x17ee,0x21f,0x17ee,0x17ee,0x17ee,0x17ee,
+0x17ee,0x17ee,0x17ee,0x17ee,0x17ee,0x17ee,0x17ee,0x17ee,0x17ee,0x17ee,0x17ee,0x17ee,0x17ee,0x21f,0x21f,0x17ee,
+0x17ee,0x17ee,0x17ee,0x17ee,0x17ee,0x17ee,0x21f,0x17ee,0x17ee,0x21f,0x17ee,0x17ee,0x17ee,0x17ee,0x17ee,0x21f,
+0x21f,0x21f,0x21f,0x21f,0x1bfc,0x1bfc,0x1bfc,0x1bfc,0x1bfc,0x1bfc,0x1bfc,0x1bfc,0x1bfc,0x1bfc,0x1bfc,0x1bfc,
+0x1bfc,0x1bfc,0x1bfc,0x1bfc,0x183c,0x18d8,0x1a40,0x1a43,0x1aeb,0x222,0x222,0x222,0x222,0x222,0x222,0x222,
+0x222,0x222,0x222,0x222,0x1ae8,0x1ae8,0x222,0x222,0x222,0x222,0x222,0x222,0x222,0x222,0x222,0x222,
+0x222,0x222,0x222,0x222,0x17fd,0x17fd,0x17fd,0x17fd,0x17fd,0x17fd,0x17fd,0x17fd,0x17fd,0x17fd,0x17fd,0x17fd,
+0x17fd,0x17fd,0x17fd,0x17fd,0x225,0x225,0x17f1,0x17f1,0x17f1,0x17f1,0x17f1,0x17f1,0x17f1,0x17f1,0x17f1,0x17f1,
+0x17f1,0x17f1,0x17f1,0x17f1,0x225,0x17fa,0x17f1,0x17f1,0x17f1,0x17f1,0x17f1,0x17f1,0x17f1,0x17fa,0x17f1,0x17f1,
+0x17fa,0x17f1,0x17f1,0x225,0x225,0x225,0x225,0x225,0x225,0x225,0x225,0x225,0x1800,0x1800,0x1800,0x1800,
+0x1800,0x1800,0x1800,0x1800,0x1800,0x1800,0x1800,0x1800,0x1800,0x228,0x228,0x228,0x228,0x228,0x228,0x228,
+0x228,0x228,0x228,0x228,0x228,0x228,0x228,0x228,0x228,0x228,0x228,0x228,0x1818,0x1818,0x1809,0x1803,
+0x1803,0x1818,0x1806,0x181b,0x181b,0x181b,0x181b,0x181e,0x181e,0x1812,0x180f,0x180c,0x1815,0x1815,0x1815,0x1815,
+0x1815,0x1815,0x1815,0x1815,0x1815,0x1815,0x1a94,0x1812,0x22b,0x180c,0x193b,0x19e9,0x1a97,0x1a97,0x22b,0x22b,
 0x22b,0x22b,0x22b,0x22b,0x22b,0x22b,0x22b,0x22b,0x22b,0x22b,0x22b,0x22b,0x22b,0x22b,0x22b,0x22b,
-0x1806,0x1806,0x17f7,0x17f1,0x17f1,0x1806,0x17f4,0x1809,0x1809,0x1809,0x1809,0x180c,0x180c,0x1800,0x17fd,0x17fa,
-0x1803,0x1803,0x1803,0x1803,0x1803,0x1803,0x1803,0x1803,0x1803,0x1803,0x1a82,0x1800,0x22e,0x17fa,0x1929,0x19d7,
-0x1a85,0x1a85,0x22e,0x22e,0x22e,0x22e,0x22e,0x22e,0x22e,0x22e,0x22e,0x22e,0x22e,0x22e,0x22e,0x22e,
-0x22e,0x22e,0x22e,0x22e,0x22e,0x22e,0x22e,0x22e,0x22e,0x22e,0x22e,0x22e,0x22e,0x22e,0x22e,0x22e,
-0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,
-0x1812,0x1812,0x1812,0x1812,0x231,0x231,0x231,0x231,0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,
-0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,
-0x180f,0x180f,0x180f,0x180f,0x231,0x231,0x231,0x231,0x182d,0x182d,0x182d,0x182d,0x182d,0x182d,0x182d,0x182d,
-0x182d,0x182d,0x182d,0x182d,0x182d,0x19a7,0x19a7,0x19a7,0x19a7,0x19a7,0x1a34,0x1a34,0x1a34,0x1a34,0x1a34,0x1a34,
-0x234,0x234,0x234,0x234,0x234,0x234,0x234,0x234,0x1ba8,0x1ba8,0x1ba8,0x237,0x237,0x237,0x237,0x237,
-0x237,0x237,0x237,0x237,0x237,0x237,0x237,0x237,0x279,0x279,0x279,0x279,0x279,0x279,0x279,0x279,
-0x279,0x279,0x279,0x279,0x279,0x279,0x279,0x279,0x186c,0x186c,0x186c,0x186c,0x186c,0x186c,0x186c,0x23a,
-0x186c,0x186c,0x23a,0x186c,0x186c,0x186c,0x186c,0x186c,0x186c,0x186c,0x186c,0x186c,0x186c,0x186c,0x186c,0x186c,
-0x186c,0x186c,0x186c,0x186c,0x186c,0x186c,0x186c,0x186c,0x186c,0x1860,0x1860,0x1860,0x1860,0x1860,0x1860,0x23a,
-0x23a,0x23a,0x1860,0x23a,0x1860,0x1860,0x23a,0x1860,0x1860,0x1860,0x1863,0x1860,0x1866,0x1866,0x186f,0x1860,
-0x23a,0x23a,0x23a,0x23a,0x23a,0x23a,0x23a,0x23a,0x1869,0x1869,0x1869,0x1869,0x1869,0x1869,0x1869,0x1869,
-0x1869,0x1869,0x23a,0x23a,0x23a,0x23a,0x23a,0x23a,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,
-0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,
-0x18cf,0x18cf,0x18cf,0x18cf,0x23d,0x23d,0x23d,0x23d,0x187e,0x1881,0x1881,0x240,0x240,0x240,0x240,0x240,
-0x240,0x240,0x240,0x240,0x240,0x240,0x240,0x240,0x1b84,0x1b84,0x1b84,0x1b84,0x1b84,0x1b84,0x1b84,0x1b84,
-0x1b84,0x1b84,0x1b84,0x1b84,0x1b84,0x1b84,0x1b84,0x1b84,0x1890,0x1890,0x1890,0x1890,0x1890,0x1890,0x1890,0x1890,
-0x1890,0x1890,0x1890,0x243,0x243,0x243,0x243,0x243,0x1b51,0x1b51,0x1b51,0x1b51,0x1b51,0x1b51,0x1b51,0x1b51,
-0x1b51,0x1b51,0x1b51,0x1b51,0x1b51,0x1b51,0x1b51,0x1b51,0x189c,0x189f,0x18ae,0x18ae,0x189f,0x18a2,0x189c,0x1899,
-0x246,0x246,0x246,0x246,0x246,0x246,0x246,0x246,0x1887,0x1872,0x1872,0x1872,0x1872,0x1872,0x1872,0x1884,
-0x1884,0x1872,0x1872,0x1872,0x1887,0x1887,0x1887,0x1887,0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,
-0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,0x249,0x249,0x249,0x249,
-0x249,0x249,0x249,0x249,0x249,0x249,0x249,0x249,0x192f,0x192f,0x192f,0x192f,0x192f,0x192f,0x192f,0x192f,
-0x192f,0x192f,0x192f,0x192f,0x192f,0x192f,0x249,0x249,0x1a3d,0x1a3d,0x1a3d,0x1a3d,0x1adf,0x27c,0x27c,0x27c,
-0x1a3d,0x1a3d,0x1a3d,0x1bab,0x1bab,0x27c,0x27c,0x27c,0x1941,0x1941,0x1941,0x1941,0x1941,0x1941,0x1941,0x1941,
-0x1941,0x1941,0x1941,0x1941,0x193e,0x193e,0x193e,0x1932,0x1932,0x1932,0x1932,0x1932,0x1932,0x1932,0x1932,0x1932,
-0x193e,0x1938,0x1935,0x193b,0x24c,0x24c,0x24c,0x24c,0x1944,0x1944,0x1944,0x1944,0x1944,0x1944,0x1944,0x1944,
-0x1944,0x1944,0x1944,0x1944,0x1944,0x1944,0x1944,0x1944,0x1944,0x1944,0x1944,0x1944,0x1944,0x1944,0x1944,0x1944,
-0x1944,0x1944,0x1944,0x24f,0x24f,0x1944,0x1944,0x1944,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x252,0x1953,
-0x1953,0x252,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,
-0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1950,0x1950,0x1950,0x1950,0x1950,0x252,
-0x1947,0x1947,0x252,0x1950,0x1950,0x1947,0x1950,0x194a,0x1953,0x252,0x252,0x252,0x252,0x252,0x252,0x252,
-0x195c,0x195c,0x195f,0x195f,0x1956,0x1956,0x1956,0x1956,0x255,0x255,0x255,0x255,0x255,0x255,0x255,0x255,
-0x1959,0x1959,0x1959,0x1959,0x1959,0x1959,0x1959,0x1959,0x1959,0x1959,0x255,0x255,0x255,0x255,0x255,0x255,
-0x1962,0x1962,0x1962,0x1962,0x1962,0x1962,0x1962,0x1962,0x1962,0x1962,0x1962,0x1962,0x1965,0x1962,0x1962,0x1962,
-0x1965,0x1962,0x1962,0x1962,0x1962,0x258,0x258,0x258,0x258,0x258,0x258,0x258,0x258,0x258,0x258,0x258,
-0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,
-0x196e,0x196e,0x196e,0x1968,0x1968,0x196b,0x196b,0x1971,0x1971,0x25b,0x25b,0x25b,0x25b,0x25b,0x25b,0x25b,
-0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,
-0x1974,0x1974,0x1974,0x1974,0x25e,0x25e,0x25e,0x25e,0x25e,0x25e,0x25e,0x25e,0x25e,0x25e,0x25e,0x25e,
-0x1977,0x1977,0x1977,0x1977,0x1977,0x1977,0x1977,0x1977,0x1977,0x1977,0x1977,0x1977,0x1977,0x1977,0x1977,0x1977,
-0x1977,0x1977,0x1977,0x1977,0x1977,0x1977,0x1977,0x197a,0x1983,0x1977,0x1977,0x261,0x261,0x261,0x261,0x261,
-0x1986,0x1986,0x1986,0x1986,0x1986,0x1986,0x1986,0x1989,0x264,0x264,0x264,0x264,0x264,0x264,0x264,0x264,
-0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,
-0x1992,0x1992,0x198c,0x198c,0x198c,0x198c,0x198c,0x198c,0x198c,0x198c,0x198c,0x198c,0x198c,0x198f,0x198f,0x198f,
-0x198f,0x1995,0x1995,0x1995,0x1995,0x1995,0x267,0x267,0x267,0x267,0x267,0x267,0x267,0x267,0x267,0x267,
-0x267,0x267,0x267,0x267,0x267,0x267,0x267,0x267,0x1b72,0x1b72,0x1b72,0x1b72,0x1b72,0x1b72,0x1b72,0x1b72,
-0x1b72,0x1b72,0x1b72,0x1b72,0x1b72,0x1b72,0x1b72,0x1b72,0x19e9,0x19e9,0x19e9,0x19e9,0x19e9,0x19e9,0x19e9,0x19e9,
-0x19e9,0x19e9,0x19e9,0x19e9,0x19e9,0x19e9,0x19e9,0x19e9,0x19e9,0x19e9,0x19e9,0x19e9,0x19e9,0x19e9,0x19e9,0x26d,
-0x26d,0x26d,0x26d,0x26d,0x26d,0x26d,0x26d,0x26d,0x19f8,0x19f8,0x19f8,0x19f8,0x19f8,0x19f8,0x19f8,0x19f8,
-0x270,0x270,0x19f8,0x19f8,0x19f8,0x19f8,0x19f8,0x19f8,0x19f8,0x19f8,0x19f8,0x19f8,0x19f8,0x19f8,0x19f8,0x19f8,
-0x19f8,0x19f8,0x19f8,0x19f8,0x19f8,0x19f8,0x19f8,0x19f8,0x19f8,0x19f5,0x19f5,0x19f5,0x19ec,0x19ec,0x19ec,0x19ec,
-0x270,0x270,0x19ec,0x19ec,0x19f5,0x19f5,0x19f5,0x19f5,0x19ef,0x19f8,0x19f2,0x19f8,0x19f5,0x270,0x270,0x270,
-0x270,0x270,0x270,0x270,0x270,0x270,0x270,0x270,0x270,0x270,0x270,0x270,0x270,0x270,0x270,0x270,
-0x270,0x270,0x270,0x270,0x270,0x270,0x270,0x270,0x1a04,0x1a04,0x1a04,0x1a04,0x1a04,0x1a04,0x1a04,0x1a04,
-0x1a04,0x1a04,0x1a04,0x1a04,0x1a04,0x273,0x273,0x273,0x19fb,0x19fb,0x19fb,0x19fb,0x19fb,0x19fb,0x19fb,0x1a04,
-0x1a04,0x1a04,0x1a04,0x1a04,0x1a07,0x1a07,0x273,0x273,0x276,0x1a0a,0x1a0a,0x1a0a,0x1a0a,0x1a0a,0x1a0a,0x1a0a,
+0x22b,0x22b,0x22b,0x22b,0x22b,0x22b,0x22b,0x22b,0x22b,0x22b,0x22b,0x22b,0x1824,0x1824,0x1824,0x1824,
+0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,
+0x22e,0x22e,0x22e,0x22e,0x1821,0x1821,0x1821,0x1821,0x1821,0x1821,0x1821,0x1821,0x1821,0x1821,0x1821,0x1821,
+0x1821,0x1821,0x1821,0x1821,0x1821,0x1821,0x1821,0x1821,0x1821,0x1821,0x1821,0x1821,0x1821,0x1821,0x1821,0x1821,
+0x22e,0x22e,0x22e,0x22e,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,
+0x183f,0x19b9,0x19b9,0x19b9,0x19b9,0x19b9,0x1a46,0x1a46,0x1a46,0x1a46,0x1a46,0x1a46,0x231,0x231,0x231,0x231,
+0x231,0x231,0x231,0x231,0x1bba,0x1bba,0x1bba,0x234,0x234,0x234,0x234,0x234,0x234,0x234,0x234,0x234,
+0x234,0x234,0x234,0x234,0x276,0x276,0x1c2f,0x276,0x276,0x276,0x276,0x276,0x276,0x276,0x276,0x276,
+0x276,0x276,0x276,0x276,0x187e,0x187e,0x187e,0x187e,0x187e,0x187e,0x187e,0x237,0x187e,0x187e,0x237,0x187e,
+0x187e,0x187e,0x187e,0x187e,0x187e,0x187e,0x187e,0x187e,0x187e,0x187e,0x187e,0x187e,0x187e,0x187e,0x187e,0x187e,
+0x187e,0x187e,0x187e,0x187e,0x187e,0x1872,0x1872,0x1872,0x1872,0x1872,0x1872,0x237,0x237,0x237,0x1872,0x237,
+0x1872,0x1872,0x237,0x1872,0x1872,0x1872,0x1875,0x1872,0x1878,0x1878,0x1881,0x1872,0x237,0x237,0x237,0x237,
+0x237,0x237,0x237,0x237,0x187b,0x187b,0x187b,0x187b,0x187b,0x187b,0x187b,0x187b,0x187b,0x187b,0x237,0x237,
+0x237,0x237,0x237,0x237,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,
+0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,
+0x23a,0x23a,0x23a,0x23a,0x1890,0x1893,0x1893,0x23d,0x23d,0x23d,0x23d,0x23d,0x23d,0x23d,0x23d,0x23d,
+0x23d,0x23d,0x23d,0x23d,0x1b96,0x1b96,0x1b96,0x1b96,0x1b96,0x1b96,0x1b96,0x1b96,0x1b96,0x1b96,0x1b96,0x1b96,
+0x1b96,0x1b96,0x1b96,0x1b96,0x18a2,0x18a2,0x18a2,0x18a2,0x18a2,0x18a2,0x18a2,0x18a2,0x18a2,0x18a2,0x18a2,0x240,
+0x240,0x240,0x240,0x240,0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,
+0x1b63,0x1b63,0x1b63,0x1b63,0x18ae,0x18b1,0x18c0,0x18c0,0x18b1,0x18b4,0x18ae,0x18ab,0x243,0x243,0x243,0x243,
+0x243,0x243,0x243,0x243,0x1899,0x1884,0x1884,0x1884,0x1884,0x1884,0x1884,0x1896,0x1896,0x1884,0x1884,0x1884,
+0x1899,0x1899,0x1899,0x1899,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,
+0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x246,0x246,0x246,0x246,0x246,0x246,0x246,0x246,
+0x246,0x246,0x246,0x246,0x1941,0x1941,0x1941,0x1941,0x1941,0x1941,0x1941,0x1941,0x1941,0x1941,0x1941,0x1941,
+0x1941,0x1941,0x246,0x246,0x1a4f,0x1a4f,0x1a4f,0x1a4f,0x1af1,0x1c35,0x1c35,0x1c35,0x1a4f,0x1a4f,0x1a4f,0x1bbd,
+0x1bbd,0x279,0x279,0x279,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,
+0x1950,0x1950,0x1950,0x1944,0x1944,0x1944,0x1944,0x1944,0x1944,0x1944,0x1944,0x1944,0x1950,0x194a,0x1947,0x194d,
+0x249,0x249,0x249,0x249,0x1956,0x1956,0x1956,0x1956,0x1956,0x1956,0x1956,0x1956,0x1956,0x1956,0x1956,0x1956,
+0x1956,0x1956,0x1956,0x1956,0x1956,0x1956,0x1956,0x1956,0x1956,0x1956,0x1956,0x1956,0x1956,0x1956,0x1956,0x24c,
+0x24c,0x1956,0x1956,0x1956,0x1965,0x1965,0x1965,0x1965,0x1965,0x1965,0x24f,0x1965,0x1965,0x24f,0x1965,0x1965,
+0x1965,0x1965,0x1965,0x1965,0x1965,0x1965,0x1965,0x1965,0x1965,0x1965,0x1965,0x1965,0x1965,0x1965,0x1965,0x1965,
+0x1965,0x1965,0x1965,0x1965,0x1965,0x1965,0x1962,0x1962,0x1962,0x1962,0x1962,0x24f,0x1959,0x1959,0x24f,0x1962,
+0x1962,0x1959,0x1962,0x195c,0x1965,0x24f,0x24f,0x24f,0x24f,0x24f,0x24f,0x24f,0x196e,0x196e,0x1971,0x1971,
+0x1968,0x1968,0x1968,0x1968,0x252,0x252,0x252,0x252,0x252,0x252,0x252,0x252,0x196b,0x196b,0x196b,0x196b,
+0x196b,0x196b,0x196b,0x196b,0x196b,0x196b,0x252,0x252,0x252,0x252,0x252,0x252,0x1974,0x1974,0x1974,0x1974,
+0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1977,0x1974,0x1974,0x1974,0x1977,0x1974,0x1974,0x1974,
+0x1974,0x255,0x255,0x255,0x255,0x255,0x255,0x255,0x255,0x255,0x255,0x255,0x1980,0x1980,0x1980,0x1980,
+0x1980,0x1980,0x1980,0x1980,0x1980,0x1980,0x1980,0x1980,0x1980,0x1980,0x1980,0x1980,0x1980,0x1980,0x1980,0x197a,
+0x197a,0x197d,0x197d,0x1983,0x1983,0x258,0x258,0x258,0x258,0x258,0x258,0x258,0x1986,0x1986,0x1986,0x1986,
+0x1986,0x1986,0x1986,0x1986,0x1986,0x1986,0x1986,0x1986,0x1986,0x1986,0x1986,0x1986,0x1986,0x1986,0x1986,0x1986,
+0x25b,0x25b,0x25b,0x25b,0x25b,0x25b,0x25b,0x25b,0x25b,0x25b,0x25b,0x25b,0x1989,0x1989,0x1989,0x1989,
+0x1989,0x1989,0x1989,0x1989,0x1989,0x1989,0x1989,0x1989,0x1989,0x1989,0x1989,0x1989,0x1989,0x1989,0x1989,0x1989,
+0x1989,0x1989,0x1989,0x198c,0x1995,0x1989,0x1989,0x25e,0x25e,0x25e,0x25e,0x25e,0x1998,0x1998,0x1998,0x1998,
+0x1998,0x1998,0x1998,0x199b,0x261,0x261,0x261,0x261,0x261,0x261,0x261,0x261,0x19a4,0x19a4,0x19a4,0x19a4,
+0x19a4,0x19a4,0x19a4,0x19a4,0x19a4,0x19a4,0x19a4,0x19a4,0x19a4,0x19a4,0x19a4,0x19a4,0x19a4,0x19a4,0x199e,0x199e,
+0x199e,0x199e,0x199e,0x199e,0x199e,0x199e,0x199e,0x199e,0x199e,0x19a1,0x19a1,0x19a1,0x19a1,0x19a7,0x19a7,0x19a7,
+0x19a7,0x19a7,0x264,0x264,0x264,0x264,0x264,0x264,0x264,0x264,0x264,0x264,0x264,0x264,0x264,0x264,
+0x264,0x264,0x264,0x264,0x1b84,0x1b84,0x1b84,0x1b84,0x1b84,0x1b84,0x1b84,0x1b84,0x1b84,0x1b84,0x1b84,0x1b84,
+0x1b84,0x1b84,0x1b84,0x1b84,0x1be7,0x1bed,0x1bed,0x1bed,0x1bed,0x1bed,0x1bed,0x1bea,0x1bea,0x1bea,0x1bea,0x1bea,
+0x1bea,0x1bea,0x1bea,0x1bea,0x1bea,0x1bea,0x1bea,0x1bea,0x1bea,0x1bea,0x267,0x267,0x267,0x267,0x267,0x267,
+0x267,0x267,0x267,0x267,0x19fb,0x19fb,0x19fb,0x19fb,0x19fb,0x19fb,0x19fb,0x19fb,0x19fb,0x19fb,0x19fb,0x19fb,
+0x19fb,0x19fb,0x19fb,0x19fb,0x19fb,0x19fb,0x19fb,0x19fb,0x19fb,0x19fb,0x19fb,0x26a,0x26a,0x26a,0x26a,0x26a,
+0x26a,0x26a,0x26a,0x26a,0x1a0a,0x1a0a,0x1a0a,0x1a0a,0x1a0a,0x1a0a,0x1a0a,0x1a0a,0x26d,0x26d,0x1a0a,0x1a0a,
 0x1a0a,0x1a0a,0x1a0a,0x1a0a,0x1a0a,0x1a0a,0x1a0a,0x1a0a,0x1a0a,0x1a0a,0x1a0a,0x1a0a,0x1a0a,0x1a0a,0x1a0a,0x1a0a,
-0x1a0a,0x1a0a,0x1a0a,0x1a0a,0x1a0a,0x1a0a,0x1a0a,0x1a0a,0x1a0a,0x1a0a,0x276,0x276,0x279,0x279,0x279,0x279,
-0x279,0x279,0x279,0x279,0x279,0x279,0x279,0x279,0x279,0x279,0x279,0x279,0x1a37,0x1a37,0x1a37,0x279,
-0x279,0x279,0x279,0x279,0x279,0x279,0x279,0x279,0x279,0x279,0x279,0x279,0x1a3a,0x1a3a,0x1a3a,0x1a3a,
-0x279,0x279,0x279,0x279,0x279,0x279,0x279,0x279,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,
-0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x1a3d,0x1a3d,0x1a3d,0x1adf,0x1adf,0x1adf,0x1adf,0x27c,
-0x27c,0x27c,0x27c,0x27c,0x27c,0x27c,0x27c,0x27c,0x1a3d,0x1a3d,0x1a3d,0x1a3d,0x1a3d,0x1a3d,0x1adf,0x1adf,
-0x1adf,0x1adf,0x1adf,0x1adf,0x1adf,0x1adf,0x1adf,0x1adf,0x1adf,0x1bab,0x1bab,0x1bab,0x1bab,0x27c,0x27c,0x27c,
-0x1adf,0x1adf,0x1adf,0x1adf,0x1adf,0x1adf,0x1adf,0x1bab,0x1bab,0x1bab,0x1bab,0x27c,0x27c,0x27c,0x27c,0x27c,
-0x1adf,0x1adf,0x1adf,0x1bae,0x1bae,0x1bae,0x27c,0x27c,0x27c,0x27c,0x27c,0x27c,0x27c,0x27c,0x27c,0x27c,
-0x1adf,0x1adf,0x1adf,0x1adf,0x1adf,0x1adf,0x1adf,0x1bab,0x1bab,0x1bab,0x27c,0x27c,0x27c,0x27c,0x27c,0x27c,
-0x1bab,0x1bab,0x1bab,0x1bab,0x1bab,0x1bab,0x1bab,0x1bab,0x27c,0x27c,0x27c,0x27c,0x27c,0x27c,0x27c,0x27c,
-0x1bae,0x1bae,0x1bae,0x1bae,0x1bae,0x1bae,0x1bae,0x27c,0x27c,0x27c,0x27c,0x27c,0x27c,0x27c,0x27c,0x27c,
-0x1a13,0x1a0d,0x1a0d,0x1a0d,0x1a0d,0x1a0d,0x1a0d,0x1a0d,0x1a0d,0x1a0d,0x1a0d,0x1a0d,0x1a0d,0x1a0d,0x1a0d,0x1a0d,
-0x1a0d,0x1a0d,0x27f,0x27f,0x27f,0x27f,0x27f,0x27f,0x27f,0x27f,0x27f,0x27f,0x27f,0x27f,0x27f,0x1a10,
-0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a16,0x1a16,0x1a16,0x1a16,
-0x1a1c,0x1a1c,0x1a1c,0x1a1c,0x1a1c,0x1a1c,0x1a1c,0x1a1c,0x1a1c,0x1a1c,0x282,0x282,0x282,0x282,0x282,0x1a19,
-0x1a8b,0x1a8b,0x1a8b,0x1a8b,0x1a8b,0x1a88,0x1a88,0x1a88,0x1a88,0x1a88,0x1a88,0x1a88,0x285,0x285,0x285,0x285,
-0x285,0x285,0x285,0x285,0x285,0x285,0x285,0x285,0x285,0x285,0x285,0x285,0x285,0x285,0x285,0x285,
-0x1aa6,0x1aa6,0x1aa6,0x1aa6,0x1aa6,0x1aa6,0x1aa6,0x288,0x288,0x1aa6,0x288,0x288,0x1aa6,0x1aa6,0x1aa6,0x1aa6,
-0x1aa6,0x1aa6,0x1aa6,0x1aa6,0x288,0x1aa6,0x1aa6,0x288,0x1aa6,0x1aa6,0x1aa6,0x1aa6,0x1aa6,0x1aa6,0x1aa6,0x1aa6,
-0x1aa6,0x1aa6,0x1aa6,0x1aa6,0x1aa6,0x1aa6,0x1aa6,0x1aa6,0x1a8e,0x1a9d,0x1a9d,0x1a9d,0x1a9d,0x1a9d,0x288,0x1a9d,
-0x1aa0,0x288,0x288,0x1a8e,0x1a8e,0x1aa3,0x1a94,0x1aa9,0x1a9d,0x1aa9,0x1a9d,0x1a91,0x1aac,0x1a97,0x1aac,0x288,
-0x288,0x288,0x288,0x288,0x288,0x288,0x288,0x288,0x1a9a,0x1a9a,0x1a9a,0x1a9a,0x1a9a,0x1a9a,0x1a9a,0x1a9a,
-0x1a9a,0x1a9a,0x288,0x288,0x288,0x288,0x288,0x288,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,
-0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x28b,0x28b,
-0x28b,0x28b,0x28b,0x28b,0x28b,0x28b,0x28b,0x28b,0x28b,0x28b,0x28b,0x28b,0x28b,0x28b,0x28b,0x28b,
-0x28b,0x28b,0x28b,0x28b,0x28b,0x28b,0x28b,0x28b,0x28b,0x28b,0x28b,0x28b,0x28b,0x28b,0x28b,0x28b,
-0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,
-0x1ab2,0x1ab2,0x1ab2,0x291,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,
-0x1ab2,0x1ab2,0x1ab2,0x291,0x291,0x291,0x291,0x291,0x291,0x291,0x291,0x291,0x291,0x291,0x291,0x291,
-0x291,0x291,0x291,0x291,0x291,0x291,0x291,0x291,0x1ab5,0x1ab5,0x1ab5,0x1ab5,0x1ab5,0x1ab5,0x1ab5,0x1ab5,
-0x1ab5,0x1ab5,0x291,0x291,0x291,0x291,0x291,0x291,0x1ae8,0x1ae8,0x1ae8,0x1ae8,0x1ae8,0x1ae8,0x1ae8,0x1ae8,
-0x1ae8,0x294,0x294,0x294,0x294,0x294,0x294,0x294,0x294,0x294,0x294,0x294,0x294,0x294,0x294,0x294,
-0x294,0x294,0x294,0x294,0x294,0x294,0x294,0x294,0x294,0x294,0x294,0x294,0x294,0x294,0x294,0x294,
-0x294,0x294,0x294,0x294,0x1abe,0x1abe,0x1abe,0x1abe,0x1abe,0x1abe,0x1abe,0x1abe,0x1abe,0x1abe,0x297,0x1ab8,
-0x1ab8,0x1abb,0x297,0x297,0x1abe,0x1abe,0x297,0x297,0x297,0x297,0x297,0x297,0x297,0x297,0x297,0x297,
-0x297,0x297,0x297,0x297,0x1b51,0x1b51,0x1b51,0x1b51,0x1b51,0x1b51,0x1b51,0x1b51,0x1b4e,0x1b51,0x1b51,0x1b51,
-0x1b51,0x1b51,0x1b51,0x29a,0x1b54,0x1b54,0x29a,0x29a,0x29a,0x29a,0x29a,0x29a,0x1b4b,0x1b4b,0x1b4b,0x1b4b,
-0x1b4b,0x1b4b,0x1b4b,0x1b4b,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,
-0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b57,0x1b57,0x29d,0x29d,0x29d,0x29d,0x29d,0x29d,0x29d,0x29d,0x29d,
-0x29d,0x29d,0x29d,0x29d,0x1b5d,0x1b5d,0x1b5d,0x1b5d,0x1b5d,0x1b5d,0x1b5d,0x2a0,0x1b5d,0x1b5d,0x1b5d,0x1b5d,
-0x2a0,0x1b5d,0x1b5d,0x2a0,0x1b5d,0x1b5d,0x1b5d,0x1b5d,0x1b5d,0x1b5d,0x1b5d,0x1b5d,0x1b5d,0x1b5d,0x1b5d,0x1b5d,
-0x1b5d,0x1b5d,0x1b5d,0x2a0,0x1b60,0x1b66,0x1b66,0x1b63,0x1b63,0x1b63,0x2a6,0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,
-0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,
-0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,0x2a6,0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,0x2a6,
-0x2a6,0x2a6,0x2a6,0x2a6,0x1b69,0x1b69,0x1b69,0x1b69,0x1b69,0x1b69,0x1b69,0x1b69,0x1b69,0x1b69,0x1b6c,0x1b69,
-0x1b69,0x1b69,0x1b69,0x1b69,0x1b69,0x1b69,0x1b69,0x1b69,0x1b69,0x1b69,0x1b69,0x1b69,0x1b69,0x1b69,0x1b69,0x1b69,
-0x1b69,0x1b69,0x1b69,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,
-0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,
-0x2a9,0x2a9,0x2a9,0x2a9,0x1b72,0x1b72,0x1b6f,0x1b6f,0x1b6f,0x1b6f,0x1b75,0x1b75,0x1b75,0x1b75,0x2ac,0x2ac,
-0x2ac,0x2ac,0x2ac,0x2ac,0x2ac,0x2ac,0x2ac,0x2ac,0x2ac,0x2ac,0x2ac,0x2ac,0x2ac,0x2ac,0x2ac,0x2ac,
-0x2ac,0x2ac,0x2ac,0x2ac,0x1a8b,0x1a8b,0x1a8b,0x1a8b,0x1a8b,0x1a8b,0x1a8b,0x1a8b,0x1a8b,0x1a8b,0x1a8b,0x1a8b,
-0x1a8b,0x1a8b,0x1a8b,0x1a8b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,
-0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,
-0x1b7b,0x1b7b,0x1b7b,0x2af,0x1b78,0x1b78,0x1b78,0x1b78,0x1b78,0x1b78,0x1b78,0x1b78,0x1b78,0x1b78,0x2af,0x2af,
-0x2af,0x2af,0x2af,0x2af,0x1542,0x1542,0x1542,0x1542,0x1542,0x1542,0x1542,0x1542,0x1542,0x1542,0x1542,0x1542,
-0x1542,0x1542,0x1542,0x1542,0x1b81,0x1b81,0x1b81,0x1b81,0x1b81,0x1b81,0x1b81,0x1b81,0x1b81,0x1b81,0x1b81,0x1b81,
-0x1b81,0x1b81,0x1b7e,0x2b2,0x2b2,0x2b2,0x2b2,0x2b2,0x2b2,0x2b2,0x2b2,0x2b2,0x2b2,0x2b2,0x2b2,0x2b2,
-0x2b2,0x2b2,0x2b2,0x2b2,0x1b8a,0x1b8a,0x1b8a,0x1b8a,0x1b8a,0x1b8a,0x1b8a,0x1b8a,0x1b8a,0x1b8a,0x1b8a,0x2b5,
-0x1b8a,0x1b8a,0x1b8a,0x1b8a,0x1b8a,0x1b8a,0x1b8a,0x2b5,0x1b8a,0x1b8a,0x2b5,0x1b87,0x1b87,0x1b87,0x1b87,0x1b87,
-0x1b87,0x1b87,0x1b87,0x1b87,0x1b87,0x1b87,0x2b5,0x1b87,0x1b87,0x1b87,0x1b87,0x1b87,0x1b87,0x1b87,0x1b87,0x1b87,
-0x1b87,0x1b87,0x1b87,0x1b87,0x1b87,0x1b87,0x2b5,0x1b87,0x1b87,0x1b87,0x1b87,0x1b87,0x1b87,0x1b87,0x2b5,0x1b87,
-0x1b87,0x2b5,0x2b5,0x2b5,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,
-0x1b90,0x1b90,0x2b8,0x2b8,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,
-0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,
+0x1a0a,0x1a0a,0x1a0a,0x1a0a,0x1a0a,0x1a07,0x1a07,0x1a07,0x19fe,0x19fe,0x19fe,0x19fe,0x26d,0x26d,0x19fe,0x19fe,
+0x1a07,0x1a07,0x1a07,0x1a07,0x1a01,0x1a0a,0x1a04,0x1a0a,0x1a07,0x26d,0x26d,0x26d,0x26d,0x26d,0x26d,0x26d,
+0x26d,0x26d,0x26d,0x26d,0x26d,0x26d,0x26d,0x26d,0x26d,0x26d,0x26d,0x26d,0x26d,0x26d,0x26d,0x26d,
+0x26d,0x26d,0x26d,0x26d,0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,
+0x1a16,0x270,0x270,0x270,0x1a0d,0x1a0d,0x1a0d,0x1a0d,0x1a0d,0x1a0d,0x1a0d,0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,
+0x1a19,0x1a19,0x270,0x270,0x273,0x1a1c,0x1a1c,0x1a1c,0x1a1c,0x1a1c,0x1a1c,0x1a1c,0x1a1c,0x1a1c,0x1a1c,0x1a1c,
+0x1a1c,0x1a1c,0x1a1c,0x1a1c,0x1a1c,0x1a1c,0x1a1c,0x1a1c,0x1a1c,0x1a1c,0x1a1c,0x1a1c,0x1a1c,0x1a1c,0x1a1c,0x1a1c,
+0x1a1c,0x1a1c,0x1a1c,0x1a1c,0x1a1c,0x1a1c,0x273,0x273,0x276,0x276,0x276,0x276,0x276,0x276,0x276,0x276,
+0x276,0x276,0x276,0x276,0x276,0x276,0x276,0x276,0x1a49,0x1a49,0x1a49,0x276,0x276,0x1c32,0x276,0x276,
+0x276,0x276,0x276,0x276,0x276,0x276,0x276,0x276,0x1a4c,0x1a4c,0x1a4c,0x1a4c,0x276,0x276,0x276,0x276,
+0x276,0x276,0x276,0x276,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,
+0x18e1,0x18e1,0x18e1,0x18e1,0x1a4f,0x1a4f,0x1a4f,0x1af1,0x1af1,0x1af1,0x1af1,0x1c35,0x1c35,0x279,0x279,0x279,
+0x279,0x279,0x279,0x279,0x1a4f,0x1a4f,0x1a4f,0x1a4f,0x1a4f,0x1a4f,0x1af1,0x1af1,0x1af1,0x1af1,0x1af1,0x1af1,
+0x1af1,0x1af1,0x1af1,0x1af1,0x1af1,0x1bbd,0x1bbd,0x1bbd,0x1bbd,0x1c35,0x1c35,0x1c35,0x1af1,0x1af1,0x1af1,0x1af1,
+0x1af1,0x1af1,0x1af1,0x1bbd,0x1bbd,0x1bbd,0x1bbd,0x1c35,0x1c35,0x1c35,0x279,0x1c35,0x1af1,0x1af1,0x1af1,0x1bc0,
+0x1bc0,0x1bc0,0x279,0x279,0x279,0x279,0x279,0x279,0x279,0x279,0x1c35,0x1c35,0x1af1,0x1af1,0x1af1,0x1af1,
+0x1af1,0x1af1,0x1af1,0x1bbd,0x1bbd,0x1bbd,0x1c35,0x1c35,0x279,0x279,0x279,0x279,0x1bbd,0x1bbd,0x1bbd,0x1bbd,
+0x1bbd,0x1bbd,0x1bbd,0x1bbd,0x1c35,0x279,0x279,0x279,0x279,0x279,0x279,0x279,0x1bc0,0x1bc0,0x1bc0,0x1bc0,
+0x1bc0,0x1bc0,0x1bc0,0x1c38,0x1c38,0x279,0x279,0x279,0x279,0x279,0x279,0x279,0x1a25,0x1a1f,0x1a1f,0x1a1f,
+0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x27c,0x27c,
+0x27c,0x27c,0x27c,0x27c,0x27c,0x27c,0x27c,0x27c,0x27c,0x27c,0x27c,0x1a22,0x1a31,0x1a31,0x1a31,0x1a31,
+0x1a31,0x1a31,0x1a31,0x1a31,0x1a31,0x1a31,0x1a31,0x1a31,0x1a28,0x1a28,0x1a28,0x1a28,0x1a2e,0x1a2e,0x1a2e,0x1a2e,
+0x1a2e,0x1a2e,0x1a2e,0x1a2e,0x1a2e,0x1a2e,0x27f,0x27f,0x27f,0x27f,0x27f,0x1a2b,0x1a9d,0x1a9d,0x1a9d,0x1a9d,
+0x1a9d,0x1a9a,0x1a9a,0x1a9a,0x1a9a,0x1a9a,0x1a9a,0x1a9a,0x282,0x282,0x282,0x282,0x282,0x282,0x282,0x282,
+0x282,0x282,0x282,0x282,0x282,0x282,0x282,0x282,0x282,0x282,0x282,0x282,0x1ab8,0x1ab8,0x1ab8,0x1ab8,
+0x1ab8,0x1ab8,0x1ab8,0x285,0x285,0x1ab8,0x285,0x285,0x1ab8,0x1ab8,0x1ab8,0x1ab8,0x1ab8,0x1ab8,0x1ab8,0x1ab8,
+0x285,0x1ab8,0x1ab8,0x285,0x1ab8,0x1ab8,0x1ab8,0x1ab8,0x1ab8,0x1ab8,0x1ab8,0x1ab8,0x1ab8,0x1ab8,0x1ab8,0x1ab8,
+0x1ab8,0x1ab8,0x1ab8,0x1ab8,0x1aa0,0x1aaf,0x1aaf,0x1aaf,0x1aaf,0x1aaf,0x285,0x1aaf,0x1ab2,0x285,0x285,0x1aa0,
+0x1aa0,0x1ab5,0x1aa6,0x1abb,0x1aaf,0x1abb,0x1aaf,0x1aa3,0x1abe,0x1aa9,0x1abe,0x285,0x285,0x285,0x285,0x285,
+0x285,0x285,0x285,0x285,0x1aac,0x1aac,0x1aac,0x1aac,0x1aac,0x1aac,0x1aac,0x1aac,0x1aac,0x1aac,0x285,0x285,
+0x285,0x285,0x285,0x285,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,
+0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x288,0x288,0x288,0x288,0x288,0x288,
+0x288,0x288,0x288,0x288,0x288,0x288,0x288,0x288,0x288,0x288,0x288,0x288,0x288,0x288,0x288,0x288,
+0x288,0x288,0x288,0x288,0x288,0x288,0x288,0x288,0x288,0x288,0x288,0x288,0x1ac4,0x1ac4,0x1ac4,0x1ac4,
+0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x28e,
+0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x28e,
+0x28e,0x28e,0x28e,0x28e,0x28e,0x28e,0x28e,0x28e,0x28e,0x28e,0x28e,0x28e,0x28e,0x28e,0x28e,0x28e,
+0x28e,0x28e,0x28e,0x28e,0x1ac7,0x1ac7,0x1ac7,0x1ac7,0x1ac7,0x1ac7,0x1ac7,0x1ac7,0x1ac7,0x1ac7,0x28e,0x28e,
+0x28e,0x28e,0x28e,0x28e,0x1afa,0x1afa,0x1afa,0x1afa,0x1afa,0x1afa,0x1afa,0x1afa,0x1afa,0x291,0x291,0x291,
+0x291,0x291,0x291,0x291,0x291,0x291,0x291,0x291,0x291,0x291,0x291,0x291,0x291,0x291,0x291,0x291,
+0x291,0x291,0x291,0x291,0x291,0x291,0x291,0x291,0x291,0x291,0x291,0x291,0x291,0x291,0x291,0x291,
+0x1ad0,0x1ad0,0x1ad0,0x1ad0,0x1ad0,0x1ad0,0x1ad0,0x1ad0,0x1ad0,0x1ad0,0x294,0x1aca,0x1aca,0x1acd,0x294,0x294,
+0x1ad0,0x1ad0,0x294,0x294,0x294,0x294,0x294,0x294,0x294,0x294,0x294,0x294,0x294,0x294,0x294,0x294,
+0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,0x1b60,0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,0x1b63,0x297,
+0x1b66,0x1b66,0x297,0x297,0x297,0x297,0x297,0x297,0x1b5d,0x1b5d,0x1b5d,0x1b5d,0x1b5d,0x1b5d,0x1b5d,0x1b5d,
+0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,
+0x1b6c,0x1b69,0x1b69,0x29a,0x29a,0x29a,0x29a,0x29a,0x29a,0x29a,0x29a,0x29a,0x29a,0x29a,0x29a,0x29a,
+0x1b6f,0x1b6f,0x1b6f,0x1b6f,0x1b6f,0x1b6f,0x1b6f,0x29d,0x1b6f,0x1b6f,0x1b6f,0x1b6f,0x29d,0x1b6f,0x1b6f,0x29d,
+0x1b6f,0x1b6f,0x1b6f,0x1b6f,0x1b6f,0x1b6f,0x1b6f,0x1b6f,0x1b6f,0x1b6f,0x1b6f,0x1b6f,0x1b6f,0x1b6f,0x1b6f,0x29d,
+0x1b72,0x1b78,0x1b78,0x1b75,0x1b75,0x1b75,0x2a3,0x1b75,0x1b75,0x1b75,0x1b75,0x1b75,0x1b75,0x1b75,0x1b75,0x1b75,
+0x1b75,0x1b75,0x1b75,0x1b75,0x1b75,0x1b75,0x1b75,0x1b75,0x1b75,0x1b75,0x1b75,0x1b75,0x1b75,0x1b75,0x1b75,0x1b75,
+0x1b75,0x2a3,0x1b75,0x1b75,0x1b75,0x1b75,0x1b75,0x1b75,0x1b75,0x1b75,0x1b75,0x2a3,0x2a3,0x2a3,0x2a3,0x2a3,
+0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7e,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,
+0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x2a6,
+0x2a6,0x2a6,0x2a6,0x2a6,0x2a6,0x1bf0,0x1bf0,0x1bf0,0x1bf0,0x1bf0,0x1bf0,0x2a6,0x2a6,0x2a6,0x2a6,0x2a6,
+0x2a6,0x2a6,0x2a6,0x2a6,0x2a6,0x2a6,0x2a6,0x2a6,0x2a6,0x2a6,0x2a6,0x2a6,0x2a6,0x2a6,0x2a6,0x2a6,
+0x2a6,0x2a6,0x2a6,0x2a6,0x2a6,0x2a6,0x2a6,0x2a6,0x2a6,0x2a6,0x2a6,0x2a6,0x1b84,0x1b84,0x1b81,0x1b81,
+0x1b81,0x1b81,0x1b87,0x1b87,0x1b87,0x1b87,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,
+0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x2a9,0x1a9d,0x1a9d,0x1a9d,0x1a9d,
+0x1a9d,0x1a9d,0x1a9d,0x1a9d,0x1a9d,0x1a9d,0x1a9d,0x1a9d,0x1a9d,0x1a9d,0x1a9d,0x1a9d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,
 0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,
-0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,
-0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,
-0x18c9,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,
-0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,
-0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x94e,0x94e,
-0x1ae2,0x1ae2,0x1ae2,0x1ae2,0x1ae2,0x1ae2,0x1ae2,0x1ae2,0x1ae2,0x1ae2,0x1ae2,0x2d0,0x2d0,0x2d0,0x2d0,0x2d0,
-0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,
-0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0x128d,0x128d,0x128d,0x2be,0x2be,
-0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,
-0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,
+0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x2ac,0x1b8a,0x1b8a,0x1b8a,0x1b8a,
+0x1b8a,0x1b8a,0x1b8a,0x1b8a,0x1b8a,0x1b8a,0x2ac,0x2ac,0x2ac,0x2ac,0x2ac,0x2ac,0x1554,0x1554,0x1554,0x1554,
+0x1554,0x1554,0x1554,0x1554,0x1554,0x1554,0x1554,0x1554,0x1554,0x1554,0x1554,0x1554,0x1b93,0x1b93,0x1b93,0x1b93,
+0x1b93,0x1b93,0x1b93,0x1b93,0x1b93,0x1b93,0x1b93,0x1b93,0x1b93,0x1b93,0x1b90,0x2af,0x2af,0x2af,0x2af,0x2af,
+0x2af,0x2af,0x2af,0x2af,0x2af,0x2af,0x2af,0x2af,0x2af,0x2af,0x2af,0x2af,0x1b9c,0x1b9c,0x1b9c,0x1b9c,
+0x1b9c,0x1b9c,0x1b9c,0x1b9c,0x1b9c,0x1b9c,0x1b9c,0x2b2,0x1b9c,0x1b9c,0x1b9c,0x1b9c,0x1b9c,0x1b9c,0x1b9c,0x2b2,
+0x1b9c,0x1b9c,0x2b2,0x1b99,0x1b99,0x1b99,0x1b99,0x1b99,0x1b99,0x1b99,0x1b99,0x1b99,0x1b99,0x1b99,0x2b2,0x1b99,
+0x1b99,0x1b99,0x1b99,0x1b99,0x1b99,0x1b99,0x1b99,0x1b99,0x1b99,0x1b99,0x1b99,0x1b99,0x1b99,0x1b99,0x2b2,0x1b99,
+0x1b99,0x1b99,0x1b99,0x1b99,0x1b99,0x1b99,0x2b2,0x1b99,0x1b99,0x2b2,0x2b2,0x2b2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,
+0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x2b5,0x2b5,0x1ba2,0x1ba2,0x1ba2,0x1ba2,
+0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x2b5,
+0x2b5,0x2b5,0x2b5,0x2b5,0x2b5,0x2b5,0x2b5,0x2b5,0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,
+0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,
+0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,
+0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,0x1bf3,0x1bf3,0x1bf3,0x1bf9,0x1bf9,0x1bf9,0x1bf9,
+0x1bf9,0x1bf9,0x1bf9,0x1bf9,0x1bf9,0x1bf9,0x1bf9,0x1bfc,0x1bfc,0x1bfc,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,
+0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x2bb,0x1bff,0x1bff,0x1bff,0x1bff,
+0x1bff,0x1bff,0x1bff,0x1bff,0x1bff,0x1bff,0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,
 0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,
-0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,0xb76,0xb76,0xb76,0xb76,
-0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,
-0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0x2c1,0x2c1,0x129f,0x129f,0x129f,0x129f,
-0x129f,0x129f,0x129f,0x129f,0x129f,0x129f,0x129f,0x129f,0x129f,0x129f,0x129f,0x129f,0x129f,0x129f,0x129f,0x129f,
-0x129f,0x1b99,0x1b99,0x1b99,0x1b99,0x2c4,0x2c4,0x2c4,0x2c4,0x2c4,0x2c4,0x2c4,0x13b6,0x13b6,0x13b6,0x13b6,
-0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,
-0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x2c7,0x2c7,0x1773,0x1773,0x2ca,0x2ca,
-0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x18c9,0x18c9,0x18c9,0x18c9,
-0x18c9,0x18c9,0x18c9,0x18c9,0x18c9,0x18c9,0x18c9,0x18c9,0x18c9,0x18c9,0x18c9,0x18c9,0x3d8,0x3cc,0x3cc,0x3cc,
-0x3cc,0x3cc,0x3cc,0x3cc,0x3cc,0x3d8,0x3d8,0x3d8,0x3d8,0x3d2,0x110a,0x12e4,0x3db,0x918,0x91b,0x3c9,
-0x3c9,0x1107,0x12e1,0x12e1,0x3de,0x3de,0x3de,0x3de,0x3de,0x3de,0x3de,0x3de,0x1107,0x3cc,0x3cc,0x3d8,
-0xc9c,0x3db,0x3db,0x3db,0x3db,0x3db,0x3db,0x3db,0x3db,0x3db,0x3db,0x3db,0x3db,0x3db,0x3db,0x3db,
-0x3db,0x3db,0x3db,0x3db,0x3db,0x3db,0x3db,0x3db,0x3db,0x3db,0x3db,0x3db,0x3db,0x3db,0x3cc,0x3cc,
-0x8a0,0x8a3,0x936,0x936,0x936,0x936,0x936,0x936,0x936,0x936,0x936,0x936,0x3d5,0xf6c,0xf69,0x12e7,
-0x12e7,0x12e7,0x12e7,0x12e7,0x14a6,0x110d,0x110d,0xebe,0xebe,0xd8f,0xebe,0xebe,0x3db,0x3db,0x3db,0x3db,
-0x3db,0x3db,0x3db,0x3db,0x3db,0x3de,0x3db,0x3db,0x3db,0x3db,0x3db,0x3db,0x3db,0x3de,0x3db,0x3db,
-0x3de,0x3db,0x3db,0x3db,0x3db,0x3db,0x12e1,0x12e4,0x3cf,0x3db,0x3d8,0x3d8,0x47a,0x47a,0x47a,0x47a,
-0x47a,0x47a,0x47a,0x47a,0x47a,0x12ed,0x47a,0x47a,0x47a,0x47a,0x47a,0x47a,0x47a,0x47a,0x47a,0x47a,
-0x47a,0x47a,0x47a,0x47a,0x47a,0x47a,0x12ed,0x1845,0x1845,0xf8a,0x46b,0x474,0x4b6,0x4b6,0x4b6,0x4b6,
-0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,
-0x4b6,0x4b6,0x4b6,0xb91,0xb91,0xd9b,0xd9b,0x8a6,0xd9e,0x13c8,0x13c8,0x13c8,0x4b9,0x4b9,0x4b9,0x4b9,
-0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,
-0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4bf,0x4bf,0x4bf,0x1122,
-0x1122,0x1122,0x1122,0x1122,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,
-0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,
-0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x111f,0x111f,0x111f,0x111f,0x111f,0x111f,0x4c2,0x4bf,0x4bf,0x4bf,
-0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,
-0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,
-0x4cb,0x4c5,0x4cb,0x4c5,0x4cb,0x4c5,0x4cb,0x4c5,0x4cb,0x4c5,0x4cb,0x4c5,0x4cb,0x4c5,0x4cb,0x4c5,
-0x4cb,0x4c5,0x4cb,0x4c5,0x4cb,0x4c5,0x4cb,0x4c5,0x4cb,0x4c5,0x4cb,0x4c5,0x4cb,0x4c5,0x4cb,0x4c5,
-0x4cb,0x4c5,0x4c5,0x4c5,0x4c5,0x4c5,0x4c8,0x990,0xfb7,0xfb7,0xfba,0xfb7,0x4cb,0x4c5,0x4cb,0x4c5,
-0x4cb,0x4c5,0x4cb,0x4c5,0x4cb,0x4c5,0x4cb,0x4c5,0x4cb,0x4c5,0x4cb,0x4c5,0x4cb,0x4c5,0x4cb,0x4c5,
-0x4cb,0x4c5,0x4cb,0x4c5,0x4cb,0x4c5,0xfba,0xfb7,0xfba,0xfb7,0xfba,0xfb7,0x4d7,0x4d7,0x4d7,0x4d7,
-0x4d7,0x4d7,0x4d7,0x4d7,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x4d7,0x4d7,0x4d7,0x4d7,
-0x4d7,0x4d7,0x4d7,0x4d7,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x696,0x696,0x699,0x4f5,
-0x6a5,0x6a2,0x6a2,0x69f,0x51f,0x51f,0x4dd,0x4dd,0x4dd,0x4dd,0x4dd,0xb22,0x6a8,0x501,0x6c0,0x6c3,
-0x516,0x6a8,0x504,0x504,0x4f5,0x510,0x510,0x696,0x51c,0x519,0x69c,0x4ef,0x4e6,0x4e6,0x4e9,0x4e9,
-0x4e9,0x4e9,0x4e9,0x4ec,0x4e9,0x4e9,0x4e9,0x4e0,0x528,0x525,0x522,0x522,0x6b4,0x50a,0x507,0x6b1,
-0x6ae,0x6ab,0x6bd,0x4f8,0x6ba,0x6ba,0x50d,0x510,0x6b7,0x6b7,0x50d,0x510,0x4f2,0x4f5,0x4f5,0x4f5,
-0x513,0x4fe,0x4fb,0xba6,0xac5,0xac5,0xac2,0xac2,0xac2,0xac2,0xb9d,0xb9d,0xb9d,0xb9d,0xba3,0xcc9,
-0xcc6,0xdaa,0xdad,0xba0,0xdad,0xdad,0xdad,0xdad,0xdaa,0xdad,0xdad,0xb9a,0x54c,0x54c,0x54c,0x54c,
-0x54c,0x54c,0x54c,0x549,0x54f,0x72f,0x54c,0x993,0x9b4,0xac8,0xac8,0xac8,0xbac,0xbac,0xdb3,0xdb3,
-0xdb3,0xdb3,0x112b,0x112e,0x112e,0x1302,0x1494,0x14be,0x14c1,0x14c1,0x16c8,0x1848,0x55b,0x55b,0x573,0x6d5,
-0x558,0x6cf,0x55b,0x570,0x558,0x6d5,0x56a,0x573,0x573,0x573,0x56a,0x56a,0x573,0x573,0x573,0x6db,
-0x558,0x573,0x6d8,0x558,0x567,0x573,0x573,0x573,0x573,0x573,0x558,0x558,0x55e,0x6cf,0x6d2,0x558,
-0x573,0x558,0x6de,0x558,0x573,0x561,0x579,0x6e1,0x573,0x573,0x564,0x56a,0x573,0x573,0x576,0x573,
-0x56a,0x56d,0x56d,0x56d,0x56d,0xad1,0xace,0xccc,0xdbc,0xbc1,0xbc4,0xbc4,0xbbe,0xbbb,0xbbb,0xbbb,
-0xbbb,0xbc4,0xbc1,0xbc1,0xbc1,0xbc1,0xbb8,0xbbb,0xdb9,0xeca,0xecd,0xfc0,0x1131,0x1131,0x1131,0x6e7,
-0x6e4,0x57c,0x57f,0x57f,0x57f,0x57f,0x57f,0x6e4,0x6e7,0x6e7,0x6e4,0x57f,0x6ed,0x6ed,0x6ed,0x6ed,
-0x6ed,0x6ed,0x6ed,0x6ed,0x6ed,0x6ed,0x6ed,0x6ed,0x588,0x588,0x588,0x588,0x6ea,0x6ea,0x6ea,0x6ea,
-0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x582,0x582,0x582,0x582,0x582,0x582,0x58e,0x58e,0x58e,0x58e,
-0x58e,0x58e,0x58e,0x58e,0x58b,0x58e,0x58e,0x58e,0x58e,0x58e,0x591,0x58b,0x58e,0x58e,0x58b,0x58b,
-0x58b,0x58b,0x58e,0x58e,0x6f0,0x6f0,0x58b,0x58b,0x58e,0x58e,0x58e,0x58e,0x58e,0x58e,0x58e,0x58e,
-0x58e,0x58e,0x58e,0x58e,0x58e,0x591,0x591,0x591,0x58e,0x58e,0x6f3,0x58e,0x6f3,0x58e,0x58e,0x58e,
-0x58e,0x58e,0x58e,0x58e,0x58b,0x58e,0x58b,0x58b,0x58b,0x58b,0x58b,0x58b,0x58e,0x58e,0x58b,0x6f0,
-0x58b,0x58b,0x58b,0xad7,0xad7,0xad7,0xad7,0xad7,0xad7,0xad7,0xad7,0xad7,0xbc7,0xbc7,0xbc7,0xbc7,
-0xbc7,0xbc7,0xbc7,0xbc7,0xbc7,0xbc7,0xbc7,0xbc7,0x6f6,0x594,0x6f6,0x6f6,0x597,0x594,0x594,0x6f6,
-0x6f6,0x597,0x594,0x6f6,0x597,0x594,0x594,0x6f6,0x594,0x6f6,0x5a3,0x5a0,0x594,0x6f6,0x594,0x594,
-0x594,0x594,0x6f6,0x594,0x594,0x6f6,0x6f6,0x6f6,0x6f6,0x594,0x594,0x6f6,0x597,0x6f6,0x597,0x6f6,
-0x6f6,0x6f6,0x6f6,0x6f6,0x6fc,0x59a,0x6f6,0x59a,0x59a,0x594,0x594,0x594,0x6f6,0x6f6,0x6f6,0x6f6,
-0x594,0x594,0x594,0x594,0x6f6,0x6f6,0x594,0x594,0x594,0x597,0x594,0x594,0x597,0x594,0x594,0x597,
-0x6f6,0x597,0x594,0x594,0x6f6,0x594,0x594,0x594,0x594,0x594,0x6f6,0x594,0x594,0x594,0x594,0x594,
-0x594,0x594,0x594,0x594,0x594,0x594,0x594,0x594,0x6f9,0x6f6,0x597,0x594,0x6f6,0x6f6,0x6f6,0x6f6,
-0x594,0x594,0x6f6,0x6f6,0x594,0x597,0x6f9,0x6f9,0x597,0x597,0x594,0x594,0x597,0x597,0x594,0x594,
-0x597,0x597,0x594,0x594,0x594,0x594,0x594,0x594,0x597,0x597,0x6f6,0x6f6,0x597,0x597,0x6f6,0x6f6,
-0x597,0x597,0x594,0x594,0x594,0x594,0x594,0x594,0x594,0x594,0x594,0x594,0x594,0x6f6,0x594,0x594,
-0x594,0x6f6,0x594,0x594,0x594,0x594,0x594,0x594,0x594,0x6f6,0x594,0x594,0x594,0x594,0x594,0x594,
-0x597,0x597,0x597,0x597,0x594,0x594,0x594,0x594,0x594,0x594,0x594,0x594,0x594,0x594,0x594,0x594,
-0x594,0x594,0x594,0x6f6,0x594,0x594,0x594,0x594,0x594,0x594,0x594,0x594,0x594,0x594,0x594,0x594,
-0x594,0x594,0x594,0x594,0x594,0x594,0x594,0x594,0x594,0x594,0x594,0x594,0x594,0x594,0x594,0x594,
-0x594,0x594,0x594,0x594,0x597,0x597,0x597,0x597,0x594,0x594,0x594,0x594,0x594,0x594,0x597,0x597,
-0x597,0x597,0x594,0x59d,0x594,0x594,0xbca,0xbca,0xbca,0xbca,0xbca,0xbca,0xbca,0xbca,0xbca,0xbca,
-0xbca,0xbca,0xbca,0xbca,0x5a6,0xada,0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x5af,0x5ac,0x5af,0x5ac,
-0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x6ff,0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x7ef,0x7ef,
-0x5a6,0x5a6,0x5a6,0x5a6,0x5a9,0x5a9,0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x7f5,0x7f2,0x5a6,
-0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,
-0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,0x5a6,
-0x5a6,0x5a6,0x5a6,0xada,0xbd0,0xada,0xada,0xada,0x5b2,0x5b2,0x5b2,0x5b2,0x5b2,0x5b2,0x5b2,0x5b2,
-0x5b2,0x5b2,0x5b2,0x5b2,0x5b2,0x5b2,0x5b2,0x5b2,0x5b2,0x5b2,0x5b2,0x5b2,0x5b2,0x5b2,0x5b2,0x5b2,
-0x5b2,0x5b2,0x5b2,0x5b2,0x5b2,0x5b2,0x5b2,0x5b2,0x708,0x708,0x708,0x708,0x708,0x708,0x708,0x708,
-0x708,0x708,0x5b8,0xc2d,0xc2d,0xc2d,0xc2d,0xc2d,0xc2d,0xc2d,0xc2d,0xc2d,0xc2d,0xc2d,0xc2d,0xc2d,
-0xc2d,0xc2d,0xc2d,0xc2d,0xc2d,0xc2d,0xc2d,0xd3b,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,
-0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,0x5bb,0x5be,0x5be,0x5be,
-0x5be,0x5be,0x5be,0x5be,0x5be,0x5be,0x5be,0x5be,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,
-0x70e,0x70e,0x70e,0x70e,0x5be,0x5be,0x5be,0x5be,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,
-0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,0x711,0x711,0x711,0x711,0x711,0x711,0x711,0x711,
-0x711,0x711,0x711,0x711,0x711,0x711,0x711,0x711,0x5c1,0x5c1,0x711,0x711,0x711,0x711,0xbd3,0xbd3,
-0xbd3,0xbd3,0xbd3,0xbd3,0xbd3,0xbd3,0xbd3,0xbd3,0x717,0x717,0x5c4,0x714,0x714,0x714,0x714,0x714,
-0x714,0x714,0x5c4,0x5c4,0x5c4,0x5c4,0x5c7,0x5c7,0x5c7,0x5c7,0x717,0x717,0x5c7,0x5c7,0x717,0x717,
-0x5c4,0x5c4,0x5c4,0x5c4,0x717,0x717,0x5c7,0x5c7,0x717,0x717,0x5c4,0x5c4,0x5c4,0x5c4,0x717,0x717,
-0x714,0x5c4,0x5c7,0x717,0x5c4,0x5c4,0x714,0x717,0x717,0x717,0x5c7,0x5c7,0x5c4,0x5c4,0x5c4,0x5c4,
-0x5c4,0x5c4,0x5c4,0x5c4,0x5c4,0x5c4,0x5c4,0x5c4,0x5c4,0x5c4,0x717,0x714,0x717,0x714,0x5c4,0x5c7,
-0x5c7,0x5c7,0x5c7,0x5c7,0x5c7,0x5c4,0x5c4,0x714,0xae0,0xae0,0xae0,0xae0,0xae0,0xae0,0xae0,0xae0,
-0xbd6,0xbd6,0xbd6,0xbd6,0xbd6,0xc45,0xc45,0xbd6,0x5cd,0x5cd,0x5cd,0x5cd,0x5ca,0x720,0x720,0x5ca,
-0x5ca,0x71a,0x5ca,0x5ca,0x5ca,0x5ca,0x71a,0x71a,0x5ca,0x5ca,0x5ca,0x5ca,0xd44,0xd44,0xbd9,0xbd9,
-0xdc5,0xae3,0x5cd,0x5cd,0x71d,0x5d0,0x71d,0x5cd,0x5ca,0x5ca,0x5ca,0x5ca,0x5ca,0x5ca,0x5ca,0x5ca,
-0x5ca,0x5ca,0x5ca,0x5ca,0x5ca,0x5ca,0x5ca,0x5ca,0x5ca,0x5ca,0x5ca,0x5ca,0x5ca,0x5ca,0x5ca,0x5ca,
-0x5ca,0x5cd,0x5cd,0x5cd,0x5ca,0x5ca,0x5ca,0x5ca,0x720,0x5ca,0x720,0x5ca,0x5ca,0x5ca,0x5ca,0x5ca,
-0x7f8,0x7f8,0x7f8,0x7f8,0x7f8,0x7f8,0x7f8,0x7f8,0x7f8,0x7f8,0x7f8,0x7f8,0x5ca,0x5ca,0x5ca,0x5ca,
-0x5ca,0x5ca,0x5ca,0x5ca,0x5ca,0x5ca,0x5ca,0x5ca,0x720,0x720,0x5d3,0x720,0x71a,0x71a,0x5ca,0x71a,
-0x71d,0x71a,0x71a,0x5ca,0x71a,0x720,0x5d3,0x720,0xae3,0xae3,0xbdc,0xbdc,0xbdc,0xbdc,0xbdc,0xbdc,
-0xbdc,0xbdc,0xbdc,0xbdc,0xbdc,0xbdc,0xdc2,0xe79,0x5d6,0x5d6,0x5d6,0x5d6,0x5d6,0x5d6,0x5d6,0x5d6,
-0x5d6,0x5d6,0x5d6,0x5d6,0x5d6,0x5d6,0x5d6,0x5d6,0x5d6,0x5d6,0x5d6,0x5d6,0x5d9,0x1389,0x1389,0x1389,
-0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x14c7,0x5df,0x5df,0x5df,0x5df,0x1389,0x5d9,0x5d9,
-0x5df,0x5df,0x138c,0x138c,0x5e5,0x5e5,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,
-0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x1389,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,
-0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x726,0x5d9,0x5d9,
-0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x1389,0x5d9,0x1389,0x5d9,
-0x5d9,0x5d9,0x5d9,0x1389,0x1389,0x1389,0x5d9,0x1287,0x5d9,0x5d9,0x5d9,0x5e2,0x5e2,0x5e2,0x5e2,0x130e,
-0x130e,0x5d9,0x5dc,0x5dc,0x5df,0x5d9,0x5d9,0x5d9,0xbe2,0xbdf,0xbe2,0xbdf,0xbe2,0xbdf,0xbe2,0xbdf,
-0xbe2,0xbdf,0xbe2,0xbdf,0xbe2,0xbdf,0x723,0x723,0x723,0x723,0x723,0x723,0x723,0x723,0x723,0x723,
-0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,
-0x1389,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x1389,
-0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,
-0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x5fd,0x5fd,
-0x5fd,0x5fd,0x5fd,0x5fd,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
-0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
-0xb34,0xb34,0xb34,0xb34,0xb34,0xb34,0xb34,0xb34,0xb34,0xb34,0xb34,0xb34,0xb34,0xb34,0xb34,0xb34,
-0x606,0x606,0x94b,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x5fd,0x5fd,0xbe5,0xd68,0x1afd,0x1afd,
-0x603,0x609,0x606,0x600,0x603,0x609,0x606,0x600,0x603,0x609,0x606,0x600,0x603,0x609,0x606,0x600,
-0x603,0x609,0x606,0x600,0x603,0x609,0x606,0x600,0x603,0x609,0x606,0x600,0x603,0x609,0x606,0x600,
-0x606,0x600,0x606,0x600,0x606,0x600,0x606,0x600,0x606,0x600,0x606,0x600,0x603,0x609,0x606,0x600,
-0x603,0x609,0x606,0x600,0x603,0x609,0x606,0x600,0x603,0x609,0x606,0x600,0x606,0x600,0x603,0x609,
-0x606,0x600,0x606,0x600,0x603,0x609,0x606,0x600,0x603,0x609,0x606,0x600,0x606,0x600,0x1311,0x1311,
-0x1311,0x1311,0x1311,0x1311,0x1311,0x1311,0x1311,0x1311,0x1311,0x1311,0x1311,0x1311,0x606,0x600,0x606,0x600,
-0x606,0x600,0x603,0x609,0x603,0x609,0x606,0x600,0x606,0x600,0x606,0x600,0x606,0x600,0x606,0x600,
-0x606,0x600,0x606,0x600,0x603,0x606,0x600,0x603,0x606,0x600,0x603,0x609,0x600,0x600,0x600,0x600,
-0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
-0x600,0x600,0x600,0x603,0x603,0x603,0x603,0x603,0x603,0x603,0x603,0x603,0x606,0x606,0x606,0x606,
-0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x600,0x600,0x600,
-0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x603,0x603,0x603,
-0x603,0x603,0x603,0x603,0x609,0x609,0x609,0x609,0x609,0x609,0x609,0x609,0x600,0x606,0x909,0x90c,
-0x1afd,0x1afd,0x1afd,0x1afd,0x1afd,0x1afd,0x1afd,0x1afd,0x1afd,0x1afd,0x1afd,0x1afd,0x1afd,0x1afd,0x1afd,0x1afd,
-0x603,0x600,0x603,0x603,0x603,0x603,0x603,0x603,0x600,0x603,0x600,0x600,0x603,0x603,0x600,0x600,
-0x603,0x603,0x600,0x603,0x600,0x603,0x600,0x600,0x603,0x600,0x600,0x603,0x600,0x603,0x600,0x600,
-0x603,0x600,0x603,0x603,0x600,0x600,0x600,0x603,0x600,0x600,0x600,0x600,0x600,0x603,0x600,0x600,
-0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
-0x600,0x600,0x600,0x600,0x603,0x603,0x600,0x600,0x603,0x600,0x603,0x600,0x600,0x600,0x600,0x600,
-0x603,0x603,0x603,0x603,0x603,0x603,0x603,0x603,0x603,0x603,0x603,0x603,0x603,0x603,0x603,0x603,
-0x603,0x603,0x603,0x603,0x603,0x603,0x603,0x603,0x603,0x603,0x603,0x603,0x603,0x603,0x603,0x603,
-0x603,0x603,0x603,0x609,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,
-0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,0x606,
-0x606,0x606,0x606,0x606,0x609,0x609,0x609,0x609,0x609,0x609,0x609,0x609,0x609,0x609,0x609,0x609,
-0x609,0x609,0x609,0x609,0x609,0x609,0x609,0x609,0x609,0x606,0x606,0x606,0x606,0x606,0x606,0x606,
-0x606,0x606,0x606,0x606,0x60c,0x60c,0x60c,0x60c,0xfcc,0xfcc,0xfcc,0x14ca,0x14ca,0x14ca,0x14ca,0x14ca,
-0x14ca,0x14ca,0x16ce,0x16ce,0x855,0x85b,0x85b,0x867,0x867,0x858,0x84f,0x858,0x84f,0x858,0x84f,0x858,
-0x84f,0x858,0x84f,0x858,0x61b,0x61b,0x615,0x61b,0x615,0x61b,0x615,0x61b,0x615,0x61b,0x615,0x618,
-0x61e,0x61b,0x615,0x61b,0x615,0x618,0x61e,0x61b,0x615,0x61b,0x615,0x618,0x61e,0x61b,0x615,0x618,
-0x61e,0x61b,0x615,0x618,0x61e,0x61b,0x615,0x61b,0x615,0x61b,0x615,0x61b,0x615,0x61b,0x615,0x618,
-0x61e,0x61b,0x615,0x618,0x61e,0x61b,0x615,0x618,0x61e,0x61b,0x615,0x618,0x61e,0x61b,0x615,0x618,
-0x61e,0x61b,0x615,0x618,0x61e,0x61b,0x615,0x618,0x61e,0x61b,0x615,0x618,0x61e,0x61b,0x615,0x618,
-0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,
-0x705,0x705,0x705,0x705,0x702,0x702,0x702,0x702,0x702,0x702,0x702,0x702,0x702,0x702,0x702,0x702,
-0x702,0x702,0x702,0x702,0x702,0x702,0x702,0x702,0x702,0x702,0x702,0x702,0x702,0x702,0x702,0x702,
-0x702,0x702,0x702,0x702,0x702,0x702,0x70b,0x70b,0x70b,0x70b,0x70b,0x70b,0x70b,0x70b,0x70b,0x70b,
-0x70b,0x70b,0x70b,0x70b,0x70b,0x70b,0x70b,0x70b,0x708,0x708,0x708,0x708,0x708,0x708,0x708,0x708,
-0x708,0x708,0x708,0x708,0x708,0x708,0x708,0x708,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,
-0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,
-0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,0x70e,0x729,0x729,0x729,0x729,0x729,0x729,0x729,0x729,
-0x729,0x729,0x729,0x729,0x729,0x729,0x729,0x729,0x729,0x729,0x729,0x729,0x729,0x729,0x729,0x729,
-0x729,0x729,0x729,0x729,0x729,0x729,0x729,0x729,0xc33,0x8b8,0x8b2,0x8af,0x8b5,0x8ac,0x73e,0x741,
-0x741,0x741,0x741,0x741,0x741,0x741,0x741,0x741,0x8be,0x73e,0x73e,0x73e,0x73e,0x73e,0x73e,0x73e,
-0x73e,0x73e,0x73e,0x73e,0x73e,0x73e,0x73e,0x73e,0x73e,0x73e,0x73e,0x73e,0x73e,0x73e,0x73e,0x73e,
-0x73e,0x73e,0x73e,0x73e,0x73e,0x73e,0x73e,0x73e,0x73e,0x73e,0x8bb,0x8bb,0x744,0x8cd,0x8d0,0x8d6,
-0x7fb,0x807,0x8eb,0x804,0x8c4,0x8c1,0x8c4,0x8c1,0x8ca,0x8c7,0x8ca,0x8c7,0x8c4,0x8c1,0x801,0x8d6,
-0x8c4,0x8c1,0x8c4,0x8c1,0x8c4,0x8c1,0x8c4,0x8c1,0x8dc,0x8e2,0x8df,0x8df,0x74a,0x786,0x786,0x786,
-0x786,0x786,0x786,0x780,0x780,0x780,0x780,0x780,0x780,0x780,0x780,0x780,0x780,0x780,0x780,0x780,
-0x780,0x780,0x780,0x780,0x780,0x780,0x780,0x74d,0x768,0x747,0x76e,0x771,0x76b,0x783,0x783,0x783,
-0x783,0x783,0x783,0x77d,0x77d,0x77d,0x77d,0x77d,0x77d,0x77d,0x77d,0x77d,0x77d,0x77d,0x77d,0x77d,
-0x77d,0x77d,0x77d,0x77d,0x77d,0x77d,0x77d,0x74d,0x768,0x747,0x768,0xc36,0x7e9,0x7e9,0x7e9,0x7e9,
-0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,
-0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x1281,0x1281,
-0x1281,0x1281,0x1281,0x7ec,0x801,0x804,0x804,0x804,0x804,0x804,0x804,0x804,0x804,0x804,0x924,0x924,
-0x924,0x924,0x80a,0x80a,0x8d9,0x8e8,0x8e8,0x8e8,0x8e8,0x8e5,0x7fe,0x8d3,0xb07,0xb07,0xb07,0xc48,
-0xc66,0xc63,0xb25,0x8a9,0x810,0x80d,0x810,0x813,0x80d,0x810,0x80d,0x810,0x80d,0x810,0x80d,0x80d,
-0x80d,0x80d,0x80d,0x80d,0x810,0x810,0x80d,0x810,0x810,0x80d,0x810,0x810,0x80d,0x810,0x810,0x80d,
-0x810,0x810,0x80d,0x80d,0xc69,0x822,0x81c,0x822,0x81c,0x822,0x81c,0x822,0x81c,0x822,0x81c,0x81c,
-0x81f,0x81c,0x81f,0x81c,0x81f,0x81c,0x81f,0x81c,0x81f,0x81c,0x81f,0x81c,0x81f,0x81c,0x81f,0x81c,
-0x81f,0x81c,0x81f,0x81c,0x81f,0x81c,0x81f,0x822,0x81c,0x81f,0x81c,0x81f,0x81c,0x81f,0x81c,0x81c,
-0x81c,0x81c,0x81c,0x81c,0x81f,0x81f,0x81c,0x81f,0x81f,0x81c,0x81f,0x81f,0x81c,0x81f,0x81f,0x81c,
-0x81f,0x81f,0x81c,0x81c,0x81c,0x81c,0x81c,0x822,0x81c,0x822,0x81c,0x822,0x81c,0x81c,0x81c,0x81c,
-0x81c,0x81c,0x822,0x81c,0x81c,0x81c,0x81c,0x81c,0x81f,0x822,0x822,0x81f,0x81f,0x81f,0x81f,0x8f1,
-0x8f4,0x825,0x828,0xc51,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,
-0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,
-0x82e,0x82e,0x82e,0x82e,0x831,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,
-0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,0x82e,
-0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,
-0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0xd4d,0xd4d,0xe7c,0x834,
-0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0xd47,0xd47,0xd47,0xd47,
+0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,0x1c02,0x1c02,0x1c02,0x1c02,0x1c02,0x1c02,0x1c02,0x1c02,
+0x1c02,0x1c02,0x1c02,0x1c02,0x1c02,0x1c02,0x1c02,0x1c02,0x1c02,0x1c02,0x1c02,0x1c02,0x2c1,0x2c1,0x2c1,0x2c1,
+0x2c1,0x2c1,0x2c1,0x2c1,0x2c1,0x2c1,0x2c1,0x2c1,0x1c05,0x1c05,0x1c1a,0x1c11,0x1c17,0x1c17,0x1c17,0x1c17,
+0x1c17,0x1c17,0x1c17,0x1c17,0x1c17,0x1c17,0x1c17,0x1c17,0x1c17,0x2c4,0x1c17,0x1c17,0x1c17,0x1c17,0x1c17,0x1c17,
+0x1c17,0x1c17,0x1c17,0x1c17,0x1c17,0x1c17,0x1c17,0x1c17,0x1c17,0x1c17,0x1c17,0x1c17,0x1c17,0x1c17,0x1c17,0x1c17,
+0x1c11,0x1c11,0x1c05,0x1c05,0x1c05,0x1c05,0x1c05,0x2c4,0x2c4,0x2c4,0x1c11,0x1c11,0x1c05,0x1c14,0x1c08,0x1c1d,
+0x1c1d,0x1c0b,0x1c0b,0x1c0b,0x1c0b,0x1c0b,0x1c0b,0x1c0b,0x1c0b,0x1c0b,0x1c0b,0x1c0b,0x1c0e,0x1c0e,0x1c0e,0x1c0e,
+0x1c0e,0x1c0e,0x1c0e,0x1c0e,0x1c0e,0x1c0e,0x2c4,0x2c4,0x2c4,0x2c4,0x2c4,0x2c4,0x1c26,0x1c26,0x1c26,0x1c26,
+0x1c26,0x1c26,0x1c26,0x1c26,0x1c26,0x1c26,0x1c26,0x1c26,0x1c20,0x1c20,0x1c20,0x1c20,0x1c23,0x1c23,0x1c23,0x1c23,
+0x1c23,0x1c23,0x1c23,0x1c23,0x1c23,0x1c23,0x2c7,0x2c7,0x2c7,0x2c7,0x2c7,0x2c7,0x2ca,0x2ca,0x2ca,0x2ca,
+0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,
+0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x18db,0x2dc,0x2dc,0x2dc,
+0x2dc,0x2dc,0x2dc,0x2dc,0x2dc,0x2dc,0x2dc,0x2dc,0x2dc,0x2dc,0x2dc,0x2dc,0x2ca,0x2ca,0x2ca,0x2ca,
+0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,
+0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x95d,0x95d,0x1c3b,0x1c3b,0x1c3b,0x1c3b,
+0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x2ca,0x2ca,0x2ca,0x2ca,
+0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0x2ca,0xc6c,0xc6c,0xc6c,0xc6c,
+0xc6c,0xc6c,0xc6c,0xc6c,0xc6c,0xc6c,0xc6c,0x129f,0x129f,0x129f,0x2cd,0x2cd,0xe94,0xe94,0xe94,0xe94,
+0xe94,0xe94,0xe94,0xe94,0xe94,0xe94,0xe94,0xe94,0xe94,0xe94,0xe94,0xe94,0xe94,0xe94,0xe94,0xe94,
+0xe94,0xe94,0xe94,0xe94,0xe94,0xe94,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,
+0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,
+0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,
+0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,
+0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0x2d0,0x2d0,0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,
+0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,0x1bab,0x1bab,0x1bab,
+0x1bab,0x1c29,0x2d3,0x2d3,0x2d3,0x2d3,0x2d3,0x2d3,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,
+0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,
+0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x2d6,0x2d6,0x1785,0x1785,0x2d9,0x2d9,0x2d9,0x2d9,0x2d9,0x2d9,
+0x2d9,0x2d9,0x2d9,0x2d9,0x2d9,0x2d9,0x2d9,0x2d9,0x18db,0x18db,0x18db,0x18db,0x18db,0x18db,0x18db,0x18db,
+0x18db,0x18db,0x18db,0x18db,0x18db,0x18db,0x18db,0x18db,0x1af4,0x1af4,0x1af4,0x1af4,0x1af4,0x1af4,0x1af4,0x1af4,
+0x1af4,0x1af4,0x1af4,0x2df,0x2df,0x2df,0x2df,0x2df,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,
+0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x3e7,0x3db,0x3db,0x3db,0x3db,0x3db,0x3db,0x3db,
+0x3db,0x3e7,0x3e7,0x3e7,0x3e7,0x3e1,0x111f,0x12f6,0x3ea,0x927,0x92a,0x3d8,0x3d8,0x111c,0x12f3,0x12f3,
+0x3ed,0x3ed,0x3ed,0x3ed,0x3ed,0x3ed,0x3ed,0x3ed,0x111c,0x3db,0x3db,0x3e7,0xcae,0x3ea,0x3ea,0x3ea,
+0x3ea,0x3ea,0x3ea,0x3ea,0x3ea,0x3ea,0x3ea,0x3ea,0x3ea,0x3ea,0x3ea,0x3ea,0x3ea,0x3ea,0x3ea,0x3ea,
+0x3ea,0x3ea,0x3ea,0x3ea,0x3ea,0x3ea,0x3ea,0x3ea,0x3ea,0x3ea,0x3db,0x3db,0x8af,0x8b2,0x945,0x945,
+0x945,0x945,0x945,0x945,0x945,0x945,0x945,0x945,0x3e4,0xf7e,0xf7b,0x12f9,0x12f9,0x12f9,0x12f9,0x12f9,
+0x14b8,0x1122,0x1122,0xed0,0xed0,0xda1,0xed0,0xed0,0x3ea,0x3ea,0x3ea,0x3ea,0x3ea,0x3ea,0x3ea,0x3ea,
+0x3ea,0x3ed,0x3ea,0x3ea,0x3ea,0x3ea,0x3ea,0x3ea,0x3ea,0x3ed,0x3ea,0x3ea,0x3ed,0x3ea,0x3ea,0x3ea,
+0x3ea,0x3ea,0x12f3,0x12f6,0x3de,0x3ea,0x3e7,0x3e7,0x489,0x489,0x489,0x489,0x489,0x489,0x489,0x489,
+0x489,0x12ff,0x489,0x489,0x489,0x489,0x489,0x489,0x489,0x489,0x489,0x489,0x489,0x489,0x489,0x489,
+0x489,0x489,0x12ff,0x1857,0x1857,0xf9c,0x47a,0x483,0x4c5,0x4c5,0x4c5,0x4c5,0x4c5,0x4c5,0x4c5,0x4c5,
+0x4c5,0x4c5,0x4c5,0x4c5,0x4c5,0x4c5,0x4c5,0x4c5,0x4c5,0x4c5,0x4c5,0x4c5,0x4c5,0x4c5,0x4c5,0xba3,
+0xba3,0xdb0,0xdb0,0x8b5,0xdad,0x13da,0x13da,0x13da,0x4c8,0x4c8,0x4c8,0x4c8,0x4c8,0x4c8,0x4c8,0x4c8,
+0x4c8,0x4c8,0x4c8,0x4c8,0x4c8,0x4c8,0x4c8,0x4c8,0x4c8,0x4c8,0x4c8,0x4c8,0x4c8,0x4c8,0x4c8,0x4c8,
+0x4c8,0x4c8,0x4c8,0x4c8,0x4c8,0x4c8,0x4c8,0x4c8,0x4ce,0x4ce,0x4ce,0x1137,0x1137,0x1137,0x1137,0x1137,
+0x4cb,0x4cb,0x4cb,0x4cb,0x4cb,0x4cb,0x4cb,0x4cb,0x4cb,0x4cb,0x4cb,0x4cb,0x4cb,0x4cb,0x4cb,0x4cb,
+0x4cb,0x4cb,0x4cb,0x4cb,0x4cb,0x4cb,0x4cb,0x4cb,0x4cb,0x4cb,0x4cb,0x4cb,0x4cb,0x4cb,0x4cb,0x4cb,
+0x4cb,0x4cb,0x1134,0x1134,0x1134,0x1134,0x1134,0x1134,0x4d1,0x4ce,0x4ce,0x4ce,0x4ce,0x4ce,0x4ce,0x4ce,
+0x4ce,0x4ce,0x4ce,0x4ce,0x4ce,0x4ce,0x4ce,0x4ce,0x4ce,0x4ce,0x4ce,0x4ce,0x4ce,0x4ce,0x4ce,0x4ce,
+0x4ce,0x4ce,0x4ce,0x4ce,0x4ce,0x4ce,0x4ce,0x4ce,0x4ce,0x4ce,0x4ce,0x4ce,0x4da,0x4d4,0x4da,0x4d4,
+0x4da,0x4d4,0x4da,0x4d4,0x4da,0x4d4,0x4da,0x4d4,0x4da,0x4d4,0x4da,0x4d4,0x4da,0x4d4,0x4da,0x4d4,
+0x4da,0x4d4,0x4da,0x4d4,0x4da,0x4d4,0x4da,0x4d4,0x4da,0x4d4,0x4da,0x4d4,0x4da,0x4d4,0x4d4,0x4d4,
+0x4d4,0x4d4,0x4d7,0x9a2,0xfc9,0xfc9,0xfcc,0xfc9,0x4da,0x4d4,0x4da,0x4d4,0x4da,0x4d4,0x4da,0x4d4,
+0x4da,0x4d4,0x4da,0x4d4,0x4da,0x4d4,0x4da,0x4d4,0x4da,0x4d4,0x4da,0x4d4,0x4da,0x4d4,0x4da,0x4d4,
+0x4da,0x4d4,0xfcc,0xfc9,0xfcc,0xfc9,0xfcc,0xfc9,0x4e6,0x4e6,0x4e6,0x4e6,0x4e6,0x4e6,0x4e6,0x4e6,
+0x4e9,0x4e9,0x4e9,0x4e9,0x4e9,0x4e9,0x4e9,0x4e9,0x4e6,0x4e6,0x4e6,0x4e6,0x4e6,0x4e6,0x4e6,0x4e6,
+0x4e9,0x4e9,0x4e9,0x4e9,0x4e9,0x4e9,0x4e9,0x4e9,0x6a5,0x6a5,0x6a8,0x504,0x6b4,0x6b1,0x6b1,0x6ae,
+0x52e,0x52e,0x4ec,0x4ec,0x4ec,0x4ec,0x4ec,0xb34,0x6b7,0x510,0x6cf,0x6d2,0x525,0x6b7,0x513,0x513,
+0x504,0x51f,0x51f,0x6a5,0x52b,0x528,0x6ab,0x4fe,0x4f5,0x4f5,0x4f8,0x4f8,0x4f8,0x4f8,0x4f8,0x4fb,
+0x4f8,0x4f8,0x4f8,0x4ef,0x537,0x534,0x531,0x531,0x6c3,0x519,0x516,0x6c0,0x6bd,0x6ba,0x6cc,0x507,
+0x6c9,0x6c9,0x51c,0x51f,0x6c6,0x6c6,0x51c,0x51f,0x501,0x504,0x504,0x504,0x522,0x50d,0x50a,0xbb8,
+0xad7,0xad7,0xad4,0xad4,0xad4,0xad4,0xbaf,0xbaf,0xbaf,0xbaf,0xbb5,0xcdb,0xcd8,0xdbc,0xdbf,0xbb2,
+0xdbf,0xdbf,0xdbf,0xdbf,0xdbc,0xdbf,0xdbf,0xbac,0x55b,0x55b,0x55b,0x55b,0x55b,0x55b,0x55b,0x558,
+0x55e,0x73e,0x55b,0x9a5,0x9c6,0xada,0xada,0xada,0xbbe,0xbbe,0xdc5,0xdc5,0xdc5,0xdc5,0x1140,0x1143,
+0x1143,0x1314,0x14a6,0x14d0,0x14d3,0x14d3,0x16da,0x185a,0x56a,0x56a,0x582,0x6e4,0x567,0x6de,0x56a,0x57f,
+0x567,0x6e4,0x579,0x582,0x582,0x582,0x579,0x579,0x582,0x582,0x582,0x6ea,0x567,0x582,0x6e7,0x567,
+0x576,0x582,0x582,0x582,0x582,0x582,0x567,0x567,0x56d,0x6de,0x6e1,0x567,0x582,0x567,0x6ed,0x567,
+0x582,0x570,0x588,0x6f0,0x582,0x582,0x573,0x579,0x582,0x582,0x585,0x582,0x579,0x57c,0x57c,0x57c,
+0x57c,0xae3,0xae0,0xcde,0xdce,0xbd3,0xbd6,0xbd6,0xbd0,0xbcd,0xbcd,0xbcd,0xbcd,0xbd6,0xbd3,0xbd3,
+0xbd3,0xbd3,0xbca,0xbcd,0xdcb,0xedc,0xedf,0xfd2,0x1146,0x1146,0x1146,0x6f6,0x6f3,0x58b,0x58e,0x58e,
+0x58e,0x58e,0x58e,0x6f3,0x6f6,0x6f6,0x6f3,0x58e,0x6fc,0x6fc,0x6fc,0x6fc,0x6fc,0x6fc,0x6fc,0x6fc,
+0x6fc,0x6fc,0x6fc,0x6fc,0x597,0x597,0x597,0x597,0x6f9,0x6f9,0x6f9,0x6f9,0x6f9,0x6f9,0x6f9,0x6f9,
+0x6f9,0x6f9,0x591,0x591,0x591,0x591,0x591,0x591,0x59d,0x59d,0x59d,0x59d,0x59d,0x59d,0x59d,0x59d,
+0x59a,0x59d,0x59d,0x59d,0x59d,0x59d,0x5a0,0x59a,0x59d,0x59d,0x59a,0x59a,0x59a,0x59a,0x59d,0x59d,
+0x6ff,0x6ff,0x59a,0x59a,0x59d,0x59d,0x59d,0x59d,0x59d,0x59d,0x59d,0x59d,0x59d,0x59d,0x59d,0x59d,
+0x59d,0x5a0,0x5a0,0x5a0,0x59d,0x59d,0x702,0x59d,0x702,0x59d,0x59d,0x59d,0x59d,0x59d,0x59d,0x59d,
+0x59a,0x59d,0x59a,0x59a,0x59a,0x59a,0x59a,0x59a,0x59d,0x59d,0x59a,0x6ff,0x59a,0x59a,0x59a,0xae9,
+0xae9,0xae9,0xae9,0xae9,0xae9,0xae9,0xae9,0xae9,0xbd9,0xbd9,0xbd9,0xbd9,0xbd9,0xbd9,0xbd9,0xbd9,
+0xbd9,0xbd9,0xbd9,0xbd9,0x705,0x5a3,0x705,0x705,0x5a6,0x5a3,0x5a3,0x705,0x705,0x5a6,0x5a3,0x705,
+0x5a6,0x5a3,0x5a3,0x705,0x5a3,0x705,0x5b2,0x5af,0x5a3,0x705,0x5a3,0x5a3,0x5a3,0x5a3,0x705,0x5a3,
+0x5a3,0x705,0x705,0x705,0x705,0x5a3,0x5a3,0x705,0x5a6,0x705,0x5a6,0x705,0x705,0x705,0x705,0x705,
+0x70b,0x5a9,0x705,0x5a9,0x5a9,0x5a3,0x5a3,0x5a3,0x705,0x705,0x705,0x705,0x5a3,0x5a3,0x5a3,0x5a3,
+0x705,0x705,0x5a3,0x5a3,0x5a3,0x5a6,0x5a3,0x5a3,0x5a6,0x5a3,0x5a3,0x5a6,0x705,0x5a6,0x5a3,0x5a3,
+0x705,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x705,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,
+0x5a3,0x5a3,0x5a3,0x5a3,0x708,0x705,0x5a6,0x5a3,0x705,0x705,0x705,0x705,0x5a3,0x5a3,0x705,0x705,
+0x5a3,0x5a6,0x708,0x708,0x5a6,0x5a6,0x5a3,0x5a3,0x5a6,0x5a6,0x5a3,0x5a3,0x5a6,0x5a6,0x5a3,0x5a3,
+0x5a3,0x5a3,0x5a3,0x5a3,0x5a6,0x5a6,0x705,0x705,0x5a6,0x5a6,0x705,0x705,0x5a6,0x5a6,0x5a3,0x5a3,
+0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x705,0x5a3,0x5a3,0x5a3,0x705,0x5a3,0x5a3,
+0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x705,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a6,0x5a6,0x5a6,0x5a6,
+0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x705,
+0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,
+0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,
+0x5a6,0x5a6,0x5a6,0x5a6,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a3,0x5a6,0x5a6,0x5a6,0x5a6,0x5a3,0x5ac,
+0x5a3,0x5a3,0xbdc,0xbdc,0xbdc,0xbdc,0xbdc,0xbdc,0xbdc,0xbdc,0xbdc,0xbdc,0xbdc,0xbdc,0xbdc,0xbdc,
+0x5b5,0xaec,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x5be,0x5bb,0x5be,0x5bb,0x5b5,0x5b5,0x5b5,0x5b5,
+0x5b5,0x5b5,0x70e,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x7fe,0x7fe,0x5b5,0x5b5,0x5b5,0x5b5,
+0x5b8,0x5b8,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x804,0x801,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,
+0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,
+0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0x5b5,0xaec,
+0xbe2,0xaec,0xaec,0xaec,0x5c1,0x5c1,0x5c1,0x5c1,0x5c1,0x5c1,0x5c1,0x5c1,0x5c1,0x5c1,0x5c1,0x5c1,
+0x5c1,0x5c1,0x5c1,0x5c1,0x5c1,0x5c1,0x5c1,0x5c1,0x5c1,0x5c1,0x5c1,0x5c1,0x5c1,0x5c1,0x5c1,0x5c1,
+0x5c1,0x5c1,0x5c1,0x5c1,0x717,0x717,0x717,0x717,0x717,0x717,0x717,0x717,0x717,0x717,0x5c7,0xc3f,
+0xc3f,0xc3f,0xc3f,0xc3f,0xc3f,0xc3f,0xc3f,0xc3f,0xc3f,0xc3f,0xc3f,0xc3f,0xc3f,0xc3f,0xc3f,0xc3f,
+0xc3f,0xc3f,0xc3f,0xd4d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,
+0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x5ca,0x5cd,0x5cd,0x5cd,0x5cd,0x5cd,0x5cd,0x5cd,
+0x5cd,0x5cd,0x5cd,0x5cd,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,
+0x5cd,0x5cd,0x5cd,0x5cd,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,
+0x71d,0x71d,0x71d,0x71d,0x720,0x720,0x720,0x720,0x720,0x720,0x720,0x720,0x720,0x720,0x720,0x720,
+0x720,0x720,0x720,0x720,0x5d0,0x5d0,0x720,0x720,0x720,0x720,0xbe5,0xbe5,0xbe5,0xbe5,0xbe5,0xbe5,
+0xbe5,0xbe5,0xbe5,0xbe5,0x726,0x726,0x5d3,0x723,0x723,0x723,0x723,0x723,0x723,0x723,0x5d3,0x5d3,
+0x5d3,0x5d3,0x5d6,0x5d6,0x5d6,0x5d6,0x726,0x726,0x5d6,0x5d6,0x726,0x726,0x5d3,0x5d3,0x5d3,0x5d3,
+0x726,0x726,0x5d6,0x5d6,0x726,0x726,0x5d3,0x5d3,0x5d3,0x5d3,0x726,0x726,0x723,0x5d3,0x5d6,0x726,
+0x5d3,0x5d3,0x723,0x726,0x726,0x726,0x5d6,0x5d6,0x5d3,0x5d3,0x5d3,0x5d3,0x5d3,0x5d3,0x5d3,0x5d3,
+0x5d3,0x5d3,0x5d3,0x5d3,0x5d3,0x5d3,0x726,0x723,0x726,0x723,0x5d3,0x5d6,0x5d6,0x5d6,0x5d6,0x5d6,
+0x5d6,0x5d3,0x5d3,0x723,0xaf2,0xaf2,0xaf2,0xaf2,0xaf2,0xaf2,0xaf2,0xaf2,0xbe8,0xbe8,0xbe8,0xbe8,
+0xbe8,0xc57,0xc57,0xbe8,0x5dc,0x5dc,0x5dc,0x5dc,0x5d9,0x72f,0x72f,0x5d9,0x5d9,0x729,0x5d9,0x5d9,
+0x5d9,0x5d9,0x729,0x729,0x5d9,0x5d9,0x5d9,0x5d9,0xd56,0xd56,0xbeb,0xbeb,0xdd7,0xaf5,0x5dc,0x5dc,
+0x72c,0x5df,0x72c,0x5dc,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,
+0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5dc,0x5dc,0x5dc,
+0x5d9,0x5d9,0x5d9,0x5d9,0x72f,0x5d9,0x72f,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x807,0x807,0x807,0x807,
+0x807,0x807,0x807,0x807,0x807,0x807,0x807,0x807,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,0x5d9,
+0x5d9,0x5d9,0x5d9,0x5d9,0x72f,0x72f,0x5e2,0x72f,0x729,0x729,0x5d9,0x729,0x72c,0x729,0x729,0x5d9,
+0x729,0x72f,0x5e2,0x72f,0xaf5,0xaf5,0xbee,0xbee,0xbee,0xbee,0xbee,0xbee,0xbee,0xbee,0xbee,0xbee,
+0xbee,0xbee,0xdd4,0xe8b,0x5e5,0x5e5,0x5e5,0x5e5,0x5e5,0x5e5,0x5e5,0x5e5,0x5e5,0x5e5,0x5e5,0x5e5,
+0x5e5,0x5e5,0x5e5,0x5e5,0x5e5,0x5e5,0x5e5,0x5e5,0x5e8,0x139b,0x139b,0x139b,0x5e8,0x5e8,0x5e8,0x5e8,
+0x5e8,0x5e8,0x5e8,0x5e8,0x14d9,0x5ee,0x5ee,0x5ee,0x5ee,0x139b,0x5e8,0x5e8,0x5ee,0x5ee,0x139e,0x139e,
+0x5f4,0x5f4,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,
+0x5e8,0x5e8,0x5e8,0x5e8,0x139b,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,
+0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x735,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,
+0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x139b,0x5e8,0x139b,0x5e8,0x5e8,0x5e8,0x5e8,0x139b,
+0x139b,0x139b,0x5e8,0x1299,0x5e8,0x5e8,0x5e8,0x5f1,0x5f1,0x5f1,0x5f1,0x1320,0x1320,0x5e8,0x5eb,0x5eb,
+0x5ee,0x5e8,0x5e8,0x5e8,0xbf4,0xbf1,0xbf4,0xbf1,0xbf4,0xbf1,0xbf4,0xbf1,0xbf4,0xbf1,0xbf4,0xbf1,
+0xbf4,0xbf1,0x732,0x732,0x732,0x732,0x732,0x732,0x732,0x732,0x732,0x732,0x5e8,0x5e8,0x5e8,0x5e8,
+0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x139b,0x5e8,0x5e8,0x5e8,
+0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x5e8,0x139b,0x615,0x615,0x615,0x615,
+0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,
+0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x60c,0x60c,0x60c,0x60c,0x60c,0x60c,
+0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,
+0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0xb46,0xb46,0xb46,0xb46,
+0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0x615,0x615,0x95a,0x615,
+0x615,0x615,0x615,0x615,0x615,0x615,0x60c,0x60c,0xbf7,0xd7a,0x1b0f,0x1b0f,0x612,0x618,0x615,0x60f,
+0x612,0x618,0x615,0x60f,0x612,0x618,0x615,0x60f,0x612,0x618,0x615,0x60f,0x612,0x618,0x615,0x60f,
+0x612,0x618,0x615,0x60f,0x612,0x618,0x615,0x60f,0x612,0x618,0x615,0x60f,0x615,0x60f,0x615,0x60f,
+0x615,0x60f,0x615,0x60f,0x615,0x60f,0x615,0x60f,0x612,0x618,0x615,0x60f,0x612,0x618,0x615,0x60f,
+0x612,0x618,0x615,0x60f,0x612,0x618,0x615,0x60f,0x615,0x60f,0x612,0x618,0x615,0x60f,0x615,0x60f,
+0x612,0x618,0x615,0x60f,0x612,0x618,0x615,0x60f,0x615,0x60f,0x1323,0x1323,0x1323,0x1323,0x1323,0x1323,
+0x1323,0x1323,0x1323,0x1323,0x1323,0x1323,0x1323,0x1323,0x615,0x60f,0x615,0x60f,0x615,0x60f,0x612,0x618,
+0x612,0x618,0x615,0x60f,0x615,0x60f,0x615,0x60f,0x615,0x60f,0x615,0x60f,0x615,0x60f,0x615,0x60f,
+0x612,0x615,0x60f,0x612,0x615,0x60f,0x612,0x618,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,
+0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x612,
+0x612,0x612,0x612,0x612,0x612,0x612,0x612,0x612,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,
+0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,
+0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x612,0x612,0x612,0x612,0x612,0x612,0x612,
+0x618,0x618,0x618,0x618,0x618,0x618,0x618,0x618,0x60f,0x615,0x918,0x91b,0x1b0f,0x1b0f,0x1b0f,0x1b0f,
+0x1b0f,0x1b0f,0x1b0f,0x1b0f,0x1b0f,0x1b0f,0x1b0f,0x1b0f,0x1b0f,0x1b0f,0x1b0f,0x1b0f,0x612,0x60f,0x612,0x612,
+0x612,0x612,0x612,0x612,0x60f,0x612,0x60f,0x60f,0x612,0x612,0x60f,0x60f,0x612,0x612,0x60f,0x612,
+0x60f,0x612,0x60f,0x60f,0x612,0x60f,0x60f,0x612,0x60f,0x612,0x60f,0x60f,0x612,0x60f,0x612,0x612,
+0x60f,0x60f,0x60f,0x612,0x60f,0x60f,0x60f,0x60f,0x60f,0x612,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,
+0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,0x60f,
+0x612,0x612,0x60f,0x60f,0x612,0x60f,0x612,0x60f,0x60f,0x60f,0x60f,0x60f,0x612,0x612,0x612,0x612,
+0x612,0x612,0x612,0x612,0x612,0x612,0x612,0x612,0x612,0x612,0x612,0x612,0x612,0x612,0x612,0x612,
+0x612,0x612,0x612,0x612,0x612,0x612,0x612,0x612,0x612,0x612,0x612,0x612,0x612,0x612,0x612,0x618,
+0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,
+0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,
+0x618,0x618,0x618,0x618,0x618,0x618,0x618,0x618,0x618,0x618,0x618,0x618,0x618,0x618,0x618,0x618,
+0x618,0x618,0x618,0x618,0x618,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,0x615,
+0x61b,0x61b,0x61b,0x61b,0xfde,0xfde,0xfde,0x14dc,0x14dc,0x14dc,0x14dc,0x14dc,0x14dc,0x14dc,0x16e0,0x16e0,
+0x864,0x86a,0x86a,0x876,0x876,0x867,0x85e,0x867,0x85e,0x867,0x85e,0x867,0x85e,0x867,0x85e,0x867,
+0x62a,0x62a,0x624,0x62a,0x624,0x62a,0x624,0x62a,0x624,0x62a,0x624,0x627,0x62d,0x62a,0x624,0x62a,
+0x624,0x627,0x62d,0x62a,0x624,0x62a,0x624,0x627,0x62d,0x62a,0x624,0x627,0x62d,0x62a,0x624,0x627,
+0x62d,0x62a,0x624,0x62a,0x624,0x62a,0x624,0x62a,0x624,0x62a,0x624,0x627,0x62d,0x62a,0x624,0x627,
+0x62d,0x62a,0x624,0x627,0x62d,0x62a,0x624,0x627,0x62d,0x62a,0x624,0x627,0x62d,0x62a,0x624,0x627,
+0x62d,0x62a,0x624,0x627,0x62d,0x62a,0x624,0x627,0x62d,0x62a,0x624,0x627,0x714,0x714,0x714,0x714,
+0x714,0x714,0x714,0x714,0x714,0x714,0x714,0x714,0x714,0x714,0x714,0x714,0x714,0x714,0x714,0x714,
+0x711,0x711,0x711,0x711,0x711,0x711,0x711,0x711,0x711,0x711,0x711,0x711,0x711,0x711,0x711,0x711,
+0x711,0x711,0x711,0x711,0x711,0x711,0x711,0x711,0x711,0x711,0x711,0x711,0x711,0x711,0x711,0x711,
+0x711,0x711,0x71a,0x71a,0x71a,0x71a,0x71a,0x71a,0x71a,0x71a,0x71a,0x71a,0x71a,0x71a,0x71a,0x71a,
+0x71a,0x71a,0x71a,0x71a,0x717,0x717,0x717,0x717,0x717,0x717,0x717,0x717,0x717,0x717,0x717,0x717,
+0x717,0x717,0x717,0x717,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,
+0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,0x71d,
+0x71d,0x71d,0x71d,0x71d,0x738,0x738,0x738,0x738,0x738,0x738,0x738,0x738,0x738,0x738,0x738,0x738,
+0x738,0x738,0x738,0x738,0x738,0x738,0x738,0x738,0x738,0x738,0x738,0x738,0x738,0x738,0x738,0x738,
+0x738,0x738,0x738,0x738,0xc45,0x8c7,0x8c1,0x8be,0x8c4,0x8bb,0x74d,0x750,0x750,0x750,0x750,0x750,
+0x750,0x750,0x750,0x750,0x8cd,0x74d,0x74d,0x74d,0x74d,0x74d,0x74d,0x74d,0x74d,0x74d,0x74d,0x74d,
+0x74d,0x74d,0x74d,0x74d,0x74d,0x74d,0x74d,0x74d,0x74d,0x74d,0x74d,0x74d,0x74d,0x74d,0x74d,0x74d,
+0x74d,0x74d,0x74d,0x74d,0x74d,0x74d,0x8ca,0x8ca,0x753,0x8dc,0x8df,0x8e5,0x80a,0x816,0x8fa,0x813,
+0x8d3,0x8d0,0x8d3,0x8d0,0x8d9,0x8d6,0x8d9,0x8d6,0x8d3,0x8d0,0x810,0x8e5,0x8d3,0x8d0,0x8d3,0x8d0,
+0x8d3,0x8d0,0x8d3,0x8d0,0x8eb,0x8f1,0x8ee,0x8ee,0x759,0x795,0x795,0x795,0x795,0x795,0x795,0x78f,
+0x78f,0x78f,0x78f,0x78f,0x78f,0x78f,0x78f,0x78f,0x78f,0x78f,0x78f,0x78f,0x78f,0x78f,0x78f,0x78f,
+0x78f,0x78f,0x78f,0x75c,0x777,0x756,0x77d,0x780,0x77a,0x792,0x792,0x792,0x792,0x792,0x792,0x78c,
+0x78c,0x78c,0x78c,0x78c,0x78c,0x78c,0x78c,0x78c,0x78c,0x78c,0x78c,0x78c,0x78c,0x78c,0x78c,0x78c,
+0x78c,0x78c,0x78c,0x75c,0x777,0x756,0x777,0xc48,0x7f8,0x7f8,0x7f8,0x7f8,0x7f8,0x7f8,0x7f8,0x7f8,
+0x7f8,0x7f8,0x7f8,0x7f8,0x7f8,0x7f8,0x7f8,0x7f8,0x7f8,0x7f8,0x7f8,0x7f8,0x7f8,0x7f8,0x7f8,0x7f8,
+0x7f8,0x7f8,0x7f8,0x7f8,0x7f8,0x7f8,0x7f8,0x7f8,0x7f8,0x7f8,0x1293,0x1293,0x1293,0x1293,0x1293,0x7fb,
+0x810,0x813,0x813,0x813,0x813,0x813,0x813,0x813,0x813,0x813,0x933,0x933,0x933,0x933,0x819,0x819,
+0x8e8,0x8f7,0x8f7,0x8f7,0x8f7,0x8f4,0x80d,0x8e2,0xb19,0xb19,0xb19,0xc5a,0xc78,0xc75,0xb37,0x8b8,
+0x81f,0x81c,0x81f,0x822,0x81c,0x81f,0x81c,0x81f,0x81c,0x81f,0x81c,0x81c,0x81c,0x81c,0x81c,0x81c,
+0x81f,0x81f,0x81c,0x81f,0x81f,0x81c,0x81f,0x81f,0x81c,0x81f,0x81f,0x81c,0x81f,0x81f,0x81c,0x81c,
+0xc7b,0x831,0x82b,0x831,0x82b,0x831,0x82b,0x831,0x82b,0x831,0x82b,0x82b,0x82e,0x82b,0x82e,0x82b,
+0x82e,0x82b,0x82e,0x82b,0x82e,0x82b,0x82e,0x82b,0x82e,0x82b,0x82e,0x82b,0x82e,0x82b,0x82e,0x82b,
+0x82e,0x82b,0x82e,0x831,0x82b,0x82e,0x82b,0x82e,0x82b,0x82e,0x82b,0x82b,0x82b,0x82b,0x82b,0x82b,
+0x82e,0x82e,0x82b,0x82e,0x82e,0x82b,0x82e,0x82e,0x82b,0x82e,0x82e,0x82b,0x82e,0x82e,0x82b,0x82b,
+0x82b,0x82b,0x82b,0x831,0x82b,0x831,0x82b,0x831,0x82b,0x82b,0x82b,0x82b,0x82b,0x82b,0x831,0x82b,
+0x82b,0x82b,0x82b,0x82b,0x82e,0x831,0x831,0x82e,0x82e,0x82e,0x82e,0x900,0x903,0x834,0x837,0xc63,
 0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,
-0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x1a46,
-0x903,0x903,0x903,0x903,0x903,0x903,0x903,0x903,0x903,0x903,0x903,0x903,0x903,0x903,0x903,0x903,
-0x903,0x840,0x840,0x840,0x840,0x840,0x840,0xd50,0xd50,0xd50,0xd50,0x906,0x906,0x906,0x906,0x906,
-0x840,0x840,0x840,0x840,0x840,0x840,0x840,0x840,0x840,0x840,0x840,0x840,0x840,0x840,0x840,0x840,
-0x840,0x840,0x840,0x840,0x840,0x840,0x840,0x840,0x840,0x840,0x840,0x840,0x840,0x840,0x840,0x840,
-0x840,0x840,0xd50,0xd50,0x843,0x843,0x843,0x843,0x843,0x843,0x843,0x843,0x843,0x843,0x843,0x843,
-0x843,0x843,0x843,0x843,0x843,0x843,0x843,0x843,0x843,0x843,0x843,0x843,0x843,0x843,0x843,0x843,
-0x843,0x843,0x843,0x843,0x903,0x903,0x903,0x903,0x903,0x903,0x903,0x903,0x846,0x846,0x846,0x846,
-0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,
-0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,0xe7f,0xe7f,
-0xe7f,0xe7f,0xe7f,0xe7f,0xe7f,0xe7f,0xe7f,0xe7f,0xe7f,0xe7f,0xe7f,0xe7f,0xe7f,0xe7f,0xe7f,0xe7f,
-0xe7f,0xe7f,0xe7f,0xe7f,0x10ef,0x10ef,0x10ef,0x10ef,0x849,0x849,0x849,0x849,0x849,0x849,0x849,0x849,
+0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,
+0x840,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,
+0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x83d,0x849,0x849,0x849,0x849,
 0x849,0x849,0x849,0x849,0x849,0x849,0x849,0x849,0x849,0x849,0x849,0x849,0x849,0x849,0x849,0x849,
-0x849,0x849,0x849,0x849,0x849,0x849,0x849,0x849,0x849,0x849,0x84c,0x84c,0x849,0x84c,0x849,0x84c,
-0x84c,0x849,0x849,0x849,0x849,0x849,0x849,0x849,0x849,0x849,0x849,0x84c,0x849,0x84c,0x849,0x84c,
-0x84c,0x849,0x849,0x84c,0x84c,0x84c,0x849,0x849,0x849,0x849,0x1485,0x1485,0xc5a,0xc5a,0xc5a,0xc5a,
-0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0x8fd,0x8fd,0x8fd,0x8fd,
-0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,
-0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0x12c0,0x12c0,0x12c0,0x12c0,
-0x1269,0x1269,0x1269,0x1269,0x1269,0x1269,0x1269,0x1269,0xd47,0xc54,0xc54,0xc54,0xc54,0xc54,0xc54,0xc54,
-0xc54,0xc54,0xc54,0xc54,0xc54,0xc54,0xc54,0xc54,0x900,0x900,0x900,0x900,0x900,0x900,0x900,0x900,
-0x900,0x900,0x900,0x900,0x900,0x900,0x900,0x900,0x900,0x900,0x900,0x900,0x900,0x900,0x900,0x900,
-0x900,0x900,0x900,0x900,0x900,0x900,0x900,0x900,0x900,0xc54,0xc54,0xc54,0xc54,0xc54,0xc54,0xc54,
-0xc54,0xc54,0xc54,0xc54,0xc54,0xc54,0xc54,0xc54,0x903,0x903,0x903,0x903,0x903,0x903,0x903,0x903,
-0x903,0x903,0x903,0x903,0x903,0x903,0x903,0x903,0x903,0x903,0x903,0x903,0x903,0x903,0x903,0x903,
-0x903,0x903,0x903,0x903,0x903,0x903,0x903,0xd50,0x98a,0x96c,0x96c,0x96c,0x96c,0x966,0x96c,0x96c,
-0x97e,0x96c,0x96c,0x969,0x975,0x97b,0x97b,0x97b,0x97b,0x97b,0x97e,0x966,0x972,0x966,0x966,0x966,
-0x95d,0x95d,0x966,0x966,0x966,0x966,0x966,0x966,0x981,0x981,0x981,0x981,0x981,0x981,0x981,0x981,
-0x981,0x981,0x966,0x966,0x966,0x966,0x966,0x966,0x966,0x966,0x966,0x966,0x969,0x95d,0x966,0x95d,
-0x966,0x95d,0x978,0x96f,0x978,0x96f,0x987,0x987,0x996,0x996,0x996,0x996,0x996,0x996,0x996,0x996,
-0x996,0x996,0x996,0x996,0x996,0x996,0x996,0x996,0x996,0x996,0x996,0x996,0x996,0x996,0x996,0x996,
-0x996,0x996,0x996,0x996,0x996,0x996,0x996,0x996,0x999,0x999,0x999,0x999,0x999,0x999,0x999,0x999,
-0x999,0x999,0x999,0x999,0x999,0x999,0x999,0x999,0x999,0x999,0x999,0x999,0x999,0x999,0x999,0x999,
-0x999,0x999,0x999,0x999,0x999,0x999,0x999,0x999,0x99c,0x99c,0x99c,0x99c,0x99c,0x99c,0x99c,0x99c,
-0x99c,0x99c,0x99c,0x99c,0x99c,0x99c,0x99c,0x99c,0x99c,0x99c,0x99c,0x99c,0x99c,0x99c,0x99c,0x99c,
-0x99c,0x99c,0x99c,0x99c,0x99c,0x99c,0x99c,0x99c,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,
-0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,
-0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x99f,0x99f,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,
-0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,
-0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a2,0x9a2,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,
-0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,
-0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a5,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,
+0x849,0x849,0x849,0x849,0x849,0x849,0x849,0x849,0xd5f,0xd5f,0xe8e,0x843,0x90c,0x90c,0x90c,0x90c,
+0x90c,0x90c,0x90c,0x90c,0x90c,0x90c,0x90c,0x90c,0xd59,0xd59,0xd59,0xd59,0x84c,0x84c,0x84c,0x84c,
+0x84c,0x84c,0x84c,0x84c,0x84c,0x84c,0x84c,0x84c,0x84c,0x84c,0x84c,0x84c,0x84c,0x84c,0x84c,0x84c,
+0x84c,0x84c,0x84c,0x84c,0x84c,0x84c,0x84c,0x84c,0x84c,0x84c,0x84c,0x1a58,0x912,0x912,0x912,0x912,
+0x912,0x912,0x912,0x912,0x912,0x912,0x912,0x912,0x912,0x912,0x912,0x912,0x912,0x84f,0x84f,0x84f,
+0x84f,0x84f,0x84f,0xd62,0xd62,0xd62,0xd62,0x915,0x915,0x915,0x915,0x915,0x84f,0x84f,0x84f,0x84f,
+0x84f,0x84f,0x84f,0x84f,0x84f,0x84f,0x84f,0x84f,0x84f,0x84f,0x84f,0x84f,0x84f,0x84f,0x84f,0x84f,
+0x84f,0x84f,0x84f,0x84f,0x84f,0x84f,0x84f,0x84f,0x84f,0x84f,0x84f,0x84f,0x84f,0x84f,0xd62,0xd62,
+0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,
+0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,
+0x912,0x912,0x912,0x912,0x912,0x912,0x912,0x912,0x855,0x855,0x855,0x855,0x855,0x855,0x855,0x855,
+0x855,0x855,0x855,0x855,0x855,0x855,0x855,0x855,0x855,0x855,0x855,0x855,0x855,0x855,0x855,0x855,
+0x855,0x855,0x855,0x855,0x855,0x855,0x855,0x855,0x855,0x855,0xe91,0xe91,0xe91,0xe91,0xe91,0xe91,
+0xe91,0xe91,0xe91,0xe91,0xe91,0xe91,0xe91,0xe91,0xe91,0xe91,0xe91,0xe91,0xe91,0xe91,0xe91,0xe91,
+0x1104,0x1104,0x1104,0x1104,0x858,0x858,0x858,0x858,0x858,0x858,0x858,0x858,0x858,0x858,0x858,0x858,
+0x858,0x858,0x858,0x858,0x858,0x858,0x858,0x858,0x858,0x858,0x858,0x858,0x858,0x858,0x858,0x858,
+0x858,0x858,0x858,0x858,0x858,0x858,0x85b,0x85b,0x858,0x85b,0x858,0x85b,0x85b,0x858,0x858,0x858,
+0x858,0x858,0x858,0x858,0x858,0x858,0x858,0x85b,0x858,0x85b,0x858,0x85b,0x85b,0x858,0x858,0x85b,
+0x85b,0x85b,0x858,0x858,0x858,0x858,0x1497,0x1497,0xc6c,0xc6c,0xc6c,0xc6c,0xc6c,0xc6c,0xc6c,0xc6c,
+0xc6c,0xc6c,0xc6c,0xc6c,0xc6c,0xc6c,0xc6c,0xc6c,0x90c,0x90c,0x90c,0x90c,0x90c,0x90c,0x90c,0x90c,
+0x90c,0x90c,0x90c,0x90c,0x90c,0x90c,0x90c,0x90c,0x90c,0x90c,0x90c,0x90c,0x90c,0x90c,0x90c,0x90c,
+0x90c,0x90c,0x90c,0x90c,0x90c,0x90c,0x90c,0x90c,0x12d2,0x12d2,0x12d2,0x12d2,0x127b,0x127b,0x127b,0x127b,
+0x127b,0x127b,0x127b,0x127b,0xd59,0xc66,0xc66,0xc66,0xc66,0xc66,0xc66,0xc66,0xc66,0xc66,0xc66,0xc66,
+0xc66,0xc66,0xc66,0xc66,0x90f,0x90f,0x90f,0x90f,0x90f,0x90f,0x90f,0x90f,0x90f,0x90f,0x90f,0x90f,
+0x90f,0x90f,0x90f,0x90f,0x90f,0x90f,0x90f,0x90f,0x90f,0x90f,0x90f,0x90f,0x90f,0x90f,0x90f,0x90f,
+0x90f,0x90f,0x90f,0x90f,0x90f,0xc66,0xc66,0xc66,0xc66,0xc66,0xc66,0xc66,0xc66,0xc66,0xc66,0xc66,
+0xc66,0xc66,0xc66,0xc66,0x912,0x912,0x912,0x912,0x912,0x912,0x912,0x912,0x912,0x912,0x912,0x912,
+0x912,0x912,0x912,0x912,0x912,0x912,0x912,0x912,0x912,0x912,0x912,0x912,0x912,0x912,0x912,0x912,
+0x912,0x912,0x912,0xd62,0x99c,0x97e,0x97e,0x97e,0x97e,0x978,0x97e,0x97e,0x990,0x97e,0x97e,0x97b,
+0x987,0x98d,0x98d,0x98d,0x98d,0x98d,0x990,0x978,0x984,0x978,0x978,0x978,0x96c,0x96c,0x978,0x978,
+0x978,0x978,0x978,0x978,0x993,0x993,0x993,0x993,0x993,0x993,0x993,0x993,0x993,0x993,0x978,0x978,
+0x978,0x978,0x978,0x978,0x978,0x978,0x978,0x978,0x97b,0x96c,0x978,0x96c,0x978,0x96c,0x98a,0x981,
+0x98a,0x981,0x999,0x999,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,
 0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,
-0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9a8,0x9ab,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,
+0x9a8,0x9a8,0x9a8,0x9a8,0x9ab,0x9ab,0x9ab,0x9ab,0x9ab,0x9ab,0x9ab,0x9ab,0x9ab,0x9ab,0x9ab,0x9ab,
+0x9ab,0x9ab,0x9ab,0x9ab,0x9ab,0x9ab,0x9ab,0x9ab,0x9ab,0x9ab,0x9ab,0x9ab,0x9ab,0x9ab,0x9ab,0x9ab,
+0x9ab,0x9ab,0x9ab,0x9ab,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,
 0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,
-0x9ae,0x9ae,0x9ae,0x9ae,0x9ab,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,
-0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,
-0xa3b,0xa3b,0xfb1,0xa3b,0xa3b,0xa3b,0xa3e,0xa3b,0xfb1,0xa3b,0xa3b,0xfa8,0xa35,0xa29,0xa29,0xa29,
-0xa29,0xa38,0xa29,0xf99,0xf99,0xf99,0xa29,0xa2c,0xa35,0xa2f,0xf9f,0xfab,0xfab,0xf99,0xf99,0xfb1,
-0xb2b,0xb2b,0xb2b,0xb2b,0xb2b,0xb2b,0xb2b,0xb2b,0xb2b,0xb2b,0xa41,0xa41,0xa32,0xa32,0xa32,0xa32,
-0xa3b,0xa3b,0xa3b,0xa3b,0xa3b,0xa3b,0xa38,0xa38,0xa29,0xa29,0xfb1,0xfb1,0xfb1,0xfb1,0xf99,0xf99,
-0xa3b,0xa3b,0xa3b,0xa3b,0xa3b,0xa3b,0xa3b,0xa3b,0xa3b,0xa3b,0xa3b,0xa3b,0xa3b,0xa3b,0xa3b,0xa3b,
-0xa3b,0xa3b,0xa3b,0xa3b,0xa3b,0xa3b,0xa3b,0xa3b,0xa3b,0xa3b,0xa3b,0xa3b,0xa3b,0xa3b,0xa3b,0xa3b,
-0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xda7,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,
-0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,
-0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xda7,0xa50,0xa50,0xa50,0xa50,
-0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa50,0xa56,0xa56,0xa56,0xa56,
-0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,
-0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,0xa56,0xa5c,0xa5c,0xa5c,0xa5c,
-0xa5c,0xa5c,0xa5c,0xa5c,0xa5c,0xa5c,0xa5c,0xa5c,0xa5c,0xa59,0xa5f,0xa5c,0xa5c,0xa5c,0xa5c,0xa5c,
-0xa5c,0xa5c,0xa5c,0x1128,0x1128,0x1128,0x1128,0x1128,0x1128,0x1128,0x1128,0x1128,0x1125,0xa5c,0xa5c,0xa5c,
-0xa5c,0xa5c,0xa5c,0xa5c,0xa5c,0xa5c,0xa5c,0xa5c,0xa5c,0xa5c,0xa5c,0xa5c,0xa5c,0xa5c,0xa5c,0xa5c,
-0xa5c,0xa5c,0xa5c,0xa5c,0xa5c,0xa5c,0xa5c,0xa5c,0xa5c,0xa5c,0xa5c,0xa5c,0xa5c,0xa5c,0xa5c,0xa5c,
-0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,
-0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,
-0xa95,0xa95,0xa95,0xa98,0xa98,0xa95,0xa95,0xa95,0xa95,0xa95,0xa95,0xa95,0xa95,0xa95,0xa95,0xa95,
-0xa95,0xa95,0xa95,0xa95,0xa7d,0xa7d,0xa92,0xa74,0xa74,0xa74,0xa74,0xa74,0xa74,0xa74,0xa92,0xa92,
-0xa95,0xa95,0xa95,0xa95,0xa95,0xa95,0xa95,0xa95,0xa95,0xa95,0xa95,0xa95,0xa95,0xa95,0xa95,0xa95,
-0xa95,0xa95,0xa95,0xa95,0xa95,0xa95,0xa95,0xa95,0xa95,0xa95,0xa95,0xa95,0xa95,0xa95,0xa95,0xa95,
-0xab6,0xab6,0xab6,0xab6,0xab6,0xaa1,0xaa1,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,
-0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,
-0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab9,0xab6,0xab6,0xab6,0xab6,
-0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,
-0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xab6,0xada,0xada,0xada,0xada,0xada,0xada,0xada,0xada,
-0xada,0xada,0xada,0xada,0xada,0xada,0xada,0xada,0xada,0xada,0xada,0xada,0xada,0xada,0xada,0xada,
-0xada,0xada,0xada,0xbd0,0xbd0,0xbd0,0xbd0,0xbd0,0xae6,0xae6,0xae6,0xae6,0xae6,0xae6,0xae6,0xae6,
-0xae6,0xae6,0xae6,0xae6,0xae6,0xae6,0xae6,0xae6,0xae6,0xae6,0xae6,0xae6,0xae6,0xae6,0xae6,0xae6,
-0xae6,0xae6,0xae6,0xae6,0xae6,0xae6,0xae6,0xae6,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,
+0x9ae,0x9ae,0x9ae,0x9ae,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,
+0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,
+0x9b7,0x9b7,0x9b1,0x9b1,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,
+0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,
+0x9ba,0x9ba,0x9b4,0x9b4,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,
+0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,0x9b7,
+0x9b7,0x9b7,0x9b7,0x9b7,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,
+0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,0x9ba,
+0x9ba,0x9ba,0x9ba,0x9ba,0x9bd,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,
+0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,
+0x9bd,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,
+0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0x9c0,0xa4d,0xa4d,0xfc3,0xa4d,
+0xa4d,0xa4d,0xa50,0xa4d,0xfc3,0xa4d,0xa4d,0xfba,0xa47,0xa3b,0xa3b,0xa3b,0xa3b,0xa4a,0xa3b,0xfab,
+0xfab,0xfab,0xa3b,0xa3e,0xa47,0xa41,0xfb1,0xfbd,0xfbd,0xfab,0xfab,0xfc3,0xb3d,0xb3d,0xb3d,0xb3d,
+0xb3d,0xb3d,0xb3d,0xb3d,0xb3d,0xb3d,0xa53,0xa53,0xa44,0xa44,0xa44,0xa44,0xa4d,0xa4d,0xa4d,0xa4d,
+0xa4d,0xa4d,0xa4a,0xa4a,0xa3b,0xa3b,0xfc3,0xfc3,0xfc3,0xfc3,0xfab,0xfab,0xa4d,0xa4d,0xa4d,0xa4d,
+0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,
+0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,0xa62,0xa62,0xa62,0xa62,
+0xa62,0xa62,0xa62,0xdb9,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,
+0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,
+0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xdb9,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,
+0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa68,0xa68,0xa68,0xa68,0xa68,0xa68,0xa68,0xa68,
+0xa68,0xa68,0xa68,0xa68,0xa68,0xa68,0xa68,0xa68,0xa68,0xa68,0xa68,0xa68,0xa68,0xa68,0xa68,0xa68,
+0xa68,0xa68,0xa68,0xa68,0xa68,0xa68,0xa68,0xa68,0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,
+0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,0xa6b,0xa71,0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,0x113d,
+0x113d,0x113d,0x113d,0x113d,0x113d,0x113d,0x113d,0x113d,0x113a,0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,
+0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,
+0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,0xa6e,0xa83,0xa83,0xa83,0xa83,
+0xa83,0xa83,0xa83,0xa83,0xa83,0xa83,0xa83,0xa83,0xa83,0xa83,0xa83,0xa83,0xa83,0xa83,0xa83,0xa83,
+0xa83,0xa83,0xa83,0xa83,0xa83,0xa83,0xa83,0xa83,0xa83,0xa83,0xa83,0xa83,0xaa7,0xaa7,0xaa7,0xaaa,
+0xaaa,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,
+0xa8f,0xa8f,0xaa4,0xa86,0xa86,0xa86,0xa86,0xa86,0xa86,0xa86,0xaa4,0xaa4,0xaa7,0xaa7,0xaa7,0xaa7,
+0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,
+0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xac8,0xac8,0xac8,0xac8,
+0xac8,0xab3,0xab3,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,
+0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,
+0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xacb,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,
+0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,
+0xac8,0xac8,0xac8,0xac8,0xaec,0xaec,0xaec,0xaec,0xaec,0xaec,0xaec,0xaec,0xaec,0xaec,0xaec,0xaec,
+0xaec,0xaec,0xaec,0xaec,0xaec,0xaec,0xaec,0xaec,0xaec,0xaec,0xaec,0xaec,0xaec,0xaec,0xaec,0xbe2,
+0xbe2,0xbe2,0xbe2,0xbe2,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,
 0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,
-0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,
-0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,
-0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,
+0xaf8,0xaf8,0xaf8,0xaf8,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,
 0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,
-0x138f,0x138f,0x138f,0x1ac1,0x1ac1,0x1ac1,0x1ac1,0x1ac1,0xb0d,0xb0d,0xb0d,0xb0d,0xb0d,0xb0d,0xb0d,0xb0d,
-0xb0d,0xb0d,0xb0d,0xb0d,0xb0d,0xb0d,0xb0d,0xb0d,0xb0d,0xb0d,0xb0d,0xb0d,0xb0d,0xb0d,0xb0d,0xb0d,
-0xb0d,0xb0d,0xb0d,0xb0d,0xb0d,0xb0d,0xb0d,0xb0d,0xb0d,0xb0d,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,
-0x1ac4,0x1ac4,0x1ac4,0x1ac4,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,
-0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb13,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,
+0xb0a,0xb0a,0xb0a,0xb0a,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,
 0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,
-0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb16,0xb16,0xc57,0xc57,
-0xb16,0xb16,0xb16,0xb16,0xb16,0xb16,0xb16,0xb16,0xb16,0xb16,0xb16,0xb16,0xb16,0xb16,0xb16,0xb16,
-0xc57,0xb16,0xb16,0xb16,0xb16,0xb16,0xb16,0xb16,0xb16,0xb16,0xb16,0xb16,0xb3a,0xb3a,0xb3a,0xb3a,
-0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,
-0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0x14cd,0xb43,0xb43,0xb43,0xb43,
-0xb43,0xb43,0xcdb,0xcdb,0xb40,0xb40,0xb40,0xb40,0xb40,0xb40,0xb40,0xb40,0xb40,0xb40,0xb40,0xb40,
-0xb40,0xb40,0xb40,0xb40,0xb40,0xb40,0xb40,0xb40,0xb40,0xb40,0xb40,0xb40,0xb40,0xb40,0xcd8,0xcd8,
-0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,
-0xb43,0xb43,0xb43,0xb43,0xb43,0xb43,0xb43,0xb43,0xb43,0xb43,0xb43,0xb43,0xb43,0xb43,0xb43,0xb43,
-0xb43,0xb43,0xb43,0xb43,0xb43,0xb43,0xb43,0xb43,0xb43,0xb43,0xb43,0xb43,0xb43,0xb43,0xb43,0xb43,
-0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,
-0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,0xb46,
-0xb55,0xb55,0xb55,0xb55,0xb55,0xb4c,0xb58,0xb5e,0xb5e,0xb5e,0xb52,0xb52,0xb52,0xb5b,0xb4f,0xb4f,
-0xb4f,0xb4f,0xb4f,0xb49,0xb49,0xb49,0xb49,0xb49,0xb49,0xb49,0xb49,0xb5e,0xb5e,0xb5e,0xb5e,0xb5e,
-0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,
-0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,
-0xb52,0xb52,0xb55,0xb55,0xb5e,0xb5e,0xb5e,0xb52,0xb52,0xb5e,0xb5e,0xb5e,0xb5e,0xb5e,0xb5e,0xb5e,
-0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,
-0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb5e,0xb5e,0xb5e,0xb5e,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,
-0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb55,0xb55,0xb55,0xb55,0xb55,0xb55,0xb52,0xb52,0xb52,
+0xb10,0xb10,0xb10,0xb10,0xb1c,0xb1c,0xb1c,0xb1c,0xb1c,0xb1c,0xb1c,0xb1c,0xb1c,0xb1c,0xb1c,0xb1c,
+0xb1c,0xb1c,0xb1c,0xb1c,0xb1c,0xb1c,0xb1c,0xb1c,0xb1c,0xb1c,0xb1c,0xb1c,0x13a1,0x13a1,0x13a1,0x1ad3,
+0x1ad3,0x1ad3,0x1ad3,0x1ad3,0xb1f,0xb1f,0xb1f,0xb1f,0xb1f,0xb1f,0xb1f,0xb1f,0xb1f,0xb1f,0xb1f,0xb1f,
+0xb1f,0xb1f,0xb1f,0xb1f,0xb1f,0xb1f,0xb1f,0xb1f,0xb1f,0xb1f,0xb1f,0xb1f,0xb1f,0xb1f,0xb1f,0xb1f,
+0xb1f,0xb1f,0xb1f,0xb1f,0xb1f,0xb1f,0x1ad6,0x1ad6,0x1ad6,0x1ad6,0x1ad6,0x1ad6,0x1ad6,0x1ad6,0x1ad6,0x1ad6,
+0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,
+0xb22,0xb22,0xb22,0xb22,0xb22,0xb25,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,
+0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,
+0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb22,0xb28,0xb28,0xc69,0xc69,0xb28,0xb28,0xb28,0xb28,
+0xb28,0xb28,0xb28,0xb28,0xb28,0xb28,0xb28,0xb28,0xb28,0xb28,0xb28,0xb28,0xc69,0xb28,0xb28,0xb28,
+0xb28,0xb28,0xb28,0xb28,0xb28,0xb28,0xb28,0xb28,0xb4c,0xb4c,0xb4c,0xb4c,0xb4c,0xb4c,0xb4c,0xb4c,
+0xb4c,0xb4c,0xb4c,0xb4c,0xb4c,0xb4c,0xb4c,0xb4c,0xb4c,0xb4c,0xb4c,0xb4c,0xb4c,0xb4c,0xb4c,0xb4c,
+0xb4c,0xb4c,0xb4c,0xb4c,0xb4c,0xb4c,0xb4c,0x14df,0xb55,0xb55,0xb55,0xb55,0xb55,0xb55,0xced,0xced,
 0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,
-0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0x16d1,0x16d1,0xb6a,0xb61,0xb67,0xb67,
-0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,
-0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb61,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb6a,0xb6a,
-0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,
-0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb61,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,
-0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb61,0xb67,0xb67,
-0xb67,0xb67,0xb67,0xb67,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,
-0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb61,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,
-0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,
+0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xb52,0xcea,0xcea,0xd38,0xd38,0xd38,0xd38,
+0xd38,0xd38,0xd38,0xd38,0xd38,0xd38,0xd38,0xd38,0xd38,0xd38,0xd38,0xd38,0xb55,0xb55,0xb55,0xb55,
+0xb55,0xb55,0xb55,0xb55,0xb55,0xb55,0xb55,0xb55,0xb55,0xb55,0xb55,0xb55,0xb55,0xb55,0xb55,0xb55,
+0xb55,0xb55,0xb55,0xb55,0xb55,0xb55,0xb55,0xb55,0xb55,0xb55,0xb55,0xb55,0xb58,0xb58,0xb58,0xb58,
+0xb58,0xb58,0xb58,0xb58,0xb58,0xb58,0xb58,0xb58,0xb58,0xb58,0xb58,0xb58,0xb58,0xb58,0xb58,0xb58,
+0xb58,0xb58,0xb58,0xb58,0xb58,0xb58,0xb58,0xb58,0xb58,0xb58,0xb58,0xb58,0xb67,0xb67,0xb67,0xb67,
+0xb67,0xb5e,0xb6a,0xb70,0xb70,0xb70,0xb64,0xb64,0xb64,0xb6d,0xb61,0xb61,0xb61,0xb61,0xb61,0xb5b,
+0xb5b,0xb5b,0xb5b,0xb5b,0xb5b,0xb5b,0xb5b,0xb70,0xb70,0xb70,0xb70,0xb70,0xb64,0xb64,0xb64,0xb64,
 0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,
+0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb67,0xb67,
+0xb70,0xb70,0xb70,0xb64,0xb64,0xb70,0xb70,0xb70,0xb70,0xb70,0xb70,0xb70,0xb64,0xb64,0xb64,0xb64,
 0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,
-0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,
-0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,
-0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,
-0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,
-0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb6a,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,
-0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,
-0xb67,0xb67,0xb67,0xb67,0xb6a,0xb6a,0xb6a,0xb6a,0xb6d,0xb6d,0xb6d,0xb6d,0xb6d,0xb6d,0xb6d,0xb6d,
-0xb6d,0xb6d,0xb6d,0xb6d,0xb6d,0xb6d,0xb6d,0xb6d,0xb6d,0xb6d,0xb6d,0xb6d,0xb6d,0xb6d,0xb6d,0xb6d,
-0xb6d,0xb6d,0xb6d,0xb6d,0xb6d,0xb6d,0xb6d,0xb6d,0xb73,0xb73,0xb73,0xb73,0xb73,0xb73,0xb73,0xb73,
-0xb73,0xb73,0xb73,0xb73,0xb73,0xb73,0xb73,0xb73,0xb73,0xb73,0xb73,0xb73,0xb73,0xb73,0xb73,0xb73,
-0xb73,0xb73,0xb73,0xb73,0xb73,0xb73,0xb73,0xb73,0xb73,0xb73,0xb73,0x1aca,0x1aca,0x1aca,0x1aca,0x1aca,
-0x1aca,0x1aca,0x1b96,0x1b96,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,
+0xb64,0xb64,0xb70,0xb70,0xb70,0xb70,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,
+0xb64,0xb64,0xb64,0xb67,0xb67,0xb67,0xb67,0xb67,0xb67,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,
+0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,
+0xb64,0xb64,0xb64,0xb64,0xb64,0xb64,0x16e3,0x16e3,0xb7c,0xb73,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,
+0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,
+0xb79,0xb79,0xb79,0xb73,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,
+0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,
+0xb7c,0xb7c,0xb7c,0xb73,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,
+0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb73,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,
+0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,
+0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb73,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,
+0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb76,0xb76,0xb76,0xb76,
 0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,
-0xb76,0xb76,0xb76,0xb76,0xbd0,0xbd0,0xbd0,0xbd0,0xbd0,0xbd0,0xbd0,0xbd0,0xbd0,0xbd0,0xbd0,0xbd0,
-0xbd0,0xbd0,0xbd0,0xbd0,0xbd0,0xbd0,0xbd0,0xbd0,0xbd0,0xbd0,0xbcd,0xbd0,0xbcd,0xbcd,0xbcd,0xbcd,
-0xbcd,0xbcd,0xbcd,0xbcd,0xbcd,0xbcd,0xbcd,0xbcd,0xbcd,0xbcd,0xbcd,0xccf,0xcd2,0xdbf,0xdbf,0xdbf,
-0xdbf,0xdbf,0xdbf,0xdbf,0xdbf,0xdbf,0xdbf,0xdbf,0xed6,0xed6,0xed6,0xed6,0xbdc,0xbdc,0xbdc,0xbdc,
-0xbdc,0xbdc,0xbdc,0xbdc,0xbdc,0xbdc,0xcd5,0xcd5,0xcd5,0xcd5,0xcd5,0xcd5,0xcd5,0xcd5,0xdc2,0xe76,
-0xdc2,0xdc2,0xdc2,0xdc2,0xdc2,0xdc2,0xdc2,0xdc2,0xdc2,0xfc6,0x1260,0x1260,0xdcb,0xdcb,0xdcb,0xdcb,
-0xdcb,0xdd1,0xdce,0xee8,0xee8,0xee8,0xee8,0x13ce,0xfd8,0x13ce,0x131a,0x131a,0xc0f,0xc0f,0xc0f,0xc0f,
-0xc0f,0xc0f,0xc0f,0xc0f,0xc0f,0xc0f,0xc0f,0xc0f,0xc0f,0xc0f,0xc0f,0xc0f,0xc0f,0xc0f,0xc3c,0xc39,
-0xc3c,0xc39,0xc3c,0xc39,0x10e9,0x10e6,0xfde,0xfdb,0xc12,0xc12,0xc12,0xc12,0xc12,0xc12,0xc12,0xc12,
-0xc12,0xc12,0xc12,0xc12,0xc12,0xc12,0xc12,0xc12,0xc15,0xc15,0xc15,0xc15,0xc15,0xc15,0xc15,0xc15,
-0xc15,0xc15,0xc15,0xc15,0xc15,0xc15,0xc15,0xc15,0xc15,0xc15,0xc15,0xc15,0xc15,0xc15,0xc15,0xc15,
-0xc15,0xc15,0xc15,0xc15,0xc15,0xc15,0xc15,0xc15,0xc18,0xc18,0xc18,0xc1e,0xc1b,0xc42,0xc3f,0xc1e,
-0xc1b,0xc1e,0xc1b,0xc1e,0xc1b,0xc1e,0xc1b,0xc1e,0xc1b,0xc1e,0xc1b,0xc1e,0xc1b,0xc1e,0xc1b,0xc1e,
-0xc1b,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,
-0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,
-0xc18,0xc18,0xc18,0xc18,0xc1e,0xc1b,0xc1e,0xc1b,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,
-0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,
-0xc18,0xc18,0xc18,0xc18,0xc1e,0xc1b,0xc18,0xc18,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,
-0xc21,0xc21,0xc21,0xc21,0xc27,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,
-0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,
-0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc27,0xc27,0xc27,0xc21,0xc21,0xc21,0xc21,0xc21,
-0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,
-0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc24,0xc21,0xc21,0xc21,0xc5a,0xc5a,0xc5a,0xc5a,
-0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,
-0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xc5a,0xcd5,0xd41,0xdc2,0xdc2,
-0xdc2,0xdc2,0xdc2,0xdc2,0xdc2,0xdc2,0xe76,0xe76,0xdc2,0xdc2,0xdc2,0xdc2,0xdc2,0xdc2,0xed9,0xfc6,
-0xfc6,0xfc6,0xfc6,0xfc6,0xfc6,0xfc6,0xfc6,0xfc6,0xfc6,0x1284,0x1284,0x1263,0xcf9,0xcf9,0xcf9,0xcf9,
-0xcf9,0xcf9,0xcf9,0xcf9,0xcf9,0xcf9,0xcf9,0xcf9,0xcf9,0xcf9,0xcf9,0xcf9,0xcf9,0xcf9,0xcf9,0xcf9,
-0xcf9,0xcf9,0xcf9,0xcf9,0xcf9,0xcf9,0xcf9,0xcf9,0xcf9,0xcf9,0xcf9,0xcf9,0xd08,0xd08,0xd08,0xd08,
-0xd08,0xd08,0xcff,0xcff,0xcff,0xcff,0xcff,0xcfc,0xd11,0xd11,0xd11,0xd0b,0xd11,0xd11,0xd11,0xd11,
-0xd11,0xd11,0xd11,0xd11,0xd11,0xd11,0xd11,0xd0b,0xd11,0xd11,0xd11,0xd11,0xd05,0xd05,0xd0e,0xd0e,
-0xd0e,0xd0e,0xd02,0xd02,0xd02,0xd02,0xd02,0xd08,0xdd7,0xdd7,0xdd7,0xdd7,0xdd7,0xdd7,0xdd7,0xdd7,
-0xdd7,0xdd7,0xdd7,0xdd7,0xdd4,0xdd7,0xdd7,0xdd7,0xdd7,0xdd7,0xdd7,0xdd7,0xd11,0xd11,0xd11,0xd11,
-0xd11,0xd11,0xd11,0xd11,0xd11,0xd11,0xd11,0xd11,0xd11,0xd11,0xd0b,0xd11,0xd11,0xd11,0xd11,0xd11,
-0xd11,0xd11,0xd11,0xd11,0xd11,0xd11,0xd11,0xd11,0xd11,0xd05,0xd05,0xd05,0xd08,0xd08,0xd08,0xd08,
-0xd08,0xd08,0xd08,0xd08,0xd08,0xd08,0xd08,0xd08,0xd08,0xd08,0xd08,0xd08,0xd08,0xd08,0xd08,0xd08,
-0xd08,0xd08,0xd08,0xd08,0xd08,0xd08,0xd08,0xd08,0xd08,0xd08,0xd08,0xd08,0xd14,0xd14,0xd14,0xd14,
-0xd14,0xd14,0xd14,0xd14,0xd14,0xd14,0xd14,0xd14,0xd14,0xd14,0xdda,0xdda,0xdda,0xdda,0xdda,0xdda,
-0xeeb,0xeeb,0xeeb,0xeeb,0xeeb,0xeeb,0xeeb,0x10f2,0x10f2,0xfe1,0xfe1,0xfe1,0xd17,0xd17,0xd17,0xd17,
-0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,
-0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd1d,0xd1d,0xd1d,0xd1d,
-0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,
-0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd1d,0xd26,0xd26,0xd26,0xd26,
-0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,
-0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd32,0xd32,0xd32,0xd32,
-0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,
-0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,0xd3e,0xd3e,0xd3e,0xd3e,
-0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,
-0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xd3e,0xde0,0xde0,0xde0,0xde0,
-0xde0,0xde0,0xde0,0xde0,0xde0,0xde0,0xde0,0xde0,0xde0,0xde0,0xde0,0xde0,0xde0,0xde0,0xde0,0xde0,
-0xde0,0xde0,0xde0,0xde0,0xde0,0xde0,0xde0,0xde0,0xde0,0xde0,0xde0,0xde0,0xde6,0xde6,0xde6,0xde6,
-0xde6,0xde6,0xde6,0xde6,0xde6,0xde6,0xde6,0xde6,0xde6,0xde6,0xde6,0xde6,0xde6,0xde6,0xde6,0xde6,
-0xde6,0xde3,0xde3,0xde3,0xde3,0xde3,0xde3,0xde3,0xde3,0xde3,0xde3,0xde3,0xde6,0xde6,0xde6,0xde6,
-0xde6,0xde6,0xde6,0xde6,0xde6,0xde6,0xde6,0xde6,0xde6,0xde6,0xde6,0xde6,0xde6,0xde6,0xde6,0xde6,
-0xde6,0xde6,0xde6,0xde6,0xde6,0xde6,0xde6,0xde6,0xde6,0xde6,0xde6,0xde6,0xea6,0xea6,0xdf8,0xdf8,
-0xeee,0xeee,0xeee,0xeee,0xeee,0xeee,0xeee,0xfed,0xfed,0xfed,0xfed,0xfed,0xfea,0xfea,0xfea,0xfea,
-0xfea,0xfea,0xfea,0xfea,0xfea,0xfea,0xfea,0xfea,0xfea,0xfea,0xfea,0xfea,0xe07,0xe04,0xe07,0xe04,
-0xe07,0xe04,0xe07,0xe04,0xe07,0xe04,0xe07,0xe04,0xe07,0xe04,0xe07,0xe04,0xe07,0xe04,0xe07,0xe04,
-0xe07,0xe04,0xe07,0xe04,0xe07,0xe04,0xe07,0xe04,0xe07,0xe04,0xe07,0xe04,0xe13,0xe13,0xe13,0xe13,
-0xe13,0xe13,0xe13,0xe13,0xe13,0xe13,0xe13,0xe13,0xe13,0xe13,0xe13,0xe13,0xe13,0xe13,0xe13,0xe13,
-0xe13,0xe13,0xe13,0xe13,0xe13,0xe13,0xe13,0xe13,0xe13,0xe13,0xe13,0xe13,0xe19,0xe19,0xe19,0xe19,
-0xe19,0xe19,0xe19,0xe19,0xe19,0xe19,0xe19,0xe19,0xe19,0xe19,0xe19,0x1b0c,0xe16,0xe16,0xe16,0xe16,
-0xe16,0xe16,0xe16,0xe16,0xe16,0xe16,0xe16,0xe16,0xe16,0xe16,0xe16,0xe16,0xe16,0xe16,0xe16,0xe16,
-0xe16,0xe16,0xe16,0xe16,0xe16,0xe16,0xe16,0xe16,0xe16,0xe16,0xe16,0x1b09,0xe19,0xe19,0xe19,0xe19,
-0xe19,0xe19,0xe19,0xe19,0xe19,0xe19,0xe19,0xe19,0xe19,0xe19,0xe19,0xe19,0xe19,0xe19,0xe19,0xe19,
-0xe19,0xe19,0xe19,0xe19,0xe19,0xe19,0xe19,0xe19,0xe19,0xe19,0xe19,0xe19,0xea0,0xea0,0xea0,0xea0,
-0xea0,0xea0,0xea0,0xea0,0xe31,0xe31,0xe31,0xe31,0xe31,0xe31,0xe31,0xe31,0xe31,0xe31,0xe31,0xe31,
-0xe31,0xe31,0xe31,0xef1,0xef1,0xef1,0xef1,0xff0,0xff0,0xff0,0xff0,0xff0,0xe3a,0xe3a,0xe3a,0xe3a,
-0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,
-0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe3a,0xe43,0xe43,0xe43,0xe43,
-0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,
-0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe4c,0xe4c,0xe4c,0xe4c,
+0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb76,0xb7c,0xb7c,0xb7c,0xb7c,
+0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,
+0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,
+0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb7c,0xb7c,0xb7c,0xb7c,
+0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,
+0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb7c,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,
+0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,0xb79,
+0xb7c,0xb7c,0xb7c,0xb7c,0xb7f,0xb7f,0xb7f,0xb7f,0xb7f,0xb7f,0xb7f,0xb7f,0xb7f,0xb7f,0xb7f,0xb7f,
+0xb7f,0xb7f,0xb7f,0xb7f,0xb7f,0xb7f,0xb7f,0xb7f,0xb7f,0xb7f,0xb7f,0xb7f,0xb7f,0xb7f,0xb7f,0xb7f,
+0xb7f,0xb7f,0xb7f,0xb7f,0xb85,0xb85,0xb85,0xb85,0xb85,0xb85,0xb85,0xb85,0xb85,0xb85,0xb85,0xb85,
+0xb85,0xb85,0xb85,0xb85,0xb85,0xb85,0xb85,0xb85,0xb85,0xb85,0xb85,0xb85,0xb85,0xb85,0xb85,0xb85,
+0xb85,0xb85,0xb85,0xb85,0xb85,0xb85,0xb85,0x1adc,0x1adc,0x1adc,0x1adc,0x1adc,0x1adc,0x1adc,0x1ba8,0x1ba8,
+0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,
+0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,0xb88,
+0xbe2,0xbe2,0xbe2,0xbe2,0xbe2,0xbe2,0xbe2,0xbe2,0xbe2,0xbe2,0xbe2,0xbe2,0xbe2,0xbe2,0xbe2,0xbe2,
+0xbe2,0xbe2,0xbe2,0xbe2,0xbe2,0xbe2,0xbdf,0xbe2,0xbdf,0xbdf,0xbdf,0xbdf,0xbdf,0xbdf,0xbdf,0xbdf,
+0xbdf,0xbdf,0xbdf,0xbdf,0xbdf,0xbdf,0xbdf,0xce1,0xce4,0xdd1,0xdd1,0xdd1,0xdd1,0xdd1,0xdd1,0xdd1,
+0xdd1,0xdd1,0xdd1,0xdd1,0xee8,0xee8,0xee8,0xee8,0xbee,0xbee,0xbee,0xbee,0xbee,0xbee,0xbee,0xbee,
+0xbee,0xbee,0xce7,0xce7,0xce7,0xce7,0xce7,0xce7,0xce7,0xce7,0xdd4,0xe88,0xdd4,0xdd4,0xdd4,0xdd4,
+0xdd4,0xdd4,0xdd4,0xdd4,0xdd4,0xfd8,0x1272,0x1272,0xddd,0xddd,0xddd,0xddd,0xddd,0xde3,0xde0,0xefa,
+0xefa,0xefa,0xefa,0x13e0,0xfea,0x13e0,0x132c,0x132c,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,
+0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc21,0xc4e,0xc4b,0xc4e,0xc4b,0xc4e,0xc4b,
+0x10fe,0x10fb,0xff0,0xfed,0xc24,0xc24,0xc24,0xc24,0xc24,0xc24,0xc24,0xc24,0xc24,0xc24,0xc24,0xc24,
+0xc24,0xc24,0xc24,0xc24,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,
+0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,
+0xc27,0xc27,0xc27,0xc27,0xc2a,0xc2a,0xc2a,0xc30,0xc2d,0xc54,0xc51,0xc30,0xc2d,0xc30,0xc2d,0xc30,
+0xc2d,0xc30,0xc2d,0xc30,0xc2d,0xc30,0xc2d,0xc30,0xc2d,0xc30,0xc2d,0xc30,0xc2d,0xc2a,0xc2a,0xc2a,
+0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,
+0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,
+0xc30,0xc2d,0xc30,0xc2d,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,
+0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,
+0xc30,0xc2d,0xc2a,0xc2a,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,
+0xc39,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,
+0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,
+0xc33,0xc33,0xc33,0xc33,0xc39,0xc39,0xc39,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,
+0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,0xc33,
+0xc33,0xc33,0xc33,0xc33,0xc36,0xc33,0xc33,0xc33,0xc6c,0xc6c,0xc6c,0xc6c,0xc6c,0xc6c,0xc6c,0xc6c,
+0xc6c,0xc6c,0xc6c,0xc6c,0xc6c,0xc6c,0xc6c,0xc6c,0xc6c,0xc6c,0xc6c,0xc6c,0xc6c,0xc6c,0xc6c,0xc6c,
+0xc6c,0xc6c,0xc6c,0xc6c,0xc6c,0xc6c,0xc6c,0xc6c,0xce7,0xd53,0xdd4,0xdd4,0xdd4,0xdd4,0xdd4,0xdd4,
+0xdd4,0xdd4,0xe88,0xe88,0xdd4,0xdd4,0xdd4,0xdd4,0xdd4,0xdd4,0xeeb,0xfd8,0xfd8,0xfd8,0xfd8,0xfd8,
+0xfd8,0xfd8,0xfd8,0xfd8,0xfd8,0x1296,0x1296,0x1275,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,
+0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,
+0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd11,0xd11,
+0xd11,0xd11,0xd11,0xd0e,0xd23,0xd23,0xd23,0xd1d,0xd23,0xd23,0xd23,0xd23,0xd23,0xd23,0xd23,0xd23,
+0xd23,0xd23,0xd23,0xd1d,0xd23,0xd23,0xd23,0xd23,0xd17,0xd17,0xd20,0xd20,0xd20,0xd20,0xd14,0xd14,
+0xd14,0xd14,0xd14,0xd1a,0xde9,0xde9,0xde9,0xde9,0xde9,0xde9,0xde9,0xde9,0xde9,0xde9,0xde9,0xde9,
+0xde6,0xde9,0xde9,0xde9,0xde9,0xde9,0xde9,0xde9,0xd23,0xd23,0xd23,0xd23,0xd23,0xd23,0xd23,0xd23,
+0xd23,0xd23,0xd23,0xd23,0xd23,0xd23,0xd1d,0xd23,0xd23,0xd23,0xd23,0xd23,0xd23,0xd23,0xd23,0xd23,
+0xd23,0xd23,0xd23,0xd23,0xd23,0xd17,0xd17,0xd17,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,
+0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,
+0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd1a,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,
+0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xdec,0xdec,0xdec,0xdec,0xdec,0xdec,0xefd,0xefd,0xefd,0xefd,
+0xefd,0xefd,0xefd,0x1107,0x1107,0xff3,0xff3,0xff3,0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,
+0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,
+0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,
+0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,
+0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd38,0xd38,0xd38,0xd38,0xd38,0xd38,0xd38,0xd38,
+0xd38,0xd38,0xd38,0xd38,0xd38,0xd38,0xd38,0xd38,0xd38,0xd38,0xd38,0xd38,0xd38,0xd38,0xd38,0xd38,
+0xd38,0xd38,0xd38,0xd38,0xd38,0xd38,0xd38,0xd38,0xd44,0xd44,0xd44,0xd44,0xd44,0xd44,0xd44,0xd44,
+0xd44,0xd44,0xd44,0xd44,0xd44,0xd44,0xd44,0xd44,0xd44,0xd44,0xd44,0xd44,0xd44,0xd44,0xd44,0xd44,
+0xd44,0xd44,0xd44,0xd44,0xd44,0xd44,0xd44,0xd44,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,
+0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,
+0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xdf2,0xdf2,0xdf2,0xdf2,0xdf2,0xdf2,0xdf2,0xdf2,
+0xdf2,0xdf2,0xdf2,0xdf2,0xdf2,0xdf2,0xdf2,0xdf2,0xdf2,0xdf2,0xdf2,0xdf2,0xdf2,0xdf2,0xdf2,0xdf2,
+0xdf2,0xdf2,0xdf2,0xdf2,0xdf2,0xdf2,0xdf2,0xdf2,0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,
+0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,0xdf5,0xdf5,0xdf5,
+0xdf5,0xdf5,0xdf5,0xdf5,0xdf5,0xdf5,0xdf5,0xdf5,0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,
+0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,
+0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,0xdf8,0xeb8,0xeb8,0xe0a,0xe0a,0xf00,0xf00,0xf00,0xf00,
+0xf00,0xf00,0xf00,0xfff,0xfff,0x1002,0xfff,0xfff,0xffc,0xffc,0xffc,0xffc,0xffc,0xffc,0xffc,0xffc,
+0xffc,0xffc,0xffc,0xffc,0xffc,0xffc,0xffc,0xffc,0xe19,0xe16,0xe19,0xe16,0xe19,0xe16,0xe19,0xe16,
+0xe19,0xe16,0xe19,0xe16,0xe19,0xe16,0xe19,0xe16,0xe19,0xe16,0xe19,0xe16,0xe19,0xe16,0xe19,0xe16,
+0xe19,0xe16,0xe19,0xe16,0xe19,0xe16,0xe19,0xe16,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,
+0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,
+0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,
+0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0x1b1e,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
+0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
+0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0x1b1b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,
+0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,
+0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xe2b,0xeb2,0xeb2,0xeb2,0xeb2,0xeb2,0xeb2,0xeb2,0xeb2,
+0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xf03,
+0xf03,0xf03,0xf03,0x1005,0x1005,0x1005,0x1005,0x1005,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,
 0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,
-0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe46,0xe49,0xe49,0xe49,0xe49,
-0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,
-0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe55,0xe55,0xe55,0xe55,
-0xe55,0xe55,0xe55,0xe55,0xe55,0xe55,0xe55,0xe55,0xe55,0xe55,0xe52,0xe52,0xe52,0xe52,0xe52,0xe52,
-0xe52,0xe52,0xe4f,0xe58,0xffc,0xff6,0x1005,0xff3,0xe55,0xe55,0xff3,0xff3,0xe67,0xe67,0xe5b,0xe67,
-0xe67,0xe67,0xe5e,0xe67,0xe67,0xe67,0xe67,0xe5b,0xe67,0xe67,0xe67,0xe67,0xe67,0xe67,0xe67,0xe67,
-0xe67,0xe67,0xe67,0xe67,0xe67,0xe67,0xe67,0xe67,0xe67,0xe67,0xe67,0xe67,0xe6a,0xe6a,0xe6a,0xe6a,
-0xe6a,0xe6a,0xe6a,0xe6a,0xe6a,0xe6a,0xe6a,0xe6a,0xe6a,0xe6a,0xe6a,0xe6a,0xe6a,0xe6a,0xe6a,0xe6a,
-0xe6a,0xe6a,0xe6a,0xe6a,0xe6a,0xe6a,0xe6a,0xe6a,0xe6a,0xe6a,0xe6a,0xe6a,0xe82,0xe82,0xe82,0xe82,
-0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,
-0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xea3,0xea3,0xea3,0xea3,
-0xea3,0xea3,0xea3,0xea3,0xea3,0xea3,0xea3,0xea3,0xea3,0xea3,0xea3,0xea3,0x10fb,0x10fb,0x10fb,0x10fb,
-0x10fb,0x10fb,0x10fb,0x10fb,0x10fb,0x10fb,0x10fb,0x10fb,0x10fb,0x10fb,0x10fb,0x10fb,0xed6,0xed6,0xed6,0xed3,
-0xed3,0xed3,0xed3,0xed3,0x1134,0x1380,0x1380,0x1380,0x1380,0x1305,0x1305,0x1305,0x1383,0x1308,0x1308,0x1383,
-0x14c4,0x14c4,0x14c4,0x14c4,0x14c4,0x14c4,0x14c4,0x1785,0x1785,0x1785,0x1785,0x184b,0xeeb,0xeeb,0xeeb,0xeeb,
-0xfe1,0xfe1,0xfe1,0xfe1,0xfe1,0xfe1,0xfe1,0xfe1,0xfe1,0xfe1,0xfe1,0xfe1,0xfe4,0xfe4,0xfe4,0xfe4,
-0xfe4,0xfe4,0xfe4,0xfe4,0xfe4,0xfe4,0xfe4,0xfe4,0xfe4,0xfe4,0xfe4,0xfe4,0xfea,0xfea,0xfea,0xfea,
-0xfea,0xfea,0xfea,0x14df,0x14df,0x14df,0x14df,0x14df,0x14df,0x14df,0x14df,0x14df,0x14df,0x14df,0x14df,0x14df,
-0x14df,0x14e2,0x1854,0x1854,0x18d5,0x1854,0x1bb4,0x178b,0x131d,0x113d,0xeee,0xeee,0xf0c,0xf0c,0xf0c,0xf0c,
-0xf1e,0xf27,0xf2a,0xf27,0xf2a,0xf27,0xf2a,0xf27,0xf2a,0xf27,0xf2a,0xf27,0xf27,0xf27,0xf2a,0xf27,
-0xf27,0xf27,0xf27,0xf27,0xf27,0xf27,0xf27,0xf27,0xf27,0xf27,0xf27,0xf27,0xf27,0xf27,0xf27,0xf27,
-0xf27,0xf27,0xf27,0xf27,0xf0f,0xf0c,0xf0c,0xf0c,0xf0c,0xf0c,0xf0c,0xf21,0xf0c,0xf21,0xf1e,0xf1e,
-0xf33,0xf30,0xf33,0xf33,0xf33,0xf30,0xf30,0xf33,0xf30,0xf33,0xf30,0xf33,0xf30,0x1017,0x1017,0x1017,
-0x1152,0x100e,0x1017,0x100e,0xf30,0xf33,0xf30,0xf30,0x100e,0x100e,0x100e,0x100e,0x1011,0x1014,0x1152,0x1152,
-0xf36,0xf36,0x1029,0x1020,0x1029,0x1020,0x1029,0x1020,0x1029,0x1020,0x1029,0x1020,0x1029,0x1020,0x1029,0x1020,
-0x1020,0x1020,0x1029,0x1020,0x1029,0x1020,0x1029,0x1020,0x1029,0x1020,0x1029,0x1020,0x1029,0x1020,0x1029,0x1020,
-0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,
-0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,0xf3c,
-0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,
-0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,
-0xf4b,0xf4b,0xf4b,0x1500,0x1500,0x1500,0x1500,0x1500,0x1500,0x1500,0x1500,0x1500,0x1500,0x1500,0x1500,0x1500,
-0x1500,0x1500,0x1500,0x1500,0xf51,0xf51,0xf51,0xf51,0xf51,0xf51,0xf51,0xf51,0xf51,0xf51,0xf51,0xf51,
-0xf51,0xf51,0xf51,0xf51,0xf51,0xf51,0xf51,0xf51,0xf51,0xf51,0xf51,0xf51,0xf51,0xf51,0xf51,0xf51,
-0xf51,0xf51,0xf51,0xf51,0xf99,0xfb1,0xfa8,0xfae,0xfae,0xfb1,0xfb1,0xfa8,0xfa8,0xfae,0xfae,0xfae,
-0xfae,0xfae,0xfb1,0xfb1,0xfb1,0xf99,0xf99,0xf99,0xf99,0xfb1,0xfb1,0xfb1,0xfb1,0xfb1,0xfb1,0xfb1,
-0xfb1,0xfb1,0xfb1,0xfb1,0xfb1,0xfb1,0xf99,0xfa8,0xfab,0xf99,0xf99,0xfae,0xfae,0xfae,0xfae,0xfae,
-0xfae,0xf9c,0xfb1,0xfae,0xfa5,0xfa5,0xfa5,0xfa5,0xfa5,0xfa5,0xfa5,0xfa5,0xfa5,0xfa5,0x111c,0x111c,
-0x1119,0x1116,0xfa2,0xfa2,0xfc9,0xfc9,0xfc9,0xfc9,0x1284,0x1284,0x1263,0x1263,0x1263,0x1260,0x1260,0x1260,
-0x1260,0x1263,0x1386,0x1263,0x1263,0x1263,0x1260,0x1263,0x1284,0x1260,0x1260,0x1260,0x1263,0x1263,0x1260,0x1260,
-0x1263,0x1260,0x1260,0x1263,0xfe4,0xfe4,0xfe4,0xfe4,0xfe4,0xfe1,0xfe1,0xfe4,0xfe4,0xfe4,0xfe4,0xfe4,
-0xfe4,0x14d9,0x14d9,0x14d9,0x10f2,0xfe1,0xfe1,0xfe1,0xfe1,0x1290,0x126c,0x126c,0x126c,0x126c,0x14d9,0x14d9,
-0x14d9,0x14d9,0x14d9,0x14d9,0x1002,0x1002,0xfff,0xff9,0xfff,0xff9,0xfff,0xff9,0xfff,0xff9,0xff6,0xff6,
-0xff6,0xff6,0x100b,0x1008,0xff6,0x114f,0x13da,0x13dd,0x13dd,0x13da,0x13da,0x13da,0x13da,0x13da,0x13e0,0x13e0,
-0x14f4,0x14e8,0x14e8,0x14e5,0x1029,0x1020,0x1029,0x1020,0x1029,0x1020,0x1029,0x1020,0x101d,0x101a,0x101a,0x1029,
-0x1020,0x1329,0x1326,0x16da,0x1329,0x1326,0x13e9,0x13e6,0x14f7,0x14f7,0x14fd,0x14f7,0x14fd,0x14f7,0x14fd,0x14f7,
-0x14fd,0x14f7,0x14fd,0x14f7,0x1029,0x1020,0x1029,0x1020,0x1029,0x1020,0x1029,0x1020,0x1029,0x1020,0x1029,0x1020,
-0x1029,0x1020,0x1029,0x1020,0x1029,0x1020,0x1029,0x1020,0x1029,0x1020,0x1029,0x1020,0x1029,0x1020,0x1029,0x1020,
-0x1029,0x1020,0x1029,0x1020,0x1023,0x1020,0x1020,0x1020,0x1020,0x1020,0x1020,0x1020,0x1020,0x1029,0x1020,0x1029,
-0x1020,0x1029,0x1029,0x1020,0x102c,0x102c,0x1032,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,
-0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,
-0x1038,0x1038,0x1038,0x1038,0x1038,0x1032,0x102c,0x102c,0x102c,0x102c,0x1032,0x1032,0x102c,0x102c,0x1035,0x13f2,
-0x13ef,0x13ef,0x1038,0x1038,0x102f,0x102f,0x102f,0x102f,0x102f,0x102f,0x102f,0x102f,0x102f,0x102f,0x13f5,0x13f5,
-0x13f5,0x13f5,0x13f5,0x13f5,0x104d,0x104d,0x104d,0x104d,0x104d,0x104d,0x104d,0x104d,0x104d,0x104d,0x104d,0x104d,
+0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe4c,0xe55,0xe55,0xe55,0xe55,0xe55,0xe55,0xe55,0xe55,
+0xe55,0xe55,0xe55,0xe55,0xe55,0xe55,0xe55,0xe55,0xe55,0xe55,0xe55,0xe55,0xe55,0xe55,0xe55,0xe55,
+0xe55,0xe55,0xe55,0xe55,0xe55,0xe55,0xe55,0xe55,0xe5e,0xe5e,0xe5e,0xe5e,0xe5e,0xe5e,0xe5e,0xe5e,
+0xe5e,0xe5e,0xe5e,0xe5e,0xe5e,0xe5e,0xe5e,0xe5e,0xe5e,0xe5e,0xe5e,0xe5e,0xe5e,0xe5e,0xe5e,0xe5e,
+0xe5e,0xe5e,0xe5e,0xe5e,0xe5e,0xe5e,0xe5e,0xe58,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,
+0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,
+0xe5b,0xe5b,0xe5b,0xe5e,0xe5e,0xe5e,0xe5e,0xe5e,0xe67,0xe67,0xe67,0xe67,0xe67,0xe67,0xe67,0xe67,
+0xe67,0xe67,0xe67,0xe67,0xe67,0xe67,0xe64,0xe64,0xe64,0xe64,0xe64,0xe64,0xe64,0xe64,0xe61,0xe6a,
+0x1011,0x100b,0x101a,0x1008,0xe67,0xe67,0x1008,0x1008,0xe79,0xe79,0xe6d,0xe79,0xe79,0xe79,0xe70,0xe79,
+0xe79,0xe79,0xe79,0xe6d,0xe79,0xe79,0xe79,0xe79,0xe79,0xe79,0xe79,0xe79,0xe79,0xe79,0xe79,0xe79,
+0xe79,0xe79,0xe79,0xe79,0xe79,0xe79,0xe79,0xe79,0xe7c,0xe7c,0xe7c,0xe7c,0xe7c,0xe7c,0xe7c,0xe7c,
+0xe7c,0xe7c,0xe7c,0xe7c,0xe7c,0xe7c,0xe7c,0xe7c,0xe7c,0xe7c,0xe7c,0xe7c,0xe7c,0xe7c,0xe7c,0xe7c,
+0xe7c,0xe7c,0xe7c,0xe7c,0xe7c,0xe7c,0xe7c,0xe7c,0xe94,0xe94,0xe94,0xe94,0xe94,0xe94,0xe94,0xe94,
+0xe94,0xe94,0xe94,0xe94,0xe94,0xe94,0xe94,0xe94,0xe94,0xe94,0xe94,0xe94,0xe94,0xe94,0xe94,0xe94,
+0xe94,0xe94,0xe94,0xe94,0xe94,0xe94,0xe94,0xe94,0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,
+0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,0x1110,0x1110,0x1110,0x1110,0x1110,0x1110,0x1110,0x1110,
+0x1110,0x1110,0x1110,0x1110,0x1110,0x1110,0x1110,0x1110,0xee8,0xee8,0xee8,0xee5,0xee5,0xee5,0xee5,0xee5,
+0x1149,0x1392,0x1392,0x1392,0x1392,0x1317,0x1317,0x1317,0x1395,0x131a,0x131a,0x1395,0x14d6,0x14d6,0x14d6,0x14d6,
+0x14d6,0x14d6,0x14d6,0x1797,0x1797,0x1797,0x1797,0x185d,0xefd,0xefd,0xefd,0xefd,0xff3,0xff3,0xff3,0xff3,
+0xff3,0xff3,0xff3,0xff3,0xff3,0xff3,0xff3,0xff3,0xff6,0xff6,0xff6,0xff6,0xff6,0xff6,0xff6,0xff6,
+0xff6,0xff6,0xff6,0xff6,0xff6,0xff6,0xff6,0xff6,0xffc,0xffc,0xffc,0xffc,0xffc,0xffc,0xffc,0x14f1,
+0x14f1,0x14f1,0x14f1,0x14f1,0x14f1,0x14f1,0x14f1,0x14f1,0x14f1,0x14f1,0x14f1,0x14f1,0x14f1,0x14f4,0x1866,0x1866,
+0x18e7,0x1866,0x1bc6,0x179d,0x132f,0x1152,0xf00,0xf00,0xf1e,0xf1e,0xf1e,0xf1e,0xf30,0xf39,0xf3c,0xf39,
+0xf3c,0xf39,0xf3c,0xf39,0xf3c,0xf39,0xf3c,0xf39,0xf39,0xf39,0xf3c,0xf39,0xf39,0xf39,0xf39,0xf39,
+0xf39,0xf39,0xf39,0xf39,0xf39,0xf39,0xf39,0xf39,0xf39,0xf39,0xf39,0xf39,0xf39,0xf39,0xf39,0xf39,
+0xf21,0xf1e,0xf1e,0xf1e,0xf1e,0xf1e,0xf1e,0xf33,0xf1e,0xf33,0xf30,0xf30,0xf45,0xf42,0xf45,0xf45,
+0xf45,0xf42,0xf42,0xf45,0xf42,0xf45,0xf42,0xf45,0xf42,0x102c,0x102c,0x102c,0x1167,0x1023,0x102c,0x1023,
+0xf42,0xf45,0xf42,0xf42,0x1023,0x1023,0x1023,0x1023,0x1026,0x1029,0x1167,0x1167,0xf48,0xf48,0x103e,0x1035,
+0x103e,0x1035,0x103e,0x1035,0x103e,0x1035,0x103e,0x1035,0x103e,0x1035,0x103e,0x1035,0x1035,0x1035,0x103e,0x1035,
+0x103e,0x1035,0x103e,0x1035,0x103e,0x1035,0x103e,0x1035,0x103e,0x1035,0x103e,0x1035,0xf4e,0xf4e,0xf4e,0xf4e,
+0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,
+0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,0xf4e,0xf5d,0xf5d,0xf5d,0xf5d,
+0xf5d,0xf5d,0xf5d,0xf5d,0xf5d,0xf5d,0xf5d,0xf5d,0xf5d,0xf5d,0xf5d,0xf5d,0xf5d,0xf5d,0xf5d,0xf5d,
+0xf5d,0xf5d,0xf5d,0xf5d,0xf5d,0xf5d,0xf5d,0xf5d,0xf5d,0xf5d,0xf5d,0xf5d,0xf5d,0xf5d,0xf5d,0x1512,
+0x1512,0x1512,0x1512,0x1512,0x1512,0x1512,0x1512,0x1512,0x1512,0x1512,0x1512,0x1512,0x1512,0x1512,0x1512,0x1512,
+0xf63,0xf63,0xf63,0xf63,0xf63,0xf63,0xf63,0xf63,0xf63,0xf63,0xf63,0xf63,0xf63,0xf63,0xf63,0xf63,
+0xf63,0xf63,0xf63,0xf63,0xf63,0xf63,0xf63,0xf63,0xf63,0xf63,0xf63,0xf63,0xf63,0xf63,0xf63,0xf63,
+0xfab,0xfc3,0xfba,0xfc0,0xfc0,0xfc3,0xfc3,0xfba,0xfba,0xfc0,0xfc0,0xfc0,0xfc0,0xfc0,0xfc3,0xfc3,
+0xfc3,0xfab,0xfab,0xfab,0xfab,0xfc3,0xfc3,0xfc3,0xfc3,0xfc3,0xfc3,0xfc3,0xfc3,0xfc3,0xfc3,0xfc3,
+0xfc3,0xfc3,0xfab,0xfba,0xfbd,0xfab,0xfab,0xfc0,0xfc0,0xfc0,0xfc0,0xfc0,0xfc0,0xfae,0xfc3,0xfc0,
+0xfb7,0xfb7,0xfb7,0xfb7,0xfb7,0xfb7,0xfb7,0xfb7,0xfb7,0xfb7,0x1131,0x1131,0x112e,0x112b,0xfb4,0xfb4,
+0xfdb,0xfdb,0xfdb,0xfdb,0x1296,0x1296,0x1275,0x1275,0x1275,0x1272,0x1272,0x1272,0x1272,0x1275,0x1398,0x1275,
+0x1275,0x1275,0x1272,0x1275,0x1296,0x1272,0x1272,0x1272,0x1275,0x1275,0x1272,0x1272,0x1275,0x1272,0x1272,0x1275,
+0xff6,0xff6,0xff6,0xff6,0xff6,0xff3,0xff3,0xff6,0xff6,0xff6,0xff6,0xff6,0xff6,0x14eb,0x14eb,0x14eb,
+0x1107,0xff3,0xff3,0xff3,0xff3,0x12a2,0x127e,0x127e,0x127e,0x127e,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,
+0x1017,0x1017,0x1014,0x100e,0x1014,0x100e,0x1014,0x100e,0x1014,0x100e,0x100b,0x100b,0x100b,0x100b,0x1020,0x101d,
+0x100b,0x1164,0x13ec,0x13ef,0x13ef,0x13ec,0x13ec,0x13ec,0x13ec,0x13ec,0x13f2,0x13f2,0x1506,0x14fa,0x14fa,0x14f7,
+0x103e,0x1035,0x103e,0x1035,0x103e,0x1035,0x103e,0x1035,0x1032,0x102f,0x102f,0x103e,0x1035,0x133b,0x1338,0x16ec,
+0x133b,0x1338,0x13fb,0x13f8,0x1509,0x1509,0x150f,0x1509,0x150f,0x1509,0x150f,0x1509,0x150f,0x1509,0x150f,0x1509,
+0x103e,0x1035,0x103e,0x1035,0x103e,0x1035,0x103e,0x1035,0x103e,0x1035,0x103e,0x1035,0x103e,0x1035,0x103e,0x1035,
+0x103e,0x1035,0x103e,0x1035,0x103e,0x1035,0x103e,0x1035,0x103e,0x1035,0x103e,0x1035,0x103e,0x1035,0x103e,0x1035,
+0x1038,0x1035,0x1035,0x1035,0x1035,0x1035,0x1035,0x1035,0x1035,0x103e,0x1035,0x103e,0x1035,0x103e,0x103e,0x1035,
+0x1041,0x1041,0x1047,0x104d,0x104d,0x104d,0x104d,0x104d,0x104d,0x104d,0x104d,0x104d,0x104d,0x104d,0x104d,0x104d,
 0x104d,0x104d,0x104d,0x104d,0x104d,0x104d,0x104d,0x104d,0x104d,0x104d,0x104d,0x104d,0x104d,0x104d,0x104d,0x104d,
-0x104d,0x104d,0x104d,0x104d,0x1056,0x1056,0x1056,0x1056,0x1056,0x1056,0x1056,0x1056,0x1056,0x1056,0x1056,0x1056,
-0x1056,0x1056,0x1056,0x1056,0x1056,0x1056,0x1056,0x1056,0x1056,0x1056,0x1056,0x1056,0x1059,0x1059,0x1059,0x105c,
-0x1059,0x1059,0x105f,0x105f,0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,
+0x104d,0x1047,0x1041,0x1041,0x1041,0x1041,0x1047,0x1047,0x1041,0x1041,0x104a,0x1404,0x1401,0x1401,0x104d,0x104d,
+0x1044,0x1044,0x1044,0x1044,0x1044,0x1044,0x1044,0x1044,0x1044,0x1044,0x1407,0x1407,0x1407,0x1407,0x1407,0x1407,
+0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,
 0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,
-0x1062,0x1062,0x1062,0x1062,0x106b,0x106b,0x106b,0x106b,0x106b,0x106b,0x106b,0x106b,0x106b,0x106b,0x106b,0x106b,
-0x106e,0x1065,0x1074,0x1071,0x106b,0x106b,0x106b,0x106b,0x106b,0x106b,0x106b,0x106b,0x106b,0x106b,0x106b,0x106b,
 0x106b,0x106b,0x106b,0x106b,0x106b,0x106b,0x106b,0x106b,0x106b,0x106b,0x106b,0x106b,0x106b,0x106b,0x106b,0x106b,
-0x106b,0x106b,0x106b,0x106b,0x132f,0x132c,0x1086,0x1080,0x1086,0x1080,0x1086,0x1080,0x1086,0x1080,0x1086,0x1080,
-0x1086,0x1080,0x1083,0x1104,0x1077,0x1077,0x1077,0x107d,0x13f8,0x13f8,0x13f8,0x13f8,0x13f8,0x13f8,0x13f8,0x13f8,
-0x107a,0x107a,0x107d,0x1089,0x1086,0x1080,0x1086,0x1080,0x1086,0x1080,0x1086,0x1080,0x1086,0x1080,0x1086,0x1080,
-0x1086,0x1080,0x1086,0x1080,0x1086,0x1080,0x1086,0x1080,0x1086,0x1080,0x1086,0x1080,0x1086,0x1080,0x1086,0x1080,
-0x1086,0x1080,0x1086,0x1080,0x150c,0x1509,0x150c,0x1509,0x150f,0x150f,0x16e3,0x13f8,0x1092,0x1092,0x1095,0x1095,
-0x1095,0x1095,0x1095,0x1095,0x1095,0x1095,0x1095,0x1095,0x1095,0x1095,0x1095,0x1095,0x1095,0x1095,0x1095,0x1095,
-0x1095,0x1095,0x1095,0x1095,0x1095,0x1095,0x1095,0x1095,0x1095,0x1095,0x1095,0x1095,0x1092,0x1092,0x1092,0x1092,
-0x1092,0x1092,0x1092,0x1092,0x1092,0x1092,0x1092,0x1092,0x10a4,0x10a4,0x10a4,0x10a4,0x10a4,0x10a4,0x109b,0x109b,
-0x109b,0x109b,0x109b,0x109e,0x109e,0x109e,0x10f8,0x10a7,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,
-0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10a1,0x10a1,0x10a1,0x10a1,0x10a1,0x10a1,0x10a1,0x10a1,
-0x10a1,0x10a1,0x10a4,0x10a4,0x10a4,0x10a4,0x10a4,0x10a4,0x10a4,0x10a4,0x10a4,0x10a4,0x10a4,0x10a4,0x10a4,0x10a4,
-0x10a4,0x10a4,0x10a4,0x10a4,0x10a4,0x10a4,0x10a4,0x10a4,0x10c5,0x10c5,0x10c5,0x10c5,0x10c5,0x10c5,0x10c5,0x10c5,
-0x10c5,0x10c5,0x10c5,0x10c5,0x10c5,0x10c5,0x10c5,0x10c5,0x10c5,0x10c5,0x10c5,0x10c5,0x10c5,0x10c5,0x10c5,0x10c5,
-0x10c5,0x10c5,0x10c5,0x10c5,0x10c5,0x10c5,0x10c5,0x10c5,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,
-0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,
-0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10e0,0x10e0,0x10e0,0x10e0,0x10f5,0x10e0,0x10e0,0x10e0,
-0x10e0,0x10e0,0x10e0,0x10e0,0x10e0,0x10e0,0x10e0,0x10e0,0x10e0,0x10e0,0x10e0,0x10e0,0x10e0,0x10e0,0x10e0,0x10e0,
-0x10e0,0x10e0,0x10e0,0x10e0,0x10e0,0x10e0,0x10e0,0x10e0,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,
-0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,
-0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10e3,0x10ef,0x10ef,0x10ef,0x10ef,0x128a,0x128a,0x128a,0x128a,
-0x128a,0x128a,0x128a,0x128a,0x1482,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x18b4,0x18b4,
-0x18b4,0x18b4,0x18b4,0x18b4,0x18b4,0x18b4,0x18b4,0x18b4,0x1164,0x1164,0x1164,0x1164,0x1164,0x1164,0x1164,0x1164,
-0x1164,0x1164,0x1164,0x1164,0x1164,0x1164,0x1164,0x1164,0x1164,0x1164,0x1164,0x1164,0x1164,0x1164,0x115b,0x115b,
-0x115e,0x115e,0x1164,0x115b,0x115b,0x115b,0x115b,0x115b,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,
-0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,
-0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x1185,0x1185,0x1185,0x1185,0x1185,0x1185,0x1185,0x1185,
-0x1185,0x1185,0x1185,0x1185,0x1185,0x1185,0x1185,0x1185,0x1185,0x1185,0x1185,0x1185,0x1185,0x1185,0x1185,0x1185,
-0x1185,0x1185,0x1185,0x1185,0x1185,0x1185,0x1185,0x1185,0x1191,0x1191,0x1191,0x1191,0x1191,0x1191,0x1191,0x1191,
-0x1191,0x1191,0x1191,0x1191,0x1191,0x1191,0x1191,0x1191,0x1191,0x1191,0x1191,0x1191,0x1191,0x1191,0x1191,0x1191,
-0x1191,0x1191,0x1191,0x1191,0x1191,0x1191,0x118e,0x1194,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,
-0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,
-0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,
-0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x12d5,0x11ac,0x12d8,0x11ac,0x11ac,0x11ac,0x11ac,
-0x11a9,0x11a9,0x11a9,0x11ac,0x16e6,0x16e9,0x1911,0x190e,0x11af,0x11af,0x11af,0x11be,0x11c4,0x11c4,0x11c4,0x11c4,
-0x11c4,0x11c4,0x11c4,0x11c4,0x11c4,0x11c4,0x11c4,0x11c4,0x11c4,0x11c4,0x11c4,0x11c4,0x11c4,0x11c4,0x11c4,0x11c4,
-0x11c4,0x11c4,0x11c4,0x11c4,0x11c4,0x11c4,0x11c4,0x11c4,0x11c4,0x11c4,0x11c4,0x11b2,0x11be,0x11be,0x11af,0x11af,
-0x11af,0x11af,0x11be,0x11be,0x11af,0x11af,0x11be,0x11be,0x11d0,0x11d0,0x11d0,0x11d0,0x11d0,0x11d0,0x11d0,0x11d0,
-0x11d0,0x11d0,0x11d0,0x11d0,0x11d0,0x11d0,0x11d0,0x11d0,0x11d3,0x11d0,0x11d0,0x11d0,0x11d0,0x11d0,0x11d0,0x11ca,
-0x11ca,0x11ca,0x11d0,0x11cd,0x1515,0x1518,0x151b,0x151b,0x11e2,0x11e2,0x11e2,0x11e2,0x11e2,0x11e2,0x11e2,0x11e2,
-0x11e2,0x11e2,0x11e2,0x11e2,0x11e2,0x11e2,0x11e2,0x11e2,0x11d6,0x11e2,0x11d6,0x11d6,0x11d6,0x11eb,0x11eb,0x11d6,
-0x11d6,0x11eb,0x11e2,0x11eb,0x11eb,0x11e2,0x11d6,0x11d9,0x11e2,0x11e2,0x11e2,0x11e2,0x11e2,0x11e2,0x11e2,0x11e2,
-0x11e2,0x11e2,0x11e2,0x11e2,0x11e2,0x11e2,0x11e2,0x11e2,0x11e2,0x11e2,0x11e2,0x11e2,0x11e2,0x11e2,0x11e2,0x11e2,
-0x11e2,0x11e2,0x11e2,0x11e2,0x11e2,0x11e2,0x11e2,0x11e2,0x11fd,0x11fd,0x11fd,0x11fd,0x11fd,0x11fd,0x11fd,0x11fd,
-0x11fd,0x11fd,0x11fd,0x11fd,0x11fd,0x11fd,0x11fd,0x11fd,0x11fd,0x11fd,0x11fd,0x11fd,0x11fd,0x11fd,0x11fd,0x11fd,
-0x11fd,0x11fd,0x11fd,0x11fd,0x11fd,0x11fd,0x11fd,0x11fd,0x1215,0x1215,0x1215,0x1215,0x1215,0x1215,0x1215,0x1215,
-0x1215,0x1215,0x1215,0x1215,0x1215,0x1215,0x1215,0x1215,0x1215,0x1215,0x1215,0x1215,0x1215,0x1215,0x1215,0x1215,
-0x1215,0x1215,0x1215,0x1215,0x1215,0x1212,0x1212,0x1212,0x121e,0x121e,0x121e,0x121e,0x121e,0x121e,0x121e,0x121e,
-0x121e,0x121e,0x121e,0x121e,0x121e,0x121e,0x121e,0x121e,0x121e,0x121e,0x121e,0x121e,0x121e,0x121e,0x121e,0x121e,
-0x121e,0x121e,0x121e,0x121e,0x121e,0x121e,0x121e,0x121e,0x122d,0x122d,0x122d,0x122d,0x122d,0x122d,0x122d,0x122d,
-0x122d,0x122d,0x122d,0x122d,0x122d,0x122d,0x122d,0x122d,0x122d,0x122d,0x122d,0x122d,0x122d,0x122d,0x122d,0x122d,
-0x122d,0x122d,0x122d,0x122d,0x122d,0x122d,0x122d,0x122d,0x1233,0x1233,0x1242,0x1245,0x1245,0x1245,0x1245,0x1245,
-0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,
-0x1245,0x1245,0x1248,0x1245,0x1248,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,
-0x1245,0x1245,0x1245,0x1248,0x1245,0x1245,0x1245,0x1245,0x1242,0x1242,0x1242,0x1236,0x1236,0x1236,0x1236,0x1242,
-0x1242,0x123c,0x1239,0x123f,0x123f,0x124e,0x124b,0x124b,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,
-0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,
-0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0x1257,0x1257,0x1257,0x1254,0x1254,0x1254,0x1251,0x1251,
-0x1251,0x1251,0x1254,0x1251,0x1251,0x1251,0x1257,0x1254,0x1257,0x1254,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,
-0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,
-0x1251,0x1251,0x1251,0x1251,0x1251,0x1257,0x1254,0x1254,0x1251,0x1251,0x1251,0x1251,0x1272,0x1272,0x1272,0x1272,
-0x1272,0x1272,0x1272,0x1272,0x1272,0x1272,0x1272,0x1275,0x1275,0x1275,0x125a,0x1917,0x137d,0x127e,0x137d,0x137d,
-0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x127e,0x137d,0x127e,0x1263,0x1263,0x130b,0x1260,
-0x130b,0x130b,0x130b,0x130b,0x1260,0x1260,0x1284,0x1260,0x1260,0x1260,0x1260,0x1260,0x1260,0x1263,0x1284,0x1284,
-0x1263,0x1284,0x1260,0x1263,0x1263,0x1266,0x1284,0x1260,0x1260,0x1284,0x1263,0x1263,0x137a,0x137a,0x137a,0x137a,
-0x137a,0x137a,0x137a,0x137a,0x137a,0x137a,0x126f,0x126f,0x126f,0x126f,0x1392,0x1374,0x1278,0x1392,0x1392,0x1392,
-0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1815,0x1815,0x1815,0x1815,0x1815,0x1272,0x1272,0x1272,0x1272,
-0x1272,0x1272,0x1272,0x1272,0x1272,0x1272,0x1272,0x151e,0x151e,0x1a64,0x1a64,0x1a64,0x1272,0x1272,0x1272,0x1272,
-0x1272,0x1272,0x1272,0x1272,0x1272,0x1272,0x1272,0x1272,0x1272,0x1272,0x1272,0x1272,0x137d,0x137d,0x127e,0x137d,
-0x137d,0x137d,0x127e,0x137d,0x137d,0x137d,0x1278,0x1278,0x1278,0x1278,0x1278,0x1377,0x137a,0x137a,0x137a,0x137a,
-0x137a,0x137a,0x137a,0x127b,0x137a,0x137a,0x137a,0x137a,0x137a,0x137a,0x137a,0x127b,0x137a,0x137a,0x137a,0x137a,
-0x137a,0x137a,0x137a,0x137a,0x137a,0x137a,0x13fb,0x13fb,0x19c2,0x1a64,0x1a64,0x1a64,0x137a,0x137a,0x137a,0x137a,
-0x137a,0x137a,0x137a,0x137a,0x137a,0x127b,0x137a,0x127b,0x127b,0x137a,0x137a,0x127b,0x129f,0x129f,0x129f,0x129f,
-0x129f,0x129f,0x129f,0x129f,0x129f,0x129f,0x129f,0x129f,0x129f,0x129f,0x129f,0x129f,0x129f,0x129f,0x129f,0x129f,
-0x129f,0x129f,0x129f,0x129f,0x129f,0x129f,0x129f,0x129f,0x129f,0x129f,0x129f,0x129f,0x1329,0x1326,0x1329,0x1326,
-0x1329,0x1326,0x1329,0x1326,0x1329,0x1326,0x13e9,0x14fd,0x14fd,0x14fd,0x1791,0x1905,0x14fd,0x14fd,0x16dd,0x16dd,
-0x16dd,0x16d7,0x16dd,0x16d7,0x1908,0x1905,0x19bf,0x19bc,0x19bf,0x19bc,0x19bf,0x19bc,0x134d,0x134d,0x134d,0x134d,
-0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,
-0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,0x134d,0x1362,0x1353,0x1362,0x1365,
-0x1365,0x1365,0x1365,0x1365,0x1365,0x1365,0x1365,0x1365,0x1365,0x1365,0x1365,0x1365,0x1365,0x1365,0x1365,0x1365,
-0x1365,0x1365,0x1365,0x1365,0x1365,0x1365,0x1365,0x1365,0x1365,0x1365,0x1365,0x1365,0x1353,0x1353,0x1353,0x1353,
-0x1353,0x1353,0x1353,0x1353,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,
-0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,0x136b,
-0x136b,0x136b,0x136b,0x136b,0x1371,0x1371,0x1371,0x1371,0x1371,0x1371,0x1371,0x1371,0x1371,0x1371,0x1371,0x1371,
-0x1371,0x1371,0x1371,0x1371,0x1371,0x1371,0x1371,0x1371,0x1371,0x1371,0x1371,0x1371,0x1371,0x1371,0x1371,0x1371,
-0x1371,0x1371,0x1371,0x1371,0x139b,0x1398,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,
-0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,
-0x18ba,0x18ba,0x18ba,0x18ba,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,
-0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a1,0x13a1,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,
-0x13a1,0x13a4,0x13a4,0x13a4,0x13a1,0x13a4,0x13a1,0x13a4,0x13a1,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a7,0x13a4,
-0x13a4,0x13a4,0x13a4,0x13a1,0x13a4,0x13a1,0x13a1,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,
-0x13a4,0x13a4,0x13a4,0x13a4,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,
-0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,
-0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,
-0x13a4,0x13a4,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x1527,0x1527,
-0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,
-0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,
-0x13a4,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x1767,0x1767,0x1767,
-0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x152a,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,
-0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,
-0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x152a,0x1767,0x1767,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a7,0x13a4,0x13a4,
-0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x152a,0x152a,0x152a,0x152a,
-0x152a,0x152a,0x152a,0x152a,0x1527,0x1527,0x152a,0x152a,0x13a4,0x13a4,0x13a7,0x13a7,0x13a7,0x1692,0x13a4,0x13a7,
-0x13a4,0x13a4,0x13a7,0x152d,0x152d,0x152a,0x152a,0x1767,0x1767,0x1767,0x1767,0x1767,0x152a,0x152a,0x152a,0x152a,
-0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,
-0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x152a,0x152a,0x152a,0x1692,0x152a,0x152a,0x152a,
-0x1767,0x1767,0x1767,0x176a,0x176a,0x176a,0x176a,0x176a,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,
-0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,
-0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x152a,0x13a4,0x152a,0x13a7,0x13a7,0x13a4,0x13a4,0x13a7,0x13a7,
-0x13a7,0x13a7,0x13a7,0x13a7,0x13a7,0x13a7,0x13a7,0x13a7,0x13a7,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,
-0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a7,0x13a7,0x13a7,0x13a7,0x13a7,0x13a7,
-0x13a7,0x13a7,0x13a7,0x13a7,0x13a7,0x13a7,0x13a7,0x13a7,0x13a7,0x13a7,0x13a7,0x13a7,0x13a7,0x13a4,0x13a4,0x13a4,
-0x13a7,0x13a4,0x13a4,0x13a4,0x13a4,0x13a7,0x13a7,0x13a7,0x13a4,0x13a7,0x13a7,0x13a7,0x13a4,0x13a4,0x13a4,0x13a4,
-0x13a4,0x13a4,0x13a4,0x13a7,0x13a4,0x13a7,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,
-0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,
-0x1692,0x13a4,0x13a4,0x13a4,0x13a4,0x152a,0x152a,0x1767,0x13fe,0x13fe,0x13fe,0x13fe,0x1527,0x1527,0x1527,0x1527,
-0x1527,0x1527,0x152a,0x1767,0x1767,0x1767,0x1767,0x16ec,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,
-0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,
-0x152a,0x152a,0x152a,0x152a,0x152d,0x152d,0x152a,0x152a,0x152a,0x152a,0x181e,0x152a,0x152a,0x152a,0x152a,0x152a,
-0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,
-0x1527,0x1527,0x1527,0x1527,0x1527,0x1527,0x152a,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x1488,0x13aa,0x13aa,0x13aa,
-0x13aa,0x13aa,0x13aa,0x13aa,0x13aa,0x13aa,0x13aa,0x13aa,0x13aa,0x13aa,0x13aa,0x13aa,0x13aa,0x1488,0x13aa,0x13aa,
-0x13aa,0x1488,0x13aa,0x1488,0x13aa,0x1488,0x13aa,0x1488,0x13aa,0x13aa,0x13aa,0x1488,0x13aa,0x13aa,0x13aa,0x13aa,
-0x13aa,0x13aa,0x1488,0x1488,0x13aa,0x13aa,0x13aa,0x13aa,0x1488,0x13aa,0x1488,0x1488,0x13aa,0x13aa,0x13aa,0x13aa,
-0x1488,0x13aa,0x13aa,0x13aa,0x13aa,0x13aa,0x13aa,0x13aa,0x13aa,0x13aa,0x13aa,0x13aa,0x13aa,0x1698,0x1698,0x176d,
-0x176d,0x13ad,0x13ad,0x13ad,0x13aa,0x13aa,0x13aa,0x13ad,0x13ad,0x13ad,0x13ad,0x13ad,0x1617,0x1617,0x1617,0x1617,
-0x1617,0x1617,0x1617,0x1617,0x1617,0x1617,0x1617,0x1617,0x1617,0x1617,0x1617,0x1617,0x13b0,0x13b0,0x13b0,0x13b0,
-0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,
-0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b3,
-0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,
-0x13b3,0x13b3,0x13b3,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b0,0x13b6,0x13b6,0x13b6,0x13b6,
+0x106b,0x106b,0x106b,0x106b,0x106b,0x106b,0x106b,0x106b,0x106e,0x106e,0x106e,0x1071,0x106e,0x106e,0x1074,0x1074,
+0x1077,0x1077,0x1077,0x1077,0x1077,0x1077,0x1077,0x1077,0x1077,0x1077,0x1077,0x1077,0x1077,0x1077,0x1077,0x1077,
+0x1077,0x1077,0x1077,0x1077,0x1077,0x1077,0x1077,0x1077,0x1077,0x1077,0x1077,0x1077,0x1077,0x1077,0x1077,0x1077,
+0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1083,0x107a,0x1089,0x1086,
+0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,
+0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,
+0x1341,0x133e,0x109b,0x1095,0x109b,0x1095,0x109b,0x1095,0x109b,0x1095,0x109b,0x1095,0x109b,0x1095,0x1098,0x1119,
+0x108c,0x108c,0x108c,0x1092,0x140a,0x140a,0x140a,0x140a,0x140a,0x140a,0x140a,0x140a,0x108f,0x108f,0x1092,0x109e,
+0x109b,0x1095,0x109b,0x1095,0x109b,0x1095,0x109b,0x1095,0x109b,0x1095,0x109b,0x1095,0x109b,0x1095,0x109b,0x1095,
+0x109b,0x1095,0x109b,0x1095,0x109b,0x1095,0x109b,0x1095,0x109b,0x1095,0x109b,0x1095,0x109b,0x1095,0x109b,0x1095,
+0x151e,0x151b,0x151e,0x151b,0x1521,0x1521,0x16f5,0x140a,0x10a7,0x10a7,0x10aa,0x10aa,0x10aa,0x10aa,0x10aa,0x10aa,
+0x10aa,0x10aa,0x10aa,0x10aa,0x10aa,0x10aa,0x10aa,0x10aa,0x10aa,0x10aa,0x10aa,0x10aa,0x10aa,0x10aa,0x10aa,0x10aa,
+0x10aa,0x10aa,0x10aa,0x10aa,0x10aa,0x10aa,0x10aa,0x10aa,0x10a7,0x10a7,0x10a7,0x10a7,0x10a7,0x10a7,0x10a7,0x10a7,
+0x10a7,0x10a7,0x10a7,0x10a7,0x10b9,0x10b9,0x10b9,0x10b9,0x10b9,0x10b9,0x10b0,0x10b0,0x10b0,0x10b0,0x10b0,0x10b3,
+0x10b3,0x10b3,0x110d,0x10bc,0x10cb,0x10cb,0x10cb,0x10cb,0x10cb,0x10cb,0x10cb,0x10cb,0x10cb,0x10cb,0x10cb,0x10cb,
+0x10cb,0x10cb,0x10cb,0x10cb,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b9,0x10b9,
+0x10b9,0x10b9,0x10b9,0x10b9,0x10b9,0x10b9,0x10b9,0x10b9,0x10b9,0x10b9,0x10b9,0x10b9,0x10b9,0x10b9,0x10b9,0x10b9,
+0x10b9,0x10b9,0x10b9,0x10b9,0x10da,0x10da,0x10da,0x10da,0x10da,0x10da,0x10da,0x10da,0x10da,0x10da,0x10da,0x10da,
+0x10da,0x10da,0x10da,0x10da,0x10da,0x10da,0x10da,0x10da,0x10da,0x10da,0x10da,0x10da,0x10da,0x10da,0x10da,0x10da,
+0x10da,0x10da,0x10da,0x10da,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,
+0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,
+0x10ec,0x10ec,0x10ec,0x10ec,0x10f5,0x10f5,0x10f5,0x10f5,0x110a,0x10f5,0x10f5,0x10f5,0x10f5,0x10f5,0x10f5,0x10f5,
+0x10f5,0x10f5,0x10f5,0x10f5,0x10f5,0x10f5,0x10f5,0x10f5,0x10f5,0x10f5,0x10f5,0x10f5,0x10f5,0x10f5,0x10f5,0x10f5,
+0x10f5,0x10f5,0x10f5,0x10f5,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,
+0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,
+0x10f8,0x10f8,0x10f8,0x10f8,0x1104,0x1104,0x1104,0x1104,0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,
+0x1494,0x1776,0x1776,0x1776,0x1776,0x1776,0x1776,0x1776,0x1776,0x1776,0x18c6,0x18c6,0x18c6,0x18c6,0x18c6,0x18c6,
+0x18c6,0x18c6,0x18c6,0x18c6,0x1179,0x1179,0x1179,0x1179,0x1179,0x1179,0x1179,0x1179,0x1179,0x1179,0x1179,0x1179,
+0x1179,0x1179,0x1179,0x1179,0x1179,0x1179,0x1179,0x1179,0x1179,0x1179,0x1170,0x1170,0x1173,0x1173,0x1179,0x1170,
+0x1170,0x1170,0x1170,0x1170,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,
+0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,0x117f,
+0x117f,0x117f,0x117f,0x117f,0x119a,0x119a,0x119a,0x119a,0x119a,0x119a,0x119a,0x119a,0x119a,0x119a,0x119a,0x119a,
+0x119a,0x119a,0x119a,0x119a,0x119a,0x119a,0x119a,0x119a,0x119a,0x119a,0x119a,0x119a,0x119a,0x119a,0x119a,0x119a,
+0x119a,0x119a,0x119a,0x119a,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,
+0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,0x11a6,
+0x11a6,0x11a6,0x11a3,0x11a9,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,
+0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,
+0x11b5,0x11b5,0x11b5,0x11b5,0x11bb,0x11bb,0x11bb,0x11bb,0x11bb,0x11bb,0x11bb,0x11bb,0x11bb,0x11bb,0x11bb,0x11bb,
+0x11bb,0x11bb,0x11bb,0x11bb,0x11bb,0x12e7,0x11c1,0x12ea,0x11c1,0x11c1,0x11c1,0x11c1,0x11be,0x11be,0x11be,0x11c1,
+0x16f8,0x16fb,0x1923,0x1920,0x11c4,0x11c4,0x11c4,0x11d3,0x11d9,0x11d9,0x11d9,0x11d9,0x11d9,0x11d9,0x11d9,0x11d9,
+0x11d9,0x11d9,0x11d9,0x11d9,0x11d9,0x11d9,0x11d9,0x11d9,0x11d9,0x11d9,0x11d9,0x11d9,0x11d9,0x11d9,0x11d9,0x11d9,
+0x11d9,0x11d9,0x11d9,0x11d9,0x11d9,0x11d9,0x11d9,0x11c7,0x11d3,0x11d3,0x11c4,0x11c4,0x11c4,0x11c4,0x11d3,0x11d3,
+0x11c4,0x11c4,0x11d3,0x11d3,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,
+0x11e5,0x11e5,0x11e5,0x11e5,0x11e8,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11df,0x11df,0x11df,0x11e5,0x11e2,
+0x1527,0x152a,0x152d,0x152d,0x11f7,0x11f7,0x11f7,0x11f7,0x11f7,0x11f7,0x11f7,0x11f7,0x11f7,0x11f7,0x11f7,0x11f7,
+0x11f7,0x11f7,0x11f7,0x11f7,0x11eb,0x11f7,0x11eb,0x11eb,0x11eb,0x1200,0x1200,0x11eb,0x11eb,0x1200,0x11f7,0x1200,
+0x1200,0x11f7,0x11eb,0x11ee,0x11f7,0x11f7,0x11f7,0x11f7,0x11f7,0x11f7,0x11f7,0x11f7,0x11f7,0x11f7,0x11f7,0x11f7,
+0x11f7,0x11f7,0x11f7,0x11f7,0x11f7,0x11f7,0x11f7,0x11f7,0x11f7,0x11f7,0x11f7,0x11f7,0x11f7,0x11f7,0x11f7,0x11f7,
+0x11f7,0x11f7,0x11f7,0x11f7,0x1212,0x1212,0x1212,0x1212,0x1212,0x1212,0x1212,0x1212,0x1212,0x1212,0x1212,0x1212,
+0x1212,0x1212,0x1212,0x1212,0x1212,0x1212,0x1212,0x1212,0x1212,0x1212,0x1212,0x1212,0x1212,0x1212,0x1212,0x1212,
+0x1212,0x1212,0x1212,0x1212,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,
+0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,
+0x122a,0x1227,0x1227,0x1227,0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,
+0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,
+0x1233,0x1233,0x1233,0x1233,0x1242,0x1242,0x1242,0x1242,0x1242,0x1242,0x1242,0x1242,0x1242,0x1242,0x1242,0x1242,
+0x1242,0x1242,0x1242,0x1242,0x1242,0x1242,0x1242,0x1242,0x1242,0x1242,0x1242,0x1242,0x1242,0x1242,0x1242,0x1242,
+0x1242,0x1242,0x1242,0x1242,0x1248,0x1248,0x1254,0x1257,0x1257,0x1257,0x1257,0x1257,0x1257,0x1257,0x1257,0x1257,
+0x1257,0x1257,0x1257,0x1257,0x1257,0x1257,0x1257,0x1257,0x1257,0x1257,0x1257,0x1257,0x1257,0x1257,0x125a,0x1257,
+0x125a,0x1257,0x1257,0x1257,0x1257,0x1257,0x1257,0x1257,0x1257,0x1257,0x1257,0x1257,0x1257,0x1257,0x1257,0x125a,
+0x1257,0x1257,0x1257,0x1257,0x1254,0x1254,0x1254,0x1248,0x1248,0x1248,0x1248,0x1254,0x1254,0x124e,0x124b,0x1251,
+0x1251,0x1260,0x125d,0x125d,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,
+0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,
+0x1263,0x1263,0x1263,0x1263,0x1269,0x1269,0x1269,0x1266,0x1266,0x1266,0x1263,0x1263,0x1263,0x1263,0x1266,0x1263,
+0x1263,0x1263,0x1269,0x1266,0x1269,0x1266,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,
+0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,
+0x1263,0x1269,0x1266,0x1266,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,0x1263,
+0x1263,0x1263,0x1263,0x1bcf,0x19f5,0x19f5,0x19f5,0x19f5,0x19f5,0x19f5,0x19f5,0x19f8,0x19f2,0x1be1,0x1be1,0x1be1,
+0x1be4,0x1bde,0x1be4,0x1bde,0x1284,0x1284,0x1284,0x1284,0x1284,0x1284,0x1284,0x1284,0x1284,0x1284,0x1284,0x1287,
+0x1287,0x1287,0x126c,0x1929,0x138f,0x1290,0x138f,0x138f,0x138f,0x138f,0x138f,0x138f,0x138f,0x138f,0x138f,0x138f,
+0x138f,0x1290,0x138f,0x1290,0x1275,0x1275,0x131d,0x1272,0x131d,0x131d,0x131d,0x131d,0x1272,0x1272,0x1296,0x1272,
+0x1272,0x1272,0x1272,0x1272,0x1272,0x1275,0x1296,0x1296,0x1275,0x1296,0x1272,0x1275,0x1275,0x1278,0x1296,0x1272,
+0x1272,0x1296,0x1275,0x1275,0x138c,0x138c,0x138c,0x138c,0x138c,0x138c,0x138c,0x138c,0x138c,0x138c,0x1281,0x1281,
+0x1281,0x1281,0x13a4,0x1386,0x128a,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x13a4,0x1827,
+0x1827,0x1827,0x1827,0x1827,0x1284,0x1284,0x1284,0x1284,0x1284,0x1284,0x1284,0x1284,0x1284,0x1284,0x1284,0x1530,
+0x1530,0x1a76,0x1a76,0x1a76,0x1284,0x1284,0x1284,0x1284,0x1284,0x1284,0x1284,0x1284,0x1284,0x1284,0x1284,0x1284,
+0x1284,0x1284,0x1284,0x1284,0x138f,0x138f,0x1290,0x138f,0x138f,0x138f,0x1290,0x138f,0x138f,0x138f,0x128a,0x128a,
+0x128a,0x128a,0x128a,0x1389,0x138c,0x138c,0x138c,0x138c,0x138c,0x138c,0x138c,0x128d,0x138c,0x138c,0x138c,0x138c,
+0x138c,0x138c,0x138c,0x128d,0x138c,0x138c,0x138c,0x138c,0x138c,0x138c,0x138c,0x138c,0x138c,0x138c,0x140d,0x140d,
+0x19d4,0x1a76,0x1a76,0x1a76,0x138c,0x138c,0x138c,0x138c,0x138c,0x138c,0x138c,0x138c,0x138c,0x128d,0x138c,0x128d,
+0x128d,0x138c,0x138c,0x128d,0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,
+0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,0x12b1,
+0x12b1,0x12b1,0x12b1,0x12b1,0x133b,0x1338,0x133b,0x1338,0x133b,0x1338,0x133b,0x1338,0x133b,0x1338,0x13fb,0x150f,
+0x150f,0x150f,0x17a3,0x1917,0x150f,0x150f,0x16ef,0x16ef,0x16ef,0x16e9,0x16ef,0x16e9,0x191a,0x1917,0x19d1,0x19ce,
+0x19d1,0x19ce,0x19d1,0x19ce,0x135f,0x135f,0x135f,0x135f,0x135f,0x135f,0x135f,0x135f,0x135f,0x135f,0x135f,0x135f,
+0x135f,0x135f,0x135f,0x135f,0x135f,0x135f,0x135f,0x135f,0x135f,0x135f,0x135f,0x135f,0x135f,0x135f,0x135f,0x135f,
+0x135f,0x135f,0x135f,0x135f,0x1374,0x1365,0x1374,0x1377,0x1377,0x1377,0x1377,0x1377,0x1377,0x1377,0x1377,0x1377,
+0x1377,0x1377,0x1377,0x1377,0x1377,0x1377,0x1377,0x1377,0x1377,0x1377,0x1377,0x1377,0x1377,0x1377,0x1377,0x1377,
+0x1377,0x1377,0x1377,0x1377,0x1365,0x1365,0x1365,0x1365,0x1365,0x1365,0x1365,0x1365,0x137d,0x137d,0x137d,0x137d,
+0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,
+0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x1383,0x1383,0x1383,0x1383,
+0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,
+0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x13ad,0x13aa,0x18cc,0x18cc,
+0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,
+0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x13b6,0x13b6,0x13b6,0x13b6,
+0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,
+0x13b6,0x13b3,0x13b3,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b3,0x13b6,0x13b6,0x13b6,0x13b3,0x13b6,0x13b3,0x13b6,
+0x13b3,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b9,0x13b6,0x13b6,0x13b6,0x13b6,0x13b3,0x13b6,0x13b3,0x13b3,0x13b6,
+0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b3,0x13b3,0x13b3,0x13b3,
+0x13b3,0x13b3,0x13b3,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,
+0x13b6,0x13b6,0x13b6,0x13b3,0x13b3,0x13b3,0x13b3,0x13b3,0x13b3,0x13b3,0x13b3,0x13b3,0x13b3,0x13b6,0x13b6,0x13b6,
+0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b3,0x13b3,0x13b3,0x13b3,0x13b3,0x13b3,
+0x13b3,0x13b3,0x13b3,0x13b3,0x13b3,0x13b3,0x1539,0x1539,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,
+0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,
+0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,
+0x153c,0x153c,0x153c,0x153c,0x153c,0x1779,0x1779,0x1779,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x153c,0x13b6,
+0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,
+0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x153c,0x1779,0x1779,
+0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b9,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,
+0x13b6,0x13b6,0x13b6,0x13b6,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x1539,0x1539,0x153c,0x153c,
+0x13b6,0x13b6,0x13b9,0x13b9,0x13b9,0x16a4,0x13b6,0x13b9,0x13b6,0x13b6,0x13b9,0x153f,0x153f,0x153c,0x153c,0x1779,
+0x1779,0x1779,0x1779,0x1779,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,
+0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,
+0x13b6,0x153c,0x153c,0x153c,0x16a4,0x153c,0x153c,0x153c,0x1779,0x1779,0x1779,0x177c,0x177c,0x177c,0x177c,0x177c,
 0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,
-0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x179a,0x179a,0x1797,0x16ef,
-0x1404,0x1404,0x1404,0x1404,0x1404,0x1404,0x1401,0x1401,0x1401,0x1401,0x1401,0x1401,0x1404,0x1404,0x1404,0x1404,
-0x1404,0x1404,0x1404,0x1404,0x1404,0x1404,0x1404,0x1404,0x1404,0x1404,0x1404,0x1533,0x1407,0x1536,0x1407,0x1407,
-0x1407,0x1407,0x1407,0x1407,0x1407,0x1407,0x1407,0x1407,0x1407,0x1536,0x1536,0x1536,0x1536,0x1536,0x1536,0x16f2,
-0x16f2,0x1b39,0x17a0,0x17a0,0x17a0,0x17a0,0x17a0,0x17a0,0x17a0,0x17a0,0x1a67,0x1a67,0x1410,0x1410,0x1410,0x1422,
-0x1422,0x1422,0x1422,0x1422,0x1422,0x1422,0x1422,0x1422,0x1422,0x1422,0x1422,0x1422,0x1422,0x1422,0x1422,0x1422,
-0x1422,0x1422,0x1422,0x1422,0x1422,0x1422,0x1422,0x1422,0x1422,0x1422,0x1422,0x1422,0x143d,0x143d,0x143d,0x143d,
-0x143d,0x143d,0x143d,0x143d,0x143d,0x143d,0x143d,0x143d,0x143d,0x143d,0x143d,0x143d,0x143d,0x143d,0x143d,0x143d,
-0x143d,0x143d,0x143d,0x143d,0x143d,0x143d,0x143d,0x143d,0x143d,0x143d,0x143d,0x143d,0x1443,0x1443,0x1443,0x1443,
-0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,
-0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,0x1443,0x19c8,0x1446,0x1446,0x1446,0x1446,
-0x1446,0x1446,0x1446,0x1446,0x1446,0x1446,0x1446,0x1446,0x1446,0x1446,0x1446,0x1446,0x1446,0x1446,0x1446,0x1446,
-0x1446,0x1446,0x1446,0x1446,0x1446,0x1446,0x1446,0x1446,0x1446,0x1446,0x1446,0x1446,0x144c,0x144c,0x1458,0x145e,
-0x145e,0x145e,0x145e,0x145e,0x145e,0x145e,0x145e,0x145e,0x145e,0x145e,0x145e,0x145e,0x145e,0x145e,0x145e,0x145e,
-0x145e,0x145e,0x145e,0x145e,0x145e,0x145e,0x145e,0x145e,0x145e,0x145e,0x145e,0x145e,0x145e,0x145e,0x145e,0x1458,
-0x1458,0x1458,0x144c,0x144c,0x144c,0x144c,0x144c,0x144c,0x144c,0x144c,0x144c,0x1458,0x145b,0x145e,0x1461,0x1461,
-0x145e,0x1464,0x1464,0x144f,0x1452,0x16f8,0x16fb,0x16fb,0x16fb,0x153c,0x1a70,0x1a6d,0x1455,0x1455,0x1455,0x1455,
-0x1455,0x1455,0x1455,0x1455,0x1455,0x1455,0x1539,0x1701,0x1704,0x16fe,0x1707,0x1707,0x147f,0x147f,0x147f,0x147f,
-0x147f,0x147f,0x147f,0x147f,0x147f,0x147f,0x147f,0x147f,0x147f,0x147f,0x147f,0x147f,0x147f,0x147f,0x147f,0x147f,
-0x147f,0x147f,0x147f,0x147f,0x147f,0x147f,0x147f,0x147f,0x147f,0x147f,0x147f,0x147f,0x14d9,0x14d9,0x14d9,0x14d9,
-0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,
-0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x18ed,0x18ed,0x18ed,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,
-0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x19b6,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x14d9,0x1851,0x18ed,
-0x18ed,0x18ed,0x18ed,0x18ed,0x18ed,0x18ed,0x18ed,0x18ed,0x18ed,0x18ed,0x18ed,0x18ed,0x152a,0x152a,0x152a,0x152a,
-0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,
-0x1527,0x1527,0x1527,0x1527,0x1527,0x1527,0x1527,0x1527,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,
-0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152d,0x152a,0x152a,0x152a,0x152a,0x1695,0x1695,0x152a,
-0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x181b,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,
-0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,0x152a,
-0x152a,0x152a,0x152a,0x152a,0x154b,0x154b,0x154b,0x154b,0x154b,0x154b,0x154b,0x154b,0x154b,0x154b,0x154b,0x154b,
-0x154b,0x154b,0x154b,0x154b,0x154b,0x154b,0x154b,0x154b,0x154b,0x154b,0x154b,0x154b,0x154b,0x154b,0x154b,0x154b,
-0x154b,0x154b,0x154b,0x154b,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,
+0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x153c,
+0x13b6,0x153c,0x13b9,0x13b9,0x13b6,0x13b6,0x13b9,0x13b9,0x13b9,0x13b9,0x13b9,0x13b9,0x13b9,0x13b9,0x13b9,0x13b9,
+0x13b9,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,
+0x13b6,0x13b6,0x13b9,0x13b9,0x13b9,0x13b9,0x13b9,0x13b9,0x13b9,0x13b9,0x13b9,0x13b9,0x13b9,0x13b9,0x13b9,0x13b9,
+0x13b9,0x13b9,0x13b9,0x13b9,0x13b9,0x13b6,0x13b6,0x13b6,0x13b9,0x13b6,0x13b6,0x13b6,0x13b6,0x13b9,0x13b9,0x13b9,
+0x13b6,0x13b9,0x13b9,0x13b9,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b9,0x13b6,0x13b9,0x13b6,0x13b6,
+0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,
+0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x16a4,0x13b6,0x13b6,0x13b6,0x13b6,0x153c,0x153c,0x1779,
+0x1410,0x1410,0x1410,0x1410,0x1539,0x1539,0x1539,0x1539,0x1539,0x1539,0x153c,0x1779,0x1779,0x1779,0x1779,0x16fe,
+0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,
+0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153f,0x153f,0x153c,0x153c,
+0x153c,0x153c,0x1830,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,
+0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x1539,0x1539,0x1539,0x1539,0x1539,0x1539,0x153c,0x13b6,
+0x13b6,0x13b6,0x13b6,0x13b6,0x149a,0x13bc,0x13bc,0x13bc,0x13bc,0x13bc,0x13bc,0x13bc,0x13bc,0x13bc,0x13bc,0x13bc,
+0x13bc,0x13bc,0x13bc,0x13bc,0x13bc,0x149a,0x13bc,0x13bc,0x13bc,0x149a,0x13bc,0x149a,0x13bc,0x149a,0x13bc,0x149a,
+0x13bc,0x13bc,0x13bc,0x149a,0x13bc,0x13bc,0x13bc,0x13bc,0x13bc,0x13bc,0x149a,0x149a,0x13bc,0x13bc,0x13bc,0x13bc,
+0x149a,0x13bc,0x149a,0x149a,0x13bc,0x13bc,0x13bc,0x13bc,0x149a,0x13bc,0x13bc,0x13bc,0x13bc,0x13bc,0x13bc,0x13bc,
+0x13bc,0x13bc,0x13bc,0x13bc,0x13bc,0x16aa,0x16aa,0x177f,0x177f,0x13bf,0x13bf,0x13bf,0x13bc,0x13bc,0x13bc,0x13bf,
+0x13bf,0x13bf,0x13bf,0x13bf,0x1629,0x1629,0x1629,0x1629,0x1629,0x1629,0x1629,0x1629,0x1629,0x1629,0x1629,0x1629,
+0x1629,0x1629,0x1629,0x1629,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,
+0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,
+0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c5,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,
+0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c5,0x13c5,0x13c5,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,
+0x13c2,0x13c2,0x13c2,0x13c2,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,
+0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,0x13c8,
+0x13c8,0x13c8,0x13c8,0x13c8,0x17ac,0x17ac,0x17a9,0x1701,0x1416,0x1416,0x1416,0x1416,0x1416,0x1416,0x1413,0x1413,
+0x1413,0x1413,0x1413,0x1413,0x1416,0x1416,0x1416,0x1416,0x1416,0x1416,0x1416,0x1416,0x1416,0x1416,0x1416,0x1416,
+0x1416,0x1416,0x1416,0x1545,0x1419,0x1548,0x1419,0x1419,0x1419,0x1419,0x1419,0x1419,0x1419,0x1419,0x1419,0x1419,
+0x1419,0x1548,0x1548,0x1548,0x1548,0x1548,0x1548,0x1704,0x1704,0x1b4b,0x17b2,0x17b2,0x17b2,0x17b2,0x17b2,0x17b2,
+0x17b2,0x17b2,0x1a79,0x1a79,0x1422,0x1422,0x1422,0x1434,0x1434,0x1434,0x1434,0x1434,0x1434,0x1434,0x1434,0x1434,
+0x1434,0x1434,0x1434,0x1434,0x1434,0x1434,0x1434,0x1434,0x1434,0x1434,0x1434,0x1434,0x1434,0x1434,0x1434,0x1434,
+0x1434,0x1434,0x1434,0x1434,0x144f,0x144f,0x144f,0x144f,0x144f,0x144f,0x144f,0x144f,0x144f,0x144f,0x144f,0x144f,
+0x144f,0x144f,0x144f,0x144f,0x144f,0x144f,0x144f,0x144f,0x144f,0x144f,0x144f,0x144f,0x144f,0x144f,0x144f,0x144f,
+0x144f,0x144f,0x144f,0x144f,0x1455,0x1455,0x1455,0x1455,0x1455,0x1455,0x1455,0x1455,0x1455,0x1455,0x1455,0x1455,
+0x1455,0x1455,0x1455,0x1455,0x1455,0x1455,0x1455,0x1455,0x1455,0x1455,0x1455,0x1455,0x1455,0x1455,0x1455,0x1455,
+0x1455,0x1455,0x1455,0x19da,0x1458,0x1458,0x1458,0x1458,0x1458,0x1458,0x1458,0x1458,0x1458,0x1458,0x1458,0x1458,
+0x1458,0x1458,0x1458,0x1458,0x1458,0x1458,0x1458,0x1458,0x1458,0x1458,0x1458,0x1458,0x1458,0x1458,0x1458,0x1458,
+0x1458,0x1458,0x1458,0x1458,0x145e,0x145e,0x146a,0x1470,0x1470,0x1470,0x1470,0x1470,0x1470,0x1470,0x1470,0x1470,
+0x1470,0x1470,0x1470,0x1470,0x1470,0x1470,0x1470,0x1470,0x1470,0x1470,0x1470,0x1470,0x1470,0x1470,0x1470,0x1470,
+0x1470,0x1470,0x1470,0x1470,0x1470,0x1470,0x1470,0x146a,0x146a,0x146a,0x145e,0x145e,0x145e,0x145e,0x145e,0x145e,
+0x145e,0x145e,0x145e,0x146a,0x146d,0x1470,0x1473,0x1473,0x1470,0x1476,0x1476,0x1461,0x1464,0x170a,0x170d,0x170d,
+0x170d,0x154e,0x1a82,0x1a7f,0x1467,0x1467,0x1467,0x1467,0x1467,0x1467,0x1467,0x1467,0x1467,0x1467,0x154b,0x1713,
+0x1716,0x1710,0x1719,0x1719,0x1491,0x1491,0x1491,0x1491,0x1491,0x1491,0x1491,0x1491,0x1491,0x1491,0x1491,0x1491,
+0x1491,0x1491,0x1491,0x1491,0x1491,0x1491,0x1491,0x1491,0x1491,0x1491,0x1491,0x1491,0x1491,0x1491,0x1491,0x1491,
+0x1491,0x1491,0x1491,0x1491,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,
+0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x18ff,0x18ff,
+0x18ff,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x19c8,0x14eb,0x14eb,
+0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x14eb,0x1863,0x18ff,0x18ff,0x18ff,0x18ff,0x18ff,0x18ff,0x18ff,0x18ff,0x18ff,
+0x18ff,0x18ff,0x18ff,0x18ff,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,
+0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x1539,0x1539,0x1539,0x1539,0x1539,0x1539,0x1539,0x1539,
+0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,
+0x153f,0x153c,0x153c,0x153c,0x153c,0x16a7,0x16a7,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,
+0x182d,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,
+0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x155d,0x155d,0x155d,0x155d,
 0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,
-0x155d,0x155d,0x155d,0x155d,0x1563,0x1563,0x1563,0x1563,0x1563,0x1563,0x1563,0x1563,0x1563,0x1563,0x1563,0x1563,
-0x1563,0x1563,0x1563,0x1563,0x1563,0x1563,0x1563,0x1563,0x1563,0x1563,0x1563,0x1563,0x1563,0x1563,0x1563,0x1563,
-0x1563,0x1563,0x1563,0x1563,0x1566,0x1566,0x1566,0x1566,0x1566,0x1566,0x1566,0x1566,0x1566,0x1566,0x1566,0x1566,
-0x1566,0x1566,0x1566,0x1566,0x1566,0x1566,0x1566,0x1566,0x1566,0x1566,0x1566,0x1566,0x1566,0x1566,0x1566,0x1566,
-0x1566,0x1566,0x1566,0x1566,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,
-0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,
-0x15a5,0x15a5,0x15a5,0x1596,0x15ae,0x15ae,0x15ae,0x15ae,0x15ae,0x15ae,0x15ae,0x15ae,0x15ae,0x15ae,0x15ae,0x15ae,
-0x15ae,0x15ae,0x15ae,0x15ae,0x15ae,0x15ae,0x15ae,0x15ae,0x15ae,0x15ae,0x15ae,0x15ae,0x15ae,0x15ae,0x15ae,0x15a8,
-0x15b1,0x15b1,0x15b1,0x15b1,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,
-0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,
-0x15b4,0x15b4,0x15b4,0x15b4,0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15c6,0x15cf,0x15cf,0x15cf,
-0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,
-0x15cf,0x15cf,0x15cf,0x15cf,0x15d8,0x15d8,0x15d8,0x15d8,0x15d8,0x15d8,0x15d8,0x15d8,0x15d8,0x15d8,0x15d8,0x15d8,
-0x15d8,0x15d8,0x15d8,0x15d8,0x15d8,0x15d8,0x15d8,0x15d8,0x15d8,0x15d8,0x15d8,0x15d8,0x15d8,0x15d8,0x15d8,0x15d8,
-0x15d8,0x15d8,0x15d8,0x15d8,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,
-0x15ea,0x15ea,0x15ea,0x15ea,0x15e7,0x15e7,0x15e7,0x15db,0x15db,0x15db,0x15db,0x15db,0x15db,0x15db,0x15db,0x15e7,
-0x15e7,0x15db,0x15e7,0x15de,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,
+0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x156f,0x156f,0x156f,0x156f,
+0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,
+0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x156f,0x1575,0x1575,0x1575,0x1575,
+0x1575,0x1575,0x1575,0x1575,0x1575,0x1575,0x1575,0x1575,0x1575,0x1575,0x1575,0x1575,0x1575,0x1575,0x1575,0x1575,
+0x1575,0x1575,0x1575,0x1575,0x1575,0x1575,0x1575,0x1575,0x1575,0x1575,0x1575,0x1575,0x1578,0x1578,0x1578,0x1578,
+0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,
+0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x1578,0x15a2,0x15a2,0x15a2,0x15a2,
+0x15a2,0x15a2,0x15a2,0x15a2,0x15a2,0x15a2,0x15a2,0x15a2,0x159c,0x159c,0x159c,0x1590,0x1590,0x1590,0x159c,0x159c,
+0x1590,0x159f,0x1593,0x1590,0x15a5,0x15a5,0x1599,0x15a5,0x15a5,0x1596,0x17b5,0x1bdb,0x15b7,0x15b7,0x15b7,0x15b7,
+0x15b7,0x15b7,0x15b7,0x15b7,0x15b7,0x15b7,0x15b7,0x15b7,0x15b7,0x15b7,0x15b7,0x15b7,0x15b7,0x15b7,0x15b7,0x15b7,
+0x15b7,0x15b7,0x15b7,0x15b7,0x15b7,0x15b7,0x15b7,0x15b7,0x15b7,0x15b7,0x15b7,0x15a8,0x15c0,0x15c0,0x15c0,0x15c0,
+0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,
+0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15c0,0x15ba,0x15c3,0x15c3,0x15c3,0x15c3,0x15c6,0x15c6,0x15c6,0x15c6,
+0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,
+0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15e1,0x15e1,0x15e1,0x15e1,
+0x15e1,0x15e1,0x15e1,0x15e1,0x15d8,0x15e1,0x15e1,0x15e1,0x15e1,0x15e1,0x15e1,0x15e1,0x15e1,0x15e1,0x15e1,0x15e1,
+0x15e1,0x15e1,0x15e1,0x15e1,0x15e1,0x15e1,0x15e1,0x15e1,0x15e1,0x15e1,0x15e1,0x15e1,0x15ea,0x15ea,0x15ea,0x15ea,
 0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,
-0x15ea,0x15ea,0x15ea,0x15ea,0x160e,0x160e,0x160e,0x160e,0x160e,0x160e,0x160e,0x160e,0x160e,0x160e,0x160e,0x160e,
-0x160e,0x160e,0x160e,0x160e,0x160e,0x160e,0x160e,0x160e,0x160e,0x160e,0x160e,0x160e,0x160e,0x160e,0x160e,0x160e,
-0x160e,0x160b,0x160b,0x160b,0x1617,0x1617,0x1617,0x1617,0x1617,0x1617,0x1617,0x1617,0x1617,0x1617,0x1617,0x1617,
-0x1617,0x1617,0x1617,0x1617,0x1617,0x1617,0x1617,0x1617,0x1617,0x1617,0x161d,0x161d,0x161d,0x161a,0x161a,0x161a,
-0x1617,0x1617,0x1617,0x1617,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,
-0x162c,0x162c,0x162c,0x162c,0x1620,0x1620,0x1620,0x1620,0x1620,0x1620,0x1620,0x1632,0x1632,0x1626,0x1623,0x1623,
-0x1623,0x1623,0x1623,0x1623,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,
-0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,
-0x162c,0x162c,0x162c,0x162c,0x1638,0x1638,0x1638,0x1638,0x1638,0x1638,0x1638,0x1638,0x1638,0x1638,0x1638,0x1638,
-0x1638,0x1638,0x1638,0x1638,0x1638,0x1638,0x1638,0x1638,0x1638,0x1638,0x1638,0x1635,0x1635,0x1635,0x1635,0x1635,
-0x1635,0x1635,0x1635,0x1635,0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,
-0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,
-0x163b,0x163b,0x163b,0x163b,0x165f,0x165f,0x165f,0x165f,0x165f,0x165f,0x165f,0x165f,0x165f,0x165f,0x165f,0x165f,
-0x165f,0x165f,0x165f,0x165f,0x165f,0x165f,0x165f,0x165f,0x165f,0x165f,0x165f,0x165f,0x165f,0x165f,0x165f,0x165f,
-0x165f,0x165f,0x165f,0x165f,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,
-0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,
-0x1668,0x1668,0x1668,0x1668,0x1680,0x1680,0x1680,0x1680,0x1680,0x1680,0x1680,0x1680,0x1680,0x1680,0x1680,0x1680,
-0x1680,0x1680,0x1680,0x1680,0x166b,0x167a,0x167a,0x166b,0x166b,0x166b,0x166b,0x166b,0x166b,0x167a,0x166b,0x167d,
-0x167d,0x166b,0x167d,0x166b,0x1680,0x1680,0x1680,0x1680,0x1680,0x1680,0x1680,0x1680,0x1680,0x1680,0x1680,0x1680,
-0x1680,0x1680,0x1680,0x1680,0x1680,0x1680,0x1680,0x1680,0x1680,0x1680,0x1680,0x1680,0x1680,0x1680,0x1680,0x1680,
-0x1680,0x1680,0x1680,0x1680,0x1689,0x1689,0x1689,0x1689,0x1689,0x1689,0x1689,0x1689,0x1689,0x1689,0x1689,0x1689,
-0x1689,0x1689,0x1689,0x1689,0x1689,0x1689,0x1689,0x1689,0x1689,0x1689,0x1689,0x1689,0x1689,0x1689,0x1689,0x1689,
-0x1689,0x1689,0x1689,0x1689,0x168f,0x168f,0x168f,0x168f,0x168f,0x168f,0x168f,0x168f,0x168f,0x168f,0x168f,0x168f,
-0x168f,0x168f,0x168f,0x168f,0x168f,0x168f,0x168f,0x168f,0x168f,0x168f,0x168f,0x168f,0x168f,0x168f,0x168f,0x168f,
-0x168f,0x168f,0x168f,0x168f,0x18ed,0x18ed,0x18ed,0x18ed,0x18ed,0x18ed,0x18ed,0x18ed,0x18ed,0x18ed,0x18ed,0x18ed,
-0x16d4,0x16d4,0x16d4,0x16d4,0x18ed,0x18ed,0x18ed,0x18ed,0x18ed,0x18ed,0x18ed,0x18ed,0x18ed,0x18ed,0x18ed,0x18ed,
-0x18ed,0x18ed,0x18ed,0x19b6,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,
-0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,
-0x16f5,0x16f5,0x16f5,0x16f5,0x1734,0x1734,0x1734,0x1734,0x1734,0x1734,0x1734,0x1734,0x1734,0x1734,0x1734,0x1734,
-0x1734,0x1734,0x1734,0x1734,0x1734,0x1734,0x1734,0x1734,0x1734,0x1734,0x1734,0x1734,0x1734,0x1734,0x1734,0x1734,
-0x1734,0x1734,0x1734,0x1734,0x1734,0x1734,0x173a,0x1737,0x1734,0x1734,0x1734,0x1734,0x1734,0x1734,0x1734,0x1734,
-0x1734,0x1734,0x1734,0x1734,0x1734,0x1734,0x1734,0x1734,0x173d,0x173d,0x173d,0x173d,0x173d,0x173d,0x173d,0x173d,
-0x173d,0x173d,0x173d,0x173d,0x173d,0x173d,0x173d,0x173d,0x173d,0x173d,0x173d,0x173d,0x173d,0x173d,0x173d,0x173d,
-0x173d,0x173d,0x173d,0x173d,0x173d,0x173d,0x173d,0x173d,0x1740,0x1740,0x1740,0x1740,0x1740,0x1740,0x1740,0x1740,
-0x1740,0x1740,0x1740,0x1740,0x1740,0x1740,0x1740,0x1740,0x1740,0x1740,0x1740,0x1740,0x1740,0x1740,0x1740,0x1740,
-0x1740,0x1740,0x1740,0x1740,0x1740,0x1740,0x1740,0x1740,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,
+0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15ea,0x15fc,0x15fc,0x15fc,0x15fc,
+0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15f9,0x15f9,0x15f9,0x15ed,
+0x15ed,0x15ed,0x15ed,0x15ed,0x15ed,0x15ed,0x15ed,0x15f9,0x15f9,0x15ed,0x15f9,0x15f0,0x15fc,0x15fc,0x15fc,0x15fc,
+0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,
+0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x15fc,0x1620,0x1620,0x1620,0x1620,
+0x1620,0x1620,0x1620,0x1620,0x1620,0x1620,0x1620,0x1620,0x1620,0x1620,0x1620,0x1620,0x1620,0x1620,0x1620,0x1620,
+0x1620,0x1620,0x1620,0x1620,0x1620,0x1620,0x1620,0x1620,0x1620,0x161d,0x161d,0x161d,0x1629,0x1629,0x1629,0x1629,
+0x1629,0x1629,0x1629,0x1629,0x1629,0x1629,0x1629,0x1629,0x1629,0x1629,0x1629,0x1629,0x1629,0x1629,0x1629,0x1629,
+0x1629,0x1629,0x162f,0x162f,0x162f,0x162c,0x162c,0x162c,0x1629,0x1629,0x1629,0x1629,0x163e,0x163e,0x163e,0x163e,
+0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x1632,0x1632,0x1632,0x1632,
+0x1632,0x1632,0x1632,0x1644,0x1644,0x1638,0x1635,0x1635,0x1635,0x1635,0x1635,0x1635,0x163e,0x163e,0x163e,0x163e,
+0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,
+0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x163e,0x164a,0x164a,0x164a,0x164a,
+0x164a,0x164a,0x164a,0x164a,0x164a,0x164a,0x164a,0x164a,0x164a,0x164a,0x164a,0x164a,0x164a,0x164a,0x164a,0x164a,
+0x164a,0x164a,0x164a,0x1647,0x1647,0x1647,0x1647,0x1647,0x1647,0x1647,0x1647,0x1647,0x164d,0x164d,0x164d,0x164d,
+0x164d,0x164d,0x164d,0x164d,0x164d,0x164d,0x164d,0x164d,0x164d,0x164d,0x164d,0x164d,0x164d,0x164d,0x164d,0x164d,
+0x164d,0x164d,0x164d,0x164d,0x164d,0x164d,0x164d,0x164d,0x164d,0x164d,0x164d,0x164d,0x1671,0x1671,0x1671,0x1671,
+0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,
+0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x167a,0x167a,0x167a,0x167a,
+0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,
+0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x1692,0x1692,0x1692,0x1692,
+0x1692,0x1692,0x1692,0x1692,0x1692,0x1692,0x1692,0x1692,0x1692,0x1692,0x1692,0x1692,0x167d,0x168c,0x168c,0x167d,
+0x167d,0x167d,0x167d,0x167d,0x167d,0x168c,0x167d,0x168f,0x168f,0x167d,0x168f,0x167d,0x1692,0x1692,0x1692,0x1692,
+0x1692,0x1692,0x1692,0x1692,0x1692,0x1692,0x1692,0x1692,0x1692,0x1692,0x1692,0x1692,0x1692,0x1692,0x1692,0x1692,
+0x1692,0x1692,0x1692,0x1692,0x1692,0x1692,0x1692,0x1692,0x1692,0x1692,0x1692,0x1692,0x169b,0x169b,0x169b,0x169b,
+0x169b,0x169b,0x169b,0x169b,0x169b,0x169b,0x169b,0x169b,0x169b,0x169b,0x169b,0x169b,0x169b,0x169b,0x169b,0x169b,
+0x169b,0x169b,0x169b,0x169b,0x169b,0x169b,0x169b,0x169b,0x169b,0x169b,0x169b,0x169b,0x16a1,0x16a1,0x16a1,0x16a1,
+0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,
+0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x16a1,0x18ff,0x18ff,0x18ff,0x18ff,
+0x18ff,0x18ff,0x18ff,0x18ff,0x18ff,0x18ff,0x18ff,0x18ff,0x16e6,0x16e6,0x16e6,0x16e6,0x18ff,0x18ff,0x18ff,0x18ff,
+0x18ff,0x18ff,0x18ff,0x18ff,0x18ff,0x18ff,0x18ff,0x18ff,0x18ff,0x18ff,0x18ff,0x19c8,0x1707,0x1707,0x1707,0x1707,
+0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,
+0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1746,0x1746,0x1746,0x1746,
+0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,
+0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x174c,0x1749,
+0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,
+0x174f,0x174f,0x174f,0x174f,0x174f,0x174f,0x174f,0x174f,0x174f,0x174f,0x174f,0x174f,0x174f,0x174f,0x174f,0x174f,
+0x174f,0x174f,0x174f,0x174f,0x174f,0x174f,0x174f,0x174f,0x174f,0x174f,0x174f,0x174f,0x174f,0x174f,0x174f,0x174f,
 0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,
-0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1755,0x1755,0x1755,0x1755,0x1755,0x1755,0x1755,0x1755,
-0x1755,0x1755,0x1755,0x1755,0x1755,0x1755,0x1755,0x1755,0x1755,0x1755,0x1755,0x1755,0x1755,0x1755,0x1755,0x1755,
-0x1755,0x1755,0x1755,0x1755,0x1755,0x1755,0x1755,0x1755,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,
-0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,
-0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x175b,0x175b,0x175b,0x175b,0x1758,
-0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x1758,0x175b,0x175b,0x175b,
-0x175b,0x175b,0x175b,0x175b,0x175b,0x1758,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,
-0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,
-0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x1773,0x1773,0x1773,0x1773,0x1773,0x1773,0x1773,0x1773,
-0x1773,0x1773,0x1773,0x1773,0x1773,0x1773,0x1773,0x1773,0x1773,0x1773,0x1773,0x1773,0x1773,0x1773,0x1773,0x1773,
-0x1773,0x1773,0x1773,0x1773,0x1773,0x1773,0x1773,0x1773,0x185d,0x185d,0x185d,0x185d,0x185d,0x185d,0x185d,0x185d,
-0x185d,0x185d,0x185d,0x185d,0x1ad3,0x1a28,0x1a28,0x1a2b,0x1776,0x1776,0x1776,0x1776,0x1776,0x1776,0x1776,0x1776,
-0x1779,0x1827,0x1827,0x1827,0x1827,0x1827,0x1827,0x18c3,0x1776,0x1776,0x1776,0x1776,0x1776,0x1824,0x1824,0x1824,
-0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,
-0x19a1,0x19a1,0x19a1,0x19a1,0x19a1,0x19a1,0x19a1,0x19a1,0x1776,0x19a1,0x19a1,0x1a28,0x1a28,0x1a28,0x1a28,0x1a28,
-0x1a28,0x1a28,0x1a28,0x1ad0,0x1ba2,0x1a2b,0x1a2b,0x1a2b,0x18c0,0x18c3,0x18c3,0x18c3,0x18c3,0x18c3,0x18c3,0x18c3,
-0x18c3,0x18c3,0x18c3,0x18c3,0x18c3,0x18c3,0x18c0,0x18c0,0x1a67,0x1a67,0x1a67,0x1a67,0x1a67,0x1a67,0x1a67,0x1a67,
-0x1b39,0x1b3c,0x1b36,0x1b36,0x1b36,0x1b36,0x1b36,0x1b36,0x1b36,0x1b36,0x1b36,0x191a,0x179d,0x179d,0x179d,0x179d,
-0x179d,0x179d,0x179d,0x179d,0x179d,0x179d,0x179d,0x179d,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1827,0x1824,
-0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x1827,0x18c3,0x18c3,0x1827,0x1827,0x1827,0x1827,0x1827,
-0x1827,0x1827,0x1824,0x17a6,0x1827,0x1827,0x1827,0x1a28,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x17a6,0x1824,
-0x1824,0x1824,0x1824,0x1824,0x18c0,0x19a1,0x19a1,0x19a1,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,
-0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x18c0,0x17bb,0x17bb,0x17b8,0x17b8,0x17b8,0x17b8,0x17b8,0x17b8,
-0x17b8,0x17b8,0x17b8,0x17b8,0x17b8,0x17b8,0x17b8,0x17b8,0x17b8,0x17b8,0x17b8,0x17b8,0x17b8,0x17b8,0x17b8,0x17b8,
-0x17b8,0x17b8,0x17b8,0x17b8,0x17b8,0x17b8,0x17b8,0x17b8,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,
-0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,
-0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,
-0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,0x1806,0x1806,0x1806,
-0x17f1,0x17f1,0x17f1,0x17f1,0x17f1,0x17f1,0x17f1,0x17f1,0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,
-0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,
-0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,0x182d,0x182d,0x182d,0x182d,0x182d,0x182d,0x182d,0x182d,
-0x182d,0x182d,0x182d,0x182d,0x182d,0x182d,0x182d,0x182d,0x182d,0x182d,0x182d,0x182d,0x182d,0x182d,0x182d,0x182d,
-0x182d,0x182d,0x182d,0x182d,0x182d,0x182d,0x182d,0x182d,0x1830,0x1830,0x1830,0x1830,0x1830,0x1830,0x1830,0x1830,
-0x1830,0x1830,0x1830,0x1830,0x1830,0x1830,0x1830,0x1830,0x1830,0x1830,0x1830,0x1830,0x1830,0x1830,0x1830,0x1830,
-0x1830,0x1830,0x1830,0x1830,0x1830,0x1830,0x1830,0x1830,0x1830,0x1830,0x1830,0x1adc,0x1adc,0x1adc,0x1adc,0x1adc,
-0x1adc,0x1adc,0x1adc,0x1adc,0x1adc,0x1adc,0x1adc,0x1adc,0x1887,0x1887,0x1887,0x1887,0x19da,0x19da,0x188a,0x188a,
-0x188a,0x188a,0x1872,0x1872,0x1872,0x1872,0x1872,0x1872,0x1872,0x1872,0x1872,0x1872,0x1872,0x1872,0x1872,0x1884,
-0x1875,0x1878,0x187b,0x188d,0x188d,0x192c,0x187e,0x187e,0x1887,0x1887,0x1887,0x1887,0x1887,0x1887,0x1887,0x1887,
-0x1887,0x1887,0x1887,0x1887,0x1887,0x1887,0x1887,0x1887,0x1887,0x1887,0x1887,0x1887,0x1887,0x1887,0x1887,0x1887,
-0x1887,0x1887,0x1887,0x1887,0x1887,0x1887,0x1887,0x1887,0x18a8,0x18a8,0x18a8,0x18a8,0x18a8,0x18a8,0x18a8,0x18a8,
-0x18a8,0x18a8,0x18a8,0x18a8,0x18a8,0x18a8,0x18a8,0x18a8,0x18a8,0x18a8,0x18a8,0x1893,0x1899,0x1896,0x1896,0x1896,
-0x1896,0x18a5,0x18ab,0x1896,0x1896,0x1896,0x1896,0x18a2,0x18a8,0x1896,0x1896,0x1896,0x1896,0x1896,0x1896,0x1896,
-0x1896,0x1896,0x1896,0x18a8,0x18a8,0x18a8,0x18a8,0x18a8,0x18a8,0x18a8,0x18a8,0x18a8,0x18a8,0x18a8,0x18a8,0x18a8,
-0x18a8,0x18a8,0x18a8,0x18a8,0x18a8,0x18a8,0x18a8,0x18a8,0x18b4,0x18b4,0x18b4,0x18b4,0x18b4,0x18b4,0x18b4,0x18b4,
-0x18b4,0x18b4,0x18b4,0x199b,0x199b,0x199b,0x199b,0x199b,0x1ac7,0x1ac7,0x1ac7,0x1ac7,0x1ac7,0x1ac7,0x1ac7,0x1ac7,
-0x1ac7,0x1ac7,0x1ac7,0x1ac7,0x1ac7,0x1b93,0x1b93,0x1b93,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,
+0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,
+0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,
+0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,0x1764,
+0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,
+0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,
+0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,
+0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,
+0x176a,0x176a,0x176a,0x176d,0x176d,0x176d,0x176d,0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,0x176a,
+0x176a,0x176a,0x176a,0x176a,0x176a,0x176d,0x176d,0x176d,0x176d,0x176d,0x176d,0x176d,0x176d,0x176a,0x176d,0x176d,
+0x176d,0x176d,0x176d,0x176d,0x176d,0x176d,0x176d,0x176d,0x176d,0x176d,0x176d,0x176d,0x176d,0x176d,0x176d,0x176d,
+0x176d,0x176d,0x176d,0x176d,0x176d,0x176d,0x176d,0x176d,0x176d,0x176d,0x176d,0x176d,0x176d,0x176d,0x176d,0x176d,
+0x1785,0x1785,0x1785,0x1785,0x1785,0x1785,0x1785,0x1785,0x1785,0x1785,0x1785,0x1785,0x1785,0x1785,0x1785,0x1785,
+0x1785,0x1785,0x1785,0x1785,0x1785,0x1785,0x1785,0x1785,0x1785,0x1785,0x1785,0x1785,0x1785,0x1785,0x1785,0x1785,
+0x186f,0x186f,0x186f,0x186f,0x186f,0x186f,0x186f,0x186f,0x186f,0x186f,0x186f,0x186f,0x1ae5,0x1a3a,0x1a3a,0x1a3d,
+0x1788,0x1788,0x1788,0x1788,0x1788,0x1788,0x1788,0x1788,0x178b,0x1839,0x1839,0x1839,0x1839,0x1839,0x1839,0x18d5,
+0x1788,0x1788,0x1788,0x1788,0x1788,0x1836,0x1836,0x1836,0x1836,0x1836,0x1836,0x1836,0x1836,0x1836,0x1836,0x1836,
+0x1836,0x1836,0x18d2,0x18d2,0x18d2,0x18d2,0x18d2,0x18d2,0x19b3,0x19b3,0x19b3,0x19b3,0x19b3,0x19b3,0x19b3,0x19b3,
+0x1788,0x19b3,0x19b3,0x1a3a,0x1a3a,0x1a3a,0x1a3a,0x1a3a,0x1a3a,0x1a3a,0x1a3a,0x1ae2,0x1bb4,0x1a3d,0x1a3d,0x1a3d,
+0x18d2,0x18d5,0x18d5,0x18d5,0x18d5,0x18d5,0x18d5,0x18d5,0x18d5,0x18d5,0x18d5,0x18d5,0x18d5,0x18d5,0x18d2,0x18d2,
+0x1a79,0x1a79,0x1a79,0x1a79,0x1a79,0x1a79,0x1a79,0x1a79,0x1b4b,0x1b4e,0x1b48,0x1b48,0x1b48,0x1b48,0x1b48,0x1b48,
+0x1b48,0x1b48,0x1b48,0x192c,0x17af,0x17af,0x17af,0x17af,0x17af,0x17af,0x17af,0x17af,0x17af,0x17af,0x17af,0x17af,
+0x1836,0x1836,0x1836,0x1836,0x1836,0x1836,0x1839,0x1836,0x18d2,0x18d2,0x18d2,0x18d2,0x18d2,0x18d2,0x18d2,0x18d2,
+0x1839,0x18d5,0x18d5,0x1839,0x1839,0x1839,0x1839,0x1839,0x1839,0x1839,0x1836,0x17b8,0x1839,0x1839,0x1839,0x1a3a,
+0x1836,0x1836,0x1836,0x1836,0x1836,0x1836,0x17b8,0x1836,0x1836,0x1836,0x1836,0x1836,0x18d2,0x19b3,0x19b3,0x19b3,
+0x1836,0x1836,0x1836,0x1836,0x1836,0x1836,0x1836,0x1836,0x1836,0x1836,0x1836,0x1836,0x1836,0x1836,0x1836,0x18d2,
+0x17cd,0x17cd,0x17ca,0x17ca,0x17ca,0x17ca,0x17ca,0x17ca,0x17ca,0x17ca,0x17ca,0x17ca,0x17ca,0x17ca,0x17ca,0x17ca,
+0x17ca,0x17ca,0x17ca,0x17ca,0x17ca,0x17ca,0x17ca,0x17ca,0x17ca,0x17ca,0x17ca,0x17ca,0x17ca,0x17ca,0x17ca,0x17ca,
+0x17cd,0x17cd,0x17cd,0x17cd,0x17cd,0x17cd,0x17cd,0x17cd,0x17cd,0x17cd,0x17cd,0x17cd,0x17cd,0x17cd,0x17cd,0x17cd,
+0x17cd,0x17cd,0x17cd,0x17cd,0x17cd,0x17cd,0x17cd,0x17cd,0x17cd,0x17cd,0x17cd,0x17cd,0x17cd,0x17cd,0x17cd,0x17cd,
+0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,
+0x181b,0x181b,0x181b,0x181b,0x181b,0x1818,0x1818,0x1818,0x1803,0x1803,0x1803,0x1803,0x1803,0x1803,0x1803,0x1803,
+0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,
+0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,
+0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,
+0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,
+0x1842,0x1842,0x1842,0x1842,0x1842,0x1842,0x1842,0x1842,0x1842,0x1842,0x1842,0x1842,0x1842,0x1842,0x1842,0x1842,
+0x1842,0x1842,0x1842,0x1842,0x1842,0x1842,0x1842,0x1842,0x1842,0x1842,0x1842,0x1842,0x1842,0x1842,0x1842,0x1842,
+0x1842,0x1842,0x1842,0x1aee,0x1aee,0x1aee,0x1aee,0x1aee,0x1aee,0x1aee,0x1aee,0x1aee,0x1aee,0x1aee,0x1aee,0x1aee,
+0x1899,0x1899,0x1899,0x1899,0x19ec,0x19ec,0x189c,0x189c,0x189c,0x189c,0x1884,0x1884,0x1884,0x1884,0x1884,0x1884,
+0x1884,0x1884,0x1884,0x1884,0x1884,0x1884,0x1884,0x1896,0x1887,0x188a,0x188d,0x189f,0x189f,0x193e,0x1890,0x1890,
+0x1899,0x1899,0x1899,0x1899,0x1899,0x1899,0x1899,0x1899,0x1899,0x1899,0x1899,0x1899,0x1899,0x1899,0x1899,0x1899,
+0x1899,0x1899,0x1899,0x1899,0x1899,0x1899,0x1899,0x1899,0x1899,0x1899,0x1899,0x1899,0x1899,0x1899,0x1899,0x1899,
+0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,
+0x18ba,0x18ba,0x18ba,0x18a5,0x18ab,0x18a8,0x18a8,0x18a8,0x18a8,0x18b7,0x18bd,0x18a8,0x18a8,0x18a8,0x18a8,0x18b4,
+0x18ba,0x18a8,0x18a8,0x18a8,0x18a8,0x18a8,0x18a8,0x18a8,0x18a8,0x18a8,0x18a8,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,
 0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,
-0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,
-0x18c0,0x18c0,0x18c0,0x18c0,0x19a1,0x19a1,0x19a1,0x19a1,0x19a1,0x1a28,0x1ad0,0x19a1,0x19a1,0x19a1,0x19a1,0x1ad3,
-0x1ad0,0x1ba2,0x19a1,0x1a28,0x19a1,0x19a1,0x19a1,0x19a1,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x19a1,
-0x19a1,0x19a1,0x19a1,0x19a1,0x19a1,0x19a1,0x19a1,0x19a1,0x19a1,0x19a1,0x19a1,0x19a1,0x19a1,0x19a1,0x19a1,0x19a1,
-0x19a1,0x19a1,0x19a1,0x19a1,0x19a1,0x19a1,0x19a1,0x19a1,0x18c9,0x18c9,0x18c9,0x18c9,0x18c9,0x18c9,0x18c9,0x18c9,
-0x18c9,0x18c9,0x18c9,0x18c9,0x18c9,0x18c9,0x18c9,0x18c9,0x18c9,0x18c9,0x18c9,0x18c9,0x18c9,0x18c9,0x18c9,0x18c9,
-0x18c9,0x18c9,0x18c9,0x18c9,0x18c9,0x18c9,0x18c9,0x18c9,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,
+0x18c6,0x18c6,0x18c6,0x18c6,0x18c6,0x18c6,0x18c6,0x18c6,0x18c6,0x18c6,0x18c6,0x19ad,0x19ad,0x19ad,0x19ad,0x19ad,
+0x1ad9,0x1ad9,0x1ad9,0x1ad9,0x1ad9,0x1ad9,0x1ad9,0x1ad9,0x1ad9,0x1ad9,0x1ad9,0x1ad9,0x1ad9,0x1ba5,0x1ba5,0x1ba5,
 0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,
-0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x1ba5,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,
-0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,
-0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x1941,0x1941,0x1941,0x1941,0x1941,0x1941,0x1941,0x1941,
-0x1941,0x1941,0x1941,0x1941,0x1941,0x1941,0x1941,0x1941,0x1941,0x1941,0x1941,0x1941,0x1941,0x1941,0x1941,0x1941,
-0x1941,0x1941,0x1941,0x1941,0x1941,0x1941,0x1941,0x1941,0x195c,0x195c,0x195c,0x195c,0x195c,0x195c,0x195c,0x195c,
-0x195c,0x195c,0x195c,0x195c,0x195c,0x195c,0x195c,0x195c,0x195c,0x195c,0x195c,0x195c,0x195c,0x195c,0x195c,0x195c,
-0x195c,0x195c,0x195c,0x195c,0x195c,0x195c,0x195c,0x195c,0x1962,0x1962,0x1962,0x1962,0x1962,0x1962,0x1962,0x1962,
-0x1962,0x1962,0x1962,0x1962,0x1962,0x1962,0x1962,0x1962,0x1962,0x1962,0x1962,0x1962,0x1962,0x1962,0x1962,0x1962,
-0x1962,0x1962,0x1962,0x1962,0x1962,0x1962,0x1962,0x1962,0x197d,0x197d,0x197d,0x197d,0x197d,0x197d,0x197d,0x197d,
-0x197d,0x197d,0x197d,0x197d,0x197d,0x197d,0x197d,0x197d,0x197d,0x197d,0x197d,0x197d,0x197d,0x197d,0x197d,0x197d,
-0x197d,0x197d,0x197d,0x197d,0x197d,0x197d,0x197d,0x197d,0x1980,0x1980,0x1980,0x1980,0x1980,0x1980,0x1980,0x1980,
-0x1980,0x1980,0x1980,0x1980,0x1980,0x1980,0x1980,0x1980,0x1980,0x1980,0x1980,0x1980,0x1980,0x1980,0x1980,0x1980,
-0x1980,0x1980,0x1980,0x1980,0x1980,0x1980,0x1980,0x1980,0x1989,0x1989,0x1989,0x1989,0x1989,0x1989,0x1989,0x1989,
-0x1989,0x1989,0x1989,0x1989,0x1989,0x1989,0x1989,0x1989,0x1989,0x1989,0x1989,0x1989,0x1989,0x1989,0x1989,0x1989,
-0x1989,0x1989,0x1989,0x1989,0x1989,0x1986,0x1986,0x1986,0x19a1,0x19a1,0x19a1,0x1ad0,0x1ad0,0x1a28,0x1a28,0x1a28,
-0x1a28,0x1a28,0x1a28,0x1ad0,0x1ad0,0x1ad0,0x1a28,0x1a28,0x19a1,0x19a1,0x19a1,0x19a1,0x19a1,0x19a4,0x19a4,0x19a1,
-0x19a4,0x19a4,0x1a28,0x1a2b,0x1a28,0x1a28,0x1a28,0x1a28,0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,
-0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,
-0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,0x19dd,0x1a04,0x1a04,0x1a04,0x1a04,0x1a04,0x1a04,0x1a04,0x1a04,
-0x1a04,0x1a04,0x1a04,0x1a04,0x1a04,0x1a04,0x1a04,0x1a04,0x1a04,0x1a04,0x1a04,0x1a04,0x1a04,0x1a04,0x1a04,0x1a04,
-0x1a04,0x1a04,0x1a04,0x1a04,0x1a04,0x1a04,0x1a04,0x1a04,0x1a0d,0x1a0d,0x1a0d,0x1a0d,0x1a0d,0x1a0d,0x1a0d,0x1a0d,
-0x1a0d,0x1a0d,0x1a0d,0x1a0d,0x1a0d,0x1a0d,0x1a0d,0x1a0d,0x1a43,0x1a43,0x1a0d,0x1a43,0x1a0d,0x1a0d,0x1a0d,0x1a0d,
-0x1a0d,0x1a0d,0x1a0d,0x1a0d,0x1a0d,0x1a13,0x1a13,0x1a13,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,
+0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,0x18cc,
+0x18d2,0x18d2,0x18d2,0x18d2,0x18d2,0x18d2,0x18d2,0x18d2,0x18d2,0x18d2,0x18d2,0x18d2,0x19b3,0x19b3,0x19b3,0x19b3,
+0x19b3,0x1a3a,0x1ae2,0x19b3,0x19b3,0x19b3,0x19b3,0x1ae5,0x1ae2,0x1bb4,0x19b3,0x1a3a,0x19b3,0x19b3,0x19b3,0x19b3,
+0x18d2,0x18d2,0x18d2,0x18d2,0x18d2,0x18d2,0x18d2,0x19b3,0x19b3,0x19b3,0x19b3,0x19b3,0x19b3,0x19b3,0x19b3,0x19b3,
+0x19b3,0x19b3,0x19b3,0x19b3,0x19b3,0x19b3,0x19b3,0x19b3,0x19b3,0x19b3,0x19b3,0x19b3,0x19b3,0x19b3,0x19b3,0x19b3,
+0x18db,0x18db,0x18db,0x18db,0x18db,0x18db,0x18db,0x18db,0x18db,0x18db,0x18db,0x18db,0x18db,0x18db,0x18db,0x18db,
+0x18db,0x18db,0x18db,0x18db,0x18db,0x18db,0x18db,0x18db,0x18db,0x18db,0x18db,0x18db,0x18db,0x18db,0x18db,0x18db,
+0x18de,0x18de,0x18de,0x18de,0x18de,0x18de,0x18de,0x18de,0x18de,0x18de,0x18de,0x18de,0x18de,0x18de,0x18de,0x18de,
+0x18de,0x18de,0x18de,0x18de,0x18de,0x18de,0x18de,0x18de,0x18de,0x18de,0x18de,0x18de,0x18de,0x18de,0x18de,0x1bb7,
+0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,
+0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,0x18e1,
+0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,
+0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,0x1953,
+0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,
+0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,0x196e,
+0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,
+0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,0x1974,
+0x198f,0x198f,0x198f,0x198f,0x198f,0x198f,0x198f,0x198f,0x198f,0x198f,0x198f,0x198f,0x198f,0x198f,0x198f,0x198f,
+0x198f,0x198f,0x198f,0x198f,0x198f,0x198f,0x198f,0x198f,0x198f,0x198f,0x198f,0x198f,0x198f,0x198f,0x198f,0x198f,
+0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,
+0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,0x1992,
+0x199b,0x199b,0x199b,0x199b,0x199b,0x199b,0x199b,0x199b,0x199b,0x199b,0x199b,0x199b,0x199b,0x199b,0x199b,0x199b,
+0x199b,0x199b,0x199b,0x199b,0x199b,0x199b,0x199b,0x199b,0x199b,0x199b,0x199b,0x199b,0x199b,0x1998,0x1998,0x1998,
+0x19b3,0x19b3,0x19b3,0x1ae2,0x1ae2,0x1a3a,0x1a3a,0x1a3a,0x1a3a,0x1a3a,0x1a3a,0x1ae2,0x1ae2,0x1ae2,0x1a3a,0x1a3a,
+0x19b3,0x19b3,0x19b3,0x19b3,0x19b3,0x19b6,0x19b6,0x19b3,0x19b6,0x19b6,0x1a3a,0x1a3d,0x1a3a,0x1a3a,0x1a3a,0x1a3a,
+0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,
+0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,0x19ef,
+0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,
+0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,0x1a16,
 0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,
-0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,
-0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,
-0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1ab2,0x1abe,0x1abe,0x1abe,0x1abe,0x1abe,0x1abe,0x1abe,0x1abe,
-0x1abe,0x1abe,0x1abe,0x1abe,0x1abe,0x1abe,0x1abe,0x1abe,0x1abe,0x1abe,0x1abe,0x1abe,0x1abe,0x1abe,0x1abe,0x1abe,
-0x1abe,0x1abe,0x1abe,0x1abe,0x1abe,0x1abe,0x1abe,0x1abe,0x1ae2,0x1ae2,0x1ae2,0x1ae2,0x1ae2,0x1ae2,0x1ae2,0x1ae2,
-0x1ae2,0x1ae2,0x1ae2,0x1ae2,0x1ae2,0x1ae2,0x1ae2,0x1ae2,0x1ae2,0x1ae2,0x1ae2,0x1ae2,0x1ae2,0x1ae2,0x1ae2,0x1ae2,
-0x1ae2,0x1ae2,0x1ae2,0x1ae2,0x1ae2,0x1ae2,0x1ae2,0x1ae2,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,
-0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,
-0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1ae5,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,
-0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,
-0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b5a,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,
-0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,
-0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b7b,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,
+0x1a55,0x1a55,0x1a1f,0x1a55,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a1f,0x1a25,0x1a25,0x1a25,
+0x1a31,0x1a31,0x1a31,0x1a31,0x1a31,0x1a31,0x1a31,0x1a31,0x1a31,0x1a31,0x1a31,0x1a31,0x1a31,0x1a31,0x1a31,0x1a31,
+0x1a31,0x1a31,0x1a31,0x1a31,0x1a31,0x1a31,0x1a31,0x1a31,0x1a31,0x1a31,0x1a31,0x1a31,0x1a31,0x1a31,0x1a31,0x1a31,
+0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,
+0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,0x1ac4,
+0x1ad0,0x1ad0,0x1ad0,0x1ad0,0x1ad0,0x1ad0,0x1ad0,0x1ad0,0x1ad0,0x1ad0,0x1ad0,0x1ad0,0x1ad0,0x1ad0,0x1ad0,0x1ad0,
+0x1ad0,0x1ad0,0x1ad0,0x1ad0,0x1ad0,0x1ad0,0x1ad0,0x1ad0,0x1ad0,0x1ad0,0x1ad0,0x1ad0,0x1ad0,0x1ad0,0x1ad0,0x1ad0,
+0x1af4,0x1af4,0x1af4,0x1af4,0x1af4,0x1af4,0x1af4,0x1af4,0x1af4,0x1af4,0x1af4,0x1af4,0x1af4,0x1af4,0x1af4,0x1af4,
+0x1af4,0x1af4,0x1af4,0x1af4,0x1af4,0x1af4,0x1af4,0x1af4,0x1af4,0x1af4,0x1af4,0x1af4,0x1af4,0x1af4,0x1af4,0x1af4,
+0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,
+0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,0x1af7,
+0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,
+0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,0x1b6c,
+0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,
 0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,
-0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b8d,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,
-0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,
-0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0x1b90,0,0,0,0
+0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,
+0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,0x1b9f,
+0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,
+0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,0x1ba2,
+0x1bfc,0x1bfc,0x1bfc,0x1bfc,0x1bfc,0x1bfc,0x1bfc,0x1bfc,0x1bfc,0x1bfc,0x1bfc,0x1bfc,0x1bfc,0x1bfc,0x1bfc,0x1bfc,
+0x1bfc,0x1bf9,0x1bf9,0x1bf9,0x1bf9,0x1bf9,0x1bf9,0x1bf9,0x1bf9,0x1bf9,0x1bf9,0x1bf9,0x1bf9,0x1bf9,0x1bf9,0x1bf9,
+0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,
+0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,0x1c3b,
+0,0,0,0
 };
 
 static const UTrie2 propsVectorsTrie={
     propsVectorsTrie_index,
-    propsVectorsTrie_index+5188,
+    propsVectorsTrie_index+5348,
     NULL,
-    5188,
-    26872,
+    5348,
+    27344,
     0xa40,
-    0x14c4,
+    0x1564,
     0x0,
     0x0,
     0x110000,
-    0x7d38,
-    NULL, 0, FALSE, FALSE, 0, NULL
+    0x7fb0,
+    NULL, 0, false, false, 0, NULL
 };
 
-static const uint32_t propsVectors[7095]={
+static const uint32_t propsVectors[7230]={
 0x67,0,0,0x67,0,0xe00000,0x67,0x80000,0x20,0x867,0,0,0xa67,0,0,0xb67,
 0,0,0xd67,0,0,0xe67,0,0,0x1067,0,0,0x1167,0,0,0x1267,0,
 0,0x1367,0,0,0x1467,0,0,0x1567,0,0,0x1667,0,0,0x1767,0,0,
@@ -3493,429 +3554,437 @@ static const uint32_t propsVectors[7095]={
 0,0xad67,0,0,0xae67,0,0,0xaf67,0,0,0xb167,0,0,0xb267,0,0,
 0xb467,0,0,0xb567,0,0,0xb767,0,0,0xb867,0,0,0xb967,0,0,0xba67,
 0,0,0xbc67,0,0,0xbd67,0,0,0xbe67,0,0,0xbf67,0,0,0xc067,0,
-0,0xc167,0,0,0xc267,0,0,0xc367,0,0xe00000,0xc467,0,0xe00000,0xc667,0,0,
-0xc767,0,0,0xc867,0,0,0xc967,0,0,0xca67,0,0,0xcc67,0,0xe00000,0xcf67,
-0,0xe00000,0xd067,0,0xe00000,0xd367,0,0,0xd467,0,0,0xd567,0,0,0xd667,0,
-0,0xd867,0,0,0xda67,0,0,0xdb67,0,0,0xdc67,0,0,0xdd67,0,0,
-0xde67,0,0,0xdf67,0,0,0xe067,0,0,0xe167,0,0,0xe267,0,0,0xe367,
-0,0xe00000,0xe467,0,0,0xe567,0,0,0xe667,0,0,0xe767,0,0,0xe867,0,
-0,0xe967,0,0,0xea67,0,0,0xeb67,0,0,0xec67,0,0,0xed67,0,0,
-0xee67,0,0,0xef67,0,0,0xf167,0,0,0xf367,0,0,0xf567,0,0,0xf667,
-0,0,0xf767,0,0,0xf867,0,0,0xf967,0,0,0xfa67,0,0xe00000,0xfb67,0,
-0,0xfc67,0,0,0xfd67,0,0,0xfe67,0,0,0x10167,0,0,0x10267,0,0,
-0x10367,0,0,0x10467,0,0,0x10667,0,0,0x10767,0,0,0x10867,0,0,0x10967,
-0,0,0x10a67,0,0,0x10b67,0,0,0x10c67,0,0,0x10d67,0,0,0x10e67,0,
-0,0x10f67,0,0,0x11067,0,0,0x11367,0,0,0x11467,0,0,0x11567,0,0,
-0x11667,0,0,0x11767,0,0,0x11867,0,0,0x11967,0,0xe00000,0x11a67,0,0,0x11b67,
-0,0,0x11c67,0,0,0x11d67,0,0,0x11e67,0,0,0x11f67,0,0,0x12067,0,
-0,0x12167,0,0,0x12267,0,0,0x12367,0,0,0x12467,0,0,0x12567,0,0,
-0x12667,0,0,0x12767,0,0,0x12867,0,0,0x12967,0,0,0x12a67,0,0xe00000,0x12b67,
-0,0,0x12c67,0,0,0x12d67,0,0,0x12f67,0,0,0x13067,0,0,0x13167,0,
-0,0x13267,0,0,0x13367,0,0,0x13467,0,0,0x13567,0,0,0x13667,0,0,
-0x13767,0,0,0x13867,0,0,0x13967,0,0,0x13a67,0,0,0x13b67,0,0,0x13c67,
-0,0,0x13d67,0,0,0x13f67,0,0,0x14067,0,0,0xa0067,0,0xe00000,0xa4f67,0,
-0xe00000,0xa5f67,0,0xe00000,0xac567,0,0xe00000,0xad167,0,0xe00000,0xb0067,0,0xe00000,0xb1267,0,0xe00000,
-0xb2e67,0,0xe00000,0x11000100,0,0x900020,0x11000100,0x40000001,0x440020,0x11000100,0x40000001,0x643020,0x11000100,0x40000001,0xa5a040,0x11000100,
-0x40000001,0x116a8a0,0x11000200,0,0x900020,0x11000200,0x4000001,0xc4000b,0x11000200,0x7c00100,0x220402,0x11000200,0x24000000,0x200000,0x11000200,0x24000008,
-0x1710000,0x11000200,0x40000001,0x1d3b020,0x11000219,0x7c00100,0x220401,0x11000219,0x7c00100,0x250401,0x11000319,0x7c00100,0x220401,0x11000319,0x7c00100,0x220402,
-0x11000319,0x7c00100,0x250400,0x11000319,0x7c00100,0x250401,0x11000419,0x7c00100,0x220400,0x11000419,0x7c00100,0x220401,0x11000419,0x7c00100,0x220402,0x11000419,
-0x7c00100,0x230400,0x11000419,0x7c00100,0x250400,0x11000419,0x7c00100,0x250401,0x11000419,0x7c00100,0x250402,0x11000519,0x7c00100,0x220400,0x11000519,0x7c00100,
-0x230400,0x11000600,0x4000400,0x200002,0x11000600,0x4000400,0x200400,0x11000600,0x7c00500,0x220400,0x11000600,0x7c00500,0x230400,0x11000600,0x7c00500,0x530400,
-0x11000600,0x7c00d00,0x230400,0x11000619,0x7c00500,0x22040f,0x11000800,0x4000010,0x1001401,0x11000800,0x4000400,0x200001,0x11000800,0x6800010,0x201001,0x11000800,
-0x7c00500,0x230401,0x11000807,0x7c00100,0x220400,0x11000807,0x7c00100,0x250400,0x1100080e,0x4000400,0x200000,0x1100080e,0x4000400,0x200002,0x1100080e,0x7000500,
-0x220402,0x1100080e,0x7c00100,0x220400,0x1100080e,0x7c00100,0x220401,0x1100080e,0x7c00100,0x220402,0x1100080e,0x7c00100,0x250400,0x1100080e,0x7c00100,0x250401,
-0x1100080e,0x7c00120,0x220402,0x1100080e,0x7c00120,0x250402,0x11000908,0x4000000,0x200000,0x11000908,0x7c00100,0x220400,0x11000908,0x7c00100,0x220401,0x11000908,
-0x7c00100,0x250400,0x11000908,0x7c00100,0x250401,0x11000a03,0x4000000,0x200400,0x11000a03,0x4000000,0x201000,0x11000a03,0x4000000,0x270000,0x11000a03,0x7c00100,
-0x220400,0x11000a03,0x7c00100,0x220402,0x11000a03,0x7c00100,0x250400,0x11000a03,0x7c00500,0x230400,0x11000a03,0xc000010,0x1049400,0x11000b13,0x2802500,0x962460,
-0x11000b13,0x4000000,0x200000,0x11000b13,0x4000000,0x201000,0x11000b13,0x4000000,0x230400,0x11000b13,0x4000002,0x400000,0x11000b13,0x4000010,0x200000,0x11000b13,
-0x7c00100,0x2633800,0x11000c00,0x80000000,0x218960,0x11000c02,0x2802100,0x962460,0x11000c02,0x2802400,0x962460,0x11000c02,0x4000000,0x200000,0x11000c02,0x4000000,
-0x1329400,0x11000c02,0x4000000,0x1329800,0x11000c02,0x4000000,0x1500000,0x11000c02,0x6800000,0x1329800,0x11000c02,0x7c00100,0x230400,0x11000c02,0x7c00100,0x230401,
-0x11000c02,0x7c00100,0x230402,0x11000c02,0x7c00500,0x230400,0x11000c02,0x7d00100,0x230400,0x11000f01,0x2802400,0x962460,0x11000f0a,0x2802100,0x962460,0x11000f0a,
-0x2802400,0x962460,0x11000f0a,0x2806400,0x962460,0x11000f0a,0x4000000,0x200000,0x11000f0a,0x6800100,0x962540,0x11000f0a,0x7c00100,0x230400,0x11000f0a,0x7c00100,
-0x230401,0x11001004,0x2802100,0x962460,0x11001004,0x2802400,0x962460,0x11001004,0x2806400,0x962460,0x11001004,0x4000000,0x200000,0x11001004,0x4000000,0x1500000,
-0x11001004,0x6800100,0x962540,0x11001004,0x6800100,0x962541,0x11001004,0x7c00100,0x230400,0x11001004,0x7c00100,0x230401,0x11001110,0x2802100,0x962460,0x11001110,
-0x2802400,0x962460,0x11001110,0x2806400,0x962460,0x11001110,0x6800100,0x962540,0x11001110,0x7c00100,0x230400,0x11001110,0x7c00100,0x230401,0x1100120f,0x2802100,
-0x962460,0x1100120f,0x2802400,0x962460,0x1100120f,0x2806400,0x962460,0x1100120f,0x6800100,0x962540,0x1100120f,0x7c00100,0x230400,0x1100131f,0x2802100,0x962460,
-0x1100131f,0x2802400,0x962460,0x1100131f,0x2806400,0x962460,0x1100131f,0x4000000,0x200000,0x1100131f,0x6800000,0x1329800,0x1100131f,0x6800100,0x962540,0x1100131f,
-0x6800100,0x962541,0x1100131f,0x7c00100,0x230400,0x1100131f,0x7c00100,0x230401,0x11001423,0x2802100,0x962460,0x11001423,0x2806400,0x962460,0x11001423,0x6800100,
-0x962540,0x11001423,0x6800100,0x962541,0x11001423,0x7c00100,0x230400,0x11001423,0x7c00100,0x230401,0x11001524,0x2802100,0x962460,0x11001524,0x2802100,0x962461,
-0x11001524,0x2806400,0x962460,0x11001524,0x6800000,0x1329800,0x11001524,0x6800100,0x962540,0x11001524,0x7c00100,0x230400,0x11001615,0x2802100,0x962460,0x11001615,
-0x2806400,0x962460,0x11001615,0x6800100,0x962540,0x11001615,0x6800100,0x962541,0x11001615,0x7c00100,0x230400,0x1100171a,0x2802100,0x962460,0x1100171a,0x2806400,
-0x962460,0x1100171a,0x6800000,0x1329800,0x1100171a,0x6800100,0x962540,0x1100171a,0x6800100,0x962541,0x1100171a,0x7c00100,0x230400,0x11001900,0x4000000,0x1600000,
-0x11001926,0x2802100,0x1862460,0x11001926,0x2802400,0x1862460,0x11001926,0x2806100,0x1862460,0x11001926,0x4000000,0x200000,0x11001926,0x4000010,0x400000,0x11001926,
-0x6800000,0x1329800,0x11001926,0x7800100,0x1830142,0x11001926,0x7c00100,0x1830000,0x11001926,0x7c00900,0x1830000,0x11001926,0x7e00100,0x1830000,0x11001a18,0x2802100,
-0x1862460,0x11001a18,0x2802400,0x1862460,0x11001a18,0x6800000,0x1329800,0x11001a18,0x7800100,0x1830142,0x11001a18,0x7c00100,0x1830000,0x11001a18,0x7c00100,0x1830002,
-0x11001a18,0x7c00900,0x1830000,0x11001a18,0x7e00100,0x1830000,0x11001d0c,0x7c00100,0x230400,0x11001d0c,0x7c00100,0x250400,0x11001e12,0x7c00100,0x2230500,0x11001e12,
-0x7c00100,0x2330520,0x11001e12,0x7c80100,0x2330520,0x11002619,0x7c00100,0x220401,0x11002619,0x7c00100,0x220402,0x11002619,0x7c00100,0x250401,0x1100270e,0x4000400,
-0x200001,0x1100270e,0x4000400,0x200002,0x1100270e,0x4000400,0x500001,0x1100270e,0x7c00100,0x220401,0x1100270e,0x7c00100,0x250401,0x11002800,0x80000,0x918820,
-0x11002800,0x80000,0x1c18020,0x11002800,0x180000,0x918820,0x11002800,0x4000001,0x445801,0x11002800,0x4000001,0x445802,0x11002800,0x4000001,0xc4000b,0x11002800,
-0x6800000,0x201c00,0x11002800,0x6800020,0x201c00,0x11002800,0x24000000,0x200000,0x11002800,0x24000000,0x200002,0x11002800,0x24000000,0x810000,0x11002800,0x24000000,
-0x1410000,0x11002800,0x24000000,0x1500000,0x11002800,0x24000000,0x1500002,0x11002800,0x24000002,0x400000,0x11002800,0x24000006,0xc0000b,0x11002800,0x24000008,0x1410000,
-0x11002800,0x24000008,0x1710000,0x11002800,0x24000020,0x1001400,0x11002800,0x24000020,0x1500002,0x11002800,0x2c000010,0x1248000,0x11002800,0x2c000010,0x1248002,0x11002800,
-0x40000001,0x63b020,0x11002800,0x40080000,0x918820,0x11002801,0x80000,0x2a65620,0x11002801,0x82000,0x962460,0x11002900,0x4000000,0x20000e,0x11002900,0x4000000,
-0x20000f,0x11002900,0x4000020,0x20000e,0x11002900,0x4000020,0x20000f,0x11002900,0x4000020,0x81000e,0x11002900,0x4000020,0x81000f,0x11002900,0x4000020,0x141000e,
-0x11002900,0x4000020,0x141000f,0x11002900,0x4000022,0x20000e,0x11002900,0x4000022,0x20000f,0x11002a00,0x4000000,0x1500000,0x11002a00,0x4000000,0x1600000,0x11002a00,
-0x4000000,0x1600002,0x11002b01,0x2000,0x962460,0x11002b01,0x2802020,0x962460,0x11002c00,0x4000000,0x200000,0x11002c00,0x4000000,0x200002,0x11002c00,0x4000000,
-0x20000f,0x11002c00,0x4000020,0x200000,0x11002c00,0x7c00000,0x200000,0x11002c00,0x7c00020,0x200000,0x11002c00,0x7c00120,0x220405,0x11002c00,0x7c00120,0x230402,
-0x11002c00,0x7c00120,0x250402,0x11002c00,0x7c00120,0x250405,0x11002c19,0x7c00100,0x250400,0x11002c19,0x7c00100,0x250401,0x11002d00,0x4000000,0x100006,0x11002d00,
-0x4000000,0x200006,0x11002d19,0x7c00100,0x220402,0x11002d19,0x7c00100,0x230400,0x11002d19,0x7c00100,0x250402,0x11002e00,0x24000000,0x200000,0x11002e00,0x24000020,
-0x200000,0x11002e00,0x24000020,0x200001,0x11002f00,0x24000020,0x200000,0x11002f00,0x24000020,0x200001,0x11002f00,0x24000020,0x200002,0x11002f00,0x24000020,0xf00000,
-0x11002f00,0x24000020,0x1600000,0x11002f00,0x24000022,0x1600000,0x11003000,0x24000000,0x200000,0x11003000,0x24000020,0x200000,0x11003000,0x24000020,0x810000,0x11003000,
-0x24000020,0x1410000,0x11003100,0x24000000,0x200000,0x11003200,0x24000000,0x200000,0x11003300,0x4000000,0x100003,0x11003400,0x24000000,0x100000,0x11003400,0x24000000,
-0x200000,0x11003500,0x24000000,0x200000,0x11003600,0x24000000,0x200000,0x11003600,0x24000020,0x200000,0x11003700,0x24000000,0x200000,0x11003700,0x24000000,0xe00000,
-0x11003700,0x24000000,0x2800000,0x11003700,0x24000020,0x200000,0x11003800,0x4000000,0x100000,0x11003800,0x24000000,0x200000,0x11003800,0x24000000,0xb00000,0x11003800,
-0x24000000,0xe00000,0x11003800,0x24000000,0x1710000,0x11003800,0x24000000,0x2800000,0x11005003,0x7c00100,0x220402,0x11005013,0x2802500,0x962460,0x11005013,0x4000020,
-0x200005,0x11005013,0x7c00100,0x2633801,0x11005013,0x7c00100,0x2633802,0x11005013,0x7c00100,0x2633805,0x11005019,0x7c00100,0x220402,0x11005102,0x7000100,0x230408,
-0x11005102,0x7c00100,0x230404,0x11005102,0x7c00100,0x230407,0x11005102,0x7c00100,0x230408,0x11005102,0x7c00100,0x230409,0x11005201,0x2802400,0x962460,0x11005500,
-0x80000,0x1e18820,0x11005502,0x7000100,0x230408,0x11005502,0x7c00100,0x230404,0x11005502,0x7c00100,0x230407,0x11005502,0x7c00100,0x230408,0x11005502,0x7c00100,
-0x230409,0x11005667,0x1000,0,0x11020200,0x80004,0x418820,0x11020200,0x4000000,0x100006,0x11020200,0x4000000,0x10000f,0x11020200,0x4000400,0x100002,
-0x11020200,0x4000400,0x500002,0x11020200,0x6800c00,0x101000,0x11020200,0x24000000,0x100000,0x11020200,0x24000000,0x200000,0x11020200,0x24000000,0x1400000,0x11020200,
-0x24000000,0x1500000,0x11020200,0x24000000,0x1600000,0x11020200,0x24000020,0x100000,0x11020200,0x24000020,0x1600000,0x11020219,0x7c00100,0x12040f,0x11020219,0x7c00100,
-0x220400,0x11020219,0x7c00100,0x220401,0x11020219,0x7c00100,0x250400,0x11020319,0x7c00100,0x220400,0x11020319,0x7c00100,0x220401,0x11020319,0x7c00100,0x220402,
-0x11020319,0x7c00100,0x250400,0x11020319,0x7c00100,0x250402,0x11020319,0x7d00100,0x220402,0x11020419,0x7c00100,0x220401,0x11020519,0x7c00100,0x220400,0x11020600,
-0x4000400,0x100002,0x11020600,0x4000400,0x200400,0x11020600,0x7c00500,0x130400,0x11020600,0x7c00d00,0x130400,0x11020701,0x2802400,0x962460,0x11020701,0x2802400,
-0x962461,0x11020701,0x2802400,0xc62460,0x1102080e,0x7c00100,0x220400,0x1102080e,0x7c00100,0x250400,0x11020908,0x7c00100,0x220400,0x11020908,0x7c00100,0x220401,
-0x11020908,0x7c00100,0x250400,0x11020908,0x7c00100,0x250401,0x11022800,0x24000000,0x100000,0x11022800,0x24000000,0x200000,0x11022800,0x24000000,0x200002,0x11022800,
-0x24000000,0x401000,0x11022800,0x24000000,0xf00002,0x11022800,0x24000000,0xf0ac02,0x11022800,0x24000000,0x1500000,0x11022800,0x24000002,0x100000,0x11022800,0x24000002,
-0x370000,0x11022800,0x24000002,0x470000,0x11022800,0x24000006,0x400000,0x11022800,0x24000008,0x1710000,0x11022800,0x24000008,0x1712c00,0x11022800,0x24000020,0x100000,
-0x11022800,0x24000020,0x1500000,0x11022800,0x24000020,0x1500002,0x11022900,0x4000000,0x10000e,0x11022900,0x4000000,0x10000f,0x11022919,0x7c00100,0x12040f,0x11022c00,
-0x4000000,0x100002,0x11022c00,0x4000000,0x10000f,0x11022c00,0x4000000,0x1500002,0x11022c00,0x4000000,0x1600002,0x11022c00,0x7c00120,0x120405,0x11022c0e,0x7c00100,
-0x250401,0x11022c19,0x7c00100,0x150401,0x11022d00,0x4000000,0x100006,0x11022d00,0x4000000,0x200006,0x11022d19,0x7c00100,0x120402,0x11022d19,0x7c00100,0x150402,
-0x11022e00,0x24000000,0x200000,0x11022e00,0x24000020,0x100000,0x11022f00,0x24000020,0x100000,0x11022f00,0x24000020,0x100001,0x11022f00,0x24000020,0x100002,0x11023000,
-0x24000000,0x100000,0x11023300,0x4000000,0x100002,0x11023300,0x4000000,0x100003,0x11023300,0x4000100,0x120403,0x11023300,0x4000100,0x150403,0x11023400,0x24000000,
-0x100000,0x11023500,0x24000000,0x100000,0x11023600,0x24000000,0x100000,0x11023600,0x24000020,0x100000,0x11023700,0x24000000,0x100000,0x11023700,0x24000000,0xe00000,
-0x11023700,0x24000020,0x100000,0x11023800,0x4000000,0x100000,0x11023800,0x24000000,0x200000,0x11024e67,0,0,0x11025600,0x4000000,0x100000,0x11042a00,
-0x4000000,0x1600000,0x11045700,0x4000000,0x20000a,0x11045700,0x4000020,0x20000a,0x11045712,0x7c00100,0xe3040a,0x11045712,0x7c80100,0xe3040a,0x11045716,0x7c00100,
-0xe30c0a,0x11045716,0x7c00100,0x2530c0a,0x11063d00,0x4000001,0x445811,0x11065700,0x4000000,0x810011,0x11065700,0x4000000,0xe00011,0x11065700,0x4000000,0x1410011,
-0x11065700,0x4000000,0x1500011,0x11065700,0x4000000,0x1600011,0x11065700,0x4000006,0xe70011,0x11065700,0x4000008,0xe00011,0x11065700,0x4000008,0xe02c11,0x11065700,
-0x4000010,0x871411,0x11065700,0x4000010,0x1201411,0x11065700,0x4000010,0x1271011,0x11065700,0x4000020,0xe00011,0x11065700,0x4000400,0xe00011,0x11065700,0x4000420,
-0xe00011,0x11065700,0x6800000,0xe01c11,0x11065700,0x6800040,0xe29811,0x11065700,0xc000010,0x80ac11,0x11065700,0xc000010,0xb48011,0x11065719,0x7c00100,0xe20411,
-0x11065719,0x7c00100,0xe50411,0x11065719,0x7c00140,0xe20411,0x11065719,0x7c00140,0xe50411,0x11080100,0x6800000,0x201c00,0x11080100,0x68000c0,0x1329800,0x11080100,
-0x24000000,0x200000,0x11080100,0x24000000,0x810000,0x11080100,0x24000000,0x1410000,0x11080100,0x24000000,0x1500000,0x11080100,0x24000000,0x1600000,0x11080100,0x24000000,
-0x1b00000,0x11080100,0x24000000,0x2410000,0x11080100,0x24000006,0xd70000,0x11080100,0x24000008,0x1713c00,0x11080100,0x24000008,0x1714000,0x11080100,0x24000010,0x1001400,
-0x11080100,0x24000010,0x1071000,0x11080100,0x24000010,0x1071400,0x11080100,0x24000020,0x200000,0x11080100,0x24000020,0x400000,0x11080100,0x24000020,0x1600000,0x11080100,
-0x24000400,0x200000,0x11080100,0x24000420,0x200000,0x11080100,0x2c000010,0xb48000,0x11080100,0x2c000010,0x100ac00,0x11080100,0x44000001,0x1a45800,0x11080119,0x7c00100,
-0x220400,0x11080119,0x7c00100,0x250400,0x11080119,0x7c001c0,0x220400,0x11080119,0x7c001c0,0x250400,0x11080200,0x4000400,0x200002,0x11080200,0x24000000,0x200000,
-0x11080200,0x24000000,0x1500000,0x11080200,0x24000000,0x1600000,0x11080200,0x24000020,0x200000,0x110a1e12,0x7c00100,0x2130480,0x110a1e12,0x7c80100,0x2130480,0x110a3000,
-0x24000000,0xe00000,0x110a3000,0x24100000,0x810001,0x110a3000,0x24100000,0x1410001,0x110a3700,0x24000000,0x200000,0x110a3d00,0x4000000,0xe00000,0x110a3d00,0x4000000,
-0xe00002,0x110a3d00,0x24000000,0xe00000,0x110a3d11,0x7c00300,0xe30000,0x110a3d11,0x7c00900,0x1230400,0x110a3d12,0x2802400,0x962460,0x110a3e14,0x7c00100,0xe30000,
-0x110a3e14,0x7c00100,0xe30001,0x110a3e14,0x7c00100,0x2530000,0x110a3e14,0x7c00900,0x1230000,0x110a3e14,0x7c00900,0x1230001,0x110a3f16,0x7c00100,0xe30c00,0x110a3f16,
-0x7c00100,0xe30c01,0x110a3f16,0x7c00100,0x2530c00,0x110a3f16,0x7c00900,0x1230c00,0x110a3f16,0x7c00900,0x1230c01,0x110a4005,0x7c00100,0xe30400,0x110a4112,0x7c00100,
-0xe30402,0x110a4112,0x7c80100,0xe30402,0x110a4400,0x4000000,0xe00000,0x110a4412,0x4000000,0xe00002,0x110a4412,0x4000000,0xe00003,0x110a4416,0x4000000,0xe00c03,
-0x110a4500,0x4000000,0xe0000d,0x110a4516,0x4000000,0xe00c0d,0x110a4711,0x7c40300,0xe30000,0x110a4f11,0x7c00300,0xe30001,0x110a4f11,0x7c40300,0xe30000,0x110a5300,
-0x4000000,0x810010,0x110a5300,0x4000000,0xe00002,0x110a5300,0x4000000,0xe00010,0x110a5300,0x4000000,0x1410010,0x110a5300,0x4000002,0xe70010,0x110a5300,0x4000008,
-0x810010,0x110a5300,0x4000008,0x1410010,0x110a5300,0x6800000,0xe01c02,0x110a5300,0x6800000,0xe01c10,0x110a5400,0x4000000,0x81000c,0x110a5400,0x4000000,0xe0000c,
-0x110a5400,0x4000000,0x141000c,0x110a5400,0x4000000,0x150000c,0x110a5400,0x4000000,0x160000c,0x110a5400,0x4000002,0xe7000c,0x110a5400,0x4000010,0x87140c,0x110a5400,
-0x4000010,0xe7000c,0x110a5400,0x4000010,0x120140c,0x110a5400,0x4000010,0x127100c,0x110a5400,0x4000020,0xe0000c,0x110a5400,0x4000026,0xe7000c,0x110a5400,0xc000010,
-0x80ac0c,0x110a5400,0xc000010,0xb4800c,0x11400c0c,0x4000010,0xb00000,0x11400c0c,0x4000010,0x1071400,0x11400c17,0xc000010,0xb48000,0x11400c1e,0x7c00900,0x230400,
-0x11400f4b,0xc000010,0x448000,0x11400f5f,0xc000010,0x448000,0x11401d94,0x4000000,0x200000,0x11403dca,0x4000000,0xe00000,0x114457bf,0x4000004,0x120000a,0x114457bf,
-0x4000008,0x81000a,0x114457bf,0x4000008,0x141000a,0x114457bf,0x4000010,0x87000a,0x114457bf,0xc000010,0x84800a,0x114457c8,0x3802500,0x126246a,0x114457c8,0x7c00d00,
-0x2530c0a,0x114a3dbf,0x24000000,0x810000,0x114a3dbf,0x24000000,0x1410000,0x114a3dbf,0x24000008,0x810000,0x114a3dbf,0x24000008,0x1410000,0x114a3dbf,0x24000010,0x870000,
-0x114a3dbf,0x2c000010,0x848000,0x114a3dc5,0x4000000,0xe00000,0x114a3dc5,0x24000000,0xe00000,0x114a3dc5,0x24000002,0xe00000,0x114a3dc5,0x24000002,0x1200000,0x114a3dc5,
-0x24000008,0x810000,0x114a3dc5,0x24000008,0x1410000,0x114a3dc8,0x7c00900,0x930c00,0x114a3dc8,0x7c00900,0xe30c00,0x114a3dca,0x7c00300,0xe30000,0x114a3ec8,0x7000400,
-0x1200c02,0x114a3fbf,0x4000004,0x1200000,0x114a3fc8,0x7c00d00,0x2530c00,0x114a42ca,0x4000000,0xe00000,0x114a42ca,0x4000000,0xe0000f,0x114a44ca,0x4000000,0xe00002,
-0x114a44ca,0x4000000,0xe00003,0x114a45ca,0x4000000,0xe00002,0x114a45ca,0x4000000,0xe0000d,0x11505103,0x24000000,0x810000,0x11505103,0x24000000,0x1410000,0x1180090a,
-0x2802400,0x962460,0x11800c27,0x2802100,0x962460,0x11800c27,0x2802500,0x962460,0x11800f32,0x2802400,0x962460,0x11800f3f,0x2802400,0x962460,0x11820700,0x2802400,
-0x962460,0x11820700,0x2802500,0x962460,0x118a3dcb,0x2802400,0x962460,0x118a3ec8,0x2802400,0x962460,0x11c00904,0x2802400,0x962460,0x11c00908,0x2802400,0x962460,
-0x11c00c2c,0x6800000,0x1329800,0x11c00c30,0xc000010,0xb48000,0x11c00f78,0x6800000,0x1329800,0x11c0107d,0x6800000,0x1329800,0x11c01181,0x6800000,0x1329800,0x11c01285,
-0x6800000,0x1329800,0x11c01489,0x4000000,0x200000,0x11c01489,0x6800000,0x1329800,0x11c0168d,0x6800000,0x1329800,0x11d05107,0x7c00100,0x230408,0x20000067,0x1000,
-0,0x20000b13,0x2802400,0x962460,0x20000b13,0x2802500,0x962460,0x20001b27,0x2802100,0x962460,0x20001b27,0x2802100,0x962461,0x20001b27,0x2802400,0x962460,
-0x20001b27,0x2806400,0x962460,0x20001b27,0x2902100,0x962462,0x20001b27,0x4000000,0x200000,0x20001b27,0x4000000,0x400000,0x20001b27,0x4000000,0x500000,0x20001b27,
-0x4000000,0x810000,0x20001b27,0x4000000,0xb00000,0x20001b27,0x4000000,0xc0000b,0x20001b27,0x4000000,0x1410000,0x20001b27,0x4000010,0xb00000,0x20001b27,0x4000010,
-0xc00000,0x20001b27,0x6800000,0x1329800,0x20001b27,0x6800100,0x462540,0x20001b27,0x6800400,0x962540,0x20001b27,0x7c00100,0x230400,0x20001b27,0x7c00100,0x230401,
-0x20002619,0x7c00100,0x220401,0x20002a00,0x4000000,0x1600000,0x20004b67,0,0x1900000,0x20004c67,0,0x1900000,0x20004d67,0,0x1900000,0x20006d67,
-0x1000,0,0x20006e67,0x1000,0,0x20026d67,0,0,0x20026e67,0,0,0x200a4a12,0x7c00100,0x1f304c1,0x200a4a12,0x7c00100,
-0x20304e1,0x21005600,0x4000000,0x700000,0x21022a00,0x4000000,0x1600000,0x30000419,0x7c00100,0x220400,0x30000419,0x7c00100,0x220401,0x30000419,0x7c00100,0x250400,
-0x30000419,0x7c00100,0x250401,0x30000519,0x7c00100,0x220400,0x30000600,0x4000400,0x200400,0x30000600,0x7c00500,0x230400,0x30000605,0x4000400,0x200400,0x3000080e,
-0x7c00100,0x220400,0x30000908,0x2000,0x962460,0x30000908,0x7c00100,0x220400,0x30000908,0x7c00100,0x220401,0x30000908,0x7c00100,0x250400,0x30000908,0x7c00100,
-0x250401,0x30000a03,0x4000006,0x400400,0x30000c02,0x4000000,0x200000,0x30000c02,0x7c00100,0x230400,0x30000d22,0x2802100,0x962460,0x30000d22,0x2802400,0x962460,
-0x30000d22,0x2802500,0x962460,0x30000d22,0x4000000,0x200000,0x30000d22,0x4000010,0x200000,0x30000d22,0x7c00100,0x230400,0x30000d22,0xc000010,0x248000,0x30000d22,
-0x80000000,0x218960,0x30000e25,0x2802500,0x962460,0x30000e25,0x7c00100,0x230400,0x30001821,0x2802100,0x962460,0x30001821,0x2806400,0x962460,0x30001821,0x4000000,
-0x200000,0x30001821,0x6800100,0x962540,0x30001821,0x6800100,0x962541,0x30001821,0x7c00100,0x230400,0x30001b27,0x2802100,0x962460,0x30001b27,0x2802400,0x962460,
-0x30001b27,0x4000000,0x200000,0x30001b27,0x4000000,0x400000,0x30001b27,0x7c00100,0x230400,0x30001c1c,0x2802100,0x1862460,0x30001c1c,0x2802400,0x1862460,0x30001c1c,
-0x2806400,0x1862460,0x30001c1c,0x4000000,0x200000,0x30001c1c,0x6800100,0x1862400,0x30001c1c,0x6800100,0x1862540,0x30001c1c,0x7c00100,0x1830000,0x30001c1c,0x7c00100,
-0x1830001,0x30001c1c,0xc000010,0x448000,0x30001f0b,0x4000000,0x200000,0x30001f0b,0x4000010,0x200000,0x30001f0b,0x4000010,0x400000,0x30001f0b,0x6800000,0x200000,
-0x30001f0b,0x7c00100,0x230400,0x30001f0b,0xc000010,0x248000,0x30002006,0x7c00100,0x250400,0x30002128,0x4000000,0x200000,0x30002128,0x7c00100,0x230400,0x30002128,
-0xc000010,0x248000,0x3000221d,0x4000000,0x810000,0x3000221d,0x4000000,0x1410000,0x3000221d,0x4000001,0x445800,0x3000221d,0x7c00100,0x230400,0x30002300,0x4000010,
-0x400000,0x30002320,0x7c00100,0x230400,0x30002417,0x2802100,0x1862460,0x30002417,0x2802400,0x1862460,0x30002417,0x2806400,0x1862460,0x30002417,0x2882000,0x1862460,
-0x30002417,0x4000000,0x200000,0x30002417,0x4000000,0x400000,0x30002417,0x4000000,0x1600000,0x30002417,0x4000010,0x400000,0x30002417,0x4000010,0x1200000,0x30002417,
-0x6800000,0x1329800,0x30002417,0x6800100,0x1862540,0x30002417,0x7c00100,0x1830000,0x30002417,0x7d00100,0x1830000,0x3000251b,0x80000,0xc18820,0x3000251b,0x2802100,
-0x962460,0x3000251b,0x3c02100,0x962460,0x3000251b,0x4000000,0x200000,0x3000251b,0x4000006,0x500000,0x3000251b,0x4000010,0x400000,0x3000251b,0x4000010,0xb70000,
-0x3000251b,0x4000800,0x200000,0x3000251b,0x6800000,0x1329800,0x3000251b,0x7c00100,0x230400,0x3000251b,0x7c00900,0x230400,0x3000251b,0xc000010,0xb48000,0x3000251b,
-0x12882000,0x962460,0x30002800,0x24000000,0x200000,0x30002800,0x2c000010,0x1248002,0x30002a00,0x4000000,0x1600000,0x30002b01,0x2000,0x962460,0x30002c00,0x4000000,
-0x200000,0x30002c00,0x7c00100,0x220405,0x30002d19,0x7c00100,0x250400,0x30002e00,0x24000000,0x200000,0x30003000,0x24000000,0x200000,0x30003100,0x24000000,0x200000,
-0x30003600,0x24000000,0x200000,0x30003700,0x24000000,0x200000,0x3000392e,0x24000000,0x200000,0x30005013,0x7c00100,0x2633801,0x30005600,0,0x918820,0x30020600,
-0x4000400,0x500400,0x30020701,0x2802400,0x962460,0x30020701,0x2802400,0xc62460,0x300a3a11,0x4020000,0xe00000,0x300a3a11,0x4020000,0xe00002,0x300a3b11,0x4020000,
-0xe00002,0x300a3c00,0x4008000,0xe00000,0x300a3c00,0x4010000,0xe00000,0x300a3d11,0x7c00300,0xe30002,0x300a4305,0x7c00100,0xe30400,0x300a4611,0x7c40300,0xe30000,
-0x300a4829,0x7c00100,0xe30400,0x300a4829,0x7c00900,0x1230400,0x300a4929,0x4000000,0xe00000,0x3040259a,0x4000010,0x400000,0x3040259a,0x4000010,0xb70000,0x3040259a,
-0xc000010,0xb48000,0x304028ba,0x4000001,0xc41c0b,0x304a3dca,0x4000000,0xe00000,0x30800c27,0x2802100,0x962460,0x30c01c92,0x6800000,0x1329800,0x3100080e,0x7c00120,
-0x220402,0x3100080e,0x7c00120,0x250402,0x31005167,0x1000,0,0x3100581e,0x4000000,0x200000,0x3100581e,0x7c00100,0x230400,0x3100590d,0x7c00100,0x230400,
-0x31005a09,0x7c00100,0x220400,0x31005a09,0x7c00100,0x250400,0x31005b00,0x4000000,0x200000,0x31005c00,0x80000,0x918820,0x31005c00,0x2802000,0x962460,0x31005c00,
-0x2802400,0x962460,0x31005c00,0x4000000,0x200000,0x31005c00,0x4000000,0x200001,0x31005c00,0x6800000,0x962540,0x31005c00,0x6800400,0x962540,0x31005c01,0x2802400,
-0x962460,0x31005d00,0x4000020,0x200005,0x31005d00,0x6800020,0x1329805,0x31005d00,0x7c00120,0x220405,0x31005d00,0x7c00120,0x250405,0x31006000,0x82000,0x962460,
-0x31006000,0x180000,0x918820,0x310a5e11,0x7c40300,0xe30000,0x310a5f11,0x7c00300,0xe30001,0x32000419,0x7c00100,0x250400,0x3200080e,0x4000020,0x200000,0x3200080e,
-0x7c00100,0x220400,0x3200080e,0x7c00100,0x250400,0x32000908,0x7c00100,0x220400,0x32000908,0x7c00100,0x250400,0x32000c02,0x7c00100,0x230400,0x32000e25,0x7c00100,
-0x230400,0x32001d0c,0x7c00100,0x230400,0x32002800,0x80000,0x1e18820,0x32002800,0x80020,0x218820,0x32002800,0x4000001,0x445802,0x32002800,0x24000000,0x200000,
-0x32002800,0x24000000,0x200002,0x32002800,0x24000020,0x200000,0x32002800,0x2c000010,0x1248002,0x32002919,0x7c00100,0x22040f,0x32002a00,0x4000000,0x1600000,0x32002b01,
-0x2000,0x962460,0x32002b01,0x2802000,0x962460,0x32002b01,0x2802020,0x962460,0x32002c00,0x4000000,0x200000,0x32002c00,0x4000020,0x200000,0x32002c00,0x4000020,
-0x200005,0x32002c00,0x7c00120,0x220405,0x32002c00,0x7c00120,0x250405,0x32002e00,0x24000020,0x200000,0x32002f00,0x24000020,0x200000,0x32003000,0x24000000,0x200000,
-0x32003000,0x24000020,0x200000,0x32003500,0x24000000,0x200000,0x32003600,0x24000020,0x200000,0x32003700,0x24000000,0x100000,0x32003700,0x24000000,0x200000,0x32003800,
-0x24000000,0x810000,0x32003800,0x24000000,0x1410000,0x32005102,0x4000000,0x1500008,0x32005502,0x7c00100,0x230400,0x32006108,0x7c00100,0x220400,0x32006108,0x7c00100,
-0x250400,0x3200622a,0x2802100,0x962460,0x3200622a,0x2806400,0x962460,0x3200622a,0x7c00100,0x230400,0x3200632b,0x2802100,0x962460,0x3200632b,0x6804000,0x962540,
-0x3200632b,0x7c00100,0x230400,0x3200642c,0x2802100,0x962460,0x3200642c,0x7c00100,0x230400,0x3200652d,0x2802100,0x962460,0x3200652d,0x7c00100,0x230400,0x32006600,
-0x24000020,0x200000,0x32006700,0x24000020,0x200000,0x32006800,0x24000020,0x200000,0x32006900,0x24000020,0x200000,0x32006900,0x24000020,0x810000,0x32006900,0x24000020,
-0x1410000,0x32006a00,0x24000020,0x200000,0x32006a00,0x24000020,0x200001,0x32006a00,0x24000020,0x200002,0x32020701,0x2882000,0xc62460,0x32023300,0x4000000,0x100000,
-0x32026c01,0x12882000,0x962460,0x32065700,0x4000000,0x810011,0x32065700,0x4000000,0x1410011,0x32086600,0x24000020,0x810000,0x32086600,0x24000020,0x1410000,0x32086900,
-0x24000020,0x810000,0x32086900,0x24000020,0x1410000,0x320a3600,0x24000020,0x200000,0x320a3d11,0x7c00100,0x1230400,0x320a3e14,0x7c00100,0xe30010,0x320a3e14,0x7c00100,
-0x2530000,0x320a3f16,0x7c00100,0xe30c10,0x320a4400,0x4000000,0xe00003,0x320a4929,0x4000000,0xe00000,0x320a4f11,0x7c00300,0xe30001,0x320a6b16,0x7c00100,0x2530c00,
-0x32406396,0xc000010,0x448000,0x324a3dcd,0x4000000,0xe00000,0x324a3dcd,0x7c00100,0x1230400,0x324a3fc8,0x4000002,0x1200c00,0x324a53c5,0x24000000,0xe00000,0x32820701,
-0x2802000,0x962460,0x40000419,0x7c00100,0x220400,0x40000519,0x7c00100,0x220400,0x40000600,0x4000400,0x200400,0x4000080e,0x7c00100,0x220400,0x4000080e,0x7c00100,
-0x250400,0x4000080e,0x7c00100,0x250402,0x40000c02,0x2802100,0x962460,0x40000c02,0x2802400,0x962460,0x40000c02,0x2802500,0x962460,0x40000c02,0x4000000,0x200000,
-0x40000c02,0x4000000,0x1071400,0x40000c02,0x7c00100,0x230400,0x40000c02,0x80000000,0x218960,0x40000d22,0x7c00100,0x230400,0x40000f0a,0x7c00100,0x230400,0x40001004,
-0x7c00100,0x230400,0x40001110,0x2802100,0x962460,0x40001110,0x6800100,0x962540,0x4000120f,0x2802100,0x962460,0x4000120f,0x4000000,0x1600000,0x4000120f,0x7c00100,
-0x230400,0x4000131f,0x7c00100,0x230400,0x40001423,0x4000000,0x200000,0x40001423,0x4000000,0x1600000,0x40001615,0x2802400,0x962460,0x40001615,0x7c00100,0x230400,
-0x40002417,0x2802400,0x1862460,0x40002417,0x4000000,0x200000,0x40002800,0x6800000,0x201c00,0x40002800,0x24000002,0x200000,0x40002c00,0x4000000,0x200002,0x40003000,
-0x24000000,0x200000,0x40003000,0x24000020,0x200000,0x40003700,0x24000000,0x200000,0x40005a09,0x7c00100,0x220400,0x40005a09,0x7c00100,0x250400,0x40005d00,0x7c00120,
-0x220405,0x40006f30,0x2802100,0x962460,0x40006f30,0x2802400,0x962460,0x40006f30,0x4000000,0x200000,0x40006f30,0x6800000,0x1329800,0x40006f30,0x6800100,0x962540,
-0x40006f30,0x7c00100,0x230400,0x40006f30,0xc000010,0xb48000,0x40007034,0x7c00100,0x1830000,0x40007117,0x4000000,0x200000,0x40007208,0x7c00100,0x220400,0x4000720e,
-0x7c00100,0x220400,0x4000720e,0x7c00500,0x22040e,0x4000720e,0x7c00500,0x22040f,0x40007219,0x7c00100,0x220400,0x40007219,0x7c00500,0x220400,0x40007219,0x7c00500,
-0x22040e,0x40007219,0x7c00500,0x22040f,0x40007300,0x24000000,0x200000,0x40007400,0x4000000,0x200000,0x40007531,0x7c00100,0x230400,0x40007631,0x7c00100,0x230400,
-0x40007835,0x4000010,0x400000,0x40007835,0x7c00100,0x230400,0x40007933,0x7c00100,0x230400,0x40007a32,0x6800000,0x1329800,0x40007a32,0x7c00100,0x230400,0x40007b2f,
-0x7c00100,0x230400,0x40007c00,0x4000000,0x200000,0x40020701,0x2802400,0x962460,0x40020701,0x2802400,0xc62460,0x40023300,0x4000000,0x200000,0x40027d01,0x12882000,
-0x962460,0x400a3700,0x24000000,0x200000,0x400a3700,0x24000000,0xe00000,0x400a4400,0x4000000,0xe0000d,0x400a4412,0x4000000,0xe00002,0x400a4412,0x4000000,0xe00003,
-0x400a4500,0x4000000,0xe0000d,0x400a5300,0x4000000,0x810010,0x400a5300,0x4000000,0x1410010,0x40507709,0x4000000,0x200000,0x4050770c,0x4000000,0x400000,0x4050770f,
-0x4000000,0x200000,0x4050770f,0x4000000,0x400000,0x40c01489,0x4000000,0x200000,0x40d05107,0x4000000,0x200000,0x41000419,0x7c00100,0x220400,0x41000419,0x7c00100,
-0x250400,0x4100080e,0x7c00100,0x220400,0x4100080e,0x7c00100,0x250400,0x41000908,0x7c00100,0x220400,0x41000908,0x7c00100,0x250400,0x41000b13,0x2802000,0x962460,
-0x41000b13,0x2802100,0x962460,0x41000b13,0x4000000,0xb00000,0x41000c02,0x2802100,0x962460,0x41000c02,0x4000000,0x1500000,0x41000c02,0xc000010,0xb48000,0x41000f0a,
-0x7c00100,0x230400,0x41001004,0x7c00100,0x230400,0x41001423,0x7c00100,0x230400,0x41001b27,0x4000000,0x500000,0x41001d0c,0x7c00100,0x230400,0x41001d0c,0x7c00100,
-0x23040f,0x41001f0b,0x2802400,0x962460,0x41001f0b,0x4000000,0x200000,0x41001f0b,0x7c00100,0x230400,0x41002800,0x24000000,0x200000,0x41002800,0x24000000,0x400000,
-0x41002919,0x7c00100,0x22040e,0x41002a00,0x4000000,0x1600000,0x41002b01,0x2802020,0x962460,0x41002c00,0x4000000,0x200000,0x41002c00,0x7c00120,0x220405,0x41003000,
-0x24000000,0x200000,0x41003700,0x24000000,0x200000,0x41003700,0x24000000,0xe00000,0x41005d00,0x7c00120,0x220405,0x41006600,0x24000020,0x200000,0x41006600,0x24000020,
-0x810000,0x41006600,0x24000020,0x1410000,0x41007208,0x7c00100,0x22040f,0x41007219,0x7c00100,0x220400,0x41007300,0x24000000,0x200000,0x41007e0e,0x2802000,0x962460,
-0x41007e0e,0x4000000,0x200000,0x41007f0e,0x4000000,0x200000,0x41007f0e,0x7c00100,0x230400,0x41008002,0x7c00100,0x230400,0x41008137,0x2802100,0x962460,0x41008137,
-0x4000000,0x200000,0x41008137,0x6800100,0x962540,0x41008137,0x7c00100,0x230400,0x41008301,0x2802000,0x962460,0x41008407,0x4000000,0x200000,0x41008407,0x4000000,
-0x400000,0x41008407,0x4000000,0xb00000,0x41008407,0x7c00100,0x220400,0x41008407,0x7c00100,0x250400,0x4100850b,0x7c00100,0x230400,0x4100860b,0x4000000,0x200000,
-0x4100860b,0x7c00100,0x230400,0x4100870c,0x7c00100,0x220400,0x41008838,0x7c00100,0x220400,0x41008838,0x7c00100,0x250400,0x41008939,0x2802000,0x962460,0x41008939,
-0x2802100,0x962460,0x41008939,0x2806000,0x962460,0x41008939,0x4000000,0x200000,0x41008939,0x4000000,0x400000,0x41008939,0x7c00100,0x230400,0x41008939,0xc000010,
-0x448000,0x41008a00,0x4000400,0x200400,0x41008b3b,0x4000000,0x1800000,0x41008b3b,0x6800000,0x1329800,0x41008b3b,0x7c00100,0x1830000,0x41008b3b,0x7e00100,0x1830000,
-0x41008c3d,0x4000010,0x400000,0x41008c3d,0x7c00100,0x230400,0x41008d0e,0x7c00100,0x22040f,0x41008d19,0x7c00100,0x220400,0x41008d19,0x7c00100,0x22040f,0x41008e00,
-0x24000000,0x200000,0x41008e00,0x24000000,0x400000,0x41008e00,0x24000000,0x1710000,0x41008e00,0x24000006,0x400000,0x41008f3a,0x2802100,0x962460,0x41008f3a,0x2806000,
-0x962460,0x41008f3a,0x4000000,0x200000,0x41008f3a,0x6800100,0x962540,0x41008f3a,0x7c00100,0x230400,0x4100903c,0x7c00100,0x230400,0x4100903c,0x7c00100,0x23040f,
-0x41020701,0x2802000,0x962460,0x41020701,0x2802000,0xc62460,0x410a3700,0x24000000,0x200000,0x410a3700,0x24000000,0xe00000,0x410a4412,0x4000000,0xe00003,0x410a4711,
-0x7c40300,0xe30000,0x410a4f11,0x7c00300,0xe30001,0x410a9100,0x4000000,0x800010,0x410a9100,0x4000000,0x810010,0x410a9100,0x4000000,0x870010,0x410a9100,0x4000000,
-0xb00010,0x410a9100,0x4000000,0xf00010,0x410a9100,0x4000000,0x1001410,0x410a9100,0x4000000,0x1071010,0x410a9100,0x4000000,0x1071410,0x410a9100,0x4000000,0x1410010,
-0x41408ad0,0x4000400,0x200000,0x414a82ca,0x4000000,0xe00000,0x41808300,0x2802000,0x962460,0x41c01489,0x6800000,0x1329800,0x50000419,0x7c00100,0x220400,0x50000419,
-0x7c00100,0x250400,0x5000080e,0x7c00100,0x220400,0x50000908,0x7c00100,0x220400,0x50000908,0x7c00100,0x250400,0x50000b13,0x2802500,0x962460,0x50000f0a,0x7c00100,
-0x230400,0x50001615,0x2802100,0x962460,0x50001615,0x7c00100,0x230400,0x50002b01,0x2802020,0x962460,0x50002c00,0x4000000,0x200000,0x50002c19,0x7c00100,0x220400,
-0x50002d19,0x7c00100,0x220400,0x50003000,0x24000000,0x200000,0x50003000,0x24000020,0x200000,0x50003700,0x24000000,0x200000,0x50005d00,0x7c00120,0x220405,0x50005d00,
-0x7c00120,0x250405,0x50006108,0x7c00100,0x220400,0x50006108,0x7c00100,0x250400,0x50006600,0x24000020,0x200000,0x50007300,0x24000000,0x200000,0x50008301,0x2802400,
-0x962460,0x50008a00,0x7c00500,0x230400,0x50009257,0x2802400,0x962460,0x50009257,0x4000000,0x200000,0x50009257,0x4000010,0x1071400,0x50009257,0x6800000,0x1329800,
-0x50009257,0x7c00100,0x230400,0x50009257,0x7c00500,0x230400,0x50009257,0x7c00900,0x230400,0x50009257,0xc000010,0xb48000,0x5000933e,0x2802100,0x962460,0x5000933e,
-0x2802400,0x962460,0x5000933e,0x4000000,0x200000,0x5000933e,0x4000000,0x400000,0x5000933e,0x4000010,0x400000,0x5000933e,0x6800000,0x1329800,0x5000933e,0x6800100,
-0x962540,0x5000933e,0x6800100,0x962541,0x5000933e,0x6804400,0x962540,0x5000933e,0x7c00100,0x230400,0x5000933e,0x7c00100,0x230401,0x5000933e,0xc000010,0x448000,
-0x50009419,0x7c00100,0x220400,0x50009419,0x7c00100,0x250400,0x50009500,0x4000400,0x200400,0x5000965a,0x4000000,0x500000,0x5000965a,0x7c00100,0x230400,0x5000965a,
-0xc000010,0xb48000,0x5000975b,0x4000000,0x200000,0x5000975b,0x4000010,0x400000,0x5000975b,0x7c00100,0x230400,0x50009865,0x7c00100,0x230400,0x50009965,0x4000010,
-0x400000,0x50009965,0x7c00100,0x230400,0x50409aca,0x4000000,0x200000,0x5100080e,0x7c00100,0x220400,0x5100080e,0x7c00100,0x250400,0x51000c02,0x2802100,0x962460,
-0x51000c02,0x4000000,0x1500000,0x51000c02,0x4000020,0x200000,0x51000c02,0x7c00100,0x230400,0x51000f0a,0x7c00100,0x230400,0x51000f0a,0x7c00500,0x230400,0x51001110,
-0x2802100,0x962460,0x5100131f,0x2802100,0x962460,0x51001423,0x7c00100,0x230400,0x51001524,0x2802100,0x962460,0x51001524,0x4000000,0x200000,0x51001524,0x7c00100,
-0x230400,0x5100171a,0x2802100,0x962460,0x5100171a,0x4000000,0x200000,0x5100171a,0x4000000,0x1500000,0x5100171a,0x7c00100,0x230400,0x51001b27,0x4000000,0x200000,
-0x51001b27,0x4000000,0x400000,0x51001b27,0x4000000,0x500000,0x51001b27,0x7c00100,0x230400,0x51001c1c,0x2802100,0x1862460,0x51001c1c,0x2802500,0x1862460,0x51001c1c,
-0x2806400,0x1862460,0x51001c1c,0x4000000,0x1800000,0x51001c1c,0x6800000,0x1329800,0x51001c1c,0x6800100,0x1862400,0x51001c1c,0x6800100,0x1862540,0x51001c1c,0x6800500,
-0x1862400,0x51001c1c,0x7c00100,0x1830000,0x5100251b,0x7c00100,0x230400,0x51002619,0x7c00100,0x220400,0x51002619,0x7c00100,0x250400,0x51002800,0x80020,0x218820,
-0x51002c00,0x4000000,0x200000,0x51002d19,0x7c00100,0x230400,0x51003700,0x24000000,0x200000,0x51003700,0x24000000,0xe00000,0x51005201,0x2802400,0x962460,0x51005c00,
-0x4000000,0x200000,0x51006108,0x7c00100,0x220400,0x51006108,0x7c00100,0x250400,0x51006600,0x24000020,0x200000,0x51006600,0x24000020,0x810000,0x51006600,0x24000020,
-0x1410000,0x51007300,0x24000000,0x200000,0x51007300,0x24000020,0x200000,0x51008002,0x7c00100,0x230400,0x51008301,0x2802000,0x962460,0x51008301,0x2802400,0x962460,
-0x51008a00,0x7c00500,0x230400,0x51008e00,0x24000000,0x200000,0x51008e00,0x24000000,0x400000,0x51008e00,0x24000000,0x810000,0x51008e00,0x24000000,0x1400000,0x51008e00,
-0x24000000,0x1410000,0x51008e00,0x24000000,0x1710000,0x51008e00,0x24000002,0x200000,0x51008e00,0x24000500,0x230400,0x51008e00,0x2c000010,0xb48000,0x51009419,0x7c00100,
-0x220400,0x51009419,0x7c00100,0x22040e,0x51009419,0x7c00100,0x22040f,0x51009419,0x7c00100,0x250400,0x51009500,0x4000400,0x200400,0x51009500,0x7c00500,0x230400,
-0x51009519,0x7c00100,0x220400,0x51009519,0x7c00100,0x22040f,0x51009519,0x7c00100,0x230400,0x51009519,0x7c00100,0x250400,0x51009b71,0x2802100,0x962460,0x51009b71,
-0x6800000,0x1329800,0x51009b71,0x6800100,0x962540,0x51009b71,0x6804400,0x962540,0x51009b71,0x7c00100,0x230400,0x51009c52,0x2802100,0x962460,0x51009c52,0x2802400,
-0x962460,0x51009c52,0x2802d00,0x962460,0x51009c52,0x4000010,0x400000,0x51009c52,0x6800000,0x1329800,0x51009c52,0x6800100,0x962540,0x51009c52,0x7c00100,0x230400,
-0x51009c52,0xc000010,0x448000,0x51009d6d,0x6800000,0x1329800,0x51009d6d,0x7c00100,0x230400,0x51009d6d,0x7c00500,0x230400,0x51009d6d,0x7c00d00,0x230400,0x51009d6d,
-0xc000010,0x448000,0x51009e08,0x2802100,0x962460,0x51009f63,0x4000010,0x400000,0x51009f63,0x6800000,0x1329800,0x51009f63,0x7c00100,0x230400,0x51009f63,0x7c00900,
-0x230400,0x51009f63,0xc000010,0x448000,0x51009f63,0xc000010,0xb48000,0x5100a008,0x2000,0x962460,0x5100a008,0x2802400,0x962460,0x5100a008,0x4000000,0x200000,
-0x5100a008,0x7c00100,0x220400,0x5100a008,0x7c00100,0x230400,0x5100a008,0x7c00100,0x250400,0x5100a008,0x7c00500,0x230400,0x5100a16f,0x2806400,0x962460,0x5100a16f,
-0x6800000,0x1329800,0x5100a16f,0x6800100,0x962540,0x5100a16f,0x7c00100,0x230400,0x5100a16f,0xc000010,0x448000,0x5100a24f,0x2802100,0x962460,0x5100a24f,0x2802400,
-0x962460,0x5100a24f,0x6800000,0x1329800,0x5100a24f,0x7c00100,0x230400,0x5100a24f,0xc000010,0x448000,0x5100a36e,0x2802100,0x962460,0x5100a36e,0x4000000,0x200000,
-0x5100a36e,0x6800100,0x962540,0x5100a36e,0x6804400,0x962540,0x5100a36e,0x7c00100,0x230400,0x5100a442,0x2802100,0x962460,0x5100a442,0x4000000,0x200000,0x5100a442,
-0x6800000,0x1329800,0x5100a442,0x6800100,0x962540,0x5100a442,0x7c00100,0x230400,0x5100a442,0xc000010,0x448000,0x5100a500,0x4000000,0x200000,0x5100a600,0x4000000,
-0x200000,0x5100a601,0x2802000,0x962460,0x5100a76b,0x7c00100,0x230400,0x5100a868,0x7c00100,0x230400,0x5100a96c,0x4000000,0x200000,0x5100a96c,0x7c00100,0x230400,
-0x5100aa00,0x4000000,0xe00000,0x5100ab00,0x4000000,0xe00000,0x51086600,0x24000020,0x810000,0x51086600,0x24000020,0x1410000,0x510a4005,0x7c00100,0xe30400,0x510a4711,
-0x7c40300,0xe30000,0x510a7300,0x24000000,0x200000,0x510aaa00,0x4000000,0xe00000,0x5140a2fe,0x4000400,0x400000,0x514a82ca,0x4000000,0xe00000,0x51802bbc,0x2802000,
-0x962460,0x51c00908,0x2802400,0x962460,0x51c0a008,0x2802400,0x962460,0x52000f0a,0x2802100,0x962460,0x52000f0a,0x6800100,0x962540,0x52000f0a,0x7c00100,0x230400,
-0x52001004,0x4000000,0x1600000,0x52001b00,0x4000000,0x200000,0x52001c1c,0x2802100,0x1862460,0x52001c1c,0x6800100,0x1862400,0x52001c1c,0x6800500,0x1862400,0x52001e12,
-0x7c00100,0x2230500,0x52001e12,0x7c00100,0x2330520,0x52002128,0x4000002,0x400000,0x52002128,0x7c00100,0x230400,0x52002a00,0x4000000,0x1500000,0x52002a00,0x4000000,
-0x1600000,0x52002d00,0x4000000,0x200006,0x52003000,0x24000000,0x200000,0x52006108,0x7c00100,0x220400,0x52006108,0x7c00100,0x250400,0x52008301,0x2802400,0x962460,
-0x52008407,0x2802400,0x962460,0x52008407,0x7c00100,0x220400,0x52008407,0x7c00100,0x250400,0x52008b3b,0x6800000,0x1800000,0x52008b3b,0x7c00100,0x1830000,0x52008e00,
-0x24000000,0x400000,0x52009419,0x7c00100,0x250400,0x5200975b,0x4000000,0x200000,0x5200ac7e,0x2802000,0x962460,0x5200ac7e,0x2802100,0x962460,0x5200ac7e,0x2802400,
-0x962460,0x5200ac7e,0x4000010,0x200000,0x5200ac7e,0x7c00100,0x230400,0x5200ac7e,0xc000010,0x248000,0x5200ad28,0x7c00100,0x230400,0x5200ae6a,0x2802100,0x1862460,
-0x5200ae6a,0x2802400,0x962460,0x5200ae6a,0x2802400,0x1862460,0x5200ae6a,0x2806000,0x1862460,0x5200ae6a,0x4000000,0x1800000,0x5200ae6a,0x6800000,0x1329800,0x5200ae6a,
-0x6800100,0x1862400,0x5200ae6a,0x6800100,0x1862540,0x5200ae6a,0x7c00100,0x1830000,0x5200ae6a,0x7c00900,0x1830000,0x5200ae6a,0xc000010,0x1848000,0x5200b083,0x4000010,
-0x400000,0x5200b083,0x7c00100,0x230400,0x5200b083,0xc000010,0x448000,0x5200b182,0x2802400,0x962460,0x5200b182,0x4000000,0x200000,0x5200b182,0x4000010,0x400000,
-0x5200b182,0x7c00100,0x230400,0x5200b182,0xc000010,0x448000,0x5200b30a,0x2802400,0x962460,0x5200b30a,0x4000000,0x200000,0x5200b30a,0x7c00100,0x230400,0x5200b54e,
-0x2802100,0x962460,0x5200b54e,0x2802400,0x962460,0x5200b54e,0x4000000,0x200000,0x5200b54e,0x4000010,0x400000,0x5200b54e,0x6800000,0x1329800,0x5200b54e,0x6800100,
-0x962540,0x5200b54e,0x6804400,0x962540,0x5200b54e,0x7c00100,0x230400,0x5200b54e,0xc000010,0x448000,0x5200b61c,0x4000000,0x1800000,0x5200b61c,0x6800500,0x1862400,
-0x5200b61c,0x7c00100,0x1830000,0x5200b61c,0x7c00900,0x1830000,0x5200b77f,0x2802100,0x1862460,0x5200b77f,0x2802400,0x1862460,0x5200b77f,0x4000000,0x1800000,0x5200b77f,
-0x4000010,0x1800000,0x5200b77f,0x7c00100,0x1830000,0x5200b77f,0x7c00500,0x1830000,0x5200b77f,0x7c00900,0x1830000,0x5200b77f,0x7e00100,0x1830000,0x5200b873,0x2802100,
-0x962460,0x5200b873,0x2806400,0x962460,0x5200b873,0x6800000,0x1329800,0x5200b873,0x6800100,0x962540,0x5200b873,0x6800400,0x962540,0x5200b873,0x7c00100,0x230400,
-0x5200b873,0xc000010,0x448000,0x5200b912,0x7c00100,0x2230500,0x5200b912,0x7c00100,0x2330520,0x5200ba74,0x4000000,0x200000,0x5200ba74,0x4000010,0x400000,0x5200ba74,
-0x7c00100,0x230400,0x5200bb85,0x4000000,0x200000,0x5200bb85,0x7c00100,0x230400,0x5200bc75,0x4000000,0x400000,0x5200bc75,0x4000010,0x400000,0x5200bc75,0x7c00100,
-0x230400,0x5200bd7d,0x4000000,0x200000,0x5200bd7d,0x7c00100,0x230400,0x5200be7a,0x4000000,0x200000,0x5200be7a,0x7c00100,0x230400,0x5200bf58,0x7c00100,0x230400,
-0x5200c002,0x4000000,0x200000,0x5200c178,0x2802000,0x962460,0x5200c178,0x2802100,0x962460,0x5200c178,0x2802400,0x962460,0x5200c178,0x2806400,0x962460,0x5200c178,
-0x4000000,0x200000,0x5200c178,0x6800100,0x962540,0x5200c178,0x7c00100,0x230400,0x5200c178,0x7c00100,0x230401,0x5200c178,0xc000010,0x448000,0x5200c178,0x80000000,
-0x218960,0x5200c247,0x7c00100,0x230400,0x5200c247,0x7c00100,0x830400,0x5200c247,0x7c00100,0x1430400,0x5200c300,0x4000000,0x200003,0x52022d00,0x4000000,0x100006,
-0x52023700,0x24000000,0x100000,0x52023700,0x24000000,0xe00000,0x52023700,0x24000000,0x2800000,0x52024400,0x4000000,0x100000,0x52027300,0x24000000,0x100000,0x5202c300,
-0x4000000,0x100000,0x5202c300,0x4000000,0x100002,0x5202c300,0x4000000,0x100003,0x5202c300,0x4000000,0x10000d,0x5202c300,0x4000100,0x150400,0x5202c300,0x4000100,
-0x15040d,0x520a1e12,0x7c00100,0x2130480,0x520a3700,0x24000000,0xe00000,0x520a3800,0x24000000,0x100000,0x520a4711,0x7c40300,0xe30000,0x520a4f11,0x7c00300,0xe30001,
-0x520a7300,0x24000000,0x100000,0x520ab412,0x7c00100,0x2130480,0x520ac400,0x4000000,0xe00002,0x520ac400,0x4000000,0xe0000d,0x520ac414,0x4000000,0xe0000d,0x520ac511,
-0x7c40300,0xe30000,0x5240af9c,0x7c00100,0x230400,0x5240afa1,0x4000400,0x200000,0x5240afa3,0x6800400,0x962540,0x5240afa3,0x7c00100,0x230400,0x5240afad,0x7c00100,
-0x230400,0x5240afaf,0x7c00100,0x230400,0x5240b2d2,0x4000000,0x200000,0x5240b2d2,0x4000000,0x1500000,0x5240b2dd,0x4000000,0x200000,0x5240b2eb,0x4000000,0x200000,
-0x524a44ca,0x4000000,0xe00003,0x5250b501,0x7c00900,0x230400,0x5280af9c,0x2802400,0x962460,0x5280af9d,0x2802400,0x962460,0x5280afa3,0x2802400,0x962460,0x5280afa5,
-0x2802400,0x962460,0x5280afa7,0x2802400,0x962460,0x52c0b3f8,0x2802400,0x962460,0x52c0b3fc,0x7c00100,0x230400,0x60000c02,0x2802100,0x962460,0x60000c02,0x7c00100,
-0x230400,0x60000f0a,0x2802100,0x962460,0x60000f0a,0x6800100,0x962540,0x60000f0a,0x7c00100,0x230400,0x6000131f,0x4000000,0x200000,0x6000171a,0x7c00100,0x230400,
-0x6000171a,0x7c00100,0x230560,0x60001b27,0x2802100,0x962460,0x60001b27,0x4000000,0xc00000,0x60001b27,0x7c00100,0x230400,0x60001f0b,0x2802400,0x962460,0x60002919,
-0x7c00100,0x22040e,0x60002a00,0x4000000,0x1600000,0x60003000,0x24000000,0x200000,0x60003000,0x24000000,0xe00000,0x60003700,0x24000000,0x200000,0x60003800,0x24000000,
-0x1710000,0x60005102,0x4000000,0x200000,0x60006108,0x7c00100,0x220400,0x60006108,0x7c00100,0x250400,0x60006600,0x24000020,0x200000,0x60008301,0x2802400,0x962460,
-0x6000903c,0x2806000,0x962460,0x6000903c,0x4000000,0x400000,0x60009519,0x7c00100,0x220400,0x60009519,0x7c00100,0x250400,0x6000a008,0x7c00100,0x220400,0x6000a008,
-0x7c00100,0x250400,0x6000c300,0x4000000,0x2703580,0x6000c654,0x2802000,0x962460,0x6000c654,0x4000010,0x200000,0x6000c654,0x7c00100,0x230400,0x6000c73f,0x2802000,
-0x962460,0x6000c73f,0x2802100,0x962460,0x6000c73f,0x4000000,0x200000,0x6000c73f,0x6800100,0x962540,0x6000c73f,0x6804000,0x962540,0x6000c73f,0x7c00100,0x230400,
-0x6000c80b,0x7c00100,0x230400,0x6000c941,0x2802100,0x962460,0x6000c941,0x2806400,0x962460,0x6000c941,0x4000000,0x200000,0x6000c941,0x4000010,0x200000,0x6000c941,
-0x6800000,0x1329800,0x6000c941,0x6800100,0x962540,0x6000c941,0x7c00100,0x230400,0x6000c941,0xc000010,0x448000,0x6000ca82,0x7c00100,0x230400,0x6000cc00,0x4000000,
-0xe00000,0x6000d000,0x4000000,0x200000,0x6002c300,0x4000000,0x100000,0x6002c300,0x4000000,0x10000d,0x6002c300,0x4000100,0x150400,0x6002c300,0x4000100,0x15040d,
-0x600a3000,0x24000000,0x200000,0x600a3000,0x24000000,0xe00000,0x600a3700,0x24000000,0x200000,0x600a3800,0x24000000,0x200000,0x600a3800,0x24000000,0x2800000,0x600a4305,
-0x7c00100,0xe30400,0x600ac300,0x4000000,0x100000,0x600ac400,0x4000000,0xe0000d,0x600acb14,0x7c00100,0xe30000,0x600acb16,0x7c00100,0xe30c00,0x600acc00,0x4000000,
-0xe00000,0x600acd00,0x4000000,0x200000,0x600acd00,0x4000000,0xe00000,0x600acd00,0x4000000,0x2800000,0x600ace00,0x4000000,0xe00000,0x600ace00,0x4000000,0x2800000,
-0x600acf00,0x4000000,0xe00000,0x600acf00,0x4000000,0x2800000,0x600ad111,0x7c40300,0xe30000,0x604ac4ca,0x4000000,0xe00003,0x61000a03,0x4000000,0x1600000,0x61000c02,
-0x80000000,0x218960,0x6100120f,0x4000000,0x200000,0x61001a18,0x7c00100,0x1830000,0x61001d0c,0x7c00100,0x230400,0x61001d0c,0x7c00100,0x250400,0x61006600,0x24000020,
-0x200000,0x61008407,0x7c00100,0x220400,0x61008407,0x7c00100,0x250400,0x6100870c,0x7c00100,0x220400,0x61008e00,0x24000000,0x200000,0x61008e00,0x24000000,0x400000,
-0x61008e00,0x24000002,0x300000,0x6100903c,0x7c00100,0x230400,0x61009519,0x7c00100,0x220400,0x61009519,0x7c00100,0x250400,0x61009519,0x7c00500,0x22040f,0x61009b71,
-0x2802100,0x962460,0x61009b71,0x2806400,0x962460,0x61009b71,0x7c00100,0x230400,0x6100a008,0x2802100,0x962460,0x6100c300,0x4000000,0x20000f,0x6100cd00,0x4000000,
-0x200000,0x6100d202,0x2802400,0x962460,0x6100d202,0x2802500,0x962460,0x6100d202,0x7c00100,0x230400,0x6100d302,0x4000020,0x200000,0x6100d302,0x7c00120,0x230405,
-0x6100d476,0x2802100,0x962460,0x6100d476,0x2802100,0x962461,0x6100d476,0x2806400,0x962460,0x6100d476,0x4000000,0x400000,0x6100d476,0x6800000,0x1329800,0x6100d476,
-0x6800100,0x962540,0x6100d476,0x7c00100,0x230400,0x6100d476,0xc000010,0x448000,0x6100d573,0x2802100,0x962460,0x6100d573,0x2806400,0x962460,0x6100d573,0x6800100,
-0x962540,0x6100d573,0x7c00100,0x230400,0x6100d573,0x7c00900,0x230400,0x6100d573,0xc000010,0x448000,0x6100d68d,0x7c00100,0x230400,0x6100d756,0x7c00100,0x230400,
-0x6100d85c,0x2802500,0x962460,0x6100d85c,0x6800100,0x962540,0x6100d85c,0x7c00100,0x230400,0x6100d85c,0x7c00500,0x230400,0x6100d997,0x2802100,0x962460,0x6100d997,
-0x4000000,0x200000,0x6100d997,0x4000000,0x400000,0x6100d997,0x6800000,0x1329800,0x6100d997,0x6800100,0x962540,0x6100d997,0x6804400,0x962540,0x6100d997,0x7c00100,
-0x230400,0x6100d997,0x7c00100,0x230560,0x6100d997,0xc000010,0x448000,0x6100da98,0x6800000,0x1329800,0x6100da98,0x7c00100,0x230400,0x6100db71,0x4000000,0x200000,
-0x6100dc99,0x2802100,0x962460,0x6100dc99,0x2802400,0x962460,0x6100dc99,0x6800000,0x1329800,0x6100dc99,0x6800100,0x962540,0x6100dc99,0x6804400,0x962540,0x6100dc99,
-0x7c00100,0x230400,0x610a4711,0x7c40300,0xe30000,0x610a4f11,0x7c00300,0xe30001,0x610ace00,0x4000000,0xe00000,0x6140afa1,0x7c00100,0x230400,0x6140afa3,0x7c00100,
-0x230400,0x6180af9e,0x2802400,0x962460,0x62002a00,0x4000000,0x1600000,0x63002800,0x80000,0x918820,0x63c00c15,0x80000,0x918820,0x7000080e,0x7c00100,0x250400,
-0x70000a03,0x4000000,0x200000,0x70000c00,0x80000000,0x218960,0x70000f0a,0x7c00100,0x230400,0x70001004,0x7c00100,0x230400,0x70001524,0x2802100,0x962460,0x70001524,
-0x7c00100,0x230400,0x70001615,0x2802100,0x962460,0x7000171a,0x2802100,0x962460,0x70001821,0x6800000,0x1329800,0x70002320,0x7c00100,0x230400,0x70002a00,0x4000000,
-0x1500000,0x70002a00,0x4000000,0x1600000,0x70003000,0x24000000,0x200000,0x70003800,0x24000000,0xe00000,0x70005201,0x2802400,0x962460,0x7000581e,0x7c00100,0x230400,
-0x70006108,0x7c00100,0x220400,0x70006108,0x7c00100,0x250400,0x70006f30,0x7c00100,0x230400,0x70007300,0x24000000,0x200000,0x70007f0e,0x4000000,0x200000,0x70008301,
-0x2802100,0x962460,0x70008301,0x2802400,0x962460,0x70008e00,0x24000000,0x200000,0x70008e00,0x24000000,0x400000,0x70008e00,0x24000002,0x400000,0x70008e00,0x24000008,
-0x1410000,0x70008e00,0x24000010,0x400000,0x70008e00,0x2c000010,0x448000,0x70009519,0x7c00100,0x220400,0x70009519,0x7c00100,0x230400,0x70009519,0x7c00100,0x250400,
-0x70009865,0x7c00100,0x230400,0x70009965,0x4000010,0x400000,0x70009965,0x7c00100,0x230400,0x7000a008,0x7c00100,0x220400,0x7000a008,0x7c00100,0x250400,0x7000a008,
-0x7c00500,0x22040f,0x7000a50e,0x4000000,0x200000,0x7000b61c,0x2802500,0x1862460,0x7000b61c,0x6800500,0x1862400,0x7000b61c,0x7c00100,0x1830000,0x7000c300,0x4000000,
-0x100000,0x7000c941,0x2806000,0x962460,0x7000cc00,0x4000000,0xe00000,0x7000cd00,0x4000000,0x200000,0x7000cd00,0x4000000,0xe00000,0x7000cd00,0x4000000,0x2800000,
-0x7000cf00,0x4000000,0xe00000,0x7000d202,0x2802100,0x962460,0x7000d202,0x7c00100,0x230400,0x7000d997,0x7c00100,0x230400,0x7000d997,0xc000010,0x248000,0x7000dd86,
-0x2802400,0x962460,0x7000dd86,0x7c00100,0x230400,0x7000dd86,0xc000010,0x448000,0x7000de9f,0x4000000,0x200000,0x7000de9f,0x7c00100,0x230400,0x7000e001,0x2400,
-0x962460,0x7000e001,0x2802400,0x962460,0x7000e187,0x2802000,0x962460,0x7000e187,0x2802100,0x962460,0x7000e187,0x4000000,0x200000,0x7000e187,0x7c00100,0x230400,
-0x7000e187,0xc000010,0x448000,0x7000e288,0x7c00100,0x230400,0x7000e300,0x4000000,0x200000,0x7000e489,0x2802100,0x962460,0x7000e489,0x2802400,0x962460,0x7000e489,
-0x6800100,0x962540,0x7000e489,0x6800100,0x962541,0x7000e489,0x6804400,0x962540,0x7000e489,0x7c00100,0x230400,0x7000e489,0x7c00900,0x230400,0x7000e59d,0x2802100,
-0x962460,0x7000e59d,0x2802400,0x962460,0x7000e59d,0x4000000,0x200000,0x7000e59d,0x4000010,0x200000,0x7000e59d,0x6800100,0x962540,0x7000e59d,0x6804400,0x962540,
-0x7000e59d,0x7c00100,0x230400,0x7000e59d,0xc000010,0x448000,0x7000e691,0x2802100,0x962460,0x7000e691,0x2802400,0x962460,0x7000e691,0x2806400,0x962460,0x7000e691,
-0x6800000,0x1329800,0x7000e691,0x6800100,0x962540,0x7000e691,0x7c00100,0x230400,0x7000e700,0x4000400,0x200400,0x7000e70e,0x7c00100,0x220400,0x7000e719,0x7c00100,
-0x220400,0x7000e719,0x7c00500,0x22040f,0x7000e853,0x7c00100,0x230400,0x7000e9a0,0x2802400,0x962460,0x7000e9a0,0x4000000,0x200000,0x7000e9a0,0x4000000,0x500000,
-0x7000e9a0,0x7c00100,0x230400,0x7000ea79,0x2802400,0x962460,0x7000ea79,0x4000000,0x200000,0x7000ea79,0x4000000,0xf00000,0x7000ea79,0x4000010,0x400000,0x7000ea79,
-0x7c00100,0x230400,0x7000eb8c,0x2802400,0x962460,0x7000eb8c,0x4000000,0x200000,0x7000eb8c,0x7c00100,0x230400,0x7000eca3,0x2802100,0x962460,0x7000eca3,0x2806400,
-0x962460,0x7000eca3,0x4000000,0x200000,0x7000eca3,0x6800000,0x1329800,0x7000eca3,0x6800100,0x962540,0x7000eca3,0x7c00100,0x230400,0x7000eca3,0xc000010,0x448000,
-0x7000ed95,0x6800000,0x1329800,0x7000ed95,0x7c00100,0x230400,0x7000ed95,0xc000010,0x448000,0x7000ee1c,0x2802500,0x1862460,0x7000ee1c,0x6800000,0x1329800,0x7000ee1c,
-0x7c00100,0x1830000,0x7000ee1c,0x7c00900,0x1830000,0x7000ef8f,0x4000000,0x200000,0x7000ef8f,0x7c00100,0x230400,0x7000f08e,0x4000000,0x200000,0x7000f08e,0x7c00100,
-0x230400,0x7000f159,0x2802100,0x962460,0x7000f159,0x7c00100,0x230400,0x7000f200,0x4000000,0x200000,0x7000f200,0x4000000,0x1200000,0x7000f200,0x4000000,0x1710000,
-0x7000f34b,0x2802400,0x962460,0x7000f34b,0x4000000,0x200000,0x7000f34b,0x4000010,0x400000,0x7000f34b,0x6800000,0x1329800,0x7000f34b,0x7c00100,0x230400,0x7000f34b,
-0x7c00900,0x230400,0x7000f34b,0xc000010,0x448000,0x7000f490,0x4000000,0x200000,0x7000f490,0x7c00100,0x230400,0x7000f5a5,0x7c00100,0x230400,0x7000f67b,0x4000000,
-0x200000,0x7000f67b,0x4000010,0x200000,0x7000f67b,0x7c00100,0x230400,0x7000f8a6,0x2802100,0x962460,0x7000f8a6,0x2802400,0x962460,0x7000f8a6,0x2806400,0x962460,
-0x7000f8a6,0x4000000,0x500000,0x7000f8a6,0x4000010,0xb00000,0x7000f8a6,0x4000800,0x200000,0x7000f8a6,0x6800100,0x962540,0x7000f8a6,0x6800100,0x962541,0x7000f8a6,
-0x7c00100,0x230400,0x7000f8a6,0xc000010,0x448000,0x7000f921,0x4000000,0x200000,0x7000fa00,0x4000000,0x200000,0x7000fb9e,0x2802100,0x962460,0x7000fb9e,0x2802400,
-0x962460,0x7000fb9e,0x2806400,0x962460,0x7000fb9e,0x4000000,0x200000,0x7000fb9e,0x6800000,0x1329800,0x7000fb9e,0x6800100,0x962540,0x7000fb9e,0x6800100,0x962541,
-0x7000fb9e,0x7c00100,0x230400,0x7000fc92,0x4000000,0x200000,0x7000fc92,0x6800000,0x1329800,0x7000fc92,0x7c00100,0x220400,0x7000fc92,0x7c00100,0x230400,0x7000fc92,
-0x7c00100,0x250400,0x700acd00,0x4000000,0xe00000,0x700acd00,0x4000000,0x2800000,0x700ace00,0x4000000,0xe00000,0x700acf00,0x4000000,0xe00000,0x700acf00,0x4000000,
-0x2800000,0x7050df11,0x4000000,0x200000,0x7050f719,0x80000,0x918820,0x7080afa1,0x2802400,0x962460,0x7090df11,0x2802400,0x962460,0x70d0e417,0x2802100,0x962460,
-0x70d0e417,0x2802400,0x962460,0x70d0e417,0x6800100,0x962540,0x70d0ea15,0x4000010,0x400000,0x8000120f,0x7c00100,0x230400,0x80001524,0x7c00100,0x230400,0x8000171a,
-0x7c00100,0x230400,0x80002006,0x7c00100,0x220400,0x80002006,0x7c00100,0x250400,0x80002a00,0x4000000,0x1500000,0x80002d00,0x4000000,0x200000,0x80005208,0x2802400,
-0x962460,0x80005c00,0x4000000,0x200000,0x80007300,0x24000000,0x200000,0x80009519,0x7c00100,0x220400,0x80009519,0x7c00100,0x230400,0x80009519,0x7c00100,0x250400,
-0x80009865,0x7c00100,0x230400,0x8000a008,0x2802100,0x962460,0x8000b30a,0x4000000,0x500000,0x8000b30a,0x7c00100,0x230400,0x8000cd00,0x4000000,0xe00000,0x8000d202,
-0x2802500,0x962460,0x8000d202,0x7c00100,0x230400,0x8000d68d,0x4000000,0x200000,0x8000d997,0x2802000,0x962460,0x8000d997,0x2802400,0x962460,0x8000d997,0x4000000,
-0x400000,0x8000d997,0x4000000,0x500000,0x8000d997,0x7c00100,0x230400,0x8000d997,0xc000010,0x448000,0x8000e489,0x2802100,0x962460,0x8000e489,0x7c00100,0x230400,
-0x8000e719,0x7c00100,0x220400,0x8000f8a6,0x2802100,0x962460,0x8000f8a6,0x7c00100,0x230400,0x8000f8a6,0xc000010,0x448000,0x8000fda1,0x2802100,0x1862460,0x8000fda1,
-0x2806400,0x1862460,0x8000fda1,0x4000000,0x1800000,0x8000fda1,0x6800000,0x1329800,0x8000fda1,0x6800100,0x1862400,0x8000fda1,0x6800100,0x1862540,0x8000fda1,0x7c00100,
-0x1830000,0x8000fda1,0xc000010,0x448000,0x8000fe9c,0x7c00100,0x230400,0x8000fe9c,0x7c00100,0x830400,0x8000fe9c,0x7c00100,0x1430400,0x8000ff06,0x7c00100,0x220400,
-0x80010165,0x7c00100,0x230400,0x800102a2,0x4000000,0x200000,0x800102a2,0x7c00100,0x230400,0x800103a4,0x7c00100,0x230400,0x800103a4,0xc000010,0x448000,0x8001044c,
-0x4000000,0x200000,0x8001044c,0x7c00100,0x220400,0x8001044c,0x7c00100,0x250400,0x80010670,0x2802000,0x962460,0x80010670,0x4000000,0x200000,0x80010670,0x4000010,
-0x400000,0x80010670,0xc000010,0x448000,0x800a4711,0x7c40300,0xe30000,0x800acd00,0x4000000,0xe00000,0x800acd00,0x4000000,0x2902460,0x800ace00,0x4000000,0xe00000,
-0x800acf00,0x4000000,0xe00000,0x800b0011,0x7c40300,0xe30000,0x800b0500,0x4000000,0xe00000,0x800b0500,0x4000000,0x2800000,0x90001615,0x7c00100,0x230400,0x9000171a,
-0x4000000,0x200000,0x9000171a,0x7c00100,0x230400,0x90003000,0x24000000,0x200000,0x90007f0e,0x4000000,0x200000,0x90008301,0x2802400,0x962460,0x90008e00,0x24000000,
-0x400000,0x90009519,0x7c00100,0x250400,0x9000a16f,0x2802100,0x962460,0x9000d200,0x80000000,0x218960,0x9000d202,0x2802000,0x962460,0x9000d202,0x2802100,0x962460,
-0x9000d202,0x7c00100,0x230400,0x9000e59d,0x2802100,0x962460,0x90010500,0x4000000,0xe00000,0x900107a7,0x2802100,0x962460,0x900107a7,0x2802400,0x962460,0x900107a7,
-0x2802c00,0x962460,0x900107a7,0x4000000,0x1400000,0x900107a7,0x6800000,0x1329800,0x900107a7,0x7c00100,0x220400,0x900107a7,0x7c00100,0x250400,0x900108a8,0x2802100,
-0x962460,0x900108a8,0x2806400,0x962460,0x900108a8,0x4000000,0x200000,0x900108a8,0x4000000,0x400000,0x900108a8,0x4000010,0x400000,0x900108a8,0x6800000,0x1329800,
-0x900108a8,0x6800100,0x962540,0x900108a8,0x7c00100,0x230400,0x900108a8,0xc000010,0x448000,0x90010908,0x7c00100,0x220400,0x90010a38,0x2802100,0x962460,0x90010ca9,
-0x2802100,0x962460,0x90010ca9,0x4000000,0x500000,0x90010ca9,0x4000010,0xb00000,0x90010ca9,0x6800100,0x962540,0x90010ca9,0x7c00100,0x230400,0x90010d1b,0x4000000,
-0x500000,0x90010eaa,0x2802100,0x962460,0x90010eaa,0x2802400,0x962460,0x90010eaa,0x2806400,0x962460,0x90010eaa,0x4000000,0x200000,0x90010eaa,0x4000000,0x400000,
-0x90010eaa,0x4000010,0x400000,0x90010eaa,0x6800000,0x1329800,0x90010eaa,0x6800100,0x962540,0x90010eaa,0x7c00100,0x230400,0x90010eaa,0xc000010,0x448000,0x90010fab,
-0x7c00100,0x220400,0x90010fab,0x7c00100,0x250400,0x9002c300,0x4000000,0x100000,0x900ac400,0x4000000,0xe0000d,0x900acd00,0x4000000,0xe00000,0x900acd00,0x4000000,
-0x2800000,0x900acf00,0x4000000,0xe00000,0x900b0500,0x4000000,0xe00000,0x900b0500,0x4000000,0x2800000,0x900b0b9a,0x7c00900,0x1230400,0x900b109a,0x7c00300,0xe30000,
-0x900b119a,0x7c00300,0xe30000,0x90408e06,0x24000000,0x400000,0xa0001004,0x4000000,0x200000,0xa0001004,0x7c00100,0x230400,0xa000120f,0x2802100,0x962460,0xa000120f,
-0x2802400,0x962460,0xa000171a,0x2802100,0x962460,0xa000171a,0x2806400,0x962460,0xa0002a00,0x4000000,0x1600000,0xa0003000,0x24000000,0x200000,0xa000581e,0x7c00100,
-0x230400,0xa0007300,0x24000000,0x200000,0xa0008301,0x2802400,0x962460,0xa0008e00,0x24000000,0x400000,0xa000cf00,0x4000000,0xe00000,0xa0010500,0x4000000,0x200000,
-0xa00114af,0x2802100,0x962460,0xa00114af,0x2802400,0x962460,0xa00114af,0x2806400,0x962460,0xa00114af,0x6800000,0x1329800,0xa00114af,0x7c00100,0x230400,0xa00114af,
-0x7c00100,0x230560,0xa00116b0,0x2802100,0x962460,0xa00116b0,0x2802800,0x962460,0xa00116b0,0x2806400,0x962460,0xa00116b0,0x4000000,0x400000,0xa00116b0,0x4000000,
-0x500000,0xa00116b0,0x4000010,0x400000,0xa00116b0,0x6800100,0x962540,0xa00116b0,0x7c00100,0x230400,0xa00116b0,0x7c00100,0x230560,0xa00116b0,0xc000010,0x448000,
-0xa0011722,0x7c00100,0x230400,0xa00118b1,0x2802000,0x962460,0xa00118b1,0x2802100,0x962460,0xa00118b1,0x2806400,0x962460,0xa00118b1,0x4000000,0x200000,0xa00118b1,
-0x4000000,0x400000,0xa00118b1,0x4000000,0x500000,0xa00118b1,0x6800100,0x962540,0xa00118b1,0x7c00100,0x230400,0xa00118b1,0x7c00100,0x230560,0xa00118b1,0xc000010,
-0x448000,0xa00a4005,0x7c00100,0xe30400,0xa00a4711,0x7c40300,0xe30000,0xa00ac400,0x4000000,0xe00000,0xa00acb14,0x7c00100,0xe30000,0xa00acf00,0x4000000,0xe00000,
-0xa00b0500,0x4000000,0xe00000,0xa00b0500,0x4000000,0x2800000,0xa00b0b96,0x7c00900,0x1230400,0xa00b1211,0x7c40300,0xe30000,0xa00b1314,0x7c00100,0xe30000,0xa00b1596,
-0x7c00300,0xe30000,0xa040afb7,0x6800400,0x962540,0xa08083b8,0x2802400,0x962460,0xb0000a03,0x7c00100,0x220400,0xb0000b13,0x7c00100,0x2633800,0xb0001004,0x2802000,
-0x962460,0xb0001110,0x4000000,0x200000,0xb0001524,0x2802000,0x962460,0xb0001615,0x4000000,0x500000,0xb000251b,0x7c00100,0x230400,0xb0007300,0x24000000,0x200000,
-0xb0008939,0x4000000,0x200000,0xb0008939,0x7c00100,0x230400,0xb0008e00,0x24000000,0x200000,0xb0008e00,0x24000000,0x400000,0xb0008e00,0x24000010,0x400000,0xb0009257,
-0x2802000,0x962460,0xb0009257,0x4000000,0x1600000,0xb0009519,0x7c00100,0x220400,0xb0009519,0x7c00100,0x250400,0xb0009a00,0x4000000,0x200000,0xb000b30a,0x2802100,
-0x962460,0xb000b30a,0x7c00100,0x230400,0xb000c178,0x80000000,0x218960,0xb000c300,0x4000000,0x200000,0xb000d202,0x2802000,0x962460,0xb000d476,0x6800100,0x962540,
-0xb000d476,0x7c00100,0x230400,0xb000e300,0x4000000,0xe00000,0xb000fda1,0x7c00100,0x1830000,0xb0010eaa,0x2802000,0x962460,0xb00116b0,0x7c00100,0x230400,0xb0011900,
-0x4000000,0xe00000,0xb0011ab2,0x2802100,0x962460,0xb0011ab2,0x2802400,0x962460,0xb0011ab2,0x2806400,0x962460,0xb0011ab2,0x4000000,0x200000,0xb0011ab2,0x6800100,
-0x962540,0xb0011ab2,0x7c00100,0x230400,0xb0011b0c,0x7c00100,0x230400,0xb0011cb3,0x2802100,0x962460,0xb0011cb3,0x2806400,0x962460,0xb0011cb3,0x6800000,0x1329800,
-0xb0011cb3,0x6800100,0x962540,0xb0011cb3,0x7c00100,0x230400,0xb0011db6,0x2802500,0x962460,0xb0011db6,0x6800000,0x1329800,0xb0011db6,0x7c00100,0x230400,0xb0011db6,
-0x7c00500,0x230400,0xb0011e00,0x4000000,0x200000,0xb0011e00,0x4000000,0x1500000,0xb0011fb4,0x2802100,0x962460,0xb0011fb4,0x6800100,0x962540,0xb0011fb4,0x7c00100,
-0x230400,0xb0011fb4,0xc000010,0x248000,0xb0012000,0x4000000,0x200000,0xb00121b5,0x4000000,0x200000,0xb00121b5,0x4000010,0x400000,0xb00121b5,0x7c00100,0x220400,
-0xb00121b5,0x7c00100,0x250400,0xb00121b5,0xc000010,0x448000,0xb00122b8,0x4000000,0x200000,0xb00122b8,0x7c00100,0x230400,0xb00123b7,0x2802400,0x962460,0xb00123b7,
-0x4000000,0x200000,0xb00123b7,0x7c00100,0x230400,0xb00123b7,0xc000010,0x248000,0xb00a4005,0x7c00100,0xe30400,0xb00a4711,0x7c40300,0xe30000,0xb00acf00,0x4000000,
-0xe00000,0xb00b0500,0x4000000,0xe00000,0xb00b0500,0x4000000,0x2800000,0xb00b109a,0x7c00300,0xe30000,0xb080e487,0x2802000,0x962460,0xc0001524,0x4000000,0x500000,
-0xc0001a18,0x2806400,0x1862460,0xc0001a18,0x7c00100,0x1830000,0xc0007300,0x24000000,0x200000,0xc0008e00,0x24000010,0x400000,0xc0009519,0x7c00100,0x220400,0xc0009519,
-0x7c00100,0x250400,0xc000c300,0x4000000,0x20000f,0xc000d85c,0x2802100,0x962460,0xc000d85c,0x6800100,0x962540,0xc000d85c,0x7c00100,0x230400,0xc000dc99,0x7c00100,
-0x230400,0xc000e719,0x7c00100,0x220400,0xc00107a7,0x7c00100,0x230400,0xc0010eaa,0x7c00100,0x230400,0xc00116b0,0x7c00100,0x230560,0xc0011900,0x4000000,0x200000,
-0xc0012447,0,0x818820,0xc0012447,0,0xc18820,0xc0012447,0,0x1418820,0xc00125b9,0x7c00100,0x230400,0xc00126bb,0x2802100,0x962460,0xc00126bb,
-0x2806400,0x962460,0xc00126bb,0x4000000,0x500000,0xc00126bb,0x6800100,0x962540,0xc00126bb,0x7c00100,0x230400,0xc00127ba,0x2802400,0x962460,0xc00127ba,0x4000000,
-0x200000,0xc00127ba,0x6800000,0x1329800,0xc00127ba,0x7c00100,0x230400,0xc00127ba,0x7c00900,0x230400,0xc0012800,0x4000000,0x200000,0xc0012b23,0x4000000,0x200000,
-0xc0012b23,0x4000000,0x400000,0xc0012b23,0x4000000,0x1500000,0xc0012cbc,0x2802400,0x962460,0xc0012cbc,0x4000000,0x1600000,0xc0012cbc,0x6800000,0x1329800,0xc0012cbc,
-0x7c00100,0x230400,0xc00acf00,0x4000000,0xe00000,0xc00ae300,0x4000000,0xe00000,0xc00b0500,0x4000000,0xe00000,0xc00b0500,0x4000000,0x2800000,0xc00b0b11,0x4000000,
-0x1200000,0xc00b0b11,0x7c00900,0x1230400,0xc00b109a,0x7c00300,0xe30000,0xc00b2914,0x7c00100,0x2530000,0xc00b2916,0x7c00100,0x2530c00,0xc00b2a00,0x4000000,0xe00000,
-0xc040af5e,0x7c00100,0x230400,0xc0c12b89,0x4000000,0x200000,0xc14a44ca,0x4000000,0xe0000d,0xd000131f,0x2802c00,0x962460,0xd000171a,0x7c00100,0x230400,0xd0001821,
-0x2802100,0x962460,0xd0007300,0x24000000,0x200000,0xd0008e00,0x24000000,0x200000,0xd0008f3a,0x2806000,0x962460,0xd0009519,0x7c00100,0x220400,0xd0009519,0x7c00100,
-0x250400,0xd000a500,0x4000000,0x200000,0xd000c300,0x4000000,0xe00000,0xd000d202,0x7c00100,0x230400,0xd000d476,0x7c00100,0x230400,0xd000d997,0x2802100,0x962460,
-0xd000d997,0x6800100,0x962540,0xd000e001,0x2802100,0x962460,0xd000e700,0x4000400,0x200000,0xd000e719,0x7c00100,0x220400,0xd000e719,0x7c00500,0x23040f,0xd000fa00,
-0x4000000,0xe00000,0xd0010eaa,0x4000010,0x400000,0xd0010eaa,0x7c00100,0x230400,0xd0012dbd,0x4000000,0x200000,0xd0012dbd,0x7c00100,0x230400,0xd0012fbe,0x2802100,
-0x962460,0xd0012fbe,0x2802400,0x962460,0xd0012fbe,0x2806400,0x962460,0xd0012fbe,0x4000000,0x400000,0xd0012fbe,0x6800000,0x1329800,0xd0012fbe,0x6800100,0x962540,
-0xd0012fbe,0x6800100,0x962541,0xd0012fbe,0x6804400,0x962540,0xd0012fbe,0x7c00100,0x230400,0xd0012fbe,0x7c00100,0x230560,0xd0012fbe,0xc000010,0x448000,0xd0013183,
-0x7c00100,0x230400,0xd0013200,0x4000000,0x200000,0xd0013200,0x6800000,0x1329805,0xd00134c0,0x2802100,0x962460,0xd00134c0,0x4000002,0x400000,0xd00134c0,0x7c00100,
-0x230400,0xd00a4305,0x7c00100,0xe30400,0xd00a4611,0x7c40300,0xe30000,0xd00a4711,0x7c40300,0xe30000,0xd00a5e11,0x7c40300,0xe30000,0xd00acf00,0x4000000,0xe00000,
-0xd00b0500,0x4000000,0xe00000,0xd00b0500,0x4000000,0x2800000,0xd00b0b11,0x6800500,0x962540,0xd00b0bbf,0x2802200,0xc62460,0xd00b119a,0x7c00300,0xe30000,0xd00b2a00,
-0x4000000,0xe00000,0xd00b2e11,0x7c40300,0xe30000,0xd00b30bf,0x7c00300,0x230000,0xd00b339a,0x7c00300,0xe30000,0xe0000c02,0xc000010,0xb48000,0xe0001524,0x2802400,
-0x962460,0xe0001524,0x7c00100,0x230400,0xe0001615,0x7c00100,0x230400,0xe000251b,0x12882000,0x962460,0xe0002a00,0x4000000,0x1500000,0xe0005102,0x4000000,0x200000,
-0xe0005c00,0x4000000,0x200000,0xe000622a,0x6804400,0x962540,0xe000622a,0x7c00100,0x230400,0xe0008838,0x7c00100,0x220400,0xe0008838,0x7c00100,0x250400,0xe0008e00,
-0x24000000,0x810000,0xe0008e00,0x24000000,0x1410000,0xe0008e00,0x24000002,0x400000,0xe0008e00,0x2c000010,0xb48000,0xe000933e,0x7c00100,0x230400,0xe000933e,0xc000010,
-0x448000,0xe0009519,0x7c00100,0x220400,0xe0009519,0x7c00100,0x23040f,0xe0009519,0x7c00100,0x250400,0xe000c178,0x2802100,0x962460,0xe000c941,0x2802100,0x962460,
-0xe000c941,0x2806400,0x962460,0xe000c941,0x7c00100,0x230400,0xe000d202,0x2802400,0x962460,0xe000d202,0x7c00100,0x230400,0xe000d202,0x7c00500,0x230400,0xe000dc99,
-0x4000000,0x200000,0xe000e001,0x2802100,0x962460,0xe000e001,0x2802400,0x962460,0xe000fda1,0x7c00100,0x1830000,0xe0013502,0x2802400,0x962460,0xe0013502,0x4000000,
-0x200000,0xe0013502,0x7c00100,0x230400,0xe0013502,0x80000000,0x218960,0xe00136c1,0x4000000,0x200000,0xe00136c1,0x7c00100,0x230400,0xe001370b,0x7c00100,0x230400,
-0xe0013919,0x7c00500,0x220400,0xe0013919,0x7c00500,0x22040f,0xe0013919,0x7c00d00,0x23040f,0xe0013a19,0x7c00100,0x220400,0xe0013a19,0x7c00100,0x230400,0xe0013bc2,
-0x2802400,0x962460,0xe0013bc2,0x7c00100,0x230400,0xe0013bc2,0xc000010,0x248000,0xe0013cc3,0x6800000,0x1329800,0xe0013cc3,0x7c00100,0x230400,0xe0013dc4,0x2802400,
-0x962460,0xe0013dc4,0x7c00100,0x230400,0xe0013e28,0x7c00100,0x230400,0xe0013fc5,0x7c00100,0x220400,0xe0013fc5,0x7c00100,0x250400,0xe0014000,0x4000000,0x200000,
-0xe0014001,0x2802400,0x962460,0xe00a4711,0x7c40300,0xe30000,0xe00a5e11,0x7c40300,0xe30000,0xe00ac511,0x7c40300,0xe30000,0xe00acf00,0x4000000,0xe00000,0xe00ae300,
-0x4000000,0xe00000,0xe00b0500,0x4000000,0xe00000,0xe00b1314,0x7c00100,0xe30000,0xe00b1316,0x7c00100,0xe30c00,0xe00b2a00,0x4000000,0xe00000,0xe00b2a00,0x4000000,
-0x2800000,0xe00b3816,0x7c00500,0x230c00,0xe0808328,0x2802400,0x962460};
+0,0xc167,0,0,0xc367,0,0xe00000,0xc467,0,0xe00000,0xc667,0,0,0xc767,0,0,
+0xc867,0,0,0xc967,0,0,0xca67,0,0,0xcc67,0,0xe00000,0xcf67,0,0xe00000,0xd067,
+0,0xe00000,0xd367,0,0,0xd467,0,0,0xd567,0,0,0xd667,0,0,0xd867,0,
+0,0xda67,0,0,0xdb67,0,0,0xdc67,0,0,0xdd67,0,0,0xde67,0,0,
+0xdf67,0,0,0xe067,0,0,0xe167,0,0,0xe267,0,0,0xe367,0,0xe00000,0xe467,
+0,0,0xe567,0,0,0xe667,0,0,0xe767,0,0,0xe867,0,0,0xe967,0,
+0,0xea67,0,0,0xeb67,0,0,0xec67,0,0,0xed67,0,0,0xee67,0,0,
+0xef67,0,0,0xf167,0,0,0xf367,0,0,0xf567,0,0,0xf667,0,0,0xf767,
+0,0,0xf867,0,0,0xf967,0,0,0xfa67,0,0xe00000,0xfb67,0,0,0xfc67,0,
+0,0xfd67,0,0,0xfe67,0,0,0x10167,0,0,0x10267,0,0,0x10367,0,0,
+0x10467,0,0,0x10667,0,0,0x10767,0,0,0x10867,0,0,0x10967,0,0,0x10a67,
+0,0,0x10b67,0,0,0x10c67,0,0,0x10d67,0,0,0x10e67,0,0,0x10f67,0,
+0,0x11067,0,0,0x11367,0,0,0x11467,0,0,0x11567,0,0,0x11667,0,0,
+0x11767,0,0,0x11867,0,0,0x11967,0,0xe00000,0x11a67,0,0,0x11b67,0,0,0x11c67,
+0,0,0x11d67,0,0,0x11e67,0,0,0x11f67,0,0,0x12067,0,0,0x12167,0,
+0,0x12267,0,0,0x12367,0,0,0x12467,0,0,0x12567,0,0,0x12667,0,0,
+0x12767,0,0,0x12867,0,0,0x12967,0,0,0x12a67,0,0xe00000,0x12b67,0,0,0x12c67,
+0,0,0x12d67,0,0,0x12f67,0,0,0x13067,0,0,0x13167,0,0,0x13267,0,
+0,0x13367,0,0,0x13467,0,0,0x13567,0,0,0x13667,0,0,0x13767,0,0,
+0x13867,0,0,0x13967,0,0,0x13a67,0,0,0x13b67,0,0,0x13c67,0,0,0x13d67,
+0,0,0x13f67,0,0,0x14067,0,0,0x14167,0,0,0x14367,0,0,0x14467,0,
+0,0x14567,0,0,0x14667,0,0,0x14767,0,0,0xa0067,0,0xe00000,0xa4f67,0,0xe00000,
+0xa5f67,0,0xe00000,0xac567,0,0xe00000,0xad167,0,0xe00000,0xb0067,0,0xe00000,0xb1267,0,0xe00000,0xb2e67,
+0,0xe00000,0x11000100,0,0x900020,0x11000100,0x40000001,0x440020,0x11000100,0x40000001,0x643020,0x11000100,0x40000001,0xa5a040,0x11000100,0x40000001,
+0x116a8a0,0x11000200,0,0x900020,0x11000200,0x4000001,0xc4000b,0x11000200,0x7c00100,0x220402,0x11000200,0x24000000,0x200000,0x11000200,0x24000008,0x1710000,
+0x11000200,0x40000001,0x1d3b020,0x11000219,0x7c00100,0x220401,0x11000219,0x7c00100,0x250401,0x11000319,0x7c00100,0x220401,0x11000319,0x7c00100,0x220402,0x11000319,
+0x7c00100,0x250400,0x11000319,0x7c00100,0x250401,0x11000419,0x7c00100,0x220400,0x11000419,0x7c00100,0x220401,0x11000419,0x7c00100,0x220402,0x11000419,0x7c00100,
+0x230400,0x11000419,0x7c00100,0x250400,0x11000419,0x7c00100,0x250401,0x11000419,0x7c00100,0x250402,0x11000519,0x7c00100,0x220400,0x11000519,0x7c00100,0x230400,
+0x11000600,0x4000400,0x200002,0x11000600,0x4000400,0x200400,0x11000600,0x7c00500,0x220400,0x11000600,0x7c00500,0x230400,0x11000600,0x7c00500,0x530400,0x11000600,
+0x7c00d00,0x230400,0x11000619,0x7c00500,0x22040f,0x11000800,0x4000010,0x1001401,0x11000800,0x4000400,0x200001,0x11000800,0x6800010,0x201001,0x11000800,0x7c00500,
+0x230401,0x11000807,0x7c00100,0x220400,0x11000807,0x7c00100,0x250400,0x1100080e,0x4000400,0x200000,0x1100080e,0x4000400,0x200002,0x1100080e,0x7000500,0x220402,
+0x1100080e,0x7c00100,0x220400,0x1100080e,0x7c00100,0x220401,0x1100080e,0x7c00100,0x220402,0x1100080e,0x7c00100,0x250400,0x1100080e,0x7c00100,0x250401,0x1100080e,
+0x7c00120,0x220402,0x1100080e,0x7c00120,0x250402,0x11000908,0x4000000,0x200000,0x11000908,0x7c00100,0x220400,0x11000908,0x7c00100,0x220401,0x11000908,0x7c00100,
+0x250400,0x11000908,0x7c00100,0x250401,0x11000a03,0x4000000,0x200400,0x11000a03,0x4000000,0x201000,0x11000a03,0x4000000,0x270000,0x11000a03,0x7c00100,0x220400,
+0x11000a03,0x7c00100,0x220402,0x11000a03,0x7c00100,0x250400,0x11000a03,0x7c00500,0x230400,0x11000a03,0xc000010,0x1049400,0x11000b13,0x2802500,0x962460,0x11000b13,
+0x4000000,0x200000,0x11000b13,0x4000000,0x201000,0x11000b13,0x4000000,0x230400,0x11000b13,0x4000002,0x400000,0x11000b13,0x4000010,0x200000,0x11000b13,0x7c00100,
+0x2633800,0x11000c00,0x80000000,0x218960,0x11000c02,0x2802100,0x962460,0x11000c02,0x2802400,0x962460,0x11000c02,0x4000000,0x200000,0x11000c02,0x4000000,0x1329400,
+0x11000c02,0x4000000,0x1329800,0x11000c02,0x4000000,0x1500000,0x11000c02,0x6800000,0x1329800,0x11000c02,0x7c00100,0x230400,0x11000c02,0x7c00100,0x230401,0x11000c02,
+0x7c00100,0x230402,0x11000c02,0x7c00500,0x230400,0x11000c02,0x7d00100,0x230400,0x11000f01,0x2802400,0x962460,0x11000f0a,0x2802100,0x962460,0x11000f0a,0x2802400,
+0x962460,0x11000f0a,0x2806400,0x962460,0x11000f0a,0x4000000,0x200000,0x11000f0a,0x6800100,0x962540,0x11000f0a,0x7c00100,0x230400,0x11000f0a,0x7c00100,0x230401,
+0x11001004,0x2802100,0x962460,0x11001004,0x2802400,0x962460,0x11001004,0x2806400,0x962460,0x11001004,0x4000000,0x200000,0x11001004,0x4000000,0x1500000,0x11001004,
+0x6800100,0x962540,0x11001004,0x6800100,0x962541,0x11001004,0x7c00100,0x230400,0x11001004,0x7c00100,0x230401,0x11001110,0x2802100,0x962460,0x11001110,0x2802400,
+0x962460,0x11001110,0x2806400,0x962460,0x11001110,0x6800100,0x962540,0x11001110,0x7c00100,0x230400,0x11001110,0x7c00100,0x230401,0x1100120f,0x2802100,0x962460,
+0x1100120f,0x2802400,0x962460,0x1100120f,0x2806400,0x962460,0x1100120f,0x6800100,0x962540,0x1100120f,0x7c00100,0x230400,0x1100131f,0x2802100,0x962460,0x1100131f,
+0x2802400,0x962460,0x1100131f,0x2806400,0x962460,0x1100131f,0x4000000,0x200000,0x1100131f,0x6800000,0x1329800,0x1100131f,0x6800100,0x962540,0x1100131f,0x6800100,
+0x962541,0x1100131f,0x7c00100,0x230400,0x1100131f,0x7c00100,0x230401,0x11001423,0x2802100,0x962460,0x11001423,0x2806400,0x962460,0x11001423,0x6800100,0x962540,
+0x11001423,0x6800100,0x962541,0x11001423,0x7c00100,0x230400,0x11001423,0x7c00100,0x230401,0x11001524,0x2802100,0x962460,0x11001524,0x2802100,0x962461,0x11001524,
+0x2806400,0x962460,0x11001524,0x6800000,0x1329800,0x11001524,0x6800100,0x962540,0x11001524,0x7c00100,0x230400,0x11001615,0x2802100,0x962460,0x11001615,0x2806400,
+0x962460,0x11001615,0x6800100,0x962540,0x11001615,0x6800100,0x962541,0x11001615,0x7c00100,0x230400,0x1100171a,0x2802100,0x962460,0x1100171a,0x2806400,0x962460,
+0x1100171a,0x6800000,0x1329800,0x1100171a,0x6800100,0x962540,0x1100171a,0x6800100,0x962541,0x1100171a,0x7c00100,0x230400,0x11001900,0x4000000,0x1600000,0x11001926,
+0x2802100,0x1862460,0x11001926,0x2802400,0x1862460,0x11001926,0x2806100,0x1862460,0x11001926,0x4000000,0x200000,0x11001926,0x4000010,0x400000,0x11001926,0x6800000,
+0x1329800,0x11001926,0x7800100,0x1830142,0x11001926,0x7c00100,0x1830000,0x11001926,0x7c00900,0x1830000,0x11001926,0x7e00100,0x1830000,0x11001a18,0x2802100,0x1862460,
+0x11001a18,0x2802400,0x1862460,0x11001a18,0x6800000,0x1329800,0x11001a18,0x7800100,0x1830142,0x11001a18,0x7c00100,0x1830000,0x11001a18,0x7c00100,0x1830002,0x11001a18,
+0x7c00900,0x1830000,0x11001a18,0x7e00100,0x1830000,0x11001d0c,0x7c00100,0x230400,0x11001d0c,0x7c00100,0x250400,0x11001e12,0x7c00100,0x2230500,0x11001e12,0x7c00100,
+0x2330520,0x11001e12,0x7c80100,0x2330520,0x11002619,0x7c00100,0x220401,0x11002619,0x7c00100,0x220402,0x11002619,0x7c00100,0x250401,0x1100270e,0x4000400,0x200001,
+0x1100270e,0x4000400,0x200002,0x1100270e,0x4000400,0x500001,0x1100270e,0x7c00100,0x220401,0x1100270e,0x7c00100,0x250401,0x11002800,0x80000,0x918820,0x11002800,
+0x80000,0x1c18020,0x11002800,0x180000,0x918820,0x11002800,0x4000001,0x445801,0x11002800,0x4000001,0x445802,0x11002800,0x4000001,0xc4000b,0x11002800,0x6800000,
+0x201c00,0x11002800,0x6800020,0x201c00,0x11002800,0x24000000,0x200000,0x11002800,0x24000000,0x200002,0x11002800,0x24000000,0x810000,0x11002800,0x24000000,0x1410000,
+0x11002800,0x24000000,0x1500000,0x11002800,0x24000000,0x1500002,0x11002800,0x24000002,0x400000,0x11002800,0x24000006,0xc0000b,0x11002800,0x24000008,0x1410000,0x11002800,
+0x24000008,0x1710000,0x11002800,0x24000020,0x1001400,0x11002800,0x24000020,0x1500002,0x11002800,0x2c000010,0x1248000,0x11002800,0x2c000010,0x1248002,0x11002800,0x40000001,
+0x63b020,0x11002800,0x40080000,0x918820,0x11002801,0x80000,0x2a65620,0x11002801,0x82000,0x962460,0x11002900,0x4000000,0x20000e,0x11002900,0x4000000,0x20000f,
+0x11002900,0x4000020,0x20000e,0x11002900,0x4000020,0x20000f,0x11002900,0x4000020,0x81000e,0x11002900,0x4000020,0x81000f,0x11002900,0x4000020,0x141000e,0x11002900,
+0x4000020,0x141000f,0x11002900,0x4000022,0x20000e,0x11002900,0x4000022,0x20000f,0x11002a00,0x4000000,0x1500000,0x11002a00,0x4000000,0x1600000,0x11002a00,0x4000000,
+0x1600002,0x11002b01,0x2000,0x962460,0x11002b01,0x2802020,0x962460,0x11002c00,0x4000000,0x200000,0x11002c00,0x4000000,0x200002,0x11002c00,0x4000000,0x20000f,
+0x11002c00,0x4000020,0x200000,0x11002c00,0x7c00000,0x200000,0x11002c00,0x7c00020,0x200000,0x11002c00,0x7c00120,0x220405,0x11002c00,0x7c00120,0x230402,0x11002c00,
+0x7c00120,0x250402,0x11002c00,0x7c00120,0x250405,0x11002c19,0x7c00100,0x250400,0x11002c19,0x7c00100,0x250401,0x11002d00,0x4000000,0x100006,0x11002d00,0x4000000,
+0x200006,0x11002d19,0x7c00100,0x220402,0x11002d19,0x7c00100,0x230400,0x11002d19,0x7c00100,0x250402,0x11002e00,0x24000000,0x200000,0x11002e00,0x24000020,0x200000,
+0x11002e00,0x24000020,0x200001,0x11002f00,0x24000020,0x200000,0x11002f00,0x24000020,0x200001,0x11002f00,0x24000020,0x200002,0x11002f00,0x24000020,0xf00000,0x11002f00,
+0x24000020,0x1600000,0x11002f00,0x24000022,0x1600000,0x11003000,0x24000000,0x200000,0x11003000,0x24000020,0x200000,0x11003000,0x24000020,0x810000,0x11003000,0x24000020,
+0x1410000,0x11003100,0x24000000,0x200000,0x11003200,0x24000000,0x200000,0x11003300,0x4000000,0x100003,0x11003400,0x24000000,0x100000,0x11003400,0x24000000,0x200000,
+0x11003500,0x24000000,0x200000,0x11003600,0x24000000,0x200000,0x11003600,0x24000020,0x200000,0x11003700,0x24000000,0x200000,0x11003700,0x24000000,0xe00000,0x11003700,
+0x24000000,0x2800000,0x11003700,0x24000020,0x200000,0x11003800,0x4000000,0x100000,0x11003800,0x24000000,0x200000,0x11003800,0x24000000,0xb00000,0x11003800,0x24000000,
+0xe00000,0x11003800,0x24000000,0x1710000,0x11003800,0x24000000,0x2800000,0x11005003,0x7c00100,0x220402,0x11005013,0x2802500,0x962460,0x11005013,0x4000020,0x200005,
+0x11005013,0x7c00100,0x2633801,0x11005013,0x7c00100,0x2633802,0x11005013,0x7c00100,0x2633805,0x11005019,0x7c00100,0x220402,0x11005102,0x7000100,0x230408,0x11005102,
+0x7c00100,0x230404,0x11005102,0x7c00100,0x230407,0x11005102,0x7c00100,0x230408,0x11005102,0x7c00100,0x230409,0x11005201,0x2802400,0x962460,0x11005500,0x80000,
+0x1e18820,0x11005502,0x7000100,0x230408,0x11005502,0x7c00100,0x230404,0x11005502,0x7c00100,0x230407,0x11005502,0x7c00100,0x230408,0x11005502,0x7c00100,0x230409,
+0x11005667,0x1000,0,0x11020200,0x80004,0x418820,0x11020200,0x4000000,0x100006,0x11020200,0x4000000,0x10000f,0x11020200,0x4000400,0x100002,0x11020200,
+0x4000400,0x500002,0x11020200,0x6800c00,0x101000,0x11020200,0x24000000,0x100000,0x11020200,0x24000000,0x200000,0x11020200,0x24000000,0x1400000,0x11020200,0x24000000,
+0x1500000,0x11020200,0x24000000,0x1600000,0x11020200,0x24000020,0x100000,0x11020200,0x24000020,0x1600000,0x11020219,0x7c00100,0x12040f,0x11020219,0x7c00100,0x220400,
+0x11020219,0x7c00100,0x220401,0x11020219,0x7c00100,0x250400,0x11020319,0x7c00100,0x220400,0x11020319,0x7c00100,0x220401,0x11020319,0x7c00100,0x220402,0x11020319,
+0x7c00100,0x250400,0x11020319,0x7c00100,0x250402,0x11020319,0x7d00100,0x220402,0x11020419,0x7c00100,0x220401,0x11020519,0x7c00100,0x220400,0x11020600,0x4000400,
+0x100002,0x11020600,0x4000400,0x200400,0x11020600,0x7c00500,0x130400,0x11020600,0x7c00d00,0x130400,0x11020701,0x2802400,0x962460,0x11020701,0x2802400,0x962461,
+0x11020701,0x2802400,0xc62460,0x1102080e,0x7c00100,0x220400,0x1102080e,0x7c00100,0x250400,0x11020908,0x7c00100,0x220400,0x11020908,0x7c00100,0x220401,0x11020908,
+0x7c00100,0x250400,0x11020908,0x7c00100,0x250401,0x11022800,0x24000000,0x100000,0x11022800,0x24000000,0x200000,0x11022800,0x24000000,0x200002,0x11022800,0x24000000,
+0x401000,0x11022800,0x24000000,0xf00002,0x11022800,0x24000000,0xf0ac02,0x11022800,0x24000000,0x1500000,0x11022800,0x24000002,0x100000,0x11022800,0x24000002,0x370000,
+0x11022800,0x24000002,0x470000,0x11022800,0x24000006,0x400000,0x11022800,0x24000008,0x1710000,0x11022800,0x24000008,0x1712c00,0x11022800,0x24000020,0x100000,0x11022800,
+0x24000020,0x1500000,0x11022800,0x24000020,0x1500002,0x11022900,0x4000000,0x10000e,0x11022900,0x4000000,0x10000f,0x11022919,0x7c00100,0x12040f,0x11022c00,0x4000000,
+0x100002,0x11022c00,0x4000000,0x10000f,0x11022c00,0x4000000,0x1500002,0x11022c00,0x4000000,0x1600002,0x11022c00,0x7c00120,0x120405,0x11022c0e,0x7c00100,0x250401,
+0x11022c19,0x7c00100,0x150401,0x11022d00,0x4000000,0x100006,0x11022d00,0x4000000,0x200006,0x11022d19,0x7c00100,0x120402,0x11022d19,0x7c00100,0x150402,0x11022e00,
+0x24000000,0x200000,0x11022e00,0x24000020,0x100000,0x11022f00,0x24000020,0x100000,0x11022f00,0x24000020,0x100001,0x11022f00,0x24000020,0x100002,0x11023000,0x24000000,
+0x100000,0x11023300,0x4000000,0x100002,0x11023300,0x4000000,0x100003,0x11023300,0x4000100,0x120403,0x11023300,0x4000100,0x150403,0x11023400,0x24000000,0x100000,
+0x11023500,0x24000000,0x100000,0x11023600,0x24000000,0x100000,0x11023600,0x24000020,0x100000,0x11023700,0x24000000,0x100000,0x11023700,0x24000000,0xe00000,0x11023700,
+0x24000020,0x100000,0x11023800,0x4000000,0x100000,0x11023800,0x24000000,0x200000,0x11024e67,0,0,0x11025600,0x4000000,0x100000,0x11042a00,0x4000000,
+0x1600000,0x11045700,0x4000000,0x20000a,0x11045700,0x4000020,0x20000a,0x11045712,0x7c00100,0xe3040a,0x11045712,0x7c80100,0xe3040a,0x11045716,0x7c00100,0xe30c0a,
+0x11045716,0x7c00100,0x2530c0a,0x11063d00,0x4000001,0x445811,0x11065700,0x4000000,0x810011,0x11065700,0x4000000,0xe00011,0x11065700,0x4000000,0x1410011,0x11065700,
+0x4000000,0x1500011,0x11065700,0x4000000,0x1600011,0x11065700,0x4000006,0xe70011,0x11065700,0x4000008,0xe00011,0x11065700,0x4000008,0xe02c11,0x11065700,0x4000010,
+0x871411,0x11065700,0x4000010,0x1201411,0x11065700,0x4000010,0x1271011,0x11065700,0x4000020,0xe00011,0x11065700,0x4000400,0xe00011,0x11065700,0x4000420,0xe00011,
+0x11065700,0x6800000,0xe01c11,0x11065700,0x6800040,0xe29811,0x11065700,0xc000010,0x80ac11,0x11065700,0xc000010,0xb48011,0x11065719,0x7c00100,0xe20411,0x11065719,
+0x7c00100,0xe50411,0x11065719,0x7c00140,0xe20411,0x11065719,0x7c00140,0xe50411,0x11080100,0x6800000,0x201c00,0x11080100,0x68000c0,0x1329800,0x11080100,0x24000000,
+0x200000,0x11080100,0x24000000,0x810000,0x11080100,0x24000000,0x1410000,0x11080100,0x24000000,0x1500000,0x11080100,0x24000000,0x1600000,0x11080100,0x24000000,0x1b00000,
+0x11080100,0x24000000,0x2410000,0x11080100,0x24000006,0xd70000,0x11080100,0x24000008,0x1713c00,0x11080100,0x24000008,0x1714000,0x11080100,0x24000010,0x1001400,0x11080100,
+0x24000010,0x1071000,0x11080100,0x24000010,0x1071400,0x11080100,0x24000020,0x200000,0x11080100,0x24000020,0x400000,0x11080100,0x24000020,0x1600000,0x11080100,0x24000400,
+0x200000,0x11080100,0x24000420,0x200000,0x11080100,0x2c000010,0xb48000,0x11080100,0x2c000010,0x100ac00,0x11080100,0x44000001,0x1a45800,0x11080119,0x7c00100,0x220400,
+0x11080119,0x7c00100,0x250400,0x11080119,0x7c001c0,0x220400,0x11080119,0x7c001c0,0x250400,0x11080200,0x4000400,0x200002,0x11080200,0x24000000,0x200000,0x11080200,
+0x24000000,0x1500000,0x11080200,0x24000000,0x1600000,0x11080200,0x24000020,0x200000,0x110a1e12,0x7c00100,0x2130480,0x110a1e12,0x7c80100,0x2130480,0x110a3000,0x24000000,
+0xe00000,0x110a3000,0x24100000,0x810001,0x110a3000,0x24100000,0x1410001,0x110a3700,0x24000000,0x200000,0x110a3d00,0x4000000,0xe00000,0x110a3d00,0x4000000,0xe00002,
+0x110a3d00,0x24000000,0xe00000,0x110a3d11,0x7c00300,0xe30000,0x110a3d11,0x7c00900,0x1230400,0x110a3d12,0x2802400,0x962460,0x110a3e14,0x7c00100,0xe30000,0x110a3e14,
+0x7c00100,0xe30001,0x110a3e14,0x7c00100,0x2530000,0x110a3e14,0x7c00900,0x1230000,0x110a3e14,0x7c00900,0x1230001,0x110a3f16,0x7c00100,0xe30c00,0x110a3f16,0x7c00100,
+0xe30c01,0x110a3f16,0x7c00100,0x2530c00,0x110a3f16,0x7c00900,0x1230c00,0x110a3f16,0x7c00900,0x1230c01,0x110a4005,0x7c00100,0xe30400,0x110a4112,0x7c00100,0xe30402,
+0x110a4112,0x7c80100,0xe30402,0x110a4400,0x4000000,0xe00000,0x110a4412,0x4000000,0xe00002,0x110a4412,0x4000000,0xe00003,0x110a4416,0x4000000,0xe00c03,0x110a4500,
+0x4000000,0xe0000d,0x110a4516,0x4000000,0xe00c0d,0x110a4711,0x7c40300,0xe30000,0x110a4f11,0x7c00300,0xe30001,0x110a4f11,0x7c40300,0xe30000,0x110a5300,0x4000000,
+0x810010,0x110a5300,0x4000000,0xe00002,0x110a5300,0x4000000,0xe00010,0x110a5300,0x4000000,0x1410010,0x110a5300,0x4000002,0xe70010,0x110a5300,0x4000008,0x810010,
+0x110a5300,0x4000008,0x1410010,0x110a5300,0x6800000,0xe01c02,0x110a5300,0x6800000,0xe01c10,0x110a5400,0x4000000,0x81000c,0x110a5400,0x4000000,0xe0000c,0x110a5400,
+0x4000000,0x141000c,0x110a5400,0x4000000,0x150000c,0x110a5400,0x4000000,0x160000c,0x110a5400,0x4000002,0xe7000c,0x110a5400,0x4000010,0x87140c,0x110a5400,0x4000010,
+0xe7000c,0x110a5400,0x4000010,0x120140c,0x110a5400,0x4000010,0x127100c,0x110a5400,0x4000020,0xe0000c,0x110a5400,0x4000026,0xe7000c,0x110a5400,0xc000010,0x80ac0c,
+0x110a5400,0xc000010,0xb4800c,0x11400c0c,0x4000010,0xb00000,0x11400c0c,0x4000010,0x1071400,0x11400c17,0xc000010,0xb48000,0x11400c1e,0x7c00900,0x230400,0x11400f4b,
+0xc000010,0x448000,0x11400f5f,0xc000010,0x448000,0x11401d94,0x4000000,0x200000,0x11403dca,0x4000000,0xe00000,0x114457bf,0x4000004,0x120000a,0x114457bf,0x4000008,
+0x81000a,0x114457bf,0x4000008,0x141000a,0x114457bf,0x4000010,0x87000a,0x114457bf,0xc000010,0x84800a,0x114457c8,0x3802500,0x126246a,0x114457c8,0x7c00d00,0x2530c0a,
+0x114a3dbf,0x24000000,0x810000,0x114a3dbf,0x24000000,0x1410000,0x114a3dbf,0x24000008,0x810000,0x114a3dbf,0x24000008,0x1410000,0x114a3dbf,0x24000010,0x870000,0x114a3dbf,
+0x2c000010,0x848000,0x114a3dc5,0x4000000,0xe00000,0x114a3dc5,0x24000000,0xe00000,0x114a3dc5,0x24000002,0xe00000,0x114a3dc5,0x24000002,0x1200000,0x114a3dc5,0x24000008,
+0x810000,0x114a3dc5,0x24000008,0x1410000,0x114a3dc8,0x7c00900,0x930c00,0x114a3dc8,0x7c00900,0xe30c00,0x114a3dca,0x7c00300,0xe30000,0x114a3ec8,0x7000400,0x1200c02,
+0x114a3fbf,0x4000004,0x1200000,0x114a3fc8,0x7c00d00,0x2530c00,0x114a42ca,0x4000000,0xe00000,0x114a42ca,0x4000000,0xe0000f,0x114a44ca,0x4000000,0xe00002,0x114a44ca,
+0x4000000,0xe00003,0x114a45ca,0x4000000,0xe00002,0x114a45ca,0x4000000,0xe0000d,0x11505103,0x24000000,0x810000,0x11505103,0x24000000,0x1410000,0x1180090a,0x2802400,
+0x962460,0x11800c27,0x2802100,0x962460,0x11800c27,0x2802500,0x962460,0x11800f32,0x2802400,0x962460,0x11800f3f,0x2802400,0x962460,0x11820700,0x2802400,0x962460,
+0x11820700,0x2802500,0x962460,0x118a3dcb,0x2802400,0x962460,0x118a3ec8,0x2802400,0x962460,0x11c00904,0x2802400,0x962460,0x11c00908,0x2802400,0x962460,0x11c00c2c,
+0x6800000,0x1329800,0x11c00c30,0xc000010,0xb48000,0x11c00f78,0x6800000,0x1329800,0x11c0107d,0x6800000,0x1329800,0x11c01181,0x6800000,0x1329800,0x11c01285,0x6800000,
+0x1329800,0x11c01489,0x4000000,0x200000,0x11c01489,0x6800000,0x1329800,0x11c0168d,0x6800000,0x1329800,0x11d05107,0x7c00100,0x230408,0x20000067,0x1000,0,
+0x20000b13,0x2802400,0x962460,0x20000b13,0x2802500,0x962460,0x20001b27,0x2802100,0x962460,0x20001b27,0x2802100,0x962461,0x20001b27,0x2802400,0x962460,0x20001b27,
+0x2802500,0x962460,0x20001b27,0x2806400,0x962460,0x20001b27,0x2902100,0x962462,0x20001b27,0x4000000,0x200000,0x20001b27,0x4000000,0x400000,0x20001b27,0x4000000,
+0x500000,0x20001b27,0x4000000,0x810000,0x20001b27,0x4000000,0xb00000,0x20001b27,0x4000000,0xc0000b,0x20001b27,0x4000000,0x1410000,0x20001b27,0x4000010,0xb00000,
+0x20001b27,0x4000010,0xc00000,0x20001b27,0x6800000,0x1329800,0x20001b27,0x6800100,0x462540,0x20001b27,0x6800400,0x962540,0x20001b27,0x7c00100,0x230400,0x20001b27,
+0x7c00100,0x230401,0x20002619,0x7c00100,0x220401,0x20002a00,0x4000000,0x1600000,0x20004b67,0,0x1900000,0x20004c67,0,0x1900000,0x20004d67,0,
+0x1900000,0x20006d67,0x1000,0,0x20006e67,0x1000,0,0x20026d67,0,0,0x20026e67,0,0,0x200a4a12,0x7c00100,0x1f304c1,
+0x200a4a12,0x7c00100,0x20304e1,0x21005600,0x4000000,0x700000,0x21022a00,0x4000000,0x1600000,0x30000419,0x7c00100,0x220400,0x30000419,0x7c00100,0x220401,0x30000419,
+0x7c00100,0x250400,0x30000419,0x7c00100,0x250401,0x30000519,0x7c00100,0x220400,0x30000600,0x4000400,0x200400,0x30000600,0x7c00500,0x230400,0x30000605,0x4000400,
+0x200400,0x3000080e,0x7c00100,0x220400,0x30000908,0x2000,0x962460,0x30000908,0x7c00100,0x220400,0x30000908,0x7c00100,0x220401,0x30000908,0x7c00100,0x250400,
+0x30000908,0x7c00100,0x250401,0x30000a03,0x4000006,0x400400,0x30000c02,0x4000000,0x200000,0x30000c02,0x7c00100,0x230400,0x30000d22,0x2802100,0x962460,0x30000d22,
+0x2802400,0x962460,0x30000d22,0x2802500,0x962460,0x30000d22,0x4000000,0x200000,0x30000d22,0x4000010,0x200000,0x30000d22,0x7c00100,0x230400,0x30000d22,0xc000010,
+0x248000,0x30000d22,0x80000000,0x218960,0x30000e25,0x2802500,0x962460,0x30000e25,0x7c00100,0x230400,0x30001821,0x2802100,0x962460,0x30001821,0x2806400,0x962460,
+0x30001821,0x4000000,0x200000,0x30001821,0x6800100,0x962540,0x30001821,0x6800100,0x962541,0x30001821,0x7c00100,0x230400,0x30001b27,0x2802100,0x962460,0x30001b27,
+0x2802400,0x962460,0x30001b27,0x4000000,0x200000,0x30001b27,0x4000000,0x400000,0x30001b27,0x7c00100,0x230400,0x30001c1c,0x2802100,0x1862460,0x30001c1c,0x2802400,
+0x1862460,0x30001c1c,0x2806400,0x1862460,0x30001c1c,0x4000000,0x200000,0x30001c1c,0x6800100,0x1862400,0x30001c1c,0x6800100,0x1862540,0x30001c1c,0x7c00100,0x1830000,
+0x30001c1c,0x7c00100,0x1830001,0x30001c1c,0xc000010,0x448000,0x30001f0b,0x4000000,0x200000,0x30001f0b,0x4000010,0x200000,0x30001f0b,0x4000010,0x400000,0x30001f0b,
+0x6800000,0x200000,0x30001f0b,0x7c00100,0x230400,0x30001f0b,0xc000010,0x248000,0x30002006,0x7c00100,0x250400,0x30002128,0x4000000,0x200000,0x30002128,0x7c00100,
+0x230400,0x30002128,0xc000010,0x248000,0x3000221d,0x4000000,0x810000,0x3000221d,0x4000000,0x1410000,0x3000221d,0x4000001,0x445800,0x3000221d,0x7c00100,0x230400,
+0x30002300,0x4000010,0x400000,0x30002320,0x7c00100,0x230400,0x30002417,0x2802100,0x1862460,0x30002417,0x2802400,0x1862460,0x30002417,0x2806400,0x1862460,0x30002417,
+0x2882000,0x1862460,0x30002417,0x4000000,0x200000,0x30002417,0x4000000,0x400000,0x30002417,0x4000000,0x1600000,0x30002417,0x4000010,0x400000,0x30002417,0x4000010,
+0x1200000,0x30002417,0x6800000,0x1329800,0x30002417,0x6800100,0x1862540,0x30002417,0x7c00100,0x1830000,0x30002417,0x7d00100,0x1830000,0x3000251b,0x80000,0xc18820,
+0x3000251b,0x2802100,0x962460,0x3000251b,0x3c02100,0x962460,0x3000251b,0x4000000,0x200000,0x3000251b,0x4000006,0x500000,0x3000251b,0x4000010,0x400000,0x3000251b,
+0x4000010,0xb70000,0x3000251b,0x4000800,0x200000,0x3000251b,0x6800000,0x1329800,0x3000251b,0x7c00100,0x230400,0x3000251b,0x7c00900,0x230400,0x3000251b,0xc000010,
+0xb48000,0x3000251b,0x12882000,0x962460,0x30002800,0x24000000,0x200000,0x30002800,0x2c000010,0x1248002,0x30002a00,0x4000000,0x1600000,0x30002b01,0x2000,0x962460,
+0x30002c00,0x4000000,0x200000,0x30002c00,0x7c00100,0x220405,0x30002d19,0x7c00100,0x250400,0x30002e00,0x24000000,0x200000,0x30003000,0x24000000,0x200000,0x30003100,
+0x24000000,0x200000,0x30003600,0x24000000,0x200000,0x30003700,0x24000000,0x200000,0x3000392e,0x24000000,0x200000,0x30005013,0x7c00100,0x2633801,0x30005600,0,
+0x918820,0x30020600,0x4000400,0x500400,0x30020701,0x2802400,0x962460,0x30020701,0x2802400,0xc62460,0x300a3a11,0x4020000,0xe00000,0x300a3a11,0x4020000,0xe00002,
+0x300a3b11,0x4020000,0xe00002,0x300a3c00,0x4008000,0xe00000,0x300a3c00,0x4010000,0xe00000,0x300a3d11,0x7c00300,0xe30002,0x300a4305,0x7c00100,0xe30400,0x300a4611,
+0x7c40300,0xe30000,0x300a4829,0x7c00100,0xe30400,0x300a4829,0x7c00900,0x1230400,0x300a4929,0x4000000,0xe00000,0x3040259a,0x4000010,0x400000,0x3040259a,0x4000010,
+0xb70000,0x3040259a,0xc000010,0xb48000,0x304028ba,0x4000001,0xc41c0b,0x304a3dca,0x4000000,0xe00000,0x30800c27,0x2802100,0x962460,0x30c01c92,0x6800000,0x1329800,
+0x3100080e,0x7c00120,0x220402,0x3100080e,0x7c00120,0x250402,0x31005167,0x1000,0,0x3100581e,0x4000000,0x200000,0x3100581e,0x7c00100,0x230400,0x3100590d,
+0x7c00100,0x230400,0x31005a09,0x7c00100,0x220400,0x31005a09,0x7c00100,0x250400,0x31005b00,0x4000000,0x200000,0x31005c00,0x80000,0x918820,0x31005c00,0x2802000,
+0x962460,0x31005c00,0x2802400,0x962460,0x31005c00,0x4000000,0x200000,0x31005c00,0x4000000,0x200001,0x31005c00,0x6800000,0x962540,0x31005c00,0x6800400,0x962540,
+0x31005c01,0x2802400,0x962460,0x31005d00,0x4000020,0x200005,0x31005d00,0x6800020,0x1329805,0x31005d00,0x7c00120,0x220405,0x31005d00,0x7c00120,0x250405,0x31006000,
+0x82000,0x962460,0x31006000,0x180000,0x918820,0x310a5e11,0x7c40300,0xe30000,0x310a5f11,0x7c00300,0xe30001,0x32000419,0x7c00100,0x250400,0x3200080e,0x4000020,
+0x200000,0x3200080e,0x7c00100,0x220400,0x3200080e,0x7c00100,0x250400,0x32000908,0x7c00100,0x220400,0x32000908,0x7c00100,0x250400,0x32000c02,0x7c00100,0x230400,
+0x32000e25,0x7c00100,0x230400,0x32001d0c,0x7c00100,0x230400,0x32002800,0x80000,0x1e18820,0x32002800,0x80020,0x218820,0x32002800,0x4000001,0x445802,0x32002800,
+0x24000000,0x200000,0x32002800,0x24000000,0x1500002,0x32002800,0x24000020,0x200000,0x32002800,0x2c000010,0x1248002,0x32002919,0x7c00100,0x22040f,0x32002a00,0x4000000,
+0x1600000,0x32002b01,0x2000,0x962460,0x32002b01,0x2802000,0x962460,0x32002b01,0x2802020,0x962460,0x32002c00,0x4000000,0x200000,0x32002c00,0x4000020,0x200000,
+0x32002c00,0x4000020,0x200005,0x32002c00,0x7c00120,0x220405,0x32002c00,0x7c00120,0x250405,0x32002e00,0x24000020,0x200000,0x32002f00,0x24000020,0x200000,0x32003000,
+0x24000000,0x200000,0x32003000,0x24000020,0x200000,0x32003500,0x24000000,0x200000,0x32003600,0x24000020,0x200000,0x32003700,0x24000000,0x100000,0x32003700,0x24000000,
+0x200000,0x32003800,0x24000000,0x810000,0x32003800,0x24000000,0x1410000,0x32005102,0x4000000,0x1500008,0x32005502,0x7c00100,0x230400,0x32006108,0x7c00100,0x220400,
+0x32006108,0x7c00100,0x250400,0x3200622a,0x2802100,0x962460,0x3200622a,0x2806400,0x962460,0x3200622a,0x7c00100,0x230400,0x3200632b,0x2802100,0x962460,0x3200632b,
+0x6804000,0x962540,0x3200632b,0x7c00100,0x230400,0x3200642c,0x2802100,0x962460,0x3200642c,0x7c00100,0x230400,0x3200652d,0x2802100,0x962460,0x3200652d,0x7c00100,
+0x230400,0x32006600,0x24000020,0x200000,0x32006700,0x24000020,0x200000,0x32006800,0x24000020,0x200000,0x32006900,0x24000020,0x200000,0x32006900,0x24000020,0x810000,
+0x32006900,0x24000020,0x1410000,0x32006a00,0x24000020,0x200000,0x32006a00,0x24000020,0x200001,0x32006a00,0x24000020,0x200002,0x32020701,0x2882000,0xc62460,0x32023300,
+0x4000000,0x100000,0x32026c01,0x12882000,0x962460,0x32065700,0x4000000,0x810011,0x32065700,0x4000000,0x1410011,0x32086600,0x24000020,0x810000,0x32086600,0x24000020,
+0x1410000,0x32086900,0x24000020,0x810000,0x32086900,0x24000020,0x1410000,0x320a3600,0x24000020,0x200000,0x320a3d11,0x7c00100,0x1230400,0x320a3e14,0x7c00100,0xe30010,
+0x320a3e14,0x7c00100,0x2530000,0x320a3f16,0x7c00100,0xe30c10,0x320a4400,0x4000000,0xe00003,0x320a4929,0x4000000,0xe00000,0x320a4f11,0x7c00300,0xe30001,0x320a6b16,
+0x7c00100,0x2530c00,0x32406396,0xc000010,0x448000,0x324a3dcd,0x4000000,0xe00000,0x324a3dcd,0x7c00100,0x1230400,0x324a3fc8,0x4000002,0x1200c00,0x324a53c5,0x24000000,
+0xe00000,0x32820701,0x2802000,0x962460,0x40000419,0x7c00100,0x220400,0x40000519,0x7c00100,0x220400,0x40000600,0x4000400,0x200400,0x4000080e,0x7c00100,0x220400,
+0x4000080e,0x7c00100,0x250400,0x4000080e,0x7c00100,0x250402,0x40000c02,0x2802100,0x962460,0x40000c02,0x2802400,0x962460,0x40000c02,0x2802500,0x962460,0x40000c02,
+0x4000000,0x200000,0x40000c02,0x4000000,0x1071400,0x40000c02,0x7c00100,0x230400,0x40000c02,0x80000000,0x218960,0x40000d22,0x7c00100,0x230400,0x40000f0a,0x7c00100,
+0x230400,0x40001004,0x7c00100,0x230400,0x40001110,0x2802100,0x962460,0x40001110,0x6800100,0x962540,0x4000120f,0x2802100,0x962460,0x4000120f,0x4000000,0x1600000,
+0x4000120f,0x7c00100,0x230400,0x4000131f,0x7c00100,0x230400,0x40001423,0x4000000,0x200000,0x40001423,0x4000000,0x1600000,0x40001615,0x2802400,0x962460,0x40001615,
+0x7c00100,0x230400,0x40002417,0x2802400,0x1862460,0x40002417,0x4000000,0x200000,0x40002800,0x6800000,0x201c00,0x40002800,0x24000002,0x200000,0x40002c00,0x4000000,
+0x200002,0x40003000,0x24000000,0x200000,0x40003000,0x24000020,0x200000,0x40003700,0x24000000,0x200000,0x40005a09,0x7c00100,0x220400,0x40005a09,0x7c00100,0x250400,
+0x40005d00,0x7c00120,0x220405,0x40006f30,0x2802100,0x962460,0x40006f30,0x2802400,0x962460,0x40006f30,0x4000000,0x200000,0x40006f30,0x6800000,0x1329800,0x40006f30,
+0x6800100,0x962540,0x40006f30,0x7c00100,0x230400,0x40006f30,0xc000010,0xb48000,0x40007034,0x7c00100,0x1830000,0x40007117,0x4000000,0x200000,0x40007208,0x7c00100,
+0x220400,0x4000720e,0x7c00100,0x220400,0x4000720e,0x7c00500,0x22040e,0x4000720e,0x7c00500,0x22040f,0x40007219,0x7c00100,0x220400,0x40007219,0x7c00500,0x220400,
+0x40007219,0x7c00500,0x22040e,0x40007219,0x7c00500,0x22040f,0x40007300,0x24000000,0x200000,0x40007400,0x4000000,0x200000,0x40007531,0x7c00100,0x230400,0x40007631,
+0x7c00100,0x230400,0x40007835,0x4000010,0x400000,0x40007835,0x7c00100,0x230400,0x40007933,0x7c00100,0x230400,0x40007a32,0x6800000,0x1329800,0x40007a32,0x7c00100,
+0x230400,0x40007b2f,0x7c00100,0x230400,0x40007c00,0x4000000,0x200000,0x40020701,0x2802400,0x962460,0x40020701,0x2802400,0xc62460,0x40023300,0x4000000,0x200000,
+0x40027d01,0x12882000,0x962460,0x400a3700,0x24000000,0x200000,0x400a3700,0x24000000,0xe00000,0x400a4400,0x4000000,0xe0000d,0x400a4412,0x4000000,0xe00002,0x400a4412,
+0x4000000,0xe00003,0x400a4500,0x4000000,0xe0000d,0x400a5300,0x4000000,0x810010,0x400a5300,0x4000000,0x1410010,0x40507709,0x4000000,0x200000,0x4050770c,0x4000000,
+0x400000,0x4050770f,0x4000000,0x200000,0x4050770f,0x4000000,0x400000,0x40c01489,0x4000000,0x200000,0x40d05107,0x4000000,0x200000,0x41000419,0x7c00100,0x220400,
+0x41000419,0x7c00100,0x250400,0x4100080e,0x7c00100,0x220400,0x4100080e,0x7c00100,0x250400,0x41000908,0x7c00100,0x220400,0x41000908,0x7c00100,0x250400,0x41000b13,
+0x2802000,0x962460,0x41000b13,0x2802100,0x962460,0x41000b13,0x4000000,0xb00000,0x41000c02,0x2802100,0x962460,0x41000c02,0x4000000,0x1500000,0x41000c02,0xc000010,
+0xb48000,0x41000f0a,0x7c00100,0x230400,0x41001004,0x7c00100,0x230400,0x41001423,0x7c00100,0x230400,0x41001b27,0x4000000,0x500000,0x41001d0c,0x7c00100,0x22040f,
+0x41001d0c,0x7c00100,0x230400,0x41001f0b,0x2802400,0x962460,0x41001f0b,0x4000000,0x200000,0x41001f0b,0x7c00100,0x230400,0x41002800,0x24000000,0x200000,0x41002800,
+0x24000000,0x400000,0x41002919,0x7c00100,0x22040e,0x41002a00,0x4000000,0x1600000,0x41002b01,0x2802020,0x962460,0x41002c00,0x4000000,0x200000,0x41002c00,0x7c00120,
+0x220405,0x41003000,0x24000000,0x200000,0x41003700,0x24000000,0x200000,0x41003700,0x24000000,0xe00000,0x41005d00,0x7c00120,0x220405,0x41006600,0x24000020,0x200000,
+0x41006600,0x24000020,0x810000,0x41006600,0x24000020,0x1410000,0x41007208,0x7c00100,0x22040f,0x41007219,0x7c00100,0x220400,0x41007300,0x24000000,0x200000,0x41007e0e,
+0x2802000,0x962460,0x41007e0e,0x4000000,0x200000,0x41007f0e,0x4000000,0x200000,0x41007f0e,0x7c00100,0x230400,0x41008002,0x7c00100,0x230400,0x41008137,0x2802100,
+0x962460,0x41008137,0x4000000,0x200000,0x41008137,0x6800100,0x962540,0x41008137,0x7c00100,0x230400,0x41008301,0x2802000,0x962460,0x41008407,0x4000000,0x200000,
+0x41008407,0x4000000,0x400000,0x41008407,0x4000000,0xb00000,0x41008407,0x7c00100,0x220400,0x41008407,0x7c00100,0x250400,0x4100850b,0x7c00100,0x230400,0x4100860b,
+0x4000000,0x200000,0x4100860b,0x7c00100,0x230400,0x4100870c,0x7c00100,0x220400,0x41008838,0x7c00100,0x220400,0x41008838,0x7c00100,0x250400,0x41008939,0x2802000,
+0x962460,0x41008939,0x2802100,0x962460,0x41008939,0x2806000,0x962460,0x41008939,0x4000000,0x200000,0x41008939,0x4000000,0x400000,0x41008939,0x7c00100,0x230400,
+0x41008939,0xc000010,0x448000,0x41008a00,0x4000400,0x200400,0x41008b3b,0x4000000,0x1800000,0x41008b3b,0x6800000,0x1329800,0x41008b3b,0x7c00100,0x1830000,0x41008b3b,
+0x7e00100,0x1830000,0x41008c3d,0x4000010,0x400000,0x41008c3d,0x7c00100,0x230400,0x41008d0e,0x7c00100,0x22040f,0x41008d19,0x7c00100,0x220400,0x41008d19,0x7c00100,
+0x22040f,0x41008e00,0x24000000,0x200000,0x41008e00,0x24000000,0x400000,0x41008e00,0x24000000,0x1710000,0x41008e00,0x24000006,0x400000,0x41008f3a,0x2802100,0x962460,
+0x41008f3a,0x2806000,0x962460,0x41008f3a,0x4000000,0x200000,0x41008f3a,0x6800100,0x962540,0x41008f3a,0x7c00100,0x230400,0x4100903c,0x7c00100,0x230400,0x4100903c,
+0x7c00100,0x23040f,0x41020701,0x2802000,0x962460,0x41020701,0x2802000,0xc62460,0x410a3700,0x24000000,0x200000,0x410a3700,0x24000000,0xe00000,0x410a4412,0x4000000,
+0xe00003,0x410a4711,0x7c40300,0xe30000,0x410a4f11,0x7c00300,0xe30001,0x410a9100,0x4000000,0x800010,0x410a9100,0x4000000,0x810010,0x410a9100,0x4000000,0x870010,
+0x410a9100,0x4000000,0xb00010,0x410a9100,0x4000000,0xf00010,0x410a9100,0x4000000,0x1001410,0x410a9100,0x4000000,0x1071010,0x410a9100,0x4000000,0x1071410,0x410a9100,
+0x4000000,0x1410010,0x41408ad0,0x4000400,0x200000,0x414a82ca,0x4000000,0xe00000,0x41808300,0x2802000,0x962460,0x41c01489,0x6800000,0x1329800,0x50000419,0x7c00100,
+0x220400,0x50000419,0x7c00100,0x250400,0x5000080e,0x7c00100,0x220400,0x50000908,0x7c00100,0x220400,0x50000908,0x7c00100,0x250400,0x50000b13,0x2802500,0x962460,
+0x50000f0a,0x7c00100,0x230400,0x50001615,0x2802100,0x962460,0x50001615,0x7c00100,0x230400,0x50002b01,0x2802020,0x962460,0x50002c00,0x4000000,0x200000,0x50002c19,
+0x7c00100,0x220400,0x50002d19,0x7c00100,0x220400,0x50003000,0x24000000,0x200000,0x50003000,0x24000020,0x200000,0x50003700,0x24000000,0x200000,0x50005d00,0x7c00120,
+0x220405,0x50005d00,0x7c00120,0x250405,0x50006108,0x7c00100,0x220400,0x50006108,0x7c00100,0x250400,0x50006600,0x24000020,0x200000,0x50007300,0x24000000,0x200000,
+0x50008301,0x2802400,0x962460,0x50008a00,0x7c00500,0x230400,0x50009257,0x2802400,0x962460,0x50009257,0x4000000,0x200000,0x50009257,0x4000010,0x1071400,0x50009257,
+0x6800000,0x1329800,0x50009257,0x7c00100,0x230400,0x50009257,0x7c00500,0x230400,0x50009257,0x7c00900,0x230400,0x50009257,0xc000010,0xb48000,0x5000933e,0x2802100,
+0x962460,0x5000933e,0x2802400,0x962460,0x5000933e,0x4000000,0x200000,0x5000933e,0x4000000,0x400000,0x5000933e,0x4000010,0x400000,0x5000933e,0x6800000,0x1329800,
+0x5000933e,0x6800100,0x962540,0x5000933e,0x6800100,0x962541,0x5000933e,0x6804400,0x962540,0x5000933e,0x7c00100,0x230400,0x5000933e,0x7c00100,0x230401,0x5000933e,
+0xc000010,0x448000,0x50009419,0x7c00100,0x220400,0x50009419,0x7c00100,0x250400,0x50009500,0x4000400,0x200400,0x5000965a,0x4000000,0x500000,0x5000965a,0x7c00100,
+0x230400,0x5000965a,0xc000010,0xb48000,0x5000975b,0x4000000,0x200000,0x5000975b,0x4000010,0x400000,0x5000975b,0x7c00100,0x230400,0x50009865,0x7c00100,0x230400,
+0x50009965,0x4000010,0x400000,0x50009965,0x7c00100,0x230400,0x50409aca,0x4000000,0x200000,0x5100080e,0x7c00100,0x220400,0x5100080e,0x7c00100,0x250400,0x51000c02,
+0x2802100,0x962460,0x51000c02,0x4000000,0x1500000,0x51000c02,0x4000020,0x200000,0x51000c02,0x7c00100,0x230400,0x51000f0a,0x7c00100,0x230400,0x51000f0a,0x7c00500,
+0x230400,0x51001110,0x2802100,0x962460,0x5100131f,0x2802100,0x962460,0x51001423,0x7c00100,0x230400,0x51001524,0x2802100,0x962460,0x51001524,0x4000000,0x200000,
+0x51001524,0x7c00100,0x230400,0x5100171a,0x2802100,0x962460,0x5100171a,0x4000000,0x200000,0x5100171a,0x4000000,0x1500000,0x5100171a,0x7c00100,0x230400,0x51001b27,
+0x4000000,0x200000,0x51001b27,0x4000000,0x400000,0x51001b27,0x4000000,0x500000,0x51001b27,0x7c00100,0x230400,0x51001c1c,0x2802100,0x1862460,0x51001c1c,0x2802500,
+0x1862460,0x51001c1c,0x2806400,0x1862460,0x51001c1c,0x4000000,0x1800000,0x51001c1c,0x6800000,0x1329800,0x51001c1c,0x6800100,0x1862400,0x51001c1c,0x6800100,0x1862540,
+0x51001c1c,0x6800500,0x1862400,0x51001c1c,0x7c00100,0x1830000,0x5100251b,0x7c00100,0x230400,0x51002619,0x7c00100,0x220400,0x51002619,0x7c00100,0x250400,0x51002800,
+0x80020,0x218820,0x51002c00,0x4000000,0x200000,0x51002d19,0x7c00100,0x230400,0x51003700,0x24000000,0x200000,0x51003700,0x24000000,0xe00000,0x51005201,0x2802400,
+0x962460,0x51005c00,0x4000000,0x200000,0x51006108,0x7c00100,0x220400,0x51006108,0x7c00100,0x250400,0x51006600,0x24000020,0x200000,0x51006600,0x24000020,0x810000,
+0x51006600,0x24000020,0x1410000,0x51007300,0x24000000,0x200000,0x51007300,0x24000020,0x200000,0x51008002,0x7c00100,0x230400,0x51008301,0x2802000,0x962460,0x51008301,
+0x2802400,0x962460,0x51008301,0x2802400,0xc62460,0x51008a00,0x7c00500,0x230400,0x51008e00,0x24000000,0x200000,0x51008e00,0x24000000,0x400000,0x51008e00,0x24000000,
+0x810000,0x51008e00,0x24000000,0x1400000,0x51008e00,0x24000000,0x1410000,0x51008e00,0x24000000,0x1710000,0x51008e00,0x24000002,0x200000,0x51008e00,0x24000500,0x230400,
+0x51008e00,0x2c000010,0xb48000,0x51009419,0x7c00100,0x220400,0x51009419,0x7c00100,0x22040e,0x51009419,0x7c00100,0x22040f,0x51009419,0x7c00100,0x250400,0x51009500,
+0x4000400,0x200400,0x51009500,0x7c00500,0x230400,0x51009519,0x7c00100,0x220400,0x51009519,0x7c00100,0x22040f,0x51009519,0x7c00100,0x230400,0x51009519,0x7c00100,
+0x250400,0x51009b71,0x2802100,0x962460,0x51009b71,0x6800000,0x1329800,0x51009b71,0x6800100,0x962540,0x51009b71,0x6804400,0x962540,0x51009b71,0x7c00100,0x230400,
+0x51009c52,0x2802100,0x962460,0x51009c52,0x2802400,0x962460,0x51009c52,0x2802d00,0x962460,0x51009c52,0x4000010,0x400000,0x51009c52,0x6800000,0x1329800,0x51009c52,
+0x6800100,0x962540,0x51009c52,0x7c00100,0x230400,0x51009c52,0xc000010,0x448000,0x51009d6d,0x6800000,0x1329800,0x51009d6d,0x7c00100,0x230400,0x51009d6d,0x7c00500,
+0x230400,0x51009d6d,0x7c00d00,0x230400,0x51009d6d,0xc000010,0x448000,0x51009e08,0x2802100,0x962460,0x51009f63,0x4000010,0x400000,0x51009f63,0x6800000,0x1329800,
+0x51009f63,0x7c00100,0x230400,0x51009f63,0x7c00900,0x230400,0x51009f63,0xc000010,0x448000,0x51009f63,0xc000010,0xb48000,0x5100a008,0x2000,0x962460,0x5100a008,
+0x2802400,0x962460,0x5100a008,0x4000000,0x200000,0x5100a008,0x7c00100,0x220400,0x5100a008,0x7c00100,0x230400,0x5100a008,0x7c00100,0x250400,0x5100a008,0x7c00500,
+0x230400,0x5100a16f,0x2806400,0x962460,0x5100a16f,0x6800000,0x1329800,0x5100a16f,0x6800100,0x962540,0x5100a16f,0x7c00100,0x230400,0x5100a16f,0xc000010,0x448000,
+0x5100a24f,0x2802100,0x962460,0x5100a24f,0x2802400,0x962460,0x5100a24f,0x6800000,0x1329800,0x5100a24f,0x7c00100,0x230400,0x5100a24f,0xc000010,0x448000,0x5100a36e,
+0x2802100,0x962460,0x5100a36e,0x4000000,0x200000,0x5100a36e,0x6800100,0x962540,0x5100a36e,0x6804400,0x962540,0x5100a36e,0x7c00100,0x230400,0x5100a442,0x2802100,
+0x962460,0x5100a442,0x4000000,0x200000,0x5100a442,0x6800000,0x1329800,0x5100a442,0x6800100,0x962540,0x5100a442,0x7c00100,0x230400,0x5100a442,0xc000010,0x448000,
+0x5100a500,0x4000000,0x200000,0x5100a600,0x4000000,0x200000,0x5100a601,0x2802000,0x962460,0x5100a76b,0x7c00100,0x230400,0x5100a868,0x7c00100,0x230400,0x5100a96c,
+0x4000000,0x200000,0x5100a96c,0x7c00100,0x230400,0x5100aa00,0x4000000,0xe00000,0x5100ab00,0x4000000,0xe00000,0x51086600,0x24000020,0x810000,0x51086600,0x24000020,
+0x1410000,0x510a4005,0x7c00100,0xe30400,0x510a4711,0x7c40300,0xe30000,0x510a7300,0x24000000,0x200000,0x510aaa00,0x4000000,0xe00000,0x5140a2fe,0x4000400,0x400000,
+0x514a82ca,0x4000000,0xe00000,0x51802bbc,0x2802000,0x962460,0x51c00908,0x2802400,0x962460,0x51c0a008,0x2802400,0x962460,0x52000f0a,0x2802100,0x962460,0x52000f0a,
+0x6800100,0x962540,0x52000f0a,0x7c00100,0x230400,0x52001004,0x4000000,0x1600000,0x52001b00,0x4000000,0x200000,0x52001c1c,0x2802100,0x1862460,0x52001c1c,0x6800100,
+0x1862400,0x52001c1c,0x6800500,0x1862400,0x52001e12,0x7c00100,0x2230500,0x52001e12,0x7c00100,0x2330520,0x52002128,0x4000002,0x400000,0x52002128,0x7c00100,0x230400,
+0x52002a00,0x4000000,0x1500000,0x52002a00,0x4000000,0x1600000,0x52002d00,0x4000000,0x200006,0x52003000,0x24000000,0x200000,0x52006108,0x7c00100,0x220400,0x52006108,
+0x7c00100,0x250400,0x52008301,0x2802400,0x962460,0x52008407,0x2802400,0x962460,0x52008407,0x7c00100,0x220400,0x52008407,0x7c00100,0x250400,0x52008b3b,0x6800000,
+0x1800000,0x52008b3b,0x7c00100,0x1830000,0x52008e00,0x24000000,0x400000,0x52009419,0x7c00100,0x250400,0x5200975b,0x4000000,0x200000,0x5200ac7e,0x2802000,0x962460,
+0x5200ac7e,0x2802100,0x962460,0x5200ac7e,0x2802400,0x962460,0x5200ac7e,0x4000010,0x200000,0x5200ac7e,0x7c00100,0x230400,0x5200ac7e,0xc000010,0x248000,0x5200ad28,
+0x7c00100,0x230400,0x5200ae6a,0x2802100,0x1862460,0x5200ae6a,0x2802400,0x962460,0x5200ae6a,0x2802400,0x1862460,0x5200ae6a,0x2806000,0x1862460,0x5200ae6a,0x4000000,
+0x1800000,0x5200ae6a,0x6800000,0x1329800,0x5200ae6a,0x6800100,0x1862400,0x5200ae6a,0x6800100,0x1862540,0x5200ae6a,0x7c00100,0x1830000,0x5200ae6a,0x7c00900,0x1830000,
+0x5200ae6a,0xc000010,0x1848000,0x5200b083,0x4000010,0x400000,0x5200b083,0x7c00100,0x230400,0x5200b083,0xc000010,0x448000,0x5200b182,0x2802400,0x962460,0x5200b182,
+0x4000000,0x200000,0x5200b182,0x4000010,0x400000,0x5200b182,0x7c00100,0x230400,0x5200b182,0xc000010,0x448000,0x5200b30a,0x2802400,0x962460,0x5200b30a,0x4000000,
+0x200000,0x5200b30a,0x7c00100,0x230400,0x5200b54e,0x2802100,0x962460,0x5200b54e,0x2802400,0x962460,0x5200b54e,0x4000000,0x200000,0x5200b54e,0x4000010,0x400000,
+0x5200b54e,0x6800000,0x1329800,0x5200b54e,0x6800100,0x962540,0x5200b54e,0x6804400,0x962540,0x5200b54e,0x7c00100,0x230400,0x5200b54e,0xc000010,0x448000,0x5200b61c,
+0x4000000,0x1800000,0x5200b61c,0x6800500,0x1862400,0x5200b61c,0x7c00100,0x1830000,0x5200b61c,0x7c00900,0x1830000,0x5200b77f,0x2802100,0x1862460,0x5200b77f,0x2802400,
+0x1862460,0x5200b77f,0x4000000,0x1800000,0x5200b77f,0x4000010,0x1800000,0x5200b77f,0x7c00100,0x1830000,0x5200b77f,0x7c00500,0x1830000,0x5200b77f,0x7c00900,0x1830000,
+0x5200b77f,0x7e00100,0x1830000,0x5200b873,0x2802100,0x962460,0x5200b873,0x2806400,0x962460,0x5200b873,0x6800000,0x1329800,0x5200b873,0x6800100,0x962540,0x5200b873,
+0x6800400,0x962540,0x5200b873,0x7c00100,0x230400,0x5200b873,0xc000010,0x448000,0x5200b912,0x7c00100,0x2230500,0x5200b912,0x7c00100,0x2330520,0x5200ba74,0x4000000,
+0x200000,0x5200ba74,0x4000010,0x400000,0x5200ba74,0x7c00100,0x230400,0x5200bb85,0x4000000,0x200000,0x5200bb85,0x7c00100,0x230400,0x5200bc75,0x4000000,0x400000,
+0x5200bc75,0x4000010,0x400000,0x5200bc75,0x7c00100,0x230400,0x5200bd7d,0x4000000,0x200000,0x5200bd7d,0x7c00100,0x230400,0x5200be7a,0x4000000,0x200000,0x5200be7a,
+0x7c00100,0x230400,0x5200bf58,0x7c00100,0x230400,0x5200c002,0x4000000,0x200000,0x5200c178,0x2802100,0x962460,0x5200c178,0x2802400,0x962460,0x5200c178,0x2806400,
+0x962460,0x5200c178,0x4000000,0x200000,0x5200c178,0x6800100,0x962540,0x5200c178,0x7c00100,0x230400,0x5200c178,0x7c00100,0x230401,0x5200c178,0xc000010,0x448000,
+0x5200c178,0x80000000,0x218960,0x5200c247,0x7c00100,0x230400,0x5200c247,0x7c00100,0x830400,0x5200c247,0x7c00100,0x1430400,0x5200c300,0x4000000,0x200003,0x52022d00,
+0x4000000,0x100006,0x52023700,0x24000000,0x100000,0x52023700,0x24000000,0xe00000,0x52023700,0x24000000,0x2800000,0x52024400,0x4000000,0x100000,0x52027300,0x24000000,
+0x100000,0x5202c300,0x4000000,0x100000,0x5202c300,0x4000000,0x100002,0x5202c300,0x4000000,0x100003,0x5202c300,0x4000000,0x10000d,0x5202c300,0x4000100,0x150400,
+0x5202c300,0x4000100,0x15040d,0x520a1e12,0x7c00100,0x2130480,0x520a3700,0x24000000,0xe00000,0x520a3800,0x24000000,0x100000,0x520a4711,0x7c40300,0xe30000,0x520a4f11,
+0x7c00300,0xe30001,0x520a7300,0x24000000,0x100000,0x520ab412,0x7c00100,0x2130480,0x520ac400,0x4000000,0xe00002,0x520ac400,0x4000000,0xe0000d,0x520ac414,0x4000000,
+0xe0000d,0x520ac511,0x7c40300,0xe30000,0x5240af9c,0x7c00100,0x230400,0x5240afa1,0x4000400,0x200000,0x5240afa3,0x6800400,0x962540,0x5240afa3,0x7c00100,0x230400,
+0x5240afad,0x7c00100,0x230400,0x5240afaf,0x7c00100,0x230400,0x5240b2d2,0x4000000,0x200000,0x5240b2d2,0x4000000,0x1500000,0x5240b2dd,0x4000000,0x200000,0x5240b2eb,
+0x4000000,0x200000,0x524a44ca,0x4000000,0xe00003,0x5250b501,0x7c00900,0x230400,0x5280af9c,0x2802400,0x962460,0x5280af9d,0x2802400,0x962460,0x5280afa3,0x2802400,
+0x962460,0x5280afa5,0x2802400,0x962460,0x5280afa7,0x2802400,0x962460,0x52c0b3f8,0x2802400,0x962460,0x52c0b3fc,0x7c00100,0x230400,0x60000c02,0x2802100,0x962460,
+0x60000c02,0x7c00100,0x230400,0x60000f0a,0x2802100,0x962460,0x60000f0a,0x6800100,0x962540,0x60000f0a,0x7c00100,0x230400,0x6000131f,0x4000000,0x200000,0x6000171a,
+0x7c00100,0x230400,0x6000171a,0x7c00100,0x230560,0x60001b27,0x2802100,0x962460,0x60001b27,0x4000000,0xc00000,0x60001b27,0x7c00100,0x230400,0x60001f0b,0x2802400,
+0x962460,0x60002919,0x7c00100,0x22040e,0x60002a00,0x4000000,0x1600000,0x60003000,0x24000000,0x200000,0x60003000,0x24000000,0xe00000,0x60003700,0x24000000,0x200000,
+0x60003800,0x24000000,0x1710000,0x60005102,0x4000000,0x200000,0x60006108,0x7c00100,0x220400,0x60006108,0x7c00100,0x250400,0x60006600,0x24000020,0x200000,0x60008301,
+0x2802400,0xc62460,0x6000903c,0x2806000,0x962460,0x6000903c,0x4000000,0x400000,0x60009519,0x7c00100,0x220400,0x60009519,0x7c00100,0x250400,0x6000a008,0x7c00100,
+0x220400,0x6000a008,0x7c00100,0x250400,0x6000c300,0x4000000,0x2703580,0x6000c654,0x2802000,0x962460,0x6000c654,0x4000010,0x200000,0x6000c654,0x7c00100,0x230400,
+0x6000c73f,0x2802000,0x962460,0x6000c73f,0x2802100,0x962460,0x6000c73f,0x4000000,0x200000,0x6000c73f,0x6800100,0x962540,0x6000c73f,0x6804000,0x962540,0x6000c73f,
+0x7c00100,0x230400,0x6000c80b,0x7c00100,0x230400,0x6000c941,0x2802100,0x962460,0x6000c941,0x2806400,0x962460,0x6000c941,0x4000000,0x200000,0x6000c941,0x4000010,
+0x200000,0x6000c941,0x6800000,0x1329800,0x6000c941,0x6800100,0x962540,0x6000c941,0x7c00100,0x230400,0x6000c941,0xc000010,0x448000,0x6000ca82,0x7c00100,0x230400,
+0x6000cc00,0x4000000,0xe00000,0x6000d000,0x4000000,0x200000,0x6002c300,0x4000000,0x100000,0x6002c300,0x4000000,0x10000d,0x6002c300,0x4000100,0x150400,0x6002c300,
+0x4000100,0x15040d,0x600a3000,0x24000000,0x200000,0x600a3000,0x24000000,0xe00000,0x600a3700,0x24000000,0x200000,0x600a3800,0x24000000,0x200000,0x600a3800,0x24000000,
+0x2800000,0x600a4305,0x7c00100,0xe30400,0x600ac300,0x4000000,0x100000,0x600ac400,0x4000000,0xe0000d,0x600acb14,0x7c00100,0xe30000,0x600acb16,0x7c00100,0xe30c00,
+0x600acc00,0x4000000,0xe00000,0x600acd00,0x4000000,0x200000,0x600acd00,0x4000000,0xe00000,0x600acd00,0x4000000,0x2800000,0x600ace00,0x4000000,0xe00000,0x600ace00,
+0x4000000,0x2800000,0x600acf00,0x4000000,0xe00000,0x600acf00,0x4000000,0x2800000,0x600ad111,0x7c40300,0xe30000,0x604ac4ca,0x4000000,0xe00003,0x61000a03,0x4000000,
+0x1600000,0x61000c02,0x80000000,0x218960,0x6100120f,0x4000000,0x200000,0x61001a18,0x7c00100,0x1830000,0x61001d0c,0x7c00100,0x230400,0x61001d0c,0x7c00100,0x250400,
+0x61006600,0x24000020,0x200000,0x61008407,0x7c00100,0x220400,0x61008407,0x7c00100,0x250400,0x6100870c,0x7c00100,0x220400,0x61008e00,0x24000000,0x200000,0x61008e00,
+0x24000000,0x400000,0x61008e00,0x24000002,0x300000,0x6100903c,0x7c00100,0x230400,0x61009519,0x7c00100,0x220400,0x61009519,0x7c00100,0x250400,0x61009519,0x7c00500,
+0x22040f,0x61009b71,0x2802100,0x962460,0x61009b71,0x2806400,0x962460,0x61009b71,0x7c00100,0x230400,0x6100a008,0x2802100,0x962460,0x6100c300,0x4000000,0x20000f,
+0x6100cd00,0x4000000,0x200000,0x6100d202,0x2802400,0x962460,0x6100d202,0x2802500,0x962460,0x6100d202,0x7c00100,0x230400,0x6100d302,0x4000020,0x200000,0x6100d302,
+0x7c00120,0x230405,0x6100d476,0x2802100,0x962460,0x6100d476,0x2802100,0x962461,0x6100d476,0x2806400,0x962460,0x6100d476,0x4000000,0x400000,0x6100d476,0x6800000,
+0x1329800,0x6100d476,0x6800100,0x962540,0x6100d476,0x7c00100,0x230400,0x6100d476,0xc000010,0x448000,0x6100d573,0x2802100,0x962460,0x6100d573,0x2806400,0x962460,
+0x6100d573,0x6800100,0x962540,0x6100d573,0x7c00100,0x230400,0x6100d573,0x7c00900,0x230400,0x6100d573,0xc000010,0x448000,0x6100d68d,0x7c00100,0x230400,0x6100d756,
+0x7c00100,0x230400,0x6100d85c,0x2802500,0x962460,0x6100d85c,0x6800100,0x962540,0x6100d85c,0x7c00100,0x230400,0x6100d85c,0x7c00500,0x230400,0x6100d997,0x2802100,
+0x962460,0x6100d997,0x4000000,0x200000,0x6100d997,0x4000000,0x400000,0x6100d997,0x6800000,0x1329800,0x6100d997,0x6800100,0x962540,0x6100d997,0x6804400,0x962540,
+0x6100d997,0x7c00100,0x230400,0x6100d997,0x7c00100,0x230560,0x6100d997,0xc000010,0x448000,0x6100da98,0x6800000,0x1329800,0x6100da98,0x7c00100,0x230400,0x6100db71,
+0x4000000,0x200000,0x6100dc99,0x2802100,0x962460,0x6100dc99,0x2802400,0x962460,0x6100dc99,0x6800000,0x1329800,0x6100dc99,0x6800100,0x962540,0x6100dc99,0x6804400,
+0x962540,0x6100dc99,0x7c00100,0x230400,0x610a4711,0x7c40300,0xe30000,0x610a4f11,0x7c00300,0xe30001,0x610ace00,0x4000000,0xe00000,0x6140afa1,0x7c00100,0x230400,
+0x6140afa3,0x7c00100,0x230400,0x6180af9e,0x2802400,0x962460,0x62002a00,0x4000000,0x1600000,0x63002800,0x80000,0x918820,0x63c00c15,0x80000,0x918820,0x7000080e,
+0x7c00100,0x250400,0x70000a03,0x4000000,0x200000,0x70000c00,0x80000000,0x218960,0x70000f0a,0x7c00100,0x230400,0x70001004,0x7c00100,0x230400,0x70001524,0x2802100,
+0x962460,0x70001524,0x7c00100,0x230400,0x70001615,0x2802100,0x962460,0x7000171a,0x2802100,0x962460,0x70001821,0x6800000,0x1329800,0x70002320,0x7c00100,0x230400,
+0x70002a00,0x4000000,0x1500000,0x70002a00,0x4000000,0x1600000,0x70003000,0x24000000,0x200000,0x70003800,0x24000000,0xe00000,0x70005201,0x2802400,0x962460,0x7000581e,
+0x7c00100,0x230400,0x70006108,0x7c00100,0x220400,0x70006108,0x7c00100,0x250400,0x70006f30,0x7c00100,0x230400,0x70007300,0x24000000,0x200000,0x70007f0e,0x4000000,
+0x200000,0x70008301,0x2802100,0x962460,0x70008301,0x2802400,0x962460,0x70008e00,0x24000000,0x200000,0x70008e00,0x24000000,0x400000,0x70008e00,0x24000002,0x400000,
+0x70008e00,0x24000008,0x1410000,0x70008e00,0x24000010,0x400000,0x70008e00,0x2c000010,0x448000,0x70009519,0x7c00100,0x220400,0x70009519,0x7c00100,0x230400,0x70009519,
+0x7c00100,0x250400,0x70009865,0x7c00100,0x230400,0x70009965,0x4000010,0x400000,0x70009965,0x7c00100,0x230400,0x7000a008,0x7c00100,0x220400,0x7000a008,0x7c00100,
+0x250400,0x7000a008,0x7c00500,0x22040f,0x7000a50e,0x4000000,0x200000,0x7000b61c,0x2802500,0x1862460,0x7000b61c,0x6800500,0x1862400,0x7000b61c,0x7c00100,0x1830000,
+0x7000c300,0x4000000,0x100000,0x7000c941,0x2806000,0x962460,0x7000cc00,0x4000000,0xe00000,0x7000cd00,0x4000000,0x200000,0x7000cd00,0x4000000,0xe00000,0x7000cd00,
+0x4000000,0x2800000,0x7000cf00,0x4000000,0xe00000,0x7000d202,0x2802100,0x962460,0x7000d202,0x7c00100,0x230400,0x7000d997,0x7c00100,0x230400,0x7000d997,0xc000010,
+0x248000,0x7000dd86,0x2802400,0x962460,0x7000dd86,0x7c00100,0x230400,0x7000dd86,0xc000010,0x448000,0x7000de9f,0x4000000,0x200000,0x7000de9f,0x7c00100,0x230400,
+0x7000e001,0x2400,0x962460,0x7000e001,0x2802400,0x962460,0x7000e187,0x2802000,0x962460,0x7000e187,0x2802100,0x962460,0x7000e187,0x4000000,0x200000,0x7000e187,
+0x7c00100,0x230400,0x7000e187,0xc000010,0x448000,0x7000e288,0x7c00100,0x230400,0x7000e300,0x4000000,0x200000,0x7000e489,0x2802100,0x962460,0x7000e489,0x2802400,
+0x962460,0x7000e489,0x6800100,0x962540,0x7000e489,0x6800100,0x962541,0x7000e489,0x6804400,0x962540,0x7000e489,0x7c00100,0x230400,0x7000e489,0x7c00900,0x230400,
+0x7000e59d,0x2802100,0x962460,0x7000e59d,0x2802400,0x962460,0x7000e59d,0x4000000,0x200000,0x7000e59d,0x4000010,0x200000,0x7000e59d,0x6800100,0x962540,0x7000e59d,
+0x6804400,0x962540,0x7000e59d,0x7c00100,0x230400,0x7000e59d,0xc000010,0x448000,0x7000e691,0x2802100,0x962460,0x7000e691,0x2802400,0x962460,0x7000e691,0x2806400,
+0x962460,0x7000e691,0x6800000,0x1329800,0x7000e691,0x6800100,0x962540,0x7000e691,0x7c00100,0x230400,0x7000e700,0x4000400,0x200400,0x7000e70e,0x7c00100,0x220400,
+0x7000e719,0x7c00100,0x220400,0x7000e719,0x7c00500,0x22040f,0x7000e853,0x7c00100,0x230400,0x7000e9a0,0x2802400,0x962460,0x7000e9a0,0x4000000,0x200000,0x7000e9a0,
+0x4000000,0x500000,0x7000e9a0,0x7c00100,0x230400,0x7000ea79,0x2802400,0x962460,0x7000ea79,0x4000000,0x200000,0x7000ea79,0x4000000,0xf00000,0x7000ea79,0x4000010,
+0x400000,0x7000ea79,0x7c00100,0x230400,0x7000eb8c,0x2802400,0x962460,0x7000eb8c,0x4000000,0x200000,0x7000eb8c,0x7c00100,0x230400,0x7000eca3,0x2802100,0x962460,
+0x7000eca3,0x2806400,0x962460,0x7000eca3,0x4000000,0x200000,0x7000eca3,0x6800000,0x1329800,0x7000eca3,0x6800100,0x962540,0x7000eca3,0x7c00100,0x230400,0x7000eca3,
+0xc000010,0x448000,0x7000ed95,0x6800000,0x1329800,0x7000ed95,0x7c00100,0x230400,0x7000ed95,0xc000010,0x448000,0x7000ee1c,0x2802500,0x1862460,0x7000ee1c,0x6800000,
+0x1329800,0x7000ee1c,0x7c00100,0x1830000,0x7000ee1c,0x7c00900,0x1830000,0x7000ef8f,0x4000000,0x200000,0x7000ef8f,0x7c00100,0x230400,0x7000f08e,0x4000000,0x200000,
+0x7000f08e,0x7c00100,0x230400,0x7000f159,0x2802100,0x962460,0x7000f159,0x7c00100,0x230400,0x7000f200,0x4000000,0x200000,0x7000f200,0x4000000,0x1200000,0x7000f200,
+0x4000000,0x1710000,0x7000f34b,0x2802400,0x962460,0x7000f34b,0x4000000,0x200000,0x7000f34b,0x4000010,0x400000,0x7000f34b,0x6800000,0x1329800,0x7000f34b,0x7c00100,
+0x230400,0x7000f34b,0x7c00900,0x230400,0x7000f34b,0xc000010,0x448000,0x7000f490,0x4000000,0x200000,0x7000f490,0x7c00100,0x230400,0x7000f5a5,0x7c00100,0x230400,
+0x7000f67b,0x4000000,0x200000,0x7000f67b,0x4000010,0x200000,0x7000f67b,0x7c00100,0x230400,0x7000f8a6,0x2802100,0x962460,0x7000f8a6,0x2802400,0x962460,0x7000f8a6,
+0x2806400,0x962460,0x7000f8a6,0x4000000,0x500000,0x7000f8a6,0x4000010,0xb00000,0x7000f8a6,0x4000800,0x200000,0x7000f8a6,0x6800100,0x962540,0x7000f8a6,0x6800100,
+0x962541,0x7000f8a6,0x7c00100,0x230400,0x7000f8a6,0xc000010,0x448000,0x7000f921,0x4000000,0x200000,0x7000fa00,0x4000000,0x200000,0x7000fb9e,0x2802100,0x962460,
+0x7000fb9e,0x2802400,0x962460,0x7000fb9e,0x2806400,0x962460,0x7000fb9e,0x4000000,0x200000,0x7000fb9e,0x6800000,0x1329800,0x7000fb9e,0x6800100,0x962540,0x7000fb9e,
+0x6800100,0x962541,0x7000fb9e,0x7c00100,0x230400,0x7000fc92,0x4000000,0x200000,0x7000fc92,0x6800000,0x1329800,0x7000fc92,0x7c00100,0x220400,0x7000fc92,0x7c00100,
+0x230400,0x7000fc92,0x7c00100,0x250400,0x700acd00,0x4000000,0xe00000,0x700acd00,0x4000000,0x2800000,0x700ace00,0x4000000,0xe00000,0x700acf00,0x4000000,0xe00000,
+0x700acf00,0x4000000,0x2800000,0x7050df11,0x4000000,0x200000,0x7050f719,0x80000,0x918820,0x7080afa1,0x2802400,0x962460,0x7090df11,0x2802400,0x962460,0x70d0e417,
+0x2802100,0x962460,0x70d0e417,0x2802400,0x962460,0x70d0e417,0x6800100,0x962540,0x70d0ea15,0x4000010,0x400000,0x8000120f,0x7c00100,0x230400,0x80001524,0x7c00100,
+0x230400,0x8000171a,0x7c00100,0x230400,0x80002006,0x7c00100,0x220400,0x80002006,0x7c00100,0x250400,0x80002a00,0x4000000,0x1500000,0x80002d00,0x4000000,0x200000,
+0x80005208,0x2802400,0x962460,0x80005c00,0x4000000,0x200000,0x80007300,0x24000000,0x200000,0x80009519,0x7c00100,0x220400,0x80009519,0x7c00100,0x230400,0x80009519,
+0x7c00100,0x250400,0x80009865,0x7c00100,0x230400,0x8000a008,0x2802100,0x962460,0x8000b30a,0x4000000,0x500000,0x8000b30a,0x7c00100,0x230400,0x8000cd00,0x4000000,
+0xe00000,0x8000d202,0x2802500,0x962460,0x8000d202,0x7c00100,0x230400,0x8000d68d,0x4000000,0x200000,0x8000d997,0x2802000,0x962460,0x8000d997,0x2802400,0x962460,
+0x8000d997,0x4000000,0x400000,0x8000d997,0x4000000,0x500000,0x8000d997,0x7c00100,0x230400,0x8000d997,0xc000010,0x448000,0x8000e489,0x2802100,0x962460,0x8000e489,
+0x7c00100,0x230400,0x8000e719,0x7c00100,0x220400,0x8000f8a6,0x2802100,0x962460,0x8000f8a6,0x7c00100,0x230400,0x8000f8a6,0xc000010,0x448000,0x8000fda1,0x2802100,
+0x1862460,0x8000fda1,0x2806400,0x1862460,0x8000fda1,0x4000000,0x1800000,0x8000fda1,0x6800000,0x1329800,0x8000fda1,0x6800100,0x1862400,0x8000fda1,0x6800100,0x1862540,
+0x8000fda1,0x7c00100,0x1830000,0x8000fda1,0xc000010,0x448000,0x8000fe9c,0x7c00100,0x230400,0x8000fe9c,0x7c00100,0x830400,0x8000fe9c,0x7c00100,0x1430400,0x8000ff06,
+0x7c00100,0x220400,0x80010165,0x7c00100,0x230400,0x800102a2,0x4000000,0x200000,0x800102a2,0x7c00100,0x230400,0x800103a4,0x7c00100,0x230400,0x800103a4,0xc000010,
+0x448000,0x8001044c,0x4000000,0x200000,0x8001044c,0x7c00100,0x220400,0x8001044c,0x7c00100,0x250400,0x80010670,0x2802000,0x962460,0x80010670,0x4000000,0x200000,
+0x80010670,0x4000010,0x400000,0x80010670,0xc000010,0x448000,0x800a4711,0x7c40300,0xe30000,0x800acd00,0x4000000,0xe00000,0x800acd00,0x4000000,0x2902460,0x800ace00,
+0x4000000,0xe00000,0x800acf00,0x4000000,0xe00000,0x800b0011,0x7c40300,0xe30000,0x800b0500,0x4000000,0xe00000,0x800b0500,0x4000000,0x2800000,0x90001615,0x7c00100,
+0x230400,0x9000171a,0x4000000,0x200000,0x9000171a,0x7c00100,0x230400,0x90003000,0x24000000,0x200000,0x90007f0e,0x4000000,0x200000,0x90008301,0x2802400,0x962460,
+0x90008e00,0x24000000,0x400000,0x90009519,0x7c00100,0x250400,0x9000a16f,0x2802100,0x962460,0x9000d200,0x80000000,0x218960,0x9000d202,0x2802000,0x962460,0x9000d202,
+0x2802100,0x962460,0x9000d202,0x7c00100,0x230400,0x9000e59d,0x2802100,0x962460,0x90010500,0x4000000,0xe00000,0x900107a7,0x2802100,0x962460,0x900107a7,0x2802400,
+0x962460,0x900107a7,0x2802c00,0x962460,0x900107a7,0x4000000,0x1400000,0x900107a7,0x6800000,0x1329800,0x900107a7,0x7c00100,0x220400,0x900107a7,0x7c00100,0x250400,
+0x900108a8,0x2802100,0x962460,0x900108a8,0x2806400,0x962460,0x900108a8,0x4000000,0x200000,0x900108a8,0x4000000,0x400000,0x900108a8,0x4000010,0x400000,0x900108a8,
+0x6800000,0x1329800,0x900108a8,0x6800100,0x962540,0x900108a8,0x7c00100,0x230400,0x900108a8,0xc000010,0x448000,0x90010908,0x7c00100,0x220400,0x90010a38,0x2802100,
+0x962460,0x90010ca9,0x2802100,0x962460,0x90010ca9,0x4000000,0x500000,0x90010ca9,0x4000010,0xb00000,0x90010ca9,0x6800100,0x962540,0x90010ca9,0x7c00100,0x230400,
+0x90010d1b,0x4000000,0x500000,0x90010eaa,0x2802100,0x962460,0x90010eaa,0x2802400,0x962460,0x90010eaa,0x2806400,0x962460,0x90010eaa,0x4000000,0x200000,0x90010eaa,
+0x4000000,0x400000,0x90010eaa,0x4000010,0x400000,0x90010eaa,0x6800000,0x1329800,0x90010eaa,0x6800100,0x962540,0x90010eaa,0x7c00100,0x230400,0x90010eaa,0xc000010,
+0x448000,0x90010fab,0x7c00100,0x220400,0x90010fab,0x7c00100,0x250400,0x9002c300,0x4000000,0x100000,0x900ac400,0x4000000,0xe0000d,0x900acd00,0x4000000,0xe00000,
+0x900acd00,0x4000000,0x2800000,0x900acf00,0x4000000,0xe00000,0x900b0500,0x4000000,0xe00000,0x900b0500,0x4000000,0x2800000,0x900b0b9a,0x7c00900,0x1230400,0x900b109a,
+0x7c00300,0xe30000,0x900b119a,0x7c00300,0xe30000,0x90408e06,0x24000000,0x400000,0xa0001004,0x4000000,0x200000,0xa0001004,0x7c00100,0x230400,0xa000120f,0x2802100,
+0x962460,0xa000120f,0x2802400,0x962460,0xa000171a,0x2802100,0x962460,0xa000171a,0x2806400,0x962460,0xa0002a00,0x4000000,0x1600000,0xa0003000,0x24000000,0x200000,
+0xa000581e,0x7c00100,0x230400,0xa0007300,0x24000000,0x200000,0xa0008301,0x2802400,0x962460,0xa0008e00,0x24000000,0x400000,0xa000cf00,0x4000000,0xe00000,0xa0010500,
+0x4000000,0x200000,0xa00114af,0x2802100,0x962460,0xa00114af,0x2802400,0x962460,0xa00114af,0x2806400,0x962460,0xa00114af,0x6800000,0x1329800,0xa00114af,0x7c00100,
+0x230400,0xa00114af,0x7c00100,0x230560,0xa00116b0,0x2802100,0x962460,0xa00116b0,0x2802800,0x962460,0xa00116b0,0x2806400,0x962460,0xa00116b0,0x4000000,0x400000,
+0xa00116b0,0x4000000,0x500000,0xa00116b0,0x4000010,0x400000,0xa00116b0,0x6800100,0x962540,0xa00116b0,0x7c00100,0x230400,0xa00116b0,0x7c00100,0x230560,0xa00116b0,
+0xc000010,0x448000,0xa0011722,0x7c00100,0x230400,0xa00118b1,0x2802000,0x962460,0xa00118b1,0x2802100,0x962460,0xa00118b1,0x2806400,0x962460,0xa00118b1,0x4000000,
+0x200000,0xa00118b1,0x4000000,0x400000,0xa00118b1,0x4000000,0x500000,0xa00118b1,0x6800100,0x962540,0xa00118b1,0x7c00100,0x230400,0xa00118b1,0x7c00100,0x230560,
+0xa00118b1,0xc000010,0x448000,0xa00a4005,0x7c00100,0xe30400,0xa00a4711,0x7c40300,0xe30000,0xa00ac400,0x4000000,0xe00000,0xa00acb14,0x7c00100,0xe30000,0xa00acf00,
+0x4000000,0xe00000,0xa00b0500,0x4000000,0xe00000,0xa00b0500,0x4000000,0x2800000,0xa00b0b96,0x7c00900,0x1230400,0xa00b1211,0x7c40300,0xe30000,0xa00b1314,0x7c00100,
+0xe30000,0xa00b1596,0x7c00300,0xe30000,0xa040afb7,0x6800400,0x962540,0xa08083b8,0x2802400,0x962460,0xb0000a03,0x7c00100,0x220400,0xb0000b13,0x7c00100,0x2633800,
+0xb0001004,0x2802000,0x962460,0xb0001110,0x4000000,0x200000,0xb0001524,0x2802100,0x962460,0xb0001615,0x4000000,0x500000,0xb000251b,0x7c00100,0x230400,0xb0007300,
+0x24000000,0x200000,0xb0008939,0x4000000,0x200000,0xb0008939,0x7c00100,0x230400,0xb0008e00,0x24000000,0x200000,0xb0008e00,0x24000000,0x400000,0xb0008e00,0x24000010,
+0x400000,0xb0009257,0x2802000,0x962460,0xb0009257,0x4000000,0x1600000,0xb0009519,0x7c00100,0x220400,0xb0009519,0x7c00100,0x250400,0xb0009a00,0x4000000,0x200000,
+0xb000b30a,0x2802100,0x962460,0xb000b30a,0x7c00100,0x230400,0xb000c178,0x80000000,0x218960,0xb000c300,0x4000000,0x200000,0xb000d202,0x2802000,0x962460,0xb000d476,
+0x6800100,0x962540,0xb000d476,0x7c00100,0x230400,0xb000e300,0x4000000,0xe00000,0xb000fda1,0x7c00100,0x1830000,0xb0010eaa,0x2802000,0x962460,0xb00116b0,0x7c00100,
+0x230400,0xb0011900,0x4000000,0xe00000,0xb0011ab2,0x2802100,0x962460,0xb0011ab2,0x2802400,0x962460,0xb0011ab2,0x2806400,0x962460,0xb0011ab2,0x4000000,0x200000,
+0xb0011ab2,0x6800100,0x962540,0xb0011ab2,0x7c00100,0x230400,0xb0011b0c,0x7c00100,0x230400,0xb0011cb3,0x2802100,0x962460,0xb0011cb3,0x2806400,0x962460,0xb0011cb3,
+0x6800000,0x1329800,0xb0011cb3,0x6800100,0x962540,0xb0011cb3,0x7c00100,0x230400,0xb0011db6,0x2802500,0x962460,0xb0011db6,0x6800000,0x1329800,0xb0011db6,0x7c00100,
+0x230400,0xb0011db6,0x7c00500,0x230400,0xb0011e00,0x4000000,0x200000,0xb0011e00,0x4000000,0x1500000,0xb0011fb4,0x2802100,0x962460,0xb0011fb4,0x6800100,0x962540,
+0xb0011fb4,0x7c00100,0x230400,0xb0011fb4,0xc000010,0x248000,0xb0012000,0x4000000,0x200000,0xb00121b5,0x4000000,0x200000,0xb00121b5,0x4000010,0x400000,0xb00121b5,
+0x7c00100,0x220400,0xb00121b5,0x7c00100,0x250400,0xb00121b5,0xc000010,0x448000,0xb00122b8,0x4000000,0x200000,0xb00122b8,0x7c00100,0x230400,0xb00123b7,0x2802400,
+0x962460,0xb00123b7,0x4000000,0x200000,0xb00123b7,0x7c00100,0x230400,0xb00123b7,0xc000010,0x248000,0xb00a4005,0x7c00100,0xe30400,0xb00a4711,0x7c40300,0xe30000,
+0xb00acf00,0x4000000,0xe00000,0xb00b0500,0x4000000,0xe00000,0xb00b0500,0x4000000,0x2800000,0xb00b109a,0x7c00300,0xe30000,0xb080e487,0x2802000,0x962460,0xc0001524,
+0x4000000,0x500000,0xc0001a18,0x2806400,0x1862460,0xc0001a18,0x7c00100,0x1830000,0xc0007300,0x24000000,0x200000,0xc0008e00,0x24000010,0x400000,0xc0009519,0x7c00100,
+0x220400,0xc0009519,0x7c00100,0x250400,0xc000c300,0x4000000,0x20000f,0xc000d85c,0x2802100,0x962460,0xc000d85c,0x6800100,0x962540,0xc000d85c,0x7c00100,0x230400,
+0xc000dc99,0x7c00100,0x230400,0xc000e719,0x7c00100,0x220400,0xc00107a7,0x7c00100,0x230400,0xc0010eaa,0x7c00100,0x230400,0xc00116b0,0x7c00100,0x230560,0xc0011900,
+0x4000000,0x200000,0xc0012447,0,0x818820,0xc0012447,0,0xc18820,0xc0012447,0,0x1418820,0xc00125b9,0x7c00100,0x230400,0xc00126bb,0x2802100,
+0x962460,0xc00126bb,0x2806400,0x962460,0xc00126bb,0x4000000,0x500000,0xc00126bb,0x6800100,0x962540,0xc00126bb,0x7c00100,0x230400,0xc00127ba,0x2802400,0x962460,
+0xc00127ba,0x4000000,0x200000,0xc00127ba,0x6800000,0x1329800,0xc00127ba,0x7c00100,0x230400,0xc00127ba,0x7c00900,0x230400,0xc0012800,0x4000000,0x200000,0xc0012b23,
+0x4000000,0x200000,0xc0012b23,0x4000000,0x400000,0xc0012b23,0x4000000,0x1500000,0xc0012cbc,0x2802400,0x962460,0xc0012cbc,0x4000000,0x1600000,0xc0012cbc,0x6800000,
+0x1329800,0xc0012cbc,0x7c00100,0x230400,0xc00acf00,0x4000000,0xe00000,0xc00ae300,0x4000000,0xe00000,0xc00b0500,0x4000000,0xe00000,0xc00b0500,0x4000000,0x2800000,
+0xc00b0b11,0x4000000,0x1200000,0xc00b0b11,0x7c00900,0x1230400,0xc00b109a,0x7c00300,0xe30000,0xc00b2914,0x7c00100,0x2530000,0xc00b2916,0x7c00100,0x2530c00,0xc00b2a00,
+0x4000000,0xe00000,0xc040af5e,0x7c00100,0x230400,0xc0c12b89,0x4000000,0x200000,0xc14a44ca,0x4000000,0xe0000d,0xd000131f,0x2802c00,0x962460,0xd000171a,0x7c00100,
+0x230400,0xd0001821,0x2802100,0x962460,0xd0007300,0x24000000,0x200000,0xd0008e00,0x24000000,0x200000,0xd0008f3a,0x2806000,0x962460,0xd0009519,0x7c00100,0x220400,
+0xd0009519,0x7c00100,0x250400,0xd000a500,0x4000000,0x200000,0xd000c300,0x4000000,0xe00000,0xd000d202,0x7c00100,0x230400,0xd000d476,0x7c00100,0x230400,0xd000d997,
+0x2802100,0x962460,0xd000d997,0x6800100,0x962540,0xd000e001,0x2802100,0x962460,0xd000e700,0x4000400,0x200000,0xd000e719,0x7c00100,0x220400,0xd000e719,0x7c00500,
+0x22040f,0xd000fa00,0x4000000,0xe00000,0xd0010eaa,0x4000010,0x400000,0xd0010eaa,0x7c00100,0x230400,0xd0012dbd,0x4000000,0x200000,0xd0012dbd,0x7c00100,0x230400,
+0xd0012fbe,0x2802100,0x962460,0xd0012fbe,0x2802400,0x962460,0xd0012fbe,0x2806400,0x962460,0xd0012fbe,0x4000000,0x400000,0xd0012fbe,0x6800000,0x1329800,0xd0012fbe,
+0x6800100,0x962540,0xd0012fbe,0x6800100,0x962541,0xd0012fbe,0x6804400,0x962540,0xd0012fbe,0x7c00100,0x230400,0xd0012fbe,0x7c00100,0x230560,0xd0012fbe,0xc000010,
+0x448000,0xd0013183,0x7c00100,0x230400,0xd0013200,0x4000000,0x200000,0xd0013200,0x6800000,0x1329805,0xd00134c0,0x2802100,0x962460,0xd00134c0,0x4000002,0x400000,
+0xd00134c0,0x7c00100,0x230400,0xd00a4305,0x7c00100,0xe30400,0xd00a4611,0x7c40300,0xe30000,0xd00a4711,0x7c40300,0xe30000,0xd00a5e11,0x7c40300,0xe30000,0xd00acf00,
+0x4000000,0xe00000,0xd00b0500,0x4000000,0xe00000,0xd00b0500,0x4000000,0x2800000,0xd00b0b11,0x6800500,0x962540,0xd00b0bbf,0x2802200,0xc62460,0xd00b119a,0x7c00300,
+0xe30000,0xd00b2a00,0x4000000,0xe00000,0xd00b2e11,0x7c40300,0xe30000,0xd00b30bf,0x7c00300,0x230000,0xd00b339a,0x7c00300,0xe30000,0xe0000c02,0xc000010,0xb48000,
+0xe0001524,0x2802400,0x962460,0xe0001524,0x7c00100,0x230400,0xe0001615,0x7c00100,0x230400,0xe000251b,0x12882000,0x962460,0xe0002a00,0x4000000,0x1500000,0xe0005102,
+0x4000000,0x200000,0xe0005c00,0x4000000,0x200000,0xe000622a,0x6804400,0x962540,0xe000622a,0x7c00100,0x230400,0xe0008838,0x7c00100,0x220400,0xe0008838,0x7c00100,
+0x250400,0xe0008e00,0x24000000,0x810000,0xe0008e00,0x24000000,0x1410000,0xe0008e00,0x24000002,0x400000,0xe0008e00,0x2c000010,0xb48000,0xe000933e,0x7c00100,0x230400,
+0xe000933e,0xc000010,0x448000,0xe0009519,0x7c00100,0x220400,0xe0009519,0x7c00100,0x22040f,0xe0009519,0x7c00100,0x250400,0xe000c178,0x2802100,0x962460,0xe000c941,
+0x2802100,0x962460,0xe000c941,0x2806400,0x962460,0xe000c941,0x7c00100,0x230400,0xe000d202,0x2802400,0x962460,0xe000d202,0x7c00100,0x230400,0xe000d202,0x7c00500,
+0x230400,0xe000dc99,0x4000000,0x200000,0xe000e001,0x2802100,0x962460,0xe000e001,0x2802400,0x962460,0xe000fda1,0x7c00100,0x1830000,0xe0013502,0x2802400,0x962460,
+0xe0013502,0x4000000,0x200000,0xe0013502,0x7c00100,0x230400,0xe0013502,0x80000000,0x218960,0xe00136c1,0x4000000,0x200000,0xe00136c1,0x7c00100,0x230400,0xe001370b,
+0x7c00100,0x230400,0xe0013919,0x7c00500,0x220400,0xe0013919,0x7c00500,0x22040f,0xe0013919,0x7c00d00,0x23040f,0xe0013a19,0x7c00100,0x220400,0xe0013a19,0x7c00100,
+0x230400,0xe0013bc2,0x2802400,0x962460,0xe0013bc2,0x7c00100,0x230400,0xe0013bc2,0xc000010,0x248000,0xe0013cc3,0x6800000,0x1329800,0xe0013cc3,0x7c00100,0x230400,
+0xe0013dc4,0x2802400,0x962460,0xe0013dc4,0x7c00100,0x230400,0xe0013e28,0x7c00100,0x230400,0xe0013fc5,0x7c00100,0x220400,0xe0013fc5,0x7c00100,0x250400,0xe0014000,
+0x4000000,0x200000,0xe0014001,0x2802400,0x962460,0xe00a4711,0x7c40300,0xe30000,0xe00a5e11,0x7c40300,0xe30000,0xe00ac511,0x7c40300,0xe30000,0xe00acf00,0x4000000,
+0xe00000,0xe00ae300,0x4000000,0xe00000,0xe00b0500,0x4000000,0xe00000,0xe00b1314,0x7c00100,0xe30000,0xe00b1316,0x7c00100,0xe30c00,0xe00b2a00,0x4000000,0xe00000,
+0xe00b2a00,0x4000000,0x2800000,0xe00b3816,0x7c00500,0x230c00,0xe0808328,0x2802400,0x962460,0xf0001615,0x6800100,0x962540,0xf0001a18,0x2802000,0x1862460,0xf000c247,
+0x7c00100,0x230400,0xf000d000,0x4000000,0xe00000,0xf000e300,0x4000000,0xe00000,0xf000e59d,0x2802100,0x962460,0xf000e59d,0x7c00100,0x230400,0xf0012447,0,
+0x818820,0xf0012447,0,0xc18820,0xf0012447,0,0x1418820,0xf0012447,0x2802000,0x962460,0xf0012447,0x2802400,0x962460,0xf0012447,0x7c00100,0x230400,
+0xf0013a19,0x7c00100,0x220400,0xf0014102,0x2802400,0x962460,0xf0014308,0x2802100,0x962460,0xf0014308,0x7c00500,0x22040e,0xf0014308,0x7c00500,0x22040f,0xf001440a,
+0x4000000,0x500000,0xf0014500,0x4000000,0x200000,0xf00146c6,0x2802100,0x962460,0xf00146c6,0x2806000,0x962460,0xf00146c6,0x4000000,0xe00000,0xf00146c6,0x6800000,
+0x1329800,0xf00146c6,0x6800100,0x962540,0xf00146c6,0x6804000,0x962540,0xf00146c6,0x7c00100,0x230400,0xf00146c6,0x7c00100,0x230560,0xf00146c6,0xc000010,0x448000,
+0xf00147c7,0x2802000,0x962460,0xf00147c7,0x6800000,0x1329800,0xf00147c7,0x7c00100,0x230400,0xf00ac511,0x7c40300,0xe30000,0xf00acf00,0x4000000,0xe00000,0xf00b2914,
+0x7c00100,0x2530000,0xf00b2916,0x7c00100,0x2530c00,0xf00b2a00,0x4000000,0xe00000,0xf00b2a00,0x4000000,0x2800000,0xf00b4211,0x7c40300,0xe30000};
 
-static const int32_t countPropsVectors=7095;
+static const int32_t countPropsVectors=7230;
 static const int32_t propsVectorsColumns=3;
 static const uint16_t scriptExtensions[282]={
 0x800e,0x8019,8,0x8059,8,2,8,0x8038,8,6,8,0x8019,2,0x22,0x25,0x57,
@@ -3937,6 +4006,6 @@ static const uint16_t scriptExtensions[282]={
 0x804f,0x37,0x804e,2,0x8057,2,0x8025,2,0x105,0x2f,0x31,0x8053,0x2f,0x31,0x80c1,0x2f,
 0x8031,2,0x8007,0x79,0x80c2,0x79,0x113,0x89,0x87,0x8087};
 
-static const int32_t indexes[UPROPS_INDEX_COUNT]={0x2c64,0x2c64,0x2c64,0x2c64,0x6b06,3,0x86bd,0x874a,0x874a,0x874a,0xb40c5,0x2a75a31,0,0,0,0};
+static const int32_t indexes[UPROPS_INDEX_COUNT]={0x2d08,0x2d08,0x2d08,0x2d08,0x6ce6,3,0x8924,0x89b1,0x89b1,0x89b1,0xb47c7,0x2a75a31,0,0,0,0};
 
 #endif  // INCLUDED_FROM_UCHAR_C
diff --git a/deps/icu-small/source/common/ucharstrie.cpp b/deps/icu-small/source/common/ucharstrie.cpp
index e0b33af519..24ab425777 100644
--- a/deps/icu-small/source/common/ucharstrie.cpp
+++ b/deps/icu-small/source/common/ucharstrie.cpp
@@ -308,13 +308,13 @@ UCharsTrie::findUniqueValueFromBranch(const UChar *pos, int32_t length,
                 }
             } else {
                 uniqueValue=value;
-                haveUniqueValue=TRUE;
+                haveUniqueValue=true;
             }
         } else {
             if(!findUniqueValue(pos+value, haveUniqueValue, uniqueValue)) {
                 return NULL;
             }
-            haveUniqueValue=TRUE;
+            haveUniqueValue=true;
         }
     } while(--length>1);
     return pos+1;  // ignore the last comparison unit
@@ -330,9 +330,9 @@ UCharsTrie::findUniqueValue(const UChar *pos, UBool haveUniqueValue, int32_t &un
             }
             pos=findUniqueValueFromBranch(pos, node+1, haveUniqueValue, uniqueValue);
             if(pos==NULL) {
-                return FALSE;
+                return false;
             }
-            haveUniqueValue=TRUE;
+            haveUniqueValue=true;
             node=*pos++;
         } else if(node<kMinValueLead) {
             // linear-match node
@@ -348,14 +348,14 @@ UCharsTrie::findUniqueValue(const UChar *pos, UBool haveUniqueValue, int32_t &un
             }
             if(haveUniqueValue) {
                 if(value!=uniqueValue) {
-                    return FALSE;
+                    return false;
                 }
             } else {
                 uniqueValue=value;
-                haveUniqueValue=TRUE;
+                haveUniqueValue=true;
             }
             if(isFinal) {
-                return TRUE;
+                return true;
             }
             pos=skipNodeValue(pos, node);
             node&=kNodeTypeMask;
diff --git a/deps/icu-small/source/common/ucharstriebuilder.cpp b/deps/icu-small/source/common/ucharstriebuilder.cpp
index 3871df6c27..be3260941e 100644
--- a/deps/icu-small/source/common/ucharstriebuilder.cpp
+++ b/deps/icu-small/source/common/ucharstriebuilder.cpp
@@ -163,7 +163,7 @@ UCharsTrieBuilder::buildUnicodeString(UStringTrieBuildOption buildOption, Unicod
                                       UErrorCode &errorCode) {
     buildUChars(buildOption, errorCode);
     if(U_SUCCESS(errorCode)) {
-        result.setTo(FALSE, uchars+(ucharsCapacity-ucharsLength), ucharsLength);
+        result.setTo(false, uchars+(ucharsCapacity-ucharsLength), ucharsLength);
     }
     return result;
 }
@@ -188,7 +188,7 @@ UCharsTrieBuilder::buildUChars(UStringTrieBuildOption buildOption, UErrorCode &e
         }
         uprv_sortArray(elements, elementsLength, (int32_t)sizeof(UCharsTrieElement),
                       compareElementStrings, &strings,
-                      FALSE,  // need not be a stable sort
+                      false,  // need not be a stable sort
                       &errorCode);
         if(U_FAILURE(errorCode)) {
             return;
@@ -322,7 +322,7 @@ UCharsTrieBuilder::createLinearMatchNode(int32_t i, int32_t unitIndex, int32_t l
 UBool
 UCharsTrieBuilder::ensureCapacity(int32_t length) {
     if(uchars==NULL) {
-        return FALSE;  // previous memory allocation had failed
+        return false;  // previous memory allocation had failed
     }
     if(length>ucharsCapacity) {
         int32_t newCapacity=ucharsCapacity;
@@ -335,7 +335,7 @@ UCharsTrieBuilder::ensureCapacity(int32_t length) {
             uprv_free(uchars);
             uchars=NULL;
             ucharsCapacity=0;
-            return FALSE;
+            return false;
         }
         u_memcpy(newUChars+(newCapacity-ucharsLength),
                  uchars+(ucharsCapacity-ucharsLength), ucharsLength);
@@ -343,7 +343,7 @@ UCharsTrieBuilder::ensureCapacity(int32_t length) {
         uchars=newUChars;
         ucharsCapacity=newCapacity;
     }
-    return TRUE;
+    return true;
 }
 
 int32_t
diff --git a/deps/icu-small/source/common/ucharstrieiterator.cpp b/deps/icu-small/source/common/ucharstrieiterator.cpp
index b3132241fe..2ba43692dd 100644
--- a/deps/icu-small/source/common/ucharstrieiterator.cpp
+++ b/deps/icu-small/source/common/ucharstrieiterator.cpp
@@ -26,7 +26,7 @@ UCharsTrie::Iterator::Iterator(ConstChar16Ptr trieUChars, int32_t maxStringLengt
         : uchars_(trieUChars),
           pos_(uchars_), initialPos_(uchars_),
           remainingMatchLength_(-1), initialRemainingMatchLength_(-1),
-          skipValue_(FALSE),
+          skipValue_(false),
           maxLength_(maxStringLength), value_(0), stack_(NULL) {
     if(U_FAILURE(errorCode)) {
         return;
@@ -48,7 +48,7 @@ UCharsTrie::Iterator::Iterator(const UCharsTrie &trie, int32_t maxStringLength,
         : uchars_(trie.uchars_), pos_(trie.pos_), initialPos_(trie.pos_),
           remainingMatchLength_(trie.remainingMatchLength_),
           initialRemainingMatchLength_(trie.remainingMatchLength_),
-          skipValue_(FALSE),
+          skipValue_(false),
           maxLength_(maxStringLength), value_(0), stack_(NULL) {
     if(U_FAILURE(errorCode)) {
         return;
@@ -82,7 +82,7 @@ UCharsTrie::Iterator &
 UCharsTrie::Iterator::reset() {
     pos_=initialPos_;
     remainingMatchLength_=initialRemainingMatchLength_;
-    skipValue_=FALSE;
+    skipValue_=false;
     int32_t length=remainingMatchLength_+1;  // Remaining match length.
     if(maxLength_>0 && length>maxLength_) {
         length=maxLength_;
@@ -100,12 +100,12 @@ UCharsTrie::Iterator::hasNext() const { return pos_!=NULL || !stack_->isEmpty();
 UBool
 UCharsTrie::Iterator::next(UErrorCode &errorCode) {
     if(U_FAILURE(errorCode)) {
-        return FALSE;
+        return false;
     }
     const UChar *pos=pos_;
     if(pos==NULL) {
         if(stack_->isEmpty()) {
-            return FALSE;
+            return false;
         }
         // Pop the state off the stack and continue with the next outbound edge of
         // the branch node.
@@ -118,7 +118,7 @@ UCharsTrie::Iterator::next(UErrorCode &errorCode) {
         if(length>1) {
             pos=branchNext(pos, length, errorCode);
             if(pos==NULL) {
-                return TRUE;  // Reached a final value.
+                return true;  // Reached a final value.
             }
         } else {
             str_.append(*pos++);
@@ -135,7 +135,7 @@ UCharsTrie::Iterator::next(UErrorCode &errorCode) {
             if(skipValue_) {
                 pos=skipNodeValue(pos, node);
                 node&=kNodeTypeMask;
-                skipValue_=FALSE;
+                skipValue_=false;
             } else {
                 // Deliver value for the string so far.
                 UBool isFinal=(UBool)(node>>15);
@@ -152,9 +152,9 @@ UCharsTrie::Iterator::next(UErrorCode &errorCode) {
                     // next time.
                     // Instead, keep pos_ on the node lead unit itself.
                     pos_=pos-1;
-                    skipValue_=TRUE;
+                    skipValue_=true;
                 }
-                return TRUE;
+                return true;
             }
         }
         if(maxLength_>0 && str_.length()==maxLength_) {
@@ -166,7 +166,7 @@ UCharsTrie::Iterator::next(UErrorCode &errorCode) {
             }
             pos=branchNext(pos, node+1, errorCode);
             if(pos==NULL) {
-                return TRUE;  // Reached a final value.
+                return true;  // Reached a final value.
             }
         } else {
             // Linear-match node, append length units to str_.
diff --git a/deps/icu-small/source/common/uchriter.cpp b/deps/icu-small/source/common/uchriter.cpp
index 2967375a6a..f2a9953841 100644
--- a/deps/icu-small/source/common/uchriter.cpp
+++ b/deps/icu-small/source/common/uchriter.cpp
@@ -171,7 +171,7 @@ UCharCharacterIterator::nextPostInc() {
 
 UBool
 UCharCharacterIterator::hasNext() {
-    return (UBool)(pos < end ? TRUE : FALSE);
+    return (UBool)(pos < end ? true : false);
 }
 
 UChar
@@ -185,7 +185,7 @@ UCharCharacterIterator::previous() {
 
 UBool
 UCharCharacterIterator::hasPrevious() {
-    return (UBool)(pos > begin ? TRUE : FALSE);
+    return (UBool)(pos > begin ? true : false);
 }
 
 UChar32
diff --git a/deps/icu-small/source/common/ucln_cmn.cpp b/deps/icu-small/source/common/ucln_cmn.cpp
index f3e07c6b89..ea797d1344 100644
--- a/deps/icu-small/source/common/ucln_cmn.cpp
+++ b/deps/icu-small/source/common/ucln_cmn.cpp
@@ -120,5 +120,5 @@ U_CFUNC UBool ucln_lib_cleanup(void) {
 #if !UCLN_NO_AUTO_CLEANUP && (defined(UCLN_AUTO_ATEXIT) || defined(UCLN_AUTO_LOCAL))
     ucln_unRegisterAutomaticCleanup();
 #endif
-    return TRUE;
+    return true;
 }
diff --git a/deps/icu-small/source/common/ucnv.cpp b/deps/icu-small/source/common/ucnv.cpp
index 019bcb6a79..26baa550c3 100644
--- a/deps/icu-small/source/common/ucnv.cpp
+++ b/deps/icu-small/source/common/ucnv.cpp
@@ -163,7 +163,7 @@ ucnv_safeClone(const UConverter* cnv, void *stackBuffer, int32_t *pBufferSize, U
     UErrorCode cbErr;
     UConverterToUnicodeArgs toUArgs = {
         sizeof(UConverterToUnicodeArgs),
-            TRUE,
+            true,
             NULL,
             NULL,
             NULL,
@@ -173,7 +173,7 @@ ucnv_safeClone(const UConverter* cnv, void *stackBuffer, int32_t *pBufferSize, U
     };
     UConverterFromUnicodeArgs fromUArgs = {
         sizeof(UConverterFromUnicodeArgs),
-            TRUE,
+            true,
             NULL,
             NULL,
             NULL,
@@ -269,7 +269,7 @@ ucnv_safeClone(const UConverter* cnv, void *stackBuffer, int32_t *pBufferSize, U
 
     /* Copy initial state */
     uprv_memcpy(localConverter, cnv, sizeof(UConverter));
-    localConverter->isCopyLocal = localConverter->isExtraLocal = FALSE;
+    localConverter->isCopyLocal = localConverter->isExtraLocal = false;
 
     /* copy the substitution string */
     if (cnv->subChars == (uint8_t *)cnv->subUChars) {
@@ -306,7 +306,7 @@ ucnv_safeClone(const UConverter* cnv, void *stackBuffer, int32_t *pBufferSize, U
 
     if(localConverter == (UConverter*)stackBuffer) {
         /* we're using user provided data - set to not destroy */
-        localConverter->isCopyLocal = TRUE;
+        localConverter->isCopyLocal = true;
     }
 
     /* allow callback functions to handle any memory allocation */
@@ -352,7 +352,7 @@ ucnv_close (UConverter * converter)
     if (converter->fromCharErrorBehaviour != UCNV_TO_U_DEFAULT_CALLBACK) {
         UConverterToUnicodeArgs toUArgs = {
             sizeof(UConverterToUnicodeArgs),
-                TRUE,
+                true,
                 NULL,
                 NULL,
                 NULL,
@@ -368,7 +368,7 @@ ucnv_close (UConverter * converter)
     if (converter->fromUCharErrorBehaviour != UCNV_FROM_U_DEFAULT_CALLBACK) {
         UConverterFromUnicodeArgs fromUArgs = {
             sizeof(UConverterFromUnicodeArgs),
-                TRUE,
+                true,
                 NULL,
                 NULL,
                 NULL,
@@ -580,7 +580,7 @@ static void _reset(UConverter *converter, UConverterResetChoice choice,
         if(choice<=UCNV_RESET_TO_UNICODE && converter->fromCharErrorBehaviour != UCNV_TO_U_DEFAULT_CALLBACK) {
             UConverterToUnicodeArgs toUArgs = {
                 sizeof(UConverterToUnicodeArgs),
-                TRUE,
+                true,
                 NULL,
                 NULL,
                 NULL,
@@ -595,7 +595,7 @@ static void _reset(UConverter *converter, UConverterResetChoice choice,
         if(choice!=UCNV_RESET_TO_UNICODE && converter->fromUCharErrorBehaviour != UCNV_FROM_U_DEFAULT_CALLBACK) {
             UConverterFromUnicodeArgs fromUArgs = {
                 sizeof(UConverterFromUnicodeArgs),
-                TRUE,
+                true,
                 NULL,
                 NULL,
                 NULL,
@@ -634,19 +634,19 @@ static void _reset(UConverter *converter, UConverterResetChoice choice,
 U_CAPI void  U_EXPORT2
 ucnv_reset(UConverter *converter)
 {
-    _reset(converter, UCNV_RESET_BOTH, TRUE);
+    _reset(converter, UCNV_RESET_BOTH, true);
 }
 
 U_CAPI void  U_EXPORT2
 ucnv_resetToUnicode(UConverter *converter)
 {
-    _reset(converter, UCNV_RESET_TO_UNICODE, TRUE);
+    _reset(converter, UCNV_RESET_TO_UNICODE, true);
 }
 
 U_CAPI void  U_EXPORT2
 ucnv_resetFromUnicode(UConverter *converter)
 {
-    _reset(converter, UCNV_RESET_FROM_UNICODE, TRUE);
+    _reset(converter, UCNV_RESET_FROM_UNICODE, true);
 }
 
 U_CAPI int8_t   U_EXPORT2
@@ -871,7 +871,7 @@ _fromUnicodeWithCallback(UConverterFromUnicodeArgs *pArgs, UErrorCode *err) {
 
         /* avoid compiler warnings - not otherwise necessary, and the values do not matter */
         realSourceLimit=NULL;
-        realFlush=FALSE;
+        realFlush=false;
         realSourceIndex=0;
     } else {
         /*
@@ -887,7 +887,7 @@ _fromUnicodeWithCallback(UConverterFromUnicodeArgs *pArgs, UErrorCode *err) {
         uprv_memcpy(replay, cnv->preFromU, -cnv->preFromULength*U_SIZEOF_UCHAR);
         pArgs->source=replay;
         pArgs->sourceLimit=replay-cnv->preFromULength;
-        pArgs->flush=FALSE;
+        pArgs->flush=false;
         sourceIndex=-1;
 
         cnv->preFromULength=0;
@@ -923,11 +923,11 @@ _fromUnicodeWithCallback(UConverterFromUnicodeArgs *pArgs, UErrorCode *err) {
                         cnv->fromUChar32==0);
         } else {
             /* handle error from ucnv_convertEx() */
-            converterSawEndOfInput=FALSE;
+            converterSawEndOfInput=false;
         }
 
         /* no callback called yet for this iteration */
-        calledCallback=FALSE;
+        calledCallback=false;
 
         /* no sourceIndex adjustment for conversion, only for callback output */
         errorInputLength=0;
@@ -976,7 +976,7 @@ _fromUnicodeWithCallback(UConverterFromUnicodeArgs *pArgs, UErrorCode *err) {
                     uprv_memcpy(replay, cnv->preFromU, -cnv->preFromULength*U_SIZEOF_UCHAR);
                     pArgs->source=replay;
                     pArgs->sourceLimit=replay-cnv->preFromULength;
-                    pArgs->flush=FALSE;
+                    pArgs->flush=false;
                     if((sourceIndex+=cnv->preFromULength)<0) {
                         sourceIndex=-1;
                     }
@@ -1017,7 +1017,7 @@ _fromUnicodeWithCallback(UConverterFromUnicodeArgs *pArgs, UErrorCode *err) {
 
                     /* inject an error and continue with callback handling */
                     *err=U_TRUNCATED_CHAR_FOUND;
-                    calledCallback=FALSE; /* new error condition */
+                    calledCallback=false; /* new error condition */
                 } else {
                     /* input consumed */
                     if(pArgs->flush) {
@@ -1033,7 +1033,7 @@ _fromUnicodeWithCallback(UConverterFromUnicodeArgs *pArgs, UErrorCode *err) {
                         }
 
                         /* reset the converter without calling the callback function */
-                        _reset(cnv, UCNV_RESET_FROM_UNICODE, FALSE);
+                        _reset(cnv, UCNV_RESET_FROM_UNICODE, false);
                     }
 
                     /* done successfully */
@@ -1110,7 +1110,7 @@ _fromUnicodeWithCallback(UConverterFromUnicodeArgs *pArgs, UErrorCode *err) {
              * that a callback was called;
              * if the callback did not resolve the error, then we return
              */
-            calledCallback=TRUE;
+            calledCallback=true;
         }
     }
 }
@@ -1118,7 +1118,7 @@ _fromUnicodeWithCallback(UConverterFromUnicodeArgs *pArgs, UErrorCode *err) {
 /*
  * Output the fromUnicode overflow buffer.
  * Call this function if(cnv->charErrorBufferLength>0).
- * @return TRUE if overflow
+ * @return true if overflow
  */
 static UBool
 ucnv_outputOverflowFromUnicode(UConverter *cnv,
@@ -1154,7 +1154,7 @@ ucnv_outputOverflowFromUnicode(UConverter *cnv,
                 *pOffsets=offsets;
             }
             *err=U_BUFFER_OVERFLOW_ERROR;
-            return TRUE;
+            return true;
         }
 
         /* copy the overflow contents to the target */
@@ -1170,7 +1170,7 @@ ucnv_outputOverflowFromUnicode(UConverter *cnv,
     if(offsets!=NULL) {
         *pOffsets=offsets;
     }
-    return FALSE;
+    return false;
 }
 
 U_CAPI void U_EXPORT2
@@ -1316,7 +1316,7 @@ _toUnicodeWithCallback(UConverterToUnicodeArgs *pArgs, UErrorCode *err) {
 
         /* avoid compiler warnings - not otherwise necessary, and the values do not matter */
         realSourceLimit=NULL;
-        realFlush=FALSE;
+        realFlush=false;
         realSourceIndex=0;
     } else {
         /*
@@ -1332,7 +1332,7 @@ _toUnicodeWithCallback(UConverterToUnicodeArgs *pArgs, UErrorCode *err) {
         uprv_memcpy(replay, cnv->preToU, -cnv->preToULength);
         pArgs->source=replay;
         pArgs->sourceLimit=replay-cnv->preToULength;
-        pArgs->flush=FALSE;
+        pArgs->flush=false;
         sourceIndex=-1;
 
         cnv->preToULength=0;
@@ -1368,11 +1368,11 @@ _toUnicodeWithCallback(UConverterToUnicodeArgs *pArgs, UErrorCode *err) {
                         cnv->toULength==0);
         } else {
             /* handle error from getNextUChar() or ucnv_convertEx() */
-            converterSawEndOfInput=FALSE;
+            converterSawEndOfInput=false;
         }
 
         /* no callback called yet for this iteration */
-        calledCallback=FALSE;
+        calledCallback=false;
 
         /* no sourceIndex adjustment for conversion, only for callback output */
         errorInputLength=0;
@@ -1421,7 +1421,7 @@ _toUnicodeWithCallback(UConverterToUnicodeArgs *pArgs, UErrorCode *err) {
                     uprv_memcpy(replay, cnv->preToU, -cnv->preToULength);
                     pArgs->source=replay;
                     pArgs->sourceLimit=replay-cnv->preToULength;
-                    pArgs->flush=FALSE;
+                    pArgs->flush=false;
                     if((sourceIndex+=cnv->preToULength)<0) {
                         sourceIndex=-1;
                     }
@@ -1462,7 +1462,7 @@ _toUnicodeWithCallback(UConverterToUnicodeArgs *pArgs, UErrorCode *err) {
 
                     /* inject an error and continue with callback handling */
                     *err=U_TRUNCATED_CHAR_FOUND;
-                    calledCallback=FALSE; /* new error condition */
+                    calledCallback=false; /* new error condition */
                 } else {
                     /* input consumed */
                     if(pArgs->flush) {
@@ -1478,7 +1478,7 @@ _toUnicodeWithCallback(UConverterToUnicodeArgs *pArgs, UErrorCode *err) {
                         }
 
                         /* reset the converter without calling the callback function */
-                        _reset(cnv, UCNV_RESET_TO_UNICODE, FALSE);
+                        _reset(cnv, UCNV_RESET_TO_UNICODE, false);
                     }
 
                     /* done successfully */
@@ -1556,7 +1556,7 @@ _toUnicodeWithCallback(UConverterToUnicodeArgs *pArgs, UErrorCode *err) {
              * that a callback was called;
              * if the callback did not resolve the error, then we return
              */
-            calledCallback=TRUE;
+            calledCallback=true;
         }
     }
 }
@@ -1564,7 +1564,7 @@ _toUnicodeWithCallback(UConverterToUnicodeArgs *pArgs, UErrorCode *err) {
 /*
  * Output the toUnicode overflow buffer.
  * Call this function if(cnv->UCharErrorBufferLength>0).
- * @return TRUE if overflow
+ * @return true if overflow
  */
 static UBool
 ucnv_outputOverflowToUnicode(UConverter *cnv,
@@ -1600,7 +1600,7 @@ ucnv_outputOverflowToUnicode(UConverter *cnv,
                 *pOffsets=offsets;
             }
             *err=U_BUFFER_OVERFLOW_ERROR;
-            return TRUE;
+            return true;
         }
 
         /* copy the overflow contents to the target */
@@ -1616,7 +1616,7 @@ ucnv_outputOverflowToUnicode(UConverter *cnv,
     if(offsets!=NULL) {
         *pOffsets=offsets;
     }
-    return FALSE;
+    return false;
 }
 
 U_CAPI void U_EXPORT2
@@ -1754,7 +1754,7 @@ ucnv_fromUChars(UConverter *cnv,
         destLimit=dest+destCapacity;
 
         /* perform the conversion */
-        ucnv_fromUnicode(cnv, &dest, destLimit, &src, srcLimit, 0, TRUE, pErrorCode);
+        ucnv_fromUnicode(cnv, &dest, destLimit, &src, srcLimit, 0, true, pErrorCode);
         destLength=(int32_t)(dest-originalDest);
 
         /* if an overflow occurs, then get the preflighting length */
@@ -1765,7 +1765,7 @@ ucnv_fromUChars(UConverter *cnv,
             do {
                 dest=buffer;
                 *pErrorCode=U_ZERO_ERROR;
-                ucnv_fromUnicode(cnv, &dest, destLimit, &src, srcLimit, 0, TRUE, pErrorCode);
+                ucnv_fromUnicode(cnv, &dest, destLimit, &src, srcLimit, 0, true, pErrorCode);
                 destLength+=(int32_t)(dest-buffer);
             } while(*pErrorCode==U_BUFFER_OVERFLOW_ERROR);
         }
@@ -1810,7 +1810,7 @@ ucnv_toUChars(UConverter *cnv,
         destLimit=dest+destCapacity;
 
         /* perform the conversion */
-        ucnv_toUnicode(cnv, &dest, destLimit, &src, srcLimit, 0, TRUE, pErrorCode);
+        ucnv_toUnicode(cnv, &dest, destLimit, &src, srcLimit, 0, true, pErrorCode);
         destLength=(int32_t)(dest-originalDest);
 
         /* if an overflow occurs, then get the preflighting length */
@@ -1822,7 +1822,7 @@ ucnv_toUChars(UConverter *cnv,
             do {
                 dest=buffer;
                 *pErrorCode=U_ZERO_ERROR;
-                ucnv_toUnicode(cnv, &dest, destLimit, &src, srcLimit, 0, TRUE, pErrorCode);
+                ucnv_toUnicode(cnv, &dest, destLimit, &src, srcLimit, 0, true, pErrorCode);
                 destLength+=(int32_t)(dest-buffer);
             }
             while(*pErrorCode==U_BUFFER_OVERFLOW_ERROR);
@@ -1907,15 +1907,15 @@ ucnv_getNextUChar(UConverter *cnv,
     }
 
     /*
-     * flush==TRUE is implied for ucnv_getNextUChar()
+     * flush==true is implied for ucnv_getNextUChar()
      *
      * do not simply return even if s==sourceLimit because the converter may
-     * not have seen flush==TRUE before
+     * not have seen flush==true before
      */
 
     /* prepare the converter arguments */
     args.converter=cnv;
-    args.flush=TRUE;
+    args.flush=true;
     args.offsets=NULL;
     args.source=s;
     args.sourceLimit=sourceLimit;
@@ -1937,7 +1937,7 @@ ucnv_getNextUChar(UConverter *cnv,
             *source=s=args.source;
             if(*err==U_INDEX_OUTOFBOUNDS_ERROR) {
                 /* reset the converter without calling the callback function */
-                _reset(cnv, UCNV_RESET_TO_UNICODE, FALSE);
+                _reset(cnv, UCNV_RESET_TO_UNICODE, false);
                 return 0xffff; /* no output */
             } else if(U_SUCCESS(*err) && c>=0) {
                 return c;
@@ -2176,7 +2176,7 @@ ucnv_convertEx(UConverter *targetCnv, UConverter *sourceCnv,
 
     /* prepare the converter arguments */
     fromUArgs.converter=targetCnv;
-    fromUArgs.flush=FALSE;
+    fromUArgs.flush=false;
     fromUArgs.offsets=NULL;
     fromUArgs.target=*target;
     fromUArgs.targetLimit=targetLimit;
@@ -2331,8 +2331,8 @@ ucnv_convertEx(UConverter *targetCnv, UConverter *sourceCnv,
                 /* input consumed */
                 if(flush) {
                     /* reset the converters without calling the callback functions */
-                    _reset(sourceCnv, UCNV_RESET_TO_UNICODE, FALSE);
-                    _reset(targetCnv, UCNV_RESET_FROM_UNICODE, FALSE);
+                    _reset(sourceCnv, UCNV_RESET_TO_UNICODE, false);
+                    _reset(targetCnv, UCNV_RESET_FROM_UNICODE, false);
                 }
 
                 /* done successfully */
@@ -2372,7 +2372,7 @@ ucnv_convertEx(UConverter *targetCnv, UConverter *sourceCnv,
             sourceCnv->preToULength>=0 &&
             sourceCnv->UCharErrorBufferLength==0
         ) {
-            fromUArgs.flush=TRUE;
+            fromUArgs.flush=true;
         }
     }
 
@@ -2436,8 +2436,8 @@ ucnv_internalConvert(UConverter *outConverter, UConverter *inConverter,
                        &myTarget, targetLimit,
                        &source, sourceLimit,
                        pivotBuffer, &pivot, &pivot2, pivotBuffer+CHUNK_SIZE,
-                       FALSE,
-                       TRUE,
+                       false,
+                       true,
                        pErrorCode);
         targetLength=(int32_t)(myTarget-target);
     }
@@ -2459,8 +2459,8 @@ ucnv_internalConvert(UConverter *outConverter, UConverter *inConverter,
                            &myTarget, targetLimit,
                            &source, sourceLimit,
                            pivotBuffer, &pivot, &pivot2, pivotBuffer+CHUNK_SIZE,
-                           FALSE,
-                           TRUE,
+                           false,
+                           true,
                            pErrorCode);
             targetLength+=(int32_t)(myTarget-targetBuffer);
         } while(*pErrorCode==U_BUFFER_OVERFLOW_ERROR);
@@ -2585,7 +2585,7 @@ ucnv_toAlgorithmic(UConverterType algorithmicType,
                    char *target, int32_t targetCapacity,
                    const char *source, int32_t sourceLength,
                    UErrorCode *pErrorCode) {
-    return ucnv_convertAlgorithmic(TRUE, algorithmicType, cnv,
+    return ucnv_convertAlgorithmic(true, algorithmicType, cnv,
                                    target, targetCapacity,
                                    source, sourceLength,
                                    pErrorCode);
@@ -2597,7 +2597,7 @@ ucnv_fromAlgorithmic(UConverter *cnv,
                      char *target, int32_t targetCapacity,
                      const char *source, int32_t sourceLength,
                      UErrorCode *pErrorCode) {
-    return ucnv_convertAlgorithmic(FALSE, algorithmicType, cnv,
+    return ucnv_convertAlgorithmic(false, algorithmicType, cnv,
                                    target, targetCapacity,
                                    source, sourceLength,
                                    pErrorCode);
@@ -2885,12 +2885,12 @@ ucnv_toUCountPending(const UConverter* cnv, UErrorCode* status){
 U_CAPI UBool U_EXPORT2
 ucnv_isFixedWidth(UConverter *cnv, UErrorCode *status){
     if (U_FAILURE(*status)) {
-        return FALSE;
+        return false;
     }
 
     if (cnv == NULL) {
         *status = U_ILLEGAL_ARGUMENT_ERROR;
-        return FALSE;
+        return false;
     }
 
     switch (ucnv_getType(cnv)) {
@@ -2900,9 +2900,9 @@ ucnv_isFixedWidth(UConverter *cnv, UErrorCode *status){
         case UCNV_UTF32_LittleEndian:
         case UCNV_UTF32:
         case UCNV_US_ASCII:
-            return TRUE;
+            return true;
         default:
-            return FALSE;
+            return false;
     }
 }
 #endif
diff --git a/deps/icu-small/source/common/ucnv2022.cpp b/deps/icu-small/source/common/ucnv2022.cpp
index aa1e169c99..ec096780e9 100644
--- a/deps/icu-small/source/common/ucnv2022.cpp
+++ b/deps/icu-small/source/common/ucnv2022.cpp
@@ -491,7 +491,7 @@ _ISO2022Open(UConverter *cnv, UConverterLoadArgs *pArgs, UErrorCode *errorCode){
 
         uprv_memset(myConverterData, 0, sizeof(UConverterDataISO2022));
         myConverterData->currentType = ASCII1;
-        cnv->fromUnicodeStatus =FALSE;
+        cnv->fromUnicodeStatus =false;
         if(pArgs->locale){
             uprv_strncpy(myLocale, pArgs->locale, sizeof(myLocale)-1);
         }
@@ -623,7 +623,7 @@ _ISO2022Open(UConverter *cnv, UConverterLoadArgs *pArgs, UErrorCode *errorCode){
 #endif  // !UCONFIG_ONLY_HTML_CONVERSION
         else{
 #ifdef U_ENABLE_GENERIC_ISO_2022
-            myConverterData->isFirstBuffer = TRUE;
+            myConverterData->isFirstBuffer = true;
 
             /* append the UTF-8 escape sequence */
             cnv->charErrorBufferLength = 3;
@@ -682,7 +682,7 @@ _ISO2022Reset(UConverter *converter, UConverterResetChoice choice) {
     if(choice<=UCNV_RESET_TO_UNICODE) {
         uprv_memset(&myConverterData->toU2022State, 0, sizeof(ISO2022State));
         myConverterData->key = 0;
-        myConverterData->isEmptySegment = FALSE;
+        myConverterData->isEmptySegment = false;
     }
     if(choice!=UCNV_RESET_TO_UNICODE) {
         uprv_memset(&myConverterData->fromU2022State, 0, sizeof(ISO2022State));
@@ -690,7 +690,7 @@ _ISO2022Reset(UConverter *converter, UConverterResetChoice choice) {
 #ifdef U_ENABLE_GENERIC_ISO_2022
     if(myConverterData->locale[0] == 0){
         if(choice<=UCNV_RESET_TO_UNICODE) {
-            myConverterData->isFirstBuffer = TRUE;
+            myConverterData->isFirstBuffer = true;
             myConverterData->key = 0;
             if (converter->mode == UCNV_SO){
                 ucnv_close (myConverterData->currentConverter);
@@ -1285,7 +1285,7 @@ T_UConverter_toUnicode_ISO_2022_OFFSETS_LOGIC(UConverterToUnicodeArgs* args,
                 }
 
                 /* convert to before the ESC or until the end of the buffer */
-                myData->isFirstBuffer=FALSE;
+                myData->isFirstBuffer=false;
                 sourceStart = args->source;
                 myTargetStart = args->target;
                 args->converter = myData->currentConverter;
@@ -1848,7 +1848,7 @@ getTrail:
                         len = 1;
                         cs = cs0;
                         g = 0;
-                        useFallback = FALSE;
+                        useFallback = false;
                     }
                     break;
                 case JISX208:
@@ -1864,7 +1864,7 @@ getTrail:
                             len = len2;
                             cs = cs0;
                             g = 0;
-                            useFallback = FALSE;
+                            useFallback = false;
                         }
                     } else if(len == 0 && useFallback &&
                               (uint32_t)(sourceChar - HWKANA_START) <= (HWKANA_END - HWKANA_START)) {
@@ -1872,7 +1872,7 @@ getTrail:
                         len = -2;
                         cs = cs0;
                         g = 0;
-                        useFallback = FALSE;
+                        useFallback = false;
                     }
                     break;
                 case ISO8859_7:
@@ -1886,7 +1886,7 @@ getTrail:
                         len = len2;
                         cs = cs0;
                         g = 2;
-                        useFallback = FALSE;
+                        useFallback = false;
                     }
                     break;
                 default:
@@ -1911,7 +1911,7 @@ getTrail:
                         len = len2;
                         cs = cs0;
                         g = 0;
-                        useFallback = FALSE;
+                        useFallback = false;
                     }
                     break;
                 }
@@ -2121,7 +2121,7 @@ UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *args,
                     continue;
                 } else {
                     /* only JIS7 uses SI/SO, not ISO-2022-JP-x */
-                    myData->isEmptySegment = FALSE;	/* reset this, we have a different error */
+                    myData->isEmptySegment = false;	/* reset this, we have a different error */
                     break;
                 }
 
@@ -2133,7 +2133,7 @@ UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *args,
                     continue;
                 } else {
                     /* only JIS7 uses SI/SO, not ISO-2022-JP-x */
-                    myData->isEmptySegment = FALSE;	/* reset this, we have a different error */
+                    myData->isEmptySegment = false;	/* reset this, we have a different error */
                     break;
                 }
 
@@ -2159,12 +2159,12 @@ escape:
                 if(U_FAILURE(*err)){
                     args->target = myTarget;
                     args->source = mySource;
-                    myData->isEmptySegment = FALSE;	/* Reset to avoid future spurious errors */
+                    myData->isEmptySegment = false;	/* Reset to avoid future spurious errors */
                     return;
                 }
                 /* If we successfully completed an escape sequence, we begin a new segment, empty so far */
                 if(myData->key==0) {
-                    myData->isEmptySegment = TRUE;
+                    myData->isEmptySegment = true;
                 }
                 continue;
 
@@ -2181,7 +2181,7 @@ escape:
                 U_FALLTHROUGH;
             default:
                 /* convert one or two bytes */
-                myData->isEmptySegment = FALSE;
+                myData->isEmptySegment = false;
                 cs = (StateEnum)pToU2022State->cs[pToU2022State->g];
                 if( (uint8_t)(mySourceChar - 0xa1) <= (0xdf - 0xa1) && myData->version==4 &&
                     !IS_JP_DBCS(cs)
@@ -2262,7 +2262,7 @@ getTrailByte:
                                 tempBuf[0] = (char)(tmpSourceChar >> 8);
                                 tempBuf[1] = (char)(tmpSourceChar);
                             }
-                            targetUniChar = ucnv_MBCSSimpleGetNextUChar(myData->myConverterArray[cs], tempBuf, 2, FALSE);
+                            targetUniChar = ucnv_MBCSSimpleGetNextUChar(myData->myConverterArray[cs], tempBuf, 2, false);
                         } else if (!(trailIsOk || IS_2022_CONTROL(trailByte))) {
                             /* report a pair of illegal bytes if the second byte is not a DBCS starter */
                             ++mySource;
@@ -2534,7 +2534,7 @@ getTrail:
         int32_t sourceIndex;
 
         /* we are switching to ASCII */
-        isTargetByteDBCS=FALSE;
+        isTargetByteDBCS=false;
 
         /* get the source index of the last input character */
         /*
@@ -2712,7 +2712,7 @@ UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *args,
             if(mySourceChar==UCNV_SI){
                 myData->toU2022State.g = 0;
                 if (myData->isEmptySegment) {
-                    myData->isEmptySegment = FALSE;	/* we are handling it, reset to avoid future spurious errors */
+                    myData->isEmptySegment = false;	/* we are handling it, reset to avoid future spurious errors */
                     *err = U_ILLEGAL_ESCAPE_SEQUENCE;
                     args->converter->toUCallbackReason = UCNV_IRREGULAR;
                     args->converter->toUBytes[0] = (uint8_t)mySourceChar;
@@ -2725,13 +2725,13 @@ UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *args,
                 continue;
             }else if(mySourceChar==UCNV_SO){
                 myData->toU2022State.g = 1;
-                myData->isEmptySegment = TRUE;	/* Begin a new segment, empty so far */
+                myData->isEmptySegment = true;	/* Begin a new segment, empty so far */
                 /*consume the source */
                 continue;
             }else if(mySourceChar==ESC_2022){
                 mySource--;
 escape:
-                myData->isEmptySegment = FALSE;	/* Any invalid ESC sequences will be detected separately, so just reset this */
+                myData->isEmptySegment = false;	/* Any invalid ESC sequences will be detected separately, so just reset this */
                 changeState_2022(args->converter,&(mySource),
                                 mySourceLimit, ISO_2022_KR, err);
                 if(U_FAILURE(*err)){
@@ -2742,7 +2742,7 @@ escape:
                 continue;
             }
 
-            myData->isEmptySegment = FALSE;	/* Any invalid char errors will be detected separately, so just reset this */
+            myData->isEmptySegment = false;	/* Any invalid char errors will be detected separately, so just reset this */
             if(myData->toU2022State.g == 1) {
                 if(mySource < mySourceLimit) {
                     int leadIsOk, trailIsOk;
@@ -3092,7 +3092,7 @@ getTrail:
                                     len = 2;
                                 } else {
                                     len = -2;
-                                    useFallback = FALSE;
+                                    useFallback = false;
                                 }
                                 if(cs == CNS_11643_1) {
                                     g = 1;
@@ -3119,7 +3119,7 @@ getTrail:
                                 len = len2;
                                 cs = cs0;
                                 g = 1;
-                                useFallback = FALSE;
+                                useFallback = false;
                             }
                         }
                     }
@@ -3301,7 +3301,7 @@ UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *args,
             case UCNV_SI:
                 pToU2022State->g=0;
                 if (myData->isEmptySegment) {
-                    myData->isEmptySegment = FALSE;	/* we are handling it, reset to avoid future spurious errors */
+                    myData->isEmptySegment = false;	/* we are handling it, reset to avoid future spurious errors */
                     *err = U_ILLEGAL_ESCAPE_SEQUENCE;
                     args->converter->toUCallbackReason = UCNV_IRREGULAR;
                     args->converter->toUBytes[0] = static_cast<uint8_t>(mySourceChar);
@@ -3315,11 +3315,11 @@ UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *args,
             case UCNV_SO:
                 if(pToU2022State->cs[1] != 0) {
                     pToU2022State->g=1;
-                    myData->isEmptySegment = TRUE;	/* Begin a new segment, empty so far */
+                    myData->isEmptySegment = true;	/* Begin a new segment, empty so far */
                     continue;
                 } else {
                     /* illegal to have SO before a matching designator */
-                    myData->isEmptySegment = FALSE;	/* Handling a different error, reset this to avoid future spurious errs */
+                    myData->isEmptySegment = false;	/* Handling a different error, reset this to avoid future spurious errs */
                     break;
                 }
 
@@ -3345,7 +3345,7 @@ escape:
                 if(U_FAILURE(*err)){
                     args->target = myTarget;
                     args->source = mySource;
-                    myData->isEmptySegment = FALSE;	/* Reset to avoid future spurious errors */
+                    myData->isEmptySegment = false;	/* Reset to avoid future spurious errors */
                     return;
                 }
                 continue;
@@ -3358,7 +3358,7 @@ escape:
                 U_FALLTHROUGH;
             default:
                 /* convert one or two bytes */
-                myData->isEmptySegment = FALSE;
+                myData->isEmptySegment = false;
                 if(pToU2022State->g != 0) {
                     if(mySource < mySourceLimit) {
                         UConverterSharedData *cnv;
@@ -3397,7 +3397,7 @@ getTrailByte:
                                 tempBuf[1] = (char) trailByte;
                                 tempBufLen = 2;
                             }
-                            targetUniChar = ucnv_MBCSSimpleGetNextUChar(cnv, tempBuf, tempBufLen, FALSE);
+                            targetUniChar = ucnv_MBCSSimpleGetNextUChar(cnv, tempBuf, tempBufLen, false);
                             mySourceChar = (mySourceChar << 8) | trailByte;
                         } else if (!(trailIsOk || IS_2022_CONTROL(trailByte))) {
                             /* report a pair of illegal bytes if the second byte is not a DBCS starter */
@@ -3609,7 +3609,7 @@ _ISO_2022_SafeClone(
 
     uprv_memcpy(&localClone->mydata, cnvData, sizeof(UConverterDataISO2022));
     localClone->cnv.extraInfo = &localClone->mydata; /* set pointer to extra data */
-    localClone->cnv.isExtraLocal = TRUE;
+    localClone->cnv.isExtraLocal = true;
 
     /* share the subconverters */
 
@@ -3808,8 +3808,8 @@ static const UConverterStaticData _ISO2022StaticData={
     3, /* max 3 bytes per UChar from UTF-8 (4 bytes from surrogate _pair_) */
     { 0x1a, 0, 0, 0 },
     1,
-    FALSE,
-    FALSE,
+    false,
+    false,
     0,
     0,
     { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } /* reserved */
@@ -3853,8 +3853,8 @@ static const UConverterStaticData _ISO2022JPStaticData={
     6, /* max 6 bytes per UChar: 4-byte escape sequence + DBCS */
     { 0x1a, 0, 0, 0 },
     1,
-    FALSE,
-    FALSE,
+    false,
+    false,
     0,
     0,
     { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } /* reserved */
@@ -3904,8 +3904,8 @@ static const UConverterStaticData _ISO2022KRStaticData={
     8, /* max 8 bytes per UChar */
     { 0x1a, 0, 0, 0 },
     1,
-    FALSE,
-    FALSE,
+    false,
+    false,
     0,
     0,
     { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } /* reserved */
@@ -3955,8 +3955,8 @@ static const UConverterStaticData _ISO2022CNStaticData={
     8, /* max 8 bytes per UChar: 4-byte CNS designator + 2 bytes for SS2/SS3 + DBCS */
     { 0x1a, 0, 0, 0 },
     1,
-    FALSE,
-    FALSE,
+    false,
+    false,
     0,
     0,
     { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } /* reserved */
diff --git a/deps/icu-small/source/common/ucnv_bld.cpp b/deps/icu-small/source/common/ucnv_bld.cpp
index d08eec7369..a0fbfe2d7f 100644
--- a/deps/icu-small/source/common/ucnv_bld.cpp
+++ b/deps/icu-small/source/common/ucnv_bld.cpp
@@ -200,7 +200,7 @@ static icu::UMutex cnvCacheMutex;
 
 static const char **gAvailableConverters = NULL;
 static uint16_t gAvailableConverterCount = 0;
-static icu::UInitOnce gAvailableConvertersInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gAvailableConvertersInitOnce {};
 
 #if !U_CHARSET_IS_UTF8
 
@@ -254,7 +254,7 @@ static UBool U_CALLCONV ucnv_cleanup(void) {
 #if !U_CHARSET_IS_UTF8
     gDefaultConverterName = NULL;
     gDefaultConverterNameBuffer[0] = 0;
-    gDefaultConverterContainsOption = FALSE;
+    gDefaultConverterContainsOption = false;
     gDefaultAlgorithmicSharedData = NULL;
 #endif
 
@@ -318,7 +318,7 @@ ucnv_data_unFlattenClone(UConverterLoadArgs *pArgs, UDataMemory *pData, UErrorCo
 
     data->staticData = source;
 
-    data->sharedDataCached = FALSE;
+    data->sharedDataCached = false;
 
     /* fill in fields from the loaded data */
     data->dataMemory = (void*)pData; /* for future use */
@@ -462,7 +462,7 @@ ucnv_shareConverterData(UConverterSharedData * data)
     */
 
     /* Mark it shared */
-    data->sharedDataCached = TRUE;
+    data->sharedDataCached = true;
 
     uhash_put(SHARED_DATA_HASHTABLE,
             (void*) data->staticData->name, /* Okay to cast away const as long as
@@ -502,11 +502,11 @@ ucnv_getSharedConverterData(const char *name)
  */
 /* Deletes (frees) the Shared data it's passed. first it checks the referenceCounter to
  * see if anyone is using it, if not it frees all the memory stemming from sharedConverterData and
- * returns TRUE,
- * otherwise returns FALSE
+ * returns true,
+ * otherwise returns false
  * @param sharedConverterData The shared data
  * @return if not it frees all the memory stemming from sharedConverterData and
- * returns TRUE, otherwise returns FALSE
+ * returns true, otherwise returns false
  */
 static UBool
 ucnv_deleteSharedConverterData(UConverterSharedData * deadSharedData)
@@ -515,8 +515,8 @@ ucnv_deleteSharedConverterData(UConverterSharedData * deadSharedData)
     UTRACE_DATA2(UTRACE_OPEN_CLOSE, "unload converter %s shared data %p", deadSharedData->staticData->name, deadSharedData);
 
     if (deadSharedData->referenceCounter > 0) {
-        UTRACE_EXIT_VALUE((int32_t)FALSE);
-        return FALSE;
+        UTRACE_EXIT_VALUE((int32_t)false);
+        return false;
     }
 
     if (deadSharedData->impl->unload != NULL) {
@@ -531,8 +531,8 @@ ucnv_deleteSharedConverterData(UConverterSharedData * deadSharedData)
 
     uprv_free(deadSharedData);
 
-    UTRACE_EXIT_VALUE((int32_t)TRUE);
-    return TRUE;
+    UTRACE_EXIT_VALUE((int32_t)true);
+    return true;
 }
 
 /**
@@ -589,7 +589,7 @@ ucnv_unload(UConverterSharedData *sharedData) {
             sharedData->referenceCounter--;
         }
 
-        if((sharedData->referenceCounter <= 0)&&(sharedData->sharedDataCached == FALSE)) {
+        if((sharedData->referenceCounter <= 0)&&(sharedData->sharedDataCached == false)) {
             ucnv_deleteSharedConverterData(sharedData);
         }
     }
@@ -703,10 +703,10 @@ parseConverterOptions(const char *inName,
 
 /*Logic determines if the converter is Algorithmic AND/OR cached
  *depending on that:
- * -we either go to get data from disk and cache it (Data=TRUE, Cached=False)
- * -Get it from a Hashtable (Data=X, Cached=TRUE)
- * -Call dataConverter initializer (Data=TRUE, Cached=TRUE)
- * -Call AlgorithmicConverter initializer (Data=FALSE, Cached=TRUE)
+ * -we either go to get data from disk and cache it (Data=true, Cached=false)
+ * -Get it from a Hashtable (Data=X, Cached=true)
+ * -Call dataConverter initializer (Data=true, Cached=true)
+ * -Call AlgorithmicConverter initializer (Data=false, Cached=true)
  */
 U_CFUNC UConverterSharedData *
 ucnv_loadSharedData(const char *converterName,
@@ -717,8 +717,8 @@ ucnv_loadSharedData(const char *converterName,
     UConverterLoadArgs stackArgs;
     UConverterSharedData *mySharedConverterData = NULL;
     UErrorCode internalErrorCode = U_ZERO_ERROR;
-    UBool mayContainOption = TRUE;
-    UBool checkForAlgorithmic = TRUE;
+    UBool mayContainOption = true;
+    UBool checkForAlgorithmic = true;
 
     if (U_FAILURE (*err)) {
         return NULL;
@@ -762,7 +762,7 @@ ucnv_loadSharedData(const char *converterName,
             return NULL;
         }
         mySharedConverterData = (UConverterSharedData *)gDefaultAlgorithmicSharedData;
-        checkForAlgorithmic = FALSE;
+        checkForAlgorithmic = false;
         mayContainOption = gDefaultConverterContainsOption;
         /* the default converter name is already canonical */
 #endif
@@ -866,7 +866,7 @@ ucnv_canCreateConverter(const char *converterName, UErrorCode *err) {
     if(U_SUCCESS(*err)) {
         UTRACE_DATA1(UTRACE_OPEN_CLOSE, "test if can open converter %s", converterName);
 
-        stackArgs.onlyTestIsLoadable=TRUE;
+        stackArgs.onlyTestIsLoadable=true;
         mySharedConverterData = ucnv_loadSharedData(converterName, &stackPieces, &stackArgs, err);
         ucnv_createConverterFromSharedData(
             &myUConverter, mySharedConverterData,
@@ -989,15 +989,15 @@ ucnv_createConverterFromSharedData(UConverter *myUConverter,
             ucnv_unloadSharedDataIfReady(mySharedConverterData);
             return NULL;
         }
-        isCopyLocal = FALSE;
+        isCopyLocal = false;
     } else {
-        isCopyLocal = TRUE;
+        isCopyLocal = true;
     }
 
     /* initialize the converter */
     uprv_memset(myUConverter, 0, sizeof(UConverter));
     myUConverter->isCopyLocal = isCopyLocal;
-    /*myUConverter->isExtraLocal = FALSE;*/ /* Set by the memset call */
+    /*myUConverter->isExtraLocal = false;*/ /* Set by the memset call */
     myUConverter->sharedData = mySharedConverterData;
     myUConverter->options = pArgs->options;
     if(!pArgs->onlyTestIsLoadable) {
@@ -1083,7 +1083,7 @@ ucnv_flushCache ()
                 UCNV_DEBUG_LOG("del",mySharedData->staticData->name,mySharedData);
 
                 uhash_removeElement(SHARED_DATA_HASHTABLE, e);
-                mySharedData->sharedDataCached = FALSE;
+                mySharedData->sharedDataCached = false;
                 ucnv_deleteSharedConverterData (mySharedData);
             } else {
                 ++remaining;
@@ -1342,7 +1342,7 @@ ucnv_swap(const UDataSwapper *ds,
     _MBCSHeader *outMBCSHeader;
     _MBCSHeader mbcsHeader;
     uint32_t mbcsHeaderLength;
-    UBool noFromU=FALSE;
+    UBool noFromU=false;
 
     uint8_t outputType;
 
diff --git a/deps/icu-small/source/common/ucnv_cb.cpp b/deps/icu-small/source/common/ucnv_cb.cpp
index 1bb0012014..7bfde82870 100644
--- a/deps/icu-small/source/common/ucnv_cb.cpp
+++ b/deps/icu-small/source/common/ucnv_cb.cpp
@@ -86,7 +86,7 @@ ucnv_cbFromUWriteUChars(UConverterFromUnicodeArgs *args,
         source,
         sourceLimit,
         NULL, /* no offsets */
-        FALSE, /* no flush */
+        false, /* no flush */
         err);
 
     if(args->offsets)
@@ -141,7 +141,7 @@ ucnv_cbFromUWriteUChars(UConverterFromUnicodeArgs *args,
                          source,
                          sourceLimit,
                          NULL,
-                         FALSE,
+                         false,
                          &err2);
 
         /* We can go ahead and overwrite the  length here. We know just how
diff --git a/deps/icu-small/source/common/ucnv_ct.cpp b/deps/icu-small/source/common/ucnv_ct.cpp
index b40e1b2c97..c12e982b88 100644
--- a/deps/icu-small/source/common/ucnv_ct.cpp
+++ b/deps/icu-small/source/common/ucnv_ct.cpp
@@ -225,23 +225,23 @@ static COMPOUND_TEXT_CONVERTERS getState(int codepoint) {
 
 static COMPOUND_TEXT_CONVERTERS findStateFromEscSeq(const char* source, const char* sourceLimit, const uint8_t* toUBytesBuffer, int32_t toUBytesBufferLength, UErrorCode *err) {
     COMPOUND_TEXT_CONVERTERS state = INVALID;
-    UBool matchFound = FALSE;
+    UBool matchFound = false;
     int32_t i, n, offset = toUBytesBufferLength;
 
     for (i = 0; i < NUM_OF_CONVERTERS; i++) {
-        matchFound = TRUE;
+        matchFound = true;
         for (n = 0; escSeqCompoundText[i][n] != 0; n++) {
             if (n < toUBytesBufferLength) {
                 if (toUBytesBuffer[n] != escSeqCompoundText[i][n]) {
-                    matchFound = FALSE;
+                    matchFound = false;
                     break;
                 }
             } else if ((source + (n - offset)) >= sourceLimit) {
                 *err = U_TRUNCATED_CHAR_FOUND;
-                matchFound = FALSE;
+                matchFound = false;
                 break;
             } else if (*(source + (n - offset)) != escSeqCompoundText[i][n]) {
-                matchFound = FALSE;
+                matchFound = false;
                 break;
             }
         }
@@ -634,8 +634,8 @@ static const UConverterStaticData _CompoundTextStaticData = {
     6,
     { 0xef, 0, 0, 0 },
     1,
-    FALSE,
-    FALSE,
+    false,
+    false,
     0,
     0,
     { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } /* reserved */
diff --git a/deps/icu-small/source/common/ucnv_ext.cpp b/deps/icu-small/source/common/ucnv_ext.cpp
index 7dea4eef41..ffc3c93033 100644
--- a/deps/icu-small/source/common/ucnv_ext.cpp
+++ b/deps/icu-small/source/common/ucnv_ext.cpp
@@ -108,7 +108,7 @@ ucnv_extFindToU(const uint32_t *toUSection, int32_t length, uint8_t byte) {
 }
 
 /*
- * TRUE if not an SI/SO stateful converter,
+ * true if not an SI/SO stateful converter,
  * or if the match length fits with the current converter state
  */
 #define UCNV_EXT_TO_U_VERIFY_SISO_MATCH(sisoState, match) \
@@ -154,7 +154,7 @@ ucnv_extMatchToU(const int32_t *cx, int8_t sisoState,
                 srcLength=1;
             }
         }
-        flush=TRUE;
+        flush=true;
     }
 
     /* we must not remember fallback matches when not using fallbacks */
@@ -302,7 +302,7 @@ ucnv_extInitialMatchToU(UConverter *cnv, const int32_t *cx,
                          target, targetLimit,
                          offsets, srcIndex,
                          pErrorCode);
-        return TRUE;
+        return true;
     } else if(match<0) {
         /* save state for partial match */
         const char *s;
@@ -323,9 +323,9 @@ ucnv_extInitialMatchToU(UConverter *cnv, const int32_t *cx,
         }
         *src=s; /* same as *src=srcLimit; because we reached the end of input */
         cnv->preToULength=(int8_t)match;
-        return TRUE;
+        return true;
     } else /* match==0 no match */ {
-        return FALSE;
+        return false;
     }
 }
 
@@ -345,7 +345,7 @@ ucnv_extSimpleMatchToU(const int32_t *cx,
                            source, length,
                            NULL, 0,
                            &value,
-                           useFallback, TRUE);
+                           useFallback, true);
     if(match==length) {
         /* write result for simple, single-character conversion */
         if(UCNV_EXT_TO_U_IS_CODE_POINT(value)) {
@@ -358,7 +358,7 @@ ucnv_extSimpleMatchToU(const int32_t *cx,
      * - match>0 && value points to string: simple conversion cannot handle multiple code points
      * - match>0 && match!=length: not all input consumed, forbidden for this function
      * - match==0: no match found in the first place
-     * - match<0: partial match, not supported for simple conversion (and flush==TRUE)
+     * - match<0: partial match, not supported for simple conversion (and flush==true)
      */
     return 0xfffe;
 }
@@ -516,13 +516,13 @@ ucnv_extFindFromU(const UChar *fromUSection, int32_t length, UChar u) {
  * @param srcLength length of src, >=0
  * @param pMatchValue [out] output result value for the match from the data structure
  * @param useFallback "use fallback" flag, usually from cnv->useFallback
- * @param flush TRUE if the end of the input stream is reached
+ * @param flush true if the end of the input stream is reached
  * @return >1: matched, return value=total match length (number of input units matched)
  *          1: matched, no mapping but request for <subchar1>
  *             (only for the first code point)
  *          0: no match
  *         <0: partial match, return value=negative total match length
- *             (partial matches are never returned for flush==TRUE)
+ *             (partial matches are never returned for flush==true)
  *             (partial matches are never returned as being longer than UCNV_EXT_MAX_UCHARS)
  *         the matchLength is 2 if only firstCP matched, and >2 if firstCP and
  *         further code units matched
@@ -778,7 +778,7 @@ ucnv_extInitialMatchFromU(UConverter *cnv, const int32_t *cx,
                            target, targetLimit,
                            offsets, srcIndex,
                            pErrorCode);
-        return TRUE;
+        return true;
     } else if(match<0) {
         /* save state for partial match */
         const UChar *s;
@@ -795,13 +795,13 @@ ucnv_extInitialMatchFromU(UConverter *cnv, const int32_t *cx,
         }
         *src=s; /* same as *src=srcLimit; because we reached the end of input */
         cnv->preFromULength=(int8_t)match;
-        return TRUE;
+        return true;
     } else if(match==1) {
         /* matched, no mapping but request for <subchar1> */
-        cnv->useSubChar1=TRUE;
-        return FALSE;
+        cnv->useSubChar1=true;
+        return false;
     } else /* match==0 no match */ {
-        return FALSE;
+        return false;
     }
 }
 
@@ -822,7 +822,7 @@ ucnv_extSimpleMatchFromU(const int32_t *cx,
                              NULL, 0,
                              NULL, 0,
                              &value,
-                             useFallback, TRUE);
+                             useFallback, true);
     if(match>=2) {
         /* write result for simple, single-character conversion */
         int32_t length;
@@ -854,7 +854,7 @@ ucnv_extSimpleMatchFromU(const int32_t *cx,
      * - match>1 && resultLength>4: result too long for simple conversion
      * - match==1: no match found, <subchar1> preferred
      * - match==0: no match found in the first place
-     * - match<0: partial match, not supported for simple conversion (and flush==TRUE)
+     * - match<0: partial match, not supported for simple conversion (and flush==true)
      */
     return 0;
 }
@@ -934,7 +934,7 @@ ucnv_extContinueMatchFromU(UConverter *cnv,
 
         if(match==1) {
             /* matched, no mapping but request for <subchar1> */
-            cnv->useSubChar1=TRUE;
+            cnv->useSubChar1=true;
         }
 
         /* move the first code point to the error field */
@@ -961,12 +961,12 @@ extSetUseMapping(UConverterUnicodeSet which, int32_t minLength, uint32_t value)
         // Do not add entries with reserved bits set.
         if(((value&(UCNV_EXT_FROM_U_ROUNDTRIP_FLAG|UCNV_EXT_FROM_U_RESERVED_MASK))!=
                 UCNV_EXT_FROM_U_ROUNDTRIP_FLAG)) {
-            return FALSE;
+            return false;
         }
     } else /* UCNV_ROUNDTRIP_AND_FALLBACK_SET */ {
         // Do not add entries with reserved bits set.
         if((value&UCNV_EXT_FROM_U_RESERVED_MASK)!=0) {
-            return FALSE;
+            return false;
         }
     }
     // Do not add <subchar1> entries or other (future?) pseudo-entries
diff --git a/deps/icu-small/source/common/ucnv_io.cpp b/deps/icu-small/source/common/ucnv_io.cpp
index 7a95a3f1e6..c9d20cb941 100644
--- a/deps/icu-small/source/common/ucnv_io.cpp
+++ b/deps/icu-small/source/common/ucnv_io.cpp
@@ -175,7 +175,7 @@ static const char DATA_NAME[] = "cnvalias";
 static const char DATA_TYPE[] = "icu";
 
 static UDataMemory *gAliasData=NULL;
-static icu::UInitOnce gAliasDataInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gAliasDataInitOnce {};
 
 enum {
     tocLengthIndex=0,
@@ -226,7 +226,7 @@ static UBool U_CALLCONV ucnv_io_cleanup(void)
 
     uprv_memset(&gMainTable, 0, sizeof(gMainTable));
 
-    return TRUE;                   /* Everything was cleaned up */
+    return true;                   /* Everything was cleaned up */
 }
 
 static void U_CALLCONV initAliasData(UErrorCode &errCode) {
@@ -319,7 +319,7 @@ static inline UBool
 isAlias(const char *alias, UErrorCode *pErrorCode) {
     if(alias==NULL) {
         *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
-        return FALSE;
+        return false;
     }
     return (UBool)(*alias!=0);
 }
@@ -388,13 +388,13 @@ ucnv_io_stripASCIIForCompare(char *dst, const char *name) {
     char *dstItr = dst;
     uint8_t type, nextType;
     char c1;
-    UBool afterDigit = FALSE;
+    UBool afterDigit = false;
 
     while ((c1 = *name++) != 0) {
         type = GET_ASCII_TYPE(c1);
         switch (type) {
         case UIGNORE:
-            afterDigit = FALSE;
+            afterDigit = false;
             continue; /* ignore all but letters and digits */
         case ZERO:
             if (!afterDigit) {
@@ -405,11 +405,11 @@ ucnv_io_stripASCIIForCompare(char *dst, const char *name) {
             }
             break;
         case NONZERO:
-            afterDigit = TRUE;
+            afterDigit = true;
             break;
         default:
             c1 = (char)type; /* lowercased letter */
-            afterDigit = FALSE;
+            afterDigit = false;
             break;
         }
         *dstItr++ = c1;
@@ -423,13 +423,13 @@ ucnv_io_stripEBCDICForCompare(char *dst, const char *name) {
     char *dstItr = dst;
     uint8_t type, nextType;
     char c1;
-    UBool afterDigit = FALSE;
+    UBool afterDigit = false;
 
     while ((c1 = *name++) != 0) {
         type = GET_EBCDIC_TYPE(c1);
         switch (type) {
         case UIGNORE:
-            afterDigit = FALSE;
+            afterDigit = false;
             continue; /* ignore all but letters and digits */
         case ZERO:
             if (!afterDigit) {
@@ -440,11 +440,11 @@ ucnv_io_stripEBCDICForCompare(char *dst, const char *name) {
             }
             break;
         case NONZERO:
-            afterDigit = TRUE;
+            afterDigit = true;
             break;
         default:
             c1 = (char)type; /* lowercased letter */
-            afterDigit = FALSE;
+            afterDigit = false;
             break;
         }
         *dstItr++ = c1;
@@ -479,14 +479,14 @@ ucnv_compareNames(const char *name1, const char *name2) {
     int rc;
     uint8_t type, nextType;
     char c1, c2;
-    UBool afterDigit1 = FALSE, afterDigit2 = FALSE;
+    UBool afterDigit1 = false, afterDigit2 = false;
 
     for (;;) {
         while ((c1 = *name1++) != 0) {
             type = GET_CHAR_TYPE(c1);
             switch (type) {
             case UIGNORE:
-                afterDigit1 = FALSE;
+                afterDigit1 = false;
                 continue; /* ignore all but letters and digits */
             case ZERO:
                 if (!afterDigit1) {
@@ -497,11 +497,11 @@ ucnv_compareNames(const char *name1, const char *name2) {
                 }
                 break;
             case NONZERO:
-                afterDigit1 = TRUE;
+                afterDigit1 = true;
                 break;
             default:
                 c1 = (char)type; /* lowercased letter */
-                afterDigit1 = FALSE;
+                afterDigit1 = false;
                 break;
             }
             break; /* deliver c1 */
@@ -510,7 +510,7 @@ ucnv_compareNames(const char *name1, const char *name2) {
             type = GET_CHAR_TYPE(c2);
             switch (type) {
             case UIGNORE:
-                afterDigit2 = FALSE;
+                afterDigit2 = false;
                 continue; /* ignore all but letters and digits */
             case ZERO:
                 if (!afterDigit2) {
@@ -521,11 +521,11 @@ ucnv_compareNames(const char *name1, const char *name2) {
                 }
                 break;
             case NONZERO:
-                afterDigit2 = TRUE;
+                afterDigit2 = true;
                 break;
             default:
                 c2 = (char)type; /* lowercased letter */
-                afterDigit2 = FALSE;
+                afterDigit2 = false;
                 break;
             }
             break; /* deliver c2 */
@@ -628,11 +628,11 @@ isAliasInList(const char *alias, uint32_t listOffset) {
             if (currList[currAlias]
                 && ucnv_compareNames(alias, GET_STRING(currList[currAlias]))==0)
             {
-                return TRUE;
+                return true;
             }
         }
     }
-    return FALSE;
+    return false;
 }
 
 /*
@@ -1288,7 +1288,7 @@ ucnv_swapAliases(const UDataSwapper *ds,
 
             uprv_sortArray(tempTable.rows, (int32_t)count, sizeof(TempRow),
                            io_compareRows, &tempTable,
-                           FALSE, pErrorCode);
+                           false, pErrorCode);
 
             if(U_SUCCESS(*pErrorCode)) {
                 /* copy/swap/permutate items */
diff --git a/deps/icu-small/source/common/ucnv_lmb.cpp b/deps/icu-small/source/common/ucnv_lmb.cpp
index 6969727927..78b8e40700 100644
--- a/deps/icu-small/source/common/ucnv_lmb.cpp
+++ b/deps/icu-small/source/common/ucnv_lmb.cpp
@@ -610,7 +610,7 @@ static const UConverterStaticData _LMBCSStaticData##n={\
   sizeof(UConverterStaticData),\
  "LMBCS-"  #n,\
     0, UCNV_IBM, UCNV_LMBCS_##n, 1, 3,\
-    { 0x3f, 0, 0, 0 },1,FALSE,FALSE,0,0,{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} \
+    { 0x3f, 0, 0, 0 },1,false,false,0,0,{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} \
 };\
 const UConverterSharedData _LMBCSData##n= \
         UCNV_IMMUTABLE_SHARED_DATA_INITIALIZER(&_LMBCSStaticData##n, &_LMBCSImpl##n);
@@ -721,7 +721,7 @@ _LMBCSSafeClone(const UConverter *cnv,
     }
 
     newLMBCS->cnv.extraInfo = &newLMBCS->lmbcs;
-    newLMBCS->cnv.isExtraLocal = TRUE;
+    newLMBCS->cnv.isExtraLocal = true;
     return &newLMBCS->cnv;
 }
 
@@ -763,14 +763,14 @@ LMBCSConversionWorker (
    U_ASSERT(xcnv);
    U_ASSERT(group<ULMBCS_GRP_UNICODE);
 
-   bytesConverted = ucnv_MBCSFromUChar32(xcnv, *pUniChar, &value, FALSE);
+   bytesConverted = ucnv_MBCSFromUChar32(xcnv, *pUniChar, &value, false);
 
    /* get the first result byte */
    if(bytesConverted > 0) {
       firstByte = (ulmbcs_byte_t)(value >> ((bytesConverted - 1) * 8));
    } else {
       /* most common failure mode is an unassigned character */
-      groups_tried[group] = TRUE;
+      groups_tried[group] = true;
       return 0;
    }
 
@@ -1191,11 +1191,11 @@ _LMBCSGetNextUCharWorker(UConverterToUnicodeArgs*   args,
                 if (*args->source == group) {
                     /* single byte */
                     ++args->source;
-                    uniChar = ucnv_MBCSSimpleGetNextUChar(cnv, args->source, 1, FALSE);
+                    uniChar = ucnv_MBCSSimpleGetNextUChar(cnv, args->source, 1, false);
                     ++args->source;
                 } else {
                     /* double byte */
-                    uniChar = ucnv_MBCSSimpleGetNextUChar(cnv, args->source, 2, FALSE);
+                    uniChar = ucnv_MBCSSimpleGetNextUChar(cnv, args->source, 2, false);
                     args->source += 2;
                 }
             }
@@ -1220,7 +1220,7 @@ _LMBCSGetNextUCharWorker(UConverterToUnicodeArgs*   args,
                     /* Lookup value must include opt group */
                     bytes[0] = group;
                     bytes[1] = CurByte;
-                    uniChar = ucnv_MBCSSimpleGetNextUChar(cnv, bytes, 2, FALSE);
+                    uniChar = ucnv_MBCSSimpleGetNextUChar(cnv, bytes, 2, false);
                 }
             }
         }
@@ -1236,13 +1236,13 @@ _LMBCSGetNextUCharWorker(UConverterToUnicodeArgs*   args,
                     CHECK_SOURCE_LIMIT(0);
 
                     /* let the MBCS conversion consume CurByte again */
-                    uniChar = ucnv_MBCSSimpleGetNextUChar(cnv, args->source - 1, 1, FALSE);
+                    uniChar = ucnv_MBCSSimpleGetNextUChar(cnv, args->source - 1, 1, false);
                 }
                 else
                 {
                     CHECK_SOURCE_LIMIT(1);
                     /* let the MBCS conversion consume CurByte again */
-                    uniChar = ucnv_MBCSSimpleGetNextUChar(cnv, args->source - 1, 2, FALSE);
+                    uniChar = ucnv_MBCSSimpleGetNextUChar(cnv, args->source - 1, 2, false);
                     ++args->source;
                 }
             }
diff --git a/deps/icu-small/source/common/ucnv_u16.cpp b/deps/icu-small/source/common/ucnv_u16.cpp
index a5e8367400..bebdede4c4 100644
--- a/deps/icu-small/source/common/ucnv_u16.cpp
+++ b/deps/icu-small/source/common/ucnv_u16.cpp
@@ -637,7 +637,7 @@ static const UConverterStaticData _UTF16BEStaticData={
     sizeof(UConverterStaticData),
     "UTF-16BE",
     1200, UCNV_IBM, UCNV_UTF16_BigEndian, 2, 2,
-    { 0xff, 0xfd, 0, 0 },2,FALSE,FALSE,
+    { 0xff, 0xfd, 0, 0 },2,false,false,
     0,
     0,
     { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } /* reserved */
@@ -1239,7 +1239,7 @@ static const UConverterStaticData _UTF16LEStaticData={
     sizeof(UConverterStaticData),
     "UTF-16LE",
     1202, UCNV_IBM, UCNV_UTF16_LittleEndian, 2, 2,
-    { 0xfd, 0xff, 0, 0 },2,FALSE,FALSE,
+    { 0xfd, 0xff, 0, 0 },2,false,false,
     0,
     0,
     { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } /* reserved */
@@ -1526,7 +1526,7 @@ static const UConverterStaticData _UTF16StaticData = {
 #else
     { 0xfd, 0xff, 0, 0 }, 2,
 #endif
-    FALSE, FALSE,
+    false, false,
     0,
     0,
     { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } /* reserved */
@@ -1567,7 +1567,7 @@ static const UConverterStaticData _UTF16v2StaticData = {
     1204, /* CCSID for BOM sensitive UTF-16 */
     UCNV_IBM, UCNV_UTF16, 2, 2,
     { 0xff, 0xfd, 0, 0 }, 2,
-    FALSE, FALSE,
+    false, false,
     0,
     0,
     { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } /* reserved */
diff --git a/deps/icu-small/source/common/ucnv_u32.cpp b/deps/icu-small/source/common/ucnv_u32.cpp
index bf6bd11dba..bc160b71dd 100644
--- a/deps/icu-small/source/common/ucnv_u32.cpp
+++ b/deps/icu-small/source/common/ucnv_u32.cpp
@@ -494,7 +494,7 @@ static const UConverterStaticData _UTF32BEStaticData = {
     "UTF-32BE",
     1232,
     UCNV_IBM, UCNV_UTF32_BigEndian, 4, 4,
-    { 0, 0, 0xff, 0xfd }, 4, FALSE, FALSE,
+    { 0, 0, 0xff, 0xfd }, 4, false, false,
     0,
     0,
     { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } /* reserved */
@@ -989,7 +989,7 @@ static const UConverterStaticData _UTF32LEStaticData = {
     "UTF-32LE",
     1234,
     UCNV_IBM, UCNV_UTF32_LittleEndian, 4, 4,
-    { 0xfd, 0xff, 0, 0 }, 4, FALSE, FALSE,
+    { 0xfd, 0xff, 0, 0 }, 4, false, false,
     0,
     0,
     { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } /* reserved */
@@ -1110,7 +1110,7 @@ _UTF32ToUnicodeWithOffsets(UConverterToUnicodeArgs *pArgs,
                     /* some of the bytes are from a previous buffer, replay those first */
                     pArgs->source=utf32BOM+(state&4); /* select the correct BOM */
                     pArgs->sourceLimit=pArgs->source+((state&3)-count); /* replay previous bytes */
-                    pArgs->flush=FALSE; /* this sourceLimit is not the real source stream limit */
+                    pArgs->flush=false; /* this sourceLimit is not the real source stream limit */
 
                     /* no offsets: bytes from previous buffer, and not enough for output */
                     T_UConverter_toUnicode_UTF32_BE(pArgs, pErrorCode);
@@ -1241,7 +1241,7 @@ static const UConverterStaticData _UTF32StaticData = {
 #else
     { 0xfd, 0xff, 0, 0 }, 4,
 #endif
-    FALSE, FALSE,
+    false, false,
     0,
     0,
     { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } /* reserved */
diff --git a/deps/icu-small/source/common/ucnv_u7.cpp b/deps/icu-small/source/common/ucnv_u7.cpp
index de9f3f42ec..8964ca01de 100644
--- a/deps/icu-small/source/common/ucnv_u7.cpp
+++ b/deps/icu-small/source/common/ucnv_u7.cpp
@@ -184,12 +184,12 @@ static void U_CALLCONV
 _UTF7Reset(UConverter *cnv, UConverterResetChoice choice) {
     if(choice<=UCNV_RESET_TO_UNICODE) {
         /* reset toUnicode */
-        cnv->toUnicodeStatus=0x1000000; /* inDirectMode=TRUE */
+        cnv->toUnicodeStatus=0x1000000; /* inDirectMode=true */
         cnv->toULength=0;
     }
     if(choice!=UCNV_RESET_TO_UNICODE) {
         /* reset fromUnicode */
-        cnv->fromUnicodeStatus=(cnv->fromUnicodeStatus&0xf0000000)|0x1000000; /* keep version, inDirectMode=TRUE */
+        cnv->fromUnicodeStatus=(cnv->fromUnicodeStatus&0xf0000000)|0x1000000; /* keep version, inDirectMode=true */
     }
 }
 
@@ -286,7 +286,7 @@ directMode:
             } else /* PLUS */ {
                 /* switch to Unicode mode */
                 nextSourceIndex=++sourceIndex;
-                inDirectMode=FALSE;
+                inDirectMode=false;
                 byteIndex=0;
                 bits=0;
                 base64Counter=-1;
@@ -329,7 +329,7 @@ unicodeMode:
                      *        It may be for example, a plus which we need to deal with in direct mode.
                      * 2.2.2. Else if the current char is illegal, we might as well deal with it here.
                      */
-                    inDirectMode=TRUE;
+                    inDirectMode=true;
                     if(base64Counter==-1) {
                         /* illegal: + immediately followed by something other than base64 or minus sign */
                         /* include the plus sign in the reported sequence, but not the subsequent char */
@@ -411,7 +411,7 @@ unicodeMode:
                     }
                 } else /*base64Value==-2*/ {
                     /* minus sign terminates the base64 sequence */
-                    inDirectMode=TRUE;
+                    inDirectMode=true;
                     if(base64Counter==-1) {
                         /* +- i.e. a minus immediately following a plus */
                         *target++=PLUS;
@@ -541,7 +541,7 @@ directMode:
                 if(offsets!=NULL) {
                     *offsets++=sourceIndex;
                 }
-                inDirectMode=FALSE;
+                inDirectMode=false;
                 base64Counter=0;
                 goto unicodeMode;
             }
@@ -558,7 +558,7 @@ unicodeMode:
                 c=*source++;
                 if(c<=127 && encodeDirectly[c]) {
                     /* encode directly */
-                    inDirectMode=TRUE;
+                    inDirectMode=true;
 
                     /* trick: back out this character to make this easier */
                     --source;
@@ -719,7 +719,7 @@ unicodeMode:
             }
         }
         /* reset the state for the next conversion */
-        cnv->fromUnicodeStatus=(cnv->fromUnicodeStatus&0xf0000000)|0x1000000; /* keep version, inDirectMode=TRUE */
+        cnv->fromUnicodeStatus=(cnv->fromUnicodeStatus&0xf0000000)|0x1000000; /* keep version, inDirectMode=true */
     } else {
         /* set the converter state back into UConverter */
         cnv->fromUnicodeStatus=
@@ -778,7 +778,7 @@ static const UConverterStaticData _UTF7StaticData={
     UCNV_IBM, UCNV_UTF7,
     1, 4,
     { 0x3f, 0, 0, 0 }, 1, /* the subchar is not used */
-    FALSE, FALSE,
+    false, false,
     0,
     0,
     { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } /* reserved */
@@ -971,7 +971,7 @@ directMode:
             } else /* AMPERSAND */ {
                 /* switch to Unicode mode */
                 nextSourceIndex=++sourceIndex;
-                inDirectMode=FALSE;
+                inDirectMode=false;
                 byteIndex=0;
                 bits=0;
                 base64Counter=-1;
@@ -1002,7 +1002,7 @@ unicodeMode:
                 ++nextSourceIndex;
                 if(b>0x7e) {
                     /* illegal - test other illegal US-ASCII values by base64Value==-3 */
-                    inDirectMode=TRUE;
+                    inDirectMode=true;
                     *pErrorCode=U_ILLEGAL_CHAR_FOUND;
                     break;
                 } else if((base64Value=FROM_BASE64_IMAP(b))>=0) {
@@ -1024,7 +1024,7 @@ unicodeMode:
                         c=(UChar)((bits<<4)|(base64Value>>2));
                         if(isLegalIMAP(c)) {
                             /* illegal */
-                            inDirectMode=TRUE;
+                            inDirectMode=true;
                             *pErrorCode=U_ILLEGAL_CHAR_FOUND;
                             goto endloop;
                         }
@@ -1042,7 +1042,7 @@ unicodeMode:
                         c=(UChar)((bits<<2)|(base64Value>>4));
                         if(isLegalIMAP(c)) {
                             /* illegal */
-                            inDirectMode=TRUE;
+                            inDirectMode=true;
                             *pErrorCode=U_ILLEGAL_CHAR_FOUND;
                             goto endloop;
                         }
@@ -1060,7 +1060,7 @@ unicodeMode:
                         c=(UChar)((bits<<6)|base64Value);
                         if(isLegalIMAP(c)) {
                             /* illegal */
-                            inDirectMode=TRUE;
+                            inDirectMode=true;
                             *pErrorCode=U_ILLEGAL_CHAR_FOUND;
                             goto endloop;
                         }
@@ -1079,7 +1079,7 @@ unicodeMode:
                     }
                 } else if(base64Value==-2) {
                     /* minus sign terminates the base64 sequence */
-                    inDirectMode=TRUE;
+                    inDirectMode=true;
                     if(base64Counter==-1) {
                         /* &- i.e. a minus immediately following an ampersand */
                         *target++=AMPERSAND;
@@ -1109,7 +1109,7 @@ unicodeMode:
                     /* base64Value==-1 for characters that are illegal only in Unicode mode */
                     /* base64Value==-3 for illegal characters */
                     /* illegal */
-                    inDirectMode=TRUE;
+                    inDirectMode=true;
                     *pErrorCode=U_ILLEGAL_CHAR_FOUND;
                     break;
                 }
@@ -1144,7 +1144,7 @@ endloop:
         }
         /* else if(base64Counter!=-1) byteIndex remains 0 because there is no particular byte sequence */
 
-        inDirectMode=TRUE; /* avoid looping */
+        inDirectMode=true; /* avoid looping */
         *pErrorCode=U_TRUNCATED_CHAR_FOUND;
     }
 
@@ -1240,7 +1240,7 @@ directMode:
                 if(offsets!=NULL) {
                     *offsets++=sourceIndex;
                 }
-                inDirectMode=FALSE;
+                inDirectMode=false;
                 base64Counter=0;
                 goto unicodeMode;
             }
@@ -1257,7 +1257,7 @@ unicodeMode:
                 c=*source++;
                 if(isLegalIMAP(c)) {
                     /* encode directly */
-                    inDirectMode=TRUE;
+                    inDirectMode=true;
 
                     /* trick: back out this character to make this easier */
                     --source;
@@ -1431,7 +1431,7 @@ unicodeMode:
             }
         }
         /* reset the state for the next conversion */
-        cnv->fromUnicodeStatus=(cnv->fromUnicodeStatus&0xf0000000)|0x1000000; /* keep version, inDirectMode=TRUE */
+        cnv->fromUnicodeStatus=(cnv->fromUnicodeStatus&0xf0000000)|0x1000000; /* keep version, inDirectMode=true */
     } else {
         /* set the converter state back into UConverter */
         cnv->fromUnicodeStatus=
@@ -1479,7 +1479,7 @@ static const UConverterStaticData _IMAPStaticData={
     UCNV_IBM, UCNV_IMAP_MAILBOX,
     1, 4,
     { 0x3f, 0, 0, 0 }, 1, /* the subchar is not used */
-    FALSE, FALSE,
+    false, false,
     0,
     0,
     { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } /* reserved */
diff --git a/deps/icu-small/source/common/ucnv_u8.cpp b/deps/icu-small/source/common/ucnv_u8.cpp
index 1ef7fa2f02..3c27f2e46e 100644
--- a/deps/icu-small/source/common/ucnv_u8.cpp
+++ b/deps/icu-small/source/common/ucnv_u8.cpp
@@ -56,7 +56,7 @@ static const uint32_t offsetsFromUTF8[5] = {0,
 static UBool hasCESU8Data(const UConverter *cnv)
 {
 #if UCONFIG_ONLY_HTML_CONVERSION
-    return FALSE;
+    return false;
 #else
     return (UBool)(cnv->sharedData == &_CESU8Data);
 #endif
@@ -888,7 +888,7 @@ static const UConverterStaticData _UTF8StaticData={
     "UTF-8",
     1208, UCNV_IBM, UCNV_UTF8,
     1, 3, /* max 3 bytes per UChar from UTF-8 (4 bytes from surrogate _pair_) */
-    { 0xef, 0xbf, 0xbd, 0 },3,FALSE,FALSE,
+    { 0xef, 0xbf, 0xbd, 0 },3,false,false,
     0,
     0,
     { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } /* reserved */
@@ -931,7 +931,7 @@ static const UConverterStaticData _CESU8StaticData={
     "CESU-8",
     9400, /* CCSID for CESU-8 */
     UCNV_UNKNOWN, UCNV_CESU8, 1, 3,
-    { 0xef, 0xbf, 0xbd, 0 },3,FALSE,FALSE,
+    { 0xef, 0xbf, 0xbd, 0 },3,false,false,
     0,
     0,
     { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } /* reserved */
diff --git a/deps/icu-small/source/common/ucnvbocu.cpp b/deps/icu-small/source/common/ucnvbocu.cpp
index 7c2aab5655..edb49d36a9 100644
--- a/deps/icu-small/source/common/ucnvbocu.cpp
+++ b/deps/icu-small/source/common/ucnvbocu.cpp
@@ -195,7 +195,7 @@ bocu1TrailToByte[BOCU1_TRAIL_CONTROLS_COUNT]={
  * what we need here.
  * This macro adjust the results so that the modulo-value m is always >=0.
  *
- * For positive n, the if() condition is always FALSE.
+ * For positive n, the if() condition is always false.
  *
  * @param n Number to be split into quotient and rest.
  *          Will be modified to contain the quotient.
@@ -1401,7 +1401,7 @@ static const UConverterStaticData _Bocu1StaticData={
     UCNV_IBM, UCNV_BOCU1,
     1, 4, /* one UChar generates at least 1 byte and at most 4 bytes */
     { 0x1a, 0, 0, 0 }, 1, /* BOCU-1 never needs to write a subchar */
-    FALSE, FALSE,
+    false, false,
     0,
     0,
     { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } /* reserved */
diff --git a/deps/icu-small/source/common/ucnvhz.cpp b/deps/icu-small/source/common/ucnvhz.cpp
index 6b2f5faaf0..e0d2f0775d 100644
--- a/deps/icu-small/source/common/ucnvhz.cpp
+++ b/deps/icu-small/source/common/ucnvhz.cpp
@@ -111,18 +111,18 @@ _HZReset(UConverter *cnv, UConverterResetChoice choice){
         cnv->toUnicodeStatus = 0;
         cnv->mode=0;
         if(cnv->extraInfo != NULL){
-            ((UConverterDataHZ*)cnv->extraInfo)->isStateDBCS = FALSE;
-            ((UConverterDataHZ*)cnv->extraInfo)->isEmptySegment = FALSE;
+            ((UConverterDataHZ*)cnv->extraInfo)->isStateDBCS = false;
+            ((UConverterDataHZ*)cnv->extraInfo)->isEmptySegment = false;
         }
     }
     if(choice!=UCNV_RESET_TO_UNICODE) {
         cnv->fromUnicodeStatus= 0;
         cnv->fromUChar32=0x0000; 
         if(cnv->extraInfo != NULL){
-            ((UConverterDataHZ*)cnv->extraInfo)->isEscapeAppended = FALSE;
+            ((UConverterDataHZ*)cnv->extraInfo)->isEscapeAppended = false;
             ((UConverterDataHZ*)cnv->extraInfo)->targetIndex = 0;
             ((UConverterDataHZ*)cnv->extraInfo)->sourceIndex = 0;
-            ((UConverterDataHZ*)cnv->extraInfo)->isTargetUCharDBCS = FALSE;
+            ((UConverterDataHZ*)cnv->extraInfo)->isTargetUCharDBCS = false;
         }
     }
 }
@@ -189,13 +189,13 @@ UConverter_toUnicode_HZ_OFFSETS_LOGIC(UConverterToUnicodeArgs *args,
                         args->offsets[myTarget - args->target]=(int32_t)(mySource - args->source - 2);
                     }
                     *(myTarget++)=(UChar)mySourceChar;
-                    myData->isEmptySegment = FALSE;
+                    myData->isEmptySegment = false;
                     continue;
                 case UCNV_OPEN_BRACE:
                 case UCNV_CLOSE_BRACE:
                     myData->isStateDBCS = (mySourceChar == UCNV_OPEN_BRACE);
                     if (myData->isEmptySegment) {
-                        myData->isEmptySegment = FALSE; /* we are handling it, reset to avoid future spurious errors */
+                        myData->isEmptySegment = false; /* we are handling it, reset to avoid future spurious errors */
                         *err = U_ILLEGAL_ESCAPE_SEQUENCE;
                         args->converter->toUCallbackReason = UCNV_IRREGULAR;
                         args->converter->toUBytes[0] = UCNV_TILDE;
@@ -205,7 +205,7 @@ UConverter_toUnicode_HZ_OFFSETS_LOGIC(UConverterToUnicodeArgs *args,
                         args->source = mySource;
                         return;
                     }
-                    myData->isEmptySegment = TRUE;
+                    myData->isEmptySegment = true;
                     continue;
                 default:
                      /* if the first byte is equal to TILDE and the trail byte
@@ -217,7 +217,7 @@ UConverter_toUnicode_HZ_OFFSETS_LOGIC(UConverterToUnicodeArgs *args,
                      * - If any of the non-initial bytes could be the start of a character,
                      *   we stop the illegal sequence before the first one of those.
                      */
-                    myData->isEmptySegment = FALSE; /* different error here, reset this to avoid spurious future error */
+                    myData->isEmptySegment = false; /* different error here, reset this to avoid spurious future error */
                     *err = U_ILLEGAL_ESCAPE_SEQUENCE;
                     args->converter->toUBytes[0] = UCNV_TILDE;
                     if( myData->isStateDBCS ?
@@ -244,7 +244,7 @@ UConverter_toUnicode_HZ_OFFSETS_LOGIC(UConverterToUnicodeArgs *args,
                     } else {
                         /* add another bit to distinguish a 0 byte from not having seen a lead byte */
                         args->converter->toUnicodeStatus = (uint32_t) (mySourceChar | 0x100);
-                        myData->isEmptySegment = FALSE; /* the segment has something, either valid or will produce a different error, so reset this */
+                        myData->isEmptySegment = false; /* the segment has something, either valid or will produce a different error, so reset this */
                     }
                     continue;
                 }
@@ -289,10 +289,10 @@ UConverter_toUnicode_HZ_OFFSETS_LOGIC(UConverterToUnicodeArgs *args,
                     continue;
                 } else if(mySourceChar <= 0x7f) {
                     targetUniChar = (UChar)mySourceChar;  /* ASCII */
-                    myData->isEmptySegment = FALSE; /* the segment has something valid */
+                    myData->isEmptySegment = false; /* the segment has something valid */
                 } else {
                     targetUniChar = 0xffff;
-                    myData->isEmptySegment = FALSE; /* different error here, reset this to avoid spurious future error */
+                    myData->isEmptySegment = false; /* different error here, reset this to avoid spurious future error */
                 }
             }
             if(targetUniChar < 0xfffe){
@@ -396,13 +396,13 @@ UConverter_fromUnicode_HZ_OFFSETS_LOGIC (UConverterFromUnicodeArgs * args,
                         len =ESC_LEN;
                         escSeq = SB_ESCAPE;
                         CONCAT_ESCAPE_MACRO(args, myTargetIndex, targetLength, escSeq,err,len,mySourceIndex);
-                        myConverterData->isEscapeAppended = TRUE;
+                        myConverterData->isEscapeAppended = true;
                     }
                     else{ /* Shifting from a single byte to double byte mode*/
                         len =ESC_LEN;
                         escSeq = DB_ESCAPE;
                         CONCAT_ESCAPE_MACRO(args, myTargetIndex, targetLength, escSeq,err,len,mySourceIndex);
-                        myConverterData->isEscapeAppended = TRUE;
+                        myConverterData->isEscapeAppended = true;
                         
                     }
                 }
@@ -507,7 +507,7 @@ _HZ_WriteSub(UConverterFromUnicodeArgs *args, int32_t offsetIndex, UErrorCode *e
     if( convData->isTargetUCharDBCS){
         *p++= UCNV_TILDE;
         *p++= UCNV_CLOSE_BRACE;
-        convData->isTargetUCharDBCS=FALSE;
+        convData->isTargetUCharDBCS=false;
     }
     *p++= (char)cnv->subChars[0];
 
@@ -550,7 +550,7 @@ _HZ_SafeClone(const UConverter *cnv,
 
     uprv_memcpy(&localClone->mydata, cnv->extraInfo, sizeof(UConverterDataHZ));
     localClone->cnv.extraInfo = &localClone->mydata;
-    localClone->cnv.isExtraLocal = TRUE;
+    localClone->cnv.isExtraLocal = true;
 
     /* deep-clone the sub-converter */
     size = (int32_t)sizeof(UConverter);
@@ -611,8 +611,8 @@ static const UConverterStaticData _HZStaticData={
          4,
         { 0x1a, 0, 0, 0 },
         1,
-        FALSE, 
-        FALSE,
+        false, 
+        false,
         0,
         0,
         { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, /* reserved */
diff --git a/deps/icu-small/source/common/ucnvisci.cpp b/deps/icu-small/source/common/ucnvisci.cpp
index f303e7e24f..4d747e1ff8 100644
--- a/deps/icu-small/source/common/ucnvisci.cpp
+++ b/deps/icu-small/source/common/ucnvisci.cpp
@@ -172,7 +172,7 @@ static const uint8_t pnjMap[80] = {
 static UBool
 isPNJConsonant(UChar32 c) {
     if (c < 0xa00 || 0xa50 <= c) {
-        return FALSE;
+        return false;
     } else {
         return (UBool)(pnjMap[c - 0xa00] & 1);
     }
@@ -181,7 +181,7 @@ isPNJConsonant(UChar32 c) {
 static UBool
 isPNJBindiTippi(UChar32 c) {
     if (c < 0xa00 || 0xa50 <= c) {
-        return FALSE;
+        return false;
     } else {
         return (UBool)(pnjMap[c - 0xa00] >> 1);
     }
@@ -202,7 +202,7 @@ _ISCIIOpen(UConverter *cnv, UConverterLoadArgs *pArgs, UErrorCode *errorCode) {
         converterData->contextCharToUnicode=NO_CHAR_MARKER;
         cnv->toUnicodeStatus = missingCharMarker;
         converterData->contextCharFromUnicode=0x0000;
-        converterData->resetToDefaultToUnicode=FALSE;
+        converterData->resetToDefaultToUnicode=false;
         /* check if the version requested is supported */
         if ((pArgs->options & UCNV_OPTIONS_VERSION_MASK) < 9) {
             /* initialize state variables */
@@ -214,7 +214,7 @@ _ISCIIOpen(UConverter *cnv, UConverterLoadArgs *pArgs, UErrorCode *errorCode) {
                     = converterData->currentMaskToUnicode
                             = converterData->defMaskToUnicode = lookupInitialData[pArgs->options & UCNV_OPTIONS_VERSION_MASK].maskEnum;
             
-            converterData->isFirstBuffer=TRUE;
+            converterData->isFirstBuffer=true;
             (void)uprv_strcpy(converterData->name, ISCII_CNV_PREFIX);
             len = (int32_t)uprv_strlen(converterData->name);
             converterData->name[len]= (char)((pArgs->options & UCNV_OPTIONS_VERSION_MASK) + '0');
@@ -267,8 +267,8 @@ _ISCIIReset(UConverter *cnv, UConverterResetChoice choice) {
         data->contextCharFromUnicode=0x00;
         data->currentMaskFromUnicode=data->defMaskToUnicode;
         data->currentDeltaFromUnicode=data->defDeltaToUnicode;
-        data->isFirstBuffer=TRUE;
-        data->resetToDefaultToUnicode=FALSE;
+        data->isFirstBuffer=true;
+        data->resetToDefaultToUnicode=false;
     }
 }
 
@@ -906,7 +906,7 @@ UConverter_fromUnicode_ISCII_OFFSETS_LOGIC(
     UConverterDataISCII *converterData;
     uint16_t newDelta=0;
     uint16_t range = 0;
-    UBool deltaChanged = FALSE;
+    UBool deltaChanged = false;
 
     if ((args->converter == NULL) || (args->targetLimit < args->target) || (args->sourceLimit < args->source)) {
         *err = U_ILLEGAL_ARGUMENT_ERROR;
@@ -986,8 +986,8 @@ UConverter_fromUnicode_ISCII_OFFSETS_LOGIC(
                     if (newDelta!= converterData->currentDeltaFromUnicode || converterData->isFirstBuffer) {
                         converterData->currentDeltaFromUnicode = newDelta;
                         converterData->currentMaskFromUnicode = lookupInitialData[range].maskEnum;
-                        deltaChanged =TRUE;
-                        converterData->isFirstBuffer=FALSE;
+                        deltaChanged =true;
+                        converterData->isFirstBuffer=false;
                     }
                     
                     if (converterData->currentDeltaFromUnicode == PNJ_DELTA) { 
@@ -1024,7 +1024,7 @@ UConverter_fromUnicode_ISCII_OFFSETS_LOGIC(
                     temp =(uint16_t)(ATR<<8);
                     temp += (uint16_t)((uint8_t) lookupInitialData[range].isciiLang);
                     /* reset */
-                    deltaChanged=FALSE;
+                    deltaChanged=false;
                     /* now append ATR and language code */
                     WRITE_TO_TARGET_FROM_U(args,offsets,source,target,targetLimit,temp,err);
                     if (U_FAILURE(*err)) {
@@ -1330,7 +1330,7 @@ UConverter_toUnicode_ISCII_OFFSETS_LOGIC(UConverterToUnicodeArgs *args, UErrorCo
                 break;
             case 0x0A:
             case 0x0D:
-                data->resetToDefaultToUnicode = TRUE;
+                data->resetToDefaultToUnicode = true;
                 GET_MAPPING(sourceChar,targetUniChar,data)
                 ;
                 *contextCharToUnicode = sourceChar;
@@ -1338,12 +1338,12 @@ UConverter_toUnicode_ISCII_OFFSETS_LOGIC(UConverterToUnicodeArgs *args, UErrorCo
 
             case ISCII_VOWEL_SIGN_E:
                 i=1;
-                found=FALSE;
+                found=false;
                 for (; i<vowelSignESpecialCases[0][0]; i++) {
                     U_ASSERT(i<UPRV_LENGTHOF(vowelSignESpecialCases));
                     if (vowelSignESpecialCases[i][0]==(uint8_t)*contextCharToUnicode) {
                         targetUniChar=vowelSignESpecialCases[i][1];
-                        found=TRUE;
+                        found=true;
                         break;
                     }
                 }
@@ -1397,12 +1397,12 @@ UConverter_toUnicode_ISCII_OFFSETS_LOGIC(UConverterToUnicodeArgs *args, UErrorCo
                 } else {
                     /* try to handle <CHAR> + ISCII_NUKTA special mappings */
                     i=1;
-                    found =FALSE;
+                    found =false;
                     for (; i<nuktaSpecialCases[0][0]; i++) {
                         if (nuktaSpecialCases[i][0]==(uint8_t)
                                 *contextCharToUnicode) {
                             targetUniChar=nuktaSpecialCases[i][1];
-                            found =TRUE;
+                            found =true;
                             break;
                         }
                     }
@@ -1472,10 +1472,10 @@ UConverter_toUnicode_ISCII_OFFSETS_LOGIC(UConverterToUnicodeArgs *args, UErrorCo
             if (targetUniChar != missingCharMarker) {
                 /* now save the targetUniChar for delayed write */
                 *toUnicodeStatus = (UChar) targetUniChar;
-                if (data->resetToDefaultToUnicode==TRUE) {
+                if (data->resetToDefaultToUnicode==true) {
                     data->currentDeltaToUnicode = data->defDeltaToUnicode;
                     data->currentMaskToUnicode = data->defMaskToUnicode;
-                    data->resetToDefaultToUnicode=FALSE;
+                    data->resetToDefaultToUnicode=false;
                 }
             } else {
 
@@ -1550,7 +1550,7 @@ _ISCII_SafeClone(const UConverter *cnv,
 
     uprv_memcpy(&localClone->mydata, cnv->extraInfo, sizeof(UConverterDataISCII));
     localClone->cnv.extraInfo = &localClone->mydata;
-    localClone->cnv.isExtraLocal = TRUE;
+    localClone->cnv.isExtraLocal = true;
 
     return &localClone->cnv;
 }
@@ -1621,8 +1621,8 @@ static const UConverterStaticData _ISCIIStaticData={
          4,
         { 0x1a, 0, 0, 0 },
         0x1,
-        FALSE,
-        FALSE,
+        false,
+        false,
         0x0,
         0x0,
         { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, /* reserved */
diff --git a/deps/icu-small/source/common/ucnvlat1.cpp b/deps/icu-small/source/common/ucnvlat1.cpp
index 358bc0caa2..05aad6a0e0 100644
--- a/deps/icu-small/source/common/ucnvlat1.cpp
+++ b/deps/icu-small/source/common/ucnvlat1.cpp
@@ -465,7 +465,7 @@ static const UConverterStaticData _Latin1StaticData={
     sizeof(UConverterStaticData),
     "ISO-8859-1",
     819, UCNV_IBM, UCNV_LATIN_1, 1, 1,
-    { 0x1a, 0, 0, 0 }, 1, FALSE, FALSE,
+    { 0x1a, 0, 0, 0 }, 1, false, false,
     0,
     0,
     { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } /* reserved */
@@ -744,7 +744,7 @@ static const UConverterStaticData _ASCIIStaticData={
     sizeof(UConverterStaticData),
     "US-ASCII",
     367, UCNV_IBM, UCNV_US_ASCII, 1, 1,
-    { 0x1a, 0, 0, 0 }, 1, FALSE, FALSE,
+    { 0x1a, 0, 0, 0 }, 1, false, false,
     0,
     0,
     { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } /* reserved */
diff --git a/deps/icu-small/source/common/ucnvmbcs.cpp b/deps/icu-small/source/common/ucnvmbcs.cpp
index 420aa02af5..0e753c8ffb 100644
--- a/deps/icu-small/source/common/ucnvmbcs.cpp
+++ b/deps/icu-small/source/common/ucnvmbcs.cpp
@@ -373,7 +373,7 @@
  * @param value contains 1..4 bytes of the first byte sequence, right-aligned
  * @param codePoints resulting Unicode code points, or negative if a byte sequence does
  *        not map to anything
- * @return TRUE to continue enumeration, FALSE to stop
+ * @return true to continue enumeration, false to stop
  */
 typedef UBool U_CALLCONV
 UConverterEnumToUCallback(const void *context, uint32_t value, UChar32 codePoints[32]);
@@ -514,7 +514,7 @@ static const UConverterImpl _MBCSImpl={
 
 const UConverterSharedData _MBCSData={
     sizeof(UConverterSharedData), 1,
-    NULL, NULL, FALSE, TRUE, &_MBCSImpl,
+    NULL, NULL, false, true, &_MBCSImpl,
     0, UCNV_MBCS_TABLE_INITIALIZER
 };
 
@@ -668,7 +668,7 @@ enumToU(UConverterMBCSTable *mbcsTable, int8_t stateProps[],
                         value|(uint32_t)b,
                         callback, context,
                         pErrorCode)) {
-                    return FALSE;
+                    return false;
                 }
             }
             codePoints[b&0x1f]=U_SENTINEL;
@@ -719,13 +719,13 @@ enumToU(UConverterMBCSTable *mbcsTable, int8_t stateProps[],
         if(((++b)&0x1f)==0) {
             if(anyCodePoints>=0) {
                 if(!callback(context, value|(uint32_t)(b-0x20), codePoints)) {
-                    return FALSE;
+                    return false;
                 }
                 anyCodePoints=-1;
             }
         }
     }
-    return TRUE;
+    return true;
 }
 
 /*
@@ -1111,7 +1111,7 @@ _extFromU(UConverter *cnv, const UConverterSharedData *sharedData,
           UErrorCode *pErrorCode) {
     const int32_t *cx;
 
-    cnv->useSubChar1=FALSE;
+    cnv->useSubChar1=false;
 
     if( (cx=sharedData->mbcs.extIndexes)!=NULL &&
         ucnv_extInitialMatchFromU(
@@ -1286,7 +1286,7 @@ _EBCDICSwapLFNL(UConverterSharedData *sharedData, UErrorCode *pErrorCode) {
          mbcsTable->stateTable[0][EBCDIC_LF]==MBCS_ENTRY_FINAL(0, MBCS_STATE_VALID_DIRECT_16, U_LF) &&
          mbcsTable->stateTable[0][EBCDIC_NL]==MBCS_ENTRY_FINAL(0, MBCS_STATE_VALID_DIRECT_16, U_NL)
     )) {
-        return FALSE;
+        return false;
     }
 
     if(mbcsTable->outputType==MBCS_OUTPUT_1) {
@@ -1294,7 +1294,7 @@ _EBCDICSwapLFNL(UConverterSharedData *sharedData, UErrorCode *pErrorCode) {
              EBCDIC_RT_LF==MBCS_SINGLE_RESULT_FROM_U(table, results, U_LF) &&
              EBCDIC_RT_NL==MBCS_SINGLE_RESULT_FROM_U(table, results, U_NL)
         )) {
-            return FALSE;
+            return false;
         }
     } else /* MBCS_OUTPUT_2_SISO */ {
         stage2Entry=MBCS_STAGE_2_FROM_U(table, U_LF);
@@ -1302,7 +1302,7 @@ _EBCDICSwapLFNL(UConverterSharedData *sharedData, UErrorCode *pErrorCode) {
              MBCS_FROM_U_IS_ROUNDTRIP(stage2Entry, U_LF)!=0 &&
              EBCDIC_LF==MBCS_VALUE_2_FROM_STAGE_2(bytes, stage2Entry, U_LF)
         )) {
-            return FALSE;
+            return false;
         }
 
         stage2Entry=MBCS_STAGE_2_FROM_U(table, U_NL);
@@ -1310,7 +1310,7 @@ _EBCDICSwapLFNL(UConverterSharedData *sharedData, UErrorCode *pErrorCode) {
              MBCS_FROM_U_IS_ROUNDTRIP(stage2Entry, U_NL)!=0 &&
              EBCDIC_NL==MBCS_VALUE_2_FROM_STAGE_2(bytes, stage2Entry, U_NL)
         )) {
-            return FALSE;
+            return false;
         }
     }
 
@@ -1334,7 +1334,7 @@ _EBCDICSwapLFNL(UConverterSharedData *sharedData, UErrorCode *pErrorCode) {
          * ucnv_MBCSSizeofFromUBytes() function.
          */
         *pErrorCode=U_INVALID_FORMAT_ERROR;
-        return FALSE;
+        return false;
     }
 
     /*
@@ -1351,7 +1351,7 @@ _EBCDICSwapLFNL(UConverterSharedData *sharedData, UErrorCode *pErrorCode) {
     p=(uint8_t *)uprv_malloc(size);
     if(p==NULL) {
         *pErrorCode=U_MEMORY_ALLOCATION_ERROR;
-        return FALSE;
+        return false;
     }
 
     /* copy and modify the to-Unicode state table */
@@ -1397,7 +1397,7 @@ _EBCDICSwapLFNL(UConverterSharedData *sharedData, UErrorCode *pErrorCode) {
     if(newStateTable!=NULL) {
         uprv_free(newStateTable);
     }
-    return TRUE;
+    return true;
 }
 
 /* reconstitute omitted fromUnicode data ------------------------------------ */
@@ -1477,7 +1477,7 @@ writeStage3Roundtrip(const void *context, uint32_t value, UChar32 codePoints[32]
         /* set the roundtrip flag */
         *stage2|=(1UL<<(16+(c&0xf)));
     }
-    return TRUE;
+    return true;
  }
 
 static void
@@ -1561,7 +1561,7 @@ ucnv_MBCSLoad(UConverterSharedData *sharedData,
     _MBCSHeader *header=(_MBCSHeader *)raw;
     uint32_t offset;
     uint32_t headerLength;
-    UBool noFromU=FALSE;
+    UBool noFromU=false;
 
     if(header->version[0]==4) {
         headerLength=MBCS_HEADER_V4_LENGTH;
@@ -1726,7 +1726,7 @@ ucnv_MBCSLoad(UConverterSharedData *sharedData,
                 }
                 mbcsTable->stateTable=(const int32_t (*)[256])newStateTable;
                 mbcsTable->countStates=(uint8_t)(count+1);
-                mbcsTable->stateTableOwned=TRUE;
+                mbcsTable->stateTableOwned=true;
 
                 mbcsTable->outputType=MBCS_OUTPUT_DBCS_ONLY;
             }
@@ -1805,7 +1805,7 @@ ucnv_MBCSLoad(UConverterSharedData *sharedData,
                 (header->version[2]>=(MBCS_FAST_MAX>>8))
             )
         ) {
-            mbcsTable->utf8Friendly=TRUE;
+            mbcsTable->utf8Friendly=true;
 
             if(mbcsTable->countStates==1) {
                 /*
@@ -2411,13 +2411,13 @@ hasValidTrailBytes(const int32_t (*stateTable)[256], uint8_t state) {
     if( !MBCS_ENTRY_IS_TRANSITION(entry) &&
         MBCS_ENTRY_FINAL_ACTION(entry)!=MBCS_STATE_ILLEGAL
     ) {
-        return TRUE;
+        return true;
     }
     entry=row[0x41];
     if( !MBCS_ENTRY_IS_TRANSITION(entry) &&
         MBCS_ENTRY_FINAL_ACTION(entry)!=MBCS_STATE_ILLEGAL
     ) {
-        return TRUE;
+        return true;
     }
     /* Then test for final entries in this state. */
     for(b=0; b<=0xff; ++b) {
@@ -2425,7 +2425,7 @@ hasValidTrailBytes(const int32_t (*stateTable)[256], uint8_t state) {
         if( !MBCS_ENTRY_IS_TRANSITION(entry) &&
             MBCS_ENTRY_FINAL_ACTION(entry)!=MBCS_STATE_ILLEGAL
         ) {
-            return TRUE;
+            return true;
         }
     }
     /* Then recurse for transition entries. */
@@ -2434,10 +2434,10 @@ hasValidTrailBytes(const int32_t (*stateTable)[256], uint8_t state) {
         if( MBCS_ENTRY_IS_TRANSITION(entry) &&
             hasValidTrailBytes(stateTable, (uint8_t)MBCS_ENTRY_TRANSITION_STATE(entry))
         ) {
-            return TRUE;
+            return true;
         }
     }
-    return FALSE;
+    return false;
 }
 
 /*
@@ -2454,7 +2454,7 @@ isSingleOrLead(const int32_t (*stateTable)[256], uint8_t state, UBool isDBCSOnly
     } else {
         uint8_t action=(uint8_t)(MBCS_ENTRY_FINAL_ACTION(entry));
         if(action==MBCS_STATE_CHANGE_ONLY && isDBCSOnly) {
-            return FALSE;   /* SI/SO are illegal for DBCS-only conversion */
+            return false;   /* SI/SO are illegal for DBCS-only conversion */
         } else {
             return action!=MBCS_STATE_ILLEGAL;
         }
@@ -5672,7 +5672,7 @@ ucnv_MBCSWriteSub(UConverterFromUnicodeArgs *pArgs,
     }
 
     /* reset the selector for the next code point */
-    cnv->useSubChar1=FALSE;
+    cnv->useSubChar1=false;
 
     if (cnv->sharedData->mbcs.outputType == MBCS_OUTPUT_2_SISO) {
         p=buffer;
diff --git a/deps/icu-small/source/common/ucnvscsu.cpp b/deps/icu-small/source/common/ucnvscsu.cpp
index 7b580291e1..86e850a998 100644
--- a/deps/icu-small/source/common/ucnvscsu.cpp
+++ b/deps/icu-small/source/common/ucnvscsu.cpp
@@ -163,7 +163,7 @@ _SCSUReset(UConverter *cnv, UConverterResetChoice choice) {
         /* reset toUnicode */
         uprv_memcpy(scsu->toUDynamicOffsets, initialDynamicOffsets, 32);
 
-        scsu->toUIsSingleByteMode=TRUE;
+        scsu->toUIsSingleByteMode=true;
         scsu->toUState=readCommand;
         scsu->toUQuoteWindow=scsu->toUDynamicWindow=0;
         scsu->toUByteOne=0;
@@ -174,7 +174,7 @@ _SCSUReset(UConverter *cnv, UConverterResetChoice choice) {
         /* reset fromUnicode */
         uprv_memcpy(scsu->fromUDynamicOffsets, initialDynamicOffsets, 32);
 
-        scsu->fromUIsSingleByteMode=TRUE;
+        scsu->fromUIsSingleByteMode=true;
         scsu->fromUDynamicWindow=0;
 
         scsu->nextWindowUseIndex=0;
@@ -371,7 +371,7 @@ singleByteMode:
                     state=quotePairOne;
                 } else if(b==SCU) {
                     sourceIndex=nextSourceIndex;
-                    isSingleByteMode=FALSE;
+                    isSingleByteMode=false;
                     goto fastUnicode;
                 } else /* Srs */ {
                     /* callback(illegal) */
@@ -508,17 +508,17 @@ fastUnicode:
                 } else if(/* UC0<=b && */ b<=UC7) {
                     dynamicWindow=(int8_t)(b-UC0);
                     sourceIndex=nextSourceIndex;
-                    isSingleByteMode=TRUE;
+                    isSingleByteMode=true;
                     goto fastSingle;
                 } else if(/* UD0<=b && */ b<=UD7) {
                     dynamicWindow=(int8_t)(b-UD0);
-                    isSingleByteMode=TRUE;
+                    isSingleByteMode=true;
                     cnv->toUBytes[0]=b;
                     cnv->toULength=1;
                     state=defineOne;
                     goto singleByteMode;
                 } else if(b==UDX) {
-                    isSingleByteMode=TRUE;
+                    isSingleByteMode=true;
                     cnv->toUBytes[0]=b;
                     cnv->toULength=1;
                     state=definePairOne;
@@ -695,7 +695,7 @@ singleByteMode:
                 } else if(b==SQU) {
                     state=quotePairOne;
                 } else if(b==SCU) {
-                    isSingleByteMode=FALSE;
+                    isSingleByteMode=false;
                     goto fastUnicode;
                 } else /* Srs */ {
                     /* callback(illegal) */
@@ -805,17 +805,17 @@ fastUnicode:
                     state=quotePairTwo;
                 } else if(/* UC0<=b && */ b<=UC7) {
                     dynamicWindow=(int8_t)(b-UC0);
-                    isSingleByteMode=TRUE;
+                    isSingleByteMode=true;
                     goto fastSingle;
                 } else if(/* UD0<=b && */ b<=UD7) {
                     dynamicWindow=(int8_t)(b-UD0);
-                    isSingleByteMode=TRUE;
+                    isSingleByteMode=true;
                     cnv->toUBytes[0]=b;
                     cnv->toULength=1;
                     state=defineOne;
                     goto singleByteMode;
                 } else if(b==UDX) {
-                    isSingleByteMode=TRUE;
+                    isSingleByteMode=true;
                     cnv->toUBytes[0]=b;
                     cnv->toULength=1;
                     state=definePairOne;
@@ -1159,7 +1159,7 @@ getTrailSingle:
                     goto outputBytes;
                 } else {
                     /* change to Unicode mode and output this (lead, trail) pair */
-                    isSingleByteMode=FALSE;
+                    isSingleByteMode=false;
                     *target++=(uint8_t)SCU;
                     if(offsets!=NULL) {
                         *offsets++=sourceIndex;
@@ -1218,7 +1218,7 @@ getTrailSingle:
                      * switch to Unicode mode if this is the last character in the block
                      * or there is at least one more ideograph following immediately
                      */
-                    isSingleByteMode=FALSE;
+                    isSingleByteMode=false;
                     c|=SCU<<16;
                     length=3;
                     goto outputBytes;
@@ -1269,13 +1269,13 @@ getTrailSingle:
                 if(!(source<sourceLimit && (uint32_t)(*source-0x3400)<(0xd800-0x3400))) {
                     if(((uint32_t)(c-0x30)<10 || (uint32_t)(c-0x61)<26 || (uint32_t)(c-0x41)<26)) {
                         /* ASCII digit or letter */
-                        isSingleByteMode=TRUE;
+                        isSingleByteMode=true;
                         c|=((uint32_t)(UC0+dynamicWindow)<<8)|c;
                         length=2;
                         goto outputBytes;
                     } else if((window=getWindow(scsu->fromUDynamicOffsets, c))>=0) {
                         /* there is a dynamic window that contains this character, change to it */
-                        isSingleByteMode=TRUE;
+                        isSingleByteMode=true;
                         dynamicWindow=window;
                         currentOffset=scsu->fromUDynamicOffsets[dynamicWindow];
                         useDynamicWindow(scsu, dynamicWindow);
@@ -1284,7 +1284,7 @@ getTrailSingle:
                         goto outputBytes;
                     } else if((code=getDynamicOffset(c, &offset))>=0) {
                         /* define a dynamic window with this character */
-                        isSingleByteMode=TRUE;
+                        isSingleByteMode=true;
                         dynamicWindow=getNextDynamicWindow(scsu);
                         currentOffset=scsu->fromUDynamicOffsets[dynamicWindow]=offset;
                         useDynamicWindow(scsu, dynamicWindow);
@@ -1337,7 +1337,7 @@ getTrailUnicode:
                      * the following character is not uncompressible,
                      * change to the window
                      */
-                    isSingleByteMode=TRUE;
+                    isSingleByteMode=true;
                     dynamicWindow=window;
                     currentOffset=scsu->fromUDynamicOffsets[dynamicWindow];
                     useDynamicWindow(scsu, dynamicWindow);
@@ -1348,7 +1348,7 @@ getTrailUnicode:
                           (code=getDynamicOffset(c, &offset))>=0
                 ) {
                     /* two supplementary characters in (probably) the same window - define an extended one */
-                    isSingleByteMode=TRUE;
+                    isSingleByteMode=true;
                     code-=0x200;
                     dynamicWindow=getNextDynamicWindow(scsu);
                     currentOffset=scsu->fromUDynamicOffsets[dynamicWindow]=offset;
@@ -1645,7 +1645,7 @@ getTrailSingle:
                     goto outputBytes;
                 } else {
                     /* change to Unicode mode and output this (lead, trail) pair */
-                    isSingleByteMode=FALSE;
+                    isSingleByteMode=false;
                     *target++=(uint8_t)SCU;
                     --targetCapacity;
                     c=((uint32_t)lead<<16)|trail;
@@ -1701,7 +1701,7 @@ getTrailSingle:
                      * switch to Unicode mode if this is the last character in the block
                      * or there is at least one more ideograph following immediately
                      */
-                    isSingleByteMode=FALSE;
+                    isSingleByteMode=false;
                     c|=SCU<<16;
                     length=3;
                     goto outputBytes;
@@ -1746,13 +1746,13 @@ getTrailSingle:
                 if(!(source<sourceLimit && (uint32_t)(*source-0x3400)<(0xd800-0x3400))) {
                     if(((uint32_t)(c-0x30)<10 || (uint32_t)(c-0x61)<26 || (uint32_t)(c-0x41)<26)) {
                         /* ASCII digit or letter */
-                        isSingleByteMode=TRUE;
+                        isSingleByteMode=true;
                         c|=((uint32_t)(UC0+dynamicWindow)<<8)|c;
                         length=2;
                         goto outputBytes;
                     } else if((window=getWindow(scsu->fromUDynamicOffsets, c))>=0) {
                         /* there is a dynamic window that contains this character, change to it */
-                        isSingleByteMode=TRUE;
+                        isSingleByteMode=true;
                         dynamicWindow=window;
                         currentOffset=scsu->fromUDynamicOffsets[dynamicWindow];
                         useDynamicWindow(scsu, dynamicWindow);
@@ -1761,7 +1761,7 @@ getTrailSingle:
                         goto outputBytes;
                     } else if((code=getDynamicOffset(c, &offset))>=0) {
                         /* define a dynamic window with this character */
-                        isSingleByteMode=TRUE;
+                        isSingleByteMode=true;
                         dynamicWindow=getNextDynamicWindow(scsu);
                         currentOffset=scsu->fromUDynamicOffsets[dynamicWindow]=offset;
                         useDynamicWindow(scsu, dynamicWindow);
@@ -1813,7 +1813,7 @@ getTrailUnicode:
                      * the following character is not uncompressible,
                      * change to the window
                      */
-                    isSingleByteMode=TRUE;
+                    isSingleByteMode=true;
                     dynamicWindow=window;
                     currentOffset=scsu->fromUDynamicOffsets[dynamicWindow];
                     useDynamicWindow(scsu, dynamicWindow);
@@ -1824,7 +1824,7 @@ getTrailUnicode:
                           (code=getDynamicOffset(c, &offset))>=0
                 ) {
                     /* two supplementary characters in (probably) the same window - define an extended one */
-                    isSingleByteMode=TRUE;
+                    isSingleByteMode=true;
                     code-=0x200;
                     dynamicWindow=getNextDynamicWindow(scsu);
                     currentOffset=scsu->fromUDynamicOffsets[dynamicWindow]=offset;
@@ -1991,7 +1991,7 @@ _SCSUSafeClone(const UConverter *cnv,
 
     uprv_memcpy(&localClone->mydata, cnv->extraInfo, sizeof(SCSUData));
     localClone->cnv.extraInfo = &localClone->mydata;
-    localClone->cnv.isExtraLocal = TRUE;
+    localClone->cnv.isExtraLocal = true;
 
     return &localClone->cnv;
 }
@@ -2033,7 +2033,7 @@ static const UConverterStaticData _SCSUStaticData={
      * substitution string.
      */
     { 0x0e, 0xff, 0xfd, 0 }, 3,
-    FALSE, FALSE,
+    false, false,
     0,
     0,
     { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } /* reserved */
diff --git a/deps/icu-small/source/common/ucnvsel.cpp b/deps/icu-small/source/common/ucnvsel.cpp
index 2dff5ac1bc..15ee596a23 100644
--- a/deps/icu-small/source/common/ucnvsel.cpp
+++ b/deps/icu-small/source/common/ucnvsel.cpp
@@ -142,7 +142,7 @@ static void generateSelectorData(UConverterSelector* result,
   result->trie = upvec_compactToUTrie2WithRowIndexes(upvec, status);
   result->pv = upvec_cloneArray(upvec, &result->pvCount, NULL, status);
   result->pvCount *= columns;  // number of uint32_t = rows * columns
-  result->ownPv = TRUE;
+  result->ownPv = true;
 }
 
 /* open a selector. If converterListSize is 0, build for all converters.
@@ -212,7 +212,7 @@ ucnvsel_open(const char* const*  converterList, int32_t converterListSize,
     --encodingStrPadding;
   }
 
-  newSelector->ownEncodingStrings = TRUE;
+  newSelector->ownEncodingStrings = true;
   newSelector->encodingsCount = converterListSize;
   UPropsVectors *upvec = upvec_open((converterListSize+31)/32, status);
   generateSelectorData(newSelector.getAlias(), upvec, excludedCodePoints, whichSet, status);
diff --git a/deps/icu-small/source/common/ucol_swp.cpp b/deps/icu-small/source/common/ucol_swp.cpp
index 1af19863fa..59704ff8f6 100644
--- a/deps/icu-small/source/common/ucol_swp.cpp
+++ b/deps/icu-small/source/common/ucol_swp.cpp
@@ -34,7 +34,7 @@ U_CAPI UBool U_EXPORT2
 ucol_looksLikeCollationBinary(const UDataSwapper *ds,
                               const void *inData, int32_t length) {
     if(ds==NULL || inData==NULL || length<-1) {
-        return FALSE;
+        return false;
     }
 
     // First check for format version 4+ which has a standard data header.
@@ -46,7 +46,7 @@ ucol_looksLikeCollationBinary(const UDataSwapper *ds,
                 info.dataFormat[1]==0x43 &&
                 info.dataFormat[2]==0x6f &&
                 info.dataFormat[3]==0x6c) {
-            return TRUE;
+            return true;
         }
     }
 
@@ -64,7 +64,7 @@ ucol_looksLikeCollationBinary(const UDataSwapper *ds,
     if(length<0) {
         header.size=udata_readInt32(ds, inHeader->size);
     } else if((length<(42*4) || length<(header.size=udata_readInt32(ds, inHeader->size)))) {
-        return FALSE;
+        return false;
     }
 
     header.magic=ds->readUInt32(inHeader->magic);
@@ -73,14 +73,14 @@ ucol_looksLikeCollationBinary(const UDataSwapper *ds,
         inHeader->formatVersion[0]==3 /*&&
         inHeader->formatVersion[1]>=0*/
     )) {
-        return FALSE;
+        return false;
     }
 
     if(inHeader->isBigEndian!=ds->inIsBigEndian || inHeader->charSetFamily!=ds->inCharset) {
-        return FALSE;
+        return false;
     }
 
-    return TRUE;
+    return true;
 }
 
 namespace {
diff --git a/deps/icu-small/source/common/ucptrie_impl.h b/deps/icu-small/source/common/ucptrie_impl.h
index 048353c80d..a7a80a8f08 100644
--- a/deps/icu-small/source/common/ucptrie_impl.h
+++ b/deps/icu-small/source/common/ucptrie_impl.h
@@ -54,80 +54,76 @@ struct UCPTrieHeader {
     uint16_t shiftedHighStart;
 };
 
+// Constants for use with UCPTrieHeader.options.
+constexpr uint16_t UCPTRIE_OPTIONS_DATA_LENGTH_MASK = 0xf000;
+constexpr uint16_t UCPTRIE_OPTIONS_DATA_NULL_OFFSET_MASK = 0xf00;
+constexpr uint16_t UCPTRIE_OPTIONS_RESERVED_MASK = 0x38;
+constexpr uint16_t UCPTRIE_OPTIONS_VALUE_BITS_MASK = 7;
+
 /**
- * Constants for use with UCPTrieHeader.options.
- * @internal
+ * Value for index3NullOffset which indicates that there is no index-3 null block.
+ * Bit 15 is unused for this value because this bit is used if the index-3 contains
+ * 18-bit indexes.
  */
-enum {
-    UCPTRIE_OPTIONS_DATA_LENGTH_MASK = 0xf000,
-    UCPTRIE_OPTIONS_DATA_NULL_OFFSET_MASK = 0xf00,
-    UCPTRIE_OPTIONS_RESERVED_MASK = 0x38,
-    UCPTRIE_OPTIONS_VALUE_BITS_MASK = 7,
-    /**
-     * Value for index3NullOffset which indicates that there is no index-3 null block.
-     * Bit 15 is unused for this value because this bit is used if the index-3 contains
-     * 18-bit indexes.
-     */
-    UCPTRIE_NO_INDEX3_NULL_OFFSET = 0x7fff,
-    UCPTRIE_NO_DATA_NULL_OFFSET = 0xfffff
-};
+constexpr int32_t UCPTRIE_NO_INDEX3_NULL_OFFSET = 0x7fff;
+constexpr int32_t UCPTRIE_NO_DATA_NULL_OFFSET = 0xfffff;
 
 // Internal constants.
-enum {
-    /** The length of the BMP index table. 1024=0x400 */
-    UCPTRIE_BMP_INDEX_LENGTH = 0x10000 >> UCPTRIE_FAST_SHIFT,
 
-    UCPTRIE_SMALL_LIMIT = 0x1000,
-    UCPTRIE_SMALL_INDEX_LENGTH = UCPTRIE_SMALL_LIMIT >> UCPTRIE_FAST_SHIFT,
+/** The length of the BMP index table. 1024=0x400 */
+constexpr int32_t UCPTRIE_BMP_INDEX_LENGTH = 0x10000 >> UCPTRIE_FAST_SHIFT;
 
-    /** Shift size for getting the index-3 table offset. */
-    UCPTRIE_SHIFT_3 = 4,
+constexpr int32_t UCPTRIE_SMALL_LIMIT = 0x1000;
+constexpr int32_t UCPTRIE_SMALL_INDEX_LENGTH = UCPTRIE_SMALL_LIMIT >> UCPTRIE_FAST_SHIFT;
 
-    /** Shift size for getting the index-2 table offset. */
-    UCPTRIE_SHIFT_2 = 5 + UCPTRIE_SHIFT_3,
+/** Shift size for getting the index-3 table offset. */
+constexpr int32_t UCPTRIE_SHIFT_3 = 4;
 
-    /** Shift size for getting the index-1 table offset. */
-    UCPTRIE_SHIFT_1 = 5 + UCPTRIE_SHIFT_2,
+/** Shift size for getting the index-2 table offset. */
+constexpr int32_t UCPTRIE_SHIFT_2 = 5 + UCPTRIE_SHIFT_3;
 
-    /**
-     * Difference between two shift sizes,
-     * for getting an index-2 offset from an index-3 offset. 5=9-4
-     */
-    UCPTRIE_SHIFT_2_3 = UCPTRIE_SHIFT_2 - UCPTRIE_SHIFT_3,
+/** Shift size for getting the index-1 table offset. */
+constexpr int32_t UCPTRIE_SHIFT_1 = 5 + UCPTRIE_SHIFT_2;
 
-    /**
-     * Difference between two shift sizes,
-     * for getting an index-1 offset from an index-2 offset. 5=14-9
-     */
-    UCPTRIE_SHIFT_1_2 = UCPTRIE_SHIFT_1 - UCPTRIE_SHIFT_2,
+/**
+ * Difference between two shift sizes,
+ * for getting an index-2 offset from an index-3 offset. 5=9-4
+ */
+constexpr int32_t UCPTRIE_SHIFT_2_3 = UCPTRIE_SHIFT_2 - UCPTRIE_SHIFT_3;
 
-    /**
-     * Number of index-1 entries for the BMP. (4)
-     * This part of the index-1 table is omitted from the serialized form.
-     */
-    UCPTRIE_OMITTED_BMP_INDEX_1_LENGTH = 0x10000 >> UCPTRIE_SHIFT_1,
+/**
+ * Difference between two shift sizes,
+ * for getting an index-1 offset from an index-2 offset. 5=14-9
+ */
+constexpr int32_t UCPTRIE_SHIFT_1_2 = UCPTRIE_SHIFT_1 - UCPTRIE_SHIFT_2;
 
-    /** Number of entries in an index-2 block. 32=0x20 */
-    UCPTRIE_INDEX_2_BLOCK_LENGTH = 1 << UCPTRIE_SHIFT_1_2,
+/**
+ * Number of index-1 entries for the BMP. (4)
+ * This part of the index-1 table is omitted from the serialized form.
+ */
+constexpr int32_t UCPTRIE_OMITTED_BMP_INDEX_1_LENGTH = 0x10000 >> UCPTRIE_SHIFT_1;
 
-    /** Mask for getting the lower bits for the in-index-2-block offset. */
-    UCPTRIE_INDEX_2_MASK = UCPTRIE_INDEX_2_BLOCK_LENGTH - 1,
+/** Number of entries in an index-2 block. 32=0x20 */
+constexpr int32_t UCPTRIE_INDEX_2_BLOCK_LENGTH = 1 << UCPTRIE_SHIFT_1_2;
 
-    /** Number of code points per index-2 table entry. 512=0x200 */
-    UCPTRIE_CP_PER_INDEX_2_ENTRY = 1 << UCPTRIE_SHIFT_2,
+/** Mask for getting the lower bits for the in-index-2-block offset. */
+constexpr int32_t UCPTRIE_INDEX_2_MASK = UCPTRIE_INDEX_2_BLOCK_LENGTH - 1;
 
-    /** Number of entries in an index-3 block. 32=0x20 */
-    UCPTRIE_INDEX_3_BLOCK_LENGTH = 1 << UCPTRIE_SHIFT_2_3,
+/** Number of code points per index-2 table entry. 512=0x200 */
+constexpr int32_t UCPTRIE_CP_PER_INDEX_2_ENTRY = 1 << UCPTRIE_SHIFT_2;
 
-    /** Mask for getting the lower bits for the in-index-3-block offset. */
-    UCPTRIE_INDEX_3_MASK = UCPTRIE_INDEX_3_BLOCK_LENGTH - 1,
+/** Number of entries in an index-3 block. 32=0x20 */
+constexpr int32_t UCPTRIE_INDEX_3_BLOCK_LENGTH = 1 << UCPTRIE_SHIFT_2_3;
 
-    /** Number of entries in a small data block. 16=0x10 */
-    UCPTRIE_SMALL_DATA_BLOCK_LENGTH = 1 << UCPTRIE_SHIFT_3,
+/** Mask for getting the lower bits for the in-index-3-block offset. */
+constexpr int32_t UCPTRIE_INDEX_3_MASK = UCPTRIE_INDEX_3_BLOCK_LENGTH - 1;
+
+/** Number of entries in a small data block. 16=0x10 */
+constexpr int32_t UCPTRIE_SMALL_DATA_BLOCK_LENGTH = 1 << UCPTRIE_SHIFT_3;
+
+/** Mask for getting the lower bits for the in-small-data-block offset. */
+constexpr int32_t UCPTRIE_SMALL_DATA_MASK = UCPTRIE_SMALL_DATA_BLOCK_LENGTH - 1;
 
-    /** Mask for getting the lower bits for the in-small-data-block offset. */
-    UCPTRIE_SMALL_DATA_MASK = UCPTRIE_SMALL_DATA_BLOCK_LENGTH - 1
-};
 
 typedef UChar32
 UCPTrieGetRange(const void *trie, UChar32 start,
diff --git a/deps/icu-small/source/common/ucurr.cpp b/deps/icu-small/source/common/ucurr.cpp
index 6e489e0563..928d049fb5 100644
--- a/deps/icu-small/source/common/ucurr.cpp
+++ b/deps/icu-small/source/common/ucurr.cpp
@@ -97,11 +97,11 @@ static const char CURRENCYPLURALS[] = "CurrencyPlurals";
 
 // ISO codes mapping table
 static const UHashtable* gIsoCodes = NULL;
-static icu::UInitOnce gIsoCodesInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gIsoCodesInitOnce {};
 
 // Currency symbol equivalances
 static const icu::Hashtable* gCurrSymbolsEquiv = NULL;
-static icu::UInitOnce gCurrSymbolsEquivInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gCurrSymbolsEquivInitOnce {};
 
 U_NAMESPACE_BEGIN
 
@@ -238,7 +238,7 @@ isoCodes_cleanup(void)
         gIsoCodes = NULL;
     }
     gIsoCodesInitOnce.reset();
-    return TRUE;
+    return true;
 }
 
 /**
@@ -250,7 +250,7 @@ currSymbolsEquiv_cleanup(void)
     delete const_cast<icu::Hashtable *>(gCurrSymbolsEquiv);
     gCurrSymbolsEquiv = NULL;
     gCurrSymbolsEquivInitOnce.reset();
-    return TRUE;
+    return true;
 }
 
 /**
@@ -349,7 +349,7 @@ _findMetaData(const UChar* currency, UErrorCode& ec) {
 static void
 idForLocale(const char* locale, char* countryAndVariant, int capacity, UErrorCode* ec)
 {
-    ulocimp_getRegionForSupplementalData(locale, FALSE, countryAndVariant, capacity, ec);
+    ulocimp_getRegionForSupplementalData(locale, false, countryAndVariant, capacity, ec);
 }
 
 // ------------------------------------------
@@ -409,7 +409,7 @@ struct CReg : public icu::UMemory {
     }
 
     static UBool unreg(UCurrRegistryKey key) {
-        UBool found = FALSE;
+        UBool found = false;
         umtx_lock(&gCRegLock);
 
         CReg** p = &gCRegHead;
@@ -417,7 +417,7 @@ struct CReg : public icu::UMemory {
             if (*p == key) {
                 *p = ((CReg*)key)->next;
                 delete (CReg*)key;
-                found = TRUE;
+                found = true;
                 break;
             }
             p = &((*p)->next);
@@ -476,7 +476,7 @@ ucurr_unregister(UCurrRegistryKey key, UErrorCode* status)
     if (status && U_SUCCESS(*status)) {
         return CReg::unreg(key);
     }
-    return FALSE;
+    return false;
 }
 #endif /* UCONFIG_NO_SERVICE */
 
@@ -503,7 +503,7 @@ static UBool U_CALLCONV currency_cleanup(void) {
     isoCodes_cleanup();
     currSymbolsEquiv_cleanup();
 
-    return TRUE;
+    return true;
 }
 U_CDECL_END
 
@@ -566,9 +566,32 @@ ucurr_forLocale(const char* locale,
         UResourceBundle *rb = ures_openDirect(U_ICUDATA_CURR, CURRENCY_DATA, &localStatus);
         UResourceBundle *cm = ures_getByKey(rb, CURRENCY_MAP, rb, &localStatus);
         UResourceBundle *countryArray = ures_getByKey(rb, id, cm, &localStatus);
-        UResourceBundle *currencyReq = ures_getByIndex(countryArray, 0, NULL, &localStatus);
-        s = ures_getStringByKey(currencyReq, "id", &resLen, &localStatus);
-        ures_close(currencyReq);
+        // https://unicode-org.atlassian.net/browse/ICU-21997
+        // Prefer to use currencies that are legal tender.
+        if (U_SUCCESS(localStatus)) {
+            int32_t arrayLength = ures_getSize(countryArray);
+            for (int32_t i = 0; i < arrayLength; ++i) {
+                LocalUResourceBundlePointer currencyReq(
+                    ures_getByIndex(countryArray, i, nullptr, &localStatus));
+                // The currency is legal tender if it is *not* marked with tender{"false"}.
+                UErrorCode tenderStatus = localStatus;
+                const UChar *tender =
+                    ures_getStringByKey(currencyReq.getAlias(), "tender", nullptr, &tenderStatus);
+                bool isTender = U_FAILURE(tenderStatus) || u_strcmp(tender, u"false") != 0;
+                if (!isTender && s != nullptr) {
+                    // We already have a non-tender currency. Ignore all following non-tender ones.
+                    continue;
+                }
+                // Fetch the currency code.
+                s = ures_getStringByKey(currencyReq.getAlias(), "id", &resLen, &localStatus);
+                if (isTender) {
+                    break;
+                }
+            }
+            if (U_SUCCESS(localStatus) && s == nullptr) {
+                localStatus = U_MISSING_RESOURCE_ERROR;
+            }
+        }
         ures_close(countryArray);
     }
 
@@ -598,12 +621,12 @@ ucurr_forLocale(const char* locale,
  * Modify the given locale name by removing the rightmost _-delimited
  * element.  If there is none, empty the string ("" == root).
  * NOTE: The string "root" is not recognized; do not use it.
- * @return TRUE if the fallback happened; FALSE if locale is already
+ * @return true if the fallback happened; false if locale is already
  * root ("").
  */
 static UBool fallback(char *loc) {
     if (!*loc) {
-        return FALSE;
+        return false;
     }
     UErrorCode status = U_ZERO_ERROR;
     if (uprv_strcmp(loc, "en_GB") == 0) {
@@ -623,7 +646,7 @@ static UBool fallback(char *loc) {
     }
     *i = 0;
  */
-    return TRUE;
+    return true;
 }
 
 
@@ -729,7 +752,7 @@ ucurr_getName(const UChar* currency,
     // We no longer support choice format data in names.  Data should not contain
     // choice patterns.
     if (isChoiceFormat != NULL) {
-        *isChoiceFormat = FALSE;
+        *isChoiceFormat = false;
     }
     if (U_SUCCESS(ec2)) {
         U_ASSERT(s != NULL);
@@ -896,7 +919,7 @@ getCurrencyNameCount(const char* loc, int32_t* total_currency_name_count, int32_
             s = ures_getStringByIndex(names, UCURR_SYMBOL_NAME, &len, &ec2);
             ++(*total_currency_symbol_count);  // currency symbol
             if (currencySymbolsEquiv != NULL) {
-                *total_currency_symbol_count += countEquivalent(*currencySymbolsEquiv, UnicodeString(TRUE, s, len));
+                *total_currency_symbol_count += countEquivalent(*currencySymbolsEquiv, UnicodeString(true, s, len));
             }
             ++(*total_currency_symbol_count); // iso code
             ++(*total_currency_name_count); // long name
@@ -1017,7 +1040,7 @@ collectCurrencyNames(const char* locale,
             (*currencySymbols)[(*total_currency_symbol_count)++].currencyNameLen = len;
             // Add equivalent symbols
             if (currencySymbolsEquiv != NULL) {
-                UnicodeString str(TRUE, s, len);
+                UnicodeString str(true, s, len);
                 icu::EquivIterator iter(*currencySymbolsEquiv, str);
                 const UnicodeString *symbol;
                 while ((symbol = iter.next()) != NULL) {
@@ -1401,7 +1424,7 @@ currency_cache_cleanup(void) {
             currCache[i] = 0;
         }
     }
-    return TRUE;
+    return true;
 }
 
 
@@ -1928,6 +1951,7 @@ static const struct CurrencyList {
     {"SHP", UCURR_COMMON|UCURR_NON_DEPRECATED},
     {"SIT", UCURR_COMMON|UCURR_DEPRECATED},
     {"SKK", UCURR_COMMON|UCURR_DEPRECATED},
+    {"SLE", UCURR_COMMON|UCURR_NON_DEPRECATED},
     {"SLL", UCURR_COMMON|UCURR_NON_DEPRECATED},
     {"SOS", UCURR_COMMON|UCURR_NON_DEPRECATED},
     {"SRD", UCURR_COMMON|UCURR_NON_DEPRECATED},
@@ -1965,6 +1989,7 @@ static const struct CurrencyList {
     {"UYW", UCURR_UNCOMMON|UCURR_NON_DEPRECATED},
     {"UZS", UCURR_COMMON|UCURR_NON_DEPRECATED},
     {"VEB", UCURR_COMMON|UCURR_DEPRECATED},
+    {"VED", UCURR_UNCOMMON|UCURR_NON_DEPRECATED},
     {"VEF", UCURR_COMMON|UCURR_NON_DEPRECATED},
     {"VES", UCURR_COMMON|UCURR_NON_DEPRECATED},
     {"VND", UCURR_COMMON|UCURR_NON_DEPRECATED},
@@ -2220,19 +2245,19 @@ U_CAPI UBool U_EXPORT2
 ucurr_isAvailable(const UChar* isoCode, UDate from, UDate to, UErrorCode* eErrorCode) {
     umtx_initOnce(gIsoCodesInitOnce, &initIsoCodes, *eErrorCode);
     if (U_FAILURE(*eErrorCode)) {
-        return FALSE;
+        return false;
     }
 
     IsoCodeEntry* result = (IsoCodeEntry *) uhash_get(gIsoCodes, isoCode);
     if (result == NULL) {
-        return FALSE;
+        return false;
     } else if (from > to) {
         *eErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
-        return FALSE;
+        return false;
     } else if  ((from > result->to) || (to < result->from)) {
-        return FALSE;
+        return false;
     }
-    return TRUE;
+    return true;
 }
 
 static const icu::Hashtable* getCurrSymbolsEquiv() {
@@ -2537,7 +2562,7 @@ static const UEnumeration defaultKeywordValues = {
 U_CAPI UEnumeration *U_EXPORT2 ucurr_getKeywordValuesForLocale(const char *key, const char *locale, UBool commonlyUsed, UErrorCode* status) {
     // Resolve region
     char prefRegion[ULOC_COUNTRY_CAPACITY];
-    ulocimp_getRegionForSupplementalData(locale, TRUE, prefRegion, sizeof(prefRegion), status);
+    ulocimp_getRegionForSupplementalData(locale, true, prefRegion, sizeof(prefRegion), status);
     
     // Read value from supplementalData
     UList *values = ulist_createEmptyList(status);
@@ -2570,7 +2595,7 @@ U_CAPI UEnumeration *U_EXPORT2 ucurr_getKeywordValuesForLocale(const char *key,
             break;
         }
         const char *region = ures_getKey(&bundlekey);
-        UBool isPrefRegion = uprv_strcmp(region, prefRegion) == 0 ? TRUE : FALSE;
+        UBool isPrefRegion = uprv_strcmp(region, prefRegion) == 0 ? true : false;
         if (!isPrefRegion && commonlyUsed) {
             // With commonlyUsed=true, we do not put
             // currencies for other regions in the
@@ -2595,7 +2620,7 @@ U_CAPI UEnumeration *U_EXPORT2 ucurr_getKeywordValuesForLocale(const char *key,
             }
 
 #if U_CHARSET_FAMILY==U_ASCII_FAMILY
-            ures_getUTF8StringByKey(&curbndl, "id", curID, &curIDLength, TRUE, status);
+            ures_getUTF8StringByKey(&curbndl, "id", curID, &curIDLength, true, status);
             /* optimize - use the utf-8 string */
 #else
             {
@@ -2613,19 +2638,19 @@ U_CAPI UEnumeration *U_EXPORT2 ucurr_getKeywordValuesForLocale(const char *key,
             if (U_FAILURE(*status)) {
                 break;
             }
-            UBool hasTo = FALSE;
+            UBool hasTo = false;
             ures_getByKey(&curbndl, "to", &to, status);
             if (U_FAILURE(*status)) {
                 // Do nothing here...
                 *status = U_ZERO_ERROR;
             } else {
-                hasTo = TRUE;
+                hasTo = true;
             }
             if (isPrefRegion && !hasTo && !ulist_containsString(values, curID, (int32_t)uprv_strlen(curID))) {
                 // Currently active currency for the target country
-                ulist_addItemEndList(values, curID, TRUE, status);
+                ulist_addItemEndList(values, curID, true, status);
             } else if (!ulist_containsString(otherValues, curID, (int32_t)uprv_strlen(curID)) && !commonlyUsed) {
-                ulist_addItemEndList(otherValues, curID, TRUE, status);
+                ulist_addItemEndList(otherValues, curID, true, status);
             } else {
                 uprv_free(curID);
             }
@@ -2638,7 +2663,7 @@ U_CAPI UEnumeration *U_EXPORT2 ucurr_getKeywordValuesForLocale(const char *key,
                 // This could happen if no valid region is supplied in the input
                 // locale. In this case, we use the CLDR's default.
                 uenum_close(en);
-                en = ucurr_getKeywordValuesForLocale(key, "und", TRUE, status);
+                en = ucurr_getKeywordValuesForLocale(key, "und", true, status);
             }
         } else {
             // Consolidate the list
@@ -2648,7 +2673,7 @@ U_CAPI UEnumeration *U_EXPORT2 ucurr_getKeywordValuesForLocale(const char *key,
                 if (!ulist_containsString(values, value, (int32_t)uprv_strlen(value))) {
                     char *tmpValue = (char *)uprv_malloc(sizeof(char) * ULOC_KEYWORDS_CAPACITY);
                     uprv_memcpy(tmpValue, value, uprv_strlen(value) + 1);
-                    ulist_addItemEndList(values, tmpValue, TRUE, status);
+                    ulist_addItemEndList(values, tmpValue, true, status);
                     if (U_FAILURE(*status)) {
                         break;
                     }
diff --git a/deps/icu-small/source/common/udata.cpp b/deps/icu-small/source/common/udata.cpp
index ec9c999cea..2bc74c9789 100644
--- a/deps/icu-small/source/common/udata.cpp
+++ b/deps/icu-small/source/common/udata.cpp
@@ -106,10 +106,10 @@ static UDataMemory *udata_findCachedData(const char *path, UErrorCode &err);
  */
 static UDataMemory *gCommonICUDataArray[10] = { NULL };   // Access protected by icu global mutex.
 
-static u_atomic_int32_t gHaveTriedToLoadCommonData = ATOMIC_INT32_T_INITIALIZER(0);  //  See extendICUData().
+static u_atomic_int32_t gHaveTriedToLoadCommonData {0};  //  See extendICUData().
 
 static UHashtable  *gCommonDataCache = NULL;  /* Global hash table of opened ICU data files.  */
-static icu::UInitOnce gCommonDataCacheInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gCommonDataCacheInitOnce {};
 
 #if !defined(ICU_DATA_DIR_WINDOWS)
 static UDataFileAccess  gDataFileAccess = UDATA_DEFAULT_ACCESS;  // Access not synchronized.
@@ -136,25 +136,25 @@ udata_cleanup(void)
     }
     gHaveTriedToLoadCommonData = 0;
 
-    return TRUE;                   /* Everything was cleaned up */
+    return true;                   /* Everything was cleaned up */
 }
 
 static UBool U_CALLCONV
 findCommonICUDataByName(const char *inBasename, UErrorCode &err)
 {
-    UBool found = FALSE;
+    UBool found = false;
     int32_t i;
 
     UDataMemory  *pData = udata_findCachedData(inBasename, err);
     if (U_FAILURE(err) || pData == NULL)
-        return FALSE;
+        return false;
 
     {
         Mutex lock;
         for (i = 0; i < UPRV_LENGTHOF(gCommonICUDataArray); ++i) {
             if ((gCommonICUDataArray[i] != NULL) && (gCommonICUDataArray[i]->pHeader == pData->pHeader)) {
                 /* The data pointer is already in the array. */
-                found = TRUE;
+                found = true;
                 break;
             }
         }
@@ -174,9 +174,9 @@ setCommonICUData(UDataMemory *pData,     /*  The new common data.  Belongs to ca
 {
     UDataMemory  *newCommonData = UDataMemory_createNewInstance(pErr);
     int32_t i;
-    UBool didUpdate = FALSE;
+    UBool didUpdate = false;
     if (U_FAILURE(*pErr)) {
-        return FALSE;
+        return false;
     }
 
     /*  For the assignment, other threads must cleanly see either the old            */
@@ -188,7 +188,7 @@ setCommonICUData(UDataMemory *pData,     /*  The new common data.  Belongs to ca
     for (i = 0; i < UPRV_LENGTHOF(gCommonICUDataArray); ++i) {
         if (gCommonICUDataArray[i] == NULL) {
             gCommonICUDataArray[i] = newCommonData;
-            didUpdate = TRUE;
+            didUpdate = true;
             break;
         } else if (gCommonICUDataArray[i]->pHeader == pData->pHeader) {
             /* The same data pointer is already in the array. */
@@ -216,7 +216,7 @@ setCommonICUDataPointer(const void *pData, UBool /*warn*/, UErrorCode *pErrorCod
     UDataMemory_init(&tData);
     UDataMemory_setData(&tData, pData);
     udata_checkCommonData(&tData, pErrorCode);
-    return setCommonICUData(&tData, FALSE, pErrorCode);
+    return setCommonICUData(&tData, false, pErrorCode);
 }
 
 #endif
@@ -429,7 +429,7 @@ private:
     CharString  pathBuffer;                        /* output path for this it'ion */
     CharString  packageStub;                       /* example:  "/icudt28b". Will ignore that leaf in set paths. */
 
-    UBool       checkLastFour;                     /* if TRUE then allow paths such as '/foo/myapp.dat'
+    UBool       checkLastFour;                     /* if true then allow paths such as '/foo/myapp.dat'
                                                     * to match, checks last 4 chars of suffix with
                                                     * last 4 of path, then previous chars. */
 };
@@ -501,7 +501,7 @@ UDataPathIterator::UDataPathIterator(const char *inPath, const char *pkg,
             suffix.data(),
             itemPath.data(),
             nextPath,
-            checkLastFour?"TRUE":"false");
+            checkLastFour?"true":"false");
 #endif
 }
 
@@ -568,7 +568,7 @@ const char *UDataPathIterator::next(UErrorCode *pErrorCode)
         /* check for .dat files */
         pathBasename = findBasename(pathBuffer.data());
 
-        if(checkLastFour == TRUE && 
+        if(checkLastFour == true && 
            (pathLen>=4) &&
            uprv_strncmp(pathBuffer.data() +(pathLen-4), suffix.data(), 4)==0 && /* suffix matches */
            uprv_strncmp(findBasename(pathBuffer.data()), basename, basenameLen)==0  && /* base matches */
@@ -711,15 +711,15 @@ openCommonData(const char *path,          /*  Path from OpenChoice?          */
          */
         /*
         if (uprv_getICUData_collation) {
-            setCommonICUDataPointer(uprv_getICUData_collation(), FALSE, pErrorCode);
+            setCommonICUDataPointer(uprv_getICUData_collation(), false, pErrorCode);
         }
         if (uprv_getICUData_conversion) {
-            setCommonICUDataPointer(uprv_getICUData_conversion(), FALSE, pErrorCode);
+            setCommonICUDataPointer(uprv_getICUData_conversion(), false, pErrorCode);
         }
         */
 #if !defined(ICU_DATA_DIR_WINDOWS)
 // When using the Windows system data, we expect only a single data file.
-        setCommonICUDataPointer(&U_ICUDATA_ENTRY_POINT, FALSE, pErrorCode);
+        setCommonICUDataPointer(&U_ICUDATA_ENTRY_POINT, false, pErrorCode);
         {
             Mutex lock;
             return gCommonICUDataArray[commonDataIndex];
@@ -761,9 +761,9 @@ openCommonData(const char *path,          /*  Path from OpenChoice?          */
      * Hunt it down, trying all the path locations
      */
 
-    UDataPathIterator iter(u_getDataDirectory(), inBasename, path, ".dat", TRUE, pErrorCode);
+    UDataPathIterator iter(u_getDataDirectory(), inBasename, path, ".dat", true, pErrorCode);
 
-    while ((UDataMemory_isLoaded(&tData)==FALSE) && (pathBuffer = iter.next(pErrorCode)) != NULL)
+    while ((UDataMemory_isLoaded(&tData)==false) && (pathBuffer = iter.next(pErrorCode)) != NULL)
     {
 #ifdef UDATA_DEBUG
         fprintf(stderr, "ocd: trying path %s - ", pathBuffer);
@@ -822,7 +822,7 @@ static UBool extendICUData(UErrorCode *pErr)
 {
     UDataMemory   *pData;
     UDataMemory   copyPData;
-    UBool         didUpdate = FALSE;
+    UBool         didUpdate = false;
 
     /*
      * There is a chance for a race condition here.
@@ -859,7 +859,7 @@ static UBool extendICUData(UErrorCode *pErr)
 
           didUpdate = /* no longer using this result */
               setCommonICUData(&copyPData,/*  The new common data.                                */
-                       FALSE,             /*  No warnings if write didn't happen                  */
+                       false,             /*  No warnings if write didn't happen                  */
                        pErr);             /*  setCommonICUData honors errors; NOP if error set    */
         }
 
@@ -906,7 +906,7 @@ udata_setCommonData(const void *data, UErrorCode *pErrorCode) {
 
     /* we have good data */
     /* Set it up as the ICU Common Data.  */
-    setCommonICUData(&dataMemory, TRUE, pErrorCode);
+    setCommonICUData(&dataMemory, true, pErrorCode);
 }
 
 /*---------------------------------------------------------------------------
@@ -999,7 +999,7 @@ static UDataMemory *doLoadFromIndividualFiles(const char *pkgName,
 
     /* look in ind. files: package\nam.typ  ========================= */
     /* init path iterator for individual files */
-    UDataPathIterator iter(dataPath, pkgName, path, tocEntryPathSuffix, FALSE, pErrorCode);
+    UDataPathIterator iter(dataPath, pkgName, path, tocEntryPathSuffix, false, pErrorCode);
 
     while ((pathBuffer = iter.next(pErrorCode)) != NULL)
     {
@@ -1055,7 +1055,7 @@ static UDataMemory *doLoadFromCommonData(UBool isICUData, const char * /*pkgName
     const DataHeader   *pHeader;
     UDataMemory        *pCommonData;
     int32_t            commonDataIndex;
-    UBool              checkedExtendedICUData = FALSE;
+    UBool              checkedExtendedICUData = false;
     /* try to get common data.  The loop is for platforms such as the 390 that do
      *  not initially load the full set of ICU data.  If the lookup of an ICU data item
      *  fails, the full (but slower to load) set is loaded, the and the loop repeats,
@@ -1104,7 +1104,7 @@ static UDataMemory *doLoadFromCommonData(UBool isICUData, const char * /*pkgName
         } else if (pCommonData != NULL) {
             ++commonDataIndex;  /* try the next data package */
         } else if ((!checkedExtendedICUData) && extendICUData(subErrorCode)) {
-            checkedExtendedICUData = TRUE;
+            checkedExtendedICUData = true;
             /* try this data package slot again: it changed from NULL to non-NULL */
         } else {
             return NULL;
@@ -1169,7 +1169,7 @@ doOpenChoice(const char *path, const char *type, const char *name,
     UErrorCode          subErrorCode=U_ZERO_ERROR;
     const char         *treeChar;
 
-    UBool               isICUData = FALSE;
+    UBool               isICUData = false;
 
 
     FileTracer::traceOpen(path, type, name);
@@ -1182,7 +1182,7 @@ doOpenChoice(const char *path, const char *type, const char *name,
                      uprv_strlen(U_ICUDATA_NAME U_TREE_SEPARATOR_STRING)) ||  
        !uprv_strncmp(path, U_ICUDATA_ALIAS U_TREE_SEPARATOR_STRING, /* "ICUDATA-" */
                      uprv_strlen(U_ICUDATA_ALIAS U_TREE_SEPARATOR_STRING))) {
-      isICUData = TRUE;
+      isICUData = true;
     }
 
 #if (U_FILE_SEP_CHAR != U_FILE_ALT_SEP_CHAR)  /* Windows:  try "foo\bar" and "foo/bar" */
diff --git a/deps/icu-small/source/common/udatamem.cpp b/deps/icu-small/source/common/udatamem.cpp
index 6bf7c01235..0f80de28eb 100644
--- a/deps/icu-small/source/common/udatamem.cpp
+++ b/deps/icu-small/source/common/udatamem.cpp
@@ -49,7 +49,7 @@ U_CFUNC UDataMemory *UDataMemory_createNewInstance(UErrorCode *pErr) {
         *pErr = U_MEMORY_ALLOCATION_ERROR; }
     else {
         UDataMemory_init(This);
-        This->heapAllocated = TRUE;
+        This->heapAllocated = true;
     }
     return This;
 }
diff --git a/deps/icu-small/source/common/udatamem.h b/deps/icu-small/source/common/udatamem.h
index a05dd69756..3db2af43aa 100644
--- a/deps/icu-small/source/common/udatamem.h
+++ b/deps/icu-small/source/common/udatamem.h
@@ -44,7 +44,7 @@ struct UDataMemory {
     int32_t           length;      /* Length of the data in bytes; -1 if unknown.     */
 };
 
-U_CFUNC UDataMemory *UDataMemory_createNewInstance(UErrorCode *pErr);
+U_CAPI  UDataMemory* U_EXPORT2 UDataMemory_createNewInstance(UErrorCode *pErr);
 U_CFUNC void         UDatamemory_assign  (UDataMemory *dest, UDataMemory *source);
 U_CFUNC void         UDataMemory_init    (UDataMemory *This);
 U_CFUNC UBool        UDataMemory_isLoaded(const UDataMemory *This);
diff --git a/deps/icu-small/source/common/uhash.cpp b/deps/icu-small/source/common/uhash.cpp
index 2e331b7172..a04f9606c5 100644
--- a/deps/icu-small/source/common/uhash.cpp
+++ b/deps/icu-small/source/common/uhash.cpp
@@ -265,7 +265,7 @@ _uhash_init(UHashtable *result,
     result->valueComparator = valueComp;
     result->keyDeleter      = NULL;
     result->valueDeleter    = NULL;
-    result->allocated       = FALSE;
+    result->allocated       = false;
     _uhash_internalSetResizePolicy(result, U_GROW);
 
     _uhash_allocate(result, primeIndex, status);
@@ -294,7 +294,7 @@ _uhash_create(UHashFunction *keyHash,
     }
 
     _uhash_init(result, keyHash, keyComp, valueComp, primeIndex, status);
-    result->allocated       = TRUE;
+    result->allocated       = true;
 
     if (U_FAILURE(*status)) {
         uprv_free(result);
@@ -949,7 +949,7 @@ uhash_equals(const UHashtable* hash1, const UHashtable* hash2){
     int32_t count1, count2, pos, i;
 
     if(hash1==hash2){
-        return TRUE;
+        return true;
     }
 
     /*
@@ -967,15 +967,15 @@ uhash_equals(const UHashtable* hash1, const UHashtable* hash2){
     {
         /*
         Normally we would return an error here about incompatible hash tables,
-        but we return FALSE instead.
+        but we return false instead.
         */
-        return FALSE;
+        return false;
     }
 
     count1 = uhash_count(hash1);
     count2 = uhash_count(hash2);
     if(count1!=count2){
-        return FALSE;
+        return false;
     }
 
     pos=UHASH_FIRST;
@@ -989,11 +989,11 @@ uhash_equals(const UHashtable* hash1, const UHashtable* hash2){
          */
         const UHashElement* elem2 = _uhash_find(hash2, key1, hash2->keyHasher(key1));
         const UHashTok val2 = elem2->value;
-        if(hash1->valueComparator(val1, val2)==FALSE){
-            return FALSE;
+        if(hash1->valueComparator(val1, val2)==false){
+            return false;
         }
     }
-    return TRUE;
+    return true;
 }
 
 /********************************************************************
@@ -1005,10 +1005,10 @@ uhash_compareUChars(const UHashTok key1, const UHashTok key2) {
     const UChar *p1 = (const UChar*) key1.pointer;
     const UChar *p2 = (const UChar*) key2.pointer;
     if (p1 == p2) {
-        return TRUE;
+        return true;
     }
     if (p1 == NULL || p2 == NULL) {
-        return FALSE;
+        return false;
     }
     while (*p1 != 0 && *p1 == *p2) {
         ++p1;
@@ -1022,10 +1022,10 @@ uhash_compareChars(const UHashTok key1, const UHashTok key2) {
     const char *p1 = (const char*) key1.pointer;
     const char *p2 = (const char*) key2.pointer;
     if (p1 == p2) {
-        return TRUE;
+        return true;
     }
     if (p1 == NULL || p2 == NULL) {
-        return FALSE;
+        return false;
     }
     while (*p1 != 0 && *p1 == *p2) {
         ++p1;
@@ -1039,10 +1039,10 @@ uhash_compareIChars(const UHashTok key1, const UHashTok key2) {
     const char *p1 = (const char*) key1.pointer;
     const char *p2 = (const char*) key2.pointer;
     if (p1 == p2) {
-        return TRUE;
+        return true;
     }
     if (p1 == NULL || p2 == NULL) {
-        return FALSE;
+        return false;
     }
     while (*p1 != 0 && uprv_tolower(*p1) == uprv_tolower(*p2)) {
         ++p1;
diff --git a/deps/icu-small/source/common/uidna.cpp b/deps/icu-small/source/common/uidna.cpp
index ac2f9c3c8c..1cbdeec327 100644
--- a/deps/icu-small/source/common/uidna.cpp
+++ b/deps/icu-small/source/common/uidna.cpp
@@ -58,15 +58,15 @@ toASCIILower(UChar ch){
 inline static UBool 
 startsWithPrefix(const UChar* src , int32_t srcLength){
     if(srcLength < ACE_PREFIX_LENGTH){
-        return FALSE;
+        return false;
     }
 
     for(int8_t i=0; i< ACE_PREFIX_LENGTH; i++){
         if(toASCIILower(src[i]) != ACE_PREFIX[i]){
-            return FALSE;
+            return false;
         }
     }
-    return TRUE;
+    return true;
 }
 
 
@@ -132,9 +132,9 @@ static inline UBool isLabelSeparator(UChar ch){
         case 0x3002:
         case 0xFF0E:
         case 0xFF61:
-            return TRUE;
+            return true;
         default:
-            return FALSE;           
+            return false;           
     }
 }
 
@@ -149,7 +149,7 @@ getNextSeparator(UChar *src, int32_t srcLength,
         for(i=0 ; ;i++){
             if(src[i] == 0){
                 *limit = src + i; // point to null
-                *done = TRUE;
+                *done = true;
                 return i;
             }
             if(isLabelSeparator(src[i])){
@@ -169,7 +169,7 @@ getNextSeparator(UChar *src, int32_t srcLength,
         // we have not found the delimiter
         // if(i==srcLength)
         *limit = src+srcLength;
-        *done = TRUE;
+        *done = true;
 
         return i;
     }
@@ -177,7 +177,7 @@ getNextSeparator(UChar *src, int32_t srcLength,
 static inline UBool isLDHChar(UChar ch){
     // high runner case
     if(ch>0x007A){
-        return FALSE;
+        return false;
     }
     //[\\u002D \\u0030-\\u0039 \\u0041-\\u005A \\u0061-\\u007A]
     if( (ch==0x002D) || 
@@ -185,9 +185,9 @@ static inline UBool isLDHChar(UChar ch){
         (0x0041 <= ch && ch <= 0x005A) ||
         (0x0061 <= ch && ch <= 0x007A)
       ){
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 static int32_t 
@@ -212,9 +212,9 @@ _internal_toASCII(const UChar* src, int32_t srcLength,
     UBool* caseFlags = NULL;
     
     // the source contains all ascii codepoints
-    UBool srcIsASCII  = TRUE;
+    UBool srcIsASCII  = true;
     // assume the source contains all LDH codepoints
-    UBool srcIsLDH = TRUE; 
+    UBool srcIsLDH = true; 
 
     int32_t j=0;
 
@@ -239,13 +239,13 @@ _internal_toASCII(const UChar* src, int32_t srcLength,
     // step 1 
     for( j=0;j<srcLength;j++){
         if(src[j] > 0x7F){
-            srcIsASCII = FALSE;
+            srcIsASCII = false;
         }
         b1[b1Len++] = src[j];
     }
     
     // step 2 is performed only if the source contains non ASCII
-    if(srcIsASCII == FALSE){
+    if(srcIsASCII == false){
         
         // step 2    
         b1Len = usprep_prepare(nameprep, src, srcLength, b1, b1Capacity, namePrepOptions, parseError, status);
@@ -277,29 +277,29 @@ _internal_toASCII(const UChar* src, int32_t srcLength,
     }
 
     // for step 3 & 4
-    srcIsASCII = TRUE;
+    srcIsASCII = true;
     for( j=0;j<b1Len;j++){
         // check if output of usprep_prepare is all ASCII 
         if(b1[j] > 0x7F){
-            srcIsASCII = FALSE;
-        }else if(isLDHChar(b1[j])==FALSE){  // if the char is in ASCII range verify that it is an LDH character
-            srcIsLDH = FALSE;
+            srcIsASCII = false;
+        }else if(isLDHChar(b1[j])==false){  // if the char is in ASCII range verify that it is an LDH character
+            srcIsLDH = false;
             failPos = j;
         }
     }
-    if(useSTD3ASCIIRules == TRUE){
+    if(useSTD3ASCIIRules == true){
         // verify 3a and 3b
         // 3(a) Verify the absence of non-LDH ASCII code points; that is, the
         //  absence of 0..2C, 2E..2F, 3A..40, 5B..60, and 7B..7F.
         // 3(b) Verify the absence of leading and trailing hyphen-minus; that
         //  is, the absence of U+002D at the beginning and end of the
         //  sequence.
-        if( srcIsLDH == FALSE /* source at this point should not contain anyLDH characters */
+        if( srcIsLDH == false /* source at this point should not contain anyLDH characters */
             || b1[0] ==  HYPHEN || b1[b1Len-1] == HYPHEN){
             *status = U_IDNA_STD3_ASCII_RULES_ERROR;
 
             /* populate the parseError struct */
-            if(srcIsLDH==FALSE){
+            if(srcIsLDH==false){
                 // failPos is always set the index of failure
                 uprv_syntaxError(b1,failPos, b1Len,parseError);
             }else if(b1[0] == HYPHEN){
@@ -331,7 +331,7 @@ _internal_toASCII(const UChar* src, int32_t srcLength,
             // do not preserve the case flags for now!
             // TODO: Preserve the case while implementing the RFE
             // caseFlags = (UBool*) uprv_malloc(b1Len * sizeof(UBool));
-            // uprv_memset(caseFlags,TRUE,b1Len);
+            // uprv_memset(caseFlags,true,b1Len);
 
             b2Len = u_strToPunycode(b1,b1Len,b2,b2Capacity,caseFlags, status);
 
@@ -416,8 +416,8 @@ _internal_toUnicode(const UChar* src, int32_t srcLength,
 
     UBool* caseFlags = NULL;
 
-    UBool srcIsASCII = TRUE;
-    /*UBool srcIsLDH = TRUE;
+    UBool srcIsASCII = true;
+    /*UBool srcIsLDH = true;
     int32_t failPos =0;*/
 
     // step 1: find out if all the codepoints in src are ASCII  
@@ -425,12 +425,12 @@ _internal_toUnicode(const UChar* src, int32_t srcLength,
         srcLength = 0;
         for(;src[srcLength]!=0;){
             if(src[srcLength]> 0x7f){
-                srcIsASCII = FALSE;
-            }/*else if(isLDHChar(src[srcLength])==FALSE){
+                srcIsASCII = false;
+            }/*else if(isLDHChar(src[srcLength])==false){
                 // here we do not assemble surrogates
                 // since we know that LDH code points
                 // are in the ASCII range only
-                srcIsLDH = FALSE;
+                srcIsLDH = false;
                 failPos = srcLength;
             }*/
             srcLength++;
@@ -438,13 +438,13 @@ _internal_toUnicode(const UChar* src, int32_t srcLength,
     }else if(srcLength > 0){
         for(int32_t j=0; j<srcLength; j++){
             if(src[j]> 0x7f){
-                srcIsASCII = FALSE;
+                srcIsASCII = false;
                 break;
-            }/*else if(isLDHChar(src[j])==FALSE){
+            }/*else if(isLDHChar(src[j])==false){
                 // here we do not assemble surrogates
                 // since we know that LDH code points
                 // are in the ASCII range only
-                srcIsLDH = FALSE;
+                srcIsLDH = false;
                 failPos = j;
             }*/
         }
@@ -452,7 +452,7 @@ _internal_toUnicode(const UChar* src, int32_t srcLength,
         return 0;
     }
     
-    if(srcIsASCII == FALSE){
+    if(srcIsASCII == false){
         // step 2: process the string
         b1Len = usprep_prepare(nameprep, src, srcLength, b1, b1Capacity, namePrepOptions, parseError, status);
         if(*status == U_BUFFER_OVERFLOW_ERROR){
@@ -548,13 +548,13 @@ _internal_toUnicode(const UChar* src, int32_t srcLength,
     else{
         // See the start of this if statement for why this is commented out.
         // verify that STD3 ASCII rules are satisfied
-        /*if(useSTD3ASCIIRules == TRUE){
-            if( srcIsLDH == FALSE // source contains some non-LDH characters
+        /*if(useSTD3ASCIIRules == true){
+            if( srcIsLDH == false // source contains some non-LDH characters
                 || src[0] ==  HYPHEN || src[srcLength-1] == HYPHEN){
                 *status = U_IDNA_STD3_ASCII_RULES_ERROR;
 
                 // populate the parseError struct
-                if(srcIsLDH==FALSE){
+                if(srcIsLDH==false){
                     // failPos is always set the index of failure
                     uprv_syntaxError(src,failPos, srcLength,parseError);
                 }else if(src[0] == HYPHEN){
@@ -695,7 +695,7 @@ uidna_IDNToASCII(  const UChar *src, int32_t srcLength,
     int32_t remainingLen = srcLength;
     int32_t remainingDestCapacity = destCapacity;
     int32_t labelLen = 0, labelReqLength = 0;
-    UBool done = FALSE;
+    UBool done = false;
 
 
     for(;;){
@@ -731,7 +731,7 @@ uidna_IDNToASCII(  const UChar *src, int32_t srcLength,
             remainingDestCapacity = 0;
         }
 
-        if(done == TRUE){
+        if(done == true){
             break;
         }
 
@@ -788,7 +788,7 @@ uidna_IDNToUnicode(  const UChar* src, int32_t srcLength,
     int32_t remainingLen = srcLength;
     int32_t remainingDestCapacity = destCapacity;
     int32_t labelLen = 0, labelReqLength = 0;
-    UBool done = FALSE;
+    UBool done = false;
 
     for(;;){
 
@@ -800,7 +800,7 @@ uidna_IDNToUnicode(  const UChar* src, int32_t srcLength,
         // is returned immediately in that step.
         // </quote>
         // _internal_toUnicode will copy the label.
-        /*if(labelLen==0 && done==FALSE){ 
+        /*if(labelLen==0 && done==false){ 
             *status = U_IDNA_ZERO_LENGTH_LABEL_ERROR;
             break;
         }*/
@@ -829,7 +829,7 @@ uidna_IDNToUnicode(  const UChar* src, int32_t srcLength,
             remainingDestCapacity = 0;
         }
 
-        if(done == TRUE){
+        if(done == true){
             break;
         }
 
diff --git a/deps/icu-small/source/common/uinit.cpp b/deps/icu-small/source/common/uinit.cpp
index 624431be02..dc3867b17e 100644
--- a/deps/icu-small/source/common/uinit.cpp
+++ b/deps/icu-small/source/common/uinit.cpp
@@ -26,11 +26,11 @@
 
 U_NAMESPACE_BEGIN
 
-static UInitOnce gICUInitOnce = U_INITONCE_INITIALIZER;
+static UInitOnce gICUInitOnce {};
 
 static UBool U_CALLCONV uinit_cleanup() {
     gICUInitOnce.reset();
-    return TRUE;
+    return true;
 }
 
 static void U_CALLCONV
diff --git a/deps/icu-small/source/common/uinvchar.cpp b/deps/icu-small/source/common/uinvchar.cpp
index 52b8906568..ffce3ec158 100644
--- a/deps/icu-small/source/common/uinvchar.cpp
+++ b/deps/icu-small/source/common/uinvchar.cpp
@@ -207,7 +207,7 @@ u_UCharsToChars(const UChar *us, char *cs, int32_t length) {
     while(length>0) {
         u=*us++;
         if(!UCHAR_IS_INVARIANT(u)) {
-            U_ASSERT(FALSE); /* Variant characters were used. These are not portable in ICU. */
+            U_ASSERT(false); /* Variant characters were used. These are not portable in ICU. */
             u=0;
         }
         *cs++=(char)UCHAR_TO_CHAR(u);
@@ -245,18 +245,18 @@ uprv_isInvariantString(const char *s, int32_t length) {
          */
 #if U_CHARSET_FAMILY==U_ASCII_FAMILY
         if(!UCHAR_IS_INVARIANT(c)) {
-            return FALSE; /* found a variant char */
+            return false; /* found a variant char */
         }
 #elif U_CHARSET_FAMILY==U_EBCDIC_FAMILY
         c=CHAR_TO_UCHAR(c);
         if(c==0 || !UCHAR_IS_INVARIANT(c)) {
-            return FALSE; /* found a variant char */
+            return false; /* found a variant char */
         }
 #else
 #   error U_CHARSET_FAMILY is not valid
 #endif
     }
-    return TRUE;
+    return true;
 }
 
 U_CAPI UBool U_EXPORT2
@@ -284,10 +284,10 @@ uprv_isInvariantUString(const UChar *s, int32_t length) {
          * for strings with variant characters
          */
         if(!UCHAR_IS_INVARIANT(c)) {
-            return FALSE; /* found a variant char */
+            return false; /* found a variant char */
         }
     }
-    return TRUE;
+    return true;
 }
 
 /* UDataSwapFn implementations used in udataswp.c ------- */
diff --git a/deps/icu-small/source/common/uiter.cpp b/deps/icu-small/source/common/uiter.cpp
index b9252d81c2..c4ab7d6d56 100644
--- a/deps/icu-small/source/common/uiter.cpp
+++ b/deps/icu-small/source/common/uiter.cpp
@@ -47,7 +47,7 @@ noopMove(UCharIterator * /*iter*/, int32_t /*delta*/, UCharIteratorOrigin /*orig
 
 static UBool U_CALLCONV
 noopHasNext(UCharIterator * /*iter*/) {
-    return FALSE;
+    return false;
 }
 
 static UChar32 U_CALLCONV
@@ -678,24 +678,24 @@ utf8IteratorMove(UCharIterator *iter, int32_t delta, UCharIteratorOrigin origin)
     case UITER_ZERO:
     case UITER_START:
         pos=delta;
-        havePos=TRUE;
+        havePos=true;
         /* iter->index<0 (unknown) is possible */
         break;
     case UITER_CURRENT:
         if(iter->index>=0) {
             pos=iter->index+delta;
-            havePos=TRUE;
+            havePos=true;
         } else {
             /* the current UTF-16 index is unknown after setState(), use only delta */
             pos=0;
-            havePos=FALSE;
+            havePos=false;
         }
         break;
     case UITER_LIMIT:
     case UITER_LENGTH:
         if(iter->length>=0) {
             pos=iter->length+delta;
-            havePos=TRUE;
+            havePos=true;
         } else {
             /* pin to the end, avoid counting the length */
             iter->index=-1;
@@ -706,7 +706,7 @@ utf8IteratorMove(UCharIterator *iter, int32_t delta, UCharIteratorOrigin origin)
             } else {
                 /* the current UTF-16 index is unknown, use only delta */
                 pos=0;
-                havePos=FALSE;
+                havePos=false;
             }
         }
         break;
diff --git a/deps/icu-small/source/common/ulist.cpp b/deps/icu-small/source/common/ulist.cpp
index c5180431c3..57344715de 100644
--- a/deps/icu-small/source/common/ulist.cpp
+++ b/deps/icu-small/source/common/ulist.cpp
@@ -160,12 +160,12 @@ U_CAPI UBool U_EXPORT2 ulist_containsString(const UList *list, const char *data,
         for (pointer = list->head; pointer != NULL; pointer = pointer->next) {
             if (length == (int32_t)uprv_strlen((const char *)pointer->data)) {
                 if (uprv_memcmp(data, pointer->data, length) == 0) {
-                    return TRUE;
+                    return true;
                 }
             }
         }
     }
-    return FALSE;
+    return false;
 }
 
 U_CAPI UBool U_EXPORT2 ulist_removeString(UList *list, const char *data) {
@@ -175,11 +175,11 @@ U_CAPI UBool U_EXPORT2 ulist_removeString(UList *list, const char *data) {
             if (uprv_strcmp(data, (const char *)pointer->data) == 0) {
                 ulist_removeItem(list, pointer);
                 // Remove only the first occurrence, like Java LinkedList.remove(Object).
-                return TRUE;
+                return true;
             }
         }
     }
-    return FALSE;
+    return false;
 }
 
 U_CAPI void *U_EXPORT2 ulist_getNext(UList *list) {
diff --git a/deps/icu-small/source/common/uloc.cpp b/deps/icu-small/source/common/uloc.cpp
index 99c6a0af39..1da2abc361 100644
--- a/deps/icu-small/source/common/uloc.cpp
+++ b/deps/icu-small/source/common/uloc.cpp
@@ -102,7 +102,7 @@ static const char * const LANGUAGES[] = {
     "asa", "ase", "ast", "av",  "avk", "awa", "ay",  "az",
     "ba",  "bal", "ban", "bar", "bas", "bax", "bbc", "bbj",
     "be",  "bej", "bem", "bew", "bez", "bfd", "bfq", "bg",
-    "bgn", "bho", "bi",  "bik", "bin", "bjn", "bkm", "bla",
+    "bgc", "bgn", "bho", "bi",  "bik", "bin", "bjn", "bkm", "bla",
     "bm",  "bn",  "bo",  "bpy", "bqi", "br",  "bra", "brh",
     "brx", "bs",  "bss", "bua", "bug", "bum", "byn", "byv",
     "ca",  "cad", "car", "cay", "cch", "ccp", "ce",  "ceb", "cgg",
@@ -219,7 +219,7 @@ static const char * const LANGUAGES_3[] = {
     "asa", "ase", "ast", "ava", "avk", "awa", "aym", "aze",
     "bak", "bal", "ban", "bar", "bas", "bax", "bbc", "bbj",
     "bel", "bej", "bem", "bew", "bez", "bfd", "bfq", "bul",
-    "bgn", "bho", "bis", "bik", "bin", "bjn", "bkm", "bla",
+    "bgc", "bgn", "bho", "bis", "bik", "bin", "bjn", "bkm", "bla",
     "bam", "ben", "bod", "bpy", "bqi", "bre", "bra", "brh",
     "brx", "bos", "bss", "bua", "bug", "bum", "byn", "byv",
     "cat", "cad", "car", "cay", "cch", "ccp", "che", "ceb", "cgg",
@@ -502,20 +502,20 @@ static int32_t getShortestSubtagLength(const char *localeID) {
     int32_t length = localeIDLength;
     int32_t tmpLength = 0;
     int32_t i;
-    UBool reset = TRUE;
+    UBool reset = true;
 
     for (i = 0; i < localeIDLength; i++) {
         if (localeID[i] != '_' && localeID[i] != '-') {
             if (reset) {
                 tmpLength = 0;
-                reset = FALSE;
+                reset = false;
             }
             tmpLength++;
         } else {
             if (tmpLength != 0 && tmpLength < length) {
                 length = tmpLength;
             }
-            reset = TRUE;
+            reset = true;
         }
     }
 
@@ -620,7 +620,7 @@ ulocimp_getKeywords(const char *localeID,
     if(prev == '@') { /* start of keyword definition */
         /* we will grab pairs, trim spaces, lowercase keywords, sort and return */
         do {
-            UBool duplicate = FALSE;
+            UBool duplicate = false;
             /* skip leading spaces */
             while(*pos == ' ') {
                 pos++;
@@ -693,7 +693,7 @@ ulocimp_getKeywords(const char *localeID,
             /* If this is a duplicate keyword, then ignore it */
             for (j=0; j<numKeywords; ++j) {
                 if (uprv_strcmp(keywordList[j].keyword, keywordList[numKeywords].keyword) == 0) {
-                    duplicate = TRUE;
+                    duplicate = true;
                     break;
                 }
             }
@@ -704,7 +704,7 @@ ulocimp_getKeywords(const char *localeID,
 
         /* now we have a list of keywords */
         /* we need to sort it */
-        uprv_sortArray(keywordList, numKeywords, sizeof(KeywordStruct), compareKeywordStructs, NULL, FALSE, status);
+        uprv_sortArray(keywordList, numKeywords, sizeof(KeywordStruct), compareKeywordStructs, NULL, false, status);
 
         /* Now construct the keyword part */
         for(i = 0; i < numKeywords; i++) {
@@ -881,7 +881,7 @@ uloc_setKeywordValue(const char* keywordName,
     char* startSearchHere = NULL;
     char* keywordStart = NULL;
     CharString updatedKeysAndValues;
-    UBool handledInputKeyAndValue = FALSE;
+    UBool handledInputKeyAndValue = false;
     char keyValuePrefix = '@';
 
     if(U_FAILURE(*status)) {
@@ -1020,7 +1020,7 @@ uloc_setKeywordValue(const char* keywordName,
                 updatedKeysAndValues.append('=', *status);
                 updatedKeysAndValues.append(keywordValueBuffer, keywordValueLen, *status);
             } /* else removing this entry, don't emit anything */
-            handledInputKeyAndValue = TRUE;
+            handledInputKeyAndValue = true;
         } else {
            /* input keyword sorts earlier than current entry, add before current entry */
             if (rc < 0 && keywordValueLen > 0 && !handledInputKeyAndValue) {
@@ -1030,7 +1030,7 @@ uloc_setKeywordValue(const char* keywordName,
                 updatedKeysAndValues.append(keywordNameBuffer, keywordNameLen, *status);
                 updatedKeysAndValues.append('=', *status);
                 updatedKeysAndValues.append(keywordValueBuffer, keywordValueLen, *status);
-                handledInputKeyAndValue = TRUE;
+                handledInputKeyAndValue = true;
             }
             /* copy the current entry */
             updatedKeysAndValues.append(keyValuePrefix, *status);
@@ -1046,7 +1046,7 @@ uloc_setKeywordValue(const char* keywordName,
             updatedKeysAndValues.append(keywordNameBuffer, keywordNameLen, *status);
             updatedKeysAndValues.append('=', *status);
             updatedKeysAndValues.append(keywordValueBuffer, keywordValueLen, *status);
-            handledInputKeyAndValue = TRUE;
+            handledInputKeyAndValue = true;
         }
         keywordStart = nextSeparator;
     } /* end loop searching */
@@ -1089,7 +1089,7 @@ uloc_setKeywordValue(const char* keywordName,
 
 #define _isPrefixLetter(a) ((a=='x')||(a=='X')||(a=='i')||(a=='I'))
 
-/*returns TRUE if one of the special prefixes is here (s=string)
+/*returns true if one of the special prefixes is here (s=string)
   'x-' or 'i-' */
 #define _isIDPrefix(s) (_isPrefixLetter(s[0])&&_isIDSeparator(s[1]))
 
@@ -1270,7 +1270,7 @@ _getVariant(const char *localeID,
             char prev,
             ByteSink& sink,
             UBool needSeparator) {
-    UBool hasVariant = FALSE;
+    UBool hasVariant = false;
 
     /* get one or more variant tags and separate them with '_' */
     if(_isIDSeparator(prev)) {
@@ -1278,12 +1278,12 @@ _getVariant(const char *localeID,
         while(!_isTerminator(*localeID)) {
             if (needSeparator) {
                 sink.Append("_", 1);
-                needSeparator = FALSE;
+                needSeparator = false;
             }
             char c = (char)uprv_toupper(*localeID);
             if (c == '-') c = '_';
             sink.Append(&c, 1);
-            hasVariant = TRUE;
+            hasVariant = true;
             localeID++;
         }
     }
@@ -1300,7 +1300,7 @@ _getVariant(const char *localeID,
         while(!_isTerminator(*localeID)) {
             if (needSeparator) {
                 sink.Append("_", 1);
-                needSeparator = FALSE;
+                needSeparator = false;
             }
             char c = (char)uprv_toupper(*localeID);
             if (c == '-' || c == ',') c = '_';
@@ -1453,7 +1453,7 @@ uloc_openKeywords(const char* localeID,
     if((tmpLocaleID = locale_getKeywordsStart(tmpLocaleID)) != NULL) {
         CharString keywords;
         CharStringByteSink sink(&keywords);
-        ulocimp_getKeywords(tmpLocaleID+1, '@', sink, FALSE, status);
+        ulocimp_getKeywords(tmpLocaleID+1, '@', sink, false, status);
         if (U_FAILURE(*status)) {
             return NULL;
         }
@@ -1573,7 +1573,7 @@ _canonicalize(const char* localeID,
                 variantSize = -tag.length();
                 {
                     CharStringByteSink s(&tag);
-                    _getVariant(tmpLocaleID+1, *tmpLocaleID, s, FALSE);
+                    _getVariant(tmpLocaleID+1, *tmpLocaleID, s, false);
                 }
                 variantSize += tag.length();
                 if (variantSize > 0) {
@@ -1585,13 +1585,13 @@ _canonicalize(const char* localeID,
 
     /* Copy POSIX-style charset specifier, if any [mr.utf8] */
     if (!OPTION_SET(options, _ULOC_CANONICALIZE) && *tmpLocaleID == '.') {
-        UBool done = FALSE;
+        UBool done = false;
         do {
             char c = *tmpLocaleID;
             switch (c) {
             case 0:
             case '@':
-                done = TRUE;
+                done = true;
                 break;
             default:
                 tag.append(c, *err);
@@ -1664,7 +1664,7 @@ _canonicalize(const char* localeID,
             (!separatorIndicator || separatorIndicator > keywordAssign)) {
             sink.Append("@", 1);
             ++fieldCount;
-            ulocimp_getKeywords(tmpLocaleID+1, '@', sink, TRUE, err);
+            ulocimp_getKeywords(tmpLocaleID+1, '@', sink, true, err);
         }
     }
 }
@@ -1847,7 +1847,7 @@ uloc_getVariant(const char* localeID,
                 }
 
                 CheckedArrayByteSink sink(variant, variantCapacity);
-                _getVariant(tmpLocaleID+1, *tmpLocaleID, sink, FALSE);
+                _getVariant(tmpLocaleID+1, *tmpLocaleID, sink, false);
 
                 i = sink.NumberOfBytesAppended();
 
@@ -2158,11 +2158,11 @@ isWellFormedLegacyKey(const char* legacyKey)
     const char* p = legacyKey;
     while (*p) {
         if (!UPRV_ISALPHANUM(*p)) {
-            return FALSE;
+            return false;
         }
         p++;
     }
-    return TRUE;
+    return true;
 }
 
 static UBool
@@ -2173,13 +2173,13 @@ isWellFormedLegacyType(const char* legacyType)
     while (*p) {
         if (*p == '_' || *p == '/' || *p == '-') {
             if (alphaNumLen == 0) {
-                return FALSE;
+                return false;
             }
             alphaNumLen = 0;
         } else if (UPRV_ISALPHANUM(*p)) {
             alphaNumLen++;
         } else {
-            return FALSE;
+            return false;
         }
         p++;
     }
diff --git a/deps/icu-small/source/common/uloc_keytype.cpp b/deps/icu-small/source/common/uloc_keytype.cpp
index 580244124e..12dc300492 100644
--- a/deps/icu-small/source/common/uloc_keytype.cpp
+++ b/deps/icu-small/source/common/uloc_keytype.cpp
@@ -24,7 +24,7 @@
 #include "udataswp.h" /* for InvChar functions */
 
 static UHashtable* gLocExtKeyMap = NULL;
-static icu::UInitOnce gLocExtKeyMapInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gLocExtKeyMapInitOnce {};
 
 // bit flags for special types
 typedef enum {
@@ -69,7 +69,7 @@ uloc_key_type_cleanup(void) {
     gKeyTypeStringPool = NULL;
 
     gLocExtKeyMapInitOnce.reset();
-    return TRUE;
+    return true;
 }
 
 U_CDECL_END
@@ -356,9 +356,9 @@ init() {
     UErrorCode sts = U_ZERO_ERROR;
     umtx_initOnce(gLocExtKeyMapInitOnce, &initFromResourceBundle, sts);
     if (U_FAILURE(sts)) {
-        return FALSE;
+        return false;
     }
-    return TRUE;
+    return true;
 }
 
 static UBool
@@ -368,7 +368,7 @@ isSpecialTypeCodepoints(const char* val) {
     while (*p) {
         if (*p == '-') {
             if (subtagLen < 4 || subtagLen > 6) {
-                return FALSE;
+                return false;
             }
             subtagLen = 0;
         } else if ((*p >= '0' && *p <= '9') ||
@@ -376,7 +376,7 @@ isSpecialTypeCodepoints(const char* val) {
                     (*p >= 'a' && *p <= 'f')) { // also in EBCDIC
             subtagLen++;
         } else {
-            return FALSE;
+            return false;
         }
         p++;
     }
@@ -390,13 +390,13 @@ isSpecialTypeReorderCode(const char* val) {
     while (*p) {
         if (*p == '-') {
             if (subtagLen < 3 || subtagLen > 8) {
-                return FALSE;
+                return false;
             }
             subtagLen = 0;
         } else if (uprv_isASCIILetter(*p)) {
             subtagLen++;
         } else {
-            return FALSE;
+            return false;
         }
         p++;
     }
@@ -412,7 +412,7 @@ isSpecialTypeRgKeyValue(const char* val) {
                     (subtagLen >= 2 && (*p == 'Z' || *p == 'z')) ) {
             subtagLen++;
         } else {
-            return FALSE;
+            return false;
         }
         p++;
     }
@@ -448,10 +448,10 @@ ulocimp_toLegacyKey(const char* key) {
 U_CFUNC const char*
 ulocimp_toBcpType(const char* key, const char* type, UBool* isKnownKey, UBool* isSpecialType) {
     if (isKnownKey != NULL) {
-        *isKnownKey = FALSE;
+        *isKnownKey = false;
     }
     if (isSpecialType != NULL) {
-        *isSpecialType = FALSE;
+        *isSpecialType = false;
     }
 
     if (!init()) {
@@ -461,14 +461,14 @@ ulocimp_toBcpType(const char* key, const char* type, UBool* isKnownKey, UBool* i
     LocExtKeyData* keyData = (LocExtKeyData*)uhash_get(gLocExtKeyMap, key);
     if (keyData != NULL) {
         if (isKnownKey != NULL) {
-            *isKnownKey = TRUE;
+            *isKnownKey = true;
         }
         LocExtType* t = (LocExtType*)uhash_get(keyData->typeMap.getAlias(), type);
         if (t != NULL) {
             return t->bcpId;
         }
         if (keyData->specialTypes != SPECIALTYPE_NONE) {
-            UBool matched = FALSE;
+            UBool matched = false;
             if (keyData->specialTypes & SPECIALTYPE_CODEPOINTS) {
                 matched = isSpecialTypeCodepoints(type);
             }
@@ -480,7 +480,7 @@ ulocimp_toBcpType(const char* key, const char* type, UBool* isKnownKey, UBool* i
             }
             if (matched) {
                 if (isSpecialType != NULL) {
-                    *isSpecialType = TRUE;
+                    *isSpecialType = true;
                 }
                 return type;
             }
@@ -493,10 +493,10 @@ ulocimp_toBcpType(const char* key, const char* type, UBool* isKnownKey, UBool* i
 U_CFUNC const char*
 ulocimp_toLegacyType(const char* key, const char* type, UBool* isKnownKey, UBool* isSpecialType) {
     if (isKnownKey != NULL) {
-        *isKnownKey = FALSE;
+        *isKnownKey = false;
     }
     if (isSpecialType != NULL) {
-        *isSpecialType = FALSE;
+        *isSpecialType = false;
     }
 
     if (!init()) {
@@ -506,14 +506,14 @@ ulocimp_toLegacyType(const char* key, const char* type, UBool* isKnownKey, UBool
     LocExtKeyData* keyData = (LocExtKeyData*)uhash_get(gLocExtKeyMap, key);
     if (keyData != NULL) {
         if (isKnownKey != NULL) {
-            *isKnownKey = TRUE;
+            *isKnownKey = true;
         }
         LocExtType* t = (LocExtType*)uhash_get(keyData->typeMap.getAlias(), type);
         if (t != NULL) {
             return t->legacyId;
         }
         if (keyData->specialTypes != SPECIALTYPE_NONE) {
-            UBool matched = FALSE;
+            UBool matched = false;
             if (keyData->specialTypes & SPECIALTYPE_CODEPOINTS) {
                 matched = isSpecialTypeCodepoints(type);
             }
@@ -525,7 +525,7 @@ ulocimp_toLegacyType(const char* key, const char* type, UBool* isKnownKey, UBool
             }
             if (matched) {
                 if (isSpecialType != NULL) {
-                    *isSpecialType = TRUE;
+                    *isSpecialType = true;
                 }
                 return type;
             }
diff --git a/deps/icu-small/source/common/uloc_tag.cpp b/deps/icu-small/source/common/uloc_tag.cpp
index 0150e94cef..01a0e0028f 100644
--- a/deps/icu-small/source/common/uloc_tag.cpp
+++ b/deps/icu-small/source/common/uloc_tag.cpp
@@ -378,10 +378,10 @@ _isAlphaString(const char* s, int32_t len) {
     int32_t i;
     for (i = 0; i < len; i++) {
         if (!ISALPHA(*(s + i))) {
-            return FALSE;
+            return false;
         }
     }
-    return TRUE;
+    return true;
 }
 
 static UBool
@@ -389,10 +389,10 @@ _isNumericString(const char* s, int32_t len) {
     int32_t i;
     for (i = 0; i < len; i++) {
         if (!ISNUMERIC(*(s + i))) {
-            return FALSE;
+            return false;
         }
     }
-    return TRUE;
+    return true;
 }
 
 static UBool
@@ -400,10 +400,10 @@ _isAlphaNumericString(const char* s, int32_t len) {
     int32_t i;
     for (i = 0; i < len; i++) {
         if (!ISALPHA(*(s + i)) && !ISNUMERIC(*(s + i))) {
-            return FALSE;
+            return false;
         }
     }
-    return TRUE;
+    return true;
 }
 
 static UBool
@@ -412,9 +412,9 @@ _isAlphaNumericStringLimitedLength(const char* s, int32_t len, int32_t min, int3
         len = (int32_t)uprv_strlen(s);
     }
     if (len >= min && len <= max && _isAlphaNumericString(s, len)) {
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 U_CFUNC UBool
@@ -428,9 +428,9 @@ ultag_isLanguageSubtag(const char* s, int32_t len) {
         len = (int32_t)uprv_strlen(s);
     }
     if (len >= 2 && len <= 8 && _isAlphaString(s, len)) {
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 static UBool
@@ -443,9 +443,9 @@ _isExtlangSubtag(const char* s, int32_t len) {
         len = (int32_t)uprv_strlen(s);
     }
     if (len == 3 && _isAlphaString(s, len)) {
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 U_CFUNC UBool
@@ -457,9 +457,9 @@ ultag_isScriptSubtag(const char* s, int32_t len) {
         len = (int32_t)uprv_strlen(s);
     }
     if (len == 4 && _isAlphaString(s, len)) {
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 U_CFUNC UBool
@@ -472,12 +472,12 @@ ultag_isRegionSubtag(const char* s, int32_t len) {
         len = (int32_t)uprv_strlen(s);
     }
     if (len == 2 && _isAlphaString(s, len)) {
-        return TRUE;
+        return true;
     }
     if (len == 3 && _isNumericString(s, len)) {
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 static UBool
@@ -490,12 +490,12 @@ _isVariantSubtag(const char* s, int32_t len) {
         len = (int32_t)uprv_strlen(s);
     }
     if (_isAlphaNumericStringLimitedLength(s, len, 5, 8)) {
-        return TRUE;
+        return true;
     }
     if (len == 4 && ISNUMERIC(*s) && _isAlphaNumericString(s + 1, 3)) {
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 static UBool
@@ -510,10 +510,10 @@ _isSepListOf(UBool (*test)(const char*, int32_t), const char* s, int32_t len) {
     while ((p - s) < len) {
         if (*p == SEP) {
             if (pSubtag == NULL) {
-                return FALSE;
+                return false;
             }
             if (!test(pSubtag, (int32_t)(p - pSubtag))) {
-                return FALSE;
+                return false;
             }
             pSubtag = NULL;
         } else if (pSubtag == NULL) {
@@ -522,7 +522,7 @@ _isSepListOf(UBool (*test)(const char*, int32_t), const char* s, int32_t len) {
         p++;
     }
     if (pSubtag == NULL) {
-        return FALSE;
+        return false;
     }
     return test(pSubtag, (int32_t)(p - pSubtag));
 }
@@ -557,9 +557,9 @@ _isExtensionSingleton(const char* s, int32_t len) {
         len = (int32_t)uprv_strlen(s);
     }
     if (len == 1 && (ISALPHA(*s) || ISNUMERIC(*s)) && (uprv_tolower(*s) != PRIVATEUSE)) {
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 static UBool
@@ -610,9 +610,9 @@ ultag_isUnicodeLocaleKey(const char* s, int32_t len) {
         len = (int32_t)uprv_strlen(s);
     }
     if (len == 2 && (ISALPHA(*s) || ISNUMERIC(*s)) && ISALPHA(s[1])) {
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 U_CFUNC UBool
@@ -641,9 +641,9 @@ _isTKey(const char* s, int32_t len)
         len = (int32_t)uprv_strlen(s);
     }
     if (len == 2 && ISALPHA(*s) && ISNUMERIC(*(s + 1))) {
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 U_CAPI const char * U_EXPORT2
@@ -694,23 +694,23 @@ _isTransformedExtensionSubtag(int32_t& state, const char* s, int32_t len)
         case kStart:
             if (ultag_isLanguageSubtag(s, len) && len != 4) {
                 state = kGotLanguage;
-                return TRUE;
+                return true;
             }
             if (_isTKey(s, len)) {
                 state = kGotTKey;
-                return TRUE;
+                return true;
             }
-            return FALSE;
+            return false;
         case kGotLanguage:
             if (ultag_isScriptSubtag(s, len)) {
                 state = kGotScript;
-                return TRUE;
+                return true;
             }
             U_FALLTHROUGH;
         case kGotScript:
             if (ultag_isRegionSubtag(s, len)) {
                 state = kGotRegion;
-                return TRUE;
+                return true;
             }
             U_FALLTHROUGH;
         case kGotRegion:
@@ -718,30 +718,30 @@ _isTransformedExtensionSubtag(int32_t& state, const char* s, int32_t len)
         case kGotVariant:
             if (_isVariantSubtag(s, len)) {
                 state = kGotVariant;
-                return TRUE;
+                return true;
             }
             if (_isTKey(s, len)) {
                 state = kGotTKey;
-                return TRUE;
+                return true;
             }
-            return FALSE;
+            return false;
         case kGotTKey:
             if (_isTValue(s, len)) {
                 state = kGotTValue;
-                return TRUE;
+                return true;
             }
-            return FALSE;
+            return false;
         case kGotTValue:
             if (_isTKey(s, len)) {
                 state = kGotTKey;
-                return TRUE;
+                return true;
             }
             if (_isTValue(s, len)) {
-                return TRUE;
+                return true;
             }
-            return FALSE;
+            return false;
     }
-    return FALSE;
+    return false;
 }
 
 static UBool
@@ -755,32 +755,32 @@ _isUnicodeExtensionSubtag(int32_t& state, const char* s, int32_t len)
         case kStart:
             if (ultag_isUnicodeLocaleKey(s, len)) {
                 state = kGotKey;
-                return TRUE;
+                return true;
             }
             if (ultag_isUnicodeLocaleAttribute(s, len)) {
-                return TRUE;
+                return true;
             }
-            return FALSE;
+            return false;
         case kGotKey:
             if (ultag_isUnicodeLocaleKey(s, len)) {
-                return TRUE;
+                return true;
             }
             if (_isUnicodeLocaleTypeSubtag(s, len)) {
                 state = kGotType;
-                return TRUE;
+                return true;
             }
-            return FALSE;
+            return false;
         case kGotType:
             if (ultag_isUnicodeLocaleKey(s, len)) {
                 state = kGotKey;
-                return TRUE;
+                return true;
             }
             if (_isUnicodeLocaleTypeSubtag(s, len)) {
-                return TRUE;
+                return true;
             }
-            return FALSE;
+            return false;
     }
-    return FALSE;
+    return false;
 }
 
 static UBool
@@ -798,7 +798,7 @@ _isStatefulSepListOf(UBool (*test)(int32_t&, const char*, int32_t), const char*
     for (p = s; len > 0; p++, len--) {
         if (*p == SEP) {
             if (!test(state, start, subtagLen)) {
-                return FALSE;
+                return false;
             }
             subtagLen = 0;
             start = p + 1;
@@ -808,9 +808,9 @@ _isStatefulSepListOf(UBool (*test)(int32_t&, const char*, int32_t), const char*
     }
 
     if (test(state, start, subtagLen) && state >= 0) {
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 U_CFUNC UBool
@@ -835,7 +835,7 @@ ultag_isUnicodeExtensionSubtags(const char* s, int32_t len) {
 
 static UBool
 _addVariantToList(VariantListEntry **first, VariantListEntry *var) {
-    UBool bAdded = TRUE;
+    UBool bAdded = true;
 
     if (*first == NULL) {
         var->next = NULL;
@@ -847,7 +847,7 @@ _addVariantToList(VariantListEntry **first, VariantListEntry *var) {
         /* variants order should be preserved */
         prev = NULL;
         cur = *first;
-        while (TRUE) {
+        while (true) {
             if (cur == NULL) {
                 prev->next = var;
                 var->next = NULL;
@@ -858,7 +858,7 @@ _addVariantToList(VariantListEntry **first, VariantListEntry *var) {
             cmp = uprv_compareInvCharsAsAscii(var->variant, cur->variant);
             if (cmp == 0) {
                 /* duplicated variant */
-                bAdded = FALSE;
+                bAdded = false;
                 break;
             }
             prev = cur;
@@ -871,7 +871,7 @@ _addVariantToList(VariantListEntry **first, VariantListEntry *var) {
 
 static UBool
 _addAttributeToList(AttributeListEntry **first, AttributeListEntry *attr) {
-    UBool bAdded = TRUE;
+    UBool bAdded = true;
 
     if (*first == NULL) {
         attr->next = NULL;
@@ -883,7 +883,7 @@ _addAttributeToList(AttributeListEntry **first, AttributeListEntry *attr) {
         /* reorder variants in alphabetical order */
         prev = NULL;
         cur = *first;
-        while (TRUE) {
+        while (true) {
             if (cur == NULL) {
                 prev->next = attr;
                 attr->next = NULL;
@@ -901,7 +901,7 @@ _addAttributeToList(AttributeListEntry **first, AttributeListEntry *attr) {
             }
             if (cmp == 0) {
                 /* duplicated variant */
-                bAdded = FALSE;
+                bAdded = false;
                 break;
             }
             prev = cur;
@@ -915,7 +915,7 @@ _addAttributeToList(AttributeListEntry **first, AttributeListEntry *attr) {
 
 static UBool
 _addExtensionToList(ExtensionListEntry **first, ExtensionListEntry *ext, UBool localeToBCP) {
-    UBool bAdded = TRUE;
+    UBool bAdded = true;
 
     if (*first == NULL) {
         ext->next = NULL;
@@ -927,7 +927,7 @@ _addExtensionToList(ExtensionListEntry **first, ExtensionListEntry *ext, UBool l
         /* reorder variants in alphabetical order */
         prev = NULL;
         cur = *first;
-        while (TRUE) {
+        while (true) {
             if (cur == NULL) {
                 prev->next = ext;
                 ext->next = NULL;
@@ -979,7 +979,7 @@ _addExtensionToList(ExtensionListEntry **first, ExtensionListEntry *ext, UBool l
             }
             if (cmp == 0) {
                 /* duplicated extension key */
-                bAdded = FALSE;
+                bAdded = false;
                 break;
             }
             prev = cur;
@@ -1164,7 +1164,7 @@ _appendVariantsToLanguageTag(const char* localeID, icu::ByteSink& sink, UBool st
 
     if (len > 0) {
         char *p, *pVar;
-        UBool bNext = TRUE;
+        UBool bNext = true;
         VariantListEntry *var;
         VariantListEntry *varFirst = NULL;
 
@@ -1173,7 +1173,7 @@ _appendVariantsToLanguageTag(const char* localeID, icu::ByteSink& sink, UBool st
         while (bNext) {
             if (*p == SEP || *p == LOCALE_SEP || *p == 0) {
                 if (*p == 0) {
-                    bNext = FALSE;
+                    bNext = false;
                 } else {
                     *p = 0; /* terminate */
                 }
@@ -1211,7 +1211,7 @@ _appendVariantsToLanguageTag(const char* localeID, icu::ByteSink& sink, UBool st
                         } else {
                             /* Special handling for POSIX variant, need to remember that we had it and then */
                             /* treat it like an extension later. */
-                            *hadPosix = TRUE;
+                            *hadPosix = true;
                         }
                     } else if (strict) {
                         *status = U_ILLEGAL_ARGUMENT_ERROR;
@@ -1288,7 +1288,7 @@ _appendKeywordsToLanguageTag(const char* localeID, icu::ByteSink& sink, UBool st
         int32_t keylen;
         UBool isBcpUExt;
 
-        while (TRUE) {
+        while (true) {
             key = uenum_next(keywordEnum.getAlias(), NULL, status);
             if (key == NULL) {
                 break;
@@ -1322,7 +1322,7 @@ _appendKeywordsToLanguageTag(const char* localeID, icu::ByteSink& sink, UBool st
             if (uprv_strcmp(key, LOCALE_ATTRIBUTE_KEY) == 0) {
                 if (len > 0) {
                     int32_t i = 0;
-                    while (TRUE) {
+                    while (true) {
                         attrBufLength = 0;
                         for (; i < len; i++) {
                             if (buf[i] != '-') {
@@ -1448,7 +1448,7 @@ _appendKeywordsToLanguageTag(const char* localeID, icu::ByteSink& sink, UBool st
             ext->key = bcpKey;
             ext->value = bcpValue;
 
-            if (!_addExtensionToList(&firstExt, ext, TRUE)) {
+            if (!_addExtensionToList(&firstExt, ext, true)) {
                 if (strict) {
                     *status = U_ILLEGAL_ARGUMENT_ERROR;
                     break;
@@ -1467,18 +1467,18 @@ _appendKeywordsToLanguageTag(const char* localeID, icu::ByteSink& sink, UBool st
             ext->key = POSIX_KEY;
             ext->value = POSIX_VALUE;
 
-            if (!_addExtensionToList(&firstExt, ext, TRUE)) {
+            if (!_addExtensionToList(&firstExt, ext, true)) {
                 // Silently ignore errors.
             }
         }
 
         if (U_SUCCESS(*status) && (firstExt != NULL || firstAttr != NULL)) {
-            UBool startLDMLExtension = FALSE;
+            UBool startLDMLExtension = false;
             for (ext = firstExt; ext; ext = ext->next) {
                 if (!startLDMLExtension && uprv_strlen(ext->key) > 1) {
                     /* first LDML u singlton extension */
                    sink.Append("-u", 2);
-                   startLDMLExtension = TRUE;
+                   startLDMLExtension = true;
                 }
 
                 /* write out the sorted BCP47 attributes, extensions and private use */
@@ -1520,7 +1520,7 @@ _appendLDMLExtensionAsKeywords(const char* ldmlext, ExtensionListEntry** appendT
     int32_t len;
 
     /* Reset the posixVariant value */
-    *posixVariant = FALSE;
+    *posixVariant = false;
 
     pTag = ldmlext;
     pKwds = NULL;
@@ -1604,7 +1604,7 @@ _appendLDMLExtensionAsKeywords(const char* ldmlext, ExtensionListEntry** appendT
             kwd->key = LOCALE_ATTRIBUTE_KEY;
             kwd->value = value->data();
 
-            if (!_addExtensionToList(&kwdFirst, kwd, FALSE)) {
+            if (!_addExtensionToList(&kwdFirst, kwd, false)) {
                 *status = U_ILLEGAL_ARGUMENT_ERROR;
                 return;
             }
@@ -1616,14 +1616,14 @@ _appendLDMLExtensionAsKeywords(const char* ldmlext, ExtensionListEntry** appendT
         const char *pBcpType = NULL;    /* beginning of u extension type subtag(s) */
         int32_t bcpKeyLen = 0;
         int32_t bcpTypeLen = 0;
-        UBool isDone = FALSE;
+        UBool isDone = false;
 
         pTag = pKwds;
         /* BCP47 representation of LDML key/type pairs */
         while (!isDone) {
             const char *pNextBcpKey = NULL;
             int32_t nextBcpKeyLen = 0;
-            UBool emitKeyword = FALSE;
+            UBool emitKeyword = false;
 
             if (*pTag) {
                 /* locate next separator char */
@@ -1631,7 +1631,7 @@ _appendLDMLExtensionAsKeywords(const char* ldmlext, ExtensionListEntry** appendT
 
                 if (ultag_isUnicodeLocaleKey(pTag, len)) {
                     if (pBcpKey) {
-                        emitKeyword = TRUE;
+                        emitKeyword = true;
                         pNextBcpKey = pTag;
                         nextBcpKeyLen = len;
                     } else {
@@ -1657,8 +1657,8 @@ _appendLDMLExtensionAsKeywords(const char* ldmlext, ExtensionListEntry** appendT
                 }
             } else {
                 /* processing last one */
-                emitKeyword = TRUE;
-                isDone = TRUE;
+                emitKeyword = true;
+                isDone = true;
             }
 
             if (emitKeyword) {
@@ -1744,7 +1744,7 @@ _appendLDMLExtensionAsKeywords(const char* ldmlext, ExtensionListEntry** appendT
                 /* Special handling for u-va-posix, since we want to treat this as a variant, 
                    not as a keyword */
                 if (!variantExists && !uprv_strcmp(pKey, POSIX_KEY) && !uprv_strcmp(pType, POSIX_VALUE) ) {
-                    *posixVariant = TRUE;
+                    *posixVariant = true;
                 } else {
                     /* create an ExtensionListEntry for this keyword */
                     kwd = extPool.create();
@@ -1756,7 +1756,7 @@ _appendLDMLExtensionAsKeywords(const char* ldmlext, ExtensionListEntry** appendT
                     kwd->key = pKey;
                     kwd->value = pType;
 
-                    if (!_addExtensionToList(&kwdFirst, kwd, FALSE)) {
+                    if (!_addExtensionToList(&kwdFirst, kwd, false)) {
                         // duplicate keyword is allowed, Only the first
                         // is honored.
                     }
@@ -1773,7 +1773,7 @@ _appendLDMLExtensionAsKeywords(const char* ldmlext, ExtensionListEntry** appendT
     kwd = kwdFirst;
     while (kwd != NULL) {
         nextKwd = kwd->next;
-        _addExtensionToList(appendTo, kwd, FALSE);
+        _addExtensionToList(appendTo, kwd, false);
         kwd = nextKwd;
     }
 }
@@ -1788,7 +1788,7 @@ _appendKeywords(ULanguageTag* langtag, icu::ByteSink& sink, UErrorCode* status)
     const char *key, *type;
     icu::MemoryPool<ExtensionListEntry> extPool;
     icu::MemoryPool<icu::CharString> kwdBuf;
-    UBool posixVariant = FALSE;
+    UBool posixVariant = false;
 
     if (U_FAILURE(*status)) {
         return;
@@ -1803,7 +1803,7 @@ _appendKeywords(ULanguageTag* langtag, icu::ByteSink& sink, UErrorCode* status)
         if (*key == LDMLEXT) {
             /* Determine if variants already exists */
             if (ultag_getVariantsSize(langtag)) {
-                posixVariant = TRUE;
+                posixVariant = true;
             }
 
             _appendLDMLExtensionAsKeywords(type, &kwdFirst, extPool, kwdBuf, &posixVariant, status);
@@ -1818,7 +1818,7 @@ _appendKeywords(ULanguageTag* langtag, icu::ByteSink& sink, UErrorCode* status)
             }
             kwd->key = key;
             kwd->value = type;
-            if (!_addExtensionToList(&kwdFirst, kwd, FALSE)) {
+            if (!_addExtensionToList(&kwdFirst, kwd, false)) {
                 *status = U_ILLEGAL_ARGUMENT_ERROR;
                 break;
             }
@@ -1835,7 +1835,7 @@ _appendKeywords(ULanguageTag* langtag, icu::ByteSink& sink, UErrorCode* status)
             } else {
                 kwd->key = PRIVATEUSE_KEY;
                 kwd->value = type;
-                if (!_addExtensionToList(&kwdFirst, kwd, FALSE)) {
+                if (!_addExtensionToList(&kwdFirst, kwd, false)) {
                     *status = U_ILLEGAL_ARGUMENT_ERROR;
                 }
             }
@@ -1851,12 +1851,12 @@ _appendKeywords(ULanguageTag* langtag, icu::ByteSink& sink, UErrorCode* status)
 
     if (U_SUCCESS(*status) && kwdFirst != NULL) {
         /* write out the sorted keywords */
-        UBool firstValue = TRUE;
+        UBool firstValue = true;
         kwd = kwdFirst;
         do {
             if (firstValue) {
                 sink.Append("@", 1);
-                firstValue = FALSE;
+                firstValue = false;
             } else {
                 sink.Append(";", 1);
             }
@@ -1899,17 +1899,17 @@ _appendPrivateuseToLanguageTag(const char* localeID, icu::ByteSink& sink, UBool
 
     if (len > 0) {
         char *p, *pPriv;
-        UBool bNext = TRUE;
-        UBool firstValue = TRUE;
+        UBool bNext = true;
+        UBool firstValue = true;
         UBool writeValue;
 
         pPriv = NULL;
         p = buf;
         while (bNext) {
-            writeValue = FALSE;
+            writeValue = false;
             if (*p == SEP || *p == LOCALE_SEP || *p == 0) {
                 if (*p == 0) {
-                    bNext = FALSE;
+                    bNext = false;
                 } else {
                     *p = 0; /* terminate */
                 }
@@ -1923,10 +1923,10 @@ _appendPrivateuseToLanguageTag(const char* localeID, icu::ByteSink& sink, UBool
                     if (_isPrivateuseValueSubtag(pPriv, -1)) {
                         if (firstValue) {
                             if (!_isVariantSubtag(pPriv, -1)) {
-                                writeValue = TRUE;
+                                writeValue = true;
                             }
                         } else {
-                            writeValue = TRUE;
+                            writeValue = true;
                         }
                     } else if (strict) {
                         *status = U_ILLEGAL_ARGUMENT_ERROR;
@@ -1959,7 +1959,7 @@ _appendPrivateuseToLanguageTag(const char* localeID, icu::ByteSink& sink, UBool
                                 tmpAppend[reslen++] = SEP;
                             }
 
-                            firstValue = FALSE;
+                            firstValue = false;
                         }
 
                         len = (int32_t)uprv_strlen(pPriv);
@@ -2026,7 +2026,7 @@ ultag_parse(const char* tag, int32_t tagLen, int32_t* parsedLen, UErrorCode* sta
     ExtensionListEntry *pExtension;
     char *pExtValueSubtag, *pExtValueSubtagEnd;
     int32_t i;
-    UBool privateuseVar = FALSE;
+    UBool privateuseVar = false;
     int32_t legacyLen = 0;
 
     if (parsedLen != NULL) {
@@ -2124,7 +2124,7 @@ ultag_parse(const char* tag, int32_t tagLen, int32_t* parsedLen, UErrorCode* sta
                 if (*redundantTagEnd  == '\0' || *redundantTagEnd == SEP) {
                     const char* preferredTag = REDUNDANT[i + 1];
                     size_t preferredTagLen = uprv_strlen(preferredTag);
-                    uprv_strncpy(t->buf, preferredTag, preferredTagLen);
+                    uprv_memcpy(t->buf, preferredTag, preferredTagLen);
                     if (*redundantTagEnd == SEP) {
                         uprv_memmove(tagBuf + preferredTagLen,
                                      redundantTagEnd,
@@ -2276,7 +2276,7 @@ ultag_parse(const char* tag, int32_t tagLen, int32_t* parsedLen, UErrorCode* sta
                     pExtension->value = T_CString_toLowerCase(pExtValueSubtag);
 
                     /* insert the extension to the list */
-                    if (_addExtensionToList(&(t->extensions), pExtension, FALSE)) {
+                    if (_addExtensionToList(&(t->extensions), pExtension, false)) {
                         pLastGoodPosition = pExtValueSubtagEnd;
                     } else {
                         /* stop parsing here */
@@ -2339,7 +2339,7 @@ ultag_parse(const char* tag, int32_t tagLen, int32_t* parsedLen, UErrorCode* sta
                         pExtension->value = T_CString_toLowerCase(pExtValueSubtag);
 
                         /* insert the extension to the list */
-                        if (_addExtensionToList(&(t->extensions), pExtension, FALSE)) {
+                        if (_addExtensionToList(&(t->extensions), pExtension, false)) {
                             pLastGoodPosition = pExtValueSubtagEnd;
                             pExtension = NULL;
                         } else {
@@ -2380,7 +2380,7 @@ ultag_parse(const char* tag, int32_t tagLen, int32_t* parsedLen, UErrorCode* sta
                     if (uprv_strncmp(pSubtag, PRIVUSE_VARIANT_PREFIX, uprv_strlen(PRIVUSE_VARIANT_PREFIX)) == 0) {
                         *pSep = 0;
                         next = VART;
-                        privateuseVar = TRUE;
+                        privateuseVar = true;
                         break;
                     } else if (_isPrivateuseValueSubtag(pSubtag, subtagLen)) {
                         pLastGoodPosition = pSep;
@@ -2417,7 +2417,7 @@ ultag_parse(const char* tag, int32_t tagLen, int32_t* parsedLen, UErrorCode* sta
             *pExtValueSubtagEnd = 0;
             pExtension->value = T_CString_toLowerCase(pExtValueSubtag);
             /* insert the extension to the list */
-            if (_addExtensionToList(&(t->extensions), pExtension, FALSE)) {
+            if (_addExtensionToList(&(t->extensions), pExtension, false)) {
                 pLastGoodPosition = pExtValueSubtagEnd;
             } else {
                 uprv_free(pExtension);
@@ -2535,7 +2535,7 @@ static int32_t
 ultag_getVariantsSize(const ULanguageTag* langtag) {
     int32_t size = 0;
     VariantListEntry *cur = langtag->variants;
-    while (TRUE) {
+    while (true) {
         if (cur == NULL) {
             break;
         }
@@ -2581,7 +2581,7 @@ static int32_t
 ultag_getExtensionsSize(const ULanguageTag* langtag) {
     int32_t size = 0;
     ExtensionListEntry *cur = langtag->extensions;
-    while (TRUE) {
+    while (true) {
         if (cur == NULL) {
             break;
         }
@@ -2648,7 +2648,7 @@ ulocimp_toLanguageTag(const char* localeID,
     icu::CharString canonical;
     int32_t reslen;
     UErrorCode tmpStatus = U_ZERO_ERROR;
-    UBool hadPosix = FALSE;
+    UBool hadPosix = false;
     const char* pKeywordStart;
 
     /* Note: uloc_canonicalize returns "en_US_POSIX" for input locale ID "".  See #6835 */
@@ -2699,7 +2699,7 @@ ulocimp_toLanguageTag(const char* localeID,
     pKeywordStart = locale_getKeywordsStart(canonical.data());
     if (pKeywordStart == canonical.data()) {
         int kwdCnt = 0;
-        UBool done = FALSE;
+        UBool done = false;
 
         icu::LocalUEnumerationPointer kwdEnum(uloc_openKeywords(canonical.data(), &tmpStatus));
         if (U_SUCCESS(tmpStatus)) {
@@ -2720,15 +2720,15 @@ ulocimp_toLanguageTag(const char* localeID,
                             /* return private use only tag */
                             sink.Append("und-x-", 6);
                             sink.Append(buf.data(), buf.length());
-                            done = TRUE;
+                            done = true;
                         } else if (strict) {
                             *status = U_ILLEGAL_ARGUMENT_ERROR;
-                            done = TRUE;
+                            done = true;
                         }
                         /* if not strict mode, then "und" will be returned */
                     } else {
                         *status = U_ILLEGAL_ARGUMENT_ERROR;
-                        done = TRUE;
+                        done = true;
                     }
                 }
             }
@@ -2782,11 +2782,11 @@ ulocimp_forLanguageTag(const char* langtag,
                        icu::ByteSink& sink,
                        int32_t* parsedLength,
                        UErrorCode* status) {
-    UBool isEmpty = TRUE;
+    UBool isEmpty = true;
     const char *subtag, *p;
     int32_t len;
     int32_t i, n;
-    UBool noRegion = TRUE;
+    UBool noRegion = true;
 
     icu::LocalULanguageTagPointer lt(ultag_parse(langtag, tagLen, parsedLength, status));
     if (U_FAILURE(*status)) {
@@ -2799,7 +2799,7 @@ ulocimp_forLanguageTag(const char* langtag,
         len = (int32_t)uprv_strlen(subtag);
         if (len > 0) {
             sink.Append(subtag, len);
-            isEmpty = FALSE;
+            isEmpty = false;
         }
     }
 
@@ -2808,7 +2808,7 @@ ulocimp_forLanguageTag(const char* langtag,
     len = (int32_t)uprv_strlen(subtag);
     if (len > 0) {
         sink.Append("_", 1);
-        isEmpty = FALSE;
+        isEmpty = false;
 
         /* write out the script in title case */
         char c = uprv_toupper(*subtag);
@@ -2821,7 +2821,7 @@ ulocimp_forLanguageTag(const char* langtag,
     len = (int32_t)uprv_strlen(subtag);
     if (len > 0) {
         sink.Append("_", 1);
-        isEmpty = FALSE;
+        isEmpty = false;
 
         /* write out the region in upper case */
         p = subtag;
@@ -2830,7 +2830,7 @@ ulocimp_forLanguageTag(const char* langtag,
             sink.Append(&c, 1);
             p++;
         }
-        noRegion = FALSE;
+        noRegion = false;
     }
 
     /* variants */
@@ -2839,7 +2839,7 @@ ulocimp_forLanguageTag(const char* langtag,
     if (n > 0) {
         if (noRegion) {
             sink.Append("_", 1);
-            isEmpty = FALSE;
+            isEmpty = false;
         }
 
         for (i = 0; i < n; i++) {
diff --git a/deps/icu-small/source/common/umapfile.cpp b/deps/icu-small/source/common/umapfile.cpp
index 3e714876a4..145582ea97 100644
--- a/deps/icu-small/source/common/umapfile.cpp
+++ b/deps/icu-small/source/common/umapfile.cpp
@@ -107,10 +107,10 @@ typedef HANDLE MemoryMap;
     U_CFUNC UBool
     uprv_mapFile(UDataMemory *pData, const char *path, UErrorCode *status) {
         if (U_FAILURE(*status)) {
-            return FALSE;
+            return false;
         }
         UDataMemory_init(pData); /* Clear the output struct. */
-        return FALSE;            /* no file access */
+        return false;            /* no file access */
     }
 
     U_CFUNC void uprv_unmapFile(UDataMemory *pData) {
@@ -126,7 +126,7 @@ typedef HANDLE MemoryMap;
          )
     {
         if (U_FAILURE(*status)) {
-            return FALSE;
+            return false;
         }
 
         HANDLE map = nullptr;
@@ -150,12 +150,12 @@ typedef HANDLE MemoryMap;
         u_strFromUTF8(reinterpret_cast<UChar*>(utf16Path), static_cast<int32_t>(UPRV_LENGTHOF(utf16Path)), &pathUtf16Len, path, -1, status);
 
         if (U_FAILURE(*status)) {
-            return FALSE;
+            return false;
         }
         if (*status == U_STRING_NOT_TERMINATED_WARNING) {
             // Report back an error instead of a warning.
             *status = U_BUFFER_OVERFLOW_ERROR;
-            return FALSE;
+            return false;
         }
 
         file = CreateFileW(utf16Path, GENERIC_READ, FILE_SHARE_READ, nullptr,
@@ -168,7 +168,7 @@ typedef HANDLE MemoryMap;
             if (HRESULT_FROM_WIN32(GetLastError()) == E_OUTOFMEMORY) {
                 *status = U_MEMORY_ALLOCATION_ERROR;
             }
-            return FALSE;
+            return false;
         }
 
         // Note: We use NULL/nullptr for lpAttributes parameter below.
@@ -183,17 +183,17 @@ typedef HANDLE MemoryMap;
             if (HRESULT_FROM_WIN32(GetLastError()) == E_OUTOFMEMORY) {
                 *status = U_MEMORY_ALLOCATION_ERROR;
             }
-            return FALSE;
+            return false;
         }
 
         /* map a view of the file into our address space */
         pData->pHeader = reinterpret_cast<const DataHeader *>(MapViewOfFile(map, FILE_MAP_READ, 0, 0, 0));
         if (pData->pHeader == nullptr) {
             CloseHandle(map);
-            return FALSE;
+            return false;
         }
         pData->map = map;
-        return TRUE;
+        return true;
     }
 
     U_CFUNC void
@@ -217,21 +217,21 @@ typedef HANDLE MemoryMap;
         void *data;
 
         if (U_FAILURE(*status)) {
-            return FALSE;
+            return false;
         }
 
         UDataMemory_init(pData); /* Clear the output struct.        */
 
         /* determine the length of the file */
         if(stat(path, &mystat)!=0 || mystat.st_size<=0) {
-            return FALSE;
+            return false;
         }
         length=mystat.st_size;
 
         /* open the file */
         fd=open(path, O_RDONLY);
         if(fd==-1) {
-            return FALSE;
+            return false;
         }
 
         /* get a view of the mapping */
@@ -243,7 +243,7 @@ typedef HANDLE MemoryMap;
         close(fd); /* no longer needed */
         if(data==MAP_FAILED) {
             // Possibly check the errno value for ENOMEM, and report U_MEMORY_ALLOCATION_ERROR?
-            return FALSE;
+            return false;
         }
 
         pData->map = (char *)data + length;
@@ -252,7 +252,7 @@ typedef HANDLE MemoryMap;
 #if U_PLATFORM == U_PF_IPHONE
         posix_madvise(data, length, POSIX_MADV_RANDOM);
 #endif
-        return TRUE;
+        return true;
     }
 
     U_CFUNC void
@@ -291,21 +291,21 @@ typedef HANDLE MemoryMap;
         void *p;
 
         if (U_FAILURE(*status)) {
-            return FALSE;
+            return false;
         }
 
         UDataMemory_init(pData); /* Clear the output struct.        */
         /* open the input file */
         file=fopen(path, "rb");
         if(file==nullptr) {
-            return FALSE;
+            return false;
         }
 
         /* get the file length */
         fileLength=umap_fsize(file);
         if(ferror(file) || fileLength<=20) {
             fclose(file);
-            return FALSE;
+            return false;
         }
 
         /* allocate the memory to hold the file data */
@@ -313,21 +313,21 @@ typedef HANDLE MemoryMap;
         if(p==nullptr) {
             fclose(file);
             *status = U_MEMORY_ALLOCATION_ERROR;
-            return FALSE;
+            return false;
         }
 
         /* read the file */
         if(fileLength!=fread(p, 1, fileLength, file)) {
             uprv_free(p);
             fclose(file);
-            return FALSE;
+            return false;
         }
 
         fclose(file);
         pData->map=p;
         pData->pHeader=(const DataHeader *)p;
         pData->mapAddr=p;
-        return TRUE;
+        return true;
     }
 
     U_CFUNC void
@@ -427,7 +427,7 @@ typedef HANDLE MemoryMap;
         void *val=0;
 
         if (U_FAILURE(*status)) {
-            return FALSE;
+            return false;
         }
 
         inBasename=uprv_strrchr(path, U_FILE_SEP_CHAR);
@@ -447,14 +447,14 @@ typedef HANDLE MemoryMap;
 
             /* determine the length of the file */
             if(stat(path, &mystat)!=0 || mystat.st_size<=0) {
-                return FALSE;
+                return false;
             }
             length=mystat.st_size;
 
             /* open the file */
             fd=open(path, O_RDONLY);
             if(fd==-1) {
-                return FALSE;
+                return false;
             }
 
             /* get a view of the mapping */
@@ -462,12 +462,12 @@ typedef HANDLE MemoryMap;
             close(fd); /* no longer needed */
             if(data==MAP_FAILED) {
                 // Possibly check the errorno value for ENOMEM, and report U_MEMORY_ALLOCATION_ERROR?
-                return FALSE;
+                return false;
             }
             pData->map = (char *)data + length;
             pData->pHeader=(const DataHeader *)data;
             pData->mapAddr = data;
-            return TRUE;
+            return true;
         }
 
 #       ifdef OS390BATCH
@@ -503,16 +503,16 @@ typedef HANDLE MemoryMap;
                val=dllqueryvar((dllhandle*)handle, U_ICUDATA_ENTRY_NAME);
                if(val == 0) {
                     /* failed... so keep looking */
-                    return FALSE;
+                    return false;
                }
 #              ifdef UDATA_DEBUG
                     fprintf(stderr, "dllqueryvar(%08X, %s) -> %08X\n", handle, U_ICUDATA_ENTRY_NAME, val);
 #              endif
 
                pData->pHeader=(const DataHeader *)val;
-               return TRUE;
+               return true;
          } else {
-               return FALSE; /* no handle */
+               return false; /* no handle */
          }
     }
 
diff --git a/deps/icu-small/source/common/umapfile.h b/deps/icu-small/source/common/umapfile.h
index adc265203d..042e71374c 100644
--- a/deps/icu-small/source/common/umapfile.h
+++ b/deps/icu-small/source/common/umapfile.h
@@ -29,7 +29,7 @@
 #include "unicode/udata.h"
 #include "putilimp.h"
 
-U_CFUNC UBool uprv_mapFile(UDataMemory *pdm, const char *path, UErrorCode *status);
+U_CAPI  UBool U_EXPORT2 uprv_mapFile(UDataMemory *pdm, const char *path, UErrorCode *status);
 U_CFUNC void  uprv_unmapFile(UDataMemory *pData);
 
 /* MAP_NONE: no memory mapping, no file access at all */
diff --git a/deps/icu-small/source/common/umutex.h b/deps/icu-small/source/common/umutex.h
index 8d76b3f3e6..1b8332409c 100644
--- a/deps/icu-small/source/common/umutex.h
+++ b/deps/icu-small/source/common/umutex.h
@@ -71,7 +71,6 @@ U_NAMESPACE_BEGIN
  ****************************************************************************/
 
 typedef std::atomic<int32_t> u_atomic_int32_t;
-#define ATOMIC_INT32_T_INITIALIZER(val) ATOMIC_VAR_INIT(val)
 
 inline int32_t umtx_loadAcquire(u_atomic_int32_t &var) {
     return var.load(std::memory_order_acquire);
@@ -96,18 +95,15 @@ inline int32_t umtx_atomic_dec(u_atomic_int32_t *var) {
  *
  *************************************************************************************************/
 
-struct UInitOnce {
-    u_atomic_int32_t   fState;
-    UErrorCode       fErrCode;
+struct U_COMMON_API UInitOnce {
+    u_atomic_int32_t   fState {0};
+    UErrorCode       fErrCode {U_ZERO_ERROR};
     void reset() {fState = 0;}
     UBool isReset() {return umtx_loadAcquire(fState) == 0;}
 // Note: isReset() is used by service registration code.
 //                 Thread safety of this usage needs review.
 };
 
-#define U_INITONCE_INITIALIZER {ATOMIC_INT32_T_INITIALIZER(0), U_ZERO_ERROR}
-
-
 U_COMMON_API UBool U_EXPORT2 umtx_initImplPreInit(UInitOnce &);
 U_COMMON_API void  U_EXPORT2 umtx_initImplPostInit(UInitOnce &);
 
diff --git a/deps/icu-small/source/common/unames.cpp b/deps/icu-small/source/common/unames.cpp
index 5776058f95..b0ac991e1b 100644
--- a/deps/icu-small/source/common/unames.cpp
+++ b/deps/icu-small/source/common/unames.cpp
@@ -105,7 +105,7 @@ typedef struct {
 
 static UDataMemory *uCharNamesData=NULL;
 static UCharNames *uCharNames=NULL;
-static icu::UInitOnce gCharNamesInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gCharNamesInitOnce {};
 
 /*
  * Maximum length of character names (regular & 1.0).
@@ -173,7 +173,7 @@ static UBool U_CALLCONV unames_cleanup(void)
     }
     gCharNamesInitOnce.reset();
     gMaxNameLength=0;
-    return TRUE;
+    return true;
 }
 
 static UBool U_CALLCONV
@@ -371,7 +371,7 @@ compareName(UCharNames *names,
             if(c!=';') {
                 /* implicit letter */
                 if((char)c!=*otherName++) {
-                    return FALSE;
+                    return false;
                 }
             } else {
                 /* finished */
@@ -388,7 +388,7 @@ compareName(UCharNames *names,
                 if(c!=';') {
                     /* explicit letter */
                     if((char)c!=*otherName++) {
-                        return FALSE;
+                        return false;
                     }
                 } else {
                     /* stop, but skip the semicolon if we are seeking
@@ -407,7 +407,7 @@ compareName(UCharNames *names,
                 uint8_t *tokenString=tokenStrings+token;
                 while((c=*tokenString++)!=0) {
                     if((char)c!=*otherName++) {
-                        return FALSE;
+                        return false;
                     }
                 }
             }
@@ -616,7 +616,7 @@ enumGroupNames(UCharNames *names, const uint16_t *group,
             /* here, we assume that the buffer is large enough */
             if(length>0) {
                 if(!fn(context, start, nameChoice, buffer, length)) {
-                    return FALSE;
+                    return false;
                 }
             }
             ++start;
@@ -626,12 +626,12 @@ enumGroupNames(UCharNames *names, const uint16_t *group,
         while(start<=end) {
             if(compareName(names, s+offsets[start&GROUP_MASK], lengths[start&GROUP_MASK], nameChoice, otherName)) {
                 ((FindName *)context)->code=start;
-                return FALSE;
+                return false;
             }
             ++start;
         }
     }
-    return TRUE;
+    return true;
 }
 
 /*
@@ -653,14 +653,14 @@ enumExtNames(UChar32 start, UChar32 end,
             /* here, we assume that the buffer is large enough */
             if(length>0) {
                 if(!fn(context, start, U_EXTENDED_CHAR_NAME, buffer, length)) {
-                    return FALSE;
+                    return false;
                 }
             }
             ++start;
         }
     }
 
-    return TRUE;
+    return true;
 }
 
 static UBool
@@ -684,7 +684,7 @@ enumNames(UCharNames *names,
             extLimit=limit;
         }
         if(!enumExtNames(start, extLimit-1, fn, context)) {
-            return FALSE;
+            return false;
         }
         start=extLimit;
     }
@@ -705,7 +705,7 @@ enumNames(UCharNames *names,
                 if(!enumGroupNames(names, group,
                                    start, ((UChar32)startGroupMSB<<GROUP_SHIFT)+LINES_PER_GROUP-1,
                                    fn, context, nameChoice)) {
-                    return FALSE;
+                    return false;
                 }
                 group=NEXT_GROUP(group); /* continue with the next group */
             }
@@ -718,7 +718,7 @@ enumNames(UCharNames *names,
                     end = limit;
                 }
                 if (!enumExtNames(start, end - 1, fn, context)) {
-                    return FALSE;
+                    return false;
                 }
             }
             group=nextGroup;
@@ -729,7 +729,7 @@ enumNames(UCharNames *names,
             const uint16_t *nextGroup;
             start=(UChar32)group[GROUP_MSB]<<GROUP_SHIFT;
             if(!enumGroupNames(names, group, start, start+LINES_PER_GROUP-1, fn, context, nameChoice)) {
-                return FALSE;
+                return false;
             }
             nextGroup=NEXT_GROUP(group);
             if (nextGroup < groupLimit && nextGroup[GROUP_MSB] > group[GROUP_MSB] + 1 && nameChoice == U_EXTENDED_CHAR_NAME) {
@@ -738,7 +738,7 @@ enumNames(UCharNames *names,
                     end = limit;
                 }
                 if (!enumExtNames((group[GROUP_MSB] + 1) << GROUP_SHIFT, end - 1, fn, context)) {
-                    return FALSE;
+                    return false;
                 }
             }
             group=nextGroup;
@@ -753,7 +753,7 @@ enumNames(UCharNames *names,
                 start = next;
             }
         } else {
-            return TRUE;
+            return true;
         }
     }
 
@@ -766,7 +766,7 @@ enumNames(UCharNames *names,
         return enumExtNames(start, limit - 1, fn, context);
     }
     
-    return TRUE;
+    return true;
 }
 
 static uint16_t
@@ -941,7 +941,7 @@ enumAlgNames(AlgorithmicRange *range,
     uint16_t length;
 
     if(nameChoice!=U_UNICODE_CHAR_NAME && nameChoice!=U_EXTENDED_CHAR_NAME) {
-        return TRUE;
+        return true;
     }
 
     switch(range->type) {
@@ -952,12 +952,12 @@ enumAlgNames(AlgorithmicRange *range,
         /* get the full name of the start character */
         length=getAlgName(range, (uint32_t)start, nameChoice, buffer, sizeof(buffer));
         if(length<=0) {
-            return TRUE;
+            return true;
         }
 
         /* call the enumerator function with this first character */
         if(!fn(context, start, nameChoice, buffer, length)) {
-            return FALSE;
+            return false;
         }
 
         /* go to the end of the name; all these names have the same length */
@@ -984,7 +984,7 @@ enumAlgNames(AlgorithmicRange *range,
             }
 
             if(!fn(context, start, nameChoice, buffer, length)) {
-                return FALSE;
+                return false;
             }
         }
         break;
@@ -1018,7 +1018,7 @@ enumAlgNames(AlgorithmicRange *range,
 
         /* call the enumerator function with this first character */
         if(!fn(context, start, nameChoice, buffer, length)) {
-            return FALSE;
+            return false;
         }
 
         /* enumerate the rest of the names */
@@ -1056,7 +1056,7 @@ enumAlgNames(AlgorithmicRange *range,
             *t=0;
 
             if(!fn(context, start, nameChoice, buffer, length)) {
-                return FALSE;
+                return false;
             }
         }
         break;
@@ -1066,7 +1066,7 @@ enumAlgNames(AlgorithmicRange *range,
         break;
     }
 
-    return TRUE;
+    return true;
 }
 
 /*
@@ -1416,11 +1416,11 @@ calcNameSetsLengths(UErrorCode *pErrorCode) {
     int32_t i, maxNameLength;
 
     if(gMaxNameLength!=0) {
-        return TRUE;
+        return true;
     }
 
     if(!isDataLoaded(pErrorCode)) {
-        return FALSE;
+        return false;
     }
 
     /* set hex digits, used in various names, and <>-, used in extended names */
@@ -1437,7 +1437,7 @@ calcNameSetsLengths(UErrorCode *pErrorCode) {
     /* set sets and lengths from group names, set global maximum values */
     calcGroupNameSetsLengths(maxNameLength);
 
-    return TRUE;
+    return true;
 }
 
 U_NAMESPACE_END
@@ -1809,7 +1809,7 @@ makeTokenMap(const UDataSwapper *ds,
 
                 /* enter the converted character into the map and mark it used */
                 map[c1]=c2;
-                usedOutChar[c2]=TRUE;
+                usedOutChar[c2]=true;
             }
         }
 
diff --git a/deps/icu-small/source/common/unicode/bytestrie.h b/deps/icu-small/source/common/unicode/bytestrie.h
index 271a81d1b4..8fe66780f5 100644
--- a/deps/icu-small/source/common/unicode/bytestrie.h
+++ b/deps/icu-small/source/common/unicode/bytestrie.h
@@ -394,7 +394,7 @@ private:
               pos_(bytes_), remainingMatchLength_(-1) {}
 
     // No assignment operator.
-    BytesTrie &operator=(const BytesTrie &other);
+    BytesTrie &operator=(const BytesTrie &other) = delete;
 
     inline void stop() {
         pos_=NULL;
diff --git a/deps/icu-small/source/common/unicode/bytestriebuilder.h b/deps/icu-small/source/common/unicode/bytestriebuilder.h
index 382f5e0095..ec9c625473 100644
--- a/deps/icu-small/source/common/unicode/bytestriebuilder.h
+++ b/deps/icu-small/source/common/unicode/bytestriebuilder.h
@@ -129,8 +129,8 @@ public:
 private:
     friend class ::BytesTrieTest;
 
-    BytesTrieBuilder(const BytesTrieBuilder &other);  // no copy constructor
-    BytesTrieBuilder &operator=(const BytesTrieBuilder &other);  // no assignment operator
+    BytesTrieBuilder(const BytesTrieBuilder &other) = delete;  // no copy constructor
+    BytesTrieBuilder &operator=(const BytesTrieBuilder &other) = delete;  // no assignment operator
 
     void buildBytes(UStringTrieBuildOption buildOption, UErrorCode &errorCode);
 
diff --git a/deps/icu-small/source/common/unicode/caniter.h b/deps/icu-small/source/common/unicode/caniter.h
index 6e57ef5e3b..db400a531b 100644
--- a/deps/icu-small/source/common/unicode/caniter.h
+++ b/deps/icu-small/source/common/unicode/caniter.h
@@ -150,20 +150,20 @@ public:
 private:
     // ===================== PRIVATES ==============================
     // private default constructor
-    CanonicalIterator();
+    CanonicalIterator() = delete;
 
 
     /**
      * Copy constructor. Private for now.
      * @internal (private)
      */
-    CanonicalIterator(const CanonicalIterator& other);
+    CanonicalIterator(const CanonicalIterator& other) = delete;
 
     /**
      * Assignment operator. Private for now.
      * @internal (private)
      */
-    CanonicalIterator& operator=(const CanonicalIterator& other);
+    CanonicalIterator& operator=(const CanonicalIterator& other) = delete;
 
     // fields
     UnicodeString source;
diff --git a/deps/icu-small/source/common/unicode/dtintrv.h b/deps/icu-small/source/common/unicode/dtintrv.h
index 46a94ce349..8c172eb7a5 100644
--- a/deps/icu-small/source/common/unicode/dtintrv.h
+++ b/deps/icu-small/source/common/unicode/dtintrv.h
@@ -131,7 +131,7 @@ private:
     /** 
      * Default constructor, not implemented.
      */
-    DateInterval();
+    DateInterval() = delete;
 
     UDate fromDate;
     UDate toDate;
diff --git a/deps/icu-small/source/common/unicode/idna.h b/deps/icu-small/source/common/unicode/idna.h
index 1305dc6048..1c57205bae 100644
--- a/deps/icu-small/source/common/unicode/idna.h
+++ b/deps/icu-small/source/common/unicode/idna.h
@@ -305,8 +305,8 @@ public:
 private:
     friend class UTS46;
 
-    IDNAInfo(const IDNAInfo &other);  // no copying
-    IDNAInfo &operator=(const IDNAInfo &other);  // no copying
+    IDNAInfo(const IDNAInfo &other) = delete;  // no copying
+    IDNAInfo &operator=(const IDNAInfo &other) = delete;  // no copying
 
     void reset() {
         errors=labelErrors=0;
diff --git a/deps/icu-small/source/common/unicode/normlzr.h b/deps/icu-small/source/common/unicode/normlzr.h
index 93661990fe..14b2469885 100644
--- a/deps/icu-small/source/common/unicode/normlzr.h
+++ b/deps/icu-small/source/common/unicode/normlzr.h
@@ -740,8 +740,8 @@ private:
   // Private functions
   //-------------------------------------------------------------------------
 
-  Normalizer(); // default constructor not implemented
-  Normalizer &operator=(const Normalizer &that); // assignment operator not implemented
+  Normalizer() = delete; // default constructor not implemented
+  Normalizer &operator=(const Normalizer &that) = delete; // assignment operator not implemented
 
   // Private utility methods for iteration
   // For documentation, see the source code
diff --git a/deps/icu-small/source/common/unicode/platform.h b/deps/icu-small/source/common/unicode/platform.h
index b7e514442c..1605226a79 100644
--- a/deps/icu-small/source/common/unicode/platform.h
+++ b/deps/icu-small/source/common/unicode/platform.h
@@ -168,7 +168,7 @@
 #   define U_PLATFORM U_PF_LINUX
 #elif defined(__APPLE__) && defined(__MACH__)
 #   include <TargetConditionals.h>
-#   if defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE  /* variant of TARGET_OS_MAC */
+#   if (defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE) && (defined(TARGET_OS_MACCATALYST) && !TARGET_OS_MACCATALYST)   /* variant of TARGET_OS_MAC */
 #       define U_PLATFORM U_PF_IPHONE
 #   else
 #       define U_PLATFORM U_PF_DARWIN
@@ -847,6 +847,21 @@ namespace std {
 #   define U_IMPORT 
 #endif
 
+/**
+ * \def U_HIDDEN
+ * This is used to mark internal structs declared within external classes,
+ * to prevent the internal structs from having the same visibility as the
+ * class within which they are declared. 
+ * @internal
+ */
+#ifdef U_HIDDEN
+    /* Use the predefined value. */
+#elif defined(__GNUC__)
+#   define U_HIDDEN __attribute__((visibility("hidden")))
+#else
+#   define U_HIDDEN 
+#endif
+
 /**
  * \def U_CALLCONV
  * Similar to U_CDECL_BEGIN/U_CDECL_END, this qualifier is necessary
diff --git a/deps/icu-small/source/common/unicode/rbbi.h b/deps/icu-small/source/common/unicode/rbbi.h
index 0bad0d3897..d878243e3f 100644
--- a/deps/icu-small/source/common/unicode/rbbi.h
+++ b/deps/icu-small/source/common/unicode/rbbi.h
@@ -648,13 +648,6 @@ private:
     //=======================================================================
     // implementation
     //=======================================================================
-    /**
-     * Dumps caches and performs other actions associated with a complete change
-     * in text or iteration position.
-     * @internal (private)
-     */
-    void reset(void);
-
     /**
       * Common initialization function, used by constructors and bufferClone.
       * @internal (private)
diff --git a/deps/icu-small/source/common/unicode/resbund.h b/deps/icu-small/source/common/unicode/resbund.h
index 7441592a0f..6e26a40591 100644
--- a/deps/icu-small/source/common/unicode/resbund.h
+++ b/deps/icu-small/source/common/unicode/resbund.h
@@ -484,7 +484,7 @@ public:
     static UClassID U_EXPORT2 getStaticClassID();
 
 private:
-    ResourceBundle(); // default constructor not implemented
+    ResourceBundle() = delete; // default constructor not implemented
 
     UResourceBundle *fResource;
     void constructForLocale(const UnicodeString& path, const Locale& locale, UErrorCode& error);
diff --git a/deps/icu-small/source/common/unicode/schriter.h b/deps/icu-small/source/common/unicode/schriter.h
index 9dac099967..a2ab17982d 100644
--- a/deps/icu-small/source/common/unicode/schriter.h
+++ b/deps/icu-small/source/common/unicode/schriter.h
@@ -172,14 +172,6 @@ protected:
    */
   StringCharacterIterator();
 
-  /**
-   * Sets the iterator to iterate over the provided string.
-   * @param newText The string to be iterated over
-   * @param newTextLength The length of the String
-   * @stable ICU 2.0
-   */
-  void setText(const char16_t* newText, int32_t newTextLength);
-
   /**
    * Copy of the iterated string object.
    * @stable ICU 2.0
diff --git a/deps/icu-small/source/common/unicode/ubiditransform.h b/deps/icu-small/source/common/unicode/ubiditransform.h
index 2dd7564010..24433aa8ac 100644
--- a/deps/icu-small/source/common/unicode/ubiditransform.h
+++ b/deps/icu-small/source/common/unicode/ubiditransform.h
@@ -28,7 +28,7 @@
 
 /**
  * \file
- * \brief Bidi Transformations
+ * \brief C API: Bidi Transformations
  */
 
 /**
diff --git a/deps/icu-small/source/common/unicode/uchar.h b/deps/icu-small/source/common/unicode/uchar.h
index 253e6db173..6bb68e62a9 100644
--- a/deps/icu-small/source/common/unicode/uchar.h
+++ b/deps/icu-small/source/common/unicode/uchar.h
@@ -60,7 +60,7 @@ U_CDECL_BEGIN
  * @see u_getUnicodeVersion
  * @stable ICU 2.0
  */
-#define U_UNICODE_VERSION "14.0"
+#define U_UNICODE_VERSION "15.0"
 
 /**
  * \file
@@ -483,57 +483,55 @@ typedef enum UProperty {
      * @stable ICU 62
      */
     UCHAR_EXTENDED_PICTOGRAPHIC=64,
-#ifndef U_HIDE_DRAFT_API
     /**
      * Binary property of strings Basic_Emoji.
      * See https://www.unicode.org/reports/tr51/#Emoji_Sets
      *
-     * @draft ICU 70
+     * @stable ICU 70
      */
     UCHAR_BASIC_EMOJI=65,
     /**
      * Binary property of strings Emoji_Keycap_Sequence.
      * See https://www.unicode.org/reports/tr51/#Emoji_Sets
      *
-     * @draft ICU 70
+     * @stable ICU 70
      */
     UCHAR_EMOJI_KEYCAP_SEQUENCE=66,
     /**
      * Binary property of strings RGI_Emoji_Modifier_Sequence.
      * See https://www.unicode.org/reports/tr51/#Emoji_Sets
      *
-     * @draft ICU 70
+     * @stable ICU 70
      */
     UCHAR_RGI_EMOJI_MODIFIER_SEQUENCE=67,
     /**
      * Binary property of strings RGI_Emoji_Flag_Sequence.
      * See https://www.unicode.org/reports/tr51/#Emoji_Sets
      *
-     * @draft ICU 70
+     * @stable ICU 70
      */
     UCHAR_RGI_EMOJI_FLAG_SEQUENCE=68,
     /**
      * Binary property of strings RGI_Emoji_Tag_Sequence.
      * See https://www.unicode.org/reports/tr51/#Emoji_Sets
      *
-     * @draft ICU 70
+     * @stable ICU 70
      */
     UCHAR_RGI_EMOJI_TAG_SEQUENCE=69,
     /**
      * Binary property of strings RGI_Emoji_ZWJ_Sequence.
      * See https://www.unicode.org/reports/tr51/#Emoji_Sets
      *
-     * @draft ICU 70
+     * @stable ICU 70
      */
     UCHAR_RGI_EMOJI_ZWJ_SEQUENCE=70,
     /**
      * Binary property of strings RGI_Emoji.
      * See https://www.unicode.org/reports/tr51/#Emoji_Sets
      *
-     * @draft ICU 70
+     * @stable ICU 70
      */
     UCHAR_RGI_EMOJI=71,
-#endif  // U_HIDE_DRAFT_API
 #ifndef U_HIDE_DEPRECATED_API
     /**
      * One more than the last constant for binary Unicode properties.
@@ -1885,6 +1883,23 @@ enum UBlockCode {
     /** @stable ICU 70 */
     UBLOCK_ZNAMENNY_MUSICAL_NOTATION = 320, /*[1CF00]*/
 
+    // New blocks in Unicode 15.0
+
+    /** @stable ICU 72 */
+    UBLOCK_ARABIC_EXTENDED_C = 321, /*[10EC0]*/
+    /** @stable ICU 72 */
+    UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_H = 322, /*[31350]*/
+    /** @stable ICU 72 */
+    UBLOCK_CYRILLIC_EXTENDED_D = 323, /*[1E030]*/
+    /** @stable ICU 72 */
+    UBLOCK_DEVANAGARI_EXTENDED_A = 324, /*[11B00]*/
+    /** @stable ICU 72 */
+    UBLOCK_KAKTOVIK_NUMERALS = 325, /*[1D2C0]*/
+    /** @stable ICU 72 */
+    UBLOCK_KAWI = 326, /*[11F00]*/
+    /** @stable ICU 72 */
+    UBLOCK_NAG_MUNDARI = 327, /*[1E4D0]*/
+
 #ifndef U_HIDE_DEPRECATED_API
     /**
      * One more than the highest normal UBlockCode value.
@@ -1892,7 +1907,7 @@ enum UBlockCode {
      *
      * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
      */
-    UBLOCK_COUNT = 321,
+    UBLOCK_COUNT = 328,
 #endif  // U_HIDE_DEPRECATED_API
 
     /** @stable ICU 2.0 */
@@ -2680,8 +2695,6 @@ typedef enum UVerticalOrientation {
 U_CAPI UBool U_EXPORT2
 u_hasBinaryProperty(UChar32 c, UProperty which);
 
-#ifndef U_HIDE_DRAFT_API
-
 /**
  * Returns true if the property is true for the string.
  * Same as u_hasBinaryProperty(single code point, which)
@@ -2704,13 +2717,11 @@ u_hasBinaryProperty(UChar32 c, UProperty which);
  * @see u_getBinaryPropertySet
  * @see u_getIntPropertyValue
  * @see u_getUnicodeVersion
- * @draft ICU 70
+ * @stable ICU 70
  */
 U_CAPI UBool U_EXPORT2
 u_stringHasBinaryProperty(const UChar *s, int32_t length, UProperty which);
 
-#endif  // U_HIDE_DRAFT_API
-
 /**
  * Returns a frozen USet for a binary property.
  * The library retains ownership over the returned object.
diff --git a/deps/icu-small/source/common/unicode/ucharstrie.h b/deps/icu-small/source/common/unicode/ucharstrie.h
index b6f9e3e075..064244a74c 100644
--- a/deps/icu-small/source/common/unicode/ucharstrie.h
+++ b/deps/icu-small/source/common/unicode/ucharstrie.h
@@ -409,7 +409,7 @@ private:
               pos_(uchars_), remainingMatchLength_(-1) {}
 
     // No assignment operator.
-    UCharsTrie &operator=(const UCharsTrie &other);
+    UCharsTrie &operator=(const UCharsTrie &other) = delete;
 
     inline void stop() {
         pos_=NULL;
diff --git a/deps/icu-small/source/common/unicode/ucharstriebuilder.h b/deps/icu-small/source/common/unicode/ucharstriebuilder.h
index e0cb0acdc5..5c8aa33ffb 100644
--- a/deps/icu-small/source/common/unicode/ucharstriebuilder.h
+++ b/deps/icu-small/source/common/unicode/ucharstriebuilder.h
@@ -133,8 +133,8 @@ public:
     }
 
 private:
-    UCharsTrieBuilder(const UCharsTrieBuilder &other);  // no copy constructor
-    UCharsTrieBuilder &operator=(const UCharsTrieBuilder &other);  // no assignment operator
+    UCharsTrieBuilder(const UCharsTrieBuilder &other) = delete;  // no copy constructor
+    UCharsTrieBuilder &operator=(const UCharsTrieBuilder &other) = delete;  // no assignment operator
 
     void buildUChars(UStringTrieBuildOption buildOption, UErrorCode &errorCode);
 
diff --git a/deps/icu-small/source/common/unicode/ucnv_cb.h b/deps/icu-small/source/common/unicode/ucnv_cb.h
index 41845d1bca..b4ef99208b 100644
--- a/deps/icu-small/source/common/unicode/ucnv_cb.h
+++ b/deps/icu-small/source/common/unicode/ucnv_cb.h
@@ -15,8 +15,8 @@
  */
 
 /**
- * \file 
- * \brief C UConverter functions to aid the writers of callbacks
+ * \file
+ * \brief C API: UConverter functions to aid the writers of callbacks
  *
  * <h2> Callback API for UConverter </h2>
  * 
diff --git a/deps/icu-small/source/common/unicode/ucnv_err.h b/deps/icu-small/source/common/unicode/ucnv_err.h
index a13d01db09..c743e5614f 100644
--- a/deps/icu-small/source/common/unicode/ucnv_err.h
+++ b/deps/icu-small/source/common/unicode/ucnv_err.h
@@ -12,7 +12,7 @@
 
 /**
  * \file
- * \brief C UConverter predefined error callbacks
+ * \brief C API: UConverter predefined error callbacks
  *
  *  <h2>Error Behaviour Functions</h2>
  *  Defines some error behaviour functions called by ucnv_{from,to}Unicode
diff --git a/deps/icu-small/source/common/unicode/ucnvsel.h b/deps/icu-small/source/common/unicode/ucnvsel.h
index 3d7d3327f7..9373ec951b 100644
--- a/deps/icu-small/source/common/unicode/ucnvsel.h
+++ b/deps/icu-small/source/common/unicode/ucnvsel.h
@@ -36,6 +36,7 @@
 
 /**
  * \file
+ * \brief C API: Encoding/charset encoding selector
  *
  * A converter selector is built with a set of encoding/charset names
  * and given an input string returns the set of names of the
diff --git a/deps/icu-small/source/common/unicode/ucpmap.h b/deps/icu-small/source/common/unicode/ucpmap.h
index 31e1365cac..a740bd160f 100644
--- a/deps/icu-small/source/common/unicode/ucpmap.h
+++ b/deps/icu-small/source/common/unicode/ucpmap.h
@@ -13,8 +13,7 @@ U_CDECL_BEGIN
 
 /**
  * \file
- *
- * This file defines an abstract map from Unicode code points to integer values.
+ * \brief C API: This file defines an abstract map from Unicode code points to integer values.
  *
  * @see UCPMap
  * @see UCPTrie
diff --git a/deps/icu-small/source/common/unicode/ucptrie.h b/deps/icu-small/source/common/unicode/ucptrie.h
index e2547ae2ee..dadef79c51 100644
--- a/deps/icu-small/source/common/unicode/ucptrie.h
+++ b/deps/icu-small/source/common/unicode/ucptrie.h
@@ -19,8 +19,7 @@ U_CDECL_BEGIN
 
 /**
  * \file
- *
- * This file defines an immutable Unicode code point trie.
+ * \brief C API: This file defines an immutable Unicode code point trie.
  *
  * @see UCPTrie
  * @see UMutableCPTrie
diff --git a/deps/icu-small/source/common/unicode/uloc.h b/deps/icu-small/source/common/unicode/uloc.h
index b0bdbe1b87..21179c1b62 100644
--- a/deps/icu-small/source/common/unicode/uloc.h
+++ b/deps/icu-small/source/common/unicode/uloc.h
@@ -26,9 +26,9 @@
 #include "unicode/utypes.h"
 #include "unicode/uenum.h"
 
-/**    
+/**
  * \file
- * \brief  C API: Locale 
+ * \brief C API: Locale ID functionality similar to C++ class Locale
  *
  * <h2> ULoc C API for Locale </h2>
  * A <code>Locale</code> represents a specific geographical, political,
diff --git a/deps/icu-small/source/common/unicode/umachine.h b/deps/icu-small/source/common/unicode/umachine.h
index 09c887c80e..6640606272 100644
--- a/deps/icu-small/source/common/unicode/umachine.h
+++ b/deps/icu-small/source/common/unicode/umachine.h
@@ -282,14 +282,8 @@ typedef int8_t UBool;
  */
 #ifdef U_DEFINE_FALSE_AND_TRUE
     // Use the predefined value.
-#elif defined(U_COMBINED_IMPLEMENTATION) || \
-        defined(U_COMMON_IMPLEMENTATION) || defined(U_I18N_IMPLEMENTATION) || \
-        defined(U_IO_IMPLEMENTATION) || defined(U_LAYOUTEX_IMPLEMENTATION) || \
-        defined(U_TOOLUTIL_IMPLEMENTATION)
-    // Inside ICU: Keep FALSE & TRUE available.
-#   define U_DEFINE_FALSE_AND_TRUE 1
 #else
-    // Outside ICU: Avoid collision with non-macro definitions of FALSE & TRUE.
+    // Default to avoiding collision with non-macro definitions of FALSE & TRUE.
 #   define U_DEFINE_FALSE_AND_TRUE 0
 #endif
 
diff --git a/deps/icu-small/source/common/unicode/umisc.h b/deps/icu-small/source/common/unicode/umisc.h
index 213290b9af..4e9dda7450 100644
--- a/deps/icu-small/source/common/unicode/umisc.h
+++ b/deps/icu-small/source/common/unicode/umisc.h
@@ -21,9 +21,9 @@
 
 /**
  * \file
- * \brief  C API:misc definitions 
+ * \brief C API: Miscellaneous definitions
  *
- *  This file contains miscellaneous definitions for the C APIs. 
+ *  This file contains miscellaneous definitions for the C APIs.
  */
 
 U_CDECL_BEGIN
diff --git a/deps/icu-small/source/common/unicode/umutablecptrie.h b/deps/icu-small/source/common/unicode/umutablecptrie.h
index 3b950055da..d60fd61819 100644
--- a/deps/icu-small/source/common/unicode/umutablecptrie.h
+++ b/deps/icu-small/source/common/unicode/umutablecptrie.h
@@ -21,8 +21,7 @@ U_CDECL_BEGIN
 
 /**
  * \file
- *
- * This file defines a mutable Unicode code point trie.
+ * \brief C API: This file defines a mutable Unicode code point trie.
  *
  * @see UCPTrie
  * @see UMutableCPTrie
diff --git a/deps/icu-small/source/common/unicode/uniset.h b/deps/icu-small/source/common/unicode/uniset.h
index 310c7c8d20..33e35c4def 100644
--- a/deps/icu-small/source/common/unicode/uniset.h
+++ b/deps/icu-small/source/common/unicode/uniset.h
@@ -794,13 +794,11 @@ public:
      */
     virtual UBool isEmpty(void) const;
 
-#ifndef U_HIDE_DRAFT_API
     /**
      * @return true if this set contains multi-character strings or the empty string.
-     * @draft ICU 70
+     * @stable ICU 70
      */
     UBool hasStrings() const;
-#endif  // U_HIDE_DRAFT_API
 
     /**
      * Returns true if this set contains the given character.
@@ -1678,8 +1676,6 @@ private:
                               UnicodeString& rebuiltPat,
                               UErrorCode& ec);
 
-    static const UnicodeSet* getInclusions(int32_t src, UErrorCode &status);
-
     /**
      * A filter that returns true if the given code point should be
      * included in the UnicodeSet being constructed.
@@ -1700,11 +1696,6 @@ private:
                      const UnicodeSet* inclusions,
                      UErrorCode &status);
 
-    // UCPMap is now stable ICU 63
-    void applyIntPropertyValue(const UCPMap *map,
-                               UCPMapValueFilter *filter, const void *context,
-                               UErrorCode &errorCode);
-
     /**
      * Set the new pattern to cache.
      */
diff --git a/deps/icu-small/source/common/unicode/urename.h b/deps/icu-small/source/common/unicode/urename.h
index d9f9b8f336..d3e23b8fa7 100644
--- a/deps/icu-small/source/common/unicode/urename.h
+++ b/deps/icu-small/source/common/unicode/urename.h
@@ -925,6 +925,12 @@
 #define udatpg_setDateTimeFormatForStyle U_ICU_ENTRY_POINT_RENAME(udatpg_setDateTimeFormatForStyle)
 #define udatpg_setDecimal U_ICU_ENTRY_POINT_RENAME(udatpg_setDecimal)
 #define udict_swap U_ICU_ENTRY_POINT_RENAME(udict_swap)
+#define udispopt_fromGrammaticalCaseIdentifier U_ICU_ENTRY_POINT_RENAME(udispopt_fromGrammaticalCaseIdentifier)
+#define udispopt_fromNounClassIdentifier U_ICU_ENTRY_POINT_RENAME(udispopt_fromNounClassIdentifier)
+#define udispopt_fromPluralCategoryIdentifier U_ICU_ENTRY_POINT_RENAME(udispopt_fromPluralCategoryIdentifier)
+#define udispopt_getGrammaticalCaseIdentifier U_ICU_ENTRY_POINT_RENAME(udispopt_getGrammaticalCaseIdentifier)
+#define udispopt_getNounClassIdentifier U_ICU_ENTRY_POINT_RENAME(udispopt_getNounClassIdentifier)
+#define udispopt_getPluralCategoryIdentifier U_ICU_ENTRY_POINT_RENAME(udispopt_getPluralCategoryIdentifier)
 #define udtitvfmt_close U_ICU_ENTRY_POINT_RENAME(udtitvfmt_close)
 #define udtitvfmt_closeResult U_ICU_ENTRY_POINT_RENAME(udtitvfmt_closeResult)
 #define udtitvfmt_format U_ICU_ENTRY_POINT_RENAME(udtitvfmt_format)
@@ -1247,6 +1253,7 @@
 #define unum_getLocaleByType U_ICU_ENTRY_POINT_RENAME(unum_getLocaleByType)
 #define unum_getSymbol U_ICU_ENTRY_POINT_RENAME(unum_getSymbol)
 #define unum_getTextAttribute U_ICU_ENTRY_POINT_RENAME(unum_getTextAttribute)
+#define unum_hasAttribute U_ICU_ENTRY_POINT_RENAME(unum_hasAttribute)
 #define unum_open U_ICU_ENTRY_POINT_RENAME(unum_open)
 #define unum_parse U_ICU_ENTRY_POINT_RENAME(unum_parse)
 #define unum_parseDecimal U_ICU_ENTRY_POINT_RENAME(unum_parseDecimal)
diff --git a/deps/icu-small/source/common/unicode/uscript.h b/deps/icu-small/source/common/unicode/uscript.h
index 6cb1532808..dc97ab2ba5 100644
--- a/deps/icu-small/source/common/unicode/uscript.h
+++ b/deps/icu-small/source/common/unicode/uscript.h
@@ -495,6 +495,11 @@ typedef enum UScriptCode {
       /** @stable ICU 70 */
       USCRIPT_VITHKUQI                      = 197,/* Vith */
 
+      /** @stable ICU 72 */
+      USCRIPT_KAWI                          = 198,/* Kawi */
+      /** @stable ICU 72 */
+      USCRIPT_NAG_MUNDARI                   = 199,/* Nagm */
+
 #ifndef U_HIDE_DEPRECATED_API
     /**
      * One more than the highest normal UScriptCode value.
@@ -502,7 +507,7 @@ typedef enum UScriptCode {
      *
      * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
      */
-    USCRIPT_CODE_LIMIT    = 198
+    USCRIPT_CODE_LIMIT    = 200
 #endif  // U_HIDE_DEPRECATED_API
 } UScriptCode;
 
diff --git a/deps/icu-small/source/common/unicode/uset.h b/deps/icu-small/source/common/unicode/uset.h
index 33332f2d36..5dd890e148 100644
--- a/deps/icu-small/source/common/unicode/uset.h
+++ b/deps/icu-small/source/common/unicode/uset.h
@@ -850,15 +850,13 @@ uset_removeAllStrings(USet* set);
 U_CAPI UBool U_EXPORT2
 uset_isEmpty(const USet* set);
 
-#ifndef U_HIDE_DRAFT_API
 /**
  * @param set the set
  * @return true if this set contains multi-character strings or the empty string.
- * @draft ICU 70
+ * @stable ICU 70
  */
 U_CAPI UBool U_EXPORT2
 uset_hasStrings(const USet *set);
-#endif  // U_HIDE_DRAFT_API
 
 /**
  * Returns true if the given USet contains the given character.
@@ -941,18 +939,16 @@ uset_charAt(const USet* set, int32_t charIndex);
 U_CAPI int32_t U_EXPORT2
 uset_size(const USet* set);
 
-#ifndef U_HIDE_DRAFT_API
 /**
  * @param set the set
  * @return the number of ranges in this set.
- * @draft ICU 70
+ * @stable ICU 70
  * @see uset_getItemCount
  * @see uset_getItem
  * @see uset_size
  */
 U_CAPI int32_t U_EXPORT2
 uset_getRangeCount(const USet *set);
-#endif  // U_HIDE_DRAFT_API
 
 /**
  * Returns the number of items in this set.  An item is either a range
diff --git a/deps/icu-small/source/common/unicode/usetiter.h b/deps/icu-small/source/common/unicode/usetiter.h
index 5834c308e4..34992d94b7 100644
--- a/deps/icu-small/source/common/unicode/usetiter.h
+++ b/deps/icu-small/source/common/unicode/usetiter.h
@@ -164,14 +164,13 @@ class U_COMMON_API UnicodeSetIterator U_FINAL : public UObject {
      */
     const UnicodeString& getString();
 
-#ifndef U_HIDE_DRAFT_API
     /**
      * Skips over the remaining code points/ranges, if any.
      * A following call to next() or nextRange() will yield a string, if there is one.
      * No-op if next() would return false, or if it would yield a string anyway.
      *
      * @return *this
-     * @draft ICU 70
+     * @stable ICU 70
      * @see UnicodeSet#strings()
      */
     inline UnicodeSetIterator &skipToStrings() {
@@ -181,7 +180,6 @@ class U_COMMON_API UnicodeSetIterator U_FINAL : public UObject {
         nextElement = 0;
         return *this;
     }
-#endif  // U_HIDE_DRAFT_API
 
     /**
      * Advances the iteration position to the next element in the set, 
diff --git a/deps/icu-small/source/common/unicode/utf_old.h b/deps/icu-small/source/common/unicode/utf_old.h
index 160f5ad0a9..6b868c7280 100644
--- a/deps/icu-small/source/common/unicode/utf_old.h
+++ b/deps/icu-small/source/common/unicode/utf_old.h
@@ -293,10 +293,10 @@ typedef int32_t UTextOffset;
 #ifdef U_UTF8_IMPL
 // No forward declaration if compiling utf_impl.cpp, which defines utf8_countTrailBytes.
 #elif defined(U_STATIC_IMPLEMENTATION) || defined(U_COMMON_IMPLEMENTATION)
-U_CFUNC const uint8_t utf8_countTrailBytes[];
+U_CAPI const uint8_t utf8_countTrailBytes[];
 #else
-U_CFUNC U_IMPORT const uint8_t utf8_countTrailBytes[];    /* U_IMPORT2? */ /*U_IMPORT*/
-#endif
+U_CFUNC U_IMPORT const uint8_t utf8_countTrailBytes[];
+#endif 
 
 /**
  * Count the trail bytes for a UTF-8 lead byte.
diff --git a/deps/icu-small/source/common/unicode/uvernum.h b/deps/icu-small/source/common/unicode/uvernum.h
index 2706e0b060..a93f3509ef 100644
--- a/deps/icu-small/source/common/unicode/uvernum.h
+++ b/deps/icu-small/source/common/unicode/uvernum.h
@@ -31,19 +31,12 @@
   *                    renaming macro, and copyright
   *
   * The following files need to be updated as well, which can be done
-  *  by running the UNIX makefile target 'update-windows-makefiles' in icu/source.
+  *  by running the UNIX makefile target 'update-windows-makefiles' in icu4c/source.
   *
-  *
-  * source/common/common_uwp.vcxproj
-  * source/common/common.vcxproj - update 'Output file name' on the link tab so
-  *                   that it contains the new major/minor combination
-  * source/i18n/i18n.vcxproj - same as for the common.vcxproj
-  * source/i18n/i18n_uwp.vcxproj - same as for the common_uwp.vcxproj
-  * source/layoutex/layoutex.vcproj - same
-  * source/stubdata/stubdata.vcproj - same as for the common.vcxproj
-  * source/io/io.vcproj - same as for the common.vcxproj
+  * source/allinone/Build.Windows.IcuVersion.props - Update the IcuMajorVersion
   * source/data/makedata.mak - change U_ICUDATA_NAME so that it contains
-  *                            the new major/minor combination and the Unicode version.
+  *                            the new major/minor combination, and UNICODE_VERSION
+  *                            for the Unicode version.
   */
 
 #ifndef UVERNUM_H
@@ -60,7 +53,7 @@
  *  This value will change in the subsequent releases of ICU
  *  @stable ICU 2.4
  */
-#define U_ICU_VERSION_MAJOR_NUM 71
+#define U_ICU_VERSION_MAJOR_NUM 72
 
 /** The current ICU minor version as an integer.
  *  This value will change in the subsequent releases of ICU
@@ -86,7 +79,7 @@
  *  This value will change in the subsequent releases of ICU
  *  @stable ICU 2.6
  */
-#define U_ICU_VERSION_SUFFIX _71
+#define U_ICU_VERSION_SUFFIX _72
 
 /**
  * \def U_DEF2_ICU_ENTRY_POINT_RENAME
@@ -139,7 +132,7 @@
  *  This value will change in the subsequent releases of ICU
  *  @stable ICU 2.4
  */
-#define U_ICU_VERSION "71.1"
+#define U_ICU_VERSION "72.1"
 
 /**
  * The current ICU library major version number as a string, for library name suffixes.
@@ -152,13 +145,13 @@
  *
  * @stable ICU 2.6
  */
-#define U_ICU_VERSION_SHORT "71"
+#define U_ICU_VERSION_SHORT "72"
 
 #ifndef U_HIDE_INTERNAL_API
 /** Data version in ICU4C.
  * @internal ICU 4.4 Internal Use Only
  **/
-#define U_ICU_DATA_VERSION "71.1"
+#define U_ICU_DATA_VERSION "72.1"
 #endif  /* U_HIDE_INTERNAL_API */
 
 /*===========================================================================
diff --git a/deps/icu-small/source/common/unifiedcache.cpp b/deps/icu-small/source/common/unifiedcache.cpp
index 493ab79f6d..cfb000b2c8 100644
--- a/deps/icu-small/source/common/unifiedcache.cpp
+++ b/deps/icu-small/source/common/unifiedcache.cpp
@@ -22,7 +22,7 @@
 static icu::UnifiedCache *gCache = NULL;
 static std::mutex *gCacheMutex = nullptr;
 static std::condition_variable *gInProgressValueAddedCond;
-static icu::UInitOnce gCacheInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gCacheInitOnce {};
 
 static const int32_t MAX_EVICT_ITERATIONS = 10;
 static const int32_t DEFAULT_MAX_UNUSED = 1000;
@@ -38,27 +38,27 @@ static UBool U_CALLCONV unifiedcache_cleanup() {
     gCacheMutex = nullptr;
     gInProgressValueAddedCond->~condition_variable();
     gInProgressValueAddedCond = nullptr;
-    return TRUE;
+    return true;
 }
 U_CDECL_END
 
 
 U_NAMESPACE_BEGIN
 
-U_CAPI int32_t U_EXPORT2
+int32_t U_EXPORT2
 ucache_hashKeys(const UHashTok key) {
     const CacheKeyBase *ckey = (const CacheKeyBase *) key.pointer;
     return ckey->hashCode();
 }
 
-U_CAPI UBool U_EXPORT2
+UBool U_EXPORT2
 ucache_compareKeys(const UHashTok key1, const UHashTok key2) {
     const CacheKeyBase *p1 = (const CacheKeyBase *) key1.pointer;
     const CacheKeyBase *p2 = (const CacheKeyBase *) key2.pointer;
     return *p1 == *p2;
 }
 
-U_CAPI void U_EXPORT2
+void U_EXPORT2
 ucache_deleteKey(void *obj) {
     CacheKeyBase *p = (CacheKeyBase *) obj;
     delete p;
@@ -161,7 +161,7 @@ void UnifiedCache::flush() const {
     // Use a loop in case cache items that are flushed held hard references to
     // other cache items making those additional cache items eligible for
     // flushing.
-    while (_flush(FALSE));
+    while (_flush(false));
 }
 
 void UnifiedCache::handleUnreferencedObject() const {
@@ -225,7 +225,7 @@ UnifiedCache::~UnifiedCache() {
         // each other and entries with hard references from outside the cache.
         // Nothing we can do about these so proceed to wipe out the cache.
         std::lock_guard<std::mutex> lock(*gCacheMutex);
-        _flush(TRUE);
+        _flush(true);
     }
     uhash_close(fHashtable);
     fHashtable = nullptr;
@@ -244,7 +244,7 @@ UnifiedCache::_nextElement() const {
 }
 
 UBool UnifiedCache::_flush(UBool all) const {
-    UBool result = FALSE;
+    UBool result = false;
     int32_t origSize = uhash_count(fHashtable);
     for (int32_t i = 0; i < origSize; ++i) {
         const UHashElement *element = _nextElement();
@@ -257,7 +257,7 @@ UBool UnifiedCache::_flush(UBool all) const {
             U_ASSERT(sharedObject->cachePtr == this);
             uhash_removeElement(fHashtable, element);
             removeSoftRef(sharedObject);    // Deletes the sharedObject when softRefCount goes to zero.
-            result = TRUE;
+            result = true;
         }
     }
     return result;
@@ -365,14 +365,14 @@ UBool UnifiedCache::_poll(
     // fetch out the contents and return them.
     if (element != NULL) {
          _fetch(element, value, status);
-        return TRUE;
+        return true;
     }
 
     // The hash table contained nothing for this key.
     // Insert an inProgress place holder value.
     // Our caller will create the final value and update the hash table.
     _putNew(key, fNoValue, U_ZERO_ERROR, status);
-    return FALSE;
+    return false;
 }
 
 void UnifiedCache::_get(
@@ -471,7 +471,7 @@ UBool UnifiedCache::_isEvictable(const UHashElement *element) const
 
     // Entries that are under construction are never evictable
     if (_inProgress(theValue, theKey->fCreationStatus)) {
-        return FALSE;
+        return false;
     }
 
     // We can evict entries that are either not a primary or have just
diff --git a/deps/icu-small/source/common/unifiedcache.h b/deps/icu-small/source/common/unifiedcache.h
index 07a734b8bd..4b9222124a 100644
--- a/deps/icu-small/source/common/unifiedcache.h
+++ b/deps/icu-small/source/common/unifiedcache.h
@@ -354,8 +354,8 @@ class U_COMMON_API UnifiedCache : public UnifiedCacheBase {
    mutable int64_t fAutoEvictedCount;
    SharedObject *fNoValue;
    
-   UnifiedCache(const UnifiedCache &other);
-   UnifiedCache &operator=(const UnifiedCache &other);
+   UnifiedCache(const UnifiedCache &other) = delete;
+   UnifiedCache &operator=(const UnifiedCache &other) = delete;
    
    /**
     * Flushes the contents of the cache. If cache values hold references to other
diff --git a/deps/icu-small/source/common/uniset.cpp b/deps/icu-small/source/common/uniset.cpp
index 92a81a1a02..4faace525c 100644
--- a/deps/icu-small/source/common/uniset.cpp
+++ b/deps/icu-small/source/common/uniset.cpp
@@ -82,7 +82,7 @@ static int32_t _dbgCount = 0;
 
 static inline void _dbgct(UnicodeSet* set) {
     UnicodeString str;
-    set->toPattern(str, TRUE);
+    set->toPattern(str, true);
     char buf[40];
     str.extract(0, 39, buf, "");
     printf("DEBUG UnicodeSet: ct 0x%08X; %d %s\n", set, ++_dbgCount, buf);
@@ -90,7 +90,7 @@ static inline void _dbgct(UnicodeSet* set) {
 
 static inline void _dbgdt(UnicodeSet* set) {
     UnicodeString str;
-    set->toPattern(str, TRUE);
+    set->toPattern(str, true);
     char buf[40];
     str.extract(0, 39, buf, "");
     printf("DEBUG UnicodeSet: dt 0x%08X; %d %s\n", set, --_dbgCount, buf);
@@ -204,7 +204,7 @@ UnicodeSet::~UnicodeSet() {
  * Assigns this object to be a copy of another.
  */
 UnicodeSet& UnicodeSet::operator=(const UnicodeSet& o) {
-    return copyFrom(o, FALSE);
+    return copyFrom(o, false);
 }
 
 UnicodeSet& UnicodeSet::copyFrom(const UnicodeSet& o, UBool asThawed) {
@@ -265,7 +265,7 @@ UnicodeSet* UnicodeSet::clone() const {
 }
 
 UnicodeSet *UnicodeSet::cloneAsThawed() const {
-    return new UnicodeSet(*this, TRUE);
+    return new UnicodeSet(*this, true);
 }
 
 /**
@@ -352,7 +352,7 @@ UBool UnicodeSet::contains(UChar32 c) const {
         return stringSpan->contains(c);
     }
     if (c >= UNICODESET_HIGH) { // Don't need to check LOW bound
-        return FALSE;
+        return false;
     }
     int32_t i = findCodePoint(c);
     return (UBool)(i & 1); // return true if odd
@@ -447,7 +447,7 @@ UBool UnicodeSet::containsAll(const UnicodeSet& c) const {
     int32_t n = c.getRangeCount();
     for (int i=0; i<n; ++i) {
         if (!contains(c.getRangeStart(i), c.getRangeEnd(i))) {
-            return FALSE;
+            return false;
         }
     }
     return !c.hasStrings() || (strings != nullptr && strings->containsAll(*c.strings));
@@ -493,7 +493,7 @@ UBool UnicodeSet::containsNone(const UnicodeSet& c) const {
     int32_t n = c.getRangeCount();
     for (int32_t i=0; i<n; ++i) {
         if (!containsNone(c.getRangeStart(i), c.getRangeEnd(i))) {
-            return FALSE;
+            return false;
         }
     }
     return strings == nullptr || !c.hasStrings() || strings->containsNone(*c.strings);
@@ -531,10 +531,10 @@ UBool UnicodeSet::matchesIndexValue(uint8_t v) const {
         UChar32 high = getRangeEnd(i);
         if ((low & ~0xFF) == (high & ~0xFF)) {
             if ((low & 0xFF) <= v && v <= (high & 0xFF)) {
-                return TRUE;
+                return true;
             }
         } else if ((low & 0xFF) <= v || v <= (high & 0xFF)) {
-            return TRUE;
+            return true;
         }
     }
     if (hasStrings()) {
@@ -545,11 +545,11 @@ UBool UnicodeSet::matchesIndexValue(uint8_t v) const {
             }
             UChar32 c = s.char32At(0);
             if ((c & 0xFF) == v) {
-                return TRUE;
+                return true;
             }
         }
     }
-    return FALSE;
+    return false;
 }
 
 /**
@@ -1603,24 +1603,24 @@ int32_t UnicodeSet::serialize(uint16_t *dest, int32_t destCapacity, UErrorCode&
 //----------------------------------------------------------------
 
 /**
- * Allocate our strings vector and return TRUE if successful.
+ * Allocate our strings vector and return true if successful.
  */
 UBool UnicodeSet::allocateStrings(UErrorCode &status) {
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
     strings = new UVector(uprv_deleteUObject,
                           uhash_compareUnicodeString, 1, status);
     if (strings == NULL) { // Check for memory allocation error.
         status = U_MEMORY_ALLOCATION_ERROR;
-        return FALSE;
+        return false;
     }
     if (U_FAILURE(status)) {
         delete strings;
         strings = NULL;
-        return FALSE;
+        return false;
     } 
-    return TRUE;
+    return true;
 }
 
 int32_t UnicodeSet::nextCapacity(int32_t minCapacity) {
diff --git a/deps/icu-small/source/common/uniset_closure.cpp b/deps/icu-small/source/common/uniset_closure.cpp
index 882231ba1a..d7dab2a17b 100644
--- a/deps/icu-small/source/common/uniset_closure.cpp
+++ b/deps/icu-small/source/common/uniset_closure.cpp
@@ -74,7 +74,7 @@ UnicodeSet& UnicodeSet::applyPattern(const UnicodeString& pattern,
 
     if (options & USET_IGNORE_SPACE) {
         // Skip over trailing whitespace
-        ICU_Utility::skipWhitespace(pattern, i, TRUE);
+        ICU_Utility::skipWhitespace(pattern, i, true);
     }
 
     if (i != pattern.length()) {
@@ -141,7 +141,7 @@ addCaseMapping(UnicodeSet &set, int32_t result, const UChar *full, UnicodeString
             set.add(result);
         } else {
             // add a string case mapping from full with length result
-            str.setTo((UBool)FALSE, full, result);
+            str.setTo((UBool)false, full, result);
             set.add(str);
         }
     }
diff --git a/deps/icu-small/source/common/uniset_props.cpp b/deps/icu-small/source/common/uniset_props.cpp
index 49d6caabc7..48c0a26a71 100644
--- a/deps/icu-small/source/common/uniset_props.cpp
+++ b/deps/icu-small/source/common/uniset_props.cpp
@@ -62,7 +62,7 @@ U_CDECL_BEGIN
 static UBool U_CALLCONV uset_cleanup();
 
 static UnicodeSet *uni32Singleton;
-static icu::UInitOnce uni32InitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce uni32InitOnce {};
 
 /**
  * Cleanup function for UnicodeSet
@@ -71,7 +71,7 @@ static UBool U_CALLCONV uset_cleanup(void) {
     delete uni32Singleton;
     uni32Singleton = NULL;
     uni32InitOnce.reset();
-    return TRUE;
+    return true;
 }
 
 U_CDECL_END
@@ -170,7 +170,7 @@ UnicodeSet& UnicodeSet::applyPattern(const UnicodeString& pattern,
 
     int32_t i = pos.getIndex();
     // Skip over trailing whitespace
-    ICU_Utility::skipWhitespace(pattern, i, TRUE);
+    ICU_Utility::skipWhitespace(pattern, i, true);
     if (i != pattern.length()) {
         status = U_ILLEGAL_ARGUMENT_ERROR;
     }
@@ -279,7 +279,7 @@ void UnicodeSet::applyPattern(RuleCharacterIterator& chars,
     }
 
     UnicodeString patLocal, buf;
-    UBool usePat = FALSE;
+    UBool usePat = false;
     UnicodeSetPointer scratch;
     RuleCharacterIterator::Pos backup;
 
@@ -289,7 +289,7 @@ void UnicodeSet::applyPattern(RuleCharacterIterator& chars,
     UChar32 lastChar = 0;
     UChar op = 0;
 
-    UBool invert = FALSE;
+    UBool invert = false;
 
     clear();
 
@@ -299,7 +299,7 @@ void UnicodeSet::applyPattern(RuleCharacterIterator& chars,
                  (lastItem == 2 && (op == 0 || op == u'-' || op == u'&')));
 
         UChar32 c = 0;
-        UBool literal = FALSE;
+        UBool literal = false;
         UnicodeSet* nested = 0; // alias - do not delete
 
         // -------- Check for property pattern
@@ -336,7 +336,7 @@ void UnicodeSet::applyPattern(RuleCharacterIterator& chars,
                     c = chars.next(opts, literal, ec); 
                     if (U_FAILURE(ec)) return;
                     if (c == u'^' && !literal) {
-                        invert = TRUE;
+                        invert = true;
                         patLocal.append(u'^');
                         chars.getPos(backup); // prepare to backup
                         c = chars.next(opts, literal, ec);
@@ -345,7 +345,7 @@ void UnicodeSet::applyPattern(RuleCharacterIterator& chars,
                     // Fall through to handle special leading '-';
                     // otherwise restart loop for nested [], \p{}, etc.
                     if (c == u'-') {
-                        literal = TRUE;
+                        literal = true;
                         // Fall through to handle literal '-' below
                     } else {
                         chars.setPos(backup); // backup
@@ -381,7 +381,7 @@ void UnicodeSet::applyPattern(RuleCharacterIterator& chars,
                     return;
                 }
                 add(lastChar, lastChar);
-                _appendToPat(patLocal, lastChar, FALSE);
+                _appendToPat(patLocal, lastChar, false);
                 lastItem = 0;
                 op = 0;
             }
@@ -408,11 +408,11 @@ void UnicodeSet::applyPattern(RuleCharacterIterator& chars,
                 if (U_FAILURE(ec)) return;
                 break;
             case 3: // `nested' already parsed
-                nested->_toPattern(patLocal, FALSE);
+                nested->_toPattern(patLocal, false);
                 break;
             }
 
-            usePat = TRUE;
+            usePat = true;
 
             if (mode == 0) {
                 // Entire pattern is a category; leave parse loop
@@ -454,7 +454,7 @@ void UnicodeSet::applyPattern(RuleCharacterIterator& chars,
             case u']':
                 if (lastItem == 1) {
                     add(lastChar, lastChar);
-                    _appendToPat(patLocal, lastChar, FALSE);
+                    _appendToPat(patLocal, lastChar, false);
                 }
                 // Treat final trailing '-' as a literal
                 if (op == u'-') {
@@ -508,17 +508,17 @@ void UnicodeSet::applyPattern(RuleCharacterIterator& chars,
                 }
                 if (lastItem == 1) {
                     add(lastChar, lastChar);
-                    _appendToPat(patLocal, lastChar, FALSE);
+                    _appendToPat(patLocal, lastChar, false);
                 }
                 lastItem = 0;
                 buf.truncate(0);
                 {
-                    UBool ok = FALSE;
+                    UBool ok = false;
                     while (!chars.atEnd()) {
                         c = chars.next(opts, literal, ec);
                         if (U_FAILURE(ec)) return;
                         if (c == u'}' && !literal) {
-                            ok = TRUE;
+                            ok = true;
                             break;
                         }
                         buf.append(c);
@@ -534,7 +534,7 @@ void UnicodeSet::applyPattern(RuleCharacterIterator& chars,
                 // processing
                 add(buf);
                 patLocal.append(u'{');
-                _appendToPat(patLocal, buf, FALSE);
+                _appendToPat(patLocal, buf, false);
                 patLocal.append(u'}');
                 continue;
             case SymbolTable::SYMBOL_REF:
@@ -557,10 +557,10 @@ void UnicodeSet::applyPattern(RuleCharacterIterator& chars,
                     if (anchor && op == 0) {
                         if (lastItem == 1) {
                             add(lastChar, lastChar);
-                            _appendToPat(patLocal, lastChar, FALSE);
+                            _appendToPat(patLocal, lastChar, false);
                         }
                         add(U_ETHER);
-                        usePat = TRUE;
+                        usePat = true;
                         patLocal.append((UChar) SymbolTable::SYMBOL_REF);
                         patLocal.append(u']');
                         mode = 2;
@@ -594,14 +594,14 @@ void UnicodeSet::applyPattern(RuleCharacterIterator& chars,
                     return;
                 }
                 add(lastChar, c);
-                _appendToPat(patLocal, lastChar, FALSE);
+                _appendToPat(patLocal, lastChar, false);
                 patLocal.append(op);
-                _appendToPat(patLocal, c, FALSE);
+                _appendToPat(patLocal, c, false);
                 lastItem = 0;
                 op = 0;
             } else {
                 add(lastChar, lastChar);
-                _appendToPat(patLocal, lastChar, FALSE);
+                _appendToPat(patLocal, lastChar, false);
                 lastChar = c;
             }
             break;
@@ -646,7 +646,7 @@ void UnicodeSet::applyPattern(RuleCharacterIterator& chars,
     if (usePat) {
         rebuiltPat.append(patLocal);
     } else {
-        _generatePattern(rebuiltPat, FALSE);
+        _generatePattern(rebuiltPat, false);
     }
     if (isBogus() && U_SUCCESS(ec)) {
         // We likely ran out of memory. AHHH!
@@ -756,12 +756,12 @@ static UBool mungeCharName(char* dst, const char* src, int32_t dstCapacity) {
         if (ch == ' ' && (j==0 || (j>0 && dst[j-1]==' '))) {
             continue;
         }
-        if (j >= dstCapacity) return FALSE;
+        if (j >= dstCapacity) return false;
         dst[j++] = ch;
     }
     if (j > 0 && dst[j-1] == ' ') --j;
     dst[j] = 0;
-    return TRUE;
+    return true;
 }
 
 }  // namespace
@@ -789,7 +789,7 @@ UnicodeSet::applyIntPropertyValue(UProperty prop, int32_t value, UErrorCode& ec)
         if (value == 0 || value == 1) {
             const USet *set = u_getBinaryPropertySet(prop, &ec);
             if (U_FAILURE(ec)) { return *this; }
-            copyFrom(*UnicodeSet::fromUSet(set), TRUE);
+            copyFrom(*UnicodeSet::fromUSet(set), true);
             if (value == 0) {
                 complement().removeAllStrings();  // code point complement
             }
@@ -830,7 +830,7 @@ UnicodeSet::applyPropertyAlias(const UnicodeString& prop,
 
     UProperty p;
     int32_t v;
-    UBool invert = FALSE;
+    UBool invert = false;
 
     if (value.length() > 0) {
         p = u_getPropertyEnum(pname.data());
@@ -948,7 +948,7 @@ UnicodeSet::applyPropertyAlias(const UnicodeString& prop,
                     // [:Assigned:]=[:^Cn:]
                     p = UCHAR_GENERAL_CATEGORY_MASK;
                     v = U_GC_CN_MASK;
-                    invert = TRUE;
+                    invert = true;
                 } else {
                     FAIL(ec);
                 }
@@ -980,7 +980,7 @@ UBool UnicodeSet::resemblesPropertyPattern(const UnicodeString& pattern,
                                            int32_t pos) {
     // Patterns are at least 5 characters long
     if ((pos+5) > pattern.length()) {
-        return FALSE;
+        return false;
     }
 
     // Look for an opening [:, [:^, \p, or \P
@@ -997,8 +997,8 @@ UBool UnicodeSet::resemblesPropertyPattern(const UnicodeString& pattern,
  */
 UBool UnicodeSet::resemblesPropertyPattern(RuleCharacterIterator& chars,
                                            int32_t iterOpts) {
-    // NOTE: literal will always be FALSE, because we don't parse escapes.
-    UBool result = FALSE, literal;
+    // NOTE: literal will always be false, because we don't parse escapes.
+    UBool result = false, literal;
     UErrorCode ec = U_ZERO_ERROR;
     iterOpts &= ~RuleCharacterIterator::PARSE_ESCAPES;
     RuleCharacterIterator::Pos pos;
@@ -1022,9 +1022,9 @@ UnicodeSet& UnicodeSet::applyPropertyPattern(const UnicodeString& pattern,
                                              UErrorCode &ec) {
     int32_t pos = ppos.getIndex();
 
-    UBool posix = FALSE; // true for [:pat:], false for \p{pat} \P{pat} \N{pat}
-    UBool isName = FALSE; // true for \N{pat}, o/w false
-    UBool invert = FALSE;
+    UBool posix = false; // true for [:pat:], false for \p{pat} \P{pat} \N{pat}
+    UBool isName = false; // true for \N{pat}, o/w false
+    UBool invert = false;
 
     if (U_FAILURE(ec)) return *this;
 
@@ -1036,12 +1036,12 @@ UnicodeSet& UnicodeSet::applyPropertyPattern(const UnicodeString& pattern,
     // On entry, ppos should point to one of the following locations:
     // Look for an opening [:, [:^, \p, or \P
     if (isPOSIXOpen(pattern, pos)) {
-        posix = TRUE;
+        posix = true;
         pos += 2;
         pos = ICU_Utility::skipWhitespace(pattern, pos);
         if (pos < pattern.length() && pattern.charAt(pos) == u'^') {
             ++pos;
-            invert = TRUE;
+            invert = true;
         }
     } else if (isPerlOpen(pattern, pos) || isNameOpen(pattern, pos)) {
         UChar c = pattern.charAt(pos+1);
diff --git a/deps/icu-small/source/common/unisetspan.cpp b/deps/icu-small/source/common/unisetspan.cpp
index fe0d74f5b2..e4277c5be6 100644
--- a/deps/icu-small/source/common/unisetspan.cpp
+++ b/deps/icu-small/source/common/unisetspan.cpp
@@ -98,7 +98,7 @@ public:
             i-=capacity;
         }
         if(list[i]) {
-            list[i]=FALSE;
+            list[i]=false;
             --length;
         }
         start=i;
@@ -111,7 +111,7 @@ public:
         if(i>=capacity) {
             i-=capacity;
         }
-        list[i]=TRUE;
+        list[i]=true;
         ++length;
     }
 
@@ -132,7 +132,7 @@ public:
         int32_t i=start, result;
         while(++i<capacity) {
             if(list[i]) {
-                list[i]=FALSE;
+                list[i]=false;
                 --length;
                 result=i-start;
                 start=i;
@@ -148,7 +148,7 @@ public:
         while(!list[i]) {
             ++i;
         }
-        list[i]=FALSE;
+        list[i]=false;
         --length;
         start=i;
         return result+=i;
@@ -226,7 +226,7 @@ UnicodeSetStringSpan::UnicodeSetStringSpan(const UnicodeSet &set,
     int32_t stringsLength=strings.size();
 
     int32_t i, spanLength;
-    UBool someRelevant=FALSE;
+    UBool someRelevant=false;
     for(i=0; i<stringsLength; ++i) {
         const UnicodeString &string=*(const UnicodeString *)strings.elementAt(i);
         const UChar *s16=string.getBuffer();
@@ -237,9 +237,9 @@ UnicodeSetStringSpan::UnicodeSetStringSpan(const UnicodeSet &set,
         UBool thisRelevant;
         spanLength=spanSet.span(s16, length16, USET_SPAN_CONTAINED);
         if(spanLength<length16) {  // Relevant string.
-            someRelevant=thisRelevant=TRUE;
+            someRelevant=thisRelevant=true;
         } else {
-            thisRelevant=FALSE;
+            thisRelevant=false;
         }
         if((which&UTF16) && length16>maxLength16) {
             maxLength16=length16;
@@ -284,7 +284,7 @@ UnicodeSetStringSpan::UnicodeSetStringSpan(const UnicodeSet &set,
     } else {
         utf8Lengths=(int32_t *)uprv_malloc(allocSize);
         if(utf8Lengths==NULL) {
-            maxLength16=maxLength8=0;  // Prevent usage by making needsStringSpanUTF16/8() return FALSE.
+            maxLength16=maxLength8=0;  // Prevent usage by making needsStringSpanUTF16/8() return false.
             return;  // Out of memory.
         }
     }
@@ -399,7 +399,7 @@ UnicodeSetStringSpan::UnicodeSetStringSpan(const UnicodeSetStringSpan &otherStri
           utf8Lengths(NULL), spanLengths(NULL), utf8(NULL),
           utf8Length(otherStringSpan.utf8Length),
           maxLength16(otherStringSpan.maxLength16), maxLength8(otherStringSpan.maxLength8),
-          all(TRUE) {
+          all(true) {
     if(otherStringSpan.pSpanNotSet==&otherStringSpan.spanSet) {
         pSpanNotSet=&spanSet;
     } else {
@@ -415,7 +415,7 @@ UnicodeSetStringSpan::UnicodeSetStringSpan(const UnicodeSetStringSpan &otherStri
     } else {
         utf8Lengths=(int32_t *)uprv_malloc(allocSize);
         if(utf8Lengths==NULL) {
-            maxLength16=maxLength8=0;  // Prevent usage by making needsStringSpanUTF16/8() return FALSE.
+            maxLength16=maxLength8=0;  // Prevent usage by making needsStringSpanUTF16/8() return false.
             return;  // Out of memory.
         }
     }
@@ -454,20 +454,20 @@ static inline UBool
 matches16(const UChar *s, const UChar *t, int32_t length) {
     do {
         if(*s++!=*t++) {
-            return FALSE;
+            return false;
         }
     } while(--length>0);
-    return TRUE;
+    return true;
 }
 
 static inline UBool
 matches8(const uint8_t *s, const uint8_t *t, int32_t length) {
     do {
         if(*s++!=*t++) {
-            return FALSE;
+            return false;
         }
     } while(--length>0);
-    return TRUE;
+    return true;
 }
 
 // Compare 16-bit Unicode strings (which may be malformed UTF-16)
diff --git a/deps/icu-small/source/common/unistr.cpp b/deps/icu-small/source/common/unistr.cpp
index c18665928d..4125d19472 100644
--- a/deps/icu-small/source/common/unistr.cpp
+++ b/deps/icu-small/source/common/unistr.cpp
@@ -197,7 +197,7 @@ UnicodeString::UnicodeString(UChar ch) {
 UnicodeString::UnicodeString(UChar32 ch) {
   fUnion.fFields.fLengthAndFlags = kShortString;
   int32_t i = 0;
-  UBool isError = FALSE;
+  UBool isError = false;
   U16_APPEND(fUnion.fStackFields.fBuffer, i, US_STACKBUF_SIZE, ch, isError);
   // We test isError so that the compiler does not complain that we don't.
   // If isError then i==0 which is what we want anyway.
@@ -270,7 +270,7 @@ UnicodeString::UnicodeString(const char *src, int32_t length, EInvariant) {
     if(length<0) {
       length=(int32_t)uprv_strlen(src);
     }
-    if(cloneArrayIfNeeded(length, length, FALSE)) {
+    if(cloneArrayIfNeeded(length, length, false)) {
       u_charsToUChars(src, getArrayStart(), length);
       setLength(length);
     } else {
@@ -309,7 +309,7 @@ UnicodeString::UnicodeString(const UnicodeString& that) {
 }
 
 UnicodeString::UnicodeString(UnicodeString &&src) U_NOEXCEPT {
-  copyFieldsFrom(src, TRUE);
+  copyFieldsFrom(src, true);
 }
 
 UnicodeString::UnicodeString(const UnicodeString& that,
@@ -370,7 +370,7 @@ UBool
 UnicodeString::allocate(int32_t capacity) {
   if(capacity <= US_STACKBUF_SIZE) {
     fUnion.fFields.fLengthAndFlags = kShortString;
-    return TRUE;
+    return true;
   }
   if(capacity <= kMaxCapacity) {
     ++capacity;  // for the NUL
@@ -389,13 +389,13 @@ UnicodeString::allocate(int32_t capacity) {
       fUnion.fFields.fArray = (UChar *)array;
       fUnion.fFields.fCapacity = (int32_t)(numBytes / U_SIZEOF_UCHAR);
       fUnion.fFields.fLengthAndFlags = kLongString;
-      return TRUE;
+      return true;
     }
   }
   fUnion.fFields.fLengthAndFlags = kIsBogus;
   fUnion.fFields.fArray = 0;
   fUnion.fFields.fCapacity = 0;
-  return FALSE;
+  return false;
 }
 
 //========================================
@@ -476,7 +476,7 @@ UnicodeString UnicodeString::fromUTF32(const UChar32 *utf32, int32_t length) {
       result.setToBogus();
     }
     break;
-  } while(TRUE);
+  } while(true);
   return result;
 }
 
@@ -491,7 +491,7 @@ UnicodeString::operator=(const UnicodeString &src) {
 
 UnicodeString &
 UnicodeString::fastCopyFrom(const UnicodeString &src) {
-  return copyFrom(src, TRUE);
+  return copyFrom(src, true);
 }
 
 UnicodeString &
@@ -576,7 +576,7 @@ UnicodeString &UnicodeString::operator=(UnicodeString &&src) U_NOEXCEPT {
   // No explicit check for self move assignment, consistent with standard library.
   // Self move assignment causes no crash nor leak but might make the object bogus.
   releaseArray();
-  copyFieldsFrom(src, TRUE);
+  copyFieldsFrom(src, true);
   return *this;
 }
 
@@ -610,9 +610,9 @@ void UnicodeString::copyFieldsFrom(UnicodeString &src, UBool setSrcToBogus) U_NO
 void UnicodeString::swap(UnicodeString &other) U_NOEXCEPT {
   UnicodeString temp;  // Empty short string: Known not to need releaseArray().
   // Copy fields without resetting source values in between.
-  temp.copyFieldsFrom(*this, FALSE);
-  this->copyFieldsFrom(other, FALSE);
-  other.copyFieldsFrom(temp, FALSE);
+  temp.copyFieldsFrom(*this, false);
+  this->copyFieldsFrom(other, false);
+  other.copyFieldsFrom(temp, false);
   // Set temp to an empty string so that other's memory is not released twice.
   temp.fUnion.fFields.fLengthAndFlags = kShortString;
 }
@@ -761,7 +761,7 @@ UnicodeString::doCompareCodePointOrder(int32_t start,
     srcStart = srcLength = 0;
   }
 
-  int32_t diff = uprv_strCompare(getArrayStart() + start, length, (srcChars!=NULL)?(srcChars + srcStart):NULL, srcLength, FALSE, TRUE);
+  int32_t diff = uprv_strCompare(getArrayStart() + start, length, (srcChars!=NULL)?(srcChars + srcStart):NULL, srcLength, false, true);
   /* translate the 32-bit result into an 8-bit one */
   if(diff!=0) {
     return (int8_t)(diff >> 15 | 1);
@@ -921,7 +921,7 @@ UnicodeString::tempSubString(int32_t start, int32_t len) const {
     array=fUnion.fStackFields.fBuffer;  // anything not NULL because that would make an empty string
     len=-2;  // bogus result string
   }
-  return UnicodeString(FALSE, array + start, len);
+  return UnicodeString(false, array + start, len);
 }
 
 int32_t
@@ -972,7 +972,7 @@ UnicodeString::toUTF8(ByteSink &sink) const {
   if(length16 != 0) {
     char stackBuffer[1024];
     int32_t capacity = (int32_t)sizeof(stackBuffer);
-    UBool utf8IsOwned = FALSE;
+    UBool utf8IsOwned = false;
     char *utf8 = sink.GetAppendBuffer(length16 < capacity ? length16 : capacity,
                                       3*length16,
                                       stackBuffer, capacity,
@@ -987,7 +987,7 @@ UnicodeString::toUTF8(ByteSink &sink) const {
     if(errorCode == U_BUFFER_OVERFLOW_ERROR) {
       utf8 = (char *)uprv_malloc(length8);
       if(utf8 != NULL) {
-        utf8IsOwned = TRUE;
+        utf8IsOwned = true;
         errorCode = U_ZERO_ERROR;
         u_strToUTF8WithSub(utf8, length8, &length8,
                            getBuffer(), length16,
@@ -1225,7 +1225,7 @@ UnicodeString::getTerminatedBuffer() {
   if(len < getCapacity()) {
     if(fUnion.fFields.fLengthAndFlags & kBufferIsReadonly) {
       // If len<capacity on a read-only alias, then array[len] is
-      // either the original NUL (if constructed with (TRUE, s, length))
+      // either the original NUL (if constructed with (true, s, length))
       // or one of the original string contents characters (if later truncated),
       // therefore we can assume that array[len] is initialized memory.
       if(array[len] == 0) {
@@ -1375,7 +1375,7 @@ UnicodeString::replace(int32_t start,
                UChar32 srcChar) {
   UChar buffer[U16_MAX_LENGTH];
   int32_t count = 0;
-  UBool isError = FALSE;
+  UBool isError = false;
   U16_APPEND(buffer, count, U16_MAX_LENGTH, srcChar, isError);
   // We test isError so that the compiler does not complain that we don't.
   // If isError (srcChar is not a valid code point) then count==0 which means
@@ -1387,7 +1387,7 @@ UnicodeString&
 UnicodeString::append(UChar32 srcChar) {
   UChar buffer[U16_MAX_LENGTH];
   int32_t _length = 0;
-  UBool isError = FALSE;
+  UBool isError = false;
   U16_APPEND(buffer, _length, U16_MAX_LENGTH, srcChar, isError);
   // We test isError so that the compiler does not complain that we don't.
   // If isError then _length==0 which turns the doAppend() into a no-op anyway.
@@ -1484,7 +1484,7 @@ UnicodeString::doReplace(int32_t start,
     return doReplace(start, length, copy.getArrayStart(), 0, srcLength);
   }
 
-  // cloneArrayIfNeeded(doCopyArray=FALSE) may change fArray but will not copy the current contents;
+  // cloneArrayIfNeeded(doCopyArray=false) may change fArray but will not copy the current contents;
   // therefore we need to keep the current fArray
   UChar oldStackBuffer[US_STACKBUF_SIZE];
   if((fUnion.fFields.fLengthAndFlags&kUsingStackBuffer) && (newLength > US_STACKBUF_SIZE)) {
@@ -1497,7 +1497,7 @@ UnicodeString::doReplace(int32_t start,
   // clone our array and allocate a bigger array if needed
   int32_t *bufferToDelete = 0;
   if(!cloneArrayIfNeeded(newLength, getGrowCapacity(newLength),
-                         FALSE, &bufferToDelete)
+                         false, &bufferToDelete)
   ) {
     return *this;
   }
@@ -1637,14 +1637,14 @@ UnicodeString::copy(int32_t start, int32_t limit, int32_t dest) {
  * so we implement this function here.
  */
 UBool Replaceable::hasMetaData() const {
-    return TRUE;
+    return true;
 }
 
 /**
  * Replaceable API
  */
 UBool UnicodeString::hasMetaData() const {
-    return FALSE;
+    return false;
 }
 
 UnicodeString&
@@ -1662,7 +1662,7 @@ UnicodeString::doReverse(int32_t start, int32_t length) {
   UChar *left = getArrayStart() + start;
   UChar *right = left + length - 1;  // -1 for inclusive boundary (length>=2)
   UChar swap;
-  UBool hasSupplementary = FALSE;
+  UBool hasSupplementary = false;
 
   // Before the loop we know left<right because length>=2.
   do {
@@ -1699,7 +1699,7 @@ UnicodeString::padLeading(int32_t targetLength,
 {
   int32_t oldLength = length();
   if(oldLength >= targetLength || !cloneArrayIfNeeded(targetLength)) {
-    return FALSE;
+    return false;
   } else {
     // move contents up by padding width
     UChar *array = getArrayStart();
@@ -1711,7 +1711,7 @@ UnicodeString::padLeading(int32_t targetLength,
       array[start] = padChar;
     }
     setLength(targetLength);
-    return TRUE;
+    return true;
   }
 }
 
@@ -1721,7 +1721,7 @@ UnicodeString::padTrailing(int32_t targetLength,
 {
   int32_t oldLength = length();
   if(oldLength >= targetLength || !cloneArrayIfNeeded(targetLength)) {
-    return FALSE;
+    return false;
   } else {
     // fill in padding character
     UChar *array = getArrayStart();
@@ -1730,7 +1730,7 @@ UnicodeString::padTrailing(int32_t targetLength,
       array[length] = padChar;
     }
     setLength(targetLength);
-    return TRUE;
+    return true;
   }
 }
 
@@ -1800,10 +1800,10 @@ UnicodeString::cloneArrayIfNeeded(int32_t newCapacity,
   }
 
   // while a getBuffer(minCapacity) is "open",
-  // prevent any modifications of the string by returning FALSE here
+  // prevent any modifications of the string by returning false here
   // if the string is bogus, then only an assignment or similar can revive it
   if(!isWritable()) {
-    return FALSE;
+    return false;
   }
 
   /*
@@ -1811,7 +1811,7 @@ UnicodeString::cloneArrayIfNeeded(int32_t newCapacity,
    * the buffer is read-only, or
    * the buffer is refCounted (shared), and refCount>1, or
    * the buffer is too small.
-   * Return FALSE if memory could not be allocated.
+   * Return false if memory could not be allocated.
    */
   if(forceClone ||
      fUnion.fFields.fLengthAndFlags & kBufferIsReadonly ||
@@ -1890,10 +1890,10 @@ UnicodeString::cloneArrayIfNeeded(int32_t newCapacity,
       }
       fUnion.fFields.fLengthAndFlags = flags;
       setToBogus();
-      return FALSE;
+      return false;
     }
   }
-  return TRUE;
+  return true;
 }
 
 // UnicodeStringAppendable ------------------------------------------------- ***
@@ -1909,7 +1909,7 @@ UBool
 UnicodeStringAppendable::appendCodePoint(UChar32 c) {
   UChar buffer[U16_MAX_LENGTH];
   int32_t cLength = 0;
-  UBool isError = FALSE;
+  UBool isError = false;
   U16_APPEND(buffer, cLength, U16_MAX_LENGTH, c, isError);
   return !isError && str.doAppend(buffer, 0, cLength).isWritable();
 }
@@ -1961,10 +1961,10 @@ uhash_compareUnicodeString(const UElement key1, const UElement key2) {
     const UnicodeString *str1 = (const UnicodeString*) key1.pointer;
     const UnicodeString *str2 = (const UnicodeString*) key2.pointer;
     if (str1 == str2) {
-        return TRUE;
+        return true;
     }
     if (str1 == NULL || str2 == NULL) {
-        return FALSE;
+        return false;
     }
     return *str1 == *str2;
 }
diff --git a/deps/icu-small/source/common/unistr_case.cpp b/deps/icu-small/source/common/unistr_case.cpp
index 2138d60c01..f4c43b4889 100644
--- a/deps/icu-small/source/common/unistr_case.cpp
+++ b/deps/icu-small/source/common/unistr_case.cpp
@@ -123,7 +123,7 @@ UnicodeString::caseMap(int32_t caseLocale, uint32_t options, UCASEMAP_BREAK_ITER
       capacity = getCapacity();
     } else {
       // Switch from the read-only alias or shared heap buffer to the stack buffer.
-      if (!cloneArrayIfNeeded(US_STACKBUF_SIZE, US_STACKBUF_SIZE, /* doCopyArray= */ FALSE)) {
+      if (!cloneArrayIfNeeded(US_STACKBUF_SIZE, US_STACKBUF_SIZE, /* doCopyArray= */ false)) {
         return *this;
       }
       U_ASSERT(fUnion.fFields.fLengthAndFlags & kUsingStackBuffer);
@@ -132,7 +132,7 @@ UnicodeString::caseMap(int32_t caseLocale, uint32_t options, UCASEMAP_BREAK_ITER
     }
 #if !UCONFIG_NO_BREAK_ITERATION
     if (iter != nullptr) {
-      oldString.setTo(FALSE, oldArray, oldLength);
+      oldString.setTo(false, oldArray, oldLength);
       iter->setText(oldString);
     }
 #endif
@@ -158,7 +158,7 @@ UnicodeString::caseMap(int32_t caseLocale, uint32_t options, UCASEMAP_BREAK_ITER
     UChar replacementChars[200];
 #if !UCONFIG_NO_BREAK_ITERATION
     if (iter != nullptr) {
-      oldString.setTo(FALSE, oldArray, oldLength);
+      oldString.setTo(false, oldArray, oldLength);
       iter->setText(oldString);
     }
 #endif
@@ -194,7 +194,7 @@ UnicodeString::caseMap(int32_t caseLocale, uint32_t options, UCASEMAP_BREAK_ITER
   // and deletes the old array itself after it is done.
   // In addition, we are forcing cloneArrayIfNeeded() to always allocate a new array.
   int32_t *bufferToDelete = 0;
-  if (!cloneArrayIfNeeded(newLength, newLength, FALSE, &bufferToDelete, TRUE)) {
+  if (!cloneArrayIfNeeded(newLength, newLength, false, &bufferToDelete, true)) {
     return *this;
   }
   errorCode = U_ZERO_ERROR;
@@ -241,10 +241,10 @@ uhash_compareCaselessUnicodeString(const UElement key1, const UElement key2) {
     const UnicodeString *str1 = (const UnicodeString*) key1.pointer;
     const UnicodeString *str2 = (const UnicodeString*) key2.pointer;
     if (str1 == str2) {
-        return TRUE;
+        return true;
     }
     if (str1 == NULL || str2 == NULL) {
-        return FALSE;
+        return false;
     }
     return str1->caseCompare(*str2, U_FOLD_CASE_DEFAULT) == 0;
 }
diff --git a/deps/icu-small/source/common/unistr_cnv.cpp b/deps/icu-small/source/common/unistr_cnv.cpp
index 64d3c16801..e1f60d4487 100644
--- a/deps/icu-small/source/common/unistr_cnv.cpp
+++ b/deps/icu-small/source/common/unistr_cnv.cpp
@@ -225,13 +225,13 @@ UnicodeString::extract(char *dest, int32_t destCapacity,
     // get the converter
     UBool isDefaultConverter;
     if(cnv==0) {
-        isDefaultConverter=TRUE;
+        isDefaultConverter=true;
         cnv=u_getDefaultConverter(&errorCode);
         if(U_FAILURE(errorCode)) {
             return 0;
         }
     } else {
-        isDefaultConverter=FALSE;
+        isDefaultConverter=false;
         ucnv_resetFromUnicode(cnv);
     }
 
@@ -275,7 +275,7 @@ UnicodeString::doExtract(int32_t start, int32_t length,
     }
 
     // perform the conversion
-    ucnv_fromUnicode(cnv, &dest, destLimit, &src, srcLimit, 0, TRUE, &errorCode);
+    ucnv_fromUnicode(cnv, &dest, destLimit, &src, srcLimit, 0, true, &errorCode);
     length=(int32_t)(dest-originalDest);
 
     // if an overflow occurs, then get the preflighting length
@@ -286,7 +286,7 @@ UnicodeString::doExtract(int32_t start, int32_t length,
         do {
             dest=buffer;
             errorCode=U_ZERO_ERROR;
-            ucnv_fromUnicode(cnv, &dest, destLimit, &src, srcLimit, 0, TRUE, &errorCode);
+            ucnv_fromUnicode(cnv, &dest, destLimit, &src, srcLimit, 0, true, &errorCode);
             length+=(int32_t)(dest-buffer);
         } while(errorCode==U_BUFFER_OVERFLOW_ERROR);
     }
@@ -322,7 +322,7 @@ UnicodeString::doCodepageCreate(const char *codepageData,
         converter = u_getDefaultConverter(&status);
     } else if(*codepage == 0) {
         // use the "invariant characters" conversion
-        if(cloneArrayIfNeeded(dataLength, dataLength, FALSE)) {
+        if(cloneArrayIfNeeded(dataLength, dataLength, false)) {
             u_charsToUChars(codepageData, getArrayStart(), dataLength);
             setLength(dataLength);
         } else {
@@ -379,7 +379,7 @@ UnicodeString::doCodepageCreate(const char *codepageData,
     }
 
     // we do not care about the current contents
-    UBool doCopyArray = FALSE;
+    UBool doCopyArray = false;
     for(;;) {
         if(!cloneArrayIfNeeded(arraySize, arraySize, doCopyArray)) {
             setToBogus();
@@ -390,7 +390,7 @@ UnicodeString::doCodepageCreate(const char *codepageData,
         array = getArrayStart();
         myTarget = array + length();
         ucnv_toUnicode(converter, &myTarget,  array + getCapacity(),
-            &mySource, mySourceEnd, 0, TRUE, &status);
+            &mySource, mySourceEnd, 0, true, &status);
 
         // update the conversion parameters
         setLength((int32_t)(myTarget - array));
@@ -401,7 +401,7 @@ UnicodeString::doCodepageCreate(const char *codepageData,
             status = U_ZERO_ERROR;
 
             // keep the previous conversion results
-            doCopyArray = TRUE;
+            doCopyArray = true;
 
             // estimate the new size needed, larger than before
             // try 2 UChar's per remaining source byte
diff --git a/deps/icu-small/source/common/unorm.cpp b/deps/icu-small/source/common/unorm.cpp
index 2d9f46052f..cf3915c27f 100644
--- a/deps/icu-small/source/common/unorm.cpp
+++ b/deps/icu-small/source/common/unorm.cpp
@@ -128,7 +128,7 @@ _iterate(UCharIterator *src, UBool forward,
     }
 
     if(pNeededToNormalize!=NULL) {
-        *pNeededToNormalize=FALSE;
+        *pNeededToNormalize=false;
     }
     if(!(forward ? src->hasNext(src) : src->hasPrevious(src))) {
         return u_terminateUChars(dest, destCapacity, 0, pErrorCode);
@@ -199,7 +199,7 @@ unorm_previous(UCharIterator *src,
                UNormalizationMode mode, int32_t options,
                UBool doNormalize, UBool *pNeededToNormalize,
                UErrorCode *pErrorCode) {
-    return unorm_iterate(src, FALSE,
+    return unorm_iterate(src, false,
                          dest, destCapacity,
                          mode, options,
                          doNormalize, pNeededToNormalize,
@@ -212,7 +212,7 @@ unorm_next(UCharIterator *src,
            UNormalizationMode mode, int32_t options,
            UBool doNormalize, UBool *pNeededToNormalize,
            UErrorCode *pErrorCode) {
-    return unorm_iterate(src, TRUE,
+    return unorm_iterate(src, true,
                          dest, destCapacity,
                          mode, options,
                          doNormalize, pNeededToNormalize,
diff --git a/deps/icu-small/source/common/unormcmp.cpp b/deps/icu-small/source/common/unormcmp.cpp
index 689b0b53b2..e224190972 100644
--- a/deps/icu-small/source/common/unormcmp.cpp
+++ b/deps/icu-small/source/common/unormcmp.cpp
@@ -536,7 +536,7 @@ UBool _normalize(const Normalizer2 *n2, const UChar *s, int32_t length,
     // check if s fulfill the conditions
     int32_t spanQCYes=n2->spanQuickCheckYes(str, *pErrorCode);
     if (U_FAILURE(*pErrorCode)) {
-        return FALSE;
+        return false;
     }
     /*
      * ICU 2.4 had a further optimization:
@@ -548,13 +548,13 @@ UBool _normalize(const Normalizer2 *n2, const UChar *s, int32_t length,
      */
     if(spanQCYes<str.length()) {
         UnicodeString unnormalized=str.tempSubString(spanQCYes);
-        normalized.setTo(FALSE, str.getBuffer(), spanQCYes);
+        normalized.setTo(false, str.getBuffer(), spanQCYes);
         n2->normalizeSecondAndAppend(normalized, unnormalized, *pErrorCode);
         if (U_SUCCESS(*pErrorCode)) {
-            return TRUE;
+            return true;
         }
     }
-    return FALSE;
+    return false;
 }
 
 U_CAPI int32_t U_EXPORT2
diff --git a/deps/icu-small/source/common/uprops.cpp b/deps/icu-small/source/common/uprops.cpp
index 5186a0c75c..26e950b876 100644
--- a/deps/icu-small/source/common/uprops.cpp
+++ b/deps/icu-small/source/common/uprops.cpp
@@ -49,7 +49,7 @@ U_NAMESPACE_USE
 
 namespace {
 
-icu::UInitOnce gLayoutInitOnce = U_INITONCE_INITIALIZER;
+icu::UInitOnce gLayoutInitOnce {};
 UDataMemory *gLayoutMemory = nullptr;
 
 UCPTrie *gInpcTrie = nullptr;  // Indic_Positional_Category
@@ -76,7 +76,7 @@ UBool U_CALLCONV uprops_cleanup() {
     gMaxVoValue = 0;
 
     gLayoutInitOnce.reset();
-    return TRUE;
+    return true;
 }
 
 UBool U_CALLCONV
@@ -141,7 +141,7 @@ void U_CALLCONV ulayout_load(UErrorCode &errorCode) {
 }
 
 UBool ulayout_ensureData(UErrorCode &errorCode) {
-    if (U_FAILURE(errorCode)) { return FALSE; }
+    if (U_FAILURE(errorCode)) { return false; }
     umtx_initOnce(gLayoutInitOnce, &ulayout_load, errorCode);
     return U_SUCCESS(errorCode);
 }
@@ -188,7 +188,7 @@ static UBool isJoinControl(const BinaryProperty &/*prop*/, UChar32 c, UProperty
 
 #if UCONFIG_NO_NORMALIZATION
 static UBool hasFullCompositionExclusion(const BinaryProperty &, UChar32, UProperty) {
-    return FALSE;
+    return false;
 }
 #else
 static UBool hasFullCompositionExclusion(const BinaryProperty &/*prop*/, UChar32 c, UProperty /*which*/) {
@@ -202,7 +202,7 @@ static UBool hasFullCompositionExclusion(const BinaryProperty &/*prop*/, UChar32
 // UCHAR_NF*_INERT properties
 #if UCONFIG_NO_NORMALIZATION
 static UBool isNormInert(const BinaryProperty &, UChar32, UProperty) {
-    return FALSE;
+    return false;
 }
 #else
 static UBool isNormInert(const BinaryProperty &/*prop*/, UChar32 c, UProperty which) {
@@ -215,7 +215,7 @@ static UBool isNormInert(const BinaryProperty &/*prop*/, UChar32 c, UProperty wh
 
 #if UCONFIG_NO_NORMALIZATION
 static UBool changesWhenCasefolded(const BinaryProperty &, UChar32, UProperty) {
-    return FALSE;
+    return false;
 }
 #else
 static UBool changesWhenCasefolded(const BinaryProperty &/*prop*/, UChar32 c, UProperty /*which*/) {
@@ -223,7 +223,7 @@ static UBool changesWhenCasefolded(const BinaryProperty &/*prop*/, UChar32 c, UP
     UErrorCode errorCode=U_ZERO_ERROR;
     const Normalizer2 *nfcNorm2=Normalizer2::getNFCInstance(errorCode);
     if(U_FAILURE(errorCode)) {
-        return FALSE;
+        return false;
     }
     if(nfcNorm2->getDecomposition(c, nfd)) {
         /* c has a decomposition */
@@ -237,7 +237,7 @@ static UBool changesWhenCasefolded(const BinaryProperty &/*prop*/, UChar32 c, UP
             c=U_SENTINEL;
         }
     } else if(c<0) {
-        return FALSE;  /* protect against bad input */
+        return false;  /* protect against bad input */
     }
     if(c>=0) {
         /* single code point */
@@ -252,21 +252,21 @@ static UBool changesWhenCasefolded(const BinaryProperty &/*prop*/, UChar32 c, UP
                                   U_FOLD_CASE_DEFAULT, &errorCode);
         return (UBool)(U_SUCCESS(errorCode) &&
                        0!=u_strCompare(nfd.getBuffer(), nfd.length(),
-                                       dest, destLength, FALSE));
+                                       dest, destLength, false));
     }
 }
 #endif
 
 #if UCONFIG_NO_NORMALIZATION
 static UBool changesWhenNFKC_Casefolded(const BinaryProperty &, UChar32, UProperty) {
-    return FALSE;
+    return false;
 }
 #else
 static UBool changesWhenNFKC_Casefolded(const BinaryProperty &/*prop*/, UChar32 c, UProperty /*which*/) {
     UErrorCode errorCode=U_ZERO_ERROR;
     const Normalizer2Impl *kcf=Normalizer2Factory::getNFKC_CFImpl(errorCode);
     if(U_FAILURE(errorCode)) {
-        return FALSE;
+        return false;
     }
     UnicodeString src(c);
     UnicodeString dest;
@@ -277,8 +277,8 @@ static UBool changesWhenNFKC_Casefolded(const BinaryProperty &/*prop*/, UChar32
         // Small destCapacity for NFKC_CF(c).
         if(buffer.init(5, errorCode)) {
             const UChar *srcArray=src.getBuffer();
-            kcf->compose(srcArray, srcArray+src.length(), FALSE,
-                          TRUE, buffer, errorCode);
+            kcf->compose(srcArray, srcArray+src.length(), false,
+                          true, buffer, errorCode);
         }
     }
     return U_SUCCESS(errorCode) && dest!=src;
@@ -287,7 +287,7 @@ static UBool changesWhenNFKC_Casefolded(const BinaryProperty &/*prop*/, UChar32
 
 #if UCONFIG_NO_NORMALIZATION
 static UBool isCanonSegmentStarter(const BinaryProperty &, UChar32, UProperty) {
-    return FALSE;
+    return false;
 }
 #else
 static UBool isCanonSegmentStarter(const BinaryProperty &/*prop*/, UChar32 c, UProperty /*which*/) {
@@ -416,7 +416,7 @@ u_hasBinaryProperty(UChar32 c, UProperty which) {
     /* c is range-checked in the functions that are called from here */
     if(which<UCHAR_BINARY_START || UCHAR_BINARY_LIMIT<=which) {
         /* not a known binary property */
-        return FALSE;
+        return false;
     } else {
         const BinaryProperty &prop=binProps[which];
         return prop.contains(prop, c, which);
@@ -670,7 +670,7 @@ U_CAPI int32_t U_EXPORT2
 u_getIntPropertyMaxValue(UProperty which) {
     if(which<UCHAR_INT_START) {
         if(UCHAR_BINARY_START<=which && which<UCHAR_BINARY_LIMIT) {
-            return 1;  // maximum TRUE for all binary properties
+            return 1;  // maximum true for all binary properties
         }
     } else if(which<UCHAR_INT_LIMIT) {
         const IntProperty &prop=intProps[which-UCHAR_INT_START];
@@ -812,7 +812,7 @@ u_getFC_NFKC_Closure(UChar32 c, UChar *dest, int32_t destCapacity, UErrorCode *p
         if(folded1Length>UCASE_MAX_STRING_LENGTH) {
             folded1String.setTo(folded1Length);
         } else {
-            folded1String.setTo(FALSE, folded1, folded1Length);
+            folded1String.setTo(false, folded1, folded1Length);
         }
     }
     UnicodeString kc1=nfkc->normalize(folded1String, *pErrorCode);
diff --git a/deps/icu-small/source/common/uresbund.cpp b/deps/icu-small/source/common/uresbund.cpp
index a9c6459418..17c0177a05 100644
--- a/deps/icu-small/source/common/uresbund.cpp
+++ b/deps/icu-small/source/common/uresbund.cpp
@@ -49,7 +49,7 @@ TODO: This cache should probably be removed when the deprecated code is
       completely removed.
 */
 static UHashtable *cache = NULL;
-static icu::UInitOnce gCacheInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gCacheInitOnce {};
 
 static UMutex resbMutex;
 
@@ -85,10 +85,206 @@ static UBool chopLocale(char *name) {
 
     if(i != NULL) {
         *i = '\0';
-        return TRUE;
+        return true;
     }
 
-    return FALSE;
+    return false;
+}
+
+static UBool hasVariant(const char* localeID) {
+    UErrorCode err = U_ZERO_ERROR;
+    int32_t variantLength = uloc_getVariant(localeID, NULL, 0, &err);
+    return variantLength != 0;
+}
+
+// This file contains the tables for doing locale fallback, which are generated
+// by the CLDR-to-ICU process directly from the CLDR data.  This file should only
+// ever be included from here.
+#define INCLUDED_FROM_URESBUND_CPP
+#include "localefallback_data.h"
+
+static const char* performFallbackLookup(const char* key,
+                                         const char* keyStrs,
+                                         const char* valueStrs,
+                                         const int32_t* lookupTable,
+                                         int32_t lookupTableLength) {
+    const int32_t* bottom = lookupTable;
+    const int32_t* top = lookupTable + lookupTableLength;
+
+    while (bottom < top) {
+        // Effectively, divide by 2 and round down to an even index
+        const int32_t* middle = bottom + (((top - bottom) / 4) * 2);
+        const char* entryKey = &(keyStrs[*middle]);
+        int32_t strcmpResult = uprv_strcmp(key, entryKey);
+        if (strcmpResult == 0) {
+            return &(valueStrs[middle[1]]);
+        } else if (strcmpResult < 0) {
+            top = middle;
+        } else {
+            bottom = middle + 2;
+        }
+    }
+    return nullptr;
+}
+
+static CharString getDefaultScript(const CharString& language, const CharString& region) {
+    const char* defaultScript = nullptr;
+    UErrorCode err = U_ZERO_ERROR;
+    
+    // the default script will be "Latn" if we don't find the locale ID in the tables
+    CharString result("Latn", err);
+    
+    // if we were passed both language and region, make them into a locale ID and look that up in the default
+    // script table
+    if (!region.isEmpty()) {
+        CharString localeID;
+        localeID.append(language, err).append("_", err).append(region, err);
+        if (U_FAILURE(err)) {
+            return result;
+        }
+        defaultScript = performFallbackLookup(localeID.data(), dsLocaleIDChars, scriptCodeChars, defaultScriptTable, UPRV_LENGTHOF(defaultScriptTable));
+    }
+    
+    // if we didn't find anything, look up just the language in the default script table
+    if (defaultScript == nullptr) {
+        defaultScript = performFallbackLookup(language.data(), dsLocaleIDChars, scriptCodeChars, defaultScriptTable, UPRV_LENGTHOF(defaultScriptTable));
+    }
+    
+    // if either lookup above succeeded, copy the result from "defaultScript" into "result"; otherwise, return "Latn"
+    if (defaultScript != nullptr) {
+        result.clear();
+        result.append(defaultScript, err);
+    }
+    return result;
+}
+
+enum UResOpenType {
+    /**
+     * Open a resource bundle for the locale;
+     * if there is not even a base language bundle, then fall back to the default locale;
+     * if there is no bundle for that either, then load the root bundle.
+     *
+     * This is the default bundle loading behavior.
+     */
+    URES_OPEN_LOCALE_DEFAULT_ROOT,
+    // TODO: ICU ticket #11271 "consistent default locale across locale trees"
+    // Add an option to look at the main locale tree for whether to
+    // fall back to root directly (if the locale has main data) or
+    // fall back to the default locale first (if the locale does not even have main data).
+    /**
+     * Open a resource bundle for the locale;
+     * if there is not even a base language bundle, then load the root bundle;
+     * never fall back to the default locale.
+     *
+     * This is used for algorithms that have good pan-Unicode default behavior,
+     * such as case mappings, collation, and segmentation (BreakIterator).
+     */
+    URES_OPEN_LOCALE_ROOT,
+    /**
+     * Open a resource bundle for the exact bundle name as requested;
+     * no fallbacks, do not load parent bundles.
+     *
+     * This is used for supplemental (non-locale) data.
+     */
+    URES_OPEN_DIRECT
+};
+typedef enum UResOpenType UResOpenType;
+
+/**
+ *  Internal function, determines the search path for resource bundle files.
+ *  Currently, this function is used only by findFirstExisting() to help search for resource bundle files when a bundle for the specified
+ *  locale doesn't exist.  The code that supports inheritance of resources between existing resource bundle files continues to
+ *  use chopLocale() below.
+ *  @param name In-out parameter: On input, the locale ID to get a parent locale ID for (this is a locale's base name, without keywords); on output, the
+ *  requested parent locale ID.
+ *  @param origName The original locale ID the caller of findFirstExisting() requested.  This is the same as `name` on the first call to this function,
+ *  but as findFirstExisting() ascends the resource bundle's parent tree, this parameter will continue to be the original locale ID requested.
+ */
+static bool getParentLocaleID(char *name, const char *origName, UResOpenType openType) {
+    // early out if the locale ID has a variant code or ends with _
+    if (name[uprv_strlen(name) - 1] == '_' || hasVariant(name)) {
+        return chopLocale(name);
+    }
+    
+    UErrorCode err = U_ZERO_ERROR;
+    const char* tempNamePtr = name;
+    CharString language = ulocimp_getLanguage(tempNamePtr, &tempNamePtr, err);
+    if (*tempNamePtr == '_') {
+        ++tempNamePtr;
+    }
+    CharString script = ulocimp_getScript(tempNamePtr, &tempNamePtr, err);
+    if (*tempNamePtr == '_') {
+        ++tempNamePtr;
+    }
+    CharString region = ulocimp_getCountry(tempNamePtr, &tempNamePtr, err);
+    CharString workingLocale;
+    if (U_FAILURE(err)) {
+        // hopefully this never happens...
+        return chopLocale(name);
+    }
+    
+    // if the open type is URES_OPEN_LOCALE_DEFAULT_ROOT, first look the locale ID up in the parent locale table;
+    // if that table specifies a parent for it, return that  (we don't do this for the other open types-- if we're not
+    // falling back through the system default locale, we also want to do straight truncation fallback instead
+    // of looking things up in the parent locale table-- see https://www.unicode.org/reports/tr35/tr35.html#Parent_Locales:
+    // "Collation data, however, is an exception...")
+    if (openType == URES_OPEN_LOCALE_DEFAULT_ROOT) {
+        const char* parentID = performFallbackLookup(name, parentLocaleChars, parentLocaleChars, parentLocaleTable, UPRV_LENGTHOF(parentLocaleTable));
+        if (parentID != NULL) {
+            uprv_strcpy(name, parentID);
+            return true;
+        }
+    }
+
+    // if it's not in the parent locale table, figure out the fallback script algorithmically
+    // (see CLDR-15265 for an explanation of the algorithm)
+    if (!script.isEmpty() && !region.isEmpty()) {
+        // if "name" has both script and region, is the script the default script?
+        // - if so, remove it and keep the region
+        // - if not, remove the region and keep the script
+        if (getDefaultScript(language, region) == script.toStringPiece()) {
+            workingLocale.append(language, err).append("_", err).append(region, err);
+        } else {
+            workingLocale.append(language, err).append("_", err).append(script, err);
+        }
+    } else if (!region.isEmpty()) {
+        // if "name" has region but not script, did the original locale ID specify a script?
+        // - if yes, replace the region with the script from the original locale ID
+        // - if no, replace the region with the default script for that language and region
+        UErrorCode err = U_ZERO_ERROR;
+        tempNamePtr = origName;
+        CharString origNameLanguage = ulocimp_getLanguage(tempNamePtr, &tempNamePtr, err);
+        if (*tempNamePtr == '_') {
+            ++tempNamePtr;
+        }
+        CharString origNameScript = ulocimp_getScript(origName, nullptr, err);
+        if (!origNameScript.isEmpty()) {
+            workingLocale.append(language, err).append("_", err).append(origNameScript, err);
+        } else {
+            workingLocale.append(language, err).append("_", err).append(getDefaultScript(language, region), err);
+        }
+    } else if (!script.isEmpty()) {
+        // if "name" has script but not region (and our open type if URES_OPEN_LOCALE_DEFAULT_ROOT), is the script
+        // the default script for the language?
+        // - if so, remove it from the locale ID
+        // - if not, return false to continue up the chain
+        // (we don't do this for other open types for the same reason we don't look things up in the parent
+        // locale table for other open types-- see the reference to UTS #35 above)
+        if (openType != URES_OPEN_LOCALE_DEFAULT_ROOT || getDefaultScript(language, CharString()) == script.toStringPiece()) {
+            workingLocale.append(language, err);
+        } else {
+            return false;
+        }
+    } else {
+        // if "name" just contains a language code, return false so the calling code falls back to "root"
+        return false;
+    }
+    if (U_SUCCESS(err) && !workingLocale.isEmpty()) {
+        uprv_strcpy(name, workingLocale.data());
+        return true;
+    } else {
+        return false;
+    }
 }
 
 /**
@@ -199,7 +395,7 @@ static int32_t ures_flushCache()
     }
 
     do {
-        deletedMore = FALSE;
+        deletedMore = false;
         /*creates an enumeration to iterate through every element in the table */
         pos = UHASH_FIRST;
         while ((e = uhash_nextElement(cache, &pos)) != NULL)
@@ -216,7 +412,7 @@ static int32_t ures_flushCache()
 
             if (resB->fCountExisting == 0) {
                 rbDeletedNum++;
-                deletedMore = TRUE;
+                deletedMore = true;
                 uhash_removeElement(cache, e);
                 free_entry(resB);
             }
@@ -234,7 +430,7 @@ static int32_t ures_flushCache()
 #include <stdio.h>
 
 U_CAPI UBool U_EXPORT2 ures_dumpCacheContents(void) {
-  UBool cacheNotEmpty = FALSE;
+  UBool cacheNotEmpty = false;
   int32_t pos = UHASH_FIRST;
   const UHashElement *e;
   UResourceDataEntry *resB;
@@ -242,11 +438,11 @@ U_CAPI UBool U_EXPORT2 ures_dumpCacheContents(void) {
     Mutex lock(&resbMutex);
     if (cache == NULL) {
       fprintf(stderr,"%s:%d: RB Cache is NULL.\n", __FILE__, __LINE__);
-      return FALSE;
+      return false;
     }
 
     while ((e = uhash_nextElement(cache, &pos)) != NULL) {
-      cacheNotEmpty=TRUE;
+      cacheNotEmpty=true;
       resB = (UResourceDataEntry *) e->value.pointer;
       fprintf(stderr,"%s:%d: RB Cache: Entry @0x%p, refcount %d, name %s:%s.  Pool 0x%p, alias 0x%p, parent 0x%p\n",
               __FILE__, __LINE__,
@@ -272,7 +468,7 @@ static UBool U_CALLCONV ures_cleanup(void)
         cache = NULL;
     }
     gCacheInitOnce.reset();
-    return TRUE;
+    return true;
 }
 
 /** INTERNAL: Initializes the cache for resources */
@@ -320,7 +516,7 @@ static UResourceDataEntry *init_entry(const char *localeID, const char *path, UE
     const char *name;
     char aliasName[100] = { 0 };
     int32_t aliasLen = 0;
-    /*UBool isAlias = FALSE;*/
+    /*UBool isAlias = false;*/
     /*UHashTok hashkey; */
 
     if(U_FAILURE(*status)) {
@@ -463,13 +659,15 @@ getPoolEntry(const char *path, UErrorCode *status) {
 /* INTERNAL: */
 /*   CAUTION:  resbMutex must be locked when calling this function! */
 static UResourceDataEntry *
-findFirstExisting(const char* path, char* name, const char* defaultLocale,
-                  UBool *isRoot, UBool *hasChopped, UBool *isDefault, UErrorCode* status) {
+findFirstExisting(const char* path, char* name, const char* defaultLocale, UResOpenType openType,
+                  UBool *isRoot, UBool *foundParent, UBool *isDefault, UErrorCode* status) {
     UResourceDataEntry *r = NULL;
-    UBool hasRealData = FALSE;
-    *hasChopped = TRUE; /* we're starting with a fresh name */
+    UBool hasRealData = false;
+    *foundParent = true; /* we're starting with a fresh name */
+    char origName[ULOC_FULLNAME_CAPACITY];
 
-    while(*hasChopped && !hasRealData) {
+    uprv_strcpy(origName, name);
+    while(*foundParent && !hasRealData) {
         r = init_entry(name, path, status);
         /* Null pointer test */
         if (U_FAILURE(*status)) {
@@ -494,8 +692,14 @@ findFirstExisting(const char* path, char* name, const char* defaultLocale,
         *isRoot = (UBool)(uprv_strcmp(name, kRootLocaleName) == 0);
 
         /*Fallback data stuff*/
-        *hasChopped = chopLocale(name);
-        if (*hasChopped && *name == '\0') {
+        if (!hasRealData) {
+            *foundParent = getParentLocaleID(name, origName, openType);
+        } else {
+            // we've already found a real resource file; what we return to the caller is the parent
+            // locale ID for inheritance, which should come from chopLocale(), not getParentLocaleID()
+            *foundParent = chopLocale(name);
+        }
+        if (*foundParent && *name == '\0') {
             uprv_strcpy(name, "und");
         }
     }
@@ -513,13 +717,13 @@ static void ures_setIsStackObject( UResourceBundle* resB, UBool state) {
 }
 
 static UBool ures_isStackObject(const UResourceBundle* resB) {
-  return((resB->fMagic1 == MAGIC1 && resB->fMagic2 == MAGIC2)?FALSE:TRUE);
+  return((resB->fMagic1 == MAGIC1 && resB->fMagic2 == MAGIC2)?false:true);
 }
 
 
 U_CFUNC void ures_initStackObject(UResourceBundle* resB) {
   uprv_memset(resB, 0, sizeof(UResourceBundle));
-  ures_setIsStackObject(resB, TRUE);
+  ures_setIsStackObject(resB, true);
 }
 
 U_NAMESPACE_BEGIN
@@ -538,8 +742,8 @@ static UBool  // returns U_SUCCESS(*status)
 loadParentsExceptRoot(UResourceDataEntry *&t1,
                       char name[], int32_t nameCapacity,
                       UBool usingUSRData, char usrDataPath[], UErrorCode *status) {
-    if (U_FAILURE(*status)) { return FALSE; }
-    UBool checkParent = TRUE;
+    if (U_FAILURE(*status)) { return false; }
+    UBool checkParent = true;
     while (checkParent && t1->fParent == NULL && !t1->fData.noFallback &&
             res_getResource(&t1->fData,"%%ParentIsRoot") == RES_BOGUS) {
         Resource parentRes = res_getResource(&t1->fData, "%%Parent");
@@ -550,7 +754,7 @@ loadParentsExceptRoot(UResourceDataEntry *&t1,
             if(parentLocaleName != NULL && 0 < parentLocaleLen && parentLocaleLen < nameCapacity) {
                 u_UCharsToChars(parentLocaleName, name, parentLocaleLen + 1);
                 if (uprv_strcmp(name, kRootLocaleName) == 0) {
-                    return TRUE;
+                    return true;
                 }
             }
         }
@@ -559,7 +763,7 @@ loadParentsExceptRoot(UResourceDataEntry *&t1,
         UResourceDataEntry *t2 = init_entry(name, t1->fPath, &parentStatus);
         if (U_FAILURE(parentStatus)) {
             *status = parentStatus;
-            return FALSE;
+            return false;
         }
         UResourceDataEntry *u2 = NULL;
         UErrorCode usrStatus = U_ZERO_ERROR;
@@ -568,7 +772,7 @@ loadParentsExceptRoot(UResourceDataEntry *&t1,
             // If we failed due to out-of-memory, report that to the caller and exit early.
             if (usrStatus == U_MEMORY_ALLOCATION_ERROR) {
                 *status = usrStatus;
-                return FALSE;
+                return false;
             }
         }
 
@@ -585,65 +789,33 @@ loadParentsExceptRoot(UResourceDataEntry *&t1,
         t1 = t2;
         checkParent = chopLocale(name) || mayHaveParent(name);
     }
-    return TRUE;
+    return true;
 }
 
 static UBool  // returns U_SUCCESS(*status)
 insertRootBundle(UResourceDataEntry *&t1, UErrorCode *status) {
-    if (U_FAILURE(*status)) { return FALSE; }
+    if (U_FAILURE(*status)) { return false; }
     UErrorCode parentStatus = U_ZERO_ERROR;
     UResourceDataEntry *t2 = init_entry(kRootLocaleName, t1->fPath, &parentStatus);
     if (U_FAILURE(parentStatus)) {
         *status = parentStatus;
-        return FALSE;
+        return false;
     }
     t1->fParent = t2;
     t1 = t2;
-    return TRUE;
+    return true;
 }
 
-enum UResOpenType {
-    /**
-     * Open a resource bundle for the locale;
-     * if there is not even a base language bundle, then fall back to the default locale;
-     * if there is no bundle for that either, then load the root bundle.
-     *
-     * This is the default bundle loading behavior.
-     */
-    URES_OPEN_LOCALE_DEFAULT_ROOT,
-    // TODO: ICU ticket #11271 "consistent default locale across locale trees"
-    // Add an option to look at the main locale tree for whether to
-    // fall back to root directly (if the locale has main data) or
-    // fall back to the default locale first (if the locale does not even have main data).
-    /**
-     * Open a resource bundle for the locale;
-     * if there is not even a base language bundle, then load the root bundle;
-     * never fall back to the default locale.
-     *
-     * This is used for algorithms that have good pan-Unicode default behavior,
-     * such as case mappings, collation, and segmentation (BreakIterator).
-     */
-    URES_OPEN_LOCALE_ROOT,
-    /**
-     * Open a resource bundle for the exact bundle name as requested;
-     * no fallbacks, do not load parent bundles.
-     *
-     * This is used for supplemental (non-locale) data.
-     */
-    URES_OPEN_DIRECT
-};
-typedef enum UResOpenType UResOpenType;
-
 static UResourceDataEntry *entryOpen(const char* path, const char* localeID,
                                      UResOpenType openType, UErrorCode* status) {
     U_ASSERT(openType != URES_OPEN_DIRECT);
     UErrorCode intStatus = U_ZERO_ERROR;
     UResourceDataEntry *r = NULL;
     UResourceDataEntry *t1 = NULL;
-    UBool isDefault = FALSE;
-    UBool isRoot = FALSE;
-    UBool hasRealData = FALSE;
-    UBool hasChopped = TRUE;
+    UBool isDefault = false;
+    UBool isRoot = false;
+    UBool hasRealData = false;
+    UBool hasChopped = true;
     UBool usingUSRData = U_USE_USRDATA && ( path == NULL || uprv_strncmp(path,U_ICUDATA_NAME,8) == 0);
 
     char name[ULOC_FULLNAME_CAPACITY];
@@ -676,7 +848,7 @@ static UResourceDataEntry *entryOpen(const char* path, const char* localeID,
     Mutex lock(&resbMutex);    // Lock resbMutex until the end of this function.
 
     /* We're going to skip all the locales that do not have any data */
-    r = findFirstExisting(path, name, defaultLocale, &isRoot, &hasChopped, &isDefault, &intStatus);
+    r = findFirstExisting(path, name, defaultLocale, openType, &isRoot, &hasChopped, &isDefault, &intStatus);
 
     // If we failed due to out-of-memory, report the failure and exit early.
     if (intStatus == U_MEMORY_ALLOCATION_ERROR) {
@@ -686,7 +858,7 @@ static UResourceDataEntry *entryOpen(const char* path, const char* localeID,
 
     if(r != NULL) { /* if there is one real locale, we can look for parents. */
         t1 = r;
-        hasRealData = TRUE;
+        hasRealData = true;
         if ( usingUSRData ) {  /* This code inserts user override data into the inheritance chain */
             UErrorCode usrStatus = U_ZERO_ERROR;
             UResourceDataEntry *u1 = init_entry(t1->fName, usrDataPath, &usrStatus);
@@ -717,7 +889,7 @@ static UResourceDataEntry *entryOpen(const char* path, const char* localeID,
     if(r==NULL && openType == URES_OPEN_LOCALE_DEFAULT_ROOT && !isDefault && !isRoot) {
         /* insert default locale */
         uprv_strcpy(name, defaultLocale);
-        r = findFirstExisting(path, name, defaultLocale, &isRoot, &hasChopped, &isDefault, &intStatus);
+        r = findFirstExisting(path, name, defaultLocale, openType, &isRoot, &hasChopped, &isDefault, &intStatus);
         // If we failed due to out-of-memory, report the failure and exit early.
         if (intStatus == U_MEMORY_ALLOCATION_ERROR) {
             *status = intStatus;
@@ -726,8 +898,8 @@ static UResourceDataEntry *entryOpen(const char* path, const char* localeID,
         intStatus = U_USING_DEFAULT_WARNING;
         if(r != NULL) { /* the default locale exists */
             t1 = r;
-            hasRealData = TRUE;
-            isDefault = TRUE;
+            hasRealData = true;
+            isDefault = true;
             // TODO: Why not if (usingUSRData) { ... } like in the non-default-locale code path?
             if ((hasChopped || mayHaveParent(name)) && !isRoot) {
                 if (!loadParentsExceptRoot(t1, name, UPRV_LENGTHOF(name), usingUSRData, usrDataPath, status)) {
@@ -741,7 +913,7 @@ static UResourceDataEntry *entryOpen(const char* path, const char* localeID,
     /* present */
     if(r == NULL) {
         uprv_strcpy(name, kRootLocaleName);
-        r = findFirstExisting(path, name, defaultLocale, &isRoot, &hasChopped, &isDefault, &intStatus);
+        r = findFirstExisting(path, name, defaultLocale, openType, &isRoot, &hasChopped, &isDefault, &intStatus);
         // If we failed due to out-of-memory, report the failure and exit early.
         if (intStatus == U_MEMORY_ALLOCATION_ERROR) {
             *status = intStatus;
@@ -750,7 +922,7 @@ static UResourceDataEntry *entryOpen(const char* path, const char* localeID,
         if(r != NULL) {
             t1 = r;
             intStatus = U_USING_DEFAULT_WARNING;
-            hasRealData = TRUE;
+            hasRealData = true;
         } else { /* we don't even have the root locale */
             *status = U_MISSING_RESOURCE_ERROR;
             goto finish;
@@ -826,7 +998,7 @@ entryOpenDirect(const char* path, const char* localeID, UErrorCode* status) {
         char name[ULOC_FULLNAME_CAPACITY];
         uprv_strcpy(name, localeID);
         if(!chopLocale(name) || uprv_strcmp(name, kRootLocaleName) == 0 ||
-                loadParentsExceptRoot(t1, name, UPRV_LENGTHOF(name), FALSE, NULL, status)) {
+                loadParentsExceptRoot(t1, name, UPRV_LENGTHOF(name), false, NULL, status)) {
             if(uprv_strcmp(t1->fName, kRootLocaleName) != 0 && t1->fParent == NULL) {
                 insertRootBundle(t1, status);
             }
@@ -956,7 +1128,7 @@ ures_closeBundle(UResourceBundle* resB, UBool freeBundleObj)
         }
         ures_freeResPath(resB);
 
-        if(ures_isStackObject(resB) == FALSE && freeBundleObj) {
+        if(ures_isStackObject(resB) == false && freeBundleObj) {
             uprv_free(resB);
         }
 #if 0 /*U_DEBUG*/
@@ -971,7 +1143,7 @@ ures_closeBundle(UResourceBundle* resB, UBool freeBundleObj)
 U_CAPI void  U_EXPORT2
 ures_close(UResourceBundle* resB)
 {
-    ures_closeBundle(resB, TRUE);
+    ures_closeBundle(resB, true);
 }
 
 namespace {
@@ -1237,7 +1409,7 @@ UResourceBundle *init_resb_result(
             *status = U_MEMORY_ALLOCATION_ERROR;
             return NULL;
         }
-        ures_setIsStackObject(resB, FALSE);
+        ures_setIsStackObject(resB, false);
         resB->fResPath = NULL;
         resB->fResPathLen = 0;
     } else {
@@ -1254,7 +1426,7 @@ UResourceBundle *init_resb_result(
         treated the same
         */
         /*
-        if(ures_isStackObject(resB) != FALSE) {
+        if(ures_isStackObject(resB) != false) {
         ures_initStackObject(resB);
         }
         */
@@ -1264,8 +1436,8 @@ UResourceBundle *init_resb_result(
     }
     resB->fData = dataEntry;
     entryIncrease(resB->fData);
-    resB->fHasFallback = FALSE;
-    resB->fIsTopLevel = FALSE;
+    resB->fHasFallback = false;
+    resB->fIsTopLevel = false;
     resB->fIndex = -1;
     resB->fKey = key; 
     resB->fValidLocaleDataEntry = validLocaleDataEntry;
@@ -1318,7 +1490,7 @@ UResourceBundle *ures_copyResb(UResourceBundle *r, const UResourceBundle *origin
     }
     if(original != NULL) {
         if(r == NULL) {
-            isStackObject = FALSE;
+            isStackObject = false;
             r = (UResourceBundle *)uprv_malloc(sizeof(UResourceBundle));
             /* test for NULL */
             if (r == NULL) {
@@ -1327,7 +1499,7 @@ UResourceBundle *ures_copyResb(UResourceBundle *r, const UResourceBundle *origin
             }
         } else {
             isStackObject = ures_isStackObject(r);
-            ures_closeBundle(r, FALSE);
+            ures_closeBundle(r, false);
         }
         uprv_memcpy(r, original, sizeof(UResourceBundle));
         r->fResPath = NULL;
@@ -1409,7 +1581,7 @@ ures_toUTF8String(const UChar *s16, int32_t length16,
              * may store UTF-8 natively.
              * (In which case dest would not be used at all.)
              *
-             * We do not do this if forceCopy=TRUE because then the caller
+             * We do not do this if forceCopy=true because then the caller
              * expects the string to start exactly at dest.
              *
              * The test above for <= 0x2aaaaaaa prevents overflows.
@@ -1553,7 +1725,7 @@ U_CAPI void U_EXPORT2 ures_resetIterator(UResourceBundle *resB){
 
 U_CAPI UBool U_EXPORT2 ures_hasNext(const UResourceBundle *resB) {
   if(resB == NULL) {
-    return FALSE;
+    return false;
   }
   return (UBool)(resB->fIndex < resB->fSize-1);
 }
@@ -2133,7 +2305,7 @@ void getAllItemsWithFallback(
         parentRef.fData = parentEntry;
         parentRef.fValidLocaleDataEntry = bundle->fValidLocaleDataEntry;
         parentRef.fHasFallback = !parentRef.getResData().noFallback;
-        parentRef.fIsTopLevel = TRUE;
+        parentRef.fIsTopLevel = true;
         parentRef.fRes = parentRef.getResData().rootRes;
         parentRef.fSize = res_countArrayItems(&parentRef.getResData(), parentRef.fRes);
         parentRef.fIndex = -1;
@@ -2276,7 +2448,7 @@ U_CAPI UResourceBundle* U_EXPORT2 ures_getByKey(const UResourceBundle *resB, con
         res = res_getTableItemByKey(&resB->getResData(), resB->fRes, &t, &key);
         if(res == RES_BOGUS) {
             key = inKey;
-            if(resB->fHasFallback == TRUE) {
+            if(resB->fHasFallback == true) {
                 dataEntry = getFallbackData(resB, &key, &res, status);
                 if(U_SUCCESS(*status)) {
                     /* check if resB->fResPath gives the right name here */
@@ -2294,7 +2466,7 @@ U_CAPI UResourceBundle* U_EXPORT2 ures_getByKey(const UResourceBundle *resB, con
 #if 0
     /* this is a kind of TODO item. If we have an array with an index table, we could do this. */
     /* not currently */
-    else if(RES_GET_TYPE(resB->fRes) == URES_ARRAY && resB->fHasFallback == TRUE) {
+    else if(RES_GET_TYPE(resB->fRes) == URES_ARRAY && resB->fHasFallback == true) {
         /* here should go a first attempt to locate the key using index table */
         dataEntry = getFallbackData(resB, &key, &res, status);
         if(U_SUCCESS(*status)) {
@@ -2331,7 +2503,7 @@ U_CAPI const UChar* U_EXPORT2 ures_getStringByKey(const UResourceBundle *resB, c
 
         if(res == RES_BOGUS) {
             key = inKey;
-            if(resB->fHasFallback == TRUE) {
+            if(resB->fHasFallback == true) {
                 dataEntry = getFallbackData(resB, &key, &res, status);
                 if(U_SUCCESS(*status)) {
                     switch (RES_GET_TYPE(res)) {
@@ -2376,7 +2548,7 @@ U_CAPI const UChar* U_EXPORT2 ures_getStringByKey(const UResourceBundle *resB, c
 #if 0 
     /* this is a kind of TODO item. If we have an array with an index table, we could do this. */
     /* not currently */   
-    else if(RES_GET_TYPE(resB->fRes) == URES_ARRAY && resB->fHasFallback == TRUE) {
+    else if(RES_GET_TYPE(resB->fRes) == URES_ARRAY && resB->fHasFallback == true) {
         /* here should go a first attempt to locate the key using index table */
         dataEntry = getFallbackData(resB, &key, &res, status);
         if(U_SUCCESS(*status)) {
@@ -2510,17 +2682,17 @@ ures_openWithType(UResourceBundle *r, const char* path, const char* localeID,
             *status = U_MEMORY_ALLOCATION_ERROR;
             return NULL;
         }
-        isStackObject = FALSE;
+        isStackObject = false;
     } else {  // fill-in
         isStackObject = ures_isStackObject(r);
-        ures_closeBundle(r, FALSE);
+        ures_closeBundle(r, false);
     }
     uprv_memset(r, 0, sizeof(UResourceBundle));
     ures_setIsStackObject(r, isStackObject);
 
     r->fValidLocaleDataEntry = r->fData = entry;
     r->fHasFallback = openType != URES_OPEN_DIRECT && !r->getResData().noFallback;
-    r->fIsTopLevel = TRUE;
+    r->fIsTopLevel = true;
     r->fRes = r->getResData().rootRes;
     r->fSize = res_countArrayItems(&r->getResData(), r->fRes);
     r->fIndex = -1;
@@ -2795,10 +2967,10 @@ static UBool isLocaleInList(UEnumeration *locEnum, const char *locToSearch, UErr
     const char *loc;
     while ((loc = uenum_next(locEnum, NULL, status)) != NULL) {
         if (uprv_strcmp(loc, locToSearch) == 0) {
-            return TRUE;
+            return true;
         }
     }
-    return FALSE;
+    return false;
 }
 
 U_CAPI int32_t U_EXPORT2
@@ -2836,7 +3008,7 @@ ures_getFunctionalEquivalent(char *result, int32_t resultCapacity,
 
     if(isAvailable) { 
         UEnumeration *locEnum = ures_openAvailableLocales(path, &subStatus);
-        *isAvailable = TRUE;
+        *isAvailable = true;
         if (U_SUCCESS(subStatus)) {
             *isAvailable = isLocaleInList(locEnum, parent, &subStatus);
         }
@@ -2854,7 +3026,7 @@ ures_getFunctionalEquivalent(char *result, int32_t resultCapacity,
         if(((subStatus == U_USING_FALLBACK_WARNING) ||
             (subStatus == U_USING_DEFAULT_WARNING)) && isAvailable)
         {
-            *isAvailable = FALSE;
+            *isAvailable = false;
         }
         isAvailable = NULL; /* only want to set this the first time around */
         
@@ -2910,7 +3082,7 @@ ures_getFunctionalEquivalent(char *result, int32_t resultCapacity,
         subStatus = U_ZERO_ERROR;
         res = ures_open(path, parent, &subStatus);
         if((subStatus == U_USING_FALLBACK_WARNING) && isAvailable) {
-            *isAvailable = FALSE;
+            *isAvailable = false;
         }
         isAvailable = NULL; /* only want to set this the first time around */
         
@@ -2991,7 +3163,7 @@ ures_getFunctionalEquivalent(char *result, int32_t resultCapacity,
             subStatus = U_ZERO_ERROR;
             res = ures_open(path, parent, &subStatus);
             if((subStatus == U_USING_FALLBACK_WARNING) && isAvailable) {
-                *isAvailable = FALSE;
+                *isAvailable = false;
             }
             isAvailable = NULL; /* only want to set this the first time around */
             
@@ -3224,32 +3396,32 @@ ures_equal(const UResourceBundle* res1, const UResourceBundle* res2){
         return (res1->fKey==res2->fKey);
     }else{
         if(uprv_strcmp(res1->fKey, res2->fKey)!=0){
-            return FALSE;
+            return false;
         }
     }
     if(uprv_strcmp(res1->fData->fName, res2->fData->fName)!=0){
-        return FALSE;
+        return false;
     }
     if(res1->fData->fPath == NULL||  res2->fData->fPath==NULL){
         return (res1->fData->fPath == res2->fData->fPath);
     }else{
         if(uprv_strcmp(res1->fData->fPath, res2->fData->fPath)!=0){
-            return FALSE;
+            return false;
         }
     }
     if(uprv_strcmp(res1->fData->fParent->fName, res2->fData->fParent->fName)!=0){
-        return FALSE;
+        return false;
     }
     if(uprv_strcmp(res1->fData->fParent->fPath, res2->fData->fParent->fPath)!=0){
-        return FALSE;
+        return false;
     }
     if(uprv_strncmp(res1->fResPath, res2->fResPath, res1->fResPathLen)!=0){
-        return FALSE;
+        return false;
     }
     if(res1->fRes != res2->fRes){
-        return FALSE;
+        return false;
     }
-    return TRUE;
+    return true;
 }
 U_CAPI UResourceBundle* U_EXPORT2
 ures_clone(const UResourceBundle* res, UErrorCode* status){
diff --git a/deps/icu-small/source/common/uresdata.cpp b/deps/icu-small/source/common/uresdata.cpp
index 9af081be40..a1222d415c 100644
--- a/deps/icu-small/source/common/uresdata.cpp
+++ b/deps/icu-small/source/common/uresdata.cpp
@@ -234,7 +234,7 @@ res_init(ResourceData *pResData,
          * formatVersion 1: compare key strings in native-charset order
          * formatVersion 2 and up: compare key strings in ASCII order
          */
-        pResData->useNativeStrcmp=TRUE;
+        pResData->useNativeStrcmp=true;
     }
 }
 
@@ -377,10 +377,10 @@ UBool isNoInheritanceMarker(const ResourceData *pResData, Resource res) {
             return p[1] == 0x2205 && p[2] == 0x2205 && p[3] == 0x2205;
         } else {
             // Assume that the string has not been stored with more length units than necessary.
-            return FALSE;
+            return false;
         }
     }
-    return FALSE;
+    return false;
 }
 
 int32_t getStringArray(const ResourceData *pResData, const icu::ResourceArray &array,
@@ -409,7 +409,7 @@ int32_t getStringArray(const ResourceData *pResData, const icu::ResourceArray &a
             errorCode = U_RESOURCE_TYPE_MISMATCH;
             return 0;
         }
-        dest[i].setTo(TRUE, s, sLength);
+        dest[i].setTo(true, s, sLength);
     }
     return length;
 }
@@ -660,7 +660,7 @@ int32_t ResourceDataValue::getStringArrayOrStringAsArray(UnicodeString *dest, in
     int32_t sLength;
     const UChar *s = res_getString(fTraceInfo, &getData(), res, &sLength);
     if(s != NULL) {
-        dest[0].setTo(TRUE, s, sLength);
+        dest[0].setTo(true, s, sLength);
         return 1;
     }
     errorCode = U_RESOURCE_TYPE_MISMATCH;
@@ -675,7 +675,7 @@ UnicodeString ResourceDataValue::getStringOrFirstOfArray(UErrorCode &errorCode)
     int32_t sLength;
     const UChar *s = res_getString(fTraceInfo, &getData(), res, &sLength);
     if(s != NULL) {
-        us.setTo(TRUE, s, sLength);
+        us.setTo(true, s, sLength);
         return us;
     }
     ResourceArray array = getArray(errorCode);
@@ -686,7 +686,7 @@ UnicodeString ResourceDataValue::getStringOrFirstOfArray(UErrorCode &errorCode)
         // Tracing is already performed above (unimportant for trace that this is an array)
         s = res_getStringNoTrace(&getData(), array.internalGetResource(&getData(), 0), &sLength);
         if(s != NULL) {
-            us.setTo(TRUE, s, sLength);
+            us.setTo(true, s, sLength);
             return us;
         }
     }
@@ -837,9 +837,9 @@ UBool icu::ResourceTable::getKeyAndValue(int32_t i,
         // alive for the duration that fields are being read from it
         // (including nested fields).
         rdValue.setResource(res, ResourceTracer(fTraceInfo, key));
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 UBool icu::ResourceTable::findValue(const char *key, ResourceValue &value) const {
@@ -860,9 +860,9 @@ UBool icu::ResourceTable::findValue(const char *key, ResourceValue &value) const
         }
         // Same note about lifetime as in getKeyAndValue().
         rdValue.setResource(res, ResourceTracer(fTraceInfo, key));
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 U_CAPI Resource U_EXPORT2
@@ -912,9 +912,9 @@ UBool icu::ResourceArray::getValue(int32_t i, icu::ResourceValue &value) const {
         rdValue.setResource(
             internalGetResource(&rdValue.getData(), i),
             ResourceTracer(fTraceInfo, i));
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 U_CFUNC Resource
@@ -1222,7 +1222,7 @@ ures_swapResource(const UDataSwapper *ds,
             }
             uprv_sortArray(pTempTable->rows, count, sizeof(Row),
                            ures_compareRows, pTempTable->keyChars,
-                           FALSE, pErrorCode);
+                           false, pErrorCode);
             if(U_FAILURE(*pErrorCode)) {
                 udata_printError(ds, "ures_swapResource(table res=%08x).uprv_sortArray(%d items) failed\n",
                                  res, count);
diff --git a/deps/icu-small/source/common/usc_impl.cpp b/deps/icu-small/source/common/usc_impl.cpp
index 111029b974..a4e2fc6069 100644
--- a/deps/icu-small/source/common/usc_impl.cpp
+++ b/deps/icu-small/source/common/usc_impl.cpp
@@ -261,7 +261,7 @@ uscript_nextRun(UScriptRun *scriptRun, int32_t *pRunStart, int32_t *pRunLimit, U
 
     /* if we've fallen off the end of the text, we're done */
     if (scriptRun == NULL || scriptRun->scriptLimit >= scriptRun->textLength) {
-        return FALSE;
+        return false;
     }
     
     SYNC_FIXUP(scriptRun);
@@ -357,5 +357,5 @@ uscript_nextRun(UScriptRun *scriptRun, int32_t *pRunStart, int32_t *pRunLimit, U
         *pRunScript = scriptRun->scriptCode;
     }
 
-    return TRUE;
+    return true;
 }
diff --git a/deps/icu-small/source/common/uscript.cpp b/deps/icu-small/source/common/uscript.cpp
index f8bd7e7fdd..1ededbb268 100644
--- a/deps/icu-small/source/common/uscript.cpp
+++ b/deps/icu-small/source/common/uscript.cpp
@@ -113,14 +113,14 @@ uscript_getCode(const char* nameOrAbbrOrLocale,
         return 0;
     }
 
-    triedCode = FALSE;
+    triedCode = false;
     if(uprv_strchr(nameOrAbbrOrLocale, '-')==NULL && uprv_strchr(nameOrAbbrOrLocale, '_')==NULL ){
         /* try long and abbreviated script names first */
         UScriptCode code = (UScriptCode) u_getPropertyValueEnum(UCHAR_SCRIPT, nameOrAbbrOrLocale);
         if(code!=USCRIPT_INVALID_CODE) {
             return setOneCode(code, fillIn, capacity, err);
         }
-        triedCode = TRUE;
+        triedCode = true;
     }
     internalErrorCode = U_ZERO_ERROR;
     length = getCodesFromLocale(nameOrAbbrOrLocale, fillIn, capacity, err);
diff --git a/deps/icu-small/source/common/uscript_props.cpp b/deps/icu-small/source/common/uscript_props.cpp
index 07bae251ea..886acfafa8 100644
--- a/deps/icu-small/source/common/uscript_props.cpp
+++ b/deps/icu-small/source/common/uscript_props.cpp
@@ -242,6 +242,8 @@ const int32_t SCRIPT_PROPS[] = {
     0x16ABC | EXCLUSION,  // Tnsa
     0x1E290 | EXCLUSION,  // Toto
     0x10582 | EXCLUSION | CASED,  // Vith
+    0x11F1B | EXCLUSION | LB_LETTERS,  // Kawi
+    0x1E4E6 | EXCLUSION,  // Nagm
     // End copy-paste from parsescriptmetadata.py
 };
 
diff --git a/deps/icu-small/source/common/uset.cpp b/deps/icu-small/source/common/uset.cpp
index 871a5d8986..2152693560 100644
--- a/deps/icu-small/source/common/uset.cpp
+++ b/deps/icu-small/source/common/uset.cpp
@@ -344,12 +344,12 @@ uset_getItem(const USet* uset, int32_t itemIndex,
 //uset_getRange(const USet* set, int32_t rangeIndex,
 //              UChar32* pStart, UChar32* pEnd) {
 //    if ((uint32_t) rangeIndex >= (uint32_t) uset_getRangeCount(set)) {
-//        return FALSE;
+//        return false;
 //    }
 //    const UnicodeSet* us = (const UnicodeSet*) set;
 //    *pStart = us->getRangeStart(rangeIndex);
 //    *pEnd = us->getRangeEnd(rangeIndex);
-//    return TRUE;
+//    return true;
 //}
 
 /*
@@ -384,11 +384,11 @@ uset_getSerializedSet(USerializedSet* fillSet, const uint16_t* src, int32_t srcL
     int32_t length;
 
     if(fillSet==NULL) {
-        return FALSE;
+        return false;
     }
     if(src==NULL || srcLength<=0) {
         fillSet->length=fillSet->bmpLength=0;
-        return FALSE;
+        return false;
     }
 
     length=*src++;
@@ -397,20 +397,20 @@ uset_getSerializedSet(USerializedSet* fillSet, const uint16_t* src, int32_t srcL
         length&=0x7fff;
         if(srcLength<(2+length)) {
             fillSet->length=fillSet->bmpLength=0;
-            return FALSE;
+            return false;
         }
         fillSet->bmpLength=*src++;
     } else {
         /* only BMP values */
         if(srcLength<(1+length)) {
             fillSet->length=fillSet->bmpLength=0;
-            return FALSE;
+            return false;
         }
         fillSet->bmpLength=length;
     }
     fillSet->array=src;
     fillSet->length=length;
-    return TRUE;
+    return true;
 }
 
 U_CAPI void U_EXPORT2
@@ -451,7 +451,7 @@ uset_serializedContains(const USerializedSet* set, UChar32 c) {
     const uint16_t* array;
 
     if(set==NULL || (uint32_t)c>0x10ffff) {
-        return FALSE;
+        return false;
     }
 
     array=set->array;
@@ -520,7 +520,7 @@ uset_getSerializedRange(const USerializedSet* set, int32_t rangeIndex,
     int32_t bmpLength, length;
 
     if(set==NULL || rangeIndex<0 || pStart==NULL || pEnd==NULL) {
-        return FALSE;
+        return false;
     }
 
     array=set->array;
@@ -537,7 +537,7 @@ uset_getSerializedRange(const USerializedSet* set, int32_t rangeIndex,
         } else {
             *pEnd=0x10ffff;
         }
-        return TRUE;
+        return true;
     } else {
         rangeIndex-=bmpLength;
         rangeIndex*=2; /* address pairs of pairs of units */
@@ -551,9 +551,9 @@ uset_getSerializedRange(const USerializedSet* set, int32_t rangeIndex,
             } else {
                 *pEnd=0x10ffff;
             }
-            return TRUE;
+            return true;
         } else {
-            return FALSE;
+            return false;
         }
     }
 }
@@ -591,14 +591,14 @@ uset_getSerializedRange(const USerializedSet* set, int32_t rangeIndex,
 //     int32_t i, length, more;
 // 
 //     if(set==NULL || (uint32_t)c>0x10ffff) {
-//         return FALSE;
+//         return false;
 //     }
 // 
 //     length=set->length;
 //     i=findChar(set->array, length, c);
 //     if((i&1)^doRemove) {
 //         /* c is already in the set */
-//         return TRUE;
+//         return true;
 //     }
 // 
 //     /* how many more array items do we need? */
@@ -615,7 +615,7 @@ uset_getSerializedRange(const USerializedSet* set, int32_t rangeIndex,
 //                 }
 //             }
 //         }
-//         return TRUE;
+//         return true;
 //     } else if(i>0 && c==set->array[i-1]) {
 //         /* c is just after the previous range, extend that in-place by one */
 //         if(++c<=0x10ffff) {
@@ -632,7 +632,7 @@ uset_getSerializedRange(const USerializedSet* set, int32_t rangeIndex,
 //             /* extend the previous range (had limit 0x10ffff) to the end of Unicode */
 //             set->length=i-1;
 //         }
-//         return TRUE;
+//         return true;
 //     } else if(i==length && c==0x10ffff) {
 //         /* insert one range limit c */
 //         more=1;
@@ -647,7 +647,7 @@ uset_getSerializedRange(const USerializedSet* set, int32_t rangeIndex,
 //         int32_t newCapacity=set->capacity+set->capacity/2+USET_GROW_DELTA;
 //         UChar32* newArray=(UChar32* )uprv_malloc(newCapacity*4);
 //         if(newArray==NULL) {
-//             return FALSE;
+//             return false;
 //         }
 //         set->capacity=newCapacity;
 //         uprv_memcpy(newArray, set->array, length*4);
@@ -667,7 +667,7 @@ uset_getSerializedRange(const USerializedSet* set, int32_t rangeIndex,
 //     }
 //     set->length+=more;
 // 
-//     return TRUE;
+//     return true;
 // }
 // 
 // U_CAPI UBool U_EXPORT2
diff --git a/deps/icu-small/source/common/usetiter.cpp b/deps/icu-small/source/common/usetiter.cpp
index 7915169049..3cdece5500 100644
--- a/deps/icu-small/source/common/usetiter.cpp
+++ b/deps/icu-small/source/common/usetiter.cpp
@@ -50,19 +50,19 @@ UBool UnicodeSetIterator::next() {
     if (nextElement <= endElement) {
         codepoint = codepointEnd = nextElement++;
         string = NULL;
-        return TRUE;
+        return true;
     }
     if (range < endRange) {
         loadRange(++range);
         codepoint = codepointEnd = nextElement++;
         string = NULL;
-        return TRUE;
+        return true;
     }
 
-    if (nextString >= stringCount) return FALSE;
+    if (nextString >= stringCount) return false;
     codepoint = (UChar32)IS_STRING; // signal that value is actually a string
     string = (const UnicodeString*) set->strings->elementAt(nextString++);
-    return TRUE;
+    return true;
 }
 
 /**
@@ -82,20 +82,20 @@ UBool UnicodeSetIterator::nextRange() {
         codepointEnd = endElement;
         codepoint = nextElement;
         nextElement = endElement+1;
-        return TRUE;
+        return true;
     }
     if (range < endRange) {
         loadRange(++range);
         codepointEnd = endElement;
         codepoint = nextElement;
         nextElement = endElement+1;
-        return TRUE;
+        return true;
     }
 
-    if (nextString >= stringCount) return FALSE;
+    if (nextString >= stringCount) return false;
     codepoint = (UChar32)IS_STRING; // signal that value is actually a string
     string = (const UnicodeString*) set->strings->elementAt(nextString++);
-    return TRUE;
+    return true;
 }
 
 /**
diff --git a/deps/icu-small/source/common/ushape.cpp b/deps/icu-small/source/common/ushape.cpp
index ae13b5c118..babbbe52a8 100644
--- a/deps/icu-small/source/common/ushape.cpp
+++ b/deps/icu-small/source/common/ushape.cpp
@@ -354,10 +354,10 @@ _shapeToArabicDigitsWithContext(UChar *s, int32_t length,
             switch(ubidi_getClass(c)) {
             case U_LEFT_TO_RIGHT: /* L */
             case U_RIGHT_TO_LEFT: /* R */
-                lastStrongWasAL=FALSE;
+                lastStrongWasAL=false;
                 break;
             case U_RIGHT_TO_LEFT_ARABIC: /* AL */
-                lastStrongWasAL=TRUE;
+                lastStrongWasAL=true;
                 break;
             case U_EUROPEAN_NUMBER: /* EN */
                 if(lastStrongWasAL && (uint32_t)(c-0x30)<10) {
@@ -374,10 +374,10 @@ _shapeToArabicDigitsWithContext(UChar *s, int32_t length,
             switch(ubidi_getClass(c)) {
             case U_LEFT_TO_RIGHT: /* L */
             case U_RIGHT_TO_LEFT: /* R */
-                lastStrongWasAL=FALSE;
+                lastStrongWasAL=false;
                 break;
             case U_RIGHT_TO_LEFT_ARABIC: /* AL */
-                lastStrongWasAL=TRUE;
+                lastStrongWasAL=true;
                 break;
             case U_EUROPEAN_NUMBER: /* EN */
                 if(lastStrongWasAL && (uint32_t)(c-0x30)<10) {
@@ -1710,13 +1710,13 @@ u_shapeArabic(const UChar *source, int32_t sourceLength,
             _shapeToArabicDigitsWithContext(dest, destLength,
                                             digitBase,
                                             (UBool)((options&U_SHAPE_TEXT_DIRECTION_MASK)==U_SHAPE_TEXT_DIRECTION_LOGICAL),
-                                            FALSE);
+                                            false);
             break;
         case U_SHAPE_DIGITS_ALEN2AN_INIT_AL:
             _shapeToArabicDigitsWithContext(dest, destLength,
                                             digitBase,
                                             (UBool)((options&U_SHAPE_TEXT_DIRECTION_MASK)==U_SHAPE_TEXT_DIRECTION_LOGICAL),
-                                            TRUE);
+                                            true);
             break;
         default:
             /* will never occur because of validity checks above */
diff --git a/deps/icu-small/source/common/usprep.cpp b/deps/icu-small/source/common/usprep.cpp
index 41a1f56c77..50d16081d1 100644
--- a/deps/icu-small/source/common/usprep.cpp
+++ b/deps/icu-small/source/common/usprep.cpp
@@ -45,7 +45,7 @@ U_CDECL_BEGIN
 Static cache for already opened StringPrep profiles
 */
 static UHashtable *SHARED_DATA_HASHTABLE = NULL;
-static icu::UInitOnce gSharedDataInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gSharedDataInitOnce {};
 
 static UMutex usprepMutex;
 /* format version of spp file */
@@ -91,9 +91,9 @@ isSPrepAcceptable(void * /* context */,
     ) {
         //uprv_memcpy(formatVersion, pInfo->formatVersion, 4);
         uprv_memcpy(dataVersion, pInfo->dataVersion, 4);
-        return TRUE;
+        return true;
     } else {
-        return FALSE;
+        return false;
     }
 }
 
@@ -159,8 +159,8 @@ usprep_internal_flushCache(UBool noRefCount){
         profile = (UStringPrepProfile *) e->value.pointer;
         key  = (UStringPrepKey *) e->key.pointer;
 
-        if ((noRefCount== FALSE && profile->refCount == 0) || 
-             noRefCount== TRUE) {
+        if ((noRefCount== false && profile->refCount == 0) || 
+             noRefCount== true) {
             deletedNum++;
             uhash_removeElement(SHARED_DATA_HASHTABLE, e);
 
@@ -188,13 +188,13 @@ usprep_internal_flushCache(UBool noRefCount){
 /* Works just like ucnv_flushCache() 
 static int32_t 
 usprep_flushCache(){
-    return usprep_internal_flushCache(FALSE);
+    return usprep_internal_flushCache(false);
 }
 */
 
 static UBool U_CALLCONV usprep_cleanup(void){
     if (SHARED_DATA_HASHTABLE != NULL) {
-        usprep_internal_flushCache(TRUE);
+        usprep_internal_flushCache(true);
         if (SHARED_DATA_HASHTABLE != NULL && uhash_count(SHARED_DATA_HASHTABLE) == 0) {
             uhash_close(SHARED_DATA_HASHTABLE);
             SHARED_DATA_HASHTABLE = NULL;
@@ -243,7 +243,7 @@ loadData(UStringPrepProfile* profile,
     //TODO: change the path
     dataMemory=udata_openChoice(path, type, name, isSPrepAcceptable, NULL, errorCode);
     if(U_FAILURE(*errorCode)) {
-        return FALSE;
+        return false;
     }
 
     p=(const int32_t *)udata_getMemory(dataMemory);
@@ -254,7 +254,7 @@ loadData(UStringPrepProfile* profile,
 
     if(U_FAILURE(*errorCode)) {
         udata_close(dataMemory);
-        return FALSE;
+        return false;
     }
 
     /* in the mutex block, set the data for this process */
@@ -280,7 +280,7 @@ loadData(UStringPrepProfile* profile,
     
     if(U_FAILURE(*errorCode)){
         udata_close(dataMemory);
-        return FALSE;
+        return false;
     }
     if( normUniVer < sprepUniVer && /* the Unicode version of SPREP file must be less than the Unicode Version of the normalization data */
         normUniVer < normCorrVer && /* the Unicode version of the NormalizationCorrections.txt file should be less than the Unicode Version of the normalization data */
@@ -288,9 +288,9 @@ loadData(UStringPrepProfile* profile,
       ){
         *errorCode = U_INVALID_FORMAT_ERROR;
         udata_close(dataMemory);
-        return FALSE;
+        return false;
     }
-    profile->isDataLoaded = TRUE;
+    profile->isDataLoaded = true;
 
     /* if a different thread set it first, then close the extra data */
     if(dataMemory!=NULL) {
@@ -474,28 +474,28 @@ getValues(uint16_t trieWord, int16_t& value, UBool& isIndex){
          * the source codepoint is copied to the destination
          */
         type = USPREP_TYPE_LIMIT;
-        isIndex =FALSE;
+        isIndex =false;
         value = 0;
     }else if(trieWord >= _SPREP_TYPE_THRESHOLD){
         type = (UStringPrepType) (trieWord - _SPREP_TYPE_THRESHOLD);
-        isIndex =FALSE;
+        isIndex =false;
         value = 0;
     }else{
         /* get the type */
         type = USPREP_MAP;
         /* ascertain if the value is index or delta */
         if(trieWord & 0x02){
-            isIndex = TRUE;
+            isIndex = true;
             value = trieWord  >> 2; //mask off the lower 2 bits and shift
         }else{
-            isIndex = FALSE;
+            isIndex = false;
             value = (int16_t)trieWord;
             value =  (value >> 2);
         }
  
         if((trieWord>>2) == _SPREP_MAX_INDEX_VALUE){
             type = USPREP_DELETE;
-            isIndex =FALSE;
+            isIndex =false;
             value = 0;
         }
     }
@@ -535,7 +535,7 @@ usprep_map(  const UStringPrepProfile* profile,
         type = getValues(result, value, isIndex);
 
         // check if the source codepoint is unassigned
-        if(type == USPREP_UNASSIGNED && allowUnassigned == FALSE){
+        if(type == USPREP_UNASSIGNED && allowUnassigned == false){
 
             uprv_syntaxError(src,srcIndex-U16_LENGTH(ch), srcLength,parseError);
             *status = U_STRINGPREP_UNASSIGNED_ERROR;
@@ -709,7 +709,7 @@ usprep_prepare(   const UStringPrepProfile* profile,
     const UChar *b2 = s2.getBuffer();
     int32_t b2Len = s2.length();
     UCharDirection direction=U_CHAR_DIRECTION_COUNT, firstCharDir=U_CHAR_DIRECTION_COUNT;
-    UBool leftToRight=FALSE, rightToLeft=FALSE;
+    UBool leftToRight=false, rightToLeft=false;
     int32_t rtlPos =-1, ltrPos =-1;
 
     for(int32_t b2Index=0; b2Index<b2Len;){
@@ -737,31 +737,31 @@ usprep_prepare(   const UStringPrepProfile* profile,
                 firstCharDir = direction;
             }
             if(direction == U_LEFT_TO_RIGHT){
-                leftToRight = TRUE;
+                leftToRight = true;
                 ltrPos = b2Index-1;
             }
             if(direction == U_RIGHT_TO_LEFT || direction == U_RIGHT_TO_LEFT_ARABIC){
-                rightToLeft = TRUE;
+                rightToLeft = true;
                 rtlPos = b2Index-1;
             }
         }
     }
-    if(profile->checkBiDi == TRUE){
+    if(profile->checkBiDi == true){
         // satisfy 2
-        if( leftToRight == TRUE && rightToLeft == TRUE){
+        if( leftToRight == true && rightToLeft == true){
             *status = U_STRINGPREP_CHECK_BIDI_ERROR;
             uprv_syntaxError(b2,(rtlPos>ltrPos) ? rtlPos : ltrPos, b2Len, parseError);
             return 0;
         }
 
         //satisfy 3
-        if( rightToLeft == TRUE && 
+        if( rightToLeft == true && 
             !((firstCharDir == U_RIGHT_TO_LEFT || firstCharDir == U_RIGHT_TO_LEFT_ARABIC) &&
               (direction == U_RIGHT_TO_LEFT || direction == U_RIGHT_TO_LEFT_ARABIC))
            ){
             *status = U_STRINGPREP_CHECK_BIDI_ERROR;
             uprv_syntaxError(b2, rtlPos, b2Len, parseError);
-            return FALSE;
+            return false;
         }
     }
     return s2.extract(dest, destCapacity, *status);
diff --git a/deps/icu-small/source/common/ustr_cnv.cpp b/deps/icu-small/source/common/ustr_cnv.cpp
index 9a25a9905a..97fbc527a3 100644
--- a/deps/icu-small/source/common/ustr_cnv.cpp
+++ b/deps/icu-small/source/common/ustr_cnv.cpp
@@ -144,7 +144,7 @@ u_uastrncpy(UChar *ucs1,
                    &s2,
                    s2+u_astrnlen(s2, n),
                    NULL,
-                   TRUE,
+                   true,
                    &err);
     ucnv_reset(cnv); /* be good citizens */
     u_releaseDefaultConverter(cnv);
@@ -216,7 +216,7 @@ u_austrncpy(char *s1,
                   &ucs2,
                   ucs2+u_ustrnlen(ucs2, n),
                   NULL,
-                  TRUE,
+                  true,
                   &err);
     ucnv_reset(cnv); /* be good citizens */
     u_releaseDefaultConverter(cnv);
diff --git a/deps/icu-small/source/common/ustr_titlecase_brkiter.cpp b/deps/icu-small/source/common/ustr_titlecase_brkiter.cpp
index 3002d64e34..85dfa0decb 100644
--- a/deps/icu-small/source/common/ustr_titlecase_brkiter.cpp
+++ b/deps/icu-small/source/common/ustr_titlecase_brkiter.cpp
@@ -110,7 +110,7 @@ int32_t WholeStringBreakIterator::next() { return length; }
 int32_t WholeStringBreakIterator::current() const { return 0; }
 int32_t WholeStringBreakIterator::following(int32_t /*offset*/) { return length; }
 int32_t WholeStringBreakIterator::preceding(int32_t /*offset*/) { return 0; }
-UBool WholeStringBreakIterator::isBoundary(int32_t /*offset*/) { return FALSE; }
+UBool WholeStringBreakIterator::isBoundary(int32_t /*offset*/) { return false; }
 int32_t WholeStringBreakIterator::next(int32_t /*n*/) { return length; }
 
 WholeStringBreakIterator *WholeStringBreakIterator::createBufferClone(
diff --git a/deps/icu-small/source/common/ustrcase.cpp b/deps/icu-small/source/common/ustrcase.cpp
index 43910ea520..8037c09b4f 100644
--- a/deps/icu-small/source/common/ustrcase.cpp
+++ b/deps/icu-small/source/common/ustrcase.cpp
@@ -107,7 +107,7 @@ appendResult(UChar *dest, int32_t destIndex, int32_t destCapacity,
         /* append the result */
         if(c>=0) {
             /* code point */
-            UBool isError=FALSE;
+            UBool isError=false;
             U16_APPEND(dest, destIndex, destCapacity, c, isError);
             if(isError) {
                 /* overflow, nothing written */
@@ -1087,12 +1087,12 @@ UBool isFollowedByCasedLetter(const UChar *s, int32_t i, int32_t length) {
         if ((type & UCASE_IGNORABLE) != 0) {
             // Case-ignorable, continue with the loop.
         } else if (type != UCASE_NONE) {
-            return TRUE;  // Followed by cased letter.
+            return true;  // Followed by cased letter.
         } else {
-            return FALSE;  // Uncased and not case-ignorable.
+            return false;  // Uncased and not case-ignorable.
         }
     }
-    return FALSE;  // Not followed by cased letter.
+    return false;  // Not followed by cased letter.
 }
 
 /**
@@ -1155,7 +1155,7 @@ int32_t toUpper(uint32_t options,
                 nextState |= AFTER_VOWEL_WITH_ACCENT;
             }
             // Map according to Greek rules.
-            UBool addTonos = FALSE;
+            UBool addTonos = false;
             if (upper == 0x397 &&
                     (data & HAS_ACCENT) != 0 &&
                     numYpogegrammeni == 0 &&
@@ -1166,7 +1166,7 @@ int32_t toUpper(uint32_t options,
                 if (i == nextIndex) {
                     upper = 0x389;  // Preserve the precomposed form.
                 } else {
-                    addTonos = TRUE;
+                    addTonos = true;
                 }
             } else if ((data & HAS_DIALYTIKA) != 0) {
                 // Preserve a vowel with dialytika in precomposed form if it exists.
@@ -1181,7 +1181,7 @@ int32_t toUpper(uint32_t options,
 
             UBool change;
             if (edits == nullptr && (options & U_OMIT_UNCHANGED_TEXT) == 0) {
-                change = TRUE;  // common, simple usage
+                change = true;  // common, simple usage
             } else {
                 // Find out first whether we are changing the text.
                 change = src[i] != upper || numYpogegrammeni > 0;
diff --git a/deps/icu-small/source/common/ustring.cpp b/deps/icu-small/source/common/ustring.cpp
index 8477256389..5804976ef9 100644
--- a/deps/icu-small/source/common/ustring.cpp
+++ b/deps/icu-small/source/common/ustring.cpp
@@ -43,13 +43,13 @@ static inline UBool
 isMatchAtCPBoundary(const UChar *start, const UChar *match, const UChar *matchLimit, const UChar *limit) {
     if(U16_IS_TRAIL(*match) && start!=match && U16_IS_LEAD(*(match-1))) {
         /* the leading edge of the match is in the middle of a surrogate pair */
-        return FALSE;
+        return false;
     }
     if(U16_IS_LEAD(*(matchLimit-1)) && matchLimit!=limit && U16_IS_TRAIL(*matchLimit)) {
         /* the trailing edge of the match is in the middle of a surrogate pair */
-        return FALSE;
+        return false;
     }
-    return TRUE;
+    return true;
 }
 
 U_CAPI UChar * U_EXPORT2
@@ -461,7 +461,7 @@ u_memrchr32(const UChar *s, UChar32 c, int32_t count) {
 /*
  * Match each code point in a string against each code point in the matchSet.
  * Return the index of the first string code point that
- * is (polarity==TRUE) or is not (FALSE) contained in the matchSet.
+ * is (polarity==true) or is not (false) contained in the matchSet.
  * Return -(string length)-1 if there is no such code point.
  */
 static int32_t
@@ -540,7 +540,7 @@ endloop:
 U_CAPI UChar * U_EXPORT2
 u_strpbrk(const UChar *string, const UChar *matchSet)
 {
-    int32_t idx = _matchFromSet(string, matchSet, TRUE);
+    int32_t idx = _matchFromSet(string, matchSet, true);
     if(idx >= 0) {
         return (UChar *)string + idx;
     } else {
@@ -552,7 +552,7 @@ u_strpbrk(const UChar *string, const UChar *matchSet)
 U_CAPI int32_t U_EXPORT2
 u_strcspn(const UChar *string, const UChar *matchSet)
 {
-    int32_t idx = _matchFromSet(string, matchSet, TRUE);
+    int32_t idx = _matchFromSet(string, matchSet, true);
     if(idx >= 0) {
         return idx;
     } else {
@@ -564,7 +564,7 @@ u_strcspn(const UChar *string, const UChar *matchSet)
 U_CAPI int32_t U_EXPORT2
 u_strspn(const UChar *string, const UChar *matchSet)
 {
-    int32_t idx = _matchFromSet(string, matchSet, FALSE);
+    int32_t idx = _matchFromSet(string, matchSet, false);
     if(idx >= 0) {
         return idx;
     } else {
@@ -929,13 +929,13 @@ u_strCompare(const UChar *s1, int32_t length1,
     if(s1==NULL || length1<-1 || s2==NULL || length2<-1) {
         return 0;
     }
-    return uprv_strCompare(s1, length1, s2, length2, FALSE, codePointOrder);
+    return uprv_strCompare(s1, length1, s2, length2, false, codePointOrder);
 }
 
 /* String compare in code point order - u_strcmp() compares in code unit order. */
 U_CAPI int32_t U_EXPORT2
 u_strcmpCodePointOrder(const UChar *s1, const UChar *s2) {
-    return uprv_strCompare(s1, -1, s2, -1, FALSE, TRUE);
+    return uprv_strCompare(s1, -1, s2, -1, false, true);
 }
 
 U_CAPI int32_t   U_EXPORT2
@@ -960,7 +960,7 @@ u_strncmp(const UChar     *s1,
 
 U_CAPI int32_t U_EXPORT2
 u_strncmpCodePointOrder(const UChar *s1, const UChar *s2, int32_t n) {
-    return uprv_strCompare(s1, n, s2, n, TRUE, TRUE);
+    return uprv_strCompare(s1, n, s2, n, true, true);
 }
 
 U_CAPI UChar* U_EXPORT2
@@ -1049,10 +1049,10 @@ U_CAPI UBool U_EXPORT2
 u_strHasMoreChar32Than(const UChar *s, int32_t length, int32_t number) {
 
     if(number<0) {
-        return TRUE;
+        return true;
     }
     if(s==NULL || length<-1) {
-        return FALSE;
+        return false;
     }
 
     if(length==-1) {
@@ -1062,10 +1062,10 @@ u_strHasMoreChar32Than(const UChar *s, int32_t length, int32_t number) {
         /* count code points until they exceed */
         for(;;) {
             if((c=*s++)==0) {
-                return FALSE;
+                return false;
             }
             if(number==0) {
-                return TRUE;
+                return true;
             }
             if(U16_IS_LEAD(c) && U16_IS_TRAIL(*s)) {
                 ++s;
@@ -1079,13 +1079,13 @@ u_strHasMoreChar32Than(const UChar *s, int32_t length, int32_t number) {
 
         /* s contains at least (length+1)/2 code points: <=2 UChars per cp */
         if(((length+1)/2)>number) {
-            return TRUE;
+            return true;
         }
 
         /* check if s does not even contain enough UChars */
         maxSupplementary=length-number;
         if(maxSupplementary<=0) {
-            return FALSE;
+            return false;
         }
         /* there are maxSupplementary=length-number more UChars than asked-for code points */
 
@@ -1096,16 +1096,16 @@ u_strHasMoreChar32Than(const UChar *s, int32_t length, int32_t number) {
         limit=s+length;
         for(;;) {
             if(s==limit) {
-                return FALSE;
+                return false;
             }
             if(number==0) {
-                return TRUE;
+                return true;
             }
             if(U16_IS_LEAD(*s++) && s!=limit && U16_IS_TRAIL(*s)) {
                 ++s;
                 if(--maxSupplementary<=0) {
                     /* too many pairs - too few code points */
-                    return FALSE;
+                    return false;
                 }
             }
             --number;
@@ -1162,7 +1162,7 @@ u_memcmp(const UChar *buf1, const UChar *buf2, int32_t count) {
 
 U_CAPI int32_t U_EXPORT2
 u_memcmpCodePointOrder(const UChar *s1, const UChar *s2, int32_t count) {
-    return uprv_strCompare(s1, count, s2, count, FALSE, TRUE);
+    return uprv_strCompare(s1, count, s2, count, false, true);
 }
 
 /* u_unescape & support fns ------------------------------------------------- */
@@ -1223,7 +1223,7 @@ u_unescapeAt(UNESCAPE_CHAR_AT charAt,
     int8_t maxDig = 0;
     int8_t bitsPerDigit = 4; 
     int32_t dig;
-    UBool braces = FALSE;
+    UBool braces = false;
 
     /* Check that offset is in range */
     if (*offset < 0 || *offset >= length) {
@@ -1245,7 +1245,7 @@ u_unescapeAt(UNESCAPE_CHAR_AT charAt,
         minDig = 1;
         if (*offset < length && charAt(*offset, context) == u'{') {
             ++(*offset);
-            braces = TRUE;
+            braces = true;
             maxDig = 8;
         } else {
             maxDig = 2;
diff --git a/deps/icu-small/source/common/ustrtrns.cpp b/deps/icu-small/source/common/ustrtrns.cpp
index 5dc032c02f..dcb9dc5878 100644
--- a/deps/icu-small/source/common/ustrtrns.cpp
+++ b/deps/icu-small/source/common/ustrtrns.cpp
@@ -119,7 +119,7 @@ u_strFromUTF32WithSub(UChar *dest,
             } else {
                 ++numSubstitutions;
             }
-        } while(TRUE);
+        } while(true);
     }
 
     reqLength += (int32_t)(pDest - dest);
diff --git a/deps/icu-small/source/common/utext.cpp b/deps/icu-small/source/common/utext.cpp
index ec79700ca8..548e6a60f3 100644
--- a/deps/icu-small/source/common/utext.cpp
+++ b/deps/icu-small/source/common/utext.cpp
@@ -49,14 +49,14 @@ utext_moveIndex32(UText *ut, int32_t delta) {
     UChar32  c;
     if (delta > 0) {
         do {
-            if(ut->chunkOffset>=ut->chunkLength && !utext_access(ut, ut->chunkNativeLimit, TRUE)) {
-                return FALSE;
+            if(ut->chunkOffset>=ut->chunkLength && !utext_access(ut, ut->chunkNativeLimit, true)) {
+                return false;
             }
             c = ut->chunkContents[ut->chunkOffset];
             if (U16_IS_SURROGATE(c)) {
                 c = utext_next32(ut);
                 if (c == U_SENTINEL) {
-                    return FALSE;
+                    return false;
                 }
             } else {
                 ut->chunkOffset++;
@@ -65,14 +65,14 @@ utext_moveIndex32(UText *ut, int32_t delta) {
 
     } else if (delta<0) {
         do {
-            if(ut->chunkOffset<=0 && !utext_access(ut, ut->chunkNativeStart, FALSE)) {
-                return FALSE;
+            if(ut->chunkOffset<=0 && !utext_access(ut, ut->chunkNativeStart, false)) {
+                return false;
             }
             c = ut->chunkContents[ut->chunkOffset-1];
             if (U16_IS_SURROGATE(c)) {
                 c = utext_previous32(ut);
                 if (c == U_SENTINEL) {
-                    return FALSE;
+                    return false;
                 }
             } else {
                 ut->chunkOffset--;
@@ -80,7 +80,7 @@ utext_moveIndex32(UText *ut, int32_t delta) {
         } while(++delta<0);
     }
 
-    return TRUE;
+    return true;
 }
 
 
@@ -114,7 +114,7 @@ utext_setNativeIndex(UText *ut, int64_t index) {
         // Access the new position.  Assume a forward iteration from here,
         // which will also be optimimum for a single random access.
         // Reverse iterations may suffer slightly.
-        ut->pFuncs->access(ut, index, TRUE);
+        ut->pFuncs->access(ut, index, true);
     } else if((int32_t)(index - ut->chunkNativeStart) <= ut->nativeIndexingLimit) {
         // utf-16 indexing.
         ut->chunkOffset=(int32_t)(index-ut->chunkNativeStart);
@@ -127,7 +127,7 @@ utext_setNativeIndex(UText *ut, int64_t index) {
         UChar c= ut->chunkContents[ut->chunkOffset];
         if (U16_IS_TRAIL(c)) {
             if (ut->chunkOffset==0) {
-                ut->pFuncs->access(ut, ut->chunkNativeStart, FALSE);
+                ut->pFuncs->access(ut, ut->chunkNativeStart, false);
             }
             if (ut->chunkOffset>0) {
                 UChar lead = ut->chunkContents[ut->chunkOffset-1];
@@ -152,7 +152,7 @@ utext_getPreviousNativeIndex(UText *ut) {
     int64_t result;
     if (i >= 0) {
         UChar c = ut->chunkContents[i];
-        if (U16_IS_TRAIL(c) == FALSE) {
+        if (U16_IS_TRAIL(c) == false) {
             if (i <= ut->nativeIndexingLimit) {
                 result = ut->chunkNativeStart + i;
             } else {
@@ -189,14 +189,14 @@ utext_current32(UText *ut) {
     UChar32  c;
     if (ut->chunkOffset==ut->chunkLength) {
         // Current position is just off the end of the chunk.
-        if (ut->pFuncs->access(ut, ut->chunkNativeLimit, TRUE) == FALSE) {
+        if (ut->pFuncs->access(ut, ut->chunkNativeLimit, true) == false) {
             // Off the end of the text.
             return U_SENTINEL;
         }
     }
 
     c = ut->chunkContents[ut->chunkOffset];
-    if (U16_IS_LEAD(c) == FALSE) {
+    if (U16_IS_LEAD(c) == false) {
         // Normal, non-supplementary case.
         return c;
     }
@@ -219,11 +219,11 @@ utext_current32(UText *ut) {
         //        the original position before the unpaired lead still needs to be restored.
         int64_t  nativePosition = ut->chunkNativeLimit;
         int32_t  originalOffset = ut->chunkOffset;
-        if (ut->pFuncs->access(ut, nativePosition, TRUE)) {
+        if (ut->pFuncs->access(ut, nativePosition, true)) {
             trail = ut->chunkContents[ut->chunkOffset];
         }
-        UBool r = ut->pFuncs->access(ut, nativePosition, FALSE);  // reverse iteration flag loads preceding chunk
-        U_ASSERT(r==TRUE);
+        UBool r = ut->pFuncs->access(ut, nativePosition, false);  // reverse iteration flag loads preceding chunk
+        U_ASSERT(r==true);
         ut->chunkOffset = originalOffset;
         if(!r) {
             return U_SENTINEL;
@@ -246,7 +246,7 @@ utext_char32At(UText *ut, int64_t nativeIndex) {
     if (nativeIndex>=ut->chunkNativeStart && nativeIndex < ut->chunkNativeStart + ut->nativeIndexingLimit) {
         ut->chunkOffset = (int32_t)(nativeIndex - ut->chunkNativeStart);
         c = ut->chunkContents[ut->chunkOffset];
-        if (U16_IS_SURROGATE(c) == FALSE) {
+        if (U16_IS_SURROGATE(c) == false) {
             return c;
         }
     }
@@ -270,13 +270,13 @@ utext_next32(UText *ut) {
     UChar32       c;
 
     if (ut->chunkOffset >= ut->chunkLength) {
-        if (ut->pFuncs->access(ut, ut->chunkNativeLimit, TRUE) == FALSE) {
+        if (ut->pFuncs->access(ut, ut->chunkNativeLimit, true) == false) {
             return U_SENTINEL;
         }
     }
 
     c = ut->chunkContents[ut->chunkOffset++];
-    if (U16_IS_LEAD(c) == FALSE) {
+    if (U16_IS_LEAD(c) == false) {
         // Normal case, not supplementary.
         //   (A trail surrogate seen here is just returned as is, as a surrogate value.
         //    It cannot be part of a pair.)
@@ -284,14 +284,14 @@ utext_next32(UText *ut) {
     }
 
     if (ut->chunkOffset >= ut->chunkLength) {
-        if (ut->pFuncs->access(ut, ut->chunkNativeLimit, TRUE) == FALSE) {
+        if (ut->pFuncs->access(ut, ut->chunkNativeLimit, true) == false) {
             // c is an unpaired lead surrogate at the end of the text.
             // return it as it is.
             return c;
         }
     }
     UChar32 trail = ut->chunkContents[ut->chunkOffset];
-    if (U16_IS_TRAIL(trail) == FALSE) {
+    if (U16_IS_TRAIL(trail) == false) {
         // c was an unpaired lead surrogate, not at the end of the text.
         // return it as it is (unpaired).  Iteration position is on the
         // following character, possibly in the next chunk, where the
@@ -310,13 +310,13 @@ utext_previous32(UText *ut) {
     UChar32       c;
 
     if (ut->chunkOffset <= 0) {
-        if (ut->pFuncs->access(ut, ut->chunkNativeStart, FALSE) == FALSE) {
+        if (ut->pFuncs->access(ut, ut->chunkNativeStart, false) == false) {
             return U_SENTINEL;
         }
     }
     ut->chunkOffset--;
     c = ut->chunkContents[ut->chunkOffset];
-    if (U16_IS_TRAIL(c) == FALSE) {
+    if (U16_IS_TRAIL(c) == false) {
         // Normal case, not supplementary.
         //   (A lead surrogate seen here is just returned as is, as a surrogate value.
         //    It cannot be part of a pair.)
@@ -324,7 +324,7 @@ utext_previous32(UText *ut) {
     }
 
     if (ut->chunkOffset <= 0) {
-        if (ut->pFuncs->access(ut, ut->chunkNativeStart, FALSE) == FALSE) {
+        if (ut->pFuncs->access(ut, ut->chunkNativeStart, false) == false) {
             // c is an unpaired trail surrogate at the start of the text.
             // return it as it is.
             return c;
@@ -332,7 +332,7 @@ utext_previous32(UText *ut) {
     }
 
     UChar32 lead = ut->chunkContents[ut->chunkOffset-1];
-    if (U16_IS_LEAD(lead) == FALSE) {
+    if (U16_IS_LEAD(lead) == false) {
         // c was an unpaired trail surrogate, not at the end of the text.
         // return it as it is (unpaired).  Iteration position is at c
         return c;
@@ -351,7 +351,7 @@ utext_next32From(UText *ut, int64_t index) {
 
     if(index<ut->chunkNativeStart || index>=ut->chunkNativeLimit) {
         // Desired position is outside of the current chunk.
-        if(!ut->pFuncs->access(ut, index, TRUE)) {
+        if(!ut->pFuncs->access(ut, index, true)) {
             // no chunk available here
             return U_SENTINEL;
         }
@@ -391,7 +391,7 @@ utext_previous32From(UText *ut, int64_t index) {
     //
     if(index<=ut->chunkNativeStart || index>ut->chunkNativeLimit) {
         // Requested native index is outside of the current chunk.
-        if(!ut->pFuncs->access(ut, index, FALSE)) {
+        if(!ut->pFuncs->access(ut, index, false)) {
             // no chunk available here
             return U_SENTINEL;
         }
@@ -400,7 +400,7 @@ utext_previous32From(UText *ut, int64_t index) {
         ut->chunkOffset = (int32_t)(index - ut->chunkNativeStart);
     } else {
         ut->chunkOffset=ut->pFuncs->mapNativeIndexToUTF16(ut, index);
-        if (ut->chunkOffset==0 && !ut->pFuncs->access(ut, index, FALSE)) {
+        if (ut->chunkOffset==0 && !ut->pFuncs->access(ut, index, false)) {
             // no chunk available here
             return U_SENTINEL;
         }
@@ -438,24 +438,24 @@ utext_equals(const UText *a, const UText *b) {
         a->magic != UTEXT_MAGIC ||
         b->magic != UTEXT_MAGIC) {
             // Null or invalid arguments don't compare equal to anything.
-            return FALSE;
+            return false;
     }
 
     if (a->pFuncs != b->pFuncs) {
         // Different types of text providers.
-        return FALSE;
+        return false;
     }
 
     if (a->context != b->context) {
         // Different sources (different strings)
-        return FALSE;
+        return false;
     }
     if (utext_getNativeIndex(a) != utext_getNativeIndex(b)) {
         // Different current position in the string.
-        return FALSE;
+        return false;
     }
 
-    return TRUE;
+    return true;
 }
 
 U_CAPI UBool U_EXPORT2
@@ -987,7 +987,7 @@ utf8TextAccess(UText *ut, int64_t index, UBool forward) {
                 // Don't swap buffers, but do set the
                 //   current buffer position.
                 ut->chunkOffset = ut->chunkLength;
-                return FALSE;
+                return false;
             } else {
                 // End of current buffer.
                 //   check whether other buffer already has what we need.
@@ -1016,7 +1016,7 @@ utf8TextAccess(UText *ut, int64_t index, UBool forward) {
                     // Current buffer extends up to the end of the string.
                     //   Leave it as the current buffer.
                     ut->chunkOffset = ut->chunkLength;
-                    return FALSE;
+                    return false;
                 }
                 if (ix == u8b->bufNativeLimit) {
                     // Alternate buffer extends to the end of string.
@@ -1038,7 +1038,7 @@ utf8TextAccess(UText *ut, int64_t index, UBool forward) {
             mapIndex = ix - u8b->toUCharsMapStart;
             U_ASSERT(mapIndex < (int32_t)sizeof(UTF8Buf::mapToUChars));
             ut->chunkOffset = u8b->mapToUChars[mapIndex] - u8b->bufStartIdx;
-            return TRUE;
+            return true;
 
         }
     }
@@ -1055,7 +1055,7 @@ utf8TextAccess(UText *ut, int64_t index, UBool forward) {
             // Don't swap buffers, but do set the
             //   current buffer position.
             ut->chunkOffset = 0;
-            return FALSE;
+            return false;
         } else {
             // Start of current buffer.
             //   check whether other buffer already has what we need.
@@ -1108,9 +1108,9 @@ utf8TextAccess(UText *ut, int64_t index, UBool forward) {
         //   one of the trailing bytes.  Because there is no preceding ,
         //   character, this access fails.  We can't pick up on the
         //   situation sooner because the requested index is not zero.
-        return FALSE;
+        return false;
     } else {
-        return TRUE;
+        return true;
     }
 
 
@@ -1139,7 +1139,7 @@ swapBuffers:
         U_ASSERT(mapIndex<(int32_t)sizeof(u8b->mapToUChars));
         ut->chunkOffset = u8b->mapToUChars[mapIndex] - u8b->bufStartIdx;
 
-        return TRUE;
+        return true;
     }
 
 
@@ -1170,7 +1170,7 @@ swapBuffers:
         ut->chunkOffset = 0;
         U_ASSERT(ix == u8b->bufNativeStart);
     }
-    return FALSE;
+    return false;
 
 makeStubBuffer:
     //   The user has done a seek/access past the start or end
@@ -1203,10 +1203,10 @@ fillForward:
         ut->p = u8b_swap;
 
         int32_t strLen = ut->b;
-        UBool   nulTerminated = FALSE;
+        UBool   nulTerminated = false;
         if (strLen < 0) {
             strLen = 0x7fffffff;
-            nulTerminated = TRUE;
+            nulTerminated = true;
         }
 
         UChar   *buf = u8b_swap->buf;
@@ -1214,7 +1214,7 @@ fillForward:
         uint8_t *mapToUChars  = u8b_swap->mapToUChars;
         int32_t  destIx       = 0;
         int32_t  srcIx        = ix;
-        UBool    seenNonAscii = FALSE;
+        UBool    seenNonAscii = false;
         UChar32  c = 0;
 
         // Fill the chunk buffer and mapping arrays.
@@ -1230,8 +1230,8 @@ fillForward:
                 destIx++;
             } else {
                 // General case, handle everything.
-                if (seenNonAscii == FALSE) {
-                    seenNonAscii = TRUE;
+                if (seenNonAscii == false) {
+                    seenNonAscii = true;
                     u8b_swap->bufNILimit = destIx;
                 }
 
@@ -1269,7 +1269,7 @@ fillForward:
         u8b_swap->bufNativeLimit     = srcIx;
         u8b_swap->bufStartIdx        = 0;
         u8b_swap->bufLimitIdx        = destIx;
-        if (seenNonAscii == FALSE) {
+        if (seenNonAscii == false) {
             u8b_swap->bufNILimit     = destIx;
         }
         u8b_swap->toUCharsMapStart   = u8b_swap->bufNativeStart;
@@ -1293,7 +1293,7 @@ fillForward:
                 ut->providerProperties &= ~I32_FLAG(UTEXT_PROVIDER_LENGTH_IS_EXPENSIVE);
             }
         }
-        return TRUE;
+        return true;
     }
 
 
@@ -1402,7 +1402,7 @@ fillReverse:
         ut->chunkNativeStart    = u8b_swap->bufNativeStart;
         ut->chunkNativeLimit    = u8b_swap->bufNativeLimit;
         ut->nativeIndexingLimit = u8b_swap->bufNILimit;
-        return TRUE;
+        return true;
     }
 
 }
@@ -1526,7 +1526,7 @@ utf8TextExtract(UText *ut,
     utext_strFromUTF8(dest, destCapacity, &destLength,
                     (const char *)ut->context+start32, limit32-start32,
                     pErrorCode);
-    utf8TextAccess(ut, limit32, TRUE);
+    utf8TextAccess(ut, limit32, true);
     return destLength;
 }
 
@@ -1760,13 +1760,13 @@ repTextAccess(UText *ut, int64_t index, UBool forward) {
         if (index32>=ut->chunkNativeStart && index32<ut->chunkNativeLimit) {
             // Buffer already contains the requested position.
             ut->chunkOffset = (int32_t)(index - ut->chunkNativeStart);
-            return TRUE;
+            return true;
         }
         if (index32>=length && ut->chunkNativeLimit==length) {
             // Request for end of string, and buffer already extends up to it.
             // Can't get the data, but don't change the buffer.
             ut->chunkOffset = length - (int32_t)ut->chunkNativeStart;
-            return FALSE;
+            return false;
         }
 
         ut->chunkNativeLimit = index + REP_TEXT_CHUNK_SIZE - 1;
@@ -1787,13 +1787,13 @@ repTextAccess(UText *ut, int64_t index, UBool forward) {
         if (index32>ut->chunkNativeStart && index32<=ut->chunkNativeLimit) {
             // Requested position already in buffer.
             ut->chunkOffset = index32 - (int32_t)ut->chunkNativeStart;
-            return TRUE;
+            return true;
         }
         if (index32==0 && ut->chunkNativeStart==0) {
             // Request for start, buffer already begins at start.
             //  No data, but keep the buffer as is.
             ut->chunkOffset = 0;
-            return FALSE;
+            return false;
         }
 
         // Figure out the bounds of the chunk to extract for reverse iteration.
@@ -1849,7 +1849,7 @@ repTextAccess(UText *ut, int64_t index, UBool forward) {
     // Use fast indexing for get/setNativeIndex()
     ut->nativeIndexingLimit = ut->chunkLength;
 
-    return TRUE;
+    return true;
 }
 
 
@@ -1892,7 +1892,7 @@ repTextExtract(UText *ut,
     }
     UnicodeString buffer(dest, 0, destCapacity); // writable alias
     rep->extractBetween(start32, limit32, buffer);
-    repTextAccess(ut, limit32, TRUE);
+    repTextAccess(ut, limit32, true);
 
     return u_terminateUChars(dest, destCapacity, length, status);
 }
@@ -1948,7 +1948,7 @@ repTextReplace(UText *ut,
 
     // set the iteration position to the end of the newly inserted replacement text.
     int32_t newIndexPos = limit32 + lengthDelta;
-    repTextAccess(ut, newIndexPos, TRUE);
+    repTextAccess(ut, newIndexPos, true);
 
     return lengthDelta;
 }
@@ -2012,7 +2012,7 @@ repTextCopy(UText *ut,
     }
 
     // Set position, reload chunk if needed.
-    repTextAccess(ut, nativeIterIndex, TRUE);
+    repTextAccess(ut, nativeIterIndex, true);
 }
 
 static const struct UTextFuncs repFuncs =
@@ -2254,7 +2254,7 @@ unistrTextCopy(UText *ut,
 
     // update chunk description, set iteration position.
     ut->chunkContents = us->getBuffer();
-    if (move==FALSE) {
+    if (move==false) {
         // copy operation, string length grows
         ut->chunkLength += limit32-start32;
         ut->chunkNativeLimit = ut->chunkLength;
@@ -2525,7 +2525,7 @@ ucstrTextExtract(UText *ut,
     // Access the start.  Does two things we need:
     //   Pins 'start' to the length of the string, if it came in out-of-bounds.
     //   Snaps 'start' to the beginning of a code point.
-    ucstrTextAccess(ut, start, TRUE);
+    ucstrTextAccess(ut, start, true);
     const UChar *s=ut->chunkContents;
     start32 = ut->chunkOffset;
 
@@ -2579,7 +2579,7 @@ ucstrTextExtract(UText *ut,
     if (si <= ut->chunkNativeLimit) {
         ut->chunkOffset = si;
     } else {
-        ucstrTextAccess(ut, si, TRUE);
+        ucstrTextAccess(ut, si, true);
     }
 
     // Add a terminating NUL if space in the buffer permits,
@@ -2698,11 +2698,11 @@ charIterTextAccess(UText *ut, int64_t index, UBool  forward) {
     neededIndex -= neededIndex % CIBufSize;
 
     UChar *buf = NULL;
-    UBool  needChunkSetup = TRUE;
+    UBool  needChunkSetup = true;
     int    i;
     if (ut->chunkNativeStart == neededIndex) {
         // The buffer we want is already the current chunk.
-        needChunkSetup = FALSE;
+        needChunkSetup = false;
     } else if (ut->b == neededIndex) {
         // The first buffer (buffer p) has what we need.
         buf = (UChar *)ut->p;
@@ -2809,7 +2809,7 @@ charIterTextExtract(UText *ut,
         srci += len;
     }
 
-    charIterTextAccess(ut, copyLimit, TRUE);
+    charIterTextAccess(ut, copyLimit, true);
 
     u_terminateUChars(dest, destCapacity, desti, status);
     return desti;
diff --git a/deps/icu-small/source/common/utf_impl.cpp b/deps/icu-small/source/common/utf_impl.cpp
index 9dd241a12b..a1f9c6529a 100644
--- a/deps/icu-small/source/common/utf_impl.cpp
+++ b/deps/icu-small/source/common/utf_impl.cpp
@@ -55,7 +55,7 @@
  * -finish:
  * (BSR: Bit Scan Reverse, scans for a 1-bit, starting from the MSB)
  */
-extern "C" U_EXPORT const uint8_t
+U_CAPI const uint8_t
 utf8_countTrailBytes[256]={
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
@@ -117,11 +117,11 @@ errorValue(int32_t count, int8_t strict) {
  *         Unicode 16-bit strings that are not well-formed UTF-16, that is, they
  *         contain unpaired surrogates.
  *     -3: All illegal byte sequences yield U+FFFD.
- *  0  Obsolete "safe" behavior of UTF8_NEXT_CHAR_SAFE(..., FALSE):
+ *  0  Obsolete "safe" behavior of UTF8_NEXT_CHAR_SAFE(..., false):
  *     All illegal byte sequences yield a positive code point such that this
  *     result code point would be encoded with the same number of bytes as
  *     the illegal sequence.
- * >0  Obsolete "strict" behavior of UTF8_NEXT_CHAR_SAFE(..., TRUE):
+ * >0  Obsolete "strict" behavior of UTF8_NEXT_CHAR_SAFE(..., true):
  *     Same as the obsolete "safe" behavior, but non-characters are also treated
  *     like illegal sequences.
  *
@@ -214,7 +214,7 @@ utf8_appendCharSafeBody(uint8_t *s, int32_t i, int32_t length, UChar32 c, UBool
     }
     /* c>0x10ffff or not enough space, write an error value */
     if(pIsError!=NULL) {
-        *pIsError=TRUE;
+        *pIsError=true;
     } else {
         length-=i;
         if(length>0) {
diff --git a/deps/icu-small/source/common/util.cpp b/deps/icu-small/source/common/util.cpp
index f342172259..3dcc05578b 100644
--- a/deps/icu-small/source/common/util.cpp
+++ b/deps/icu-small/source/common/util.cpp
@@ -214,14 +214,14 @@ int32_t ICU_Utility::skipWhitespace(const UnicodeString& str, int32_t& pos,
  */
 UBool ICU_Utility::parseChar(const UnicodeString& id, int32_t& pos, UChar ch) {
     int32_t start = pos;
-    skipWhitespace(id, pos, TRUE);
+    skipWhitespace(id, pos, true);
     if (pos == id.length() ||
         id.charAt(pos) != ch) {
         pos = start;
-        return FALSE;
+        return false;
     }
     ++pos;
-    return TRUE;
+    return true;
 }
 
 /**
@@ -302,7 +302,7 @@ int32_t ICU_Utility::parseAsciiInteger(const UnicodeString& str, int32_t& pos) {
 
 /**
  * Append a character to a rule that is being built up.  To flush
- * the quoteBuf to rule, make one final call with isLiteral == TRUE.
+ * the quoteBuf to rule, make one final call with isLiteral == true.
  * If there is no final character, pass in (UChar32)-1 as c.
  * @param rule the string to append the character to
  * @param c the character to append, or (UChar32)-1 if none.
@@ -428,7 +428,7 @@ void ICU_Utility::appendToRule(UnicodeString& rule,
     if (matcher != NULL) {
         UnicodeString pat;
         appendToRule(rule, matcher->toPattern(pat, escapeUnprintable),
-                     TRUE, escapeUnprintable, quoteBuf);
+                     true, escapeUnprintable, quoteBuf);
     }
 }
 
diff --git a/deps/icu-small/source/common/util.h b/deps/icu-small/source/common/util.h
index 7e6d356899..4a9ae831de 100644
--- a/deps/icu-small/source/common/util.h
+++ b/deps/icu-small/source/common/util.h
@@ -258,7 +258,7 @@ class U_COMMON_API ICU_Utility /* not : public UObject because all methods are s
 
 private:
     // do not instantiate
-    ICU_Utility();
+    ICU_Utility() = delete;
 };
 
 U_NAMESPACE_END
diff --git a/deps/icu-small/source/common/utrace.cpp b/deps/icu-small/source/common/utrace.cpp
index dfd2062f31..f7b8ade674 100644
--- a/deps/icu-small/source/common/utrace.cpp
+++ b/deps/icu-small/source/common/utrace.cpp
@@ -436,7 +436,7 @@ utrace_cleanup() {
     pTraceDataFunc  = NULL;
     utrace_level    = UTRACE_OFF;
     gTraceContext   = NULL;
-    return TRUE;
+    return true;
 }
 
 
diff --git a/deps/icu-small/source/common/utrie.cpp b/deps/icu-small/source/common/utrie.cpp
index ecf9b1cba7..96f2397ca1 100644
--- a/deps/icu-small/source/common/utrie.cpp
+++ b/deps/icu-small/source/common/utrie.cpp
@@ -72,14 +72,14 @@ utrie_open(UNewTrie *fillIn,
 
     if(aliasData!=NULL) {
         trie->data=aliasData;
-        trie->isDataAllocated=FALSE;
+        trie->isDataAllocated=false;
     } else {
         trie->data=(uint32_t *)uprv_malloc(maxDataLength*4);
         if(trie->data==NULL) {
             uprv_free(trie);
             return NULL;
         }
-        trie->isDataAllocated=TRUE;
+        trie->isDataAllocated=true;
     }
 
     /* preallocate and reset the first data block (block index 0) */
@@ -108,7 +108,7 @@ utrie_open(UNewTrie *fillIn,
     trie->indexLength=UTRIE_MAX_INDEX_LENGTH;
     trie->dataCapacity=maxDataLength;
     trie->isLatin1Linear=latin1Linear;
-    trie->isCompacted=FALSE;
+    trie->isCompacted=false;
     return trie;
 }
 
@@ -124,14 +124,14 @@ utrie_clone(UNewTrie *fillIn, const UNewTrie *other, uint32_t *aliasData, int32_
 
     /* clone data */
     if(aliasData!=NULL && aliasDataCapacity>=other->dataCapacity) {
-        isDataAllocated=FALSE;
+        isDataAllocated=false;
     } else {
         aliasDataCapacity=other->dataCapacity;
         aliasData=(uint32_t *)uprv_malloc(other->dataCapacity*4);
         if(aliasData==NULL) {
             return NULL;
         }
-        isDataAllocated=TRUE;
+        isDataAllocated=true;
     }
 
     trie=utrie_open(fillIn, aliasData, aliasDataCapacity,
@@ -216,7 +216,7 @@ utrie_getDataBlock(UNewTrie *trie, UChar32 c) {
 }
 
 /**
- * @return TRUE if the value was successfully set
+ * @return true if the value was successfully set
  */
 U_CAPI UBool U_EXPORT2
 utrie_set32(UNewTrie *trie, UChar32 c, uint32_t value) {
@@ -224,16 +224,16 @@ utrie_set32(UNewTrie *trie, UChar32 c, uint32_t value) {
 
     /* valid, uncompacted trie and valid c? */
     if(trie==NULL || trie->isCompacted || (uint32_t)c>0x10ffff) {
-        return FALSE;
+        return false;
     }
 
     block=utrie_getDataBlock(trie, c);
     if(block<0) {
-        return FALSE;
+        return false;
     }
 
     trie->data[block+(c&UTRIE_MASK)]=value;
-    return TRUE;
+    return true;
 }
 
 U_CAPI uint32_t U_EXPORT2
@@ -243,7 +243,7 @@ utrie_get32(UNewTrie *trie, UChar32 c, UBool *pInBlockZero) {
     /* valid, uncompacted trie and valid c? */
     if(trie==NULL || trie->isCompacted || (uint32_t)c>0x10ffff) {
         if(pInBlockZero!=NULL) {
-            *pInBlockZero=TRUE;
+            *pInBlockZero=true;
         }
         return 0;
     }
@@ -294,10 +294,10 @@ utrie_setRange32(UNewTrie *trie, UChar32 start, UChar32 limit, uint32_t value, U
     if( trie==NULL || trie->isCompacted ||
         (uint32_t)start>0x10ffff || (uint32_t)limit>0x110000 || start>limit
     ) {
-        return FALSE;
+        return false;
     }
     if(start==limit) {
-        return TRUE; /* nothing to do */
+        return true; /* nothing to do */
     }
 
     initialValue=trie->data[0];
@@ -307,7 +307,7 @@ utrie_setRange32(UNewTrie *trie, UChar32 start, UChar32 limit, uint32_t value, U
         /* set partial block at [start..following block boundary[ */
         block=utrie_getDataBlock(trie, start);
         if(block<0) {
-            return FALSE;
+            return false;
         }
 
         nextStart=(start+UTRIE_DATA_BLOCK_LENGTH)&~UTRIE_MASK;
@@ -318,7 +318,7 @@ utrie_setRange32(UNewTrie *trie, UChar32 start, UChar32 limit, uint32_t value, U
         } else {
             utrie_fillBlock(trie->data+block, start&UTRIE_MASK, limit&UTRIE_MASK,
                             value, initialValue, overwrite);
-            return TRUE;
+            return true;
         }
     }
 
@@ -348,12 +348,12 @@ utrie_setRange32(UNewTrie *trie, UChar32 start, UChar32 limit, uint32_t value, U
                 /* create and set and fill the repeatBlock */
                 repeatBlock=utrie_getDataBlock(trie, start);
                 if(repeatBlock<0) {
-                    return FALSE;
+                    return false;
                 }
 
                 /* set the negative block number to indicate that it is a repeat block */
                 trie->index[start>>UTRIE_SHIFT]=-repeatBlock;
-                utrie_fillBlock(trie->data+repeatBlock, 0, UTRIE_DATA_BLOCK_LENGTH, value, initialValue, TRUE);
+                utrie_fillBlock(trie->data+repeatBlock, 0, UTRIE_DATA_BLOCK_LENGTH, value, initialValue, true);
             }
         }
 
@@ -364,13 +364,13 @@ utrie_setRange32(UNewTrie *trie, UChar32 start, UChar32 limit, uint32_t value, U
         /* set partial block at [last block boundary..limit[ */
         block=utrie_getDataBlock(trie, start);
         if(block<0) {
-            return FALSE;
+            return false;
         }
 
         utrie_fillBlock(trie->data+block, 0, rest, value, initialValue, overwrite);
     }
 
-    return TRUE;
+    return true;
 }
 
 static int32_t
@@ -437,7 +437,7 @@ utrie_fold(UNewTrie *trie, UNewTrieGetFoldedValue *getFoldedValue, UErrorCode *p
             *pErrorCode=U_MEMORY_ALLOCATION_ERROR;
             return;
         }
-        utrie_fillBlock(trie->data+block, 0, UTRIE_DATA_BLOCK_LENGTH, trie->leadUnitValue, trie->data[0], TRUE);
+        utrie_fillBlock(trie->data+block, 0, UTRIE_DATA_BLOCK_LENGTH, trie->leadUnitValue, trie->data[0], true);
         block=-block; /* negative block number to indicate that it is a repeat block */
     }
     for(c=(0xd800>>UTRIE_SHIFT); c<(0xdc00>>UTRIE_SHIFT); ++c) {
@@ -579,7 +579,7 @@ _findSameDataBlock(const uint32_t *data, int32_t dataLength,
  *
  * The compaction
  * - removes blocks that are identical with earlier ones
- * - overlaps adjacent blocks as much as possible (if overlap==TRUE)
+ * - overlaps adjacent blocks as much as possible (if overlap==true)
  * - moves blocks in steps of the data granularity
  * - moves and overlaps blocks that overlap with multiple values in the overlap region
  *
@@ -766,15 +766,15 @@ utrie_serialize(UNewTrie *trie, void *dt, int32_t capacity,
     /* fold and compact if necessary, also checks that indexLength is within limits */
     if(!trie->isCompacted) {
         /* compact once without overlap to improve folding */
-        utrie_compact(trie, FALSE, pErrorCode);
+        utrie_compact(trie, false, pErrorCode);
 
         /* fold the supplementary part of the index array */
         utrie_fold(trie, getFoldedValue, pErrorCode);
 
         /* compact again with overlap for minimum data array length */
-        utrie_compact(trie, TRUE, pErrorCode);
+        utrie_compact(trie, true, pErrorCode);
 
-        trie->isCompacted=TRUE;
+        trie->isCompacted=true;
         if(U_FAILURE(*pErrorCode)) {
             return 0;
         }
@@ -966,7 +966,7 @@ utrie_unserializeDummy(UTrie *trie,
         return actualLength;
     }
 
-    trie->isLatin1Linear=TRUE;
+    trie->isLatin1Linear=true;
     trie->initialValue=initialValue;
 
     /* fill the index and data arrays */
diff --git a/deps/icu-small/source/common/utrie2.cpp b/deps/icu-small/source/common/utrie2.cpp
index 24ef5782c9..0fb74ba1c3 100644
--- a/deps/icu-small/source/common/utrie2.cpp
+++ b/deps/icu-small/source/common/utrie2.cpp
@@ -66,7 +66,7 @@ utrie2_get32(const UTrie2 *trie, UChar32 c) {
     } else if((uint32_t)c>0x10ffff) {
         return trie->errorValue;
     } else {
-        return get32(trie->newTrie, c, TRUE);
+        return get32(trie->newTrie, c, true);
     }
 }
 
@@ -80,7 +80,7 @@ utrie2_get32FromLeadSurrogateCodeUnit(const UTrie2 *trie, UChar32 c) {
     } else if(trie->data32!=NULL) {
         return UTRIE2_GET32_FROM_U16_SINGLE_LEAD(trie, c);
     } else {
-        return get32(trie->newTrie, c, FALSE);
+        return get32(trie->newTrie, c, false);
     }
 }
 
@@ -200,7 +200,7 @@ utrie2_openFromSerialized(UTrie2ValueBits valueBits,
     uprv_memcpy(trie, &tempTrie, sizeof(tempTrie));
     trie->memory=(uint32_t *)data;
     trie->length=actualLength;
-    trie->isMemoryOwned=FALSE;
+    trie->isMemoryOwned=false;
 #ifdef UTRIE2_DEBUG
     trie->name="fromSerialized";
 #endif
@@ -279,7 +279,7 @@ utrie2_openDummy(UTrie2ValueBits valueBits,
         return 0;
     }
     trie->length=length;
-    trie->isMemoryOwned=TRUE;
+    trie->isMemoryOwned=true;
 
     /* set the UTrie2 fields */
     if(valueBits==UTRIE2_16_VALUE_BITS) {
diff --git a/deps/icu-small/source/common/utrie2.h b/deps/icu-small/source/common/utrie2.h
index d1e1e15a6e..ace52cce37 100644
--- a/deps/icu-small/source/common/utrie2.h
+++ b/deps/icu-small/source/common/utrie2.h
@@ -591,8 +591,8 @@ U_CDECL_END
 
 #ifdef __cplusplus
 
+#include "unicode/uobject.h"
 #include "unicode/utf.h"
-#include "mutex.h"
 
 U_NAMESPACE_BEGIN
 
diff --git a/deps/icu-small/source/common/utrie2_builder.cpp b/deps/icu-small/source/common/utrie2_builder.cpp
index 8de824cc3d..2513332b80 100644
--- a/deps/icu-small/source/common/utrie2_builder.cpp
+++ b/deps/icu-small/source/common/utrie2_builder.cpp
@@ -152,7 +152,7 @@ utrie2_open(uint32_t initialValue, uint32_t errorValue, UErrorCode *pErrorCode)
     newTrie->errorValue=errorValue;
     newTrie->highStart=0x110000;
     newTrie->firstFreeBlock=0;  /* no free block in the list */
-    newTrie->isCompacted=FALSE;
+    newTrie->isCompacted=false;
 
     /*
      * preallocate and reset
@@ -317,7 +317,7 @@ utrie2_clone(const UTrie2 *other, UErrorCode *pErrorCode) {
     if(other->memory!=NULL) {
         trie->memory=uprv_malloc(other->length);
         if(trie->memory!=NULL) {
-            trie->isMemoryOwned=TRUE;
+            trie->isMemoryOwned=true;
             uprv_memcpy(trie->memory, other->memory, other->length);
 
             /* make the clone's pointers point to its own memory */
@@ -357,11 +357,11 @@ copyEnumRange(const void *context, UChar32 start, UChar32 end, uint32_t value) {
         if(start==end) {
             utrie2_set32(nt->trie, start, value, &nt->errorCode);
         } else {
-            utrie2_setRange32(nt->trie, start, end, value, TRUE, &nt->errorCode);
+            utrie2_setRange32(nt->trie, start, end, value, true, &nt->errorCode);
         }
         return U_SUCCESS(nt->errorCode);
     } else {
-        return TRUE;
+        return true;
     }
 }
 
@@ -422,7 +422,7 @@ utrie2_cloneAsThawed(const UTrie2 *other, UErrorCode *pErrorCode) {
     if(U_FAILURE(*pErrorCode)) {
         return NULL;
     }
-    context.exclusiveLimit=FALSE;
+    context.exclusiveLimit=false;
     context.errorCode=*pErrorCode;
     utrie2_enum(other, NULL, copyEnumRange, &context);
     *pErrorCode=context.errorCode;
@@ -461,7 +461,7 @@ utrie2_fromUTrie(const UTrie *trie1, uint32_t errorValue, UErrorCode *pErrorCode
     if(U_FAILURE(*pErrorCode)) {
         return NULL;
     }
-    context.exclusiveLimit=TRUE;
+    context.exclusiveLimit=true;
     context.errorCode=*pErrorCode;
     utrie_enum(trie1, NULL, copyEnumRange, &context);
     *pErrorCode=context.errorCode;
@@ -649,7 +649,7 @@ getDataBlock(UNewTrie2 *trie, UChar32 c, UBool forLSCP) {
 }
 
 /**
- * @return TRUE if the value was successfully set
+ * @return true if the value was successfully set
  */
 static void
 set32(UNewTrie2 *trie,
@@ -683,7 +683,7 @@ utrie2_set32(UTrie2 *trie, UChar32 c, uint32_t value, UErrorCode *pErrorCode) {
         *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
         return;
     }
-    set32(trie->newTrie, c, TRUE, value, pErrorCode);
+    set32(trie->newTrie, c, true, value, pErrorCode);
 }
 
 U_CAPI void U_EXPORT2
@@ -697,7 +697,7 @@ utrie2_set32ForLeadSurrogateCodeUnit(UTrie2 *trie,
         *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
         return;
     }
-    set32(trie->newTrie, c, FALSE, value, pErrorCode);
+    set32(trie->newTrie, c, false, value, pErrorCode);
 }
 
 static void
@@ -709,7 +709,7 @@ writeBlock(uint32_t *block, uint32_t value) {
 }
 
 /**
- * initialValue is ignored if overwrite=TRUE
+ * initialValue is ignored if overwrite=true
  * @internal
  */
 static void
@@ -771,7 +771,7 @@ utrie2_setRange32(UTrie2 *trie,
         UChar32 nextStart;
 
         /* set partial block at [start..following block boundary[ */
-        block=getDataBlock(newTrie, start, TRUE);
+        block=getDataBlock(newTrie, start, true);
         if(block<0) {
             *pErrorCode=U_MEMORY_ALLOCATION_ERROR;
             return;
@@ -804,15 +804,15 @@ utrie2_setRange32(UTrie2 *trie,
 
     while(start<limit) {
         int32_t i2;
-        UBool setRepeatBlock=FALSE;
+        UBool setRepeatBlock=false;
 
-        if(value==newTrie->initialValue && isInNullBlock(newTrie, start, TRUE)) {
+        if(value==newTrie->initialValue && isInNullBlock(newTrie, start, true)) {
             start+=UTRIE2_DATA_BLOCK_LENGTH; /* nothing to do */
             continue;
         }
 
         /* get index value */
-        i2=getIndex2Block(newTrie, start, TRUE);
+        i2=getIndex2Block(newTrie, start, true);
         if(i2<0) {
             *pErrorCode=U_INTERNAL_PROGRAM_ERROR;
             return;
@@ -827,7 +827,7 @@ utrie2_setRange32(UTrie2 *trie,
                  * protected (ASCII-linear or 2-byte UTF-8) block:
                  * replace with the repeatBlock.
                  */
-                setRepeatBlock=TRUE;
+                setRepeatBlock=true;
             } else {
                 /* !overwrite, or protected block: just write the values into this block */
                 fillBlock(newTrie->data+block,
@@ -851,14 +851,14 @@ utrie2_setRange32(UTrie2 *trie,
              * and if we overwrite any data or if the data is all initial values
              * (which is the same as the block being the null block, see above).
              */
-            setRepeatBlock=TRUE;
+            setRepeatBlock=true;
         }
         if(setRepeatBlock) {
             if(repeatBlock>=0) {
                 setIndex2Entry(newTrie, i2, repeatBlock);
             } else {
                 /* create and set and fill the repeatBlock */
-                repeatBlock=getDataBlock(newTrie, start, TRUE);
+                repeatBlock=getDataBlock(newTrie, start, true);
                 if(repeatBlock<0) {
                     *pErrorCode=U_MEMORY_ALLOCATION_ERROR;
                     return;
@@ -872,7 +872,7 @@ utrie2_setRange32(UTrie2 *trie,
 
     if(rest>0) {
         /* set partial block at [last block boundary..limit[ */
-        block=getDataBlock(newTrie, start, TRUE);
+        block=getDataBlock(newTrie, start, true);
         if(block<0) {
             *pErrorCode=U_MEMORY_ALLOCATION_ERROR;
             return;
@@ -1019,7 +1019,7 @@ findHighStart(UNewTrie2 *trie, uint32_t highValue) {
  *
  * The compaction
  * - removes blocks that are identical with earlier ones
- * - overlaps adjacent blocks as much as possible (if overlap==TRUE)
+ * - overlaps adjacent blocks as much as possible (if overlap==true)
  * - moves blocks in steps of the data granularity
  * - moves and overlaps blocks that overlap with multiple values in the overlap region
  *
@@ -1255,7 +1255,7 @@ compactTrie(UTrie2 *trie, UErrorCode *pErrorCode) {
     if(highStart<0x110000) {
         /* Blank out [highStart..10ffff] to release associated data blocks. */
         suppHighStart= highStart<=0x10000 ? 0x10000 : highStart;
-        utrie2_setRange32(trie, suppHighStart, 0x10ffff, trie->initialValue, TRUE, pErrorCode);
+        utrie2_setRange32(trie, suppHighStart, 0x10ffff, trie->initialValue, true, pErrorCode);
         if(U_FAILURE(*pErrorCode)) {
             return;
         }
@@ -1281,7 +1281,7 @@ compactTrie(UTrie2 *trie, UErrorCode *pErrorCode) {
         newTrie->data[newTrie->dataLength++]=trie->initialValue;
     }
 
-    newTrie->isCompacted=TRUE;
+    newTrie->isCompacted=true;
 }
 
 /* serialization ------------------------------------------------------------ */
@@ -1382,7 +1382,7 @@ utrie2_freeze(UTrie2 *trie, UTrie2ValueBits valueBits, UErrorCode *pErrorCode) {
         return;
     }
     trie->length=length;
-    trie->isMemoryOwned=TRUE;
+    trie->isMemoryOwned=true;
 
     trie->indexLength=allIndexesLength;
     trie->dataLength=newTrie->dataLength;
diff --git a/deps/icu-small/source/common/utrie_swap.cpp b/deps/icu-small/source/common/utrie_swap.cpp
index 6e8b138394..b01b94601e 100644
--- a/deps/icu-small/source/common/utrie_swap.cpp
+++ b/deps/icu-small/source/common/utrie_swap.cpp
@@ -294,8 +294,8 @@ namespace {
  * @param data a pointer to 32-bit-aligned memory containing the serialized form of a trie
  * @param length the number of bytes available at data;
  *               can be more than necessary (see return value)
- * @param anyEndianOk If FALSE, only platform-endian serialized forms are recognized.
- *                    If TRUE, opposite-endian serialized forms are recognized as well.
+ * @param anyEndianOk If false, only platform-endian serialized forms are recognized.
+ *                    If true, opposite-endian serialized forms are recognized as well.
  * @return the trie version of the serialized form, or 0 if it is not
  *         recognized as a serialized trie
  */
@@ -334,7 +334,7 @@ utrie_swapAnyVersion(const UDataSwapper *ds,
                      const void *inData, int32_t length, void *outData,
                      UErrorCode *pErrorCode) {
     if(U_FAILURE(*pErrorCode)) { return 0; }
-    switch(getVersion(inData, length, TRUE)) {
+    switch(getVersion(inData, length, true)) {
     case 1:
         return utrie_swap(ds, inData, length, outData, pErrorCode);
     case 2:
diff --git a/deps/icu-small/source/common/uts46.cpp b/deps/icu-small/source/common/uts46.cpp
index 6f93070339..10a4f56597 100644
--- a/deps/icu-small/source/common/uts46.cpp
+++ b/deps/icu-small/source/common/uts46.cpp
@@ -53,10 +53,10 @@ isASCIIString(const UnicodeString &dest) {
     const UChar *limit=s+dest.length();
     while(s<limit) {
         if(*s++>0x7f) {
-            return FALSE;
+            return false;
         }
     }
-    return TRUE;
+    return true;
 }
 
 static UBool
@@ -224,19 +224,19 @@ UTS46::~UTS46() {}
 UnicodeString &
 UTS46::labelToASCII(const UnicodeString &label, UnicodeString &dest,
                     IDNAInfo &info, UErrorCode &errorCode) const {
-    return process(label, TRUE, TRUE, dest, info, errorCode);
+    return process(label, true, true, dest, info, errorCode);
 }
 
 UnicodeString &
 UTS46::labelToUnicode(const UnicodeString &label, UnicodeString &dest,
                       IDNAInfo &info, UErrorCode &errorCode) const {
-    return process(label, TRUE, FALSE, dest, info, errorCode);
+    return process(label, true, false, dest, info, errorCode);
 }
 
 UnicodeString &
 UTS46::nameToASCII(const UnicodeString &name, UnicodeString &dest,
                    IDNAInfo &info, UErrorCode &errorCode) const {
-    process(name, FALSE, TRUE, dest, info, errorCode);
+    process(name, false, true, dest, info, errorCode);
     if( dest.length()>=254 && (info.errors&UIDNA_ERROR_DOMAIN_NAME_TOO_LONG)==0 &&
         isASCIIString(dest) &&
         (dest.length()>254 || dest[253]!=0x2e)
@@ -249,31 +249,31 @@ UTS46::nameToASCII(const UnicodeString &name, UnicodeString &dest,
 UnicodeString &
 UTS46::nameToUnicode(const UnicodeString &name, UnicodeString &dest,
                      IDNAInfo &info, UErrorCode &errorCode) const {
-    return process(name, FALSE, FALSE, dest, info, errorCode);
+    return process(name, false, false, dest, info, errorCode);
 }
 
 void
 UTS46::labelToASCII_UTF8(StringPiece label, ByteSink &dest,
                          IDNAInfo &info, UErrorCode &errorCode) const {
-    processUTF8(label, TRUE, TRUE, dest, info, errorCode);
+    processUTF8(label, true, true, dest, info, errorCode);
 }
 
 void
 UTS46::labelToUnicodeUTF8(StringPiece label, ByteSink &dest,
                           IDNAInfo &info, UErrorCode &errorCode) const {
-    processUTF8(label, TRUE, FALSE, dest, info, errorCode);
+    processUTF8(label, true, false, dest, info, errorCode);
 }
 
 void
 UTS46::nameToASCII_UTF8(StringPiece name, ByteSink &dest,
                         IDNAInfo &info, UErrorCode &errorCode) const {
-    processUTF8(name, FALSE, TRUE, dest, info, errorCode);
+    processUTF8(name, false, true, dest, info, errorCode);
 }
 
 void
 UTS46::nameToUnicodeUTF8(StringPiece name, ByteSink &dest,
                          IDNAInfo &info, UErrorCode &errorCode) const {
-    processUTF8(name, FALSE, FALSE, dest, info, errorCode);
+    processUTF8(name, false, false, dest, info, errorCode);
 }
 
 // UTS #46 data for ASCII characters.
@@ -561,7 +561,7 @@ UTS46::processUnicode(const UnicodeString &src,
         } else if(c<0xdf) {
             // pass
         } else if(c<=0x200d && (c==0xdf || c==0x3c2 || c>=0x200c)) {
-            info.isTransDiff=TRUE;
+            info.isTransDiff=true;
             if(doMapDevChars) {
                 destLength=mapDevChars(dest, labelStart, labelLimit, errorCode);
                 if(U_FAILURE(errorCode)) {
@@ -569,7 +569,7 @@ UTS46::processUnicode(const UnicodeString &src,
                 }
                 destArray=dest.getBuffer();
                 // All deviation characters have been mapped, no need to check for them again.
-                doMapDevChars=FALSE;
+                doMapDevChars=false;
                 // Do not increment labelLimit in case c was removed.
                 continue;
             }
@@ -610,14 +610,14 @@ UTS46::mapDevChars(UnicodeString &dest, int32_t labelStart, int32_t mappingStart
         return length;
     }
     int32_t capacity=dest.getCapacity();
-    UBool didMapDevChars=FALSE;
+    UBool didMapDevChars=false;
     int32_t readIndex=mappingStart, writeIndex=mappingStart;
     do {
         UChar c=s[readIndex++];
         switch(c) {
         case 0xdf:
             // Map sharp s to ss.
-            didMapDevChars=TRUE;
+            didMapDevChars=true;
             s[writeIndex++]=0x73;  // Replace sharp s with first s.
             // Insert second s and account for possible buffer reallocation.
             if(writeIndex==readIndex) {
@@ -637,12 +637,12 @@ UTS46::mapDevChars(UnicodeString &dest, int32_t labelStart, int32_t mappingStart
             ++length;
             break;
         case 0x3c2:  // Map final sigma to nonfinal sigma.
-            didMapDevChars=TRUE;
+            didMapDevChars=true;
             s[writeIndex++]=0x3c3;
             break;
         case 0x200c:  // Ignore/remove ZWNJ.
         case 0x200d:  // Ignore/remove ZWJ.
-            didMapDevChars=TRUE;
+            didMapDevChars=true;
             --length;
             break;
         default:
@@ -724,7 +724,7 @@ UTS46::processLabel(UnicodeString &dest,
             info.labelErrors|=UIDNA_ERROR_INVALID_ACE_LABEL;
             return markBadACELabel(dest, labelStart, labelLength, toASCII, info, errorCode);
         }
-        wasPunycode=TRUE;
+        wasPunycode=true;
         UChar *unicodeBuffer=fromPunycode.getBuffer(-1);  // capacity==-1: most labels should fit
         if(unicodeBuffer==NULL) {
             // Should never occur if we used capacity==-1 which uses the internal buffer.
@@ -772,7 +772,7 @@ UTS46::processLabel(UnicodeString &dest,
         labelStart=0;
         labelLength=fromPunycode.length();
     } else {
-        wasPunycode=FALSE;
+        wasPunycode=false;
         labelString=&dest;
     }
     // Validity check
@@ -932,8 +932,8 @@ UTS46::markBadACELabel(UnicodeString &dest,
         return 0;
     }
     UBool disallowNonLDHDot=(options&UIDNA_USE_STD3_RULES)!=0;
-    UBool isASCII=TRUE;
-    UBool onlyLDH=TRUE;
+    UBool isASCII=true;
+    UBool onlyLDH=true;
     const UChar *label=dest.getBuffer()+labelStart;
     const UChar *limit=label+labelLength;
     // Start after the initial "xn--".
@@ -944,16 +944,16 @@ UTS46::markBadACELabel(UnicodeString &dest,
             if(c==0x2e) {
                 info.labelErrors|=UIDNA_ERROR_LABEL_HAS_DOT;
                 *s=0xfffd;
-                isASCII=onlyLDH=FALSE;
+                isASCII=onlyLDH=false;
             } else if(asciiData[c]<0) {
-                onlyLDH=FALSE;
+                onlyLDH=false;
                 if(disallowNonLDHDot) {
                     *s=0xfffd;
-                    isASCII=FALSE;
+                    isASCII=false;
                 }
             }
         } else {
-            isASCII=onlyLDH=FALSE;
+            isASCII=onlyLDH=false;
         }
     }
     if(onlyLDH) {
@@ -1008,7 +1008,7 @@ UTS46::checkLabelBiDi(const UChar *label, int32_t labelLength, IDNAInfo &info) c
     // or AL.  If it has the R or AL property, it is an RTL label; if it
     // has the L property, it is an LTR label.
     if((firstMask&~L_R_AL_MASK)!=0) {
-        info.isOkBiDi=FALSE;
+        info.isOkBiDi=false;
     }
     // Get the directionality of the last non-NSM character.
     uint32_t lastMask;
@@ -1034,7 +1034,7 @@ UTS46::checkLabelBiDi(const UChar *label, int32_t labelLength, IDNAInfo &info) c
             (lastMask&~L_EN_MASK)!=0 :
             (lastMask&~R_AL_EN_AN_MASK)!=0
     ) {
-        info.isOkBiDi=FALSE;
+        info.isOkBiDi=false;
     }
     // Add the directionalities of the intervening characters.
     uint32_t mask=firstMask|lastMask;
@@ -1046,18 +1046,18 @@ UTS46::checkLabelBiDi(const UChar *label, int32_t labelLength, IDNAInfo &info) c
         // 5. In an LTR label, only characters with the BIDI properties L, EN,
         // ES, CS, ET, ON, BN and NSM are allowed.
         if((mask&~L_EN_ES_CS_ET_ON_BN_NSM_MASK)!=0) {
-            info.isOkBiDi=FALSE;
+            info.isOkBiDi=false;
         }
     } else {
         // 2. In an RTL label, only characters with the BIDI properties R, AL,
         // AN, EN, ES, CS, ET, ON, BN and NSM are allowed.
         if((mask&~R_AL_AN_EN_ES_CS_ET_ON_BN_NSM_MASK)!=0) {
-            info.isOkBiDi=FALSE;
+            info.isOkBiDi=false;
         }
         // 4. In an RTL label, if an EN is present, no AN may be present, and
         // vice versa.
         if((mask&EN_AN_MASK)==EN_AN_MASK) {
-            info.isOkBiDi=FALSE;
+            info.isOkBiDi=false;
         }
     }
     // An RTL label is a label that contains at least one character of type
@@ -1067,7 +1067,7 @@ UTS46::checkLabelBiDi(const UChar *label, int32_t labelLength, IDNAInfo &info) c
     // The following rule, consisting of six conditions, applies to labels
     // in BIDI domain names.
     if((mask&R_AL_AN_MASK)!=0) {
-        info.isBiDi=TRUE;
+        info.isBiDi=true;
     }
 }
 
@@ -1094,23 +1094,23 @@ isASCIIOkBiDi(const UChar *s, int32_t length) {
                 c=s[i-1];
                 if(!(0x61<=c && c<=0x7a) && !(0x30<=c && c<=0x39)) {
                     // Last character in the label is not an L or EN.
-                    return FALSE;
+                    return false;
                 }
             }
             labelStart=i+1;
         } else if(i==labelStart) {
             if(!(0x61<=c && c<=0x7a)) {
                 // First character in the label is not an L.
-                return FALSE;
+                return false;
             }
         } else {
             if(c<=0x20 && (c>=0x1c || (9<=c && c<=0xd))) {
                 // Intermediate character in the label is a B, S or WS.
-                return FALSE;
+                return false;
             }
         }
     }
-    return TRUE;
+    return true;
 }
 
 // UTF-8 version, called for source ASCII prefix.
@@ -1126,23 +1126,23 @@ isASCIIOkBiDi(const char *s, int32_t length) {
                 c=s[i-1];
                 if(!(0x61<=c && c<=0x7a) && !(0x41<=c && c<=0x5a) && !(0x30<=c && c<=0x39)) {
                     // Last character in the label is not an L or EN.
-                    return FALSE;
+                    return false;
                 }
             }
             labelStart=i+1;
         } else if(i==labelStart) {
             if(!(0x61<=c && c<=0x7a) && !(0x41<=c && c<=0x5a)) {
                 // First character in the label is not an L.
-                return FALSE;
+                return false;
             }
         } else {
             if(c<=0x20 && (c>=0x1c || (9<=c && c<=0xd))) {
                 // Intermediate character in the label is a B, S or WS.
-                return FALSE;
+                return false;
             }
         }
     }
-    return TRUE;
+    return true;
 }
 
 UBool
@@ -1158,7 +1158,7 @@ UTS46::isLabelOkContextJ(const UChar *label, int32_t labelLength) const {
             //  If RegExpMatch((Joining_Type:{L,D})(Joining_Type:T)*\u200C
             //     (Joining_Type:T)*(Joining_Type:{R,D})) Then True;
             if(i==0) {
-                return FALSE;
+                return false;
             }
             UChar32 c;
             int32_t j=i;
@@ -1171,19 +1171,19 @@ UTS46::isLabelOkContextJ(const UChar *label, int32_t labelLength) const {
                 UJoiningType type=ubidi_getJoiningType(c);
                 if(type==U_JT_TRANSPARENT) {
                     if(j==0) {
-                        return FALSE;
+                        return false;
                     }
                     U16_PREV_UNSAFE(label, j, c);
                 } else if(type==U_JT_LEFT_JOINING || type==U_JT_DUAL_JOINING) {
                     break;  // precontext fulfilled
                 } else {
-                    return FALSE;
+                    return false;
                 }
             }
             // check postcontext (Joining_Type:T)*(Joining_Type:{R,D})
             for(j=i+1;;) {
                 if(j==labelLength) {
-                    return FALSE;
+                    return false;
                 }
                 U16_NEXT_UNSAFE(label, j, c);
                 UJoiningType type=ubidi_getJoiningType(c);
@@ -1192,7 +1192,7 @@ UTS46::isLabelOkContextJ(const UChar *label, int32_t labelLength) const {
                 } else if(type==U_JT_RIGHT_JOINING || type==U_JT_DUAL_JOINING) {
                     break;  // postcontext fulfilled
                 } else {
-                    return FALSE;
+                    return false;
                 }
             }
         } else if(label[i]==0x200d) {
@@ -1201,17 +1201,17 @@ UTS46::isLabelOkContextJ(const UChar *label, int32_t labelLength) const {
             //  False;
             //  If Canonical_Combining_Class(Before(cp)) .eq.  Virama Then True;
             if(i==0) {
-                return FALSE;
+                return false;
             }
             UChar32 c;
             int32_t j=i;
             U16_PREV_UNSAFE(label, j, c);
             if(uts46Norm2.getCombiningClass(c)!=9) {
-                return FALSE;
+                return false;
             }
         }
     }
-    return TRUE;
+    return true;
 }
 
 void
@@ -1338,23 +1338,23 @@ checkArgs(const void *label, int32_t length,
           void *dest, int32_t capacity,
           UIDNAInfo *pInfo, UErrorCode *pErrorCode) {
     if(U_FAILURE(*pErrorCode)) {
-        return FALSE;
+        return false;
     }
     // sizeof(UIDNAInfo)=16 in the first API version.
     if(pInfo==NULL || pInfo->size<16) {
         *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
-        return FALSE;
+        return false;
     }
     if( (label==NULL ? length!=0 : length<-1) ||
         (dest==NULL ? capacity!=0 : capacity<0) ||
         (dest==label && label!=NULL)
     ) {
         *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
-        return FALSE;
+        return false;
     }
     // Set all *pInfo bytes to 0 except for the size field itself.
     uprv_memset(&pInfo->size+1, 0, pInfo->size-sizeof(pInfo->size));
-    return TRUE;
+    return true;
 }
 
 static void
diff --git a/deps/icu-small/source/common/uvector.cpp b/deps/icu-small/source/common/uvector.cpp
index 844463921e..729314ae95 100644
--- a/deps/icu-small/source/common/uvector.cpp
+++ b/deps/icu-small/source/common/uvector.cpp
@@ -193,40 +193,40 @@ int32_t UVector::elementAti(int32_t index) const {
 UBool UVector::containsAll(const UVector& other) const {
     for (int32_t i=0; i<other.size(); ++i) {
         if (indexOf(other.elements[i]) < 0) {
-            return FALSE;
+            return false;
         }
     }
-    return TRUE;
+    return true;
 }
 
 UBool UVector::containsNone(const UVector& other) const {
     for (int32_t i=0; i<other.size(); ++i) {
         if (indexOf(other.elements[i]) >= 0) {
-            return FALSE;
+            return false;
         }
     }
-    return TRUE;
+    return true;
 }
 
 UBool UVector::removeAll(const UVector& other) {
-    UBool changed = FALSE;
+    UBool changed = false;
     for (int32_t i=0; i<other.size(); ++i) {
         int32_t j = indexOf(other.elements[i]);
         if (j >= 0) {
             removeElementAt(j);
-            changed = TRUE;
+            changed = true;
         }
     }
     return changed;
 }
 
 UBool UVector::retainAll(const UVector& other) {
-    UBool changed = FALSE;
+    UBool changed = false;
     for (int32_t j=size()-1; j>=0; --j) {
         int32_t i = other.indexOf(elements[j]);
         if (i < 0) {
             removeElementAt(j);
-            changed = TRUE;
+            changed = true;
         }
     }
     return changed;
@@ -243,9 +243,9 @@ UBool UVector::removeElement(void* obj) {
     int32_t i = indexOf(obj);
     if (i >= 0) {
         removeElementAt(i);
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 void UVector::removeAllElements(void) {
@@ -263,12 +263,12 @@ UBool   UVector::equals(const UVector &other) const {
     int      i;
 
     if (this->count != other.count) {
-        return FALSE;
+        return false;
     }
     if (comparer == nullptr) {
         for (i=0; i<count; i++) {
             if (elements[i].pointer != other.elements[i].pointer) {
-                return FALSE;
+                return false;
             }
         }
     } else {
@@ -276,11 +276,11 @@ UBool   UVector::equals(const UVector &other) const {
         for (i=0; i<count; i++) {
             key.pointer = &other.elements[i];
             if (!(*comparer)(key, elements[i])) {
-                return FALSE;
+                return false;
             }
         }
     }
-    return TRUE;
+    return true;
 }
 
 
@@ -525,7 +525,7 @@ sortiComparator(const void * /*context */, const void *left, const void *right)
 void UVector::sorti(UErrorCode &ec) {
     if (U_SUCCESS(ec)) {
         uprv_sortArray(elements, count, sizeof(UElement),
-                       sortiComparator, nullptr,  FALSE, &ec);
+                       sortiComparator, nullptr,  false, &ec);
     }
 }
 
@@ -547,7 +547,7 @@ void UVector::sorti(UErrorCode &ec) {
 void UVector::sort(UElementComparator *compare, UErrorCode &ec) {
     if (U_SUCCESS(ec)) {
         uprv_sortArray(elements, count, sizeof(UElement),
-                       sortComparator, &compare, FALSE, &ec);
+                       sortComparator, &compare, false, &ec);
     }
 }
 
@@ -558,7 +558,7 @@ void UVector::sort(UElementComparator *compare, UErrorCode &ec) {
 void UVector::sortWithUComparator(UComparator *compare, const void *context, UErrorCode &ec) {
     if (U_SUCCESS(ec)) {
         uprv_sortArray(elements, count, sizeof(UElement),
-                       compare, context, TRUE, &ec);
+                       compare, context, true, &ec);
     }
 }
 
diff --git a/deps/icu-small/source/common/uvectr32.cpp b/deps/icu-small/source/common/uvectr32.cpp
index 2b4d0b8a75..952f51792b 100644
--- a/deps/icu-small/source/common/uvectr32.cpp
+++ b/deps/icu-small/source/common/uvectr32.cpp
@@ -117,40 +117,40 @@ void UVector32::insertElementAt(int32_t elem, int32_t index, UErrorCode &status)
 UBool UVector32::containsAll(const UVector32& other) const {
     for (int32_t i=0; i<other.size(); ++i) {
         if (indexOf(other.elements[i]) < 0) {
-            return FALSE;
+            return false;
         }
     }
-    return TRUE;
+    return true;
 }
 
 UBool UVector32::containsNone(const UVector32& other) const {
     for (int32_t i=0; i<other.size(); ++i) {
         if (indexOf(other.elements[i]) >= 0) {
-            return FALSE;
+            return false;
         }
     }
-    return TRUE;
+    return true;
 }
 
 UBool UVector32::removeAll(const UVector32& other) {
-    UBool changed = FALSE;
+    UBool changed = false;
     for (int32_t i=0; i<other.size(); ++i) {
         int32_t j = indexOf(other.elements[i]);
         if (j >= 0) {
             removeElementAt(j);
-            changed = TRUE;
+            changed = true;
         }
     }
     return changed;
 }
 
 UBool UVector32::retainAll(const UVector32& other) {
-    UBool changed = FALSE;
+    UBool changed = false;
     for (int32_t j=size()-1; j>=0; --j) {
         int32_t i = other.indexOf(elements[j]);
         if (i < 0) {
             removeElementAt(j);
-            changed = TRUE;
+            changed = true;
         }
     }
     return changed;
@@ -173,14 +173,14 @@ UBool   UVector32::equals(const UVector32 &other) const {
     int      i;
 
     if (this->count != other.count) {
-        return FALSE;
+        return false;
     }
     for (i=0; i<count; i++) {
         if (elements[i] != other.elements[i]) {
-            return FALSE;
+            return false;
         }
     }
-    return TRUE;
+    return true;
 }
 
 
@@ -199,22 +199,22 @@ int32_t UVector32::indexOf(int32_t key, int32_t startIndex) const {
 
 UBool UVector32::expandCapacity(int32_t minimumCapacity, UErrorCode &status) {
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
     if (minimumCapacity < 0) {
         status = U_ILLEGAL_ARGUMENT_ERROR;
-        return FALSE;
+        return false;
     }
     if (capacity >= minimumCapacity) {
-        return TRUE;
+        return true;
     }
     if (maxCapacity>0 && minimumCapacity>maxCapacity) {
         status = U_BUFFER_OVERFLOW_ERROR;
-        return FALSE;
+        return false;
     }
     if (capacity > (INT32_MAX - 1) / 2) {  // integer overflow check
         status = U_ILLEGAL_ARGUMENT_ERROR;
-        return FALSE;
+        return false;
     }
     int32_t newCap = capacity * 2;
     if (newCap < minimumCapacity) {
@@ -226,17 +226,17 @@ UBool UVector32::expandCapacity(int32_t minimumCapacity, UErrorCode &status) {
     if (newCap > (int32_t)(INT32_MAX / sizeof(int32_t))) {  // integer overflow check
         // We keep the original memory contents on bad minimumCapacity/maxCapacity.
         status = U_ILLEGAL_ARGUMENT_ERROR;
-        return FALSE;
+        return false;
     }
     int32_t* newElems = (int32_t *)uprv_realloc(elements, sizeof(int32_t)*newCap);
     if (newElems == NULL) {
         // We keep the original contents on the memory failure on realloc.
         status = U_MEMORY_ALLOCATION_ERROR;
-        return FALSE;
+        return false;
     }
     elements = newElems;
     capacity = newCap;
-    return TRUE;
+    return true;
 }
 
 void UVector32::setMaxCapacity(int32_t limit) {
diff --git a/deps/icu-small/source/common/uvectr32.h b/deps/icu-small/source/common/uvectr32.h
index ecefb7af3e..a7fada3833 100644
--- a/deps/icu-small/source/common/uvectr32.h
+++ b/deps/icu-small/source/common/uvectr32.h
@@ -187,10 +187,10 @@ private:
     void _init(int32_t initialCapacity, UErrorCode &status);
 
     // Disallow
-    UVector32(const UVector32&);
+    UVector32(const UVector32&) = delete;
 
     // Disallow
-    UVector32& operator=(const UVector32&);
+    UVector32& operator=(const UVector32&) = delete;
 
 
     //  API Functions for Stack operations.
diff --git a/deps/icu-small/source/common/uvectr64.cpp b/deps/icu-small/source/common/uvectr64.cpp
index 57315c00ff..8bd5cd7839 100644
--- a/deps/icu-small/source/common/uvectr64.cpp
+++ b/deps/icu-small/source/common/uvectr64.cpp
@@ -117,22 +117,22 @@ void UVector64::removeAllElements(void) {
 
 UBool UVector64::expandCapacity(int32_t minimumCapacity, UErrorCode &status) {
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
     if (minimumCapacity < 0) {
         status = U_ILLEGAL_ARGUMENT_ERROR;
-        return FALSE;
+        return false;
     }
     if (capacity >= minimumCapacity) {
-        return TRUE;
+        return true;
     }
     if (maxCapacity>0 && minimumCapacity>maxCapacity) {
         status = U_BUFFER_OVERFLOW_ERROR;
-        return FALSE;
+        return false;
     }
     if (capacity > (INT32_MAX - 1) / 2) {  // integer overflow check
         status = U_ILLEGAL_ARGUMENT_ERROR;
-        return FALSE;
+        return false;
     }
     int32_t newCap = capacity * 2;
     if (newCap < minimumCapacity) {
@@ -144,17 +144,17 @@ UBool UVector64::expandCapacity(int32_t minimumCapacity, UErrorCode &status) {
     if (newCap > (int32_t)(INT32_MAX / sizeof(int64_t))) {  // integer overflow check
         // We keep the original memory contents on bad minimumCapacity/maxCapacity.
         status = U_ILLEGAL_ARGUMENT_ERROR;
-        return FALSE;
+        return false;
     }
     int64_t* newElems = (int64_t *)uprv_realloc(elements, sizeof(int64_t)*newCap);
     if (newElems == NULL) {
         // We keep the original contents on the memory failure on realloc.
         status = U_MEMORY_ALLOCATION_ERROR;
-        return FALSE;
+        return false;
     }
     elements = newElems;
     capacity = newCap;
-    return TRUE;
+    return true;
 }
 
 void UVector64::setMaxCapacity(int32_t limit) {
diff --git a/deps/icu-small/source/common/uvectr64.h b/deps/icu-small/source/common/uvectr64.h
index ba3eca268d..070e2dd67d 100644
--- a/deps/icu-small/source/common/uvectr64.h
+++ b/deps/icu-small/source/common/uvectr64.h
@@ -176,10 +176,10 @@ private:
     void _init(int32_t initialCapacity, UErrorCode &status);
 
     // Disallow
-    UVector64(const UVector64&);
+    UVector64(const UVector64&) = delete;
 
     // Disallow
-    UVector64& operator=(const UVector64&);
+    UVector64& operator=(const UVector64&) = delete;
 
 
     //  API Functions for Stack operations.
diff --git a/deps/icu-small/source/common/wintz.cpp b/deps/icu-small/source/common/wintz.cpp
index 84a29b8d36..1bc08ae654 100644
--- a/deps/icu-small/source/common/wintz.cpp
+++ b/deps/icu-small/source/common/wintz.cpp
@@ -274,7 +274,7 @@ uprv_detectWindowsTimeZone()
 
     CharString winTZ;
     UErrorCode status = U_ZERO_ERROR;
-    winTZ.appendInvariantChars(UnicodeString(TRUE, windowsTimeZoneName, -1), status);
+    winTZ.appendInvariantChars(UnicodeString(true, windowsTimeZoneName, -1), status);
 
     // Map Windows Timezone name (non-localized) to ICU timezone ID (~ Olson timezone id).
     StackUResourceBundle winTZBundle;
diff --git a/deps/icu-small/source/data/in/icudt71l.dat.bz2 b/deps/icu-small/source/data/in/icudt72l.dat.bz2
similarity index 56%
rename from deps/icu-small/source/data/in/icudt71l.dat.bz2
rename to deps/icu-small/source/data/in/icudt72l.dat.bz2
index 80cea637d2..9f6ed16011 100644
Binary files a/deps/icu-small/source/data/in/icudt71l.dat.bz2 and b/deps/icu-small/source/data/in/icudt72l.dat.bz2 differ
diff --git a/deps/icu-small/source/i18n/alphaindex.cpp b/deps/icu-small/source/i18n/alphaindex.cpp
index 88d63675a7..16b9d99395 100644
--- a/deps/icu-small/source/i18n/alphaindex.cpp
+++ b/deps/icu-small/source/i18n/alphaindex.cpp
@@ -312,7 +312,7 @@ void AlphabeticIndex::initLabels(UVector &indexCharacters, UErrorCode &errorCode
         UBool checkDistinct;
         int32_t itemLength = item->length();
         if (!item->hasMoreChar32Than(0, itemLength, 1)) {
-            checkDistinct = FALSE;
+            checkDistinct = false;
         } else if(item->charAt(itemLength - 1) == 0x2a &&  // '*'
                 item->charAt(itemLength - 2) != 0x2a) {
             // Use a label if it is marked with one trailing star,
@@ -323,9 +323,9 @@ void AlphabeticIndex::initLabels(UVector &indexCharacters, UErrorCode &errorCode
                 errorCode = U_MEMORY_ALLOCATION_ERROR;
                 return;
             }
-            checkDistinct = FALSE;
+            checkDistinct = false;
         } else {
-            checkDistinct = TRUE;
+            checkDistinct = true;
         }
         if (collatorPrimaryOnly_->compare(*item, firstScriptBoundary, errorCode) < 0) {
             // Ignore a primary-ignorable or non-alphabetic index character.
@@ -398,20 +398,20 @@ UBool hasMultiplePrimaryWeights(
         const UnicodeString &s, UVector64 &ces, UErrorCode &errorCode) {
     ces.removeAllElements();
     coll.internalGetCEs(s, ces, errorCode);
-    if (U_FAILURE(errorCode)) { return FALSE; }
-    UBool seenPrimary = FALSE;
+    if (U_FAILURE(errorCode)) { return false; }
+    UBool seenPrimary = false;
     for (int32_t i = 0; i < ces.size(); ++i) {
         int64_t ce = ces.elementAti(i);
         uint32_t p = (uint32_t)(ce >> 32);
         if (p > variableTop) {
             // not primary ignorable
             if (seenPrimary) {
-                return TRUE;
+                return true;
             }
-            seenPrimary = TRUE;
+            seenPrimary = true;
         }
     }
-    return FALSE;
+    return false;
 }
 
 }  // namespace
@@ -431,7 +431,7 @@ BucketList *AlphabeticIndex::createBucketList(UErrorCode &errorCode) const {
     } else {
         variableTop = 0;
     }
-    UBool hasInvisibleBuckets = FALSE;
+    UBool hasInvisibleBuckets = false;
 
     // Helper arrays for Chinese Pinyin collation.
     Bucket *asciiBuckets[26] = {
@@ -442,7 +442,7 @@ BucketList *AlphabeticIndex::createBucketList(UErrorCode &errorCode) const {
         NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
         NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
     };
-    UBool hasPinyin = FALSE;
+    UBool hasPinyin = false;
 
     LocalPointer<UVector> bucketList(new UVector(errorCode), errorCode);
     if (U_FAILURE(errorCode)) {
@@ -469,13 +469,13 @@ BucketList *AlphabeticIndex::createBucketList(UErrorCode &errorCode) const {
         if (collatorPrimaryOnly_->compare(current, *scriptUpperBoundary, errorCode) >= 0) {
             // We crossed the script boundary into a new script.
             const UnicodeString &inflowBoundary = *scriptUpperBoundary;
-            UBool skippedScript = FALSE;
+            UBool skippedScript = false;
             for (;;) {
                 scriptUpperBoundary = getString(*firstCharsInScripts_, ++scriptIndex);
                 if (collatorPrimaryOnly_->compare(current, *scriptUpperBoundary, errorCode) < 0) {
                     break;
                 }
-                skippedScript = TRUE;
+                skippedScript = true;
             }
             if (skippedScript && bucketList->size() > 1) {
                 // We are skipping one or more scripts,
@@ -498,7 +498,7 @@ BucketList *AlphabeticIndex::createBucketList(UErrorCode &errorCode) const {
         } else if (current.length() == BASE_LENGTH + 1 && current.startsWith(BASE, BASE_LENGTH) &&
                 0x41 <= (c = current.charAt(BASE_LENGTH)) && c <= 0x5A) {
             pinyinBuckets[c - 0x41] = (Bucket *)bucketList->lastElement();
-            hasPinyin = TRUE;
+            hasPinyin = true;
         }
         // Check for multiple primary weights.
         if (!current.startsWith(BASE, BASE_LENGTH) &&
@@ -531,7 +531,7 @@ BucketList *AlphabeticIndex::createBucketList(UErrorCode &errorCode) const {
                     bucket->displayBucket_ = singleBucket;
                     bucketList->adoptElement(bucket.orphan(), errorCode);
                     if (U_FAILURE(errorCode)) { return nullptr; }
-                    hasInvisibleBuckets = TRUE;
+                    hasInvisibleBuckets = true;
                     break;
                 }
             }
@@ -563,7 +563,7 @@ BucketList *AlphabeticIndex::createBucketList(UErrorCode &errorCode) const {
             }
             if (pinyinBuckets[i] != NULL && asciiBucket != NULL) {
                 pinyinBuckets[i]->displayBucket_ = asciiBucket;
-                hasInvisibleBuckets = TRUE;
+                hasInvisibleBuckets = true;
             }
         }
     }
@@ -754,7 +754,7 @@ void AlphabeticIndex::addIndexExemplars(const Locale &locale, UErrorCode &status
 UBool AlphabeticIndex::addChineseIndexCharacters(UErrorCode &errorCode) {
     UnicodeSet contractions;
     collatorPrimaryOnly_->internalAddContractions(BASE[0], contractions, errorCode);
-    if (U_FAILURE(errorCode) || contractions.isEmpty()) { return FALSE; }
+    if (U_FAILURE(errorCode) || contractions.isEmpty()) { return false; }
     initialLabels_->addAll(contractions);
     UnicodeSetIterator iter(contractions);
     while (iter.next()) {
@@ -767,7 +767,7 @@ UBool AlphabeticIndex::addChineseIndexCharacters(UErrorCode &errorCode) {
             break;
         }
     }
-    return TRUE;
+    return true;
 }
 
 
@@ -1028,7 +1028,7 @@ UBool isOneLabelBetterThanOther(const Normalizer2 &nfkdNormalizer,
     UErrorCode status = U_ZERO_ERROR;
     UnicodeString n1 = nfkdNormalizer.normalize(one, status);
     UnicodeString n2 = nfkdNormalizer.normalize(other, status);
-    if (U_FAILURE(status)) { return FALSE; }
+    if (U_FAILURE(status)) { return false; }
     int32_t result = n1.countChar32() - n2.countChar32();
     if (result != 0) {
         return result < 0;
@@ -1105,24 +1105,24 @@ int32_t AlphabeticIndex::getBucketIndex() const {
 
 UBool AlphabeticIndex::nextBucket(UErrorCode &status) {
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
     if (buckets_ == NULL && currentBucket_ != NULL) {
         status = U_ENUM_OUT_OF_SYNC_ERROR;
-        return FALSE;
+        return false;
     }
     initBuckets(status);
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
     ++labelsIterIndex_;
     if (labelsIterIndex_ >= buckets_->getBucketCount()) {
         labelsIterIndex_ = buckets_->getBucketCount();
-        return FALSE;
+        return false;
     }
     currentBucket_ = getBucket(*buckets_->immutableVisibleList_, labelsIterIndex_);
     resetRecordIterator();
-    return TRUE;
+    return true;
 }
 
 const UnicodeString &AlphabeticIndex::getBucketLabel() const {
@@ -1163,27 +1163,27 @@ AlphabeticIndex &AlphabeticIndex::resetBucketIterator(UErrorCode &status) {
 
 UBool AlphabeticIndex::nextRecord(UErrorCode &status) {
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
     if (currentBucket_ == NULL) {
         // We are trying to iterate over the items in a bucket, but there is no
         // current bucket from the enumeration of buckets.
         status = U_INVALID_STATE_ERROR;
-        return FALSE;
+        return false;
     }
     if (buckets_ == NULL) {
         status = U_ENUM_OUT_OF_SYNC_ERROR;
-        return FALSE;
+        return false;
     }
     if (currentBucket_->records_ == NULL) {
-        return FALSE;
+        return false;
     }
     ++itemsIterIndex_;
     if (itemsIterIndex_ >= currentBucket_->records_->size()) {
         itemsIterIndex_  = currentBucket_->records_->size();
-        return FALSE;
+        return false;
     }
-    return TRUE;
+    return true;
 }
 
 
diff --git a/deps/icu-small/source/i18n/anytrans.cpp b/deps/icu-small/source/i18n/anytrans.cpp
index 167b018528..e10ff479dd 100644
--- a/deps/icu-small/source/i18n/anytrans.cpp
+++ b/deps/icu-small/source/i18n/anytrans.cpp
@@ -101,7 +101,7 @@ public:
     ScriptRunIterator(const Replaceable& text, int32_t start, int32_t limit);
 
     /**
-     * Returns TRUE if there are any more runs.  TRUE is always
+     * Returns true if there are any more runs.  true is always
      * returned at least once.  Upon return, the caller should
      * examine scriptCode, start, and limit.
      */
@@ -137,7 +137,7 @@ UBool ScriptRunIterator::next() {
 
     // Are we done?
     if (start == textLimit) {
-        return FALSE;
+        return false;
     }
 
     // Move start back to include adjacent COMMON or INHERITED
@@ -167,9 +167,9 @@ UBool ScriptRunIterator::next() {
         ++limit;
     }
 
-    // Return TRUE even if the entire text is COMMON / INHERITED, in
+    // Return true even if the entire text is COMMON / INHERITED, in
     // which case scriptCode will be USCRIPT_INVALID_CODE.
-    return TRUE;
+    return true;
 }
 
 void ScriptRunIterator::adjustLimit(int32_t delta) {
@@ -358,7 +358,7 @@ static UScriptCode scriptNameToCode(const UnicodeString& name) {
 void AnyTransliterator::registerIDs() {
 
     UErrorCode ec = U_ZERO_ERROR;
-    Hashtable seen(TRUE, ec);
+    Hashtable seen(true, ec);
 
     int32_t sourceCount = Transliterator::_countAvailableSources();
     for (int32_t s=0; s<sourceCount; ++s) {
@@ -389,7 +389,7 @@ void AnyTransliterator::registerIDs() {
                 Transliterator::_getAvailableVariant(v, source, target, variant);
 
                 UnicodeString id;
-                TransliteratorIDParser::STVtoID(UnicodeString(TRUE, ANY, 3), target, variant, id);
+                TransliteratorIDParser::STVtoID(UnicodeString(true, ANY, 3), target, variant, id);
                 ec = U_ZERO_ERROR;
                 AnyTransliterator* tl = new AnyTransliterator(id, target, variant,
                                                              targetScript, ec);
@@ -397,7 +397,7 @@ void AnyTransliterator::registerIDs() {
                     delete tl;
                 } else {
                     Transliterator::_registerInstance(tl);
-                    Transliterator::_registerSpecialInverse(target, UnicodeString(TRUE, NULL_ID, 4), FALSE);
+                    Transliterator::_registerSpecialInverse(target, UnicodeString(true, NULL_ID, 4), false);
                 }
             }
         }
diff --git a/deps/icu-small/source/i18n/astro.cpp b/deps/icu-small/source/i18n/astro.cpp
index 6dc463b4ca..b28e9f06ba 100644
--- a/deps/icu-small/source/i18n/astro.cpp
+++ b/deps/icu-small/source/i18n/astro.cpp
@@ -69,7 +69,7 @@ static icu::UMutex ccLock;
 
 U_CDECL_BEGIN
 static UBool calendar_astro_cleanup(void) {
-  return TRUE;
+  return true;
 }
 U_CDECL_END
 
@@ -242,7 +242,7 @@ inline static  double normPI(double angle)  {
  * @deprecated ICU 2.4. This class may be removed or modified.
  */
 CalendarAstronomer::CalendarAstronomer():
-  fTime(Calendar::getNow()), fLongitude(0.0), fLatitude(0.0), fGmtOffset(0.0), moonPosition(0,0), moonPositionSet(FALSE) {
+  fTime(Calendar::getNow()), fLongitude(0.0), fLatitude(0.0), fGmtOffset(0.0), moonPosition(0,0), moonPositionSet(false) {
   clearCache();
 }
 
@@ -252,7 +252,7 @@ CalendarAstronomer::CalendarAstronomer():
  * @internal
  * @deprecated ICU 2.4. This class may be removed or modified.
  */
-CalendarAstronomer::CalendarAstronomer(UDate d): fTime(d), fLongitude(0.0), fLatitude(0.0), fGmtOffset(0.0), moonPosition(0,0), moonPositionSet(FALSE) {
+CalendarAstronomer::CalendarAstronomer(UDate d): fTime(d), fLongitude(0.0), fLatitude(0.0), fGmtOffset(0.0), moonPosition(0,0), moonPositionSet(false) {
   clearCache();
 }
 
@@ -272,7 +272,7 @@ CalendarAstronomer::CalendarAstronomer(UDate d): fTime(d), fLongitude(0.0), fLat
  * @deprecated ICU 2.4. This class may be removed or modified.
  */
 CalendarAstronomer::CalendarAstronomer(double longitude, double latitude) :
-  fTime(Calendar::getNow()), moonPosition(0,0), moonPositionSet(FALSE) {
+  fTime(Calendar::getNow()), moonPosition(0,0), moonPositionSet(false) {
   fLongitude = normPI(longitude * (double)DEG_RAD);
   fLatitude  = normPI(latitude  * (double)DEG_RAD);
   fGmtOffset = (double)(fLongitude * 24. * (double)HOUR_MS / (double)CalendarAstronomer_PI2);
@@ -1069,7 +1069,7 @@ const CalendarAstronomer::Equatorial& CalendarAstronomer::getMoonPosition()
     // See page 142 of "Practical Astronomy with your Calculator",
     // by Peter Duffet-Smith, for details on the algorithm.
     //
-    if (moonPositionSet == FALSE) {
+    if (moonPositionSet == false) {
         // Calculate the solar longitude.  Has the side effect of
         // filling in "meanAnomalySun" as well.
         getSunLongitude();
@@ -1138,7 +1138,7 @@ const CalendarAstronomer::Equatorial& CalendarAstronomer::getMoonPosition()
         double moonEclipLat = ::asin(y * ::sin(moonI));
 
         eclipticToEquatorial(moonPosition, moonEclipLong, moonEclipLat);
-        moonPositionSet = TRUE;
+        moonPositionSet = true;
     }
     return moonPosition;
 }
@@ -1446,7 +1446,7 @@ void CalendarAstronomer::clearCache() {
     eclipObliquity  = INVALID;
     siderealTime    = INVALID;
     siderealT0      = INVALID;
-    moonPositionSet = FALSE;
+    moonPositionSet = false;
 }
 
 //private static void out(String s) {
@@ -1471,7 +1471,7 @@ void CalendarAstronomer::clearCache() {
   int32_t rawOffset;
   int32_t dstOffset;
   UErrorCode status = U_ZERO_ERROR;
-  tz->getOffset(localMillis, TRUE, rawOffset, dstOffset, status);
+  tz->getOffset(localMillis, true, rawOffset, dstOffset, status);
   delete tz;
   return localMillis - rawOffset;
 }*/
diff --git a/deps/icu-small/source/i18n/basictz.cpp b/deps/icu-small/source/i18n/basictz.cpp
index 7b5449f416..dfc3aea6cb 100644
--- a/deps/icu-small/source/i18n/basictz.cpp
+++ b/deps/icu-small/source/i18n/basictz.cpp
@@ -39,59 +39,59 @@ UBool
 BasicTimeZone::hasEquivalentTransitions(const BasicTimeZone& tz, UDate start, UDate end,
                                         UBool ignoreDstAmount, UErrorCode& status) const {
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
     if (hasSameRules(tz)) {
-        return TRUE;
+        return true;
     }
     // Check the offsets at the start time
     int32_t raw1, raw2, dst1, dst2;
-    getOffset(start, FALSE, raw1, dst1, status);
+    getOffset(start, false, raw1, dst1, status);
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
-    tz.getOffset(start, FALSE, raw2, dst2, status);
+    tz.getOffset(start, false, raw2, dst2, status);
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
     if (ignoreDstAmount) {
         if ((raw1 + dst1 != raw2 + dst2)
             || (dst1 != 0 && dst2 == 0)
             || (dst1 == 0 && dst2 != 0)) {
-            return FALSE;
+            return false;
         }
     } else {
         if (raw1 != raw2 || dst1 != dst2) {
-            return FALSE;
+            return false;
         }            
     }
     // Check transitions in the range
     UDate time = start;
     TimeZoneTransition tr1, tr2;
-    while (TRUE) {
-        UBool avail1 = getNextTransition(time, FALSE, tr1);
-        UBool avail2 = tz.getNextTransition(time, FALSE, tr2);
+    while (true) {
+        UBool avail1 = getNextTransition(time, false, tr1);
+        UBool avail2 = tz.getNextTransition(time, false, tr2);
 
         if (ignoreDstAmount) {
             // Skip a transition which only differ the amount of DST savings
-            while (TRUE) {
+            while (true) {
                 if (avail1
                         && tr1.getTime() <= end
                         && (tr1.getFrom()->getRawOffset() + tr1.getFrom()->getDSTSavings()
                                 == tr1.getTo()->getRawOffset() + tr1.getTo()->getDSTSavings())
                         && (tr1.getFrom()->getDSTSavings() != 0 && tr1.getTo()->getDSTSavings() != 0)) {
-                    getNextTransition(tr1.getTime(), FALSE, tr1);
+                    getNextTransition(tr1.getTime(), false, tr1);
                 } else {
                     break;
                 }
             }
-            while (TRUE) {
+            while (true) {
                 if (avail2
                         && tr2.getTime() <= end
                         && (tr2.getFrom()->getRawOffset() + tr2.getFrom()->getDSTSavings()
                                 == tr2.getTo()->getRawOffset() + tr2.getTo()->getDSTSavings())
                         && (tr2.getFrom()->getDSTSavings() != 0 && tr2.getTo()->getDSTSavings() != 0)) {
-                    tz.getNextTransition(tr2.getTime(), FALSE, tr2);
+                    tz.getNextTransition(tr2.getTime(), false, tr2);
                 } else {
                     break;
                 }
@@ -105,27 +105,27 @@ BasicTimeZone::hasEquivalentTransitions(const BasicTimeZone& tz, UDate start, UD
             break;
         }
         if (!inRange1 || !inRange2) {
-            return FALSE;
+            return false;
         }
         if (tr1.getTime() != tr2.getTime()) {
-            return FALSE;
+            return false;
         }
         if (ignoreDstAmount) {
             if (tr1.getTo()->getRawOffset() + tr1.getTo()->getDSTSavings()
                         != tr2.getTo()->getRawOffset() + tr2.getTo()->getDSTSavings()
                     || (tr1.getTo()->getDSTSavings() != 0 &&  tr2.getTo()->getDSTSavings() == 0)
                     || (tr1.getTo()->getDSTSavings() == 0 &&  tr2.getTo()->getDSTSavings() != 0)) {
-                return FALSE;
+                return false;
             }
         } else {
             if (tr1.getTo()->getRawOffset() != tr2.getTo()->getRawOffset() ||
                 tr1.getTo()->getDSTSavings() != tr2.getTo()->getDSTSavings()) {
-                return FALSE;
+                return false;
             }
         }
         time = tr1.getTime();
     }
-    return TRUE;
+    return true;
 }
 
 void
@@ -147,7 +147,7 @@ BasicTimeZone::getSimpleRulesNear(UDate date, InitialTimeZoneRule*& initial,
     UBool avail;
     TimeZoneTransition tr;
     // Get the next transition
-    avail = getNextTransition(date, FALSE, tr);
+    avail = getNextTransition(date, false, tr);
     if (avail) {
         tr.getFrom()->getName(initialName);
         initialRaw = tr.getFrom()->getRawOffset();
@@ -182,7 +182,7 @@ BasicTimeZone::getSimpleRulesNear(UDate date, InitialTimeZoneRule*& initial,
 
             if (tr.getTo()->getRawOffset() == initialRaw) {
                 // Get the next next transition
-                avail = getNextTransition(nextTransitionTime, FALSE, tr);
+                avail = getNextTransition(nextTransitionTime, false, tr);
                 if (avail) {
                     // Check if the next next transition is either DST->STD or STD->DST
                     // and within roughly 1 year from the next transition
@@ -201,7 +201,7 @@ BasicTimeZone::getSimpleRulesNear(UDate date, InitialTimeZoneRule*& initial,
                             dtr, year - 1, AnnualTimeZoneRule::MAX_YEAR);
 
                         // Make sure this rule can be applied to the specified date
-                        avail = ar2->getPreviousStart(date, tr.getFrom()->getRawOffset(), tr.getFrom()->getDSTSavings(), TRUE, d);
+                        avail = ar2->getPreviousStart(date, tr.getFrom()->getRawOffset(), tr.getFrom()->getDSTSavings(), true, d);
                         if (!avail || d > date
                                 || initialRaw != tr.getTo()->getRawOffset()
                                 || initialDst != tr.getTo()->getDSTSavings()) {
@@ -214,7 +214,7 @@ BasicTimeZone::getSimpleRulesNear(UDate date, InitialTimeZoneRule*& initial,
             }
             if (ar2 == NULL) {
                 // Try previous transition
-                avail = getPreviousTransition(date, TRUE, tr);
+                avail = getPreviousTransition(date, true, tr);
                 if (avail) {
                     // Check if the previous transition is either DST->STD or STD->DST.
                     // The actual transition time does not matter here.
@@ -234,7 +234,7 @@ BasicTimeZone::getSimpleRulesNear(UDate date, InitialTimeZoneRule*& initial,
                             dtr, ar1->getStartYear() - 1, AnnualTimeZoneRule::MAX_YEAR);
 
                         // Check if this rule start after the first rule after the specified date
-                        avail = ar2->getNextStart(date, tr.getFrom()->getRawOffset(), tr.getFrom()->getDSTSavings(), FALSE, d);
+                        avail = ar2->getNextStart(date, tr.getFrom()->getRawOffset(), tr.getFrom()->getDSTSavings(), false, d);
                         if (!avail || d <= nextTransitionTime) {
                             // We cannot use this rule as the second transition rule
                             delete ar2;
@@ -257,14 +257,14 @@ BasicTimeZone::getSimpleRulesNear(UDate date, InitialTimeZoneRule*& initial,
     }
     else {
         // Try the previous one
-        avail = getPreviousTransition(date, TRUE, tr);
+        avail = getPreviousTransition(date, true, tr);
         if (avail) {
             tr.getTo()->getName(initialName);
             initialRaw = tr.getTo()->getRawOffset();
             initialDst = tr.getTo()->getDSTSavings();
         } else {
             // No transitions in the past.  Just use the current offsets
-            getOffset(date, FALSE, initialRaw, initialDst, status);
+            getOffset(date, false, initialRaw, initialDst, status);
             if (U_FAILURE(status)) {
                 return;
             }
@@ -334,7 +334,7 @@ BasicTimeZone::getTimeZoneRulesAfter(UDate start, InitialTimeZoneRule*& initial,
         }
     }
 
-    avail = getPreviousTransition(start, TRUE, tzt);
+    avail = getPreviousTransition(start, true, tzt);
     if (!avail) {
         // No need to filter out rules only applicable to time before the start
         initial = orgini->clone();
@@ -368,13 +368,13 @@ BasicTimeZone::getTimeZoneRulesAfter(UDate start, InitialTimeZoneRule*& initial,
     // Mark rules which does not need to be processed
     for (i = 0; i < ruleCount; i++) {
         r = (TimeZoneRule*)orgRules->elementAt(i);
-        avail = r->getNextStart(start, res_initial->getRawOffset(), res_initial->getDSTSavings(), FALSE, time);
+        avail = r->getNextStart(start, res_initial->getRawOffset(), res_initial->getDSTSavings(), false, time);
         done[i] = !avail;
     }
 
     time = start;
     while (!bFinalStd || !bFinalDst) {
-        avail = getNextTransition(time, FALSE, tzt);
+        avail = getNextTransition(time, false, tzt);
         if (!avail) {
             break;
         }
@@ -409,8 +409,8 @@ BasicTimeZone::getTimeZoneRulesAfter(UDate start, InitialTimeZoneRule*& initial,
             // Get the previous raw offset and DST savings before the very first start time
             TimeZoneTransition tzt0;
             t = start;
-            while (TRUE) {
-                avail = getNextTransition(t, FALSE, tzt0);
+            while (true) {
+                avail = getNextTransition(t, false, tzt0);
                 if (!avail) {
                     break;
                 }
@@ -499,9 +499,9 @@ BasicTimeZone::getTimeZoneRulesAfter(UDate start, InitialTimeZoneRule*& initial,
                 // After bot final standard and dst rules are processed,
                 // exit this while loop.
                 if (ar->getDSTSavings() == 0) {
-                    bFinalStd = TRUE;
+                    bFinalStd = true;
                 } else {
-                    bFinalDst = TRUE;
+                    bFinalDst = true;
                 }
             }
         }
diff --git a/deps/icu-small/source/i18n/buddhcal.cpp b/deps/icu-small/source/i18n/buddhcal.cpp
index 6083349ecd..de304129cb 100644
--- a/deps/icu-small/source/i18n/buddhcal.cpp
+++ b/deps/icu-small/source/i18n/buddhcal.cpp
@@ -133,12 +133,12 @@ void BuddhistCalendar::timeToFields(UDate theTime, UBool quick, UErrorCode& stat
  */
 static UDate     gSystemDefaultCenturyStart       = DBL_MIN;
 static int32_t   gSystemDefaultCenturyStartYear   = -1;
-static icu::UInitOnce gBCInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gBCInitOnce {};
 
 
 UBool BuddhistCalendar::haveDefaultCentury() const
 {
-    return TRUE;
+    return true;
 }
 
 static void U_CALLCONV
diff --git a/deps/icu-small/source/i18n/calendar.cpp b/deps/icu-small/source/i18n/calendar.cpp
index 8405d08d3c..7b8b929990 100644
--- a/deps/icu-small/source/i18n/calendar.cpp
+++ b/deps/icu-small/source/i18n/calendar.cpp
@@ -22,7 +22,7 @@
 *   07/28/98    stephen     Sync up with JDK 1.2
 *   09/02/98    stephen     Sync with JDK 1.2 8/31 build (getActualMin/Max)
 *   03/17/99    stephen     Changed adoptTimeZone() - now fAreFieldsSet is
-*                           set to FALSE to force update of time.
+*                           set to false to force update of time.
 *******************************************************************************
 */
 
@@ -65,7 +65,7 @@
 
 #if !UCONFIG_NO_SERVICE
 static icu::ICULocaleService* gService = NULL;
-static icu::UInitOnce gServiceInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gServiceInitOnce {};
 
 // INTERNAL - for cleanup
 U_CDECL_BEGIN
@@ -77,7 +77,7 @@ static UBool calendar_cleanup(void) {
     }
     gServiceInitOnce.reset();
 #endif
-    return TRUE;
+    return true;
 }
 U_CDECL_END
 #endif
@@ -210,15 +210,18 @@ SharedCalendar::~SharedCalendar() {
 template<> U_I18N_API
 const SharedCalendar *LocaleCacheKey<SharedCalendar>::createObject(
         const void * /*unusedCreationContext*/, UErrorCode &status) const {
+    if (U_FAILURE(status)) {
+       return nullptr;
+    }
     Calendar *calendar = Calendar::makeInstance(fLoc, status);
     if (U_FAILURE(status)) {
-        return NULL;
+        return nullptr;
     }
     SharedCalendar *shared = new SharedCalendar(calendar);
-    if (shared == NULL) {
+    if (shared == nullptr) {
         delete calendar;
         status = U_MEMORY_ALLOCATION_ERROR;
-        return NULL;
+        return nullptr;
     }
     shared->addRef();
     return shared;
@@ -237,7 +240,7 @@ static ECalType getCalendarType(const char *s) {
 // Only used with service registration.
 static UBool isStandardSupportedKeyword(const char *keyword, UErrorCode& status) {
     if(U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
     ECalType calType = getCalendarType(keyword);
     return (calType != CALTYPE_UNKNOWN);
@@ -292,7 +295,7 @@ static ECalType getCalendarTypeForLocale(const char *locid) {
     // when calendar keyword is not available or not supported, read supplementalData
     // to get the default calendar type for the locale's region
     char region[ULOC_COUNTRY_CAPACITY];
-    (void)ulocimp_getRegionForSupplementalData(canonicalName, TRUE, region, sizeof(region), &status);
+    (void)ulocimp_getRegionForSupplementalData(canonicalName, true, region, sizeof(region), &status);
     if (U_FAILURE(status)) {
         return CALTYPE_GREGORIAN;
     }
@@ -420,7 +423,7 @@ public:
 protected:
     //virtual UBool isSupportedID( const UnicodeString& id, UErrorCode& status) const {
     //  if(U_FAILURE(status)) {
-    //    return FALSE;
+    //    return false;
     //  }
     //  char keyword[ULOC_FULLNAME_CAPACITY];
     //  getCalendarKeyword(id, keyword, (int32_t)sizeof(keyword));
@@ -440,6 +443,9 @@ protected:
     }
 
     virtual UObject* create(const ICUServiceKey& key, const ICUService* /*service*/, UErrorCode& status) const override {
+        if (U_FAILURE(status)) {
+           return nullptr;
+        }
 #ifdef U_DEBUG_CALSVC
         if(dynamic_cast<const LocaleKey*>(&key) == NULL) {
             fprintf(stderr, "::create - not a LocaleKey!\n");
@@ -486,13 +492,16 @@ public:
     virtual ~DefaultCalendarFactory();
 protected:
     virtual UObject* create(const ICUServiceKey& key, const ICUService* /*service*/, UErrorCode& status) const override {
+        if (U_FAILURE(status)) {
+           return nullptr;
+        }
 
         LocaleKey &lkey = (LocaleKey&)key;
         Locale loc;
         lkey.currentLocale(loc);
 
         UnicodeString *ret = new UnicodeString();
-        if (ret == NULL) {
+        if (ret == nullptr) {
             status = U_MEMORY_ALLOCATION_ERROR;
         } else {
             ret->append((UChar)0x40); // '@' is a variant character
@@ -531,6 +540,9 @@ public:
     }
 
     virtual UObject* handleDefault(const ICUServiceKey& key, UnicodeString* /*actualID*/, UErrorCode& status) const override {
+        if (U_FAILURE(status)) {
+           return nullptr;
+        }
         LocaleKey& lkey = (LocaleKey&)key;
         //int32_t kind = lkey.kind();
 
@@ -577,6 +589,9 @@ initCalendarService(UErrorCode &status)
 #ifdef U_DEBUG_CALSVC
         fprintf(stderr, "Spinning up Calendar Service\n");
 #endif
+    if (U_FAILURE(status)) {
+       return;
+    }
     ucln_i18n_registerCleanup(UCLN_I18N_CALENDAR, calendar_cleanup);
     gService = new CalendarService();
     if (gService == NULL) {
@@ -639,8 +654,8 @@ static const int32_t kCalendarLimits[UCAL_FIELD_COUNT][4] = {
     {           0,            0,            59,            59  }, // MINUTE
     {           0,            0,            59,            59  }, // SECOND
     {           0,            0,           999,           999  }, // MILLISECOND
-    {-12*kOneHour, -12*kOneHour,   12*kOneHour,   15*kOneHour  }, // ZONE_OFFSET
-    {           0,            0,    1*kOneHour,    1*kOneHour  }, // DST_OFFSET
+    {-16*kOneHour, -16*kOneHour,   12*kOneHour,   30*kOneHour  }, // ZONE_OFFSET
+    { -1*kOneHour,  -1*kOneHour,    2*kOneHour,    2*kOneHour  }, // DST_OFFSET
     {/*N/A*/-1,       /*N/A*/-1,     /*N/A*/-1,       /*N/A*/-1}, // YEAR_WOY
     {           1,            1,             7,             7  }, // DOW_LOCAL
     {/*N/A*/-1,       /*N/A*/-1,     /*N/A*/-1,       /*N/A*/-1}, // EXTENDED_YEAR
@@ -708,13 +723,13 @@ static const char gGregorian[] = "gregorian";
 
 Calendar::Calendar(UErrorCode& success)
 :   UObject(),
-fIsTimeSet(FALSE),
-fAreFieldsSet(FALSE),
-fAreAllFieldsSet(FALSE),
-fAreFieldsVirtuallySet(FALSE),
+fIsTimeSet(false),
+fAreFieldsSet(false),
+fAreAllFieldsSet(false),
+fAreFieldsVirtuallySet(false),
 fNextStamp((int32_t)kMinimumUserStamp),
 fTime(0),
-fLenient(TRUE),
+fLenient(true),
 fZone(NULL),
 fRepeatedWallTime(UCAL_WALLTIME_LAST),
 fSkippedWallTime(UCAL_WALLTIME_LAST)
@@ -736,13 +751,13 @@ fSkippedWallTime(UCAL_WALLTIME_LAST)
 
 Calendar::Calendar(TimeZone* zone, const Locale& aLocale, UErrorCode& success)
 :   UObject(),
-fIsTimeSet(FALSE),
-fAreFieldsSet(FALSE),
-fAreAllFieldsSet(FALSE),
-fAreFieldsVirtuallySet(FALSE),
+fIsTimeSet(false),
+fAreFieldsSet(false),
+fAreAllFieldsSet(false),
+fAreFieldsVirtuallySet(false),
 fNextStamp((int32_t)kMinimumUserStamp),
 fTime(0),
-fLenient(TRUE),
+fLenient(true),
 fZone(NULL),
 fRepeatedWallTime(UCAL_WALLTIME_LAST),
 fSkippedWallTime(UCAL_WALLTIME_LAST)
@@ -771,13 +786,13 @@ fSkippedWallTime(UCAL_WALLTIME_LAST)
 
 Calendar::Calendar(const TimeZone& zone, const Locale& aLocale, UErrorCode& success)
 :   UObject(),
-fIsTimeSet(FALSE),
-fAreFieldsSet(FALSE),
-fAreAllFieldsSet(FALSE),
-fAreFieldsVirtuallySet(FALSE),
+fIsTimeSet(false),
+fAreFieldsSet(false),
+fAreAllFieldsSet(false),
+fAreFieldsVirtuallySet(false),
 fNextStamp((int32_t)kMinimumUserStamp),
 fTime(0),
-fLenient(TRUE),
+fLenient(true),
 fZone(NULL),
 fRepeatedWallTime(UCAL_WALLTIME_LAST),
 fSkippedWallTime(UCAL_WALLTIME_LAST)
@@ -1173,13 +1188,13 @@ Calendar::setTimeInMillis( double millis, UErrorCode& status ) {
     }
 
     fTime = millis;
-    fAreFieldsSet = fAreAllFieldsSet = FALSE;
-    fIsTimeSet = fAreFieldsVirtuallySet = TRUE;
+    fAreFieldsSet = fAreAllFieldsSet = false;
+    fIsTimeSet = fAreFieldsVirtuallySet = true;
 
     for (int32_t i=0; i<UCAL_FIELD_COUNT; ++i) {
         fFields[i]     = 0;
         fStamp[i]     = kUnset;
-        fIsSet[i]     = FALSE;
+        fIsSet[i]     = false;
     }
 
 
@@ -1212,8 +1227,8 @@ Calendar::set(UCalendarDateFields field, int32_t value)
         recalculateStamp();
     }
     fStamp[field]     = fNextStamp++;
-    fIsSet[field]     = TRUE; // Remove later
-    fIsTimeSet = fAreFieldsSet = fAreFieldsVirtuallySet = FALSE;
+    fIsSet[field]     = true; // Remove later
+    fIsTimeSet = fAreFieldsSet = fAreFieldsVirtuallySet = false;
 }
 
 // -------------------------------------
@@ -1388,9 +1403,9 @@ Calendar::clear()
     for (int32_t i=0; i<UCAL_FIELD_COUNT; ++i) {
         fFields[i]     = 0; // Must do this; other code depends on it
         fStamp[i]     = kUnset;
-        fIsSet[i]     = FALSE; // Remove later
+        fIsSet[i]     = false; // Remove later
     }
-    fIsTimeSet = fAreFieldsSet = fAreAllFieldsSet = fAreFieldsVirtuallySet = FALSE;
+    fIsTimeSet = fAreFieldsSet = fAreAllFieldsSet = fAreFieldsVirtuallySet = false;
     // fTime is not 'cleared' - may be used if no fields are set.
 }
 
@@ -1405,8 +1420,8 @@ Calendar::clear(UCalendarDateFields field)
     }
     fFields[field]         = 0;
     fStamp[field]         = kUnset;
-    fIsSet[field]         = FALSE; // Remove later
-    fIsTimeSet = fAreFieldsSet = fAreAllFieldsSet = fAreFieldsVirtuallySet = FALSE;
+    fIsSet[field]         = false; // Remove later
+    fIsTimeSet = fAreFieldsSet = fAreAllFieldsSet = fAreFieldsVirtuallySet = false;
 }
 
 // -------------------------------------
@@ -1435,6 +1450,9 @@ int32_t Calendar::newestStamp(UCalendarDateFields first, UCalendarDateFields las
 void
 Calendar::complete(UErrorCode& status)
 {
+    if (U_FAILURE(status)) {
+       return;
+    }
     if (!fIsTimeSet) {
         updateTime(status);
         /* Test for buffer overflows */
@@ -1448,8 +1466,8 @@ Calendar::complete(UErrorCode& status)
         if(U_FAILURE(status)) {
             return;
         }
-        fAreFieldsSet         = TRUE;
-        fAreAllFieldsSet     = TRUE;
+        fAreFieldsSet         = true;
+        fAreAllFieldsSet     = true;
     }
 }
 
@@ -1486,6 +1504,9 @@ Calendar::complete(UErrorCode& status)
 * @stable ICU 2.0
 */
 void Calendar::pinField(UCalendarDateFields field, UErrorCode& status) {
+    if (U_FAILURE(status)) {
+       return;
+    }
     int32_t max = getActualMaximum(field, status);
     int32_t min = getActualMinimum(field, status);
 
@@ -1499,13 +1520,16 @@ void Calendar::pinField(UCalendarDateFields field, UErrorCode& status) {
 
 void Calendar::computeFields(UErrorCode &ec)
 {
-  if (U_FAILURE(ec)) {
+    if (U_FAILURE(ec)) {
         return;
     }
     // Compute local wall millis
     double localMillis = internalGetTime();
     int32_t rawOffset, dstOffset;
-    getTimeZone().getOffset(localMillis, FALSE, rawOffset, dstOffset, ec);
+    getTimeZone().getOffset(localMillis, false, rawOffset, dstOffset, ec);
+    if (U_FAILURE(ec)) {
+        return;
+    }
     localMillis += (rawOffset + dstOffset);
 
     // Mark fields as set.  Do this before calling handleComputeFields().
@@ -1520,10 +1544,10 @@ void Calendar::computeFields(UErrorCode &ec)
     for (int32_t i=0; i<UCAL_FIELD_COUNT; ++i) {
         if ((mask & 1) == 0) {
             fStamp[i] = kInternallySet;
-            fIsSet[i] = TRUE; // Remove later
+            fIsSet[i] = true; // Remove later
         } else {
             fStamp[i] = kUnset;
-            fIsSet[i] = FALSE; // Remove later
+            fIsSet[i] = false; // Remove later
         }
         mask >>= 1;
     }
@@ -1537,7 +1561,8 @@ void Calendar::computeFields(UErrorCode &ec)
     // JULIAN_DAY field and also removes some inelegant code. - Liu
     // 11/6/00
 
-    int32_t days =  (int32_t)ClockMath::floorDivide(localMillis, (double)kOneDay);
+    int32_t millisInDay;
+    int32_t days = ClockMath::floorDivide(localMillis, kOneDay, &millisInDay);
 
     internalSet(UCAL_JULIAN_DAY,days + kEpochStartAsJulianDay);
 
@@ -1561,19 +1586,50 @@ void Calendar::computeFields(UErrorCode &ec)
     // Compute time-related fields.  These are independent of the date and
     // of the subclass algorithm.  They depend only on the local zone
     // wall milliseconds in day.
-    int32_t millisInDay =  (int32_t) (localMillis - (days * kOneDay));
+    if (U_FAILURE(ec)) {
+        return;
+    }
+
     fFields[UCAL_MILLISECONDS_IN_DAY] = millisInDay;
+    U_ASSERT(getMinimum(UCAL_MILLISECONDS_IN_DAY) <=
+             fFields[UCAL_MILLISECONDS_IN_DAY]);
+    U_ASSERT(fFields[UCAL_MILLISECONDS_IN_DAY] <=
+             getMaximum(UCAL_MILLISECONDS_IN_DAY));
+
     fFields[UCAL_MILLISECOND] = millisInDay % 1000;
+    U_ASSERT(getMinimum(UCAL_MILLISECOND) <= fFields[UCAL_MILLISECOND]);
+    U_ASSERT(fFields[UCAL_MILLISECOND] <= getMaximum(UCAL_MILLISECOND));
+
     millisInDay /= 1000;
     fFields[UCAL_SECOND] = millisInDay % 60;
+    U_ASSERT(getMinimum(UCAL_SECOND) <= fFields[UCAL_SECOND]);
+    U_ASSERT(fFields[UCAL_SECOND] <= getMaximum(UCAL_SECOND));
+
     millisInDay /= 60;
     fFields[UCAL_MINUTE] = millisInDay % 60;
+    U_ASSERT(getMinimum(UCAL_MINUTE) <= fFields[UCAL_MINUTE]);
+    U_ASSERT(fFields[UCAL_MINUTE] <= getMaximum(UCAL_MINUTE));
+
     millisInDay /= 60;
     fFields[UCAL_HOUR_OF_DAY] = millisInDay;
+    U_ASSERT(getMinimum(UCAL_HOUR_OF_DAY) <= fFields[UCAL_HOUR_OF_DAY]);
+    U_ASSERT(fFields[UCAL_HOUR_OF_DAY] <= getMaximum(UCAL_HOUR_OF_DAY));
+
     fFields[UCAL_AM_PM] = millisInDay / 12; // Assume AM == 0
+    U_ASSERT(getMinimum(UCAL_AM_PM) <= fFields[UCAL_AM_PM]);
+    U_ASSERT(fFields[UCAL_AM_PM] <= getMaximum(UCAL_AM_PM));
+
     fFields[UCAL_HOUR] = millisInDay % 12;
+    U_ASSERT(getMinimum(UCAL_HOUR) <= fFields[UCAL_HOUR]);
+    U_ASSERT(fFields[UCAL_HOUR] <= getMaximum(UCAL_HOUR));
+
     fFields[UCAL_ZONE_OFFSET] = rawOffset;
+    U_ASSERT(getMinimum(UCAL_ZONE_OFFSET) <= fFields[UCAL_ZONE_OFFSET]);
+    U_ASSERT(fFields[UCAL_ZONE_OFFSET] <= getMaximum(UCAL_ZONE_OFFSET));
+
     fFields[UCAL_DST_OFFSET] = dstOffset;
+    U_ASSERT(getMinimum(UCAL_DST_OFFSET) <= fFields[UCAL_DST_OFFSET]);
+    U_ASSERT(fFields[UCAL_DST_OFFSET] <= getMaximum(UCAL_DST_OFFSET));
 }
 
 uint8_t Calendar::julianDayToDayOfWeek(double julian)
@@ -1595,6 +1651,9 @@ uint8_t Calendar::julianDayToDayOfWeek(double julian)
 void Calendar::computeGregorianAndDOWFields(int32_t julianDay, UErrorCode &ec)
 {
     computeGregorianFields(julianDay, ec);
+    if (U_FAILURE(ec)) {
+        return;
+    }
 
     // Compute day of week: JD 0 = Monday
     int32_t dow = julianDayToDayOfWeek(julianDay);
@@ -1616,7 +1675,10 @@ void Calendar::computeGregorianAndDOWFields(int32_t julianDay, UErrorCode &ec)
 * subclasses that are Gregorian derivatives.  Subclasses may call this
 * method to perform a Gregorian calendar millis->fields computation.
 */
-void Calendar::computeGregorianFields(int32_t julianDay, UErrorCode & /* ec */) {
+void Calendar::computeGregorianFields(int32_t julianDay, UErrorCode& ec) {
+    if (U_FAILURE(ec)) {
+        return;
+    }
     int32_t gregorianDayOfWeekUnused;
     Grego::dayToFields(julianDay - kEpochStartAsJulianDay, fGregorianYear, fGregorianMonth, fGregorianDayOfMonth, gregorianDayOfWeekUnused, fGregorianDayOfYear);
 }
@@ -1699,11 +1761,20 @@ void Calendar::computeWeekFields(UErrorCode &ec) {
     }
     fFields[UCAL_WEEK_OF_YEAR] = woy;
     fFields[UCAL_YEAR_WOY] = yearOfWeekOfYear;
+    // min/max of years are not constrains for caller, so not assert here.
     // WEEK_OF_YEAR end
 
     int32_t dayOfMonth = fFields[UCAL_DAY_OF_MONTH];
     fFields[UCAL_WEEK_OF_MONTH] = weekNumber(dayOfMonth, dayOfWeek);
+    U_ASSERT(getMinimum(UCAL_WEEK_OF_MONTH) <= fFields[UCAL_WEEK_OF_MONTH]);
+    U_ASSERT(fFields[UCAL_WEEK_OF_MONTH] <= getMaximum(UCAL_WEEK_OF_MONTH));
+
     fFields[UCAL_DAY_OF_WEEK_IN_MONTH] = (dayOfMonth-1) / 7 + 1;
+    U_ASSERT(getMinimum(UCAL_DAY_OF_WEEK_IN_MONTH) <=
+             fFields[UCAL_DAY_OF_WEEK_IN_MONTH]);
+    U_ASSERT(fFields[UCAL_DAY_OF_WEEK_IN_MONTH] <=
+             getMaximum(UCAL_DAY_OF_WEEK_IN_MONTH));
+
 #if defined (U_DEBUG_CAL)
     if(fFields[UCAL_DAY_OF_WEEK_IN_MONTH]==0) fprintf(stderr, "%s:%d: DOWIM %d on %g\n",
         __FILE__, __LINE__,fFields[UCAL_DAY_OF_WEEK_IN_MONTH], fTime);
@@ -1732,8 +1803,11 @@ int32_t Calendar::weekNumber(int32_t desiredDay, int32_t dayOfPeriod, int32_t da
     return weekNo;
 }
 
-void Calendar::handleComputeFields(int32_t /* julianDay */, UErrorCode &/* status */)
+void Calendar::handleComputeFields(int32_t /* julianDay */, UErrorCode& status)
 {
+    if (U_FAILURE(status)) {
+        return;
+    }
     internalSet(UCAL_MONTH, getGregorianMonth());
     internalSet(UCAL_DAY_OF_MONTH, getGregorianDayOfMonth());
     internalSet(UCAL_DAY_OF_YEAR, getGregorianDayOfYear());
@@ -1842,13 +1916,13 @@ void Calendar::roll(UCalendarDateFields field, int32_t amount, UErrorCode& statu
             // * If era==0 and years go backwards in time, change sign of amount.
             // * Until we have new API per #9393, we temporarily hardcode knowledge of
             //   which calendars have era 0 years that go backwards.
-            UBool era0WithYearsThatGoBackwards = FALSE;
+            UBool era0WithYearsThatGoBackwards = false;
             int32_t era = get(UCAL_ERA, status);
             if (era == 0) {
                 const char * calType = getType();
                 if ( uprv_strcmp(calType,"gregorian")==0 || uprv_strcmp(calType,"roc")==0 || uprv_strcmp(calType,"coptic")==0 ) {
                     amount = -amount;
-                    era0WithYearsThatGoBackwards = TRUE;
+                    era0WithYearsThatGoBackwards = true;
                 }
             }
             int32_t newYear = internalGet(field) + amount;
@@ -2103,6 +2177,9 @@ void Calendar::add(EDateFields field, int32_t amount, UErrorCode& status)
 // -------------------------------------
 void Calendar::add(UCalendarDateFields field, int32_t amount, UErrorCode& status)
 {
+    if (U_FAILURE(status)) {
+       return;
+    }
     if (amount == 0) {
         return;   // Do nothing!
     }
@@ -2114,7 +2191,7 @@ void Calendar::add(UCalendarDateFields field, int32_t amount, UErrorCode& status
     // we don't want the wall time to shift due to changes in DST.  If the
     // result of the add operation is to move from DST to Standard, or
     // vice versa, we need to adjust by an hour forward or back,
-    // respectively.  For such fields we set keepWallTimeInvariant to TRUE.
+    // respectively.  For such fields we set keepWallTimeInvariant to true.
 
     // We only adjust the DST for fields larger than an hour.  For
     // fields smaller than an hour, we cannot adjust for DST without
@@ -2129,7 +2206,7 @@ void Calendar::add(UCalendarDateFields field, int32_t amount, UErrorCode& status
     // <April 30>, rather than <April 31> => <May 1>.
 
     double delta = amount; // delta in ms
-    UBool keepWallTimeInvariant = TRUE;
+    UBool keepWallTimeInvariant = true;
 
     switch (field) {
     case UCAL_ERA:
@@ -2161,10 +2238,10 @@ void Calendar::add(UCalendarDateFields field, int32_t amount, UErrorCode& status
     case UCAL_MONTH:
       {
         UBool oldLenient = isLenient();
-        setLenient(TRUE);
+        setLenient(true);
         set(field, get(field, status) + amount);
         pinField(UCAL_DAY_OF_MONTH, status);
-        if(oldLenient==FALSE) {
+        if(oldLenient==false) {
           complete(status); /* force recalculate */
           setLenient(oldLenient);
         }
@@ -2192,22 +2269,22 @@ void Calendar::add(UCalendarDateFields field, int32_t amount, UErrorCode& status
     case UCAL_HOUR_OF_DAY:
     case UCAL_HOUR:
         delta *= kOneHour;
-        keepWallTimeInvariant = FALSE;
+        keepWallTimeInvariant = false;
         break;
 
     case UCAL_MINUTE:
         delta *= kOneMinute;
-        keepWallTimeInvariant = FALSE;
+        keepWallTimeInvariant = false;
         break;
 
     case UCAL_SECOND:
         delta *= kOneSecond;
-        keepWallTimeInvariant = FALSE;
+        keepWallTimeInvariant = false;
         break;
 
     case UCAL_MILLISECOND:
     case UCAL_MILLISECONDS_IN_DAY:
-        keepWallTimeInvariant = FALSE;
+        keepWallTimeInvariant = false;
         break;
 
     default:
@@ -2400,7 +2477,7 @@ Calendar::adoptTimeZone(TimeZone* zone)
     fZone = zone;
 
     // if the zone changes, we need to recompute the time fields
-    fAreFieldsSet = FALSE;
+    fAreFieldsSet = false;
 }
 
 // -------------------------------------
@@ -2493,7 +2570,7 @@ Calendar::setFirstDayOfWeek(UCalendarDaysOfWeek value)
     if (fFirstDayOfWeek != value &&
         value >= UCAL_SUNDAY && value <= UCAL_SATURDAY) {
             fFirstDayOfWeek = value;
-            fAreFieldsSet = FALSE;
+            fAreFieldsSet = false;
         }
 }
 
@@ -2525,7 +2602,7 @@ Calendar::setMinimalDaysInFirstWeek(uint8_t value)
     }
     if (fMinimalDaysInFirstWeek != value) {
         fMinimalDaysInFirstWeek = value;
-        fAreFieldsSet = FALSE;
+        fAreFieldsSet = false;
     }
 }
 
@@ -2592,15 +2669,15 @@ UBool
 Calendar::isWeekend(UDate date, UErrorCode &status) const
 {
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
     // clone the calendar so we don't mess with the real one.
     Calendar *work = this->clone();
     if (work == NULL) {
         status = U_MEMORY_ALLOCATION_ERROR;
-        return FALSE;
+        return false;
     }
-    UBool result = FALSE;
+    UBool result = false;
     work->setTime(date, status);
     if (U_SUCCESS(status)) {
         result = work->isWeekend();
@@ -2618,9 +2695,9 @@ Calendar::isWeekend(void) const
     if (U_SUCCESS(status)) {
         switch (dayType) {
             case UCAL_WEEKDAY:
-                return FALSE;
+                return false;
             case UCAL_WEEKEND:
-                return TRUE;
+                return true;
             case UCAL_WEEKEND_ONSET:
             case UCAL_WEEKEND_CEASE:
                 // Use internalGet() because the above call to get() populated all fields.
@@ -2632,14 +2709,14 @@ Calendar::isWeekend(void) const
                             (millisInDay >= transitionMillis):
                             (millisInDay <  transitionMillis);
                     }
-                    // else fall through, return FALSE
+                    // else fall through, return false
                     U_FALLTHROUGH;
                 }
             default:
                 break;
         }
     }
-    return FALSE;
+    return false;
 }
 
 // ------------------------------------- limits
@@ -2745,6 +2822,9 @@ int32_t Calendar::getLimit(UCalendarDateFields field, ELimitType limitType) cons
 int32_t
 Calendar::getActualMinimum(UCalendarDateFields field, UErrorCode& status) const
 {
+    if (U_FAILURE(status)) {
+       return 0;
+    }
     int32_t fieldValue = getGreatestMinimum(field);
     int32_t endValue = getMinimum(field);
 
@@ -2760,7 +2840,7 @@ Calendar::getActualMinimum(UCalendarDateFields field, UErrorCode& status) const
         status = U_MEMORY_ALLOCATION_ERROR;
         return 0;
     }
-    work->setLenient(TRUE);
+    work->setLenient(true);
 
     // now try each value from getLeastMaximum() to getMaximum() one by one until
     // we get a value that normalizes to another value.  The last value that
@@ -2799,6 +2879,9 @@ Calendar::getActualMinimum(UCalendarDateFields field, UErrorCode& status) const
 * @see #validateField(int)
 */
 void Calendar::validateFields(UErrorCode &status) {
+    if (U_FAILURE(status)) {
+       return;
+    }
     for (int32_t field = 0; U_SUCCESS(status) && (field < UCAL_FIELD_COUNT); field++) {
         if (fStamp[field] >= kMinimumUserStamp) {
             validateField((UCalendarDateFields)field, status);
@@ -2814,6 +2897,9 @@ void Calendar::validateFields(UErrorCode &status) {
 * @see #validateField(int, int, int)
 */
 void Calendar::validateField(UCalendarDateFields field, UErrorCode &status) {
+    if (U_FAILURE(status)) {
+       return;
+    }
     int32_t y;
     switch (field) {
     case UCAL_DAY_OF_MONTH:
@@ -2850,6 +2936,9 @@ void Calendar::validateField(UCalendarDateFields field, UErrorCode &status) {
 */
 void Calendar::validateField(UCalendarDateFields field, int32_t min, int32_t max, UErrorCode& status)
 {
+    if (U_FAILURE(status)) {
+       return;
+    }
     int32_t value = fFields[field];
     if (value < min || value > max) {
 #if defined (U_DEBUG_CAL)
@@ -2972,6 +3061,9 @@ const UFieldResolutionTable Calendar::kYearPrecedence[] =
 
 
 void Calendar::computeTime(UErrorCode& status) {
+    if (U_FAILURE(status)) {
+       return;
+    }
     if (!isLenient()) {
         validateFields(status);
         if (U_FAILURE(status)) {
@@ -3050,7 +3142,7 @@ void Calendar::computeTime(UErrorCode& status) {
             UDate tmpTime = millis + millisInDay - zoneOffset;
 
             int32_t raw, dst;
-            fZone->getOffset(tmpTime, FALSE, raw, dst, status);
+            fZone->getOffset(tmpTime, false, raw, dst, status);
 
             if (U_SUCCESS(status)) {
                 // zoneOffset != (raw + dst) only when the given wall time fall into
@@ -3086,13 +3178,16 @@ void Calendar::computeTime(UErrorCode& status) {
  * Find the previous zone transition near the given time.
  */
 UBool Calendar::getImmediatePreviousZoneTransition(UDate base, UDate *transitionTime, UErrorCode& status) const {
+    if (U_FAILURE(status)) {
+       return false;
+    }
     BasicTimeZone *btz = getBasicTimeZone();
     if (btz) {
         TimeZoneTransition trans;
-        UBool hasTransition = btz->getPreviousTransition(base, TRUE, trans);
+        UBool hasTransition = btz->getPreviousTransition(base, true, trans);
         if (hasTransition) {
             *transitionTime = trans.getTime();
-            return TRUE;
+            return true;
         } else {
             // Could not find any transitions.
             // Note: This should never happen.
@@ -3103,7 +3198,7 @@ UBool Calendar::getImmediatePreviousZoneTransition(UDate base, UDate *transition
         // TODO: We may support non-BasicTimeZone in future.
         status = U_UNSUPPORTED_ERROR;
     }
-    return FALSE;
+    return false;
 }
 
 /**
@@ -3159,6 +3254,9 @@ double Calendar::computeMillisInDay() {
 * @stable ICU 2.0
 */
 int32_t Calendar::computeZoneOffset(double millis, double millisInDay, UErrorCode &ec) {
+    if (U_FAILURE(ec)) {
+       return 0;
+    }
     int32_t rawOffset, dstOffset;
     UDate wall = millis + millisInDay;
     BasicTimeZone* btz = getBasicTimeZone();
@@ -3169,9 +3267,9 @@ int32_t Calendar::computeZoneOffset(double millis, double millisInDay, UErrorCod
     } else {
         const TimeZone& tz = getTimeZone();
         // By default, TimeZone::getOffset behaves UCAL_WALLTIME_LAST for both.
-        tz.getOffset(wall, TRUE, rawOffset, dstOffset, ec);
+        tz.getOffset(wall, true, rawOffset, dstOffset, ec);
 
-        UBool sawRecentNegativeShift = FALSE;
+        UBool sawRecentNegativeShift = false;
         if (fRepeatedWallTime == UCAL_WALLTIME_FIRST) {
             // Check if the given wall time falls into repeated time range
             UDate tgmt = wall - (rawOffset + dstOffset);
@@ -3180,16 +3278,16 @@ int32_t Calendar::computeZoneOffset(double millis, double millisInDay, UErrorCod
             // Note: The maximum historic negative zone transition is -3 hours in the tz database.
             // 6 hour window would be sufficient for this purpose.
             int32_t tmpRaw, tmpDst;
-            tz.getOffset(tgmt - 6*60*60*1000, FALSE, tmpRaw, tmpDst, ec);
+            tz.getOffset(tgmt - 6*60*60*1000, false, tmpRaw, tmpDst, ec);
             int32_t offsetDelta = (rawOffset + dstOffset) - (tmpRaw + tmpDst);
 
             U_ASSERT(offsetDelta < -6*60*60*1000);
             if (offsetDelta < 0) {
-                sawRecentNegativeShift = TRUE;
+                sawRecentNegativeShift = true;
                 // Negative shift within last 6 hours. When UCAL_WALLTIME_FIRST is used and the given wall time falls
                 // into the repeated time range, use offsets before the transition.
                 // Note: If it does not fall into the repeated time range, offsets remain unchanged below.
-                tz.getOffset(wall + offsetDelta, TRUE, rawOffset, dstOffset, ec);
+                tz.getOffset(wall + offsetDelta, true, rawOffset, dstOffset, ec);
             }
         }
         if (!sawRecentNegativeShift && fSkippedWallTime == UCAL_WALLTIME_FIRST) {
@@ -3199,7 +3297,7 @@ int32_t Calendar::computeZoneOffset(double millis, double millisInDay, UErrorCod
             // the offsets will be based on the zone offsets AFTER
             // the transition (which means, earliest possible interpretation).
             UDate tgmt = wall - (rawOffset + dstOffset);
-            tz.getOffset(tgmt, FALSE, rawOffset, dstOffset, ec);
+            tz.getOffset(tgmt, false, rawOffset, dstOffset, ec);
         }
     }
     return rawOffset + dstOffset;
@@ -3343,7 +3441,7 @@ int32_t Calendar::handleComputeJulianDay(UCalendarDateFields bestField)  {
                 // need to be sure to stay in 'real' year.
                 int32_t woy = internalGet(bestField);
 
-                int32_t nextJulianDay = handleComputeMonthStart(year+1, 0, FALSE); // jd of day before jan 1
+                int32_t nextJulianDay = handleComputeMonthStart(year+1, 0, false); // jd of day before jan 1
                 int32_t nextFirst = julianDayToDayOfWeek(nextJulianDay + 1) - firstDayOfWeek;
 
                 if (nextFirst < 0) { // 0..6 ldow of Jan 1
@@ -3394,7 +3492,7 @@ int32_t Calendar::handleComputeJulianDay(UCalendarDateFields bestField)  {
 #endif
                     if(julianDay+testDate > nextJulianDay) { // is it past Dec 31?  (nextJulianDay is day BEFORE year+1's  Jan 1)
                         // Fire up the calculating engines.. retry YWOY = (year-1)
-                        julianDay = handleComputeMonthStart(year-1, 0, FALSE); // jd before Jan 1 of previous year
+                        julianDay = handleComputeMonthStart(year-1, 0, false); // jd before Jan 1 of previous year
                         first = julianDayToDayOfWeek(julianDay + 1) - firstDayOfWeek; // 0 based local dow   of first week
 
                         if(first < 0) { // 0..6
@@ -3474,8 +3572,8 @@ int32_t Calendar::handleGetExtendedYearFromWeekFields(int32_t yearWoy, int32_t w
     // Now, a local DOW
     int32_t dowLocal = getLocalDOW(); // 0..6
     int32_t firstDayOfWeek = getFirstDayOfWeek(); // Localized fdw
-    int32_t jan1Start = handleComputeMonthStart(yearWoy, 0, FALSE);
-    int32_t nextJan1Start = handleComputeMonthStart(yearWoy+1, 0, FALSE); // next year's Jan1 start
+    int32_t jan1Start = handleComputeMonthStart(yearWoy, 0, false);
+    int32_t nextJan1Start = handleComputeMonthStart(yearWoy+1, 0, false); // next year's Jan1 start
 
     // At this point julianDay is the 0-based day BEFORE the first day of
     // January 1, year 1 of the given calendar.  If julianDay == 0, it
@@ -3501,21 +3599,21 @@ int32_t Calendar::handleGetExtendedYearFromWeekFields(int32_t yearWoy, int32_t w
     //}
 
     int32_t minDays = getMinimalDaysInFirstWeek();
-    UBool jan1InPrevYear = FALSE;  // January 1st in the year of WOY is the 1st week?  (i.e. first week is < minimal )
-    //UBool nextJan1InPrevYear = FALSE; // January 1st of Year of WOY + 1 is in the first week?
+    UBool jan1InPrevYear = false;  // January 1st in the year of WOY is the 1st week?  (i.e. first week is < minimal )
+    //UBool nextJan1InPrevYear = false; // January 1st of Year of WOY + 1 is in the first week?
 
     if((7 - first) < minDays) {
-        jan1InPrevYear = TRUE;
+        jan1InPrevYear = true;
     }
 
     //   if((7 - nextFirst) < minDays) {
-    //     nextJan1InPrevYear = TRUE;
+    //     nextJan1InPrevYear = true;
     //   }
 
     switch(bestField) {
     case UCAL_WEEK_OF_YEAR:
         if(woy == 1) {
-            if(jan1InPrevYear == TRUE) {
+            if(jan1InPrevYear == true) {
                 // the first week of January is in the previous year
                 // therefore WOY1 is always solidly within yearWoy
                 return yearWoy;
@@ -3534,7 +3632,7 @@ int32_t Calendar::handleGetExtendedYearFromWeekFields(int32_t yearWoy, int32_t w
                 (7-first) + //  days in the first week (Jan 1.. )
                 (woy-1)*7 + // add the weeks of the year
                 dowLocal;   // the local dow (0..6) of last week
-            if(jan1InPrevYear==FALSE) {
+            if(jan1InPrevYear==false) {
                 jd -= 7; // woy already includes Jan 1's week.
             }
 
@@ -3576,18 +3674,21 @@ int32_t Calendar::handleGetExtendedYearFromWeekFields(int32_t yearWoy, int32_t w
 
 int32_t Calendar::handleGetMonthLength(int32_t extendedYear, int32_t month) const
 {
-    return handleComputeMonthStart(extendedYear, month+1, TRUE) -
-        handleComputeMonthStart(extendedYear, month, TRUE);
+    return handleComputeMonthStart(extendedYear, month+1, true) -
+        handleComputeMonthStart(extendedYear, month, true);
 }
 
 int32_t Calendar::handleGetYearLength(int32_t eyear) const  {
-    return handleComputeMonthStart(eyear+1, 0, FALSE) -
-        handleComputeMonthStart(eyear, 0, FALSE);
+    return handleComputeMonthStart(eyear+1, 0, false) -
+        handleComputeMonthStart(eyear, 0, false);
 }
 
 int32_t
 Calendar::getActualMaximum(UCalendarDateFields field, UErrorCode& status) const
 {
+    if (U_FAILURE(status)) {
+       return 0;
+    }
     int32_t result;
     switch (field) {
     case UCAL_DATE:
@@ -3595,8 +3696,8 @@ Calendar::getActualMaximum(UCalendarDateFields field, UErrorCode& status) const
             if(U_FAILURE(status)) return 0;
             Calendar *cal = clone();
             if(!cal) { status = U_MEMORY_ALLOCATION_ERROR; return 0; }
-            cal->setLenient(TRUE);
-            cal->prepareGetActual(field,FALSE,status);
+            cal->setLenient(true);
+            cal->prepareGetActual(field,false,status);
             result = handleGetMonthLength(cal->get(UCAL_EXTENDED_YEAR, status), cal->get(UCAL_MONTH, status));
             delete cal;
         }
@@ -3607,8 +3708,8 @@ Calendar::getActualMaximum(UCalendarDateFields field, UErrorCode& status) const
             if(U_FAILURE(status)) return 0;
             Calendar *cal = clone();
             if(!cal) { status = U_MEMORY_ALLOCATION_ERROR; return 0; }
-            cal->setLenient(TRUE);
-            cal->prepareGetActual(field,FALSE,status);
+            cal->setLenient(true);
+            cal->prepareGetActual(field,false,status);
             result = handleGetYearLength(cal->get(UCAL_EXTENDED_YEAR, status));
             delete cal;
         }
@@ -3662,6 +3763,9 @@ Calendar::getActualMaximum(UCalendarDateFields field, UErrorCode& status) const
 */
 void Calendar::prepareGetActual(UCalendarDateFields field, UBool isMinimum, UErrorCode &status)
 {
+    if (U_FAILURE(status)) {
+       return;
+    }
     set(UCAL_MILLISECONDS_IN_DAY, 0);
 
     switch (field) {
@@ -3717,6 +3821,9 @@ int32_t Calendar::getActualHelper(UCalendarDateFields field, int32_t startValue,
 #if defined (U_DEBUG_CAL)
     fprintf(stderr, "getActualHelper(%d,%d .. %d, %s)\n", field, startValue, endValue, u_errorName(status));
 #endif
+    if (U_FAILURE(status)) {
+       return 0;
+    }
     if (startValue == endValue) {
         // if we know that the maximum value is always the same, just return it
         return startValue;
@@ -3734,7 +3841,7 @@ int32_t Calendar::getActualHelper(UCalendarDateFields field, int32_t startValue,
     // may cause conflict with fields previously set (but not yet resolved).
     work->complete(status);
 
-    work->setLenient(TRUE);
+    work->setLenient(true);
     work->prepareGetActual(field, delta < 0, status);
 
     // now try each value from the start to the end one by one until
@@ -3850,7 +3957,7 @@ Calendar::setWeekData(const Locale& desiredLocale, const char *type, UErrorCode&
     }
 
     char region[ULOC_COUNTRY_CAPACITY];
-    (void)ulocimp_getRegionForSupplementalData(desiredLocale.getName(), TRUE, region, sizeof(region), &status);
+    (void)ulocimp_getRegionForSupplementalData(desiredLocale.getName(), true, region, sizeof(region), &status);
 
     // Read week data values from supplementalData week data
     UResourceBundle *rb = ures_openDirect(NULL, "supplementalData", &status);
@@ -3901,10 +4008,10 @@ Calendar::updateTime(UErrorCode& status)
     // the values.  Also, if we haven't set all the fields yet (i.e.,
     // in a newly-created object), we need to fill in the fields. [LIU]
     if (isLenient() || ! fAreAllFieldsSet)
-        fAreFieldsSet = FALSE;
+        fAreFieldsSet = false;
 
-    fIsTimeSet = TRUE;
-    fAreFieldsVirtuallySet = FALSE;
+    fIsTimeSet = true;
+    fAreFieldsVirtuallySet = false;
 }
 
 Locale
diff --git a/deps/icu-small/source/i18n/casetrn.cpp b/deps/icu-small/source/i18n/casetrn.cpp
index bb650f8fa2..a065330cac 100644
--- a/deps/icu-small/source/i18n/casetrn.cpp
+++ b/deps/icu-small/source/i18n/casetrn.cpp
@@ -71,13 +71,13 @@ utrans_rep_caseContextIterator(void *context, int8_t dir)
             c=rep->char32At(csc->index);
             if(c<0) {
                 csc->limit=csc->index;
-                csc->b1=TRUE;
+                csc->b1=true;
             } else {
                 csc->index+=U16_LENGTH(c);
                 return c;
             }
         } else {
-            csc->b1=TRUE;
+            csc->b1=true;
         }
     }
     return U_SENTINEL;
@@ -170,7 +170,7 @@ void CaseMapTransliterator::handleTransliterate(Replaceable& text,
             // see UCASE_MAX_STRING_LENGTH
             if(result<=UCASE_MAX_STRING_LENGTH) {
                 // string s[result]
-                tmp.setTo(FALSE, s, result);
+                tmp.setTo(false, s, result);
                 delta=result-U16_LENGTH(c);
             } else {
                 // single code point
diff --git a/deps/icu-small/source/i18n/cecal.cpp b/deps/icu-small/source/i18n/cecal.cpp
index cb97c40a3c..60e3d4b265 100644
--- a/deps/icu-small/source/i18n/cecal.cpp
+++ b/deps/icu-small/source/i18n/cecal.cpp
@@ -90,19 +90,19 @@ UBool
 CECalendar::inDaylightTime(UErrorCode& status) const
 {
     if (U_FAILURE(status) || !getTimeZone().useDaylightTime()) {
-        return FALSE;
+        return false;
     }
 
     // Force an update of the state of the Calendar.
     ((CECalendar*)this)->complete(status); // cast away const
 
-    return (UBool)(U_SUCCESS(status) ? (internalGet(UCAL_DST_OFFSET) != 0) : FALSE);
+    return (UBool)(U_SUCCESS(status) ? (internalGet(UCAL_DST_OFFSET) != 0) : false);
 }
 
 UBool
 CECalendar::haveDefaultCentury() const
 {
-    return TRUE;
+    return true;
 }
 
 //-------------------------------------------------------------------------
@@ -135,7 +135,7 @@ CECalendar::jdToCE(int32_t julianDay, int32_t jdEpochOffset, int32_t& year, int3
     int32_t c4; // number of 4 year cycle (1461 days)
     int32_t r4; // remainder of 4 year cycle, always positive
 
-    c4 = ClockMath::floorDivide(julianDay - jdEpochOffset, 1461, r4);
+    c4 = ClockMath::floorDivide(julianDay - jdEpochOffset, 1461, &r4);
 
     year = 4 * c4 + (r4/365 - r4/1460); // 4 * <number of 4year cycle> + <years within the last cycle>
 
diff --git a/deps/icu-small/source/i18n/chnsecal.cpp b/deps/icu-small/source/i18n/chnsecal.cpp
index f8fb4a40f1..e48c90eb5a 100644
--- a/deps/icu-small/source/i18n/chnsecal.cpp
+++ b/deps/icu-small/source/i18n/chnsecal.cpp
@@ -59,7 +59,7 @@ static icu::CalendarCache *gChineseCalendarWinterSolsticeCache = NULL;
 static icu::CalendarCache *gChineseCalendarNewYearCache = NULL;
 
 static icu::TimeZone *gChineseCalendarZoneAstroCalc = NULL;
-static icu::UInitOnce gChineseCalendarZoneAstroCalcInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gChineseCalendarZoneAstroCalcInitOnce {};
 
 /**
  * The start year of the Chinese calendar, the 61st year of the reign
@@ -103,7 +103,7 @@ static UBool calendar_chinese_cleanup(void) {
         gChineseCalendarZoneAstroCalc = NULL;
     }
     gChineseCalendarZoneAstroCalcInitOnce.reset();
-    return TRUE;
+    return true;
 }
 U_CDECL_END
 
@@ -124,7 +124,7 @@ ChineseCalendar* ChineseCalendar::clone() const {
 
 ChineseCalendar::ChineseCalendar(const Locale& aLocale, UErrorCode& success)
 :   Calendar(TimeZone::forLocaleOrDefault(aLocale), aLocale, success),
-    isLeapYear(FALSE),
+    isLeapYear(false),
     fEpochYear(CHINESE_EPOCH_YEAR),
     fZoneAstroCalc(getChineseCalZoneAstroCalc())
 {
@@ -134,7 +134,7 @@ ChineseCalendar::ChineseCalendar(const Locale& aLocale, UErrorCode& success)
 ChineseCalendar::ChineseCalendar(const Locale& aLocale, int32_t epochYear,
                                 const TimeZone* zoneAstroCalc, UErrorCode &success)
 :   Calendar(TimeZone::forLocaleOrDefault(aLocale), aLocale, success),
-    isLeapYear(FALSE),
+    isLeapYear(false),
     fEpochYear(epochYear),
     fZoneAstroCalc(zoneAstroCalc)
 {
@@ -239,9 +239,9 @@ int32_t ChineseCalendar::handleGetExtendedYear() {
  * @stable ICU 2.8
  */
 int32_t ChineseCalendar::handleGetMonthLength(int32_t extendedYear, int32_t month) const {
-    int32_t thisStart = handleComputeMonthStart(extendedYear, month, TRUE) -
+    int32_t thisStart = handleComputeMonthStart(extendedYear, month, true) -
         kEpochStartAsJulianDay + 1; // Julian day -> local days
-    int32_t nextStart = newMoonNear(thisStart + SYNODIC_GAP, TRUE);
+    int32_t nextStart = newMoonNear(thisStart + SYNODIC_GAP, true);
     return nextStart - thisStart;
 }
 
@@ -267,7 +267,7 @@ void ChineseCalendar::handleComputeFields(int32_t julianDay, UErrorCode &/*statu
 
     computeChineseFields(julianDay - kEpochStartAsJulianDay, // local days
                          getGregorianYear(), getGregorianMonth(),
-                         TRUE); // set all fields
+                         true); // set all fields
 }
 
 /**
@@ -328,13 +328,13 @@ int32_t ChineseCalendar::handleComputeMonthStart(int32_t eyear, int32_t month, U
     // modify the extended year value accordingly.
     if (month < 0 || month > 11) {
         double m = month;
-        eyear += (int32_t)ClockMath::floorDivide(m, 12.0, m);
+        eyear += (int32_t)ClockMath::floorDivide(m, 12.0, &m);
         month = (int32_t)m;
     }
 
     int32_t gyear = eyear + fEpochYear - 1; // Gregorian year
     int32_t theNewYear = newYear(gyear);
-    int32_t newMoon = newMoonNear(theNewYear + month * 29, TRUE);
+    int32_t newMoon = newMoonNear(theNewYear + month * 29, true);
     
     int32_t julianDay = newMoon + kEpochStartAsJulianDay;
 
@@ -352,11 +352,11 @@ int32_t ChineseCalendar::handleComputeMonthStart(int32_t eyear, int32_t month, U
     
     // This will modify the MONTH and IS_LEAP_MONTH fields (only)
     nonConstThis->computeChineseFields(newMoon, getGregorianYear(),
-                         getGregorianMonth(), FALSE);        
+                         getGregorianMonth(), false);        
 
     if (month != internalGet(UCAL_MONTH) ||
         isLeapMonth != internalGet(UCAL_IS_LEAP_MONTH)) {
-        newMoon = newMoonNear(newMoon + SYNODIC_GAP, TRUE);
+        newMoon = newMoonNear(newMoon + SYNODIC_GAP, true);
         julianDay = newMoon + kEpochStartAsJulianDay;
     }
 
@@ -432,7 +432,7 @@ void ChineseCalendar::roll(UCalendarDateFields field, int32_t amount, UErrorCode
                     // otherwise it will be the start of month 1.
                     int moon1 = moon -
                         (int) (CalendarAstronomer::SYNODIC_MONTH * (m - 0.5));
-                    moon1 = newMoonNear(moon1, TRUE);
+                    moon1 = newMoonNear(moon1, true);
                     if (isLeapMonthBetween(moon1, moon)) {
                         ++m;
                     }
@@ -485,7 +485,7 @@ double ChineseCalendar::daysToMillis(double days) const {
     if (fZoneAstroCalc != NULL) {
         int32_t rawOffset, dstOffset;
         UErrorCode status = U_ZERO_ERROR;
-        fZoneAstroCalc->getOffset(millis, FALSE, rawOffset, dstOffset, status);
+        fZoneAstroCalc->getOffset(millis, false, rawOffset, dstOffset, status);
         if (U_SUCCESS(status)) {
         	return millis - (double)(rawOffset + dstOffset);
         }
@@ -502,7 +502,7 @@ double ChineseCalendar::millisToDays(double millis) const {
     if (fZoneAstroCalc != NULL) {
         int32_t rawOffset, dstOffset;
         UErrorCode status = U_ZERO_ERROR;
-        fZoneAstroCalc->getOffset(millis, FALSE, rawOffset, dstOffset, status);
+        fZoneAstroCalc->getOffset(millis, false, rawOffset, dstOffset, status);
         if (U_SUCCESS(status)) {
         	return ClockMath::floorDivide(millis + (double)(rawOffset + dstOffset), kOneDay);
         }
@@ -541,7 +541,7 @@ int32_t ChineseCalendar::winterSolstice(int32_t gyear) const {
             ucln_i18n_registerCleanup(UCLN_I18N_CHINESE_CALENDAR, calendar_chinese_cleanup);
         }
         gChineseCalendarAstro->setTime(ms);
-        UDate solarLong = gChineseCalendarAstro->getSunTime(CalendarAstronomer::WINTER_SOLSTICE(), TRUE);
+        UDate solarLong = gChineseCalendarAstro->getSunTime(CalendarAstronomer::WINTER_SOLSTICE(), true);
         umtx_unlock(&astroLock);
 
         // Winter solstice is 270 degrees solar longitude aka Dongzhi
@@ -621,7 +621,7 @@ int32_t ChineseCalendar::majorSolarTerm(int32_t days) const {
  */
 UBool ChineseCalendar::hasNoMajorSolarTerm(int32_t newMoon) const {
     return majorSolarTerm(newMoon) ==
-        majorSolarTerm(newMoonNear(newMoon + SYNODIC_GAP, TRUE));
+        majorSolarTerm(newMoonNear(newMoon + SYNODIC_GAP, true));
 }
 
 
@@ -650,7 +650,7 @@ UBool ChineseCalendar::isLeapMonthBetween(int32_t newMoon1, int32_t newMoon2) co
 #endif
 
     return (newMoon2 >= newMoon1) &&
-        (isLeapMonthBetween(newMoon1, newMoonNear(newMoon2 - SYNODIC_GAP, FALSE)) ||
+        (isLeapMonthBetween(newMoon1, newMoonNear(newMoon2 - SYNODIC_GAP, false)) ||
          hasNoMajorSolarTerm(newMoon2));
 }
 
@@ -689,9 +689,9 @@ void ChineseCalendar::computeChineseFields(int32_t days, int32_t gyear, int32_t
     // Find the start of the month after month 11.  This will be either
     // the prior month 12 or leap month 11 (very rare).  Also find the
     // start of the following month 11.
-    int32_t firstMoon = newMoonNear(solsticeBefore + 1, TRUE);
-    int32_t lastMoon = newMoonNear(solsticeAfter + 1, FALSE);
-    int32_t thisMoon = newMoonNear(days + 1, FALSE); // Start of this month
+    int32_t firstMoon = newMoonNear(solsticeBefore + 1, true);
+    int32_t lastMoon = newMoonNear(solsticeAfter + 1, false);
+    int32_t thisMoon = newMoonNear(days + 1, false); // Start of this month
     // Note: isLeapYear is a member variable
     isLeapYear = synodicMonthsBetween(firstMoon, lastMoon) == 12;
 
@@ -705,7 +705,7 @@ void ChineseCalendar::computeChineseFields(int32_t days, int32_t gyear, int32_t
 
     UBool isLeapMonth = isLeapYear &&
         hasNoMajorSolarTerm(thisMoon) &&
-        !isLeapMonthBetween(firstMoon, newMoonNear(thisMoon - SYNODIC_GAP, FALSE));
+        !isLeapMonthBetween(firstMoon, newMoonNear(thisMoon - SYNODIC_GAP, false));
 
     internalSet(UCAL_MONTH, month-1); // Convert from 1-based to 0-based
     internalSet(UCAL_IS_LEAP_MONTH, isLeapMonth?1:0);
@@ -727,7 +727,7 @@ void ChineseCalendar::computeChineseFields(int32_t days, int32_t gyear, int32_t
 
         // 0->0,60  1->1,1  60->1,60  61->2,1  etc.
         int32_t yearOfCycle;
-        int32_t cycle = ClockMath::floorDivide(cycle_year - 1, 60, yearOfCycle);
+        int32_t cycle = ClockMath::floorDivide(cycle_year - 1, 60, &yearOfCycle);
         internalSet(UCAL_ERA, cycle + 1);
         internalSet(UCAL_YEAR, yearOfCycle + 1);
 
@@ -764,13 +764,13 @@ int32_t ChineseCalendar::newYear(int32_t gyear) const {
 
         int32_t solsticeBefore= winterSolstice(gyear - 1);
         int32_t solsticeAfter = winterSolstice(gyear);
-        int32_t newMoon1 = newMoonNear(solsticeBefore + 1, TRUE);
-        int32_t newMoon2 = newMoonNear(newMoon1 + SYNODIC_GAP, TRUE);
-        int32_t newMoon11 = newMoonNear(solsticeAfter + 1, FALSE);
+        int32_t newMoon1 = newMoonNear(solsticeBefore + 1, true);
+        int32_t newMoon2 = newMoonNear(newMoon1 + SYNODIC_GAP, true);
+        int32_t newMoon11 = newMoonNear(solsticeAfter + 1, false);
         
         if (synodicMonthsBetween(newMoon1, newMoon11) == 12 &&
             (hasNoMajorSolarTerm(newMoon1) || hasNoMajorSolarTerm(newMoon2))) {
-            cacheValue = newMoonNear(newMoon2 + SYNODIC_GAP, TRUE);
+            cacheValue = newMoonNear(newMoon2 + SYNODIC_GAP, true);
         } else {
             cacheValue = newMoon2;
         }
@@ -801,7 +801,7 @@ void ChineseCalendar::offsetMonth(int32_t newMoon, int32_t dom, int32_t delta) {
     newMoon += (int32_t) (CalendarAstronomer::SYNODIC_MONTH * (delta - 0.5));
 
     // Search forward to the target month's new moon
-    newMoon = newMoonNear(newMoon, TRUE);
+    newMoon = newMoonNear(newMoon, true);
 
     // Find the target dom
     int32_t jd = newMoon + kEpochStartAsJulianDay - 1 + dom;
@@ -831,24 +831,24 @@ ChineseCalendar::inDaylightTime(UErrorCode& status) const
 {
     // copied from GregorianCalendar
     if (U_FAILURE(status) || !getTimeZone().useDaylightTime()) 
-        return FALSE;
+        return false;
 
     // Force an update of the state of the Calendar.
     ((ChineseCalendar*)this)->complete(status); // cast away const
 
-    return (UBool)(U_SUCCESS(status) ? (internalGet(UCAL_DST_OFFSET) != 0) : FALSE);
+    return (UBool)(U_SUCCESS(status) ? (internalGet(UCAL_DST_OFFSET) != 0) : false);
 }
 
 // default century
 
 static UDate     gSystemDefaultCenturyStart       = DBL_MIN;
 static int32_t   gSystemDefaultCenturyStartYear   = -1;
-static icu::UInitOnce gSystemDefaultCenturyInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gSystemDefaultCenturyInitOnce {};
 
 
 UBool ChineseCalendar::haveDefaultCentury() const
 {
-    return TRUE;
+    return true;
 }
 
 UDate ChineseCalendar::defaultCenturyStart() const
diff --git a/deps/icu-small/source/i18n/chnsecal.h b/deps/icu-small/source/i18n/chnsecal.h
index 61ef2d3cad..488fe169d9 100644
--- a/deps/icu-small/source/i18n/chnsecal.h
+++ b/deps/icu-small/source/i18n/chnsecal.h
@@ -274,7 +274,7 @@ class U_I18N_API ChineseCalendar : public Calendar {
    */
   int32_t          internalGetDefaultCenturyStartYear(void) const;
 
-  ChineseCalendar(); // default constructor not implemented
+  ChineseCalendar() = delete; // default constructor not implemented
 };
 
 U_NAMESPACE_END
diff --git a/deps/icu-small/source/i18n/coleitr.cpp b/deps/icu-small/source/i18n/coleitr.cpp
index 48c1da9015..0503950273 100644
--- a/deps/icu-small/source/i18n/coleitr.cpp
+++ b/deps/icu-small/source/i18n/coleitr.cpp
@@ -440,7 +440,7 @@ CollationElementIterator::computeMaxExpansions(const CollationData *data, UError
                                            uhash_compareLong, &errorCode);
     if (U_FAILURE(errorCode)) { return NULL; }
     MaxExpSink sink(maxExpansions, errorCode);
-    ContractionsAndExpansions(NULL, NULL, &sink, TRUE).forData(data, errorCode);
+    ContractionsAndExpansions(NULL, NULL, &sink, true).forData(data, errorCode);
     if (U_FAILURE(errorCode)) {
         uhash_close(maxExpansions);
         return NULL;
diff --git a/deps/icu-small/source/i18n/coll.cpp b/deps/icu-small/source/i18n/coll.cpp
index fe73118da0..b22a9d5876 100644
--- a/deps/icu-small/source/i18n/coll.cpp
+++ b/deps/icu-small/source/i18n/coll.cpp
@@ -65,9 +65,9 @@ static icu::Locale* availableLocaleList = NULL;
 static int32_t  availableLocaleListCount;
 #if !UCONFIG_NO_SERVICE
 static icu::ICULocaleService* gService = NULL;
-static icu::UInitOnce gServiceInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gServiceInitOnce {};
 #endif
-static icu::UInitOnce gAvailableLocaleListInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gAvailableLocaleListInitOnce {};
 
 /**
  * Release all static memory held by collator.
@@ -87,7 +87,7 @@ static UBool U_CALLCONV collator_cleanup(void) {
     }
     availableLocaleListCount = 0;
     gAvailableLocaleListInitOnce.reset();
-    return TRUE;
+    return true;
 }
 
 U_CDECL_END
@@ -109,7 +109,7 @@ CollatorFactory::~CollatorFactory() {}
 
 UBool
 CollatorFactory::visible(void) const {
-    return TRUE;
+    return true;
 }
 
 //-------------------------------------------
@@ -372,7 +372,7 @@ void setAttributesFromKeywords(const Locale &loc, Collator &coll, UErrorCode &er
         return;
     }
     if (length != 0) {
-        int32_t codes[USCRIPT_CODE_LIMIT + UCOL_REORDER_CODE_LIMIT - UCOL_REORDER_CODE_FIRST];
+        int32_t codes[USCRIPT_CODE_LIMIT + (UCOL_REORDER_CODE_LIMIT - UCOL_REORDER_CODE_FIRST)];
         int32_t codesLength = 0;
         char *scriptName = value;
         for (;;) {
@@ -794,7 +794,7 @@ Collator::unregister(URegistryKey key, UErrorCode& status)
         }
         status = U_ILLEGAL_ARGUMENT_ERROR;
     }
-    return FALSE;
+    return false;
 }
 #endif /* UCONFIG_NO_SERVICE */
 
diff --git a/deps/icu-small/source/i18n/collation.cpp b/deps/icu-small/source/i18n/collation.cpp
index 14cb86576b..705ee12e23 100644
--- a/deps/icu-small/source/i18n/collation.cpp
+++ b/deps/icu-small/source/i18n/collation.cpp
@@ -20,15 +20,6 @@
 
 U_NAMESPACE_BEGIN
 
-// Some compilers don't care if constants are defined in the .cpp file.
-// MS Visual C++ does not like it, but gcc requires it. clang does not care.
-#ifndef _MSC_VER
-const uint8_t Collation::LEVEL_SEPARATOR_BYTE;
-const uint8_t Collation::MERGE_SEPARATOR_BYTE;
-const uint32_t Collation::ONLY_TERTIARY_MASK;
-const uint32_t Collation::CASE_AND_TERTIARY_MASK;
-#endif
-
 uint32_t
 Collation::incTwoBytePrimaryByOffset(uint32_t basePrimary, UBool isCompressible, int32_t offset) {
     // Extract the second byte, minus the minimum byte value,
diff --git a/deps/icu-small/source/i18n/collation.h b/deps/icu-small/source/i18n/collation.h
index 6a449a3eb6..2062ef2946 100644
--- a/deps/icu-small/source/i18n/collation.h
+++ b/deps/icu-small/source/i18n/collation.h
@@ -221,7 +221,8 @@ public:
         /**
          * Points to contraction data.
          * Bits 31..13: Index into prefix/contraction data.
-         * Bits 12..11: Unused, 0.
+         * Bit      12: Unused, 0.
+         * Bit      11: CONTRACT_HAS_STARTER flag. (Used by ICU4X only.)
          * Bit      10: CONTRACT_TRAILING_CCC flag.
          * Bit       9: CONTRACT_NEXT_CCC flag.
          * Bit       8: CONTRACT_SINGLE_CP_NO_MATCH flag.
@@ -298,6 +299,8 @@ public:
     static const uint32_t CONTRACT_NEXT_CCC = 0x200;
     /** Set if any contraction suffix ends with lccc!=0. */
     static const uint32_t CONTRACT_TRAILING_CCC = 0x400;
+    /** Set if any contraction suffix contains a starter. (Used by ICU4X only.) */
+    static const uint32_t CONTRACT_HAS_STARTER = 0x800;
 
     /** For HANGUL_TAG: None of its Jamo CE32s isSpecialCE32(). */
     static const uint32_t HANGUL_NO_SPECIAL_JAMO = 0x100;
@@ -491,7 +494,7 @@ public:
     }
 
 private:
-    Collation();  // No instantiation.
+    Collation() = delete;  // No instantiation.
 };
 
 U_NAMESPACE_END
diff --git a/deps/icu-small/source/i18n/collationbuilder.cpp b/deps/icu-small/source/i18n/collationbuilder.cpp
index 5d4611b851..fbf09a313d 100644
--- a/deps/icu-small/source/i18n/collationbuilder.cpp
+++ b/deps/icu-small/source/i18n/collationbuilder.cpp
@@ -89,7 +89,7 @@ RuleBasedCollator::RuleBasedCollator()
           cacheEntry(NULL),
           validLocale(""),
           explicitlySetAttributes(0),
-          actualLocaleIsSameAsValid(FALSE) {
+          actualLocaleIsSameAsValid(false) {
 }
 
 RuleBasedCollator::RuleBasedCollator(const UnicodeString &rules, UErrorCode &errorCode)
@@ -99,7 +99,7 @@ RuleBasedCollator::RuleBasedCollator(const UnicodeString &rules, UErrorCode &err
           cacheEntry(NULL),
           validLocale(""),
           explicitlySetAttributes(0),
-          actualLocaleIsSameAsValid(FALSE) {
+          actualLocaleIsSameAsValid(false) {
     internalBuildTailoring(rules, UCOL_DEFAULT, UCOL_DEFAULT, NULL, NULL, errorCode);
 }
 
@@ -111,7 +111,7 @@ RuleBasedCollator::RuleBasedCollator(const UnicodeString &rules, ECollationStren
           cacheEntry(NULL),
           validLocale(""),
           explicitlySetAttributes(0),
-          actualLocaleIsSameAsValid(FALSE) {
+          actualLocaleIsSameAsValid(false) {
     internalBuildTailoring(rules, strength, UCOL_DEFAULT, NULL, NULL, errorCode);
 }
 
@@ -124,7 +124,7 @@ RuleBasedCollator::RuleBasedCollator(const UnicodeString &rules,
           cacheEntry(NULL),
           validLocale(""),
           explicitlySetAttributes(0),
-          actualLocaleIsSameAsValid(FALSE) {
+          actualLocaleIsSameAsValid(false) {
     internalBuildTailoring(rules, UCOL_DEFAULT, decompositionMode, NULL, NULL, errorCode);
 }
 
@@ -138,7 +138,7 @@ RuleBasedCollator::RuleBasedCollator(const UnicodeString &rules,
           cacheEntry(NULL),
           validLocale(""),
           explicitlySetAttributes(0),
-          actualLocaleIsSameAsValid(FALSE) {
+          actualLocaleIsSameAsValid(false) {
     internalBuildTailoring(rules, strength, decompositionMode, NULL, NULL, errorCode);
 }
 
@@ -151,7 +151,7 @@ RuleBasedCollator::RuleBasedCollator(const UnicodeString &rules,
           cacheEntry(NULL),
           validLocale(""),
           explicitlySetAttributes(0),
-          actualLocaleIsSameAsValid(FALSE) {
+          actualLocaleIsSameAsValid(false) {
     internalBuildTailoring(rules, UCOL_DEFAULT, UCOL_DEFAULT, &parseError, &reason, errorCode);
 }
 
@@ -191,14 +191,7 @@ RuleBasedCollator::internalBuildTailoring(const UnicodeString &rules,
 
 // CollationBuilder implementation ----------------------------------------- ***
 
-// Some compilers don't care if constants are defined in the .cpp file.
-// MS Visual C++ does not like it, but gcc requires it. clang does not care.
-#ifndef _MSC_VER
-const int32_t CollationBuilder::HAS_BEFORE2;
-const int32_t CollationBuilder::HAS_BEFORE3;
-#endif
-
-CollationBuilder::CollationBuilder(const CollationTailoring *b, UErrorCode &errorCode)
+CollationBuilder::CollationBuilder(const CollationTailoring *b, UBool icu4xMode, UErrorCode &errorCode)
         : nfd(*Normalizer2::getNFDInstance(errorCode)),
           fcd(*Normalizer2Factory::getFCDInstance(errorCode)),
           nfcImpl(*Normalizer2Factory::getNFCImpl(errorCode)),
@@ -206,7 +199,8 @@ CollationBuilder::CollationBuilder(const CollationTailoring *b, UErrorCode &erro
           baseData(b->data),
           rootElements(b->data->rootElements, b->data->rootElementsLength),
           variableTop(0),
-          dataBuilder(new CollationDataBuilder(errorCode)), fastLatinEnabled(TRUE),
+          dataBuilder(new CollationDataBuilder(icu4xMode, errorCode)), fastLatinEnabled(true),
+          icu4xMode(icu4xMode),
           errorReason(NULL),
           cesLength(0),
           rootPrimaryIndexes(errorCode), nodes(errorCode) {
@@ -225,6 +219,10 @@ CollationBuilder::CollationBuilder(const CollationTailoring *b, UErrorCode &erro
     }
 }
 
+CollationBuilder::CollationBuilder(const CollationTailoring *b, UErrorCode &errorCode)
+  : CollationBuilder(b, false, errorCode)
+{}
+
 CollationBuilder::~CollationBuilder() {
     delete dataBuilder;
 }
@@ -262,15 +260,19 @@ CollationBuilder::parseAndBuild(const UnicodeString &ruleString,
     if(U_FAILURE(errorCode)) { return NULL; }
     if(dataBuilder->hasMappings()) {
         makeTailoredCEs(errorCode);
-        closeOverComposites(errorCode);
+        if (!icu4xMode) {
+            closeOverComposites(errorCode);
+        }
         finalizeCEs(errorCode);
-        // Copy all of ASCII, and Latin-1 letters, into each tailoring.
-        optimizeSet.add(0, 0x7f);
-        optimizeSet.add(0xc0, 0xff);
-        // Hangul is decomposed on the fly during collation,
-        // and the tailoring data is always built with HANGUL_TAG specials.
-        optimizeSet.remove(Hangul::HANGUL_BASE, Hangul::HANGUL_END);
-        dataBuilder->optimize(optimizeSet, errorCode);
+        if (!icu4xMode) {
+            // Copy all of ASCII, and Latin-1 letters, into each tailoring.
+            optimizeSet.add(0, 0x7f);
+            optimizeSet.add(0xc0, 0xff);
+            // Hangul is decomposed on the fly during collation,
+            // and the tailoring data is always built with HANGUL_TAG specials.
+            optimizeSet.remove(Hangul::HANGUL_BASE, Hangul::HANGUL_END);
+            dataBuilder->optimize(optimizeSet, errorCode);
+        }
         tailoring->ensureOwnedData(errorCode);
         if(U_FAILURE(errorCode)) { return NULL; }
         if(fastLatinEnabled) { dataBuilder->enableFastLatin(); }
@@ -484,7 +486,7 @@ CollationBuilder::getSpecialResetPosition(const UnicodeString &str,
     U_ASSERT(str.length() == 2);
     int64_t ce;
     int32_t strength = UCOL_PRIMARY;
-    UBool isBoundary = FALSE;
+    UBool isBoundary = false;
     UChar32 pos = str.charAt(1) - CollationRuleParser::POS_BASE;
     U_ASSERT(0 <= pos && pos <= CollationRuleParser::LAST_TRAILING);
     switch(pos) {
@@ -544,14 +546,14 @@ CollationBuilder::getSpecialResetPosition(const UnicodeString &str,
         break;
     case CollationRuleParser::FIRST_VARIABLE:
         ce = rootElements.getFirstPrimaryCE();
-        isBoundary = TRUE;  // FractionalUCA.txt: FDD1 00A0, SPACE first primary
+        isBoundary = true;  // FractionalUCA.txt: FDD1 00A0, SPACE first primary
         break;
     case CollationRuleParser::LAST_VARIABLE:
         ce = rootElements.lastCEWithPrimaryBefore(variableTop + 1);
         break;
     case CollationRuleParser::FIRST_REGULAR:
         ce = rootElements.firstCEWithPrimaryAtLeast(variableTop + 1);
-        isBoundary = TRUE;  // FractionalUCA.txt: FDD1 263A, SYMBOL first primary
+        isBoundary = true;  // FractionalUCA.txt: FDD1 263A, SYMBOL first primary
         break;
     case CollationRuleParser::LAST_REGULAR:
         // Use the Hani-first-primary rather than the actual last "regular" CE before it,
@@ -570,7 +572,7 @@ CollationBuilder::getSpecialResetPosition(const UnicodeString &str,
         return 0;
     case CollationRuleParser::FIRST_TRAILING:
         ce = Collation::makeCE(Collation::FIRST_TRAILING_PRIMARY);
-        isBoundary = TRUE;  // trailing first primary (there is no mapping for it)
+        isBoundary = true;  // trailing first primary (there is no mapping for it)
         break;
     case CollationRuleParser::LAST_TRAILING:
         errorCode = U_ILLEGAL_ARGUMENT_ERROR;
@@ -743,14 +745,18 @@ CollationBuilder::addRelation(int32_t strength, const UnicodeString &prefix,
         }
     }
     uint32_t ce32 = Collation::UNASSIGNED_CE32;
-    if((prefix != nfdPrefix || str != nfdString) &&
+    if(!icu4xMode && (prefix != nfdPrefix || str != nfdString) &&
             !ignorePrefix(prefix, errorCode) && !ignoreString(str, errorCode)) {
         // Map from the original input to the CEs.
         // We do this in case the canonical closure is incomplete,
         // so that it is possible to explicitly provide the missing mappings.
         ce32 = addIfDifferent(prefix, str, ces, cesLength, ce32, errorCode);
     }
-    addWithClosure(nfdPrefix, nfdString, ces, cesLength, ce32, errorCode);
+    if (!icu4xMode) {
+        addWithClosure(nfdPrefix, nfdString, ces, cesLength, ce32, errorCode);
+    } else {
+        addIfDifferent(nfdPrefix, nfdString, ces, cesLength, ce32, errorCode);
+    }
     if(U_FAILURE(errorCode)) {
         parserErrorReason = "writing collation elements";
         return;
@@ -1025,7 +1031,7 @@ CollationBuilder::setCaseBits(const UnicodeString &nfdString,
     int64_t cases = 0;
     if(numTailoredPrimaries > 0) {
         const UChar *s = nfdString.getBuffer();
-        UTF16CollationIterator baseCEs(baseData, FALSE, s, s, s + nfdString.length());
+        UTF16CollationIterator baseCEs(baseData, false, s, s, s + nfdString.length());
         int32_t baseCEsLength = baseCEs.fetchCEs(errorCode) - 1;
         if(U_FAILURE(errorCode)) {
             parserErrorReason = "fetching root CEs for tailored string";
@@ -1217,18 +1223,18 @@ CollationBuilder::mergeCompositeIntoString(const UnicodeString &nfdString,
                                            UChar32 composite, const UnicodeString &decomp,
                                            UnicodeString &newNFDString, UnicodeString &newString,
                                            UErrorCode &errorCode) const {
-    if(U_FAILURE(errorCode)) { return FALSE; }
+    if(U_FAILURE(errorCode)) { return false; }
     U_ASSERT(nfdString.char32At(indexAfterLastStarter - 1) == decomp.char32At(0));
     int32_t lastStarterLength = decomp.moveIndex32(0, 1);
     if(lastStarterLength == decomp.length()) {
         // Singleton decompositions should be found by addWithClosure()
         // and the CanonicalIterator, so we can ignore them here.
-        return FALSE;
+        return false;
     }
     if(nfdString.compare(indexAfterLastStarter, 0x7fffffff,
                          decomp, lastStarterLength, 0x7fffffff) == 0) {
         // same strings, nothing new to be found here
-        return FALSE;
+        return false;
     }
 
     // Make new FCD strings that combine a composite, or its decomposition,
@@ -1238,7 +1244,7 @@ CollationBuilder::mergeCompositeIntoString(const UnicodeString &nfdString,
     newString.setTo(nfdString, 0, indexAfterLastStarter - lastStarterLength).append(composite);
 
     // The following is related to discontiguous contraction matching,
-    // but builds only FCD strings (or else returns FALSE).
+    // but builds only FCD strings (or else returns false).
     int32_t sourceIndex = indexAfterLastStarter;
     int32_t decompIndex = lastStarterLength;
     // Small optimization: We keep the source character across loop iterations
@@ -1265,16 +1271,16 @@ CollationBuilder::mergeCompositeIntoString(const UnicodeString &nfdString,
             // Unable to merge because the source contains a non-zero combining mark
             // but the composite's decomposition contains another starter.
             // The strings would not be equivalent.
-            return FALSE;
+            return false;
         } else if(sourceCC < decompCC) {
             // Composite + sourceChar would not be FCD.
-            return FALSE;
+            return false;
         } else if(decompCC < sourceCC) {
             newNFDString.append(decompChar);
             decompIndex += U16_LENGTH(decompChar);
         } else if(decompChar != sourceChar) {
             // Blocked because same combining class.
-            return FALSE;
+            return false;
         } else {  // match: decompChar == sourceChar
             newNFDString.append(decompChar);
             decompIndex += U16_LENGTH(decompChar);
@@ -1286,7 +1292,7 @@ CollationBuilder::mergeCompositeIntoString(const UnicodeString &nfdString,
     if(sourceChar >= 0) {  // more characters from nfdString but not from decomp
         if(sourceCC < decompCC) {
             // Appending the next source character to the composite would not be FCD.
-            return FALSE;
+            return false;
         }
         newNFDString.append(nfdString, sourceIndex, 0x7fffffff);
         newString.append(nfdString, sourceIndex, 0x7fffffff);
@@ -1296,7 +1302,7 @@ CollationBuilder::mergeCompositeIntoString(const UnicodeString &nfdString,
     U_ASSERT(nfd.isNormalized(newNFDString, errorCode));
     U_ASSERT(fcd.isNormalized(newString, errorCode));
     U_ASSERT(nfd.normalize(newString, errorCode) == newNFDString);  // canonically equivalent
-    return TRUE;
+    return true;
 }
 
 UBool
@@ -1361,13 +1367,13 @@ UBool
 CollationBuilder::sameCEs(const int64_t ces1[], int32_t ces1Length,
                           const int64_t ces2[], int32_t ces2Length) {
     if(ces1Length != ces2Length) {
-        return FALSE;
+        return false;
     }
     U_ASSERT(ces1Length <= Collation::MAX_EXPANSION_LENGTH);
     for(int32_t i = 0; i < ces1Length; ++i) {
-        if(ces1[i] != ces2[i]) { return FALSE; }
+        if(ces1[i] != ces2[i]) { return false; }
     }
-    return TRUE;
+    return true;
 }
 
 #ifdef DEBUG_COLLATION_BUILDER
@@ -1399,9 +1405,9 @@ CollationBuilder::makeTailoredCEs(UErrorCode &errorCode) {
         uint32_t s = p == 0 ? 0 : Collation::COMMON_WEIGHT16;
         uint32_t t = s;
         uint32_t q = 0;
-        UBool pIsTailored = FALSE;
-        UBool sIsTailored = FALSE;
-        UBool tIsTailored = FALSE;
+        UBool pIsTailored = false;
+        UBool sIsTailored = false;
+        UBool tIsTailored = false;
 #ifdef DEBUG_COLLATION_BUILDER
         printf("\nprimary     %lx\n", (long)alignWeightRight(p));
 #endif
@@ -1455,13 +1461,13 @@ CollationBuilder::makeTailoredCEs(UErrorCode &errorCode) {
                                 errorReason = "tertiary tailoring gap too small";
                                 return;
                             }
-                            tIsTailored = TRUE;
+                            tIsTailored = true;
                         }
                         t = tertiaries.nextWeight();
                         U_ASSERT(t != 0xffffffff);
                     } else {
                         t = weight16FromNode(node);
-                        tIsTailored = FALSE;
+                        tIsTailored = false;
 #ifdef DEBUG_COLLATION_BUILDER
                         printf("    ter     %lx\n", (long)alignWeightRight(t));
 #endif
@@ -1507,13 +1513,13 @@ CollationBuilder::makeTailoredCEs(UErrorCode &errorCode) {
 #endif
                                     return;
                                 }
-                                sIsTailored = TRUE;
+                                sIsTailored = true;
                             }
                             s = secondaries.nextWeight();
                             U_ASSERT(s != 0xffffffff);
                         } else {
                             s = weight16FromNode(node);
-                            sIsTailored = FALSE;
+                            sIsTailored = false;
 #ifdef DEBUG_COLLATION_BUILDER
                             printf("  sec       %lx\n", (long)alignWeightRight(s));
 #endif
@@ -1536,15 +1542,15 @@ CollationBuilder::makeTailoredCEs(UErrorCode &errorCode) {
                                 errorReason = "primary tailoring gap too small";
                                 return;
                             }
-                            pIsTailored = TRUE;
+                            pIsTailored = true;
                         }
                         p = primaries.nextWeight();
                         U_ASSERT(p != 0xffffffff);
                         s = Collation::COMMON_WEIGHT16;
-                        sIsTailored = FALSE;
+                        sIsTailored = false;
                     }
                     t = s == 0 ? 0 : Collation::COMMON_WEIGHT16;
-                    tIsTailored = FALSE;
+                    tIsTailored = false;
                 }
                 q = 0;
             }
@@ -1608,7 +1614,7 @@ CEFinalizer::~CEFinalizer() {}
 void
 CollationBuilder::finalizeCEs(UErrorCode &errorCode) {
     if(U_FAILURE(errorCode)) { return; }
-    LocalPointer<CollationDataBuilder> newBuilder(new CollationDataBuilder(errorCode), errorCode);
+    LocalPointer<CollationDataBuilder> newBuilder(new CollationDataBuilder(icu4xMode, errorCode), errorCode);
     if(U_FAILURE(errorCode)) {
         return;
     }
@@ -1690,7 +1696,7 @@ ucol_getUnsafeSet( const UCollator *coll,
     USet *contractions = uset_open(0,0);
 
     int32_t i = 0, j = 0;
-    ucol_getContractionsAndExpansions(coll, contractions, NULL, FALSE, status);
+    ucol_getContractionsAndExpansions(coll, contractions, NULL, false, status);
     int32_t contsSize = uset_size(contractions);
     UChar32 c = 0;
     // Contraction set consists only of strings
diff --git a/deps/icu-small/source/i18n/collationbuilder.h b/deps/icu-small/source/i18n/collationbuilder.h
index 59d3c5d24b..22e24ddb81 100644
--- a/deps/icu-small/source/i18n/collationbuilder.h
+++ b/deps/icu-small/source/i18n/collationbuilder.h
@@ -39,6 +39,7 @@ class Normalizer2Impl;
 
 class U_I18N_API CollationBuilder : public CollationRuleParser::Sink {
 public:
+    CollationBuilder(const CollationTailoring *b, UBool icu4xMode, UErrorCode &errorCode);
     CollationBuilder(const CollationTailoring *base, UErrorCode &errorCode);
     virtual ~CollationBuilder();
 
@@ -302,6 +303,7 @@ private:
 
     CollationDataBuilder *dataBuilder;
     UBool fastLatinEnabled;
+    UBool icu4xMode;
     UnicodeSet optimizeSet;
     const char *errorReason;
 
diff --git a/deps/icu-small/source/i18n/collationcompare.cpp b/deps/icu-small/source/i18n/collationcompare.cpp
index cbf32c9fe6..d9048afc27 100644
--- a/deps/icu-small/source/i18n/collationcompare.cpp
+++ b/deps/icu-small/source/i18n/collationcompare.cpp
@@ -39,7 +39,7 @@ CollationCompare::compareUpToQuaternary(CollationIterator &left, CollationIterat
         // +1 so that we can use "<" and primary ignorables test out early.
         variableTop = settings.variableTop + 1;
     }
-    UBool anyVariable = FALSE;
+    UBool anyVariable = false;
 
     // Fetch CEs, compare primaries, store secondary & tertiary weights.
     for(;;) {
@@ -51,7 +51,7 @@ CollationCompare::compareUpToQuaternary(CollationIterator &left, CollationIterat
             if(leftPrimary < variableTop && leftPrimary > Collation::MERGE_SEPARATOR_PRIMARY) {
                 // Variable CE, shift it to quaternary level.
                 // Ignore all following primary ignorables, and shift further variable CEs.
-                anyVariable = TRUE;
+                anyVariable = true;
                 do {
                     // Store only the primary of the variable CE.
                     left.setCurrentCE(ce & INT64_C(0xffffffff00000000));
@@ -76,7 +76,7 @@ CollationCompare::compareUpToQuaternary(CollationIterator &left, CollationIterat
             if(rightPrimary < variableTop && rightPrimary > Collation::MERGE_SEPARATOR_PRIMARY) {
                 // Variable CE, shift it to quaternary level.
                 // Ignore all following primary ignorables, and shift further variable CEs.
-                anyVariable = TRUE;
+                anyVariable = true;
                 do {
                     // Store only the primary of the variable CE.
                     right.setCurrentCE(ce & INT64_C(0xffffffff00000000));
diff --git a/deps/icu-small/source/i18n/collationdata.cpp b/deps/icu-small/source/i18n/collationdata.cpp
index 688770f8f6..1b8b6a76de 100644
--- a/deps/icu-small/source/i18n/collationdata.cpp
+++ b/deps/icu-small/source/i18n/collationdata.cpp
@@ -205,7 +205,7 @@ CollationData::getEquivalentScripts(int32_t script,
 void
 CollationData::makeReorderRanges(const int32_t *reorder, int32_t length,
                                  UVector32 &ranges, UErrorCode &errorCode) const {
-    makeReorderRanges(reorder, length, FALSE, ranges, errorCode);
+    makeReorderRanges(reorder, length, false, ranges, errorCode);
 }
 
 void
@@ -277,12 +277,12 @@ CollationData::makeReorderRanges(const int32_t *reorder, int32_t length,
 
     // Reorder according to the input scripts, continuing from the bottom of the primary range.
     int32_t originalLength = length;  // length will be decremented if "others" is in the list.
-    UBool hasReorderToEnd = FALSE;
+    UBool hasReorderToEnd = false;
     for(int32_t i = 0; i < length;) {
         int32_t script = reorder[i++];
         if(script == USCRIPT_UNKNOWN) {
             // Put the remaining scripts at the top.
-            hasReorderToEnd = TRUE;
+            hasReorderToEnd = true;
             while(i < length) {
                 script = reorder[--length];
                 if(script == USCRIPT_UNKNOWN ||  // Must occur at most once.
@@ -329,7 +329,7 @@ CollationData::makeReorderRanges(const int32_t *reorder, int32_t length,
     if(lowStart > highLimit) {
         if((lowStart - (skippedReserved & 0xff00)) <= highLimit) {
             // Try not skipping the before-Latin reserved range.
-            makeReorderRanges(reorder, originalLength, TRUE, ranges, errorCode);
+            makeReorderRanges(reorder, originalLength, true, ranges, errorCode);
             return;
         }
         // We need more primary lead bytes than available, despite the reserved ranges.
diff --git a/deps/icu-small/source/i18n/collationdata.h b/deps/icu-small/source/i18n/collationdata.h
index ab9b4c47ec..71bf17abd0 100644
--- a/deps/icu-small/source/i18n/collationdata.h
+++ b/deps/icu-small/source/i18n/collationdata.h
@@ -41,16 +41,12 @@ struct U_I18N_API CollationData : public UMemory {
     // Note: The ucadata.icu loader could discover the reserved ranges by setting an array
     // parallel with the ranges, and resetting ranges that are indexed.
     // The reordering builder code could clone the resulting template array.
-    enum {
-        REORDER_RESERVED_BEFORE_LATIN = UCOL_REORDER_CODE_FIRST + 14,
-        REORDER_RESERVED_AFTER_LATIN
-    };
-
-    enum {
-        MAX_NUM_SPECIAL_REORDER_CODES = 8,
-        /** C++ only, data reader check scriptStartsLength. */
-        MAX_NUM_SCRIPT_RANGES = 256
-    };
+    static constexpr int32_t REORDER_RESERVED_BEFORE_LATIN = UCOL_REORDER_CODE_FIRST + 14;
+    static constexpr int32_t REORDER_RESERVED_AFTER_LATIN = REORDER_RESERVED_BEFORE_LATIN + 1;
+
+    static constexpr int32_t MAX_NUM_SPECIAL_REORDER_CODES = 8;
+    /** C++ only, data reader check scriptStartsLength. */
+    static constexpr int32_t MAX_NUM_SCRIPT_RANGES = 256;
 
     CollationData(const Normalizer2Impl &nfc)
             : trie(NULL),
diff --git a/deps/icu-small/source/i18n/collationdatabuilder.cpp b/deps/icu-small/source/i18n/collationdatabuilder.cpp
index b10de993c2..e7c3da1ea5 100644
--- a/deps/icu-small/source/i18n/collationdatabuilder.cpp
+++ b/deps/icu-small/source/i18n/collationdatabuilder.cpp
@@ -86,18 +86,30 @@ struct ConditionalCE32 : public UMemory {
      * When fetching CEs from the builder, the contexts are built into their runtime form
      * so that the normal collation implementation can process them.
      * The result is cached in the list head. It is reset when the contexts are modified.
+     * All of these builtCE32 are invalidated by clearContexts(),
+     * via incrementing the contextsEra.
      */
     uint32_t builtCE32;
+    /**
+     * The "era" of building intermediate contexts when the above builtCE32 was set.
+     * When the array of cached, temporary contexts overflows, then clearContexts()
+     * removes them all and invalidates the builtCE32 that used to point to built tries.
+     */
+    int32_t era = -1;
     /**
      * Index of the next ConditionalCE32.
      * Negative for the end of the list.
      */
     int32_t next;
+    // Note: We could create a separate class for all of the contextual mappings for
+    // a code point, with the builtCE32, the era, and a list of the actual mappings.
+    // The class that represents one mapping would then not need to
+    // store those fields in each element.
 };
 
 U_CDECL_BEGIN
 
-U_CAPI void U_CALLCONV
+void U_CALLCONV
 uprv_deleteConditionalCE32(void *obj) {
     delete static_cast<ConditionalCE32 *>(obj);
 }
@@ -152,7 +164,7 @@ protected:
 };
 
 DataBuilderCollationIterator::DataBuilderCollationIterator(CollationDataBuilder &b)
-        : CollationIterator(&builderData, /*numeric=*/ FALSE),
+        : CollationIterator(&builderData, /*numeric=*/ false),
           builder(b), builderData(b.nfcImpl),
           s(NULL), pos(0) {
     builderData.base = builder.base;
@@ -192,7 +204,7 @@ DataBuilderCollationIterator::fetchCEs(const UnicodeString &str, int32_t start,
         } else {
             d = &builderData;
         }
-        appendCEsFromCE32(d, c, ce32, /*forward=*/ TRUE, errorCode);
+        appendCEsFromCE32(d, c, ce32, /*forward=*/ true, errorCode);
         U_ASSERT(U_SUCCESS(errorCode));
         for(int32_t i = 0; i < getCEsLength(); ++i) {
             int64_t ce = getCE(i);
@@ -267,7 +279,7 @@ DataBuilderCollationIterator::getCE32FromBuilderData(uint32_t ce32, UErrorCode &
             // TODO: ICU-21531 figure out why this happens.
             return 0;
         }
-        if(cond->builtCE32 == Collation::NO_CE32) {
+        if(cond->builtCE32 == Collation::NO_CE32 || cond->era != builder.contextsEra) {
             // Build the context-sensitive mappings into their runtime form and cache the result.
             cond->builtCE32 = builder.buildContext(cond, errorCode);
             if(errorCode == U_BUFFER_OVERFLOW_ERROR) {
@@ -275,6 +287,7 @@ DataBuilderCollationIterator::getCE32FromBuilderData(uint32_t ce32, UErrorCode &
                 builder.clearContexts();
                 cond->builtCE32 = builder.buildContext(cond, errorCode);
             }
+            cond->era = builder.contextsEra;
             builderData.contexts = builder.contexts.getBuffer();
         }
         return cond->builtCE32;
@@ -283,16 +296,19 @@ DataBuilderCollationIterator::getCE32FromBuilderData(uint32_t ce32, UErrorCode &
 
 // ------------------------------------------------------------------------- ***
 
-CollationDataBuilder::CollationDataBuilder(UErrorCode &errorCode)
+CollationDataBuilder::CollationDataBuilder(UBool icu4xMode, UErrorCode &errorCode)
         : nfcImpl(*Normalizer2Factory::getNFCImpl(errorCode)),
           base(NULL), baseSettings(NULL),
           trie(NULL),
           ce32s(errorCode), ce64s(errorCode), conditionalCE32s(errorCode),
-          modified(FALSE),
-          fastLatinEnabled(FALSE), fastLatinBuilder(NULL),
+          modified(false),
+          icu4xMode(icu4xMode),
+          fastLatinEnabled(false), fastLatinBuilder(NULL),
           collIter(NULL) {
     // Reserve the first CE32 for U+0000.
-    ce32s.addElement(0, errorCode);
+    if (!icu4xMode) {
+        ce32s.addElement(0, errorCode);
+    }
     conditionalCE32s.setDeleter(uprv_deleteConditionalCE32);
 }
 
@@ -316,27 +332,31 @@ CollationDataBuilder::initForTailoring(const CollationData *b, UErrorCode &error
     base = b;
 
     // For a tailoring, the default is to fall back to the base.
-    trie = utrie2_open(Collation::FALLBACK_CE32, Collation::FFFD_CE32, &errorCode);
-
-    // Set the Latin-1 letters block so that it is allocated first in the data array,
-    // to try to improve locality of reference when sorting Latin-1 text.
-    // Do not use utrie2_setRange32() since that will not actually allocate blocks
-    // that are filled with the default value.
-    // ASCII (0..7F) is already preallocated anyway.
-    for(UChar32 c = 0xc0; c <= 0xff; ++c) {
-        utrie2_set32(trie, c, Collation::FALLBACK_CE32, &errorCode);
-    }
+    // For ICU4X, use the same value for fallback as for the default
+    // to avoid having to have different blocks for the two.
+    trie = utrie2_open(Collation::FALLBACK_CE32, icu4xMode ? Collation::FALLBACK_CE32 : Collation::FFFD_CE32, &errorCode);
+
+    if (!icu4xMode) {
+        // Set the Latin-1 letters block so that it is allocated first in the data array,
+        // to try to improve locality of reference when sorting Latin-1 text.
+        // Do not use utrie2_setRange32() since that will not actually allocate blocks
+        // that are filled with the default value.
+        // ASCII (0..7F) is already preallocated anyway.
+        for(UChar32 c = 0xc0; c <= 0xff; ++c) {
+            utrie2_set32(trie, c, Collation::FALLBACK_CE32, &errorCode);
+        }
 
-    // Hangul syllables are not tailorable (except via tailoring Jamos).
-    // Always set the Hangul tag to help performance.
-    // Do this here, rather than in buildMappings(),
-    // so that we see the HANGUL_TAG in various assertions.
-    uint32_t hangulCE32 = Collation::makeCE32FromTagAndIndex(Collation::HANGUL_TAG, 0);
-    utrie2_setRange32(trie, Hangul::HANGUL_BASE, Hangul::HANGUL_END, hangulCE32, TRUE, &errorCode);
+        // Hangul syllables are not tailorable (except via tailoring Jamos).
+        // Always set the Hangul tag to help performance.
+        // Do this here, rather than in buildMappings(),
+        // so that we see the HANGUL_TAG in various assertions.
+        uint32_t hangulCE32 = Collation::makeCE32FromTagAndIndex(Collation::HANGUL_TAG, 0);
+        utrie2_setRange32(trie, Hangul::HANGUL_BASE, Hangul::HANGUL_END, hangulCE32, true, &errorCode);
 
-    // Copy the set contents but don't copy/clone the set as a whole because
-    // that would copy the isFrozen state too.
-    unsafeBackwardSet.addAll(*b->unsafeBackwardSet);
+        // Copy the set contents but don't copy/clone the set as a whole because
+        // that would copy the isFrozen state too.
+        unsafeBackwardSet.addAll(*b->unsafeBackwardSet);
+    }
 
     if(U_FAILURE(errorCode)) { return; }
 }
@@ -345,7 +365,7 @@ UBool
 CollationDataBuilder::maybeSetPrimaryRange(UChar32 start, UChar32 end,
                                            uint32_t primary, int32_t step,
                                            UErrorCode &errorCode) {
-    if(U_FAILURE(errorCode)) { return FALSE; }
+    if(U_FAILURE(errorCode)) { return false; }
     U_ASSERT(start <= end);
     // TODO: Do we need to check what values are currently set for start..end?
     // An offset range is worth it only if we can achieve an overlap between
@@ -370,11 +390,11 @@ CollationDataBuilder::maybeSetPrimaryRange(UChar32 start, UChar32 end,
             return 0;
         }
         uint32_t offsetCE32 = Collation::makeCE32FromTagAndIndex(Collation::OFFSET_TAG, index);
-        utrie2_setRange32(trie, start, end, offsetCE32, TRUE, &errorCode);
-        modified = TRUE;
-        return TRUE;
+        utrie2_setRange32(trie, start, end, offsetCE32, true, &errorCode);
+        modified = true;
+        return true;
     } else {
-        return FALSE;
+        return false;
     }
 }
 
@@ -395,7 +415,7 @@ CollationDataBuilder::setPrimaryRangeAndReturnNext(UChar32 start, UChar32 end,
             primary = Collation::incThreeBytePrimaryByOffset(primary, isCompressible, step);
             if(start > end) { return primary; }
         }
-        modified = TRUE;
+        modified = true;
     }
 }
 
@@ -431,10 +451,10 @@ int64_t
 CollationDataBuilder::getSingleCE(UChar32 c, UErrorCode &errorCode) const {
     if(U_FAILURE(errorCode)) { return 0; }
     // Keep parallel with CollationData::getSingleCE().
-    UBool fromBase = FALSE;
+    UBool fromBase = false;
     uint32_t ce32 = utrie2_get32(trie, c);
     if(ce32 == Collation::FALLBACK_CE32) {
-        fromBase = TRUE;
+        fromBase = true;
         ce32 = base->getCE32(c);
     }
     while(Collation::isSpecialCE32(ce32)) {
@@ -554,6 +574,98 @@ CollationDataBuilder::addCE32(const UnicodeString &prefix, const UnicodeString &
     int32_t cLength = U16_LENGTH(c);
     uint32_t oldCE32 = utrie2_get32(trie, c);
     UBool hasContext = !prefix.isEmpty() || s.length() > cLength;
+
+    if (icu4xMode) {
+        if (base && c >= 0x1100 && c < 0x1200) {
+            // Omit jamo tailorings.
+            // TODO(https://github.com/unicode-org/icu4x/issues/1941).
+        }
+        const Normalizer2* nfdNormalizer = Normalizer2::getNFDInstance(errorCode);
+        UnicodeString sInNfd;
+        nfdNormalizer->normalize(s, sInNfd, errorCode);
+        if (s != sInNfd) {
+            // s is not in NFD, so it cannot match in ICU4X, since ICU4X only
+            // does NFD lookups.
+            // Now check that we're only rejecting known cases.
+            if (s.length() == 2) {
+                char16_t second = s.charAt(1);
+                if (second == 0x0F73 || second == 0x0F75 || second == 0x0F81) {
+                    // Second is a special decomposing Tibetan vowel sign.
+                    // These also get added in the decomposed form, so ignoring
+                    // this instance is OK.
+                    return;
+                }
+                if (c == 0xFDD1 && second == 0xAC00) {
+                    // This strange contraction exists in the root and
+                    // doesn't have a decomposed counterpart there.
+                    // This won't match in ICU4X anyway and is very strange:
+                    // Unassigned Arabic presentation form contracting with
+                    // the very first Hangul syllable. Let's ignore this
+                    // explicitly.
+                    return;
+                }
+            }
+            // Unknown case worth investigating if ever found.
+            errorCode = U_UNSUPPORTED_ERROR;
+            return;
+        }
+
+        if (!prefix.isEmpty()) {
+            UnicodeString prefixInNfd;
+            nfdNormalizer->normalize(prefix, prefixInNfd, errorCode);
+            if (prefix != prefixInNfd) {
+                errorCode = U_UNSUPPORTED_ERROR;
+                return;
+            }
+
+            int32_t count = prefix.countChar32();
+            if (count > 2) {
+                // Prefix too long for ICU4X.
+                errorCode = U_UNSUPPORTED_ERROR;
+                return;
+            }
+            UChar32 utf32[4];
+            int32_t len = prefix.toUTF32(utf32, 4, errorCode);
+            if (len != count) {
+                errorCode = U_INVALID_STATE_ERROR;
+                return;
+            }
+            UChar32 c = utf32[0];
+            if (u_getCombiningClass(c)) {
+                // Prefix must start with as starter for ICU4X.
+                errorCode = U_UNSUPPORTED_ERROR;
+                return;
+            }
+            // XXX: Korean searchjl has jamo in prefix, so commenting out this
+            // check for now. ICU4X currently ignores non-root jamo tables anyway.
+            // searchjl was added in
+            // https://unicode-org.atlassian.net/browse/CLDR-3560
+            // Contractions were changed to prefixes in
+            // https://unicode-org.atlassian.net/browse/CLDR-6546
+            //
+            // if ((c >= 0x1100 && c < 0x1200) || (c >= 0xAC00 && c < 0xD7A4)) {
+            //     errorCode = U_UNSUPPORTED_ERROR;
+            //     return;
+            // }
+            if ((len > 1) && !(utf32[1] == 0x3099 || utf32[1] == 0x309A)) {
+                // Second character in prefix, if present, must be a kana voicing mark for ICU4X.
+                errorCode = U_UNSUPPORTED_ERROR;
+                return;
+            }
+        }
+
+        if (s.length() > cLength) {
+            // Check that there's no modern Hangul in contractions.
+            for (int32_t i = 0; i < s.length(); ++i) {
+                UChar c = s.charAt(i);
+                if ((c >= 0x1100 && c < 0x1100 + 19) || (c >= 0x1161 && c < 0x1161 + 21) || (c >= 0x11A7 && c < 0x11A7 + 28) || (c >= 0xAC00 && c < 0xD7A4)) {
+                    errorCode = U_UNSUPPORTED_ERROR;
+                    return;
+                }
+            }
+        }
+    }
+
     if(oldCE32 == Collation::FALLBACK_CE32) {
         // First tailoring for c.
         // If c has contextual base mappings or if we add a contextual mapping,
@@ -561,7 +673,7 @@ CollationDataBuilder::addCE32(const UnicodeString &prefix, const UnicodeString &
         // Otherwise we just override the base mapping.
         uint32_t baseCE32 = base->getFinalCE32(base->getCE32(c));
         if(hasContext || Collation::ce32HasContext(baseCE32)) {
-            oldCE32 = copyFromBaseCE32(c, baseCE32, TRUE, errorCode);
+            oldCE32 = copyFromBaseCE32(c, baseCE32, true, errorCode);
             utrie2_set32(trie, c, oldCE32, &errorCode);
             if(U_FAILURE(errorCode)) { return; }
         }
@@ -621,7 +733,7 @@ CollationDataBuilder::addCE32(const UnicodeString &prefix, const UnicodeString &
             cond = nextCond;
         }
     }
-    modified = TRUE;
+    modified = true;
 }
 
 uint32_t
@@ -675,8 +787,11 @@ CollationDataBuilder::encodeCEs(const int64_t ces[], int32_t cesLength,
         return encodeOneCEAsCE32(0);
     } else if(cesLength == 1) {
         return encodeOneCE(ces[0], errorCode);
-    } else if(cesLength == 2) {
+    } else if(cesLength == 2 && !icu4xMode) {
         // Try to encode two CEs as one CE32.
+        // Turn this off for ICU4X, because without the canonical closure
+        // these are so rare that it doesn't make sense to spend a branch
+        // on checking this tag when using the data.
         int64_t ce0 = ces[0];
         int64_t ce1 = ces[1];
         uint32_t p0 = (uint32_t)(ce0 >> 32);
@@ -802,7 +917,7 @@ CollationDataBuilder::copyFromBaseCE32(UChar32 c, uint32_t ce32, UBool withConte
         const UChar *p = base->contexts + Collation::indexFromCE32(ce32);
         ce32 = CollationData::readCE32(p);  // Default if no prefix match.
         if(!withContext) {
-            return copyFromBaseCE32(c, ce32, FALSE, errorCode);
+            return copyFromBaseCE32(c, ce32, false, errorCode);
         }
         ConditionalCE32 head;
         UnicodeString context((UChar)0);
@@ -810,7 +925,7 @@ CollationDataBuilder::copyFromBaseCE32(UChar32 c, uint32_t ce32, UBool withConte
         if(Collation::isContractionCE32(ce32)) {
             index = copyContractionsFromBaseCE32(context, c, ce32, &head, errorCode);
         } else {
-            ce32 = copyFromBaseCE32(c, ce32, TRUE, errorCode);
+            ce32 = copyFromBaseCE32(c, ce32, true, errorCode);
             head.next = index = addConditionalCE32(context, ce32, errorCode);
         }
         if(U_FAILURE(errorCode)) { return 0; }
@@ -824,7 +939,7 @@ CollationDataBuilder::copyFromBaseCE32(UChar32 c, uint32_t ce32, UBool withConte
             if(Collation::isContractionCE32(ce32)) {
                 index = copyContractionsFromBaseCE32(context, c, ce32, cond, errorCode);
             } else {
-                ce32 = copyFromBaseCE32(c, ce32, TRUE, errorCode);
+                ce32 = copyFromBaseCE32(c, ce32, true, errorCode);
                 cond->next = index = addConditionalCE32(context, ce32, errorCode);
             }
             if(U_FAILURE(errorCode)) { return 0; }
@@ -838,7 +953,7 @@ CollationDataBuilder::copyFromBaseCE32(UChar32 c, uint32_t ce32, UBool withConte
         if(!withContext) {
             const UChar *p = base->contexts + Collation::indexFromCE32(ce32);
             ce32 = CollationData::readCE32(p);  // Default if no suffix match.
-            return copyFromBaseCE32(c, ce32, FALSE, errorCode);
+            return copyFromBaseCE32(c, ce32, false, errorCode);
         }
         ConditionalCE32 head;
         UnicodeString context((UChar)0);
@@ -851,7 +966,7 @@ CollationDataBuilder::copyFromBaseCE32(UChar32 c, uint32_t ce32, UBool withConte
         errorCode = U_UNSUPPORTED_ERROR;  // We forbid tailoring of Hangul syllables.
         break;
     case Collation::OFFSET_TAG:
-        ce32 = getCE32FromOffsetCE32(TRUE, c, ce32);
+        ce32 = getCE32FromOffsetCE32(true, c, ce32);
         break;
     case Collation::IMPLICIT_TAG:
         ce32 = encodeOneCE(Collation::unassignedCEFromCodePoint(c), errorCode);
@@ -877,7 +992,7 @@ CollationDataBuilder::copyContractionsFromBaseCE32(UnicodeString &context, UChar
     } else {
         ce32 = CollationData::readCE32(p);  // Default if no suffix match.
         U_ASSERT(!Collation::isContractionCE32(ce32));
-        ce32 = copyFromBaseCE32(c, ce32, TRUE, errorCode);
+        ce32 = copyFromBaseCE32(c, ce32, true, errorCode);
         cond->next = index = addConditionalCE32(context, ce32, errorCode);
         if(U_FAILURE(errorCode)) { return 0; }
         cond = getConditionalCE32(index);
@@ -887,7 +1002,7 @@ CollationDataBuilder::copyContractionsFromBaseCE32(UnicodeString &context, UChar
     UCharsTrie::Iterator suffixes(p + 2, 0, errorCode);
     while(suffixes.next(errorCode)) {
         context.append(suffixes.getString());
-        ce32 = copyFromBaseCE32(c, (uint32_t)suffixes.getValue(), TRUE, errorCode);
+        ce32 = copyFromBaseCE32(c, (uint32_t)suffixes.getValue(), true, errorCode);
         cond->next = index = addConditionalCE32(context, ce32, errorCode);
         if(U_FAILURE(errorCode)) { return 0; }
         // No need to update the unsafeBackwardSet because the tailoring set
@@ -908,7 +1023,7 @@ public:
 
     UBool copyRangeCE32(UChar32 start, UChar32 end, uint32_t ce32) {
         ce32 = copyCE32(ce32);
-        utrie2_setRange32(dest.trie, start, end, ce32, TRUE, &errorCode);
+        utrie2_setRange32(dest.trie, start, end, ce32, true, &errorCode);
         if(CollationDataBuilder::isBuilderContextCE32(ce32)) {
             dest.contextChars.add(start, end);
         }
@@ -929,7 +1044,7 @@ public:
                 int32_t length = Collation::lengthFromCE32(ce32);
                 // Inspect the source CE32s. Just copy them if none are modified.
                 // Otherwise copy to modifiedCEs, with modifications.
-                UBool isModified = FALSE;
+                UBool isModified = false;
                 for(int32_t i = 0; i < length; ++i) {
                     ce32 = srcCE32s[i];
                     int64_t ce;
@@ -943,7 +1058,7 @@ public:
                             for(int32_t j = 0; j < i; ++j) {
                                 modifiedCEs[j] = Collation::ceFromCE32(srcCE32s[j]);
                             }
-                            isModified = TRUE;
+                            isModified = true;
                         }
                         modifiedCEs[i] = ce;
                     }
@@ -960,7 +1075,7 @@ public:
                 int32_t length = Collation::lengthFromCE32(ce32);
                 // Inspect the source CEs. Just copy them if none are modified.
                 // Otherwise copy to modifiedCEs, with modifications.
-                UBool isModified = FALSE;
+                UBool isModified = false;
                 for(int32_t i = 0; i < length; ++i) {
                     int64_t srcCE = srcCEs[i];
                     int64_t ce = modifier.modifyCE(srcCE);
@@ -973,7 +1088,7 @@ public:
                             for(int32_t j = 0; j < i; ++j) {
                                 modifiedCEs[j] = srcCEs[j];
                             }
-                            isModified = TRUE;
+                            isModified = true;
                         }
                         modifiedCEs[i] = ce;
                     }
@@ -1055,11 +1170,11 @@ CollationDataBuilder::optimize(const UnicodeSet &set, UErrorCode &errorCode) {
         uint32_t ce32 = utrie2_get32(trie, c);
         if(ce32 == Collation::FALLBACK_CE32) {
             ce32 = base->getFinalCE32(base->getCE32(c));
-            ce32 = copyFromBaseCE32(c, ce32, TRUE, errorCode);
+            ce32 = copyFromBaseCE32(c, ce32, true, errorCode);
             utrie2_set32(trie, c, ce32, &errorCode);
         }
     }
-    modified = TRUE;
+    modified = true;
 }
 
 void
@@ -1072,7 +1187,7 @@ CollationDataBuilder::suppressContractions(const UnicodeSet &set, UErrorCode &er
         if(ce32 == Collation::FALLBACK_CE32) {
             ce32 = base->getFinalCE32(base->getCE32(c));
             if(Collation::ce32HasContext(ce32)) {
-                ce32 = copyFromBaseCE32(c, ce32, FALSE /* without context */, errorCode);
+                ce32 = copyFromBaseCE32(c, ce32, false /* without context */, errorCode);
                 utrie2_set32(trie, c, ce32, &errorCode);
             }
         } else if(isBuilderContextCE32(ce32)) {
@@ -1084,23 +1199,23 @@ CollationDataBuilder::suppressContractions(const UnicodeSet &set, UErrorCode &er
             contextChars.remove(c);
         }
     }
-    modified = TRUE;
+    modified = true;
 }
 
 UBool
 CollationDataBuilder::getJamoCE32s(uint32_t jamoCE32s[], UErrorCode &errorCode) {
-    if(U_FAILURE(errorCode)) { return FALSE; }
+    if(U_FAILURE(errorCode)) { return false; }
     UBool anyJamoAssigned = base == NULL;  // always set jamoCE32s in the base data
-    UBool needToCopyFromBase = FALSE;
+    UBool needToCopyFromBase = false;
     for(int32_t j = 0; j < CollationData::JAMO_CE32S_LENGTH; ++j) {  // Count across Jamo types.
         UChar32 jamo = jamoCpFromIndex(j);
-        UBool fromBase = FALSE;
+        UBool fromBase = false;
         uint32_t ce32 = utrie2_get32(trie, jamo);
         anyJamoAssigned |= Collation::isAssignedCE32(ce32);
         // TODO: Try to prevent [optimize [Jamo]] from counting as anyJamoAssigned.
         // (As of CLDR 24 [2013] the Korean tailoring does not optimize conjoining Jamo.)
         if(ce32 == Collation::FALLBACK_CE32) {
-            fromBase = TRUE;
+            fromBase = true;
             ce32 = base->getCE32(jamo);
         }
         if(Collation::isSpecialCE32(ce32)) {
@@ -1117,14 +1232,14 @@ CollationDataBuilder::getJamoCE32s(uint32_t jamoCE32s[], UErrorCode &errorCode)
                 if(fromBase) {
                     // Defer copying until we know if anyJamoAssigned.
                     ce32 = Collation::FALLBACK_CE32;
-                    needToCopyFromBase = TRUE;
+                    needToCopyFromBase = true;
                 }
                 break;
             case Collation::IMPLICIT_TAG:
                 // An unassigned Jamo should only occur in tests with incomplete bases.
                 U_ASSERT(fromBase);
                 ce32 = Collation::FALLBACK_CE32;
-                needToCopyFromBase = TRUE;
+                needToCopyFromBase = true;
                 break;
             case Collation::OFFSET_TAG:
                 ce32 = getCE32FromOffsetCE32(fromBase, jamo, ce32);
@@ -1137,7 +1252,7 @@ CollationDataBuilder::getJamoCE32s(uint32_t jamoCE32s[], UErrorCode &errorCode)
             case Collation::HANGUL_TAG:
             case Collation::LEAD_SURROGATE_TAG:
                 errorCode = U_INTERNAL_PROGRAM_ERROR;
-                return FALSE;
+                return false;
             }
         }
         jamoCE32s[j] = ce32;
@@ -1147,7 +1262,7 @@ CollationDataBuilder::getJamoCE32s(uint32_t jamoCE32s[], UErrorCode &errorCode)
             if(jamoCE32s[j] == Collation::FALLBACK_CE32) {
                 UChar32 jamo = jamoCpFromIndex(j);
                 jamoCE32s[j] = copyFromBaseCE32(jamo, base->getCE32(jamo),
-                                                /*withContext=*/ TRUE, errorCode);
+                                                /*withContext=*/ true, errorCode);
             }
         }
     }
@@ -1188,15 +1303,15 @@ enumRangeLeadValue(const void *context, UChar32 /*start*/, UChar32 /*end*/, uint
         value = Collation::LEAD_ALL_FALLBACK;
     } else {
         *pValue = Collation::LEAD_MIXED;
-        return FALSE;
+        return false;
     }
     if(*pValue < 0) {
         *pValue = (int32_t)value;
     } else if(*pValue != (int32_t)value) {
         *pValue = Collation::LEAD_MIXED;
-        return FALSE;
+        return false;
     }
-    return TRUE;
+    return true;
 }
 
 U_CDECL_END
@@ -1251,10 +1366,10 @@ CollationDataBuilder::buildMappings(CollationData &data, UErrorCode &errorCode)
         // In order to still have good trie compression and keep this code simple,
         // we only set this flag if a whole block of 588 Hangul syllables starting with
         // a common leading consonant (Jamo L) has this property.
-        UBool isAnyJamoVTSpecial = FALSE;
+        UBool isAnyJamoVTSpecial = false;
         for(int32_t i = Hangul::JAMO_L_COUNT; i < CollationData::JAMO_CE32S_LENGTH; ++i) {
             if(Collation::isSpecialCE32(jamoCE32s[i])) {
-                isAnyJamoVTSpecial = TRUE;
+                isAnyJamoVTSpecial = true;
                 break;
             }
         }
@@ -1266,7 +1381,7 @@ CollationDataBuilder::buildMappings(CollationData &data, UErrorCode &errorCode)
                 ce32 |= Collation::HANGUL_NO_SPECIAL_JAMO;
             }
             UChar32 limit = c + Hangul::JAMO_VT_COUNT;
-            utrie2_setRange32(trie, c, limit - 1, ce32, TRUE, &errorCode);
+            utrie2_setRange32(trie, c, limit - 1, ce32, true, &errorCode);
             c = limit;
         }
     } else {
@@ -1276,7 +1391,7 @@ CollationDataBuilder::buildMappings(CollationData &data, UErrorCode &errorCode)
             uint32_t ce32 = base->getCE32(c);
             U_ASSERT(Collation::hasCE32Tag(ce32, Collation::HANGUL_TAG));
             UChar32 limit = c + Hangul::JAMO_VT_COUNT;
-            utrie2_setRange32(trie, c, limit - 1, ce32, TRUE, &errorCode);
+            utrie2_setRange32(trie, c, limit - 1, ce32, true, &errorCode);
             c = limit;
         }
     }
@@ -1284,9 +1399,11 @@ CollationDataBuilder::buildMappings(CollationData &data, UErrorCode &errorCode)
     setDigitTags(errorCode);
     setLeadSurrogates(errorCode);
 
-    // For U+0000, move its normal ce32 into CE32s[0] and set U0000_TAG.
-    ce32s.setElementAt((int32_t)utrie2_get32(trie, 0), 0);
-    utrie2_set32(trie, 0, Collation::makeCE32FromTagAndIndex(Collation::U0000_TAG, 0), &errorCode);
+    if (!icu4xMode) {
+        // For U+0000, move its normal ce32 into CE32s[0] and set U0000_TAG.
+        ce32s.setElementAt((int32_t)utrie2_get32(trie, 0), 0);
+        utrie2_set32(trie, 0, Collation::makeCE32FromTagAndIndex(Collation::U0000_TAG, 0), &errorCode);
+    }
 
     utrie2_freeze(trie, UTRIE2_32_VALUE_BITS, &errorCode);
     if(U_FAILURE(errorCode)) { return; }
@@ -1322,13 +1439,10 @@ CollationDataBuilder::buildMappings(CollationData &data, UErrorCode &errorCode)
 void
 CollationDataBuilder::clearContexts() {
     contexts.remove();
-    UnicodeSetIterator iter(contextChars);
-    while(iter.next()) {
-        U_ASSERT(!iter.isString());
-        uint32_t ce32 = utrie2_get32(trie, iter.getCodepoint());
-        U_ASSERT(isBuilderContextCE32(ce32));
-        getConditionalCE32ForCE32(ce32)->builtCE32 = Collation::NO_CE32;
-    }
+    // Incrementing the contexts build "era" invalidates all of the builtCE32
+    // from before this clearContexts() call.
+    // Simpler than finding and resetting all of those fields.
+    ++contextsEra;
 }
 
 void
@@ -1336,7 +1450,7 @@ CollationDataBuilder::buildContexts(UErrorCode &errorCode) {
     if(U_FAILURE(errorCode)) { return; }
     // Ignore abandoned lists and the cached builtCE32,
     // and build all contexts from scratch.
-    contexts.remove();
+    clearContexts();
     UnicodeSetIterator iter(contextChars);
     while(U_SUCCESS(errorCode) && iter.next()) {
         U_ASSERT(!iter.isString());
@@ -1362,18 +1476,34 @@ CollationDataBuilder::buildContext(ConditionalCE32 *head, UErrorCode &errorCode)
     U_ASSERT(head->next >= 0);
     UCharsTrieBuilder prefixBuilder(errorCode);
     UCharsTrieBuilder contractionBuilder(errorCode);
+    // This outer loop goes from each prefix to the next.
+    // For each prefix it finds the one or more same-prefix entries (firstCond..lastCond).
+    // If there are multiple suffixes for the same prefix,
+    // then an inner loop builds a contraction trie for them.
     for(ConditionalCE32 *cond = head;; cond = getConditionalCE32(cond->next)) {
+        if(U_FAILURE(errorCode)) { return 0; }  // early out for memory allocation errors
         // After the list head, the prefix or suffix can be empty, but not both.
         U_ASSERT(cond == head || cond->hasContext());
         int32_t prefixLength = cond->prefixLength();
         UnicodeString prefix(cond->context, 0, prefixLength + 1);
         // Collect all contraction suffixes for one prefix.
         ConditionalCE32 *firstCond = cond;
-        ConditionalCE32 *lastCond = cond;
-        while(cond->next >= 0 &&
-                (cond = getConditionalCE32(cond->next))->context.startsWith(prefix)) {
+        ConditionalCE32 *lastCond;
+        do {
             lastCond = cond;
-        }
+            // Clear the defaultCE32 fields as we go.
+            // They are left over from building a previous version of this list of contexts.
+            //
+            // One of the code paths below may copy a preceding defaultCE32
+            // into its emptySuffixCE32.
+            // If a new suffix has been inserted before what used to be
+            // the firstCond for its prefix, then that previous firstCond could still
+            // contain an outdated defaultCE32 from an earlier buildContext() and
+            // result in an incorrect emptySuffixCE32.
+            // So we reset all defaultCE32 before reading and setting new values.
+            cond->defaultCE32 = Collation::NO_CE32;
+        } while(cond->next >= 0 &&
+                (cond = getConditionalCE32(cond->next))->context.startsWith(prefix));
         uint32_t ce32;
         int32_t suffixStart = prefixLength + 1;  // == prefix.length()
         if(lastCond->context.length() == suffixStart) {
@@ -1428,6 +1558,20 @@ CollationDataBuilder::buildContext(ConditionalCE32 *head, UErrorCode &errorCode)
                     // The last suffix character has lccc!=0, allowing for discontiguous contractions.
                     flags |= Collation::CONTRACT_TRAILING_CCC;
                 }
+                if (icu4xMode && (flags & Collation::CONTRACT_HAS_STARTER) == 0) {
+                    for (int32_t i = 0; i < suffix.length();) {
+                        UChar32 c = suffix.char32At(i);
+                            if (!u_getCombiningClass(c)) {
+                                flags |= Collation::CONTRACT_HAS_STARTER;
+                                break;
+                            }
+                        if (c > 0xFFFF) {
+                            i += 2;
+                        } else {
+                            ++i;
+                        }
+                    }
+                }
                 contractionBuilder.add(suffix, (int32_t)cond->ce32, errorCode);
                 if(cond == lastCond) { break; }
                 cond = getConditionalCE32(cond->next);
diff --git a/deps/icu-small/source/i18n/collationdatabuilder.h b/deps/icu-small/source/i18n/collationdatabuilder.h
index 6ae77772fd..cbbd8f264b 100644
--- a/deps/icu-small/source/i18n/collationdatabuilder.h
+++ b/deps/icu-small/source/i18n/collationdatabuilder.h
@@ -60,7 +60,7 @@ public:
         virtual int64_t modifyCE(int64_t ce) const = 0;
     };
 
-    CollationDataBuilder(UErrorCode &errorCode);
+    CollationDataBuilder(UBool icu4xMode, UErrorCode &errorCode);
 
     virtual ~CollationDataBuilder();
 
@@ -244,8 +244,18 @@ protected:
     UnicodeSet contextChars;
     // Serialized UCharsTrie structures for finalized contexts.
     UnicodeString contexts;
+private:
+    /**
+     * The "era" of building intermediate contexts.
+     * When the array of cached, temporary contexts overflows, then clearContexts()
+     * removes them all and invalidates the builtCE32 that used to point to built tries.
+     * See ConditionalCE32::era.
+     */
+    int32_t contextsEra = 0;
+protected:
     UnicodeSet unsafeBackwardSet;
     UBool modified;
+    UBool icu4xMode;
 
     UBool fastLatinEnabled;
     CollationFastLatinBuilder *fastLatinBuilder;
diff --git a/deps/icu-small/source/i18n/collationdatareader.cpp b/deps/icu-small/source/i18n/collationdatareader.cpp
index 0eb1861343..a96982cd94 100644
--- a/deps/icu-small/source/i18n/collationdatareader.cpp
+++ b/deps/icu-small/source/i18n/collationdatareader.cpp
@@ -436,7 +436,7 @@ CollationDataReader::read(const CollationTailoring *base, const uint8_t *inBytes
     settings->options = options;
     // Set variableTop from options and scripts data.
     settings->variableTop = tailoring.data->getLastPrimaryForGroup(
-            UCOL_REORDER_CODE_FIRST + settings->getMaxVariable());
+            UCOL_REORDER_CODE_FIRST + int32_t{settings->getMaxVariable()});
     if(settings->variableTop == 0) {
         errorCode = U_INVALID_FORMAT_ERROR;
         return;
@@ -471,9 +471,9 @@ CollationDataReader::isAcceptable(void *context,
         if(version != NULL) {
             uprv_memcpy(version, pInfo->dataVersion, 4);
         }
-        return TRUE;
+        return true;
     } else {
-        return FALSE;
+        return false;
     }
 }
 
diff --git a/deps/icu-small/source/i18n/collationdatareader.h b/deps/icu-small/source/i18n/collationdatareader.h
index 44e69399e3..083b57ea58 100644
--- a/deps/icu-small/source/i18n/collationdatareader.h
+++ b/deps/icu-small/source/i18n/collationdatareader.h
@@ -106,7 +106,7 @@ struct U_I18N_API CollationDataReader /* all static */ {
     isAcceptable(void *context, const char *type, const char *name, const UDataInfo *pInfo);
 
 private:
-    CollationDataReader();  // no constructor
+    CollationDataReader() = delete;  // no constructor
 };
 
 /*
diff --git a/deps/icu-small/source/i18n/collationdatawriter.cpp b/deps/icu-small/source/i18n/collationdatawriter.cpp
index 823c8eb011..b4be7df887 100644
--- a/deps/icu-small/source/i18n/collationdatawriter.cpp
+++ b/deps/icu-small/source/i18n/collationdatawriter.cpp
@@ -79,7 +79,7 @@ CollationDataWriter::writeBase(const CollationData &data, const CollationSetting
                                const void *rootElements, int32_t rootElementsLength,
                                int32_t indexes[], uint8_t *dest, int32_t capacity,
                                UErrorCode &errorCode) {
-    return write(TRUE, NULL,
+    return write(true, NULL,
                  data, settings,
                  rootElements, rootElementsLength,
                  indexes, dest, capacity, errorCode);
@@ -89,7 +89,7 @@ int32_t
 CollationDataWriter::writeTailoring(const CollationTailoring &t, const CollationSettings &settings,
                                     int32_t indexes[], uint8_t *dest, int32_t capacity,
                                     UErrorCode &errorCode) {
-    return write(FALSE, t.version,
+    return write(false, t.version,
                  *t.data, settings,
                  NULL, 0,
                  indexes, dest, capacity, errorCode);
@@ -129,11 +129,11 @@ CollationDataWriter::write(UBool isBase, const UVersionInfo dataVersion,
         // so that we start with an 8-aligned offset.
         indexesLength = CollationDataReader::IX_TOTAL_SIZE + 1;
         U_ASSERT(settings.reorderCodesLength == 0);
-        hasMappings = TRUE;
+        hasMappings = true;
         unsafeBackwardSet = *data.unsafeBackwardSet;
         fastLatinTableLength = data.fastLatinTableLength;
     } else if(baseData == NULL) {
-        hasMappings = FALSE;
+        hasMappings = false;
         if(settings.reorderCodesLength == 0) {
             // only options
             indexesLength = CollationDataReader::IX_OPTIONS + 1;  // no limit offset here
@@ -142,7 +142,7 @@ CollationDataWriter::write(UBool isBase, const UVersionInfo dataVersion,
             indexesLength = CollationDataReader::IX_REORDER_TABLE_OFFSET + 2;
         }
     } else {
-        hasMappings = TRUE;
+        hasMappings = true;
         // Tailored mappings, and what else?
         // Check in ascending order of optional tailoring data items.
         indexesLength = CollationDataReader::IX_CE32S_OFFSET + 2;
diff --git a/deps/icu-small/source/i18n/collationdatawriter.h b/deps/icu-small/source/i18n/collationdatawriter.h
index 197cd5309f..6ba9a9c2c7 100644
--- a/deps/icu-small/source/i18n/collationdatawriter.h
+++ b/deps/icu-small/source/i18n/collationdatawriter.h
@@ -39,7 +39,7 @@ public:
                                   UErrorCode &errorCode);
 
 private:
-    CollationDataWriter();  // no constructor
+    CollationDataWriter() = delete;  // no constructor
 
     static int32_t write(UBool isBase, const UVersionInfo dataVersion,
                          const CollationData &data, const CollationSettings &settings,
diff --git a/deps/icu-small/source/i18n/collationfastlatin.cpp b/deps/icu-small/source/i18n/collationfastlatin.cpp
index b98b8457f4..35cf60e815 100644
--- a/deps/icu-small/source/i18n/collationfastlatin.cpp
+++ b/deps/icu-small/source/i18n/collationfastlatin.cpp
@@ -45,7 +45,7 @@ CollationFastLatin::getOptions(const CollationData *data, const CollationSetting
         miniVarTop = table[i];
     }
 
-    UBool digitsAreReordered = FALSE;
+    UBool digitsAreReordered = false;
     if(settings.hasReordering()) {
         uint32_t prevStart = 0;
         uint32_t beforeDigitStart = 0;
@@ -80,7 +80,7 @@ CollationFastLatin::getOptions(const CollationData *data, const CollationSetting
             afterDigitStart = latinStart;
         }
         if(!(beforeDigitStart < digitStart && digitStart < afterDigitStart)) {
-            digitsAreReordered = TRUE;
+            digitsAreReordered = true;
         }
     }
 
diff --git a/deps/icu-small/source/i18n/collationfastlatin.h b/deps/icu-small/source/i18n/collationfastlatin.h
index 4bac797409..7013f71ce6 100644
--- a/deps/icu-small/source/i18n/collationfastlatin.h
+++ b/deps/icu-small/source/i18n/collationfastlatin.h
@@ -249,7 +249,7 @@ private:
     static uint32_t getQuaternaries(uint32_t variableTop, uint32_t pair);
 
 private:
-    CollationFastLatin();  // no constructor
+    CollationFastLatin() = delete;  // no constructor
 };
 
 /*
diff --git a/deps/icu-small/source/i18n/collationfastlatinbuilder.cpp b/deps/icu-small/source/i18n/collationfastlatinbuilder.cpp
index e5ba2f0e21..fc50e9df8e 100644
--- a/deps/icu-small/source/i18n/collationfastlatinbuilder.cpp
+++ b/deps/icu-small/source/i18n/collationfastlatinbuilder.cpp
@@ -91,7 +91,7 @@ CollationFastLatinBuilder::CollationFastLatinBuilder(UErrorCode &errorCode)
           contractionCEs(errorCode), uniqueCEs(errorCode),
           miniCEs(NULL),
           firstDigitPrimary(0), firstLatinPrimary(0), lastLatinPrimary(0),
-          firstShortPrimary(0), shortPrimaryOverflow(FALSE),
+          firstShortPrimary(0), shortPrimaryOverflow(false),
           headerLength(0) {
 }
 
@@ -101,24 +101,24 @@ CollationFastLatinBuilder::~CollationFastLatinBuilder() {
 
 UBool
 CollationFastLatinBuilder::forData(const CollationData &data, UErrorCode &errorCode) {
-    if(U_FAILURE(errorCode)) { return FALSE; }
+    if(U_FAILURE(errorCode)) { return false; }
     if(!result.isEmpty()) {  // This builder is not reusable.
         errorCode = U_INVALID_STATE_ERROR;
-        return FALSE;
+        return false;
     }
-    if(!loadGroups(data, errorCode)) { return FALSE; }
+    if(!loadGroups(data, errorCode)) { return false; }
 
     // Fast handling of digits.
     firstShortPrimary = firstDigitPrimary;
     getCEs(data, errorCode);
-    if(!encodeUniqueCEs(errorCode)) { return FALSE; }
+    if(!encodeUniqueCEs(errorCode)) { return false; }
     if(shortPrimaryOverflow) {
         // Give digits long mini primaries,
         // so that there are more short primaries for letters.
         firstShortPrimary = firstLatinPrimary;
         resetCEs();
         getCEs(data, errorCode);
-        if(!encodeUniqueCEs(errorCode)) { return FALSE; }
+        if(!encodeUniqueCEs(errorCode)) { return false; }
     }
     // Note: If we still have a short-primary overflow but not a long-primary overflow,
     // then we could calculate how many more long primaries would fit,
@@ -126,7 +126,7 @@ CollationFastLatinBuilder::forData(const CollationData &data, UErrorCode &errorC
     // and try again.
     // However, this might only benefit the en_US_POSIX tailoring,
     // and it is simpler to suppress building fast Latin data for it in genrb,
-    // or by returning FALSE here if shortPrimaryOverflow.
+    // or by returning false here if shortPrimaryOverflow.
 
     UBool ok = !shortPrimaryOverflow &&
             encodeCharCEs(errorCode) && encodeContractions(errorCode);
@@ -137,7 +137,7 @@ CollationFastLatinBuilder::forData(const CollationData &data, UErrorCode &errorC
 
 UBool
 CollationFastLatinBuilder::loadGroups(const CollationData &data, UErrorCode &errorCode) {
-    if(U_FAILURE(errorCode)) { return FALSE; }
+    if(U_FAILURE(errorCode)) { return false; }
     headerLength = 1 + NUM_SPECIAL_GROUPS;
     uint32_t r0 = (CollationFastLatin::VERSION << 8) | headerLength;
     result.append((UChar)r0);
@@ -147,7 +147,7 @@ CollationFastLatinBuilder::loadGroups(const CollationData &data, UErrorCode &err
         lastSpecialPrimaries[i] = data.getLastPrimaryForGroup(UCOL_REORDER_CODE_FIRST + i);
         if(lastSpecialPrimaries[i] == 0) {
             // missing data
-            return FALSE;
+            return false;
         }
         result.append((UChar)0);  // reserve a slot for this group
     }
@@ -157,9 +157,9 @@ CollationFastLatinBuilder::loadGroups(const CollationData &data, UErrorCode &err
     lastLatinPrimary = data.getLastPrimaryForGroup(USCRIPT_LATIN);
     if(firstDigitPrimary == 0 || firstLatinPrimary == 0) {
         // missing data
-        return FALSE;
+        return false;
     }
-    return TRUE;
+    return true;
 }
 
 UBool
@@ -169,7 +169,7 @@ CollationFastLatinBuilder::inSameGroup(uint32_t p, uint32_t q) const {
     if(p >= firstShortPrimary) {
         return q >= firstShortPrimary;
     } else if(q >= firstShortPrimary) {
-        return FALSE;
+        return false;
     }
     // Both or neither must be potentially-variable,
     // so that we can test only one and determine if both are variable.
@@ -177,7 +177,7 @@ CollationFastLatinBuilder::inSameGroup(uint32_t p, uint32_t q) const {
     if(p > lastVariablePrimary) {
         return q > lastVariablePrimary;
     } else if(q > lastVariablePrimary) {
-        return FALSE;
+        return false;
     }
     // Both will be encoded with long mini primaries.
     // They must be in the same special reordering group,
@@ -188,7 +188,7 @@ CollationFastLatinBuilder::inSameGroup(uint32_t p, uint32_t q) const {
         if(p <= lastPrimary) {
             return q <= lastPrimary;
         } else if(q <= lastPrimary) {
-            return FALSE;
+            return false;
         }
     }
 }
@@ -197,7 +197,7 @@ void
 CollationFastLatinBuilder::resetCEs() {
     contractionCEs.removeAllElements();
     uniqueCEs.removeAllElements();
-    shortPrimaryOverflow = FALSE;
+    shortPrimaryOverflow = false;
     result.truncate(headerLength);
 }
 
@@ -245,7 +245,7 @@ CollationFastLatinBuilder::getCEs(const CollationData &data, UErrorCode &errorCo
 UBool
 CollationFastLatinBuilder::getCEsFromCE32(const CollationData &data, UChar32 c, uint32_t ce32,
                                           UErrorCode &errorCode) {
-    if(U_FAILURE(errorCode)) { return FALSE; }
+    if(U_FAILURE(errorCode)) { return false; }
     ce32 = data.getFinalCE32(ce32);
     ce1 = 0;
     if(Collation::isSimpleOrLongCE32(ce32)) {
@@ -266,7 +266,7 @@ CollationFastLatinBuilder::getCEsFromCE32(const CollationData &data, UChar32 c,
                 }
                 break;
             } else {
-                return FALSE;
+                return false;
             }
         }
         case Collation::EXPANSION_TAG: {
@@ -279,7 +279,7 @@ CollationFastLatinBuilder::getCEsFromCE32(const CollationData &data, UChar32 c,
                 }
                 break;
             } else {
-                return FALSE;
+                return false;
             }
         }
         // Note: We could support PREFIX_TAG (assert c>=0)
@@ -295,24 +295,24 @@ CollationFastLatinBuilder::getCEsFromCE32(const CollationData &data, UChar32 c,
             ce0 = data.getCEFromOffsetCE32(c, ce32);
             break;
         default:
-            return FALSE;
+            return false;
         }
     }
     // A mapping can be completely ignorable.
     if(ce0 == 0) { return ce1 == 0; }
     // We do not support an ignorable ce0 unless it is completely ignorable.
     uint32_t p0 = (uint32_t)(ce0 >> 32);
-    if(p0 == 0) { return FALSE; }
+    if(p0 == 0) { return false; }
     // We only support primaries up to the Latin script.
-    if(p0 > lastLatinPrimary) { return FALSE; }
+    if(p0 > lastLatinPrimary) { return false; }
     // We support non-common secondary and case weights only together with short primaries.
     uint32_t lower32_0 = (uint32_t)ce0;
     if(p0 < firstShortPrimary) {
         uint32_t sc0 = lower32_0 & Collation::SECONDARY_AND_CASE_MASK;
-        if(sc0 != Collation::COMMON_SECONDARY_CE) { return FALSE; }
+        if(sc0 != Collation::COMMON_SECONDARY_CE) { return false; }
     }
     // No below-common tertiary weights.
-    if((lower32_0 & Collation::ONLY_TERTIARY_MASK) < Collation::COMMON_WEIGHT16) { return FALSE; }
+    if((lower32_0 & Collation::ONLY_TERTIARY_MASK) < Collation::COMMON_WEIGHT16) { return false; }
     if(ce1 != 0) {
         // Both primaries must be in the same group,
         // or both must get short mini primaries,
@@ -320,28 +320,28 @@ CollationFastLatinBuilder::getCEsFromCE32(const CollationData &data, UChar32 c,
         // This is so that we can test the first primary and use the same mask for both,
         // and determine for both whether they are variable.
         uint32_t p1 = (uint32_t)(ce1 >> 32);
-        if(p1 == 0 ? p0 < firstShortPrimary : !inSameGroup(p0, p1)) { return FALSE; }
+        if(p1 == 0 ? p0 < firstShortPrimary : !inSameGroup(p0, p1)) { return false; }
         uint32_t lower32_1 = (uint32_t)ce1;
         // No tertiary CEs.
-        if((lower32_1 >> 16) == 0) { return FALSE; }
+        if((lower32_1 >> 16) == 0) { return false; }
         // We support non-common secondary and case weights
         // only for secondary CEs or together with short primaries.
         if(p1 != 0 && p1 < firstShortPrimary) {
             uint32_t sc1 = lower32_1 & Collation::SECONDARY_AND_CASE_MASK;
-            if(sc1 != Collation::COMMON_SECONDARY_CE) { return FALSE; }
+            if(sc1 != Collation::COMMON_SECONDARY_CE) { return false; }
         }
         // No below-common tertiary weights.
-        if((lower32_1 & Collation::ONLY_TERTIARY_MASK) < Collation::COMMON_WEIGHT16) { return FALSE; }
+        if((lower32_1 & Collation::ONLY_TERTIARY_MASK) < Collation::COMMON_WEIGHT16) { return false; }
     }
     // No quaternary weights.
-    if(((ce0 | ce1) & Collation::QUATERNARY_MASK) != 0) { return FALSE; }
-    return TRUE;
+    if(((ce0 | ce1) & Collation::QUATERNARY_MASK) != 0) { return false; }
+    return true;
 }
 
 UBool
 CollationFastLatinBuilder::getCEsFromContractionCE32(const CollationData &data, uint32_t ce32,
                                                      UErrorCode &errorCode) {
-    if(U_FAILURE(errorCode)) { return FALSE; }
+    if(U_FAILURE(errorCode)) { return false; }
     const UChar *p = data.contexts + Collation::indexFromCE32(ce32);
     ce32 = CollationData::readCE32(p);  // Default if no suffix match.
     // Since the original ce32 is not a prefix mapping,
@@ -357,7 +357,7 @@ CollationFastLatinBuilder::getCEsFromContractionCE32(const CollationData &data,
     // Handle an encodable contraction unless the next contraction is too long
     // and starts with the same character.
     int32_t prevX = -1;
-    UBool addContraction = FALSE;
+    UBool addContraction = false;
     UCharsTrie::Iterator suffixes(p + 2, 0, errorCode);
     while(suffixes.next(errorCode)) {
         const UnicodeString &suffix = suffixes.getString();
@@ -367,7 +367,7 @@ CollationFastLatinBuilder::getCEsFromContractionCE32(const CollationData &data,
             if(addContraction) {
                 // Bail out for all contractions starting with this character.
                 addContractionEntry(x, Collation::NO_CE, 0, errorCode);
-                addContraction = FALSE;
+                addContraction = false;
             }
             continue;
         }
@@ -376,17 +376,17 @@ CollationFastLatinBuilder::getCEsFromContractionCE32(const CollationData &data,
         }
         ce32 = (uint32_t)suffixes.getValue();
         if(suffix.length() == 1 && getCEsFromCE32(data, U_SENTINEL, ce32, errorCode)) {
-            addContraction = TRUE;
+            addContraction = true;
         } else {
             addContractionEntry(x, Collation::NO_CE, 0, errorCode);
-            addContraction = FALSE;
+            addContraction = false;
         }
         prevX = x;
     }
     if(addContraction) {
         addContractionEntry(prevX, ce0, ce1, errorCode);
     }
-    if(U_FAILURE(errorCode)) { return FALSE; }
+    if(U_FAILURE(errorCode)) { return false; }
     // Note: There might not be any fast Latin contractions, but
     // we need to enter contraction handling anyway so that we can bail out
     // when there is a non-fast-Latin character following.
@@ -394,7 +394,7 @@ CollationFastLatinBuilder::getCEsFromContractionCE32(const CollationData &data,
     // following umlaut and bail out, rather than return the difference of Y vs. u.
     ce0 = ((int64_t)Collation::NO_CE_PRIMARY << 32) | CONTRACTION_FLAG | contractionIndex;
     ce1 = 0;
-    return TRUE;
+    return true;
 }
 
 void
@@ -428,12 +428,12 @@ CollationFastLatinBuilder::getMiniCE(int64_t ce) const {
 
 UBool
 CollationFastLatinBuilder::encodeUniqueCEs(UErrorCode &errorCode) {
-    if(U_FAILURE(errorCode)) { return FALSE; }
+    if(U_FAILURE(errorCode)) { return false; }
     uprv_free(miniCEs);
     miniCEs = (uint16_t *)uprv_malloc(uniqueCEs.size() * 2);
     if(miniCEs == NULL) {
         errorCode = U_MEMORY_ALLOCATION_ERROR;
-        return FALSE;
+        return false;
     }
     int32_t group = 0;
     uint32_t lastGroupPrimary = lastSpecialPrimaries[group];
@@ -484,7 +484,7 @@ CollationFastLatinBuilder::encodeUniqueCEs(UErrorCode &errorCode) {
 #if DEBUG_COLLATION_FAST_LATIN_BUILDER
                     printf("short-primary overflow for %08x\n", p);
 #endif
-                    shortPrimaryOverflow = TRUE;
+                    shortPrimaryOverflow = true;
                     miniCEs[i] = CollationFastLatin::BAIL_OUT;
                     continue;
                 }
@@ -563,7 +563,7 @@ CollationFastLatinBuilder::encodeUniqueCEs(UErrorCode &errorCode) {
 
 UBool
 CollationFastLatinBuilder::encodeCharCEs(UErrorCode &errorCode) {
-    if(U_FAILURE(errorCode)) { return FALSE; }
+    if(U_FAILURE(errorCode)) { return false; }
     int32_t miniCEsStart = result.length();
     for(int32_t i = 0; i < CollationFastLatin::NUM_FAST_CHARS; ++i) {
         result.append((UChar)0);  // initialize to completely ignorable
@@ -594,7 +594,7 @@ UBool
 CollationFastLatinBuilder::encodeContractions(UErrorCode &errorCode) {
     // We encode all contraction lists so that the first word of a list
     // terminates the previous list, and we only need one additional terminator at the end.
-    if(U_FAILURE(errorCode)) { return FALSE; }
+    if(U_FAILURE(errorCode)) { return false; }
     int32_t indexBase = headerLength + CollationFastLatin::NUM_FAST_CHARS;
     int32_t firstContractionIndex = result.length();
     for(int32_t i = 0; i < CollationFastLatin::NUM_FAST_CHARS; ++i) {
@@ -605,7 +605,7 @@ CollationFastLatinBuilder::encodeContractions(UErrorCode &errorCode) {
             result.setCharAt(headerLength + i, CollationFastLatin::BAIL_OUT);
             continue;
         }
-        UBool firstTriple = TRUE;
+        UBool firstTriple = true;
         for(int32_t index = (int32_t)ce & 0x7fffffff;; index += 3) {
             int32_t x = static_cast<int32_t>(contractionCEs.elementAti(index));
             if((uint32_t)x == CollationFastLatin::CONTR_CHAR_MASK && !firstTriple) { break; }
@@ -621,7 +621,7 @@ CollationFastLatinBuilder::encodeContractions(UErrorCode &errorCode) {
                 result.append((UChar)(x | (3 << CollationFastLatin::CONTR_LENGTH_SHIFT)));
                 result.append((UChar)(miniCE >> 16)).append((UChar)miniCE);
             }
-            firstTriple = FALSE;
+            firstTriple = false;
         }
         // Note: There is a chance that this new contraction list is the same as a previous one,
         // and if so, then we could truncate the result and reuse the other list.
@@ -635,7 +635,7 @@ CollationFastLatinBuilder::encodeContractions(UErrorCode &errorCode) {
     }
     if(result.isBogus()) {
         errorCode = U_MEMORY_ALLOCATION_ERROR;
-        return FALSE;
+        return false;
     }
 #if DEBUG_COLLATION_FAST_LATIN_BUILDER
     printf("** fast Latin %d * 2 = %d bytes\n", result.length(), result.length() * 2);
@@ -663,7 +663,7 @@ CollationFastLatinBuilder::encodeContractions(UErrorCode &errorCode) {
     }
     puts("");
 #endif
-    return TRUE;
+    return true;
 }
 
 uint32_t
diff --git a/deps/icu-small/source/i18n/collationfcd.cpp b/deps/icu-small/source/i18n/collationfcd.cpp
index 0be4150b09..e1f1d0330c 100644
--- a/deps/icu-small/source/i18n/collationfcd.cpp
+++ b/deps/icu-small/source/i18n/collationfcd.cpp
@@ -151,7 +151,7 @@ const uint32_t CollationFCD::lcccBits[73]={
 0x200ff800,0xfbc00000,0x3eef,0xe000000,0xff000000,0xfffffc00,0xfffffffb,0x10000000,0x1e2000,0x2000,0x40000000,0x602000,0x18000000,0x400,0x7000000,0xf00,
 0x3000000,0x2a00000,0x3c3e0000,0xdf,0x40,0x6800000,0xe0000000,0x300000,0x100000,0x20040000,0x200,0x1800000,0x9fe00001,0xbfff0000,0x7fff,0x10,
 0xff800,0xc00,0xc0040,0x800000,0xfff70000,0x31021fd,0x1fff0000,0x1ffe2,0x38000,0x80000000,0xfc00,0x6000000,0x3ff08000,0xc0000000,0x30000,0x1000,
-0x3ffff,0x3800,0x80000,1,0xc19d0000,2,0x400000,0xc0000fd,0x5108000
+0x3ffff,0x3800,0x80000,1,0xc19d0000,2,0x400000,0xc0000fd,0x7108000
 };
 
 const uint8_t CollationFCD::tcccIndex[2048]={
@@ -293,7 +293,7 @@ const uint32_t CollationFCD::tcccBits[123]={
 0xe0000000,0x300000,0x100000,0x20040000,0x200,0x1800000,0x9fe00001,0xbfff0000,0x7fff,0x10,0xff800,0xc00,0xc0040,0x800000,0xfff70000,0x31021fd,
 0xbffffff,0x3ffffff,0x3f3fffff,0xaaff3f3f,0x3fffffff,0x1fdfffff,0xefcfffde,0x1fdc7fff,0x1fff0000,0x1ffe2,0x800,0xc000000,0x4000,0xe000,0x1210,0x50,
 0x292,0x333e005,0x333,0xf000,0x3c0f,0x38000,0x80000000,0xfc00,0x55555000,0x36db02a5,0x46100000,0x47900000,0x3ff08000,0xc0000000,0x30000,0x1000,
-0x3ffff,0x3800,0x80000,1,0xc19d0000,2,0x400000,0xc0000fd,0x5108000,0x5f7ffc00,0x7fdb
+0x3ffff,0x3800,0x80000,1,0xc19d0000,2,0x400000,0xc0000fd,0x7108000,0x5f7ffc00,0x7fdb
 };
 
 U_NAMESPACE_END
diff --git a/deps/icu-small/source/i18n/collationfcd.h b/deps/icu-small/source/i18n/collationfcd.h
index 3a5738efb2..9620452b97 100644
--- a/deps/icu-small/source/i18n/collationfcd.h
+++ b/deps/icu-small/source/i18n/collationfcd.h
@@ -123,7 +123,7 @@ public:
     }
 
 private:
-    CollationFCD();  // No instantiation.
+    CollationFCD() = delete;  // No instantiation.
 
     static const uint8_t lcccIndex[2048];
     static const uint8_t tcccIndex[2048];
diff --git a/deps/icu-small/source/i18n/collationiterator.cpp b/deps/icu-small/source/i18n/collationiterator.cpp
index 6bfdfbe7c7..a47b3d86be 100644
--- a/deps/icu-small/source/i18n/collationiterator.cpp
+++ b/deps/icu-small/source/i18n/collationiterator.cpp
@@ -36,8 +36,8 @@ CollationIterator::CEBuffer::~CEBuffer() {}
 UBool
 CollationIterator::CEBuffer::ensureAppendCapacity(int32_t appCap, UErrorCode &errorCode) {
     int32_t capacity = buffer.getCapacity();
-    if((length + appCap) <= capacity) { return TRUE; }
-    if(U_FAILURE(errorCode)) { return FALSE; }
+    if((length + appCap) <= capacity) { return true; }
+    if(U_FAILURE(errorCode)) { return false; }
     do {
         if(capacity < 1000) {
             capacity *= 4;
@@ -48,9 +48,9 @@ CollationIterator::CEBuffer::ensureAppendCapacity(int32_t appCap, UErrorCode &er
     int64_t *p = buffer.resize(capacity, length);
     if(p == NULL) {
         errorCode = U_MEMORY_ALLOCATION_ERROR;
-        return FALSE;
+        return false;
     }
-    return TRUE;
+    return true;
 }
 
 // State of combining marks skipped in discontiguous contraction.
@@ -216,12 +216,12 @@ CollationIterator::handleGetTrailSurrogate() {
 
 UBool
 CollationIterator::foundNULTerminator() {
-    return FALSE;
+    return false;
 }
 
 UBool
 CollationIterator::forbidSurrogateCodePoints() const {
-    return FALSE;
+    return false;
 }
 
 uint32_t
@@ -239,7 +239,7 @@ int64_t
 CollationIterator::nextCEFromCE32(const CollationData *d, UChar32 c, uint32_t ce32,
                                   UErrorCode &errorCode) {
     --ceBuffer.length;  // Undo ceBuffer.incLength().
-    appendCEsFromCE32(d, c, ce32, TRUE, errorCode);
+    appendCEsFromCE32(d, c, ce32, true, errorCode);
     if(U_SUCCESS(errorCode)) {
         return ceBuffer.get(cesIndex++);
     } else {
@@ -661,7 +661,7 @@ CollationIterator::nextCE32FromDiscontiguousContraction(
         // and then from the combining marks that we skipped before the match.
         c = U_SENTINEL;
         for(;;) {
-            appendCEsFromCE32(d, c, ce32, TRUE, errorCode);
+            appendCEsFromCE32(d, c, ce32, true, errorCode);
             // Fetch CE32s for skipped combining marks from the normal data, with fallback,
             // rather than from the CollationData where we found the contraction.
             if(!skipped->hasNext()) { break; }
@@ -864,7 +864,7 @@ CollationIterator::previousCE(UVector32 &offsets, UErrorCode &errorCode) {
     if(Collation::isSimpleOrLongCE32(ce32)) {
         return Collation::ceFromCE32(ce32);
     }
-    appendCEsFromCE32(d, c, ce32, FALSE, errorCode);
+    appendCEsFromCE32(d, c, ce32, false, errorCode);
     if(U_SUCCESS(errorCode)) {
         if(ceBuffer.length > 1) {
             offsets.addElement(getOffset(), errorCode);
diff --git a/deps/icu-small/source/i18n/collationiterator.h b/deps/icu-small/source/i18n/collationiterator.h
index 73cb93b934..93c119c6b8 100644
--- a/deps/icu-small/source/i18n/collationiterator.h
+++ b/deps/icu-small/source/i18n/collationiterator.h
@@ -92,8 +92,8 @@ private:
         int32_t length;
 
     private:
-        CEBuffer(const CEBuffer &);
-        void operator=(const CEBuffer &);
+        CEBuffer(const CEBuffer &) = delete;
+        void operator=(const CEBuffer &) = delete;
 
         MaybeStackArray<int64_t, INITIAL_CAPACITY> buffer;
     };
diff --git a/deps/icu-small/source/i18n/collationkeys.cpp b/deps/icu-small/source/i18n/collationkeys.cpp
index b5c322fb44..c7e0de618d 100644
--- a/deps/icu-small/source/i18n/collationkeys.cpp
+++ b/deps/icu-small/source/i18n/collationkeys.cpp
@@ -90,10 +90,10 @@ namespace {
  */
 class SortKeyLevel : public UMemory {
 public:
-    SortKeyLevel() : len(0), ok(TRUE) {}
+    SortKeyLevel() : len(0), ok(true) {}
     ~SortKeyLevel() {}
 
-    /** @return FALSE if memory allocation failed */
+    /** @return false if memory allocation failed */
     UBool isOk() const { return ok; }
     UBool isEmpty() const { return len == 0; }
     int32_t length() const { return len; }
@@ -182,7 +182,7 @@ SortKeyLevel::appendReverseWeight16(uint32_t w) {
 
 UBool SortKeyLevel::ensureCapacity(int32_t appendCapacity) {
     if(!ok) {
-        return FALSE;
+        return false;
     }
     int32_t newCapacity = 2 * buffer.getCapacity();
     int32_t altCapacity = len + 2 * appendCapacity;
@@ -193,9 +193,9 @@ UBool SortKeyLevel::ensureCapacity(int32_t appendCapacity) {
         newCapacity = 200;
     }
     if(buffer.resize(newCapacity, len)==NULL) {
-        return ok = FALSE;
+        return ok = false;
     }
-    return TRUE;
+    return true;
 }
 
 }  // namespace
@@ -203,7 +203,7 @@ UBool SortKeyLevel::ensureCapacity(int32_t appendCapacity) {
 CollationKeys::LevelCallback::~LevelCallback() {}
 
 UBool
-CollationKeys::LevelCallback::needToWrite(Collation::Level /*level*/) { return TRUE; }
+CollationKeys::LevelCallback::needToWrite(Collation::Level /*level*/) { return true; }
 
 /**
  * Map from collation strength (UColAttributeValue)
@@ -619,7 +619,7 @@ CollationKeys::writeSortKeyUpToQuaternary(CollationIterator &iter,
     if(U_FAILURE(errorCode)) { return; }
 
     // Append the beyond-primary levels.
-    UBool ok = TRUE;
+    UBool ok = true;
     if((levels & Collation::SECONDARY_LEVEL_FLAG) != 0) {
         if(!callback.needToWrite(Collation::SECONDARY_LEVEL)) { return; }
         ok &= secondaries.isOk();
diff --git a/deps/icu-small/source/i18n/collationkeys.h b/deps/icu-small/source/i18n/collationkeys.h
index 5b41d14c0b..8dad286dc6 100644
--- a/deps/icu-small/source/i18n/collationkeys.h
+++ b/deps/icu-small/source/i18n/collationkeys.h
@@ -116,7 +116,7 @@ public:
 private:
     friend struct CollationDataReader;
 
-    CollationKeys();  // no instantiation
+    CollationKeys() = delete;  // no instantiation
 
     // Secondary level: Compress up to 33 common weights as 05..25 or 25..45.
     static const uint32_t SEC_COMMON_LOW = Collation::COMMON_BYTE;
diff --git a/deps/icu-small/source/i18n/collationroot.cpp b/deps/icu-small/source/i18n/collationroot.cpp
index 71753bd6f4..dc88c35a68 100644
--- a/deps/icu-small/source/i18n/collationroot.cpp
+++ b/deps/icu-small/source/i18n/collationroot.cpp
@@ -27,13 +27,14 @@
 #include "ucln_in.h"
 #include "udatamem.h"
 #include "umutex.h"
+#include "umapfile.h"
 
 U_NAMESPACE_BEGIN
 
 namespace {
 
 static const CollationCacheEntry *rootSingleton = NULL;
-static UInitOnce initOnce = U_INITONCE_INITIALIZER;
+static UInitOnce initOnce {};
 
 }  // namespace
 
@@ -42,22 +43,51 @@ U_CDECL_BEGIN
 static UBool U_CALLCONV uprv_collation_root_cleanup() {
     SharedObject::clearPtr(rootSingleton);
     initOnce.reset();
-    return TRUE;
+    return true;
 }
 
 U_CDECL_END
 
+UDataMemory*
+CollationRoot::loadFromFile(const char* ucadataPath, UErrorCode &errorCode) {
+    UDataMemory dataMemory;
+    UDataMemory  *rDataMem = NULL;
+    if (U_FAILURE(errorCode)) {
+        return NULL;
+    }
+    if (uprv_mapFile(&dataMemory, ucadataPath, &errorCode)) {
+        if (dataMemory.pHeader->dataHeader.magic1 == 0xda &&
+            dataMemory.pHeader->dataHeader.magic2 == 0x27 &&
+            CollationDataReader::isAcceptable(NULL, "icu", "ucadata", &dataMemory.pHeader->info)) {
+            rDataMem = UDataMemory_createNewInstance(&errorCode);
+            if (U_FAILURE(errorCode)) {
+                return NULL;
+            }
+            rDataMem->pHeader = dataMemory.pHeader;
+            rDataMem->mapAddr = dataMemory.mapAddr;
+            rDataMem->map = dataMemory.map;
+            return rDataMem;
+        }
+        errorCode = U_INVALID_FORMAT_ERROR;
+        return NULL;
+    }
+    errorCode = U_MISSING_RESOURCE_ERROR;
+    return NULL;
+}
+
 void U_CALLCONV
-CollationRoot::load(UErrorCode &errorCode) {
+CollationRoot::load(const char* ucadataPath, UErrorCode &errorCode) {
     if(U_FAILURE(errorCode)) { return; }
     LocalPointer<CollationTailoring> t(new CollationTailoring(NULL));
     if(t.isNull() || t->isBogus()) {
         errorCode = U_MEMORY_ALLOCATION_ERROR;
         return;
     }
-    t->memory = udata_openChoice(U_ICUDATA_NAME U_TREE_SEPARATOR_STRING "coll",
-                                 "icu", "ucadata",
-                                 CollationDataReader::isAcceptable, t->version, &errorCode);
+    t->memory = ucadataPath ? CollationRoot::loadFromFile(ucadataPath, errorCode) :
+                              udata_openChoice(U_ICUDATA_NAME U_TREE_SEPARATOR_STRING "coll",
+                                               "icu", "ucadata",
+                                               CollationDataReader::isAcceptable,
+                                               t->version, &errorCode);
     if(U_FAILURE(errorCode)) { return; }
     const uint8_t *inBytes = static_cast<const uint8_t *>(udata_getMemory(t->memory));
     CollationDataReader::read(NULL, inBytes, udata_getLength(t->memory), *t, errorCode);
@@ -73,14 +103,14 @@ CollationRoot::load(UErrorCode &errorCode) {
 
 const CollationCacheEntry *
 CollationRoot::getRootCacheEntry(UErrorCode &errorCode) {
-    umtx_initOnce(initOnce, CollationRoot::load, errorCode);
+    umtx_initOnce(initOnce, CollationRoot::load, static_cast<const char*>(NULL), errorCode);
     if(U_FAILURE(errorCode)) { return NULL; }
     return rootSingleton;
 }
 
 const CollationTailoring *
 CollationRoot::getRoot(UErrorCode &errorCode) {
-    umtx_initOnce(initOnce, CollationRoot::load, errorCode);
+    umtx_initOnce(initOnce, CollationRoot::load, static_cast<const char*>(NULL), errorCode);
     if(U_FAILURE(errorCode)) { return NULL; }
     return rootSingleton->tailoring;
 }
@@ -99,6 +129,12 @@ CollationRoot::getSettings(UErrorCode &errorCode) {
     return root->settings;
 }
 
+void
+CollationRoot::forceLoadFromFile(const char* ucadataPath, UErrorCode &errorCode) {
+    umtx_initOnce(initOnce, CollationRoot::load, ucadataPath, errorCode);
+}
+
+
 U_NAMESPACE_END
 
 #endif  // !UCONFIG_NO_COLLATION
diff --git a/deps/icu-small/source/i18n/collationroot.h b/deps/icu-small/source/i18n/collationroot.h
index 8cd3046cdf..b203f612b3 100644
--- a/deps/icu-small/source/i18n/collationroot.h
+++ b/deps/icu-small/source/i18n/collationroot.h
@@ -15,6 +15,7 @@
 #define __COLLATIONROOT_H__
 
 #include "unicode/utypes.h"
+#include "unicode/udata.h"
 
 #if !UCONFIG_NO_COLLATION
 
@@ -34,9 +35,11 @@ public:
     static const CollationTailoring *getRoot(UErrorCode &errorCode);
     static const CollationData *getData(UErrorCode &errorCode);
     static const CollationSettings *getSettings(UErrorCode &errorCode);
+    static void U_EXPORT2 forceLoadFromFile(const char* ucadataPath, UErrorCode &errorCode);
 
 private:
-    static void U_CALLCONV load(UErrorCode &errorCode);
+    static void U_CALLCONV load(const char* ucadataPath, UErrorCode &errorCode);
+    static UDataMemory* loadFromFile(const char* ucadataPath, UErrorCode &errorCode);
 };
 
 U_NAMESPACE_END
diff --git a/deps/icu-small/source/i18n/collationruleparser.cpp b/deps/icu-small/source/i18n/collationruleparser.cpp
index ade6ecb552..7fb95c0b2b 100644
--- a/deps/icu-small/source/i18n/collationruleparser.cpp
+++ b/deps/icu-small/source/i18n/collationruleparser.cpp
@@ -128,7 +128,7 @@ CollationRuleParser::parse(const UnicodeString &ruleString, UErrorCode &errorCod
 void
 CollationRuleParser::parseRuleChain(UErrorCode &errorCode) {
     int32_t resetStrength = parseResetAndPosition(errorCode);
-    UBool isFirstRelation = TRUE;
+    UBool isFirstRelation = true;
     for(;;) {
         int32_t result = parseRelationOperator(errorCode);
         if(U_FAILURE(errorCode)) { return; }
@@ -165,7 +165,7 @@ CollationRuleParser::parseRuleChain(UErrorCode &errorCode) {
             parseStarredCharacters(strength, i, errorCode);
         }
         if(U_FAILURE(errorCode)) { return; }
-        isFirstRelation = FALSE;
+        isFirstRelation = false;
     }
 }
 
diff --git a/deps/icu-small/source/i18n/collationsets.cpp b/deps/icu-small/source/i18n/collationsets.cpp
index 09581416a8..b23c5e318d 100644
--- a/deps/icu-small/source/i18n/collationsets.cpp
+++ b/deps/icu-small/source/i18n/collationsets.cpp
@@ -34,7 +34,7 @@ U_CDECL_BEGIN
 static UBool U_CALLCONV
 enumTailoredRange(const void *context, UChar32 start, UChar32 end, uint32_t ce32) {
     if(ce32 == Collation::FALLBACK_CE32) {
-        return TRUE;  // fallback to base, not tailored
+        return true;  // fallback to base, not tailored
     }
     TailoredSet *ts = (TailoredSet *)context;
     return ts->handleCE32(start, end, ce32);
@@ -365,14 +365,14 @@ enumCnERange(const void *context, UChar32 start, UChar32 end, uint32_t ce32) {
     } else if(cne->checkTailored < 0) {
         // Collect the set of code points with mappings in the tailoring data.
         if(ce32 == Collation::FALLBACK_CE32) {
-            return TRUE;  // fallback to base, not tailored
+            return true;  // fallback to base, not tailored
         } else {
             cne->tailored.add(start, end);
         }
         // checkTailored > 0: Exclude tailored ranges from the base data enumeration.
     } else if(start == end) {
         if(cne->tailored.contains(start)) {
-            return TRUE;
+            return true;
         }
     } else if(cne->tailored.containsSome(start, end)) {
         cne->ranges.set(start, end).removeAll(cne->tailored);
@@ -509,7 +509,7 @@ ContractionsAndExpansions::handleCE32(UChar32 start, UChar32 end, uint32_t ce32)
             if(sink != NULL) {
                 // TODO: This should be optimized,
                 // especially if [start..end] is the complete Hangul range. (assert that)
-                UTF16CollationIterator iter(data, FALSE, NULL, NULL, NULL);
+                UTF16CollationIterator iter(data, false, NULL, NULL, NULL);
                 UChar hangul[1] = { 0 };
                 for(UChar32 c = start; c <= end; ++c) {
                     hangul[0] = (UChar)c;
diff --git a/deps/icu-small/source/i18n/collationsettings.cpp b/deps/icu-small/source/i18n/collationsettings.cpp
index 9eeab48331..fe051880b8 100644
--- a/deps/icu-small/source/i18n/collationsettings.cpp
+++ b/deps/icu-small/source/i18n/collationsettings.cpp
@@ -248,10 +248,10 @@ CollationSettings::reorderTableHasSplitBytes(const uint8_t table[256]) {
     U_ASSERT(table[0] == 0);
     for(int32_t i = 1; i < 256; ++i) {
         if(table[i] == 0) {
-            return TRUE;
+            return true;
         }
     }
-    return FALSE;
+    return false;
 }
 
 uint32_t
diff --git a/deps/icu-small/source/i18n/collationtailoring.cpp b/deps/icu-small/source/i18n/collationtailoring.cpp
index 78a11fbb26..440414c433 100644
--- a/deps/icu-small/source/i18n/collationtailoring.cpp
+++ b/deps/icu-small/source/i18n/collationtailoring.cpp
@@ -68,18 +68,18 @@ CollationTailoring::~CollationTailoring() {
 
 UBool
 CollationTailoring::ensureOwnedData(UErrorCode &errorCode) {
-    if(U_FAILURE(errorCode)) { return FALSE; }
+    if(U_FAILURE(errorCode)) { return false; }
     if(ownedData == NULL) {
         const Normalizer2Impl *nfcImpl = Normalizer2Factory::getNFCImpl(errorCode);
-        if(U_FAILURE(errorCode)) { return FALSE; }
+        if(U_FAILURE(errorCode)) { return false; }
         ownedData = new CollationData(*nfcImpl);
         if(ownedData == NULL) {
             errorCode = U_MEMORY_ALLOCATION_ERROR;
-            return FALSE;
+            return false;
         }
     }
     data = ownedData;
-    return TRUE;
+    return true;
 }
 
 void
diff --git a/deps/icu-small/source/i18n/collationtailoring.h b/deps/icu-small/source/i18n/collationtailoring.h
index 5fc2bac2d3..a6143c1c26 100644
--- a/deps/icu-small/source/i18n/collationtailoring.h
+++ b/deps/icu-small/source/i18n/collationtailoring.h
@@ -24,6 +24,8 @@
 #include "collationsettings.h"
 #include "uhash.h"
 #include "umutex.h"
+#include "unifiedcache.h"
+ 
 
 struct UDataMemory;
 struct UResourceBundle;
@@ -89,7 +91,7 @@ private:
      * No copy constructor: A CollationTailoring cannot be copied.
      * It is immutable, and the data trie cannot be copied either.
      */
-    CollationTailoring(const CollationTailoring &other);
+    CollationTailoring(const CollationTailoring &other) = delete;
 };
 
 struct U_I18N_API CollationCacheEntry : public SharedObject {
@@ -105,6 +107,10 @@ struct U_I18N_API CollationCacheEntry : public SharedObject {
     const CollationTailoring *tailoring;
 };
 
+template<> U_I18N_API
+const CollationCacheEntry *
+LocaleCacheKey<CollationCacheEntry>::createObject(const void *creationContext,
+                                                  UErrorCode &errorCode) const;
 U_NAMESPACE_END
 
 #endif  // !UCONFIG_NO_COLLATION
diff --git a/deps/icu-small/source/i18n/collationweights.cpp b/deps/icu-small/source/i18n/collationweights.cpp
index 05458962c6..02d0268f53 100644
--- a/deps/icu-small/source/i18n/collationweights.cpp
+++ b/deps/icu-small/source/i18n/collationweights.cpp
@@ -227,7 +227,7 @@ CollationWeights::getWeightRanges(uint32_t lowerLimit, uint32_t upperLimit) {
 #ifdef UCOL_DEBUG
         printf("error: no space between lower & upper limits\n");
 #endif
-        return FALSE;
+        return false;
     }
 
     /* check that neither is a prefix of the other */
@@ -236,7 +236,7 @@ CollationWeights::getWeightRanges(uint32_t lowerLimit, uint32_t upperLimit) {
 #ifdef UCOL_DEBUG
             printf("error: lower limit 0x%08lx is a prefix of upper limit 0x%08lx\n", lowerLimit, upperLimit);
 #endif
-            return FALSE;
+            return false;
         }
     }
     /* if the upper limit is a prefix of the lower limit then the earlier test lowerLimit>=upperLimit has caught it */
@@ -307,7 +307,7 @@ CollationWeights::getWeightRanges(uint32_t lowerLimit, uint32_t upperLimit) {
                 // maxByte (for lowerEnd) or minByte (for upperStart).
                 const uint32_t lowerEnd=lower[length].end;
                 const uint32_t upperStart=upper[length].start;
-                UBool merged=FALSE;
+                UBool merged=false;
 
                 if(lowerEnd>upperStart) {
                     // These two lower and upper ranges collide.
@@ -326,7 +326,7 @@ CollationWeights::getWeightRanges(uint32_t lowerLimit, uint32_t upperLimit) {
                             (int32_t)getWeightTrail(lower[length].start, length)+1;
                     // count might be <=0 in which case there is no room,
                     // and the range-collecting code below will ignore this range.
-                    merged=TRUE;
+                    merged=true;
                 } else if(lowerEnd==upperStart) {
                     // Not possible, unless minByte==maxByte which is not allowed.
                     U_ASSERT(minBytes[length]<maxBytes[length]);
@@ -335,7 +335,7 @@ CollationWeights::getWeightRanges(uint32_t lowerLimit, uint32_t upperLimit) {
                         // Merge adjacent ranges.
                         lower[length].end=upper[length].end;
                         lower[length].count+=upper[length].count;  // might be >countBytes
-                        merged=TRUE;
+                        merged=true;
                     }
                 }
                 if(merged) {
@@ -409,14 +409,14 @@ CollationWeights::allocWeightsInShortRanges(int32_t n, int32_t minLength) {
                 /* sort the ranges by weight values */
                 UErrorCode errorCode=U_ZERO_ERROR;
                 uprv_sortArray(ranges, rangeCount, sizeof(WeightRange),
-                               compareRanges, NULL, FALSE, &errorCode);
+                               compareRanges, NULL, false, &errorCode);
                 /* ignore error code: we know that the internal sort function will not fail here */
             }
-            return TRUE;
+            return true;
         }
         n -= ranges[i].count;  // still >0
     }
-    return FALSE;
+    return false;
 }
 
 UBool
@@ -433,7 +433,7 @@ CollationWeights::allocWeightsInMinLengthRanges(int32_t n, int32_t minLength) {
     }
 
     int32_t nextCountBytes = countBytes(minLength + 1);
-    if(n > count * nextCountBytes) { return FALSE; }
+    if(n > count * nextCountBytes) { return false; }
 
     // Use the minLength ranges. Merge them, and then split again as necessary.
     uint32_t start = ranges[0].start;
@@ -485,7 +485,7 @@ CollationWeights::allocWeightsInMinLengthRanges(int32_t n, int32_t minLength) {
         lengthenRange(ranges[1]);
         rangeCount = 2;
     }
-    return TRUE;
+    return true;
 }
 
 /*
@@ -503,7 +503,7 @@ CollationWeights::allocWeights(uint32_t lowerLimit, uint32_t upperLimit, int32_t
 #ifdef UCOL_DEBUG
         printf("error: unable to get Weight ranges\n");
 #endif
-        return FALSE;
+        return false;
     }
 
     /* try until we find suitably large ranges */
@@ -518,7 +518,7 @@ CollationWeights::allocWeights(uint32_t lowerLimit, uint32_t upperLimit, int32_t
             printf("error: the maximum number of %ld weights is insufficient for n=%ld\n",
                    minLengthCount, n);
 #endif
-            return FALSE;
+            return false;
         }
 
         if(allocWeightsInMinLengthRanges(n, minLength)) { break; }
@@ -541,7 +541,7 @@ CollationWeights::allocWeights(uint32_t lowerLimit, uint32_t upperLimit, int32_t
 #endif
 
     rangeIndex = 0;
-    return TRUE;
+    return true;
 }
 
 uint32_t
diff --git a/deps/icu-small/source/i18n/coptccal.cpp b/deps/icu-small/source/i18n/coptccal.cpp
index 9c2b1ebbb7..0be700ca01 100644
--- a/deps/icu-small/source/i18n/coptccal.cpp
+++ b/deps/icu-small/source/i18n/coptccal.cpp
@@ -103,7 +103,7 @@ CopticCalendar::handleComputeFields(int32_t julianDay, UErrorCode &/*status*/)
  */
 static UDate           gSystemDefaultCenturyStart       = DBL_MIN;
 static int32_t         gSystemDefaultCenturyStartYear   = -1;
-static icu::UInitOnce  gSystemDefaultCenturyInit        = U_INITONCE_INITIALIZER;
+static icu::UInitOnce  gSystemDefaultCenturyInit        {};
 
 
 static void U_CALLCONV initializeSystemDefaultCentury() {
diff --git a/deps/icu-small/source/i18n/cpdtrans.cpp b/deps/icu-small/source/i18n/cpdtrans.cpp
index dc0217ba61..f2b1c36a33 100644
--- a/deps/icu-small/source/i18n/cpdtrans.cpp
+++ b/deps/icu-small/source/i18n/cpdtrans.cpp
@@ -73,7 +73,7 @@ CompoundTransliterator::CompoundTransliterator(const UnicodeString& id,
     trans(0), numAnonymousRBTs(0) {
     // TODO add code for parseError...currently unused, but
     // later may be used by parsing code...
-    init(id, direction, TRUE, status);
+    init(id, direction, true, status);
 }
 
 CompoundTransliterator::CompoundTransliterator(const UnicodeString& id,
@@ -83,7 +83,7 @@ CompoundTransliterator::CompoundTransliterator(const UnicodeString& id,
     trans(0), numAnonymousRBTs(0) {
     // TODO add code for parseError...currently unused, but
     // later may be used by parsing code...
-    init(id, UTRANS_FORWARD, TRUE, status);
+    init(id, UTRANS_FORWARD, true, status);
 }
 
 
@@ -99,7 +99,7 @@ CompoundTransliterator::CompoundTransliterator(const UnicodeString& newID,
     Transliterator(newID, adoptedFilter),
     trans(0), numAnonymousRBTs(anonymousRBTs)
 {
-    init(list, UTRANS_FORWARD, FALSE, status);
+    init(list, UTRANS_FORWARD, false, status);
 }
 
 /**
@@ -115,7 +115,7 @@ CompoundTransliterator::CompoundTransliterator(UVector& list,
 {
     // TODO add code for parseError...currently unused, but
     // later may be used by parsing code...
-    init(list, UTRANS_FORWARD, FALSE, status);
+    init(list, UTRANS_FORWARD, false, status);
     // assume caller will fixup ID
 }
 
@@ -126,7 +126,7 @@ CompoundTransliterator::CompoundTransliterator(UVector& list,
     Transliterator(UnicodeString(), NULL),
     trans(0), numAnonymousRBTs(anonymousRBTs)
 {
-    init(list, UTRANS_FORWARD, FALSE, status);
+    init(list, UTRANS_FORWARD, false, status);
 }
 
 /**
@@ -140,7 +140,7 @@ CompoundTransliterator::CompoundTransliterator(UVector& list,
  * @param adoptedSplitTransliterator a transliterator to be inserted
  * before the entry at offset idSplitPoint in the id string.  May be
  * NULL to insert no entry.
- * @param fixReverseID if TRUE, then reconstruct the ID of reverse
+ * @param fixReverseID if true, then reconstruct the ID of reverse
  * entries by calling getID() of component entries.  Some constructors
  * do not require this because they apply a facade ID anyway.
  * @param status the error code indicating success or failure
@@ -182,7 +182,7 @@ void CompoundTransliterator::init(const UnicodeString& id,
  * is, it should be in the FORWARD order; if direction is REVERSE then
  * the list order will be reversed.
  * @param direction either FORWARD or REVERSE
- * @param fixReverseID if TRUE, then reconstruct the ID of reverse
+ * @param fixReverseID if true, then reconstruct the ID of reverse
  * entries by calling getID() of component entries.  Some constructors
  * do not require this because they apply a facade ID anyway.
  * @param status the error code indicating success or failure
@@ -285,7 +285,7 @@ CompoundTransliterator& CompoundTransliterator::operator=(
     if (this == &t) { return *this; }  // self-assignment: no-op
     Transliterator::operator=(t);
     int32_t i = 0;
-    UBool failed = FALSE;
+    UBool failed = false;
     if (trans != NULL) {
         for (i=0; i<count; ++i) {
             delete trans[i];
@@ -303,7 +303,7 @@ CompoundTransliterator& CompoundTransliterator::operator=(
         for (i=0; i<count; ++i) {
             trans[i] = t.trans[i]->clone();
             if (trans[i] == NULL) {
-                failed = TRUE;
+                failed = true;
                 break;
             }
         }
@@ -352,11 +352,11 @@ void CompoundTransliterator::setTransliterators(Transliterator* const transliter
         return;
     }
     int32_t i = 0;
-    UBool failed = FALSE;
+    UBool failed = false;
     for (i=0; i<transCount; ++i) {
         a[i] = transliterators[i]->clone();
         if (a[i] == NULL) {
-            failed = TRUE;
+            failed = true;
             break;
         }
     }
diff --git a/deps/icu-small/source/i18n/csdetect.cpp b/deps/icu-small/source/i18n/csdetect.cpp
index d866eb6628..0b22d4dc2a 100644
--- a/deps/icu-small/source/i18n/csdetect.cpp
+++ b/deps/icu-small/source/i18n/csdetect.cpp
@@ -47,7 +47,7 @@ struct CSRecognizerInfo : public UMemory {
 U_NAMESPACE_END
 
 static icu::CSRecognizerInfo **fCSRecognizers = NULL;
-static icu::UInitOnce gCSRecognizersInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gCSRecognizersInitOnce {};
 static int32_t fCSRecognizers_size = 0;
 
 U_CDECL_BEGIN
@@ -66,7 +66,7 @@ static UBool U_CALLCONV csdet_cleanup(void)
     }
     gCSRecognizersInitOnce.reset();
 
-    return TRUE;
+    return true;
 }
 
 static int32_t U_CALLCONV
@@ -85,39 +85,39 @@ static void U_CALLCONV initRecognizers(UErrorCode &status) {
     U_NAMESPACE_USE
     ucln_i18n_registerCleanup(UCLN_I18N_CSDET, csdet_cleanup);
     CSRecognizerInfo *tempArray[] = {
-        new CSRecognizerInfo(new CharsetRecog_UTF8(), TRUE),
-
-        new CSRecognizerInfo(new CharsetRecog_UTF_16_BE(), TRUE),
-        new CSRecognizerInfo(new CharsetRecog_UTF_16_LE(), TRUE),
-        new CSRecognizerInfo(new CharsetRecog_UTF_32_BE(), TRUE),
-        new CSRecognizerInfo(new CharsetRecog_UTF_32_LE(), TRUE),
-
-        new CSRecognizerInfo(new CharsetRecog_8859_1(), TRUE),
-        new CSRecognizerInfo(new CharsetRecog_8859_2(), TRUE),
-        new CSRecognizerInfo(new CharsetRecog_8859_5_ru(), TRUE),
-        new CSRecognizerInfo(new CharsetRecog_8859_6_ar(), TRUE),
-        new CSRecognizerInfo(new CharsetRecog_8859_7_el(), TRUE),
-        new CSRecognizerInfo(new CharsetRecog_8859_8_I_he(), TRUE),
-        new CSRecognizerInfo(new CharsetRecog_8859_8_he(), TRUE),
-        new CSRecognizerInfo(new CharsetRecog_windows_1251(), TRUE),
-        new CSRecognizerInfo(new CharsetRecog_windows_1256(), TRUE),
-        new CSRecognizerInfo(new CharsetRecog_KOI8_R(), TRUE),
-        new CSRecognizerInfo(new CharsetRecog_8859_9_tr(), TRUE),
-        new CSRecognizerInfo(new CharsetRecog_sjis(), TRUE),
-        new CSRecognizerInfo(new CharsetRecog_gb_18030(), TRUE),
-        new CSRecognizerInfo(new CharsetRecog_euc_jp(), TRUE),
-        new CSRecognizerInfo(new CharsetRecog_euc_kr(), TRUE),
-        new CSRecognizerInfo(new CharsetRecog_big5(), TRUE),
-
-        new CSRecognizerInfo(new CharsetRecog_2022JP(), TRUE),
+        new CSRecognizerInfo(new CharsetRecog_UTF8(), true),
+
+        new CSRecognizerInfo(new CharsetRecog_UTF_16_BE(), true),
+        new CSRecognizerInfo(new CharsetRecog_UTF_16_LE(), true),
+        new CSRecognizerInfo(new CharsetRecog_UTF_32_BE(), true),
+        new CSRecognizerInfo(new CharsetRecog_UTF_32_LE(), true),
+
+        new CSRecognizerInfo(new CharsetRecog_8859_1(), true),
+        new CSRecognizerInfo(new CharsetRecog_8859_2(), true),
+        new CSRecognizerInfo(new CharsetRecog_8859_5_ru(), true),
+        new CSRecognizerInfo(new CharsetRecog_8859_6_ar(), true),
+        new CSRecognizerInfo(new CharsetRecog_8859_7_el(), true),
+        new CSRecognizerInfo(new CharsetRecog_8859_8_I_he(), true),
+        new CSRecognizerInfo(new CharsetRecog_8859_8_he(), true),
+        new CSRecognizerInfo(new CharsetRecog_windows_1251(), true),
+        new CSRecognizerInfo(new CharsetRecog_windows_1256(), true),
+        new CSRecognizerInfo(new CharsetRecog_KOI8_R(), true),
+        new CSRecognizerInfo(new CharsetRecog_8859_9_tr(), true),
+        new CSRecognizerInfo(new CharsetRecog_sjis(), true),
+        new CSRecognizerInfo(new CharsetRecog_gb_18030(), true),
+        new CSRecognizerInfo(new CharsetRecog_euc_jp(), true),
+        new CSRecognizerInfo(new CharsetRecog_euc_kr(), true),
+        new CSRecognizerInfo(new CharsetRecog_big5(), true),
+
+        new CSRecognizerInfo(new CharsetRecog_2022JP(), true),
 #if !UCONFIG_ONLY_HTML_CONVERSION
-        new CSRecognizerInfo(new CharsetRecog_2022KR(), TRUE),
-        new CSRecognizerInfo(new CharsetRecog_2022CN(), TRUE),
+        new CSRecognizerInfo(new CharsetRecog_2022KR(), true),
+        new CSRecognizerInfo(new CharsetRecog_2022CN(), true),
 
-        new CSRecognizerInfo(new CharsetRecog_IBM424_he_rtl(), FALSE),
-        new CSRecognizerInfo(new CharsetRecog_IBM424_he_ltr(), FALSE),
-        new CSRecognizerInfo(new CharsetRecog_IBM420_ar_rtl(), FALSE),
-        new CSRecognizerInfo(new CharsetRecog_IBM420_ar_ltr(), FALSE)
+        new CSRecognizerInfo(new CharsetRecog_IBM424_he_rtl(), false),
+        new CSRecognizerInfo(new CharsetRecog_IBM424_he_ltr(), false),
+        new CSRecognizerInfo(new CharsetRecog_IBM420_ar_rtl(), false),
+        new CSRecognizerInfo(new CharsetRecog_IBM420_ar_ltr(), false)
 #endif
     };
     int32_t rCount = UPRV_LENGTHOF(tempArray);
@@ -149,7 +149,7 @@ void CharsetDetector::setRecognizers(UErrorCode &status)
 
 CharsetDetector::CharsetDetector(UErrorCode &status)
   : textIn(new InputText(status)), resultArray(NULL),
-    resultCount(0), fStripTags(FALSE), fFreshTextSet(FALSE),
+    resultCount(0), fStripTags(false), fFreshTextSet(false),
     fEnabledRecognizers(NULL)
 {
     if (U_FAILURE(status)) {
@@ -197,14 +197,14 @@ CharsetDetector::~CharsetDetector()
 void CharsetDetector::setText(const char *in, int32_t len)
 {
     textIn->setText(in, len);
-    fFreshTextSet = TRUE;
+    fFreshTextSet = true;
 }
 
 UBool CharsetDetector::setStripTagsFlag(UBool flag)
 {
     UBool temp = fStripTags;
     fStripTags = flag;
-    fFreshTextSet = TRUE;
+    fFreshTextSet = true;
     return temp;
 }
 
@@ -263,9 +263,9 @@ const CharsetMatch * const *CharsetDetector::detectAll(int32_t &maxMatchesFound,
         }
 
         if (resultCount > 1) {
-            uprv_sortArray(resultArray, resultCount, sizeof resultArray[0], charsetMatchComparator, NULL, TRUE, &status);
+            uprv_sortArray(resultArray, resultCount, sizeof resultArray[0], charsetMatchComparator, NULL, true, &status);
         }
-        fFreshTextSet = FALSE;
+        fFreshTextSet = false;
     }
 
     maxMatchesFound = resultCount;
@@ -285,7 +285,7 @@ void CharsetDetector::setDetectableCharset(const char *encoding, UBool enabled,
     }
 
     int32_t modIdx = -1;
-    UBool isDefaultVal = FALSE;
+    UBool isDefaultVal = false;
     for (int32_t i = 0; i < fCSRecognizers_size; i++) {
         CSRecognizerInfo *csrinfo = fCSRecognizers[i];
         if (uprv_strcmp(csrinfo->recognizer->getName(), encoding) == 0) {
@@ -459,7 +459,7 @@ UEnumeration * CharsetDetector::getAllDetectableCharsets(UErrorCode &status)
         return 0;
     }
     uprv_memset(en->context, 0, sizeof(Context));
-    ((Context*)en->context)->all = TRUE;
+    ((Context*)en->context)->all = true;
     return en;
 }
 
@@ -482,7 +482,7 @@ UEnumeration * CharsetDetector::getDetectableCharsets(UErrorCode &status) const
         return 0;
     }
     uprv_memset(en->context, 0, sizeof(Context));
-    ((Context*)en->context)->all = FALSE;
+    ((Context*)en->context)->all = false;
     ((Context*)en->context)->enabledRecognizers = fEnabledRecognizers;
     return en;
 }
diff --git a/deps/icu-small/source/i18n/csrmbcs.cpp b/deps/icu-small/source/i18n/csrmbcs.cpp
index 4c5bdfa560..ec346b5fb3 100644
--- a/deps/icu-small/source/i18n/csrmbcs.cpp
+++ b/deps/icu-small/source/i18n/csrmbcs.cpp
@@ -115,7 +115,7 @@ static int32_t binarySearch(const uint16_t *array, int32_t len, uint16_t value)
 }
 
 IteratedChar::IteratedChar() : 
-charValue(0), index(-1), nextIndex(0), error(FALSE), done(FALSE)
+charValue(0), index(-1), nextIndex(0), error(false), done(false)
 {
     // nothing else to do.
 }
@@ -125,14 +125,14 @@ charValue(0), index(-1), nextIndex(0), error(FALSE), done(FALSE)
     charValue = 0;
     index     = -1;
     nextIndex = 0;
-    error     = FALSE;
-    done      = FALSE;
+    error     = false;
+    done      = false;
 }*/
 
 int32_t IteratedChar::nextByte(InputText *det)
 {
     if (nextIndex >= det->fRawLength) {
-        done = TRUE;
+        done = true;
 
         return -1;
     }
@@ -146,7 +146,6 @@ CharsetRecog_mbcs::~CharsetRecog_mbcs()
 }
 
 int32_t CharsetRecog_mbcs::match_mbcs(InputText *det, const uint16_t commonChars[], int32_t commonCharsLen) const {
-    int32_t singleByteCharCount = 0;
     int32_t doubleByteCharCount = 0;
     int32_t commonCharCount     = 0;
     int32_t badCharCount        = 0;
@@ -160,9 +159,7 @@ int32_t CharsetRecog_mbcs::match_mbcs(InputText *det, const uint16_t commonChars
         if (iter.error) {
             badCharCount++;
         } else {
-            if (iter.charValue <= 0xFF) {
-                singleByteCharCount++;
-            } else {
+            if (iter.charValue > 0xFF) {
                 doubleByteCharCount++;
 
                 if (commonChars != 0) {
@@ -243,16 +240,16 @@ CharsetRecog_sjis::~CharsetRecog_sjis()
 
 UBool CharsetRecog_sjis::nextChar(IteratedChar* it, InputText* det) const {
     it->index = it->nextIndex;
-    it->error = FALSE;
+    it->error = false;
 
     int32_t firstByte = it->charValue = it->nextByte(det);
 
     if (firstByte < 0) {
-        return FALSE;
+        return false;
     }
 
     if (firstByte <= 0x7F || (firstByte > 0xA0 && firstByte <= 0xDF)) {
-        return TRUE;
+        return true;
     }
 
     int32_t secondByte = it->nextByte(det);
@@ -263,10 +260,10 @@ UBool CharsetRecog_sjis::nextChar(IteratedChar* it, InputText* det) const {
 
     if (! ((secondByte >= 0x40 && secondByte <= 0x7F) || (secondByte >= 0x80 && secondByte <= 0xFE))) {
         // Illegal second byte value.
-        it->error = TRUE;
+        it->error = true;
     }
 
-    return TRUE;
+    return true;
 }
 
 UBool CharsetRecog_sjis::match(InputText* det, CharsetMatch *results) const {
@@ -296,17 +293,17 @@ UBool CharsetRecog_euc::nextChar(IteratedChar* it, InputText* det) const {
     int32_t thirdByte  = 0;
 
     it->index = it->nextIndex;
-    it->error = FALSE;
+    it->error = false;
     firstByte = it->charValue = it->nextByte(det);
 
     if (firstByte < 0) {
         // Ran off the end of the input data
-        return FALSE;
+        return false;
     }
 
     if (firstByte <= 0x8D) {
         // single byte char
-        return TRUE;
+        return true;
     }
 
     secondByte = it->nextByte(det);
@@ -318,10 +315,10 @@ UBool CharsetRecog_euc::nextChar(IteratedChar* it, InputText* det) const {
     if (firstByte >= 0xA1 && firstByte <= 0xFE) {
         // Two byte Char
         if (secondByte < 0xA1) {
-            it->error = TRUE;
+            it->error = true;
         }
 
-        return TRUE;
+        return true;
     }
 
     if (firstByte == 0x8E) {
@@ -332,10 +329,10 @@ UBool CharsetRecog_euc::nextChar(IteratedChar* it, InputText* det) const {
         // Treat it like EUC-JP.  If the data really was EUC-TW, the following two
         //   bytes will look like a well formed 2 byte char.
         if (secondByte < 0xA1) {
-            it->error = TRUE;
+            it->error = true;
         }
 
-        return TRUE;
+        return true;
     }
 
     if (firstByte == 0x8F) {
@@ -346,11 +343,11 @@ UBool CharsetRecog_euc::nextChar(IteratedChar* it, InputText* det) const {
 
         if (thirdByte < 0xa1) {
             // Bad second byte or ran off the end of the input data with a non-ASCII first byte.
-            it->error = TRUE;
+            it->error = true;
         }
     }
 
-    return TRUE;
+    return true;
 
 }
 
@@ -408,16 +405,16 @@ UBool CharsetRecog_big5::nextChar(IteratedChar* it, InputText* det) const
     int32_t firstByte;
 
     it->index = it->nextIndex;
-    it->error = FALSE;
+    it->error = false;
     firstByte = it->charValue = it->nextByte(det);
 
     if (firstByte < 0) {
-        return FALSE;
+        return false;
     }
 
     if (firstByte <= 0x7F || firstByte == 0xFF) {
         // single byte character.
-        return TRUE;
+        return true;
     }
 
     int32_t secondByte = it->nextByte(det);
@@ -427,10 +424,10 @@ UBool CharsetRecog_big5::nextChar(IteratedChar* it, InputText* det) const
     // else we'll handle the error later.
 
     if (secondByte < 0x40 || secondByte == 0x7F || secondByte == 0xFF) {
-        it->error = TRUE;
+        it->error = true;
     }
 
-    return TRUE;
+    return true;
 }
 
 const char *CharsetRecog_big5::getName() const
@@ -462,17 +459,17 @@ UBool CharsetRecog_gb_18030::nextChar(IteratedChar* it, InputText* det) const {
     int32_t fourthByte = 0;
 
     it->index = it->nextIndex;
-    it->error = FALSE;
+    it->error = false;
     firstByte = it->charValue = it->nextByte(det);
 
     if (firstByte < 0) {
         // Ran off the end of the input data
-        return FALSE;
+        return false;
     }
 
     if (firstByte <= 0x80) {
         // single byte char
-        return TRUE;
+        return true;
     }
 
     secondByte = it->nextByte(det);
@@ -484,7 +481,7 @@ UBool CharsetRecog_gb_18030::nextChar(IteratedChar* it, InputText* det) const {
     if (firstByte >= 0x81 && firstByte <= 0xFE) {
         // Two byte Char
         if ((secondByte >= 0x40 && secondByte <= 0x7E) || (secondByte >=80 && secondByte <= 0xFE)) {
-            return TRUE;
+            return true;
         }
 
         // Four byte char
@@ -497,16 +494,16 @@ UBool CharsetRecog_gb_18030::nextChar(IteratedChar* it, InputText* det) const {
                 if (fourthByte >= 0x30 && fourthByte <= 0x39) {
                     it->charValue = (it->charValue << 16) | (thirdByte << 8) | fourthByte;
 
-                    return TRUE;
+                    return true;
                 }
             }
         }
 
         // Something wasn't valid, or we ran out of data (-1).
-        it->error = TRUE;
+        it->error = true;
     }
 
-    return TRUE;
+    return true;
 }
 
 const char *CharsetRecog_gb_18030::getName() const
diff --git a/deps/icu-small/source/i18n/csrsbcs.cpp b/deps/icu-small/source/i18n/csrsbcs.cpp
index 0b0d8967e7..92af9b5291 100644
--- a/deps/icu-small/source/i18n/csrsbcs.cpp
+++ b/deps/icu-small/source/i18n/csrsbcs.cpp
@@ -104,7 +104,7 @@ int32_t NGramParser::nextByte(InputText *det)
 void NGramParser::parseCharacters(InputText *det)
 {
     int32_t b;
-    bool ignoreSpace = FALSE;
+    bool ignoreSpace = false;
 
     while ((b = nextByte(det)) >= 0) {
         uint8_t mb = charMap[b];
@@ -211,7 +211,7 @@ int32_t NGramParser_IBM420::nextByte(InputText *det)
 void NGramParser_IBM420::parseCharacters(InputText *det)
 {
 	int32_t b;
-    bool ignoreSpace = FALSE;
+    bool ignoreSpace = false;
 
     while ((b = nextByte(det)) >= 0) {
         uint8_t mb = charMap[b];
diff --git a/deps/icu-small/source/i18n/csrucode.cpp b/deps/icu-small/source/i18n/csrucode.cpp
index 480dae1400..e0a64aa949 100644
--- a/deps/icu-small/source/i18n/csrucode.cpp
+++ b/deps/icu-small/source/i18n/csrucode.cpp
@@ -126,11 +126,11 @@ UBool CharsetRecog_UTF_32::match(InputText* textIn, CharsetMatch *results) const
     int32_t limit = (textIn->fRawLength / 4) * 4;
     int32_t numValid = 0;
     int32_t numInvalid = 0;
-    bool hasBOM = FALSE;
+    bool hasBOM = false;
     int32_t confidence = 0;
 
     if (limit > 0 && getChar(input, 0) == 0x0000FEFFUL) {
-        hasBOM = TRUE;
+        hasBOM = true;
     }
 
     for(int32_t i = 0; i < limit; i += 4) {
diff --git a/deps/icu-small/source/i18n/csrutf8.cpp b/deps/icu-small/source/i18n/csrutf8.cpp
index 3f16224ea6..f114f09722 100644
--- a/deps/icu-small/source/i18n/csrutf8.cpp
+++ b/deps/icu-small/source/i18n/csrutf8.cpp
@@ -27,7 +27,7 @@ const char *CharsetRecog_UTF8::getName() const
 }
 
 UBool CharsetRecog_UTF8::match(InputText* input, CharsetMatch *results) const {
-    bool hasBOM = FALSE;
+    bool hasBOM = false;
     int32_t numValid = 0;
     int32_t numInvalid = 0;
     const uint8_t *inputBytes = input->fRawInput;
@@ -37,7 +37,7 @@ UBool CharsetRecog_UTF8::match(InputText* input, CharsetMatch *results) const {
 
     if (input->fRawLength >= 3 && 
         inputBytes[0] == 0xEF && inputBytes[1] == 0xBB && inputBytes[2] == 0xBF) {
-            hasBOM = TRUE;
+            hasBOM = true;
     }
 
     // Scan for multi-byte sequences
diff --git a/deps/icu-small/source/i18n/currpinf.cpp b/deps/icu-small/source/i18n/currpinf.cpp
index a2676ab5a1..1a1c580271 100644
--- a/deps/icu-small/source/i18n/currpinf.cpp
+++ b/deps/icu-small/source/i18n/currpinf.cpp
@@ -190,7 +190,7 @@ CurrencyPluralInfo::getCurrencyPluralPattern(const UnicodeString&  pluralCount,
         // fall back to "other"
         if (pluralCount.compare(gPluralCountOther, 5)) {
             currencyPluralPattern = 
-                (UnicodeString*)fPluralCountToCurrencyUnitPattern->get(UnicodeString(TRUE, gPluralCountOther, 5));
+                (UnicodeString*)fPluralCountToCurrencyUnitPattern->get(UnicodeString(true, gPluralCountOther, 5));
         }
         if (currencyPluralPattern == nullptr) {
             // no currencyUnitPatterns defined, 
@@ -351,15 +351,15 @@ CurrencyPluralInfo::setupCurrencyPluralPattern(const Locale& loc, UErrorCode& st
                 pattern->extract(0, pattern->length(), result_1, "UTF-8");
                 std::cout << "pluralCount: " << pluralCount << "; pattern: " << result_1 << "\n";
 #endif
-                pattern->findAndReplace(UnicodeString(TRUE, gPart0, 3), 
+                pattern->findAndReplace(UnicodeString(true, gPart0, 3), 
                     UnicodeString(numberStylePattern, numberStylePatternLen));
-                pattern->findAndReplace(UnicodeString(TRUE, gPart1, 3), UnicodeString(TRUE, gTripleCurrencySign, 3));
+                pattern->findAndReplace(UnicodeString(true, gPart1, 3), UnicodeString(true, gTripleCurrencySign, 3));
 
                 if (hasSeparator) {
                     UnicodeString negPattern(patternChars, ptnLength);
-                    negPattern.findAndReplace(UnicodeString(TRUE, gPart0, 3), 
+                    negPattern.findAndReplace(UnicodeString(true, gPart0, 3), 
                         UnicodeString(negNumberStylePattern, negNumberStylePatternLen));
-                    negPattern.findAndReplace(UnicodeString(TRUE, gPart1, 3), UnicodeString(TRUE, gTripleCurrencySign, 3));
+                    negPattern.findAndReplace(UnicodeString(true, gPart1, 3), UnicodeString(true, gTripleCurrencySign, 3));
                     pattern->append(gNumberPatternSeparator);
                     pattern->append(negPattern);
                 }
@@ -400,7 +400,7 @@ CurrencyPluralInfo::initHash(UErrorCode& status) {
     if (U_FAILURE(status)) {
         return nullptr;
     }
-    LocalPointer<Hashtable> hTable(new Hashtable(TRUE, status), status);
+    LocalPointer<Hashtable> hTable(new Hashtable(true, status), status);
     if (U_FAILURE(status)) {
         return nullptr;
     }
diff --git a/deps/icu-small/source/i18n/dangical.cpp b/deps/icu-small/source/i18n/dangical.cpp
index 57fe80220b..59cdc661da 100644
--- a/deps/icu-small/source/i18n/dangical.cpp
+++ b/deps/icu-small/source/i18n/dangical.cpp
@@ -24,7 +24,7 @@
 
 // --- The cache --
 static icu::TimeZone *gDangiCalendarZoneAstroCalc = NULL;
-static icu::UInitOnce gDangiCalendarInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gDangiCalendarInitOnce {};
 
 /**
  * The start year of the Korean traditional calendar (Dan-gi) is the inaugural
@@ -39,7 +39,7 @@ static UBool calendar_dangi_cleanup(void) {
         gDangiCalendarZoneAstroCalc = NULL;
     }
     gDangiCalendarInitOnce.reset();
-    return TRUE;
+    return true;
 }
 U_CDECL_END
 
diff --git a/deps/icu-small/source/i18n/datefmt.cpp b/deps/icu-small/source/i18n/datefmt.cpp
index fed8f79aa0..2638cbf14d 100644
--- a/deps/icu-small/source/i18n/datefmt.cpp
+++ b/deps/icu-small/source/i18n/datefmt.cpp
@@ -46,7 +46,7 @@
 
 U_NAMESPACE_BEGIN
 
-class U_I18N_API DateFmtBestPattern : public SharedObject {
+class DateFmtBestPattern : public SharedObject {
 public:
     UnicodeString fPattern;
 
@@ -58,14 +58,14 @@ public:
 DateFmtBestPattern::~DateFmtBestPattern() {
 }
 
-template<> U_I18N_API
+template<> 
 const DateFmtBestPattern *LocaleCacheKey<DateFmtBestPattern>::createObject(
         const void * /*creationContext*/, UErrorCode &status) const {
     status = U_UNSUPPORTED_ERROR;
     return NULL;
 }
 
-class U_I18N_API DateFmtBestPatternKey : public LocaleCacheKey<DateFmtBestPattern> { 
+class DateFmtBestPatternKey : public LocaleCacheKey<DateFmtBestPattern> { 
 private:
     UnicodeString fSkeleton;
 protected:
@@ -588,8 +588,8 @@ DateFormat::adoptNumberFormat(NumberFormat* newNumberFormat)
 {
     delete fNumberFormat;
     fNumberFormat = newNumberFormat;
-    newNumberFormat->setParseIntegerOnly(TRUE);
-    newNumberFormat->setGroupingUsed(FALSE);
+    newNumberFormat->setParseIntegerOnly(true);
+    newNumberFormat->setGroupingUsed(false);
 }
 //----------------------------------------------------------------------
 
@@ -660,7 +660,7 @@ DateFormat::setLenient(UBool lenient)
 UBool
 DateFormat::isLenient() const
 {
-    UBool lenient = TRUE;
+    UBool lenient = true;
     if (fCalendar != NULL) {
         lenient = fCalendar->isLenient();
     }
@@ -687,7 +687,7 @@ DateFormat::isCalendarLenient() const
         return fCalendar->isLenient();
     }
     // fCalendar is rarely null
-    return FALSE;
+    return false;
 }
 
 
diff --git a/deps/icu-small/source/i18n/dayperiodrules.cpp b/deps/icu-small/source/i18n/dayperiodrules.cpp
index efe92dd794..3ef822842d 100644
--- a/deps/icu-small/source/i18n/dayperiodrules.cpp
+++ b/deps/icu-small/source/i18n/dayperiodrules.cpp
@@ -196,9 +196,9 @@ struct DayPeriodRulesDataSink : public ResourceSink {
             // AT cutoffs must be either midnight or noon.
             if (cutoffs[startHour] & (1 << CUTOFF_TYPE_AT)) {
                 if (startHour == 0 && period == DayPeriodRules::DAYPERIOD_MIDNIGHT) {
-                    rule.fHasMidnight = TRUE;
+                    rule.fHasMidnight = true;
                 } else if (startHour == 12 && period == DayPeriodRules::DAYPERIOD_NOON) {
-                    rule.fHasNoon = TRUE;
+                    rule.fHasNoon = true;
                 } else {
                     errorCode = U_INVALID_FORMAT_ERROR;  // Bad data.
                     return;
@@ -301,14 +301,14 @@ DayPeriodRulesCountSink::~DayPeriodRulesCountSink() {}
 
 namespace {
 
-UInitOnce initOnce = U_INITONCE_INITIALIZER;
+UInitOnce initOnce {};
 
 U_CFUNC UBool U_CALLCONV dayPeriodRulesCleanup() {
     delete[] data->rules;
     uhash_close(data->localeToRuleSetNumMap);
     delete data;
     data = NULL;
-    return TRUE;
+    return true;
 }
 
 }  // namespace
@@ -381,7 +381,7 @@ const DayPeriodRules *DayPeriodRules::getInstance(const Locale &locale, UErrorCo
     }
 }
 
-DayPeriodRules::DayPeriodRules() : fHasMidnight(FALSE), fHasNoon(FALSE) {
+DayPeriodRules::DayPeriodRules() : fHasMidnight(false), fHasNoon(false) {
     for (int32_t i = 0; i < 24; ++i) {
         fDayPeriodForHour[i] = DayPeriodRules::DAYPERIOD_UNKNOWN;
     }
@@ -504,10 +504,10 @@ void DayPeriodRules::add(int32_t startHour, int32_t limitHour, DayPeriod period)
 
 UBool DayPeriodRules::allHoursAreSet() {
     for (int32_t i = 0; i < 24; ++i) {
-        if (fDayPeriodForHour[i] == DAYPERIOD_UNKNOWN) { return FALSE; }
+        if (fDayPeriodForHour[i] == DAYPERIOD_UNKNOWN) { return false; }
     }
 
-    return TRUE;
+    return true;
 }
 
 
diff --git a/deps/icu-small/source/i18n/dcfmtsym.cpp b/deps/icu-small/source/i18n/dcfmtsym.cpp
index 4f5bae4e11..5d06c189fb 100644
--- a/deps/icu-small/source/i18n/dcfmtsym.cpp
+++ b/deps/icu-small/source/i18n/dcfmtsym.cpp
@@ -100,7 +100,7 @@ static const char *gNumberElementKeys[DecimalFormatSymbols::kFormatSymbolCount]
 
 DecimalFormatSymbols::DecimalFormatSymbols(UErrorCode& status)
         : UObject(), locale(), currPattern(NULL) {
-    initialize(locale, status, TRUE);
+    initialize(locale, status, true);
 }
 
 // -------------------------------------
@@ -113,7 +113,7 @@ DecimalFormatSymbols::DecimalFormatSymbols(const Locale& loc, UErrorCode& status
 
 DecimalFormatSymbols::DecimalFormatSymbols(const Locale& loc, const NumberingSystem& ns, UErrorCode& status)
         : UObject(), locale(loc), currPattern(NULL) {
-    initialize(locale, status, FALSE, &ns);
+    initialize(locale, status, false, &ns);
 }
 
 DecimalFormatSymbols::DecimalFormatSymbols()
@@ -227,7 +227,7 @@ struct DecFmtSymDataSink : public ResourceSink {
 
     // Constructor/Destructor
     DecFmtSymDataSink(DecimalFormatSymbols& _dfs) : dfs(_dfs) {
-        uprv_memset(seenSymbol, FALSE, sizeof(seenSymbol));
+        uprv_memset(seenSymbol, false, sizeof(seenSymbol));
     }
     virtual ~DecFmtSymDataSink();
 
@@ -239,7 +239,7 @@ struct DecFmtSymDataSink : public ResourceSink {
             for (int32_t i=0; i<DecimalFormatSymbols::kFormatSymbolCount; i++) {
                 if (gNumberElementKeys[i] != NULL && uprv_strcmp(key, gNumberElementKeys[i]) == 0) {
                     if (!seenSymbol[i]) {
-                        seenSymbol[i] = TRUE;
+                        seenSymbol[i] = true;
                         dfs.setSymbol(
                             (DecimalFormatSymbols::ENumberFormatSymbol) i,
                             value.getUnicodeString(errorCode));
@@ -255,10 +255,10 @@ struct DecFmtSymDataSink : public ResourceSink {
     UBool seenAll() {
         for (int32_t i=0; i<DecimalFormatSymbols::kFormatSymbolCount; i++) {
             if (!seenSymbol[i]) {
-                return FALSE;
+                return false;
             }
         }
-        return TRUE;
+        return true;
     }
 
     // If monetary decimal or grouping were not explicitly set, then set them to be the
@@ -283,7 +283,7 @@ struct CurrencySpacingSink : public ResourceSink {
     UBool hasAfterCurrency;
 
     CurrencySpacingSink(DecimalFormatSymbols& _dfs)
-        : dfs(_dfs), hasBeforeCurrency(FALSE), hasAfterCurrency(FALSE) {}
+        : dfs(_dfs), hasBeforeCurrency(false), hasAfterCurrency(false) {}
     virtual ~CurrencySpacingSink();
 
     virtual void put(const char *key, ResourceValue &value, UBool /*noFallback*/,
@@ -292,11 +292,11 @@ struct CurrencySpacingSink : public ResourceSink {
         for (int32_t i = 0; spacingTypesTable.getKeyAndValue(i, key, value); ++i) {
             UBool beforeCurrency;
             if (uprv_strcmp(key, gBeforeCurrencyTag) == 0) {
-                beforeCurrency = TRUE;
-                hasBeforeCurrency = TRUE;
+                beforeCurrency = true;
+                hasBeforeCurrency = true;
             } else if (uprv_strcmp(key, gAfterCurrencyTag) == 0) {
-                beforeCurrency = FALSE;
-                hasAfterCurrency = TRUE;
+                beforeCurrency = false;
+                hasAfterCurrency = true;
             } else {
                 continue;
             }
@@ -329,7 +329,7 @@ struct CurrencySpacingSink : public ResourceSink {
         // both beforeCurrency and afterCurrency were found in CLDR.
         static const char* defaults[] = { "[:letter:]", "[:digit:]", " " };
         if (!hasBeforeCurrency || !hasAfterCurrency) {
-            for (UBool beforeCurrency = 0; beforeCurrency <= TRUE; beforeCurrency++) {
+            for (UBool beforeCurrency = 0; beforeCurrency <= true; beforeCurrency++) {
                 for (int32_t pattern = 0; pattern < UNUM_CURRENCY_SPACING_COUNT; pattern++) {
                     dfs.setPatternForCurrencySpacing((UCurrencySpacing)pattern,
                         beforeCurrency, UnicodeString(defaults[pattern], -1, US_INV));
@@ -499,7 +499,7 @@ DecimalFormatSymbols::initialize() {
     fSymbols[kPlusSignSymbol] = (UChar)0x002b;          // '+' plus sign
     fSymbols[kMinusSignSymbol] = (UChar)0x2d;           // '-' minus sign
     fSymbols[kCurrencySymbol] = (UChar)0xa4;            // 'OX' currency symbol
-    fSymbols[kIntlCurrencySymbol].setTo(TRUE, INTL_CURRENCY_SYMBOL_STR, 2);
+    fSymbols[kIntlCurrencySymbol].setTo(true, INTL_CURRENCY_SYMBOL_STR, 2);
     fSymbols[kMonetarySeparatorSymbol] = (UChar)0x2e;   // '.' monetary decimal separator
     fSymbols[kExponentialSymbol] = (UChar)0x45;         // 'E' exponential
     fSymbols[kPerMillSymbol] = (UChar)0x2030;           // '%o' per mill
@@ -510,8 +510,8 @@ DecimalFormatSymbols::initialize() {
     fSymbols[kMonetaryGroupingSeparatorSymbol].remove(); // 
     fSymbols[kExponentMultiplicationSymbol] = (UChar)0xd7; // 'x' multiplication symbol for exponents
     fSymbols[kApproximatelySignSymbol] = u'~';          // '~' approximately sign
-    fIsCustomCurrencySymbol = FALSE; 
-    fIsCustomIntlCurrencySymbol = FALSE;
+    fIsCustomCurrencySymbol = false; 
+    fIsCustomIntlCurrencySymbol = false;
     fCodePointZero = 0x30;
     U_ASSERT(fCodePointZero == fSymbols[kZeroDigitSymbol].char32At(0));
     currPattern = nullptr;
@@ -555,7 +555,7 @@ void DecimalFormatSymbols::setCurrency(const UChar* currency, UErrorCode& status
         if(U_SUCCESS(localStatus)){
             fSymbols[kMonetaryGroupingSeparatorSymbol] = groupingSep;
             fSymbols[kMonetarySeparatorSymbol] = decimalSep;
-            //pattern.setTo(TRUE, currPattern, currPatternLen);
+            //pattern.setTo(true, currPattern, currPatternLen);
         }
     }
     /* else An explicit currency was requested and is unknown or locale data is malformed. */
diff --git a/deps/icu-small/source/i18n/decContext.h b/deps/icu-small/source/i18n/decContext.h
index 59ab65e592..91c6739739 100644
--- a/deps/icu-small/source/i18n/decContext.h
+++ b/deps/icu-small/source/i18n/decContext.h
@@ -262,7 +262,6 @@
   U_CAPI decContext  * U_EXPORT2 uprv_decContextSetStatusFromStringQuiet(decContext *, const char *);
   U_CAPI decContext  * U_EXPORT2 uprv_decContextSetStatusQuiet(decContext *, uint32_t);
   U_CAPI const char  * U_EXPORT2 uprv_decContextStatusToString(const decContext *);
-  U_CAPI int32_t       U_EXPORT2 uprv_decContextTestEndian(uint8_t);
   U_CAPI uint32_t      U_EXPORT2 uprv_decContextTestSavedStatus(uint32_t, uint32_t);
   U_CAPI uint32_t      U_EXPORT2 uprv_decContextTestStatus(decContext *, uint32_t);
   U_CAPI decContext  * U_EXPORT2 uprv_decContextZeroStatus(decContext *);
diff --git a/deps/icu-small/source/i18n/displayoptions.cpp b/deps/icu-small/source/i18n/displayoptions.cpp
new file mode 100644
index 0000000000..bb49e6033f
--- /dev/null
+++ b/deps/icu-small/source/i18n/displayoptions.cpp
@@ -0,0 +1,167 @@
+// © 2022 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html
+
+#include "unicode/utypes.h"
+
+#if !UCONFIG_NO_FORMATTING
+
+#include "unicode/displayoptions.h"
+#include "unicode/udisplayoptions.h"
+#include "cstring.h"
+
+U_NAMESPACE_BEGIN
+
+DisplayOptions::Builder DisplayOptions::builder() { return DisplayOptions::Builder(); }
+
+DisplayOptions::Builder DisplayOptions::copyToBuilder() const { return Builder(*this); }
+
+DisplayOptions::DisplayOptions(const Builder &builder) {
+    grammaticalCase = builder.grammaticalCase;
+    nounClass = builder.nounClass;
+    pluralCategory = builder.pluralCategory;
+    capitalization = builder.capitalization;
+    nameStyle = builder.nameStyle;
+    displayLength = builder.displayLength;
+    substituteHandling = builder.substituteHandling;
+}
+
+DisplayOptions::Builder::Builder() {
+    // Sets default values.
+    grammaticalCase = UDISPOPT_GRAMMATICAL_CASE_UNDEFINED;
+    nounClass = UDISPOPT_NOUN_CLASS_UNDEFINED;
+    pluralCategory = UDISPOPT_PLURAL_CATEGORY_UNDEFINED;
+    capitalization = UDISPOPT_CAPITALIZATION_UNDEFINED;
+    nameStyle = UDISPOPT_NAME_STYLE_UNDEFINED;
+    displayLength = UDISPOPT_DISPLAY_LENGTH_UNDEFINED;
+    substituteHandling = UDISPOPT_SUBSTITUTE_HANDLING_UNDEFINED;
+}
+
+DisplayOptions::Builder::Builder(const DisplayOptions &displayOptions) {
+    grammaticalCase = displayOptions.grammaticalCase;
+    nounClass = displayOptions.nounClass;
+    pluralCategory = displayOptions.pluralCategory;
+    capitalization = displayOptions.capitalization;
+    nameStyle = displayOptions.nameStyle;
+    displayLength = displayOptions.displayLength;
+    substituteHandling = displayOptions.substituteHandling;
+}
+
+U_NAMESPACE_END
+
+// C API ------------------------------------------------------------------- ***
+
+U_NAMESPACE_USE
+
+namespace {
+
+const char *grammaticalCaseIds[] = {
+    "undefined",           // 0
+    "ablative",            // 1
+    "accusative",          // 2
+    "comitative",          // 3
+    "dative",              // 4
+    "ergative",            // 5
+    "genitive",            // 6
+    "instrumental",        // 7
+    "locative",            // 8
+    "locative_copulative", // 9
+    "nominative",          // 10
+    "oblique",             // 11
+    "prepositional",       // 12
+    "sociative",           // 13
+    "vocative",            // 14
+};
+
+} // namespace
+
+U_CAPI const char * U_EXPORT2
+udispopt_getGrammaticalCaseIdentifier(UDisplayOptionsGrammaticalCase grammaticalCase) {
+    if (grammaticalCase >= 0 && grammaticalCase < UPRV_LENGTHOF(grammaticalCaseIds)) {
+        return grammaticalCaseIds[grammaticalCase];
+    }
+
+    return grammaticalCaseIds[0];
+}
+
+U_CAPI UDisplayOptionsGrammaticalCase U_EXPORT2
+udispopt_fromGrammaticalCaseIdentifier(const char *identifier) {
+    for (int32_t i = 0; i < UPRV_LENGTHOF(grammaticalCaseIds); i++) {
+        if (uprv_strcmp(identifier, grammaticalCaseIds[i]) == 0) {
+            return static_cast<UDisplayOptionsGrammaticalCase>(i);
+        }
+    }
+
+    return UDISPOPT_GRAMMATICAL_CASE_UNDEFINED;
+}
+
+namespace {
+
+const char *pluralCategoryIds[] = {
+    "undefined", // 0
+    "zero",      // 1
+    "one",       // 2
+    "two",       // 3
+    "few",       // 4
+    "many",      // 5
+    "other",     // 6
+};
+
+} // namespace
+
+U_CAPI const char * U_EXPORT2
+udispopt_getPluralCategoryIdentifier(UDisplayOptionsPluralCategory pluralCategory) {
+    if (pluralCategory >= 0 && pluralCategory < UPRV_LENGTHOF(pluralCategoryIds)) {
+        return pluralCategoryIds[pluralCategory];
+    }
+
+    return pluralCategoryIds[0];
+}
+
+U_CAPI UDisplayOptionsPluralCategory U_EXPORT2
+udispopt_fromPluralCategoryIdentifier(const char *identifier) {
+    for (int32_t i = 0; i < UPRV_LENGTHOF(pluralCategoryIds); i++) {
+        if (uprv_strcmp(identifier, pluralCategoryIds[i]) == 0) {
+            return static_cast<UDisplayOptionsPluralCategory>(i);
+        }
+    }
+
+    return UDISPOPT_PLURAL_CATEGORY_UNDEFINED;
+}
+
+namespace {
+
+const char *nounClassIds[] = {
+    "undefined", // 0
+    "other",     // 1
+    "neuter",    // 2
+    "feminine",  // 3
+    "masculine", // 4
+    "animate",   // 5
+    "inanimate", // 6
+    "personal",  // 7
+    "common",    // 8
+};
+
+} // namespace
+
+U_CAPI const char * U_EXPORT2
+udispopt_getNounClassIdentifier(UDisplayOptionsNounClass nounClass) {
+    if (nounClass >= 0 && nounClass < UPRV_LENGTHOF(nounClassIds)) {
+        return nounClassIds[nounClass];
+    }
+
+    return nounClassIds[0];
+}
+
+U_CAPI UDisplayOptionsNounClass U_EXPORT2
+udispopt_fromNounClassIdentifier(const char *identifier) {
+    for (int32_t i = 0; i < UPRV_LENGTHOF(nounClassIds); i++) {
+        if (uprv_strcmp(identifier, nounClassIds[i]) == 0) {
+            return static_cast<UDisplayOptionsNounClass>(i);
+        }
+    }
+
+    return UDISPOPT_NOUN_CLASS_UNDEFINED;
+}
+
+#endif /* #if !UCONFIG_NO_FORMATTING */
diff --git a/deps/icu-small/source/i18n/double-conversion-bignum.cpp b/deps/icu-small/source/i18n/double-conversion-bignum.cpp
index 996d75c9f6..d2b701a21d 100644
--- a/deps/icu-small/source/i18n/double-conversion-bignum.cpp
+++ b/deps/icu-small/source/i18n/double-conversion-bignum.cpp
@@ -150,7 +150,7 @@ void Bignum::AssignHexString(Vector<const char> value) {
   DOUBLE_CONVERSION_ASSERT(sizeof(uint64_t) * 8 >= kBigitSize + 4);  // TODO: static_assert
   // Accumulates converted hex digits until at least kBigitSize bits.
   // Works with non-factor-of-four kBigitSizes.
-  uint64_t tmp = 0;  // Accumulates converted hex digits until at least
+  uint64_t tmp = 0;
   for (int cnt = 0; !value.is_empty(); value.pop_back()) {
     tmp |= (HexCharValue(value.last()) << cnt);
     if ((cnt += 4) >= kBigitSize) {
@@ -160,7 +160,8 @@ void Bignum::AssignHexString(Vector<const char> value) {
     }
   }
   if (tmp > 0) {
-    RawBigit(used_bigits_++) = tmp;
+    DOUBLE_CONVERSION_ASSERT(tmp <= kBigitMask);
+    RawBigit(used_bigits_++) = static_cast<Bignum::Chunk>(tmp & kBigitMask);
   }
   Clamp();
 }
@@ -217,7 +218,7 @@ void Bignum::AddBignum(const Bignum& other) {
     carry = sum >> kBigitSize;
     ++bigit_pos;
   }
-  used_bigits_ = (std::max)(bigit_pos, static_cast<int>(used_bigits_));
+  used_bigits_ = static_cast<int16_t>(std::max(bigit_pos, static_cast<int>(used_bigits_)));
   DOUBLE_CONVERSION_ASSERT(IsClamped());
 }
 
@@ -253,7 +254,7 @@ void Bignum::ShiftLeft(const int shift_amount) {
   if (used_bigits_ == 0) {
     return;
   }
-  exponent_ += (shift_amount / kBigitSize);
+  exponent_ += static_cast<int16_t>(shift_amount / kBigitSize);
   const int local_shift = shift_amount % kBigitSize;
   EnsureCapacity(used_bigits_ + 1);
   BigitsShiftLeft(local_shift);
@@ -431,7 +432,7 @@ void Bignum::Square() {
   DOUBLE_CONVERSION_ASSERT(accumulator == 0);
 
   // Don't forget to update the used_digits and the exponent.
-  used_bigits_ = product_length;
+  used_bigits_ = static_cast<int16_t>(product_length);
   exponent_ *= 2;
   Clamp();
 }
@@ -752,8 +753,8 @@ void Bignum::Align(const Bignum& other) {
     for (int i = 0; i < zero_bigits; ++i) {
       RawBigit(i) = 0;
     }
-    used_bigits_ += zero_bigits;
-    exponent_ -= zero_bigits;
+    used_bigits_ += static_cast<int16_t>(zero_bigits);
+    exponent_ -= static_cast<int16_t>(zero_bigits);
 
     DOUBLE_CONVERSION_ASSERT(used_bigits_ >= 0);
     DOUBLE_CONVERSION_ASSERT(exponent_ >= 0);
diff --git a/deps/icu-small/source/i18n/double-conversion-double-to-string.cpp b/deps/icu-small/source/i18n/double-conversion-double-to-string.cpp
index 90ba436060..5ee6d2b8e8 100644
--- a/deps/icu-small/source/i18n/double-conversion-double-to-string.cpp
+++ b/deps/icu-small/source/i18n/double-conversion-double-to-string.cpp
@@ -71,7 +71,7 @@ bool DoubleToStringConverter::HandleSpecialValues(
     StringBuilder* result_builder) const {
   Double double_inspect(value);
   if (double_inspect.IsInfinite()) {
-    if (infinity_symbol_ == NULL) return false;
+    if (infinity_symbol_ == DOUBLE_CONVERSION_NULLPTR) return false;
     if (value < 0) {
       result_builder->AddCharacter('-');
     }
@@ -79,7 +79,7 @@ bool DoubleToStringConverter::HandleSpecialValues(
     return true;
   }
   if (double_inspect.IsNan()) {
-    if (nan_symbol_ == NULL) return false;
+    if (nan_symbol_ == DOUBLE_CONVERSION_NULLPTR) return false;
     result_builder->AddString(nan_symbol_);
     return true;
   }
diff --git a/deps/icu-small/source/i18n/double-conversion-string-to-double.cpp b/deps/icu-small/source/i18n/double-conversion-string-to-double.cpp
index c72bb26277..727fff24e1 100644
--- a/deps/icu-small/source/i18n/double-conversion-string-to-double.cpp
+++ b/deps/icu-small/source/i18n/double-conversion-string-to-double.cpp
@@ -495,7 +495,7 @@ double StringToDoubleConverter::StringToIeee(
     current = next_non_space;
   }
 
-  if (infinity_symbol_ != NULL) {
+  if (infinity_symbol_ != DOUBLE_CONVERSION_NULLPTR) {
     if (ConsumeFirstCharacter(*current, infinity_symbol_, allow_case_insensitivity)) {
       if (!ConsumeSubString(&current, end, infinity_symbol_, allow_case_insensitivity)) {
         return junk_string_value_;
@@ -513,7 +513,7 @@ double StringToDoubleConverter::StringToIeee(
     }
   }
 
-  if (nan_symbol_ != NULL) {
+  if (nan_symbol_ != DOUBLE_CONVERSION_NULLPTR) {
     if (ConsumeFirstCharacter(*current, nan_symbol_, allow_case_insensitivity)) {
       if (!ConsumeSubString(&current, end, nan_symbol_, allow_case_insensitivity)) {
         return junk_string_value_;
diff --git a/deps/icu-small/source/i18n/double-conversion-utils.h b/deps/icu-small/source/i18n/double-conversion-utils.h
index 11c92717c1..303668f931 100644
--- a/deps/icu-small/source/i18n/double-conversion-utils.h
+++ b/deps/icu-small/source/i18n/double-conversion-utils.h
@@ -43,6 +43,13 @@
 #include <cstdlib>
 #include <cstring>
 
+// For pre-C++11 compatibility
+#if __cplusplus >= 201103L
+#define DOUBLE_CONVERSION_NULLPTR nullptr
+#else
+#define DOUBLE_CONVERSION_NULLPTR NULL
+#endif
+
 // ICU PATCH: Use U_ASSERT instead of <assert.h>
 #include "uassert.h"
 #ifndef DOUBLE_CONVERSION_ASSERT
@@ -254,9 +261,9 @@ inline int StrLength(const char* string) {
 template <typename T>
 class Vector {
  public:
-  Vector() : start_(NULL), length_(0) {}
+  Vector() : start_(DOUBLE_CONVERSION_NULLPTR), length_(0) {}
   Vector(T* data, int len) : start_(data), length_(len) {
-    DOUBLE_CONVERSION_ASSERT(len == 0 || (len > 0 && data != NULL));
+    DOUBLE_CONVERSION_ASSERT(len == 0 || (len > 0 && data != DOUBLE_CONVERSION_NULLPTR));
   }
 
   // Returns a vector using the same backing storage as this one,
@@ -339,7 +346,7 @@ class StringBuilder {
   void AddSubstring(const char* s, int n) {
     DOUBLE_CONVERSION_ASSERT(!is_finalized() && position_ + n < buffer_.length());
     DOUBLE_CONVERSION_ASSERT(static_cast<size_t>(n) <= strlen(s));
-    memmove(&buffer_[position_], s, n);
+    memmove(&buffer_[position_], s, static_cast<size_t>(n));
     position_ += n;
   }
 
diff --git a/deps/icu-small/source/i18n/dtfmtsym.cpp b/deps/icu-small/source/i18n/dtfmtsym.cpp
index 134b919f06..4c44976124 100644
--- a/deps/icu-small/source/i18n/dtfmtsym.cpp
+++ b/deps/icu-small/source/i18n/dtfmtsym.cpp
@@ -272,7 +272,7 @@ DateFormatSymbols::DateFormatSymbols(const Locale& locale,
 DateFormatSymbols::DateFormatSymbols(UErrorCode& status)
     : UObject()
 {
-  initializeData(Locale::getDefault(), NULL, status, TRUE);
+  initializeData(Locale::getDefault(), NULL, status, true);
 }
 
 
@@ -287,7 +287,7 @@ DateFormatSymbols::DateFormatSymbols(const Locale& locale,
 DateFormatSymbols::DateFormatSymbols(const char *type, UErrorCode& status)
     : UObject()
 {
-  initializeData(Locale::getDefault(), type, status, TRUE);
+  initializeData(Locale::getDefault(), type, status, true);
 }
 
 DateFormatSymbols::DateFormatSymbols(const DateFormatSymbols& other)
@@ -333,7 +333,7 @@ void
 DateFormatSymbols::createZoneStrings(const UnicodeString *const * otherStrings)
 {
     int32_t row, col;
-    UBool failed = FALSE;
+    UBool failed = false;
 
     fZoneStrings = (UnicodeString **)uprv_malloc(fZoneStringsRowCount * sizeof(UnicodeString *));
     if (fZoneStrings != NULL) {
@@ -341,7 +341,7 @@ DateFormatSymbols::createZoneStrings(const UnicodeString *const * otherStrings)
         {
             fZoneStrings[row] = newUnicodeStringArray(fZoneStringsColCount);
             if (fZoneStrings[row] == NULL) {
-                failed = TRUE;
+                failed = true;
                 break;
             }
             for (col=0; col<fZoneStringsColCount; ++col) {
@@ -530,13 +530,13 @@ DateFormatSymbols::arrayCompare(const UnicodeString* array1,
                                 const UnicodeString* array2,
                                 int32_t count)
 {
-    if (array1 == array2) return TRUE;
+    if (array1 == array2) return true;
     while (count>0)
     {
         --count;
-        if (array1[count] != array2[count]) return FALSE;
+        if (array1[count] != array2[count]) return false;
     }
-    return TRUE;
+    return true;
 }
 
 bool
@@ -1334,7 +1334,7 @@ DateFormatSymbols::initZoneStringsArray(void) {
             i++;
         }
 
-    } while (FALSE);
+    } while (false);
 
     if (U_FAILURE(status)) {
         if (zarray) {
@@ -1422,7 +1422,7 @@ static const uint64_t kNumericFieldsForCount12 =
 UBool U_EXPORT2
 DateFormatSymbols::isNumericField(UDateFormatField f, int32_t count) {
     if (f == UDAT_FIELD_COUNT) {
-        return FALSE;
+        return false;
     }
     uint64_t flag = ((uint64_t)1 << f);
     return ((kNumericFieldsAlways & flag) != 0 || ((kNumericFieldsForCount12 & flag) != 0 && count < 3));
@@ -1524,7 +1524,7 @@ struct CalendarDataSink : public ResourceSink {
 
     // Initializes CalendarDataSink with default values
     CalendarDataSink(UErrorCode& status)
-    :   arrays(FALSE, status), arraySizes(FALSE, status), maps(FALSE, status),
+    :   arrays(false, status), arraySizes(false, status), maps(false, status),
         mapRefs(),
         aliasPathPairs(uprv_deleteUObject, uhash_compareUnicodeString, status),
         currentCalendarType(), nextCalendarType(),
@@ -1690,7 +1690,7 @@ struct CalendarDataSink : public ResourceSink {
                 // We are on a leaf, store the map elements into the stringMap
                 if (i == 0) {
                     // mapRefs will keep ownership of 'stringMap':
-                    stringMap = mapRefs.create(FALSE, errorCode);
+                    stringMap = mapRefs.create(false, errorCode);
                     if (stringMap == NULL) {
                         errorCode = U_MEMORY_ALLOCATION_ERROR;
                         return;
@@ -1703,7 +1703,7 @@ struct CalendarDataSink : public ResourceSink {
                 int32_t valueStringSize;
                 const UChar *valueString = value.getString(valueStringSize, errorCode);
                 if (U_FAILURE(errorCode)) { return; }
-                LocalPointer<UnicodeString> valueUString(new UnicodeString(TRUE, valueString, valueStringSize), errorCode);
+                LocalPointer<UnicodeString> valueUString(new UnicodeString(true, valueString, valueStringSize), errorCode);
                 stringMap->put(keyUString, valueUString.orphan(), errorCode);
                 if (U_FAILURE(errorCode)) { return; }
                 continue;
@@ -1717,7 +1717,7 @@ struct CalendarDataSink : public ResourceSink {
             // In cyclicNameSets ignore everything but years/format/abbreviated
             // and zodiacs/format/abbreviated
             if (path.startsWith(kCyclicNameSetsTagUChar, UPRV_LENGTHOF(kCyclicNameSetsTagUChar))) {
-                UBool skip = TRUE;
+                UBool skip = true;
                 int32_t startIndex = UPRV_LENGTHOF(kCyclicNameSetsTagUChar);
                 int32_t length = 0;
                 if (startIndex == path.length()
@@ -1732,7 +1732,7 @@ struct CalendarDataSink : public ResourceSink {
                         length = 0;
                         if (startIndex == path.length()
                             || path.compare(startIndex, (length = UPRV_LENGTHOF(kAbbrTagUChar)), kAbbrTagUChar, 0, UPRV_LENGTHOF(kAbbrTagUChar)) == 0) {
-                            skip = FALSE;
+                            skip = false;
                         }
                     }
                 }
@@ -1854,7 +1854,7 @@ initField(UnicodeString **field, int32_t& length, const UChar *data, LastResortS
             for(int32_t i = 0; i<length; i++) {
                 // readonly aliases - all "data" strings are constant
                 // -1 as length for variable-length strings (gLastResortDayNames[0] is empty)
-                (*(field)+i)->setTo(TRUE, data+(i*((int32_t)strLen)), -1);
+                (*(field)+i)->setTo(true, data+(i*((int32_t)strLen)), -1);
             }
         }
         else {
@@ -1911,7 +1911,7 @@ initLeapMonthPattern(UnicodeString *field, int32_t index, CalendarDataSink &sink
         UnicodeString pathUString(path.data(), -1, US_INV);
         Hashtable *leapMonthTable = static_cast<Hashtable*>(sink.maps.get(pathUString));
         if (leapMonthTable != NULL) {
-            UnicodeString leapLabel(FALSE, kLeapTagUChar, UPRV_LENGTHOF(kLeapTagUChar));
+            UnicodeString leapLabel(false, kLeapTagUChar, UPRV_LENGTHOF(kLeapTagUChar));
             UnicodeString *leapMonthPattern = static_cast<UnicodeString*>(leapMonthTable->get(leapLabel));
             if (leapMonthPattern != NULL) {
                 field[index].fastCopyFrom(*leapMonthPattern);
@@ -2122,7 +2122,7 @@ DateFormatSymbols::initializeData(const Locale& locale, const char *type, UError
         if (status == U_MISSING_RESOURCE_ERROR) {
             ures_close(ctb);
             if (uprv_strcmp(calendarTypeCArray, gGregorianTag) != 0) {
-                calendarType.setTo(FALSE, kGregorianTagUChar, UPRV_LENGTHOF(kGregorianTagUChar));
+                calendarType.setTo(false, kGregorianTagUChar, UPRV_LENGTHOF(kGregorianTagUChar));
                 calendarSink.visitAllResources();
                 status = oldStatus;
                 continue;
@@ -2145,7 +2145,7 @@ DateFormatSymbols::initializeData(const Locale& locale, const char *type, UError
 
         // Gregorian is always the last fallback
         if (calendarType.isBogus()) {
-            calendarType.setTo(FALSE, kGregorianTagUChar, UPRV_LENGTHOF(kGregorianTagUChar));
+            calendarType.setTo(false, kGregorianTagUChar, UPRV_LENGTHOF(kGregorianTagUChar));
             calendarSink.visitAllResources();
         }
     }
@@ -2386,14 +2386,14 @@ DateFormatSymbols::initializeData(const Locale& locale, const char *type, UError
     /*
     // fastCopyFrom()/setTo() - see assignArray comments
     resStr = ures_getStringByKey(fResourceBundle, gLocalPatternCharsTag, &len, &status);
-    fLocalPatternChars.setTo(TRUE, resStr, len);
+    fLocalPatternChars.setTo(true, resStr, len);
     // If the locale data does not include new pattern chars, use the defaults
     // TODO: Consider making this an error, since this may add conflicting characters.
     if (len < PATTERN_CHARS_LEN) {
-        fLocalPatternChars.append(UnicodeString(TRUE, &gPatternChars[len], PATTERN_CHARS_LEN-len));
+        fLocalPatternChars.append(UnicodeString(true, &gPatternChars[len], PATTERN_CHARS_LEN-len));
     }
     */
-    fLocalPatternChars.setTo(TRUE, gPatternChars, PATTERN_CHARS_LEN);
+    fLocalPatternChars.setTo(true, gPatternChars, PATTERN_CHARS_LEN);
 
     // Format wide weekdays -> fWeekdays
     // {sfb} fixed to handle 1-based weekdays
@@ -2494,7 +2494,7 @@ DateFormatSymbols::initializeData(const Locale& locale, const char *type, UError
             initField(&fStandaloneQuarters, fStandaloneQuartersCount, (const UChar *)gLastResortQuarters, kQuarterNum, kQuarterLen, status);
             initField(&fStandaloneShortQuarters, fStandaloneShortQuartersCount, (const UChar *)gLastResortQuarters, kQuarterNum, kQuarterLen, status);
             initField(&fStandaloneNarrowQuarters, fStandaloneNarrowQuartersCount, (const UChar *)gLastResortQuarters, kQuarterNum, kQuarterLen, status);
-            fLocalPatternChars.setTo(TRUE, gPatternChars, PATTERN_CHARS_LEN);
+            fLocalPatternChars.setTo(true, gPatternChars, PATTERN_CHARS_LEN);
         }
     }
 
diff --git a/deps/icu-small/source/i18n/dtitvfmt.cpp b/deps/icu-small/source/i18n/dtitvfmt.cpp
index d51ddcd5c7..eb5be7846e 100644
--- a/deps/icu-small/source/i18n/dtitvfmt.cpp
+++ b/deps/icu-small/source/i18n/dtitvfmt.cpp
@@ -298,7 +298,7 @@ DateIntervalFormat::format(const DateInterval* dtInterval,
     }
 
     FieldPositionOnlyHandler handler(fieldPosition);
-    handler.setAcceptFirstOnly(TRUE);
+    handler.setAcceptFirstOnly(true);
     int8_t ignore;
 
     Mutex lock(&gFormatterMutex);
@@ -351,7 +351,7 @@ DateIntervalFormat::format(Calendar& fromCalendar,
                            FieldPosition& pos,
                            UErrorCode& status) const {
     FieldPositionOnlyHandler handler(pos);
-    handler.setAcceptFirstOnly(TRUE);
+    handler.setAcceptFirstOnly(true);
     int8_t ignore;
 
     Mutex lock(&gFormatterMutex);
@@ -966,23 +966,26 @@ DateIntervalFormat::normalizeHourMetacharacters(const UnicodeString& skeleton) c
     
     UChar hourMetachar = u'\0';
     UChar dayPeriodChar = u'\0';
-    int32_t metacharStart = 0;
-    int32_t metacharCount = 0;
+    int32_t hourFieldStart = 0;
+    int32_t hourFieldLength = 0;
+    int32_t dayPeriodStart = 0;
+    int32_t dayPeriodLength = 0;
     for (int32_t i = 0; i < result.length(); i++) {
         UChar c = result[i];
         if (c == LOW_J || c == CAP_J || c == CAP_C || c == LOW_H || c == CAP_H || c == LOW_K || c == CAP_K) {
             if (hourMetachar == u'\0') {
                 hourMetachar = c;
-                metacharStart = i;
+                hourFieldStart = i;
             }
-            ++metacharCount;
+            ++hourFieldLength;
         } else if (c == LOW_A || c == LOW_B || c == CAP_B) {
             if (dayPeriodChar == u'\0') {
                 dayPeriodChar = c;
+                dayPeriodStart = i;
             }
-            ++metacharCount;
+            ++dayPeriodLength;
         } else {
-            if (hourMetachar != u'\0') {
+            if (hourMetachar != u'\0' && dayPeriodChar != u'\0') {
                 break;
             }
         }
@@ -1022,31 +1025,27 @@ DateIntervalFormat::normalizeHourMetacharacters(const UnicodeString& skeleton) c
             }
         }
         
-        if (hourChar == CAP_H || hourChar == LOW_K) {
-            result.replace(metacharStart, metacharCount, hourChar);
-        } else {
-            UnicodeString hourAndDayPeriod(hourChar);
-            switch (metacharCount) {
-                case 1:
-                case 2:
-                default:
-                    hourAndDayPeriod.append(UnicodeString(dayPeriodChar));
-                    break;
-                case 3:
-                case 4:
-                    for (int32_t i = 0; i < 4; i++) {
-                        hourAndDayPeriod.append(dayPeriodChar);
-                    }
-                    break;
-                case 5:
-                case 6:
-                    for (int32_t i = 0; i < 5; i++) {
-                        hourAndDayPeriod.append(dayPeriodChar);
-                    }
-                    break;
+        UnicodeString hourAndDayPeriod(hourChar);
+        if (hourChar != CAP_H && hourChar != LOW_K) {
+            int32_t newDayPeriodLength = 0;
+            if (dayPeriodLength >= 5 || hourFieldLength >= 5) {
+                newDayPeriodLength = 5;
+            } else if (dayPeriodLength >= 3 || hourFieldLength >= 3) {
+                newDayPeriodLength = 3;
+            } else {
+                newDayPeriodLength = 1;
             }
-            result.replace(metacharStart, metacharCount, hourAndDayPeriod);
+            for (int32_t i = 0; i < newDayPeriodLength; i++) {
+                hourAndDayPeriod.append(dayPeriodChar);
+            }
+        }
+        result.replace(hourFieldStart, hourFieldLength, hourAndDayPeriod);
+        if (dayPeriodStart > hourFieldStart) {
+            // before deleting the original day period field, adjust its position in case
+            // we just changed the size of the hour field (and new day period field)
+            dayPeriodStart += hourAndDayPeriod.length() - hourFieldLength;
         }
+        result.remove(dayPeriodStart, dayPeriodLength);
     }
     return result;
 }
@@ -1208,8 +1207,8 @@ DateIntervalFormat::getDateTimeSkeleton(const UnicodeString& skeleton,
  * @param dateSkeleton   normalized date skeleton
  * @param timeSkeleton   normalized time skeleton
  * @return               whether the resource is found for the skeleton.
- *                       TRUE if interval pattern found for the skeleton,
- *                       FALSE otherwise.
+ *                       true if interval pattern found for the skeleton,
+ *                       false otherwise.
  * @stable ICU 4.0
  */
 UBool
@@ -1421,8 +1420,8 @@ DateIntervalFormat::setIntervalPattern(UCalendarDateFields field,
  * @param extendedBestSkeleton  extended best match skeleton
  * @return                      whether the interval pattern is found
  *                              through extending skeleton or not.
- *                              TRUE if interval pattern is found by
- *                              extending skeleton, FALSE otherwise.
+ *                              true if interval pattern is found by
+ *                              extending skeleton, false otherwise.
  * @stable ICU 4.0
  */
 UBool
@@ -1496,10 +1495,10 @@ DateIntervalFormat::setIntervalPattern(UCalendarDateFields field,
             setIntervalPattern(field, pattern);
         }
         if ( extendedSkeleton && !extendedSkeleton->isEmpty() ) {
-            return TRUE;
+            return true;
         }
     }
-    return FALSE;
+    return false;
 }
 
 
@@ -1540,8 +1539,8 @@ DateIntervalFormat::splitPatternInto2Part(const UnicodeString& intervalPattern)
         if (ch != prevCh && count > 0) {
             // check the repeativeness of pattern letter
             UBool repeated = patternRepeated[(int)(prevCh - PATTERN_CHAR_BASE)];
-            if ( repeated == FALSE ) {
-                patternRepeated[prevCh - PATTERN_CHAR_BASE] = TRUE;
+            if ( repeated == false ) {
+                patternRepeated[prevCh - PATTERN_CHAR_BASE] = true;
             } else {
                 foundRepetition = true;
                 break;
@@ -1569,8 +1568,8 @@ DateIntervalFormat::splitPatternInto2Part(const UnicodeString& intervalPattern)
     // "dd MM" ( no repetition ),
     // "d-d"(last char repeated ), and
     // "d-d MM" ( repetition found )
-    if ( count > 0 && foundRepetition == FALSE ) {
-        if ( patternRepeated[(int)(prevCh - PATTERN_CHAR_BASE)] == FALSE ) {
+    if ( count > 0 && foundRepetition == false ) {
+        if ( patternRepeated[(int)(prevCh - PATTERN_CHAR_BASE)] == false ) {
             count = 0;
         }
     }
@@ -1684,7 +1683,7 @@ DateIntervalFormat::fieldExistsInSkeleton(UCalendarDateFields field,
                                           const UnicodeString& skeleton)
 {
     const UChar fieldChar = fgCalendarFieldToPatternLetter[field];
-    return ( (skeleton.indexOf(fieldChar) == -1)?FALSE:TRUE ) ;
+    return ( (skeleton.indexOf(fieldChar) == -1)?false:true ) ;
 }
 
 
@@ -1726,7 +1725,13 @@ DateIntervalFormat::adjustFieldWidth(const UnicodeString& inputSkeleton,
     DateIntervalInfo::parseSkeleton(inputSkeleton, inputSkeletonFieldWidth);
     DateIntervalInfo::parseSkeleton(bestMatchSkeleton, bestMatchSkeletonFieldWidth);
     if (suppressDayPeriodField) {
+        // remove the 'a' and any NBSP/NNBSP on one side of it
+        findReplaceInPattern(adjustedPtn, UnicodeString(u"\u00A0a",-1), UnicodeString());
+        findReplaceInPattern(adjustedPtn, UnicodeString(u"\u202Fa",-1), UnicodeString());
+        findReplaceInPattern(adjustedPtn, UnicodeString(u"a\u00A0",-1), UnicodeString());
+        findReplaceInPattern(adjustedPtn, UnicodeString(u"a\u202F",-1), UnicodeString());
         findReplaceInPattern(adjustedPtn, UnicodeString(LOW_A), UnicodeString());
+        // adjust interior double spaces, remove exterior whitespace
         findReplaceInPattern(adjustedPtn, UnicodeString("  "), UnicodeString(" "));
         adjustedPtn.trim();
     }
diff --git a/deps/icu-small/source/i18n/dtitvinf.cpp b/deps/icu-small/source/i18n/dtitvinf.cpp
index 6052894b58..f5fb86ce58 100644
--- a/deps/icu-small/source/i18n/dtitvinf.cpp
+++ b/deps/icu-small/source/i18n/dtitvinf.cpp
@@ -401,7 +401,7 @@ DateIntervalInfo::initializeData(const Locale& locale, UErrorCode& status)
     char         localeWithCalendarKey[ULOC_LOCALE_IDENTIFIER_CAPACITY];
     // obtain a locale that always has the calendar key value that should be used
     (void)ures_getFunctionalEquivalent(localeWithCalendarKey, ULOC_LOCALE_IDENTIFIER_CAPACITY, nullptr,
-                                     "calendar", "calendar", locName, nullptr, FALSE, &status);
+                                     "calendar", "calendar", locName, nullptr, false, &status);
     localeWithCalendarKey[ULOC_LOCALE_IDENTIFIER_CAPACITY-1] = 0; // ensure null termination
     // now get the calendar key value from that locale
     int32_t calendarTypeLen = uloc_getKeywordValue(localeWithCalendarKey, "calendar", calendarType,
@@ -437,7 +437,7 @@ DateIntervalInfo::initializeData(const Locale& locale, UErrorCode& status)
         }
 
         if ( U_SUCCESS(status) && (resStr != nullptr)) {
-            UnicodeString pattern = UnicodeString(TRUE, resStr, resStrLen);
+            UnicodeString pattern = UnicodeString(true, resStr, resStrLen);
             setFallbackIntervalPattern(pattern, status);
         }
         ures_close(itvDtPtnResource);
@@ -449,7 +449,7 @@ DateIntervalInfo::initializeData(const Locale& locale, UErrorCode& status)
         const UnicodeString &calendarTypeToUseUString = sink.getNextCalendarType();
 
         // Already loaded calendar types
-        Hashtable loadedCalendarTypes(FALSE, status);
+        Hashtable loadedCalendarTypes(false, status);
 
         if (U_SUCCESS(status)) {
             while (!calendarTypeToUseUString.isBogus()) {
@@ -504,7 +504,7 @@ DateIntervalInfo::setIntervalPatternInternally(const UnicodeString& skeleton,
     }
 
     patternsOfOneSkeleton[index] = intervalPattern;
-    if ( emptyHash == TRUE ) {
+    if ( emptyHash == true ) {
         fIntervalPatterns->put(skeleton, patternsOfOneSkeleton, status);
     }
 }
@@ -738,7 +738,7 @@ U_CDECL_BEGIN
  *
  * @param val1  one value in comparison
  * @param val2  the other value in comparison
- * @return      TRUE if 2 values are the same, FALSE otherwise
+ * @return      true if 2 values are the same, false otherwise
  */
 static UBool U_CALLCONV dtitvinfHashTableValueComparator(UHashTok val1, UHashTok val2);
 
@@ -746,9 +746,9 @@ static UBool
 U_CALLCONV dtitvinfHashTableValueComparator(UHashTok val1, UHashTok val2) {
     const UnicodeString* pattern1 = (UnicodeString*)val1.pointer;
     const UnicodeString* pattern2 = (UnicodeString*)val2.pointer;
-    UBool ret = TRUE;
+    UBool ret = true;
     int8_t i;
-    for ( i = 0; i < DateIntervalInfo::kMaxIntervalPatternIndex && ret == TRUE; ++i ) {
+    for ( i = 0; i < DateIntervalInfo::kMaxIntervalPatternIndex && ret == true; ++i ) {
         ret = (pattern1[i] == pattern2[i]);
     }
     return ret;
@@ -763,7 +763,7 @@ DateIntervalInfo::initHash(UErrorCode& status) {
         return nullptr;
     }
     Hashtable* hTable;
-    if ( (hTable = new Hashtable(FALSE, status)) == nullptr ) {
+    if ( (hTable = new Hashtable(false, status)) == nullptr ) {
         status = U_MEMORY_ALLOCATION_ERROR;
         return nullptr;
     }
diff --git a/deps/icu-small/source/i18n/dtptngen.cpp b/deps/icu-small/source/i18n/dtptngen.cpp
index e781c6e26f..f4e28de91b 100644
--- a/deps/icu-small/source/i18n/dtptngen.cpp
+++ b/deps/icu-small/source/i18n/dtptngen.cpp
@@ -100,7 +100,7 @@ static void ures_a_open(UResourceBundleAIterator *aiter, UResourceBundle *bund,
         aiter->entries[i].key = (UChar*)uprv_malloc(len*sizeof(UChar));
         u_charsToUChars(akey, aiter->entries[i].key, len);
     }
-    uprv_sortArray(aiter->entries, aiter->num, sizeof(UResAEntry), ures_a_codepointSort, nullptr, TRUE, status);
+    uprv_sortArray(aiter->entries, aiter->num, sizeof(UResAEntry), ures_a_codepointSort, nullptr, true, status);
 #endif
 }
 
@@ -283,6 +283,7 @@ static const UChar UDATPG_ItemFormat[]= {0x7B, 0x30, 0x7D, 0x20, 0x251C, 0x7B, 0
 //static const UChar repeatedPatterns[6]={CAP_G, CAP_E, LOW_Z, LOW_V, CAP_Q, 0}; // "GEzvQ"
 
 static const char DT_DateTimePatternsTag[]="DateTimePatterns";
+static const char DT_DateAtTimePatternsTag[]="DateTimePatterns%atTime";
 static const char DT_DateTimeCalendarTag[]="calendar";
 static const char DT_DateTimeGregorianTag[]="gregorian";
 static const char DT_DateTimeAppendItemsTag[]="appendItems";
@@ -473,7 +474,7 @@ DateTimePatternGenerator::~DateTimePatternGenerator() {
 
 namespace {
 
-UInitOnce initOnce = U_INITONCE_INITIALIZER;
+UInitOnce initOnce {};
 UHashtable *localeToAllowedHourFormatsMap = nullptr;
 
 // Value deleter for hashmap.
@@ -484,7 +485,7 @@ U_CFUNC void U_CALLCONV deleteAllowedHourFormats(void *ptr) {
 // Close hashmap at cleanup.
 U_CFUNC UBool U_CALLCONV allowedHourFormatsCleanup() {
     uhash_close(localeToAllowedHourFormatsMap);
-    return TRUE;
+    return true;
 }
 
 enum AllowedHourFormat{
@@ -655,6 +656,17 @@ void DateTimePatternGenerator::getAllowedHourFormats(const Locale &locale, UErro
 
     const char *language = locale.getLanguage();
     const char *country = locale.getCountry();
+    
+    char regionOverride[8];
+    int32_t regionOverrideLength = locale.getKeywordValue("rg", regionOverride, sizeof(regionOverride), status);
+    if (U_SUCCESS(status) && regionOverrideLength > 0) {
+        country = regionOverride;
+        if (regionOverrideLength > 2) {
+            // chop off any subdivision codes that may have been included
+            regionOverride[2] = '\0';
+        }
+    }
+    
     Locale maxLocale;  // must be here for correct lifetime
     if (*language == '\0' || *country == '\0') {
         maxLocale = locale;
@@ -808,7 +820,7 @@ DateTimePatternGenerator::addICUPatterns(const Locale& locale, UErrorCode& statu
         SimpleDateFormat* sdf;
         if (df != nullptr && (sdf = dynamic_cast<SimpleDateFormat*>(df)) != nullptr) {
             sdf->toPattern(dfPattern);
-            addPattern(dfPattern, FALSE, conflictingString, status);
+            addPattern(dfPattern, false, conflictingString, status);
         }
         // TODO Maybe we should return an error when the date format isn't simple.
         delete df;
@@ -817,7 +829,7 @@ DateTimePatternGenerator::addICUPatterns(const Locale& locale, UErrorCode& statu
         df = DateFormat::createTimeInstance(style, locale);
         if (df != nullptr && (sdf = dynamic_cast<SimpleDateFormat*>(df)) != nullptr) {
             sdf->toPattern(dfPattern);
-            addPattern(dfPattern, FALSE, conflictingString, status);
+            addPattern(dfPattern, false, conflictingString, status);
 
             // TODO: C++ and Java are inconsistent (see #12568).
             // C++ uses MEDIUM, but Java uses SHORT.
@@ -837,7 +849,7 @@ DateTimePatternGenerator::hackTimes(const UnicodeString& hackPattern, UErrorCode
 
     fp->set(hackPattern);
     UnicodeString mmss;
-    UBool gotMm=FALSE;
+    UBool gotMm=false;
     for (int32_t i=0; i<fp->itemNumber; ++i) {
         UnicodeString field = fp->items[i];
         if ( fp->isQuoteLiteral(field) ) {
@@ -854,7 +866,7 @@ DateTimePatternGenerator::hackTimes(const UnicodeString& hackPattern, UErrorCode
             else {
                 UChar ch=field.charAt(0);
                 if (ch==LOW_M) {
-                    gotMm=TRUE;
+                    gotMm=true;
                     mmss+=field;
                 }
                 else {
@@ -863,7 +875,7 @@ DateTimePatternGenerator::hackTimes(const UnicodeString& hackPattern, UErrorCode
                             break;
                         }
                         mmss+= field;
-                        addPattern(mmss, FALSE, conflictingString, status);
+                        addPattern(mmss, false, conflictingString, status);
                         break;
                     }
                     else {
@@ -894,7 +906,7 @@ DateTimePatternGenerator::getCalendarTypeToUse(const Locale& locale, CharString&
             "calendar",
             locale.getName(),
             nullptr,
-            FALSE,
+            false,
             &localStatus);
         localeWithCalendarKey[ULOC_LOCALE_IDENTIFIER_CAPACITY-1] = 0; // ensure null termination
         // now get the calendar key value from that locale
@@ -949,7 +961,7 @@ struct DateTimePatternGenerator::AppendItemFormatsSink : public ResourceSink {
     }
 
     void fillInMissing() {
-        UnicodeString defaultItemFormat(TRUE, UDATPG_ItemFormat, UPRV_LENGTHOF(UDATPG_ItemFormat)-1);  // Read-only alias.
+        UnicodeString defaultItemFormat(true, UDATPG_ItemFormat, UPRV_LENGTHOF(UDATPG_ItemFormat)-1);  // Read-only alias.
         for (int32_t i = 0; i < UDATPG_FIELD_COUNT; i++) {
             UDateTimePatternField field = (UDateTimePatternField)i;
             if (dtpg.getAppendItemFormat(field).isEmpty()) {
@@ -1093,7 +1105,7 @@ DateTimePatternGenerator::initHashtable(UErrorCode& err) {
     if (fAvailableFormatKeyHash!=nullptr) {
         return;
     }
-    LocalPointer<Hashtable> hash(new Hashtable(FALSE, err), err);
+    LocalPointer<Hashtable> hash(new Hashtable(false, err), err);
     if (U_SUCCESS(err)) {
         fAvailableFormatKeyHash = hash.orphan();
     }
@@ -1235,7 +1247,7 @@ UnicodeString
 DateTimePatternGenerator::mapSkeletonMetacharacters(const UnicodeString& patternForm, int32_t* flags, UErrorCode& status) {
     UnicodeString patternFormMapped;
     patternFormMapped.remove();
-    UBool inQuoted = FALSE;
+    UBool inQuoted = false;
     int32_t patPos, patLen = patternForm.length();
     for (patPos = 0; patPos < patLen; patPos++) {
         UChar patChr = patternForm.charAt(patPos);
@@ -1347,7 +1359,7 @@ DateTimePatternGenerator::addCanonicalItems(UErrorCode& status) {
 
     for (int32_t i=0; i<UDATPG_FIELD_COUNT; i++) {
         if (Canonical_Items[i] > 0) {
-            addPattern(UnicodeString(Canonical_Items[i]), FALSE, conflictingPattern, status);
+            addPattern(UnicodeString(Canonical_Items[i]), false, conflictingPattern, status);
         }
         if (U_FAILURE(status)) { return; }
     }
@@ -1396,6 +1408,8 @@ DateTimePatternGenerator::getDateTimeFormat(UDateFormatStyle style, UErrorCode&
     return dateTimeFormat[style];
 }
 
+static const int32_t cTypeBufMax = 32;
+
 void
 DateTimePatternGenerator::setDateTimeFromCalendar(const Locale& locale, UErrorCode& status) {
     if (U_FAILURE(status)) { return; }
@@ -1403,40 +1417,68 @@ DateTimePatternGenerator::setDateTimeFromCalendar(const Locale& locale, UErrorCo
     const UChar *resStr;
     int32_t resStrLen = 0;
 
-    LocalPointer<Calendar> fCalendar(Calendar::createInstance(locale, status), status);
-    if (U_FAILURE(status)) { return; }
-
     LocalUResourceBundlePointer calData(ures_open(nullptr, locale.getBaseName(), &status));
     if (U_FAILURE(status)) { return; }
     ures_getByKey(calData.getAlias(), DT_DateTimeCalendarTag, calData.getAlias(), &status);
     if (U_FAILURE(status)) { return; }
 
-    LocalUResourceBundlePointer dateTimePatterns;
-    if (fCalendar->getType() != nullptr && *fCalendar->getType() != '\0'
-            && uprv_strcmp(fCalendar->getType(), DT_DateTimeGregorianTag) != 0) {
-        dateTimePatterns.adoptInstead(ures_getByKeyWithFallback(calData.getAlias(), fCalendar->getType(),
-                                                                nullptr, &status));
-        ures_getByKeyWithFallback(dateTimePatterns.getAlias(), DT_DateTimePatternsTag,
-                                  dateTimePatterns.getAlias(), &status);
+    char cType[cTypeBufMax + 1];
+    Calendar::getCalendarTypeFromLocale(locale, cType, cTypeBufMax, status);
+    cType[cTypeBufMax] = 0;
+    if (U_FAILURE(status) || cType[0] == 0) {
+        status = U_ZERO_ERROR;
+        uprv_strcpy(cType, DT_DateTimeGregorianTag);
     }
+    UBool cTypeIsGregorian = (uprv_strcmp(cType, DT_DateTimeGregorianTag) == 0);
 
+    // Currently, for compatibility with pre-CLDR-42 data, we default to the "atTime"
+    // combining patterns. Depending on guidance in CLDR 42 spec and on DisplayOptions,
+    // we may change this.
+    LocalUResourceBundlePointer specificCalBundle;
+    LocalUResourceBundlePointer dateTimePatterns;
+    int32_t dateTimeOffset = 0; // initially for DateTimePatterns%atTime
+    if (!cTypeIsGregorian) {
+        specificCalBundle.adoptInstead(ures_getByKeyWithFallback(calData.getAlias(), cType,
+                                        nullptr, &status));
+        dateTimePatterns.adoptInstead(ures_getByKeyWithFallback(specificCalBundle.getAlias(), DT_DateAtTimePatternsTag, // the %atTime variant, 4 entries
+                                        nullptr, &status));
+    }
     if (dateTimePatterns.isNull() || status == U_MISSING_RESOURCE_ERROR) {
         status = U_ZERO_ERROR;
-        dateTimePatterns.adoptInstead(ures_getByKeyWithFallback(calData.getAlias(), DT_DateTimeGregorianTag,
-                                                                dateTimePatterns.orphan(), &status));
-        ures_getByKeyWithFallback(dateTimePatterns.getAlias(), DT_DateTimePatternsTag,
-                                  dateTimePatterns.getAlias(), &status);
+        specificCalBundle.adoptInstead(ures_getByKeyWithFallback(calData.getAlias(), DT_DateTimeGregorianTag,
+                                        nullptr, &status));
+        dateTimePatterns.adoptInstead(ures_getByKeyWithFallback(specificCalBundle.getAlias(), DT_DateAtTimePatternsTag, // the %atTime variant, 4 entries
+                                        nullptr, &status));
     }
-    if (U_FAILURE(status)) { return; }
-
-    if (ures_getSize(dateTimePatterns.getAlias()) <= DateFormat::kDateTimeOffset + DateFormat::kShort)
-    {
+    if (U_SUCCESS(status) && (ures_getSize(dateTimePatterns.getAlias()) < 4)) {
         status = U_INVALID_FORMAT_ERROR;
-        return;
     }
+    if (status == U_MISSING_RESOURCE_ERROR) {
+        // Try again with standard variant
+        status = U_ZERO_ERROR;
+        dateTimePatterns.orphan();
+        dateTimeOffset = (int32_t)DateFormat::kDateTimeOffset;
+        if (!cTypeIsGregorian) {
+            specificCalBundle.adoptInstead(ures_getByKeyWithFallback(calData.getAlias(), cType,
+                                            nullptr, &status));
+            dateTimePatterns.adoptInstead(ures_getByKeyWithFallback(specificCalBundle.getAlias(), DT_DateTimePatternsTag, // the standard variant, 13 entries
+                                            nullptr, &status));
+        }
+        if (dateTimePatterns.isNull() || status == U_MISSING_RESOURCE_ERROR) {
+            status = U_ZERO_ERROR;
+            specificCalBundle.adoptInstead(ures_getByKeyWithFallback(calData.getAlias(), DT_DateTimeGregorianTag,
+                                            nullptr, &status));
+            dateTimePatterns.adoptInstead(ures_getByKeyWithFallback(specificCalBundle.getAlias(), DT_DateTimePatternsTag, // the standard variant, 13 entries
+                                            nullptr, &status));
+        }
+        if (U_SUCCESS(status) && (ures_getSize(dateTimePatterns.getAlias()) <= DateFormat::kDateTimeOffset + DateFormat::kShort)) {
+            status = U_INVALID_FORMAT_ERROR;
+        }
+    }
+    if (U_FAILURE(status)) { return; }
     for (int32_t style = UDAT_FULL; style <= UDAT_SHORT; style++) {
-        resStr = ures_getStringByIndex(dateTimePatterns.getAlias(), (int32_t)DateFormat::kDateTimeOffset + style, &resStrLen, &status);
-        setDateTimeFormat((UDateFormatStyle)style, UnicodeString(TRUE, resStr, resStrLen), status);
+        resStr = ures_getStringByIndex(dateTimePatterns.getAlias(), dateTimeOffset + style, &resStrLen, &status);
+        setDateTimeFormat((UDateFormatStyle)style, UnicodeString(true, resStr, resStrLen), status);
     }
 }
 
@@ -1944,14 +1986,14 @@ DateTimePatternGenerator::getRedundants(UErrorCode& status) {
 UBool
 DateTimePatternGenerator::isCanonicalItem(const UnicodeString& item) const {
     if ( item.length() != 1 ) {
-        return FALSE;
+        return false;
     }
     for (int32_t i=0; i<UDATPG_FIELD_COUNT; ++i) {
         if (item.charAt(0)==Canonical_Items[i]) {
-            return TRUE;
+            return true;
         }
     }
-    return FALSE;
+    return false;
 }
 
 
@@ -1964,7 +2006,7 @@ PatternMap::PatternMap() {
    for (int32_t i=0; i < MAX_PATTERN_ENTRIES; ++i ) {
        boot[i] = nullptr;
    }
-   isDupAllowed = TRUE;
+   isDupAllowed = true;
 }
 
 void
@@ -2176,14 +2218,14 @@ PatternMap::getPatternFromSkeleton(const PtnSkeleton& skeleton, const PtnSkeleto
 UBool
 PatternMap::equals(const PatternMap& other) const {
     if ( this==&other ) {
-        return TRUE;
+        return true;
     }
     for (int32_t bootIndex = 0; bootIndex < MAX_PATTERN_ENTRIES; ++bootIndex) {
         if (boot[bootIndex] == other.boot[bootIndex]) {
             continue;
         }
         if ((boot[bootIndex] == nullptr) || (other.boot[bootIndex] == nullptr)) {
-            return FALSE;
+            return false;
         }
         PtnElem *otherElem = other.boot[bootIndex];
         PtnElem *myElem = boot[bootIndex];
@@ -2192,25 +2234,25 @@ PatternMap::equals(const PatternMap& other) const {
                 break;
             }
             if ((otherElem == nullptr) || (myElem == nullptr)) {
-                return FALSE;
+                return false;
             }
             if ( (myElem->basePattern != otherElem->basePattern) ||
                  (myElem->pattern != otherElem->pattern) ) {
-                return FALSE;
+                return false;
             }
             if ((myElem->skeleton.getAlias() != otherElem->skeleton.getAlias()) &&
                 !myElem->skeleton->equals(*(otherElem->skeleton))) {
-                return FALSE;
+                return false;
             }
             myElem = myElem->next.getAlias();
             otherElem = otherElem->next.getAlias();
         }
     }
-    return TRUE;
+    return true;
 }
 
 // find any key existing in the mapping table already.
-// return TRUE if there is an existing key, otherwise return FALSE.
+// return true if there is an existing key, otherwise return false.
 PtnElem*
 PatternMap::getDuplicateElem(
             const UnicodeString &basePattern,
@@ -2226,10 +2268,10 @@ PatternMap::getDuplicateElem(
    }
    do {
      if ( basePattern.compare(curElem->basePattern)==0 ) {
-         UBool isEqual = TRUE;
+         UBool isEqual = true;
          for (int32_t i = 0; i < UDATPG_FIELD_COUNT; ++i) {
             if (curElem->skeleton->type[i] != skeleton.type[i] ) {
-                isEqual = FALSE;
+                isEqual = false;
                 break;
             }
         }
@@ -2274,7 +2316,7 @@ DateTimeMatcher::set(const UnicodeString& pattern, FormatParser* fp, PtnSkeleton
     }
     skeletonResult.original.clear();
     skeletonResult.baseOriginal.clear();
-    skeletonResult.addedDefaultDayPeriod = FALSE;
+    skeletonResult.addedDefaultDayPeriod = false;
 
     fp->set(pattern);
     for (i=0; i < fp->itemNumber; i++) {
@@ -2342,7 +2384,7 @@ DateTimeMatcher::set(const UnicodeString& pattern, FormatParser* fp, PtnSkeleton
                         skeletonResult.original.populate(UDATPG_DAYPERIOD_FIELD, dtTypes[i].patternChar, dtTypes[i].minLen);
                         skeletonResult.baseOriginal.populate(UDATPG_DAYPERIOD_FIELD, dtTypes[i].patternChar, dtTypes[i].minLen);
                         skeletonResult.type[UDATPG_DAYPERIOD_FIELD] = dtTypes[i].type;
-                        skeletonResult.addedDefaultDayPeriod = TRUE;
+                        skeletonResult.addedDefaultDayPeriod = true;
                         break;
                     }
                 }
@@ -2410,7 +2452,7 @@ DateTimeMatcher::copyFrom() {
 
 UBool
 DateTimeMatcher::equals(const DateTimeMatcher* other) const {
-    if (other==nullptr) { return FALSE; }
+    if (other==nullptr) { return false; }
     return skeleton.original == other->skeleton.original;
 }
 
@@ -2569,10 +2611,10 @@ FormatParser::isPatternSeparator(const UnicodeString& field) const {
             continue;
         }
         else {
-            return FALSE;
+            return false;
         }
     }
-    return TRUE;
+    return true;
 }
 
 DistanceInfo::~DistanceInfo() {}
@@ -2614,12 +2656,12 @@ PatternMapIterator::hasNext() const {
     PtnElem *curPtr = nodePtr;
 
     if (patternMap==nullptr) {
-        return FALSE;
+        return false;
     }
     while ( headIndex < MAX_PATTERN_ENTRIES ) {
         if ( curPtr != nullptr ) {
             if ( curPtr->next != nullptr ) {
-                return TRUE;
+                return true;
             }
             else {
                 headIndex++;
@@ -2629,7 +2671,7 @@ PatternMapIterator::hasNext() const {
         }
         else {
             if ( patternMap->boot[headIndex] != nullptr ) {
-                return TRUE;
+                return true;
             }
             else {
                 headIndex++;
@@ -2637,7 +2679,7 @@ PatternMapIterator::hasNext() const {
             }
         }
     }
-    return FALSE;
+    return false;
 }
 
 DateTimeMatcher&
@@ -2744,7 +2786,7 @@ UChar SkeletonFields::getFirstChar() const {
 
 
 PtnSkeleton::PtnSkeleton()
-    : addedDefaultDayPeriod(FALSE) {
+    : addedDefaultDayPeriod(false) {
 }
 
 PtnSkeleton::PtnSkeleton(const PtnSkeleton& other) {
@@ -2882,14 +2924,14 @@ DTSkeletonEnumeration::count(UErrorCode& /*status*/) const {
 UBool
 DTSkeletonEnumeration::isCanonicalItem(const UnicodeString& item) {
     if ( item.length() != 1 ) {
-        return FALSE;
+        return false;
     }
     for (int32_t i=0; i<UDATPG_FIELD_COUNT; ++i) {
         if (item.charAt(0)==Canonical_Items[i]) {
-            return TRUE;
+            return true;
         }
     }
-    return FALSE;
+    return false;
 }
 
 DTSkeletonEnumeration::~DTSkeletonEnumeration() {
@@ -2949,14 +2991,14 @@ DTRedundantEnumeration::count(UErrorCode& /*status*/) const {
 UBool
 DTRedundantEnumeration::isCanonicalItem(const UnicodeString& item) const {
     if ( item.length() != 1 ) {
-        return FALSE;
+        return false;
     }
     for (int32_t i=0; i<UDATPG_FIELD_COUNT; ++i) {
         if (item.charAt(0)==Canonical_Items[i]) {
-            return TRUE;
+            return true;
         }
     }
-    return FALSE;
+    return false;
 }
 
 DTRedundantEnumeration::~DTRedundantEnumeration() {
diff --git a/deps/icu-small/source/i18n/erarules.cpp b/deps/icu-small/source/i18n/erarules.cpp
index e375740bd6..ffc7c993a2 100644
--- a/deps/icu-small/source/i18n/erarules.cpp
+++ b/deps/icu-small/source/i18n/erarules.cpp
@@ -156,8 +156,8 @@ EraRules* EraRules::createInstance(const char *calType, UBool includeTentativeEr
             return nullptr;
         }
 
-        UBool hasName = TRUE;
-        UBool hasEnd = TRUE;
+        UBool hasName = true;
+        UBool hasEnd = true;
         int32_t len;
         while (ures_hasNext(eraRuleRes.getAlias())) {
             LocalUResourceBundlePointer res(ures_getNextResource(eraRuleRes.getAlias(), nullptr, &status));
@@ -178,10 +178,10 @@ EraRules* EraRules::createInstance(const char *calType, UBool includeTentativeEr
             } else if (uprv_strcmp(key, "named") == 0) {
                 const UChar *val = ures_getString(res.getAlias(), &len, &status);
                 if (u_strncmp(val, VAL_FALSE, VAL_FALSE_LEN) == 0) {
-                    hasName = FALSE;
+                    hasName = false;
                 }
             } else if (uprv_strcmp(key, "end") == 0) {
-                hasEnd = TRUE;
+                hasEnd = true;
             }
         }
 
@@ -300,7 +300,7 @@ void EraRules::initCurrentEra() {
     // If we failed to create the default time zone, we are in a bad state and don't
     // really have many options. Carry on using UTC millis as a fallback.
     if (zone != nullptr) {
-        zone->getOffset(localMillis, FALSE, rawOffset, dstOffset, ec);
+        zone->getOffset(localMillis, false, rawOffset, dstOffset, ec);
         delete zone;
         localMillis += (rawOffset + dstOffset);
     }
diff --git a/deps/icu-small/source/i18n/esctrn.cpp b/deps/icu-small/source/i18n/esctrn.cpp
index ba0e4c2c7b..00c1304d24 100644
--- a/deps/icu-small/source/i18n/esctrn.cpp
+++ b/deps/icu-small/source/i18n/esctrn.cpp
@@ -36,28 +36,28 @@ UOBJECT_DEFINE_RTTI_IMPLEMENTATION(EscapeTransliterator)
  */
 static Transliterator* _createEscUnicode(const UnicodeString& ID, Transliterator::Token /*context*/) {
     // Unicode: "U+10FFFF" hex, min=4, max=6
-    return new EscapeTransliterator(ID, UnicodeString(TRUE, UNIPRE, 2), UnicodeString(), 16, 4, TRUE, NULL);
+    return new EscapeTransliterator(ID, UnicodeString(true, UNIPRE, 2), UnicodeString(), 16, 4, true, NULL);
 }
 static Transliterator* _createEscJava(const UnicodeString& ID, Transliterator::Token /*context*/) {
     // Java: "\\uFFFF" hex, min=4, max=4
-    return new EscapeTransliterator(ID, UnicodeString(TRUE, BS_u, 2), UnicodeString(), 16, 4, FALSE, NULL);
+    return new EscapeTransliterator(ID, UnicodeString(true, BS_u, 2), UnicodeString(), 16, 4, false, NULL);
 }
 static Transliterator* _createEscC(const UnicodeString& ID, Transliterator::Token /*context*/) {
     // C: "\\uFFFF" hex, min=4, max=4; \\U0010FFFF hex, min=8, max=8
-    return new EscapeTransliterator(ID, UnicodeString(TRUE, BS_u, 2), UnicodeString(), 16, 4, TRUE,
-             new EscapeTransliterator(UnicodeString(), UnicodeString(TRUE, BS_U, 2), UnicodeString(), 16, 8, TRUE, NULL));
+    return new EscapeTransliterator(ID, UnicodeString(true, BS_u, 2), UnicodeString(), 16, 4, true,
+             new EscapeTransliterator(UnicodeString(), UnicodeString(true, BS_U, 2), UnicodeString(), 16, 8, true, NULL));
 }
 static Transliterator* _createEscXML(const UnicodeString& ID, Transliterator::Token /*context*/) {
     // XML: "&#x10FFFF;" hex, min=1, max=6
-    return new EscapeTransliterator(ID, UnicodeString(TRUE, XMLPRE, 3), UnicodeString(SEMI[0]), 16, 1, TRUE, NULL);
+    return new EscapeTransliterator(ID, UnicodeString(true, XMLPRE, 3), UnicodeString(SEMI[0]), 16, 1, true, NULL);
 }
 static Transliterator* _createEscXML10(const UnicodeString& ID, Transliterator::Token /*context*/) {
     // XML10: "&1114111;" dec, min=1, max=7 (not really "Any-Hex")
-    return new EscapeTransliterator(ID, UnicodeString(TRUE, XML10PRE, 2), UnicodeString(SEMI[0]), 10, 1, TRUE, NULL);
+    return new EscapeTransliterator(ID, UnicodeString(true, XML10PRE, 2), UnicodeString(SEMI[0]), 10, 1, true, NULL);
 }
 static Transliterator* _createEscPerl(const UnicodeString& ID, Transliterator::Token /*context*/) {
     // Perl: "\\x{263A}" hex, min=1, max=6
-    return new EscapeTransliterator(ID, UnicodeString(TRUE, PERLPRE, 3), UnicodeString(RBRACE[0]), 16, 1, TRUE, NULL);
+    return new EscapeTransliterator(ID, UnicodeString(true, PERLPRE, 3), UnicodeString(RBRACE[0]), 16, 1, true, NULL);
 }
 
 /**
@@ -139,7 +139,7 @@ void EscapeTransliterator::handleTransliterate(Replaceable& text,
 
     UnicodeString buf(prefix);
     int32_t prefixLen = prefix.length();
-    UBool redoPrefix = FALSE;
+    UBool redoPrefix = false;
 
     while (start < limit) {
         int32_t c = grokSupplementals ? text.char32At(start) : text.charAt(start);
@@ -151,12 +151,12 @@ void EscapeTransliterator::handleTransliterate(Replaceable& text,
             ICU_Utility::appendNumber(buf, c, supplementalHandler->radix,
                                   supplementalHandler->minDigits);
             buf.append(supplementalHandler->suffix);
-            redoPrefix = TRUE;
+            redoPrefix = true;
         } else {
             if (redoPrefix) {
                 buf.truncate(0);
                 buf.append(prefix);
-                redoPrefix = FALSE;
+                redoPrefix = false;
             } else {
                 buf.truncate(prefixLen);
             }
diff --git a/deps/icu-small/source/i18n/ethpccal.cpp b/deps/icu-small/source/i18n/ethpccal.cpp
index 7c7c0ba37b..0793787224 100644
--- a/deps/icu-small/source/i18n/ethpccal.cpp
+++ b/deps/icu-small/source/i18n/ethpccal.cpp
@@ -143,7 +143,7 @@ EthiopicCalendar::handleGetLimit(UCalendarDateFields field, ELimitType limitType
  */
 static UDate           gSystemDefaultCenturyStart       = DBL_MIN;
 static int32_t         gSystemDefaultCenturyStartYear   = -1;
-static icu::UInitOnce  gSystemDefaultCenturyInit        = U_INITONCE_INITIALIZER;
+static icu::UInitOnce  gSystemDefaultCenturyInit        {};
 
 static void U_CALLCONV initializeSystemDefaultCentury()
 {
diff --git a/deps/icu-small/source/i18n/fmtable.cpp b/deps/icu-small/source/i18n/fmtable.cpp
index 7a9a81ded5..c3ede98328 100644
--- a/deps/icu-small/source/i18n/fmtable.cpp
+++ b/deps/icu-small/source/i18n/fmtable.cpp
@@ -53,7 +53,7 @@ using number::impl::DecimalQuantity;
 // NOTE: These inlines assume that all fObjects are in fact instances
 // of the Measure class, which is true as of 3.0.  [alan]
 
-// Return TRUE if *a == *b.
+// Return true if *a == *b.
 static inline UBool objectEquals(const UObject* a, const UObject* b) {
     // LATER: return *a == *b;
     return *((const Measure*) a) == *((const Measure*) b);
@@ -65,7 +65,7 @@ static inline UObject* objectClone(const UObject* a) {
     return ((const Measure*) a)->clone();
 }
 
-// Return TRUE if *a is an instance of Measure.
+// Return true if *a is an instance of Measure.
 static inline UBool instanceOfMeasure(const UObject* a) {
     return dynamic_cast<const Measure*>(a) != NULL;
 }
@@ -382,9 +382,9 @@ Formattable::isNumeric() const {
     case kDouble:
     case kLong:
     case kInt64:
-        return TRUE;
+        return true;
     default:
-        return FALSE;
+        return false;
     }
 }
 
diff --git a/deps/icu-small/source/i18n/formatted_string_builder.cpp b/deps/icu-small/source/i18n/formatted_string_builder.cpp
index 734078644b..8dbf954af9 100644
--- a/deps/icu-small/source/i18n/formatted_string_builder.cpp
+++ b/deps/icu-small/source/i18n/formatted_string_builder.cpp
@@ -6,6 +6,7 @@
 #if !UCONFIG_NO_FORMATTING
 
 #include "formatted_string_builder.h"
+#include "putilimp.h"
 #include "unicode/ustring.h"
 #include "unicode/utf16.h"
 #include "unicode/unum.h" // for UNumberFormatFields literals
@@ -197,6 +198,9 @@ FormattedStringBuilder::splice(int32_t startThis, int32_t endThis,  const Unicod
     int32_t thisLength = endThis - startThis;
     int32_t otherLength = endOther - startOther;
     int32_t count = otherLength - thisLength;
+    if (U_FAILURE(status)) {
+        return count;
+    }
     int32_t position;
     if (count > 0) {
         // Overall, chars need to be added.
@@ -221,6 +225,9 @@ int32_t FormattedStringBuilder::append(const FormattedStringBuilder &other, UErr
 
 int32_t
 FormattedStringBuilder::insert(int32_t index, const FormattedStringBuilder &other, UErrorCode &status) {
+    if (U_FAILURE(status)) {
+        return 0;
+    }
     if (this == &other) {
         status = U_ILLEGAL_ARGUMENT_ERROR;
         return 0;
@@ -255,12 +262,18 @@ int32_t FormattedStringBuilder::prepareForInsert(int32_t index, int32_t count, U
     U_ASSERT(index >= 0);
     U_ASSERT(index <= fLength);
     U_ASSERT(count >= 0);
+    U_ASSERT(fZero >= 0);
+    U_ASSERT(fLength >= 0);
+    U_ASSERT(getCapacity() - fZero >= fLength);
+    if (U_FAILURE(status)) {
+        return count;
+    }
     if (index == 0 && fZero - count >= 0) {
         // Append to start
         fZero -= count;
         fLength += count;
         return fZero;
-    } else if (index == fLength && fZero + fLength + count < getCapacity()) {
+    } else if (index == fLength && count <= getCapacity() - fZero - fLength) {
         // Append to end
         fLength += count;
         return fZero + fLength - count;
@@ -275,18 +288,26 @@ int32_t FormattedStringBuilder::prepareForInsertHelper(int32_t index, int32_t co
     int32_t oldZero = fZero;
     char16_t *oldChars = getCharPtr();
     Field *oldFields = getFieldPtr();
-    if (fLength + count > oldCapacity) {
-        if ((fLength + count) > INT32_MAX / 2) {
-            // If we continue, then newCapacity will overflow int32_t in the next line.
+    int32_t newLength;
+    if (uprv_add32_overflow(fLength, count, &newLength)) {
+        status = U_INPUT_TOO_LONG_ERROR;
+        return -1;
+    }
+    int32_t newZero;
+    if (newLength > oldCapacity) {
+        if (newLength > INT32_MAX / 2) {
+            // We do not support more than 1G char16_t in this code because
+            // dealing with >2G *bytes* can cause subtle bugs.
             status = U_INPUT_TOO_LONG_ERROR;
             return -1;
         }
-        int32_t newCapacity = (fLength + count) * 2;
-        int32_t newZero = newCapacity / 2 - (fLength + count) / 2;
+        // Keep newCapacity also to at most 1G char16_t.
+        int32_t newCapacity = newLength * 2;
+        newZero = (newCapacity - newLength) / 2;
 
         // C++ note: malloc appears in two places: here and in the assignment operator.
-        auto newChars = static_cast<char16_t *> (uprv_malloc(sizeof(char16_t) * newCapacity));
-        auto newFields = static_cast<Field *>(uprv_malloc(sizeof(Field) * newCapacity));
+        auto newChars = static_cast<char16_t *> (uprv_malloc(sizeof(char16_t) * static_cast<size_t>(newCapacity)));
+        auto newFields = static_cast<Field *>(uprv_malloc(sizeof(Field) * static_cast<size_t>(newCapacity)));
         if (newChars == nullptr || newFields == nullptr) {
             uprv_free(newChars);
             uprv_free(newFields);
@@ -315,10 +336,8 @@ int32_t FormattedStringBuilder::prepareForInsertHelper(int32_t index, int32_t co
         fChars.heap.capacity = newCapacity;
         fFields.heap.ptr = newFields;
         fFields.heap.capacity = newCapacity;
-        fZero = newZero;
-        fLength += count;
     } else {
-        int32_t newZero = oldCapacity / 2 - (fLength + count) / 2;
+        newZero = (oldCapacity - newLength) / 2;
 
         // C++ note: memmove is required because src and dest may overlap.
         // First copy the entire string to the location of the prefix, and then move the suffix
@@ -331,18 +350,20 @@ int32_t FormattedStringBuilder::prepareForInsertHelper(int32_t index, int32_t co
         uprv_memmove2(oldFields + newZero + index + count,
                 oldFields + newZero + index,
                 sizeof(Field) * (fLength - index));
-
-        fZero = newZero;
-        fLength += count;
     }
-    U_ASSERT((fZero + index) >= 0);
+    fZero = newZero;
+    fLength = newLength;
     return fZero + index;
 }
 
 int32_t FormattedStringBuilder::remove(int32_t index, int32_t count) {
-    // TODO: Reset the heap here?  (If the string after removal can fit on stack?)
+     U_ASSERT(0 <= index);
+     U_ASSERT(index <= fLength);
+     U_ASSERT(count <= (fLength - index));
+     U_ASSERT(index <= getCapacity() - fZero);
+
     int32_t position = index + fZero;
-    U_ASSERT(position >= 0);
+    // TODO: Reset the heap here?  (If the string after removal can fit on stack?)
     uprv_memmove2(getCharPtr() + position,
             getCharPtr() + position + count,
             sizeof(char16_t) * (fLength - index - count));
@@ -359,7 +380,7 @@ UnicodeString FormattedStringBuilder::toUnicodeString() const {
 
 const UnicodeString FormattedStringBuilder::toTempUnicodeString() const {
     // Readonly-alias constructor:
-    return UnicodeString(FALSE, getCharPtr() + fZero, fLength);
+    return UnicodeString(false, getCharPtr() + fZero, fLength);
 }
 
 UnicodeString FormattedStringBuilder::toDebugString() const {
diff --git a/deps/icu-small/source/i18n/formatted_string_builder.h b/deps/icu-small/source/i18n/formatted_string_builder.h
index 92bcf07d78..32e0900ae2 100644
--- a/deps/icu-small/source/i18n/formatted_string_builder.h
+++ b/deps/icu-small/source/i18n/formatted_string_builder.h
@@ -218,7 +218,9 @@ class U_I18N_API FormattedStringBuilder : public UMemory {
 };
 
 static_assert(
-    std::is_pod<FormattedStringBuilder::Field>::value,
+    // std::is_pod<> is deprecated.
+    std::is_standard_layout<FormattedStringBuilder::Field>::value &&
+        std::is_trivial<FormattedStringBuilder::Field>::value,
     "Field should be a POD type for efficient initialization");
 
 constexpr FormattedStringBuilder::Field::Field(uint8_t category, uint8_t field)
diff --git a/deps/icu-small/source/i18n/formattedval_iterimpl.cpp b/deps/icu-small/source/i18n/formattedval_iterimpl.cpp
index 75328fae88..ec770e2191 100644
--- a/deps/icu-small/source/i18n/formattedval_iterimpl.cpp
+++ b/deps/icu-small/source/i18n/formattedval_iterimpl.cpp
@@ -32,7 +32,7 @@ UnicodeString FormattedValueFieldPositionIteratorImpl::toTempString(
         UErrorCode&) const {
     // The alias must point to memory owned by this object;
     // fastCopyFrom doesn't do this when using a stack buffer.
-    return UnicodeString(TRUE, fString.getBuffer(), fString.length());
+    return UnicodeString(true, fString.getBuffer(), fString.length());
 }
 
 Appendable& FormattedValueFieldPositionIteratorImpl::appendTo(
diff --git a/deps/icu-small/source/i18n/formattedvalue.cpp b/deps/icu-small/source/i18n/formattedvalue.cpp
index 1030661f22..f103c015b8 100644
--- a/deps/icu-small/source/i18n/formattedvalue.cpp
+++ b/deps/icu-small/source/i18n/formattedvalue.cpp
@@ -43,7 +43,7 @@ void ConstrainedFieldPosition::setInt64IterationContext(int64_t context) {
 UBool ConstrainedFieldPosition::matchesField(int32_t category, int32_t field) const {
     switch (fConstraint) {
     case UCFPOS_CONSTRAINT_NONE:
-        return TRUE;
+        return true;
     case UCFPOS_CONSTRAINT_CATEGORY:
         return fCategory == category;
     case UCFPOS_CONSTRAINT_FIELD:
@@ -223,7 +223,7 @@ ufmtval_nextPosition(
     const auto* fmtval = UFormattedValueApiHelper::validate(ufmtval, *ec);
     auto* cfpos = UConstrainedFieldPositionImpl::validate(ucfpos, *ec);
     if (U_FAILURE(*ec)) {
-        return FALSE;
+        return false;
     }
     return fmtval->fFormattedValue->nextPosition(cfpos->fImpl, *ec);
 }
diff --git a/deps/icu-small/source/i18n/fphdlimp.cpp b/deps/icu-small/source/i18n/fphdlimp.cpp
index f51bf4bae7..4f6a98c212 100644
--- a/deps/icu-small/source/i18n/fphdlimp.cpp
+++ b/deps/icu-small/source/i18n/fphdlimp.cpp
@@ -39,7 +39,7 @@ FieldPositionOnlyHandler::~FieldPositionOnlyHandler() {
 void
 FieldPositionOnlyHandler::addAttribute(int32_t id, int32_t start, int32_t limit) {
   if (pos.getField() == id && (!acceptFirstOnly || !seenFirst)) {
-    seenFirst = TRUE;
+    seenFirst = true;
     pos.setBeginIndex(start + fShift);
     pos.setEndIndex(limit + fShift);
   }
diff --git a/deps/icu-small/source/i18n/fpositer.cpp b/deps/icu-small/source/i18n/fpositer.cpp
index 096896d7b3..64bec990e3 100644
--- a/deps/icu-small/source/i18n/fpositer.cpp
+++ b/deps/icu-small/source/i18n/fpositer.cpp
@@ -92,7 +92,7 @@ void FieldPositionIterator::setData(UVector32 *adopt, UErrorCode& status) {
 
 UBool FieldPositionIterator::next(FieldPosition& fp) {
   if (pos == -1) {
-    return FALSE;
+    return false;
   }
 
   // Ignore the first element of the tetrad: used for field category
@@ -105,7 +105,7 @@ UBool FieldPositionIterator::next(FieldPosition& fp) {
     pos = -1;
   }
 
-  return TRUE;
+  return true;
 }
 
 U_NAMESPACE_END
diff --git a/deps/icu-small/source/i18n/gender.cpp b/deps/icu-small/source/i18n/gender.cpp
index dc5def6ad3..ef64d17846 100644
--- a/deps/icu-small/source/i18n/gender.cpp
+++ b/deps/icu-small/source/i18n/gender.cpp
@@ -37,7 +37,7 @@ static const char* gNeutralStr = "neutral";
 static const char* gMailTaintsStr = "maleTaints";
 static const char* gMixedNeutralStr = "mixedNeutral";
 static icu::GenderInfo* gObjs = NULL;
-static icu::UInitOnce gGenderInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gGenderInitOnce {};
 
 enum GenderStyle {
   NEUTRAL,
@@ -55,7 +55,7 @@ static UBool U_CALLCONV gender_cleanup(void) {
     delete [] gObjs;
   }
   gGenderInitOnce.reset();
-  return TRUE;
+  return true;
 }
 
 U_CDECL_END
@@ -184,8 +184,8 @@ UGender GenderInfo::getListGender(const UGender* genders, int32_t length, UError
   if (length == 1) {
     return genders[0];
   }
-  UBool has_female = FALSE;
-  UBool has_male = FALSE;
+  UBool has_female = false;
+  UBool has_male = false;
   switch (_style) {
     case NEUTRAL:
       return UGENDER_OTHER;
@@ -199,13 +199,13 @@ UGender GenderInfo::getListGender(const UGender* genders, int32_t length, UError
             if (has_male) {
               return UGENDER_OTHER;
             }
-            has_female = TRUE;
+            has_female = true;
             break;
           case UGENDER_MALE:
             if (has_female) {
               return UGENDER_OTHER;
             }
-            has_male = TRUE;
+            has_male = true;
             break;
           default:
             break;
diff --git a/deps/icu-small/source/i18n/gregocal.cpp b/deps/icu-small/source/i18n/gregocal.cpp
index 31d36300ae..63a6c2d452 100644
--- a/deps/icu-small/source/i18n/gregocal.cpp
+++ b/deps/icu-small/source/i18n/gregocal.cpp
@@ -155,7 +155,7 @@ GregorianCalendar::GregorianCalendar(UErrorCode& status)
 :   Calendar(status),
 fGregorianCutover(kPapalCutover),
 fCutoverJulianDay(kCutoverJulianDay), fNormalizedGregorianCutover(fGregorianCutover), fGregorianCutoverYear(1582),
-fIsGregorian(TRUE), fInvertGregorian(FALSE)
+fIsGregorian(true), fInvertGregorian(false)
 {
     setTimeInMillis(getNow(), status);
 }
@@ -166,7 +166,7 @@ GregorianCalendar::GregorianCalendar(TimeZone* zone, UErrorCode& status)
 :   Calendar(zone, Locale::getDefault(), status),
 fGregorianCutover(kPapalCutover),
 fCutoverJulianDay(kCutoverJulianDay), fNormalizedGregorianCutover(fGregorianCutover), fGregorianCutoverYear(1582),
-fIsGregorian(TRUE), fInvertGregorian(FALSE)
+fIsGregorian(true), fInvertGregorian(false)
 {
     setTimeInMillis(getNow(), status);
 }
@@ -177,7 +177,7 @@ GregorianCalendar::GregorianCalendar(const TimeZone& zone, UErrorCode& status)
 :   Calendar(zone, Locale::getDefault(), status),
 fGregorianCutover(kPapalCutover),
 fCutoverJulianDay(kCutoverJulianDay), fNormalizedGregorianCutover(fGregorianCutover), fGregorianCutoverYear(1582),
-fIsGregorian(TRUE), fInvertGregorian(FALSE)
+fIsGregorian(true), fInvertGregorian(false)
 {
     setTimeInMillis(getNow(), status);
 }
@@ -188,7 +188,7 @@ GregorianCalendar::GregorianCalendar(const Locale& aLocale, UErrorCode& status)
 :   Calendar(TimeZone::forLocaleOrDefault(aLocale), aLocale, status),
 fGregorianCutover(kPapalCutover),
 fCutoverJulianDay(kCutoverJulianDay), fNormalizedGregorianCutover(fGregorianCutover), fGregorianCutoverYear(1582),
-fIsGregorian(TRUE), fInvertGregorian(FALSE)
+fIsGregorian(true), fInvertGregorian(false)
 {
     setTimeInMillis(getNow(), status);
 }
@@ -200,7 +200,7 @@ GregorianCalendar::GregorianCalendar(TimeZone* zone, const Locale& aLocale,
                                      :   Calendar(zone, aLocale, status),
                                      fGregorianCutover(kPapalCutover),
                                      fCutoverJulianDay(kCutoverJulianDay), fNormalizedGregorianCutover(fGregorianCutover), fGregorianCutoverYear(1582),
-                                     fIsGregorian(TRUE), fInvertGregorian(FALSE)
+                                     fIsGregorian(true), fInvertGregorian(false)
 {
     setTimeInMillis(getNow(), status);
 }
@@ -212,7 +212,7 @@ GregorianCalendar::GregorianCalendar(const TimeZone& zone, const Locale& aLocale
                                      :   Calendar(zone, aLocale, status),
                                      fGregorianCutover(kPapalCutover),
                                      fCutoverJulianDay(kCutoverJulianDay), fNormalizedGregorianCutover(fGregorianCutover), fGregorianCutoverYear(1582),
-                                     fIsGregorian(TRUE), fInvertGregorian(FALSE)
+                                     fIsGregorian(true), fInvertGregorian(false)
 {
     setTimeInMillis(getNow(), status);
 }
@@ -224,7 +224,7 @@ GregorianCalendar::GregorianCalendar(int32_t year, int32_t month, int32_t date,
                                      :   Calendar(TimeZone::createDefault(), Locale::getDefault(), status),
                                      fGregorianCutover(kPapalCutover),
                                      fCutoverJulianDay(kCutoverJulianDay), fNormalizedGregorianCutover(fGregorianCutover), fGregorianCutoverYear(1582),
-                                     fIsGregorian(TRUE), fInvertGregorian(FALSE)
+                                     fIsGregorian(true), fInvertGregorian(false)
 {
     set(UCAL_ERA, AD);
     set(UCAL_YEAR, year);
@@ -239,7 +239,7 @@ GregorianCalendar::GregorianCalendar(int32_t year, int32_t month, int32_t date,
                                      :   Calendar(TimeZone::createDefault(), Locale::getDefault(), status),
                                      fGregorianCutover(kPapalCutover),
                                      fCutoverJulianDay(kCutoverJulianDay), fNormalizedGregorianCutover(fGregorianCutover), fGregorianCutoverYear(1582),
-                                     fIsGregorian(TRUE), fInvertGregorian(FALSE)
+                                     fIsGregorian(true), fInvertGregorian(false)
 {
     set(UCAL_ERA, AD);
     set(UCAL_YEAR, year);
@@ -257,7 +257,7 @@ GregorianCalendar::GregorianCalendar(int32_t year, int32_t month, int32_t date,
                                      :   Calendar(TimeZone::createDefault(), Locale::getDefault(), status),
                                      fGregorianCutover(kPapalCutover),
                                      fCutoverJulianDay(kCutoverJulianDay), fNormalizedGregorianCutover(fGregorianCutover), fGregorianCutoverYear(1582),
-                                     fIsGregorian(TRUE), fInvertGregorian(FALSE)
+                                     fIsGregorian(true), fInvertGregorian(false)
 {
     set(UCAL_ERA, AD);
     set(UCAL_YEAR, year);
@@ -388,7 +388,7 @@ void GregorianCalendar::handleComputeFields(int32_t julianDay, UErrorCode& statu
         // The Julian epoch day (not the same as Julian Day)
         // is zero on Saturday December 30, 0 (Gregorian).
         int32_t julianEpochDay = julianDay - (kJan1_1JulianDay - 2);
-		eyear = (int32_t) ClockMath::floorDivide((4.0*julianEpochDay) + 1464.0, (int32_t) 1461, unusedRemainder);
+		eyear = (int32_t) ClockMath::floorDivide((4.0*julianEpochDay) + 1464.0, (int32_t) 1461, &unusedRemainder);
 
         // Compute the Julian calendar day number for January 1, eyear
         int32_t january1 = 365*(eyear-1) + ClockMath::floorDivide(eyear-1, (int32_t)4);
@@ -472,27 +472,27 @@ GregorianCalendar::isLeapYear(int32_t year) const
 
 int32_t GregorianCalendar::handleComputeJulianDay(UCalendarDateFields bestField) 
 {
-    fInvertGregorian = FALSE;
+    fInvertGregorian = false;
 
     int32_t jd = Calendar::handleComputeJulianDay(bestField);
 
     if((bestField == UCAL_WEEK_OF_YEAR) &&  // if we are doing WOY calculations, we are counting relative to Jan 1 *julian*
         (internalGet(UCAL_EXTENDED_YEAR)==fGregorianCutoverYear) && 
         jd >= fCutoverJulianDay) { 
-            fInvertGregorian = TRUE;  // So that the Julian Jan 1 will be used in handleComputeMonthStart
+            fInvertGregorian = true;  // So that the Julian Jan 1 will be used in handleComputeMonthStart
             return Calendar::handleComputeJulianDay(bestField);
         }
 
 
         // The following check handles portions of the cutover year BEFORE the
         // cutover itself happens.
-        //if ((fIsGregorian==TRUE) != (jd >= fCutoverJulianDay)) {  /*  cutoverJulianDay)) { */
-        if ((fIsGregorian==TRUE) != (jd >= fCutoverJulianDay)) {  /*  cutoverJulianDay)) { */
+        //if ((fIsGregorian==true) != (jd >= fCutoverJulianDay)) {  /*  cutoverJulianDay)) { */
+        if ((fIsGregorian==true) != (jd >= fCutoverJulianDay)) {  /*  cutoverJulianDay)) { */
 #if defined (U_DEBUG_CAL)
             fprintf(stderr, "%s:%d: jd [invert] %d\n", 
                 __FILE__, __LINE__, jd);
 #endif
-            fInvertGregorian = TRUE;
+            fInvertGregorian = true;
             jd = Calendar::handleComputeJulianDay(bestField);
 #if defined (U_DEBUG_CAL)
             fprintf(stderr, "%s:%d:  fIsGregorian %s, fInvertGregorian %s - ", 
@@ -537,7 +537,7 @@ int32_t GregorianCalendar::handleComputeMonthStart(int32_t eyear, int32_t month,
     // If the month is out of range, adjust it into range, and
     // modify the extended year value accordingly.
     if (month < 0 || month > 11) {
-        eyear += ClockMath::floorDivide(month, 12, month);
+        eyear += ClockMath::floorDivide(month, 12, &month);
     }
 
     UBool isLeap = eyear%4 == 0;
@@ -580,7 +580,7 @@ int32_t GregorianCalendar::handleGetMonthLength(int32_t extendedYear, int32_t mo
     // If the month is out of range, adjust it into range, and
     // modify the extended year value accordingly.
     if (month < 0 || month > 11) {
-        extendedYear += ClockMath::floorDivide(month, 12, month);
+        extendedYear += ClockMath::floorDivide(month, 12, &month);
     }
 
     return isLeapYear(extendedYear) ? kLeapMonthLength[month] : kMonthLength[month];
@@ -651,7 +651,7 @@ GregorianCalendar::validateFields() const
             field != UCAL_DAY_OF_YEAR &&
             isSet((UCalendarDateFields)field) &&
             ! boundsCheck(internalGet((UCalendarDateFields)field), (UCalendarDateFields)field))
-            return FALSE;
+            return false;
     }
 
     // Values differ in Least-Maximum and Maximum should be handled
@@ -660,14 +660,14 @@ GregorianCalendar::validateFields() const
         int32_t date = internalGet(UCAL_DATE);
         if (date < getMinimum(UCAL_DATE) ||
             date > monthLength(internalGet(UCAL_MONTH))) {
-                return FALSE;
+                return false;
             }
     }
 
     if (isSet(UCAL_DAY_OF_YEAR)) {
         int32_t days = internalGet(UCAL_DAY_OF_YEAR);
         if (days < 1 || days > yearLength()) {
-            return FALSE;
+            return false;
         }
     }
 
@@ -675,10 +675,10 @@ GregorianCalendar::validateFields() const
     // We've checked against minimum and maximum above already.
     if (isSet(UCAL_DAY_OF_WEEK_IN_MONTH) &&
         0 == internalGet(UCAL_DAY_OF_WEEK_IN_MONTH)) {
-            return FALSE;
+            return false;
         }
 
-        return TRUE;
+        return true;
 }
 
 // -------------------------------------
@@ -828,7 +828,7 @@ GregorianCalendar::roll(UCalendarDateFields field, int32_t amount, UErrorCode& s
     }
 
     // J81 processing. (gregorian cutover)
-    UBool inCutoverMonth = FALSE;
+    UBool inCutoverMonth = false;
     int32_t cMonthLen=0; // 'c' for cutover; in days
     int32_t cDayOfMonth=0; // no discontinuity: [0, cMonthLen)
     double cMonthStart=0.0; // in ms
@@ -849,7 +849,7 @@ GregorianCalendar::roll(UCalendarDateFields field, int32_t amount, UErrorCode& s
                 // A month containing the cutover is 10 days shorter.
                 if ((cMonthStart < fGregorianCutover) &&
                     (cMonthStart + (cMonthLen=(max-10))*kOneDay >= fGregorianCutover)) {
-                        inCutoverMonth = TRUE;
+                        inCutoverMonth = true;
                     }
             }
             break;
@@ -1145,7 +1145,7 @@ int32_t GregorianCalendar::getActualMaximum(UCalendarDateFields field, UErrorCod
                 return 0;
             }
 
-            cal->setLenient(TRUE);
+            cal->setLenient(true);
 
             int32_t era = cal->get(UCAL_ERA, status);
             UDate d = cal->getTime(status);
@@ -1241,12 +1241,12 @@ UBool
 GregorianCalendar::inDaylightTime(UErrorCode& status) const
 {
     if (U_FAILURE(status) || !getTimeZone().useDaylightTime()) 
-        return FALSE;
+        return false;
 
     // Force an update of the state of the Calendar.
     ((GregorianCalendar*)this)->complete(status); // cast away const
 
-    return (UBool)(U_SUCCESS(status) ? (internalGet(UCAL_DST_OFFSET) != 0) : FALSE);
+    return (UBool)(U_SUCCESS(status) ? (internalGet(UCAL_DST_OFFSET) != 0) : false);
 }
 
 // -------------------------------------
@@ -1274,12 +1274,12 @@ GregorianCalendar::getType() const {
  */
 static UDate           gSystemDefaultCenturyStart       = DBL_MIN;
 static int32_t         gSystemDefaultCenturyStartYear   = -1;
-static icu::UInitOnce  gSystemDefaultCenturyInit        = U_INITONCE_INITIALIZER;
+static icu::UInitOnce  gSystemDefaultCenturyInit        {};
 
 
 UBool GregorianCalendar::haveDefaultCentury() const
 {
-    return TRUE;
+    return true;
 }
 
 static void U_CALLCONV
diff --git a/deps/icu-small/source/i18n/gregoimp.cpp b/deps/icu-small/source/i18n/gregoimp.cpp
index 537aa19d8a..f862cd1d83 100644
--- a/deps/icu-small/source/i18n/gregoimp.cpp
+++ b/deps/icu-small/source/i18n/gregoimp.cpp
@@ -33,28 +33,33 @@ int64_t ClockMath::floorDivide(int64_t numerator, int64_t denominator) {
 }
 
 int32_t ClockMath::floorDivide(double numerator, int32_t denominator,
-                          int32_t& remainder) {
-    double quotient;
-    quotient = uprv_floor(numerator / denominator);
-    remainder = (int32_t) (numerator - (quotient * denominator));
+                          int32_t* remainder) {
+    // For an integer n and representable ⌊x/n⌋, ⌊RN(x/n)⌋=⌊x/n⌋, where RN is
+    // rounding to nearest.
+    double quotient = uprv_floor(numerator / denominator);
+    // For doubles x and n, where n is an integer and ⌊x+n⌋ < 2³¹, the
+    // expression `(int32_t) (x + n)` evaluated with rounding to nearest
+    // differs from ⌊x+n⌋ if 0 < ⌈x⌉−x ≪ x+n, as `x + n` is rounded up to
+    // n+⌈x⌉ = ⌊x+n⌋ + 1.  Rewriting it as ⌊x⌋+n makes the addition exact.
+    *remainder = (int32_t) (uprv_floor(numerator) - (quotient * denominator));
     return (int32_t) quotient;
 }
 
 double ClockMath::floorDivide(double dividend, double divisor,
-                         double& remainder) {
+                         double* remainder) {
     // Only designed to work for positive divisors
     U_ASSERT(divisor > 0);
     double quotient = floorDivide(dividend, divisor);
-    remainder = dividend - (quotient * divisor);
+    *remainder = dividend - (quotient * divisor);
     // N.B. For certain large dividends, on certain platforms, there
     // is a bug such that the quotient is off by one.  If you doubt
     // this to be true, set a breakpoint below and run cintltst.
-    if (remainder < 0 || remainder >= divisor) {
+    if (*remainder < 0 || *remainder >= divisor) {
         // E.g. 6.7317038241449352e+022 / 86400000.0 is wrong on my
         // machine (too high by one).  4.1792057231752762e+024 /
         // 86400000.0 is wrong the other way (too low).
         double q = quotient;
-        quotient += (remainder < 0) ? -1 : +1;
+        quotient += (*remainder < 0) ? -1 : +1;
         if (q == quotient) {
             // For quotients > ~2^53, we won't be able to add or
             // subtract one, since the LSB of the mantissa will be >
@@ -65,12 +70,12 @@ double ClockMath::floorDivide(double dividend, double divisor,
             // values give back an approximate answer rather than
             // crashing.  For example, UDate values above a ~10^25
             // might all have a time of midnight.
-            remainder = 0;
+            *remainder = 0;
         } else {
-            remainder = dividend - (quotient * divisor);
+            *remainder = dividend - (quotient * divisor);
         }
     }
-    U_ASSERT(0 <= remainder && remainder < divisor);
+    U_ASSERT(0 <= *remainder && *remainder < divisor);
     return quotient;
 }
 
@@ -106,10 +111,10 @@ void Grego::dayToFields(double day, int32_t& year, int32_t& month,
     // representation.  We use 400-year, 100-year, and 4-year cycles.
     // For example, the 4-year cycle has 4 years + 1 leap day; giving
     // 1461 == 365*4 + 1 days.
-    int32_t n400 = ClockMath::floorDivide(day, 146097, doy); // 400-year cycle length
-    int32_t n100 = ClockMath::floorDivide(doy, 36524, doy); // 100-year cycle length
-    int32_t n4   = ClockMath::floorDivide(doy, 1461, doy); // 4-year cycle length
-    int32_t n1   = ClockMath::floorDivide(doy, 365, doy);
+    int32_t n400 = ClockMath::floorDivide(day, 146097, &doy); // 400-year cycle length
+    int32_t n100 = ClockMath::floorDivide(doy, 36524, &doy); // 100-year cycle length
+    int32_t n4   = ClockMath::floorDivide(doy, 1461, &doy); // 4-year cycle length
+    int32_t n1   = ClockMath::floorDivide(doy, 365, &doy);
     year = 400*n400 + 100*n100 + 4*n4 + n1;
     if (n100 == 4 || n1 == 4) {
         doy = 365; // Dec 31 at end of 4- or 400-year cycle
@@ -137,14 +142,14 @@ void Grego::dayToFields(double day, int32_t& year, int32_t& month,
 void Grego::timeToFields(UDate time, int32_t& year, int32_t& month,
                         int32_t& dom, int32_t& dow, int32_t& doy, int32_t& mid) {
     double millisInDay;
-    double day = ClockMath::floorDivide((double)time, (double)U_MILLIS_PER_DAY, millisInDay);
+    double day = ClockMath::floorDivide((double)time, (double)U_MILLIS_PER_DAY, &millisInDay);
     mid = (int32_t)millisInDay;
     dayToFields(day, year, month, dom, dow, doy);
 }
 
 int32_t Grego::dayOfWeek(double day) {
     int32_t dow;
-    ClockMath::floorDivide(day + UCAL_THURSDAY, 7, dow);
+    ClockMath::floorDivide(day + int{UCAL_THURSDAY}, 7, &dow);
     return (dow == 0) ? UCAL_SATURDAY : dow;
 }
 
diff --git a/deps/icu-small/source/i18n/gregoimp.h b/deps/icu-small/source/i18n/gregoimp.h
index b1a5bc22c2..d65d6a4f88 100644
--- a/deps/icu-small/source/i18n/gregoimp.h
+++ b/deps/icu-small/source/i18n/gregoimp.h
@@ -78,7 +78,7 @@ class ClockMath {
      * @return the floor of the quotient
      */
     static int32_t floorDivide(double numerator, int32_t denominator,
-                               int32_t& remainder);
+                               int32_t* remainder);
 
     /**
      * For a positive divisor, return the quotient and remainder
@@ -91,7 +91,7 @@ class ClockMath {
      * Calling with a divisor <= 0 is disallowed.
      */
     static double floorDivide(double dividend, double divisor,
-                              double& remainder);
+                              double* remainder);
 };
 
 // Useful millisecond constants
diff --git a/deps/icu-small/source/i18n/hebrwcal.cpp b/deps/icu-small/source/i18n/hebrwcal.cpp
index 4d8e59cef9..b3e6bcb65c 100644
--- a/deps/icu-small/source/i18n/hebrwcal.cpp
+++ b/deps/icu-small/source/i18n/hebrwcal.cpp
@@ -140,7 +140,7 @@ U_CDECL_BEGIN
 static UBool calendar_hebrew_cleanup(void) {
     delete gCache;
     gCache = NULL;
-    return TRUE;
+    return true;
 }
 U_CDECL_END
 
@@ -239,7 +239,7 @@ void HebrewCalendar::add(UCalendarDateFields field, int32_t amount, UErrorCode&
                   }
                   month -= ELUL+1;
                   ++year;
-                  acrossAdar1 = TRUE;
+                  acrossAdar1 = true;
               }
           } else {
               acrossAdar1 = (month > ADAR_1); // started after ADAR_1?
@@ -253,7 +253,7 @@ void HebrewCalendar::add(UCalendarDateFields field, int32_t amount, UErrorCode&
                   }
                   month += ELUL+1;
                   --year;
-                  acrossAdar1 = TRUE;
+                  acrossAdar1 = true;
               }
           }
           set(UCAL_MONTH, month);
@@ -671,12 +671,12 @@ HebrewCalendar::inDaylightTime(UErrorCode& status) const
 {
     // copied from GregorianCalendar
     if (U_FAILURE(status) || !getTimeZone().useDaylightTime()) 
-        return FALSE;
+        return false;
 
     // Force an update of the state of the Calendar.
     ((HebrewCalendar*)this)->complete(status); // cast away const
 
-    return (UBool)(U_SUCCESS(status) ? (internalGet(UCAL_DST_OFFSET) != 0) : FALSE);
+    return (UBool)(U_SUCCESS(status) ? (internalGet(UCAL_DST_OFFSET) != 0) : false);
 }
 
 /**
@@ -686,11 +686,11 @@ HebrewCalendar::inDaylightTime(UErrorCode& status) const
  */
 static UDate           gSystemDefaultCenturyStart       = DBL_MIN;
 static int32_t         gSystemDefaultCenturyStartYear   = -1;
-static icu::UInitOnce  gSystemDefaultCenturyInit        = U_INITONCE_INITIALIZER;
+static icu::UInitOnce  gSystemDefaultCenturyInit        {};
 
 UBool HebrewCalendar::haveDefaultCentury() const
 {
-    return TRUE;
+    return true;
 }
 
 static void U_CALLCONV initializeSystemDefaultCentury()
diff --git a/deps/icu-small/source/i18n/hebrwcal.h b/deps/icu-small/source/i18n/hebrwcal.h
index ae4401832d..d75651d47a 100644
--- a/deps/icu-small/source/i18n/hebrwcal.h
+++ b/deps/icu-small/source/i18n/hebrwcal.h
@@ -88,7 +88,7 @@ public:
    * Useful constants for HebrewCalendar.
    * @internal
    */
-  enum EEras {
+  enum Month {
     /** 
      * Constant for Tishri, the 1st month of the Hebrew year. 
      */
@@ -180,13 +180,6 @@ public:
      */
     HebrewCalendar(const HebrewCalendar& source);
 
-    /**
-     * Default assignment operator
-     * @param right    the object to be copied.
-     * @internal
-     */
-    HebrewCalendar& operator=(const HebrewCalendar& right);
-
     /**
      * Create and return a polymorphic copy of this calendar.
      * @return    return a polymorphic copy of this calendar.
diff --git a/deps/icu-small/source/i18n/indiancal.cpp b/deps/icu-small/source/i18n/indiancal.cpp
index 7bba7f5092..935290a575 100644
--- a/deps/icu-small/source/i18n/indiancal.cpp
+++ b/deps/icu-small/source/i18n/indiancal.cpp
@@ -110,7 +110,7 @@ static UBool isGregorianLeap(int32_t year)
  */
 int32_t IndianCalendar::handleGetMonthLength(int32_t eyear, int32_t month) const {
    if (month < 0 || month > 11) {
-      eyear += ClockMath::floorDivide(month, 12, month);
+      eyear += ClockMath::floorDivide(month, 12, &month);
    }
 
    if (isGregorianLeap(eyear + INDIAN_ERA_START) && month == 0) {
@@ -210,7 +210,7 @@ int32_t IndianCalendar::handleComputeMonthStart(int32_t eyear, int32_t month, UB
 
     // If the month is out of range, adjust it into range, and adjust the extended year accordingly
    if (month < 0 || month > 11) {
-      eyear += (int32_t)ClockMath::floorDivide(month, 12, month);
+      eyear += (int32_t)ClockMath::floorDivide(month, 12, &month);
    }
 
    if(month == 12){
@@ -303,13 +303,13 @@ IndianCalendar::inDaylightTime(UErrorCode& status) const
 {
     // copied from GregorianCalendar
     if (U_FAILURE(status) || !getTimeZone().useDaylightTime()) {
-        return FALSE;
+        return false;
     }
 
     // Force an update of the state of the Calendar.
     ((IndianCalendar*)this)->complete(status); // cast away const
 
-    return (UBool)(U_SUCCESS(status) ? (internalGet(UCAL_DST_OFFSET) != 0) : FALSE);
+    return (UBool)(U_SUCCESS(status) ? (internalGet(UCAL_DST_OFFSET) != 0) : false);
 }
 
 
@@ -320,12 +320,12 @@ IndianCalendar::inDaylightTime(UErrorCode& status) const
  */
 static UDate           gSystemDefaultCenturyStart       = DBL_MIN;
 static int32_t         gSystemDefaultCenturyStartYear   = -1;
-static icu::UInitOnce  gSystemDefaultCenturyInit        = U_INITONCE_INITIALIZER;
+static icu::UInitOnce  gSystemDefaultCenturyInit        {};
 
 
 UBool IndianCalendar::haveDefaultCentury() const
 {
-    return TRUE;
+    return true;
 }
 
 static void U_CALLCONV
diff --git a/deps/icu-small/source/i18n/indiancal.h b/deps/icu-small/source/i18n/indiancal.h
index 029515cf54..bfbea00329 100644
--- a/deps/icu-small/source/i18n/indiancal.h
+++ b/deps/icu-small/source/i18n/indiancal.h
@@ -285,7 +285,7 @@ public:
   virtual const char * getType() const override;
 
 private:
-  IndianCalendar(); // default constructor not implemented
+  IndianCalendar() = delete; // default constructor not implemented
 
   // Default century.
 protected:
diff --git a/deps/icu-small/source/i18n/inputext.cpp b/deps/icu-small/source/i18n/inputext.cpp
index fa4939e8f4..7c78ad249a 100644
--- a/deps/icu-small/source/i18n/inputext.cpp
+++ b/deps/icu-small/source/i18n/inputext.cpp
@@ -49,7 +49,7 @@ InputText::~InputText()
 void InputText::setText(const char *in, int32_t len)
 {
     fInputLen  = 0;
-    fC1Bytes   = FALSE;
+    fC1Bytes   = false;
     fRawInput  = (const uint8_t *) in;
     fRawLength = len == -1? (int32_t)uprv_strlen(in) : len;
 }
@@ -83,7 +83,7 @@ void InputText::MungeInput(UBool fStripTags) {
     int     srci = 0;
     int     dsti = 0;
     uint8_t b;
-    bool    inMarkup = FALSE;
+    bool    inMarkup = false;
     int32_t openTags = 0;
     int32_t badTags  = 0;
 
@@ -103,7 +103,7 @@ void InputText::MungeInput(UBool fStripTags) {
                     badTags += 1;
                 }
 
-                inMarkup = TRUE;
+                inMarkup = true;
                 openTags += 1;
             }
 
@@ -112,7 +112,7 @@ void InputText::MungeInput(UBool fStripTags) {
             }
 
             if (b == (uint8_t)0x3E) { /* Check for the ASCII '>' */
-                inMarkup = FALSE;
+                inMarkup = false;
             }
         }
 
@@ -153,7 +153,7 @@ void InputText::MungeInput(UBool fStripTags) {
 
     for (int32_t i = 0x80; i <= 0x9F; i += 1) {
         if (fByteStats[i] != 0) {
-            fC1Bytes = TRUE;
+            fC1Bytes = true;
             break;
         }
     }
diff --git a/deps/icu-small/source/i18n/islamcal.cpp b/deps/icu-small/source/i18n/islamcal.cpp
index de37e6b939..916b4da2b6 100644
--- a/deps/icu-small/source/i18n/islamcal.cpp
+++ b/deps/icu-small/source/i18n/islamcal.cpp
@@ -67,7 +67,7 @@ static UBool calendar_islamic_cleanup(void) {
         delete gIslamicCalendarAstro;
         gIslamicCalendarAstro = NULL;
     }
-    return TRUE;
+    return true;
 }
 U_CDECL_END
 
@@ -697,12 +697,12 @@ IslamicCalendar::inDaylightTime(UErrorCode& status) const
 {
     // copied from GregorianCalendar
     if (U_FAILURE(status) || !getTimeZone().useDaylightTime()) 
-        return FALSE;
+        return false;
 
     // Force an update of the state of the Calendar.
     ((IslamicCalendar*)this)->complete(status); // cast away const
 
-    return (UBool)(U_SUCCESS(status) ? (internalGet(UCAL_DST_OFFSET) != 0) : FALSE);
+    return (UBool)(U_SUCCESS(status) ? (internalGet(UCAL_DST_OFFSET) != 0) : false);
 }
 
 /**
@@ -712,12 +712,12 @@ IslamicCalendar::inDaylightTime(UErrorCode& status) const
  */
 static UDate           gSystemDefaultCenturyStart       = DBL_MIN;
 static int32_t         gSystemDefaultCenturyStartYear   = -1;
-static icu::UInitOnce  gSystemDefaultCenturyInit        = U_INITONCE_INITIALIZER;
+static icu::UInitOnce  gSystemDefaultCenturyInit        {};
 
 
 UBool IslamicCalendar::haveDefaultCentury() const
 {
-    return TRUE;
+    return true;
 }
 
 UDate IslamicCalendar::defaultCenturyStart() const
diff --git a/deps/icu-small/source/i18n/islamcal.h b/deps/icu-small/source/i18n/islamcal.h
index a29b7daa08..7d9941d470 100644
--- a/deps/icu-small/source/i18n/islamcal.h
+++ b/deps/icu-small/source/i18n/islamcal.h
@@ -377,7 +377,7 @@ class U_I18N_API IslamicCalendar : public Calendar {
   virtual const char * getType() const override;
 
  private:
-  IslamicCalendar(); // default constructor not implemented
+  IslamicCalendar() = delete; // default constructor not implemented
 
   // Default century.
  protected:
diff --git a/deps/icu-small/source/i18n/japancal.cpp b/deps/icu-small/source/i18n/japancal.cpp
index 75a248f406..ca9b0704a0 100644
--- a/deps/icu-small/source/i18n/japancal.cpp
+++ b/deps/icu-small/source/i18n/japancal.cpp
@@ -39,7 +39,7 @@
 #include "cstring.h"
 
 static icu::EraRules * gJapaneseEraRules = nullptr;
-static icu::UInitOnce gJapaneseEraRulesInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gJapaneseEraRulesInitOnce {};
 static int32_t gCurrentEra = 0;
 
 U_CDECL_BEGIN
@@ -50,7 +50,7 @@ static UBool japanese_calendar_cleanup(void) {
     }
     gCurrentEra = 0;
     gJapaneseEraRulesInitOnce.reset();
-    return TRUE;
+    return true;
 }
 U_CDECL_END
 
@@ -71,7 +71,7 @@ UBool JapaneseCalendar::enableTentativeEra() {
 
     // 1. Environment variable ICU_ENABLE_TENTATIVE_ERA=true or false
 
-    UBool includeTentativeEra = FALSE;
+    UBool includeTentativeEra = false;
 
 #if U_PLATFORM_HAS_WINUWP_API == 1
     // UWP doesn't allow access to getenv(), but we can call GetEnvironmentVariableW to do the same thing.
@@ -80,12 +80,12 @@ UBool JapaneseCalendar::enableTentativeEra() {
     WCHAR varValue[5] = {};
     DWORD ret = GetEnvironmentVariableW(reinterpret_cast<WCHAR*>(varName), varValue, UPRV_LENGTHOF(varValue));
     if ((ret == 4) && (_wcsicmp(varValue, L"true") == 0)) {
-        includeTentativeEra = TRUE;
+        includeTentativeEra = true;
     }
 #else
     char *envVarVal = getenv(TENTATIVE_ERA_VAR_NAME);
     if (envVarVal != NULL && uprv_stricmp(envVarVal, "true") == 0) {
-        includeTentativeEra = TRUE;
+        includeTentativeEra = true;
     }
 #endif
     return includeTentativeEra;
@@ -230,7 +230,7 @@ Disable pivoting
 */
 UBool JapaneseCalendar::haveDefaultCentury() const
 {
-    return FALSE;
+    return false;
 }
 
 UDate JapaneseCalendar::defaultCenturyStart() const
diff --git a/deps/icu-small/source/i18n/measfmt.cpp b/deps/icu-small/source/i18n/measfmt.cpp
index a9a56a3b58..d2b4e7018d 100644
--- a/deps/icu-small/source/i18n/measfmt.cpp
+++ b/deps/icu-small/source/i18n/measfmt.cpp
@@ -183,10 +183,10 @@ static UBool getString(
     int32_t len = 0;
     const UChar *resStr = ures_getString(resource, &len, &status);
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
-    result.setTo(TRUE, resStr, len);
-    return TRUE;
+    result.setTo(true, resStr, len);
+    return true;
 }
 
 static UnicodeString loadNumericDateFormatterPattern(
@@ -239,7 +239,7 @@ static NumericDateFormatters *loadNumericDateFormatters(
     return result;
 }
 
-template<> U_I18N_API
+template<> 
 const MeasureFormatCacheData *LocaleCacheKey<MeasureFormatCacheData>::createObject(
         const void * /*unused*/, UErrorCode &status) const {
     const char *localeId = fLoc.getName();
@@ -645,7 +645,7 @@ void MeasureFormat::adoptNumberFormat(
 
 UBool MeasureFormat::setMeasureFormatLocale(const Locale &locale, UErrorCode &status) {
     if (U_FAILURE(status) || locale == getLocale(status)) {
-        return FALSE;
+        return false;
     }
     initMeasureFormat(locale, fWidth, NULL, status);
     return U_SUCCESS(status);
@@ -769,7 +769,7 @@ UnicodeString &MeasureFormat::formatNumeric(
 
     FormattedStringBuilder fsb;
 
-    UBool protect = FALSE;
+    UBool protect = false;
     const int32_t patternLength = pattern.length();
     for (int32_t i = 0; i < patternLength; i++) {
         char16_t c = pattern[i];
diff --git a/deps/icu-small/source/i18n/measunit.cpp b/deps/icu-small/source/i18n/measunit.cpp
index 5ad3991974..f53137c48c 100644
--- a/deps/icu-small/source/i18n/measunit.cpp
+++ b/deps/icu-small/source/i18n/measunit.cpp
@@ -43,24 +43,24 @@ static const int32_t gOffsets[] = {
     17,
     27,
     31,
-    330,
-    341,
-    357,
-    361,
-    370,
+    332,
+    343,
+    360,
+    364,
     373,
-    377,
-    385,
-    407,
-    411,
-    426,
-    427,
-    433,
-    443,
-    447,
-    451,
-    453,
-    487
+    376,
+    380,
+    388,
+    410,
+    414,
+    429,
+    430,
+    436,
+    446,
+    450,
+    454,
+    456,
+    490
 };
 
 static const int32_t kCurrencyOffset = 5;
@@ -345,6 +345,7 @@ static const char * const gSubTypes[] = {
     "SHP",
     "SIT",
     "SKK",
+    "SLE",
     "SLL",
     "SOS",
     "SRD",
@@ -384,6 +385,7 @@ static const char * const gSubTypes[] = {
     "UYW",
     "UZS",
     "VEB",
+    "VED",
     "VEF",
     "VES",
     "VNC",
@@ -446,6 +448,7 @@ static const char * const gSubTypes[] = {
     "month",
     "month-person",
     "nanosecond",
+    "quarter",
     "second",
     "week",
     "week-person",
@@ -511,7 +514,6 @@ static const char * const gSubTypes[] = {
     "grain",
     "gram",
     "kilogram",
-    "metric-ton",
     "microgram",
     "milligram",
     "ounce",
@@ -520,6 +522,7 @@ static const char * const gSubTypes[] = {
     "solar-mass",
     "stone",
     "ton",
+    "tonne",
     "",
     "gigawatt",
     "horsepower",
@@ -1011,46 +1014,54 @@ MeasureUnit MeasureUnit::getNanosecond() {
     return MeasureUnit(7, 10);
 }
 
-MeasureUnit *MeasureUnit::createSecond(UErrorCode &status) {
+MeasureUnit *MeasureUnit::createQuarter(UErrorCode &status) {
     return MeasureUnit::create(7, 11, status);
 }
 
-MeasureUnit MeasureUnit::getSecond() {
+MeasureUnit MeasureUnit::getQuarter() {
     return MeasureUnit(7, 11);
 }
 
-MeasureUnit *MeasureUnit::createWeek(UErrorCode &status) {
+MeasureUnit *MeasureUnit::createSecond(UErrorCode &status) {
     return MeasureUnit::create(7, 12, status);
 }
 
-MeasureUnit MeasureUnit::getWeek() {
+MeasureUnit MeasureUnit::getSecond() {
     return MeasureUnit(7, 12);
 }
 
-MeasureUnit *MeasureUnit::createWeekPerson(UErrorCode &status) {
+MeasureUnit *MeasureUnit::createWeek(UErrorCode &status) {
     return MeasureUnit::create(7, 13, status);
 }
 
-MeasureUnit MeasureUnit::getWeekPerson() {
+MeasureUnit MeasureUnit::getWeek() {
     return MeasureUnit(7, 13);
 }
 
-MeasureUnit *MeasureUnit::createYear(UErrorCode &status) {
+MeasureUnit *MeasureUnit::createWeekPerson(UErrorCode &status) {
     return MeasureUnit::create(7, 14, status);
 }
 
-MeasureUnit MeasureUnit::getYear() {
+MeasureUnit MeasureUnit::getWeekPerson() {
     return MeasureUnit(7, 14);
 }
 
-MeasureUnit *MeasureUnit::createYearPerson(UErrorCode &status) {
+MeasureUnit *MeasureUnit::createYear(UErrorCode &status) {
     return MeasureUnit::create(7, 15, status);
 }
 
-MeasureUnit MeasureUnit::getYearPerson() {
+MeasureUnit MeasureUnit::getYear() {
     return MeasureUnit(7, 15);
 }
 
+MeasureUnit *MeasureUnit::createYearPerson(UErrorCode &status) {
+    return MeasureUnit::create(7, 16, status);
+}
+
+MeasureUnit MeasureUnit::getYearPerson() {
+    return MeasureUnit(7, 16);
+}
+
 MeasureUnit *MeasureUnit::createAmpere(UErrorCode &status) {
     return MeasureUnit::create(8, 0, status);
 }
@@ -1532,74 +1543,82 @@ MeasureUnit MeasureUnit::getKilogram() {
 }
 
 MeasureUnit *MeasureUnit::createMetricTon(UErrorCode &status) {
-    return MeasureUnit::create(15, 6, status);
+    return MeasureUnit::create(15, 14, status);
 }
 
 MeasureUnit MeasureUnit::getMetricTon() {
-    return MeasureUnit(15, 6);
+    return MeasureUnit(15, 14);
 }
 
 MeasureUnit *MeasureUnit::createMicrogram(UErrorCode &status) {
-    return MeasureUnit::create(15, 7, status);
+    return MeasureUnit::create(15, 6, status);
 }
 
 MeasureUnit MeasureUnit::getMicrogram() {
-    return MeasureUnit(15, 7);
+    return MeasureUnit(15, 6);
 }
 
 MeasureUnit *MeasureUnit::createMilligram(UErrorCode &status) {
-    return MeasureUnit::create(15, 8, status);
+    return MeasureUnit::create(15, 7, status);
 }
 
 MeasureUnit MeasureUnit::getMilligram() {
-    return MeasureUnit(15, 8);
+    return MeasureUnit(15, 7);
 }
 
 MeasureUnit *MeasureUnit::createOunce(UErrorCode &status) {
-    return MeasureUnit::create(15, 9, status);
+    return MeasureUnit::create(15, 8, status);
 }
 
 MeasureUnit MeasureUnit::getOunce() {
-    return MeasureUnit(15, 9);
+    return MeasureUnit(15, 8);
 }
 
 MeasureUnit *MeasureUnit::createOunceTroy(UErrorCode &status) {
-    return MeasureUnit::create(15, 10, status);
+    return MeasureUnit::create(15, 9, status);
 }
 
 MeasureUnit MeasureUnit::getOunceTroy() {
-    return MeasureUnit(15, 10);
+    return MeasureUnit(15, 9);
 }
 
 MeasureUnit *MeasureUnit::createPound(UErrorCode &status) {
-    return MeasureUnit::create(15, 11, status);
+    return MeasureUnit::create(15, 10, status);
 }
 
 MeasureUnit MeasureUnit::getPound() {
-    return MeasureUnit(15, 11);
+    return MeasureUnit(15, 10);
 }
 
 MeasureUnit *MeasureUnit::createSolarMass(UErrorCode &status) {
-    return MeasureUnit::create(15, 12, status);
+    return MeasureUnit::create(15, 11, status);
 }
 
 MeasureUnit MeasureUnit::getSolarMass() {
-    return MeasureUnit(15, 12);
+    return MeasureUnit(15, 11);
 }
 
 MeasureUnit *MeasureUnit::createStone(UErrorCode &status) {
-    return MeasureUnit::create(15, 13, status);
+    return MeasureUnit::create(15, 12, status);
 }
 
 MeasureUnit MeasureUnit::getStone() {
-    return MeasureUnit(15, 13);
+    return MeasureUnit(15, 12);
 }
 
 MeasureUnit *MeasureUnit::createTon(UErrorCode &status) {
-    return MeasureUnit::create(15, 14, status);
+    return MeasureUnit::create(15, 13, status);
 }
 
 MeasureUnit MeasureUnit::getTon() {
+    return MeasureUnit(15, 13);
+}
+
+MeasureUnit *MeasureUnit::createTonne(UErrorCode &status) {
+    return MeasureUnit::create(15, 14, status);
+}
+
+MeasureUnit MeasureUnit::getTonne() {
     return MeasureUnit(15, 14);
 }
 
diff --git a/deps/icu-small/source/i18n/measunit_extra.cpp b/deps/icu-small/source/i18n/measunit_extra.cpp
index 2df9edee96..3d49d1d610 100644
--- a/deps/icu-small/source/i18n/measunit_extra.cpp
+++ b/deps/icu-small/source/i18n/measunit_extra.cpp
@@ -312,7 +312,7 @@ class CategoriesSink : public icu::ResourceSink {
     int32_t outIndex;
 };
 
-icu::UInitOnce gUnitExtrasInitOnce = U_INITONCE_INITIALIZER;
+icu::UInitOnce gUnitExtrasInitOnce {};
 
 // Array of simple unit IDs.
 //
@@ -349,7 +349,7 @@ UBool U_CALLCONV cleanupUnitExtras() {
     uprv_free(gSimpleUnits);
     gSimpleUnits = nullptr;
     gUnitExtrasInitOnce.reset();
-    return TRUE;
+    return true;
 }
 
 void U_CALLCONV initUnitExtras(UErrorCode& status) {
@@ -718,7 +718,7 @@ private:
             case COMPOUND_PART_PER:
                 if (sawAnd) {
                     // Mixed compound units not yet supported,
-                    // TODO(CLDR-13700).
+                    // TODO(CLDR-13701).
                     status = kUnitIdentifierSyntaxError;
                     return result;
                 }
@@ -735,7 +735,7 @@ private:
             case COMPOUND_PART_AND:
                 if (fAfterPer) {
                     // Can't start with "-and-", and mixed compound units
-                    // not yet supported, TODO(CLDR-13700).
+                    // not yet supported, TODO(CLDR-13701).
                     status = kUnitIdentifierSyntaxError;
                     return result;
                 }
diff --git a/deps/icu-small/source/i18n/msgfmt.cpp b/deps/icu-small/source/i18n/msgfmt.cpp
index 13a5a08951..29476f328f 100644
--- a/deps/icu-small/source/i18n/msgfmt.cpp
+++ b/deps/icu-small/source/i18n/msgfmt.cpp
@@ -239,7 +239,7 @@ MessageFormat::MessageFormat(const UnicodeString& pattern,
   argTypes(NULL),
   argTypeCount(0),
   argTypeCapacity(0),
-  hasArgTypeConflicts(FALSE),
+  hasArgTypeConflicts(false),
   defaultNumberFormat(NULL),
   defaultDateFormat(NULL),
   cachedFormatters(NULL),
@@ -261,7 +261,7 @@ MessageFormat::MessageFormat(const UnicodeString& pattern,
   argTypes(NULL),
   argTypeCount(0),
   argTypeCapacity(0),
-  hasArgTypeConflicts(FALSE),
+  hasArgTypeConflicts(false),
   defaultNumberFormat(NULL),
   defaultDateFormat(NULL),
   cachedFormatters(NULL),
@@ -284,7 +284,7 @@ MessageFormat::MessageFormat(const UnicodeString& pattern,
   argTypes(NULL),
   argTypeCount(0),
   argTypeCapacity(0),
-  hasArgTypeConflicts(FALSE),
+  hasArgTypeConflicts(false),
   defaultNumberFormat(NULL),
   defaultDateFormat(NULL),
   cachedFormatters(NULL),
@@ -338,17 +338,17 @@ MessageFormat::~MessageFormat()
 
 /**
  * Allocate argTypes[] to at least the given capacity and return
- * TRUE if successful.  If not, leave argTypes[] unchanged.
+ * true if successful.  If not, leave argTypes[] unchanged.
  *
  * If argTypes is NULL, allocate it.  If it is not NULL, enlarge it
  * if necessary to be at least as large as specified.
  */
 UBool MessageFormat::allocateArgTypes(int32_t capacity, UErrorCode& status) {
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
     if (argTypeCapacity >= capacity) {
-        return TRUE;
+        return true;
     }
     if (capacity < DEFAULT_INITIAL_CAPACITY) {
         capacity = DEFAULT_INITIAL_CAPACITY;
@@ -359,11 +359,11 @@ UBool MessageFormat::allocateArgTypes(int32_t capacity, UErrorCode& status) {
             uprv_realloc(argTypes, sizeof(*argTypes) * capacity);
     if (a == NULL) {
         status = U_MEMORY_ALLOCATION_ERROR;
-        return FALSE;
+        return false;
     }
     argTypes = a;
     argTypeCapacity = capacity;
-    return TRUE;
+    return true;
 }
 
 // -------------------------------------
@@ -504,7 +504,7 @@ void MessageFormat::resetPattern() {
     uhash_close(customFormatArgStarts);
     customFormatArgStarts = NULL;
     argTypeCount = 0;
-    hasArgTypeConflicts = FALSE;
+    hasArgTypeConflicts = false;
 }
 
 void
@@ -973,7 +973,7 @@ public:
     PluralSelectorContext(int32_t start, const UnicodeString &name,
                           const Formattable &num, double off, UErrorCode &errorCode)
             : startIndex(start), argName(name), offset(off),
-              numberArgIndex(-1), formatter(NULL), forReplaceNumber(FALSE) {
+              numberArgIndex(-1), formatter(NULL), forReplaceNumber(false) {
         // number needs to be set even when select() is not called.
         // Keep it as a Number/Formattable:
         // For format() methods, and to preserve information (e.g., BigDecimal).
@@ -996,7 +996,7 @@ public:
     const Format *formatter;
     /** formatted argument number - plural offset */
     UnicodeString numberString;
-    /** TRUE if number-offset was formatted with the stock number formatter */
+    /** true if number-offset was formatted with the stock number formatter */
     UBool forReplaceNumber;
 };
 
@@ -1048,7 +1048,7 @@ void MessageFormat::format(int32_t msgStart, const void *plNumber,
         UMessagePatternArgType argType = part->getArgType();
         part = &msgPattern.getPart(++i);
         const Formattable* arg;
-        UBool noArg = FALSE;
+        UBool noArg = false;
         UnicodeString argName = msgPattern.getSubstring(*part);
         if (argumentNames == NULL) {
             int32_t argNumber = part->getValue();  // ARG_NUMBER
@@ -1056,12 +1056,12 @@ void MessageFormat::format(int32_t msgStart, const void *plNumber,
                 arg = arguments + argNumber;
             } else {
                 arg = NULL;
-                noArg = TRUE;
+                noArg = true;
             }
         } else {
             arg = getArgFromListByName(arguments, argumentNames, cnt, argName);
             if (arg == NULL) {
-                noArg = TRUE;
+                noArg = true;
             }
         }
         ++i;
@@ -1268,7 +1268,7 @@ MessageFormat::findOtherSubMessage(int32_t partIndex) const {
     }
     // Iterate over (ARG_SELECTOR [ARG_INT|ARG_DOUBLE] message) tuples
     // until ARG_LIMIT or end of plural-only pattern.
-    UnicodeString other(FALSE, OTHER_STRING, 5);
+    UnicodeString other(false, OTHER_STRING, 5);
     do {
         part=&msgPattern.getPart(partIndex++);
         UMessagePatternPartType type=part->getType();
@@ -1393,7 +1393,7 @@ MessageFormat::parse(int32_t msgStart,
     ParsePosition tempStatus(0);
 
     for(int32_t i=msgStart+1; ; ++i) {
-        UBool haveArgResult = FALSE;
+        UBool haveArgResult = false;
         const MessagePattern::Part* part=&msgPattern.getPart(i);
         const UMessagePatternPartType type=part->getType();
         int32_t index=part->getIndex();
@@ -1437,7 +1437,7 @@ MessageFormat::parse(int32_t msgStart,
                 return NULL; // leave index as is to signal error
             }
             sourceOffset = tempStatus.getIndex();
-            haveArgResult = TRUE;
+            haveArgResult = true;
         } else if(
             argType==UMSGPAT_ARG_TYPE_NONE || (cachedFormatters && uhash_iget(cachedFormatters, i -2))) {
             // We arrive here if getCachedFormatter returned NULL, but there was actually an element in the hash table.
@@ -1466,7 +1466,7 @@ MessageFormat::parse(int32_t msgStart,
                 compValue.append(RIGHT_CURLY_BRACE);
                 if (0 != strValue.compare(compValue)) {
                     argResult.setString(strValue);
-                    haveArgResult = TRUE;
+                    haveArgResult = true;
                 }
                 sourceOffset = next;
             }
@@ -1478,7 +1478,7 @@ MessageFormat::parse(int32_t msgStart,
                 return NULL; // leave index as is to signal error
             }
             argResult.setDouble(choiceResult);
-            haveArgResult = TRUE;
+            haveArgResult = true;
             sourceOffset = tempStatus.getIndex();
         } else if(UMSGPAT_ARG_TYPE_HAS_PLURAL_STYLE(argType) || argType==UMSGPAT_ARG_TYPE_SELECT) {
             // Parsing not supported.
@@ -1622,7 +1622,7 @@ void MessageFormat::cacheExplicitFormats(UErrorCode& status) {
     for (int32_t i = 0; i < argTypeCount; ++i) {
         argTypes[i] = Formattable::kObject;
     }
-    hasArgTypeConflicts = FALSE;
+    hasArgTypeConflicts = false;
 
     // This loop starts at part index 1 because we do need to examine
     // ARG_START parts. (But we can ignore the MSG_START.)
@@ -1673,7 +1673,7 @@ void MessageFormat::cacheExplicitFormats(UErrorCode& status) {
         }
         if (argNumber != -1) {
             if (argTypes[argNumber] != Formattable::kObject && argTypes[argNumber] != formattableType) {
-                hasArgTypeConflicts = TRUE;
+                hasArgTypeConflicts = true;
             }
             argTypes[argNumber] = formattableType;
         }
@@ -1789,7 +1789,7 @@ int32_t MessageFormat::findKeyword(const UnicodeString& s,
 
     int32_t length = s.length();
     const UChar *ps = PatternProps::trimWhiteSpace(s.getBuffer(), length);
-    UnicodeString buffer(FALSE, ps, length);
+    UnicodeString buffer(false, ps, length);
     // Trims the space characters and turns all characters
     // in s to lower case.
     buffer.toLower("");
@@ -1810,8 +1810,8 @@ MessageFormat::createIntegerFormat(const Locale& locale, UErrorCode& status) con
     DecimalFormat *temp2;
     if (temp != NULL && (temp2 = dynamic_cast<DecimalFormat*>(temp)) != NULL) {
         temp2->setMaximumFractionDigits(0);
-        temp2->setDecimalSeparatorAlwaysShown(FALSE);
-        temp2->setParseIntegerOnly(TRUE);
+        temp2->setDecimalSeparatorAlwaysShown(false);
+        temp2->setParseIntegerOnly(true);
     }
 
     return temp;
@@ -1951,13 +1951,13 @@ MessageFormat::PluralSelectorProvider::~PluralSelectorProvider() {
 UnicodeString MessageFormat::PluralSelectorProvider::select(void *ctx, double number,
                                                             UErrorCode& ec) const {
     if (U_FAILURE(ec)) {
-        return UnicodeString(FALSE, OTHER_STRING, 5);
+        return UnicodeString(false, OTHER_STRING, 5);
     }
     MessageFormat::PluralSelectorProvider* t = const_cast<MessageFormat::PluralSelectorProvider*>(this);
     if(rules == NULL) {
         t->rules = PluralRules::forLocale(msgFormat.fLocale, type, ec);
         if (U_FAILURE(ec)) {
-            return UnicodeString(FALSE, OTHER_STRING, 5);
+            return UnicodeString(false, OTHER_STRING, 5);
         }
     }
     // Select a sub-message according to how the number is formatted,
@@ -1975,11 +1975,11 @@ UnicodeString MessageFormat::PluralSelectorProvider::select(void *ctx, double nu
     }
     if(context.formatter == NULL) {
         context.formatter = msgFormat.getDefaultNumberFormat(ec);
-        context.forReplaceNumber = TRUE;
+        context.forReplaceNumber = true;
     }
     if (context.number.getDouble(ec) != number) {
         ec = U_INTERNAL_PROGRAM_ERROR;
-        return UnicodeString(FALSE, OTHER_STRING, 5);
+        return UnicodeString(false, OTHER_STRING, 5);
     }
     context.formatter->format(context.number, context.numberString, ec);
     auto* decFmt = dynamic_cast<const DecimalFormat *>(context.formatter);
@@ -1987,7 +1987,7 @@ UnicodeString MessageFormat::PluralSelectorProvider::select(void *ctx, double nu
         number::impl::DecimalQuantity dq;
         decFmt->formatToDecimalQuantity(context.number, dq, ec);
         if (U_FAILURE(ec)) {
-            return UnicodeString(FALSE, OTHER_STRING, 5);
+            return UnicodeString(false, OTHER_STRING, 5);
         }
         return rules->select(dq);
     } else {
diff --git a/deps/icu-small/source/i18n/name2uni.cpp b/deps/icu-small/source/i18n/name2uni.cpp
index ffbbf152d3..b22c68b022 100644
--- a/deps/icu-small/source/i18n/name2uni.cpp
+++ b/deps/icu-small/source/i18n/name2uni.cpp
@@ -127,7 +127,7 @@ void NameUnicodeTransliterator::handleTransliterate(Replaceable& text, UTransPos
         return;
     }
 
-    UnicodeString openPat(TRUE, OPEN, -1);
+    UnicodeString openPat(true, OPEN, -1);
     UnicodeString str, name;
 
     int32_t cursor = offsets.start;
@@ -222,7 +222,7 @@ void NameUnicodeTransliterator::handleTransliterate(Replaceable& text, UTransPos
             }
             
             // Check if c is a legal char.  We assume here that
-            // legal.contains(OPEN_DELIM) is FALSE, so when we abort a
+            // legal.contains(OPEN_DELIM) is false, so when we abort a
             // name, we don't have to go back to openPos+1.
             if (legal.contains(c)) {
                 name.append(c);
diff --git a/deps/icu-small/source/i18n/nfrs.cpp b/deps/icu-small/source/i18n/nfrs.cpp
index df04e33e04..17fab13911 100644
--- a/deps/icu-small/source/i18n/nfrs.cpp
+++ b/deps/icu-small/source/i18n/nfrs.cpp
@@ -138,9 +138,9 @@ NFRuleSet::NFRuleSet(RuleBasedNumberFormat *_owner, UnicodeString* descriptions,
   , rules(0)
   , owner(_owner)
   , fractionRules()
-  , fIsFractionRuleSet(FALSE)
-  , fIsPublic(FALSE)
-  , fIsParseable(TRUE)
+  , fIsFractionRuleSet(false)
+  , fIsPublic(false)
+  , fIsParseable(true)
 {
     for (int32_t i = 0; i < NON_NUMERICAL_RULE_LENGTH; ++i) {
         nonNumericalRules[i] = NULL;
@@ -185,7 +185,7 @@ NFRuleSet::NFRuleSet(RuleBasedNumberFormat *_owner, UnicodeString* descriptions,
     fIsPublic = name.indexOf(gPercentPercent, 2, 0) != 0;
 
     if ( name.endsWith(gNoparse,8) ) {
-        fIsParseable = FALSE;
+        fIsParseable = false;
         name.truncate(name.length()-8); // remove the @noparse from the name
     }
 
@@ -273,13 +273,13 @@ void NFRuleSet::setNonNumericalRule(NFRule *rule) {
         nonNumericalRules[NEGATIVE_RULE_INDEX] = rule;
     }
     else if (baseValue == NFRule::kImproperFractionRule) {
-        setBestFractionRule(IMPROPER_FRACTION_RULE_INDEX, rule, TRUE);
+        setBestFractionRule(IMPROPER_FRACTION_RULE_INDEX, rule, true);
     }
     else if (baseValue == NFRule::kProperFractionRule) {
-        setBestFractionRule(PROPER_FRACTION_RULE_INDEX, rule, TRUE);
+        setBestFractionRule(PROPER_FRACTION_RULE_INDEX, rule, true);
     }
     else if (baseValue == NFRule::kDefaultRule) {
-        setBestFractionRule(DEFAULT_RULE_INDEX, rule, TRUE);
+        setBestFractionRule(DEFAULT_RULE_INDEX, rule, true);
     }
     else if (baseValue == NFRule::kInfinityRule) {
         delete nonNumericalRules[INFINITY_RULE_INDEX];
@@ -339,9 +339,9 @@ util_equalRules(const NFRule* rule1, const NFRule* rule2)
             return *rule1 == *rule2;
         }
     } else if (!rule2) {
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 bool
@@ -380,7 +380,7 @@ NFRuleSet::setDecimalFormatSymbols(const DecimalFormatSymbols &newSymbols, UErro
             for (uint32_t fIdx = 0; fIdx < fractionRules.size(); fIdx++) {
                 NFRule *fractionRule = fractionRules[fIdx];
                 if (nonNumericalRules[nonNumericalIdx]->getBaseValue() == fractionRule->getBaseValue()) {
-                    setBestFractionRule(nonNumericalIdx, fractionRule, FALSE);
+                    setBestFractionRule(nonNumericalIdx, fractionRule, false);
                 }
             }
         }
diff --git a/deps/icu-small/source/i18n/nfrule.cpp b/deps/icu-small/source/i18n/nfrule.cpp
index 4bb0785127..2f8383c764 100644
--- a/deps/icu-small/source/i18n/nfrule.cpp
+++ b/deps/icu-small/source/i18n/nfrule.cpp
@@ -621,9 +621,9 @@ util_equalSubstitutions(const NFSubstitution* sub1, const NFSubstitution* sub2)
             return *sub1 == *sub2;
         }
     } else if (!sub2) {
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 /**
@@ -856,7 +856,7 @@ NFRule::shouldRollBack(int64_t number) const
         int64_t re = util64_pow(radix, exponent);
         return (number % re) == 0 && (baseValue % re) != 0;
     }
-    return FALSE;
+    return false;
 }
 
 //-----------------------------------------------------------------------
@@ -943,19 +943,19 @@ NFRule::doParse(const UnicodeString& text,
         // restored for ICU4C port
         parsePosition.setErrorIndex(pp.getErrorIndex());
         resVal.setLong(0);
-        return TRUE;
+        return true;
     }
     if (baseValue == kInfinityRule) {
         // If you match this, don't try to perform any calculations on it.
         parsePosition.setIndex(pp.getIndex());
         resVal.setDouble(uprv_getInfinity());
-        return TRUE;
+        return true;
     }
     if (baseValue == kNaNRule) {
         // If you match this, don't try to perform any calculations on it.
         parsePosition.setIndex(pp.getIndex());
         resVal.setDouble(uprv_getNaN());
-        return TRUE;
+        return true;
     }
 
     // this is the fun part.  The basic guts of the rule-matching
@@ -1083,7 +1083,7 @@ NFRule::doParse(const UnicodeString& text,
     }
 
     resVal.setDouble(result);
-    return TRUE; // ??? do we need to worry if it is a long or a double?
+    return true; // ??? do we need to worry if it is a long or a double?
 }
 
 /**
@@ -1191,7 +1191,7 @@ NFRule::matchToDelimiter(const UnicodeString& text,
             if (subText.length() > 0) {
                 UBool success = sub->doParse(subText, tempPP, _baseValue, upperBound,
 #if UCONFIG_NO_COLLATION
-                    FALSE,
+                    false,
 #else
                     formatter->isLenient(),
 #endif
@@ -1245,7 +1245,7 @@ NFRule::matchToDelimiter(const UnicodeString& text,
         // try to match the whole string against the substitution
         UBool success = sub->doParse(text, tempPP, _baseValue, upperBound,
 #if UCONFIG_NO_COLLATION
-            FALSE,
+            false,
 #else
             formatter->isLenient(),
 #endif
@@ -1579,7 +1579,7 @@ NFRule::allIgnorable(const UnicodeString& str, UErrorCode& status) const
 {
     // if the string is empty, we can just return true
     if (str.length() == 0) {
-        return TRUE;
+        return true;
     }
 
 #if !UCONFIG_NO_COLLATION
@@ -1590,14 +1590,14 @@ NFRule::allIgnorable(const UnicodeString& str, UErrorCode& status) const
         const RuleBasedCollator* collator = formatter->getCollator();
         if (collator == NULL) {
             status = U_MEMORY_ALLOCATION_ERROR;
-            return FALSE;
+            return false;
         }
         LocalPointer<CollationElementIterator> iter(collator->createCollationElementIterator(str));
 
         // Memory allocation error check.
         if (iter.isNull()) {
             status = U_MEMORY_ALLOCATION_ERROR;
-            return FALSE;
+            return false;
         }
 
         UErrorCode err = U_ZERO_ERROR;
@@ -1613,7 +1613,7 @@ NFRule::allIgnorable(const UnicodeString& str, UErrorCode& status) const
 
     // if lenient parsing is turned off, there is no such thing as
     // an ignorable character: return true only if the string is empty
-    return FALSE;
+    return false;
 }
 
 void
diff --git a/deps/icu-small/source/i18n/nfsubs.cpp b/deps/icu-small/source/i18n/nfsubs.cpp
index 70ac18be46..9dba77b1e3 100644
--- a/deps/icu-small/source/i18n/nfsubs.cpp
+++ b/deps/icu-small/source/i18n/nfsubs.cpp
@@ -167,7 +167,7 @@ public:
 
     virtual double calcUpperBound(double /*oldUpperBound*/) const override { return static_cast<double>(divisor); }
 
-    virtual UBool isModulusSubstitution() const override { return TRUE; }
+    virtual UBool isModulusSubstitution() const override { return true; }
 
     virtual UChar tokenChar() const override { return (UChar)0x003e; } // '>'
 
@@ -763,11 +763,11 @@ NFSubstitution::doParse(const UnicodeString& text,
         // the result.
         tempResult = composeRuleValue(tempResult, baseValue);
         result.setDouble(tempResult);
-        return TRUE;
+        return true;
         // if the parse was UNsuccessful, return 0
     } else {
         result.setLong(0);
-        return FALSE;
+        return false;
     }
 }
 
@@ -779,7 +779,7 @@ NFSubstitution::doParse(const UnicodeString& text,
      */
 UBool
 NFSubstitution::isModulusSubstitution() const {
-    return FALSE;
+    return false;
 }
 
 //===================================================================
@@ -950,7 +950,7 @@ ModulusSubstitution::doParse(const UnicodeString& text,
         // use the specific rule's doParse() method, and then we have to
         // do some of the other work of NFRuleSet.parse()
     } else {
-        ruleToUse->doParse(text, parsePosition, FALSE, upperBound, nonNumericalExecutedRuleMask, result);
+        ruleToUse->doParse(text, parsePosition, false, upperBound, nonNumericalExecutedRuleMask, result);
 
         if (parsePosition.getIndex() != 0) {
             UErrorCode status = U_ZERO_ERROR;
@@ -959,7 +959,7 @@ ModulusSubstitution::doParse(const UnicodeString& text,
             result.setDouble(tempResult);
         }
 
-        return TRUE;
+        return true;
     }
 }
 /**
@@ -1007,17 +1007,17 @@ FractionalPartSubstitution::FractionalPartSubstitution(int32_t _pos,
                              const UnicodeString& description,
                              UErrorCode& status)
  : NFSubstitution(_pos, _ruleSet, description, status)
- , byDigits(FALSE)
- , useSpaces(TRUE)
+ , byDigits(false)
+ , useSpaces(true)
 
 {
     // akk, ruleSet can change in superclass constructor
     if (0 == description.compare(gGreaterGreaterThan, 2) ||
         0 == description.compare(gGreaterGreaterGreaterThan, 3) ||
         _ruleSet == getRuleSet()) {
-        byDigits = TRUE;
+        byDigits = true;
         if (0 == description.compare(gGreaterGreaterGreaterThan, 3)) {
-            useSpaces = FALSE;
+            useSpaces = false;
         }
     } else {
         // cast away const
@@ -1059,14 +1059,14 @@ FractionalPartSubstitution::doSubstitution(double number, UnicodeString& toInser
     //          // this flag keeps us from formatting trailing zeros.  It starts
     //          // out false because we're pulling from the right, and switches
     //          // to true the first time we encounter a non-zero digit
-    //          UBool doZeros = FALSE;
+    //          UBool doZeros = false;
     //          for (int32_t i = 0; i < kMaxDecimalDigits; i++) {
     //              int64_t digit = numberToFormat % 10;
     //              if (digit != 0 || doZeros) {
     //                  if (doZeros && useSpaces) {
     //                      toInsertInto.insert(_pos + getPos(), gSpace);
     //                  }
-    //                  doZeros = TRUE;
+    //                  doZeros = true;
     //                  getRuleSet()->format(digit, toInsertInto, _pos + getPos());
     //              }
     //              numberToFormat /= 10;
@@ -1076,7 +1076,7 @@ FractionalPartSubstitution::doSubstitution(double number, UnicodeString& toInser
     dl.setToDouble(number);
     dl.roundToMagnitude(-20, UNUM_ROUND_HALFEVEN, status);     // round to 20 fraction digits.
     
-    UBool pad = FALSE;
+    UBool pad = false;
     for (int32_t didx = dl.getLowerDisplayMagnitude(); didx<0; didx++) {
       // Loop iterates over fraction digits, starting with the LSD.
       //   include both real digits from the number, and zeros
@@ -1084,7 +1084,7 @@ FractionalPartSubstitution::doSubstitution(double number, UnicodeString& toInser
       if (pad && useSpaces) {
         toInsertInto.insert(_pos + getPos(), gSpace);
       } else {
-        pad = TRUE;
+        pad = true;
       }
       int64_t digit = dl.getDigit(didx);
       getRuleSet()->format(digit, toInsertInto, _pos + getPos(), recursionCount, status);
@@ -1191,7 +1191,7 @@ FractionalPartSubstitution::doParse(const UnicodeString& text,
         result = dl.toDouble();
         result = composeRuleValue(result, baseValue);
         resVal.setDouble(result);
-        return TRUE;
+        return true;
     }
 }
 
@@ -1301,7 +1301,7 @@ NumeratorSubstitution::doParse(const UnicodeString& text,
     }
 
     // we've parsed off the zeros, now let's parse the rest from our current position
-    NFSubstitution::doParse(workText, parsePosition, withZeros ? 1 : baseValue, upperBound, FALSE, nonNumericalExecutedRuleMask, result);
+    NFSubstitution::doParse(workText, parsePosition, withZeros ? 1 : baseValue, upperBound, false, nonNumericalExecutedRuleMask, result);
 
     if (withZeros) {
         // any base value will do in this case.  is there a way to
@@ -1310,10 +1310,8 @@ NumeratorSubstitution::doParse(const UnicodeString& text,
         // compute the 'effective' base and prescale the value down
         int64_t n = result.getLong(status); // force conversion!
         int64_t d = 1;
-        int32_t pow = 0;
         while (d <= n) {
             d *= 10;
-            ++pow;
         }
         // now add the zeros
         while (zeroCount > 0) {
@@ -1324,7 +1322,7 @@ NumeratorSubstitution::doParse(const UnicodeString& text,
         result.setDouble((double)n/(double)d);
     }
 
-    return TRUE;
+    return true;
 }
 
 bool
diff --git a/deps/icu-small/source/i18n/nfsubs.h b/deps/icu-small/source/i18n/nfsubs.h
index 0abd98be09..a38a3722a5 100644
--- a/deps/icu-small/source/i18n/nfsubs.h
+++ b/deps/icu-small/source/i18n/nfsubs.h
@@ -245,8 +245,8 @@ public:
     virtual UBool isModulusSubstitution() const;
     
 private:
-    NFSubstitution(const NFSubstitution &other); // forbid copying of this class
-    NFSubstitution &operator=(const NFSubstitution &other); // forbid copying of this class
+    NFSubstitution(const NFSubstitution &other) = delete; // forbid copying of this class
+    NFSubstitution &operator=(const NFSubstitution &other) = delete; // forbid copying of this class
 
 public:
     static UClassID getStaticClassID(void);
diff --git a/deps/icu-small/source/i18n/nortrans.cpp b/deps/icu-small/source/i18n/nortrans.cpp
index 6a8d2c7419..b1809daebd 100644
--- a/deps/icu-small/source/i18n/nortrans.cpp
+++ b/deps/icu-small/source/i18n/nortrans.cpp
@@ -45,13 +45,13 @@ void NormalizationTransliterator::registerIDs() {
     Transliterator::_registerFactory(UNICODE_STRING_SIMPLE("Any-FCC"),
                                      _create, cstrToken("nfc\0\3"));
     Transliterator::_registerSpecialInverse(UNICODE_STRING_SIMPLE("NFC"),
-                                            UNICODE_STRING_SIMPLE("NFD"), TRUE);
+                                            UNICODE_STRING_SIMPLE("NFD"), true);
     Transliterator::_registerSpecialInverse(UNICODE_STRING_SIMPLE("NFKC"),
-                                            UNICODE_STRING_SIMPLE("NFKD"), TRUE);
+                                            UNICODE_STRING_SIMPLE("NFKD"), true);
     Transliterator::_registerSpecialInverse(UNICODE_STRING_SIMPLE("FCC"),
-                                            UNICODE_STRING_SIMPLE("NFD"), FALSE);
+                                            UNICODE_STRING_SIMPLE("NFD"), false);
     Transliterator::_registerSpecialInverse(UNICODE_STRING_SIMPLE("FCD"),
-                                            UNICODE_STRING_SIMPLE("FCD"), FALSE);
+                                            UNICODE_STRING_SIMPLE("FCD"), false);
 }
 
 /**
diff --git a/deps/icu-small/source/i18n/number_capi.cpp b/deps/icu-small/source/i18n/number_capi.cpp
index b87dbd93e5..42bb05c066 100644
--- a/deps/icu-small/source/i18n/number_capi.cpp
+++ b/deps/icu-small/source/i18n/number_capi.cpp
@@ -166,11 +166,11 @@ unumf_resultToString(const UFormattedNumber* uresult, UChar* buffer, int32_t buf
 U_CAPI UBool U_EXPORT2
 unumf_resultNextFieldPosition(const UFormattedNumber* uresult, UFieldPosition* ufpos, UErrorCode* ec) {
     const auto* result = UFormattedNumberApiHelper::validate(uresult, *ec);
-    if (U_FAILURE(*ec)) { return FALSE; }
+    if (U_FAILURE(*ec)) { return false; }
 
     if (ufpos == nullptr) {
         *ec = U_ILLEGAL_ARGUMENT_ERROR;
-        return FALSE;
+        return false;
     }
 
     FieldPosition fp;
@@ -181,7 +181,7 @@ unumf_resultNextFieldPosition(const UFormattedNumber* uresult, UFieldPosition* u
     ufpos->beginIndex = fp.getBeginIndex();
     ufpos->endIndex = fp.getEndIndex();
     // NOTE: MSVC sometimes complains when implicitly converting between bool and UBool
-    return retval ? TRUE : FALSE;
+    return retval ? true : false;
 }
 
 U_CAPI void U_EXPORT2
diff --git a/deps/icu-small/source/i18n/number_compact.cpp b/deps/icu-small/source/i18n/number_compact.cpp
index 60cd7bedf6..4dc96e7ea1 100644
--- a/deps/icu-small/source/i18n/number_compact.cpp
+++ b/deps/icu-small/source/i18n/number_compact.cpp
@@ -173,10 +173,14 @@ void CompactData::CompactDataSink::put(const char *key, ResourceValue &value, UB
     for (int i3 = 0; powersOfTenTable.getKeyAndValue(i3, key, value); ++i3) {
 
         // Assumes that the keys are always of the form "10000" where the magnitude is the
-        // length of the key minus one.  We expect magnitudes to be less than MAX_DIGITS.
+        // length of the key minus one.  We only support magnitudes less than COMPACT_MAX_DIGITS;
+        // ignore entries that have greater magnitude.
         auto magnitude = static_cast<int8_t> (strlen(key) - 1);
+        U_ASSERT(magnitude < COMPACT_MAX_DIGITS); // debug assert
+        if (magnitude >= COMPACT_MAX_DIGITS) { // skip in production
+            continue;
+        }
         int8_t multiplier = data.multipliers[magnitude];
-        U_ASSERT(magnitude < COMPACT_MAX_DIGITS);
 
         // Iterate over the plural variants ("one", "other", etc)
         ResourceTable pluralVariantsTable = value.getTable(status);
diff --git a/deps/icu-small/source/i18n/number_compact.h b/deps/icu-small/source/i18n/number_compact.h
index 9802b9fb10..fa29744c10 100644
--- a/deps/icu-small/source/i18n/number_compact.h
+++ b/deps/icu-small/source/i18n/number_compact.h
@@ -17,7 +17,7 @@
 U_NAMESPACE_BEGIN namespace number {
 namespace impl {
 
-static const int32_t COMPACT_MAX_DIGITS = 15;
+static const int32_t COMPACT_MAX_DIGITS = 20;
 
 class CompactData : public MultiplierProducer {
   public:
diff --git a/deps/icu-small/source/i18n/number_currencysymbols.cpp b/deps/icu-small/source/i18n/number_currencysymbols.cpp
index da1812f49f..8d5127556b 100644
--- a/deps/icu-small/source/i18n/number_currencysymbols.cpp
+++ b/deps/icu-small/source/i18n/number_currencysymbols.cpp
@@ -108,6 +108,10 @@ UnicodeString CurrencySymbols::getPluralName(StandardPlural::Form plural, UError
     }
 }
 
+bool CurrencySymbols::hasEmptyCurrencySymbol() const {
+    return !fCurrencySymbol.isBogus() && fCurrencySymbol.isEmpty();
+}
+
 
 CurrencyUnit
 icu::number::impl::resolveCurrency(const DecimalFormatProperties& properties, const Locale& locale,
diff --git a/deps/icu-small/source/i18n/number_currencysymbols.h b/deps/icu-small/source/i18n/number_currencysymbols.h
index 7e38fdf828..c2223bd0f0 100644
--- a/deps/icu-small/source/i18n/number_currencysymbols.h
+++ b/deps/icu-small/source/i18n/number_currencysymbols.h
@@ -41,6 +41,8 @@ class U_I18N_API CurrencySymbols : public UMemory {
 
     UnicodeString getPluralName(StandardPlural::Form plural, UErrorCode& status) const;
 
+    bool hasEmptyCurrencySymbol() const;
+
   protected:
     // Required fields:
     CurrencyUnit fCurrency;
diff --git a/deps/icu-small/source/i18n/number_decimfmtprops.cpp b/deps/icu-small/source/i18n/number_decimfmtprops.cpp
index 7fa58bbc7a..6dbfc69ec8 100644
--- a/deps/icu-small/source/i18n/number_decimfmtprops.cpp
+++ b/deps/icu-small/source/i18n/number_decimfmtprops.cpp
@@ -18,7 +18,7 @@ namespace {
 alignas(DecimalFormatProperties)
 char kRawDefaultProperties[sizeof(DecimalFormatProperties)];
 
-icu::UInitOnce gDefaultPropertiesInitOnce = U_INITONCE_INITIALIZER;
+icu::UInitOnce gDefaultPropertiesInitOnce {};
 
 void U_CALLCONV initDefaultProperties(UErrorCode&) {
     // can't fail, uses placement new into statically allocated space.
diff --git a/deps/icu-small/source/i18n/number_fluent.cpp b/deps/icu-small/source/i18n/number_fluent.cpp
index fd486afb51..8a968d922c 100644
--- a/deps/icu-small/source/i18n/number_fluent.cpp
+++ b/deps/icu-small/source/i18n/number_fluent.cpp
@@ -288,6 +288,34 @@ Derived NumberFormatterSettings<Derived>::usage(const StringPiece usage)&& {
     return move;
 }
 
+template <typename Derived>
+Derived NumberFormatterSettings<Derived>::displayOptions(const DisplayOptions &displayOptions) const & {
+    Derived copy(*this);
+    // `displayCase` does not recognise the `undefined`
+    if (displayOptions.getGrammaticalCase() == UDISPOPT_GRAMMATICAL_CASE_UNDEFINED) {
+        copy.fMacros.unitDisplayCase.set(nullptr);
+        return copy;
+    }
+
+    copy.fMacros.unitDisplayCase.set(
+        udispopt_getGrammaticalCaseIdentifier(displayOptions.getGrammaticalCase()));
+    return copy;
+}
+
+template <typename Derived>
+Derived NumberFormatterSettings<Derived>::displayOptions(const DisplayOptions &displayOptions) && {
+    Derived move(std::move(*this));
+    // `displayCase` does not recognise the `undefined`
+    if (displayOptions.getGrammaticalCase() == UDISPOPT_GRAMMATICAL_CASE_UNDEFINED) {
+        move.fMacros.unitDisplayCase.set(nullptr);
+        return move;
+    }
+
+    move.fMacros.unitDisplayCase.set(
+        udispopt_getGrammaticalCaseIdentifier(displayOptions.getGrammaticalCase()));
+    return move;
+}
+
 template<typename Derived>
 Derived NumberFormatterSettings<Derived>::unitDisplayCase(const StringPiece unitDisplayCase) const& {
     Derived copy(*this);
diff --git a/deps/icu-small/source/i18n/number_formatimpl.cpp b/deps/icu-small/source/i18n/number_formatimpl.cpp
index 96e3e9e7c6..4fb190b744 100644
--- a/deps/icu-small/source/i18n/number_formatimpl.cpp
+++ b/deps/icu-small/source/i18n/number_formatimpl.cpp
@@ -353,7 +353,9 @@ NumberFormatterImpl::macrosToMicroGenerator(const MacroProps& macros, bool safe,
     }
     fPatternModifier.adoptInstead(patternModifier);
     const AffixPatternProvider* affixProvider =
-        macros.affixProvider != nullptr
+        macros.affixProvider != nullptr && (
+                // For more information on this condition, see ICU-22073
+                !isCompactNotation || isCurrency == macros.affixProvider->hasCurrencySign())
             ? macros.affixProvider
             : static_cast<const AffixPatternProvider*>(fPatternInfo.getAlias());
     patternModifier->setPatternInfo(affixProvider, kUndefinedField);
diff --git a/deps/icu-small/source/i18n/number_longnames.cpp b/deps/icu-small/source/i18n/number_longnames.cpp
index b4e96504de..be0320cecf 100644
--- a/deps/icu-small/source/i18n/number_longnames.cpp
+++ b/deps/icu-small/source/i18n/number_longnames.cpp
@@ -1569,7 +1569,7 @@ void MixedUnitLongNameHandler::forMeasureUnit(const Locale &loc,
     for (int32_t i = 0; i < fillIn->fMixedUnitCount; i++) {
         // Grab data for each of the components.
         UnicodeString *unitData = &fillIn->fMixedUnitData[i * ARRAY_LENGTH];
-        // TODO(CLDR-14502): check from the CLDR-14502 ticket whether this
+        // TODO(CLDR-14582): check from the CLDR-14582 ticket whether this
         // propagation of unitDisplayCase is correct:
         getMeasureData(loc, impl.singleUnits[i]->build(status), width, unitDisplayCase, unitData,
                        status);
diff --git a/deps/icu-small/source/i18n/number_mapper.cpp b/deps/icu-small/source/i18n/number_mapper.cpp
index 350c431dfd..2f398d4a93 100644
--- a/deps/icu-small/source/i18n/number_mapper.cpp
+++ b/deps/icu-small/source/i18n/number_mapper.cpp
@@ -256,8 +256,6 @@ MacroProps NumberPropertyMapper::oldToNew(const DecimalFormatProperties& propert
         } else {
             macros.notation = Notation::compactShort();
         }
-        // Do not forward the affix provider.
-        macros.affixProvider = nullptr;
     }
 
     /////////////////
diff --git a/deps/icu-small/source/i18n/number_modifiers.cpp b/deps/icu-small/source/i18n/number_modifiers.cpp
index b74bfd06fc..092b66ff57 100644
--- a/deps/icu-small/source/i18n/number_modifiers.cpp
+++ b/deps/icu-small/source/i18n/number_modifiers.cpp
@@ -22,7 +22,7 @@ const int32_t ARG_NUM_LIMIT = 0x100;
 // These are the default currency spacing UnicodeSets in CLDR.
 // Pre-compute them for performance.
 // The Java unit test testCurrencySpacingPatternStability() will start failing if these change in CLDR.
-icu::UInitOnce gDefaultCurrencySpacingInitOnce = U_INITONCE_INITIALIZER;
+icu::UInitOnce gDefaultCurrencySpacingInitOnce {};
 
 UnicodeSet *UNISET_DIGIT = nullptr;
 UnicodeSet *UNISET_NOTSZ = nullptr;
@@ -33,7 +33,7 @@ UBool U_CALLCONV cleanupDefaultCurrencySpacing() {
     delete UNISET_NOTSZ;
     UNISET_NOTSZ = nullptr;
     gDefaultCurrencySpacingInitOnce.reset();
-    return TRUE;
+    return true;
 }
 
 void U_CALLCONV initDefaultCurrencySpacing(UErrorCode &status) {
diff --git a/deps/icu-small/source/i18n/number_output.cpp b/deps/icu-small/source/i18n/number_output.cpp
index 78006da8c4..729a2cd5e6 100644
--- a/deps/icu-small/source/i18n/number_output.cpp
+++ b/deps/icu-small/source/i18n/number_output.cpp
@@ -39,52 +39,10 @@ MeasureUnit FormattedNumber::getOutputUnit(UErrorCode& status) const {
     return fData->outputUnit;
 }
 
-NounClass FormattedNumber::getNounClass(UErrorCode &status) const {
-    UPRV_FORMATTED_VALUE_METHOD_GUARD(NounClass::OTHER);
+UDisplayOptionsNounClass FormattedNumber::getNounClass(UErrorCode &status) const {
+    UPRV_FORMATTED_VALUE_METHOD_GUARD(UDISPOPT_NOUN_CLASS_UNDEFINED);
     const char *nounClass = fData->gender;
-
-    // if it is not exist, return `OTHER`
-    if (uprv_strcmp(nounClass, "") == 0) {
-        return NounClass::OTHER;
-    }
-
-    if (uprv_strcmp(nounClass, "neuter") == 0) {
-        return NounClass::NEUTER;
-    }
-
-    if (uprv_strcmp(nounClass, "feminine") == 0) {
-        return NounClass::FEMININE;
-    }
-
-    if (uprv_strcmp(nounClass, "masculine") == 0) {
-        return NounClass::MASCULINE;
-    }
-
-    if (uprv_strcmp(nounClass, "animate") == 0) {
-        return NounClass::ANIMATE;
-    }
-
-    if (uprv_strcmp(nounClass, "inanimate") == 0) {
-        return NounClass::INANIMATE;
-    }
-
-    if (uprv_strcmp(nounClass, "personal") == 0) {
-        return NounClass::PERSONAL;
-    }
-
-    if (uprv_strcmp(nounClass, "common") == 0) {
-        return NounClass::COMMON;
-    }
-
-    // In case there is no matching, this means there are noun classes
-    // that are not supported yet.
-    status = U_INTERNAL_PROGRAM_ERROR;
-    return NounClass::OTHER;
-}
-
-const char *FormattedNumber::getGender(UErrorCode &status) const {
-    UPRV_FORMATTED_VALUE_METHOD_GUARD("")
-    return fData->gender;
+    return udispopt_fromNounClassIdentifier(nounClass);
 }
 
 void FormattedNumber::getDecimalQuantity(impl::DecimalQuantity& output, UErrorCode& status) const {
diff --git a/deps/icu-small/source/i18n/number_patternmodifier.cpp b/deps/icu-small/source/i18n/number_patternmodifier.cpp
index b6543b262b..088a30ecd7 100644
--- a/deps/icu-small/source/i18n/number_patternmodifier.cpp
+++ b/deps/icu-small/source/i18n/number_patternmodifier.cpp
@@ -284,6 +284,7 @@ void MutablePatternModifier::prepareAffix(bool isPrefix) {
             fApproximately,
             fPlural,
             fPerMilleReplacesPercent,
+            false, // dropCurrencySymbols
             currentAffix);
 }
 
diff --git a/deps/icu-small/source/i18n/number_patternstring.cpp b/deps/icu-small/source/i18n/number_patternstring.cpp
index 2738895d8a..557a732085 100644
--- a/deps/icu-small/source/i18n/number_patternstring.cpp
+++ b/deps/icu-small/source/i18n/number_patternstring.cpp
@@ -1056,7 +1056,9 @@ void PatternStringUtils::patternInfoToStringBuilder(const AffixPatternProvider&
                                                     PatternSignType patternSignType,
                                                     bool approximately,
                                                     StandardPlural::Form plural,
-                                                    bool perMilleReplacesPercent, UnicodeString& output) {
+                                                    bool perMilleReplacesPercent,
+                                                    bool dropCurrencySymbols,
+                                                    UnicodeString& output) {
 
     // Should the output render '+' where '-' would normally appear in the pattern?
     bool plusReplacesMinusSign = (patternSignType == PATTERN_SIGN_TYPE_POS_SIGN)
@@ -1130,6 +1132,9 @@ void PatternStringUtils::patternInfoToStringBuilder(const AffixPatternProvider&
         if (perMilleReplacesPercent && candidate == u'%') {
             candidate = u'‰';
         }
+        if (dropCurrencySymbols && candidate == u'\u00A4') {
+            continue;
+        }
         output.append(candidate);
     }
 }
diff --git a/deps/icu-small/source/i18n/number_patternstring.h b/deps/icu-small/source/i18n/number_patternstring.h
index 94afda3722..0869669784 100644
--- a/deps/icu-small/source/i18n/number_patternstring.h
+++ b/deps/icu-small/source/i18n/number_patternstring.h
@@ -317,7 +317,9 @@ class U_I18N_API PatternStringUtils {
     static void patternInfoToStringBuilder(const AffixPatternProvider& patternInfo, bool isPrefix,
                                            PatternSignType patternSignType,
                                            bool approximately,
-                                           StandardPlural::Form plural, bool perMilleReplacesPercent,
+                                           StandardPlural::Form plural,
+                                           bool perMilleReplacesPercent,
+                                           bool dropCurrencySymbols,
                                            UnicodeString& output);
 
     static PatternSignType resolveSignDisplay(UNumberSignDisplay signDisplay, Signum signum);
diff --git a/deps/icu-small/source/i18n/number_skeletons.cpp b/deps/icu-small/source/i18n/number_skeletons.cpp
index c51831b682..3db50369cb 100644
--- a/deps/icu-small/source/i18n/number_skeletons.cpp
+++ b/deps/icu-small/source/i18n/number_skeletons.cpp
@@ -33,7 +33,7 @@ using namespace icu::number::impl::skeleton;
 
 namespace {
 
-icu::UInitOnce gNumberSkeletonsInitOnce = U_INITONCE_INITIALIZER;
+icu::UInitOnce gNumberSkeletonsInitOnce {};
 
 char16_t* kSerializedStemTrie = nullptr;
 
@@ -41,7 +41,7 @@ UBool U_CALLCONV cleanupNumberSkeletons() {
     uprv_free(kSerializedStemTrie);
     kSerializedStemTrie = nullptr;
     gNumberSkeletonsInitOnce.reset();
-    return TRUE;
+    return true;
 }
 
 void U_CALLCONV initNumberSkeletons(UErrorCode& status) {
diff --git a/deps/icu-small/source/i18n/number_usageprefs.cpp b/deps/icu-small/source/i18n/number_usageprefs.cpp
index 5d93d12cce..26fdfafeea 100644
--- a/deps/icu-small/source/i18n/number_usageprefs.cpp
+++ b/deps/icu-small/source/i18n/number_usageprefs.cpp
@@ -153,7 +153,7 @@ UsagePrefsHandler::UsagePrefsHandler(const Locale &locale,
                                      const StringPiece usage,
                                      const MicroPropsGenerator *parent,
                                      UErrorCode &status)
-    : fUnitsRouter(inputUnit, StringPiece(locale.getCountry()), usage, status),
+    : fUnitsRouter(inputUnit, locale, usage, status),
       fParent(parent) {
 }
 
diff --git a/deps/icu-small/source/i18n/numfmt.cpp b/deps/icu-small/source/i18n/numfmt.cpp
index b8ce1c930f..9e841da74a 100644
--- a/deps/icu-small/source/i18n/numfmt.cpp
+++ b/deps/icu-small/source/i18n/numfmt.cpp
@@ -117,7 +117,7 @@ static const UChar * const gLastResortNumberPatterns[UNUM_FORMAT_STYLE_COUNT] =
     NULL,  // UNUM_SPELLOUT
     NULL,  // UNUM_ORDINAL
     NULL,  // UNUM_DURATION
-    NULL,  // UNUM_NUMBERING_SYSTEM
+    gLastResortDecimalPat,  // UNUM_NUMBERING_SYSTEM
     NULL,  // UNUM_PATTERN_RULEBASED
     gLastResortIsoCurrencyPat,  // UNUM_CURRENCY_ISO
     gLastResortPluralCurrencyPat,  // UNUM_CURRENCY_PLURAL
@@ -156,11 +156,11 @@ static const icu::number::impl::CldrPatternStyle gFormatCldrStyles[UNUM_FORMAT_S
 
 // Static hashtable cache of NumberingSystem objects used by NumberFormat
 static UHashtable * NumberingSystem_cache = NULL;
-static icu::UInitOnce gNSCacheInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gNSCacheInitOnce {};
 
 #if !UCONFIG_NO_SERVICE
 static icu::ICULocaleService* gService = NULL;
-static icu::UInitOnce gServiceInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gServiceInitOnce {};
 #endif
 
 /**
@@ -186,7 +186,7 @@ static UBool U_CALLCONV numfmt_cleanup(void) {
         uhash_close(NumberingSystem_cache);
         NumberingSystem_cache = NULL;
     }
-    return TRUE;
+    return true;
 }
 U_CDECL_END
 
@@ -229,13 +229,13 @@ SimpleNumberFormatFactory::getSupportedIDs(int32_t &count, UErrorCode& status) c
 // -------------------------------------
 // default constructor
 NumberFormat::NumberFormat()
-:   fGroupingUsed(TRUE),
+:   fGroupingUsed(true),
     fMaxIntegerDigits(gDefaultMaxIntegerDigits),
     fMinIntegerDigits(1),
     fMaxFractionDigits(3), // invariant, >= minFractionDigits
     fMinFractionDigits(0),
-    fParseIntegerOnly(FALSE),
-    fLenient(FALSE),
+    fParseIntegerOnly(false),
+    fLenient(false),
     fCapitalizationContext(UDISPCTX_CAPITALIZATION_NONE)
 {
     fCurrency[0] = 0;
@@ -294,39 +294,39 @@ NumberFormat::operator==(const Format& that) const
 #ifdef FMT_DEBUG
     // This code makes it easy to determine why two format objects that should
     // be equal aren't.
-    UBool first = TRUE;
+    UBool first = true;
     if (!Format::operator==(that)) {
-        if (first) { printf("[ "); first = FALSE; } else { printf(", "); }
+        if (first) { printf("[ "); first = false; } else { printf(", "); }
         debug("Format::!=");
     }
     if (!(fMaxIntegerDigits == other->fMaxIntegerDigits &&
           fMinIntegerDigits == other->fMinIntegerDigits)) {
-        if (first) { printf("[ "); first = FALSE; } else { printf(", "); }
+        if (first) { printf("[ "); first = false; } else { printf(", "); }
         debug("Integer digits !=");
     }
     if (!(fMaxFractionDigits == other->fMaxFractionDigits &&
           fMinFractionDigits == other->fMinFractionDigits)) {
-        if (first) { printf("[ "); first = FALSE; } else { printf(", "); }
+        if (first) { printf("[ "); first = false; } else { printf(", "); }
         debug("Fraction digits !=");
     }
     if (!(fGroupingUsed == other->fGroupingUsed)) {
-        if (first) { printf("[ "); first = FALSE; } else { printf(", "); }
+        if (first) { printf("[ "); first = false; } else { printf(", "); }
         debug("fGroupingUsed != ");
     }
     if (!(fParseIntegerOnly == other->fParseIntegerOnly)) {
-        if (first) { printf("[ "); first = FALSE; } else { printf(", "); }
+        if (first) { printf("[ "); first = false; } else { printf(", "); }
         debug("fParseIntegerOnly != ");
     }
     if (!(u_strcmp(fCurrency, other->fCurrency) == 0)) {
-        if (first) { printf("[ "); first = FALSE; } else { printf(", "); }
+        if (first) { printf("[ "); first = false; } else { printf(", "); }
         debug("fCurrency !=");
     }
     if (!(fLenient == other->fLenient)) {
-        if (first) { printf("[ "); first = FALSE; } else { printf(", "); }
+        if (first) { printf("[ "); first = false; } else { printf(", "); }
         debug("fLenient != ");
     }
     if (!(fCapitalizationContext == other->fCapitalizationContext)) {
-        if (first) { printf("[ "); first = FALSE; } else { printf(", "); }
+        if (first) { printf("[ "); first = false; } else { printf(", "); }
         debug("fCapitalizationContext != ");
     }
     if (!first) { printf(" ]"); }
@@ -502,7 +502,7 @@ ArgExtractor::iso(void) const {
 }
 
 ArgExtractor::ArgExtractor(const NumberFormat& /*nf*/, const Formattable& obj, UErrorCode& /*status*/)
-  : num(&obj), fWasCurrency(FALSE) {
+  : num(&obj), fWasCurrency(false) {
 
     const UObject* o = obj.getObject(); // most commonly o==NULL
     const CurrencyAmount* amt;
@@ -512,7 +512,7 @@ ArgExtractor::ArgExtractor(const NumberFormat& /*nf*/, const Formattable& obj, U
         //const UChar* curr = amt->getISOCurrency();
         u_strcpy(save, amt->getISOCurrency());
         num = &amt->getNumber();
-        fWasCurrency=TRUE;
+        fWasCurrency=true;
     } else {
       save[0]=0;
     }
@@ -1007,13 +1007,13 @@ UBool U_EXPORT2
 NumberFormat::unregister(URegistryKey key, UErrorCode& status)
 {
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
     if (haveService()) {
         return gService->unregister(key, status);
     } else {
         status = U_ILLEGAL_ARGUMENT_ERROR;
-        return FALSE;
+        return false;
     }
 }
 
@@ -1310,6 +1310,14 @@ NumberFormat::makeInstance(const Locale& desiredLocale,
         status = U_ILLEGAL_ARGUMENT_ERROR;
         return NULL;
     }
+    
+    // For the purposes of general number formatting, UNUM_NUMBERING_SYSTEM should behave the same
+    // was as UNUM_DECIMAL.  In both cases, you get either a DecimalFormat or a RuleBasedNumberFormat
+    // depending on the locale's numbering system (either the default one for the locale or a specific
+    // one specified by using the "@numbers=" or "-u-nu-" parameter in the locale ID.
+    if (style == UNUM_NUMBERING_SYSTEM) {
+        style = UNUM_DECIMAL;
+    }
 
     // Some styles are not supported. This is a result of merging
     // the @draft ICU 4.2 NumberFormat::EStyles into the long-existing UNumberFormatStyle.
@@ -1329,11 +1337,11 @@ NumberFormat::makeInstance(const Locale& desiredLocale,
 
         // if the locale has "@compat=host", create a host-specific NumberFormat
         if (U_SUCCESS(status) && count > 0 && uprv_strcmp(buffer, "host") == 0) {
-            UBool curr = TRUE;
+            UBool curr = true;
 
             switch (style) {
             case UNUM_DECIMAL:
-                curr = FALSE;
+                curr = false;
                 // fall-through
                 U_FALLTHROUGH;
 
@@ -1407,7 +1415,7 @@ NumberFormat::makeInstance(const Locale& desiredLocale,
                 ns->getName(),
                 gFormatCldrStyles[style],
                 status);
-        pattern = UnicodeString(TRUE, patternPtr, -1);
+        pattern = UnicodeString(true, patternPtr, -1);
     }
     if (U_FAILURE(status)) {
         return NULL;
@@ -1460,8 +1468,8 @@ NumberFormat::makeInstance(const Locale& desiredLocale,
         // replace single currency sign in the pattern with double currency sign
         // if the style is UNUM_CURRENCY_ISO
         if (style == UNUM_CURRENCY_ISO) {
-            pattern.findAndReplace(UnicodeString(TRUE, gSingleCurrencySign, 1),
-                                   UnicodeString(TRUE, gDoubleCurrencySign, 2));
+            pattern.findAndReplace(UnicodeString(true, gSingleCurrencySign, 1),
+                                   UnicodeString(true, gDoubleCurrencySign, 2));
         }
 
         // "new DecimalFormat()" does not adopt the symbols argument if its memory allocation fails.
diff --git a/deps/icu-small/source/i18n/numparse_affixes.cpp b/deps/icu-small/source/i18n/numparse_affixes.cpp
index 1414006598..ad3d48b473 100644
--- a/deps/icu-small/source/i18n/numparse_affixes.cpp
+++ b/deps/icu-small/source/i18n/numparse_affixes.cpp
@@ -169,6 +169,10 @@ NumberParseMatcher* AffixTokenMatcherWarehouse::nextCodePointMatcher(UChar32 cp,
     return result;
 }
 
+bool AffixTokenMatcherWarehouse::hasEmptyCurrencySymbol() const {
+    return fSetupData->currencySymbols.hasEmptyCurrencySymbol();
+}
+
 
 CodePointMatcher::CodePointMatcher(UChar32 cp)
         : fCp(cp) {}
@@ -280,8 +284,16 @@ void AffixMatcherWarehouse::createAffixMatchers(const AffixPatternProvider& patt
     AffixPatternMatcher* posSuffix = nullptr;
 
     // Pre-process the affix strings to resolve LDML rules like sign display.
-    for (int8_t typeInt = 0; typeInt < PATTERN_SIGN_TYPE_COUNT; typeInt++) {
-        auto type = static_cast<PatternSignType>(typeInt);
+    for (int8_t typeInt = 0; typeInt < PATTERN_SIGN_TYPE_COUNT * 2; typeInt++) {
+        auto type = static_cast<PatternSignType>(typeInt / 2);
+        bool dropCurrencySymbols = (typeInt % 2) == 1;
+
+        if (dropCurrencySymbols && !patternInfo.hasCurrencySign()) {
+            continue;
+        }
+        if (dropCurrencySymbols && !fTokenWarehouse->hasEmptyCurrencySymbol()) {
+            continue;
+        }
 
         // Skip affixes in some cases
         if (type == PATTERN_SIGN_TYPE_POS
@@ -297,7 +309,7 @@ void AffixMatcherWarehouse::createAffixMatchers(const AffixPatternProvider& patt
         // TODO: Handle approximately sign?
         bool hasPrefix = false;
         PatternStringUtils::patternInfoToStringBuilder(
-                patternInfo, true, type, false, StandardPlural::OTHER, false, sb);
+                patternInfo, true, type, false, StandardPlural::OTHER, false, dropCurrencySymbols, sb);
         fAffixPatternMatchers[numAffixPatternMatchers] = AffixPatternMatcher::fromAffixPattern(
                 sb, *fTokenWarehouse, parseFlags, &hasPrefix, status);
         AffixPatternMatcher* prefix = hasPrefix ? &fAffixPatternMatchers[numAffixPatternMatchers++]
@@ -307,7 +319,7 @@ void AffixMatcherWarehouse::createAffixMatchers(const AffixPatternProvider& patt
         // TODO: Handle approximately sign?
         bool hasSuffix = false;
         PatternStringUtils::patternInfoToStringBuilder(
-                patternInfo, false, type, false, StandardPlural::OTHER, false, sb);
+                patternInfo, false, type, false, StandardPlural::OTHER, false, dropCurrencySymbols, sb);
         fAffixPatternMatchers[numAffixPatternMatchers] = AffixPatternMatcher::fromAffixPattern(
                 sb, *fTokenWarehouse, parseFlags, &hasSuffix, status);
         AffixPatternMatcher* suffix = hasSuffix ? &fAffixPatternMatchers[numAffixPatternMatchers++]
diff --git a/deps/icu-small/source/i18n/numparse_affixes.h b/deps/icu-small/source/i18n/numparse_affixes.h
index a82b731ab5..ad731ed5d8 100644
--- a/deps/icu-small/source/i18n/numparse_affixes.h
+++ b/deps/icu-small/source/i18n/numparse_affixes.h
@@ -101,6 +101,8 @@ class U_I18N_API AffixTokenMatcherWarehouse : public UMemory {
 
     NumberParseMatcher* nextCodePointMatcher(UChar32 cp, UErrorCode& status);
 
+    bool hasEmptyCurrencySymbol() const;
+
   private:
     // NOTE: The following field may be unsafe to access after construction is done!
     const AffixTokenMatcherSetupData* fSetupData;
@@ -204,10 +206,12 @@ class AffixMatcherWarehouse {
                              UErrorCode& status);
 
   private:
-    // 9 is the limit: positive, zero, and negative, each with prefix, suffix, and prefix+suffix
-    AffixMatcher fAffixMatchers[9];
-    // 6 is the limit: positive, zero, and negative, a prefix and a suffix for each
-    AffixPatternMatcher fAffixPatternMatchers[6];
+    // 18 is the limit: positive, zero, and negative, each with prefix, suffix, and prefix+suffix,
+    // and doubled since there may be an empty currency symbol
+    AffixMatcher fAffixMatchers[18];
+    // 6 is the limit: positive, zero, and negative, a prefix and a suffix for each,
+    // and doubled since there may be an empty currency symbol
+    AffixPatternMatcher fAffixPatternMatchers[12];
     // Reference to the warehouse for tokens used by the AffixPatternMatchers
     AffixTokenMatcherWarehouse* fTokenWarehouse;
 
diff --git a/deps/icu-small/source/i18n/numrange_fluent.cpp b/deps/icu-small/source/i18n/numrange_fluent.cpp
index f1060b3c21..c36defa369 100644
--- a/deps/icu-small/source/i18n/numrange_fluent.cpp
+++ b/deps/icu-small/source/i18n/numrange_fluent.cpp
@@ -354,6 +354,7 @@ LocalizedNumberRangeFormatter::getFormatter(UErrorCode& status) const {
     // Try computing the formatter on our own
     auto* temp = new NumberRangeFormatterImpl(fMacros, status);
     if (U_FAILURE(status)) {
+        delete temp;
         return nullptr;
     }
     if (temp == nullptr) {
diff --git a/deps/icu-small/source/i18n/numrange_impl.cpp b/deps/icu-small/source/i18n/numrange_impl.cpp
index 3c440c193c..06efc7b281 100644
--- a/deps/icu-small/source/i18n/numrange_impl.cpp
+++ b/deps/icu-small/source/i18n/numrange_impl.cpp
@@ -130,7 +130,7 @@ NumberRangeFormatterImpl::NumberRangeFormatterImpl(const RangeMacroProps& macros
       fApproximatelyFormatter(status) {
 
     const char* nsName = formatterImpl1.getRawMicroProps().nsName;
-    if (uprv_strcmp(nsName, formatterImpl2.getRawMicroProps().nsName) != 0) {
+    if (!fSameFormatters && uprv_strcmp(nsName, formatterImpl2.getRawMicroProps().nsName) != 0) {
         status = U_ILLEGAL_ARGUMENT_ERROR;
         return;
     }
diff --git a/deps/icu-small/source/i18n/numsys.cpp b/deps/icu-small/source/i18n/numsys.cpp
index 934149039c..015d2a4cb6 100644
--- a/deps/icu-small/source/i18n/numsys.cpp
+++ b/deps/icu-small/source/i18n/numsys.cpp
@@ -61,7 +61,7 @@ UOBJECT_DEFINE_RTTI_IMPLEMENTATION(NumsysNameEnumeration)
 
 NumberingSystem::NumberingSystem() {
      radix = 10;
-     algorithmic = FALSE;
+     algorithmic = false;
      UnicodeString defaultDigits = DEFAULT_DIGITS;
      desc.setTo(defaultDigits);
      uprv_strcpy(name,gLatn);
@@ -116,8 +116,8 @@ NumberingSystem::createInstance(const Locale & inLocale, UErrorCode& status) {
         return nullptr;
     }
 
-    UBool nsResolved = TRUE;
-    UBool usingFallback = FALSE;
+    UBool nsResolved = true;
+    UBool usingFallback = false;
     char buffer[ULOC_KEYWORDS_CAPACITY] = "";
     int32_t count = inLocale.getKeywordValue("numbers", buffer, sizeof(buffer), status);
     if (U_FAILURE(status) || status == U_STRING_NOT_TERMINATED_WARNING) {
@@ -130,11 +130,11 @@ NumberingSystem::createInstance(const Locale & inLocale, UErrorCode& status) {
         buffer[count] = '\0'; // Make sure it is null terminated.
         if ( !uprv_strcmp(buffer,gDefault) || !uprv_strcmp(buffer,gNative) || 
              !uprv_strcmp(buffer,gTraditional) || !uprv_strcmp(buffer,gFinance)) {
-            nsResolved = FALSE;
+            nsResolved = false;
         }
     } else {
         uprv_strcpy(buffer, gDefault);
-        nsResolved = FALSE;
+        nsResolved = false;
     }
 
     if (!nsResolved) { // Resolve the numbering system ( default, native, traditional or finance ) into a "real" numbering system
@@ -158,7 +158,7 @@ NumberingSystem::createInstance(const Locale & inLocale, UErrorCode& status) {
             if ( count > 0 && count < ULOC_KEYWORDS_CAPACITY ) { // numbering system found
                 u_UCharsToChars(nsName, buffer, count);
                 buffer[count] = '\0'; // Make sure it is null terminated.
-                nsResolved = TRUE;
+                nsResolved = true;
             } 
 
             if (!nsResolved) { // Fallback behavior per TR35 - traditional falls back to native, finance and native fall back to default
@@ -167,8 +167,8 @@ NumberingSystem::createInstance(const Locale & inLocale, UErrorCode& status) {
                 } else if (!uprv_strcmp(buffer,gTraditional)) {
                     uprv_strcpy(buffer,gNative);
                 } else { // If we get here we couldn't find even the default numbering system
-                    usingFallback = TRUE;
-                    nsResolved = TRUE;
+                    usingFallback = true;
+                    nsResolved = true;
                 }
             }
         }
@@ -271,7 +271,7 @@ UBool NumberingSystem::isAlgorithmic() const {
 namespace {
 
 UVector* gNumsysNames = nullptr;
-UInitOnce gNumSysInitOnce = U_INITONCE_INITIALIZER;
+UInitOnce gNumSysInitOnce {};
 
 U_CFUNC UBool U_CALLCONV numSysCleanup() {
     delete gNumsysNames;
diff --git a/deps/icu-small/source/i18n/olsontz.cpp b/deps/icu-small/source/i18n/olsontz.cpp
index cae471a5a2..e5c60f8cbe 100644
--- a/deps/icu-small/source/i18n/olsontz.cpp
+++ b/deps/icu-small/source/i18n/olsontz.cpp
@@ -53,13 +53,13 @@ static void debug_tz_msg(const char *pat, ...)
 
 static UBool arrayEqual(const void *a1, const void *a2, int32_t size) {
     if (a1 == NULL && a2 == NULL) {
-        return TRUE;
+        return true;
     }
     if ((a1 != NULL && a2 == NULL) || (a1 == NULL && a2 != NULL)) {
-        return FALSE;
+        return false;
     }
     if (a1 == a2) {
-        return TRUE;
+        return true;
     }
 
     return (uprv_memcmp(a1, a2, size) == 0);
@@ -87,7 +87,7 @@ UOBJECT_DEFINE_RTTI_IMPLEMENTATION(OlsonTimeZone)
  * Default constructor.  Creates a time zone with an empty ID and
  * a fixed GMT offset of zero.
  */
-/*OlsonTimeZone::OlsonTimeZone() : finalYear(INT32_MAX), finalMillis(DBL_MAX), finalZone(0), transitionRulesInitialized(FALSE) {
+/*OlsonTimeZone::OlsonTimeZone() : finalYear(INT32_MAX), finalMillis(DBL_MAX), finalZone(0), transitionRulesInitialized(false) {
     clearTransitionRules();
     constructEmpty();
 }*/
@@ -204,7 +204,7 @@ OlsonTimeZone::OlsonTimeZone(const UResourceBundle* top,
             ures_getByKey(res, kFINALYEAR, r.getAlias(), &ec);
             int32_t ruleYear = ures_getInt(r.getAlias(), &ec);
             if (U_SUCCESS(ec)) {
-                UnicodeString ruleID(TRUE, ruleIdUStr, len);
+                UnicodeString ruleID(true, ruleIdUStr, len);
                 UResourceBundle *rule = TimeZone::loadRule(top, ruleID, NULL, ec);
                 const int32_t *ruleData = ures_getIntVector(rule, &len, &ec); 
                 if (U_SUCCESS(ec) && len == 11) {
@@ -381,7 +381,7 @@ int32_t OlsonTimeZone::getOffset(uint8_t era, int32_t year, int32_t month,
     // Compute local epoch millis from input fields
     UDate date = (UDate)(Grego::fieldsToDay(year, month, dom) * U_MILLIS_PER_DAY + millis);
     int32_t rawoff, dstoff;
-    getHistoricalOffset(date, TRUE, kDaylight, kStandard, rawoff, dstoff);
+    getHistoricalOffset(date, true, kDaylight, kStandard, rawoff, dstoff);
     return rawoff + dstoff;
 }
 
@@ -409,7 +409,7 @@ void OlsonTimeZone::getOffsetFromLocal(UDate date, UTimeZoneLocalOption nonExist
     if (finalZone != NULL && date >= finalStartMillis) {
         finalZone->getOffsetFromLocal(date, nonExistingTimeOpt, duplicatedTimeOpt, rawoff, dstoff, ec);
     } else {
-        getHistoricalOffset(date, TRUE, nonExistingTimeOpt, duplicatedTimeOpt, rawoff, dstoff);
+        getHistoricalOffset(date, true, nonExistingTimeOpt, duplicatedTimeOpt, rawoff, dstoff);
     }
 }
 
@@ -430,8 +430,7 @@ void OlsonTimeZone::setRawOffset(int32_t /*offsetMillis*/) {
 int32_t OlsonTimeZone::getRawOffset() const {
     UErrorCode ec = U_ZERO_ERROR;
     int32_t raw, dst;
-    getOffset((double) uprv_getUTCtime() * U_MILLIS_PER_SECOND,
-              FALSE, raw, dst, ec);
+    getOffset(uprv_getUTCtime(), false, raw, dst, ec);
     return raw;
 }
 
@@ -560,9 +559,9 @@ OlsonTimeZone::getHistoricalOffset(UDate date, UBool local,
 UBool OlsonTimeZone::useDaylightTime() const {
     // If DST was observed in 1942 (for example) but has never been
     // observed from 1943 to the present, most clients will expect
-    // this method to return FALSE.  This method determines whether
+    // this method to return false.  This method determines whether
     // DST is in use in the current year (at any point in the year)
-    // and returns TRUE if so.
+    // and returns true if so.
 
     UDate current = uprv_getUTCtime();
     if (finalZone != NULL && current >= finalStartMillis) {
@@ -576,7 +575,7 @@ UBool OlsonTimeZone::useDaylightTime() const {
     double start = Grego::fieldsToDay(year, 0, 1) * SECONDS_PER_DAY;
     double limit = Grego::fieldsToDay(year+1, 0, 1) * SECONDS_PER_DAY;
 
-    // Return TRUE if DST is observed at any time during the current
+    // Return true if DST is observed at any time during the current
     // year.
     for (int16_t i = 0; i < transitionCount(); ++i) {
         double transition = (double)transitionTimeInSeconds(i);
@@ -585,10 +584,10 @@ UBool OlsonTimeZone::useDaylightTime() const {
         }
         if ((transition >= start && dstOffsetAt(i) != 0)
                 || (transition > start && dstOffsetAt(i - 1) != 0)) {
-            return TRUE;
+            return true;
         }
     }
-    return FALSE;
+    return false;
 }
 int32_t 
 OlsonTimeZone::getDSTSavings() const{
@@ -602,25 +601,25 @@ OlsonTimeZone::getDSTSavings() const{
  */
 UBool OlsonTimeZone::inDaylightTime(UDate date, UErrorCode& ec) const {
     int32_t raw, dst;
-    getOffset(date, FALSE, raw, dst, ec);
+    getOffset(date, false, raw, dst, ec);
     return dst != 0;
 }
 
 UBool
 OlsonTimeZone::hasSameRules(const TimeZone &other) const {
     if (this == &other) {
-        return TRUE;
+        return true;
     }
     const OlsonTimeZone* z = dynamic_cast<const OlsonTimeZone*>(&other);
     if (z == NULL) {
-        return FALSE;
+        return false;
     }
 
     // [sic] pointer comparison: typeMapData points into
     // memory-mapped or DLL space, so if two zones have the same
     // pointer, they are equal.
     if (typeMapData == z->typeMapData) {
-        return TRUE;
+        return true;
     }
     
     // If the pointers are not equal, the zones may still
@@ -628,19 +627,19 @@ OlsonTimeZone::hasSameRules(const TimeZone &other) const {
     if ((finalZone == NULL && z->finalZone != NULL)
         || (finalZone != NULL && z->finalZone == NULL)
         || (finalZone != NULL && z->finalZone != NULL && *finalZone != *z->finalZone)) {
-        return FALSE;
+        return false;
     }
 
     if (finalZone != NULL) {
         if (finalStartYear != z->finalStartYear || finalStartMillis != z->finalStartMillis) {
-            return FALSE;
+            return false;
         }
     }
     if (typeCount != z->typeCount
         || transitionCountPre32 != z->transitionCountPre32
         || transitionCount32 != z->transitionCount32
         || transitionCountPost32 != z->transitionCountPost32) {
-        return FALSE;
+        return false;
     }
 
     return
@@ -882,20 +881,20 @@ OlsonTimeZone::getNextTransition(UDate base, UBool inclusive, TimeZoneTransition
     UErrorCode status = U_ZERO_ERROR;
     checkTransitionRules(status);
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
 
     if (finalZone != NULL) {
         if (inclusive && base == firstFinalTZTransition->getTime()) {
             result = *firstFinalTZTransition;
-            return TRUE;
+            return true;
         } else if (base >= firstFinalTZTransition->getTime()) {
             if (finalZone->useDaylightTime()) {
                 //return finalZone->getNextTransition(base, inclusive, result);
                 return finalZoneWithStartYear->getNextTransition(base, inclusive, result);
             } else {
                 // No more transitions
-                return FALSE;
+                return false;
             }
         }
     }
@@ -912,13 +911,13 @@ OlsonTimeZone::getNextTransition(UDate base, UBool inclusive, TimeZoneTransition
         if (ttidx == transCount - 1)  {
             if (firstFinalTZTransition != NULL) {
                 result = *firstFinalTZTransition;
-                return TRUE;
+                return true;
             } else {
-                return FALSE;
+                return false;
             }
         } else if (ttidx < firstTZTransitionIdx) {
             result = *firstTZTransition;
-            return TRUE;
+            return true;
         } else {
             // Create a TimeZoneTransition
             TimeZoneRule *to = historicRules[typeMapData[ttidx + 1]];
@@ -936,10 +935,10 @@ OlsonTimeZone::getNextTransition(UDate base, UBool inclusive, TimeZoneTransition
             result.setTime(startTime);
             result.adoptFrom(from->clone());
             result.adoptTo(to->clone());
-            return TRUE;
+            return true;
         }
     }
-    return FALSE;
+    return false;
 }
 
 UBool
@@ -947,20 +946,20 @@ OlsonTimeZone::getPreviousTransition(UDate base, UBool inclusive, TimeZoneTransi
     UErrorCode status = U_ZERO_ERROR;
     checkTransitionRules(status);
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
 
     if (finalZone != NULL) {
         if (inclusive && base == firstFinalTZTransition->getTime()) {
             result = *firstFinalTZTransition;
-            return TRUE;
+            return true;
         } else if (base > firstFinalTZTransition->getTime()) {
             if (finalZone->useDaylightTime()) {
                 //return finalZone->getPreviousTransition(base, inclusive, result);
                 return finalZoneWithStartYear->getPreviousTransition(base, inclusive, result);
             } else {
                 result = *firstFinalTZTransition;
-                return TRUE;
+                return true;
             }
         }
     }
@@ -976,10 +975,10 @@ OlsonTimeZone::getPreviousTransition(UDate base, UBool inclusive, TimeZoneTransi
         }
         if (ttidx < firstTZTransitionIdx) {
             // No more transitions
-            return FALSE;
+            return false;
         } else if (ttidx == firstTZTransitionIdx) {
             result = *firstTZTransition;
-            return TRUE;
+            return true;
         } else {
             // Create a TimeZoneTransition
             TimeZoneRule *to = historicRules[typeMapData[ttidx]];
@@ -997,10 +996,10 @@ OlsonTimeZone::getPreviousTransition(UDate base, UBool inclusive, TimeZoneTransi
             result.setTime(startTime);
             result.adoptFrom(from->clone());
             result.adoptTo(to->clone());
-            return TRUE;
+            return true;
         }
     }
-    return FALSE;
+    return false;
 }
 
 int32_t
diff --git a/deps/icu-small/source/i18n/olsontz.h b/deps/icu-small/source/i18n/olsontz.h
index 75d86781ed..525bbd2b12 100644
--- a/deps/icu-small/source/i18n/olsontz.h
+++ b/deps/icu-small/source/i18n/olsontz.h
@@ -400,7 +400,7 @@ private:
     TimeArrayTimeZoneRule   **historicRules;
     int16_t             historicRuleCount;
     SimpleTimeZone      *finalZoneWithStartYear; // hack
-    UInitOnce           transitionRulesInitOnce = U_INITONCE_INITIALIZER;
+    UInitOnce           transitionRulesInitOnce {};
 };
 
 inline int16_t
diff --git a/deps/icu-small/source/i18n/persncal.cpp b/deps/icu-small/source/i18n/persncal.cpp
index d30577f337..9db47c9891 100644
--- a/deps/icu-small/source/i18n/persncal.cpp
+++ b/deps/icu-small/source/i18n/persncal.cpp
@@ -110,7 +110,7 @@ int32_t PersianCalendar::handleGetLimit(UCalendarDateFields field, ELimitType li
 UBool PersianCalendar::isLeapYear(int32_t year)
 {
     int32_t remainder;
-    ClockMath::floorDivide(25 * year + 11, 33, remainder);
+    ClockMath::floorDivide(25 * year + 11, 33, &remainder);
     return (remainder < 8);
 }
     
@@ -119,7 +119,7 @@ UBool PersianCalendar::isLeapYear(int32_t year)
  * from the Persian epoch, origin 0.
  */
 int32_t PersianCalendar::yearStart(int32_t year) {
-    return handleComputeMonthStart(year,0,FALSE);
+    return handleComputeMonthStart(year,0,false);
 }
     
 /**
@@ -130,7 +130,7 @@ int32_t PersianCalendar::yearStart(int32_t year) {
  * @param year  The Persian month, 0-based
  */
 int32_t PersianCalendar::monthStart(int32_t year, int32_t month) const {
-    return handleComputeMonthStart(year,month,TRUE);
+    return handleComputeMonthStart(year,month,true);
 }
     
 //----------------------------------------------------------------------
@@ -147,7 +147,7 @@ int32_t PersianCalendar::handleGetMonthLength(int32_t extendedYear, int32_t mont
     // If the month is out of range, adjust it into range, and
     // modify the extended year value accordingly.
     if (month < 0 || month > 11) {
-        extendedYear += ClockMath::floorDivide(month, 12, month);
+        extendedYear += ClockMath::floorDivide(month, 12, &month);
     }
 
     return isLeapYear(extendedYear) ? kPersianLeapMonthLength[month] : kPersianMonthLength[month];
@@ -169,7 +169,7 @@ int32_t PersianCalendar::handleComputeMonthStart(int32_t eyear, int32_t month, U
     // If the month is out of range, adjust it into range, and
     // modify the extended year value accordingly.
     if (month < 0 || month > 11) {
-        eyear += ClockMath::floorDivide(month, 12, month);
+        eyear += ClockMath::floorDivide(month, 12, &month);
     }
 
     int32_t julianDay = PERSIAN_EPOCH - 1 + 365 * (eyear - 1) + ClockMath::floorDivide(8 * eyear + 21, 33);
@@ -238,23 +238,23 @@ PersianCalendar::inDaylightTime(UErrorCode& status) const
 {
     // copied from GregorianCalendar
     if (U_FAILURE(status) || !getTimeZone().useDaylightTime()) 
-        return FALSE;
+        return false;
 
     // Force an update of the state of the Calendar.
     ((PersianCalendar*)this)->complete(status); // cast away const
 
-    return (UBool)(U_SUCCESS(status) ? (internalGet(UCAL_DST_OFFSET) != 0) : FALSE);
+    return (UBool)(U_SUCCESS(status) ? (internalGet(UCAL_DST_OFFSET) != 0) : false);
 }
 
 // default century
 
 static UDate           gSystemDefaultCenturyStart       = DBL_MIN;
 static int32_t         gSystemDefaultCenturyStartYear   = -1;
-static icu::UInitOnce  gSystemDefaultCenturyInit        = U_INITONCE_INITIALIZER;
+static icu::UInitOnce  gSystemDefaultCenturyInit        {};
 
 UBool PersianCalendar::haveDefaultCentury() const
 {
-    return TRUE;
+    return true;
 }
 
 static void U_CALLCONV initializeSystemDefaultCentury() {
diff --git a/deps/icu-small/source/i18n/plurfmt.cpp b/deps/icu-small/source/i18n/plurfmt.cpp
index 65e275eeeb..3b8f3a660e 100644
--- a/deps/icu-small/source/i18n/plurfmt.cpp
+++ b/deps/icu-small/source/i18n/plurfmt.cpp
@@ -434,11 +434,11 @@ int32_t PluralFormat::findSubMessage(const MessagePattern& pattern, int32_t part
     // (In other words, we never call the selector if we match against an explicit value,
     // or if the only non-explicit keyword is "other".)
     UnicodeString keyword;
-    UnicodeString other(FALSE, OTHER_STRING, 5);
+    UnicodeString other(false, OTHER_STRING, 5);
     // When we find a match, we set msgStart>0 and also set this boolean to true
     // to avoid matching the keyword again (duplicates are allowed)
     // while we continue to look for an explicit-value match.
-    UBool haveKeywordMatch=FALSE;
+    UBool haveKeywordMatch=false;
     // msgStart is 0 until we find any appropriate sub-message.
     // We remember the first "other" sub-message if we have not seen any
     // appropriate sub-message before.
@@ -477,7 +477,7 @@ int32_t PluralFormat::findSubMessage(const MessagePattern& pattern, int32_t part
                         // This is the first "other" sub-message,
                         // and the selected keyword is also "other".
                         // Do not match "other" again.
-                        haveKeywordMatch=TRUE;
+                        haveKeywordMatch=true;
                     }
                 }
             } else {
@@ -486,7 +486,7 @@ int32_t PluralFormat::findSubMessage(const MessagePattern& pattern, int32_t part
                     if(msgStart!=0 && (0 == keyword.compare(other))) {
                         // We have already seen an "other" sub-message.
                         // Do not match "other" again.
-                        haveKeywordMatch=TRUE;
+                        haveKeywordMatch=true;
                         // Skip keyword matching but do getLimitPartIndex().
                     }
                 }
@@ -494,7 +494,7 @@ int32_t PluralFormat::findSubMessage(const MessagePattern& pattern, int32_t part
                     // keyword matches
                     msgStart=partIndex;
                     // Do not match this keyword again.
-                    haveKeywordMatch=TRUE;
+                    haveKeywordMatch=true;
                 }
             }
         }
diff --git a/deps/icu-small/source/i18n/plurrule.cpp b/deps/icu-small/source/i18n/plurrule.cpp
index 7d1037f8bd..431a3ce04b 100644
--- a/deps/icu-small/source/i18n/plurrule.cpp
+++ b/deps/icu-small/source/i18n/plurrule.cpp
@@ -26,6 +26,7 @@
 #include "hash.h"
 #include "locutil.h"
 #include "mutex.h"
+#include "number_decnum.h"
 #include "patternprops.h"
 #include "plurrule_impl.h"
 #include "putilimp.h"
@@ -45,7 +46,9 @@
 U_NAMESPACE_BEGIN
 
 using namespace icu::pluralimpl;
+using icu::number::impl::DecNum;
 using icu::number::impl::DecimalQuantity;
+using icu::number::impl::RoundingMode;
 
 static const UChar PLURAL_KEYWORD_OTHER[]={LOW_O,LOW_T,LOW_H,LOW_E,LOW_R,0};
 static const UChar PLURAL_DEFAULT_RULE[]={LOW_O,LOW_T,LOW_H,LOW_E,LOW_R,COLON,SPACE,LOW_N,0};
@@ -176,7 +179,7 @@ PluralRules::createRules(const UnicodeString& description, UErrorCode& status) {
 
 PluralRules* U_EXPORT2
 PluralRules::createDefaultRules(UErrorCode& status) {
-    return createRules(UnicodeString(TRUE, PLURAL_DEFAULT_RULE, -1), status);
+    return createRules(UnicodeString(true, PLURAL_DEFAULT_RULE, -1), status);
 }
 
 /******************************************************************************/
@@ -304,7 +307,7 @@ PluralRules::select(const number::FormattedNumber& number, UErrorCode& status) c
 UnicodeString
 PluralRules::select(const IFixedDecimal &number) const {
     if (mRules == nullptr) {
-        return UnicodeString(TRUE, PLURAL_DEFAULT_RULE, -1);
+        return UnicodeString(true, PLURAL_DEFAULT_RULE, -1);
     }
     else {
         return mRules->select(number);
@@ -369,36 +372,18 @@ PluralRules::getAllKeywordValues(const UnicodeString & /* keyword */, double * /
     return 0;
 }
 
-
-static double scaleForInt(double d) {
-    double scale = 1.0;
-    while (d != floor(d)) {
-        d = d * 10.0;
-        scale = scale * 10.0;
-    }
-    return scale;
-}
-
-static const double powers10[7] = {1.0, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0}; // powers of 10 for 0..6
-static double applyExponent(double source, int32_t exponent) {
-    if (exponent >= 0 && exponent <= 6) {
-        return source * powers10[exponent];
-    }
-    return source * pow(10.0, exponent);
-}
-
 /**
- * Helper method for the overrides of getSamples() for double and FixedDecimal
- * return value types.  Provide only one of an allocated array of doubles or
- * FixedDecimals, and a nullptr for the other.
+ * Helper method for the overrides of getSamples() for double and DecimalQuantity
+ * return value types.  Provide only one of an allocated array of double or
+ * DecimalQuantity, and a nullptr for the other.
  */
 static int32_t
 getSamplesFromString(const UnicodeString &samples, double *destDbl,
-                        FixedDecimal* destFd, int32_t destCapacity,
+                        DecimalQuantity* destDq, int32_t destCapacity,
                         UErrorCode& status) {
 
-    if ((destDbl == nullptr && destFd == nullptr)
-            || (destDbl != nullptr && destFd != nullptr)) {
+    if ((destDbl == nullptr && destDq == nullptr)
+            || (destDbl != nullptr && destDq != nullptr)) {
         status = U_INTERNAL_PROGRAM_ERROR;
         return 0;
     }
@@ -420,58 +405,75 @@ getSamplesFromString(const UnicodeString &samples, double *destDbl,
         // std::cout << "PluralRules::getSamples(), samplesRange = \"" << sampleRange.toUTF8String(ss) << "\"\n";
         int32_t tildeIndex = sampleRange.indexOf(TILDE);
         if (tildeIndex < 0) {
-            FixedDecimal fixed(sampleRange, status);
+            DecimalQuantity dq = DecimalQuantity::fromExponentString(sampleRange, status);
             if (isDouble) {
-                double sampleValue = fixed.source;
-                if (fixed.visibleDecimalDigitCount == 0 || sampleValue != floor(sampleValue)) {
-                    destDbl[sampleCount++] = applyExponent(sampleValue, fixed.exponent);
+                // See warning note below about lack of precision for floating point samples for numbers with
+                // trailing zeroes in the decimal fraction representation.
+                double dblValue = dq.toDouble();
+                if (!(dblValue == floor(dblValue) && dq.fractionCount() > 0)) {
+                    destDbl[sampleCount++] = dblValue;
                 }
             } else {
-                destFd[sampleCount++] = fixed;
+                destDq[sampleCount++] = dq;
             }
         } else {
-            FixedDecimal fixedLo(sampleRange.tempSubStringBetween(0, tildeIndex), status);
-            FixedDecimal fixedHi(sampleRange.tempSubStringBetween(tildeIndex+1), status);
-            double rangeLo = fixedLo.source;
-            double rangeHi = fixedHi.source;
+            DecimalQuantity rangeLo =
+                DecimalQuantity::fromExponentString(sampleRange.tempSubStringBetween(0, tildeIndex), status);
+            DecimalQuantity rangeHi = DecimalQuantity::fromExponentString(sampleRange.tempSubStringBetween(tildeIndex+1), status);
             if (U_FAILURE(status)) {
                 break;
             }
-            if (rangeHi < rangeLo) {
+            if (rangeHi.toDouble() < rangeLo.toDouble()) {
                 status = U_INVALID_FORMAT_ERROR;
                 break;
             }
 
-            // For ranges of samples with fraction decimal digits, scale the number up so that we
-            //   are adding one in the units place. Avoids roundoffs from repetitive adds of tenths.
+            DecimalQuantity incrementDq;
+            incrementDq.setToInt(1);
+            int32_t lowerDispMag = rangeLo.getLowerDisplayMagnitude();
+            int32_t exponent = rangeLo.getExponent();
+            int32_t incrementScale = lowerDispMag + exponent;
+            incrementDq.adjustMagnitude(incrementScale);
+            double incrementVal = incrementDq.toDouble();  // 10 ^ incrementScale
+            
 
-            double scale = scaleForInt(rangeLo);
-            double t = scaleForInt(rangeHi);
-            if (t > scale) {
-                scale = t;
-            }
-            rangeLo *= scale;
-            rangeHi *= scale;
-            for (double n=rangeLo; n<=rangeHi; n+=1) {
-                double sampleValue = n/scale;
+            DecimalQuantity dq(rangeLo);
+            double dblValue = dq.toDouble();
+            double end = rangeHi.toDouble();
+
+            while (dblValue <= end) {
                 if (isDouble) {
                     // Hack Alert: don't return any decimal samples with integer values that
                     //    originated from a format with trailing decimals.
                     //    This API is returning doubles, which can't distinguish having displayed
                     //    zeros to the right of the decimal.
                     //    This results in test failures with values mapping back to a different keyword.
-                    if (!(sampleValue == floor(sampleValue) && fixedLo.visibleDecimalDigitCount > 0)) {
-                        destDbl[sampleCount++] = sampleValue;
+                    if (!(dblValue == floor(dblValue) && dq.fractionCount() > 0)) {
+                        destDbl[sampleCount++] = dblValue;
                     }
                 } else {
-                    int32_t v = (int32_t) fixedLo.getPluralOperand(PluralOperand::PLURAL_OPERAND_V);
-                    int32_t e = (int32_t) fixedLo.getPluralOperand(PluralOperand::PLURAL_OPERAND_E);
-                    FixedDecimal newSample = FixedDecimal::createWithExponent(sampleValue, v, e);
-                    destFd[sampleCount++] = newSample;
+                    destDq[sampleCount++] = dq;
                 }
                 if (sampleCount >= destCapacity) {
                     break;
                 }
+
+                // Increment dq for next iteration
+
+                // Because DecNum and DecimalQuantity do not support
+                // add operations, we need to convert to/from double,
+                // despite precision lossiness for decimal fractions like 0.1.
+                dblValue += incrementVal;
+                DecNum newDqDecNum;
+                newDqDecNum.setTo(dblValue, status);
+                DecimalQuantity newDq;             
+                newDq.setToDecNum(newDqDecNum, status);
+                newDq.setMinFraction(-lowerDispMag);
+                newDq.roundToMagnitude(lowerDispMag, RoundingMode::UNUM_ROUND_HALFEVEN, status);
+                newDq.adjustMagnitude(-exponent);
+                newDq.adjustExponent(exponent);
+                dblValue = newDq.toDouble();
+                dq = newDq;
             }
         }
         sampleStartIdx = sampleEndIdx + 1;
@@ -505,7 +507,7 @@ PluralRules::getSamples(const UnicodeString &keyword, double *dest,
 }
 
 int32_t
-PluralRules::getSamples(const UnicodeString &keyword, FixedDecimal *dest,
+PluralRules::getSamples(const UnicodeString &keyword, DecimalQuantity *dest,
                         int32_t destCapacity, UErrorCode& status) {
     if (U_FAILURE(status)) {
         return 0;
@@ -552,7 +554,7 @@ PluralRules::isKeyword(const UnicodeString& keyword) const {
 
 UnicodeString
 PluralRules::getKeywordOther() const {
-    return UnicodeString(TRUE, PLURAL_KEYWORD_OTHER, 5);
+    return UnicodeString(true, PLURAL_KEYWORD_OTHER, 5);
 }
 
 bool
@@ -639,11 +641,11 @@ PluralRuleParser::parse(const UnicodeString& ruleData, PluralRules *prules, UErr
             break;
         case tNot:
             U_ASSERT(curAndConstraint != nullptr);
-            curAndConstraint->negated=TRUE;
+            curAndConstraint->negated=true;
             break;
 
         case tNotEqual:
-            curAndConstraint->negated=TRUE;
+            curAndConstraint->negated=true;
             U_FALLTHROUGH;
         case tIn:
         case tWithin:
@@ -759,7 +761,7 @@ PluralRuleParser::parse(const UnicodeString& ruleData, PluralRules *prules, UErr
                     break;
                 }
                 if (type == tEllipsis) {
-                    currentChain->fIntegerSamplesUnbounded = TRUE;
+                    currentChain->fIntegerSamplesUnbounded = true;
                     continue;
                 }
                 currentChain->fIntegerSamples.append(token);
@@ -773,7 +775,7 @@ PluralRuleParser::parse(const UnicodeString& ruleData, PluralRules *prules, UErr
                     break;
                 }
                 if (type == tEllipsis) {
-                    currentChain->fDecimalSamplesUnbounded = TRUE;
+                    currentChain->fDecimalSamplesUnbounded = true;
                     continue;
                 }
                 currentChain->fDecimalSamples.append(token);
@@ -917,10 +919,10 @@ AndConstraint::~AndConstraint() {
 
 UBool
 AndConstraint::isFulfilled(const IFixedDecimal &number) {
-    UBool result = TRUE;
+    UBool result = true;
     if (digitsType == none) {
         // An empty AndConstraint, created by a rule with a keyword but no following expression.
-        return TRUE;
+        return true;
     }
 
     PluralOperand operand = tokenTypeToPluralOperand(digitsType);
@@ -929,7 +931,7 @@ AndConstraint::isFulfilled(const IFixedDecimal &number) {
                                                      // May be non-integer (n option only)
     do {
         if (integerOnly && n != uprv_floor(n)) {
-            result = FALSE;
+            result = false;
             break;
         }
 
@@ -941,14 +943,14 @@ AndConstraint::isFulfilled(const IFixedDecimal &number) {
                      n == value;       //  'is' rule
             break;
         }
-        result = FALSE;                // 'in' or 'within' rule
+        result = false;                // 'in' or 'within' rule
         for (int32_t r=0; r<rangeList->size(); r+=2) {
             if (rangeList->elementAti(r) <= n && n <= rangeList->elementAti(r+1)) {
-                result = TRUE;
+                result = true;
                 break;
             }
         }
-    } while (FALSE);
+    } while (false);
 
     if (negated) {
         result = !result;
@@ -1024,10 +1026,10 @@ OrConstraint::add(UErrorCode& status) {
 UBool
 OrConstraint::isFulfilled(const IFixedDecimal &number) {
     OrConstraint* orRule=this;
-    UBool result=FALSE;
+    UBool result=false;
 
     while (orRule!=nullptr && !result) {
-        result=TRUE;
+        result=true;
         AndConstraint* andRule = orRule->childNode;
         while (andRule!=nullptr && result) {
             result = andRule->isFulfilled(number);
@@ -1084,7 +1086,7 @@ RuleChain::select(const IFixedDecimal &number) const {
              }
         }
     }
-    return UnicodeString(TRUE, PLURAL_KEYWORD_OTHER, 5);
+    return UnicodeString(true, PLURAL_KEYWORD_OTHER, 5);
 }
 
 static UnicodeString tokenString(tokenType tok) {
@@ -1223,14 +1225,14 @@ RuleChain::getKeywords(int32_t capacityOfKeywords, UnicodeString* keywords, int3
 UBool
 RuleChain::isKeyword(const UnicodeString& keywordParam) const {
     if ( fKeyword == keywordParam ) {
-        return TRUE;
+        return true;
     }
 
     if ( fNext != nullptr ) {
         return fNext->isKeyword(keywordParam);
     }
     else {
-        return FALSE;
+        return false;
     }
 }
 
@@ -1545,7 +1547,7 @@ PluralKeywordEnumeration::PluralKeywordEnumeration(RuleChain *header, UErrorCode
         return;
     }
     fKeywordNames.setDeleter(uprv_deleteUObject);
-    UBool  addKeywordOther = TRUE;
+    UBool  addKeywordOther = true;
     RuleChain *node = header;
     while (node != nullptr) {
         LocalPointer<UnicodeString> newElem(node->fKeyword.clone(), status);
@@ -1554,7 +1556,7 @@ PluralKeywordEnumeration::PluralKeywordEnumeration(RuleChain *header, UErrorCode
             return;
         }
         if (0 == node->fKeyword.compare(PLURAL_KEYWORD_OTHER, 5)) {
-            addKeywordOther = FALSE;
+            addKeywordOther = false;
         }
         node = node->fNext;
     }
@@ -1751,7 +1753,7 @@ void FixedDecimal::init(double n, int32_t v, int64_t f, int32_t e, int32_t c) {
         v = 0;
         f = 0;
         intValue = 0;
-        _hasIntegerValue = FALSE;
+        _hasIntegerValue = false;
     } else {
         intValue = (int64_t)source;
         _hasIntegerValue = (source == intValue);
@@ -1777,13 +1779,13 @@ void FixedDecimal::init(double n, int32_t v, int64_t f, int32_t e, int32_t c) {
 //           A single multiply of the original number works more reliably.
 static int32_t p10[] = {1, 10, 100, 1000, 10000};
 UBool FixedDecimal::quickInit(double n) {
-    UBool success = FALSE;
+    UBool success = false;
     n = fabs(n);
     int32_t numFractionDigits;
     for (numFractionDigits = 0; numFractionDigits <= 3; numFractionDigits++) {
         double scaledN = n * p10[numFractionDigits];
         if (scaledN == floor(scaledN)) {
-            success = TRUE;
+            success = true;
             break;
         }
     }
diff --git a/deps/icu-small/source/i18n/plurrule_impl.h b/deps/icu-small/source/i18n/plurrule_impl.h
index 7274da58f0..c27b655fcd 100644
--- a/deps/icu-small/source/i18n/plurrule_impl.h
+++ b/deps/icu-small/source/i18n/plurrule_impl.h
@@ -34,7 +34,7 @@
  * A FixedDecimal version of UPLRULES_NO_UNIQUE_VALUE used in PluralRulesTest
  * for parsing of samples.
  */
-#define UPLRULES_NO_UNIQUE_VALUE_DECIMAL (FixedDecimal((double)-0.00123456777))
+#define UPLRULES_NO_UNIQUE_VALUE_DECIMAL(ERROR_CODE) (DecimalQuantity::fromExponentString(u"-0.00123456777", ERROR_CODE))
 
 class PluralRulesTest;
 
diff --git a/deps/icu-small/source/i18n/quantityformatter.cpp b/deps/icu-small/source/i18n/quantityformatter.cpp
index 9c9aa99b67..7b4d51e803 100644
--- a/deps/icu-small/source/i18n/quantityformatter.cpp
+++ b/deps/icu-small/source/i18n/quantityformatter.cpp
@@ -81,22 +81,22 @@ UBool QuantityFormatter::addIfAbsent(
         UErrorCode &status) {
     int32_t pluralIndex = StandardPlural::indexFromString(variant, status);
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
     if (formatters[pluralIndex] != NULL) {
-        return TRUE;
+        return true;
     }
     SimpleFormatter *newFmt = new SimpleFormatter(rawPattern, 0, 1, status);
     if (newFmt == NULL) {
         status = U_MEMORY_ALLOCATION_ERROR;
-        return FALSE;
+        return false;
     }
     if (U_FAILURE(status)) {
         delete newFmt;
-        return FALSE;
+        return false;
     }
     formatters[pluralIndex] = newFmt;
-    return TRUE;
+    return true;
 }
 
 UBool QuantityFormatter::isValid() const {
diff --git a/deps/icu-small/source/i18n/rbnf.cpp b/deps/icu-small/source/i18n/rbnf.cpp
index 7f54fd7a33..3d0da00bdb 100644
--- a/deps/icu-small/source/i18n/rbnf.cpp
+++ b/deps/icu-small/source/i18n/rbnf.cpp
@@ -119,16 +119,16 @@ LocalizationInfo::~LocalizationInfo() {}
 
 //UOBJECT_DEFINE_ABSTRACT_RTTI_IMPLEMENTATION(LocalizationInfo)
 
-// if both strings are NULL, this returns TRUE
+// if both strings are NULL, this returns true
 static UBool 
 streq(const UChar* lhs, const UChar* rhs) {
     if (rhs == lhs) {
-        return TRUE;
+        return true;
     }
     if (lhs && rhs) {
         return u_strcmp(lhs, rhs) == 0;
     }
-    return FALSE;
+    return false;
 }
 
 bool
@@ -325,9 +325,9 @@ private:
     inline UBool checkInc(UChar c) {
         if (p < e && (ch == c || *p == c)) {
             inc();
-            return TRUE;
+            return true;
         }
-        return FALSE;
+        return false;
     }
     inline UBool check(UChar c) {
         return p < e && (ch == c || *p == c);
@@ -339,7 +339,7 @@ private:
     }
     inline UBool inList(UChar c, const UChar* list) const {
         if (*list == SPACE && PatternProps::isWhiteSpace(c)) {
-            return TRUE;
+            return true;
         }
         while (*list && *list != c) {
             ++list;
@@ -425,10 +425,10 @@ LocDataParser::doParse(void) {
         ERROR("Missing open angle");
     } else {
         VArray array(DeleteFn);
-        UBool mightHaveNext = TRUE;
+        UBool mightHaveNext = true;
         int32_t requiredLength = -1;
         while (mightHaveNext) {
-            mightHaveNext = FALSE;
+            mightHaveNext = false;
             UChar** elem = nextArray(requiredLength);
             skipWhitespace();
             UBool haveComma = check(COMMA);
@@ -436,7 +436,7 @@ LocDataParser::doParse(void) {
                 array.add(elem, ec);
                 if (haveComma) {
                     inc();
-                    mightHaveNext = TRUE;
+                    mightHaveNext = true;
                 }
             } else if (haveComma) {
                 ERROR("Unexpected character");
@@ -481,9 +481,9 @@ LocDataParser::nextArray(int32_t& requiredLength) {
     }
 
     VArray array;
-    UBool mightHaveNext = TRUE;
+    UBool mightHaveNext = true;
     while (mightHaveNext) {
-        mightHaveNext = FALSE;
+        mightHaveNext = false;
         UChar* elem = nextString();
         skipWhitespace();
         UBool haveComma = check(COMMA);
@@ -491,7 +491,7 @@ LocDataParser::nextArray(int32_t& requiredLength) {
             array.add(elem, ec);
             if (haveComma) {
                 inc();
-                mightHaveNext = TRUE;
+                mightHaveNext = true;
             }
         } else if (haveComma) {
             ERROR("Unexpected comma");
@@ -696,12 +696,12 @@ RuleBasedNumberFormat::RuleBasedNumberFormat(const UnicodeString& description,
   , defaultInfinityRule(NULL)
   , defaultNaNRule(NULL)
   , fRoundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)
-  , lenient(FALSE)
+  , lenient(false)
   , lenientParseRules(NULL)
   , localizations(NULL)
-  , capitalizationInfoSet(FALSE)
-  , capitalizationForUIListMenu(FALSE)
-  , capitalizationForStandAlone(FALSE)
+  , capitalizationInfoSet(false)
+  , capitalizationForUIListMenu(false)
+  , capitalizationForStandAlone(false)
   , capitalizationBrkIter(NULL)
 {
   LocalizationInfo* locinfo = StringLocalizationInfo::create(locs, perror, status);
@@ -721,12 +721,12 @@ RuleBasedNumberFormat::RuleBasedNumberFormat(const UnicodeString& description,
   , defaultInfinityRule(NULL)
   , defaultNaNRule(NULL)
   , fRoundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)
-  , lenient(FALSE)
+  , lenient(false)
   , lenientParseRules(NULL)
   , localizations(NULL)
-  , capitalizationInfoSet(FALSE)
-  , capitalizationForUIListMenu(FALSE)
-  , capitalizationForStandAlone(FALSE)
+  , capitalizationInfoSet(false)
+  , capitalizationForUIListMenu(false)
+  , capitalizationForStandAlone(false)
   , capitalizationBrkIter(NULL)
 {
   LocalizationInfo* locinfo = StringLocalizationInfo::create(locs, perror, status);
@@ -746,12 +746,12 @@ RuleBasedNumberFormat::RuleBasedNumberFormat(const UnicodeString& description,
   , defaultInfinityRule(NULL)
   , defaultNaNRule(NULL)
   , fRoundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)
-  , lenient(FALSE)
+  , lenient(false)
   , lenientParseRules(NULL)
   , localizations(NULL)
-  , capitalizationInfoSet(FALSE)
-  , capitalizationForUIListMenu(FALSE)
-  , capitalizationForStandAlone(FALSE)
+  , capitalizationInfoSet(false)
+  , capitalizationForUIListMenu(false)
+  , capitalizationForStandAlone(false)
   , capitalizationBrkIter(NULL)
 {
   init(description, info, perror, status);
@@ -770,12 +770,12 @@ RuleBasedNumberFormat::RuleBasedNumberFormat(const UnicodeString& description,
   , defaultInfinityRule(NULL)
   , defaultNaNRule(NULL)
   , fRoundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)
-  , lenient(FALSE)
+  , lenient(false)
   , lenientParseRules(NULL)
   , localizations(NULL)
-  , capitalizationInfoSet(FALSE)
-  , capitalizationForUIListMenu(FALSE)
-  , capitalizationForStandAlone(FALSE)
+  , capitalizationInfoSet(false)
+  , capitalizationForUIListMenu(false)
+  , capitalizationForStandAlone(false)
   , capitalizationBrkIter(NULL)
 {
     init(description, NULL, perror, status);
@@ -795,12 +795,12 @@ RuleBasedNumberFormat::RuleBasedNumberFormat(const UnicodeString& description,
   , defaultInfinityRule(NULL)
   , defaultNaNRule(NULL)
   , fRoundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)
-  , lenient(FALSE)
+  , lenient(false)
   , lenientParseRules(NULL)
   , localizations(NULL)
-  , capitalizationInfoSet(FALSE)
-  , capitalizationForUIListMenu(FALSE)
-  , capitalizationForStandAlone(FALSE)
+  , capitalizationInfoSet(false)
+  , capitalizationForUIListMenu(false)
+  , capitalizationForStandAlone(false)
   , capitalizationBrkIter(NULL)
 {
     init(description, NULL, perror, status);
@@ -817,12 +817,12 @@ RuleBasedNumberFormat::RuleBasedNumberFormat(URBNFRuleSetTag tag, const Locale&
   , defaultInfinityRule(NULL)
   , defaultNaNRule(NULL)
   , fRoundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)
-  , lenient(FALSE)
+  , lenient(false)
   , lenientParseRules(NULL)
   , localizations(NULL)
-  , capitalizationInfoSet(FALSE)
-  , capitalizationForUIListMenu(FALSE)
-  , capitalizationForStandAlone(FALSE)
+  , capitalizationInfoSet(false)
+  , capitalizationForUIListMenu(false)
+  , capitalizationForStandAlone(false)
   , capitalizationBrkIter(NULL)
 {
     if (U_FAILURE(status)) {
@@ -884,12 +884,12 @@ RuleBasedNumberFormat::RuleBasedNumberFormat(const RuleBasedNumberFormat& rhs)
   , defaultInfinityRule(NULL)
   , defaultNaNRule(NULL)
   , fRoundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)
-  , lenient(FALSE)
+  , lenient(false)
   , lenientParseRules(NULL)
   , localizations(NULL)
-  , capitalizationInfoSet(FALSE)
-  , capitalizationForUIListMenu(FALSE)
-  , capitalizationForStandAlone(FALSE)
+  , capitalizationInfoSet(false)
+  , capitalizationForUIListMenu(false)
+  , capitalizationForStandAlone(false)
   , capitalizationBrkIter(NULL)
 {
     this->operator=(rhs);
@@ -990,7 +990,7 @@ UnicodeString
 RuleBasedNumberFormat::getRuleSetName(int32_t index) const
 {
     if (localizations) {
-        UnicodeString string(TRUE, localizations->getRuleSetName(index), (int32_t)-1);
+        UnicodeString string(true, localizations->getRuleSetName(index), (int32_t)-1);
         return string;
     }
     else if (fRuleSets) {
@@ -1040,7 +1040,7 @@ RuleBasedNumberFormat::getRuleSetDisplayNameLocale(int32_t index, UErrorCode& st
         return Locale("");
     }
     if (localizations && index >= 0 && index < localizations->getNumberOfDisplayLocales()) {
-        UnicodeString name(TRUE, localizations->getLocaleName(index), -1);
+        UnicodeString name(true, localizations->getLocaleName(index), -1);
         char buffer[64];
         int32_t cap = name.length() + 1;
         char* bp = buffer;
@@ -1073,7 +1073,7 @@ RuleBasedNumberFormat::getRuleSetDisplayName(int32_t index, const Locale& locale
             localeStr[len] = 0;
             int32_t ix = localizations->indexForLocale(localeStr);
             if (ix >= 0) {
-                UnicodeString name(TRUE, localizations->getDisplayName(ix, index), -1);
+                UnicodeString name(true, localizations->getDisplayName(ix, index), -1);
                 return name;
             }
             
@@ -1081,7 +1081,7 @@ RuleBasedNumberFormat::getRuleSetDisplayName(int32_t index, const Locale& locale
             do { --len;} while (len > 0 && localeStr[len] != 0x005f); // underscore
             while (len > 0 && localeStr[len-1] == 0x005F) --len;
         }
-        UnicodeString name(TRUE, localizations->getRuleSetName(index), -1);
+        UnicodeString name(true, localizations->getRuleSetName(index), -1);
         return name;
     }
     UnicodeString bogus;
@@ -1413,7 +1413,7 @@ RuleBasedNumberFormat::setDefaultRuleSet(const UnicodeString& ruleSetName, UErro
     if (U_SUCCESS(status)) {
         if (ruleSetName.isEmpty()) {
           if (localizations) {
-              UnicodeString name(TRUE, localizations->getRuleSetName(0), -1);
+              UnicodeString name(true, localizations->getRuleSetName(0), -1);
               defaultRuleSet = findRuleSet(name, status);
           } else {
             initDefaultRuleSet();
@@ -1636,7 +1636,7 @@ RuleBasedNumberFormat::init(const UnicodeString& rules, LocalizationInfo* locali
         // confirm the names, if any aren't in the rules, that's an error
         // it is ok if the rules contain public rule sets that are not in this list
         for (int32_t i = 0; i < localizationInfos->getNumberOfRuleSets(); ++i) {
-            UnicodeString name(TRUE, localizationInfos->getRuleSetName(i), -1);
+            UnicodeString name(true, localizationInfos->getRuleSetName(i), -1);
             NFRuleSet* rs = findRuleSet(name, status);
             if (rs == NULL) {
                 break; // error
@@ -1661,7 +1661,7 @@ RuleBasedNumberFormat::setContext(UDisplayContext value, UErrorCode& status)
     	if (!capitalizationInfoSet &&
     	        (value==UDISPCTX_CAPITALIZATION_FOR_UI_LIST_OR_MENU || value==UDISPCTX_CAPITALIZATION_FOR_STANDALONE)) {
     	    initCapitalizationContextInfo(locale);
-    	    capitalizationInfoSet = TRUE;
+    	    capitalizationInfoSet = true;
         }
 #if !UCONFIG_NO_BREAK_ITERATION
         if ( capitalizationBrkIter == NULL && (value==UDISPCTX_CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE ||
diff --git a/deps/icu-small/source/i18n/rbt.cpp b/deps/icu-small/source/i18n/rbt.cpp
index 1de53e6071..86d6cbd8bd 100644
--- a/deps/icu-small/source/i18n/rbt.cpp
+++ b/deps/icu-small/source/i18n/rbt.cpp
@@ -34,7 +34,7 @@ void RuleBasedTransliterator::_construct(const UnicodeString& rules,
                                          UParseError& parseError,
                                          UErrorCode& status) {
     fData = 0;
-    isDataOwned = TRUE;
+    isDataOwned = true;
     if (U_FAILURE(status)) {
         return;
     }
@@ -143,7 +143,7 @@ RuleBasedTransliterator::RuleBasedTransliterator(const UnicodeString& id,
                                  UnicodeFilter* adoptedFilter) :
     Transliterator(id, adoptedFilter),
     fData((TransliterationRuleData*)theData), // cast away const
-    isDataOwned(FALSE) {
+    isDataOwned(false) {
     setMaximumContextLength(fData->ruleSet.getMaximumContextLength());
 }
 
@@ -241,7 +241,7 @@ RuleBasedTransliterator::handleTransliterate(Replaceable& text, UTransPosition&
     //   Double-locking must be prevented in these cases.
     //   
 
-    UBool    lockedMutexAtThisLevel = FALSE;
+    UBool    lockedMutexAtThisLevel = false;
 
     // Test whether this request is operating on the same text string as
     //   some other transliteration that is still in progress and holding the 
@@ -263,7 +263,7 @@ RuleBasedTransliterator::handleTransliterate(Replaceable& text, UTransPosition&
         umtx_lock(&transliteratorDataMutex);  // Contention, longish waits possible here.
         Mutex m;
         gLockedText = &text;
-        lockedMutexAtThisLevel = TRUE;
+        lockedMutexAtThisLevel = true;
     }
     
     // Check to make sure we don't dereference a null pointer.
@@ -292,14 +292,14 @@ UnicodeString& RuleBasedTransliterator::toRules(UnicodeString& rulesSource,
  * Implement Transliterator framework
  */
 void RuleBasedTransliterator::handleGetSourceSet(UnicodeSet& result) const {
-    fData->ruleSet.getSourceTargetSet(result, FALSE);
+    fData->ruleSet.getSourceTargetSet(result, false);
 }
 
 /**
  * Override Transliterator framework
  */
 UnicodeSet& RuleBasedTransliterator::getTargetSet(UnicodeSet& result) const {
-    return fData->ruleSet.getSourceTargetSet(result, TRUE);
+    return fData->ruleSet.getSourceTargetSet(result, true);
 }
 
 U_NAMESPACE_END
diff --git a/deps/icu-small/source/i18n/rbt_data.cpp b/deps/icu-small/source/i18n/rbt_data.cpp
index f3985fc768..866f0c2bfa 100644
--- a/deps/icu-small/source/i18n/rbt_data.cpp
+++ b/deps/icu-small/source/i18n/rbt_data.cpp
@@ -25,7 +25,7 @@ U_NAMESPACE_BEGIN
 
 TransliterationRuleData::TransliterationRuleData(UErrorCode& status)
  : UMemory(), ruleSet(status), variableNames(status),
-    variables(0), variablesAreOwned(TRUE)
+    variables(0), variablesAreOwned(true)
 {
     if (U_FAILURE(status)) {
         return;
@@ -37,7 +37,7 @@ TransliterationRuleData::TransliterationRuleData(UErrorCode& status)
 
 TransliterationRuleData::TransliterationRuleData(const TransliterationRuleData& other) :
     UMemory(other), ruleSet(other.ruleSet),
-    variablesAreOwned(TRUE),
+    variablesAreOwned(true),
     variablesBase(other.variablesBase),
     variablesLength(other.variablesLength)
 {
diff --git a/deps/icu-small/source/i18n/rbt_pars.cpp b/deps/icu-small/source/i18n/rbt_pars.cpp
index 2f207a8deb..f13bf1c227 100644
--- a/deps/icu-small/source/i18n/rbt_pars.cpp
+++ b/deps/icu-small/source/i18n/rbt_pars.cpp
@@ -233,7 +233,7 @@ UBool ParseData::isMatcher(UChar32 ch) {
         UnicodeFunctor *f = (UnicodeFunctor*) variablesVector->elementAt(i);
         return f != NULL && f->toMatcher() != NULL;
     }
-    return TRUE;
+    return true;
 }
 
 /**
@@ -248,7 +248,7 @@ UBool ParseData::isReplacer(UChar32 ch) {
         UnicodeFunctor *f = (UnicodeFunctor*) variablesVector->elementAt(i);
         return f != NULL && f->toReplacer() != NULL;
     }
-    return TRUE;
+    return true;
 }
 
 //----------------------------------------------------------------------
@@ -348,7 +348,7 @@ RuleHalf::RuleHalf(TransliteratorParser& p) :
     post = -1;
     cursorOffset = 0;
     cursorOffsetPos = 0;
-    anchorStart = anchorEnd = FALSE;
+    anchorStart = anchorEnd = false;
     nextSegmentNumber = 1;
 }
 
@@ -364,7 +364,7 @@ RuleHalf::~RuleHalf() {
 int32_t RuleHalf::parse(const UnicodeString& rule, int32_t pos, int32_t limit, UErrorCode& status) {
     int32_t start = pos;
     text.truncate(0);
-    pos = parseSection(rule, pos, limit, text, UnicodeString(TRUE, ILLEGAL_TOP, -1), FALSE, status);
+    pos = parseSection(rule, pos, limit, text, UnicodeString(true, ILLEGAL_TOP, -1), false, status);
 
     if (cursorOffset > 0 && cursor != cursorOffsetPos) {
         return syntaxError(U_MISPLACED_CURSOR_OFFSET, rule, start, status);
@@ -403,7 +403,7 @@ int32_t RuleHalf::parseSection(const UnicodeString& rule, int32_t pos, int32_t l
     int32_t start = pos;
     ParsePosition pp;
     UnicodeString scratch;
-    UBool done = FALSE;
+    UBool done = false;
     int32_t quoteStart = -1; // Most recent 'single quoted string'
     int32_t quoteLimit = -1;
     int32_t varStart = -1; // Most recent $variableReference
@@ -511,7 +511,7 @@ int32_t RuleHalf::parseSection(const UnicodeString& rule, int32_t pos, int32_t l
         //------------------------------------------------------
         case ANCHOR_START:
             if (buf.length() == 0 && !anchorStart) {
-                anchorStart = TRUE;
+                anchorStart = true;
             } else {
               return syntaxError(U_MISPLACED_ANCHOR_START,
                                  rule, start, status);
@@ -529,7 +529,7 @@ int32_t RuleHalf::parseSection(const UnicodeString& rule, int32_t pos, int32_t l
                 int32_t segmentNumber = nextSegmentNumber++; // 1-based
                 
                 // Parse the segment
-                pos = parseSection(rule, pos, limit, buf, UnicodeString(TRUE, ILLEGAL_SEG, -1), TRUE, status);
+                pos = parseSection(rule, pos, limit, buf, UnicodeString(true, ILLEGAL_SEG, -1), true, status);
                 
                 // After parsing a segment, the relevant characters are
                 // in buf, starting at offset bufSegStart.  Extract them
@@ -571,7 +571,7 @@ int32_t RuleHalf::parseSection(const UnicodeString& rule, int32_t pos, int32_t l
                 int32_t bufSegStart = buf.length();
                 
                 // Parse the segment
-                pos = parseSection(rule, iref, limit, buf, UnicodeString(TRUE, ILLEGAL_FUNC, -1), TRUE, status);
+                pos = parseSection(rule, iref, limit, buf, UnicodeString(true, ILLEGAL_FUNC, -1), true, status);
                 
                 // After parsing a segment, the relevant characters are
                 // in buf, starting at offset bufSegStart.
@@ -598,7 +598,7 @@ int32_t RuleHalf::parseSection(const UnicodeString& rule, int32_t pos, int32_t l
                 if (pos == limit) {
                     // A variable ref character at the end acts as
                     // an anchor to the context limit, as in perl.
-                    anchorEnd = TRUE;
+                    anchorEnd = true;
                     break;
                 }
                 // Parse "$1" "$2" .. "$9" .. (no upper limit)
@@ -621,7 +621,7 @@ int32_t RuleHalf::parseSection(const UnicodeString& rule, int32_t pos, int32_t l
                         // end anchor then.  If this also doesn't work
                         // (if we see a following character) then signal
                         // an error.
-                        anchorEnd = TRUE;
+                        anchorEnd = true;
                         break;
                     }
                     pos = pp.getIndex();
@@ -704,7 +704,7 @@ int32_t RuleHalf::parseSection(const UnicodeString& rule, int32_t pos, int32_t l
         case SEGMENT_CLOSE:
             // assert(isSegment);
             // We're done parsing a segment.
-            done = TRUE;
+            done = true;
             break;
 
         //------------------------------------------------------
@@ -786,7 +786,7 @@ void RuleHalf::removeContext() {
         text.removeBetween(0, ante);
     }
     ante = post = -1;
-    anchorStart = anchorEnd = FALSE;
+    anchorStart = anchorEnd = false;
 }
 
 /**
@@ -798,10 +798,10 @@ UBool RuleHalf::isValidOutput(TransliteratorParser& transParser) {
         UChar32 c = text.char32At(i);
         i += U16_LENGTH(c);
         if (!transParser.parseData->isReplacer(c)) {
-            return FALSE;
+            return false;
         }
     }
-    return TRUE;
+    return true;
 }
 
 /**
@@ -813,10 +813,10 @@ UBool RuleHalf::isValidInput(TransliteratorParser& transParser) {
         UChar32 c = text.char32At(i);
         i += U16_LENGTH(c);
         if (!transParser.parseData->isMatcher(c)) {
-            return FALSE;
+            return false;
         }
     }
-    return TRUE;
+    return true;
 }
 
 //----------------------------------------------------------------------
@@ -891,7 +891,7 @@ void TransliteratorParser::parseRules(const UnicodeString& rule,
     uprv_memset(&parseError, 0, sizeof(parseError));
     parseError.line = parseError.offset = -1;
 
-    UBool parsingIDs = TRUE;
+    UBool parsingIDs = true;
     int32_t ruleCount = 0;
     
     while (!dataVector.isEmpty()) {
@@ -985,7 +985,7 @@ void TransliteratorParser::parseRules(const UnicodeString& rule,
                     }
                     curData = NULL;
                 }
-                parsingIDs = TRUE;
+                parsingIDs = true;
             }
 
             TransliteratorIDParser::SingleID* id =
@@ -1044,7 +1044,7 @@ void TransliteratorParser::parseRules(const UnicodeString& rule,
                     return;
                 }
                 idBlockResult.remove();
-                parsingIDs = FALSE;
+                parsingIDs = false;
                 curData = new TransliterationRuleData(status);
                 // NULL pointer check
                 if (curData == NULL) {
@@ -1177,7 +1177,7 @@ void TransliteratorParser::setVariableRange(int32_t start, int32_t end, UErrorCo
 
 /**
  * Assert that the given character is NOT within the variable range.
- * If it is, return FALSE.  This is necessary to ensure that the
+ * If it is, return false.  This is necessary to ensure that the
  * variable range does not overlap characters used in a rule.
  */
 UBool TransliteratorParser::checkVariableRange(UChar32 ch) const {
@@ -1218,7 +1218,7 @@ static const UChar PRAGMA_NFC_RULES[] = {0x7E,0x6E,0x66,0x63,0x20,0x72,0x75,0x6C
  */
 UBool TransliteratorParser::resemblesPragma(const UnicodeString& rule, int32_t pos, int32_t limit) {
     // Must start with /use\s/i
-    return ICU_Utility::parsePattern(rule, pos, limit, UnicodeString(TRUE, PRAGMA_USE, 4), NULL) >= 0;
+    return ICU_Utility::parsePattern(rule, pos, limit, UnicodeString(true, PRAGMA_USE, 4), NULL) >= 0;
 }
 
 /**
@@ -1243,25 +1243,25 @@ int32_t TransliteratorParser::parsePragma(const UnicodeString& rule, int32_t pos
     // use maximum backup 16;
     // use nfd rules;
     // use nfc rules;
-    int p = ICU_Utility::parsePattern(rule, pos, limit, UnicodeString(TRUE, PRAGMA_VARIABLE_RANGE, -1), array);
+    int p = ICU_Utility::parsePattern(rule, pos, limit, UnicodeString(true, PRAGMA_VARIABLE_RANGE, -1), array);
     if (p >= 0) {
         setVariableRange(array[0], array[1], status);
         return p;
     }
     
-    p = ICU_Utility::parsePattern(rule, pos, limit, UnicodeString(TRUE, PRAGMA_MAXIMUM_BACKUP, -1), array);
+    p = ICU_Utility::parsePattern(rule, pos, limit, UnicodeString(true, PRAGMA_MAXIMUM_BACKUP, -1), array);
     if (p >= 0) {
         pragmaMaximumBackup(array[0]);
         return p;
     }
     
-    p = ICU_Utility::parsePattern(rule, pos, limit, UnicodeString(TRUE, PRAGMA_NFD_RULES, -1), NULL);
+    p = ICU_Utility::parsePattern(rule, pos, limit, UnicodeString(true, PRAGMA_NFD_RULES, -1), NULL);
     if (p >= 0) {
         pragmaNormalizeRules(UNORM_NFD);
         return p;
     }
     
-    p = ICU_Utility::parsePattern(rule, pos, limit, UnicodeString(TRUE, PRAGMA_NFC_RULES, -1), NULL);
+    p = ICU_Utility::parsePattern(rule, pos, limit, UnicodeString(true, PRAGMA_NFC_RULES, -1), NULL);
     if (p >= 0) {
         pragmaNormalizeRules(UNORM_NFC);
         return p;
@@ -1620,7 +1620,7 @@ void TransliteratorParser::setSegmentObject(int32_t seg, StringMatcher* adopted,
  */
 UChar TransliteratorParser::getDotStandIn(UErrorCode& status) {
     if (dotStandIn == (UChar) -1) {
-        UnicodeSet* tempus = new UnicodeSet(UnicodeString(TRUE, DOT_SET, -1), status);
+        UnicodeSet* tempus = new UnicodeSet(UnicodeString(true, DOT_SET, -1), status);
         // Null pointer check.
         if (tempus == NULL) {
             status = U_MEMORY_ALLOCATION_ERROR;
@@ -1681,7 +1681,7 @@ utrans_stripRules(const UChar *source, int32_t sourceLen, UChar *target, UErrorC
     const UChar *sourceLimit = source+sourceLen;
     UChar *targetLimit = target+sourceLen;
     UChar32 c = 0;
-    UBool quoted = FALSE;
+    UBool quoted = false;
     int32_t index;
 
     uprv_memset(target, 0, sourceLen*U_SIZEOF_UCHAR);
@@ -1748,7 +1748,7 @@ utrans_stripRules(const UChar *source, int32_t sourceLen, UChar *target, UErrorC
             /* ignore spaces carriage returns, and all leading spaces on the next line.
             * and line feed unless in the form \uXXXX
             */
-            quoted = FALSE;
+            quoted = false;
             while (source < sourceLimit) {
                 c = *(source);
                 if (c != CR && c != LF && c != 0x0020) {
diff --git a/deps/icu-small/source/i18n/rbt_rule.cpp b/deps/icu-small/source/i18n/rbt_rule.cpp
index 6cc5325c46..ee0d938ca9 100644
--- a/deps/icu-small/source/i18n/rbt_rule.cpp
+++ b/deps/icu-small/source/i18n/rbt_rule.cpp
@@ -50,9 +50,9 @@ U_NAMESPACE_BEGIN
  * segments, or null if there are none.  The array itself is adopted,
  * but the pointers within it are not.
  * @param segsCount number of elements in segs[]
- * @param anchorStart TRUE if the the rule is anchored on the left to
+ * @param anchorStart true if the the rule is anchored on the left to
  * the context start
- * @param anchorEnd TRUE if the rule is anchored on the right to the
+ * @param anchorEnd true if the rule is anchored on the right to the
  * context limit
  */
 TransliterationRule::TransliterationRule(const UnicodeString& input,
@@ -119,7 +119,7 @@ TransliterationRule::TransliterationRule(const UnicodeString& input,
     anteContext = NULL;
     if (anteContextLength > 0) {
         anteContext = new StringMatcher(pattern, 0, anteContextLength,
-                                        FALSE, *data);
+                                        false, *data);
         /* test for NULL */
         if (anteContext == 0) {
             status = U_MEMORY_ALLOCATION_ERROR;
@@ -130,7 +130,7 @@ TransliterationRule::TransliterationRule(const UnicodeString& input,
     key = NULL;
     if (keyLength > 0) {
         key = new StringMatcher(pattern, anteContextLength, anteContextLength + keyLength,
-                                FALSE, *data);
+                                false, *data);
         /* test for NULL */
         if (key == 0) {
             status = U_MEMORY_ALLOCATION_ERROR;
@@ -142,7 +142,7 @@ TransliterationRule::TransliterationRule(const UnicodeString& input,
     postContext = NULL;
     if (postContextLength > 0) {
         postContext = new StringMatcher(pattern, anteContextLength + keyLength, pattern.length(),
-                                        FALSE, *data);
+                                        false, *data);
         /* test for NULL */
         if (postContext == 0) {
             status = U_MEMORY_ALLOCATION_ERROR;
@@ -242,7 +242,7 @@ UBool TransliterationRule::matchesIndexValue(uint8_t v) const {
     // Delegate to the key, or if there is none, to the postContext.
     // If there is neither then we match any key; return true.
     UnicodeMatcher *m = (key != NULL) ? key : postContext;
-    return (m != NULL) ? m->matchesIndexValue(v) : TRUE;
+    return (m != NULL) ? m->matchesIndexValue(v) : true;
 }
 
 /**
@@ -343,11 +343,11 @@ static inline int32_t posAfter(const Replaceable& str, int32_t pos) {
  * 
  * @param text the text
  * @param pos the position indices
- * @param incremental if TRUE, test for partial matches that may
+ * @param incremental if true, test for partial matches that may
  * be completed by additional text inserted at pos.limit.
  * @return one of <code>U_MISMATCH</code>,
  * <code>U_PARTIAL_MATCH</code>, or <code>U_MATCH</code>.  If
- * incremental is FALSE then U_PARTIAL_MATCH will not be returned.
+ * incremental is false then U_PARTIAL_MATCH will not be returned.
  */
 UMatchDegree TransliterationRule::matchAndReplace(Replaceable& text,
                                                   UTransPosition& pos,
@@ -392,7 +392,7 @@ UMatchDegree TransliterationRule::matchAndReplace(Replaceable& text,
     oText = posBefore(text, pos.start);
 
     if (anteContext != NULL) {
-        match = anteContext->matches(text, oText, anteLimit, FALSE);
+        match = anteContext->matches(text, oText, anteLimit, false);
         if (match != U_MATCH) {
             return U_MISMATCH;
         }
@@ -488,13 +488,13 @@ UnicodeString& TransliterationRule::toRule(UnicodeString& rule,
     ICU_Utility::appendToRule(rule, anteContext, escapeUnprintable, quoteBuf);
 
     if (emitBraces) {
-        ICU_Utility::appendToRule(rule, (UChar) 0x007B /*{*/, TRUE, escapeUnprintable, quoteBuf);
+        ICU_Utility::appendToRule(rule, (UChar) 0x007B /*{*/, true, escapeUnprintable, quoteBuf);
     }
 
     ICU_Utility::appendToRule(rule, key, escapeUnprintable, quoteBuf);
 
     if (emitBraces) {
-        ICU_Utility::appendToRule(rule, (UChar) 0x007D /*}*/, TRUE, escapeUnprintable, quoteBuf);
+        ICU_Utility::appendToRule(rule, (UChar) 0x007D /*}*/, true, escapeUnprintable, quoteBuf);
     }
 
     ICU_Utility::appendToRule(rule, postContext, escapeUnprintable, quoteBuf);
@@ -504,14 +504,14 @@ UnicodeString& TransliterationRule::toRule(UnicodeString& rule,
         rule.append((UChar)36/*$*/);
     }
 
-    ICU_Utility::appendToRule(rule, UnicodeString(TRUE, FORWARD_OP, 3), TRUE, escapeUnprintable, quoteBuf);
+    ICU_Utility::appendToRule(rule, UnicodeString(true, FORWARD_OP, 3), true, escapeUnprintable, quoteBuf);
 
     // Emit the output pattern
 
     ICU_Utility::appendToRule(rule, output->toReplacer()->toReplacerPattern(str, escapeUnprintable),
-                              TRUE, escapeUnprintable, quoteBuf);
+                              true, escapeUnprintable, quoteBuf);
 
-    ICU_Utility::appendToRule(rule, (UChar) 0x003B /*;*/, TRUE, escapeUnprintable, quoteBuf);
+    ICU_Utility::appendToRule(rule, (UChar) 0x003B /*;*/, true, escapeUnprintable, quoteBuf);
 
     return rule;
 }
diff --git a/deps/icu-small/source/i18n/rbt_set.cpp b/deps/icu-small/source/i18n/rbt_set.cpp
index 6835c03a69..c517467436 100644
--- a/deps/icu-small/source/i18n/rbt_set.cpp
+++ b/deps/icu-small/source/i18n/rbt_set.cpp
@@ -114,7 +114,7 @@ inline void _debugOut(const char* msg, TransliterationRule* rule,
     UnicodeString buf(msg, "");
     if (rule) {
         UnicodeString r;
-        rule->toRule(r, TRUE);
+        rule->toRule(r, true);
         buf.append((UChar)32).append(r);
     }
     buf.append(UnicodeString(" => ", ""));
@@ -145,14 +145,14 @@ static void maskingError(const icu::TransliterationRule& rule1,
     parseError.line = parseError.offset = -1;
     
     // for pre-context
-    rule1.toRule(r, FALSE);
+    rule1.toRule(r, false);
     len = uprv_min(r.length(), U_PARSE_CONTEXT_LEN-1);
     r.extract(0, len, parseError.preContext);
     parseError.preContext[len] = 0;   
     
     //for post-context
     r.truncate(0);
-    rule2.toRule(r, FALSE);
+    rule2.toRule(r, false);
     len = uprv_min(r.length(), U_PARSE_CONTEXT_LEN-1);
     r.extract(0, len, parseError.postContext);
     parseError.postContext[len] = 0;   
@@ -387,14 +387,14 @@ void TransliterationRuleSet::freeze(UParseError& parseError,UErrorCode& status)
 
 /**
  * Transliterate the given text with the given UTransPosition
- * indices.  Return TRUE if the transliteration should continue
- * or FALSE if it should halt (because of a U_PARTIAL_MATCH match).
- * Note that FALSE is only ever returned if isIncremental is TRUE.
+ * indices.  Return true if the transliteration should continue
+ * or false if it should halt (because of a U_PARTIAL_MATCH match).
+ * Note that false is only ever returned if isIncremental is true.
  * @param text the text to be transliterated
  * @param pos the position indices, which will be updated
- * @param incremental if TRUE, assume new text may be inserted
- * at index.limit, and return FALSE if there is a partial match.
- * @return TRUE unless a U_PARTIAL_MATCH has been obtained,
+ * @param incremental if true, assume new text may be inserted
+ * at index.limit, and return false if there is a partial match.
+ * @return true unless a U_PARTIAL_MATCH has been obtained,
  * indicating that transliteration should stop until more text
  * arrives.
  */
@@ -407,10 +407,10 @@ UBool TransliterationRuleSet::transliterate(Replaceable& text,
         switch (m) {
         case U_MATCH:
             _debugOut("match", rules[i], text, pos);
-            return TRUE;
+            return true;
         case U_PARTIAL_MATCH:
             _debugOut("partial match", rules[i], text, pos);
-            return FALSE;
+            return false;
         default: /* Ram: added default to make GCC happy */
             break;
         }
@@ -418,7 +418,7 @@ UBool TransliterationRuleSet::transliterate(Replaceable& text,
     // No match or partial match from any rule
     pos.start += U16_LENGTH(text.char32At(pos.start));
     _debugOut("no match", NULL, text, pos);
-    return TRUE;
+    return true;
 }
 
 /**
diff --git a/deps/icu-small/source/i18n/rbtz.cpp b/deps/icu-small/source/i18n/rbtz.cpp
index 495d8310d0..0e174bab38 100644
--- a/deps/icu-small/source/i18n/rbtz.cpp
+++ b/deps/icu-small/source/i18n/rbtz.cpp
@@ -40,34 +40,34 @@ U_CDECL_END
 
 static UBool compareRules(UVector* rules1, UVector* rules2) {
     if (rules1 == NULL && rules2 == NULL) {
-        return TRUE;
+        return true;
     } else if (rules1 == NULL || rules2 == NULL) {
-        return FALSE;
+        return false;
     }
     int32_t size = rules1->size();
     if (size != rules2->size()) {
-        return FALSE;
+        return false;
     }
     for (int32_t i = 0; i < size; i++) {
         TimeZoneRule *r1 = (TimeZoneRule*)rules1->elementAt(i);
         TimeZoneRule *r2 = (TimeZoneRule*)rules2->elementAt(i);
         if (*r1 != *r2) {
-            return FALSE;
+            return false;
         }
     }
-    return TRUE;
+    return true;
 }
 
 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(RuleBasedTimeZone)
 
 RuleBasedTimeZone::RuleBasedTimeZone(const UnicodeString& id, InitialTimeZoneRule* initialRule)
 : BasicTimeZone(id), fInitialRule(initialRule), fHistoricRules(NULL), fFinalRules(NULL),
-  fHistoricTransitions(NULL), fUpToDate(FALSE) {
+  fHistoricTransitions(NULL), fUpToDate(false) {
 }
 
 RuleBasedTimeZone::RuleBasedTimeZone(const RuleBasedTimeZone& source)
 : BasicTimeZone(source), fInitialRule(source.fInitialRule->clone()),
-  fHistoricTransitions(NULL), fUpToDate(FALSE) {
+  fHistoricTransitions(NULL), fUpToDate(false) {
     fHistoricRules = copyRules(source.fHistoricRules);
     fFinalRules = copyRules(source.fFinalRules);
     if (source.fUpToDate) {
@@ -90,7 +90,7 @@ RuleBasedTimeZone::operator=(const RuleBasedTimeZone& right) {
         fHistoricRules = copyRules(right.fHistoricRules);
         fFinalRules = copyRules(right.fFinalRules);
         deleteTransitions();
-        fUpToDate = FALSE;
+        fUpToDate = false;
     }
     return *this;
 }
@@ -152,7 +152,7 @@ RuleBasedTimeZone::addTransitionRule(TimeZoneRule* rule, UErrorCode& status) {
         fHistoricRules->adoptElement(lpRule.orphan(), status);
     }
     // Mark dirty, so transitions are recalculated at next complete() call
-    fUpToDate = FALSE;
+    fUpToDate = false;
 }
 
 
@@ -203,7 +203,7 @@ RuleBasedTimeZone::complete(UErrorCode& status) {
             for (i = 0; i < historicCount; i++) {
                 done[i] = false;
             }
-            while (TRUE) {
+            while (true) {
                 int32_t curStdOffset = curRule->getRawOffset();
                 int32_t curDstSavings = curRule->getDSTSavings();
                 UDate nextTransitionTime = MAX_MILLIS;
@@ -239,10 +239,10 @@ RuleBasedTimeZone::complete(UErrorCode& status) {
 
                 if (nextRule ==  NULL) {
                     // Check if all historic rules are done
-                    UBool bDoneAll = TRUE;
+                    UBool bDoneAll = true;
                     for (int32_t j = 0; j < historicCount; j++) {
                         if (!done[j]) {
-                            bDoneAll = FALSE;
+                            bDoneAll = false;
                             break;
                         }
                     }
@@ -344,12 +344,12 @@ RuleBasedTimeZone::complete(UErrorCode& status) {
             }
         }
     }
-    fUpToDate = TRUE;
+    fUpToDate = true;
     return;
 
 cleanup:
     deleteTransitions();
-    fUpToDate = FALSE;
+    fUpToDate = false;
 }
 
 RuleBasedTimeZone*
@@ -386,7 +386,7 @@ RuleBasedTimeZone::getOffset(uint8_t era, int32_t year, int32_t month, int32_t d
     }
     int32_t rawOffset, dstOffset;
     UDate time = (UDate)Grego::fieldsToDay(year, month, day) * U_MILLIS_PER_DAY + millis;
-    getOffsetInternal(time, TRUE, kDaylight, kStandard, rawOffset, dstOffset, status);
+    getOffsetInternal(time, true, kDaylight, kStandard, rawOffset, dstOffset, status);
     if (U_FAILURE(status)) {
         return 0;
     }
@@ -402,7 +402,7 @@ RuleBasedTimeZone::getOffset(UDate date, UBool local, int32_t& rawOffset,
 void RuleBasedTimeZone::getOffsetFromLocal(UDate date, UTimeZoneLocalOption nonExistingTimeOpt,
                                            UTimeZoneLocalOption duplicatedTimeOpt,
                                            int32_t& rawOffset, int32_t& dstOffset, UErrorCode& status) const {
-    getOffsetInternal(date, TRUE, nonExistingTimeOpt, duplicatedTimeOpt, rawOffset, dstOffset, status);
+    getOffsetInternal(date, true, nonExistingTimeOpt, duplicatedTimeOpt, rawOffset, dstOffset, status);
 }
 
 
@@ -479,8 +479,7 @@ RuleBasedTimeZone::getRawOffset(void) const {
     // as of current time.
     UErrorCode status = U_ZERO_ERROR;
     int32_t raw, dst;
-    getOffset(uprv_getUTCtime() * U_MILLIS_PER_SECOND,
-        FALSE, raw, dst, status);
+    getOffset(uprv_getUTCtime(), false, raw, dst, status);
     return raw;
 }
 
@@ -490,52 +489,52 @@ RuleBasedTimeZone::useDaylightTime(void) const {
     // daylight saving time is used as of now or
     // after the next transition.
     UErrorCode status = U_ZERO_ERROR;
-    UDate now = uprv_getUTCtime() * U_MILLIS_PER_SECOND;
+    UDate now = uprv_getUTCtime();
     int32_t raw, dst;
-    getOffset(now, FALSE, raw, dst, status);
+    getOffset(now, false, raw, dst, status);
     if (dst != 0) {
-        return TRUE;
+        return true;
     }
     // If DST is not used now, check if DST is used after the next transition
     UDate time;
     TimeZoneRule *from, *to;
-    UBool avail = findNext(now, FALSE, time, from, to);
+    UBool avail = findNext(now, false, time, from, to);
     if (avail && to->getDSTSavings() != 0) {
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 UBool
 RuleBasedTimeZone::inDaylightTime(UDate date, UErrorCode& status) const {
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
     int32_t raw, dst;
-    getOffset(date, FALSE, raw, dst, status);
+    getOffset(date, false, raw, dst, status);
     if (dst != 0) {
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 UBool
 RuleBasedTimeZone::hasSameRules(const TimeZone& other) const {
     if (this == &other) {
-        return TRUE;
+        return true;
     }
     if (typeid(*this) != typeid(other)) {
-        return FALSE;
+        return false;
     }
     const RuleBasedTimeZone& that = (const RuleBasedTimeZone&)other;
     if (*fInitialRule != *(that.fInitialRule)) {
-        return FALSE;
+        return false;
     }
     if (compareRules(fHistoricRules, that.fHistoricRules)
         && compareRules(fFinalRules, that.fFinalRules)) {
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 UBool
@@ -543,7 +542,7 @@ RuleBasedTimeZone::getNextTransition(UDate base, UBool inclusive, TimeZoneTransi
     UErrorCode status = U_ZERO_ERROR;
     completeConst(status);
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
     UDate transitionTime;
     TimeZoneRule *fromRule, *toRule;
@@ -552,9 +551,9 @@ RuleBasedTimeZone::getNextTransition(UDate base, UBool inclusive, TimeZoneTransi
         result.setTime(transitionTime);
         result.setFrom((const TimeZoneRule&)*fromRule);
         result.setTo((const TimeZoneRule&)*toRule);
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 UBool
@@ -562,7 +561,7 @@ RuleBasedTimeZone::getPreviousTransition(UDate base, UBool inclusive, TimeZoneTr
     UErrorCode status = U_ZERO_ERROR;
     completeConst(status);
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
     UDate transitionTime;
     TimeZoneRule *fromRule, *toRule;
@@ -571,9 +570,9 @@ RuleBasedTimeZone::getPreviousTransition(UDate base, UBool inclusive, TimeZoneTr
         result.setTime(transitionTime);
         result.setFrom((const TimeZoneRule&)*fromRule);
         result.setTo((const TimeZoneRule&)*toRule);
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 int32_t
@@ -688,7 +687,7 @@ RuleBasedTimeZone::findRuleInFinal(UDate date, UBool local,
                                    NonExistingTimeOpt, DuplicatedTimeOpt);
         base -= localDelta;
     }
-    UBool avail0 = fr0->getPreviousStart(base, fr1->getRawOffset(), fr1->getDSTSavings(), TRUE, start0);
+    UBool avail0 = fr0->getPreviousStart(base, fr1->getRawOffset(), fr1->getDSTSavings(), true, start0);
 
     base = date;
     if (local) {
@@ -697,7 +696,7 @@ RuleBasedTimeZone::findRuleInFinal(UDate date, UBool local,
                                    NonExistingTimeOpt, DuplicatedTimeOpt);
         base -= localDelta;
     }
-    UBool avail1 = fr1->getPreviousStart(base, fr0->getRawOffset(), fr0->getDSTSavings(), TRUE, start1);
+    UBool avail1 = fr1->getPreviousStart(base, fr0->getRawOffset(), fr0->getDSTSavings(), true, start1);
 
     if (!avail0 || !avail1) {
         if (avail0) {
@@ -716,23 +715,23 @@ UBool
 RuleBasedTimeZone::findNext(UDate base, UBool inclusive, UDate& transitionTime,
                             TimeZoneRule*& fromRule, TimeZoneRule*& toRule) const {
     if (fHistoricTransitions == NULL) {
-        return FALSE;
+        return false;
     }
-    UBool isFinal = FALSE;
-    UBool found = FALSE;
+    UBool isFinal = false;
+    UBool found = false;
     Transition result;
     Transition *tzt = (Transition*)fHistoricTransitions->elementAt(0);
     UDate tt = tzt->time;
     if (tt > base || (inclusive && tt == base)) {
         result = *tzt;
-        found = TRUE;
+        found = true;
     } else {
         int32_t idx = fHistoricTransitions->size() - 1;        
         tzt = (Transition*)fHistoricTransitions->elementAt(idx);
         tt = tzt->time;
         if (inclusive && tt == base) {
             result = *tzt;
-            found = TRUE;
+            found = true;
         } else if (tt <= base) {
             if (fFinalRules != NULL) {
                 // Find a transion time with finalRules
@@ -741,9 +740,9 @@ RuleBasedTimeZone::findNext(UDate base, UBool inclusive, UDate& transitionTime,
                 UDate start0, start1;
                 UBool avail0 = r0->getNextStart(base, r1->getRawOffset(), r1->getDSTSavings(), inclusive, start0);
                 UBool avail1 = r1->getNextStart(base, r0->getRawOffset(), r0->getDSTSavings(), inclusive, start1);
-                //  avail0/avail1 should be always TRUE
+                //  avail0/avail1 should be always true
                 if (!avail0 && !avail1) {
-                    return FALSE;
+                    return false;
                 }
                 if (!avail1 || start0 < start1) {
                     result.time = start0;
@@ -754,8 +753,8 @@ RuleBasedTimeZone::findNext(UDate base, UBool inclusive, UDate& transitionTime,
                     result.from = r0;
                     result.to = r1;
                 }
-                isFinal = TRUE;
-                found = TRUE;
+                isFinal = true;
+                found = true;
             }
         } else {
             // Find a transition within the historic transitions
@@ -773,7 +772,7 @@ RuleBasedTimeZone::findNext(UDate base, UBool inclusive, UDate& transitionTime,
             result.time = prev->time;
             result.from = prev->from;
             result.to = prev->to;
-            found = TRUE;
+            found = true;
         }
     }
     if (found) {
@@ -781,41 +780,41 @@ RuleBasedTimeZone::findNext(UDate base, UBool inclusive, UDate& transitionTime,
         if (result.from->getRawOffset() == result.to->getRawOffset()
             && result.from->getDSTSavings() == result.to->getDSTSavings()) {
             if (isFinal) {
-                return FALSE;
+                return false;
             } else {
                 // No offset changes.  Try next one if not final
-                return findNext(result.time, FALSE /* always exclusive */,
+                return findNext(result.time, false /* always exclusive */,
                     transitionTime, fromRule, toRule);
             }
         }
         transitionTime = result.time;
         fromRule = result.from;
         toRule = result.to;
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 UBool
 RuleBasedTimeZone::findPrev(UDate base, UBool inclusive, UDate& transitionTime,
                             TimeZoneRule*& fromRule, TimeZoneRule*& toRule) const {
     if (fHistoricTransitions == NULL) {
-        return FALSE;
+        return false;
     }
-    UBool found = FALSE;
+    UBool found = false;
     Transition result;
     Transition *tzt = (Transition*)fHistoricTransitions->elementAt(0);
     UDate tt = tzt->time;
     if (inclusive && tt == base) {
         result = *tzt;
-        found = TRUE;
+        found = true;
     } else if (tt < base) {
         int32_t idx = fHistoricTransitions->size() - 1;        
         tzt = (Transition*)fHistoricTransitions->elementAt(idx);
         tt = tzt->time;
         if (inclusive && tt == base) {
             result = *tzt;
-            found = TRUE;
+            found = true;
         } else if (tt < base) {
             if (fFinalRules != NULL) {
                 // Find a transion time with finalRules
@@ -824,9 +823,9 @@ RuleBasedTimeZone::findPrev(UDate base, UBool inclusive, UDate& transitionTime,
                 UDate start0, start1;
                 UBool avail0 = r0->getPreviousStart(base, r1->getRawOffset(), r1->getDSTSavings(), inclusive, start0);
                 UBool avail1 = r1->getPreviousStart(base, r0->getRawOffset(), r0->getDSTSavings(), inclusive, start1);
-                //  avail0/avail1 should be always TRUE
+                //  avail0/avail1 should be always true
                 if (!avail0 && !avail1) {
-                    return FALSE;
+                    return false;
                 }
                 if (!avail1 || start0 > start1) {
                     result.time = start0;
@@ -840,7 +839,7 @@ RuleBasedTimeZone::findPrev(UDate base, UBool inclusive, UDate& transitionTime,
             } else {
                 result = *tzt;
             }
-            found = TRUE;
+            found = true;
         } else {
             // Find a transition within the historic transitions
             idx--;
@@ -853,7 +852,7 @@ RuleBasedTimeZone::findPrev(UDate base, UBool inclusive, UDate& transitionTime,
                 idx--;
             }
             result = *tzt;
-            found = TRUE;
+            found = true;
         }
     }
     if (found) {
@@ -861,15 +860,15 @@ RuleBasedTimeZone::findPrev(UDate base, UBool inclusive, UDate& transitionTime,
         if (result.from->getRawOffset() == result.to->getRawOffset()
             && result.from->getDSTSavings() == result.to->getDSTSavings()) {
             // No offset changes.  Try next one if not final
-            return findPrev(result.time, FALSE /* always exclusive */,
+            return findPrev(result.time, false /* always exclusive */,
                 transitionTime, fromRule, toRule);
         }
         transitionTime = result.time;
         fromRule = result.from;
         toRule = result.to;
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 UDate
diff --git a/deps/icu-small/source/i18n/regexcmp.cpp b/deps/icu-small/source/i18n/regexcmp.cpp
index 89cb658425..4b507002d6 100644
--- a/deps/icu-small/source/i18n/regexcmp.cpp
+++ b/deps/icu-small/source/i18n/regexcmp.cpp
@@ -66,10 +66,10 @@ RegexCompile::RegexCompile(RegexPattern *rxp, UErrorCode &status) :
     fPeekChar         = -1;
     fLineNum          = 1;
     fCharNum          = 0;
-    fQuoteMode        = FALSE;
-    fInBackslashQuote = FALSE;
+    fQuoteMode        = false;
+    fInBackslashQuote = false;
     fModeFlags        = fRXPat->fFlags | 0x80000000;
-    fEOLComments      = TRUE;
+    fEOLComments      = true;
 
     fMatchOpenParen   = -1;
     fMatchCloseParen  = -1;
@@ -144,7 +144,7 @@ void    RegexCompile::compile(
     U_ASSERT(fRXPat->fPattern == NULL || utext_nativeLength(fRXPat->fPattern) == 0);
 
     // Prepare the RegexPattern object to receive the compiled pattern.
-    fRXPat->fPattern        = utext_clone(fRXPat->fPattern, pat, FALSE, TRUE, fStatus);
+    fRXPat->fPattern        = utext_clone(fRXPat->fPattern, pat, false, true, fStatus);
     if (U_FAILURE(*fStatus)) {
         return;
     }
@@ -156,7 +156,7 @@ void    RegexCompile::compile(
 
     // UREGEX_LITERAL force entire pattern to be treated as a literal string.
     if (fModeFlags & UREGEX_LITERAL) {
-        fQuoteMode = TRUE;
+        fQuoteMode = true;
     }
 
     nextChar(fC);                        // Fetch the first char from the pattern string.
@@ -193,7 +193,7 @@ void    RegexCompile::compile(
         for (;;) {    // loop through table rows belonging to this state, looking for one
                       //   that matches the current input char.
             REGEX_SCAN_DEBUG_PRINTF(("."));
-            if (tableEl->fCharClass < 127 && fC.fQuoted == FALSE &&   tableEl->fCharClass == fC.fChar) {
+            if (tableEl->fCharClass < 127 && fC.fQuoted == false &&   tableEl->fCharClass == fC.fChar) {
                 // Table row specified an individual character, not a set, and
                 //   the input character is not quoted, and
                 //   the input character matched it.
@@ -213,7 +213,7 @@ void    RegexCompile::compile(
             }
 
             if (tableEl->fCharClass >= 128 && tableEl->fCharClass < 240 &&   // Table specs a char class &&
-                fC.fQuoted == FALSE &&                                       //   char is not escaped &&
+                fC.fQuoted == false &&                                       //   char is not escaped &&
                 fC.fChar != (UChar32)-1) {                                   //   char is not EOF
                 U_ASSERT(tableEl->fCharClass <= 137);
                 if (RegexStaticSets::gStaticSets->fRuleSets[tableEl->fCharClass-128].contains(fC.fChar)) {
@@ -232,7 +232,7 @@ void    RegexCompile::compile(
         // We've found the row of the state table that matches the current input
         //   character from the rules string.
         // Perform any action specified  by this row in the state table.
-        if (doParseActions(tableEl->fAction) == FALSE) {
+        if (doParseActions(tableEl->fAction) == false) {
             // Break out of the state machine loop if the
             //   the action signalled some kind of error, or
             //   the action was to exit, occurs on normal end-of-rules-input.
@@ -345,7 +345,7 @@ void    RegexCompile::compile(
 //------------------------------------------------------------------------------
 UBool RegexCompile::doParseActions(int32_t action)
 {
-    UBool   returnVal = TRUE;
+    UBool   returnVal = true;
 
     switch ((Regex_PatternParseAction)action) {
 
@@ -386,7 +386,7 @@ UBool RegexCompile::doParseActions(int32_t action)
         appendOp(URX_END, 0);
 
         // Terminate the pattern compilation state machine.
-        returnVal = FALSE;
+        returnVal = false;
         break;
 
 
@@ -395,7 +395,7 @@ UBool RegexCompile::doParseActions(int32_t action)
         // Scanning a '|', as in (A|B)
         {
             // Generate code for any pending literals preceding the '|'
-            fixLiterals(FALSE);
+            fixLiterals(false);
 
             // Insert a SAVE operation at the start of the pattern section preceding
             //   this OR at this level.  This SAVE will branch the match forward
@@ -788,7 +788,7 @@ UBool RegexCompile::doParseActions(int32_t action)
         //     2.   LOOP_SR_I    set number  (assuming repeated item is a set ref)
         //     3.   LOOP_C       stack location
         {
-            int32_t  topLoc = blockTopLoc(FALSE);        // location of item #1
+            int32_t  topLoc = blockTopLoc(false);        // location of item #1
             int32_t  frameLoc;
 
             // Check for simple constructs, which may get special optimized code.
@@ -850,7 +850,7 @@ UBool RegexCompile::doParseActions(int32_t action)
         //     2.   state-save  1
         //     3.   ...
         {
-            int32_t topLoc      = blockTopLoc(FALSE);
+            int32_t topLoc      = blockTopLoc(false);
             appendOp(URX_STATE_SAVE, topLoc);
         }
         break;
@@ -864,7 +864,7 @@ UBool RegexCompile::doParseActions(int32_t action)
         //     3. ...
         // Insert the state save into the compiled pattern, and we're done.
         {
-            int32_t   saveStateLoc = blockTopLoc(TRUE);
+            int32_t   saveStateLoc = blockTopLoc(true);
             int32_t   saveStateOp  = buildOp(URX_STATE_SAVE, fRXPat->fCompiledPat->size());
             fRXPat->fCompiledPat->setElementAt(saveStateOp, saveStateLoc);
         }
@@ -881,7 +881,7 @@ UBool RegexCompile::doParseActions(int32_t action)
         //  This code is less than ideal, with two jmps instead of one, because we can only
         //  insert one instruction at the top of the block being iterated.
         {
-            int32_t  jmp1_loc = blockTopLoc(TRUE);
+            int32_t  jmp1_loc = blockTopLoc(true);
             int32_t  jmp2_loc = fRXPat->fCompiledPat->size();
 
             int32_t  jmp1_op  = buildOp(URX_JMP, jmp2_loc+1);
@@ -919,7 +919,7 @@ UBool RegexCompile::doParseActions(int32_t action)
         //       5.   ...
         {
             // location of item #1, the STATE_SAVE
-            int32_t   topLoc = blockTopLoc(FALSE);
+            int32_t   topLoc = blockTopLoc(false);
             int32_t   dataLoc = -1;
 
             // Check for simple *, where the construct being repeated
@@ -958,7 +958,7 @@ UBool RegexCompile::doParseActions(int32_t action)
             // Emit general case code for this *
             // The optimizations did not apply.
 
-            int32_t   saveStateLoc = blockTopLoc(TRUE);
+            int32_t   saveStateLoc = blockTopLoc(true);
             int32_t   jmpOp        = buildOp(URX_JMP_SAV, saveStateLoc+1);
 
             // Check for minimum match length of zero, which requires
@@ -993,7 +993,7 @@ UBool RegexCompile::doParseActions(int32_t action)
         //     3.   STATE_SAVE  2
         //     4    ...
         {
-            int32_t     jmpLoc  = blockTopLoc(TRUE);                   // loc  1.
+            int32_t     jmpLoc  = blockTopLoc(true);                   // loc  1.
             int32_t     saveLoc = fRXPat->fCompiledPat->size();        // loc  3.
             int32_t     jmpOp   = buildOp(URX_JMP, saveLoc);
             fRXPat->fCompiledPat->setElementAt(jmpOp, jmpLoc);
@@ -1048,7 +1048,7 @@ UBool RegexCompile::doParseActions(int32_t action)
 
     case doInterval:
         // Finished scanning a normal {lower,upper} interval.  Generate the code for it.
-        if (compileInlineInterval() == FALSE) {
+        if (compileInlineInterval() == false) {
             compileInterval(URX_CTR_INIT, URX_CTR_LOOP);
         }
         break;
@@ -1060,7 +1060,7 @@ UBool RegexCompile::doParseActions(int32_t action)
             //   (Can not reserve a slot in the compiled pattern at this time, because
             //    compileInterval needs to reserve also, and blockTopLoc can only reserve
             //    once per block.)
-            int32_t topLoc = blockTopLoc(FALSE);
+            int32_t topLoc = blockTopLoc(false);
 
             // Produce normal looping code.
             compileInterval(URX_CTR_INIT, URX_CTR_LOOP);
@@ -1116,7 +1116,7 @@ UBool RegexCompile::doParseActions(int32_t action)
     case doDotAny:
         // scanned a ".",  match any single character.
         {
-            fixLiterals(FALSE);
+            fixLiterals(false);
             if (fModeFlags & UREGEX_DOTALL) {
                 appendOp(URX_DOTANY_ALL, 0);
             } else if (fModeFlags & UREGEX_UNIX_LINES) {
@@ -1129,7 +1129,7 @@ UBool RegexCompile::doParseActions(int32_t action)
 
     case doCaret:
         {
-            fixLiterals(FALSE);
+            fixLiterals(false);
             if (       (fModeFlags & UREGEX_MULTILINE) == 0 && (fModeFlags & UREGEX_UNIX_LINES) == 0) {
                 appendOp(URX_CARET, 0);
             } else if ((fModeFlags & UREGEX_MULTILINE) != 0 && (fModeFlags & UREGEX_UNIX_LINES) == 0) {
@@ -1144,7 +1144,7 @@ UBool RegexCompile::doParseActions(int32_t action)
 
     case doDollar:
         {
-            fixLiterals(FALSE);
+            fixLiterals(false);
             if (       (fModeFlags & UREGEX_MULTILINE) == 0 && (fModeFlags & UREGEX_UNIX_LINES) == 0) {
                 appendOp(URX_DOLLAR, 0);
             } else if ((fModeFlags & UREGEX_MULTILINE) != 0 && (fModeFlags & UREGEX_UNIX_LINES) == 0) {
@@ -1158,7 +1158,7 @@ UBool RegexCompile::doParseActions(int32_t action)
         break;
 
     case doBackslashA:
-        fixLiterals(FALSE);
+        fixLiterals(false);
         appendOp(URX_CARET, 0);
         break;
 
@@ -1169,7 +1169,7 @@ UBool RegexCompile::doParseActions(int32_t action)
                 error(U_UNSUPPORTED_ERROR);
             }
             #endif
-            fixLiterals(FALSE);
+            fixLiterals(false);
             int32_t op = (fModeFlags & UREGEX_UWORD)? URX_BACKSLASH_BU : URX_BACKSLASH_B;
             appendOp(op, 1);
         }
@@ -1182,69 +1182,69 @@ UBool RegexCompile::doParseActions(int32_t action)
                 error(U_UNSUPPORTED_ERROR);
             }
             #endif
-            fixLiterals(FALSE);
+            fixLiterals(false);
             int32_t op = (fModeFlags & UREGEX_UWORD)? URX_BACKSLASH_BU : URX_BACKSLASH_B;
             appendOp(op, 0);
         }
         break;
 
     case doBackslashD:
-        fixLiterals(FALSE);
+        fixLiterals(false);
         appendOp(URX_BACKSLASH_D, 1);
         break;
 
     case doBackslashd:
-        fixLiterals(FALSE);
+        fixLiterals(false);
         appendOp(URX_BACKSLASH_D, 0);
         break;
 
     case doBackslashG:
-        fixLiterals(FALSE);
+        fixLiterals(false);
         appendOp(URX_BACKSLASH_G, 0);
         break;
 
     case doBackslashH:
-        fixLiterals(FALSE);
+        fixLiterals(false);
         appendOp(URX_BACKSLASH_H, 1);
         break;
 
     case doBackslashh:
-        fixLiterals(FALSE);
+        fixLiterals(false);
         appendOp(URX_BACKSLASH_H, 0);
         break;
 
     case doBackslashR:
-        fixLiterals(FALSE);
+        fixLiterals(false);
         appendOp(URX_BACKSLASH_R, 0);
         break;
 
     case doBackslashS:
-        fixLiterals(FALSE);
+        fixLiterals(false);
         appendOp(URX_STAT_SETREF_N, URX_ISSPACE_SET);
         break;
 
     case doBackslashs:
-        fixLiterals(FALSE);
+        fixLiterals(false);
         appendOp(URX_STATIC_SETREF, URX_ISSPACE_SET);
         break;
 
     case doBackslashV:
-        fixLiterals(FALSE);
+        fixLiterals(false);
         appendOp(URX_BACKSLASH_V, 1);
         break;
 
     case doBackslashv:
-        fixLiterals(FALSE);
+        fixLiterals(false);
         appendOp(URX_BACKSLASH_V, 0);
         break;
 
     case doBackslashW:
-        fixLiterals(FALSE);
+        fixLiterals(false);
         appendOp(URX_STAT_SETREF_N, URX_ISWORD_SET);
         break;
 
     case doBackslashw:
-        fixLiterals(FALSE);
+        fixLiterals(false);
         appendOp(URX_STATIC_SETREF, URX_ISWORD_SET);
         break;
 
@@ -1253,17 +1253,17 @@ UBool RegexCompile::doParseActions(int32_t action)
         // Grapheme Cluster Boundary requires ICU break iteration.
         error(U_UNSUPPORTED_ERROR);
         #endif
-        fixLiterals(FALSE);
+        fixLiterals(false);
         appendOp(URX_BACKSLASH_X, 0);
         break;
 
     case doBackslashZ:
-        fixLiterals(FALSE);
+        fixLiterals(false);
         appendOp(URX_DOLLAR, 0);
         break;
 
     case doBackslashz:
-        fixLiterals(FALSE);
+        fixLiterals(false);
         appendOp(URX_BACKSLASH_Z, 0);
         break;
 
@@ -1272,13 +1272,13 @@ UBool RegexCompile::doParseActions(int32_t action)
         break;
 
     case doExit:
-        fixLiterals(FALSE);
-        returnVal = FALSE;
+        fixLiterals(false);
+        returnVal = false;
         break;
 
     case doProperty:
         {
-            fixLiterals(FALSE);
+            fixLiterals(false);
             UnicodeSet *theSet = scanProp();
             compileSet(theSet);
         }
@@ -1310,7 +1310,7 @@ UBool RegexCompile::doParseActions(int32_t action)
                     break;
                 }
                 c = peekCharLL();
-                if (RegexStaticSets::gStaticSets->fRuleDigitsAlias->contains(c) == FALSE) {
+                if (RegexStaticSets::gStaticSets->fRuleDigitsAlias->contains(c) == false) {
                     break;
                 }
                 nextCharLL();
@@ -1323,7 +1323,7 @@ UBool RegexCompile::doParseActions(int32_t action)
             //  of compilation, it will be changed to the variable's location.
             U_ASSERT(groupNum > 0);  // Shouldn't happen.  '\0' begins an octal escape sequence,
                                      //    and shouldn't enter this code path at all.
-            fixLiterals(FALSE);
+            fixLiterals(false);
             if (fModeFlags & UREGEX_CASE_INSENSITIVE) {
                 appendOp(URX_BACKREF_I, groupNum);
             } else {
@@ -1356,7 +1356,7 @@ UBool RegexCompile::doParseActions(int32_t action)
         } else {
             // Given the number, handle identically to a \n numbered back reference.
             // See comments above, under doBackRef
-            fixLiterals(FALSE);
+            fixLiterals(false);
             if (fModeFlags & UREGEX_CASE_INSENSITIVE) {
                 appendOp(URX_BACKREF_I, groupNumber);
             } else {
@@ -1383,7 +1383,7 @@ UBool RegexCompile::doParseActions(int32_t action)
         //
         {
             // Emit the STO_SP
-            int32_t   topLoc = blockTopLoc(TRUE);
+            int32_t   topLoc = blockTopLoc(true);
             int32_t   stoLoc = allocateData(1);  // Reserve the data location for storing save stack ptr.
             int32_t   op     = buildOp(URX_STO_SP, stoLoc);
             fRXPat->fCompiledPat->setElementAt(op, topLoc);
@@ -1411,7 +1411,7 @@ UBool RegexCompile::doParseActions(int32_t action)
         // TODO:  do something to cut back the state stack each time through the loop.
         {
             // Reserve two slots at the top of the block.
-            int32_t   topLoc = blockTopLoc(TRUE);
+            int32_t   topLoc = blockTopLoc(true);
             insertOp(topLoc);
 
             // emit   STO_SP     loc
@@ -1443,7 +1443,7 @@ UBool RegexCompile::doParseActions(int32_t action)
         //
         {
             // Reserve two slots at the top of the block.
-            int32_t   topLoc = blockTopLoc(TRUE);
+            int32_t   topLoc = blockTopLoc(true);
             insertOp(topLoc);
 
             // Emit the STO_SP
@@ -1464,7 +1464,7 @@ UBool RegexCompile::doParseActions(int32_t action)
 
     case doBeginMatchMode:
         fNewModeFlags = fModeFlags;
-        fSetModeFlag  = TRUE;
+        fSetModeFlag  = true;
         break;
 
     case doMatchMode:   //  (?i)    and similar
@@ -1478,7 +1478,7 @@ UBool RegexCompile::doParseActions(int32_t action)
             case 0x75: /* 'u' */   bit = 0; /* Unicode casing */  break;
             case 0x77: /* 'w' */   bit = UREGEX_UWORD;            break;
             case 0x78: /* 'x' */   bit = UREGEX_COMMENTS;         break;
-            case 0x2d: /* '-' */   fSetModeFlag = FALSE;          break;
+            case 0x2d: /* '-' */   fSetModeFlag = false;          break;
             default:
                 UPRV_UNREACHABLE_EXIT;  // Should never happen.  Other chars are filtered out
                                         // by the scanner.
@@ -1513,7 +1513,7 @@ UBool RegexCompile::doParseActions(int32_t action)
         //      - NOP, which may later be replaced by a save-state if there
         //             is an '|' alternation within the parens.
         {
-            fixLiterals(FALSE);
+            fixLiterals(false);
             appendOp(URX_NOP, 0);
             appendOp(URX_NOP, 0);
 
@@ -1539,7 +1539,7 @@ UBool RegexCompile::doParseActions(int32_t action)
         // We have just scanned a '(?'.  We now need to prevent the character scanner from
         // treating a '#' as a to-the-end-of-line comment.
         //   (This Perl compatibility just gets uglier and uglier to do...)
-        fEOLComments = FALSE;
+        fEOLComments = false;
         break;
 
 
@@ -1652,7 +1652,7 @@ UBool RegexCompile::doParseActions(int32_t action)
 
     case doSetBegin:
         {
-            fixLiterals(FALSE);
+            fixLiterals(false);
             LocalPointer<UnicodeSet> lpSet(new UnicodeSet(), *fStatus);
             fSetStack.push(lpSet.orphan(), *fStatus);
             fSetOpStack.push(setStart, *fStatus);
@@ -1862,7 +1862,7 @@ UBool RegexCompile::doParseActions(int32_t action)
     }
 
     if (U_FAILURE(*fStatus)) {
-        returnVal = FALSE;
+        returnVal = false;
     }
 
     return returnVal;
@@ -1913,12 +1913,12 @@ void    RegexCompile::fixLiterals(UBool split) {
 
     if (split) {
         fLiteralChars.truncate(indexOfLastCodePoint);
-        fixLiterals(FALSE);   // Recursive call, emit code to match the first part of the string.
+        fixLiterals(false);   // Recursive call, emit code to match the first part of the string.
                               //  Note that the truncated literal string may be empty, in which case
                               //  nothing will be emitted.
 
         literalChar(lastCodePoint);  // Re-add the last code point as if it were a new literal.
-        fixLiterals(FALSE);          // Second recursive call, code for the final code point.
+        fixLiterals(false);          // Second recursive call, code for the final code point.
         return;
     }
 
@@ -2130,15 +2130,15 @@ int32_t RegexCompile::allocateStackData(int32_t size) {
 //                          is reserved for this purpose.  .* or similar don't
 //                          and a slot needs to be added.
 //
-//       parameter reserveLoc   :  TRUE -  ensure that there is space to add an opcode
+//       parameter reserveLoc   :  true -  ensure that there is space to add an opcode
 //                                         at the returned location.
-//                                 FALSE - just return the address,
+//                                 false - just return the address,
 //                                         do not reserve a location there.
 //
 //------------------------------------------------------------------------------
 int32_t   RegexCompile::blockTopLoc(UBool reserveLoc) {
     int32_t   theLoc;
-    fixLiterals(TRUE);  // Emit code for any pending literals.
+    fixLiterals(true);  // Emit code for any pending literals.
                         //   If last item was a string, emit separate op for the its last char.
     if (fRXPat->fCompiledPat->size() == fMatchCloseParen)
     {
@@ -2189,7 +2189,7 @@ void  RegexCompile::handleCloseParen() {
     }
 
     // Emit code for any pending literals.
-    fixLiterals(FALSE);
+    fixLiterals(false);
 
     // Fixup any operations within the just-closed parenthesized group
     //    that need to reference the end of the (block).
@@ -2459,7 +2459,7 @@ void        RegexCompile::compileInterval(int32_t InitOp,  int32_t LoopOp)
 {
     // The CTR_INIT op at the top of the block with the {n,m} quantifier takes
     //   four slots in the compiled code.  Reserve them.
-    int32_t   topOfBlock = blockTopLoc(TRUE);
+    int32_t   topOfBlock = blockTopLoc(true);
     insertOp(topOfBlock);
     insertOp(topOfBlock);
     insertOp(topOfBlock);
@@ -2507,10 +2507,10 @@ UBool RegexCompile::compileInlineInterval() {
     if (fIntervalUpper > 10 || fIntervalUpper < fIntervalLow) {
         // Too big to inline.  Fail, which will cause looping code to be generated.
         //   (Upper < Lower picks up unbounded upper and errors, both.)
-        return FALSE;
+        return false;
     }
 
-    int32_t   topOfBlock = blockTopLoc(FALSE);
+    int32_t   topOfBlock = blockTopLoc(false);
     if (fIntervalUpper == 0) {
         // Pathological case.  Attempt no matches, as if the block doesn't exist.
         // Discard the generated code for the block.
@@ -2522,7 +2522,7 @@ UBool RegexCompile::compileInlineInterval() {
         if (fMatchCloseParen >= topOfBlock) {
             fMatchCloseParen = -1;
         }
-        return TRUE;
+        return true;
     }
 
     if (topOfBlock != fRXPat->fCompiledPat->size()-1 && fIntervalUpper != 1) {
@@ -2530,7 +2530,7 @@ UBool RegexCompile::compileInlineInterval() {
         //   more complex block.  Do it as a loop, not inlines.
         //   Note that things "repeated" a max of once are handled as inline, because
         //     the one copy of the code already generated is just fine.
-        return FALSE;
+        return false;
     }
 
     // Pick up the opcode that is to be repeated
@@ -2560,7 +2560,7 @@ UBool RegexCompile::compileInlineInterval() {
         }
         appendOp(op);
     }
-    return TRUE;
+    return true;
 }
 
 
@@ -2701,7 +2701,7 @@ void   RegexCompile::matchStartType() {
     int32_t    currentLen = 0;         // Minimum length of a match to this point (loc) in the pattern
     int32_t    numInitialStrings = 0;  // Number of strings encountered that could match at start.
 
-    UBool      atStart = TRUE;         // True if no part of the pattern yet encountered
+    UBool      atStart = true;         // True if no part of the pattern yet encountered
                                        //   could have advanced the position in a match.
                                        //   (Maximum match length so far == 0)
 
@@ -2777,7 +2777,7 @@ void   RegexCompile::matchStartType() {
                 numInitialStrings += 2;
             }
             currentLen = safeIncrement(currentLen, 1);
-            atStart = FALSE;
+            atStart = false;
             break;
 
 
@@ -2790,7 +2790,7 @@ void   RegexCompile::matchStartType() {
                 numInitialStrings += 2;
             }
             currentLen = safeIncrement(currentLen, 1);
-            atStart = FALSE;
+            atStart = false;
             break;
 
         case URX_LOOP_SR_I:
@@ -2803,7 +2803,7 @@ void   RegexCompile::matchStartType() {
                 fRXPat->fInitialChars->addAll(*s);
                 numInitialStrings += 2;
             }
-            atStart = FALSE;
+            atStart = false;
             break;
 
         case URX_LOOP_DOT_I:
@@ -2814,7 +2814,7 @@ void   RegexCompile::matchStartType() {
                 fRXPat->fInitialChars->complement();
                 numInitialStrings += 2;
             }
-            atStart = FALSE;
+            atStart = false;
             break;
 
 
@@ -2827,7 +2827,7 @@ void   RegexCompile::matchStartType() {
                 numInitialStrings += 2;
             }
             currentLen = safeIncrement(currentLen, 1);
-            atStart = FALSE;
+            atStart = false;
             break;
 
 
@@ -2841,7 +2841,7 @@ void   RegexCompile::matchStartType() {
                 numInitialStrings += 2;
             }
             currentLen = safeIncrement(currentLen, 1);
-            atStart = FALSE;
+            atStart = false;
             break;
 
 
@@ -2858,7 +2858,7 @@ void   RegexCompile::matchStartType() {
                  numInitialStrings += 2;
             }
             currentLen = safeIncrement(currentLen, 1);
-            atStart = FALSE;
+            atStart = false;
             break;
 
 
@@ -2875,7 +2875,7 @@ void   RegexCompile::matchStartType() {
                 numInitialStrings += 2;
             }
             currentLen = safeIncrement(currentLen, 1);
-            atStart = FALSE;
+            atStart = false;
             break;
 
 
@@ -2894,7 +2894,7 @@ void   RegexCompile::matchStartType() {
                 numInitialStrings += 2;
             }
             currentLen = safeIncrement(currentLen, 1);
-            atStart = FALSE;
+            atStart = false;
             break;
 
 
@@ -2918,7 +2918,7 @@ void   RegexCompile::matchStartType() {
                 numInitialStrings += 2;
             }
             currentLen = safeIncrement(currentLen, 1);
-            atStart = FALSE;
+            atStart = false;
             break;
 
 
@@ -2934,7 +2934,7 @@ void   RegexCompile::matchStartType() {
                 numInitialStrings += 2;
             }
             currentLen = safeIncrement(currentLen, 1);
-            atStart = FALSE;
+            atStart = false;
             break;
 
 
@@ -2957,21 +2957,21 @@ void   RegexCompile::matchStartType() {
                     }
                 }
             }
-            atStart = FALSE;
+            atStart = false;
             break;
 
         case URX_JMP_SAV:
         case URX_JMP_SAV_X:
             // Combo of state save to the next loc, + jmp backwards.
             //   Net effect on min. length computation is nothing.
-            atStart = FALSE;
+            atStart = false;
             break;
 
         case URX_BACKTRACK:
             // Fails are kind of like a branch, except that the min length was
             //   propagated already, by the state save.
             currentLen = forwardedLength.elementAti(loc+1);
-            atStart = FALSE;
+            atStart = false;
             break;
 
 
@@ -2986,7 +2986,7 @@ void   RegexCompile::matchStartType() {
                     }
                 }
             }
-            atStart = FALSE;
+            atStart = false;
             break;
 
 
@@ -3014,7 +3014,7 @@ void   RegexCompile::matchStartType() {
                 }
 
                 currentLen = safeIncrement(currentLen, stringLen);
-                atStart = FALSE;
+                atStart = false;
             }
             break;
 
@@ -3039,7 +3039,7 @@ void   RegexCompile::matchStartType() {
                     numInitialStrings += 2;  // Matching on an initial string not possible.
                 }
                 currentLen = safeIncrement(currentLen, stringLen);
-                atStart = FALSE;
+                atStart = false;
             }
             break;
 
@@ -3067,7 +3067,7 @@ void   RegexCompile::matchStartType() {
                 }
                 loc+=3;  // Skips over operands of CTR_INIT
             }
-            atStart = FALSE;
+            atStart = false;
             break;
 
 
@@ -3075,13 +3075,13 @@ void   RegexCompile::matchStartType() {
         case URX_CTR_LOOP_NG:
             // Loop ops.
             //  The jump is conditional, backwards only.
-            atStart = FALSE;
+            atStart = false;
             break;
 
         case URX_LOOP_C:
             // More loop ops.  These state-save to themselves.
             //   don't change the minimum match
-            atStart = FALSE;
+            atStart = false;
             break;
 
 
@@ -3177,7 +3177,7 @@ void   RegexCompile::matchStartType() {
         fRXPat->fStartType   = START_CHAR;
         fRXPat->fInitialChar = fRXPat->fInitialChars->charAt(0);
         U_ASSERT(fRXPat->fInitialChar != (UChar32)-1);
-    } else if (fRXPat->fInitialChars->contains((UChar32)0, (UChar32)0x10ffff) == FALSE &&
+    } else if (fRXPat->fInitialChars->contains((UChar32)0, (UChar32)0x10ffff) == false &&
         fRXPat->fMinMatchLen > 0) {
         // Matches start with a set of character smaller than the set of all chars.
         fRXPat->fStartType = START_SET;
@@ -3834,7 +3834,7 @@ void RegexCompile::stripNOPs() {
                 fRXPat->fCompiledPat->setElementAt(op, dst);
                 dst++;
 
-                fRXPat->fNeedsAltInput = TRUE;
+                fRXPat->fNeedsAltInput = true;
                 break;
             }
         case URX_RESERVED_OP:
@@ -4032,13 +4032,13 @@ void RegexCompile::nextChar(RegexPatternChar &c) {
   tailRecursion:
     fScanIndex = UTEXT_GETNATIVEINDEX(fRXPat->fPattern);
     c.fChar    = nextCharLL();
-    c.fQuoted  = FALSE;
+    c.fQuoted  = false;
 
     if (fQuoteMode) {
-        c.fQuoted = TRUE;
+        c.fQuoted = true;
         if ((c.fChar==chBackSlash && peekCharLL()==chE && ((fModeFlags & UREGEX_LITERAL) == 0)) ||
             c.fChar == (UChar32)-1) {
-            fQuoteMode = FALSE;  //  Exit quote mode,
+            fQuoteMode = false;  //  Exit quote mode,
             nextCharLL();        // discard the E
             // nextChar(c);      // recurse to get the real next char
             goto tailRecursion;  // Note: fuzz testing produced testcases that
@@ -4050,7 +4050,7 @@ void RegexCompile::nextChar(RegexPatternChar &c) {
         // Don't check for any further escapes, just return it as-is.
         // Don't set c.fQuoted, because that would prevent the state machine from
         //    dispatching on the character.
-        fInBackslashQuote = FALSE;
+        fInBackslashQuote = false;
     }
     else
     {
@@ -4065,7 +4065,7 @@ void RegexCompile::nextChar(RegexPatternChar &c) {
                 if (c.fChar == (UChar32)-1) {
                     break;     // End of Input
                 }
-                if  (c.fChar == chPound && fEOLComments == TRUE) {
+                if  (c.fChar == chPound && fEOLComments == true) {
                     // Start of a comment.  Consume the rest of it, until EOF or a new line
                     for (;;) {
                         c.fChar = nextCharLL();
@@ -4079,7 +4079,7 @@ void RegexCompile::nextChar(RegexPatternChar &c) {
                     }
                 }
                 // TODO:  check what Java & Perl do with non-ASCII white spaces.  Ticket 6061.
-                if (PatternProps::isWhiteSpace(c.fChar) == FALSE) {
+                if (PatternProps::isWhiteSpace(c.fChar) == false) {
                     break;
                 }
                 c.fChar = nextCharLL();
@@ -4098,7 +4098,7 @@ void RegexCompile::nextChar(RegexPatternChar &c) {
                 //   Return the single equivalent character.
                 //
                 nextCharLL();                 // get & discard the peeked char.
-                c.fQuoted = TRUE;
+                c.fQuoted = true;
 
                 if (UTEXT_FULL_TEXT_IN_CHUNK(fRXPat->fPattern, fPatternLength)) {
                     int32_t endIndex = (int32_t)pos;
@@ -4155,11 +4155,11 @@ void RegexCompile::nextChar(RegexPatternChar &c) {
                         c.fChar >>= 3;
                     }
                 }
-                c.fQuoted = TRUE;
+                c.fQuoted = true;
             }
             else if (peekCharLL() == chQ) {
                 //  "\Q"  enter quote mode, which will continue until "\E"
-                fQuoteMode = TRUE;
+                fQuoteMode = true;
                 nextCharLL();        // discard the 'Q'.
                 // nextChar(c);      // recurse to get the real next char.
                 goto tailRecursion;  // Note: fuzz testing produced test cases that
@@ -4170,7 +4170,7 @@ void RegexCompile::nextChar(RegexPatternChar &c) {
                 // We are in a '\' escape that will be handled by the state table scanner.
                 // Just return the backslash, but remember that the following char is to
                 //  be taken literally.
-                fInBackslashQuote = TRUE;
+                fInBackslashQuote = true;
             }
         }
     }
@@ -4178,7 +4178,7 @@ void RegexCompile::nextChar(RegexPatternChar &c) {
     // re-enable # to end-of-line comments, in case they were disabled.
     // They are disabled by the parser upon seeing '(?', but this lasts for
     //  the fetching of the next character only.
-    fEOLComments = TRUE;
+    fEOLComments = true;
 
     // putc(c.fChar, stdout);
 }
@@ -4331,17 +4331,17 @@ UnicodeSet *RegexCompile::scanPosixProp() {
     //   ending on the second closing ].
 
     UnicodeString propName;
-    UBool         negated  = FALSE;
+    UBool         negated  = false;
 
     // Check for and consume the '^' in a negated POSIX property, e.g.  [:^Letter:]
     nextChar(fC);
     if (fC.fChar == chUp) {
-       negated = TRUE;
+       negated = true;
        nextChar(fC);
     }
 
     // Scan for the closing ":]", collecting the property name along the way.
-    UBool  sawPropSetTerminator = FALSE;
+    UBool  sawPropSetTerminator = false;
     for (;;) {
         propName.append(fC.fChar);
         nextChar(fC);
@@ -4352,7 +4352,7 @@ UnicodeSet *RegexCompile::scanPosixProp() {
         if (fC.fChar == chColon) {
             nextChar(fC);
             if (fC.fChar == chRBracket) {
-                sawPropSetTerminator = TRUE;
+                sawPropSetTerminator = true;
             }
             break;
         }
@@ -4613,13 +4613,13 @@ void RegexCompile::setEval(int32_t nextOp) {
     UnicodeSet *rightOperand = NULL;
     UnicodeSet *leftOperand  = NULL;
     for (;;) {
-        U_ASSERT(fSetOpStack.empty()==FALSE);
+        U_ASSERT(fSetOpStack.empty()==false);
         int32_t pendingSetOperation = fSetOpStack.peeki();
         if ((pendingSetOperation&0xffff0000) < (nextOp&0xffff0000)) {
             break;
         }
         fSetOpStack.popi();
-        U_ASSERT(fSetStack.empty() == FALSE);
+        U_ASSERT(fSetStack.empty() == false);
         rightOperand = (UnicodeSet *)fSetStack.peek();
         // ICU 70 adds emoji properties of strings, but createSetForProperty() removes all strings
         // (see comments there).
diff --git a/deps/icu-small/source/i18n/regexcmp.h b/deps/icu-small/source/i18n/regexcmp.h
index 9e1aa170f0..81ac9e5178 100644
--- a/deps/icu-small/source/i18n/regexcmp.h
+++ b/deps/icu-small/source/i18n/regexcmp.h
@@ -37,7 +37,6 @@ U_NAMESPACE_BEGIN
 //  class RegexCompile    Contains the regular expression compiler.
 //
 //--------------------------------------------------------------------------------
-struct  RegexTableEl;
 class   RegexPattern;
 
 
@@ -65,9 +64,6 @@ public:
 
     void        nextChar(RegexPatternChar &c);      // Get the next char from the input stream.
 
-    static void cleanup();                       // Memory cleanup
-
-
 
     // Categories of parentheses in pattern.
     //   The category is saved in the compile-time parentheses stack frame, and
@@ -154,12 +150,6 @@ private:
     RegexPatternChar              fC;                // Current char for parse state machine
                                                      //   processing.
 
-    //
-    //   Data for the state machine that parses the regular expression.
-    //
-    RegexTableEl                  **fStateTable;     // State Transition Table for regex Rule
-                                                     //   parsing.  index by p[state][char-class]
-
     uint16_t                      fStack[kStackSize];  // State stack, holds state pushes
     int32_t                       fStackPtr;           //  and pops as specified in the state
                                                        //  transition rules.
@@ -211,10 +201,6 @@ private:
                                                      //   -1 for the upper interval value means none
                                                      //   was specified (unlimited occurrences.)
 
-    int64_t                       fNameStartPos;     // Starting position of a \N{NAME} name in a
-                                                     //   pattern, valid while remainder of name is
-                                                     //   scanned.
-
     UStack                        fSetStack;         // Stack of UnicodeSets, used while evaluating
                                                      //   (at compile time) set expressions within
                                                      //   the pattern.
diff --git a/deps/icu-small/source/i18n/regexcst.h b/deps/icu-small/source/i18n/regexcst.h
index d44c2aec2b..a475b6b363 100644
--- a/deps/icu-small/source/i18n/regexcst.h
+++ b/deps/icu-small/source/i18n/regexcst.h
@@ -149,213 +149,213 @@ struct RegexTableEl {
 };
 
 static const struct RegexTableEl gRuleParseStateTable[] = {
-    {doNOP, 0, 0, 0, TRUE}
-    , {doPatStart, 255, 2,0,  FALSE}     //  1      start
-    , {doLiteralChar, 254, 14,0,  TRUE}     //  2      term
-    , {doLiteralChar, 130, 14,0,  TRUE}     //  3 
-    , {doSetBegin, 91 /* [ */, 123, 205, TRUE}     //  4 
-    , {doNOP, 40 /* ( */, 27,0,  TRUE}     //  5 
-    , {doDotAny, 46 /* . */, 14,0,  TRUE}     //  6 
-    , {doCaret, 94 /* ^ */, 14,0,  TRUE}     //  7 
-    , {doDollar, 36 /* $ */, 14,0,  TRUE}     //  8 
-    , {doNOP, 92 /* \ */, 89,0,  TRUE}     //  9 
-    , {doOrOperator, 124 /* | */, 2,0,  TRUE}     //  10 
-    , {doCloseParen, 41 /* ) */, 255,0,  TRUE}     //  11 
-    , {doPatFinish, 253, 2,0,  FALSE}     //  12 
-    , {doRuleError, 255, 206,0,  FALSE}     //  13 
-    , {doNOP, 42 /* * */, 68,0,  TRUE}     //  14      expr-quant
-    , {doNOP, 43 /* + */, 71,0,  TRUE}     //  15 
-    , {doNOP, 63 /* ? */, 74,0,  TRUE}     //  16 
-    , {doIntervalInit, 123 /* { */, 77,0,  TRUE}     //  17 
-    , {doNOP, 40 /* ( */, 23,0,  TRUE}     //  18 
-    , {doNOP, 255, 20,0,  FALSE}     //  19 
-    , {doOrOperator, 124 /* | */, 2,0,  TRUE}     //  20      expr-cont
-    , {doCloseParen, 41 /* ) */, 255,0,  TRUE}     //  21 
-    , {doNOP, 255, 2,0,  FALSE}     //  22 
-    , {doSuppressComments, 63 /* ? */, 25,0,  TRUE}     //  23      open-paren-quant
-    , {doNOP, 255, 27,0,  FALSE}     //  24 
-    , {doNOP, 35 /* # */, 50, 14, TRUE}     //  25      open-paren-quant2
-    , {doNOP, 255, 29,0,  FALSE}     //  26 
-    , {doSuppressComments, 63 /* ? */, 29,0,  TRUE}     //  27      open-paren
-    , {doOpenCaptureParen, 255, 2, 14, FALSE}     //  28 
-    , {doOpenNonCaptureParen, 58 /* : */, 2, 14, TRUE}     //  29      open-paren-extended
-    , {doOpenAtomicParen, 62 /* > */, 2, 14, TRUE}     //  30 
-    , {doOpenLookAhead, 61 /* = */, 2, 20, TRUE}     //  31 
-    , {doOpenLookAheadNeg, 33 /* ! */, 2, 20, TRUE}     //  32 
-    , {doNOP, 60 /* < */, 46,0,  TRUE}     //  33 
-    , {doNOP, 35 /* # */, 50, 2, TRUE}     //  34 
-    , {doBeginMatchMode, 105 /* i */, 53,0,  FALSE}     //  35 
-    , {doBeginMatchMode, 100 /* d */, 53,0,  FALSE}     //  36 
-    , {doBeginMatchMode, 109 /* m */, 53,0,  FALSE}     //  37 
-    , {doBeginMatchMode, 115 /* s */, 53,0,  FALSE}     //  38 
-    , {doBeginMatchMode, 117 /* u */, 53,0,  FALSE}     //  39 
-    , {doBeginMatchMode, 119 /* w */, 53,0,  FALSE}     //  40 
-    , {doBeginMatchMode, 120 /* x */, 53,0,  FALSE}     //  41 
-    , {doBeginMatchMode, 45 /* - */, 53,0,  FALSE}     //  42 
-    , {doConditionalExpr, 40 /* ( */, 206,0,  TRUE}     //  43 
-    , {doPerlInline, 123 /* { */, 206,0,  TRUE}     //  44 
-    , {doBadOpenParenType, 255, 206,0,  FALSE}     //  45 
-    , {doOpenLookBehind, 61 /* = */, 2, 20, TRUE}     //  46      open-paren-lookbehind
-    , {doOpenLookBehindNeg, 33 /* ! */, 2, 20, TRUE}     //  47 
-    , {doBeginNamedCapture, 129, 64,0,  FALSE}     //  48 
-    , {doBadOpenParenType, 255, 206,0,  FALSE}     //  49 
-    , {doNOP, 41 /* ) */, 255,0,  TRUE}     //  50      paren-comment
-    , {doMismatchedParenErr, 253, 206,0,  FALSE}     //  51 
-    , {doNOP, 255, 50,0,  TRUE}     //  52 
-    , {doMatchMode, 105 /* i */, 53,0,  TRUE}     //  53      paren-flag
-    , {doMatchMode, 100 /* d */, 53,0,  TRUE}     //  54 
-    , {doMatchMode, 109 /* m */, 53,0,  TRUE}     //  55 
-    , {doMatchMode, 115 /* s */, 53,0,  TRUE}     //  56 
-    , {doMatchMode, 117 /* u */, 53,0,  TRUE}     //  57 
-    , {doMatchMode, 119 /* w */, 53,0,  TRUE}     //  58 
-    , {doMatchMode, 120 /* x */, 53,0,  TRUE}     //  59 
-    , {doMatchMode, 45 /* - */, 53,0,  TRUE}     //  60 
-    , {doSetMatchMode, 41 /* ) */, 2,0,  TRUE}     //  61 
-    , {doMatchModeParen, 58 /* : */, 2, 14, TRUE}     //  62 
-    , {doBadModeFlag, 255, 206,0,  FALSE}     //  63 
-    , {doContinueNamedCapture, 129, 64,0,  TRUE}     //  64      named-capture
-    , {doContinueNamedCapture, 128, 64,0,  TRUE}     //  65 
-    , {doOpenCaptureParen, 62 /* > */, 2, 14, TRUE}     //  66 
-    , {doBadNamedCapture, 255, 206,0,  FALSE}     //  67 
-    , {doNGStar, 63 /* ? */, 20,0,  TRUE}     //  68      quant-star
-    , {doPossessiveStar, 43 /* + */, 20,0,  TRUE}     //  69 
-    , {doStar, 255, 20,0,  FALSE}     //  70 
-    , {doNGPlus, 63 /* ? */, 20,0,  TRUE}     //  71      quant-plus
-    , {doPossessivePlus, 43 /* + */, 20,0,  TRUE}     //  72 
-    , {doPlus, 255, 20,0,  FALSE}     //  73 
-    , {doNGOpt, 63 /* ? */, 20,0,  TRUE}     //  74      quant-opt
-    , {doPossessiveOpt, 43 /* + */, 20,0,  TRUE}     //  75 
-    , {doOpt, 255, 20,0,  FALSE}     //  76 
-    , {doNOP, 128, 79,0,  FALSE}     //  77      interval-open
-    , {doIntervalError, 255, 206,0,  FALSE}     //  78 
-    , {doIntevalLowerDigit, 128, 79,0,  TRUE}     //  79      interval-lower
-    , {doNOP, 44 /* , */, 83,0,  TRUE}     //  80 
-    , {doIntervalSame, 125 /* } */, 86,0,  TRUE}     //  81 
-    , {doIntervalError, 255, 206,0,  FALSE}     //  82 
-    , {doIntervalUpperDigit, 128, 83,0,  TRUE}     //  83      interval-upper
-    , {doNOP, 125 /* } */, 86,0,  TRUE}     //  84 
-    , {doIntervalError, 255, 206,0,  FALSE}     //  85 
-    , {doNGInterval, 63 /* ? */, 20,0,  TRUE}     //  86      interval-type
-    , {doPossessiveInterval, 43 /* + */, 20,0,  TRUE}     //  87 
-    , {doInterval, 255, 20,0,  FALSE}     //  88 
-    , {doBackslashA, 65 /* A */, 2,0,  TRUE}     //  89      backslash
-    , {doBackslashB, 66 /* B */, 2,0,  TRUE}     //  90 
-    , {doBackslashb, 98 /* b */, 2,0,  TRUE}     //  91 
-    , {doBackslashd, 100 /* d */, 14,0,  TRUE}     //  92 
-    , {doBackslashD, 68 /* D */, 14,0,  TRUE}     //  93 
-    , {doBackslashG, 71 /* G */, 2,0,  TRUE}     //  94 
-    , {doBackslashh, 104 /* h */, 14,0,  TRUE}     //  95 
-    , {doBackslashH, 72 /* H */, 14,0,  TRUE}     //  96 
-    , {doNOP, 107 /* k */, 115,0,  TRUE}     //  97 
-    , {doNamedChar, 78 /* N */, 14,0,  FALSE}     //  98 
-    , {doProperty, 112 /* p */, 14,0,  FALSE}     //  99 
-    , {doProperty, 80 /* P */, 14,0,  FALSE}     //  100 
-    , {doBackslashR, 82 /* R */, 14,0,  TRUE}     //  101 
-    , {doEnterQuoteMode, 81 /* Q */, 2,0,  TRUE}     //  102 
-    , {doBackslashS, 83 /* S */, 14,0,  TRUE}     //  103 
-    , {doBackslashs, 115 /* s */, 14,0,  TRUE}     //  104 
-    , {doBackslashv, 118 /* v */, 14,0,  TRUE}     //  105 
-    , {doBackslashV, 86 /* V */, 14,0,  TRUE}     //  106 
-    , {doBackslashW, 87 /* W */, 14,0,  TRUE}     //  107 
-    , {doBackslashw, 119 /* w */, 14,0,  TRUE}     //  108 
-    , {doBackslashX, 88 /* X */, 14,0,  TRUE}     //  109 
-    , {doBackslashZ, 90 /* Z */, 2,0,  TRUE}     //  110 
-    , {doBackslashz, 122 /* z */, 2,0,  TRUE}     //  111 
-    , {doBackRef, 128, 14,0,  TRUE}     //  112 
-    , {doEscapeError, 253, 206,0,  FALSE}     //  113 
-    , {doEscapedLiteralChar, 255, 14,0,  TRUE}     //  114 
-    , {doBeginNamedBackRef, 60 /* < */, 117,0,  TRUE}     //  115      named-backref
-    , {doBadNamedCapture, 255, 206,0,  FALSE}     //  116 
-    , {doContinueNamedBackRef, 129, 119,0,  TRUE}     //  117      named-backref-2
-    , {doBadNamedCapture, 255, 206,0,  FALSE}     //  118 
-    , {doContinueNamedBackRef, 129, 119,0,  TRUE}     //  119      named-backref-3
-    , {doContinueNamedBackRef, 128, 119,0,  TRUE}     //  120 
-    , {doCompleteNamedBackRef, 62 /* > */, 14,0,  TRUE}     //  121 
-    , {doBadNamedCapture, 255, 206,0,  FALSE}     //  122 
-    , {doSetNegate, 94 /* ^ */, 126,0,  TRUE}     //  123      set-open
-    , {doSetPosixProp, 58 /* : */, 128,0,  FALSE}     //  124 
-    , {doNOP, 255, 126,0,  FALSE}     //  125 
-    , {doSetLiteral, 93 /* ] */, 141,0,  TRUE}     //  126      set-open2
-    , {doNOP, 255, 131,0,  FALSE}     //  127 
-    , {doSetEnd, 93 /* ] */, 255,0,  TRUE}     //  128      set-posix
-    , {doNOP, 58 /* : */, 131,0,  FALSE}     //  129 
-    , {doRuleError, 255, 206,0,  FALSE}     //  130 
-    , {doSetEnd, 93 /* ] */, 255,0,  TRUE}     //  131      set-start
-    , {doSetBeginUnion, 91 /* [ */, 123, 148, TRUE}     //  132 
-    , {doNOP, 92 /* \ */, 191,0,  TRUE}     //  133 
-    , {doNOP, 45 /* - */, 137,0,  TRUE}     //  134 
-    , {doNOP, 38 /* & */, 139,0,  TRUE}     //  135 
-    , {doSetLiteral, 255, 141,0,  TRUE}     //  136 
-    , {doRuleError, 45 /* - */, 206,0,  FALSE}     //  137      set-start-dash
-    , {doSetAddDash, 255, 141,0,  FALSE}     //  138 
-    , {doRuleError, 38 /* & */, 206,0,  FALSE}     //  139      set-start-amp
-    , {doSetAddAmp, 255, 141,0,  FALSE}     //  140 
-    , {doSetEnd, 93 /* ] */, 255,0,  TRUE}     //  141      set-after-lit
-    , {doSetBeginUnion, 91 /* [ */, 123, 148, TRUE}     //  142 
-    , {doNOP, 45 /* - */, 178,0,  TRUE}     //  143 
-    , {doNOP, 38 /* & */, 169,0,  TRUE}     //  144 
-    , {doNOP, 92 /* \ */, 191,0,  TRUE}     //  145 
-    , {doSetNoCloseError, 253, 206,0,  FALSE}     //  146 
-    , {doSetLiteral, 255, 141,0,  TRUE}     //  147 
-    , {doSetEnd, 93 /* ] */, 255,0,  TRUE}     //  148      set-after-set
-    , {doSetBeginUnion, 91 /* [ */, 123, 148, TRUE}     //  149 
-    , {doNOP, 45 /* - */, 171,0,  TRUE}     //  150 
-    , {doNOP, 38 /* & */, 166,0,  TRUE}     //  151 
-    , {doNOP, 92 /* \ */, 191,0,  TRUE}     //  152 
-    , {doSetNoCloseError, 253, 206,0,  FALSE}     //  153 
-    , {doSetLiteral, 255, 141,0,  TRUE}     //  154 
-    , {doSetEnd, 93 /* ] */, 255,0,  TRUE}     //  155      set-after-range
-    , {doSetBeginUnion, 91 /* [ */, 123, 148, TRUE}     //  156 
-    , {doNOP, 45 /* - */, 174,0,  TRUE}     //  157 
-    , {doNOP, 38 /* & */, 176,0,  TRUE}     //  158 
-    , {doNOP, 92 /* \ */, 191,0,  TRUE}     //  159 
-    , {doSetNoCloseError, 253, 206,0,  FALSE}     //  160 
-    , {doSetLiteral, 255, 141,0,  TRUE}     //  161 
-    , {doSetBeginUnion, 91 /* [ */, 123, 148, TRUE}     //  162      set-after-op
-    , {doSetOpError, 93 /* ] */, 206,0,  FALSE}     //  163 
-    , {doNOP, 92 /* \ */, 191,0,  TRUE}     //  164 
-    , {doSetLiteral, 255, 141,0,  TRUE}     //  165 
-    , {doSetBeginIntersection1, 91 /* [ */, 123, 148, TRUE}     //  166      set-set-amp
-    , {doSetIntersection2, 38 /* & */, 162,0,  TRUE}     //  167 
-    , {doSetAddAmp, 255, 141,0,  FALSE}     //  168 
-    , {doSetIntersection2, 38 /* & */, 162,0,  TRUE}     //  169      set-lit-amp
-    , {doSetAddAmp, 255, 141,0,  FALSE}     //  170 
-    , {doSetBeginDifference1, 91 /* [ */, 123, 148, TRUE}     //  171      set-set-dash
-    , {doSetDifference2, 45 /* - */, 162,0,  TRUE}     //  172 
-    , {doSetAddDash, 255, 141,0,  FALSE}     //  173 
-    , {doSetDifference2, 45 /* - */, 162,0,  TRUE}     //  174      set-range-dash
-    , {doSetAddDash, 255, 141,0,  FALSE}     //  175 
-    , {doSetIntersection2, 38 /* & */, 162,0,  TRUE}     //  176      set-range-amp
-    , {doSetAddAmp, 255, 141,0,  FALSE}     //  177 
-    , {doSetDifference2, 45 /* - */, 162,0,  TRUE}     //  178      set-lit-dash
-    , {doSetAddDash, 91 /* [ */, 141,0,  FALSE}     //  179 
-    , {doSetAddDash, 93 /* ] */, 141,0,  FALSE}     //  180 
-    , {doNOP, 92 /* \ */, 183,0,  TRUE}     //  181 
-    , {doSetRange, 255, 155,0,  TRUE}     //  182 
-    , {doSetOpError, 115 /* s */, 206,0,  FALSE}     //  183      set-lit-dash-escape
-    , {doSetOpError, 83 /* S */, 206,0,  FALSE}     //  184 
-    , {doSetOpError, 119 /* w */, 206,0,  FALSE}     //  185 
-    , {doSetOpError, 87 /* W */, 206,0,  FALSE}     //  186 
-    , {doSetOpError, 100 /* d */, 206,0,  FALSE}     //  187 
-    , {doSetOpError, 68 /* D */, 206,0,  FALSE}     //  188 
-    , {doSetNamedRange, 78 /* N */, 155,0,  FALSE}     //  189 
-    , {doSetRange, 255, 155,0,  TRUE}     //  190 
-    , {doSetProp, 112 /* p */, 148,0,  FALSE}     //  191      set-escape
-    , {doSetProp, 80 /* P */, 148,0,  FALSE}     //  192 
-    , {doSetNamedChar, 78 /* N */, 141,0,  FALSE}     //  193 
-    , {doSetBackslash_s, 115 /* s */, 155,0,  TRUE}     //  194 
-    , {doSetBackslash_S, 83 /* S */, 155,0,  TRUE}     //  195 
-    , {doSetBackslash_w, 119 /* w */, 155,0,  TRUE}     //  196 
-    , {doSetBackslash_W, 87 /* W */, 155,0,  TRUE}     //  197 
-    , {doSetBackslash_d, 100 /* d */, 155,0,  TRUE}     //  198 
-    , {doSetBackslash_D, 68 /* D */, 155,0,  TRUE}     //  199 
-    , {doSetBackslash_h, 104 /* h */, 155,0,  TRUE}     //  200 
-    , {doSetBackslash_H, 72 /* H */, 155,0,  TRUE}     //  201 
-    , {doSetBackslash_v, 118 /* v */, 155,0,  TRUE}     //  202 
-    , {doSetBackslash_V, 86 /* V */, 155,0,  TRUE}     //  203 
-    , {doSetLiteralEscaped, 255, 141,0,  TRUE}     //  204 
-    , {doSetFinish, 255, 14,0,  FALSE}     //  205      set-finish
-    , {doExit, 255, 206,0,  TRUE}     //  206      errorDeath
+    {doNOP, 0, 0, 0, true}
+    , {doPatStart, 255, 2,0,  false}     //  1      start
+    , {doLiteralChar, 254, 14,0,  true}     //  2      term
+    , {doLiteralChar, 130, 14,0,  true}     //  3 
+    , {doSetBegin, 91 /* [ */, 123, 205, true}     //  4 
+    , {doNOP, 40 /* ( */, 27,0,  true}     //  5 
+    , {doDotAny, 46 /* . */, 14,0,  true}     //  6 
+    , {doCaret, 94 /* ^ */, 14,0,  true}     //  7 
+    , {doDollar, 36 /* $ */, 14,0,  true}     //  8 
+    , {doNOP, 92 /* \ */, 89,0,  true}     //  9 
+    , {doOrOperator, 124 /* | */, 2,0,  true}     //  10 
+    , {doCloseParen, 41 /* ) */, 255,0,  true}     //  11 
+    , {doPatFinish, 253, 2,0,  false}     //  12 
+    , {doRuleError, 255, 206,0,  false}     //  13 
+    , {doNOP, 42 /* * */, 68,0,  true}     //  14      expr-quant
+    , {doNOP, 43 /* + */, 71,0,  true}     //  15 
+    , {doNOP, 63 /* ? */, 74,0,  true}     //  16 
+    , {doIntervalInit, 123 /* { */, 77,0,  true}     //  17 
+    , {doNOP, 40 /* ( */, 23,0,  true}     //  18 
+    , {doNOP, 255, 20,0,  false}     //  19 
+    , {doOrOperator, 124 /* | */, 2,0,  true}     //  20      expr-cont
+    , {doCloseParen, 41 /* ) */, 255,0,  true}     //  21 
+    , {doNOP, 255, 2,0,  false}     //  22 
+    , {doSuppressComments, 63 /* ? */, 25,0,  true}     //  23      open-paren-quant
+    , {doNOP, 255, 27,0,  false}     //  24 
+    , {doNOP, 35 /* # */, 50, 14, true}     //  25      open-paren-quant2
+    , {doNOP, 255, 29,0,  false}     //  26 
+    , {doSuppressComments, 63 /* ? */, 29,0,  true}     //  27      open-paren
+    , {doOpenCaptureParen, 255, 2, 14, false}     //  28 
+    , {doOpenNonCaptureParen, 58 /* : */, 2, 14, true}     //  29      open-paren-extended
+    , {doOpenAtomicParen, 62 /* > */, 2, 14, true}     //  30 
+    , {doOpenLookAhead, 61 /* = */, 2, 20, true}     //  31 
+    , {doOpenLookAheadNeg, 33 /* ! */, 2, 20, true}     //  32 
+    , {doNOP, 60 /* < */, 46,0,  true}     //  33 
+    , {doNOP, 35 /* # */, 50, 2, true}     //  34 
+    , {doBeginMatchMode, 105 /* i */, 53,0,  false}     //  35 
+    , {doBeginMatchMode, 100 /* d */, 53,0,  false}     //  36 
+    , {doBeginMatchMode, 109 /* m */, 53,0,  false}     //  37 
+    , {doBeginMatchMode, 115 /* s */, 53,0,  false}     //  38 
+    , {doBeginMatchMode, 117 /* u */, 53,0,  false}     //  39 
+    , {doBeginMatchMode, 119 /* w */, 53,0,  false}     //  40 
+    , {doBeginMatchMode, 120 /* x */, 53,0,  false}     //  41 
+    , {doBeginMatchMode, 45 /* - */, 53,0,  false}     //  42 
+    , {doConditionalExpr, 40 /* ( */, 206,0,  true}     //  43 
+    , {doPerlInline, 123 /* { */, 206,0,  true}     //  44 
+    , {doBadOpenParenType, 255, 206,0,  false}     //  45 
+    , {doOpenLookBehind, 61 /* = */, 2, 20, true}     //  46      open-paren-lookbehind
+    , {doOpenLookBehindNeg, 33 /* ! */, 2, 20, true}     //  47 
+    , {doBeginNamedCapture, 129, 64,0,  false}     //  48 
+    , {doBadOpenParenType, 255, 206,0,  false}     //  49 
+    , {doNOP, 41 /* ) */, 255,0,  true}     //  50      paren-comment
+    , {doMismatchedParenErr, 253, 206,0,  false}     //  51 
+    , {doNOP, 255, 50,0,  true}     //  52 
+    , {doMatchMode, 105 /* i */, 53,0,  true}     //  53      paren-flag
+    , {doMatchMode, 100 /* d */, 53,0,  true}     //  54 
+    , {doMatchMode, 109 /* m */, 53,0,  true}     //  55 
+    , {doMatchMode, 115 /* s */, 53,0,  true}     //  56 
+    , {doMatchMode, 117 /* u */, 53,0,  true}     //  57 
+    , {doMatchMode, 119 /* w */, 53,0,  true}     //  58 
+    , {doMatchMode, 120 /* x */, 53,0,  true}     //  59 
+    , {doMatchMode, 45 /* - */, 53,0,  true}     //  60 
+    , {doSetMatchMode, 41 /* ) */, 2,0,  true}     //  61 
+    , {doMatchModeParen, 58 /* : */, 2, 14, true}     //  62 
+    , {doBadModeFlag, 255, 206,0,  false}     //  63 
+    , {doContinueNamedCapture, 129, 64,0,  true}     //  64      named-capture
+    , {doContinueNamedCapture, 128, 64,0,  true}     //  65 
+    , {doOpenCaptureParen, 62 /* > */, 2, 14, true}     //  66 
+    , {doBadNamedCapture, 255, 206,0,  false}     //  67 
+    , {doNGStar, 63 /* ? */, 20,0,  true}     //  68      quant-star
+    , {doPossessiveStar, 43 /* + */, 20,0,  true}     //  69 
+    , {doStar, 255, 20,0,  false}     //  70 
+    , {doNGPlus, 63 /* ? */, 20,0,  true}     //  71      quant-plus
+    , {doPossessivePlus, 43 /* + */, 20,0,  true}     //  72 
+    , {doPlus, 255, 20,0,  false}     //  73 
+    , {doNGOpt, 63 /* ? */, 20,0,  true}     //  74      quant-opt
+    , {doPossessiveOpt, 43 /* + */, 20,0,  true}     //  75 
+    , {doOpt, 255, 20,0,  false}     //  76 
+    , {doNOP, 128, 79,0,  false}     //  77      interval-open
+    , {doIntervalError, 255, 206,0,  false}     //  78 
+    , {doIntevalLowerDigit, 128, 79,0,  true}     //  79      interval-lower
+    , {doNOP, 44 /* , */, 83,0,  true}     //  80 
+    , {doIntervalSame, 125 /* } */, 86,0,  true}     //  81 
+    , {doIntervalError, 255, 206,0,  false}     //  82 
+    , {doIntervalUpperDigit, 128, 83,0,  true}     //  83      interval-upper
+    , {doNOP, 125 /* } */, 86,0,  true}     //  84 
+    , {doIntervalError, 255, 206,0,  false}     //  85 
+    , {doNGInterval, 63 /* ? */, 20,0,  true}     //  86      interval-type
+    , {doPossessiveInterval, 43 /* + */, 20,0,  true}     //  87 
+    , {doInterval, 255, 20,0,  false}     //  88 
+    , {doBackslashA, 65 /* A */, 2,0,  true}     //  89      backslash
+    , {doBackslashB, 66 /* B */, 2,0,  true}     //  90 
+    , {doBackslashb, 98 /* b */, 2,0,  true}     //  91 
+    , {doBackslashd, 100 /* d */, 14,0,  true}     //  92 
+    , {doBackslashD, 68 /* D */, 14,0,  true}     //  93 
+    , {doBackslashG, 71 /* G */, 2,0,  true}     //  94 
+    , {doBackslashh, 104 /* h */, 14,0,  true}     //  95 
+    , {doBackslashH, 72 /* H */, 14,0,  true}     //  96 
+    , {doNOP, 107 /* k */, 115,0,  true}     //  97 
+    , {doNamedChar, 78 /* N */, 14,0,  false}     //  98 
+    , {doProperty, 112 /* p */, 14,0,  false}     //  99 
+    , {doProperty, 80 /* P */, 14,0,  false}     //  100 
+    , {doBackslashR, 82 /* R */, 14,0,  true}     //  101 
+    , {doEnterQuoteMode, 81 /* Q */, 2,0,  true}     //  102 
+    , {doBackslashS, 83 /* S */, 14,0,  true}     //  103 
+    , {doBackslashs, 115 /* s */, 14,0,  true}     //  104 
+    , {doBackslashv, 118 /* v */, 14,0,  true}     //  105 
+    , {doBackslashV, 86 /* V */, 14,0,  true}     //  106 
+    , {doBackslashW, 87 /* W */, 14,0,  true}     //  107 
+    , {doBackslashw, 119 /* w */, 14,0,  true}     //  108 
+    , {doBackslashX, 88 /* X */, 14,0,  true}     //  109 
+    , {doBackslashZ, 90 /* Z */, 2,0,  true}     //  110 
+    , {doBackslashz, 122 /* z */, 2,0,  true}     //  111 
+    , {doBackRef, 128, 14,0,  true}     //  112 
+    , {doEscapeError, 253, 206,0,  false}     //  113 
+    , {doEscapedLiteralChar, 255, 14,0,  true}     //  114 
+    , {doBeginNamedBackRef, 60 /* < */, 117,0,  true}     //  115      named-backref
+    , {doBadNamedCapture, 255, 206,0,  false}     //  116 
+    , {doContinueNamedBackRef, 129, 119,0,  true}     //  117      named-backref-2
+    , {doBadNamedCapture, 255, 206,0,  false}     //  118 
+    , {doContinueNamedBackRef, 129, 119,0,  true}     //  119      named-backref-3
+    , {doContinueNamedBackRef, 128, 119,0,  true}     //  120 
+    , {doCompleteNamedBackRef, 62 /* > */, 14,0,  true}     //  121 
+    , {doBadNamedCapture, 255, 206,0,  false}     //  122 
+    , {doSetNegate, 94 /* ^ */, 126,0,  true}     //  123      set-open
+    , {doSetPosixProp, 58 /* : */, 128,0,  false}     //  124 
+    , {doNOP, 255, 126,0,  false}     //  125 
+    , {doSetLiteral, 93 /* ] */, 141,0,  true}     //  126      set-open2
+    , {doNOP, 255, 131,0,  false}     //  127 
+    , {doSetEnd, 93 /* ] */, 255,0,  true}     //  128      set-posix
+    , {doNOP, 58 /* : */, 131,0,  false}     //  129 
+    , {doRuleError, 255, 206,0,  false}     //  130 
+    , {doSetEnd, 93 /* ] */, 255,0,  true}     //  131      set-start
+    , {doSetBeginUnion, 91 /* [ */, 123, 148, true}     //  132 
+    , {doNOP, 92 /* \ */, 191,0,  true}     //  133 
+    , {doNOP, 45 /* - */, 137,0,  true}     //  134 
+    , {doNOP, 38 /* & */, 139,0,  true}     //  135 
+    , {doSetLiteral, 255, 141,0,  true}     //  136 
+    , {doRuleError, 45 /* - */, 206,0,  false}     //  137      set-start-dash
+    , {doSetAddDash, 255, 141,0,  false}     //  138 
+    , {doRuleError, 38 /* & */, 206,0,  false}     //  139      set-start-amp
+    , {doSetAddAmp, 255, 141,0,  false}     //  140 
+    , {doSetEnd, 93 /* ] */, 255,0,  true}     //  141      set-after-lit
+    , {doSetBeginUnion, 91 /* [ */, 123, 148, true}     //  142 
+    , {doNOP, 45 /* - */, 178,0,  true}     //  143 
+    , {doNOP, 38 /* & */, 169,0,  true}     //  144 
+    , {doNOP, 92 /* \ */, 191,0,  true}     //  145 
+    , {doSetNoCloseError, 253, 206,0,  false}     //  146 
+    , {doSetLiteral, 255, 141,0,  true}     //  147 
+    , {doSetEnd, 93 /* ] */, 255,0,  true}     //  148      set-after-set
+    , {doSetBeginUnion, 91 /* [ */, 123, 148, true}     //  149 
+    , {doNOP, 45 /* - */, 171,0,  true}     //  150 
+    , {doNOP, 38 /* & */, 166,0,  true}     //  151 
+    , {doNOP, 92 /* \ */, 191,0,  true}     //  152 
+    , {doSetNoCloseError, 253, 206,0,  false}     //  153 
+    , {doSetLiteral, 255, 141,0,  true}     //  154 
+    , {doSetEnd, 93 /* ] */, 255,0,  true}     //  155      set-after-range
+    , {doSetBeginUnion, 91 /* [ */, 123, 148, true}     //  156 
+    , {doNOP, 45 /* - */, 174,0,  true}     //  157 
+    , {doNOP, 38 /* & */, 176,0,  true}     //  158 
+    , {doNOP, 92 /* \ */, 191,0,  true}     //  159 
+    , {doSetNoCloseError, 253, 206,0,  false}     //  160 
+    , {doSetLiteral, 255, 141,0,  true}     //  161 
+    , {doSetBeginUnion, 91 /* [ */, 123, 148, true}     //  162      set-after-op
+    , {doSetOpError, 93 /* ] */, 206,0,  false}     //  163 
+    , {doNOP, 92 /* \ */, 191,0,  true}     //  164 
+    , {doSetLiteral, 255, 141,0,  true}     //  165 
+    , {doSetBeginIntersection1, 91 /* [ */, 123, 148, true}     //  166      set-set-amp
+    , {doSetIntersection2, 38 /* & */, 162,0,  true}     //  167 
+    , {doSetAddAmp, 255, 141,0,  false}     //  168 
+    , {doSetIntersection2, 38 /* & */, 162,0,  true}     //  169      set-lit-amp
+    , {doSetAddAmp, 255, 141,0,  false}     //  170 
+    , {doSetBeginDifference1, 91 /* [ */, 123, 148, true}     //  171      set-set-dash
+    , {doSetDifference2, 45 /* - */, 162,0,  true}     //  172 
+    , {doSetAddDash, 255, 141,0,  false}     //  173 
+    , {doSetDifference2, 45 /* - */, 162,0,  true}     //  174      set-range-dash
+    , {doSetAddDash, 255, 141,0,  false}     //  175 
+    , {doSetIntersection2, 38 /* & */, 162,0,  true}     //  176      set-range-amp
+    , {doSetAddAmp, 255, 141,0,  false}     //  177 
+    , {doSetDifference2, 45 /* - */, 162,0,  true}     //  178      set-lit-dash
+    , {doSetAddDash, 91 /* [ */, 141,0,  false}     //  179 
+    , {doSetAddDash, 93 /* ] */, 141,0,  false}     //  180 
+    , {doNOP, 92 /* \ */, 183,0,  true}     //  181 
+    , {doSetRange, 255, 155,0,  true}     //  182 
+    , {doSetOpError, 115 /* s */, 206,0,  false}     //  183      set-lit-dash-escape
+    , {doSetOpError, 83 /* S */, 206,0,  false}     //  184 
+    , {doSetOpError, 119 /* w */, 206,0,  false}     //  185 
+    , {doSetOpError, 87 /* W */, 206,0,  false}     //  186 
+    , {doSetOpError, 100 /* d */, 206,0,  false}     //  187 
+    , {doSetOpError, 68 /* D */, 206,0,  false}     //  188 
+    , {doSetNamedRange, 78 /* N */, 155,0,  false}     //  189 
+    , {doSetRange, 255, 155,0,  true}     //  190 
+    , {doSetProp, 112 /* p */, 148,0,  false}     //  191      set-escape
+    , {doSetProp, 80 /* P */, 148,0,  false}     //  192 
+    , {doSetNamedChar, 78 /* N */, 141,0,  false}     //  193 
+    , {doSetBackslash_s, 115 /* s */, 155,0,  true}     //  194 
+    , {doSetBackslash_S, 83 /* S */, 155,0,  true}     //  195 
+    , {doSetBackslash_w, 119 /* w */, 155,0,  true}     //  196 
+    , {doSetBackslash_W, 87 /* W */, 155,0,  true}     //  197 
+    , {doSetBackslash_d, 100 /* d */, 155,0,  true}     //  198 
+    , {doSetBackslash_D, 68 /* D */, 155,0,  true}     //  199 
+    , {doSetBackslash_h, 104 /* h */, 155,0,  true}     //  200 
+    , {doSetBackslash_H, 72 /* H */, 155,0,  true}     //  201 
+    , {doSetBackslash_v, 118 /* v */, 155,0,  true}     //  202 
+    , {doSetBackslash_V, 86 /* V */, 155,0,  true}     //  203 
+    , {doSetLiteralEscaped, 255, 141,0,  true}     //  204 
+    , {doSetFinish, 255, 14,0,  false}     //  205      set-finish
+    , {doExit, 255, 206,0,  true}     //  206      errorDeath
  };
 static const char * const RegexStateNames[] = {    0,
      "start",
diff --git a/deps/icu-small/source/i18n/regexcst.pl b/deps/icu-small/source/i18n/regexcst.pl
index 7636757331..24596d4122 100755
--- a/deps/icu-small/source/i18n/regexcst.pl
+++ b/deps/icu-small/source/i18n/regexcst.pl
@@ -110,9 +110,9 @@ line_loop: while (<>) {
     #
     # do the 'n' flag
     #
-    $state_flag[$num_states] = "FALSE";
+    $state_flag[$num_states] = "false";
     if ($fields[0] eq "n") {
-        $state_flag[$num_states] = "TRUE";
+        $state_flag[$num_states] = "true";
         shift @fields;
     }
 
@@ -282,7 +282,7 @@ print "};\n\n";
 # emit the state transition table
 #
 print "static const struct RegexTableEl gRuleParseStateTable[] = {\n";
-print "    {doNOP, 0, 0, 0, TRUE}\n";    # State 0 is a dummy.  Real states start with index = 1.
+print "    {doNOP, 0, 0, 0, true}\n";    # State 0 is a dummy.  Real states start with index = 1.
 for ($state=1; $state < $num_states; $state++) {
     print "    , {$state_func_name[$state],";
     if ($state_literal_chars[$state] ne "") {
diff --git a/deps/icu-small/source/i18n/regexst.cpp b/deps/icu-small/source/i18n/regexst.cpp
index 97e417ab5a..dc01327a02 100644
--- a/deps/icu-small/source/i18n/regexst.cpp
+++ b/deps/icu-small/source/i18n/regexst.cpp
@@ -69,7 +69,7 @@ constexpr char16_t const *gGC_LVTPattern     = u"[\\p{Hangul_Syllable_Type=LVT}]
 
 
 RegexStaticSets *RegexStaticSets::gStaticSets = nullptr;
-UInitOnce gStaticSetsInitOnce = U_INITONCE_INITIALIZER;
+UInitOnce gStaticSetsInitOnce {};
 
 
 RegexStaticSets::RegexStaticSets(UErrorCode *status) {
@@ -77,13 +77,13 @@ RegexStaticSets::RegexStaticSets(UErrorCode *status) {
     fUnescapeCharSet.addAll(UnicodeString(true, gUnescapeChars, -1)).freeze();
     fPropSets[URX_ISWORD_SET].applyPattern(UnicodeString(true, gIsWordPattern, -1), *status).freeze();
     fPropSets[URX_ISSPACE_SET].applyPattern(UnicodeString(true, gIsSpacePattern, -1), *status).freeze();
-    fPropSets[URX_GC_EXTEND].applyPattern(UnicodeString(TRUE, gGC_ExtendPattern, -1), *status).freeze();
-    fPropSets[URX_GC_CONTROL].applyPattern(UnicodeString(TRUE, gGC_ControlPattern, -1), *status).freeze();
-    fPropSets[URX_GC_L].applyPattern(UnicodeString(TRUE, gGC_LPattern, -1), *status).freeze();
-    fPropSets[URX_GC_V].applyPattern(UnicodeString(TRUE, gGC_VPattern, -1), *status).freeze();
-    fPropSets[URX_GC_T].applyPattern(UnicodeString(TRUE, gGC_TPattern, -1), *status).freeze();
-    fPropSets[URX_GC_LV].applyPattern(UnicodeString(TRUE, gGC_LVPattern, -1), *status).freeze();
-    fPropSets[URX_GC_LVT].applyPattern(UnicodeString(TRUE, gGC_LVTPattern, -1), *status).freeze();
+    fPropSets[URX_GC_EXTEND].applyPattern(UnicodeString(true, gGC_ExtendPattern, -1), *status).freeze();
+    fPropSets[URX_GC_CONTROL].applyPattern(UnicodeString(true, gGC_ControlPattern, -1), *status).freeze();
+    fPropSets[URX_GC_L].applyPattern(UnicodeString(true, gGC_LPattern, -1), *status).freeze();
+    fPropSets[URX_GC_V].applyPattern(UnicodeString(true, gGC_VPattern, -1), *status).freeze();
+    fPropSets[URX_GC_T].applyPattern(UnicodeString(true, gGC_TPattern, -1), *status).freeze();
+    fPropSets[URX_GC_LV].applyPattern(UnicodeString(true, gGC_LVPattern, -1), *status).freeze();
+    fPropSets[URX_GC_LVT].applyPattern(UnicodeString(true, gGC_LVTPattern, -1), *status).freeze();
     
 
     //
@@ -147,7 +147,7 @@ regex_cleanup(void) {
     delete RegexStaticSets::gStaticSets;
     RegexStaticSets::gStaticSets = nullptr;
     gStaticSetsInitOnce.reset();
-    return TRUE;
+    return true;
 }
 
 static void U_CALLCONV initStaticSets(UErrorCode &status) {
diff --git a/deps/icu-small/source/i18n/region.cpp b/deps/icu-small/source/i18n/region.cpp
index 277a22fd09..6a0c05fc78 100644
--- a/deps/icu-small/source/i18n/region.cpp
+++ b/deps/icu-small/source/i18n/region.cpp
@@ -46,14 +46,14 @@ static UBool U_CALLCONV region_cleanup(void)
 {
     icu::Region::cleanupRegionData();
 
-    return TRUE;
+    return true;
 }
 
 U_CDECL_END
 
 U_NAMESPACE_BEGIN
 
-static UInitOnce gRegionDataInitOnce = U_INITONCE_INITIALIZER;
+static UInitOnce gRegionDataInitOnce {};
 static UVector* availableRegions[URGN_LIMIT];
 
 static UHashtable *regionAliases = NULL;
@@ -668,21 +668,21 @@ Region::contains(const Region &other) const {
     umtx_initOnce(gRegionDataInitOnce, &loadRegionData, status);
 
     if (!containedRegions) {
-          return FALSE;
+          return false;
     }
     if (containedRegions->contains((void *)&other.idStr)) {
-        return TRUE;
+        return true;
     } else {
         for ( int32_t i = 0 ; i < containedRegions->size() ; i++ ) {
             UnicodeString *crStr = (UnicodeString *)containedRegions->elementAt(i);
             Region *cr = (Region *) uhash_get(regionIDMap,(void *)crStr);
             if ( cr && cr->contains(other) ) {
-                return TRUE;
+                return true;
             }
         }
     }
 
-    return FALSE;
+    return false;
 }
 
 /**
diff --git a/deps/icu-small/source/i18n/reldatefmt.cpp b/deps/icu-small/source/i18n/reldatefmt.cpp
index 6ef5160798..e811eac2c8 100644
--- a/deps/icu-small/source/i18n/reldatefmt.cpp
+++ b/deps/icu-small/source/i18n/reldatefmt.cpp
@@ -16,6 +16,8 @@
 
 #include <cmath>
 #include <functional>
+#include "unicode/calendar.h"
+#include "unicode/datefmt.h"
 #include "unicode/dtfmtsym.h"
 #include "unicode/ucasemap.h"
 #include "unicode/ureldatefmt.h"
@@ -184,22 +186,6 @@ const UnicodeString& RelativeDateTimeCacheData::getAbsoluteUnitString(
     return nullptr;  // No formatter found.
  }
 
-static UBool getStringWithFallback(
-        const UResourceBundle *resource,
-        const char *key,
-        UnicodeString &result,
-        UErrorCode &status) {
-    int32_t len = 0;
-    const UChar *resStr = ures_getStringByKeyWithFallback(
-        resource, key, &len, &status);
-    if (U_FAILURE(status)) {
-        return FALSE;
-    }
-    result.setTo(TRUE, resStr, len);
-    return TRUE;
-}
-
-
 static UBool getStringByIndex(
         const UResourceBundle *resource,
         int32_t idx,
@@ -209,10 +195,10 @@ static UBool getStringByIndex(
     const UChar *resStr = ures_getStringByIndex(
             resource, idx, &len, &status);
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
-    result.setTo(TRUE, resStr, len);
-    return TRUE;
+    result.setTo(true, resStr, len);
+    return true;
 }
 
 namespace {
@@ -661,39 +647,61 @@ static UBool loadUnitData(
     return U_SUCCESS(status);
 }
 
+static const int32_t cTypeBufMax = 32;
+
 static UBool getDateTimePattern(
+        Locale locale,
         const UResourceBundle *resource,
         UnicodeString &result,
         UErrorCode &status) {
-    UnicodeString defaultCalendarName;
-    if (!getStringWithFallback(
-            resource,
-            "calendar/default",
-            defaultCalendarName,
-            status)) {
-        return FALSE;
+    if (U_FAILURE(status)) {
+        return false;
+    }
+    char cType[cTypeBufMax + 1];
+    Calendar::getCalendarTypeFromLocale(locale, cType, cTypeBufMax, status);
+    cType[cTypeBufMax] = 0;
+    if (U_FAILURE(status) || cType[0] == 0) {
+        status = U_ZERO_ERROR;
+        uprv_strcpy(cType, "gregorian");
     }
+
+    LocalUResourceBundlePointer topLevel;
+    int32_t dateTimeFormatOffset = DateFormat::kMedium;
     CharString pathBuffer;
+    // Currently, for compatibility with pre-CLDR-42 data, we default to the "atTime"
+    // combining patterns. Depending on guidance in CLDR 42 spec and on DisplayOptions,
+    // we may change this.
     pathBuffer.append("calendar/", status)
-            .appendInvariantChars(defaultCalendarName, status)
-            .append("/DateTimePatterns", status);
-    LocalUResourceBundlePointer topLevel(
+            .append(cType, status)
+            .append("/DateTimePatterns%atTime", status);
+    topLevel.adoptInstead(
             ures_getByKeyWithFallback(
                     resource, pathBuffer.data(), nullptr, &status));
+    if (U_FAILURE(status) ||  ures_getSize(topLevel.getAlias()) < 4) {
+        // Fall back to standard combining patterns
+        status = U_ZERO_ERROR;
+        dateTimeFormatOffset = DateFormat::kDateTime;
+        pathBuffer.clear();
+        pathBuffer.append("calendar/", status)
+                .append(cType, status)
+                .append("/DateTimePatterns", status);
+        topLevel.adoptInstead(
+                ures_getByKeyWithFallback(
+                        resource, pathBuffer.data(), nullptr, &status));
+    }
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
-    int32_t size = ures_getSize(topLevel.getAlias());
-    if (size <= 8) {
+    if (dateTimeFormatOffset == DateFormat::kDateTime && ures_getSize(topLevel.getAlias()) <= DateFormat::kDateTime) {
         // Oops, size is too small to access the index that we want, fallback
         // to a hard-coded value.
         result = UNICODE_STRING_SIMPLE("{1} {0}");
-        return TRUE;
+        return true;
     }
-    return getStringByIndex(topLevel.getAlias(), 8, result, status);
+    return getStringByIndex(topLevel.getAlias(), dateTimeFormatOffset, result, status);
 }
 
-template<> U_I18N_API
+template<> 
 const RelativeDateTimeCacheData *LocaleCacheKey<RelativeDateTimeCacheData>::createObject(const void * /*unused*/, UErrorCode &status) const {
     const char *localeId = fLoc.getName();
     LocalUResourceBundlePointer topLevel(ures_open(nullptr, localeId, &status));
@@ -714,7 +722,7 @@ const RelativeDateTimeCacheData *LocaleCacheKey<RelativeDateTimeCacheData>::crea
         return nullptr;
     }
     UnicodeString dateTimePattern;
-    if (!getDateTimePattern(topLevel.getAlias(), dateTimePattern, status)) {
+    if (!getDateTimePattern(fLoc, topLevel.getAlias(), dateTimePattern, status)) {
         return nullptr;
     }
     result->adoptCombinedDateAndTime(
@@ -1204,9 +1212,9 @@ UBool RelativeDateTimeFormatter::checkNoAdjustForContext(UErrorCode& status) con
     // casing. The code could be written and tested if there is demand.
     if (fOptBreakIterator != nullptr) {
         status = U_UNSUPPORTED_ERROR;
-        return FALSE;
+        return false;
     }
-    return TRUE;
+    return true;
 }
 
 void RelativeDateTimeFormatter::init(
diff --git a/deps/icu-small/source/i18n/reldtfmt.cpp b/deps/icu-small/source/i18n/reldtfmt.cpp
index 5fdef1c0d6..f381bf8981 100644
--- a/deps/icu-small/source/i18n/reldtfmt.cpp
+++ b/deps/icu-small/source/i18n/reldtfmt.cpp
@@ -71,8 +71,8 @@ RelativeDateFormat::RelativeDateFormat( UDateFormatStyle timeStyle, UDateFormatS
                                         const Locale& locale, UErrorCode& status) :
  DateFormat(), fDateTimeFormatter(NULL), fDatePattern(), fTimePattern(), fCombinedFormat(NULL),
  fDateStyle(dateStyle), fLocale(locale), fDatesLen(0), fDates(NULL),
- fCombinedHasDateAtStart(FALSE), fCapitalizationInfoSet(FALSE),
- fCapitalizationOfRelativeUnitsForUIListMenu(FALSE), fCapitalizationOfRelativeUnitsForStandAlone(FALSE),
+ fCombinedHasDateAtStart(false), fCapitalizationInfoSet(false),
+ fCapitalizationOfRelativeUnitsForUIListMenu(false), fCapitalizationOfRelativeUnitsForStandAlone(false),
  fCapitalizationBrkIter(NULL)
 {
     if(U_FAILURE(status) ) {
@@ -246,13 +246,13 @@ void RelativeDateFormat::parse( const UnicodeString& text,
     } else if (fTimePattern.isEmpty() || fCombinedFormat == NULL) {
         // no time pattern or way to combine, try parsing as date
         // first check whether text matches a relativeDayString
-        UBool matchedRelative = FALSE;
+        UBool matchedRelative = false;
         for (int n=0; n < fDatesLen && !matchedRelative; n++) {
             if (fDates[n].string != NULL &&
                     text.compare(startIndex, fDates[n].len, fDates[n].string) == 0) {
                 // it matched, handle the relative day string
                 UErrorCode status = U_ZERO_ERROR;
-                matchedRelative = TRUE;
+                matchedRelative = true;
 
                 // Set the calendar to now+offset
                 cal.setTime(Calendar::getNow(),status);
@@ -424,7 +424,7 @@ RelativeDateFormat::setContext(UDisplayContext value, UErrorCode& status)
         if (!fCapitalizationInfoSet &&
                 (value==UDISPCTX_CAPITALIZATION_FOR_UI_LIST_OR_MENU || value==UDISPCTX_CAPITALIZATION_FOR_STANDALONE)) {
             initCapitalizationContextInfo(fLocale);
-            fCapitalizationInfoSet = TRUE;
+            fCapitalizationInfoSet = true;
         }
 #if !UCONFIG_NO_BREAK_ITERATION
         if ( fCapitalizationBrkIter == NULL && (value==UDISPCTX_CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE ||
@@ -536,9 +536,9 @@ void RelativeDateFormat::loadDates(UErrorCode &status) {
 
             const UChar *resStr = ures_getStringByIndex(dateTimePatterns.getAlias(), glueIndex, &resStrLen, &status);
             if (U_SUCCESS(status) && resStrLen >= patItem1Len && u_strncmp(resStr,patItem1,patItem1Len)==0) {
-                fCombinedHasDateAtStart = TRUE;
+                fCombinedHasDateAtStart = true;
             }
-            fCombinedFormat = new SimpleFormatter(UnicodeString(TRUE, resStr, resStrLen), 2, 2, status);
+            fCombinedFormat = new SimpleFormatter(UnicodeString(true, resStr, resStrLen), 2, 2, status);
         }
     }
 
diff --git a/deps/icu-small/source/i18n/rematch.cpp b/deps/icu-small/source/i18n/rematch.cpp
index 7d6eaeed8b..e74ca3a659 100644
--- a/deps/icu-small/source/i18n/rematch.cpp
+++ b/deps/icu-small/source/i18n/rematch.cpp
@@ -98,7 +98,7 @@ RegexMatcher::RegexMatcher(const UnicodeString &regexp, const UnicodeString &inp
     init2(&inputText, status);
     utext_close(&inputText);
 
-    fInputUniStrMaybeMutable = TRUE;
+    fInputUniStrMaybeMutable = true;
 }
 
 
@@ -200,15 +200,15 @@ void RegexMatcher::init(UErrorCode &status) {
     fLookLimit         = 0;
     fActiveStart       = 0;
     fActiveLimit       = 0;
-    fTransparentBounds = FALSE;
-    fAnchoringBounds   = TRUE;
-    fMatch             = FALSE;
+    fTransparentBounds = false;
+    fAnchoringBounds   = true;
+    fMatch             = false;
     fMatchStart        = 0;
     fMatchEnd          = 0;
     fLastMatchEnd      = -1;
     fAppendPosition    = 0;
-    fHitEnd            = FALSE;
-    fRequireEnd        = FALSE;
+    fHitEnd            = false;
+    fRequireEnd        = false;
     fStack             = NULL;
     fFrame             = NULL;
     fTimeLimit         = 0;
@@ -219,7 +219,7 @@ void RegexMatcher::init(UErrorCode &status) {
     fCallbackContext   = NULL;
     fFindProgressCallbackFn      = NULL;
     fFindProgressCallbackContext = NULL;
-    fTraceDebug        = FALSE;
+    fTraceDebug        = false;
     fDeferredStatus    = status;
     fData              = fSmallData;
     fWordBreakItr      = NULL;
@@ -230,7 +230,7 @@ void RegexMatcher::init(UErrorCode &status) {
     fAltInputText      = NULL;
     fInput             = NULL;
     fInputLength       = 0;
-    fInputUniStrMaybeMutable = FALSE;
+    fInputUniStrMaybeMutable = false;
 }
 
 //
@@ -309,7 +309,7 @@ RegexMatcher &RegexMatcher::appendReplacement(UText *dest,
         status = fDeferredStatus;
         return *this;
     }
-    if (fMatch == FALSE) {
+    if (fMatch == false) {
         status = U_REGEX_INVALID_STATE;
         return *this;
     }
@@ -449,7 +449,7 @@ RegexMatcher &RegexMatcher::appendReplacement(UText *dest,
                     if (nextChar == U_SENTINEL) {
                         break;
                     }
-                    if (u_isdigit(nextChar) == FALSE) {
+                    if (u_isdigit(nextChar) == false) {
                         break;
                     }
                     int32_t nextDigitVal = u_charDigitValue(nextChar);
@@ -561,7 +561,7 @@ int64_t RegexMatcher::end64(int32_t group, UErrorCode &err) const {
     if (U_FAILURE(err)) {
         return -1;
     }
-    if (fMatch == FALSE) {
+    if (fMatch == false) {
         err = U_REGEX_INVALID_STATE;
         return -1;
     }
@@ -594,16 +594,16 @@ int32_t RegexMatcher::end(int32_t group, UErrorCode &err) const {
 //                          string from the find() function, and calls the user progress callback
 //                          function if there is one installed.
 //
-//         Return:  TRUE if the find operation is to be terminated.
-//                  FALSE if the find operation is to continue running.
+//         Return:  true if the find operation is to be terminated.
+//                  false if the find operation is to continue running.
 //
 //--------------------------------------------------------------------------------
 UBool RegexMatcher::findProgressInterrupt(int64_t pos, UErrorCode &status) {
     if (fFindProgressCallbackFn && !(*fFindProgressCallbackFn)(fFindProgressCallbackContext, pos)) {
         status = U_REGEX_STOPPED_BY_CALLER;
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 //--------------------------------------------------------------------------------
@@ -613,7 +613,7 @@ UBool RegexMatcher::findProgressInterrupt(int64_t pos, UErrorCode &status) {
 //--------------------------------------------------------------------------------
 UBool RegexMatcher::find() {
     if (U_FAILURE(fDeferredStatus)) {
-        return FALSE;
+        return false;
     }
     UErrorCode status = U_ZERO_ERROR;
     UBool result = find(status);
@@ -630,11 +630,11 @@ UBool RegexMatcher::find(UErrorCode &status) {
     //   matcher has been reset.)
     //
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
     if (U_FAILURE(fDeferredStatus)) {
         status = fDeferredStatus;
-        return FALSE;
+        return false;
     }
 
     if (UTEXT_FULL_TEXT_IN_CHUNK(fInputText, fInputLength)) {
@@ -654,9 +654,9 @@ UBool RegexMatcher::find(UErrorCode &status) {
             // Previous match had zero length.  Move start position up one position
             //  to avoid sending find() into a loop on zero-length matches.
             if (startPos >= fActiveLimit) {
-                fMatch = FALSE;
-                fHitEnd = TRUE;
-                return FALSE;
+                fMatch = false;
+                fHitEnd = true;
+                return false;
             }
             UTEXT_SETNATIVEINDEX(fInputText, startPos);
             (void)UTEXT_NEXT32(fInputText);
@@ -667,8 +667,8 @@ UBool RegexMatcher::find(UErrorCode &status) {
             // A previous find() failed to match.  Don't try again.
             //   (without this test, a pattern with a zero-length match
             //    could match again at the end of an input string.)
-            fHitEnd = TRUE;
-            return FALSE;
+            fHitEnd = true;
+            return false;
         }
     }
 
@@ -681,9 +681,9 @@ UBool RegexMatcher::find(UErrorCode &status) {
     if (UTEXT_USES_U16(fInputText)) {
         testStartLimit = fActiveLimit - fPattern->fMinMatchLen;
         if (startPos > testStartLimit) {
-            fMatch = FALSE;
-            fHitEnd = TRUE;
-            return FALSE;
+            fMatch = false;
+            fHitEnd = true;
+            return false;
         }
     } else {
         // We don't know exactly how long the minimum match length is in native characters.
@@ -699,16 +699,16 @@ UBool RegexMatcher::find(UErrorCode &status) {
         // No optimization was found.
         //  Try a match at each input position.
         for (;;) {
-            MatchAt(startPos, FALSE, status);
+            MatchAt(startPos, false, status);
             if (U_FAILURE(status)) {
-                return FALSE;
+                return false;
             }
             if (fMatch) {
-                return TRUE;
+                return true;
             }
             if (startPos >= testStartLimit) {
-                fHitEnd = TRUE;
-                return FALSE;
+                fHitEnd = true;
+                return false;
             }
             UTEXT_SETNATIVEINDEX(fInputText, startPos);
             (void)UTEXT_NEXT32(fInputText);
@@ -717,7 +717,7 @@ UBool RegexMatcher::find(UErrorCode &status) {
             //   match at the end of a string, so we must make sure that the loop
             //   runs with startPos == testStartLimit the last time through.
             if  (findProgressInterrupt(startPos, status))
-                return FALSE;
+                return false;
         }
         UPRV_UNREACHABLE_EXIT;
 
@@ -725,12 +725,12 @@ UBool RegexMatcher::find(UErrorCode &status) {
         // Matches are only possible at the start of the input string
         //   (pattern begins with ^ or \A)
         if (startPos > fActiveStart) {
-            fMatch = FALSE;
-            return FALSE;
+            fMatch = false;
+            return false;
         }
-        MatchAt(startPos, FALSE, status);
+        MatchAt(startPos, false, status);
         if (U_FAILURE(status)) {
-            return FALSE;
+            return false;
         }
         return fMatch;
 
@@ -749,22 +749,22 @@ UBool RegexMatcher::find(UErrorCode &status) {
                 // and handle end of text in the following block.
                 if (c >= 0 && ((c<256 && fPattern->fInitialChars8->contains(c)) ||
                               (c>=256 && fPattern->fInitialChars->contains(c)))) {
-                    MatchAt(pos, FALSE, status);
+                    MatchAt(pos, false, status);
                     if (U_FAILURE(status)) {
-                        return FALSE;
+                        return false;
                     }
                     if (fMatch) {
-                        return TRUE;
+                        return true;
                     }
                     UTEXT_SETNATIVEINDEX(fInputText, pos);
                 }
                 if (startPos > testStartLimit) {
-                    fMatch = FALSE;
-                    fHitEnd = TRUE;
-                    return FALSE;
+                    fMatch = false;
+                    fHitEnd = true;
+                    return false;
                 }
                 if  (findProgressInterrupt(startPos, status))
-                    return FALSE;
+                    return false;
             }
         }
         UPRV_UNREACHABLE_EXIT;
@@ -781,22 +781,22 @@ UBool RegexMatcher::find(UErrorCode &status) {
                 c = UTEXT_NEXT32(fInputText);
                 startPos = UTEXT_GETNATIVEINDEX(fInputText);
                 if (c == theChar) {
-                    MatchAt(pos, FALSE, status);
+                    MatchAt(pos, false, status);
                     if (U_FAILURE(status)) {
-                        return FALSE;
+                        return false;
                     }
                     if (fMatch) {
-                        return TRUE;
+                        return true;
                     }
                     UTEXT_SETNATIVEINDEX(fInputText, startPos);
                 }
                 if (startPos > testStartLimit) {
-                    fMatch = FALSE;
-                    fHitEnd = TRUE;
-                    return FALSE;
+                    fMatch = false;
+                    fHitEnd = true;
+                    return false;
                 }
                 if  (findProgressInterrupt(startPos, status))
-                    return FALSE;
+                    return false;
            }
         }
         UPRV_UNREACHABLE_EXIT;
@@ -805,12 +805,12 @@ UBool RegexMatcher::find(UErrorCode &status) {
         {
             UChar32 ch;
             if (startPos == fAnchorStart) {
-                MatchAt(startPos, FALSE, status);
+                MatchAt(startPos, false, status);
                 if (U_FAILURE(status)) {
-                    return FALSE;
+                    return false;
                 }
                 if (fMatch) {
-                    return TRUE;
+                    return true;
                 }
                 UTEXT_SETNATIVEINDEX(fInputText, startPos);
                 ch = UTEXT_NEXT32(fInputText);
@@ -824,19 +824,19 @@ UBool RegexMatcher::find(UErrorCode &status) {
             if (fPattern->fFlags & UREGEX_UNIX_LINES) {
                 for (;;) {
                     if (ch == 0x0a) {
-                            MatchAt(startPos, FALSE, status);
+                            MatchAt(startPos, false, status);
                             if (U_FAILURE(status)) {
-                                return FALSE;
+                                return false;
                             }
                             if (fMatch) {
-                                return TRUE;
+                                return true;
                             }
                             UTEXT_SETNATIVEINDEX(fInputText, startPos);
                     }
                     if (startPos >= testStartLimit) {
-                        fMatch = FALSE;
-                        fHitEnd = TRUE;
-                        return FALSE;
+                        fMatch = false;
+                        fHitEnd = true;
+                        return false;
                     }
                     ch = UTEXT_NEXT32(fInputText);
                     startPos = UTEXT_GETNATIVEINDEX(fInputText);
@@ -844,7 +844,7 @@ UBool RegexMatcher::find(UErrorCode &status) {
                     //   match at the end of a string, so we must make sure that the loop
                     //   runs with startPos == testStartLimit the last time through.
                     if  (findProgressInterrupt(startPos, status))
-                        return FALSE;
+                        return false;
                 }
             } else {
                 for (;;) {
@@ -853,19 +853,19 @@ UBool RegexMatcher::find(UErrorCode &status) {
                             (void)UTEXT_NEXT32(fInputText);
                             startPos = UTEXT_GETNATIVEINDEX(fInputText);
                         }
-                        MatchAt(startPos, FALSE, status);
+                        MatchAt(startPos, false, status);
                         if (U_FAILURE(status)) {
-                            return FALSE;
+                            return false;
                         }
                         if (fMatch) {
-                            return TRUE;
+                            return true;
                         }
                         UTEXT_SETNATIVEINDEX(fInputText, startPos);
                     }
                     if (startPos >= testStartLimit) {
-                        fMatch = FALSE;
-                        fHitEnd = TRUE;
-                        return FALSE;
+                        fMatch = false;
+                        fHitEnd = true;
+                        return false;
                     }
                     ch = UTEXT_NEXT32(fInputText);
                     startPos = UTEXT_GETNATIVEINDEX(fInputText);
@@ -873,7 +873,7 @@ UBool RegexMatcher::find(UErrorCode &status) {
                     //   match at the end of a string, so we must make sure that the loop
                     //   runs with startPos == testStartLimit the last time through.
                     if  (findProgressInterrupt(startPos, status))
-                        return FALSE;
+                        return false;
                 }
             }
         }
@@ -884,7 +884,7 @@ UBool RegexMatcher::find(UErrorCode &status) {
         // we have reports of this in production code, don't use UPRV_UNREACHABLE_EXIT.
         // See ICU-21669.
         status = U_INTERNAL_PROGRAM_ERROR;
-        return FALSE;
+        return false;
     }
 
     UPRV_UNREACHABLE_EXIT;
@@ -894,23 +894,23 @@ UBool RegexMatcher::find(UErrorCode &status) {
 
 UBool RegexMatcher::find(int64_t start, UErrorCode &status) {
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
     if (U_FAILURE(fDeferredStatus)) {
         status = fDeferredStatus;
-        return FALSE;
+        return false;
     }
     this->reset();                        // Note:  Reset() is specified by Java Matcher documentation.
                                           //        This will reset the region to be the full input length.
     if (start < 0) {
         status = U_INDEX_OUTOFBOUNDS_ERROR;
-        return FALSE;
+        return false;
     }
 
     int64_t nativeStart = start;
     if (nativeStart < fActiveStart || nativeStart > fActiveLimit) {
         status = U_INDEX_OUTOFBOUNDS_ERROR;
-        return FALSE;
+        return false;
     }
     fMatchEnd = nativeStart;
     return find(status);
@@ -943,9 +943,9 @@ UBool RegexMatcher::findUsingChunk(UErrorCode &status) {
             // Previous match had zero length.  Move start position up one position
             //  to avoid sending find() into a loop on zero-length matches.
             if (startPos >= fActiveLimit) {
-                fMatch = FALSE;
-                fHitEnd = TRUE;
-                return FALSE;
+                fMatch = false;
+                fHitEnd = true;
+                return false;
             }
             U16_FWD_1(inputBuf, startPos, fInputLength);
         }
@@ -954,8 +954,8 @@ UBool RegexMatcher::findUsingChunk(UErrorCode &status) {
             // A previous find() failed to match.  Don't try again.
             //   (without this test, a pattern with a zero-length match
             //    could match again at the end of an input string.)
-            fHitEnd = TRUE;
-            return FALSE;
+            fHitEnd = true;
+            return false;
         }
     }
 
@@ -967,9 +967,9 @@ UBool RegexMatcher::findUsingChunk(UErrorCode &status) {
     //   Note:  a match can begin at inputBuf + testLen; it is an inclusive limit.
     int32_t testLen  = (int32_t)(fActiveLimit - fPattern->fMinMatchLen);
     if (startPos > testLen) {
-        fMatch = FALSE;
-        fHitEnd = TRUE;
-        return FALSE;
+        fMatch = false;
+        fHitEnd = true;
+        return false;
     }
 
     UChar32  c;
@@ -980,23 +980,23 @@ UBool RegexMatcher::findUsingChunk(UErrorCode &status) {
         // No optimization was found.
         //  Try a match at each input position.
         for (;;) {
-            MatchChunkAt(startPos, FALSE, status);
+            MatchChunkAt(startPos, false, status);
             if (U_FAILURE(status)) {
-                return FALSE;
+                return false;
             }
             if (fMatch) {
-                return TRUE;
+                return true;
             }
             if (startPos >= testLen) {
-                fHitEnd = TRUE;
-                return FALSE;
+                fHitEnd = true;
+                return false;
             }
             U16_FWD_1(inputBuf, startPos, fActiveLimit);
             // Note that it's perfectly OK for a pattern to have a zero-length
             //   match at the end of a string, so we must make sure that the loop
             //   runs with startPos == testLen the last time through.
             if  (findProgressInterrupt(startPos, status))
-                return FALSE;
+                return false;
         }
         UPRV_UNREACHABLE_EXIT;
 
@@ -1004,12 +1004,12 @@ UBool RegexMatcher::findUsingChunk(UErrorCode &status) {
         // Matches are only possible at the start of the input string
         //   (pattern begins with ^ or \A)
         if (startPos > fActiveStart) {
-            fMatch = FALSE;
-            return FALSE;
+            fMatch = false;
+            return false;
         }
-        MatchChunkAt(startPos, FALSE, status);
+        MatchChunkAt(startPos, false, status);
         if (U_FAILURE(status)) {
-            return FALSE;
+            return false;
         }
         return fMatch;
 
@@ -1023,21 +1023,21 @@ UBool RegexMatcher::findUsingChunk(UErrorCode &status) {
             U16_NEXT(inputBuf, startPos, fActiveLimit, c);  // like c = inputBuf[startPos++];
             if ((c<256 && fPattern->fInitialChars8->contains(c)) ||
                 (c>=256 && fPattern->fInitialChars->contains(c))) {
-                MatchChunkAt(pos, FALSE, status);
+                MatchChunkAt(pos, false, status);
                 if (U_FAILURE(status)) {
-                    return FALSE;
+                    return false;
                 }
                 if (fMatch) {
-                    return TRUE;
+                    return true;
                 }
             }
             if (startPos > testLen) {
-                fMatch = FALSE;
-                fHitEnd = TRUE;
-                return FALSE;
+                fMatch = false;
+                fHitEnd = true;
+                return false;
             }
             if  (findProgressInterrupt(startPos, status))
-                return FALSE;
+                return false;
         }
     }
     UPRV_UNREACHABLE_EXIT;
@@ -1052,21 +1052,21 @@ UBool RegexMatcher::findUsingChunk(UErrorCode &status) {
             int32_t pos = startPos;
             U16_NEXT(inputBuf, startPos, fActiveLimit, c);  // like c = inputBuf[startPos++];
             if (c == theChar) {
-                MatchChunkAt(pos, FALSE, status);
+                MatchChunkAt(pos, false, status);
                 if (U_FAILURE(status)) {
-                    return FALSE;
+                    return false;
                 }
                 if (fMatch) {
-                    return TRUE;
+                    return true;
                 }
             }
             if (startPos > testLen) {
-                fMatch = FALSE;
-                fHitEnd = TRUE;
-                return FALSE;
+                fMatch = false;
+                fHitEnd = true;
+                return false;
             }
             if  (findProgressInterrupt(startPos, status))
-                return FALSE;
+                return false;
         }
     }
     UPRV_UNREACHABLE_EXIT;
@@ -1075,12 +1075,12 @@ UBool RegexMatcher::findUsingChunk(UErrorCode &status) {
     {
         UChar32 ch;
         if (startPos == fAnchorStart) {
-            MatchChunkAt(startPos, FALSE, status);
+            MatchChunkAt(startPos, false, status);
             if (U_FAILURE(status)) {
-                return FALSE;
+                return false;
             }
             if (fMatch) {
-                return TRUE;
+                return true;
             }
             U16_FWD_1(inputBuf, startPos, fActiveLimit);
         }
@@ -1089,25 +1089,25 @@ UBool RegexMatcher::findUsingChunk(UErrorCode &status) {
             for (;;) {
                 ch = inputBuf[startPos-1];
                 if (ch == 0x0a) {
-                    MatchChunkAt(startPos, FALSE, status);
+                    MatchChunkAt(startPos, false, status);
                     if (U_FAILURE(status)) {
-                        return FALSE;
+                        return false;
                     }
                     if (fMatch) {
-                        return TRUE;
+                        return true;
                     }
                 }
                 if (startPos >= testLen) {
-                    fMatch = FALSE;
-                    fHitEnd = TRUE;
-                    return FALSE;
+                    fMatch = false;
+                    fHitEnd = true;
+                    return false;
                 }
                 U16_FWD_1(inputBuf, startPos, fActiveLimit);
                 // Note that it's perfectly OK for a pattern to have a zero-length
                 //   match at the end of a string, so we must make sure that the loop
                 //   runs with startPos == testLen the last time through.
                 if  (findProgressInterrupt(startPos, status))
-                    return FALSE;
+                    return false;
             }
         } else {
             for (;;) {
@@ -1116,25 +1116,25 @@ UBool RegexMatcher::findUsingChunk(UErrorCode &status) {
                     if (ch == 0x0d && startPos < fActiveLimit && inputBuf[startPos] == 0x0a) {
                         startPos++;
                     }
-                    MatchChunkAt(startPos, FALSE, status);
+                    MatchChunkAt(startPos, false, status);
                     if (U_FAILURE(status)) {
-                        return FALSE;
+                        return false;
                     }
                     if (fMatch) {
-                        return TRUE;
+                        return true;
                     }
                 }
                 if (startPos >= testLen) {
-                    fMatch = FALSE;
-                    fHitEnd = TRUE;
-                    return FALSE;
+                    fMatch = false;
+                    fHitEnd = true;
+                    return false;
                 }
                 U16_FWD_1(inputBuf, startPos, fActiveLimit);
                 // Note that it's perfectly OK for a pattern to have a zero-length
                 //   match at the end of a string, so we must make sure that the loop
                 //   runs with startPos == testLen the last time through.
                 if  (findProgressInterrupt(startPos, status))
-                    return FALSE;
+                    return false;
             }
         }
     }
@@ -1145,7 +1145,7 @@ UBool RegexMatcher::findUsingChunk(UErrorCode &status) {
         // we have reports of this in production code, don't use UPRV_UNREACHABLE_EXIT.
         // See ICU-21669.
         status = U_INTERNAL_PROGRAM_ERROR;
-        return FALSE;
+        return false;
     }
 
     UPRV_UNREACHABLE_EXIT;
@@ -1175,7 +1175,7 @@ UText *RegexMatcher::group(int32_t groupNum, UText *dest, int64_t &group_len, UE
     }
     if (U_FAILURE(fDeferredStatus)) {
         status = fDeferredStatus;
-    } else if (fMatch == FALSE) {
+    } else if (fMatch == false) {
         status = U_REGEX_INVALID_STATE;
     } else if (groupNum < 0 || groupNum > fPattern->fGroupMap->size()) {
         status = U_INDEX_OUTOFBOUNDS_ERROR;
@@ -1199,12 +1199,12 @@ UText *RegexMatcher::group(int32_t groupNum, UText *dest, int64_t &group_len, UE
 
     if (s < 0) {
         // A capture group wasn't part of the match
-        return utext_clone(dest, fInputText, FALSE, TRUE, &status);
+        return utext_clone(dest, fInputText, false, true, &status);
     }
     U_ASSERT(s <= e);
     group_len = e - s;
 
-    dest = utext_clone(dest, fInputText, FALSE, TRUE, &status);
+    dest = utext_clone(dest, fInputText, false, true, &status);
     if (dest)
         UTEXT_SETNATIVEINDEX(dest, s);
     return dest;
@@ -1255,7 +1255,7 @@ int64_t RegexMatcher::appendGroup(int32_t groupNum, UText *dest, UErrorCode &sta
     }
     int64_t destLen = utext_nativeLength(dest);
 
-    if (fMatch == FALSE) {
+    if (fMatch == false) {
         status = U_REGEX_INVALID_STATE;
         return utext_replace(dest, destLen, destLen, NULL, 0, &status);
     }
@@ -1425,14 +1425,14 @@ UText *RegexMatcher::getInput (UText *dest, UErrorCode &status) const {
         }
         return dest;
     } else {
-        return utext_clone(NULL, fInputText, FALSE, TRUE, &status);
+        return utext_clone(NULL, fInputText, false, true, &status);
     }
 }
 
 
 static UBool compat_SyncMutableUTextContents(UText *ut);
 static UBool compat_SyncMutableUTextContents(UText *ut) {
-    UBool retVal = FALSE;
+    UBool retVal = false;
 
     //  In the following test, we're really only interested in whether the UText should switch
     //  between heap and stack allocation.  If length hasn't changed, we won't, so the chunkContents
@@ -1450,7 +1450,7 @@ static UBool compat_SyncMutableUTextContents(UText *ut) {
         ut->chunkLength      = newLength;
         ut->chunkNativeLimit = newLength;
         ut->nativeIndexingLimit = newLength;
-        retVal = TRUE;
+        retVal = true;
     }
 
     return retVal;
@@ -1463,11 +1463,11 @@ static UBool compat_SyncMutableUTextContents(UText *ut) {
 //--------------------------------------------------------------------------------
 UBool RegexMatcher::lookingAt(UErrorCode &status) {
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
     if (U_FAILURE(fDeferredStatus)) {
         status = fDeferredStatus;
-        return FALSE;
+        return false;
     }
 
     if (fInputUniStrMaybeMutable) {
@@ -1480,9 +1480,9 @@ UBool RegexMatcher::lookingAt(UErrorCode &status) {
         resetPreserveRegion();
     }
     if (UTEXT_FULL_TEXT_IN_CHUNK(fInputText, fInputLength)) {
-        MatchChunkAt((int32_t)fActiveStart, FALSE, status);
+        MatchChunkAt((int32_t)fActiveStart, false, status);
     } else {
-        MatchAt(fActiveStart, FALSE, status);
+        MatchAt(fActiveStart, false, status);
     }
     return fMatch;
 }
@@ -1490,17 +1490,17 @@ UBool RegexMatcher::lookingAt(UErrorCode &status) {
 
 UBool RegexMatcher::lookingAt(int64_t start, UErrorCode &status) {
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
     if (U_FAILURE(fDeferredStatus)) {
         status = fDeferredStatus;
-        return FALSE;
+        return false;
     }
     reset();
 
     if (start < 0) {
         status = U_INDEX_OUTOFBOUNDS_ERROR;
-        return FALSE;
+        return false;
     }
 
     if (fInputUniStrMaybeMutable) {
@@ -1514,13 +1514,13 @@ UBool RegexMatcher::lookingAt(int64_t start, UErrorCode &status) {
     nativeStart = start;
     if (nativeStart < fActiveStart || nativeStart > fActiveLimit) {
         status = U_INDEX_OUTOFBOUNDS_ERROR;
-        return FALSE;
+        return false;
     }
 
     if (UTEXT_FULL_TEXT_IN_CHUNK(fInputText, fInputLength)) {
-        MatchChunkAt((int32_t)nativeStart, FALSE, status);
+        MatchChunkAt((int32_t)nativeStart, false, status);
     } else {
-        MatchAt(nativeStart, FALSE, status);
+        MatchAt(nativeStart, false, status);
     }
     return fMatch;
 }
@@ -1534,11 +1534,11 @@ UBool RegexMatcher::lookingAt(int64_t start, UErrorCode &status) {
 //--------------------------------------------------------------------------------
 UBool RegexMatcher::matches(UErrorCode &status) {
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
     if (U_FAILURE(fDeferredStatus)) {
         status = fDeferredStatus;
-        return FALSE;
+        return false;
     }
 
     if (fInputUniStrMaybeMutable) {
@@ -1552,9 +1552,9 @@ UBool RegexMatcher::matches(UErrorCode &status) {
     }
 
     if (UTEXT_FULL_TEXT_IN_CHUNK(fInputText, fInputLength)) {
-        MatchChunkAt((int32_t)fActiveStart, TRUE, status);
+        MatchChunkAt((int32_t)fActiveStart, true, status);
     } else {
-        MatchAt(fActiveStart, TRUE, status);
+        MatchAt(fActiveStart, true, status);
     }
     return fMatch;
 }
@@ -1562,17 +1562,17 @@ UBool RegexMatcher::matches(UErrorCode &status) {
 
 UBool RegexMatcher::matches(int64_t start, UErrorCode &status) {
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
     if (U_FAILURE(fDeferredStatus)) {
         status = fDeferredStatus;
-        return FALSE;
+        return false;
     }
     reset();
 
     if (start < 0) {
         status = U_INDEX_OUTOFBOUNDS_ERROR;
-        return FALSE;
+        return false;
     }
 
     if (fInputUniStrMaybeMutable) {
@@ -1586,13 +1586,13 @@ UBool RegexMatcher::matches(int64_t start, UErrorCode &status) {
     nativeStart = start;
     if (nativeStart < fActiveStart || nativeStart > fActiveLimit) {
         status = U_INDEX_OUTOFBOUNDS_ERROR;
-        return FALSE;
+        return false;
     }
 
     if (UTEXT_FULL_TEXT_IN_CHUNK(fInputText, fInputLength)) {
-        MatchChunkAt((int32_t)nativeStart, TRUE, status);
+        MatchChunkAt((int32_t)nativeStart, true, status);
     } else {
-        MatchAt(nativeStart, TRUE, status);
+        MatchAt(nativeStart, true, status);
     }
     return fMatch;
 }
@@ -1731,7 +1731,7 @@ UText *RegexMatcher::replaceAll(UText *replacement, UText *dest, UErrorCode &sta
         UText empty = UTEXT_INITIALIZER;
 
         utext_openUnicodeString(&empty, &emptyString, &status);
-        dest = utext_clone(NULL, &empty, TRUE, FALSE, &status);
+        dest = utext_clone(NULL, &empty, true, false, &status);
         utext_close(&empty);
     }
 
@@ -1793,7 +1793,7 @@ UText *RegexMatcher::replaceFirst(UText *replacement, UText *dest, UErrorCode &s
         UText empty = UTEXT_INITIALIZER;
 
         utext_openUnicodeString(&empty, &emptyString, &status);
-        dest = utext_clone(NULL, &empty, TRUE, FALSE, &status);
+        dest = utext_clone(NULL, &empty, true, false, &status);
         utext_close(&empty);
     }
 
@@ -1839,9 +1839,9 @@ void RegexMatcher::resetPreserveRegion() {
     fMatchEnd       = 0;
     fLastMatchEnd   = -1;
     fAppendPosition = 0;
-    fMatch          = FALSE;
-    fHitEnd         = FALSE;
-    fRequireEnd     = FALSE;
+    fMatch          = false;
+    fHitEnd         = false;
+    fRequireEnd     = false;
     fTime           = 0;
     fTickCounter    = TIMER_INITIAL_VALUE;
     //resetStack(); // more expensive than it looks...
@@ -1851,7 +1851,7 @@ void RegexMatcher::resetPreserveRegion() {
 RegexMatcher &RegexMatcher::reset(const UnicodeString &input) {
     fInputText = utext_openConstUnicodeString(fInputText, &input, &fDeferredStatus);
     if (fPattern->fNeedsAltInput) {
-        fAltInputText = utext_clone(fAltInputText, fInputText, FALSE, TRUE, &fDeferredStatus);
+        fAltInputText = utext_clone(fAltInputText, fInputText, false, true, &fDeferredStatus);
     }
     if (U_FAILURE(fDeferredStatus)) {
         return *this;
@@ -1864,7 +1864,7 @@ RegexMatcher &RegexMatcher::reset(const UnicodeString &input) {
 
     //  Do the following for any UnicodeString.
     //  This is for compatibility for those clients who modify the input string "live" during regex operations.
-    fInputUniStrMaybeMutable = TRUE;
+    fInputUniStrMaybeMutable = true;
 
 #if UCONFIG_NO_BREAK_ITERATION==0
     if (fWordBreakItr) {
@@ -1881,8 +1881,8 @@ RegexMatcher &RegexMatcher::reset(const UnicodeString &input) {
 
 RegexMatcher &RegexMatcher::reset(UText *input) {
     if (fInputText != input) {
-        fInputText = utext_clone(fInputText, input, FALSE, TRUE, &fDeferredStatus);
-        if (fPattern->fNeedsAltInput) fAltInputText = utext_clone(fAltInputText, fInputText, FALSE, TRUE, &fDeferredStatus);
+        fInputText = utext_clone(fInputText, input, false, true, &fDeferredStatus);
+        if (fPattern->fNeedsAltInput) fAltInputText = utext_clone(fAltInputText, fInputText, false, true, &fDeferredStatus);
         if (U_FAILURE(fDeferredStatus)) {
             return *this;
         }
@@ -1901,7 +1901,7 @@ RegexMatcher &RegexMatcher::reset(UText *input) {
 #endif
     }
     reset();
-    fInputUniStrMaybeMutable = FALSE;
+    fInputUniStrMaybeMutable = false;
 
     return *this;
 }
@@ -1945,7 +1945,7 @@ RegexMatcher &RegexMatcher::refreshInputText(UText *input, UErrorCode &status) {
     }
     int64_t  pos = utext_getNativeIndex(fInputText);
     //  Shallow read-only clone of the new UText into the existing input UText
-    fInputText = utext_clone(fInputText, input, FALSE, TRUE, &status);
+    fInputText = utext_clone(fInputText, input, false, true, &status);
     if (U_FAILURE(status)) {
         return *this;
     }
@@ -1953,7 +1953,7 @@ RegexMatcher &RegexMatcher::refreshInputText(UText *input, UErrorCode &status) {
 
     if (fAltInputText != NULL) {
         pos = utext_getNativeIndex(fAltInputText);
-        fAltInputText = utext_clone(fAltInputText, input, FALSE, TRUE, &status);
+        fAltInputText = utext_clone(fAltInputText, input, false, true, &status);
         if (U_FAILURE(status)) {
             return *this;
         }
@@ -2126,7 +2126,7 @@ int32_t  RegexMatcher::split(UText *input,
                         UText remainingText = UTEXT_INITIALIZER;
                         utext_openUChars(&remainingText, input->chunkContents+nextOutputStringStart,
                                          fActiveLimit-nextOutputStringStart, &status);
-                        dest[i] = utext_clone(NULL, &remainingText, TRUE, FALSE, &status);
+                        dest[i] = utext_clone(NULL, &remainingText, true, false, &status);
                         utext_close(&remainingText);
                     }
                 } else {
@@ -2145,7 +2145,7 @@ int32_t  RegexMatcher::split(UText *input,
                     } else {
                         UText remainingText = UTEXT_INITIALIZER;
                         utext_openUChars(&remainingText, remainingChars, remaining16Length, &status);
-                        dest[i] = utext_clone(NULL, &remainingText, TRUE, FALSE, &status);
+                        dest[i] = utext_clone(NULL, &remainingText, true, false, &status);
                         utext_close(&remainingText);
                     }
 
@@ -2166,7 +2166,7 @@ int32_t  RegexMatcher::split(UText *input,
                     UText remainingText = UTEXT_INITIALIZER;
                     utext_openUChars(&remainingText, input->chunkContents+nextOutputStringStart,
                                       fMatchStart-nextOutputStringStart, &status);
-                    dest[i] = utext_clone(NULL, &remainingText, TRUE, FALSE, &status);
+                    dest[i] = utext_clone(NULL, &remainingText, true, false, &status);
                     utext_close(&remainingText);
                 }
             } else {
@@ -2183,7 +2183,7 @@ int32_t  RegexMatcher::split(UText *input,
                 } else {
                     UText remainingText = UTEXT_INITIALIZER;
                     utext_openUChars(&remainingText, remainingChars, remaining16Length, &status);
-                    dest[i] = utext_clone(NULL, &remainingText, TRUE, FALSE, &status);
+                    dest[i] = utext_clone(NULL, &remainingText, true, false, &status);
                     utext_close(&remainingText);
                 }
 
@@ -2236,7 +2236,7 @@ int32_t  RegexMatcher::split(UText *input,
                     UText remainingText = UTEXT_INITIALIZER;
                     utext_openUChars(&remainingText, input->chunkContents+nextOutputStringStart,
                                      fActiveLimit-nextOutputStringStart, &status);
-                    dest[i] = utext_clone(NULL, &remainingText, TRUE, FALSE, &status);
+                    dest[i] = utext_clone(NULL, &remainingText, true, false, &status);
                     utext_close(&remainingText);
                 }
             } else {
@@ -2254,7 +2254,7 @@ int32_t  RegexMatcher::split(UText *input,
                 } else {
                     UText remainingText = UTEXT_INITIALIZER;
                     utext_openUChars(&remainingText, remainingChars, remaining16Length, &status);
-                    dest[i] = utext_clone(NULL, &remainingText, TRUE, FALSE, &status);
+                    dest[i] = utext_clone(NULL, &remainingText, true, false, &status);
                     utext_close(&remainingText);
                 }
 
@@ -2297,7 +2297,7 @@ int64_t RegexMatcher::start64(int32_t group, UErrorCode &status) const {
         status = fDeferredStatus;
         return -1;
     }
-    if (fMatch == FALSE) {
+    if (fMatch == false) {
         status = U_REGEX_INVALID_STATE;
         return -1;
     }
@@ -2534,7 +2534,7 @@ REStackFrame *RegexMatcher::resetStack() {
 //                     in perl, "xab..cd..", \b is true at positions 0,3,5,7
 //                     For us,
 //                       If the current char is a combining mark,
-//                          \b is FALSE.
+//                          \b is false.
 //                       Else Scan backwards to the first non-combining char.
 //                            We are at a boundary if the this char and the original chars are
 //                               opposite in membership in \w set
@@ -2545,11 +2545,11 @@ REStackFrame *RegexMatcher::resetStack() {
 //
 //--------------------------------------------------------------------------------
 UBool RegexMatcher::isWordBoundary(int64_t pos) {
-    UBool isBoundary = FALSE;
-    UBool cIsWord    = FALSE;
+    UBool isBoundary = false;
+    UBool cIsWord    = false;
 
     if (pos >= fLookLimit) {
-        fHitEnd = TRUE;
+        fHitEnd = true;
     } else {
         // Determine whether char c at current position is a member of the word set of chars.
         // If we're off the end of the string, behave as though we're not at a word char.
@@ -2557,14 +2557,14 @@ UBool RegexMatcher::isWordBoundary(int64_t pos) {
         UChar32  c = UTEXT_CURRENT32(fInputText);
         if (u_hasBinaryProperty(c, UCHAR_GRAPHEME_EXTEND) || u_charType(c) == U_FORMAT_CHAR) {
             // Current char is a combining one.  Not a boundary.
-            return FALSE;
+            return false;
         }
         cIsWord = RegexStaticSets::gStaticSets->fPropSets[URX_ISWORD_SET].contains(c);
     }
 
     // Back up until we come to a non-combining char, determine whether
     //  that char is a word char.
-    UBool prevCIsWord = FALSE;
+    UBool prevCIsWord = false;
     for (;;) {
         if (UTEXT_GETNATIVEINDEX(fInputText) <= fLookStart) {
             break;
@@ -2581,13 +2581,13 @@ UBool RegexMatcher::isWordBoundary(int64_t pos) {
 }
 
 UBool RegexMatcher::isChunkWordBoundary(int32_t pos) {
-    UBool isBoundary = FALSE;
-    UBool cIsWord    = FALSE;
+    UBool isBoundary = false;
+    UBool cIsWord    = false;
 
     const UChar *inputBuf = fInputText->chunkContents;
 
     if (pos >= fLookLimit) {
-        fHitEnd = TRUE;
+        fHitEnd = true;
     } else {
         // Determine whether char c at current position is a member of the word set of chars.
         // If we're off the end of the string, behave as though we're not at a word char.
@@ -2595,14 +2595,14 @@ UBool RegexMatcher::isChunkWordBoundary(int32_t pos) {
         U16_GET(inputBuf, fLookStart, pos, fLookLimit, c);
         if (u_hasBinaryProperty(c, UCHAR_GRAPHEME_EXTEND) || u_charType(c) == U_FORMAT_CHAR) {
             // Current char is a combining one.  Not a boundary.
-            return FALSE;
+            return false;
         }
         cIsWord = RegexStaticSets::gStaticSets->fPropSets[URX_ISWORD_SET].contains(c);
     }
 
     // Back up until we come to a non-combining char, determine whether
     //  that char is a word char.
-    UBool prevCIsWord = FALSE;
+    UBool prevCIsWord = false;
     for (;;) {
         if (pos <= fLookStart) {
             break;
@@ -2629,7 +2629,7 @@ UBool RegexMatcher::isChunkWordBoundary(int32_t pos) {
 //
 //--------------------------------------------------------------------------------
 UBool RegexMatcher::isUWordBoundary(int64_t pos, UErrorCode &status) {
-    UBool       returnVal = FALSE;
+    UBool       returnVal = false;
 
 #if UCONFIG_NO_BREAK_ITERATION==0
     // Note: this point will never be reached if break iteration is configured out.
@@ -2639,7 +2639,7 @@ UBool RegexMatcher::isUWordBoundary(int64_t pos, UErrorCode &status) {
     if (fWordBreakItr == nullptr) {
         fWordBreakItr = BreakIterator::createWordInstance(Locale::getEnglish(), status);
         if (U_FAILURE(status)) {
-            return FALSE;
+            return false;
         }
         fWordBreakItr->setText(fInputText, status);
     }
@@ -2647,8 +2647,8 @@ UBool RegexMatcher::isUWordBoundary(int64_t pos, UErrorCode &status) {
     // Note: zero width boundary tests like \b see through transparent region bounds,
     //       which is why fLookLimit is used here, rather than fActiveLimit.
     if (pos >= fLookLimit) {
-        fHitEnd = TRUE;
-        returnVal = TRUE;   // With Unicode word rules, only positions within the interior of "real"
+        fHitEnd = true;
+        returnVal = true;   // With Unicode word rules, only positions within the interior of "real"
                             //    words are not boundaries.  All non-word chars stand by themselves,
                             //    with word boundaries on both sides.
     } else {
@@ -2697,7 +2697,7 @@ void RegexMatcher::IncrementTime(UErrorCode &status) {
     fTickCounter = TIMER_INITIAL_VALUE;
     fTime++;
     if (fCallbackFn != NULL) {
-        if ((*fCallbackFn)(fCallbackContext, fTime) == FALSE) {
+        if ((*fCallbackFn)(fCallbackContext, fTime) == false) {
             status = U_REGEX_STOPPED_BY_CALLER;
             return;
         }
@@ -2787,7 +2787,7 @@ UnicodeString StringFromUText(UText *ut) {
 //
 //--------------------------------------------------------------------------------
 void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
-    UBool       isMatch  = FALSE;      // True if the we have a match.
+    UBool       isMatch  = false;      // True if the we have a match.
 
     int64_t     backSearchIndex = U_INT64_MAX; // used after greedy single-character matches for searching backwards
 
@@ -2872,7 +2872,7 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
                     break;
                 }
             } else {
-                fHitEnd = TRUE;
+                fHitEnd = true;
             }
             fp = (REStackFrame *)fStack->popFrame(fFrameSize);
             break;
@@ -2897,17 +2897,17 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
                 UTEXT_SETNATIVEINDEX(fInputText, fp->fInputIdx);
                 UChar32 inputChar;
                 UChar32 patternChar;
-                UBool success = TRUE;
+                UBool success = true;
                 while (patternStringIndex < stringLen) {
                     if (UTEXT_GETNATIVEINDEX(fInputText) >= fActiveLimit) {
-                        success = FALSE;
-                        fHitEnd = TRUE;
+                        success = false;
+                        fHitEnd = true;
                         break;
                     }
                     inputChar = UTEXT_NEXT32(fInputText);
                     U16_NEXT(patternString, patternStringIndex, stringLen, patternChar);
                     if (patternChar != inputChar) {
-                        success = FALSE;
+                        success = false;
                         break;
                     }
                 }
@@ -2934,7 +2934,7 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
                 fp = (REStackFrame *)fStack->popFrame(fFrameSize);
                 break;
             }
-            isMatch = TRUE;
+            isMatch = true;
             goto  breakFromLoop;
 
         // Start and End Capture stack frame variables are laid out out like this:
@@ -2962,8 +2962,8 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
             {
                 if (fp->fInputIdx >= fAnchorLimit) {
                     // We really are at the end of input.  Success.
-                    fHitEnd = TRUE;
-                    fRequireEnd = TRUE;
+                    fHitEnd = true;
+                    fRequireEnd = true;
                     break;
                 }
 
@@ -2977,8 +2977,8 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
                         // If not in the middle of a CR/LF sequence
                         if ( !(c==0x0a && fp->fInputIdx>fAnchorStart && ((void)UTEXT_PREVIOUS32(fInputText), UTEXT_PREVIOUS32(fInputText))==0x0d)) {
                             // At new-line at end of input. Success
-                            fHitEnd = TRUE;
-                            fRequireEnd = TRUE;
+                            fHitEnd = true;
+                            fRequireEnd = true;
 
                             break;
                         }
@@ -2986,8 +2986,8 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
                 } else {
                     UChar32 nextC = UTEXT_NEXT32(fInputText);
                     if (c == 0x0d && nextC == 0x0a && UTEXT_GETNATIVEINDEX(fInputText) >= fAnchorLimit) {
-                        fHitEnd = TRUE;
-                        fRequireEnd = TRUE;
+                        fHitEnd = true;
+                        fRequireEnd = true;
                         break;                         // At CR/LF at end of input.  Success
                     }
                 }
@@ -3000,16 +3000,16 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
          case URX_DOLLAR_D:                   //  $, test for End of Line, in UNIX_LINES mode.
             if (fp->fInputIdx >= fAnchorLimit) {
                 // Off the end of input.  Success.
-                fHitEnd = TRUE;
-                fRequireEnd = TRUE;
+                fHitEnd = true;
+                fRequireEnd = true;
                 break;
             } else {
                 UTEXT_SETNATIVEINDEX(fInputText, fp->fInputIdx);
                 UChar32 c = UTEXT_NEXT32(fInputText);
                 // Either at the last character of input, or off the end.
                 if (c == 0x0a && UTEXT_GETNATIVEINDEX(fInputText) == fAnchorLimit) {
-                    fHitEnd = TRUE;
-                    fRequireEnd = TRUE;
+                    fHitEnd = true;
+                    fRequireEnd = true;
                     break;
                 }
             }
@@ -3023,8 +3023,8 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
              {
                  if (fp->fInputIdx >= fAnchorLimit) {
                      // We really are at the end of input.  Success.
-                     fHitEnd = TRUE;
-                     fRequireEnd = TRUE;
+                     fHitEnd = true;
+                     fRequireEnd = true;
                      break;
                  }
                  // If we are positioned just before a new-line, succeed.
@@ -3049,8 +3049,8 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
              {
                  if (fp->fInputIdx >= fAnchorLimit) {
                      // We really are at the end of input.  Success.
-                     fHitEnd = TRUE;
-                     fRequireEnd = TRUE;  // Java set requireEnd in this case, even though
+                     fHitEnd = true;
+                     fRequireEnd = true;  // Java set requireEnd in this case, even though
                      break;               //   adding a new-line would not lose the match.
                  }
                  // If we are not positioned just before a new-line, the test fails; backtrack out.
@@ -3134,7 +3134,7 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
         case URX_BACKSLASH_D:            // Test for decimal digit
             {
                 if (fp->fInputIdx >= fActiveLimit) {
-                    fHitEnd = TRUE;
+                    fHitEnd = true;
                     fp = (REStackFrame *)fStack->popFrame(fFrameSize);
                     break;
                 }
@@ -3155,7 +3155,7 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
 
 
         case URX_BACKSLASH_G:          // Test for position at end of previous match
-            if (!((fMatch && fp->fInputIdx==fMatchEnd) || (fMatch==FALSE && fp->fInputIdx==fActiveStart))) {
+            if (!((fMatch && fp->fInputIdx==fMatchEnd) || (fMatch==false && fp->fInputIdx==fActiveStart))) {
                 fp = (REStackFrame *)fStack->popFrame(fFrameSize);
             }
             break;
@@ -3164,7 +3164,7 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
         case URX_BACKSLASH_H:            // Test for \h, horizontal white space.
             {
                 if (fp->fInputIdx >= fActiveLimit) {
-                    fHitEnd = TRUE;
+                    fHitEnd = true;
                     fp = (REStackFrame *)fStack->popFrame(fFrameSize);
                     break;
                 }
@@ -3185,7 +3185,7 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
         case URX_BACKSLASH_R:            // Test for \R, any line break sequence.
             {
                 if (fp->fInputIdx >= fActiveLimit) {
-                    fHitEnd = TRUE;
+                    fHitEnd = true;
                     fp = (REStackFrame *)fStack->popFrame(fFrameSize);
                     break;
                 }
@@ -3206,7 +3206,7 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
         case URX_BACKSLASH_V:            // \v, any single line ending character.
             {
                 if (fp->fInputIdx >= fActiveLimit) {
-                    fHitEnd = TRUE;
+                    fHitEnd = true;
                     fp = (REStackFrame *)fStack->popFrame(fFrameSize);
                     break;
                 }
@@ -3228,14 +3228,14 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
 
             // Fail if at end of input
             if (fp->fInputIdx >= fActiveLimit) {
-                fHitEnd = TRUE;
+                fHitEnd = true;
                 fp = (REStackFrame *)fStack->popFrame(fFrameSize);
                 break;
             }
 
             fp->fInputIdx = followingGCBoundary(fp->fInputIdx, status);
             if (fp->fInputIdx >= fActiveLimit) {
-                fHitEnd = TRUE;
+                fHitEnd = true;
                 fp->fInputIdx = fActiveLimit;
             }
             break;
@@ -3245,8 +3245,8 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
             if (fp->fInputIdx < fAnchorLimit) {
                 fp = (REStackFrame *)fStack->popFrame(fFrameSize);
             } else {
-                fHitEnd = TRUE;
-                fRequireEnd = TRUE;
+                fHitEnd = true;
+                fRequireEnd = true;
             }
             break;
 
@@ -3260,7 +3260,7 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
                 //    0:   success if input char is in set.
                 //    1:   success if input char is not in set.
                 if (fp->fInputIdx >= fActiveLimit) {
-                    fHitEnd = TRUE;
+                    fHitEnd = true;
                     fp = (REStackFrame *)fStack->popFrame(fFrameSize);
                     break;
                 }
@@ -3297,7 +3297,7 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
                 // Test input character for NOT being a member of  one of
                 //    the predefined sets (Word Characters, for example)
                 if (fp->fInputIdx >= fActiveLimit) {
-                    fHitEnd = TRUE;
+                    fHitEnd = true;
                     fp = (REStackFrame *)fStack->popFrame(fFrameSize);
                     break;
                 }
@@ -3309,13 +3309,13 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
                 UChar32 c = UTEXT_NEXT32(fInputText);
                 if (c < 256) {
                     Regex8BitSet &s8 = RegexStaticSets::gStaticSets->fPropSets8[opValue];
-                    if (s8.contains(c) == FALSE) {
+                    if (s8.contains(c) == false) {
                         fp->fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
                         break;
                     }
                 } else {
                     const UnicodeSet &s = RegexStaticSets::gStaticSets->fPropSets[opValue];
-                    if (s.contains(c) == FALSE) {
+                    if (s.contains(c) == false) {
                         fp->fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
                         break;
                     }
@@ -3328,7 +3328,7 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
 
         case URX_SETREF:
             if (fp->fInputIdx >= fActiveLimit) {
-                fHitEnd = TRUE;
+                fHitEnd = true;
                 fp = (REStackFrame *)fStack->popFrame(fFrameSize);
                 break;
             } else {
@@ -3363,7 +3363,7 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
                 // . matches anything, but stops at end-of-line.
                 if (fp->fInputIdx >= fActiveLimit) {
                     // At end of input.  Match failed.  Backtrack out.
-                    fHitEnd = TRUE;
+                    fHitEnd = true;
                     fp = (REStackFrame *)fStack->popFrame(fFrameSize);
                     break;
                 }
@@ -3387,7 +3387,7 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
                 // ., in dot-matches-all (including new lines) mode
                 if (fp->fInputIdx >= fActiveLimit) {
                     // At end of input.  Match failed.  Backtrack out.
-                    fHitEnd = TRUE;
+                    fHitEnd = true;
                     fp = (REStackFrame *)fStack->popFrame(fFrameSize);
                     break;
                 }
@@ -3417,7 +3417,7 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
                 //   UNIX_LINES mode, so 0x0a is the only recognized line ending.
                 if (fp->fInputIdx >= fActiveLimit) {
                     // At end of input.  Match failed.  Backtrack out.
-                    fHitEnd = TRUE;
+                    fHitEnd = true;
                     fp = (REStackFrame *)fStack->popFrame(fFrameSize);
                     break;
                 }
@@ -3441,7 +3441,7 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
             break;
 
         case URX_FAIL:
-            isMatch = FALSE;
+            isMatch = false;
             goto breakFromLoop;
 
         case URX_JMP_SAV:
@@ -3658,21 +3658,21 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
                 //         match succeeds.  Verified by testing:  Perl matches succeed
                 //         in this case, so we do too.
 
-                UBool success = TRUE;
+                UBool success = true;
                 for (;;) {
                     if (utext_getNativeIndex(fAltInputText) >= groupEndIdx) {
-                        success = TRUE;
+                        success = true;
                         break;
                     }
                     if (utext_getNativeIndex(fInputText) >= fActiveLimit) {
-                        success = FALSE;
-                        fHitEnd = TRUE;
+                        success = false;
+                        fHitEnd = true;
                         break;
                     }
                     UChar32 captureGroupChar = utext_next32(fAltInputText);
                     UChar32 inputChar = utext_next32(fInputText);
                     if (inputChar != captureGroupChar) {
-                        success = FALSE;
+                        success = false;
                         break;
                     }
                 }
@@ -3707,21 +3707,21 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
                 //         match succeeds.  Verified by testing:  Perl matches succeed
                 //         in this case, so we do too.
 
-                UBool success = TRUE;
+                UBool success = true;
                 for (;;) {
                     if (!captureGroupItr.inExpansion() && utext_getNativeIndex(fAltInputText) >= groupEndIdx) {
-                        success = TRUE;
+                        success = true;
                         break;
                     }
                     if (!inputItr.inExpansion() && utext_getNativeIndex(fInputText) >= fActiveLimit) {
-                        success = FALSE;
-                        fHitEnd = TRUE;
+                        success = false;
+                        fHitEnd = true;
                         break;
                     }
                     UChar32 captureGroupChar = captureGroupItr.next();
                     UChar32 inputChar = inputItr.next();
                     if (inputChar != captureGroupChar) {
-                        success = FALSE;
+                        success = false;
                         break;
                     }
                 }
@@ -3730,7 +3730,7 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
                     // We obtained a match by consuming part of a string obtained from
                     // case-folding a single code point of the input text.
                     // This does not count as an overall match.
-                    success = FALSE;
+                    success = false;
                 }
 
                 if (success) {
@@ -3823,7 +3823,7 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
                     break;
                 }
             } else {
-                fHitEnd = TRUE;
+                fHitEnd = true;
             }
 
             fp = (REStackFrame *)fStack->popFrame(fFrameSize);
@@ -3849,25 +3849,25 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
 
                     UChar32   cPattern;
                     UChar32   cText;
-                    UBool     success = TRUE;
+                    UBool     success = true;
 
                     UTEXT_SETNATIVEINDEX(fInputText, fp->fInputIdx);
                     CaseFoldingUTextIterator inputIterator(*fInputText);
                     while (patternStringIdx < patternStringLen) {
                         if (!inputIterator.inExpansion() && UTEXT_GETNATIVEINDEX(fInputText) >= fActiveLimit) {
-                            success = FALSE;
-                            fHitEnd = TRUE;
+                            success = false;
+                            fHitEnd = true;
                             break;
                         }
                         U16_NEXT(patternString, patternStringIdx, patternStringLen, cPattern);
                         cText = inputIterator.next();
                         if (cText != cPattern) {
-                            success = FALSE;
+                            success = false;
                             break;
                         }
                     }
                     if (inputIterator.inExpansion()) {
-                        success = FALSE;
+                        success = false;
                     }
 
                     if (success) {
@@ -4099,16 +4099,16 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
                 UTEXT_SETNATIVEINDEX(fInputText, ix);
                 for (;;) {
                     if (ix >= fActiveLimit) {
-                        fHitEnd = TRUE;
+                        fHitEnd = true;
                         break;
                     }
                     UChar32 c = UTEXT_NEXT32(fInputText);
                     if (c<256) {
-                        if (s8->contains(c) == FALSE) {
+                        if (s8->contains(c) == false) {
                             break;
                         }
                     } else {
-                        if (s->contains(c) == FALSE) {
+                        if (s->contains(c) == false) {
                             break;
                         }
                     }
@@ -4152,7 +4152,7 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
                 if ((opValue & 1) == 1) {
                     // Dot-matches-All mode.  Jump straight to the end of the string.
                     ix = fActiveLimit;
-                    fHitEnd = TRUE;
+                    fHitEnd = true;
                 } else {
                     // NOT DOT ALL mode.  Line endings do not match '.'
                     // Scan forward until a line ending or end of input.
@@ -4160,7 +4160,7 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
                     UTEXT_SETNATIVEINDEX(fInputText, ix);
                     for (;;) {
                         if (ix >= fActiveLimit) {
-                            fHitEnd = TRUE;
+                            fHitEnd = true;
                             break;
                         }
                         UChar32 c = UTEXT_NEXT32(fInputText);
@@ -4252,7 +4252,7 @@ void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &status) {
         }
 
         if (U_FAILURE(status)) {
-            isMatch = FALSE;
+            isMatch = false;
             break;
         }
     }
@@ -4295,7 +4295,7 @@ breakFromLoop:
 //
 //--------------------------------------------------------------------------------
 void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &status) {
-    UBool       isMatch  = FALSE;      // True if the we have a match.
+    UBool       isMatch  = false;      // True if the we have a match.
 
     int32_t     backSearchIndex = INT32_MAX; // used after greedy single-character matches for searching backwards
 
@@ -4381,7 +4381,7 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
                     break;
                 }
             } else {
-                fHitEnd = TRUE;
+                fHitEnd = true;
             }
             fp = (REStackFrame *)fStack->popFrame(fFrameSize);
             break;
@@ -4406,15 +4406,15 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
                 const UChar * pInpLimit = inputBuf + fActiveLimit;
                 const UChar * pPat = litText+stringStartIdx;
                 const UChar * pEnd = pInp + stringLen;
-                UBool success = TRUE;
+                UBool success = true;
                 while (pInp < pEnd) {
                     if (pInp >= pInpLimit) {
-                        fHitEnd = TRUE;
-                        success = FALSE;
+                        fHitEnd = true;
+                        success = false;
                         break;
                     }
                     if (*pInp++ != *pPat++) {
-                        success = FALSE;
+                        success = false;
                         break;
                     }
                 }
@@ -4441,7 +4441,7 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
                 fp = (REStackFrame *)fStack->popFrame(fFrameSize);
                 break;
             }
-            isMatch = TRUE;
+            isMatch = true;
             goto  breakFromLoop;
 
             // Start and End Capture stack frame variables are laid out out like this:
@@ -4474,8 +4474,8 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
             }
             if (fp->fInputIdx >= fAnchorLimit) {
                 // We really are at the end of input.  Success.
-                fHitEnd = TRUE;
-                fRequireEnd = TRUE;
+                fHitEnd = true;
+                fRequireEnd = true;
                 break;
             }
 
@@ -4488,15 +4488,15 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
                 if (isLineTerminator(c)) {
                     if ( !(c==0x0a && fp->fInputIdx>fAnchorStart && inputBuf[fp->fInputIdx-1]==0x0d)) {
                         // At new-line at end of input. Success
-                        fHitEnd = TRUE;
-                        fRequireEnd = TRUE;
+                        fHitEnd = true;
+                        fRequireEnd = true;
                         break;
                     }
                 }
             } else if (fp->fInputIdx == fAnchorLimit-2 &&
                 inputBuf[fp->fInputIdx]==0x0d && inputBuf[fp->fInputIdx+1]==0x0a) {
-                    fHitEnd = TRUE;
-                    fRequireEnd = TRUE;
+                    fHitEnd = true;
+                    fRequireEnd = true;
                     break;                         // At CR/LF at end of input.  Success
             }
 
@@ -4511,14 +4511,14 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
                 if (fp->fInputIdx == fAnchorLimit-1) {
                     // At last char of input.  Success if it's a new line.
                     if (inputBuf[fp->fInputIdx] == 0x0a) {
-                        fHitEnd = TRUE;
-                        fRequireEnd = TRUE;
+                        fHitEnd = true;
+                        fRequireEnd = true;
                         break;
                     }
                 } else {
                     // Off the end of input.  Success.
-                    fHitEnd = TRUE;
-                    fRequireEnd = TRUE;
+                    fHitEnd = true;
+                    fRequireEnd = true;
                     break;
                 }
             }
@@ -4532,8 +4532,8 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
             {
                 if (fp->fInputIdx >= fAnchorLimit) {
                     // We really are at the end of input.  Success.
-                    fHitEnd = TRUE;
-                    fRequireEnd = TRUE;
+                    fHitEnd = true;
+                    fRequireEnd = true;
                     break;
                 }
                 // If we are positioned just before a new-line, succeed.
@@ -4557,8 +4557,8 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
             {
                 if (fp->fInputIdx >= fAnchorLimit) {
                     // We really are at the end of input.  Success.
-                    fHitEnd = TRUE;
-                    fRequireEnd = TRUE;  // Java set requireEnd in this case, even though
+                    fHitEnd = true;
+                    fRequireEnd = true;  // Java set requireEnd in this case, even though
                     break;               //   adding a new-line would not lose the match.
                 }
                 // If we are not positioned just before a new-line, the test fails; backtrack out.
@@ -4640,7 +4640,7 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
         case URX_BACKSLASH_D:            // Test for decimal digit
             {
                 if (fp->fInputIdx >= fActiveLimit) {
-                    fHitEnd = TRUE;
+                    fHitEnd = true;
                     fp = (REStackFrame *)fStack->popFrame(fFrameSize);
                     break;
                 }
@@ -4658,7 +4658,7 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
 
 
         case URX_BACKSLASH_G:          // Test for position at end of previous match
-            if (!((fMatch && fp->fInputIdx==fMatchEnd) || (fMatch==FALSE && fp->fInputIdx==fActiveStart))) {
+            if (!((fMatch && fp->fInputIdx==fMatchEnd) || (fMatch==false && fp->fInputIdx==fActiveStart))) {
                 fp = (REStackFrame *)fStack->popFrame(fFrameSize);
             }
             break;
@@ -4667,7 +4667,7 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
         case URX_BACKSLASH_H:            // Test for \h, horizontal white space.
             {
                 if (fp->fInputIdx >= fActiveLimit) {
-                    fHitEnd = TRUE;
+                    fHitEnd = true;
                     fp = (REStackFrame *)fStack->popFrame(fFrameSize);
                     break;
                 }
@@ -4686,7 +4686,7 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
         case URX_BACKSLASH_R:            // Test for \R, any line break sequence.
             {
                 if (fp->fInputIdx >= fActiveLimit) {
-                    fHitEnd = TRUE;
+                    fHitEnd = true;
                     fp = (REStackFrame *)fStack->popFrame(fFrameSize);
                     break;
                 }
@@ -4711,7 +4711,7 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
         case URX_BACKSLASH_V:         // Any single code point line ending.
             {
                 if (fp->fInputIdx >= fActiveLimit) {
-                    fHitEnd = TRUE;
+                    fHitEnd = true;
                     fp = (REStackFrame *)fStack->popFrame(fFrameSize);
                     break;
                 }
@@ -4731,14 +4731,14 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
 
             // Fail if at end of input
             if (fp->fInputIdx >= fActiveLimit) {
-                fHitEnd = TRUE;
+                fHitEnd = true;
                 fp = (REStackFrame *)fStack->popFrame(fFrameSize);
                 break;
             }
 
             fp->fInputIdx = followingGCBoundary(fp->fInputIdx, status);
             if (fp->fInputIdx >= fActiveLimit) {
-                fHitEnd = TRUE;
+                fHitEnd = true;
                 fp->fInputIdx = fActiveLimit;
             }
             break;
@@ -4748,8 +4748,8 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
             if (fp->fInputIdx < fAnchorLimit) {
                 fp = (REStackFrame *)fStack->popFrame(fFrameSize);
             } else {
-                fHitEnd = TRUE;
-                fRequireEnd = TRUE;
+                fHitEnd = true;
+                fRequireEnd = true;
             }
             break;
 
@@ -4763,7 +4763,7 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
                 //    0:   success if input char is in set.
                 //    1:   success if input char is not in set.
                 if (fp->fInputIdx >= fActiveLimit) {
-                    fHitEnd = TRUE;
+                    fHitEnd = true;
                     fp = (REStackFrame *)fStack->popFrame(fFrameSize);
                     break;
                 }
@@ -4797,7 +4797,7 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
                 // Test input character for NOT being a member of  one of
                 //    the predefined sets (Word Characters, for example)
                 if (fp->fInputIdx >= fActiveLimit) {
-                    fHitEnd = TRUE;
+                    fHitEnd = true;
                     fp = (REStackFrame *)fStack->popFrame(fFrameSize);
                     break;
                 }
@@ -4808,12 +4808,12 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
                 U16_NEXT(inputBuf, fp->fInputIdx, fActiveLimit, c);
                 if (c < 256) {
                     Regex8BitSet &s8 = RegexStaticSets::gStaticSets->fPropSets8[opValue];
-                    if (s8.contains(c) == FALSE) {
+                    if (s8.contains(c) == false) {
                         break;
                     }
                 } else {
                     const UnicodeSet &s = RegexStaticSets::gStaticSets->fPropSets[opValue];
-                    if (s.contains(c) == FALSE) {
+                    if (s.contains(c) == false) {
                         break;
                     }
                 }
@@ -4825,7 +4825,7 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
         case URX_SETREF:
             {
                 if (fp->fInputIdx >= fActiveLimit) {
-                    fHitEnd = TRUE;
+                    fHitEnd = true;
                     fp = (REStackFrame *)fStack->popFrame(fFrameSize);
                     break;
                 }
@@ -4860,7 +4860,7 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
                 // . matches anything, but stops at end-of-line.
                 if (fp->fInputIdx >= fActiveLimit) {
                     // At end of input.  Match failed.  Backtrack out.
-                    fHitEnd = TRUE;
+                    fHitEnd = true;
                     fp = (REStackFrame *)fStack->popFrame(fFrameSize);
                     break;
                 }
@@ -4882,7 +4882,7 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
                 // . in dot-matches-all (including new lines) mode
                 if (fp->fInputIdx >= fActiveLimit) {
                     // At end of input.  Match failed.  Backtrack out.
-                    fHitEnd = TRUE;
+                    fHitEnd = true;
                     fp = (REStackFrame *)fStack->popFrame(fFrameSize);
                     break;
                 }
@@ -4907,7 +4907,7 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
                 //   UNIX_LINES mode, so 0x0a is the only recognized line ending.
                 if (fp->fInputIdx >= fActiveLimit) {
                     // At end of input.  Match failed.  Backtrack out.
-                    fHitEnd = TRUE;
+                    fHitEnd = true;
                     fp = (REStackFrame *)fStack->popFrame(fFrameSize);
                     break;
                 }
@@ -4928,7 +4928,7 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
             break;
 
         case URX_FAIL:
-            isMatch = FALSE;
+            isMatch = false;
             goto breakFromLoop;
 
         case URX_JMP_SAV:
@@ -5137,15 +5137,15 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
                     fp = (REStackFrame *)fStack->popFrame(fFrameSize);   // FAIL, no match.
                     break;
                 }
-                UBool success = TRUE;
+                UBool success = true;
                 for (int64_t groupIndex = groupStartIdx; groupIndex < groupEndIdx; ++groupIndex,++inputIndex) {
                     if (inputIndex >= fActiveLimit) {
-                        success = FALSE;
-                        fHitEnd = TRUE;
+                        success = false;
+                        fHitEnd = true;
                         break;
                     }
                     if (inputBuf[groupIndex] != inputBuf[inputIndex]) {
-                        success = FALSE;
+                        success = false;
                         break;
                     }
                 }
@@ -5153,7 +5153,7 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
                         inputIndex < fActiveLimit && U16_IS_TRAIL(inputBuf[inputIndex])) {
                     // Capture group ended with an unpaired lead surrogate.
                     // Back reference is not permitted to match lead only of a surrogatge pair.
-                    success = FALSE;
+                    success = false;
                 }
                 if (success) {
                     fp->fInputIdx = inputIndex;
@@ -5181,21 +5181,21 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
                 //         match succeeds.  Verified by testing:  Perl matches succeed
                 //         in this case, so we do too.
 
-                UBool success = TRUE;
+                UBool success = true;
                 for (;;) {
                     UChar32 captureGroupChar = captureGroupItr.next();
                     if (captureGroupChar == U_SENTINEL) {
-                        success = TRUE;
+                        success = true;
                         break;
                     }
                     UChar32 inputChar = inputItr.next();
                     if (inputChar == U_SENTINEL) {
-                        success = FALSE;
-                        fHitEnd = TRUE;
+                        success = false;
+                        fHitEnd = true;
                         break;
                     }
                     if (inputChar != captureGroupChar) {
-                        success = FALSE;
+                        success = false;
                         break;
                     }
                 }
@@ -5204,7 +5204,7 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
                     // We obtained a match by consuming part of a string obtained from
                     // case-folding a single code point of the input text.
                     // This does not count as an overall match.
-                    success = FALSE;
+                    success = false;
                 }
 
                 if (success) {
@@ -5291,7 +5291,7 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
                     break;
                 }
             } else {
-                fHitEnd = TRUE;
+                fHitEnd = true;
             }
             fp = (REStackFrame *)fStack->popFrame(fFrameSize);
             break;
@@ -5313,22 +5313,22 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
 
                 UChar32      cText;
                 UChar32      cPattern;
-                UBool        success = TRUE;
+                UBool        success = true;
                 int32_t      patternStringIdx  = 0;
                 CaseFoldingUCharIterator inputIterator(inputBuf, fp->fInputIdx, fActiveLimit);
                 while (patternStringIdx < patternStringLen) {
                     U16_NEXT(patternString, patternStringIdx, patternStringLen, cPattern);
                     cText = inputIterator.next();
                     if (cText != cPattern) {
-                        success = FALSE;
+                        success = false;
                         if (cText == U_SENTINEL) {
-                            fHitEnd = TRUE;
+                            fHitEnd = true;
                         }
                         break;
                     }
                 }
                 if (inputIterator.inExpansion()) {
-                    success = FALSE;
+                    success = false;
                 }
 
                 if (success) {
@@ -5540,18 +5540,18 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
                 int32_t ix = (int32_t)fp->fInputIdx;
                 for (;;) {
                     if (ix >= fActiveLimit) {
-                        fHitEnd = TRUE;
+                        fHitEnd = true;
                         break;
                     }
                     UChar32   c;
                     U16_NEXT(inputBuf, ix, fActiveLimit, c);
                     if (c<256) {
-                        if (s8->contains(c) == FALSE) {
+                        if (s8->contains(c) == false) {
                             U16_BACK_1(inputBuf, 0, ix);
                             break;
                         }
                     } else {
-                        if (s->contains(c) == FALSE) {
+                        if (s->contains(c) == false) {
                             U16_BACK_1(inputBuf, 0, ix);
                             break;
                         }
@@ -5595,14 +5595,14 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
                 if ((opValue & 1) == 1) {
                     // Dot-matches-All mode.  Jump straight to the end of the string.
                     ix = (int32_t)fActiveLimit;
-                    fHitEnd = TRUE;
+                    fHitEnd = true;
                 } else {
                     // NOT DOT ALL mode.  Line endings do not match '.'
                     // Scan forward until a line ending or end of input.
                     ix = (int32_t)fp->fInputIdx;
                     for (;;) {
                         if (ix >= fActiveLimit) {
-                            fHitEnd = TRUE;
+                            fHitEnd = true;
                             break;
                         }
                         UChar32   c;
@@ -5694,7 +5694,7 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu
         }
 
         if (U_FAILURE(status)) {
-            isMatch = FALSE;
+            isMatch = false;
             break;
         }
     }
diff --git a/deps/icu-small/source/i18n/remtrans.cpp b/deps/icu-small/source/i18n/remtrans.cpp
index 03b878575c..957ac480fb 100644
--- a/deps/icu-small/source/i18n/remtrans.cpp
+++ b/deps/icu-small/source/i18n/remtrans.cpp
@@ -37,14 +37,14 @@ static Transliterator* RemoveTransliterator_create(const UnicodeString& /*ID*/,
  */
 void RemoveTransliterator::registerIDs() {
 
-    Transliterator::_registerFactory(UnicodeString(TRUE, ::CURR_ID, -1),
+    Transliterator::_registerFactory(UnicodeString(true, ::CURR_ID, -1),
                                      RemoveTransliterator_create, integerToken(0));
 
     Transliterator::_registerSpecialInverse(UNICODE_STRING_SIMPLE("Remove"),
-                                            UNICODE_STRING_SIMPLE("Null"), FALSE);
+                                            UNICODE_STRING_SIMPLE("Null"), false);
 }
 
-RemoveTransliterator::RemoveTransliterator() : Transliterator(UnicodeString(TRUE, ::CURR_ID, -1), 0) {}
+RemoveTransliterator::RemoveTransliterator() : Transliterator(UnicodeString(true, ::CURR_ID, -1), 0) {}
 
 RemoveTransliterator::~RemoveTransliterator() {}
 
diff --git a/deps/icu-small/source/i18n/repattrn.cpp b/deps/icu-small/source/i18n/repattrn.cpp
index 8c94948d29..0ef85bdf6c 100644
--- a/deps/icu-small/source/i18n/repattrn.cpp
+++ b/deps/icu-small/source/i18n/repattrn.cpp
@@ -79,7 +79,7 @@ RegexPattern &RegexPattern::operator = (const RegexPattern &other) {
 
     if (other.fPatternString == NULL) {
         fPatternString = NULL;
-        fPattern = utext_clone(fPattern, other.fPattern, FALSE, TRUE, &fDeferredStatus);
+        fPattern = utext_clone(fPattern, other.fPattern, false, true, &fDeferredStatus);
     } else {
         fPatternString = new UnicodeString(*(other.fPatternString));
         if (fPatternString == NULL) {
@@ -179,7 +179,7 @@ void RegexPattern::init() {
     fInitialChars     = NULL;
     fInitialChar      = 0;
     fInitialChars8    = NULL;
-    fNeedsAltInput    = FALSE;
+    fNeedsAltInput    = false;
     fNamedCaptureMap  = NULL;
 
     fPattern          = NULL; // will be set later
@@ -524,7 +524,7 @@ UBool U_EXPORT2 RegexPattern::matches(const UnicodeString   &regex,
                     UParseError     &pe,
                     UErrorCode      &status) {
 
-    if (U_FAILURE(status)) {return FALSE;}
+    if (U_FAILURE(status)) {return false;}
 
     UBool         retVal;
     RegexPattern *pat     = NULL;
@@ -548,9 +548,9 @@ UBool U_EXPORT2 RegexPattern::matches(UText                *regex,
                     UParseError     &pe,
                     UErrorCode      &status) {
 
-    if (U_FAILURE(status)) {return FALSE;}
+    if (U_FAILURE(status)) {return false;}
 
-    UBool         retVal  = FALSE;
+    UBool         retVal  = false;
     RegexPattern *pat     = NULL;
     RegexMatcher *matcher = NULL;
 
@@ -788,7 +788,7 @@ void   RegexPattern::dumpOp(int32_t index) const {
         {
             UnicodeString s;
             UnicodeSet *set = (UnicodeSet *)fSets->elementAt(val);
-            set->toPattern(s, TRUE);
+            set->toPattern(s, true);
             printf("%s", CStr(s)());
         }
         break;
@@ -802,7 +802,7 @@ void   RegexPattern::dumpOp(int32_t index) const {
                 val &= ~URX_NEG_SET;
             }
             UnicodeSet &set = RegexStaticSets::gStaticSets->fPropSets[val];
-            set.toPattern(s, TRUE);
+            set.toPattern(s, true);
             printf("%s", CStr(s)());
         }
         break;
@@ -833,7 +833,7 @@ void RegexPattern::dumpPattern() const {
         printf("   Initial match string: \"%s\"\n", CStr(initialString)());
     } else if (fStartType == START_SET) {
         UnicodeString s;
-        fInitialChars->toPattern(s, TRUE);
+        fInitialChars->toPattern(s, true);
         printf("    Match First Chars: %s\n", CStr(s)());
 
     } else if (fStartType == START_CHAR) {
diff --git a/deps/icu-small/source/i18n/rulebasedcollator.cpp b/deps/icu-small/source/i18n/rulebasedcollator.cpp
index 5e5cc3db62..a240295b67 100644
--- a/deps/icu-small/source/i18n/rulebasedcollator.cpp
+++ b/deps/icu-small/source/i18n/rulebasedcollator.cpp
@@ -84,7 +84,7 @@ FixedSortKeyByteSink::AppendBeyondCapacity(const char *bytes, int32_t /*n*/, int
 
 UBool
 FixedSortKeyByteSink::Resize(int32_t /*appendCapacity*/, int32_t /*length*/) {
-    return FALSE;
+    return false;
 }
 
 }  // namespace
@@ -117,7 +117,7 @@ CollationKeyByteSink::AppendBeyondCapacity(const char *bytes, int32_t n, int32_t
 UBool
 CollationKeyByteSink::Resize(int32_t appendCapacity, int32_t length) {
     if (buffer_ == NULL) {
-        return FALSE;  // allocation failed before already
+        return false;  // allocation failed before already
     }
     int32_t newCapacity = 2 * capacity_;
     int32_t altCapacity = length + 2 * appendCapacity;
@@ -130,11 +130,11 @@ CollationKeyByteSink::Resize(int32_t appendCapacity, int32_t length) {
     uint8_t *newBuffer = key_.reallocate(newCapacity, length);
     if (newBuffer == NULL) {
         SetNotOk();
-        return FALSE;
+        return false;
     }
     buffer_ = reinterpret_cast<char *>(newBuffer);
     capacity_ = newCapacity;
-    return TRUE;
+    return true;
 }
 
 RuleBasedCollator::RuleBasedCollator(const RuleBasedCollator &other)
@@ -158,7 +158,7 @@ RuleBasedCollator::RuleBasedCollator(const uint8_t *bin, int32_t length,
           cacheEntry(NULL),
           validLocale(""),
           explicitlySetAttributes(0),
-          actualLocaleIsSameAsValid(FALSE) {
+          actualLocaleIsSameAsValid(false) {
     if(U_FAILURE(errorCode)) { return; }
     if(bin == NULL || length == 0 || base == NULL) {
         errorCode = U_ILLEGAL_ARGUMENT_ERROR;
@@ -188,7 +188,7 @@ RuleBasedCollator::RuleBasedCollator(const CollationCacheEntry *entry)
           cacheEntry(entry),
           validLocale(entry->validLocale),
           explicitlySetAttributes(0),
-          actualLocaleIsSameAsValid(FALSE) {
+          actualLocaleIsSameAsValid(false) {
     settings->addRef();
     cacheEntry->addRef();
 }
@@ -217,7 +217,7 @@ RuleBasedCollator::adoptTailoring(CollationTailoring *t, UErrorCode &errorCode)
     tailoring = t;
     cacheEntry->addRef();
     validLocale = t->actualLocale;
-    actualLocaleIsSameAsValid = FALSE;
+    actualLocaleIsSameAsValid = false;
 }
 
 RuleBasedCollator *
@@ -290,10 +290,10 @@ void
 RuleBasedCollator::setLocales(const Locale &requested, const Locale &valid,
                               const Locale &actual) {
     if(actual == tailoring->actualLocale) {
-        actualLocaleIsSameAsValid = FALSE;
+        actualLocaleIsSameAsValid = false;
     } else {
         U_ASSERT(actual == valid);
-        actualLocaleIsSameAsValid = TRUE;
+        actualLocaleIsSameAsValid = true;
     }
     // Do not modify tailoring.actualLocale:
     // We cannot be sure that that would be thread-safe.
@@ -399,7 +399,7 @@ RuleBasedCollator::internalGetContractionsAndExpansions(
 void
 RuleBasedCollator::internalAddContractions(UChar32 c, UnicodeSet &set, UErrorCode &errorCode) const {
     if(U_FAILURE(errorCode)) { return; }
-    ContractionsAndExpansions(&set, NULL, NULL, FALSE).forCodePoint(data, c, errorCode);
+    ContractionsAndExpansions(&set, NULL, NULL, false).forCodePoint(data, c, errorCode);
 }
 
 const CollationSettings &
@@ -538,7 +538,8 @@ RuleBasedCollator::setMaxVariable(UColReorderCode group, UErrorCode &errorCode)
     }
 
     if(group == UCOL_REORDER_CODE_DEFAULT) {
-        group = (UColReorderCode)(UCOL_REORDER_CODE_FIRST + defaultSettings.getMaxVariable());
+        group = (UColReorderCode)(
+            UCOL_REORDER_CODE_FIRST + int32_t{defaultSettings.getMaxVariable()});
     }
     uint32_t varTop = data->getLastPrimaryForGroup(group);
     U_ASSERT(varTop != 0);
@@ -556,7 +557,7 @@ RuleBasedCollator::setMaxVariable(UColReorderCode group, UErrorCode &errorCode)
 
 UColReorderCode
 RuleBasedCollator::getMaxVariable() const {
-    return (UColReorderCode)(UCOL_REORDER_CODE_FIRST + settings->getMaxVariable());
+    return (UColReorderCode)(UCOL_REORDER_CODE_FIRST + int32_t{settings->getMaxVariable()});
 }
 
 uint32_t
@@ -897,7 +898,7 @@ protected:
 class FCDUTF8NFDIterator : public NFDIterator {
 public:
     FCDUTF8NFDIterator(const CollationData *data, const uint8_t *text, int32_t textLength)
-            : u8ci(data, FALSE, text, 0, textLength) {}
+            : u8ci(data, false, text, 0, textLength) {}
 protected:
     virtual UChar32 nextRawCodePoint() override {
         UErrorCode errorCode = U_ZERO_ERROR;
@@ -921,7 +922,7 @@ private:
 class FCDUIterNFDIterator : public NFDIterator {
 public:
     FCDUIterNFDIterator(const CollationData *data, UCharIterator &it, int32_t startIndex)
-            : uici(data, FALSE, it, startIndex) {}
+            : uici(data, false, it, startIndex) {}
 protected:
     virtual UChar32 nextRawCodePoint() override {
         UErrorCode errorCode = U_ZERO_ERROR;
@@ -1121,7 +1122,7 @@ RuleBasedCollator::doCompare(const uint8_t *left, int32_t leftLength,
 
     UBool numeric = settings->isNumeric();
     if(equalPrefixLength > 0) {
-        UBool unsafe = FALSE;
+        UBool unsafe = false;
         if(equalPrefixLength != leftLength) {
             int32_t i = equalPrefixLength;
             UChar32 c;
@@ -1339,12 +1340,12 @@ RuleBasedCollator::writeSortKey(const UChar *s, int32_t length,
         UTF16CollationIterator iter(data, numeric, s, s, limit);
         CollationKeys::writeSortKeyUpToQuaternary(iter, data->compressibleBytes, *settings,
                                                   sink, Collation::PRIMARY_LEVEL,
-                                                  callback, TRUE, errorCode);
+                                                  callback, true, errorCode);
     } else {
         FCDUTF16CollationIterator iter(data, numeric, s, s, limit);
         CollationKeys::writeSortKeyUpToQuaternary(iter, data->compressibleBytes, *settings,
                                                   sink, Collation::PRIMARY_LEVEL,
-                                                  callback, TRUE, errorCode);
+                                                  callback, true, errorCode);
     }
     if(settings->getStrength() == UCOL_IDENTICAL) {
         writeIdenticalLevel(s, limit, sink, errorCode);
@@ -1403,9 +1404,9 @@ public:
             // Remember a level that will be at least partially written.
             level = l;
             levelCapacity = sink.GetRemainingCapacity();
-            return TRUE;
+            return true;
         } else {
-            return FALSE;
+            return false;
         }
     }
     Collation::Level getLevel() const { return level; }
@@ -1440,11 +1441,11 @@ RuleBasedCollator::internalNextSortKeyPart(UCharIterator *iter, uint32_t state[2
         if(settings->dontCheckFCD()) {
             UIterCollationIterator ci(data, numeric, *iter);
             CollationKeys::writeSortKeyUpToQuaternary(ci, data->compressibleBytes, *settings,
-                                                      sink, level, callback, FALSE, errorCode);
+                                                      sink, level, callback, false, errorCode);
         } else {
             FCDUIterCollationIterator ci(data, numeric, *iter, 0);
             CollationKeys::writeSortKeyUpToQuaternary(ci, data->compressibleBytes, *settings,
-                                                      sink, level, callback, FALSE, errorCode);
+                                                      sink, level, callback, false, errorCode);
         }
         if(U_FAILURE(errorCode)) { return 0; }
         if(sink.NumberOfBytesAppended() > count) {
diff --git a/deps/icu-small/source/i18n/scientificnumberformatter.cpp b/deps/icu-small/source/i18n/scientificnumberformatter.cpp
index 6c2cb3aeed..99b990708a 100644
--- a/deps/icu-small/source/i18n/scientificnumberformatter.cpp
+++ b/deps/icu-small/source/i18n/scientificnumberformatter.cpp
@@ -42,19 +42,19 @@ static UBool copyAsSuperscript(
         UnicodeString &result,
         UErrorCode &status) {
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
     for (int32_t i = beginIndex; i < endIndex;) {
         UChar32 c = s.char32At(i);
         int32_t digit = u_charDigitValue(c);
         if (digit < 0) {
             status = U_INVALID_CHAR_FOUND;
-            return FALSE;
+            return false;
         }
         result.append(kSuperscriptDigits[digit]);
         i += U16_LENGTH(c);
     }
-    return TRUE;
+    return true;
 }
 
 ScientificNumberFormatter *ScientificNumberFormatter::createSuperscriptInstance(
diff --git a/deps/icu-small/source/i18n/scriptset.cpp b/deps/icu-small/source/i18n/scriptset.cpp
index 6a1db8c01c..236bf9d37f 100644
--- a/deps/icu-small/source/i18n/scriptset.cpp
+++ b/deps/icu-small/source/i18n/scriptset.cpp
@@ -55,11 +55,11 @@ bool ScriptSet::operator == (const ScriptSet &other) const {
 
 UBool ScriptSet::test(UScriptCode script, UErrorCode &status) const {
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
     if (script < 0 || (int32_t)script >= SCRIPT_LIMIT) {
         status = U_ILLEGAL_ARGUMENT_ERROR;
-        return FALSE;
+        return false;
     }
     uint32_t index = script / 32;
     uint32_t bit   = 1 << (script & 31);
@@ -188,19 +188,19 @@ int32_t ScriptSet::nextSetBit(int32_t fromIndex) const {
 UBool ScriptSet::isEmpty() const {
     for (uint32_t i=0; i<UPRV_LENGTHOF(bits); i++) {
         if (bits[i] != 0) {
-            return FALSE;
+            return false;
         }
     }
-    return TRUE;
+    return true;
 }
 
 UnicodeString &ScriptSet::displayScripts(UnicodeString &dest) const {
-    UBool firstTime = TRUE;
+    UBool firstTime = true;
     for (int32_t i = nextSetBit(0); i >= 0; i = nextSetBit(i + 1)) {
         if (!firstTime) {
             dest.append((UChar)0x20);
         }
-        firstTime = FALSE;
+        firstTime = false;
         const char *scriptName = uscript_getShortName((UScriptCode(i)));
         dest.append(UnicodeString(scriptName, -1, US_INV));
     }
@@ -248,7 +248,7 @@ void ScriptSet::setScriptExtensions(UChar32 codePoint, UErrorCode& status) {
     UErrorCode internalStatus = U_ZERO_ERROR;
     int32_t script_count = -1;
 
-    while (TRUE) {
+    while (true) {
         script_count = uscript_getScriptExtensions(
             codePoint, scripts.getAlias(), scripts.getCapacity(), &internalStatus);
         if (internalStatus == U_BUFFER_OVERFLOW_ERROR) {
diff --git a/deps/icu-small/source/i18n/scriptset.h b/deps/icu-small/source/i18n/scriptset.h
index 51980ab7b3..df5cfdc748 100644
--- a/deps/icu-small/source/i18n/scriptset.h
+++ b/deps/icu-small/source/i18n/scriptset.h
@@ -83,4 +83,7 @@ uhash_hashScriptSet(const UElement key);
 U_CAPI void U_EXPORT2
 uhash_deleteScriptSet(void *obj);
 
-#endif // __SCRIPTSET_H__
+U_CAPI UBool U_EXPORT2
+uhash_equalsScriptSet(const UElement key1, const UElement key2);
+
+#endif // __SCRIPTSET_H_
diff --git a/deps/icu-small/source/i18n/search.cpp b/deps/icu-small/source/i18n/search.cpp
index 9e559bcc71..56d9b74409 100644
--- a/deps/icu-small/source/i18n/search.cpp
+++ b/deps/icu-small/source/i18n/search.cpp
@@ -55,10 +55,10 @@ void SearchIterator::setAttribute(USearchAttribute       attribute,
         switch (attribute)
         {
         case USEARCH_OVERLAP :
-            m_search_->isOverlap = (value == USEARCH_ON ? TRUE : FALSE);
+            m_search_->isOverlap = (value == USEARCH_ON ? true : false);
             break;
         case USEARCH_CANONICAL_MATCH :
-            m_search_->isCanonicalMatch = (value == USEARCH_ON ? TRUE : FALSE);
+            m_search_->isCanonicalMatch = (value == USEARCH_ON ? true : false);
             break;
         case USEARCH_ELEMENT_COMPARISON :
             if (value == USEARCH_PATTERN_BASE_WEIGHT_IS_WILDCARD || value == USEARCH_ANY_BASE_WEIGHT_IS_WILDCARD) {
@@ -81,9 +81,9 @@ USearchAttributeValue SearchIterator::getAttribute(
 {
     switch (attribute) {
     case USEARCH_OVERLAP :
-        return (m_search_->isOverlap == TRUE ? USEARCH_ON : USEARCH_OFF);
+        return (m_search_->isOverlap == true ? USEARCH_ON : USEARCH_OFF);
     case USEARCH_CANONICAL_MATCH :
-        return (m_search_->isCanonicalMatch == TRUE ? USEARCH_ON : 
+        return (m_search_->isCanonicalMatch == true ? USEARCH_ON : 
                                                                 USEARCH_OFF);
     case USEARCH_ELEMENT_COMPARISON :
         {
@@ -241,8 +241,8 @@ int32_t SearchIterator::next(UErrorCode &status)
         int32_t offset = getOffset();
         int32_t matchindex  = m_search_->matchedIndex;
         int32_t     matchlength = m_search_->matchedLength;
-        m_search_->reset = FALSE;
-        if (m_search_->isForwardSearching == TRUE) {
+        m_search_->reset = false;
+        if (m_search_->isForwardSearching == true) {
             int32_t textlength = m_search_->textLength;
             if (offset == textlength || matchindex == textlength || 
                 (matchindex != USEARCH_DONE && 
@@ -258,7 +258,7 @@ int32_t SearchIterator::next(UErrorCode &status)
             // setOffset has been called or that previous ran off the text
             // string. the iterator would have been set to offset 0 if a 
             // match is not found.
-            m_search_->isForwardSearching = TRUE;
+            m_search_->isForwardSearching = true;
             if (m_search_->matchedIndex != USEARCH_DONE) {
                 // there's no need to set the collation element iterator
                 // the next call to next will set the offset.
@@ -286,8 +286,8 @@ int32_t SearchIterator::previous(UErrorCode &status)
         int32_t offset;
         if (m_search_->reset) {
             offset                       = m_search_->textLength;
-            m_search_->isForwardSearching = FALSE;
-            m_search_->reset              = FALSE;
+            m_search_->isForwardSearching = false;
+            m_search_->reset              = false;
             setOffset(offset, status);
         }
         else {
@@ -295,13 +295,13 @@ int32_t SearchIterator::previous(UErrorCode &status)
         }
         
         int32_t matchindex = m_search_->matchedIndex;
-        if (m_search_->isForwardSearching == TRUE) {
+        if (m_search_->isForwardSearching == true) {
             // switching direction. 
             // if matchedIndex == USEARCH_DONE, it means that either a 
             // setOffset has been called or that next ran off the text
             // string. the iterator would have been set to offset textLength if 
             // a match is not found.
-            m_search_->isForwardSearching = FALSE;
+            m_search_->isForwardSearching = false;
             if (matchindex != USEARCH_DONE) {
                 return matchindex;
             }
@@ -333,11 +333,11 @@ void SearchIterator::reset()
     UErrorCode status = U_ZERO_ERROR;
     setMatchNotFound();
     setOffset(0, status);
-    m_search_->isOverlap          = FALSE;
-    m_search_->isCanonicalMatch   = FALSE;
+    m_search_->isOverlap          = false;
+    m_search_->isCanonicalMatch   = false;
     m_search_->elementComparisonType = 0;
-    m_search_->isForwardSearching = TRUE;
-    m_search_->reset              = TRUE;
+    m_search_->isForwardSearching = true;
+    m_search_->reset              = true;
 }
 
 // protected constructors and destructors -----------------------------
@@ -346,11 +346,11 @@ SearchIterator::SearchIterator()
 {
     m_search_                     = (USearch *)uprv_malloc(sizeof(USearch));
     m_search_->breakIter          = NULL;
-    m_search_->isOverlap          = FALSE;
-    m_search_->isCanonicalMatch   = FALSE;
+    m_search_->isOverlap          = false;
+    m_search_->isCanonicalMatch   = false;
     m_search_->elementComparisonType = 0;
-    m_search_->isForwardSearching = TRUE;
-    m_search_->reset              = TRUE;
+    m_search_->isForwardSearching = true;
+    m_search_->reset              = true;
     m_search_->matchedIndex       = USEARCH_DONE;
     m_search_->matchedLength      = 0;
     m_search_->text               = NULL;
@@ -365,11 +365,11 @@ SearchIterator::SearchIterator(const UnicodeString &text,
 {
     m_search_                     = (USearch *)uprv_malloc(sizeof(USearch));
     m_search_->breakIter          = NULL;
-    m_search_->isOverlap          = FALSE;
-    m_search_->isCanonicalMatch   = FALSE;
+    m_search_->isOverlap          = false;
+    m_search_->isCanonicalMatch   = false;
     m_search_->elementComparisonType = 0;
-    m_search_->isForwardSearching = TRUE;
-    m_search_->reset              = TRUE;
+    m_search_->isForwardSearching = true;
+    m_search_->reset              = true;
     m_search_->matchedIndex       = USEARCH_DONE;
     m_search_->matchedLength      = 0;
     m_search_->text               = m_text_.getBuffer();
@@ -382,11 +382,11 @@ SearchIterator::SearchIterator(CharacterIterator &text,
 {
     m_search_                     = (USearch *)uprv_malloc(sizeof(USearch));
     m_search_->breakIter          = NULL;
-    m_search_->isOverlap          = FALSE;
-    m_search_->isCanonicalMatch   = FALSE;
+    m_search_->isOverlap          = false;
+    m_search_->isCanonicalMatch   = false;
     m_search_->elementComparisonType = 0;
-    m_search_->isForwardSearching = TRUE;
-    m_search_->reset              = TRUE;
+    m_search_->isForwardSearching = true;
+    m_search_->reset              = true;
     m_search_->matchedIndex       = USEARCH_DONE;
     m_search_->matchedLength      = 0;
     text.getText(m_text_);
diff --git a/deps/icu-small/source/i18n/selfmt.cpp b/deps/icu-small/source/i18n/selfmt.cpp
index bb18e84ef6..9928d284c9 100644
--- a/deps/icu-small/source/i18n/selfmt.cpp
+++ b/deps/icu-small/source/i18n/selfmt.cpp
@@ -129,7 +129,7 @@ int32_t SelectFormat::findSubMessage(const MessagePattern& pattern, int32_t part
     if (U_FAILURE(ec)) {
         return 0;
     }
-    UnicodeString other(FALSE, SELECT_KEYWORD_OTHER, 5);
+    UnicodeString other(false, SELECT_KEYWORD_OTHER, 5);
     int32_t count = pattern.countParts();
     int32_t msgStart=0;
     // Iterate over (ARG_SELECTOR, message) pairs until ARG_LIMIT or end of select-only pattern.
diff --git a/deps/icu-small/source/i18n/sharedbreakiterator.h b/deps/icu-small/source/i18n/sharedbreakiterator.h
index b6d67bc8e8..76e959fda3 100644
--- a/deps/icu-small/source/i18n/sharedbreakiterator.h
+++ b/deps/icu-small/source/i18n/sharedbreakiterator.h
@@ -38,8 +38,8 @@ public:
     BreakIterator &operator*() const { return *ptr; }
 private:
     BreakIterator *ptr;
-    SharedBreakIterator(const SharedBreakIterator &);
-    SharedBreakIterator &operator=(const SharedBreakIterator &);
+    SharedBreakIterator(const SharedBreakIterator &) = delete;
+    SharedBreakIterator &operator=(const SharedBreakIterator &) = delete;
 };
 
 U_NAMESPACE_END
diff --git a/deps/icu-small/source/i18n/sharedcalendar.h b/deps/icu-small/source/i18n/sharedcalendar.h
index 1526f92e88..60d1d5d487 100644
--- a/deps/icu-small/source/i18n/sharedcalendar.h
+++ b/deps/icu-small/source/i18n/sharedcalendar.h
@@ -13,6 +13,7 @@
 
 #include "unicode/utypes.h"
 #include "sharedobject.h"
+#include "unifiedcache.h"
 
 U_NAMESPACE_BEGIN
 
@@ -27,10 +28,15 @@ public:
     const Calendar &operator*() const { return *ptr; }
 private:
     Calendar *ptr;
-    SharedCalendar(const SharedCalendar &);
-    SharedCalendar &operator=(const SharedCalendar &);
+    SharedCalendar(const SharedCalendar &) = delete;
+    SharedCalendar &operator=(const SharedCalendar &) = delete;
 };
 
+template<> U_I18N_API
+const SharedCalendar *LocaleCacheKey<SharedCalendar>::createObject(
+        const void * /*unusedCreationContext*/, UErrorCode &status) const;
+
+
 U_NAMESPACE_END
 
 #endif
diff --git a/deps/icu-small/source/i18n/shareddateformatsymbols.h b/deps/icu-small/source/i18n/shareddateformatsymbols.h
index 66a06ecae5..b51fad98b0 100644
--- a/deps/icu-small/source/i18n/shareddateformatsymbols.h
+++ b/deps/icu-small/source/i18n/shareddateformatsymbols.h
@@ -17,6 +17,7 @@
 
 #include "sharedobject.h"
 #include "unicode/dtfmtsym.h"
+#include "unifiedcache.h"
 
 U_NAMESPACE_BEGIN
 
@@ -30,10 +31,15 @@ public:
     const DateFormatSymbols &get() const { return dfs; }
 private:
     DateFormatSymbols dfs;
-    SharedDateFormatSymbols(const SharedDateFormatSymbols &);
-    SharedDateFormatSymbols &operator=(const SharedDateFormatSymbols &);
+    SharedDateFormatSymbols(const SharedDateFormatSymbols &) = delete;
+    SharedDateFormatSymbols &operator=(const SharedDateFormatSymbols &) = delete;
 };
 
+template<> U_I18N_API
+const SharedDateFormatSymbols *
+        LocaleCacheKey<SharedDateFormatSymbols>::createObject(
+            const void * /*unusedContext*/, UErrorCode &status) const;
+
 U_NAMESPACE_END
 
 #endif /* !UCONFIG_NO_FORMATTING */
diff --git a/deps/icu-small/source/i18n/sharednumberformat.h b/deps/icu-small/source/i18n/sharednumberformat.h
index a7e105b5ac..bd914c0340 100644
--- a/deps/icu-small/source/i18n/sharednumberformat.h
+++ b/deps/icu-small/source/i18n/sharednumberformat.h
@@ -13,6 +13,7 @@
 
 #include "unicode/utypes.h"
 #include "sharedobject.h"
+#include "unifiedcache.h"
 
 U_NAMESPACE_BEGIN
 
@@ -27,10 +28,14 @@ public:
     const NumberFormat &operator*() const { return *ptr; }
 private:
     NumberFormat *ptr;
-    SharedNumberFormat(const SharedNumberFormat &);
-    SharedNumberFormat &operator=(const SharedNumberFormat &);
+    SharedNumberFormat(const SharedNumberFormat &) = delete;
+    SharedNumberFormat &operator=(const SharedNumberFormat &) = delete;
 };
 
+template<> U_I18N_API
+const SharedNumberFormat *LocaleCacheKey<SharedNumberFormat>::createObject(
+        const void * /*unused*/, UErrorCode &status) const;
+
 U_NAMESPACE_END
 
 #endif
diff --git a/deps/icu-small/source/i18n/sharedpluralrules.h b/deps/icu-small/source/i18n/sharedpluralrules.h
index 28d8b25c14..11c82c5619 100644
--- a/deps/icu-small/source/i18n/sharedpluralrules.h
+++ b/deps/icu-small/source/i18n/sharedpluralrules.h
@@ -13,6 +13,7 @@
 
 #include "unicode/utypes.h"
 #include "sharedobject.h"
+#include "unifiedcache.h"
 
 U_NAMESPACE_BEGIN
 
@@ -26,10 +27,14 @@ public:
     const PluralRules &operator*() const { return *ptr; }
 private:
     PluralRules *ptr;
-    SharedPluralRules(const SharedPluralRules &);
-    SharedPluralRules &operator=(const SharedPluralRules &);
+    SharedPluralRules(const SharedPluralRules &) = delete;
+    SharedPluralRules &operator=(const SharedPluralRules &) =delete;
 };
 
+template<> U_I18N_API
+const SharedPluralRules *LocaleCacheKey<SharedPluralRules>::createObject(
+        const void * /*unused*/, UErrorCode &status) const;
+
 U_NAMESPACE_END
 
 #endif
diff --git a/deps/icu-small/source/i18n/simpletz.cpp b/deps/icu-small/source/i18n/simpletz.cpp
index d9b0cd8e1e..77403e4807 100644
--- a/deps/icu-small/source/i18n/simpletz.cpp
+++ b/deps/icu-small/source/i18n/simpletz.cpp
@@ -76,7 +76,7 @@ SimpleTimeZone::SimpleTimeZone(int32_t rawOffsetGMT, const UnicodeString& ID)
     endTime(0),
     startYear(0),
     rawOffset(rawOffsetGMT),
-    useDaylight(FALSE),
+    useDaylight(false),
     startMode(DOM_MODE),
     endMode(DOM_MODE),
     dstSavings(U_MILLIS_PER_HOUR)
@@ -262,7 +262,7 @@ void
 SimpleTimeZone::setStartYear(int32_t year)
 {
     startYear = year;
-    transitionRulesInitialized = FALSE;
+    transitionRulesInitialized = false;
 }
 
 // -------------------------------------
@@ -316,7 +316,7 @@ SimpleTimeZone::setStartRule(int32_t month, int32_t dayOfWeekInMonth, int32_t da
     startTime      = time;
     startTimeMode  = mode;
     decodeStartRule(status);
-    transitionRulesInitialized = FALSE;
+    transitionRulesInitialized = false;
 }
 
 // -------------------------------------
@@ -368,7 +368,7 @@ SimpleTimeZone::setEndRule(int32_t month, int32_t dayOfWeekInMonth, int32_t dayO
     endTime      = time;
     endTimeMode  = mode;
     decodeEndRule(status);
-    transitionRulesInitialized = FALSE;
+    transitionRulesInitialized = false;
 }
 
 // -------------------------------------
@@ -518,9 +518,8 @@ SimpleTimeZone::getOffsetFromLocal(UDate date, UTimeZoneLocalOption nonExistingT
     }
 
     rawOffsetGMT = getRawOffset();
-    int32_t year, month, dom, dow;
-    double day = uprv_floor(date / U_MILLIS_PER_DAY);
-    int32_t millis = (int32_t) (date - day * U_MILLIS_PER_DAY);
+    int32_t year, month, dom, dow, millis;
+    int32_t day = ClockMath::floorDivide(date, U_MILLIS_PER_DAY, &millis);
 
     Grego::dayToFields(day, year, month, dom, dow);
 
@@ -532,25 +531,24 @@ SimpleTimeZone::getOffsetFromLocal(UDate date, UTimeZoneLocalOption nonExistingT
         return;
     }
 
-    UBool recalc = FALSE;
+    UBool recalc = false;
 
     // Now we need some adjustment
     if (savingsDST > 0) {
         if ((nonExistingTimeOpt & kStdDstMask) == kStandard
             || ((nonExistingTimeOpt & kStdDstMask) != kDaylight && (nonExistingTimeOpt & kFormerLatterMask) != kLatter)) {
             date -= getDSTSavings();
-            recalc = TRUE;
+            recalc = true;
         }
     } else {
         if ((duplicatedTimeOpt & kStdDstMask) == kDaylight
                 || ((duplicatedTimeOpt & kStdDstMask) != kStandard && (duplicatedTimeOpt & kFormerLatterMask) == kFormer)) {
             date -= getDSTSavings();
-            recalc = TRUE;
+            recalc = true;
         }
     }
     if (recalc) {
-        day = uprv_floor(date / U_MILLIS_PER_DAY);
-        millis = (int32_t) (date - day * U_MILLIS_PER_DAY);
+        day = ClockMath::floorDivide(date, U_MILLIS_PER_DAY, &millis);
         Grego::dayToFields(day, year, month, dom, dow);
         savingsDST = getOffset(GregorianCalendar::AD, year, month, dom,
                           (uint8_t) dow, millis,
@@ -681,7 +679,7 @@ void
 SimpleTimeZone::setRawOffset(int32_t offsetMillis)
 {
     rawOffset = offsetMillis;
-    transitionRulesInitialized = FALSE;
+    transitionRulesInitialized = false;
 }
 
 // -------------------------------------
@@ -695,7 +693,7 @@ SimpleTimeZone::setDSTSavings(int32_t millisSavedDuringDST, UErrorCode& status)
     else {
         dstSavings = millisSavedDuringDST;
     }
-    transitionRulesInitialized = FALSE;
+    transitionRulesInitialized = false;
 }
 
 // -------------------------------------
@@ -725,12 +723,12 @@ UBool SimpleTimeZone::inDaylightTime(UDate date, UErrorCode& status) const
     // This method is wasteful since it creates a new GregorianCalendar and
     // deletes it each time it is called.  However, this is a deprecated method
     // and provided only for Java compatibility as of 8/6/97 [LIU].
-    if (U_FAILURE(status)) return FALSE;
+    if (U_FAILURE(status)) return false;
     GregorianCalendar *gc = new GregorianCalendar(*this, status);
     /* test for NULL */
     if (gc == 0) {
         status = U_MEMORY_ALLOCATION_ERROR;
-        return FALSE;
+        return false;
     }
     gc->setTime(date, status);
     UBool result = gc->inDaylightTime(status);
@@ -748,8 +746,8 @@ UBool SimpleTimeZone::inDaylightTime(UDate date, UErrorCode& status) const
 UBool 
 SimpleTimeZone::hasSameRules(const TimeZone& other) const
 {
-    if (this == &other) return TRUE;
-    if (typeid(*this) != typeid(other)) return FALSE;
+    if (this == &other) return true;
+    if (typeid(*this) != typeid(other)) return false;
     SimpleTimeZone *that = (SimpleTimeZone*)&other;
     return rawOffset     == that->rawOffset &&
         useDaylight     == that->useDaylight &&
@@ -872,7 +870,7 @@ SimpleTimeZone::decodeStartRule(UErrorCode& status)
 {
     if(U_FAILURE(status)) return;
 
-    useDaylight = (UBool)((startDay != 0) && (endDay != 0) ? TRUE : FALSE);
+    useDaylight = (UBool)((startDay != 0) && (endDay != 0) ? true : false);
     if (useDaylight && dstSavings == 0) {
         dstSavings = U_MILLIS_PER_HOUR;
     }
@@ -927,7 +925,7 @@ SimpleTimeZone::decodeEndRule(UErrorCode& status)
 {
     if(U_FAILURE(status)) return;
 
-    useDaylight = (UBool)((startDay != 0) && (endDay != 0) ? TRUE : FALSE);
+    useDaylight = (UBool)((startDay != 0) && (endDay != 0) ? true : false);
     if (useDaylight && dstSavings == 0) {
         dstSavings = U_MILLIS_PER_HOUR;
     }
@@ -975,13 +973,13 @@ SimpleTimeZone::decodeEndRule(UErrorCode& status)
 UBool
 SimpleTimeZone::getNextTransition(UDate base, UBool inclusive, TimeZoneTransition& result) const {
     if (!useDaylight) {
-        return FALSE;
+        return false;
     }
 
     UErrorCode status = U_ZERO_ERROR;
     checkTransitionRules(status);
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
 
     UDate firstTransitionTime = firstTransition->getTime();
@@ -995,32 +993,32 @@ SimpleTimeZone::getNextTransition(UDate base, UBool inclusive, TimeZoneTransitio
         result.setTime(stdDate);
         result.setFrom((const TimeZoneRule&)*dstRule);
         result.setTo((const TimeZoneRule&)*stdRule);
-        return TRUE;
+        return true;
     }
     if (dstAvail && (!stdAvail || dstDate < stdDate)) {
         result.setTime(dstDate);
         result.setFrom((const TimeZoneRule&)*stdRule);
         result.setTo((const TimeZoneRule&)*dstRule);
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 UBool
 SimpleTimeZone::getPreviousTransition(UDate base, UBool inclusive, TimeZoneTransition& result) const {
     if (!useDaylight) {
-        return FALSE;
+        return false;
     }
 
     UErrorCode status = U_ZERO_ERROR;
     checkTransitionRules(status);
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
 
     UDate firstTransitionTime = firstTransition->getTime();
     if (base < firstTransitionTime || (!inclusive && base == firstTransitionTime)) {
-        return FALSE;
+        return false;
     }
     UDate stdDate, dstDate;
     UBool stdAvail = stdRule->getPreviousStart(base, dstRule->getRawOffset(), dstRule->getDSTSavings(), inclusive, stdDate);
@@ -1029,15 +1027,15 @@ SimpleTimeZone::getPreviousTransition(UDate base, UBool inclusive, TimeZoneTrans
         result.setTime(stdDate);
         result.setFrom((const TimeZoneRule&)*dstRule);
         result.setTo((const TimeZoneRule&)*stdRule);
-        return TRUE;
+        return true;
     }
     if (dstAvail && (!stdAvail || dstDate > stdDate)) {
         result.setTime(dstDate);
         result.setFrom((const TimeZoneRule&)*stdRule);
         result.setTo((const TimeZoneRule&)*dstRule);
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 void
@@ -1046,7 +1044,7 @@ SimpleTimeZone::clearTransitionRules(void) {
     firstTransition = NULL;
     stdRule = NULL;
     dstRule = NULL;
-    transitionRulesInitialized = FALSE;
+    transitionRulesInitialized = false;
 }
 
 void
@@ -1224,7 +1222,7 @@ SimpleTimeZone::initTransitionRules(UErrorCode& status) {
         }
     }
 
-    transitionRulesInitialized = TRUE;
+    transitionRulesInitialized = true;
 }
 
 int32_t
diff --git a/deps/icu-small/source/i18n/smpdtfmt.cpp b/deps/icu-small/source/i18n/smpdtfmt.cpp
index c1e943a094..72ba0c0bfc 100644
--- a/deps/icu-small/source/i18n/smpdtfmt.cpp
+++ b/deps/icu-small/source/i18n/smpdtfmt.cpp
@@ -161,8 +161,8 @@ static const int8_t kTimeFieldsCount = 10;
 // of a resource.
 static const UChar gDefaultPattern[] =
 {
-    0x79, 0x79, 0x79, 0x79, 0x4D, 0x4D, 0x64, 0x64, 0x20, 0x68, 0x68, 0x3A, 0x6D, 0x6D, 0x20, 0x61, 0
-};  /* "yyyyMMdd hh:mm a" */
+    0x79, 0x4D, 0x4D, 0x64, 0x64, 0x20, 0x68, 0x68, 0x3A, 0x6D, 0x6D, 0x20, 0x61, 0
+};  /* "yMMdd hh:mm a" */
 
 // This prefix is designed to NEVER MATCH real text, in order to
 // suppress the parsing of negative numbers.  Adjust as needed (if
@@ -263,12 +263,12 @@ void SimpleDateFormat::NSOverride::free() {
 // to modify it so that it doesn't use thousands separators, doesn't always
 // show the decimal point, and recognizes integers only when parsing
 static void fixNumberFormatForDates(NumberFormat &nf) {
-    nf.setGroupingUsed(FALSE);
+    nf.setGroupingUsed(false);
     DecimalFormat* decfmt = dynamic_cast<DecimalFormat*>(&nf);
     if (decfmt != NULL) {
-        decfmt->setDecimalSeparatorAlwaysShown(FALSE);
+        decfmt->setDecimalSeparatorAlwaysShown(false);
     }
-    nf.setParseIntegerOnly(TRUE);
+    nf.setParseIntegerOnly(true);
     nf.setMinimumFractionDigits(0); // To prevent "Jan 1.00, 1997.00"
 }
 
@@ -701,7 +701,7 @@ void SimpleDateFormat::construct(EStyle timeStyle,
     LocalUResourceBundlePointer bundle(ures_open(NULL, locale.getBaseName(), &status));
     if (U_FAILURE(status)) return;
 
-    UBool cTypeIsGregorian = TRUE;
+    UBool cTypeIsGregorian = true;
     LocalUResourceBundlePointer dateTimePatterns;
     if (cType != NULL && uprv_strcmp(cType, "gregorian") != 0) {
         CharString resourcePath("calendar/", status);
@@ -709,7 +709,7 @@ void SimpleDateFormat::construct(EStyle timeStyle,
         dateTimePatterns.adoptInstead(
             ures_getByKeyWithFallback(bundle.getAlias(), resourcePath.data(),
                                       (UResourceBundle*)NULL, &status));
-        cTypeIsGregorian = FALSE;
+        cTypeIsGregorian = false;
     }
 
     // Check for "gregorian" fallback.
@@ -776,7 +776,7 @@ void SimpleDateFormat::construct(EStyle timeStyle,
                     // region preferences anyway.
                     LocalPointer<DateTimePatternGenerator> dtpg(DateTimePatternGenerator::createInstanceNoStdPat(locale, useStatus));
                     if (U_SUCCESS(useStatus)) {
-                        UnicodeString timeSkeleton(TRUE, timeSkeletons[timeStyle], -1);
+                        UnicodeString timeSkeleton(true, timeSkeletons[timeStyle], -1);
                         timePattern = dtpg->getBestPattern(timeSkeleton, useStatus);
                     }
                 }
@@ -805,7 +805,7 @@ void SimpleDateFormat::construct(EStyle timeStyle,
                 case URES_ARRAY: {
                    resStr = ures_getStringByIndex(currentBundle.getAlias(), 0, &resStrLen, &status);
                    ovrStr = ures_getStringByIndex(currentBundle.getAlias(), 1, &ovrStrLen, &status);
-                   fTimeOverride.setTo(TRUE, ovrStr, ovrStrLen);
+                   fTimeOverride.setTo(true, ovrStr, ovrStrLen);
                    break;
                 }
                 default: {
@@ -814,7 +814,7 @@ void SimpleDateFormat::construct(EStyle timeStyle,
                 }
             }
 
-            tempus1.setTo(TRUE, resStr, resStrLen);
+            tempus1.setTo(true, resStr, resStrLen);
         }
 
         currentBundle.adoptInstead(
@@ -831,7 +831,7 @@ void SimpleDateFormat::construct(EStyle timeStyle,
             case URES_ARRAY: {
                resStr = ures_getStringByIndex(currentBundle.getAlias(), 0, &resStrLen, &status);
                ovrStr = ures_getStringByIndex(currentBundle.getAlias(), 1, &ovrStrLen, &status);
-               fDateOverride.setTo(TRUE, ovrStr, ovrStrLen);
+               fDateOverride.setTo(true, ovrStr, ovrStrLen);
                break;
             }
             default: {
@@ -840,17 +840,40 @@ void SimpleDateFormat::construct(EStyle timeStyle,
             }
         }
 
-        UnicodeString tempus2(TRUE, resStr, resStrLen);
+        UnicodeString tempus2(true, resStr, resStrLen);
 
-        int32_t glueIndex = kDateTime;
-        int32_t patternsSize = ures_getSize(dateTimePatterns.getAlias());
-        if (patternsSize >= (kDateTimeOffset + kShort + 1)) {
-            // Get proper date time format
-            glueIndex = (int32_t)(kDateTimeOffset + (dateStyle - kDateOffset));
+        // Currently, for compatibility with pre-CLDR-42 data, we default to the "atTime"
+        // combining patterns. Depending on guidance in CLDR 42 spec and on DisplayOptions,
+        // we may change this.
+        LocalUResourceBundlePointer dateAtTimePatterns;
+        if (!cTypeIsGregorian) {
+            CharString resourcePath("calendar/", status);
+            resourcePath.append(cType, status).append("/DateTimePatterns%atTime", status);
+            dateAtTimePatterns.adoptInstead(
+                ures_getByKeyWithFallback(bundle.getAlias(), resourcePath.data(),
+                                          nullptr, &status));
         }
+        if (cTypeIsGregorian || status == U_MISSING_RESOURCE_ERROR) {
+            status = U_ZERO_ERROR;
+            dateAtTimePatterns.adoptInstead(
+                ures_getByKeyWithFallback(bundle.getAlias(),
+                                          "calendar/gregorian/DateTimePatterns%atTime",
+                                          nullptr, &status));
+        }
+        if (U_SUCCESS(status) && ures_getSize(dateAtTimePatterns.getAlias()) >= 4) {
+            resStr = ures_getStringByIndex(dateAtTimePatterns.getAlias(), dateStyle - kDateOffset, &resStrLen, &status);
+        } else {
+            status = U_ZERO_ERROR;
+            int32_t glueIndex = kDateTime;
+            int32_t patternsSize = ures_getSize(dateTimePatterns.getAlias());
+            if (patternsSize >= (kDateTimeOffset + kShort + 1)) {
+                // Get proper date time format
+                glueIndex = (int32_t)(kDateTimeOffset + (dateStyle - kDateOffset));
+            }
 
-        resStr = ures_getStringByIndex(dateTimePatterns.getAlias(), glueIndex, &resStrLen, &status);
-        SimpleFormatter(UnicodeString(TRUE, resStr, resStrLen), 2, 2, status).
+            resStr = ures_getStringByIndex(dateTimePatterns.getAlias(), glueIndex, &resStrLen, &status);
+        }
+        SimpleFormatter(UnicodeString(true, resStr, resStrLen), 2, 2, status).
                 format(tempus1, tempus2, fPattern, status);
     }
     // if the pattern includes just time data or just date date, load the appropriate
@@ -873,7 +896,7 @@ void SimpleDateFormat::construct(EStyle timeStyle,
                 case URES_ARRAY: {
                    resStr = ures_getStringByIndex(currentBundle.getAlias(), 0, &resStrLen, &status);
                    ovrStr = ures_getStringByIndex(currentBundle.getAlias(), 1, &ovrStrLen, &status);
-                   fDateOverride.setTo(TRUE, ovrStr, ovrStrLen);
+                   fDateOverride.setTo(true, ovrStr, ovrStrLen);
                    break;
                 }
                 default: {
@@ -881,7 +904,7 @@ void SimpleDateFormat::construct(EStyle timeStyle,
                    return;
                 }
             }
-            fPattern.setTo(TRUE, resStr, resStrLen);
+            fPattern.setTo(true, resStr, resStrLen);
         }
     }
     else if (dateStyle != kNone) {
@@ -899,7 +922,7 @@ void SimpleDateFormat::construct(EStyle timeStyle,
             case URES_ARRAY: {
                resStr = ures_getStringByIndex(currentBundle.getAlias(), 0, &resStrLen, &status);
                ovrStr = ures_getStringByIndex(currentBundle.getAlias(), 1, &ovrStrLen, &status);
-               fDateOverride.setTo(TRUE, ovrStr, ovrStrLen);
+               fDateOverride.setTo(true, ovrStr, ovrStrLen);
                break;
             }
             default: {
@@ -907,7 +930,7 @@ void SimpleDateFormat::construct(EStyle timeStyle,
                return;
             }
         }
-        fPattern.setTo(TRUE, resStr, resStrLen);
+        fPattern.setTo(true, resStr, resStrLen);
     }
 
     // and if it includes _neither_, that's an error
@@ -953,7 +976,7 @@ SimpleDateFormat::initialize(const Locale& locale,
     if (fNumberFormat != NULL && U_SUCCESS(status))
     {
         fixNumberFormatForDates(*fNumberFormat);
-        //fNumberFormat->setLenient(TRUE); // Java uses a custom DateNumberFormat to format/parse
+        //fNumberFormat->setLenient(true); // Java uses a custom DateNumberFormat to format/parse
 
         initNumberFormatters(locale, status);
         initFastNumberFormatters(status);
@@ -1010,7 +1033,7 @@ void SimpleDateFormat::parseAmbiguousDatesAsAfter(UDate startDate, UErrorCode& s
 
     fCalendar->setTime(startDate, status);
     if(U_SUCCESS(status)) {
-        fHaveDefaultCentury = TRUE;
+        fHaveDefaultCentury = true;
         fDefaultCenturyStart = startDate;
         fDefaultCenturyStartYear = fCalendar->get(UCAL_YEAR, status);
     }
@@ -1063,7 +1086,7 @@ SimpleDateFormat::_format(Calendar& cal, UnicodeString& appendTo,
         }
     }
 
-    UBool inQuote = FALSE;
+    UBool inQuote = false;
     UChar prevCh = 0;
     int32_t count = 0;
     int32_t fieldNum = 0;
@@ -1169,45 +1192,45 @@ int32_t SimpleDateFormat::getLevelFromChar(UChar ch) {
 UBool SimpleDateFormat::isSyntaxChar(UChar ch) {
     static const UBool mapCharToIsSyntax[] = {
         //
-        FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
+        false, false, false, false, false, false, false, false,
         //
-        FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
+        false, false, false, false, false, false, false, false,
         //
-        FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
+        false, false, false, false, false, false, false, false,
         //
-        FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
+        false, false, false, false, false, false, false, false,
         //         !      "      #      $      %      &      '
-        FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
+        false, false, false, false, false, false, false, false,
         //  (      )      *      +      ,      -      .      /
-        FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
+        false, false, false, false, false, false, false, false,
         //  0      1      2      3      4      5      6      7
-        FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
+        false, false, false, false, false, false, false, false,
 #if UDAT_HAS_PATTERN_CHAR_FOR_TIME_SEPARATOR
         //  8      9      :      ;      <      =      >      ?
-        FALSE, FALSE,  TRUE, FALSE, FALSE, FALSE, FALSE, FALSE,
+        false, false,  true, false, false, false, false, false,
 #else
         //  8      9      :      ;      <      =      >      ?
-        FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
+        false, false, false, false, false, false, false, false,
 #endif
         //  @      A      B      C      D      E      F      G
-        FALSE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,
+        false,  true,  true,  true,  true,  true,  true,  true,
         //  H      I      J      K      L      M      N      O
-         TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,
+         true,  true,  true,  true,  true,  true,  true,  true,
         //  P      Q      R      S      T      U      V      W
-         TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,
+         true,  true,  true,  true,  true,  true,  true,  true,
         //  X      Y      Z      [      \      ]      ^      _
-         TRUE,  TRUE,  TRUE, FALSE, FALSE, FALSE, FALSE, FALSE,
+         true,  true,  true, false, false, false, false, false,
         //  `      a      b      c      d      e      f      g
-        FALSE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,
+        false,  true,  true,  true,  true,  true,  true,  true,
         //  h      i      j      k      l      m      n      o
-         TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,
+         true,  true,  true,  true,  true,  true,  true,  true,
         //  p      q      r      s      t      u      v      w
-         TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,
+         true,  true,  true,  true,  true,  true,  true,  true,
         //  x      y      z      {      |      }      ~
-         TRUE,  TRUE,  TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
+         true,  true,  true, false, false, false, false, false
     };
 
-    return ch < UPRV_LENGTHOF(mapCharToIsSyntax) ? mapCharToIsSyntax[ch] : FALSE;
+    return ch < UPRV_LENGTHOF(mapCharToIsSyntax) ? mapCharToIsSyntax[ch] : false;
 }
 
 // Map index into pattern character string to Calendar field number.
@@ -1376,13 +1399,13 @@ SimpleDateFormat::processOverrideString(const Locale &locale, const UnicodeStrin
     int32_t len;
     UnicodeString nsName;
     UnicodeString ovrField;
-    UBool moreToProcess = TRUE;
+    UBool moreToProcess = true;
     NSOverride *overrideList = NULL;
 
     while (moreToProcess) {
         int32_t delimiterPosition = str.indexOf((UChar)ULOC_KEYWORD_ITEM_SEPARATOR_UNICODE,start);
         if (delimiterPosition == -1) {
-            moreToProcess = FALSE;
+            moreToProcess = false;
             len = str.length() - start;
         } else {
             len = delimiterPosition - start;
@@ -1401,11 +1424,11 @@ SimpleDateFormat::processOverrideString(const Locale &locale, const UnicodeStrin
         // See if the numbering system is in the override list, if not, then add it.
         NSOverride *curr = overrideList;
         const SharedNumberFormat *snf = NULL;
-        UBool found = FALSE;
+        UBool found = false;
         while ( curr && !found ) {
             if ( curr->hash == nsNameHash ) {
                 snf = curr->snf;
-                found = TRUE;
+                found = true;
             }
             curr = curr->next;
         }
@@ -2062,10 +2085,10 @@ SimpleDateFormat::subFormat(UnicodeString &appendTo,
     // if first field, check to see whether we need to and are able to titlecase it
     if (fieldNum == 0 && fCapitalizationBrkIter != NULL && appendTo.length() > beginOffset &&
             u_islower(appendTo.char32At(beginOffset))) {
-        UBool titlecase = FALSE;
+        UBool titlecase = false;
         switch (capitalizationContext) {
             case UDISPCTX_CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE:
-                titlecase = TRUE;
+                titlecase = true;
                 break;
             case UDISPCTX_CAPITALIZATION_FOR_UI_LIST_OR_MENU:
                 titlecase = fSymbols->fCapitalization[capContextUsageType][0];
@@ -2074,7 +2097,7 @@ SimpleDateFormat::subFormat(UnicodeString &appendTo,
                 titlecase = fSymbols->fCapitalization[capContextUsageType][1];
                 break;
             default:
-                // titlecase = FALSE;
+                // titlecase = false;
                 break;
         }
         if (titlecase) {
@@ -2228,13 +2251,13 @@ UBool
 SimpleDateFormat::isAtNumericField(const UnicodeString &pattern, int32_t patternOffset) {
     if (patternOffset >= pattern.length()) {
         // not at any field
-        return FALSE;
+        return false;
     }
     UChar ch = pattern.charAt(patternOffset);
     UDateFormatField f = DateFormatSymbols::getPatternCharIndex(ch);
     if (f == UDAT_FIELD_COUNT) {
         // not at any field
-        return FALSE;
+        return false;
     }
     int32_t i = patternOffset;
     while (pattern.charAt(++i) == ch) {}
@@ -2245,13 +2268,13 @@ UBool
 SimpleDateFormat::isAfterNonNumericField(const UnicodeString &pattern, int32_t patternOffset) {
     if (patternOffset <= 0) {
         // not after any field
-        return FALSE;
+        return false;
     }
     UChar ch = pattern.charAt(--patternOffset);
     UDateFormatField f = DateFormatSymbols::getPatternCharIndex(ch);
     if (f == UDAT_FIELD_COUNT) {
         // not after any field
-        return FALSE;
+        return false;
     }
     int32_t i = patternOffset;
     while (pattern.charAt(--i) == ch) {}
@@ -2273,7 +2296,7 @@ SimpleDateFormat::parse(const UnicodeString& text, Calendar& cal, ParsePosition&
     // the hour to interpret time correctly.
     int32_t dayPeriodInt = -1;
 
-    UBool ambiguousYear[] = { FALSE };
+    UBool ambiguousYear[] = { false };
     int32_t saveHebrewMonth = -1;
     int32_t count = 0;
     UTimeZoneFormatTimeType tzTimeType = UTZFMT_TIME_TYPE_UNKNOWN;
@@ -2286,7 +2309,7 @@ SimpleDateFormat::parse(const UnicodeString& text, Calendar& cal, ParsePosition&
     int32_t abutPat = -1; // If >=0, we are in a run of abutting numeric fields
     int32_t abutStart = 0;
     int32_t abutPass = 0;
-    UBool inQuote = FALSE;
+    UBool inQuote = false;
 
     MessageFormat * numericLeapMonthFormatter = NULL;
 
@@ -2370,7 +2393,7 @@ SimpleDateFormat::parse(const UnicodeString& text, Calendar& cal, ParsePosition&
                 }
 
                 pos = subParse(text, pos, ch, count,
-                               TRUE, FALSE, ambiguousYear, saveHebrewMonth, *workCal, i, numericLeapMonthFormatter, &tzTimeType);
+                               true, false, ambiguousYear, saveHebrewMonth, *workCal, i, numericLeapMonthFormatter, &tzTimeType);
 
                 // If the parse fails anywhere in the run, back up to the
                 // start of the run and retry.
@@ -2385,7 +2408,7 @@ SimpleDateFormat::parse(const UnicodeString& text, Calendar& cal, ParsePosition&
             // fields.
             else if (ch != 0x6C) { // pattern char 'l' (SMALL LETTER L) just gets ignored
                 int32_t s = subParse(text, pos, ch, count,
-                               FALSE, TRUE, ambiguousYear, saveHebrewMonth, *workCal, i, numericLeapMonthFormatter, &tzTimeType, &dayPeriodInt);
+                               false, true, ambiguousYear, saveHebrewMonth, *workCal, i, numericLeapMonthFormatter, &tzTimeType, &dayPeriodInt);
 
                 if (s == -pos-1) {
                     // era not present, in special cases allow this to continue
@@ -2594,7 +2617,7 @@ SimpleDateFormat::parse(const UnicodeString& text, Calendar& cal, ParsePosition&
             } else {
                 // No good way to resolve ambiguous time at transition,
                 // but following code work in most case.
-                tz.getOffset(localMillis, TRUE, raw, dst, status);
+                tz.getOffset(localMillis, true, raw, dst, status);
             }
 
             // Now, compare the results with parsed type, either standard or daylight saving time
@@ -2617,7 +2640,7 @@ SimpleDateFormat::parse(const UnicodeString& text, Calendar& cal, ParsePosition&
 
                         // Search for DST rule after the given time
                         while (time < limit) {
-                            trsAvail = btz->getNextTransition(time, FALSE, trs);
+                            trsAvail = btz->getNextTransition(time, false, trs);
                             if (!trsAvail) {
                                 break;
                             }
@@ -2634,7 +2657,7 @@ SimpleDateFormat::parse(const UnicodeString& text, Calendar& cal, ParsePosition&
                             time = baseTime;
                             limit = baseTime - MAX_DAYLIGHT_DETECTION_RANGE;
                             while (time > limit) {
-                                trsAvail = btz->getPreviousTransition(time, TRUE, trs);
+                                trsAvail = btz->getPreviousTransition(time, true, trs);
                                 if (!trsAvail) {
                                     break;
                                 }
@@ -2759,7 +2782,7 @@ UBool SimpleDateFormat::matchLiterals(const UnicodeString &pattern,
                                       UBool partialMatchLenient,
                                       UBool oldLeniency)
 {
-    UBool inQuote = FALSE;
+    UBool inQuote = false;
     UnicodeString literal;
     int32_t i = patternOffset;
 
@@ -2801,10 +2824,10 @@ UBool SimpleDateFormat::matchLiterals(const UnicodeString &pattern,
     }
 
     for (p = 0; p < literal.length() && t < text.length();) {
-        UBool needWhitespace = FALSE;
+        UBool needWhitespace = false;
 
         while (p < literal.length() && PatternProps::isWhiteSpace(literal.charAt(p))) {
-            needWhitespace = TRUE;
+            needWhitespace = true;
             p += 1;
         }
 
@@ -2827,7 +2850,7 @@ UBool SimpleDateFormat::matchLiterals(const UnicodeString &pattern,
             if (!whitespaceLenient && t == tStart) {
                 // didn't find matching whitespace:
                 // an error in strict mode
-                return FALSE;
+                return false;
             }
 
             // In strict mode, this run of whitespace
@@ -2861,7 +2884,7 @@ UBool SimpleDateFormat::matchLiterals(const UnicodeString &pattern,
                 break;
             }
 
-            return FALSE;
+            return false;
         }
         ++p;
         ++t;
@@ -2892,7 +2915,50 @@ UBool SimpleDateFormat::matchLiterals(const UnicodeString &pattern,
     patternOffset = i - 1;
     textOffset = t;
 
-    return TRUE;
+    return true;
+}
+
+//----------------------------------------------------------------------
+// check both wide and abbrev months.
+// Does not currently handle monthPattern.
+// UCalendarDateFields field = UCAL_MONTH
+
+int32_t SimpleDateFormat::matchAlphaMonthStrings(const UnicodeString& text,
+                              int32_t start,
+                              const UnicodeString* wideData,
+                              const UnicodeString* shortData,
+                              int32_t dataCount,
+                              Calendar& cal) const
+{
+    int32_t i;
+    int32_t bestMatchLength = 0, bestMatch = -1;
+
+    for (i = 0; i < dataCount; ++i) {
+        int32_t matchLen = 0;
+        if ((matchLen = matchStringWithOptionalDot(text, start, wideData[i])) > bestMatchLength) {
+            bestMatch = i;
+            bestMatchLength = matchLen;
+        }
+    }
+    for (i = 0; i < dataCount; ++i) {
+        int32_t matchLen = 0;
+        if ((matchLen = matchStringWithOptionalDot(text, start, shortData[i])) > bestMatchLength) {
+            bestMatch = i;
+            bestMatchLength = matchLen;
+        }
+    }
+
+    if (bestMatch >= 0) { 
+        // Adjustment for Hebrew Calendar month Adar II
+        if (!strcmp(cal.getType(),"hebrew") && bestMatch==13) {
+            cal.set(UCAL_MONTH,6);
+        } else {
+            cal.set(UCAL_MONTH, bestMatch);
+        }
+        return start + bestMatchLength;
+    }
+
+    return -start;
 }
 
 //----------------------------------------------------------------------
@@ -2914,6 +2980,8 @@ int32_t SimpleDateFormat::matchString(const UnicodeString& text,
     // the same prefix (e.g., Cerven and Cervenec (June and July) in Czech).
     // We keep track of the longest match, and return that.  Note that this
     // unfortunately requires us to test all array elements.
+    // But this does not really work for cases such as Chuvash in which
+    // May is "ҫу" and August is "ҫурла"/"ҫур.", hence matchAlphaMonthStrings.
     int32_t bestMatchLength = 0, bestMatch = -1;
     UnicodeString bestMatchName;
     int32_t isLeapMonth = 0;
@@ -3011,7 +3079,7 @@ int32_t SimpleDateFormat::subParse(const UnicodeString& text, int32_t& start, UC
     UDateFormatField patternCharIndex = DateFormatSymbols::getPatternCharIndex(ch);
     const NumberFormat *currentNumberFormat;
     UnicodeString temp;
-    UBool gotNumber = FALSE;
+    UBool gotNumber = false;
 
 #if defined (U_DEBUG_CAL)
     //fprintf(stderr, "%s:%d - [%c]  st=%d \n", __FILE__, __LINE__, (char) ch, start);
@@ -3072,12 +3140,12 @@ int32_t SimpleDateFormat::subParse(const UnicodeString& text, int32_t& start, UC
         // but that's going to be difficult.
         const UnicodeString* src;
 
-        UBool parsedNumericLeapMonth = FALSE;
+        UBool parsedNumericLeapMonth = false;
         if (numericLeapMonthFormatter != NULL && (patternCharIndex == UDAT_MONTH_FIELD || patternCharIndex == UDAT_STANDALONE_MONTH_FIELD)) {
             int32_t argCount;
             Formattable * args = numericLeapMonthFormatter->parse(text, pos, argCount);
             if (args != NULL && argCount == 1 && pos.getIndex() > parseStart && args[0].isNumeric()) {
-                parsedNumericLeapMonth = TRUE;
+                parsedNumericLeapMonth = true;
                 number.setLong(args[0].getLong());
                 cal.set(UCAL_IS_LEAP_MONTH, 1);
                 delete[] args;
@@ -3106,17 +3174,17 @@ int32_t SimpleDateFormat::subParse(const UnicodeString& text, int32_t& start, UC
 
         if (txtLoc > parseStart) {
             value = number.getLong();
-            gotNumber = TRUE;
+            gotNumber = true;
 
             // suffix processing
             if (value < 0 ) {
-                txtLoc = checkIntSuffix(text, txtLoc, patLoc+1, TRUE);
+                txtLoc = checkIntSuffix(text, txtLoc, patLoc+1, true);
                 if (txtLoc != pos.getIndex()) {
                     value *= -1;
                 }
             }
             else {
-                txtLoc = checkIntSuffix(text, txtLoc, patLoc+1, FALSE);
+                txtLoc = checkIntSuffix(text, txtLoc, patLoc+1, false);
             }
 
             if (!getBooleanAttribute(UDAT_PARSE_ALLOW_WHITESPACE, status)) {
@@ -3304,6 +3372,14 @@ int32_t SimpleDateFormat::subParse(const UnicodeString& text, int32_t& start, UC
             }
             int32_t newStart = 0;
             if (patternCharIndex==UDAT_MONTH_FIELD) {
+                if(getBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, status) && count>=3 && count <=4 &&
+                        fSymbols->fLeapMonthPatterns==nullptr && fSymbols->fMonthsCount==fSymbols->fShortMonthsCount) {
+                    // single function to check both wide and short, an experiment
+                    newStart = matchAlphaMonthStrings(text, start, fSymbols->fMonths, fSymbols->fShortMonths, fSymbols->fMonthsCount, cal); // try MMMM,MMM
+                    if (newStart > 0) {
+                        return newStart;
+                    }
+                }
                 if(getBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, status) || count == 4) {
                     newStart = matchString(text, start, UCAL_MONTH, fSymbols->fMonths, fSymbols->fMonthsCount, wideMonthPat, cal); // try MMMM
                     if (newStart > 0) {
@@ -3314,6 +3390,14 @@ int32_t SimpleDateFormat::subParse(const UnicodeString& text, int32_t& start, UC
                     newStart = matchString(text, start, UCAL_MONTH, fSymbols->fShortMonths, fSymbols->fShortMonthsCount, shortMonthPat, cal); // try MMM
                 }
             } else {
+                if(getBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, status) && count>=3 && count <=4 &&
+                        fSymbols->fLeapMonthPatterns==nullptr && fSymbols->fStandaloneMonthsCount==fSymbols->fStandaloneShortMonthsCount) {
+                    // single function to check both wide and short, an experiment
+                    newStart = matchAlphaMonthStrings(text, start, fSymbols->fStandaloneMonths, fSymbols->fStandaloneShortMonths, fSymbols->fStandaloneMonthsCount, cal); // try MMMM,MMM
+                    if (newStart > 0) {
+                        return newStart;
+                    }
+                }
                 if(getBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, status) || count == 4) {
                     newStart = matchString(text, start, UCAL_MONTH, fSymbols->fStandaloneMonths, fSymbols->fStandaloneMonthsCount, wideMonthPat, cal); // try LLLL
                     if (newStart > 0) {
@@ -3884,7 +3968,7 @@ void SimpleDateFormat::parseInt(const UnicodeString& text,
             // Memory allocation error
             return;
         }
-        df->setNegativePrefix(UnicodeString(TRUE, SUPPRESS_NEGATIVE_PREFIX, -1));
+        df->setNegativePrefix(UnicodeString(true, SUPPRESS_NEGATIVE_PREFIX, -1));
         fmt = df.getAlias();
     }
     int32_t oldPos = pos.getIndex();
@@ -3939,16 +4023,16 @@ void SimpleDateFormat::translatePattern(const UnicodeString& originalPattern,
     }
 
     translatedPattern.remove();
-    UBool inQuote = FALSE;
+    UBool inQuote = false;
     for (int32_t i = 0; i < originalPattern.length(); ++i) {
         UChar c = originalPattern[i];
         if (inQuote) {
             if (c == QUOTE) {
-                inQuote = FALSE;
+                inQuote = false;
             }
         } else {
             if (c == QUOTE) {
-                inQuote = TRUE;
+                inQuote = true;
             } else if (isSyntaxChar(c)) {
                 int32_t ci = from.indexOf(c);
                 if (ci == -1) {
@@ -4157,7 +4241,7 @@ SimpleDateFormat::isFieldUnitIgnored(const UnicodeString& pattern,
     int32_t fieldLevel = fgCalendarFieldToLevel[field];
     int32_t level;
     UChar ch;
-    UBool inQuote = FALSE;
+    UBool inQuote = false;
     UChar prevCh = 0;
     int32_t count = 0;
 
@@ -4167,7 +4251,7 @@ SimpleDateFormat::isFieldUnitIgnored(const UnicodeString& pattern,
             level = getLevelFromChar(prevCh);
             // the larger the level, the smaller the field unit.
             if (fieldLevel <= level) {
-                return FALSE;
+                return false;
             }
             count = 0;
         }
@@ -4187,10 +4271,10 @@ SimpleDateFormat::isFieldUnitIgnored(const UnicodeString& pattern,
         // last item
         level = getLevelFromChar(prevCh);
         if (fieldLevel <= level) {
-            return FALSE;
+            return false;
         }
     }
-    return TRUE;
+    return true;
 }
 
 //----------------------------------------------------------------------
@@ -4274,10 +4358,10 @@ SimpleDateFormat::compareSimpleAffix(const UnicodeString& affix,
             // U+0020 is UWhiteSpace.  So we have to first do a direct
             // match of the run of Pattern_White_Space in the pattern,
             // then match any extra characters.
-            UBool literalMatch = FALSE;
+            UBool literalMatch = false;
             while (pos < input.length() &&
                    input.char32At(pos) == c) {
-                literalMatch = TRUE;
+                literalMatch = true;
                 i += len;
                 pos += len;
                 if (i == affix.length()) {
@@ -4355,26 +4439,26 @@ SimpleDateFormat::tzFormat(UErrorCode &status) const {
 }
 
 void SimpleDateFormat::parsePattern() {
-    fHasMinute = FALSE;
-    fHasSecond = FALSE;
-    fHasHanYearChar = FALSE;
+    fHasMinute = false;
+    fHasSecond = false;
+    fHasHanYearChar = false;
 
     int len = fPattern.length();
-    UBool inQuote = FALSE;
+    UBool inQuote = false;
     for (int32_t i = 0; i < len; ++i) {
         UChar ch = fPattern[i];
         if (ch == QUOTE) {
             inQuote = !inQuote;
         }
         if (ch == 0x5E74) { // don't care whether this is inside quotes
-            fHasHanYearChar = TRUE;
+            fHasHanYearChar = true;
         }
         if (!inQuote) {
             if (ch == 0x6D) {  // 0x6D == 'm'
-                fHasMinute = TRUE;
+                fHasMinute = true;
             }
             if (ch == 0x73) {  // 0x73 == 's'
-                fHasSecond = TRUE;
+                fHasSecond = true;
             }
         }
     }
diff --git a/deps/icu-small/source/i18n/smpdtfst.cpp b/deps/icu-small/source/i18n/smpdtfst.cpp
index db59a4b4ab..bbf6e9eddf 100644
--- a/deps/icu-small/source/i18n/smpdtfst.cpp
+++ b/deps/icu-small/source/i18n/smpdtfst.cpp
@@ -30,7 +30,7 @@
 U_NAMESPACE_BEGIN
 
 SimpleDateFormatStaticSets *gStaticSets = NULL;
-UInitOnce gSimpleDateFormatStaticSetsInitOnce = U_INITONCE_INITIALIZER;
+UInitOnce gSimpleDateFormatStaticSetsInitOnce {};
 
 SimpleDateFormatStaticSets::SimpleDateFormatStaticSets(UErrorCode &status)
 : fDateIgnorables(NULL),
@@ -81,7 +81,7 @@ SimpleDateFormatStaticSets::cleanup(void)
     delete gStaticSets;
     gStaticSets = NULL;
     gSimpleDateFormatStaticSetsInitOnce.reset();
-    return TRUE;
+    return true;
 }
 
 U_CDECL_BEGIN
diff --git a/deps/icu-small/source/i18n/string_segment.cpp b/deps/icu-small/source/i18n/string_segment.cpp
index 5d19ac57f5..2ddb738f4d 100644
--- a/deps/icu-small/source/i18n/string_segment.cpp
+++ b/deps/icu-small/source/i18n/string_segment.cpp
@@ -64,7 +64,7 @@ UnicodeString StringSegment::toUnicodeString() const {
 
 const UnicodeString StringSegment::toTempUnicodeString() const {
     // Use the readonly-aliasing constructor for efficiency.
-    return UnicodeString(FALSE, fStr.getBuffer() + fStart, fEnd - fStart);
+    return UnicodeString(false, fStr.getBuffer() + fStart, fEnd - fStart);
 }
 
 UChar32 StringSegment::getCodePoint() const {
@@ -131,8 +131,8 @@ bool StringSegment::codePointsEqual(UChar32 cp1, UChar32 cp2, bool foldCase) {
     if (!foldCase) {
         return false;
     }
-    cp1 = u_foldCase(cp1, TRUE);
-    cp2 = u_foldCase(cp2, TRUE);
+    cp1 = u_foldCase(cp1, true);
+    cp2 = u_foldCase(cp2, true);
     return cp1 == cp2;
 }
 
diff --git a/deps/icu-small/source/i18n/strmatch.cpp b/deps/icu-small/source/i18n/strmatch.cpp
index a20f7873fe..93febc708d 100644
--- a/deps/icu-small/source/i18n/strmatch.cpp
+++ b/deps/icu-small/source/i18n/strmatch.cpp
@@ -131,7 +131,7 @@ UMatchDegree StringMatcher::matches(const Replaceable& text,
             UnicodeMatcher* subm = data->lookupMatcher(keyChar);
             if (subm == 0) {
                 // Don't need the cursor < limit check if
-                // incremental is TRUE (because it's done above); do need
+                // incremental is true (because it's done above); do need
                 // it otherwise.
                 if (cursor < limit &&
                     keyChar == text.charAt(cursor)) {
@@ -171,10 +171,10 @@ UnicodeString& StringMatcher::toPattern(UnicodeString& result,
         UChar keyChar = pattern.charAt(i);
         const UnicodeMatcher* m = data->lookupMatcher(keyChar);
         if (m == 0) {
-            ICU_Utility::appendToRule(result, keyChar, FALSE, escapeUnprintable, quoteBuf);
+            ICU_Utility::appendToRule(result, keyChar, false, escapeUnprintable, quoteBuf);
         } else {
             ICU_Utility::appendToRule(result, m->toPattern(str, escapeUnprintable),
-                         TRUE, escapeUnprintable, quoteBuf);
+                         true, escapeUnprintable, quoteBuf);
         }
     }
     if (segmentNumber > 0) {
@@ -182,7 +182,7 @@ UnicodeString& StringMatcher::toPattern(UnicodeString& result,
     }
     // Flush quoteBuf out to result
     ICU_Utility::appendToRule(result, -1,
-                              TRUE, escapeUnprintable, quoteBuf);
+                              true, escapeUnprintable, quoteBuf);
     return result;
 }
 
@@ -191,7 +191,7 @@ UnicodeString& StringMatcher::toPattern(UnicodeString& result,
  */
 UBool StringMatcher::matchesIndexValue(uint8_t v) const {
     if (pattern.length() == 0) {
-        return TRUE;
+        return true;
     }
     UChar32 c = pattern.char32At(0);
     const UnicodeMatcher *m = data->lookupMatcher(c);
diff --git a/deps/icu-small/source/i18n/strrepl.cpp b/deps/icu-small/source/i18n/strrepl.cpp
index 9fafeb2659..23dab55430 100644
--- a/deps/icu-small/source/i18n/strrepl.cpp
+++ b/deps/icu-small/source/i18n/strrepl.cpp
@@ -41,9 +41,9 @@ StringReplacer::StringReplacer(const UnicodeString& theOutput,
                                const TransliterationRuleData* theData) {
     output = theOutput;
     cursorPos = theCursorPos;
-    hasCursor = TRUE;
+    hasCursor = true;
     data = theData;
-    isComplex = TRUE;
+    isComplex = true;
 }
 
 /**
@@ -59,9 +59,9 @@ StringReplacer::StringReplacer(const UnicodeString& theOutput,
                                const TransliterationRuleData* theData) {
     output = theOutput;
     cursorPos = 0;
-    hasCursor = FALSE;
+    hasCursor = false;
     data = theData;
-    isComplex = TRUE;
+    isComplex = true;
 }
 
 /**
@@ -131,7 +131,7 @@ int32_t StringReplacer::replace(Replaceable& text,
          */
         UnicodeString buf;
         int32_t oOutput; // offset into 'output'
-        isComplex = FALSE;
+        isComplex = false;
 
         // The temporary buffer starts at tempStart, and extends
         // to destLimit.  The start of the buffer has a single
@@ -166,7 +166,7 @@ int32_t StringReplacer::replace(Replaceable& text,
                 // Accumulate straight (non-segment) text.
                 buf.append(c);
             } else {
-                isComplex = TRUE;
+                isComplex = true;
 
                 // Insert any accumulated straight text.
                 if (buf.length() > 0) {
@@ -249,27 +249,27 @@ UnicodeString& StringReplacer::toReplacerPattern(UnicodeString& rule,
     // Handle a cursor preceding the output
     if (hasCursor && cursor < 0) {
         while (cursor++ < 0) {
-            ICU_Utility::appendToRule(rule, (UChar)0x0040 /*@*/, TRUE, escapeUnprintable, quoteBuf);
+            ICU_Utility::appendToRule(rule, (UChar)0x0040 /*@*/, true, escapeUnprintable, quoteBuf);
         }
         // Fall through and append '|' below
     }
 
     for (int32_t i=0; i<output.length(); ++i) {
         if (hasCursor && i == cursor) {
-            ICU_Utility::appendToRule(rule, (UChar)0x007C /*|*/, TRUE, escapeUnprintable, quoteBuf);
+            ICU_Utility::appendToRule(rule, (UChar)0x007C /*|*/, true, escapeUnprintable, quoteBuf);
         }
         UChar c = output.charAt(i); // Ok to use 16-bits here
 
         UnicodeReplacer* r = data->lookupReplacer(c);
         if (r == NULL) {
-            ICU_Utility::appendToRule(rule, c, FALSE, escapeUnprintable, quoteBuf);
+            ICU_Utility::appendToRule(rule, c, false, escapeUnprintable, quoteBuf);
         } else {
             UnicodeString buf;
             r->toReplacerPattern(buf, escapeUnprintable);
             buf.insert(0, (UChar)0x20);
             buf.append((UChar)0x20);
             ICU_Utility::appendToRule(rule, buf,
-                                      TRUE, escapeUnprintable, quoteBuf);
+                                      true, escapeUnprintable, quoteBuf);
         }
     }
 
@@ -279,13 +279,13 @@ UnicodeString& StringReplacer::toReplacerPattern(UnicodeString& rule,
     if (hasCursor && cursor > output.length()) {
         cursor -= output.length();
         while (cursor-- > 0) {
-            ICU_Utility::appendToRule(rule, (UChar)0x0040 /*@*/, TRUE, escapeUnprintable, quoteBuf);
+            ICU_Utility::appendToRule(rule, (UChar)0x0040 /*@*/, true, escapeUnprintable, quoteBuf);
         }
-        ICU_Utility::appendToRule(rule, (UChar)0x007C /*|*/, TRUE, escapeUnprintable, quoteBuf);
+        ICU_Utility::appendToRule(rule, (UChar)0x007C /*|*/, true, escapeUnprintable, quoteBuf);
     }
     // Flush quoteBuf out to result
     ICU_Utility::appendToRule(rule, -1,
-                              TRUE, escapeUnprintable, quoteBuf);
+                              true, escapeUnprintable, quoteBuf);
 
     return rule;
 }
diff --git a/deps/icu-small/source/i18n/taiwncal.cpp b/deps/icu-small/source/i18n/taiwncal.cpp
index 27352aa10c..48f0b99e18 100644
--- a/deps/icu-small/source/i18n/taiwncal.cpp
+++ b/deps/icu-small/source/i18n/taiwncal.cpp
@@ -140,11 +140,11 @@ void TaiwanCalendar::timeToFields(UDate theTime, UBool quick, UErrorCode& status
  */
 static UDate           gSystemDefaultCenturyStart       = DBL_MIN;
 static int32_t         gSystemDefaultCenturyStartYear   = -1;
-static icu::UInitOnce  gSystemDefaultCenturyInit        = U_INITONCE_INITIALIZER;
+static icu::UInitOnce  gSystemDefaultCenturyInit        {};
 
 UBool TaiwanCalendar::haveDefaultCentury() const
 {
-    return TRUE;
+    return true;
 }
 
 static void U_CALLCONV initializeSystemDefaultCentury()
diff --git a/deps/icu-small/source/i18n/timezone.cpp b/deps/icu-small/source/i18n/timezone.cpp
index 8115a45e0a..00b44bfe90 100644
--- a/deps/icu-small/source/i18n/timezone.cpp
+++ b/deps/icu-small/source/i18n/timezone.cpp
@@ -113,7 +113,7 @@ static const int32_t       GMT_ID_LENGTH = 3;
 static const int32_t       UNKNOWN_ZONE_ID_LENGTH = 11;
 
 static icu::TimeZone* DEFAULT_ZONE = NULL;
-static icu::UInitOnce gDefaultZoneInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gDefaultZoneInitOnce {};
 
 alignas(icu::SimpleTimeZone)
 static char gRawGMT[sizeof(icu::SimpleTimeZone)];
@@ -121,11 +121,11 @@ static char gRawGMT[sizeof(icu::SimpleTimeZone)];
 alignas(icu::SimpleTimeZone)
 static char gRawUNKNOWN[sizeof(icu::SimpleTimeZone)];
 
-static icu::UInitOnce gStaticZonesInitOnce = U_INITONCE_INITIALIZER;
-static UBool gStaticZonesInitialized = FALSE; // Whether the static zones are initialized and ready to use.
+static icu::UInitOnce gStaticZonesInitOnce {};
+static UBool gStaticZonesInitialized = false; // Whether the static zones are initialized and ready to use.
 
 static char TZDATA_VERSION[16];
-static icu::UInitOnce gTZDataVersionInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gTZDataVersionInitOnce {};
 
 static int32_t* MAP_SYSTEM_ZONES = NULL;
 static int32_t* MAP_CANONICAL_SYSTEM_ZONES = NULL;
@@ -135,9 +135,9 @@ static int32_t LEN_SYSTEM_ZONES = 0;
 static int32_t LEN_CANONICAL_SYSTEM_ZONES = 0;
 static int32_t LEN_CANONICAL_SYSTEM_LOCATION_ZONES = 0;
 
-static icu::UInitOnce gSystemZonesInitOnce = U_INITONCE_INITIALIZER;
-static icu::UInitOnce gCanonicalZonesInitOnce = U_INITONCE_INITIALIZER;
-static icu::UInitOnce gCanonicalLocationZonesInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gSystemZonesInitOnce {};
+static icu::UInitOnce gCanonicalZonesInitOnce {};
+static icu::UInitOnce gCanonicalLocationZonesInitOnce {};
 
 U_CDECL_BEGIN
 static UBool U_CALLCONV timeZone_cleanup(void)
@@ -150,7 +150,7 @@ static UBool U_CALLCONV timeZone_cleanup(void)
     if (gStaticZonesInitialized) {
         reinterpret_cast<SimpleTimeZone*>(gRawGMT)->~SimpleTimeZone();
         reinterpret_cast<SimpleTimeZone*>(gRawUNKNOWN)->~SimpleTimeZone();
-        gStaticZonesInitialized = FALSE;
+        gStaticZonesInitialized = false;
         gStaticZonesInitOnce.reset();
     }
 
@@ -172,7 +172,7 @@ static UBool U_CALLCONV timeZone_cleanup(void)
     MAP_CANONICAL_SYSTEM_LOCATION_ZONES = 0;
     gCanonicalLocationZonesInitOnce.reset();
 
-    return TRUE;
+    return true;
 }
 U_CDECL_END
 
@@ -204,7 +204,7 @@ static int32_t findInStringArray(UResourceBundle* array, const UnicodeString& id
             break;
         }
         U_DEBUG_TZ_MSG(("tz: compare to %s, %d .. [%d] .. %d\n", U_DEBUG_TZ_STR(u), start, mid, limit));
-        copy.setTo(TRUE, u, len);
+        copy.setTo(true, u, len);
         int r = id.compare(copy);
         if(r==0) {
             U_DEBUG_TZ_MSG(("fisa: found at %d\n", mid));
@@ -312,10 +312,10 @@ void U_CALLCONV initStaticTimeZones() {
     ucln_i18n_registerCleanup(UCLN_I18N_TIMEZONE, timeZone_cleanup);
 
     // new can't fail below, as we use placement new into statically allocated space.
-    new(gRawGMT) SimpleTimeZone(0, UnicodeString(TRUE, GMT_ID, GMT_ID_LENGTH));
-    new(gRawUNKNOWN) SimpleTimeZone(0, UnicodeString(TRUE, UNKNOWN_ZONE_ID, UNKNOWN_ZONE_ID_LENGTH));
+    new(gRawGMT) SimpleTimeZone(0, UnicodeString(true, GMT_ID, GMT_ID_LENGTH));
+    new(gRawUNKNOWN) SimpleTimeZone(0, UnicodeString(true, UNKNOWN_ZONE_ID, UNKNOWN_ZONE_ID_LENGTH));
 
-    gStaticZonesInitialized = TRUE;
+    gStaticZonesInitialized = true;
 }
 
 }  // anonymous namespace
@@ -460,7 +460,7 @@ TimeZone::detectHostTimeZone()
     // which have platform specific implementations in putil.cpp
     int32_t rawOffset = 0;
     const char *hostID;
-    UBool hostDetectionSucceeded = TRUE;
+    UBool hostDetectionSucceeded = true;
 
     // First, try to create a system timezone, based
     // on the string ID in tzname[0].
@@ -484,8 +484,8 @@ TimeZone::detectHostTimeZone()
     if (hostStrID.length() == 0) {
         // The host time zone detection (or remapping) above has failed and
         // we have no name at all. Fallback to using the Unknown zone.
-        hostStrID = UnicodeString(TRUE, UNKNOWN_ZONE_ID, UNKNOWN_ZONE_ID_LENGTH);
-        hostDetectionSucceeded = FALSE;
+        hostStrID = UnicodeString(true, UNKNOWN_ZONE_ID, UNKNOWN_ZONE_ID_LENGTH);
+        hostDetectionSucceeded = false;
     }
 
     hostZone = createSystemTimeZone(hostStrID);
@@ -716,12 +716,12 @@ void TimeZone::getOffset(UDate date, UBool local, int32_t& rawOffset,
         date += rawOffset; // now in local standard millis
     }
 
-    // When local == TRUE, date might not be in local standard
+    // When local == true, date might not be in local standard
     // millis.  getOffset taking 7 parameters used here assume
     // the given time in day is local standard time.
     // At STD->DST transition, there is a range of time which
     // does not exist.  When 'date' is in this time range
-    // (and local == TRUE), this method interprets the specified
+    // (and local == true), this method interprets the specified
     // local time as DST.  At DST->STD transition, there is a
     // range of time which occurs twice.  In this case, this
     // method interprets the specified local time as STD.
@@ -729,9 +729,8 @@ void TimeZone::getOffset(UDate date, UBool local, int32_t& rawOffset,
     // (with 7 args) twice when local == true and DST is
     // detected in the initial call.
     for (int32_t pass=0; ; ++pass) {
-        int32_t year, month, dom, dow;
-        double day = uprv_floor(date / U_MILLIS_PER_DAY);
-        int32_t millis = (int32_t) (date - day * U_MILLIS_PER_DAY);
+        int32_t year, month, dom, dow, millis;
+        double day = ClockMath::floorDivide(date, U_MILLIS_PER_DAY, &millis);
 
         Grego::dayToFields(day, year, month, dom, dow);
 
@@ -740,7 +739,7 @@ void TimeZone::getOffset(UDate date, UBool local, int32_t& rawOffset,
                               Grego::monthLength(year, month),
                               ec) - rawOffset;
 
-        // Recompute if local==TRUE, dstOffset!=0.
+        // Recompute if local==true, dstOffset!=0.
         if (pass!=0 || !local || dstOffset == 0) {
             break;
         }
@@ -781,7 +780,7 @@ private:
             unistr.truncate(0);
         }
         else {
-            unistr.fastCopyFrom(UnicodeString(TRUE, id, idLen));
+            unistr.fastCopyFrom(UnicodeString(true, id, idLen));
         }
         ures_close(top);
         return U_SUCCESS(ec);
@@ -911,9 +910,9 @@ public:
         if (U_SUCCESS(ec)) {
             // Finally, create a new enumeration instance
             if (filteredMap == NULL) {
-                result = new TZEnumeration(baseMap, baseLen, FALSE);
+                result = new TZEnumeration(baseMap, baseLen, false);
             } else {
-                result = new TZEnumeration(filteredMap, numEntries, TRUE);
+                result = new TZEnumeration(filteredMap, numEntries, true);
                 filteredMap = NULL;
             }
             if (result == NULL) {
@@ -1075,7 +1074,7 @@ TimeZone::getEquivalentID(const UnicodeString& id, int32_t index) {
         if (U_SUCCESS(ec)) {
             int32_t idLen = 0;
             const UChar* id2 = ures_getStringByIndex(ares, zone, &idLen, &ec);
-            result.fastCopyFrom(UnicodeString(TRUE, id2, idLen));
+            result.fastCopyFrom(UnicodeString(true, id2, idLen));
             U_DEBUG_TZ_MSG(("gei(%d) -> %d, len%d, %s\n", index, zone, result.length(), u_errorName(ec)));
         }
         ures_close(ares);
@@ -1214,13 +1213,13 @@ TimeZone::getRegion(const UnicodeString& id, char *region, int32_t capacity, UEr
 UnicodeString&
 TimeZone::getDisplayName(UnicodeString& result) const
 {
-    return getDisplayName(FALSE,LONG,Locale::getDefault(), result);
+    return getDisplayName(false,LONG,Locale::getDefault(), result);
 }
 
 UnicodeString&
 TimeZone::getDisplayName(const Locale& locale, UnicodeString& result) const
 {
-    return getDisplayName(FALSE, LONG, locale, result);
+    return getDisplayName(false, LONG, locale, result);
 }
 
 UnicodeString&
@@ -1288,7 +1287,7 @@ TimeZone::getDisplayName(UBool inDaylight, EDisplayType style, const Locale& loc
             tzfmt->formatOffsetLocalizedGMT(offset, result, status);
             break;
         case SHORT_GMT:
-            tzfmt->formatOffsetISO8601Basic(offset, FALSE, FALSE, FALSE, result, status);
+            tzfmt->formatOffsetISO8601Basic(offset, false, false, false, result, status);
             break;
         default:
             UPRV_UNREACHABLE_EXIT;
@@ -1388,17 +1387,17 @@ TimeZone::parseCustomID(const UnicodeString& id, int32_t& sign,
         if (id[pos.getIndex()] == MINUS /*'-'*/) {
             sign = -1;
         } else if (id[pos.getIndex()] != PLUS /*'+'*/) {
-            return FALSE;
+            return false;
         }
         pos.setIndex(pos.getIndex() + 1);
 
         UErrorCode success = U_ZERO_ERROR;
         numberFormat = NumberFormat::createInstance(success);
         if(U_FAILURE(success)){
-            return FALSE;
+            return false;
         }
-        numberFormat->setParseIntegerOnly(TRUE);
-        //numberFormat->setLenient(TRUE); // TODO: May need to set this, depends on latest timezone parsing
+        numberFormat->setParseIntegerOnly(true);
+        //numberFormat->setLenient(true); // TODO: May need to set this, depends on latest timezone parsing
 
         // Look for either hh:mm, hhmm, or hh
         int32_t start = pos.getIndex();
@@ -1406,7 +1405,7 @@ TimeZone::parseCustomID(const UnicodeString& id, int32_t& sign,
         numberFormat->parse(id, n, pos);
         if (pos.getIndex() == start) {
             delete numberFormat;
-            return FALSE;
+            return false;
         }
         hour = n.getLong();
 
@@ -1414,7 +1413,7 @@ TimeZone::parseCustomID(const UnicodeString& id, int32_t& sign,
             if (pos.getIndex() - start > 2
                 || id[pos.getIndex()] != COLON) {
                 delete numberFormat;
-                return FALSE;
+                return false;
             }
             // hh:mm
             pos.setIndex(pos.getIndex() + 1);
@@ -1424,13 +1423,13 @@ TimeZone::parseCustomID(const UnicodeString& id, int32_t& sign,
             if ((pos.getIndex() - oldPos) != 2) {
                 // must be 2 digits
                 delete numberFormat;
-                return FALSE;
+                return false;
             }
             min = n.getLong();
             if (pos.getIndex() < id.length()) {
                 if (id[pos.getIndex()] != COLON) {
                     delete numberFormat;
-                    return FALSE;
+                    return false;
                 }
                 // [:ss]
                 pos.setIndex(pos.getIndex() + 1);
@@ -1440,7 +1439,7 @@ TimeZone::parseCustomID(const UnicodeString& id, int32_t& sign,
                 if (pos.getIndex() != id.length()
                         || (pos.getIndex() - oldPos) != 2) {
                     delete numberFormat;
-                    return FALSE;
+                    return false;
                 }
                 sec = n.getLong();
             }
@@ -1458,7 +1457,7 @@ TimeZone::parseCustomID(const UnicodeString& id, int32_t& sign,
             if (length <= 0 || 6 < length) {
                 // invalid length
                 delete numberFormat;
-                return FALSE;
+                return false;
             }
             switch (length) {
                 case 1:
@@ -1482,11 +1481,11 @@ TimeZone::parseCustomID(const UnicodeString& id, int32_t& sign,
         delete numberFormat;
 
         if (hour > kMAX_CUSTOM_HOUR || min > kMAX_CUSTOM_MIN || sec > kMAX_CUSTOM_SEC) {
-            return FALSE;
+            return false;
         }
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 UnicodeString&
@@ -1562,7 +1561,7 @@ TimeZone::getTZDataVersion(UErrorCode& status)
 UnicodeString&
 TimeZone::getCanonicalID(const UnicodeString& id, UnicodeString& canonicalID, UErrorCode& status)
 {
-    UBool isSystemID = FALSE;
+    UBool isSystemID = false;
     return getCanonicalID(id, canonicalID, isSystemID, status);
 }
 
@@ -1571,18 +1570,18 @@ TimeZone::getCanonicalID(const UnicodeString& id, UnicodeString& canonicalID, UB
                          UErrorCode& status)
 {
     canonicalID.remove();
-    isSystemID = FALSE;
+    isSystemID = false;
     if (U_FAILURE(status)) {
         return canonicalID;
     }
     if (id.compare(UNKNOWN_ZONE_ID, UNKNOWN_ZONE_ID_LENGTH) == 0) {
         // special case - Etc/Unknown is a canonical ID, but not system ID
         canonicalID.fastCopyFrom(id);
-        isSystemID = FALSE;
+        isSystemID = false;
     } else {
         ZoneMeta::getCanonicalCLDRID(id, canonicalID, status);
         if (U_SUCCESS(status)) {
-            isSystemID = TRUE;
+            isSystemID = true;
         } else {
             // Not a system ID
             status = U_ZERO_ERROR;
@@ -1601,7 +1600,7 @@ TimeZone::getWindowsID(const UnicodeString& id, UnicodeString& winid, UErrorCode
 
     // canonicalize the input ID
     UnicodeString canonicalID;
-    UBool isSystemID = FALSE;
+    UBool isSystemID = false;
 
     getCanonicalID(id, canonicalID, isSystemID, status);
     if (U_FAILURE(status) || !isSystemID) {
@@ -1622,7 +1621,7 @@ TimeZone::getWindowsID(const UnicodeString& id, UnicodeString& winid, UErrorCode
     }
 
     UResourceBundle *winzone = NULL;
-    UBool found = FALSE;
+    UBool found = false;
     while (ures_hasNext(mapTimezones) && !found) {
         winzone = ures_getNextResource(mapTimezones, winzone, &status);
         if (U_FAILURE(status)) {
@@ -1647,16 +1646,16 @@ TimeZone::getWindowsID(const UnicodeString& id, UnicodeString& winid, UErrorCode
             }
 
             const UChar *start = tzids;
-            UBool hasNext = TRUE;
+            UBool hasNext = true;
             while (hasNext) {
                 const UChar *end = u_strchr(start, (UChar)0x20);
                 if (end == NULL) {
                     end = tzids + len;
-                    hasNext = FALSE;
+                    hasNext = false;
                 }
                 if (canonicalID.compare(start, static_cast<int32_t>(end - start)) == 0) {
                     winid = UnicodeString(ures_getKey(winzone), -1 , US_INV);
-                    found = TRUE;
+                    found = true;
                     break;
                 }
                 start = end + 1;
@@ -1705,7 +1704,7 @@ TimeZone::getIDForWindowsID(const UnicodeString& winid, const char* region, Unic
 
     const UChar *tzid = NULL;
     int32_t len = 0;
-    UBool gotID = FALSE;
+    UBool gotID = false;
     if (region) {
         const UChar *tzids = ures_getStringByKey(zones, region, &len, &tmperr); // use tmperr, because
                                                                                 // regional mapping is optional
@@ -1717,7 +1716,7 @@ TimeZone::getIDForWindowsID(const UnicodeString& winid, const char* region, Unic
             } else {
                 id.setTo(tzids, static_cast<int32_t>(end - tzids));
             }
-            gotID = TRUE;
+            gotID = true;
         }
     }
 
diff --git a/deps/icu-small/source/i18n/titletrn.cpp b/deps/icu-small/source/i18n/titletrn.cpp
index 9c39b4676a..62e41f920c 100644
--- a/deps/icu-small/source/i18n/titletrn.cpp
+++ b/deps/icu-small/source/i18n/titletrn.cpp
@@ -87,7 +87,7 @@ void TitlecaseTransliterator::handleTransliterate(
 
     // Our mode; we are either converting letter toTitle or
     // toLower.
-    UBool doTitle = TRUE;
+    UBool doTitle = true;
     
     // Determine if there is a preceding context of cased case-ignorable*,
     // in which case we want to start in toLower mode.  If the
@@ -99,7 +99,7 @@ void TitlecaseTransliterator::handleTransliterate(
         c = text.char32At(start);
         type=ucase_getTypeOrIgnorable(c);
         if(type>0) { // cased
-            doTitle=FALSE;
+            doTitle=false;
             break;
         } else if(type==0) { // uncased but not ignorable
             break;
@@ -146,7 +146,7 @@ void TitlecaseTransliterator::handleTransliterate(
                 // see UCASE_MAX_STRING_LENGTH
                 if(result<=UCASE_MAX_STRING_LENGTH) {
                     // string s[result]
-                    tmp.setTo(FALSE, s, result);
+                    tmp.setTo(false, s, result);
                     delta=result-U16_LENGTH(c);
                 } else {
                     // single code point
diff --git a/deps/icu-small/source/i18n/tmutfmt.cpp b/deps/icu-small/source/i18n/tmutfmt.cpp
index f0335a81f5..37e56b26a1 100644
--- a/deps/icu-small/source/i18n/tmutfmt.cpp
+++ b/deps/icu-small/source/i18n/tmutfmt.cpp
@@ -358,7 +358,7 @@ struct TimeUnitFormatReadSink : public ResourceSink {
     TimeUnitFormatReadSink(TimeUnitFormat *timeUnitFormatObj,
             const UVector &pluralCounts, UTimeUnitFormatStyle style) :
             timeUnitFormatObj(timeUnitFormatObj), pluralCounts(pluralCounts),
-            style(style), beenHere(FALSE){}
+            style(style), beenHere(false){}
 
     virtual ~TimeUnitFormatReadSink();
 
@@ -367,7 +367,7 @@ struct TimeUnitFormatReadSink : public ResourceSink {
         if (beenHere) {
             return;
         } else {
-            beenHere = TRUE;
+            beenHere = true;
         }
 
         ResourceTable units = value.getTable(errorCode);
@@ -573,7 +573,7 @@ TimeUnitFormat::searchInLocaleChain(UTimeUnitFormatStyle style, const char* key,
         if (U_SUCCESS(status)) {
             //found
             LocalPointer<MessageFormat> messageFormat(
-                new MessageFormat(UnicodeString(TRUE, pattern, ptLength), getLocale(err), err), err);
+                new MessageFormat(UnicodeString(true, pattern, ptLength), getLocale(err), err), err);
             if (U_FAILURE(err)) {
                 return;
             }
@@ -643,7 +643,7 @@ TimeUnitFormat::searchInLocaleChain(UTimeUnitFormatStyle style, const char* key,
         }
         if (pattern != NULL) {
             messageFormat.adoptInsteadAndCheckErrorCode(
-                     new MessageFormat(UnicodeString(TRUE, pattern, -1), getLocale(err), err), err);
+                     new MessageFormat(UnicodeString(true, pattern, -1), getLocale(err), err), err);
         }
         if (U_FAILURE(err)) {
             return;
@@ -742,7 +742,7 @@ U_CDECL_BEGIN
  *
  * @param val1  one value in comparison
  * @param val2  the other value in comparison
- * @return      TRUE if 2 values are the same, FALSE otherwise
+ * @return      true if 2 values are the same, false otherwise
  */
 static UBool U_CALLCONV tmutfmtHashTableValueComparator(UHashTok val1, UHashTok val2);
 
@@ -761,7 +761,7 @@ TimeUnitFormat::initHash(UErrorCode& status) {
         return NULL;
     }
     Hashtable* hTable;
-    if ( (hTable = new Hashtable(TRUE, status)) == NULL ) {
+    if ( (hTable = new Hashtable(true, status)) == NULL ) {
         status = U_MEMORY_ALLOCATION_ERROR;
         return NULL;
     }
diff --git a/deps/icu-small/source/i18n/translit.cpp b/deps/icu-small/source/i18n/translit.cpp
index c7d6b51057..4d74d0b612 100644
--- a/deps/icu-small/source/i18n/translit.cpp
+++ b/deps/icu-small/source/i18n/translit.cpp
@@ -107,7 +107,7 @@ U_NAMESPACE_BEGIN
 UOBJECT_DEFINE_ABSTRACT_RTTI_IMPLEMENTATION(Transliterator)
 
 /**
- * Return TRUE if the given UTransPosition is valid for text of
+ * Return true if the given UTransPosition is valid for text of
  * the given length.
  */
 static inline UBool positionIsValid(UTransPosition& index, int32_t len) {
@@ -122,7 +122,7 @@ static inline UBool positionIsValid(UTransPosition& index, int32_t len) {
  * Default constructor.
  * @param theID the string identifier for this transliterator
  * @param theFilter the filter.  Any character for which
- * <tt>filter.contains()</tt> returns <tt>FALSE</tt> will not be
+ * <tt>filter.contains()</tt> returns <tt>false</tt> will not be
  * altered by this transliterator.  If <tt>filter</tt> is
  * <tt>null</tt> then no filtering is applied.
  */
@@ -202,7 +202,7 @@ int32_t Transliterator::transliterate(Replaceable& text,
     offsets.contextLimit = limit;
     offsets.start = start;
     offsets.limit = limit;
-    filteredTransliterate(text, offsets, FALSE, TRUE);
+    filteredTransliterate(text, offsets, false, true);
     return offsets.limit;
 }
 
@@ -341,7 +341,7 @@ void Transliterator::finishTransliteration(Replaceable& text,
         return;
     }
 
-    filteredTransliterate(text, index, FALSE, TRUE);
+    filteredTransliterate(text, index, false, true);
 }
 
 /**
@@ -380,7 +380,7 @@ void Transliterator::_transliterate(Replaceable& text,
         return;
     }
 
-    filteredTransliterate(text, index, TRUE, TRUE);
+    filteredTransliterate(text, index, true, true);
 
 #if 0
     // TODO
@@ -440,7 +440,7 @@ void Transliterator::filteredTransliterate(Replaceable& text,
     // This method processes text in two groupings:
     //
     // RUNS -- A run is a contiguous group of characters which are contained
-    // in the filter for this transliterator (filter.contains(ch) == TRUE).
+    // in the filter for this transliterator (filter.contains(ch) == true).
     // Text outside of runs may appear as context but it is not modified.
     // The start and limit Position values are narrowed to each run.
     //
@@ -503,10 +503,10 @@ void Transliterator::filteredTransliterate(Replaceable& text,
 
         // Is this run incremental?  If there is additional
         // filtered text (if limit < globalLimit) then we pass in
-        // an incremental value of FALSE to force the subclass to
+        // an incremental value of false to force the subclass to
         // complete the transliteration for this run.
         UBool isIncrementalRun =
-            (index.limit < globalLimit ? FALSE : incremental);
+            (index.limit < globalLimit ? false : incremental);
         
         int32_t delta;
 
@@ -585,7 +585,7 @@ void Transliterator::filteredTransliterate(Replaceable& text,
                 // return, start will be updated to point after the
                 // transliterated text, and limit and contextLimit will be
                 // adjusted for length changes.
-                handleTransliterate(text, index, TRUE);
+                handleTransliterate(text, index, true);
 
                 delta = index.limit - passLimit; // change in length
 
@@ -682,7 +682,7 @@ void Transliterator::filteredTransliterate(Replaceable& text,
 void Transliterator::filteredTransliterate(Replaceable& text,
                                            UTransPosition& index,
                                            UBool incremental) const {
-    filteredTransliterate(text, index, incremental, FALSE);
+    filteredTransliterate(text, index, incremental, false);
 }
 
 /**
@@ -1070,7 +1070,7 @@ Transliterator::createFromRules(const UnicodeString& ID,
         t = new NullTransliterator();
     }
     else if (parser.idBlockVector.size() == 0 && parser.dataVector.size() == 1) {
-        t = new RuleBasedTransliterator(ID, (TransliterationRuleData*)parser.dataVector.orphanElementAt(0), TRUE);
+        t = new RuleBasedTransliterator(ID, (TransliterationRuleData*)parser.dataVector.orphanElementAt(0), true);
     }
     else if (parser.idBlockVector.size() == 1 && parser.dataVector.size() == 0) {
         // idBlock, no data -- this is an alias.  The ID has
@@ -1079,7 +1079,7 @@ Transliterator::createFromRules(const UnicodeString& ID,
         // direction.
         if (parser.compoundFilter != NULL) {
             UnicodeString filterPattern;
-            parser.compoundFilter->toPattern(filterPattern, FALSE);
+            parser.compoundFilter->toPattern(filterPattern, false);
             t = createInstance(filterPattern + UnicodeString(ID_DELIM)
                     + *((UnicodeString*)parser.idBlockVector.elementAt(0)), UTRANS_FORWARD, parseError, status);
         }
@@ -1125,7 +1125,7 @@ Transliterator::createFromRules(const UnicodeString& ID,
                 TransliterationRuleData* data = (TransliterationRuleData*)parser.dataVector.orphanElementAt(0);
                 // TODO: Should passNumber be turned into a decimal-string representation (1 -> "1")?
                 RuleBasedTransliterator* temprbt = new RuleBasedTransliterator(UnicodeString(CompoundTransliterator::PASS_STRING) + UnicodeString(passNumber++),
-                        data, TRUE);
+                        data, true);
                 // Check if NULL before adding it to transliterators to avoid future usage of NULL pointer.
                 if (temprbt == NULL) {
                     if (U_SUCCESS(status)) {
@@ -1203,7 +1203,7 @@ UnicodeSet& Transliterator::getSourceSet(UnicodeSet& result) const {
     handleGetSourceSet(result);
     if (filter != NULL) {
         UnicodeSet* filterSet = dynamic_cast<UnicodeSet*>(filter);
-        UBool deleteFilterSet = FALSE;
+        UBool deleteFilterSet = false;
         // Most, but not all filters will be UnicodeSets.  Optimize for
         // the high-runner case.
         if (filterSet == NULL) {
@@ -1212,7 +1212,7 @@ UnicodeSet& Transliterator::getSourceSet(UnicodeSet& result) const {
             if (filterSet == NULL) {
                 return result;
             }
-            deleteFilterSet = TRUE;
+            deleteFilterSet = true;
             filter->addMatchSetTo(*filterSet);
         }
         result.retainAll(*filterSet);
@@ -1248,7 +1248,7 @@ void Transliterator::_registerFactory(const UnicodeString& id,
                                       Transliterator::Factory factory,
                                       Transliterator::Token context) {
     UErrorCode ec = U_ZERO_ERROR;
-    registry->put(id, factory, context, TRUE, ec);
+    registry->put(id, factory, context, true, ec);
 }
 
 // To be called only by Transliterator subclasses that are called
@@ -1283,7 +1283,7 @@ void U_EXPORT2 Transliterator::registerInstance(Transliterator* adoptedPrototype
 
 void Transliterator::_registerInstance(Transliterator* adoptedPrototype) {
     UErrorCode ec = U_ZERO_ERROR;
-    registry->put(adoptedPrototype, TRUE, ec);
+    registry->put(adoptedPrototype, true, ec);
 }
 
 void U_EXPORT2 Transliterator::registerAlias(const UnicodeString& aliasID,
@@ -1298,7 +1298,7 @@ void U_EXPORT2 Transliterator::registerAlias(const UnicodeString& aliasID,
 void Transliterator::_registerAlias(const UnicodeString& aliasID,
                                     const UnicodeString& realID) {
     UErrorCode ec = U_ZERO_ERROR;
-    registry->put(aliasID, realID, FALSE, TRUE, ec);
+    registry->put(aliasID, realID, false, true, ec);
 }
 
 /**
@@ -1466,9 +1466,9 @@ UChar Transliterator::filteredCharAt(const Replaceable& text, int32_t i) const {
 #endif
 
 /**
- * If the registry is initialized, return TRUE.  If not, initialize it
- * and return TRUE.  If the registry cannot be initialized, return
- * FALSE (rare).
+ * If the registry is initialized, return true.  If not, initialize it
+ * and return true.  If the registry cannot be initialized, return
+ * false (rare).
  *
  * IMPORTANT: Upon entry, registryMutex must be LOCKED.  The entire
  * initialization is done with the lock held.  There is NO REASON to
@@ -1477,14 +1477,14 @@ UChar Transliterator::filteredCharAt(const Replaceable& text, int32_t i) const {
  */
 UBool Transliterator::initializeRegistry(UErrorCode &status) {
     if (registry != 0) {
-        return TRUE;
+        return true;
     }
 
     registry = new TransliteratorRegistry(status);
     if (registry == 0 || U_FAILURE(status)) {
         delete registry;
         registry = 0;
-        return FALSE; // can't create registry, no recovery
+        return false; // can't create registry, no recovery
     }
 
     /* The following code parses the index table located in
@@ -1534,7 +1534,7 @@ UBool Transliterator::initializeRegistry(UErrorCode &status) {
         delete registry;
         registry = nullptr;
         status = U_MEMORY_ALLOCATION_ERROR;
-        return FALSE;
+        return false;
     }
     if (U_SUCCESS(lstatus)) {
         maxRows = ures_getSize(transIDs);
@@ -1567,13 +1567,13 @@ UBool Transliterator::initializeRegistry(UErrorCode &status) {
                                 (ures_getUnicodeStringByKey(res, "direction", &lstatus).charAt(0) ==
                                  0x0046 /*F*/) ?
                                 UTRANS_FORWARD : UTRANS_REVERSE;
-                            registry->put(id, UnicodeString(TRUE, resString, len), dir, TRUE, visible, lstatus);
+                            registry->put(id, UnicodeString(true, resString, len), dir, true, visible, lstatus);
                         }
                         break;
                     case 0x61: // 'a'
                         // 'alias'; row[2]=createInstance argument
                         resString = ures_getString(res, &len, &lstatus);
-                        registry->put(id, UnicodeString(TRUE, resString, len), TRUE, TRUE, lstatus);
+                        registry->put(id, UnicodeString(true, resString, len), true, true, lstatus);
                         break;
                     }
                 }
@@ -1626,14 +1626,14 @@ UBool Transliterator::initializeRegistry(UErrorCode &status) {
         return 0;
     }
 
-    registry->put(tempNullTranslit, TRUE, status);
-    registry->put(tempLowercaseTranslit, TRUE, status);
-    registry->put(tempUppercaseTranslit, TRUE, status);
-    registry->put(tempTitlecaseTranslit, TRUE, status);
-    registry->put(tempUnicodeTranslit, TRUE, status);
-    registry->put(tempNameUnicodeTranslit, TRUE, status);
+    registry->put(tempNullTranslit, true, status);
+    registry->put(tempLowercaseTranslit, true, status);
+    registry->put(tempUppercaseTranslit, true, status);
+    registry->put(tempTitlecaseTranslit, true, status);
+    registry->put(tempUnicodeTranslit, true, status);
+    registry->put(tempNameUnicodeTranslit, true, status);
 #if !UCONFIG_NO_BREAK_ITERATION
-    registry->put(tempBreakTranslit, FALSE, status);   // FALSE means invisible.
+    registry->put(tempBreakTranslit, false, status);   // false means invisible.
 #endif
 
     RemoveTransliterator::registerIDs(); // Must be within mutex
@@ -1643,15 +1643,15 @@ UBool Transliterator::initializeRegistry(UErrorCode &status) {
     AnyTransliterator::registerIDs();
 
     _registerSpecialInverse(UNICODE_STRING_SIMPLE("Null"),
-                            UNICODE_STRING_SIMPLE("Null"), FALSE);
+                            UNICODE_STRING_SIMPLE("Null"), false);
     _registerSpecialInverse(UNICODE_STRING_SIMPLE("Upper"),
-                            UNICODE_STRING_SIMPLE("Lower"), TRUE);
+                            UNICODE_STRING_SIMPLE("Lower"), true);
     _registerSpecialInverse(UNICODE_STRING_SIMPLE("Title"),
-                            UNICODE_STRING_SIMPLE("Lower"), FALSE);
+                            UNICODE_STRING_SIMPLE("Lower"), false);
 
     ucln_i18n_registerCleanup(UCLN_I18N_TRANSLITERATOR, utrans_transliterator_cleanup);
 
-    return TRUE;
+    return true;
 }
 
 U_NAMESPACE_END
@@ -1670,7 +1670,7 @@ U_CFUNC UBool utrans_transliterator_cleanup(void) {
         delete registry;
         registry = NULL;
     }
-    return TRUE;
+    return true;
 }
 
 #endif /* #if !UCONFIG_NO_TRANSLITERATION */
diff --git a/deps/icu-small/source/i18n/transreg.cpp b/deps/icu-small/source/i18n/transreg.cpp
index 726ad56f0f..32040c63a6 100644
--- a/deps/icu-small/source/i18n/transreg.cpp
+++ b/deps/icu-small/source/i18n/transreg.cpp
@@ -141,16 +141,10 @@ Transliterator* TransliteratorAlias::create(UParseError& pe,
             // to see whether there really are ID blocks at the beginning and end (by looking for U+FFFF, which
             // marks the position where an anonymous transliterator goes) and adjust accordingly
             int32_t anonymousRBTs = transes->size();
-            int32_t transCount = anonymousRBTs * 2 + 1;
-            if (!aliasesOrRules.isEmpty() && aliasesOrRules[0] == (UChar)(0xffff))
-                --transCount;
-            if (aliasesOrRules.length() >= 2 && aliasesOrRules[aliasesOrRules.length() - 1] == (UChar)(0xffff))
-                --transCount;
             UnicodeString noIDBlock((UChar)(0xffff));
             noIDBlock += ((UChar)(0xffff));
             int32_t pos = aliasesOrRules.indexOf(noIDBlock);
             while (pos >= 0) {
-                --transCount;
                 pos = aliasesOrRules.indexOf(noIDBlock, pos + 1);
             }
 
@@ -187,7 +181,7 @@ Transliterator* TransliteratorAlias::create(UParseError& pe,
         }
         break;
     case RULES:
-        UPRV_UNREACHABLE_EXIT; // don't call create() if isRuleBased() returns TRUE!
+        UPRV_UNREACHABLE_EXIT; // don't call create() if isRuleBased() returns true!
     }
     return t;
 }
@@ -248,8 +242,8 @@ class TransliteratorSpec : public UMemory {
     UnicodeString spec;
     UnicodeString nextSpec;
     UnicodeString scriptName;
-    UBool isSpecLocale; // TRUE if spec is a locale
-    UBool isNextLocale; // TRUE if nextSpec is a locale
+    UBool isSpecLocale; // true if spec is a locale
+    UBool isNextLocale; // true if nextSpec is a locale
     ResourceBundle* res;
 
     TransliteratorSpec(const TransliteratorSpec &other); // forbid copying of this class
@@ -319,7 +313,7 @@ void TransliteratorSpec::reset() {
 }
 
 void TransliteratorSpec::setupNext() {
-    isNextLocale = FALSE;
+    isNextLocale = false;
     if (isSpecLocale) {
         nextSpec = spec;
         int32_t i = nextSpec.lastIndexOf(LOCALE_SEP);
@@ -327,7 +321,7 @@ void TransliteratorSpec::setupNext() {
         // to the scriptName.
         if (i > 0) {
             nextSpec.truncate(i);
-            isNextLocale = TRUE;
+            isNextLocale = true;
         } else {
             nextSpec = scriptName; // scriptName may be empty
         }
@@ -534,8 +528,8 @@ U_CDECL_END
 //----------------------------------------------------------------------
 
 TransliteratorRegistry::TransliteratorRegistry(UErrorCode& status) :
-    registry(TRUE, status),
-    specDAG(TRUE, SPECDAG_INIT_SIZE, status),
+    registry(true, status),
+    specDAG(true, SPECDAG_INIT_SIZE, status),
     variantList(VARIANT_LIST_INIT_SIZE, status),
     availableIDs(AVAILABLE_IDS_INIT_SIZE, status)
 {
@@ -580,7 +574,7 @@ Transliterator* TransliteratorRegistry::reget(const UnicodeString& ID,
 
     // The usage model for the caller is that they will first call
     // reg->get() inside the mutex, they'll get back an alias, they call
-    // alias->isRuleBased(), and if they get TRUE, they call alias->parse()
+    // alias->isRuleBased(), and if they get true, they call alias->parse()
     // outside the mutex, then reg->reget() inside the mutex again.  A real
     // mess, but it gets things working for ICU 3.0. [alan].
 
@@ -684,7 +678,7 @@ void TransliteratorRegistry::put(const UnicodeString& ID,
     entry->entryType = (dir == UTRANS_FORWARD) ? TransliteratorEntry::RULES_FORWARD
         : TransliteratorEntry::RULES_REVERSE;
     if (readonlyResourceAlias) {
-        entry->stringArg.setTo(TRUE, resourceName.getBuffer(), -1);
+        entry->stringArg.setTo(true, resourceName.getBuffer(), -1);
     }
     else {
         entry->stringArg = resourceName;
@@ -702,7 +696,7 @@ void TransliteratorRegistry::put(const UnicodeString& ID,
     if (entry != NULL) {
         entry->entryType = TransliteratorEntry::ALIAS;
         if (readonlyAliasAlias) {
-            entry->stringArg.setTo(TRUE, alias.getBuffer(), -1);
+            entry->stringArg.setTo(true, alias.getBuffer(), -1);
         }
         else {
             entry->stringArg = alias;
@@ -916,7 +910,7 @@ void TransliteratorRegistry::registerEntry(const UnicodeString& source,
     UnicodeString ID;
     UnicodeString s(source);
     if (s.length() == 0) {
-        s.setTo(TRUE, ANY, 3);
+        s.setTo(true, ANY, 3);
     }
     TransliteratorIDParser::STVtoID(source, target, variant, ID);
     registerEntry(ID, s, target, variant, adopted, visible);
@@ -984,7 +978,7 @@ void TransliteratorRegistry::registerSTV(const UnicodeString& source,
         } else if (source.compare(LAT,3) == 0) {
             size = LAT_TARGETS_INIT_SIZE;
         }
-        targets = new Hashtable(TRUE, size, status);
+        targets = new Hashtable(true, size, status);
         if (U_FAILURE(status) || targets == NULL) {
             return;
         }
@@ -1085,7 +1079,7 @@ TransliteratorEntry* TransliteratorRegistry::findInStaticStore(const Translitera
     // If we found an entry, store it in the Hashtable for next
     // time.
     if (entry != 0) {
-        registerEntry(src.getTop(), trg.getTop(), variant, entry, FALSE);
+        registerEntry(src.getTop(), trg.getTop(), variant, entry, false);
     }
 
     return entry;
@@ -1336,7 +1330,7 @@ Transliterator* TransliteratorRegistry::instantiateEntry(const UnicodeString& ID
             for (int32_t i = 0; U_SUCCESS(status) && i < entry->u.dataVector->size(); i++) {
                 // TODO: Should passNumber be turned into a decimal-string representation (1 -> "1")?
                 Transliterator* tl = new RuleBasedTransliterator(UnicodeString(CompoundTransliterator::PASS_STRING) + UnicodeString(passNumber++),
-                    (TransliterationRuleData*)(entry->u.dataVector->elementAt(i)), FALSE);
+                    (TransliterationRuleData*)(entry->u.dataVector->elementAt(i)), false);
                 if (tl == 0)
                     status = U_MEMORY_ALLOCATION_ERROR;
                 else
diff --git a/deps/icu-small/source/i18n/tridpars.cpp b/deps/icu-small/source/i18n/tridpars.cpp
index 0ca168e7a3..a52f928759 100644
--- a/deps/icu-small/source/i18n/tridpars.cpp
+++ b/deps/icu-small/source/i18n/tridpars.cpp
@@ -45,7 +45,7 @@ static const int32_t FORWARD = UTRANS_FORWARD;
 static const int32_t REVERSE = UTRANS_REVERSE;
 
 static Hashtable* SPECIAL_INVERSES = NULL;
-static UInitOnce gSpecialInversesInitOnce = U_INITONCE_INITIALIZER;
+static UInitOnce gSpecialInversesInitOnce {};
 
 /**
  * The mutex controlling access to SPECIAL_INVERSES
@@ -77,7 +77,7 @@ TransliteratorIDParser::SingleID::SingleID(const UnicodeString& c, const Unicode
 Transliterator* TransliteratorIDParser::SingleID::createInstance() {
     Transliterator* t;
     if (basicID.length() == 0) {
-        t = createBasicInstance(UnicodeString(TRUE, ANY_NULL, 8), &canonID);
+        t = createBasicInstance(UnicodeString(true, ANY_NULL, 8), &canonID);
     } else {
         t = createBasicInstance(basicID, &canonID);
     }
@@ -118,22 +118,22 @@ TransliteratorIDParser::parseSingleID(const UnicodeString& id, int32_t& pos,
     // A and B are filter IDs.
     Specs* specsA = NULL;
     Specs* specsB = NULL;
-    UBool sawParen = FALSE;
+    UBool sawParen = false;
 
     // On the first pass, look for (B) or ().  If this fails, then
     // on the second pass, look for A, A(B), or A().
     for (int32_t pass=1; pass<=2; ++pass) {
         if (pass == 2) {
-            specsA = parseFilterID(id, pos, TRUE);
+            specsA = parseFilterID(id, pos, true);
             if (specsA == NULL) {
                 pos = start;
                 return NULL;
             }
         }
         if (ICU_Utility::parseChar(id, pos, OPEN_REV)) {
-            sawParen = TRUE;
+            sawParen = true;
             if (!ICU_Utility::parseChar(id, pos, CLOSE_REV)) {
-                specsB = parseFilterID(id, pos, TRUE);
+                specsB = parseFilterID(id, pos, true);
                 // Must close with a ')'
                 if (specsB == NULL || !ICU_Utility::parseChar(id, pos, CLOSE_REV)) {
                     delete specsA;
@@ -219,7 +219,7 @@ TransliteratorIDParser::parseFilterID(const UnicodeString& id, int32_t& pos) {
 
     int32_t start = pos;
 
-    Specs* specs = parseFilterID(id, pos, TRUE);
+    Specs* specs = parseFilterID(id, pos, true);
     if (specs == NULL) {
         pos = start;
         return NULL;
@@ -272,7 +272,7 @@ UnicodeSet* TransliteratorIDParser::parseGlobalFilter(const UnicodeString& id, i
         }
     }
 
-    ICU_Utility::skipWhitespace(id, pos, TRUE);
+    ICU_Utility::skipWhitespace(id, pos, true);
 
     if (UnicodeSet::resemblesPattern(id, pos)) {
         ParsePosition ppos(pos);
@@ -352,7 +352,7 @@ U_CDECL_END
  * @param globalFilter OUTPUT parameter that receives a pointer to
  * a newly created global filter for this ID in this direction, or
  * NULL if there is none.
- * @return TRUE if the parse succeeds, that is, if the entire
+ * @return true if the parse succeeds, that is, if the entire
  * id is consumed without syntax error.
  */
 UBool TransliteratorIDParser::parseCompoundID(const UnicodeString& id, int32_t dir,
@@ -387,7 +387,7 @@ UBool TransliteratorIDParser::parseCompoundID(const UnicodeString& id, int32_t d
         filter = NULL;
     }
 
-    UBool sawDelimiter = TRUE;
+    UBool sawDelimiter = true;
     for (;;) {
         SingleID* single = parseSingleID(id, pos, dir, ec);
         if (single == NULL) {
@@ -402,7 +402,7 @@ UBool TransliteratorIDParser::parseCompoundID(const UnicodeString& id, int32_t d
             goto FAIL;
         }
         if (!ICU_Utility::parseChar(id, pos, ID_DELIM)) {
-            sawDelimiter = FALSE;
+            sawDelimiter = false;
             break;
         }
     }
@@ -439,20 +439,20 @@ UBool TransliteratorIDParser::parseCompoundID(const UnicodeString& id, int32_t d
     }
 
     // Trailing unparsed text is a syntax error
-    ICU_Utility::skipWhitespace(id, pos, TRUE);
+    ICU_Utility::skipWhitespace(id, pos, true);
     if (pos != id.length()) {
         goto FAIL;
     }
 
     list.setDeleter(save);
-    return TRUE;
+    return true;
 
  FAIL:
     list.removeAllElements();
     list.setDeleter(save);
     delete globalFilter;
     globalFilter = NULL;
-    return FALSE;
+    return false;
 }
 
 /**
@@ -505,7 +505,7 @@ void TransliteratorIDParser::instantiateList(UVector& list,
 
     // An empty list is equivalent to a NULL transliterator.
     if (tlist.size() == 0) {
-        t = createBasicInstance(UnicodeString(TRUE, ANY_NULL, 8), NULL);
+        t = createBasicInstance(UnicodeString(true, ANY_NULL, 8), NULL);
         if (t == NULL) {
             // Should never happen
             ec = U_INTERNAL_TRANSLITERATOR_ERROR;
@@ -559,7 +559,7 @@ void TransliteratorIDParser::IDtoSTV(const UnicodeString& id,
     if (var < 0) {
         var = id.length();
     }
-    isSourcePresent = FALSE;
+    isSourcePresent = false;
 
     if (sep < 0) {
         // Form: T/V or T (or /V)
@@ -569,7 +569,7 @@ void TransliteratorIDParser::IDtoSTV(const UnicodeString& id,
         // Form: S-T/V or S-T (or -T/V or -T)
         if (sep > 0) {
             id.extractBetween(0, sep, source);
-            isSourcePresent = TRUE;
+            isSourcePresent = true;
         }
         id.extractBetween(++sep, var, target);
         id.extractBetween(var, id.length(), variant);
@@ -577,7 +577,7 @@ void TransliteratorIDParser::IDtoSTV(const UnicodeString& id,
         // Form: (S/V-T or /V-T)
         if (var > 0) {
             id.extractBetween(0, var, source);
-            isSourcePresent = TRUE;
+            isSourcePresent = true;
         }
         id.extractBetween(var, sep++, variant);
         id.extractBetween(sep, id.length(), target);
@@ -613,7 +613,7 @@ void TransliteratorIDParser::STVtoID(const UnicodeString& source,
 
 /**
  * Register two targets as being inverses of one another.  For
- * example, calling registerSpecialInverse("NFC", "NFD", TRUE) causes
+ * example, calling registerSpecialInverse("NFC", "NFD", true) causes
  * Transliterator to form the following inverse relationships:
  *
  * <pre>NFC => NFD
@@ -640,7 +640,7 @@ void TransliteratorIDParser::STVtoID(const UnicodeString& source,
  * @param target the target against which to register the inverse
  * @param inverseTarget the inverse of target, that is
  * Any-target.getInverse() => Any-inverseTarget
- * @param bidirectional if TRUE, register the reverse relation
+ * @param bidirectional if true, register the reverse relation
  * as well, that is, Any-inverseTarget.getInverse() => Any-target
  */
 void TransliteratorIDParser::registerSpecialInverse(const UnicodeString& target,
@@ -652,9 +652,9 @@ void TransliteratorIDParser::registerSpecialInverse(const UnicodeString& target,
         return;
     }
 
-    // If target == inverseTarget then force bidirectional => FALSE
+    // If target == inverseTarget then force bidirectional => false
     if (bidirectional && 0==target.caseCompare(inverseTarget, U_FOLD_CASE_DEFAULT)) {
-        bidirectional = FALSE;
+        bidirectional = false;
     }
 
     Mutex lock(&LOCK);
@@ -688,12 +688,12 @@ void TransliteratorIDParser::registerSpecialInverse(const UnicodeString& target,
  * offset of the first character to parse in id.  On output,
  * pos is the offset after the last parsed character.  If the
  * parse failed, pos will be unchanged.
- * @param allowFilter2 if TRUE, a UnicodeSet pattern is allowed
+ * @param allowFilter2 if true, a UnicodeSet pattern is allowed
  * at any location between specs or delimiters, and is returned
  * as the fifth string in the array.
  * @return a Specs object, or NULL if the parse failed.  If
  * neither source nor target was seen in the parsed id, then the
- * parse fails.  If allowFilter is TRUE, then the parsed filter
+ * parse fails.  If allowFilter is true, then the parsed filter
  * pattern is returned in the Specs object, otherwise the returned
  * filter reference is NULL.  If the parse fails for any reason
  * NULL is returned.
@@ -714,7 +714,7 @@ TransliteratorIDParser::parseFilterID(const UnicodeString& id, int32_t& pos,
     // pass: a filter, a delimiter character (either '-' or '/'),
     // or a spec (source, target, or variant).
     for (;;) {
-        ICU_Utility::skipWhitespace(id, pos, TRUE);
+        ICU_Utility::skipWhitespace(id, pos, true);
         if (pos == id.length()) {
             break;
         }
@@ -792,10 +792,10 @@ TransliteratorIDParser::parseFilterID(const UnicodeString& id, int32_t& pos,
     }
 
     // Empty source or target defaults to ANY
-    UBool sawSource = TRUE;
+    UBool sawSource = true;
     if (source.length() == 0) {
         source.setTo(ANY, 3);
-        sawSource = FALSE;
+        sawSource = false;
     }
     if (target.length() == 0) {
         target.setTo(ANY, 3);
@@ -878,7 +878,7 @@ TransliteratorIDParser::specsToSpecialInverse(const Specs& specs, UErrorCode &st
         }
         buf.append(*inverseTarget);
 
-        UnicodeString basicID(TRUE, ANY, 3);
+        UnicodeString basicID(true, ANY, 3);
         basicID.append(TARGET_SEP).append(*inverseTarget);
 
         if (specs.variant.length() != 0) {
@@ -906,7 +906,7 @@ void U_CALLCONV TransliteratorIDParser::init(UErrorCode &status) {
     U_ASSERT(SPECIAL_INVERSES == NULL);
     ucln_i18n_registerCleanup(UCLN_I18N_TRANSLITERATOR, utrans_transliterator_cleanup);
 
-    SPECIAL_INVERSES = new Hashtable(TRUE, status);
+    SPECIAL_INVERSES = new Hashtable(true, status);
     if (SPECIAL_INVERSES == NULL) {
     	status = U_MEMORY_ALLOCATION_ERROR;
     	return;
diff --git a/deps/icu-small/source/i18n/tzfmt.cpp b/deps/icu-small/source/i18n/tzfmt.cpp
index 9d046c30c8..2199986f61 100644
--- a/deps/icu-small/source/i18n/tzfmt.cpp
+++ b/deps/icu-small/source/i18n/tzfmt.cpp
@@ -145,10 +145,10 @@ static const int32_t ALL_GENERIC_NAME_TYPES = UTZGNM_LOCATION | UTZGNM_LONG | UT
 
 // Time Zone ID/Short ID trie
 static TextTrieMap *gZoneIdTrie = NULL;
-static icu::UInitOnce gZoneIdTrieInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gZoneIdTrieInitOnce {};
 
 static TextTrieMap *gShortZoneIdTrie = NULL;
-static icu::UInitOnce gShortZoneIdTrieInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gShortZoneIdTrieInitOnce {};
 
 static UMutex gLock;
 
@@ -170,7 +170,7 @@ static UBool U_CALLCONV tzfmt_cleanup(void)
     gShortZoneIdTrie = NULL;
     gShortZoneIdTrieInitOnce.reset();
 
-    return TRUE;
+    return true;
 }
 U_CDECL_END
 
@@ -365,7 +365,7 @@ TimeZoneFormat::TimeZoneFormat(const Locale& locale, UErrorCode& status)
         }
         resStr = ures_getStringByKeyWithFallback(zoneStringsArray, gGmtZeroFormatTag, &len, &status);
         if (len > 0) {
-            fGMTZeroFormat.setTo(TRUE, resStr, len);
+            fGMTZeroFormat.setTo(true, resStr, len);
         }
         resStr = ures_getStringByKeyWithFallback(zoneStringsArray, gHourFormatTag, &len, &status);
         if (len > 0) {
@@ -378,36 +378,36 @@ TimeZoneFormat::TimeZoneFormat(const Locale& locale, UErrorCode& status)
     if (gmtPattern == NULL) {
         gmtPattern = DEFAULT_GMT_PATTERN;
     }
-    initGMTPattern(UnicodeString(TRUE, gmtPattern, -1), status);
+    initGMTPattern(UnicodeString(true, gmtPattern, -1), status);
 
-    UBool useDefaultOffsetPatterns = TRUE;
+    UBool useDefaultOffsetPatterns = true;
     if (hourFormats) {
         UChar *sep = u_strchr(hourFormats, (UChar)0x003B /* ';' */);
         if (sep != NULL) {
             UErrorCode tmpStatus = U_ZERO_ERROR;
-            fGMTOffsetPatterns[UTZFMT_PAT_POSITIVE_HM].setTo(FALSE, hourFormats, (int32_t)(sep - hourFormats));
-            fGMTOffsetPatterns[UTZFMT_PAT_NEGATIVE_HM].setTo(TRUE, sep + 1, -1);
+            fGMTOffsetPatterns[UTZFMT_PAT_POSITIVE_HM].setTo(false, hourFormats, (int32_t)(sep - hourFormats));
+            fGMTOffsetPatterns[UTZFMT_PAT_NEGATIVE_HM].setTo(true, sep + 1, -1);
             expandOffsetPattern(fGMTOffsetPatterns[UTZFMT_PAT_POSITIVE_HM], fGMTOffsetPatterns[UTZFMT_PAT_POSITIVE_HMS], tmpStatus);
             expandOffsetPattern(fGMTOffsetPatterns[UTZFMT_PAT_NEGATIVE_HM], fGMTOffsetPatterns[UTZFMT_PAT_NEGATIVE_HMS], tmpStatus);
             truncateOffsetPattern(fGMTOffsetPatterns[UTZFMT_PAT_POSITIVE_HM], fGMTOffsetPatterns[UTZFMT_PAT_POSITIVE_H], tmpStatus);
             truncateOffsetPattern(fGMTOffsetPatterns[UTZFMT_PAT_NEGATIVE_HM], fGMTOffsetPatterns[UTZFMT_PAT_NEGATIVE_H], tmpStatus);
             if (U_SUCCESS(tmpStatus)) {
-                useDefaultOffsetPatterns = FALSE;
+                useDefaultOffsetPatterns = false;
             }
         }
     }
     if (useDefaultOffsetPatterns) {
-        fGMTOffsetPatterns[UTZFMT_PAT_POSITIVE_H].setTo(TRUE, DEFAULT_GMT_POSITIVE_H, -1);
-        fGMTOffsetPatterns[UTZFMT_PAT_POSITIVE_HM].setTo(TRUE, DEFAULT_GMT_POSITIVE_HM, -1);
-        fGMTOffsetPatterns[UTZFMT_PAT_POSITIVE_HMS].setTo(TRUE, DEFAULT_GMT_POSITIVE_HMS, -1);
-        fGMTOffsetPatterns[UTZFMT_PAT_NEGATIVE_H].setTo(TRUE, DEFAULT_GMT_NEGATIVE_H, -1);
-        fGMTOffsetPatterns[UTZFMT_PAT_NEGATIVE_HM].setTo(TRUE, DEFAULT_GMT_NEGATIVE_HM, -1);
-        fGMTOffsetPatterns[UTZFMT_PAT_NEGATIVE_HMS].setTo(TRUE, DEFAULT_GMT_NEGATIVE_HMS, -1);
+        fGMTOffsetPatterns[UTZFMT_PAT_POSITIVE_H].setTo(true, DEFAULT_GMT_POSITIVE_H, -1);
+        fGMTOffsetPatterns[UTZFMT_PAT_POSITIVE_HM].setTo(true, DEFAULT_GMT_POSITIVE_HM, -1);
+        fGMTOffsetPatterns[UTZFMT_PAT_POSITIVE_HMS].setTo(true, DEFAULT_GMT_POSITIVE_HMS, -1);
+        fGMTOffsetPatterns[UTZFMT_PAT_NEGATIVE_H].setTo(true, DEFAULT_GMT_NEGATIVE_H, -1);
+        fGMTOffsetPatterns[UTZFMT_PAT_NEGATIVE_HM].setTo(true, DEFAULT_GMT_NEGATIVE_HM, -1);
+        fGMTOffsetPatterns[UTZFMT_PAT_NEGATIVE_HMS].setTo(true, DEFAULT_GMT_NEGATIVE_HMS, -1);
     }
     initGMTOffsetPatterns(status);
 
     NumberingSystem* ns = NumberingSystem::createInstance(locale, status);
-    UBool useDefDigits = TRUE;
+    UBool useDefDigits = true;
     if (ns && !ns->isAlgorithmic()) {
         UnicodeString digits = ns->getDescription();
         useDefDigits = !toCodePoints(digits, fGMTOffsetDigits, 10);
@@ -657,7 +657,7 @@ TimeZoneFormat::format(UTimeZoneFormatStyle style, const TimeZone& tz, UDate dat
         *timeType = UTZFMT_TIME_TYPE_UNKNOWN;
     }
 
-    UBool noOffsetFormatFallback = FALSE;
+    UBool noOffsetFormatFallback = false;
 
     switch (style) {
     case UTZFMT_STYLE_GENERIC_LOCATION:
@@ -678,7 +678,7 @@ TimeZoneFormat::format(UTimeZoneFormatStyle style, const TimeZone& tz, UDate dat
 
     case UTZFMT_STYLE_ZONE_ID:
         tz.getID(name);
-        noOffsetFormatFallback = TRUE;
+        noOffsetFormatFallback = true;
         break;
     case UTZFMT_STYLE_ZONE_ID_SHORT:
         {
@@ -688,12 +688,12 @@ TimeZoneFormat::format(UTimeZoneFormatStyle style, const TimeZone& tz, UDate dat
             }
             name.setTo(shortID, -1);
         }
-        noOffsetFormatFallback = TRUE;
+        noOffsetFormatFallback = true;
         break;
 
     case UTZFMT_STYLE_EXEMPLAR_LOCATION:
         formatExemplarLocation(tz, name);
-        noOffsetFormatFallback = TRUE;
+        noOffsetFormatFallback = true;
         break;
 
     default:
@@ -704,7 +704,7 @@ TimeZoneFormat::format(UTimeZoneFormatStyle style, const TimeZone& tz, UDate dat
     if (name.isEmpty() && !noOffsetFormatFallback) {
         UErrorCode status = U_ZERO_ERROR;
         int32_t rawOffset, dstOffset;
-        tz.getOffset(date, FALSE, rawOffset, dstOffset, status);
+        tz.getOffset(date, false, rawOffset, dstOffset, status);
         int32_t offset = rawOffset + dstOffset;
         if (U_SUCCESS(status)) {
             switch (style) {
@@ -722,43 +722,43 @@ TimeZoneFormat::format(UTimeZoneFormatStyle style, const TimeZone& tz, UDate dat
                 break;
 
             case UTZFMT_STYLE_ISO_BASIC_SHORT:
-                formatOffsetISO8601Basic(offset, TRUE, TRUE, TRUE, name, status);
+                formatOffsetISO8601Basic(offset, true, true, true, name, status);
                 break;
 
             case UTZFMT_STYLE_ISO_BASIC_LOCAL_SHORT:
-                formatOffsetISO8601Basic(offset, FALSE, TRUE, TRUE, name, status);
+                formatOffsetISO8601Basic(offset, false, true, true, name, status);
                 break;
 
             case UTZFMT_STYLE_ISO_BASIC_FIXED:
-                formatOffsetISO8601Basic(offset, TRUE, FALSE, TRUE, name, status);
+                formatOffsetISO8601Basic(offset, true, false, true, name, status);
                 break;
 
             case UTZFMT_STYLE_ISO_BASIC_LOCAL_FIXED:
-                formatOffsetISO8601Basic(offset, FALSE, FALSE, TRUE, name, status);
+                formatOffsetISO8601Basic(offset, false, false, true, name, status);
                 break;
 
             case UTZFMT_STYLE_ISO_EXTENDED_FIXED:
-                formatOffsetISO8601Extended(offset, TRUE, FALSE, TRUE, name, status);
+                formatOffsetISO8601Extended(offset, true, false, true, name, status);
                 break;
 
             case UTZFMT_STYLE_ISO_EXTENDED_LOCAL_FIXED:
-                formatOffsetISO8601Extended(offset, FALSE, FALSE, TRUE, name, status);
+                formatOffsetISO8601Extended(offset, false, false, true, name, status);
                 break;
 
             case UTZFMT_STYLE_ISO_BASIC_FULL:
-                formatOffsetISO8601Basic(offset, TRUE, FALSE, FALSE, name, status);
+                formatOffsetISO8601Basic(offset, true, false, false, name, status);
                 break;
 
             case UTZFMT_STYLE_ISO_BASIC_LOCAL_FULL:
-                formatOffsetISO8601Basic(offset, FALSE, FALSE, FALSE, name, status);
+                formatOffsetISO8601Basic(offset, false, false, false, name, status);
                 break;
 
             case UTZFMT_STYLE_ISO_EXTENDED_FULL:
-                formatOffsetISO8601Extended(offset, TRUE, FALSE, FALSE, name, status);
+                formatOffsetISO8601Extended(offset, true, false, false, name, status);
                 break;
 
             case UTZFMT_STYLE_ISO_EXTENDED_LOCAL_FULL:
-                formatOffsetISO8601Extended(offset, FALSE, FALSE, FALSE, name, status);
+                formatOffsetISO8601Extended(offset, false, false, false, name, status);
                 break;
 
             default:
@@ -794,7 +794,7 @@ TimeZoneFormat::format(const Formattable& obj, UnicodeString& appendTo,
         }
         if (tz != NULL) {
             int32_t rawOffset, dstOffset;
-            tz->getOffset(date, FALSE, rawOffset, dstOffset, status);
+            tz->getOffset(date, false, rawOffset, dstOffset, status);
             UChar buf[ZONE_NAME_U16_MAX];
             UnicodeString result(buf, 0, UPRV_LENGTHOF(buf));
             formatOffsetLocalizedGMT(rawOffset + dstOffset, result, status);
@@ -841,7 +841,7 @@ TimeZoneFormat::parse(UTimeZoneFormatStyle style, const UnicodeString& text, Par
 
     // Try localized GMT format first if necessary
     if (fallbackLocalizedGMT || fallbackShortLocalizedGMT) {
-        UBool hasDigitOffset = FALSE;
+        UBool hasDigitOffset = false;
         offset = parseOffsetLocalizedGMT(text, tmpPos, fallbackShortLocalizedGMT, &hasDigitOffset);
         if (tmpPos.getErrorIndex() == -1) {
             // Even when the input text was successfully parsed as a localized GMT format text,
@@ -931,8 +931,8 @@ TimeZoneFormat::parse(UTimeZoneFormatStyle style, const UnicodeString& text, Par
             tmpPos.setErrorIndex(-1);
 
             // Exclude the case of UTC Indicator "Z" here
-            UBool hasDigitOffset = FALSE;
-            offset = parseOffsetISO8601(text, tmpPos, FALSE, &hasDigitOffset);
+            UBool hasDigitOffset = false;
+            offset = parseOffsetISO8601(text, tmpPos, false, &hasDigitOffset);
             if (tmpPos.getErrorIndex() == -1 && hasDigitOffset) {
                 pos.setIndex(tmpPos.getIndex());
                 return createTimeZoneForOffset(offset);
@@ -1125,8 +1125,8 @@ TimeZoneFormat::parse(UTimeZoneFormatStyle style, const UnicodeString& text, Par
         tmpPos.setIndex(startIdx);
         tmpPos.setErrorIndex(-1);
 
-        UBool hasDigitOffset = FALSE;
-        offset = parseOffsetISO8601(text, tmpPos, FALSE, &hasDigitOffset);
+        UBool hasDigitOffset = false;
+        offset = parseOffsetISO8601(text, tmpPos, false, &hasDigitOffset);
         if (tmpPos.getErrorIndex() == -1) {
             if (tmpPos.getIndex() == maxPos || hasDigitOffset) {
                 pos.setIndex(tmpPos.getIndex());
@@ -1151,8 +1151,8 @@ TimeZoneFormat::parse(UTimeZoneFormatStyle style, const UnicodeString& text, Par
         tmpPos.setIndex(startIdx);
         tmpPos.setErrorIndex(-1);
 
-        UBool hasDigitOffset = FALSE;
-        offset = parseOffsetLocalizedGMT(text, tmpPos, FALSE, &hasDigitOffset);
+        UBool hasDigitOffset = false;
+        offset = parseOffsetLocalizedGMT(text, tmpPos, false, &hasDigitOffset);
         if (tmpPos.getErrorIndex() == -1) {
             if (tmpPos.getIndex() == maxPos || hasDigitOffset) {
                 pos.setIndex(tmpPos.getIndex());
@@ -1173,8 +1173,8 @@ TimeZoneFormat::parse(UTimeZoneFormatStyle style, const UnicodeString& text, Par
         tmpPos.setIndex(startIdx);
         tmpPos.setErrorIndex(-1);
 
-        UBool hasDigitOffset = FALSE;
-        offset = parseOffsetLocalizedGMT(text, tmpPos, TRUE, &hasDigitOffset);
+        UBool hasDigitOffset = false;
+        offset = parseOffsetLocalizedGMT(text, tmpPos, true, &hasDigitOffset);
         if (tmpPos.getErrorIndex() == -1) {
             if (tmpPos.getIndex() == maxPos || hasDigitOffset) {
                 pos.setIndex(tmpPos.getIndex());
@@ -1348,7 +1348,7 @@ TimeZoneFormat::formatGeneric(const TimeZone& tz, int32_t genType, UDate date, U
             name.setToBogus();
             return name;
         }
-        return gnames->getGenericLocationName(UnicodeString(TRUE, canonicalID, -1), name);
+        return gnames->getGenericLocationName(UnicodeString(true, canonicalID, -1), name);
     }
     return gnames->getDisplayName(tz, (UTimeZoneGenericNameType)genType, date, name);
 }
@@ -1371,9 +1371,9 @@ TimeZoneFormat::formatSpecific(const TimeZone& tz, UTimeZoneNameType stdType, UT
     }
 
     if (isDaylight) {
-        fTimeZoneNames->getDisplayName(UnicodeString(TRUE, canonicalID, -1), dstType, date, name);
+        fTimeZoneNames->getDisplayName(UnicodeString(true, canonicalID, -1), dstType, date, name);
     } else {
-        fTimeZoneNames->getDisplayName(UnicodeString(TRUE, canonicalID, -1), stdType, date, name);
+        fTimeZoneNames->getDisplayName(UnicodeString(true, canonicalID, -1), stdType, date, name);
     }
 
     if (timeType && !name.isEmpty()) {
@@ -1426,13 +1426,13 @@ TimeZoneFormat::formatExemplarLocation(const TimeZone& tz, UnicodeString& name)
     const UChar* canonicalID = ZoneMeta::getCanonicalCLDRID(tz);
 
     if (canonicalID) {
-        fTimeZoneNames->getExemplarLocationName(UnicodeString(TRUE, canonicalID, -1), location);
+        fTimeZoneNames->getExemplarLocationName(UnicodeString(true, canonicalID, -1), location);
     }
     if (location.length() > 0) {
         name.setTo(location);
     } else {
         // Use "unknown" location
-        fTimeZoneNames->getExemplarLocationName(UnicodeString(TRUE, UNKNOWN_ZONE_ID, -1), location);
+        fTimeZoneNames->getExemplarLocationName(UnicodeString(true, UNKNOWN_ZONE_ID, -1), location);
         if (location.length() > 0) {
             name.setTo(location);
         } else {
@@ -1450,38 +1450,38 @@ TimeZoneFormat::formatExemplarLocation(const TimeZone& tz, UnicodeString& name)
 UnicodeString&
 TimeZoneFormat::formatOffsetISO8601Basic(int32_t offset, UBool useUtcIndicator, UBool isShort, UBool ignoreSeconds,
         UnicodeString& result, UErrorCode& status) const {
-    return formatOffsetISO8601(offset, TRUE, useUtcIndicator, isShort, ignoreSeconds, result, status);
+    return formatOffsetISO8601(offset, true, useUtcIndicator, isShort, ignoreSeconds, result, status);
 }
 
 UnicodeString&
 TimeZoneFormat::formatOffsetISO8601Extended(int32_t offset, UBool useUtcIndicator, UBool isShort, UBool ignoreSeconds,
         UnicodeString& result, UErrorCode& status) const {
-    return formatOffsetISO8601(offset, FALSE, useUtcIndicator, isShort, ignoreSeconds, result, status);
+    return formatOffsetISO8601(offset, false, useUtcIndicator, isShort, ignoreSeconds, result, status);
 }
 
 UnicodeString&
 TimeZoneFormat::formatOffsetLocalizedGMT(int32_t offset, UnicodeString& result, UErrorCode& status) const {
-    return formatOffsetLocalizedGMT(offset, FALSE, result, status);
+    return formatOffsetLocalizedGMT(offset, false, result, status);
 }
 
 UnicodeString&
 TimeZoneFormat::formatOffsetShortLocalizedGMT(int32_t offset, UnicodeString& result, UErrorCode& status) const {
-    return formatOffsetLocalizedGMT(offset, TRUE, result, status);
+    return formatOffsetLocalizedGMT(offset, true, result, status);
 }
 
 int32_t
 TimeZoneFormat::parseOffsetISO8601(const UnicodeString& text, ParsePosition& pos) const {
-    return parseOffsetISO8601(text, pos, FALSE);
+    return parseOffsetISO8601(text, pos, false);
 }
 
 int32_t
 TimeZoneFormat::parseOffsetLocalizedGMT(const UnicodeString& text, ParsePosition& pos) const {
-    return parseOffsetLocalizedGMT(text, pos, FALSE, NULL);
+    return parseOffsetLocalizedGMT(text, pos, false, NULL);
 }
 
 int32_t
 TimeZoneFormat::parseOffsetShortLocalizedGMT(const UnicodeString& text, ParsePosition& pos) const {
-    return parseOffsetLocalizedGMT(text, pos, TRUE, NULL);
+    return parseOffsetLocalizedGMT(text, pos, true, NULL);
 }
 
 // ------------------------------------------------------------------
@@ -1572,10 +1572,10 @@ TimeZoneFormat::formatOffsetLocalizedGMT(int32_t offset, UBool isShort, UnicodeS
         return result;
     }
 
-    UBool positive = TRUE;
+    UBool positive = true;
     if (offset < 0) {
         offset = -offset;
-        positive = FALSE;
+        positive = false;
     }
 
     int32_t offsetH = offset / MILLIS_PER_HOUR;
@@ -1640,7 +1640,7 @@ TimeZoneFormat::formatOffsetLocalizedGMT(int32_t offset, UBool isShort, UnicodeS
 int32_t
 TimeZoneFormat::parseOffsetISO8601(const UnicodeString& text, ParsePosition& pos, UBool extendedOnly, UBool* hasDigitOffset /* = NULL */) const {
     if (hasDigitOffset) {
-        *hasDigitOffset = FALSE;
+        *hasDigitOffset = false;
     }
     int32_t start = pos.getIndex();
     if (start >= text.length()) {
@@ -1672,7 +1672,7 @@ TimeZoneFormat::parseOffsetISO8601(const UnicodeString& text, ParsePosition& pos
         // as basic format. For example, "0230" can be parsed as offset 2:00 (only first digits are valid for
         // extended format), but it can be parsed as offset 2:30 with basic format. We use longer result.
         ParsePosition posBasic(start + 1);
-        int32_t tmpOffset = parseAbuttingAsciiOffsetFields(text, posBasic, FIELDS_H, FIELDS_HMS, FALSE);
+        int32_t tmpOffset = parseAbuttingAsciiOffsetFields(text, posBasic, FIELDS_H, FIELDS_HMS, false);
         if (posBasic.getErrorIndex() == -1 && posBasic.getIndex() > posOffset.getIndex()) {
             offset = tmpOffset;
             posOffset.setIndex(posBasic.getIndex());
@@ -1686,7 +1686,7 @@ TimeZoneFormat::parseOffsetISO8601(const UnicodeString& text, ParsePosition& pos
 
     pos.setIndex(posOffset.getIndex());
     if (hasDigitOffset) {
-        *hasDigitOffset = TRUE;
+        *hasDigitOffset = true;
     }
     return sign * offset;
 }
@@ -1698,7 +1698,7 @@ TimeZoneFormat::parseOffsetLocalizedGMT(const UnicodeString& text, ParsePosition
     int32_t parsedLength = 0;
 
     if (hasDigitOffset) {
-        *hasDigitOffset = FALSE;
+        *hasDigitOffset = false;
     }
 
     offset = parseOffsetLocalizedGMTPattern(text, start, isShort, parsedLength);
@@ -1715,7 +1715,7 @@ TimeZoneFormat::parseOffsetLocalizedGMT(const UnicodeString& text, ParsePosition
 
     if (parsedLength > 0) {
         if (hasDigitOffset) {
-            *hasDigitOffset = TRUE;
+            *hasDigitOffset = true;
         }
         pos.setIndex(start + parsedLength);
         return offset;
@@ -1725,7 +1725,7 @@ TimeZoneFormat::parseOffsetLocalizedGMT(const UnicodeString& text, ParsePosition
     offset = parseOffsetDefaultLocalizedGMT(text, start, parsedLength);
     if (parsedLength > 0) {
         if (hasDigitOffset) {
-            *hasDigitOffset = TRUE;
+            *hasDigitOffset = true;
         }
         pos.setIndex(start + parsedLength);
         return offset;
@@ -1756,7 +1756,7 @@ int32_t
 TimeZoneFormat::parseOffsetLocalizedGMTPattern(const UnicodeString& text, int32_t start, UBool /*isShort*/, int32_t& parsedLen) const {
     int32_t idx = start;
     int32_t offset = 0;
-    UBool parsed = FALSE;
+    UBool parsed = false;
 
     do {
         // Prefix part
@@ -1768,7 +1768,7 @@ TimeZoneFormat::parseOffsetLocalizedGMTPattern(const UnicodeString& text, int32_
         idx += len;
 
         // Offset part
-        offset = parseOffsetFields(text, idx, FALSE, len);
+        offset = parseOffsetFields(text, idx, false, len);
         if (len == 0) {
             // offset field match failed
             break;
@@ -1781,8 +1781,8 @@ TimeZoneFormat::parseOffsetLocalizedGMTPattern(const UnicodeString& text, int32_
             break;
         }
         idx += len;
-        parsed = TRUE;
-    } while (FALSE);
+        parsed = true;
+    } while (false);
 
     parsedLen = parsed ? idx - start : 0;
     return offset;
@@ -1804,7 +1804,7 @@ TimeZoneFormat::parseOffsetFields(const UnicodeString& text, int32_t start, UBoo
         UVector* items = fGMTOffsetPatternItems[gmtPatType];
         U_ASSERT(items != NULL);
 
-        outLen = parseOffsetFieldsWithPattern(text, start, items, FALSE, offsetH, offsetM, offsetS);
+        outLen = parseOffsetFieldsWithPattern(text, start, items, false, offsetH, offsetM, offsetS);
         if (outLen > 0) {
             sign = (gmtPatType == UTZFMT_PAT_POSITIVE_H || gmtPatType == UTZFMT_PAT_POSITIVE_HM || gmtPatType == UTZFMT_PAT_POSITIVE_HMS) ?
                 1 : -1;
@@ -1829,7 +1829,7 @@ TimeZoneFormat::parseOffsetFields(const UnicodeString& text, int32_t start, UBoo
             U_ASSERT(items != NULL);
 
             // forcing parse to use single hour digit
-            tmpLen = parseOffsetFieldsWithPattern(text, start, items, TRUE, tmpH, tmpM, tmpS);
+            tmpLen = parseOffsetFieldsWithPattern(text, start, items, true, tmpH, tmpM, tmpS);
             if (tmpLen > 0) {
                 tmpSign = (gmtPatType == UTZFMT_PAT_POSITIVE_H || gmtPatType == UTZFMT_PAT_POSITIVE_HM || gmtPatType == UTZFMT_PAT_POSITIVE_HMS) ?
                     1 : -1;
@@ -1857,7 +1857,7 @@ TimeZoneFormat::parseOffsetFields(const UnicodeString& text, int32_t start, UBoo
 int32_t
 TimeZoneFormat::parseOffsetFieldsWithPattern(const UnicodeString& text, int32_t start,
         UVector* patternItems, UBool forceSingleHourDigit, int32_t& hour, int32_t& min, int32_t& sec) const {
-    UBool failed = FALSE;
+    UBool failed = false;
     int32_t offsetH, offsetM, offsetS;
     offsetH = offsetM = offsetS = 0;
     int32_t idx = start;
@@ -1891,7 +1891,7 @@ TimeZoneFormat::parseOffsetFieldsWithPattern(const UnicodeString& text, int32_t
                 }
             }
             if (text.caseCompare(idx, len, patStr, 0) != 0) {
-                failed = TRUE;
+                failed = true;
                 break;
             }
             idx += len;
@@ -1906,7 +1906,7 @@ TimeZoneFormat::parseOffsetFieldsWithPattern(const UnicodeString& text, int32_t
             }
 
             if (len == 0) {
-                failed = TRUE;
+                failed = true;
                 break;
             }
             idx += len;
@@ -2092,7 +2092,7 @@ TimeZoneFormat::parseDefaultOffsetFields(const UnicodeString& text, int32_t star
                 idx += (1 + len);
             }
         }
-    } while (FALSE);
+    } while (false);
 
     if (idx == start) {
         return 0;
@@ -2240,7 +2240,7 @@ TimeZoneFormat::parseAbuttingAsciiOffsetFields(const UnicodeString& text, ParseP
     }
 
     int32_t hour = 0, min = 0, sec = 0;
-    UBool bParsed = FALSE;
+    UBool bParsed = false;
     while (numDigits >= minDigits) {
         switch (numDigits) {
         case 1: //H
@@ -2409,20 +2409,20 @@ TimeZoneFormat::unquote(const UnicodeString& pattern, UnicodeString& result) {
         return result;
     }
     result.remove();
-    UBool isPrevQuote = FALSE;
-    UBool inQuote = FALSE;
+    UBool isPrevQuote = false;
+    UBool inQuote = false;
     for (int32_t i = 0; i < pattern.length(); i++) {
         UChar c = pattern.charAt(i);
         if (c == SINGLEQUOTE) {
             if (isPrevQuote) {
                 result.append(c);
-                isPrevQuote = FALSE;
+                isPrevQuote = false;
             } else {
-                isPrevQuote = TRUE;
+                isPrevQuote = true;
             }
             inQuote = !inQuote;
         } else {
-            isPrevQuote = FALSE;
+            isPrevQuote = false;
             result.append(c);
         }
     }
@@ -2441,8 +2441,8 @@ TimeZoneFormat::parseOffsetPattern(const UnicodeString& pattern, OffsetFields re
     }
 
     int32_t checkBits = 0;
-    UBool isPrevQuote = FALSE;
-    UBool inQuote = FALSE;
+    UBool isPrevQuote = false;
+    UBool inQuote = false;
     UChar textBuf[32];
     UnicodeString text(textBuf, 0, UPRV_LENGTHOF(textBuf));
     GMTOffsetField::FieldType itemType = GMTOffsetField::TEXT;
@@ -2453,9 +2453,9 @@ TimeZoneFormat::parseOffsetPattern(const UnicodeString& pattern, OffsetFields re
         if (ch == SINGLEQUOTE) {
             if (isPrevQuote) {
                 text.append(SINGLEQUOTE);
-                isPrevQuote = FALSE;
+                isPrevQuote = false;
             } else {
-                isPrevQuote = TRUE;
+                isPrevQuote = true;
                 if (itemType != GMTOffsetField::TEXT) {
                     if (GMTOffsetField::isValid(itemType, itemLength)) {
                         GMTOffsetField* fld = GMTOffsetField::createTimeField(itemType, static_cast<uint8_t>(itemLength), status);
@@ -2472,7 +2472,7 @@ TimeZoneFormat::parseOffsetPattern(const UnicodeString& pattern, OffsetFields re
             }
             inQuote = !inQuote;
         } else {
-            isPrevQuote = FALSE;
+            isPrevQuote = false;
             if (inQuote) {
                 text.append(ch);
             } else {
@@ -2647,19 +2647,19 @@ TimeZoneFormat::initGMTOffsetPatterns(UErrorCode& status) {
 
 void
 TimeZoneFormat::checkAbuttingHoursAndMinutes() {
-    fAbuttingOffsetHoursAndMinutes= FALSE;
+    fAbuttingOffsetHoursAndMinutes= false;
     for (int32_t type = 0; type < UTZFMT_PAT_COUNT; type++) {
-        UBool afterH = FALSE;
+        UBool afterH = false;
         UVector *items = fGMTOffsetPatternItems[type];
         for (int32_t i = 0; i < items->size(); i++) {
             const GMTOffsetField* item = (GMTOffsetField*)items->elementAt(i);
             GMTOffsetField::FieldType fieldType = item->getType();
             if (fieldType != GMTOffsetField::TEXT) {
                 if (afterH) {
-                    fAbuttingOffsetHoursAndMinutes = TRUE;
+                    fAbuttingOffsetHoursAndMinutes = true;
                     break;
                 } else if (fieldType == GMTOffsetField::HOUR) {
-                    afterH = TRUE;
+                    afterH = true;
                 }
             } else if (afterH) {
                 break;
@@ -2675,7 +2675,7 @@ UBool
 TimeZoneFormat::toCodePoints(const UnicodeString& str, UChar32* codeArray, int32_t size) {
     int32_t count = str.countChar32();
     if (count != size) {
-        return FALSE;
+        return false;
     }
 
     for (int32_t idx = 0, start = 0; idx < size; idx++) {
@@ -2683,14 +2683,14 @@ TimeZoneFormat::toCodePoints(const UnicodeString& str, UChar32* codeArray, int32
         start = str.moveIndex32(start, 1);
     }
 
-    return TRUE;
+    return true;
 }
 
 TimeZone*
 TimeZoneFormat::createTimeZoneForOffset(int32_t offset) const {
     if (offset == 0) {
         // when offset is 0, we should use "Etc/GMT"
-        return TimeZone::createTimeZone(UnicodeString(TRUE, TZID_GMT, -1));
+        return TimeZone::createTimeZone(UnicodeString(true, TZID_GMT, -1));
     }
     return ZoneMeta::createCustomTimeZone(offset);
 }
@@ -2747,7 +2747,7 @@ ZoneIdMatchHandler::~ZoneIdMatchHandler() {
 UBool
 ZoneIdMatchHandler::handleMatch(int32_t matchLength, const CharacterNode *node, UErrorCode &status) {
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
     if (node->hasValues()) {
         const UChar* id = (const UChar*)node->getValue(0);
@@ -2758,7 +2758,7 @@ ZoneIdMatchHandler::handleMatch(int32_t matchLength, const CharacterNode *node,
             }
         }
     }
-    return TRUE;
+    return true;
 }
 
 const UChar*
@@ -2775,7 +2775,7 @@ ZoneIdMatchHandler::getMatchLen() {
 static void U_CALLCONV initZoneIdTrie(UErrorCode &status) {
     U_ASSERT(gZoneIdTrie == NULL);
     ucln_i18n_registerCleanup(UCLN_I18N_TIMEZONEFORMAT, tzfmt_cleanup);
-    gZoneIdTrie = new TextTrieMap(TRUE, NULL);    // No deleter, because values are pooled by ZoneMeta
+    gZoneIdTrie = new TextTrieMap(true, NULL);    // No deleter, because values are pooled by ZoneMeta
     if (gZoneIdTrie == NULL) {
         status = U_MEMORY_ALLOCATION_ERROR;
         return;
@@ -2826,7 +2826,7 @@ static void U_CALLCONV initShortZoneIdTrie(UErrorCode &status) {
     ucln_i18n_registerCleanup(UCLN_I18N_TIMEZONEFORMAT, tzfmt_cleanup);
     StringEnumeration *tzenum = TimeZone::createTimeZoneIDEnumeration(UCAL_ZONE_TYPE_CANONICAL, NULL, NULL, status);
     if (U_SUCCESS(status)) {
-        gShortZoneIdTrie = new TextTrieMap(TRUE, NULL);    // No deleter, because values are pooled by ZoneMeta
+        gShortZoneIdTrie = new TextTrieMap(true, NULL);    // No deleter, because values are pooled by ZoneMeta
         if (gShortZoneIdTrie == NULL) {
             status = U_MEMORY_ALLOCATION_ERROR;
         } else {
diff --git a/deps/icu-small/source/i18n/tzgnames.cpp b/deps/icu-small/source/i18n/tzgnames.cpp
index d5ee45ced7..e96dfd2b2f 100644
--- a/deps/icu-small/source/i18n/tzgnames.cpp
+++ b/deps/icu-small/source/i18n/tzgnames.cpp
@@ -87,10 +87,10 @@ comparePartialLocationKey(const UHashTok key1, const UHashTok key2) {
     PartialLocationKey *p2 = (PartialLocationKey *)key2.pointer;
 
     if (p1 == p2) {
-        return TRUE;
+        return true;
     }
     if (p1 == NULL || p2 == NULL) {
-        return FALSE;
+        return false;
     }
     // We just check identity of tzID/mzID
     return (p1->tzID == p2->tzID && p1->mzID == p2->mzID && p1->isLong == p2->isLong);
@@ -180,7 +180,7 @@ UnicodeString&
 TimeZoneGenericNameMatchInfo::getTimeZoneID(int32_t index, UnicodeString& tzID) const {
     GMatchInfo *minfo = (GMatchInfo *)fMatches->elementAt(index);
     if (minfo != NULL && minfo->gnameInfo->tzID != NULL) {
-        tzID.setTo(TRUE, minfo->gnameInfo->tzID, -1);
+        tzID.setTo(true, minfo->gnameInfo->tzID, -1);
     } else {
         tzID.setToBogus();
     }
@@ -217,7 +217,7 @@ GNameSearchHandler::~GNameSearchHandler() {
 UBool
 GNameSearchHandler::handleMatch(int32_t matchLength, const CharacterNode *node, UErrorCode &status) {
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
     if (node->hasValues()) {
         int32_t valuesCount = node->countValues();
@@ -254,7 +254,7 @@ GNameSearchHandler::handleMatch(int32_t matchLength, const CharacterNode *node,
             }
         }
     }
-    return TRUE;
+    return true;
 }
 
 UVector*
@@ -338,8 +338,8 @@ TZGNCore::TZGNCore(const Locale& locale, UErrorCode& status)
   fPartialLocationNamesMap(NULL),
   fLocaleDisplayNames(NULL),
   fStringPool(status),
-  fGNamesTrie(TRUE, deleteGNameInfo),
-  fGNamesTrieFullyLoaded(FALSE) {
+  fGNamesTrie(true, deleteGNameInfo),
+  fGNamesTrieFullyLoaded(false) {
     initialize(locale, status);
 }
 
@@ -360,8 +360,8 @@ TZGNCore::initialize(const Locale& locale, UErrorCode& status) {
     }
 
     // Initialize format patterns
-    UnicodeString rpat(TRUE, gDefRegionPattern, -1);
-    UnicodeString fpat(TRUE, gDefFallbackPattern, -1);
+    UnicodeString rpat(true, gDefRegionPattern, -1);
+    UnicodeString fpat(true, gDefFallbackPattern, -1);
 
     UErrorCode tmpsts = U_ZERO_ERROR;   // OK with fallback warning..
     UResourceBundle *zoneStrings = ures_open(U_ICUDATA_ZONE, locale.getName(), &tmpsts);
@@ -432,7 +432,7 @@ TZGNCore::initialize(const Locale& locale, UErrorCode& status) {
     TimeZone *tz = TimeZone::createDefault();
     const UChar *tzID = ZoneMeta::getCanonicalCLDRID(*tz);
     if (tzID != NULL) {
-        loadStrings(UnicodeString(TRUE, tzID, -1));
+        loadStrings(UnicodeString(true, tzID, -1));
     }
     delete tz;
 }
@@ -459,7 +459,7 @@ TZGNCore::getDisplayName(const TimeZone& tz, UTimeZoneGenericNameType type, UDat
         {
             const UChar* tzCanonicalID = ZoneMeta::getCanonicalCLDRID(tz);
             if (tzCanonicalID != NULL) {
-                getGenericLocationName(UnicodeString(TRUE, tzCanonicalID, -1), name);
+                getGenericLocationName(UnicodeString(true, tzCanonicalID, -1), name);
             }
         }
         break;
@@ -469,7 +469,7 @@ TZGNCore::getDisplayName(const TimeZone& tz, UTimeZoneGenericNameType type, UDat
         if (name.isEmpty()) {
             const UChar* tzCanonicalID = ZoneMeta::getCanonicalCLDRID(tz);
             if (tzCanonicalID != NULL) {
-                getGenericLocationName(UnicodeString(TRUE, tzCanonicalID, -1), name);
+                getGenericLocationName(UnicodeString(true, tzCanonicalID, -1), name);
             }
         }
         break;
@@ -532,7 +532,7 @@ TZGNCore::getGenericLocationName(const UnicodeString& tzCanonicalID) {
     // Construct location name
     UnicodeString name;
     UnicodeString usCountryCode;
-    UBool isPrimary = FALSE;
+    UBool isPrimary = false;
 
     ZoneMeta::getCanonicalCountry(tzCanonicalID, usCountryCode, &isPrimary);
 
@@ -600,7 +600,7 @@ TZGNCore::formatGenericNonLocationName(const TimeZone& tz, UTimeZoneGenericNameT
         return name;
     }
 
-    UnicodeString tzID(TRUE, uID, -1);
+    UnicodeString tzID(true, uID, -1);
 
     // Try to get a name from time zone first
     UTimeZoneNameType nameType = (type == UTZGNM_LONG) ? UTZNM_LONG_GENERIC : UTZNM_SHORT_GENERIC;
@@ -616,17 +616,17 @@ TZGNCore::formatGenericNonLocationName(const TimeZone& tz, UTimeZoneGenericNameT
     fTimeZoneNames->getMetaZoneID(tzID, date, mzID);
     if (!mzID.isEmpty()) {
         UErrorCode status = U_ZERO_ERROR;
-        UBool useStandard = FALSE;
+        UBool useStandard = false;
         int32_t raw, sav;
         UChar tmpNameBuf[ZONE_NAME_U16_MAX];
 
-        tz.getOffset(date, FALSE, raw, sav, status);
+        tz.getOffset(date, false, raw, sav, status);
         if (U_FAILURE(status)) {
             return name;
         }
 
         if (sav == 0) {
-            useStandard = TRUE;
+            useStandard = true;
 
             TimeZone *tmptz = tz.clone();
             // Check if the zone actually uses daylight saving time around the time
@@ -640,30 +640,30 @@ TZGNCore::formatGenericNonLocationName(const TimeZone& tz, UTimeZoneGenericNameT
 
             if (btz != NULL) {
                 TimeZoneTransition before;
-                UBool beforTrs = btz->getPreviousTransition(date, TRUE, before);
+                UBool beforTrs = btz->getPreviousTransition(date, true, before);
                 if (beforTrs
                         && (date - before.getTime() < kDstCheckRange)
                         && before.getFrom()->getDSTSavings() != 0) {
-                    useStandard = FALSE;
+                    useStandard = false;
                 } else {
                     TimeZoneTransition after;
-                    UBool afterTrs = btz->getNextTransition(date, FALSE, after);
+                    UBool afterTrs = btz->getNextTransition(date, false, after);
                     if (afterTrs
                             && (after.getTime() - date < kDstCheckRange)
                             && after.getTo()->getDSTSavings() != 0) {
-                        useStandard = FALSE;
+                        useStandard = false;
                     }
                 }
             } else {
                 // If not BasicTimeZone... only if the instance is not an ICU's implementation.
                 // We may get a wrong answer in edge case, but it should practically work OK.
-                tmptz->getOffset(date - kDstCheckRange, FALSE, raw, sav, status);
+                tmptz->getOffset(date - kDstCheckRange, false, raw, sav, status);
                 if (sav != 0) {
-                    useStandard = FALSE;
+                    useStandard = false;
                 } else {
-                    tmptz->getOffset(date + kDstCheckRange, FALSE, raw, sav, status);
+                    tmptz->getOffset(date + kDstCheckRange, false, raw, sav, status);
                     if (sav != 0){
-                        useStandard = FALSE;
+                        useStandard = false;
                     }
                 }
                 if (U_FAILURE(status)) {
@@ -713,7 +713,7 @@ TZGNCore::formatGenericNonLocationName(const TimeZone& tz, UTimeZoneGenericNameT
                     // With getOffset(date, false, offsets1),
                     // you may get incorrect results because of time overlap at DST->STD
                     // transition.
-                    goldenZone->getOffset(date + raw + sav, TRUE, raw1, sav1, status);
+                    goldenZone->getOffset(date + raw + sav, true, raw1, sav1, status);
                     delete goldenZone;
                     if (U_SUCCESS(status)) {
                         if (raw != raw1 || sav != sav1) {
@@ -752,7 +752,7 @@ TZGNCore::getPartialLocationName(const UnicodeString& tzCanonicalID,
     if (uplname == NULL) {
         name.setToBogus();
     } else {
-        name.setTo(TRUE, uplname, -1);
+        name.setTo(true, uplname, -1);
     }
     return name;
 }
@@ -902,8 +902,8 @@ TZGNCore::findBestMatch(const UnicodeString& text, int32_t start, uint32_t types
     int32_t bestMatchLen = 0;
     UTimeZoneFormatTimeType bestMatchTimeType = UTZFMT_TIME_TYPE_UNKNOWN;
     UnicodeString bestMatchTzID;
-    // UBool isLongStandard = FALSE;   // workaround - see the comments below
-    UBool isStandard = FALSE;       // TODO: Temporary hack (on hack) for short standard name/location name conflict (found in zh_Hant), should be removed after CLDR 21m1 integration
+    // UBool isLongStandard = false;   // workaround - see the comments below
+    UBool isStandard = false;       // TODO: Temporary hack (on hack) for short standard name/location name conflict (found in zh_Hant), should be removed after CLDR 21m1 integration
 
     if (tznamesMatches != NULL) {
         UnicodeString mzID;
@@ -923,9 +923,9 @@ TZGNCore::findBestMatch(const UnicodeString& text, int32_t start, uint32_t types
                 }
                 switch (nameType) {
                 case UTZNM_LONG_STANDARD:
-                    // isLongStandard = TRUE;
+                    // isLongStandard = true;
                 case UTZNM_SHORT_STANDARD:  // this one is never used for generic, but just in case
-                    isStandard = TRUE;      // TODO: Remove this later, see the comments above.
+                    isStandard = true;      // TODO: Remove this later, see the comments above.
                     bestMatchTimeType = UTZFMT_TIME_TYPE_STANDARD;
                     break;
                 case UTZNM_LONG_DAYLIGHT:
@@ -1059,7 +1059,7 @@ TZGNCore::findLocal(const UnicodeString& text, int32_t start, uint32_t types, UE
             }
 
             if (U_SUCCESS(status)) {
-                nonConstThis->fGNamesTrieFullyLoaded = TRUE;
+                nonConstThis->fGNamesTrieFullyLoaded = true;
             }
         }
     }
@@ -1117,7 +1117,7 @@ typedef struct TZGNCoreRef {
 // TZGNCore object cache handling
 static UMutex gTZGNLock;
 static UHashtable *gTZGNCoreCache = NULL;
-static UBool gTZGNCoreCacheInitialized = FALSE;
+static UBool gTZGNCoreCacheInitialized = false;
 
 // Access count - incremented every time up to SWEEP_INTERVAL,
 // then reset to 0
@@ -1142,8 +1142,8 @@ static UBool U_CALLCONV tzgnCore_cleanup(void)
         uhash_close(gTZGNCoreCache);
         gTZGNCoreCache = NULL;
     }
-    gTZGNCoreCacheInitialized = FALSE;
-    return TRUE;
+    gTZGNCoreCacheInitialized = false;
+    return true;
 }
 
 /**
@@ -1211,7 +1211,7 @@ TimeZoneGenericNames::createInstance(const Locale& locale, UErrorCode& status) {
             if (U_SUCCESS(status)) {
                 uhash_setKeyDeleter(gTZGNCoreCache, uprv_free);
                 uhash_setValueDeleter(gTZGNCoreCache, deleteTZGNCoreRef);
-                gTZGNCoreCacheInitialized = TRUE;
+                gTZGNCoreCacheInitialized = true;
                 ucln_i18n_registerCleanup(UCLN_I18N_TIMEZONEGENERICNAMES, tzgnCore_cleanup);
             }
         }
diff --git a/deps/icu-small/source/i18n/tznames.cpp b/deps/icu-small/source/i18n/tznames.cpp
index 781f1cc161..ef4266718e 100644
--- a/deps/icu-small/source/i18n/tznames.cpp
+++ b/deps/icu-small/source/i18n/tznames.cpp
@@ -31,7 +31,7 @@ U_NAMESPACE_BEGIN
 // TimeZoneNames object cache handling
 static UMutex gTimeZoneNamesLock;
 static UHashtable *gTimeZoneNamesCache = NULL;
-static UBool gTimeZoneNamesCacheInitialized = FALSE;
+static UBool gTimeZoneNamesCacheInitialized = false;
 
 // Access count - incremented every time up to SWEEP_INTERVAL,
 // then reset to 0
@@ -62,8 +62,8 @@ static UBool U_CALLCONV timeZoneNames_cleanup(void)
         uhash_close(gTimeZoneNamesCache);
         gTimeZoneNamesCache = NULL;
     }
-    gTimeZoneNamesCacheInitialized = FALSE;
-    return TRUE;
+    gTimeZoneNamesCacheInitialized = false;
+    return true;
 }
 
 /**
@@ -139,7 +139,7 @@ TimeZoneNamesDelegate::TimeZoneNamesDelegate(const Locale& locale, UErrorCode& s
         if (U_SUCCESS(status)) {
             uhash_setKeyDeleter(gTimeZoneNamesCache, uprv_free);
             uhash_setValueDeleter(gTimeZoneNamesCache, deleteTimeZoneNamesCacheEntry);
-            gTimeZoneNamesCacheInitialized = TRUE;
+            gTimeZoneNamesCacheInitialized = true;
             ucln_i18n_registerCleanup(UCLN_I18N_TIMEZONENAMES, timeZoneNames_cleanup);
         }
     }
@@ -380,10 +380,10 @@ struct MatchInfo : UMemory {
         this->matchLength = matchLength;
         if (tzID != NULL) {
             this->id.setTo(*tzID);
-            this->isTZID = TRUE;
+            this->isTZID = true;
         } else {
             this->id.setTo(*mzID);
-            this->isTZID = FALSE;
+            this->isTZID = false;
         }
     }
 };
@@ -468,9 +468,9 @@ TimeZoneNames::MatchInfoCollection::getTimeZoneIDAt(int32_t idx, UnicodeString&
     const MatchInfo* match = (const MatchInfo*)fMatches->elementAt(idx);
     if (match && match->isTZID) {
         tzID.setTo(match->id);
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 UBool
@@ -479,9 +479,9 @@ TimeZoneNames::MatchInfoCollection::getMetaZoneIDAt(int32_t idx, UnicodeString&
     const MatchInfo* match = (const MatchInfo*)fMatches->elementAt(idx);
     if (match && !match->isTZID) {
         mzID.setTo(match->id);
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 UVector*
diff --git a/deps/icu-small/source/i18n/tznames_impl.cpp b/deps/icu-small/source/i18n/tznames_impl.cpp
index 69991dfef4..2005c07ba8 100644
--- a/deps/icu-small/source/i18n/tznames_impl.cpp
+++ b/deps/icu-small/source/i18n/tznames_impl.cpp
@@ -55,10 +55,10 @@ static const int32_t TZDBNAMES_KEYS_SIZE = UPRV_LENGTHOF(TZDBNAMES_KEYS);
 static UMutex gDataMutex;
 
 static UHashtable* gTZDBNamesMap = NULL;
-static icu::UInitOnce gTZDBNamesMapInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gTZDBNamesMapInitOnce {};
 
 static TextTrieMap* gTZDBNamesTrie = NULL;
-static icu::UInitOnce gTZDBNamesTrieInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gTZDBNamesTrieInitOnce {};
 
 // The order in which strings are stored may be different than the order in the public enum.
 enum UTimeZoneNameTypeIndex {
@@ -88,7 +88,7 @@ static UBool U_CALLCONV tzdbTimeZoneNames_cleanup(void) {
     }
     gTZDBNamesTrieInitOnce.reset();
 
-    return TRUE;
+    return true;
 }
 U_CDECL_END
 
@@ -162,7 +162,7 @@ CharacterNode::addValue(void *value, UObjectDeleter *valueDeleter, UErrorCode &s
                 values->addElement(fValues, status);
             }
             fValues = values.orphan();
-            fHasValuesVector = TRUE;
+            fHasValuesVector = true;
         }
         // Add the new value.
         UVector *values = (UVector *)fValues;
@@ -185,7 +185,7 @@ TextTrieMapSearchResultHandler::~TextTrieMapSearchResultHandler(){
 // ---------------------------------------------------
 TextTrieMap::TextTrieMap(UBool ignoreCase, UObjectDeleter *valueDeleter)
 : fIgnoreCase(ignoreCase), fNodes(NULL), fNodesCapacity(0), fNodesCount(0), 
-  fLazyContents(NULL), fIsEmpty(TRUE), fValueDeleter(valueDeleter) {
+  fLazyContents(NULL), fIsEmpty(true), fValueDeleter(valueDeleter) {
 }
 
 TextTrieMap::~TextTrieMap() {
@@ -227,7 +227,7 @@ TextTrieMap::put(const UnicodeString &key, void *value, ZNStringPool &sp, UError
 // resource bundle.
 void
 TextTrieMap::put(const UChar *key, void *value, UErrorCode &status) {
-    fIsEmpty = FALSE;
+    fIsEmpty = false;
     if (fLazyContents == NULL) {
         LocalPointer<UVector> lpLazyContents(new UVector(status), status);
         fLazyContents = lpLazyContents.orphan();
@@ -289,7 +289,7 @@ TextTrieMap::putImpl(const UnicodeString &key, void *value, UErrorCode &status)
 UBool
 TextTrieMap::growNodes() {
     if (fNodesCapacity == 0xffff) {
-        return FALSE;  // We use 16-bit node indexes.
+        return false;  // We use 16-bit node indexes.
     }
     int32_t newCapacity = fNodesCapacity + 1000;
     if (newCapacity > 0xffff) {
@@ -297,13 +297,13 @@ TextTrieMap::growNodes() {
     }
     CharacterNode *newNodes = (CharacterNode *)uprv_malloc(newCapacity * sizeof(CharacterNode));
     if (newNodes == NULL) {
-        return FALSE;
+        return false;
     }
     uprv_memcpy(newNodes, fNodes, fNodesCount * sizeof(CharacterNode));
     uprv_free(fNodes);
     fNodes = newNodes;
     fNodesCapacity = newCapacity;
-    return TRUE;
+    return true;
 }
 
 CharacterNode*
@@ -377,7 +377,7 @@ void TextTrieMap::buildTrie(UErrorCode &status) {
         for (int32_t i=0; i<fLazyContents->size(); i+=2) {
             const UChar *key = (UChar *)fLazyContents->elementAt(i);
             void  *val = fLazyContents->elementAt(i+1);
-            UnicodeString keyString(TRUE, key, -1);  // Aliasing UnicodeString constructor.
+            UnicodeString keyString(true, key, -1);  // Aliasing UnicodeString constructor.
             putImpl(keyString, val, status);
         }
         delete fLazyContents;
@@ -617,13 +617,13 @@ private:
     UBool fOwnsLocationName;
 
     ZNames(const UChar* names[], const UChar* locationName)
-            : fDidAddIntoTrie(FALSE) {
+            : fDidAddIntoTrie(false) {
         uprv_memcpy(fNames, names, sizeof(fNames));
         if (locationName != NULL) {
-            fOwnsLocationName = TRUE;
+            fOwnsLocationName = true;
             fNames[UTZNM_INDEX_EXEMPLAR_LOCATION] = locationName;
         } else {
-            fOwnsLocationName = FALSE;
+            fOwnsLocationName = false;
         }
     }
 
@@ -713,7 +713,7 @@ private:
             UErrorCode& status) {
         if (U_FAILURE(status)) { return; }
         if (fDidAddIntoTrie) { return; }
-        fDidAddIntoTrie = TRUE;
+        fDidAddIntoTrie = true;
 
         for (int32_t i = 0; i < UTZNM_INDEX_COUNT; i++) {
             const UChar* name = fNames[i];
@@ -948,7 +948,7 @@ ZNameSearchHandler::~ZNameSearchHandler() {
 UBool
 ZNameSearchHandler::handleMatch(int32_t matchLength, const CharacterNode *node, UErrorCode &status) {
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
     if (node->hasValues()) {
         int32_t valuesCount = node->countValues();
@@ -980,7 +980,7 @@ ZNameSearchHandler::handleMatch(int32_t matchLength, const CharacterNode *node,
             }
         }
     }
-    return TRUE;
+    return true;
 }
 
 TimeZoneNames::MatchInfoCollection*
@@ -1028,9 +1028,9 @@ TimeZoneNamesImpl::TimeZoneNamesImpl(const Locale& locale, UErrorCode& status)
   fZoneStrings(NULL),
   fTZNamesMap(NULL),
   fMZNamesMap(NULL),
-  fNamesTrieFullyLoaded(FALSE),
-  fNamesFullyLoaded(FALSE),
-  fNamesTrie(TRUE, deleteZNameInfo) {
+  fNamesTrieFullyLoaded(false),
+  fNamesFullyLoaded(false),
+  fNamesTrie(true, deleteZNameInfo) {
     initialize(locale, status);
 }
 
@@ -1224,7 +1224,7 @@ TimeZoneNamesImpl::getMetaZoneDisplayName(const UnicodeString& mzID,
     if (znames != NULL) {
         const UChar* s = znames->getName(type);
         if (s != NULL) {
-            name.setTo(TRUE, s, -1);
+            name.setTo(true, s, -1);
         }
     }
     return name;
@@ -1250,7 +1250,7 @@ TimeZoneNamesImpl::getTimeZoneDisplayName(const UnicodeString& tzID, UTimeZoneNa
     if (tznames != NULL) {
         const UChar *s = tznames->getName(type);
         if (s != NULL) {
-            name.setTo(TRUE, s, -1);
+            name.setTo(true, s, -1);
         }
     }
     return name;
@@ -1274,7 +1274,7 @@ TimeZoneNamesImpl::getExemplarLocationName(const UnicodeString& tzID, UnicodeStr
         locName = tznames->getName(UTZNM_EXEMPLAR_LOCATION);
     }
     if (locName != NULL) {
-        name.setTo(TRUE, locName, -1);
+        name.setTo(true, locName, -1);
     }
 
     return name;
@@ -1385,7 +1385,7 @@ TimeZoneNamesImpl::find(const UnicodeString& text, int32_t start, uint32_t types
         // Load everything now.
         nonConstThis->internalLoadAllDisplayNames(status);
         nonConstThis->addAllNamesIntoTrie(status);
-        nonConstThis->fNamesTrieFullyLoaded = TRUE;
+        nonConstThis->fNamesTrieFullyLoaded = true;
         if (U_FAILURE(status)) { return NULL; }
 
         // Third try: we must return this one.
@@ -1639,7 +1639,7 @@ void TimeZoneNamesImpl::getDisplayNames(const UnicodeString& tzID,
             }
         }
         if (name != NULL) {
-            dest[i].setTo(TRUE, name, -1);
+            dest[i].setTo(true, name, -1);
         } else {
             dest[i].setToBogus();
         }
@@ -1649,7 +1649,7 @@ void TimeZoneNamesImpl::getDisplayNames(const UnicodeString& tzID,
 // Caller must synchronize.
 void TimeZoneNamesImpl::internalLoadAllDisplayNames(UErrorCode& status) {
     if (!fNamesFullyLoaded) {
-        fNamesFullyLoaded = TRUE;
+        fNamesFullyLoaded = true;
 
         ZoneStringsLoader loader(*this, status);
         loader.load(status);
@@ -1771,7 +1771,7 @@ TZDBNames::createInstance(UResourceBundle* rb, const char* key) {
     }
 
     names = (const UChar **)uprv_malloc(sizeof(const UChar*) * TZDBNAMES_KEYS_SIZE);
-    UBool isEmpty = TRUE;
+    UBool isEmpty = true;
     if (names != NULL) {
         for (int32_t i = 0; i < TZDBNAMES_KEYS_SIZE; i++) {
             status = U_ZERO_ERROR;
@@ -1780,7 +1780,7 @@ TZDBNames::createInstance(UResourceBundle* rb, const char* key) {
                 names[i] = NULL;
             } else {
                 names[i] = value;
-                isEmpty = FALSE;
+                isEmpty = false;
             }
         }
     }
@@ -1793,7 +1793,7 @@ TZDBNames::createInstance(UResourceBundle* rb, const char* key) {
     }
 
     UResourceBundle *regionsRes = ures_getByKey(rbTable, "parseRegions", NULL, &status);
-    UBool regionError = FALSE;
+    UBool regionError = false;
     if (U_SUCCESS(status)) {
         numRegions = ures_getSize(regionsRes);
         if (numRegions > 0) {
@@ -1809,12 +1809,12 @@ TZDBNames::createInstance(UResourceBundle* rb, const char* key) {
                     status = U_ZERO_ERROR;
                     const UChar *uregion = ures_getStringByIndex(regionsRes, i, &len, &status);
                     if (U_FAILURE(status)) {
-                        regionError = TRUE;
+                        regionError = true;
                         break;
                     }
                     *pRegion = (char*)uprv_malloc(sizeof(char) * (len + 1));
                     if (*pRegion == NULL) {
-                        regionError = TRUE;
+                        regionError = true;
                         break;
                     }
                     u_UCharsToChars(uregion, *pRegion, len);
@@ -1915,7 +1915,7 @@ TZDBNameSearchHandler::~TZDBNameSearchHandler() {
 UBool
 TZDBNameSearchHandler::handleMatch(int32_t matchLength, const CharacterNode *node, UErrorCode &status) {
     if (U_FAILURE(status)) {
-        return FALSE;
+        return false;
     }
 
     TZDBNameInfo *match = NULL;
@@ -1943,7 +1943,7 @@ TZDBNameSearchHandler::handleMatch(int32_t matchLength, const CharacterNode *nod
                         match = defaultRegionMatch = ninfo;
                     }
                 } else {
-                    UBool matchRegion = FALSE;
+                    UBool matchRegion = false;
                     // non-default metazone mapping for an abbreviation
                     // comes with applicable regions. For example, the default
                     // metazone mapping for "CST" is America_Central,
@@ -1953,7 +1953,7 @@ TZDBNameSearchHandler::handleMatch(int32_t matchLength, const CharacterNode *nod
                         const char *region = ninfo->parseRegions[j];
                         if (uprv_strcmp(fRegion, region) == 0) {
                             match = ninfo;
-                            matchRegion = TRUE;
+                            matchRegion = true;
                             break;
                         }
                     }
@@ -2004,7 +2004,7 @@ TZDBNameSearchHandler::handleMatch(int32_t matchLength, const CharacterNode *nod
             }
         }
     }
-    return TRUE;
+    return true;
 }
 
 TimeZoneNames::MatchInfoCollection*
@@ -2055,7 +2055,7 @@ static void U_CALLCONV prepareFind(UErrorCode &status) {
     if (U_FAILURE(status)) {
         return;
     }
-    gTZDBNamesTrie = new TextTrieMap(TRUE, deleteTZDBNameInfo);
+    gTZDBNamesTrie = new TextTrieMap(true, deleteTZDBNameInfo);
     if (gTZDBNamesTrie == NULL) {
         status = U_MEMORY_ALLOCATION_ERROR;
         return;
@@ -2131,7 +2131,7 @@ U_CDECL_END
 
 TZDBTimeZoneNames::TZDBTimeZoneNames(const Locale& locale)
 : fLocale(locale) {
-    UBool useWorld = TRUE;
+    UBool useWorld = true;
     const char* region = fLocale.getCountry();
     int32_t regionLen = static_cast<int32_t>(uprv_strlen(region));
     if (regionLen == 0) {
@@ -2143,11 +2143,11 @@ TZDBTimeZoneNames::TZDBTimeZoneNames(const Locale& locale)
         }
         regionLen = uloc_getCountry(loc.data(), fRegion, sizeof(fRegion), &status);
         if (U_SUCCESS(status) && regionLen < (int32_t)sizeof(fRegion)) {
-            useWorld = FALSE;
+            useWorld = false;
         }
     } else if (regionLen < (int32_t)sizeof(fRegion)) {
         uprv_strcpy(fRegion, region);
-        useWorld = FALSE;
+        useWorld = false;
     }
     if (useWorld) {
         uprv_strcpy(fRegion, "001");
@@ -2206,7 +2206,7 @@ TZDBTimeZoneNames::getMetaZoneDisplayName(const UnicodeString& mzID,
         if (tzdbNames != NULL) {
             const UChar *s = tzdbNames->getName(type);
             if (s != NULL) {
-                name.setTo(TRUE, s, -1);
+                name.setTo(true, s, -1);
             }
         }
     }
diff --git a/deps/icu-small/source/i18n/tzrule.cpp b/deps/icu-small/source/i18n/tzrule.cpp
index a60fffbe02..a98ecc8086 100644
--- a/deps/icu-small/source/i18n/tzrule.cpp
+++ b/deps/icu-small/source/i18n/tzrule.cpp
@@ -135,26 +135,26 @@ InitialTimeZoneRule::operator!=(const TimeZoneRule& that) const {
 UBool
 InitialTimeZoneRule::isEquivalentTo(const TimeZoneRule& other) const {
     if (this == &other) {
-        return TRUE;
+        return true;
     }
-    if (typeid(*this) != typeid(other) || TimeZoneRule::isEquivalentTo(other) == FALSE) {
-        return FALSE;
+    if (typeid(*this) != typeid(other) || TimeZoneRule::isEquivalentTo(other) == false) {
+        return false;
     }
-    return TRUE;
+    return true;
 }
 
 UBool
 InitialTimeZoneRule::getFirstStart(int32_t /*prevRawOffset*/,
                                   int32_t /*prevDSTSavings*/,
                                   UDate& /*result*/) const {
-    return FALSE;
+    return false;
 }
 
 UBool
 InitialTimeZoneRule::getFinalStart(int32_t /*prevRawOffset*/,
                                   int32_t /*prevDSTSavings*/,
                                   UDate& /*result*/) const {
-    return FALSE;
+    return false;
 }
 
 UBool
@@ -163,7 +163,7 @@ InitialTimeZoneRule::getNextStart(UDate /*base*/,
                                  int32_t /*prevDSTSavings*/,
                                  UBool /*inclusive*/,
                                  UDate& /*result*/) const {
-    return FALSE;
+    return false;
 }
 
 UBool
@@ -172,7 +172,7 @@ InitialTimeZoneRule::getPreviousStart(UDate /*base*/,
                                      int32_t /*prevDSTSavings*/,
                                      UBool /*inclusive*/,
                                      UDate& /*result*/) const {
-    return FALSE;
+    return false;
 }
 
 
@@ -266,14 +266,14 @@ AnnualTimeZoneRule::getStartInYear(int32_t year,
                                    int32_t prevDSTSavings,
                                    UDate &result) const {
     if (year < fStartYear || year > fEndYear) {
-        return FALSE;
+        return false;
     }
     double ruleDay;
     DateTimeRule::DateRuleType type = fDateTimeRule->getDateRuleType();
     if (type == DateTimeRule::DOM) {
         ruleDay = Grego::fieldsToDay(year, fDateTimeRule->getRuleMonth(), fDateTimeRule->getRuleDayOfMonth());
     } else {
-        UBool after = TRUE;
+        UBool after = true;
         if (type == DateTimeRule::DOW) {
             // Normalize DOW rule into DOW_GEQ_DOM or DOW_LEQ_DOM
             int32_t weeks = fDateTimeRule->getRuleWeekInMonth();
@@ -281,7 +281,7 @@ AnnualTimeZoneRule::getStartInYear(int32_t year,
                 ruleDay = Grego::fieldsToDay(year, fDateTimeRule->getRuleMonth(), 1);
                 ruleDay += 7 * (weeks - 1);
             } else {
-                after = FALSE;
+                after = false;
                 ruleDay = Grego::fieldsToDay(year, fDateTimeRule->getRuleMonth(),
                     Grego::monthLength(year, fDateTimeRule->getRuleMonth()));
                 ruleDay += 7 * (weeks + 1);
@@ -290,7 +290,7 @@ AnnualTimeZoneRule::getStartInYear(int32_t year,
             int32_t month = fDateTimeRule->getRuleMonth();
             int32_t dom = fDateTimeRule->getRuleDayOfMonth();
             if (type == DateTimeRule::DOW_LEQ_DOM) {
-                after = FALSE;
+                after = false;
                 // Handle Feb <=29
                 if (month == UCAL_FEBRUARY && dom == 29 && !Grego::isLeapYear(year)) {
                     dom--;
@@ -315,16 +315,16 @@ AnnualTimeZoneRule::getStartInYear(int32_t year,
     if (fDateTimeRule->getTimeRuleType() == DateTimeRule::WALL_TIME) {
         result -= prevDSTSavings;
     }
-    return TRUE;
+    return true;
 }
 
 UBool
 AnnualTimeZoneRule::isEquivalentTo(const TimeZoneRule& other) const {
     if (this == &other) {
-        return TRUE;
+        return true;
     }
-    if (typeid(*this) != typeid(other) || TimeZoneRule::isEquivalentTo(other) == FALSE) {
-        return FALSE;
+    if (typeid(*this) != typeid(other) || TimeZoneRule::isEquivalentTo(other) == false) {
+        return false;
     }
     AnnualTimeZoneRule* that = (AnnualTimeZoneRule*)&other;
     return (*fDateTimeRule == *(that->fDateTimeRule) &&
@@ -344,7 +344,7 @@ AnnualTimeZoneRule::getFinalStart(int32_t prevRawOffset,
                                   int32_t prevDSTSavings,
                                   UDate& result) const {
     if (fEndYear == MAX_YEAR) {
-        return FALSE;
+        return false;
     }
     return getStartInYear(fEndYear, prevRawOffset, prevDSTSavings, result);
 }
@@ -367,10 +367,10 @@ AnnualTimeZoneRule::getNextStart(UDate base,
             return getStartInYear(year + 1, prevRawOffset, prevDSTSavings, result);
         } else {
             result = tmp;
-            return TRUE;
+            return true;
         }
     }
-    return FALSE;
+    return false;
 }
 
 UBool
@@ -391,10 +391,10 @@ AnnualTimeZoneRule::getPreviousStart(UDate base,
             return getStartInYear(year - 1, prevRawOffset, prevDSTSavings, result);
         } else {
             result = tmp;
-            return TRUE;
+            return true;
         }
     }
-    return FALSE;
+    return false;
 }
 
 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(TimeArrayTimeZoneRule)
@@ -482,10 +482,10 @@ TimeArrayTimeZoneRule::getTimeType(void) const {
 UBool
 TimeArrayTimeZoneRule::getStartTimeAt(int32_t index, UDate& result) const {
     if (index >= fNumStartTimes || index < 0) {
-        return FALSE;
+        return false;
     }
     result = fStartTimes[index];
-    return TRUE;
+    return true;
 }
 
 int32_t
@@ -496,21 +496,21 @@ TimeArrayTimeZoneRule::countStartTimes(void) const {
 UBool
 TimeArrayTimeZoneRule::isEquivalentTo(const TimeZoneRule& other) const {
     if (this == &other) {
-        return TRUE;
+        return true;
     }
-    if (typeid(*this) != typeid(other) || TimeZoneRule::isEquivalentTo(other) == FALSE) {
-        return FALSE;
+    if (typeid(*this) != typeid(other) || TimeZoneRule::isEquivalentTo(other) == false) {
+        return false;
     }
     TimeArrayTimeZoneRule* that = (TimeArrayTimeZoneRule*)&other;
     if (fTimeRuleType != that->fTimeRuleType ||
         fNumStartTimes != that->fNumStartTimes) {
-        return FALSE;
+        return false;
     }
     // Compare start times
-    UBool res = TRUE;
+    UBool res = true;
     for (int32_t i = 0; i < fNumStartTimes; i++) {
         if (fStartTimes[i] != that->fStartTimes[i]) {
-            res = FALSE;
+            res = false;
             break;
         }
     }
@@ -522,10 +522,10 @@ TimeArrayTimeZoneRule::getFirstStart(int32_t prevRawOffset,
                                              int32_t prevDSTSavings,
                                              UDate& result) const {
     if (fNumStartTimes <= 0 || fStartTimes == NULL) {
-        return FALSE;
+        return false;
     }
     result = getUTC(fStartTimes[0], prevRawOffset, prevDSTSavings);
-    return TRUE;
+    return true;
 }
 
 UBool
@@ -533,10 +533,10 @@ TimeArrayTimeZoneRule::getFinalStart(int32_t prevRawOffset,
                                      int32_t prevDSTSavings,
                                      UDate& result) const {
     if (fNumStartTimes <= 0 || fStartTimes == NULL) {
-        return FALSE;
+        return false;
     }
     result = getUTC(fStartTimes[fNumStartTimes - 1], prevRawOffset, prevDSTSavings);
-    return TRUE;
+    return true;
 }
 
 UBool
@@ -554,9 +554,9 @@ TimeArrayTimeZoneRule::getNextStart(UDate base,
         result = time;
     }
     if (i == fNumStartTimes - 1) {
-        return FALSE;
+        return false;
     }
-    return TRUE;
+    return true;
 }
 
 UBool
@@ -570,10 +570,10 @@ TimeArrayTimeZoneRule::getPreviousStart(UDate base,
         UDate time = getUTC(fStartTimes[i], prevRawOffset, prevDSTSavings);
         if (time < base || (inclusive && time == base)) {
             result = time;
-            return TRUE;
+            return true;
         }
     }
-    return FALSE;
+    return false;
 }
 
 
@@ -591,7 +591,7 @@ TimeArrayTimeZoneRule::initStartTimes(const UDate source[], int32_t size, UError
         if (fStartTimes == NULL) {
             status = U_MEMORY_ALLOCATION_ERROR;
             fNumStartTimes = 0;
-            return FALSE;
+            return false;
         }
     } else {
         fStartTimes = (UDate*)fLocalStartTimes;
@@ -599,15 +599,15 @@ TimeArrayTimeZoneRule::initStartTimes(const UDate source[], int32_t size, UError
     uprv_memcpy(fStartTimes, source, sizeof(UDate)*size);
     fNumStartTimes = size;
     // Sort dates
-    uprv_sortArray(fStartTimes, fNumStartTimes, (int32_t)sizeof(UDate), compareDates, NULL, TRUE, &status);
+    uprv_sortArray(fStartTimes, fNumStartTimes, (int32_t)sizeof(UDate), compareDates, NULL, true, &status);
     if (U_FAILURE(status)) {
         if (fStartTimes != NULL && fStartTimes != fLocalStartTimes) {
             uprv_free(fStartTimes);
         }
         fNumStartTimes = 0;
-        return FALSE;
+        return false;
     }
-    return TRUE;
+    return true;
 }
 
 UDate
diff --git a/deps/icu-small/source/i18n/ucal.cpp b/deps/icu-small/source/i18n/ucal.cpp
index 33f72589c5..36fe9b8f8a 100644
--- a/deps/icu-small/source/i18n/ucal.cpp
+++ b/deps/icu-small/source/i18n/ucal.cpp
@@ -124,7 +124,7 @@ ucal_getDSTSavings(const UChar* zoneID, UErrorCode* ec) {
             UDate d = Calendar::getNow();
             for (int32_t i=0; i<53; ++i, d+=U_MILLIS_PER_DAY*7.0) {
                 int32_t raw, dst;
-                zone->getOffset(d, FALSE, raw, dst, *ec);
+                zone->getOffset(d, false, raw, dst, *ec);
                 if (U_FAILURE(*ec)) {
                     break;
                 } else if (dst != 0) {
@@ -263,19 +263,19 @@ ucal_getTimeZoneDisplayName(const     UCalendar*                 cal,
 
     switch(type) {
   case UCAL_STANDARD:
-      tz.getDisplayName(FALSE, TimeZone::LONG, Locale(locale), id);
+      tz.getDisplayName(false, TimeZone::LONG, Locale(locale), id);
       break;
 
   case UCAL_SHORT_STANDARD:
-      tz.getDisplayName(FALSE, TimeZone::SHORT, Locale(locale), id);
+      tz.getDisplayName(false, TimeZone::SHORT, Locale(locale), id);
       break;
 
   case UCAL_DST:
-      tz.getDisplayName(TRUE, TimeZone::LONG, Locale(locale), id);
+      tz.getDisplayName(true, TimeZone::LONG, Locale(locale), id);
       break;
 
   case UCAL_SHORT_DST:
-      tz.getDisplayName(TRUE, TimeZone::SHORT, Locale(locale), id);
+      tz.getDisplayName(true, TimeZone::SHORT, Locale(locale), id);
       break;
     }
 
@@ -594,7 +594,7 @@ ucal_getCanonicalTimeZoneID(const UChar* id, int32_t len,
         return 0;
     }
     if (isSystemID) {
-        *isSystemID = FALSE;
+        *isSystemID = false;
     }
     if (id == 0 || len == 0 || result == 0 || resultCapacity <= 0) {
         *status = U_ILLEGAL_ARGUMENT_ERROR;
@@ -602,7 +602,7 @@ ucal_getCanonicalTimeZoneID(const UChar* id, int32_t len,
     }
     int32_t reslen = 0;
     UnicodeString canonical;
-    UBool systemID = FALSE;
+    UBool systemID = false;
     TimeZone::getCanonicalID(UnicodeString(id, len), canonical, systemID, *status);
     if (U_SUCCESS(*status)) {
         if (isSystemID) {
@@ -644,7 +644,7 @@ U_CAPI UBool U_EXPORT2
 ucal_isWeekend(const UCalendar *cal, UDate date, UErrorCode *status)
 {
     if (U_FAILURE(*status)) {
-        return FALSE;
+        return false;
     }
     return ((Calendar*)cal)->isWeekend(date, *status);
 }
@@ -697,7 +697,7 @@ U_CAPI UEnumeration* U_EXPORT2
 ucal_getKeywordValuesForLocale(const char * /* key */, const char* locale, UBool commonlyUsed, UErrorCode *status) {
     // Resolve region
     char prefRegion[ULOC_COUNTRY_CAPACITY];
-    (void)ulocimp_getRegionForSupplementalData(locale, TRUE, prefRegion, sizeof(prefRegion), status);
+    (void)ulocimp_getRegionForSupplementalData(locale, true, prefRegion, sizeof(prefRegion), status);
     
     // Read preferred calendar values from supplementalData calendarPreference
     UResourceBundle *rb = ures_openDirect(nullptr, "supplementalData", status);
@@ -724,7 +724,7 @@ ucal_getKeywordValuesForLocale(const char * /* key */, const char* locale, UBool
                 u_UCharsToChars(type, caltype, len);
                 *(caltype + len) = 0;
 
-                ulist_addItemEndList(values, caltype, TRUE, status);
+                ulist_addItemEndList(values, caltype, true, status);
                 if (U_FAILURE(*status)) {
                     break;
                 }
@@ -734,7 +734,7 @@ ucal_getKeywordValuesForLocale(const char * /* key */, const char* locale, UBool
                 // If not commonlyUsed, add other available values
                 for (int32_t i = 0; CAL_TYPES[i] != nullptr; i++) {
                     if (!ulist_containsString(values, CAL_TYPES[i], (int32_t)uprv_strlen(CAL_TYPES[i]))) {
-                        ulist_addItemEndList(values, CAL_TYPES[i], FALSE, status);
+                        ulist_addItemEndList(values, CAL_TYPES[i], false, status);
                         if (U_FAILURE(*status)) {
                             break;
                         }
@@ -773,7 +773,7 @@ ucal_getTimeZoneTransitionDate(const UCalendar* cal, UTimeZoneTransitionType typ
                                UDate* transition, UErrorCode* status)
 {
     if (U_FAILURE(*status)) {
-        return FALSE;
+        return false;
     }
     UDate base = ((Calendar*)cal)->getTime(*status);
     const TimeZone& tz = ((Calendar*)cal)->getTimeZone();
@@ -786,10 +786,10 @@ ucal_getTimeZoneTransitionDate(const UCalendar* cal, UTimeZoneTransitionType typ
                         btz->getPreviousTransition(base, inclusive, tzt);
         if (result) {
             *transition = tzt.getTime();
-            return TRUE;
+            return true;
         }
     }
-    return FALSE;
+    return false;
 }
 
 U_CAPI int32_t U_EXPORT2
diff --git a/deps/icu-small/source/i18n/ucln_in.cpp b/deps/icu-small/source/i18n/ucln_in.cpp
index f29cbe41dd..cdbd16a65e 100644
--- a/deps/icu-small/source/i18n/ucln_in.cpp
+++ b/deps/icu-small/source/i18n/ucln_in.cpp
@@ -45,7 +45,7 @@ static UBool U_CALLCONV i18n_cleanup(void)
 #if !UCLN_NO_AUTO_CLEANUP && (defined(UCLN_AUTO_ATEXIT) || defined(UCLN_AUTO_LOCAL))
     ucln_unRegisterAutomaticCleanup();
 #endif
-    return TRUE;
+    return true;
 }
 
 void ucln_i18n_registerCleanup(ECleanupI18NType type,
diff --git a/deps/icu-small/source/i18n/ucol_res.cpp b/deps/icu-small/source/i18n/ucol_res.cpp
index b277cf3b28..8308d99c29 100644
--- a/deps/icu-small/source/i18n/ucol_res.cpp
+++ b/deps/icu-small/source/i18n/ucol_res.cpp
@@ -62,7 +62,7 @@ namespace {
 static const UChar *rootRules = NULL;
 static int32_t rootRulesLength = 0;
 static UResourceBundle *rootBundle = NULL;
-static UInitOnce gInitOnceUcolRes = U_INITONCE_INITIALIZER;
+static UInitOnce gInitOnceUcolRes {};
 
 }  // namespace
 
@@ -75,7 +75,7 @@ ucol_res_cleanup() {
     ures_close(rootBundle);
     rootBundle = NULL;
     gInitOnceUcolRes.reset();
-    return TRUE;
+    return true;
 }
 
 void U_CALLCONV
@@ -168,7 +168,7 @@ CollationLoader::CollationLoader(const CollationCacheEntry *re, const Locale &re
                                  UErrorCode &errorCode)
         : cache(UnifiedCache::getInstance(errorCode)), rootEntry(re),
           validLocale(re->validLocale), locale(requested),
-          typesTried(0), typeFallback(FALSE),
+          typesTried(0), typeFallback(false),
           bundle(NULL), collations(NULL), data(NULL) {
     type[0] = 0;
     defaultType[0] = 0;
@@ -321,7 +321,7 @@ CollationLoader::loadFromCollations(UErrorCode &errorCode) {
     int32_t typeLength = static_cast<int32_t>(uprv_strlen(type));
     if(errorCode == U_MISSING_RESOURCE_ERROR) {
         errorCode = U_USING_DEFAULT_WARNING;
-        typeFallback = TRUE;
+        typeFallback = true;
         if((typesTried & TRIED_SEARCH) == 0 &&
                 typeLength > 6 && uprv_strncmp(type, "search", 6) == 0) {
             // fall back from something like "searchjl" to "search"
@@ -404,7 +404,7 @@ CollationLoader::loadFromData(UErrorCode &errorCode) {
         const UChar *s = ures_getStringByKey(data, "Sequence", &len,
                                              &internalErrorCode);
         if(U_SUCCESS(internalErrorCode)) {
-            t->rules.setTo(TRUE, s, len);
+            t->rules.setTo(true, s, len);
         }
     }
 
@@ -619,7 +619,7 @@ namespace {
 struct KeywordsSink : public ResourceSink {
 public:
     KeywordsSink(UErrorCode &errorCode) :
-            values(ulist_createEmptyList(&errorCode)), hasDefault(FALSE) {}
+            values(ulist_createEmptyList(&errorCode)), hasDefault(false) {}
     virtual ~KeywordsSink();
 
     virtual void put(const char *key, ResourceValue &value, UBool /*noFallback*/,
@@ -639,13 +639,13 @@ public:
                             return;
                         }
                         ulist_removeString(values, defcoll.data());
-                        ulist_addItemBeginList(values, ownedDefault, TRUE, &errorCode);
-                        hasDefault = TRUE;
+                        ulist_addItemBeginList(values, ownedDefault, true, &errorCode);
+                        hasDefault = true;
                     }
                 }
             } else if (type == URES_TABLE && uprv_strncmp(key, "private-", 8) != 0) {
                 if (!ulist_containsString(values, key, (int32_t)uprv_strlen(key))) {
-                    ulist_addItemEndList(values, key, FALSE, &errorCode);
+                    ulist_addItemEndList(values, key, false, &errorCode);
                 }
             }
             if (U_FAILURE(errorCode)) { return; }
@@ -695,7 +695,7 @@ ucol_getFunctionalEquivalent(char* result, int32_t resultCapacity,
     // N.B.: Resource name is "collations" but keyword is "collation"
     return ures_getFunctionalEquivalent(result, resultCapacity, U_ICUDATA_COLL,
         "collations", keyword, locale,
-        isAvailable, TRUE, status);
+        isAvailable, true, status);
 }
 
 #endif /* #if !UCONFIG_NO_COLLATION */
diff --git a/deps/icu-small/source/i18n/ucol_sit.cpp b/deps/icu-small/source/i18n/ucol_sit.cpp
index 4dc81aebcc..19281e4352 100644
--- a/deps/icu-small/source/i18n/ucol_sit.cpp
+++ b/deps/icu-small/source/i18n/ucol_sit.cpp
@@ -109,7 +109,7 @@ CollatorSpec::CollatorSpec() :
 locale(),
 variableTopValue(0),
 variableTopString(),
-variableTopSet(FALSE)
+variableTopSet(false)
  {
     // set collation options to default
     for(int32_t i = 0; i < UCOL_ATTRIBUTE_COUNT; i++) {
@@ -270,7 +270,7 @@ _processVariableTop(CollatorSpec *spec, uint32_t value1, const char* string, UEr
         spec->variableTopValue = readHexCodeUnit(&string, status);
     }
     if(U_SUCCESS(*status)) {
-        spec->variableTopSet = TRUE;
+        spec->variableTopSet = true;
     }
     return string;
 }
@@ -618,7 +618,7 @@ ucol_getContractions( const UCollator *coll,
                   USet *contractions,
                   UErrorCode *status)
 {
-  ucol_getContractionsAndExpansions(coll, contractions, NULL, FALSE, status);
+  ucol_getContractionsAndExpansions(coll, contractions, NULL, false, status);
   return uset_getItemCount(contractions);
 }
 
diff --git a/deps/icu-small/source/i18n/ucoleitr.cpp b/deps/icu-small/source/i18n/ucoleitr.cpp
index 596ce03295..53649c01bc 100644
--- a/deps/icu-small/source/i18n/ucoleitr.cpp
+++ b/deps/icu-small/source/i18n/ucoleitr.cpp
@@ -205,7 +205,7 @@ void UCollationPCE::init(const Collator &coll)
 
     strength    = coll.getAttribute(UCOL_STRENGTH, status);
     toShift     = coll.getAttribute(UCOL_ALTERNATE_HANDLING, status) == UCOL_SHIFTED;
-    isShifted   = FALSE;
+    isShifted   = false;
     variableTop = coll.getVariableTop(status);
 }
 
@@ -254,13 +254,13 @@ uint64_t UCollationPCE::processCE(uint32_t ce)
         }
 
         primary = secondary = tertiary = 0;
-        isShifted = TRUE;
+        isShifted = true;
     } else {
         if (strength >= UCOL_QUATERNARY) {
             quaternary = 0xFFFF;
         }
 
-        isShifted = FALSE;
+        isShifted = false;
     }
 
     return primary << 48 | secondary << 32 | tertiary << 16 | quaternary;
diff --git a/deps/icu-small/source/i18n/ucsdet.cpp b/deps/icu-small/source/i18n/ucsdet.cpp
index 63f204d0e1..8de10d101f 100644
--- a/deps/icu-small/source/i18n/ucsdet.cpp
+++ b/deps/icu-small/source/i18n/ucsdet.cpp
@@ -148,7 +148,7 @@ ucsdet_isInputFilterEnabled(const UCharsetDetector *ucsd)
 {
     // todo: could use an error return...
     if (ucsd == NULL) {
-        return FALSE;
+        return false;
     }
 
     return ((CharsetDetector *) ucsd)->getStripTagsFlag();
@@ -159,7 +159,7 @@ ucsdet_enableInputFilter(UCharsetDetector *ucsd, UBool filter)
 {
     // todo: could use an error return...
     if (ucsd == NULL) {
-        return FALSE;
+        return false;
     }
 
     CharsetDetector *csd = (CharsetDetector *) ucsd;
diff --git a/deps/icu-small/source/i18n/udat.cpp b/deps/icu-small/source/i18n/udat.cpp
index d9549d04c5..426eb7ebf2 100644
--- a/deps/icu-small/source/i18n/udat.cpp
+++ b/deps/icu-small/source/i18n/udat.cpp
@@ -429,9 +429,9 @@ udat_getBooleanAttribute(const UDateFormat* fmt,
                          UDateFormatBooleanAttribute attr, 
                          UErrorCode* status)
 {
-    if(U_FAILURE(*status)) return FALSE;
+    if(U_FAILURE(*status)) return false;
     return ((DateFormat*)fmt)->getBooleanAttribute(attr, *status);
-    //return FALSE;
+    //return false;
 }
 
 U_CAPI void U_EXPORT2
diff --git a/deps/icu-small/source/i18n/uitercollationiterator.cpp b/deps/icu-small/source/i18n/uitercollationiterator.cpp
index 103c91cac8..26cd75a6bd 100644
--- a/deps/icu-small/source/i18n/uitercollationiterator.cpp
+++ b/deps/icu-small/source/i18n/uitercollationiterator.cpp
@@ -303,7 +303,7 @@ FCDUIterCollationIterator::switchToForward() {
 
 UBool
 FCDUIterCollationIterator::nextSegment(UErrorCode &errorCode) {
-    if(U_FAILURE(errorCode)) { return FALSE; }
+    if(U_FAILURE(errorCode)) { return false; }
     U_ASSERT(state == ITER_CHECK_FWD);
     // The input text [start..(iter index)[ passes the FCD check.
     pos = iter.getIndex(&iter, UITER_CURRENT);
@@ -333,12 +333,12 @@ FCDUIterCollationIterator::nextSegment(UErrorCode &errorCode) {
                 }
                 s.append(c);
             }
-            if(!normalize(s, errorCode)) { return FALSE; }
+            if(!normalize(s, errorCode)) { return false; }
             start = pos;
             limit = pos + s.length();
             state = IN_NORM_ITER_AT_LIMIT;
             pos = 0;
-            return TRUE;
+            return true;
         }
         prevCC = (uint8_t)fcd16;
         if(prevCC == 0) {
@@ -350,7 +350,7 @@ FCDUIterCollationIterator::nextSegment(UErrorCode &errorCode) {
     U_ASSERT(pos != limit);
     iter.move(&iter, -s.length(), UITER_CURRENT);
     state = ITER_IN_FCD_SEGMENT;
-    return TRUE;
+    return true;
 }
 
 void
@@ -384,7 +384,7 @@ FCDUIterCollationIterator::switchToBackward() {
 
 UBool
 FCDUIterCollationIterator::previousSegment(UErrorCode &errorCode) {
-    if(U_FAILURE(errorCode)) { return FALSE; }
+    if(U_FAILURE(errorCode)) { return false; }
     U_ASSERT(state == ITER_CHECK_BWD);
     // The input text [(iter index)..limit[ passes the FCD check.
     pos = iter.getIndex(&iter, UITER_CURRENT);
@@ -417,12 +417,12 @@ FCDUIterCollationIterator::previousSegment(UErrorCode &errorCode) {
                 s.append(c);
             }
             s.reverse();
-            if(!normalize(s, errorCode)) { return FALSE; }
+            if(!normalize(s, errorCode)) { return false; }
             limit = pos;
             start = pos - s.length();
             state = IN_NORM_ITER_AT_START;
             pos = normalized.length();
-            return TRUE;
+            return true;
         }
         nextCC = (uint8_t)(fcd16 >> 8);
         if(nextCC == 0) {
@@ -434,7 +434,7 @@ FCDUIterCollationIterator::previousSegment(UErrorCode &errorCode) {
     U_ASSERT(pos != start);
     iter.move(&iter, s.length(), UITER_CURRENT);
     state = ITER_IN_FCD_SEGMENT;
-    return TRUE;
+    return true;
 }
 
 UBool
diff --git a/deps/icu-small/source/i18n/ulistformatter.cpp b/deps/icu-small/source/i18n/ulistformatter.cpp
index bfb7cf96bd..7e8b385c96 100644
--- a/deps/icu-small/source/i18n/ulistformatter.cpp
+++ b/deps/icu-small/source/i18n/ulistformatter.cpp
@@ -88,7 +88,7 @@ static UnicodeString* getUnicodeStrings(
     }
     if (stringLengths == NULL) {
         for (int32_t stringIndex = 0; stringIndex < stringCount; stringIndex++) {
-            ustrings[stringIndex].setTo(TRUE, strings[stringIndex], -1);
+            ustrings[stringIndex].setTo(true, strings[stringIndex], -1);
         }
     } else {
         for (int32_t stringIndex = 0; stringIndex < stringCount; stringIndex++) {
diff --git a/deps/icu-small/source/i18n/ulocdata.cpp b/deps/icu-small/source/i18n/ulocdata.cpp
index 68b9e0cf63..48efe9d55a 100644
--- a/deps/icu-small/source/i18n/ulocdata.cpp
+++ b/deps/icu-small/source/i18n/ulocdata.cpp
@@ -66,7 +66,7 @@ ulocdata_open(const char *localeID, UErrorCode *status)
 
    uld->langBundle = NULL;
 
-   uld->noSubstitute = FALSE;
+   uld->noSubstitute = false;
    uld->bundle = ures_open(NULL, localeID, status);
    uld->langBundle = ures_open(U_ICUDATA_LANG, localeID, status);
 
@@ -196,7 +196,7 @@ static UResourceBundle * measurementTypeBundleForLocale(const char *localeID, co
     UResourceBundle *rb;
     UResourceBundle *measTypeBundle = NULL;
     
-    ulocimp_getRegionForSupplementalData(localeID, TRUE, region, ULOC_COUNTRY_CAPACITY, status);
+    ulocimp_getRegionForSupplementalData(localeID, true, region, ULOC_COUNTRY_CAPACITY, status);
     
     rb = ures_openDirect(NULL, "supplementalData", status);
     ures_getByKey(rb, "measurementData", rb, status);
@@ -230,7 +230,10 @@ ulocdata_getMeasurementSystem(const char *localeID, UErrorCode *status){
     }
 
     measurement = measurementTypeBundleForLocale(localeID, MEASUREMENT_SYSTEM, status);
-    system = (UMeasurementSystem) ures_getInt(measurement, status);
+    int32_t result = ures_getInt(measurement, status);
+    if (U_SUCCESS(*status)) {
+         system = static_cast<UMeasurementSystem>(result);
+    }
 
     ures_close(measurement);
 
diff --git a/deps/icu-small/source/i18n/unesctrn.cpp b/deps/icu-small/source/i18n/unesctrn.cpp
index 0636fe1d14..fb431ffa2e 100644
--- a/deps/icu-small/source/i18n/unesctrn.cpp
+++ b/deps/icu-small/source/i18n/unesctrn.cpp
@@ -175,13 +175,13 @@ void UnescapeTransliterator::handleTransliterate(Replaceable& text, UTransPositi
                                                  UBool isIncremental) const {
     int32_t start = pos.start;
     int32_t limit = pos.limit;
-    int32_t i, j, ipat;
+    int32_t i, ipat;
 
     while (start < limit) {
         // Loop over the forms in spec[].  Exit this loop when we
         // match one of the specs.  Exit the outer loop if a
         // partial match is detected and isIncremental is true.
-        for (j=0, ipat=0; spec[ipat] != END; ++j) {
+        for (ipat=0; spec[ipat] != END;) {
 
             // Read the header
             int32_t prefixLen = spec[ipat++];
@@ -193,7 +193,7 @@ void UnescapeTransliterator::handleTransliterate(Replaceable& text, UTransPositi
             // s is a copy of start that is advanced over the
             // characters as we parse them.
             int32_t s = start;
-            UBool match = TRUE;
+            UBool match = true;
 
             for (i=0; i<prefixLen; ++i) {
                 if (s >= limit) {
@@ -205,13 +205,13 @@ void UnescapeTransliterator::handleTransliterate(Replaceable& text, UTransPositi
                         if (isIncremental) {
                             goto exit;
                         }
-                        match = FALSE;
+                        match = false;
                         break;
                     }
                 }
                 UChar c = text.charAt(s++);
                 if (c != spec[ipat + i]) {
-                    match = FALSE;
+                    match = false;
                     break;
                 }
             }
@@ -248,12 +248,12 @@ void UnescapeTransliterator::handleTransliterate(Replaceable& text, UTransPositi
                             if (s > start && isIncremental) {
                                 goto exit;
                             }
-                            match = FALSE;
+                            match = false;
                             break;
                         }
                         UChar c = text.charAt(s++);
                         if (c != spec[ipat + prefixLen + i]) {
-                            match = FALSE;
+                            match = false;
                             break;
                         }
                     }
diff --git a/deps/icu-small/source/i18n/uni2name.cpp b/deps/icu-small/source/i18n/uni2name.cpp
index 904da0207b..97df92b097 100644
--- a/deps/icu-small/source/i18n/uni2name.cpp
+++ b/deps/icu-small/source/i18n/uni2name.cpp
@@ -91,7 +91,7 @@ void UnicodeNameTransliterator::handleTransliterate(Replaceable& text, UTransPos
     int32_t cursor = offsets.start;
     int32_t limit = offsets.limit;
 
-    UnicodeString str(FALSE, OPEN_DELIM, OPEN_DELIM_LEN);
+    UnicodeString str(false, OPEN_DELIM, OPEN_DELIM_LEN);
     UErrorCode status;
     int32_t len;
 
diff --git a/deps/icu-small/source/i18n/unicode/alphaindex.h b/deps/icu-small/source/i18n/unicode/alphaindex.h
index d0cdd817fb..ec50822d58 100644
--- a/deps/icu-small/source/i18n/unicode/alphaindex.h
+++ b/deps/icu-small/source/i18n/unicode/alphaindex.h
@@ -649,7 +649,7 @@ private:
       * No Copy constructor.
       * @internal (private)
       */
-     AlphabeticIndex(const AlphabeticIndex &other);
+     AlphabeticIndex(const AlphabeticIndex &other) = delete;
 
      /**
       *   No assignment.
diff --git a/deps/icu-small/source/i18n/unicode/basictz.h b/deps/icu-small/source/i18n/unicode/basictz.h
index d9f85e45ee..a1c94e523a 100644
--- a/deps/icu-small/source/i18n/unicode/basictz.h
+++ b/deps/icu-small/source/i18n/unicode/basictz.h
@@ -186,13 +186,15 @@ protected:
 
 #ifndef U_HIDE_INTERNAL_API
     /**
-     * The time type option bit masks used by getOffsetFromLocal
+     * A time type option bit mask used by getOffsetFromLocal.
      * @internal
      */
-    enum {
-        kStdDstMask = kDaylight,
-        kFormerLatterMask = kLatter
-    };
+    static constexpr int32_t kStdDstMask = kDaylight;
+    /**
+     * A time type option bit mask used by getOffsetFromLocal.
+     * @internal
+     */
+    static constexpr int32_t kFormerLatterMask = kLatter;
 #endif  /* U_HIDE_INTERNAL_API */
 
     /**
diff --git a/deps/icu-small/source/i18n/unicode/calendar.h b/deps/icu-small/source/i18n/unicode/calendar.h
index c1bdf92820..3c0e5c3e3e 100644
--- a/deps/icu-small/source/i18n/unicode/calendar.h
+++ b/deps/icu-small/source/i18n/unicode/calendar.h
@@ -962,16 +962,6 @@ public:
      */
     UCalendarWallTimeOption getSkippedWallTimeOption(void) const;
 
-#ifndef U_HIDE_DEPRECATED_API
-    /**
-     * Sets what the first day of the week is; e.g., Sunday in US, Monday in France.
-     *
-     * @param value  The given first day of the week.
-     * @deprecated ICU 2.6. Use setFirstDayOfWeek(UCalendarDaysOfWeek value) instead.
-     */
-    void setFirstDayOfWeek(EDaysOfWeek value);
-#endif  /* U_HIDE_DEPRECATED_API */
-
     /**
      * Sets what the first day of the week is; e.g., Sunday in US, Monday in France.
      *
@@ -1143,26 +1133,6 @@ public:
      */
     virtual int32_t getActualMinimum(UCalendarDateFields field, UErrorCode& status) const;
 
-#ifndef U_HIDE_DEPRECATED_API
-    /**
-     * Return the maximum value that this field could have, given the current date.
-     * For example, with the date "Feb 3, 1997" and the DAY_OF_MONTH field, the actual
-     * maximum would be 28; for "Feb 3, 1996" it s 29.  Similarly for a Hebrew calendar,
-     * for some years the actual maximum for MONTH is 12, and for others 13.
-     *
-     * The version of this function on Calendar uses an iterative algorithm to determine the
-     * actual maximum value for the field.  There is almost always a more efficient way to
-     * accomplish this (in most cases, you can simply return getMaximum()).  GregorianCalendar
-     * overrides this function with a more efficient implementation.
-     *
-     * @param field    the field to determine the maximum of
-     * @param status   Fill-in parameter which receives the status of this operation.
-     * @return         the maximum of the given field for the current date of this Calendar
-     * @deprecated ICU 2.6. Use getActualMaximum(UCalendarDateFields field, UErrorCode& status) instead.
-     */
-    int32_t getActualMaximum(EDateFields field, UErrorCode& status) const;
-#endif  /* U_HIDE_DEPRECATED_API */
-
     /**
      * Return the maximum value that this field could have, given the current date.
      * For example, with the date "Feb 3, 1997" and the DAY_OF_MONTH field, the actual
@@ -1181,23 +1151,6 @@ public:
      */
     virtual int32_t getActualMaximum(UCalendarDateFields field, UErrorCode& status) const;
 
-#ifndef U_HIDE_DEPRECATED_API
-    /**
-     * Gets the value for a given time field. Recalculate the current time field values
-     * if the time value has been changed by a call to setTime(). Return zero for unset
-     * fields if any fields have been explicitly set by a call to set(). To force a
-     * recomputation of all fields regardless of the previous state, call complete().
-     * This method is semantically const, but may alter the object in memory.
-     *
-     * @param field  The given time field.
-     * @param status Fill-in parameter which receives the status of the operation.
-     * @return       The value for the given time field, or zero if the field is unset,
-     *               and set() has been called for any other field.
-     * @deprecated ICU 2.6. Use get(UCalendarDateFields field, UErrorCode& status) instead.
-     */
-    int32_t get(EDateFields field, UErrorCode& status) const;
-#endif  /* U_HIDE_DEPRECATED_API */
-
     /**
      * Gets the value for a given time field. Recalculate the current time field values
      * if the time value has been changed by a call to setTime(). Return zero for unset
@@ -1213,18 +1166,6 @@ public:
      */
     int32_t get(UCalendarDateFields field, UErrorCode& status) const;
 
-#ifndef U_HIDE_DEPRECATED_API
-    /**
-     * Determines if the given time field has a value set. This can affect in the
-     * resolving of time in Calendar. Unset fields have a value of zero, by definition.
-     *
-     * @param field  The given time field.
-     * @return   True if the given time field has a value set; false otherwise.
-     * @deprecated ICU 2.6. Use isSet(UCalendarDateFields field) instead.
-     */
-    UBool isSet(EDateFields field) const;
-#endif  /* U_HIDE_DEPRECATED_API */
-
     /**
      * Determines if the given time field has a value set. This can affect in the
      * resolving of time in Calendar. Unset fields have a value of zero, by definition.
@@ -1235,17 +1176,6 @@ public:
      */
     UBool isSet(UCalendarDateFields field) const;
 
-#ifndef U_HIDE_DEPRECATED_API
-    /**
-     * Sets the given time field with the given value.
-     *
-     * @param field  The given time field.
-     * @param value  The value to be set for the given time field.
-     * @deprecated ICU 2.6. Use set(UCalendarDateFields field, int32_t value) instead.
-     */
-    void set(EDateFields field, int32_t value);
-#endif  /* U_HIDE_DEPRECATED_API */
-
     /**
      * Sets the given time field with the given value.
      *
@@ -1304,18 +1234,6 @@ public:
      */
     void clear(void);
 
-#ifndef U_HIDE_DEPRECATED_API
-    /**
-     * Clears the value in the given time field, both making it unset and assigning it a
-     * value of zero. This field value will be determined during the next resolving of
-     * time into time fields.
-     *
-     * @param field  The time field to be cleared.
-     * @deprecated ICU 2.6. Use clear(UCalendarDateFields field) instead.
-     */
-    void clear(EDateFields field);
-#endif  /* U_HIDE_DEPRECATED_API */
-
     /**
      * Clears the value in the given time field, both making it unset and assigning it a
      * value of zero. This field value will be determined during the next resolving of
@@ -1766,16 +1684,22 @@ protected:
     int32_t newestStamp(UCalendarDateFields start, UCalendarDateFields end, int32_t bestSoFar) const;
 
     /**
-     * Values for field resolution tables
+     * Marker for end of resolve set (row or group). Value for field resolution tables.
+     *
      * @see #resolveFields
      * @internal
      */
-    enum {
-      /** Marker for end of resolve set (row or group). */
-      kResolveSTOP = -1,
-      /** Value to be bitwised "ORed" against resolve table field values for remapping.  Example: (UCAL_DATE | kResolveRemap) in 1st column will cause 'UCAL_DATE' to be returned, but will not examine the value of UCAL_DATE.  */
-      kResolveRemap = 32
-    };
+    static constexpr int32_t kResolveSTOP = -1;
+    /**
+     * Value to be bitwised "ORed" against resolve table field values for remapping.
+     * Example: (UCAL_DATE | kResolveRemap) in 1st column will cause 'UCAL_DATE' to be returned,
+     * but will not examine the value of UCAL_DATE.
+     * Value for field resolution tables.
+     *
+     * @see #resolveFields
+     * @internal
+     */
+    static constexpr int32_t kResolveRemap = 32;
 
     /**
      * Precedence table for Dates
diff --git a/deps/icu-small/source/i18n/unicode/choicfmt.h b/deps/icu-small/source/i18n/unicode/choicfmt.h
index 0e7ae186d4..66f437e52f 100644
--- a/deps/icu-small/source/i18n/unicode/choicfmt.h
+++ b/deps/icu-small/source/i18n/unicode/choicfmt.h
@@ -478,7 +478,7 @@ private:
      */
     static UnicodeString& dtos(double value, UnicodeString& string);
 
-    ChoiceFormat(); // default constructor not implemented
+    ChoiceFormat() = delete; // default constructor not implemented
 
     /**
      * Construct a new ChoiceFormat with the limits and the corresponding formats
diff --git a/deps/icu-small/source/i18n/unicode/coleitr.h b/deps/icu-small/source/i18n/unicode/coleitr.h
index 4e68c6f174..d3ddd0ee04 100644
--- a/deps/icu-small/source/i18n/unicode/coleitr.h
+++ b/deps/icu-small/source/i18n/unicode/coleitr.h
@@ -351,7 +351,7 @@ private:
     const CollationElementIterator&
         operator=(const CollationElementIterator& other);
 
-    CollationElementIterator(); // default constructor not implemented
+    CollationElementIterator() = delete; // default constructor not implemented
 
     /** Normalizes dir_=1 (just after setOffset()) to dir_=0 (just after reset()). */
     inline int8_t normalizeDir() const { return dir_ == 1 ? 0 : dir_; }
diff --git a/deps/icu-small/source/i18n/unicode/coll.h b/deps/icu-small/source/i18n/unicode/coll.h
index 9e0050ba6c..6aa35bb5b7 100644
--- a/deps/icu-small/source/i18n/unicode/coll.h
+++ b/deps/icu-small/source/i18n/unicode/coll.h
@@ -1202,7 +1202,7 @@ private:
     /**
      * Assignment operator. Private for now.
      */
-    Collator& operator=(const Collator& other);
+    Collator& operator=(const Collator& other) = delete;
 
     friend class CFactory;
     friend class SimpleCFactory;
diff --git a/deps/icu-small/source/i18n/unicode/displayoptions.h b/deps/icu-small/source/i18n/unicode/displayoptions.h
new file mode 100644
index 0000000000..7bc763bbac
--- /dev/null
+++ b/deps/icu-small/source/i18n/unicode/displayoptions.h
@@ -0,0 +1,274 @@
+// © 2022 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html
+
+#ifndef __DISPLAYOPTIONS_H__
+#define __DISPLAYOPTIONS_H__
+
+#include "unicode/utypes.h"
+
+#if U_SHOW_CPLUSPLUS_API
+
+#if !UCONFIG_NO_FORMATTING
+
+/**
+ * \file
+ * \brief C++ API: Display options class
+ *
+ * This class is designed as a more modern version of the UDisplayContext mechanism.
+ */
+
+#include "unicode/udisplayoptions.h"
+#include "unicode/uversion.h"
+
+U_NAMESPACE_BEGIN
+
+#ifndef U_HIDE_DRAFT_API
+
+/**
+ * Represents all the display options that are supported by CLDR such as grammatical case, noun
+ * class, ... etc. It currently supports enums, but may be extended in the future to have other
+ * types of data. It replaces a DisplayContext[] as a method parameter.
+ *
+ * NOTE: This class is Immutable, and uses a Builder interface.
+ *
+ * For example:
+ * ```
+ * DisplayOptions x =
+ *     DisplayOptions::builder().
+ *         .setGrammaticalCase(UDISPOPT_GRAMMATICAL_CASE_DATIVE)
+ *         .setPluralCategory(UDISPOPT_PLURAL_CATEGORY_FEW)
+ *         .build();
+ * ```
+ *
+ * @draft ICU 72
+ */
+class U_I18N_API DisplayOptions {
+public:
+    /**
+     * Responsible for building `DisplayOptions`.
+     *
+     * @draft ICU 72
+     */
+    class U_I18N_API Builder {
+    public:
+        /**
+         * Sets the grammatical case.
+         *
+         * @param grammaticalCase The grammatical case.
+         * @return Builder
+         * @draft ICU 72
+         */
+        Builder &setGrammaticalCase(UDisplayOptionsGrammaticalCase grammaticalCase) {
+            this->grammaticalCase = grammaticalCase;
+            return *this;
+        }
+
+        /**
+         * Sets the noun class.
+         *
+         * @param nounClass The noun class.
+         * @return Builder
+         * @draft ICU 72
+         */
+        Builder &setNounClass(UDisplayOptionsNounClass nounClass) {
+            this->nounClass = nounClass;
+            return *this;
+        }
+
+        /**
+         * Sets the plural category.
+         *
+         * @param pluralCategory The plural category.
+         * @return Builder
+         * @draft ICU 72
+         */
+        Builder &setPluralCategory(UDisplayOptionsPluralCategory pluralCategory) {
+            this->pluralCategory = pluralCategory;
+            return *this;
+        }
+
+        /**
+         * Sets the capitalization.
+         *
+         * @param capitalization The capitalization.
+         * @return Builder
+         * @draft ICU 72
+         */
+        Builder &setCapitalization(UDisplayOptionsCapitalization capitalization) {
+            this->capitalization = capitalization;
+            return *this;
+        }
+
+        /**
+         * Sets the dialect handling.
+         *
+         * @param nameStyle The name style.
+         * @return Builder
+         * @draft ICU 72
+         */
+        Builder &setNameStyle(UDisplayOptionsNameStyle nameStyle) {
+            this->nameStyle = nameStyle;
+            return *this;
+        }
+
+        /**
+         * Sets the display length.
+         *
+         * @param displayLength The display length.
+         * @return Builder
+         * @draft ICU 72
+         */
+        Builder &setDisplayLength(UDisplayOptionsDisplayLength displayLength) {
+            this->displayLength = displayLength;
+            return *this;
+        }
+
+        /**
+         * Sets the substitute handling.
+         *
+         * @param substituteHandling The substitute handling.
+         * @return Builder
+         * @draft ICU 72
+         */
+        Builder &setSubstituteHandling(UDisplayOptionsSubstituteHandling substituteHandling) {
+            this->substituteHandling = substituteHandling;
+            return *this;
+        }
+
+        /**
+         * Builds the display options.
+         *
+         * @return DisplayOptions
+         * @draft ICU 72
+         */
+        DisplayOptions build() { return DisplayOptions(*this); }
+
+    private:
+        friend DisplayOptions;
+
+        Builder();
+        Builder(const DisplayOptions &displayOptions);
+
+        UDisplayOptionsGrammaticalCase grammaticalCase;
+        UDisplayOptionsNounClass nounClass;
+        UDisplayOptionsPluralCategory pluralCategory;
+        UDisplayOptionsCapitalization capitalization;
+        UDisplayOptionsNameStyle nameStyle;
+        UDisplayOptionsDisplayLength displayLength;
+        UDisplayOptionsSubstituteHandling substituteHandling;
+    };
+
+    /**
+     * Creates a builder with the `UNDEFINED` values for all the parameters.
+     *
+     * @return Builder
+     * @draft ICU 72
+     */
+    static Builder builder();
+    /**
+     * Creates a builder with the same parameters from this object.
+     *
+     * @return Builder
+     * @draft ICU 72
+     */
+    Builder copyToBuilder() const;
+    /**
+     * Gets the grammatical case.
+     *
+     * @return UDisplayOptionsGrammaticalCase
+     * @draft ICU 72
+     */
+    UDisplayOptionsGrammaticalCase getGrammaticalCase() const { return grammaticalCase; }
+
+    /**
+     * Gets the noun class.
+     *
+     * @return UDisplayOptionsNounClass
+     * @draft ICU 72
+     */
+    UDisplayOptionsNounClass getNounClass() const { return nounClass; }
+
+    /**
+     * Gets the plural category.
+     *
+     * @return UDisplayOptionsPluralCategory
+     * @draft ICU 72
+     */
+    UDisplayOptionsPluralCategory getPluralCategory() const { return pluralCategory; }
+
+    /**
+     * Gets the capitalization.
+     *
+     * @return UDisplayOptionsCapitalization
+     * @draft ICU 72
+     */
+    UDisplayOptionsCapitalization getCapitalization() const { return capitalization; }
+
+    /**
+     * Gets the dialect handling.
+     *
+     * @return UDisplayOptionsNameStyle
+     * @draft ICU 72
+     */
+    UDisplayOptionsNameStyle getNameStyle() const { return nameStyle; }
+
+    /**
+     * Gets the display length.
+     *
+     * @return UDisplayOptionsDisplayLength
+     * @draft ICU 72
+     */
+    UDisplayOptionsDisplayLength getDisplayLength() const { return displayLength; }
+
+    /**
+     * Gets the substitute handling.
+     *
+     * @return UDisplayOptionsSubstituteHandling
+     * @draft ICU 72
+     */
+    UDisplayOptionsSubstituteHandling getSubstituteHandling() const { return substituteHandling; }
+
+    /**
+     * Copies the DisplayOptions.
+     *
+     * @param other The options to copy.
+     * @draft ICU 72
+     */
+    DisplayOptions &operator=(const DisplayOptions &other) = default;
+
+    /**
+     * Moves the DisplayOptions.
+     *
+     * @param other The options to move from.
+     * @draft ICU 72
+     */
+    DisplayOptions &operator=(DisplayOptions &&other) noexcept = default;
+
+    /**
+     * Copies the DisplayOptions.
+     *
+     * @param other The options to copy.
+     * @draft ICU 72
+     */
+    DisplayOptions(const DisplayOptions &other) = default;
+
+private:
+    DisplayOptions(const Builder &builder);
+    UDisplayOptionsGrammaticalCase grammaticalCase;
+    UDisplayOptionsNounClass nounClass;
+    UDisplayOptionsPluralCategory pluralCategory;
+    UDisplayOptionsCapitalization capitalization;
+    UDisplayOptionsNameStyle nameStyle;
+    UDisplayOptionsDisplayLength displayLength;
+    UDisplayOptionsSubstituteHandling substituteHandling;
+};
+
+#endif // U_HIDE_DRAFT_API
+
+U_NAMESPACE_END
+
+#endif /* #if !UCONFIG_NO_FORMATTING */
+
+#endif /* U_SHOW_CPLUSPLUS_API */
+
+#endif // __DISPLAYOPTIONS_H__
diff --git a/deps/icu-small/source/i18n/unicode/dtfmtsym.h b/deps/icu-small/source/i18n/unicode/dtfmtsym.h
index 200b3a6ef1..9dbd728837 100644
--- a/deps/icu-small/source/i18n/unicode/dtfmtsym.h
+++ b/deps/icu-small/source/i18n/unicode/dtfmtsym.h
@@ -920,7 +920,7 @@ private:
     char validLocale[ULOC_FULLNAME_CAPACITY];
     char actualLocale[ULOC_FULLNAME_CAPACITY];
 
-    DateFormatSymbols(); // default constructor not implemented
+    DateFormatSymbols() = delete; // default constructor not implemented
 
     /**
      * Called by the constructors to actually load data from the resources
diff --git a/deps/icu-small/source/i18n/unicode/dtitvinf.h b/deps/icu-small/source/i18n/unicode/dtitvinf.h
index b5afc06467..a1f4f426a1 100644
--- a/deps/icu-small/source/i18n/unicode/dtitvinf.h
+++ b/deps/icu-small/source/i18n/unicode/dtitvinf.h
@@ -343,7 +343,7 @@ private:
     /**
      * Internal struct used to load resource bundle data.
      */
-    struct DateIntervalSink;
+    struct U_HIDDEN DateIntervalSink;
 
     /**
      * Following is for saving the interval patterns.
diff --git a/deps/icu-small/source/i18n/unicode/dtptngen.h b/deps/icu-small/source/i18n/unicode/dtptngen.h
index 6be0e2a571..6d2351ffca 100644
--- a/deps/icu-small/source/i18n/unicode/dtptngen.h
+++ b/deps/icu-small/source/i18n/unicode/dtptngen.h
@@ -83,13 +83,6 @@ public:
      */
     static DateTimePatternGenerator* U_EXPORT2 createInstanceNoStdPat(const Locale& uLocale, UErrorCode& status);
 
-    /**
-     * For ICU use only
-     *
-     * @internal
-     */
-    static DateTimePatternGenerator* U_EXPORT2 internalMakeInstance(const Locale& uLocale, UErrorCode& status);
-
 #endif /* U_HIDE_INTERNAL_API */
 
     /**
@@ -665,9 +658,9 @@ private:
     static void U_CALLCONV loadAllowedHourFormatsData(UErrorCode &status);
     void getAllowedHourFormats(const Locale &locale, UErrorCode &status);
 
-    struct AppendItemFormatsSink;
-    struct AppendItemNamesSink;
-    struct AvailableFormatsSink;
+    struct U_HIDDEN AppendItemFormatsSink;
+    struct U_HIDDEN AppendItemNamesSink;
+    struct U_HIDDEN AvailableFormatsSink;
 } ;// end class DateTimePatternGenerator
 
 U_NAMESPACE_END
diff --git a/deps/icu-small/source/i18n/unicode/gender.h b/deps/icu-small/source/i18n/unicode/gender.h
index cf7fee963e..c81f7c88cc 100644
--- a/deps/icu-small/source/i18n/unicode/gender.h
+++ b/deps/icu-small/source/i18n/unicode/gender.h
@@ -91,12 +91,12 @@ private:
      * Copy constructor. One object per locale invariant. Clients
      * must never copy GenderInfo objects.
      */
-    GenderInfo(const GenderInfo& other);
+    GenderInfo(const GenderInfo& other) = delete;
 
     /**
       * Assignment operator. Not applicable to immutable objects.
       */
-    GenderInfo& operator=(const GenderInfo&);
+    GenderInfo& operator=(const GenderInfo&) = delete;
 
     GenderInfo();
 
diff --git a/deps/icu-small/source/i18n/unicode/gregocal.h b/deps/icu-small/source/i18n/unicode/gregocal.h
index 4c2be18251..d97b33b7ac 100644
--- a/deps/icu-small/source/i18n/unicode/gregocal.h
+++ b/deps/icu-small/source/i18n/unicode/gregocal.h
@@ -411,19 +411,6 @@ public:
      */
     int32_t getActualMinimum(UCalendarDateFields field, UErrorCode &status) const override;
 
-#ifndef U_HIDE_DEPRECATED_API
-    /**
-     * Return the maximum value that this field could have, given the current date.
-     * For example, with the date "Feb 3, 1997" and the DAY_OF_MONTH field, the actual
-     * maximum would be 28; for "Feb 3, 1996" it s 29.  Similarly for a Hebrew calendar,
-     * for some years the actual maximum for MONTH is 12, and for others 13.
-     * @param field    the time field.
-     * @return         the maximum value that this field could have, given the current date.
-     * @deprecated ICU 2.6. Use getActualMaximum(UCalendarDateFields field) instead.
-     */
-    int32_t getActualMaximum(EDateFields field) const;
-#endif  /* U_HIDE_DEPRECATED_API */
-
     /**
      * Return the maximum value that this field could have, given the current date.
      * For example, with the date "Feb 3, 1997" and the DAY_OF_MONTH field, the actual
@@ -487,7 +474,7 @@ public:
     virtual const char * getType() const override;
 
  private:
-    GregorianCalendar(); // default constructor not implemented
+    GregorianCalendar() = delete; // default constructor not implemented
 
  protected:
     /**
@@ -715,12 +702,6 @@ public:
      */
     int32_t fGregorianCutoverYear;// = 1582;
 
-    /**
-     * The year of the gregorianCutover, with 0 representing
-     * 1 BC, -1 representing 2 BC, etc.
-     */
-    int32_t fGregorianCutoverJulianDay;// = 2299161;
-
     /**
      * Converts time as milliseconds to Julian date. The Julian date used here is not a
      * true Julian date, since it is measured from midnight, not noon.
diff --git a/deps/icu-small/source/i18n/unicode/listformatter.h b/deps/icu-small/source/i18n/unicode/listformatter.h
index d7ab1d2086..0277afd167 100644
--- a/deps/icu-small/source/i18n/unicode/listformatter.h
+++ b/deps/icu-small/source/i18n/unicode/listformatter.h
@@ -268,14 +268,10 @@ class U_I18N_API ListFormatter : public UObject{
 
     static void initializeHash(UErrorCode& errorCode);
     static const ListFormatInternal* getListFormatInternal(const Locale& locale, const char *style, UErrorCode& errorCode);
-    struct ListPatternsSink;
+    struct U_HIDDEN ListPatternsSink;
     static ListFormatInternal* loadListFormatInternal(const Locale& locale, const char* style, UErrorCode& errorCode);
 
-    UnicodeString& format_(
-        const UnicodeString items[], int32_t n_items, UnicodeString& appendTo,
-        int32_t index, int32_t &offset, FieldPositionHandler* handler, UErrorCode& errorCode) const;
-
-    ListFormatter();
+    ListFormatter() = delete;
 
     ListFormatInternal* owned;
     const ListFormatInternal* data;
diff --git a/deps/icu-small/source/i18n/unicode/measunit.h b/deps/icu-small/source/i18n/unicode/measunit.h
index b7e8e1676a..6a64ae2bb3 100644
--- a/deps/icu-small/source/i18n/unicode/measunit.h
+++ b/deps/icu-small/source/i18n/unicode/measunit.h
@@ -950,23 +950,21 @@ class U_I18N_API MeasureUnit: public UObject {
      */
     static MeasureUnit getSquareYard();
 
-#ifndef U_HIDE_DRAFT_API
     /**
      * Returns by pointer, unit of concentr: item.
      * Caller owns returned value and must free it.
      * Also see {@link #getItem()}.
      * @param status ICU error code.
-     * @draft ICU 70
+     * @stable ICU 70
      */
     static MeasureUnit *createItem(UErrorCode &status);
 
     /**
      * Returns by value, unit of concentr: item.
      * Also see {@link #createItem()}.
-     * @draft ICU 70
+     * @stable ICU 70
      */
     static MeasureUnit getItem();
-#endif /* U_HIDE_DRAFT_API */
 
     /**
      * Returns by pointer, unit of concentr: karat.
@@ -1528,6 +1526,24 @@ class U_I18N_API MeasureUnit: public UObject {
      */
     static MeasureUnit getNanosecond();
 
+#ifndef U_HIDE_DRAFT_API
+    /**
+     * Returns by pointer, unit of duration: quarter.
+     * Caller owns returned value and must free it.
+     * Also see {@link #getQuarter()}.
+     * @param status ICU error code.
+     * @draft ICU 72
+     */
+    static MeasureUnit *createQuarter(UErrorCode &status);
+
+    /**
+     * Returns by value, unit of duration: quarter.
+     * Also see {@link #createQuarter()}.
+     * @draft ICU 72
+     */
+    static MeasureUnit getQuarter();
+#endif /* U_HIDE_DRAFT_API */
+
     /**
      * Returns by pointer, unit of duration: second.
      * Caller owns returned value and must free it.
@@ -1816,23 +1832,21 @@ class U_I18N_API MeasureUnit: public UObject {
      */
     static MeasureUnit getThermUs();
 
-#ifndef U_HIDE_DRAFT_API
     /**
      * Returns by pointer, unit of force: kilowatt-hour-per-100-kilometer.
      * Caller owns returned value and must free it.
      * Also see {@link #getKilowattHourPer100Kilometer()}.
      * @param status ICU error code.
-     * @draft ICU 70
+     * @stable ICU 70
      */
     static MeasureUnit *createKilowattHourPer100Kilometer(UErrorCode &status);
 
     /**
      * Returns by value, unit of force: kilowatt-hour-per-100-kilometer.
      * Also see {@link #createKilowattHourPer100Kilometer()}.
-     * @draft ICU 70
+     * @stable ICU 70
      */
     static MeasureUnit getKilowattHourPer100Kilometer();
-#endif /* U_HIDE_DRAFT_API */
 
     /**
      * Returns by pointer, unit of force: newton.
@@ -2571,17 +2585,25 @@ class U_I18N_API MeasureUnit: public UObject {
     static MeasureUnit getKilogram();
 
     /**
-     * Returns by pointer, unit of mass: metric-ton.
+     * Returns by pointer, unit of mass: metric-ton
+     * (renamed to tonne in CLDR 42 / ICU 72).
      * Caller owns returned value and must free it.
-     * Also see {@link #getMetricTon()}.
+     * Note: In ICU 74 this will be deprecated in favor of
+     * createTonne(), which is currently draft but will
+     * become stable in ICU 74, and which uses the preferred naming.
+     * Also see {@link #getMetricTon()} and {@link #createTonne()}.
      * @param status ICU error code.
      * @stable ICU 54
      */
     static MeasureUnit *createMetricTon(UErrorCode &status);
 
     /**
-     * Returns by value, unit of mass: metric-ton.
-     * Also see {@link #createMetricTon()}.
+     * Returns by value, unit of mass: metric-ton
+     * (renamed to tonne in CLDR 42 / ICU 72).
+     * Note: In ICU 74 this will be deprecated in favor of
+     * getTonne(), which is currently draft but will
+     * become stable in ICU 74, and which uses the preferred naming.
+     * Also see {@link #createMetricTon()} and {@link #getTonne()}.
      * @stable ICU 64
      */
     static MeasureUnit getMetricTon();
@@ -2714,6 +2736,24 @@ class U_I18N_API MeasureUnit: public UObject {
      */
     static MeasureUnit getTon();
 
+#ifndef U_HIDE_DRAFT_API
+    /**
+     * Returns by pointer, unit of mass: tonne.
+     * Caller owns returned value and must free it.
+     * Also see {@link #getTonne()}.
+     * @param status ICU error code.
+     * @draft ICU 72
+     */
+    static MeasureUnit *createTonne(UErrorCode &status);
+
+    /**
+     * Returns by value, unit of mass: tonne.
+     * Also see {@link #createTonne()}.
+     * @draft ICU 72
+     */
+    static MeasureUnit getTonne();
+#endif /* U_HIDE_DRAFT_API */
+
     /**
      * Returns by pointer, unit of power: gigawatt.
      * Caller owns returned value and must free it.
diff --git a/deps/icu-small/source/i18n/unicode/msgfmt.h b/deps/icu-small/source/i18n/unicode/msgfmt.h
index c949132fda..76e1ab788e 100644
--- a/deps/icu-small/source/i18n/unicode/msgfmt.h
+++ b/deps/icu-small/source/i18n/unicode/msgfmt.h
@@ -886,7 +886,7 @@ private:
     Format**            formatAliases; // see getFormats
     int32_t             formatAliasesCapacity;
 
-    MessageFormat(); // default constructor not implemented
+    MessageFormat() = delete; // default constructor not implemented
 
      /**
       * This provider helps defer instantiation of a PluralRules object
@@ -1011,8 +1011,6 @@ private:
 
     void cacheExplicitFormats(UErrorCode& status);
 
-    int32_t skipLeadingSpaces(UnicodeString& style);
-
     Format* createAppropriateFormat(UnicodeString& type,
                                     UnicodeString& style,
                                     Formattable::Type& formattableType,
diff --git a/deps/icu-small/source/i18n/unicode/numberformatter.h b/deps/icu-small/source/i18n/unicode/numberformatter.h
index 711064ece8..be2056be36 100644
--- a/deps/icu-small/source/i18n/unicode/numberformatter.h
+++ b/deps/icu-small/source/i18n/unicode/numberformatter.h
@@ -14,6 +14,7 @@
 #include "unicode/bytestream.h"
 #include "unicode/currunit.h"
 #include "unicode/dcfmtsym.h"
+#include "unicode/displayoptions.h"
 #include "unicode/fieldpos.h"
 #include "unicode/formattedvalue.h"
 #include "unicode/fpositer.h"
@@ -22,7 +23,7 @@
 #include "unicode/parseerr.h"
 #include "unicode/plurrule.h"
 #include "unicode/ucurr.h"
-#include "unicode/unounclass.h"
+#include "unicode/udisplayoptions.h"
 #include "unicode/unum.h"
 #include "unicode/unumberformatter.h"
 #include "unicode/uobject.h"
@@ -2254,23 +2255,50 @@ class U_I18N_API NumberFormatterSettings {
     Derived usage(StringPiece usage) &&;
 
 #ifndef U_HIDE_DRAFT_API
+    /**
+     * Specifies the DisplayOptions. For example, UDisplayOptionsGrammaticalCase specifies
+     * the desired case for a unit formatter's output (e.g. accusative, dative, genitive).
+     *
+     * @param displayOptions
+     * @return The fluent chain.
+     * @draft ICU 72
+     */
+    Derived displayOptions(const DisplayOptions &displayOptions) const &;
+
+    /**
+     * Overload of displayOptions() for use on an rvalue reference.
+     *
+     * @param displayOptions
+     * @return The fluent chain.
+     * @draft ICU 72
+     */
+    Derived displayOptions(const DisplayOptions &displayOptions) &&;
+#endif // U_HIDE_DRAFT_API
+
 #ifndef U_HIDE_INTERNAL_API
     /**
+     * NOTE: Use `displayOptions` instead. This method was part of
+     * an internal technology preview in ICU 69, but will be removed
+     * in ICU 73, in favor of `displayOptions`
+     *
      * Specifies the desired case for a unit formatter's output (e.g.
      * accusative, dative, genitive).
      *
-     * @internal ICU 69 technology preview
+     * @internal
      */
     Derived unitDisplayCase(StringPiece unitDisplayCase) const &;
 
     /**
+     * NOTE: Use `displayOptions` instead. This method was part of
+     * an internal technology preview in ICU 69, but will be removed
+     * in ICU 73, in favor of `displayOptions`
+     *
      * Overload of unitDisplayCase() for use on an rvalue reference.
      *
-     * @internal ICU 69 technology preview
+     * @internal
      */
     Derived unitDisplayCase(StringPiece unitDisplayCase) &&;
 #endif // U_HIDE_INTERNAL_API
-#endif // U_HIDE_DRAFT_API
 
 #ifndef U_HIDE_INTERNAL_API
 
@@ -2771,13 +2799,13 @@ class U_I18N_API FormattedNumber : public UMemory, public FormattedValue {
 #ifndef U_HIDE_DRAFT_API
 
     /**
-     * Gets the noun class of the formatted output. Returns `OTHER` when the noun class
+     * Gets the noun class of the formatted output. Returns `UNDEFINED` when the noun class
      * is not supported yet.
      *
-     * @return `NounClass`
-     * @draft ICU 71.
+     * @return UDisplayOptionsNounClass
+     * @draft ICU 72
      */
-    NounClass getNounClass(UErrorCode &status) const;
+    UDisplayOptionsNounClass getNounClass(UErrorCode &status) const;
 
 #endif // U_HIDE_DRAFT_API
 
@@ -2797,18 +2825,6 @@ class U_I18N_API FormattedNumber : public UMemory, public FormattedValue {
 
 #endif  /* U_HIDE_INTERNAL_API */
 
-#ifndef U_HIDE_DEPRECATED_API
-
-    /**
-     * Gets the gender of the formatted output. Returns "" when the gender is
-     * unknown, or for ungendered languages.
-     *
-     * @deprecated This API is for ICU internal use only.
-     */
-    const char *getGender(UErrorCode &status) const;
-
-#endif /* U_HIDE_DEPRECATED_API */
-
   private:
     // Can't use LocalPointer because UFormattedNumberData is forward-declared
     const impl::UFormattedNumberData *fData;
diff --git a/deps/icu-small/source/i18n/unicode/numberrangeformatter.h b/deps/icu-small/source/i18n/unicode/numberrangeformatter.h
index 363f7d48cf..7f535952d2 100644
--- a/deps/icu-small/source/i18n/unicode/numberrangeformatter.h
+++ b/deps/icu-small/source/i18n/unicode/numberrangeformatter.h
@@ -560,8 +560,6 @@ class U_I18N_API LocalizedNumberRangeFormatter
 
     LocalizedNumberRangeFormatter(impl::RangeMacroProps &&macros, const Locale &locale);
 
-    void clear();
-
     // To give the fluent setters access to this class's constructor:
     friend class NumberRangeFormatterSettings<UnlocalizedNumberRangeFormatter>;
     friend class NumberRangeFormatterSettings<LocalizedNumberRangeFormatter>;
@@ -641,14 +639,12 @@ class U_I18N_API FormattedNumberRange : public UMemory, public FormattedValue {
      */
     UNumberRangeIdentityResult getIdentityResult(UErrorCode& status) const;
 
-#ifndef U_HIDE_DRAFT_API
     /**
      * Default constructor; makes an empty FormattedNumberRange.
-     * @draft ICU 70
+     * @stable ICU 70
      */
     FormattedNumberRange()
         : fData(nullptr), fErrorCode(U_INVALID_STATE_ERROR) {}
-#endif  /* U_HIDE_DRAFT_API */
 
     /**
      * Copying not supported; use move constructor instead.
@@ -696,8 +692,6 @@ class U_I18N_API FormattedNumberRange : public UMemory, public FormattedValue {
     explicit FormattedNumberRange(UErrorCode errorCode)
         : fData(nullptr), fErrorCode(errorCode) {}
 
-    void getAllFieldPositionsImpl(FieldPositionIteratorHandler& fpih, UErrorCode& status) const;
-
     void getDecimalNumbers(ByteSink& sink1, ByteSink& sink2, UErrorCode& status) const;
 
     const impl::UFormattedNumberRangeData* getData(UErrorCode& status) const;
diff --git a/deps/icu-small/source/i18n/unicode/numsys.h b/deps/icu-small/source/i18n/unicode/numsys.h
index 4f839d0f35..358dc533a5 100644
--- a/deps/icu-small/source/i18n/unicode/numsys.h
+++ b/deps/icu-small/source/i18n/unicode/numsys.h
@@ -208,10 +208,6 @@ private:
     void setDesc(const UnicodeString &desc);
 
     void setName(const char* name);
-
-    static UBool isValidDigitString(const UnicodeString &str);
-
-    UBool hasContiguousDecimalDigits() const;
 };
 
 U_NAMESPACE_END
diff --git a/deps/icu-small/source/i18n/unicode/plurfmt.h b/deps/icu-small/source/i18n/unicode/plurfmt.h
index db16054605..1bdc369341 100644
--- a/deps/icu-small/source/i18n/unicode/plurfmt.h
+++ b/deps/icu-small/source/i18n/unicode/plurfmt.h
@@ -561,7 +561,7 @@ private:
     double offset;
     PluralSelectorAdapter pluralRulesWrapper;
 
-    PluralFormat();   // default constructor not implemented
+    PluralFormat() = delete;   // default constructor not implemented
     void init(const PluralRules* rules, UPluralType type, UErrorCode& status);
     /**
      * Copies dynamically allocated values (pointer fields).
diff --git a/deps/icu-small/source/i18n/unicode/plurrule.h b/deps/icu-small/source/i18n/unicode/plurrule.h
index e90cd66a7f..b4298de63f 100644
--- a/deps/icu-small/source/i18n/unicode/plurrule.h
+++ b/deps/icu-small/source/i18n/unicode/plurrule.h
@@ -59,9 +59,15 @@ class FormattedNumber;
 class FormattedNumberRange;
 namespace impl {
 class UFormattedNumberRangeData;
+class DecimalQuantity;
+class DecNum;
 }
 }
 
+#ifndef U_HIDE_INTERNAL_API
+using icu::number::impl::DecimalQuantity;
+#endif  /* U_HIDE_INTERNAL_API */
+
 /**
  * Defines rules for mapping non-negative numeric values onto a small set of
  * keywords. Rules are constructed from a text description, consisting
@@ -306,14 +312,6 @@ public:
      */
     static StringEnumeration* U_EXPORT2 getAvailableLocales(UErrorCode &status);
 
-    /**
-     * Returns whether or not there are overrides.
-     * @param locale       the locale to check.
-     * @return
-     * @internal
-     */
-    static UBool hasOverride(const Locale &locale);
-
     /**
      * For ICU use only.
      * creates a  SharedPluralRules object
@@ -476,7 +474,7 @@ public:
 
 #ifndef U_HIDE_INTERNAL_API
     /**
-     * Internal-only function that returns FixedDecimals instead of doubles.
+     * Internal-only function that returns DecimalQuantitys instead of doubles.
      *
      * Returns sample values for which select() would return the keyword.  If
      * the keyword is unknown, returns no values, but this is not an error.
@@ -496,7 +494,7 @@ public:
      * @internal
      */
     int32_t getSamples(const UnicodeString &keyword,
-                       FixedDecimal *dest, int32_t destCapacity,
+                       DecimalQuantity *dest, int32_t destCapacity,
                        UErrorCode& status);
 #endif  /* U_HIDE_INTERNAL_API */
 
@@ -569,9 +567,7 @@ private:
     RuleChain  *mRules;
     StandardPluralRanges *mStandardPluralRanges;
 
-    PluralRules();   // default constructor not implemented
-    void            parseDescription(const UnicodeString& ruleData, UErrorCode &status);
-    int32_t         getNumberValue(const UnicodeString& token) const;
+    PluralRules() = delete;   // default constructor not implemented
     UnicodeString   getRuleFromResource(const Locale& locale, UPluralType type, UErrorCode& status);
     RuleChain      *rulesForKeyword(const UnicodeString &keyword) const;
     PluralRules    *clone(UErrorCode& status) const;
diff --git a/deps/icu-small/source/i18n/unicode/rbnf.h b/deps/icu-small/source/i18n/unicode/rbnf.h
index 0a5a378e13..70d92dd549 100644
--- a/deps/icu-small/source/i18n/unicode/rbnf.h
+++ b/deps/icu-small/source/i18n/unicode/rbnf.h
@@ -54,9 +54,27 @@ class RuleBasedCollator;
  * @stable ICU 2.2
  */
 enum URBNFRuleSetTag {
+    /**
+     * Requests predefined ruleset for spelling out numeric values in words.
+     * @stable ICU 2.2
+     */
     URBNF_SPELLOUT,
+    /**
+     * Requests predefined ruleset for the ordinal form of a number.
+     * @stable ICU 2.2
+     */
     URBNF_ORDINAL,
+    /**
+     * Requests predefined ruleset for formatting a value as a duration in hours, minutes, and seconds.
+     * @stable ICU 2.2
+     */
     URBNF_DURATION,
+    /**
+     * Requests predefined ruleset for various non-place-value numbering systems.
+     * WARNING: The same resource contains rule sets for a variety of different numbering systems.
+     * You need to call setDefaultRuleSet() on the formatter to choose the actual numbering system.
+     * @stable ICU 2.2
+     */
     URBNF_NUMBERING_SYSTEM,
 #ifndef U_HIDE_DEPRECATED_API
     /**
@@ -662,6 +680,9 @@ public:
    * URBNF_DURATION, which formats a duration in seconds as hours, minutes, and seconds always rounding down,
    * and URBNF_NUMBERING_SYSTEM, which is used to invoke rules for alternate numbering
    * systems such as the Hebrew numbering system, or for Roman Numerals, etc.
+   * NOTE: If you use URBNF_NUMBERING_SYSTEM, you must also call setDefaultRuleSet() to
+   * specify the exact numbering system you want to use.  If you want the default numbering system
+   * for the locale, call NumberFormat::createInstance() instead of creating a RuleBasedNumberFormat directly.
    * @param locale The locale for the formatter.
    * @param status The status indicating whether the constructor succeeded.
    * @stable ICU 2.0
@@ -1040,7 +1061,7 @@ public:
     virtual void setDecimalFormatSymbols(const DecimalFormatSymbols& symbols);
 
 private:
-    RuleBasedNumberFormat(); // default constructor not implemented
+    RuleBasedNumberFormat() = delete; // default constructor not implemented
 
     // this will ref the localizations if they are not NULL
     // caller must deref to get adoption
diff --git a/deps/icu-small/source/i18n/unicode/regex.h b/deps/icu-small/source/i18n/unicode/regex.h
index f8e32922f4..39b97441a4 100644
--- a/deps/icu-small/source/i18n/unicode/regex.h
+++ b/deps/icu-small/source/i18n/unicode/regex.h
@@ -22,7 +22,7 @@
 
 /**
  * \file
- * \brief  C++ API:  Regular Expressions
+ * \brief C++ API: Regular Expressions
  *
  * The ICU API for processing regular expressions consists of two classes,
  *  `RegexPattern` and `RegexMatcher`.
@@ -361,7 +361,7 @@ private:
      *
      */
     RegexMatcher *matcher(const char16_t *input,
-        UErrorCode          &status) const;
+        UErrorCode          &status) const = delete;
 public:
 
 
@@ -749,7 +749,7 @@ private:
      * `utext_openUChars(UText *ut, const char16_t *text, int64_t textLength, UErrorCode *status);`
      */
     RegexMatcher(const UnicodeString &regexp, const char16_t *input,
-        uint32_t flags, UErrorCode &status);
+        uint32_t flags, UErrorCode &status) = delete;
 public:
 
 
@@ -1157,7 +1157,7 @@ private:
      * `utext_openUChars(UText *ut, const char16_t *text, int64_t textLength, UErrorCode *status);`
      *
      */
-    RegexMatcher &reset(const char16_t *input);
+    RegexMatcher &reset(const char16_t *input) = delete;
 public:
 
    /**
@@ -1751,10 +1751,10 @@ public:
 private:
     // Constructors and other object boilerplate are private.
     // Instances of RegexMatcher can not be assigned, copied, cloned, etc.
-    RegexMatcher();                  // default constructor not implemented
+    RegexMatcher() = delete;                  // default constructor not implemented
     RegexMatcher(const RegexPattern *pat);
-    RegexMatcher(const RegexMatcher &other);
-    RegexMatcher &operator =(const RegexMatcher &rhs);
+    RegexMatcher(const RegexMatcher &other) = delete;
+    RegexMatcher &operator =(const RegexMatcher &rhs) = delete;
     void init(UErrorCode &status);                      // Common initialization
     void init2(UText *t, UErrorCode &e);  // Common initialization, part 2.
 
diff --git a/deps/icu-small/source/i18n/unicode/scientificnumberformatter.h b/deps/icu-small/source/i18n/unicode/scientificnumberformatter.h
index aa7e80543e..a1dd543638 100644
--- a/deps/icu-small/source/i18n/unicode/scientificnumberformatter.h
+++ b/deps/icu-small/source/i18n/unicode/scientificnumberformatter.h
@@ -196,7 +196,7 @@ public:
             UErrorCode &status);
 
     ScientificNumberFormatter(const ScientificNumberFormatter &other);
-    ScientificNumberFormatter &operator=(const ScientificNumberFormatter &);
+    ScientificNumberFormatter &operator=(const ScientificNumberFormatter &) = delete;
 
     static void getPreExponent(
             const DecimalFormatSymbols &dfs, UnicodeString &preExponent);
diff --git a/deps/icu-small/source/i18n/unicode/selfmt.h b/deps/icu-small/source/i18n/unicode/selfmt.h
index bdce00e593..1802380312 100644
--- a/deps/icu-small/source/i18n/unicode/selfmt.h
+++ b/deps/icu-small/source/i18n/unicode/selfmt.h
@@ -348,7 +348,7 @@ public:
 private:
     friend class MessageFormat;
 
-    SelectFormat();   // default constructor not implemented.
+    SelectFormat() = delete;   // default constructor not implemented.
 
     /**
      * Finds the SelectFormat sub-message for the given keyword, or the "other" sub-message.
diff --git a/deps/icu-small/source/i18n/unicode/simpletz.h b/deps/icu-small/source/i18n/unicode/simpletz.h
index f73d823ee5..cbdba7aff6 100644
--- a/deps/icu-small/source/i18n/unicode/simpletz.h
+++ b/deps/icu-small/source/i18n/unicode/simpletz.h
@@ -800,7 +800,7 @@ private:
         DOW_LE_DOM_MODE
     };
 
-    SimpleTimeZone(); // default constructor not implemented
+    SimpleTimeZone() = delete; // default constructor not implemented
 
     /**
      * Internal construction method.
diff --git a/deps/icu-small/source/i18n/unicode/smpdtfmt.h b/deps/icu-small/source/i18n/unicode/smpdtfmt.h
index 733a1cff13..fb83f90da1 100644
--- a/deps/icu-small/source/i18n/unicode/smpdtfmt.h
+++ b/deps/icu-small/source/i18n/unicode/smpdtfmt.h
@@ -1226,7 +1226,7 @@ private:
 
     void initializeBooleanAttributes(void);
 
-    SimpleDateFormat(); // default constructor not implemented
+    SimpleDateFormat() = delete; // default constructor not implemented
 
     /**
      * Used by the DateFormat factory methods to construct a SimpleDateFormat.
@@ -1359,6 +1359,22 @@ private:
                         const UnicodeString* stringArray, int32_t stringArrayCount,
                         const UnicodeString* monthPattern, Calendar& cal) const;
 
+    /**
+     * Private code-size reduction function used by subParse. Only for UCAL_MONTH
+     * @param text the time text being parsed.
+     * @param start where to start parsing.
+     * @param wideStringArray the wide string array to parsed.
+     * @param shortStringArray the short string array to parsed.
+     * @param stringArrayCount the size of the string arrays.
+     * @param cal a Calendar set to the date and time to be formatted
+     *            into a date/time string.
+     * @return the new start position if matching succeeded; a negative number
+     * indicating matching failure, otherwise.
+     */
+    int32_t matchAlphaMonthStrings(const UnicodeString& text, int32_t start,
+                        const UnicodeString* wideStringArray, const UnicodeString* shortStringArray,
+                        int32_t stringArrayCount, Calendar& cal) const;
+
     /**
      * Private code-size reduction function used by subParse.
      * @param text the time text being parsed.
diff --git a/deps/icu-small/source/i18n/unicode/stsearch.h b/deps/icu-small/source/i18n/unicode/stsearch.h
index c23e651d89..b8a919f614 100644
--- a/deps/icu-small/source/i18n/unicode/stsearch.h
+++ b/deps/icu-small/source/i18n/unicode/stsearch.h
@@ -482,7 +482,7 @@ protected:
     virtual int32_t handlePrev(int32_t position, UErrorCode &status) override;
     
 private :
-    StringSearch(); // default constructor not implemented
+    StringSearch() = delete; // default constructor not implemented
 
     // private data members ----------------------------------------------
 
diff --git a/deps/icu-small/source/i18n/unicode/tzrule.h b/deps/icu-small/source/i18n/unicode/tzrule.h
index ab0b97b6fd..9ec1e96179 100644
--- a/deps/icu-small/source/i18n/unicode/tzrule.h
+++ b/deps/icu-small/source/i18n/unicode/tzrule.h
@@ -258,20 +258,6 @@ public:
      */
     virtual bool operator!=(const TimeZoneRule& that) const override;
 
-    /**
-     * Gets the time when this rule takes effect in the given year.
-     * @param year              The Gregorian year, with 0 == 1 BCE, -1 == 2 BCE, etc.
-     * @param prevRawOffset     The standard time offset from UTC before this rule
-     *                          takes effect in milliseconds.
-     * @param prevDSTSavings    The amount of daylight saving offset from the
-     *                          standard time.
-     * @param result            Receives the start time in the year.
-     * @return  true if this rule takes effect in the year and the result is set to
-     *          "result".
-     * @stable ICU 3.8
-     */
-    UBool getStartInYear(int32_t year, int32_t prevRawOffset, int32_t prevDSTSavings, UDate& result) const;
-
     /**
      * Returns if this rule represents the same rule and offsets as another.
      * When two <code>TimeZoneRule</code> objects differ only its names, this method
diff --git a/deps/icu-small/source/i18n/unicode/udat.h b/deps/icu-small/source/i18n/unicode/udat.h
index 0e6e6b76da..3823dc88c4 100644
--- a/deps/icu-small/source/i18n/unicode/udat.h
+++ b/deps/icu-small/source/i18n/unicode/udat.h
@@ -1532,19 +1532,17 @@ typedef enum UDateFormatSymbolType {
      */
     UDAT_ZODIAC_NAMES_NARROW,
     
-#ifndef U_HIDE_DRAFT_API
     /**
      * The narrow quarter names, for example 1
-     * @draft ICU 70
+     * @stable ICU 70
      */
     UDAT_NARROW_QUARTERS,
     
     /**
      * The narrow standalone quarter names, for example 1
-     * @draft ICU 70
+     * @stable ICU 70
      */
     UDAT_STANDALONE_NARROW_QUARTERS
-#endif // U_HIDE_DRAFT_API
 } UDateFormatSymbolType;
 
 struct UDateFormatSymbols;
diff --git a/deps/icu-small/source/i18n/unicode/udisplayoptions.h b/deps/icu-small/source/i18n/unicode/udisplayoptions.h
new file mode 100644
index 0000000000..1ecdf1d8e9
--- /dev/null
+++ b/deps/icu-small/source/i18n/unicode/udisplayoptions.h
@@ -0,0 +1,325 @@
+// © 2022 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html
+
+#ifndef __UDISPLAYOPTIONS_H__
+#define __UDISPLAYOPTIONS_H__
+
+#include "unicode/utypes.h"
+
+#if !UCONFIG_NO_FORMATTING
+
+/**
+ * \file
+ * \brief C API: Display options (enum types, values, helper functions)
+ *
+ * These display options are designed to be used in class DisplayOptions
+ * as a more modern version of the UDisplayContext mechanism.
+ */
+
+#include "unicode/uversion.h"
+
+#ifndef U_HIDE_DRAFT_API
+
+/**
+ * Represents all the grammatical cases that are supported by CLDR.
+ *
+ * @draft ICU 72
+ */
+typedef enum UDisplayOptionsGrammaticalCase {
+    /**
+     * A possible setting for GrammaticalCase.
+     * The grammatical case context to be used is unknown (this is the default value).
+     * @draft ICU 72
+     */
+    UDISPOPT_GRAMMATICAL_CASE_UNDEFINED = 0,
+    /** @draft ICU 72 */
+    UDISPOPT_GRAMMATICAL_CASE_ABLATIVE = 1,
+    /** @draft ICU 72 */
+    UDISPOPT_GRAMMATICAL_CASE_ACCUSATIVE = 2,
+    /** @draft ICU 72 */
+    UDISPOPT_GRAMMATICAL_CASE_COMITATIVE = 3,
+    /** @draft ICU 72 */
+    UDISPOPT_GRAMMATICAL_CASE_DATIVE = 4,
+    /** @draft ICU 72 */
+    UDISPOPT_GRAMMATICAL_CASE_ERGATIVE = 5,
+    /** @draft ICU 72 */
+    UDISPOPT_GRAMMATICAL_CASE_GENITIVE = 6,
+    /** @draft ICU 72 */
+    UDISPOPT_GRAMMATICAL_CASE_INSTRUMENTAL = 7,
+    /** @draft ICU 72 */
+    UDISPOPT_GRAMMATICAL_CASE_LOCATIVE = 8,
+    /** @draft ICU 72 */
+    UDISPOPT_GRAMMATICAL_CASE_LOCATIVE_COPULATIVE = 9,
+    /** @draft ICU 72 */
+    UDISPOPT_GRAMMATICAL_CASE_NOMINATIVE = 10,
+    /** @draft ICU 72 */
+    UDISPOPT_GRAMMATICAL_CASE_OBLIQUE = 11,
+    /** @draft ICU 72 */
+    UDISPOPT_GRAMMATICAL_CASE_PREPOSITIONAL = 12,
+    /** @draft ICU 72 */
+    UDISPOPT_GRAMMATICAL_CASE_SOCIATIVE = 13,
+    /** @draft ICU 72 */
+    UDISPOPT_GRAMMATICAL_CASE_VOCATIVE = 14,
+} UDisplayOptionsGrammaticalCase;
+
+/**
+ * @param grammaticalCase The grammatical case.
+ * @return the lowercase CLDR keyword string for the grammatical case.
+ *
+ * @draft ICU 72
+ */
+U_CAPI const char * U_EXPORT2
+udispopt_getGrammaticalCaseIdentifier(UDisplayOptionsGrammaticalCase grammaticalCase);
+
+/**
+ * @param identifier in lower case such as "dative" or "nominative"
+ * @return the plural category corresponding to the identifier, or `UDISPOPT_GRAMMATICAL_CASE_UNDEFINED`
+ *
+ * @draft ICU 72
+ */
+U_CAPI UDisplayOptionsGrammaticalCase U_EXPORT2
+udispopt_fromGrammaticalCaseIdentifier(const char *identifier);
+
+/**
+ * Standard CLDR plural form/category constants.
+ * See https://www.unicode.org/reports/tr35/tr35-numbers.html#Language_Plural_Rules
+ *
+ * @draft ICU 72
+ */
+typedef enum UDisplayOptionsPluralCategory {
+
+    /**
+     * A possible setting for PluralCategory.
+     * The plural category case context to be used is unknown (this is the default value).
+     *
+     * @draft ICU 72
+     */
+    UDISPOPT_PLURAL_CATEGORY_UNDEFINED = 0,
+    /** @draft ICU 72 */
+    UDISPOPT_PLURAL_CATEGORY_ZERO = 1,
+    /** @draft ICU 72 */
+    UDISPOPT_PLURAL_CATEGORY_ONE = 2,
+    /** @draft ICU 72 */
+    UDISPOPT_PLURAL_CATEGORY_TWO = 3,
+    /** @draft ICU 72 */
+    UDISPOPT_PLURAL_CATEGORY_FEW = 4,
+    /** @draft ICU 72 */
+    UDISPOPT_PLURAL_CATEGORY_MANY = 5,
+    /** @draft ICU 72 */
+    UDISPOPT_PLURAL_CATEGORY_OTHER = 6,
+} UDisplayOptionsPluralCategory;
+
+/**
+ * @param pluralCategory The plural category.
+ * @return the lowercase CLDR identifier string for the plural category.
+ *
+ * @draft ICU 72
+ */
+U_CAPI const char * U_EXPORT2
+udispopt_getPluralCategoryIdentifier(UDisplayOptionsPluralCategory pluralCategory);
+
+/**
+ * @param identifier for example "few" or "other"
+ * @return the plural category corresponding to the identifier (plural keyword),
+ *         or `UDISPOPT_PLURAL_CATEGORY_UNDEFINED`
+ *
+ * @draft ICU 72
+ */
+U_CAPI UDisplayOptionsPluralCategory U_EXPORT2
+udispopt_fromPluralCategoryIdentifier(const char *identifier);
+
+/**
+ * Represents all the grammatical noun classes that are supported by CLDR.
+ *
+ * @draft ICU 72.
+ */
+typedef enum UDisplayOptionsNounClass {
+    /**
+     * A possible setting for NounClass.
+     * The noun class case context to be used is unknown (this is the default value).
+     *
+     * @draft ICU 72
+     */
+    UDISPOPT_NOUN_CLASS_UNDEFINED = 0,
+    /** ICU 72 */
+    UDISPOPT_NOUN_CLASS_OTHER = 1,
+    /** ICU 72 */
+    UDISPOPT_NOUN_CLASS_NEUTER = 2,
+    /** ICU 72 */
+    UDISPOPT_NOUN_CLASS_FEMININE = 3,
+    /** ICU 72 */
+    UDISPOPT_NOUN_CLASS_MASCULINE = 4,
+    /** ICU 72 */
+    UDISPOPT_NOUN_CLASS_ANIMATE = 5,
+    /** ICU 72 */
+    UDISPOPT_NOUN_CLASS_INANIMATE = 6,
+    /** ICU 72 */
+    UDISPOPT_NOUN_CLASS_PERSONAL = 7,
+    /** ICU 72 */
+    UDISPOPT_NOUN_CLASS_COMMON = 8,
+} UDisplayOptionsNounClass;
+
+/**
+ * @param nounClass The noun class.
+ * @return the lowercase CLDR keyword string for the noun class.
+ *
+ * @draft ICU 72
+ */
+U_CAPI const char * U_EXPORT2
+udispopt_getNounClassIdentifier(UDisplayOptionsNounClass nounClass);
+
+/**
+ * @param identifier in lower case such as "feminine" or "masculine"
+ * @return the plural category corresponding to the identifier, or `UDISPOPT_NOUN_CLASS_UNDEFINED`
+ *
+ * @draft ICU 72
+ */
+U_CAPI UDisplayOptionsNounClass U_EXPORT2
+udispopt_fromNounClassIdentifier(const char *identifier);
+
+/**
+ * Represents all the capitalization options.
+ *
+ * @draft ICU 72
+ */
+typedef enum UDisplayOptionsCapitalization {
+    /**
+     * A possible setting for Capitalization.
+     * The capitalization context to be used is unknown (this is the default value).
+     *
+     * @draft ICU 72
+     */
+    UDISPOPT_CAPITALIZATION_UNDEFINED = 0,
+
+    /**
+     * The capitalization context if a date, date symbol or display name is to be
+     * formatted with capitalization appropriate for the beginning of a sentence.
+     *
+     * @draft ICU 72
+     */
+    UDISPOPT_CAPITALIZATION_BEGINNING_OF_SENTENCE = 1,
+
+    /**
+     * The capitalization context if a date, date symbol or display name is to be
+     * formatted with capitalization appropriate for the middle of a sentence.
+     *
+     * @draft ICU 72
+     */
+    UDISPOPT_CAPITALIZATION_MIDDLE_OF_SENTENCE = 2,
+
+    /**
+     * The capitalization context if a date, date symbol or display name is to be
+     * formatted with capitalization appropriate for stand-alone usage such as an
+     * isolated name on a calendar page.
+     *
+     * @draft ICU 72
+     */
+    UDISPOPT_CAPITALIZATION_STANDALONE = 3,
+
+    /**
+     * The capitalization context if a date, date symbol or display name is to be
+     * formatted with capitalization appropriate for a user-interface list or menu item.
+     *
+     * @draft ICU 72
+     */
+    UDISPOPT_CAPITALIZATION_UI_LIST_OR_MENU = 4,
+} UDisplayOptionsCapitalization;
+
+/**
+ * Represents all the dialect handlings.
+ *
+ * @draft ICU 72
+ */
+typedef enum UDisplayOptionsNameStyle {
+    /**
+     * A possible setting for NameStyle.
+     * The NameStyle context to be used is unknown (this is the default value).
+     *
+     * @draft ICU 72
+     */
+    UDISPOPT_NAME_STYLE_UNDEFINED = 0,
+
+    /**
+     * Use standard names when generating a locale name,
+     * e.g. en_GB displays as 'English (United Kingdom)'.
+     *
+     * @draft ICU 72
+     */
+    UDISPOPT_NAME_STYLE_STANDARD_NAMES = 1,
+
+    /**
+     * Use dialect names, when generating a locale name,
+     * e.g. en_GB displays as 'British English'.
+     *
+     * @draft ICU 72
+     */
+    UDISPOPT_NAME_STYLE_DIALECT_NAMES = 2,
+} UDisplayOptionsNameStyle;
+
+/**
+ * Represents all the display lengths.
+ *
+ * @draft ICU 72
+ */
+typedef enum UDisplayOptionsDisplayLength {
+    /**
+     * A possible setting for DisplayLength.
+     * The DisplayLength context to be used is unknown (this is the default value).
+     *
+     * @draft ICU 72
+     */
+    UDISPOPT_DISPLAY_LENGTH_UNDEFINED = 0,
+
+    /**
+     * Uses full names when generating a locale name,
+     * e.g. "United States" for US.
+     *
+     * @draft ICU 72
+     */
+    UDISPOPT_DISPLAY_LENGTH_FULL = 1,
+
+    /**
+     * Use short names when generating a locale name,
+     * e.g. "U.S." for US.
+     *
+     * @draft ICU 72
+     */
+    UDISPOPT_DISPLAY_LENGTH_SHORT = 2,
+} UDisplayOptionsDisplayLength;
+
+/**
+ * Represents all the substitute handling.
+ *
+ * @draft ICU 72
+ */
+typedef enum UDisplayOptionsSubstituteHandling {
+
+    /**
+     * A possible setting for SubstituteHandling.
+     * The SubstituteHandling context to be used is unknown (this is the default value).
+     *
+     * @draft ICU 72
+     */
+    UDISPOPT_SUBSTITUTE_HANDLING_UNDEFINED = 0,
+
+    /**
+     * Returns a fallback value (e.g., the input code) when no data is available.
+     * This is the default behaviour.
+     *
+     * @draft ICU 72
+     */
+    UDISPOPT_SUBSTITUTE_HANDLING_SUBSTITUTE = 1,
+
+    /**
+     * Returns a null value when no data is available.
+     *
+     * @draft ICU 72
+     */
+    UDISPOPT_SUBSTITUTE_HANDLING_NO_SUBSTITUTE = 2,
+} UDisplayOptionsSubstituteHandling;
+
+#endif // U_HIDE_DRAFT_API
+
+#endif /* #if !UCONFIG_NO_FORMATTING */
+
+#endif // __UDISPLAYOPTIONS_H__
diff --git a/deps/icu-small/source/i18n/unicode/uformattedvalue.h b/deps/icu-small/source/i18n/unicode/uformattedvalue.h
index 1a550e8758..af6d18f3bc 100644
--- a/deps/icu-small/source/i18n/unicode/uformattedvalue.h
+++ b/deps/icu-small/source/i18n/unicode/uformattedvalue.h
@@ -93,14 +93,12 @@ typedef enum UFieldCategory {
      */
     UFIELD_CATEGORY_DATE_INTERVAL_SPAN = 0x1000 + UFIELD_CATEGORY_DATE_INTERVAL,
 
-#ifndef U_HIDE_DRAFT_API
     /**
      * Category for spans in a number range.
      *
-     * @draft ICU 69
+     * @stable ICU 69
      */
     UFIELD_CATEGORY_NUMBER_RANGE_SPAN = 0x1000 + UFIELD_CATEGORY_NUMBER,
-#endif // U_HIDE_DRAFT_API
 
 } UFieldCategory;
 
diff --git a/deps/icu-small/source/i18n/unicode/unounclass.h b/deps/icu-small/source/i18n/unicode/unounclass.h
deleted file mode 100644
index 1721dbd584..0000000000
--- a/deps/icu-small/source/i18n/unicode/unounclass.h
+++ /dev/null
@@ -1,43 +0,0 @@
-// © 2022 and later: Unicode, Inc. and others.
-// License & terms of use: http://www.unicode.org/copyright.html
-
-#ifndef __UNOUNCLASS_H__
-#define __UNOUNCLASS_H__
-
-#include "unicode/utypes.h"
-
-#if U_SHOW_CPLUSPLUS_API
-
-#if !UCONFIG_NO_FORMATTING
-
-#include "unicode/uversion.h"
-
-U_NAMESPACE_BEGIN
-
-#ifndef U_HIDE_DRAFT_API
-
-/**
- * Represents all the grammatical noun classes that are supported by CLDR.
- *
- * @draft ICU 71.
- */
-enum NounClass {
-    OTHER = 0,
-    NEUTER = 1,
-    FEMININE = 2,
-    MASCULINE = 3,
-    ANIMATE = 4,
-    INANIMATE = 5,
-    PERSONAL = 6,
-    COMMON = 7,
-};
-
-#endif // U_HIDE_DRAFT_API
-
-U_NAMESPACE_END
-
-#endif /* #if !UCONFIG_NO_FORMATTING */
-
-#endif /* U_SHOW_CPLUSPLUS_API */
-
-#endif // __UNOUNCLASS_H__
diff --git a/deps/icu-small/source/i18n/unicode/unum.h b/deps/icu-small/source/i18n/unicode/unum.h
index 863695591a..a392afaaed 100644
--- a/deps/icu-small/source/i18n/unicode/unum.h
+++ b/deps/icu-small/source/i18n/unicode/unum.h
@@ -1161,6 +1161,26 @@ typedef enum UNumberFormatAttribute {
 
 } UNumberFormatAttribute;
 
+#ifndef U_HIDE_DRAFT_API
+/**
+* Returns true if the formatter supports the specified attribute and false if not.
+* @param fmt The formatter to query.
+* @param attr The attribute to query.  This can be any value of UNumberFormatterAttribute,
+* regardless of type.
+* @return True if the requested attribute is supported by the formatter; false if not.
+* @see unum_getAttribute
+* @see unum_setAttribute
+* @see unum_getDoubleAttribute
+* @see unum_setDoubleAttribute
+* @see unum_getTextAttribute
+* @see unum_setTextAttribute
+* @draft ICU 72
+*/
+U_CAPI bool U_EXPORT2
+unum_hasAttribute(const UNumberFormat*          fmt,
+          UNumberFormatAttribute  attr);
+#endif // U_HIDE_DRAFT_API
+
 /**
 * Get a numeric attribute associated with a UNumberFormat.
 * An example of a numeric attribute is the number of integer digits a formatter will produce.
@@ -1170,12 +1190,12 @@ typedef enum UNumberFormatAttribute {
 * UNUM_MAX_FRACTION_DIGITS, UNUM_MIN_FRACTION_DIGITS, UNUM_FRACTION_DIGITS, UNUM_MULTIPLIER,
 * UNUM_GROUPING_SIZE, UNUM_ROUNDING_MODE, UNUM_FORMAT_WIDTH, UNUM_PADDING_POSITION, UNUM_SECONDARY_GROUPING_SIZE,
 * UNUM_SCALE, UNUM_MINIMUM_GROUPING_DIGITS.
-* @return The value of attr.
+* @return The value of attr, or -1 if the formatter doesn't have the requested attribute.  The caller should use unum_hasAttribute() to tell if the attribute
+* is available, rather than relaying on this function returning -1.
+* @see unum_hasAttribute
 * @see unum_setAttribute
 * @see unum_getDoubleAttribute
 * @see unum_setDoubleAttribute
-* @see unum_getTextAttribute
-* @see unum_setTextAttribute
 * @stable ICU 2.0
 */
 U_CAPI int32_t U_EXPORT2 
@@ -1186,7 +1206,7 @@ unum_getAttribute(const UNumberFormat*          fmt,
 * Set a numeric attribute associated with a UNumberFormat.
 * An example of a numeric attribute is the number of integer digits a formatter will produce.  If the
 * formatter does not understand the attribute, the call is ignored.  Rule-based formatters only understand
-* the lenient-parse attribute.
+* the lenient-parse attribute.  The caller can use unum_hasAttribute() to find out if the formatter supports the attribute.
 * @param fmt The formatter to set.
 * @param attr The attribute to set; one of UNUM_PARSE_INT_ONLY, UNUM_GROUPING_USED,
 * UNUM_DECIMAL_ALWAYS_SHOWN, UNUM_MAX_INTEGER_DIGITS, UNUM_MIN_INTEGER_DIGITS, UNUM_INTEGER_DIGITS,
@@ -1194,6 +1214,7 @@ unum_getAttribute(const UNumberFormat*          fmt,
 * UNUM_GROUPING_SIZE, UNUM_ROUNDING_MODE, UNUM_FORMAT_WIDTH, UNUM_PADDING_POSITION, UNUM_SECONDARY_GROUPING_SIZE,
 * UNUM_LENIENT_PARSE, UNUM_SCALE, UNUM_MINIMUM_GROUPING_DIGITS.
 * @param newValue The new value of attr.
+* @see unum_hasAttribute
 * @see unum_getAttribute
 * @see unum_getDoubleAttribute
 * @see unum_setDoubleAttribute
@@ -1210,10 +1231,12 @@ unum_setAttribute(    UNumberFormat*          fmt,
 /**
 * Get a numeric attribute associated with a UNumberFormat.
 * An example of a numeric attribute is the number of integer digits a formatter will produce.
-* If the formatter does not understand the attribute, -1 is returned.
+* If the formatter does not understand the attribute, -1 is returned.  The caller should use unum_hasAttribute()
+* to determine if the attribute is supported, rather than relying on this function returning -1.
 * @param fmt The formatter to query.
 * @param attr The attribute to query; e.g. UNUM_ROUNDING_INCREMENT.
-* @return The value of attr.
+* @return The value of attr, or -1 if the formatter doesn't understand the attribute.
+* @see unum_hasAttribute
 * @see unum_getAttribute
 * @see unum_setAttribute
 * @see unum_setDoubleAttribute
@@ -1228,10 +1251,12 @@ unum_getDoubleAttribute(const UNumberFormat*          fmt,
 /**
 * Set a numeric attribute associated with a UNumberFormat.
 * An example of a numeric attribute is the number of integer digits a formatter will produce.
-* If the formatter does not understand the attribute, this call is ignored.
+* If the formatter does not understand the attribute, this call is ignored.  The caller can use
+* unum_hasAttribute() to tell in advance whether the formatter understands the attribute.
 * @param fmt The formatter to set.
 * @param attr The attribute to set; e.g. UNUM_ROUNDING_INCREMENT.
 * @param newValue The new value of attr.
+* @see unum_hasAttribute
 * @see unum_getAttribute
 * @see unum_setAttribute
 * @see unum_getDoubleAttribute
diff --git a/deps/icu-small/source/i18n/unicode/unumberformatter.h b/deps/icu-small/source/i18n/unicode/unumberformatter.h
index 58a75baf07..253b30b534 100644
--- a/deps/icu-small/source/i18n/unicode/unumberformatter.h
+++ b/deps/icu-small/source/i18n/unicode/unumberformatter.h
@@ -16,7 +16,7 @@
 
 /**
  * \file
- * \brief C-compatible API for localized number formatting; not recommended for C++.
+ * \brief C API: Localized number formatting; not recommended for C++.
  *
  * This is the C-compatible version of the NumberFormatter API introduced in ICU 60. C++ users should
  * include unicode/numberformatter.h and use the proper C++ APIs.
diff --git a/deps/icu-small/source/i18n/unicode/unumberrangeformatter.h b/deps/icu-small/source/i18n/unicode/unumberrangeformatter.h
index 4e92fe29e2..106942f25a 100644
--- a/deps/icu-small/source/i18n/unicode/unumberrangeformatter.h
+++ b/deps/icu-small/source/i18n/unicode/unumberrangeformatter.h
@@ -17,7 +17,7 @@
 
 /**
  * \file
- * \brief C-compatible API for localized number range formatting.
+ * \brief C API: Localized number range formatting
  *
  * This is the C-compatible version of the NumberRangeFormatter API. C++ users
  * should include unicode/numberrangeformatter.h and use the proper C++ APIs.
diff --git a/deps/icu-small/source/i18n/unicode/uspoof.h b/deps/icu-small/source/i18n/unicode/uspoof.h
index b674c91b2c..0aa887b706 100644
--- a/deps/icu-small/source/i18n/unicode/uspoof.h
+++ b/deps/icu-small/source/i18n/unicode/uspoof.h
@@ -35,7 +35,7 @@
 
 /**
  * \file
- * \brief Unicode Security and Spoofing Detection, C API.
+ * \brief C API: Unicode Security and Spoofing Detection
  *
  * <p>
  * This class, based on <a href="http://unicode.org/reports/tr36">Unicode Technical Report #36</a> and
diff --git a/deps/icu-small/source/i18n/unicode/vtzone.h b/deps/icu-small/source/i18n/unicode/vtzone.h
index ecf335bbe3..487810dd5a 100644
--- a/deps/icu-small/source/i18n/unicode/vtzone.h
+++ b/deps/icu-small/source/i18n/unicode/vtzone.h
@@ -382,7 +382,6 @@ private:
      * Default constructor.
      */
     VTimeZone();
-    static VTimeZone* createVTimeZone(VTZReader* reader);
     void write(VTZWriter& writer, UErrorCode& status) const;
     void write(UDate start, VTZWriter& writer, UErrorCode& status) const;
     void writeSimple(UDate time, VTZWriter& writer, UErrorCode& status) const;
diff --git a/deps/icu-small/source/i18n/units_complexconverter.cpp b/deps/icu-small/source/i18n/units_complexconverter.cpp
index ecbe3c7879..8c9c334f7e 100644
--- a/deps/icu-small/source/i18n/units_complexconverter.cpp
+++ b/deps/icu-small/source/i18n/units_complexconverter.cpp
@@ -143,7 +143,7 @@ MaybeStackVector<Measure> ComplexUnitsConverter::convert(double quantity,
     // TODO: return an error for "foot-and-foot"?
     MaybeStackVector<Measure> result;
     int sign = 1;
-    if (quantity < 0) {
+    if (quantity < 0 && unitsConverters_.length() > 1) {
         quantity *= -1;
         sign = -1;
     }
diff --git a/deps/icu-small/source/i18n/units_converter.cpp b/deps/icu-small/source/i18n/units_converter.cpp
index 82b8eea3d8..b89f495121 100644
--- a/deps/icu-small/source/i18n/units_converter.cpp
+++ b/deps/icu-small/source/i18n/units_converter.cpp
@@ -389,8 +389,14 @@ void U_I18N_API addSingleFactorConstant(StringPiece baseStr, int32_t power, Sign
         factor.constantExponents[CONSTANT_GLUCOSE_MOLAR_MASS] += power * signum;
     } else if (baseStr == "item_per_mole") {
         factor.constantExponents[CONSTANT_ITEM_PER_MOLE] += power * signum;
+    } else if (baseStr == "meters_per_AU") {
+        factor.constantExponents[CONSTANT_METERS_PER_AU] += power * signum;
     } else if (baseStr == "PI") {
         factor.constantExponents[CONSTANT_PI] += power * signum;
+    } else if (baseStr == "sec_per_julian_year") {
+        factor.constantExponents[CONSTANT_SEC_PER_JULIAN_YEAR] += power * signum;
+    } else if (baseStr == "speed_of_light_meters_per_second") {
+        factor.constantExponents[CONSTANT_SPEED_OF_LIGHT_METERS_PER_SECOND] += power * signum;
     } else {
         if (signum == Signum::NEGATIVE) {
             factor.factorDen *= std::pow(strToDouble(baseStr, status), power);
diff --git a/deps/icu-small/source/i18n/units_converter.h b/deps/icu-small/source/i18n/units_converter.h
index 5c002f4147..fd1d6ec422 100644
--- a/deps/icu-small/source/i18n/units_converter.h
+++ b/deps/icu-small/source/i18n/units_converter.h
@@ -30,6 +30,9 @@ enum Constants {
     CONSTANT_LB2KG,      // Pound to Kilogram
     CONSTANT_GLUCOSE_MOLAR_MASS,
     CONSTANT_ITEM_PER_MOLE,
+    CONSTANT_METERS_PER_AU,
+    CONSTANT_SEC_PER_JULIAN_YEAR,
+    CONSTANT_SPEED_OF_LIGHT_METERS_PER_SECOND,
 
     // Must be the last element.
     CONSTANTS_COUNT
@@ -49,6 +52,9 @@ static const double constantsValues[CONSTANTS_COUNT] = {
     0.45359237,                // CONSTANT_LB2KG
     180.1557,                  // CONSTANT_GLUCOSE_MOLAR_MASS
     6.02214076E+23,            // CONSTANT_ITEM_PER_MOLE
+    149597870700,              // CONSTANT_METERS_PER_AU
+    31557600,                  // CONSTANT_SEC_PER_JULIAN_YEAR
+    299792458,                 // CONSTANT_SPEED_OF_LIGHT_METERS_PER_SECOND
 };
 
 typedef enum Signum {
diff --git a/deps/icu-small/source/i18n/units_data.cpp b/deps/icu-small/source/i18n/units_data.cpp
index d1d1fc5bc0..1456af4d05 100644
--- a/deps/icu-small/source/i18n/units_data.cpp
+++ b/deps/icu-small/source/i18n/units_data.cpp
@@ -5,10 +5,12 @@
 
 #if !UCONFIG_NO_FORMATTING
 
+#include "bytesinkutil.h"
 #include "cstring.h"
 #include "number_decimalquantity.h"
 #include "resource.h"
 #include "uassert.h"
+#include "unicode/locid.h"
 #include "unicode/unistr.h"
 #include "unicode/ures.h"
 #include "units_data.h"
@@ -387,24 +389,97 @@ U_I18N_API UnitPreferences::UnitPreferences(UErrorCode &status) {
     ures_getAllItemsWithFallback(unitsBundle.getAlias(), "unitPreferenceData", sink, status);
 }
 
-// TODO: make outPreferences const?
-//
-// TODO: consider replacing `UnitPreference **&outPreferences` with slice class
-// of some kind.
-void U_I18N_API UnitPreferences::getPreferencesFor(StringPiece category, StringPiece usage,
-                                                   StringPiece region,
-                                                   const UnitPreference *const *&outPreferences,
-                                                   int32_t &preferenceCount, UErrorCode &status) const {
-    int32_t idx = getPreferenceMetadataIndex(&metadata_, category, usage, region, status);
+CharString getKeyWordValue(const Locale &locale, StringPiece kw, UErrorCode &status) {
+    CharString result;
+    if (U_FAILURE(status)) { return result; }
+    {
+        CharStringByteSink sink(&result);
+        locale.getKeywordValue(kw, sink, status);
+    }
+    if (U_SUCCESS(status) && result.isEmpty()) {
+        status = U_MISSING_RESOURCE_ERROR;
+    }
+    return result;
+}
+
+MaybeStackVector<UnitPreference>
+    U_I18N_API UnitPreferences::getPreferencesFor(StringPiece category, StringPiece usage,
+                                                  const Locale &locale, UErrorCode &status) const {
+
+    MaybeStackVector<UnitPreference> result;
+
+    // TODO: remove this once all the categories are allowed.
+    UErrorCode internalMuStatus = U_ZERO_ERROR;
+    if (category.compare("temperature") == 0) {
+        CharString localeUnitCharString = getKeyWordValue(locale, "mu", internalMuStatus);
+        if (U_SUCCESS(internalMuStatus)) {
+            // TODO: use the unit category as Java especially when all the categories are allowed..
+            if (localeUnitCharString == "celsius"       //
+                || localeUnitCharString == "fahrenheit" //
+                || localeUnitCharString == "kelvin"     //
+            ) {
+                UnitPreference unitPref;
+                unitPref.unit.append(localeUnitCharString, status);
+                result.emplaceBackAndCheckErrorCode(status, unitPref);
+                return result;
+            }
+        }
+    }
+
+    CharString region(locale.getCountry(), status);
+
+    // Check the locale system tag, e.g `ms=metric`.
+    UErrorCode internalMeasureTagStatus = U_ZERO_ERROR;
+    CharString localeSystem = getKeyWordValue(locale, "measure", internalMeasureTagStatus);
+    bool isLocaleSystem = false;
+    if (U_SUCCESS(internalMeasureTagStatus)) {
+        if (localeSystem == "metric") {
+            region.clear();
+            region.append("001", status);
+            isLocaleSystem = true;
+        } else if (localeSystem == "ussystem") {
+            region.clear();
+            region.append("US", status);
+            isLocaleSystem = true;
+        } else if (localeSystem == "uksystem") {
+            region.clear();
+            region.append("GB", status);
+            isLocaleSystem = true;
+        }
+    }
+
+    // Check the region tag, e.g. `rg=uszzz`.
+    if (!isLocaleSystem) {
+        UErrorCode internalRgTagStatus = U_ZERO_ERROR;
+        CharString localeRegion = getKeyWordValue(locale, "rg", internalRgTagStatus);
+        if (U_SUCCESS(internalRgTagStatus) && localeRegion.length() >= 3) {
+            if (localeRegion == "default") {
+                region.clear();
+                region.append(localeRegion, status);
+            } else if (localeRegion[0] >= '0' && localeRegion[0] <= '9') {
+                region.clear();
+                region.append(localeRegion.data(), 3, status);
+            } else {
+                // Take the first two character and capitalize them.
+                region.clear();
+                region.append(uprv_toupper(localeRegion[0]), status);
+                region.append(uprv_toupper(localeRegion[1]), status);
+            }
+        }
+    }
+
+    int32_t idx =
+        getPreferenceMetadataIndex(&metadata_, category, usage, region.toStringPiece(), status);
     if (U_FAILURE(status)) {
-        outPreferences = nullptr;
-        preferenceCount = 0;
-        return;
+        return result;
     }
+
     U_ASSERT(idx >= 0); // Failures should have been taken care of by `status`.
     const UnitPreferenceMetadata *m = metadata_[idx];
-    outPreferences = unitPrefs_.getAlias() + m->prefsOffset;
-    preferenceCount = m->prefsCount;
+    for (int32_t i = 0; i < m->prefsCount; i++) {
+        result.emplaceBackAndCheckErrorCode(status, *(unitPrefs_[i + m->prefsOffset]));
+    }
+    return result;
 }
 
 } // namespace units
diff --git a/deps/icu-small/source/i18n/units_data.h b/deps/icu-small/source/i18n/units_data.h
index 2c19b9434b..118458ecca 100644
--- a/deps/icu-small/source/i18n/units_data.h
+++ b/deps/icu-small/source/i18n/units_data.h
@@ -99,6 +99,13 @@ struct U_I18N_API UnitPreference : public UMemory {
     CharString unit;
     double geq;
     UnicodeString skeleton;
+
+    UnitPreference(const UnitPreference &other) {
+        UErrorCode status = U_ZERO_ERROR;
+        this->unit.append(other.unit, status);
+        this->geq = other.geq;
+        this->skeleton = other.skeleton;
+    }
 };
 
 /**
@@ -189,12 +196,11 @@ class U_I18N_API UnitPreferences {
      * @param preferenceCount The number of unit preferences that belong to the
      * result set.
      * @param status Receives status.
-     *
-     * TODO(hugovdm): maybe replace `UnitPreference **&outPreferences` with a slice class?
      */
-    void getPreferencesFor(StringPiece category, StringPiece usage, StringPiece region,
-                           const UnitPreference *const *&outPreferences, int32_t &preferenceCount,
-                           UErrorCode &status) const;
+    MaybeStackVector<UnitPreference> getPreferencesFor(StringPiece category, StringPiece usage,
+                                                       const Locale &locale,
+
+                                                       UErrorCode &status) const;
 
   protected:
     // Metadata about the sets of preferences, this is the index for looking up
diff --git a/deps/icu-small/source/i18n/units_router.cpp b/deps/icu-small/source/i18n/units_router.cpp
index 0e6082fae5..03c9b4d1d7 100644
--- a/deps/icu-small/source/i18n/units_router.cpp
+++ b/deps/icu-small/source/i18n/units_router.cpp
@@ -43,17 +43,17 @@ Precision UnitsRouter::parseSkeletonToPrecision(icu::UnicodeString precisionSkel
     return result;
 }
 
-UnitsRouter::UnitsRouter(StringPiece inputUnitIdentifier, StringPiece region, StringPiece usage,
+UnitsRouter::UnitsRouter(StringPiece inputUnitIdentifier, const Locale &locale, StringPiece usage,
                          UErrorCode &status) {
-    this->init(MeasureUnit::forIdentifier(inputUnitIdentifier, status), region, usage, status);
+    this->init(MeasureUnit::forIdentifier(inputUnitIdentifier, status), locale, usage, status);
 }
 
-UnitsRouter::UnitsRouter(const MeasureUnit &inputUnit, StringPiece region, StringPiece usage,
+UnitsRouter::UnitsRouter(const MeasureUnit &inputUnit, const Locale &locale, StringPiece usage,
                          UErrorCode &status) {
-    this->init(std::move(inputUnit), region, usage, status);
+    this->init(std::move(inputUnit), locale, usage, status);
 }
 
-void UnitsRouter::init(const MeasureUnit &inputUnit, StringPiece region, StringPiece usage,
+void UnitsRouter::init(const MeasureUnit &inputUnit, const Locale &locale, StringPiece usage,
                        UErrorCode &status) {
 
     if (U_FAILURE(status)) {
@@ -73,22 +73,19 @@ void UnitsRouter::init(const MeasureUnit &inputUnit, StringPiece region, StringP
         return;
     }
 
-    const UnitPreference *const *unitPreferences;
-    int32_t preferencesCount = 0;
-    prefs.getPreferencesFor(category.toStringPiece(), usage, region, unitPreferences, preferencesCount,
-                            status);
-
-    for (int i = 0; i < preferencesCount; ++i) {
-        U_ASSERT(unitPreferences[i] != nullptr);
-        const auto &preference = *unitPreferences[i];
+    const MaybeStackVector<UnitPreference> unitPrefs =
+        prefs.getPreferencesFor(category.toStringPiece(), usage, locale, status);
+    for (int32_t i = 0, n = unitPrefs.length(); i < n; ++i) {
+        U_ASSERT(unitPrefs[i] != nullptr);
+        const auto preference = unitPrefs[i];
 
         MeasureUnitImpl complexTargetUnitImpl =
-            MeasureUnitImpl::forIdentifier(preference.unit.data(), status);
+            MeasureUnitImpl::forIdentifier(preference->unit.data(), status);
         if (U_FAILURE(status)) {
             return;
         }
 
-        UnicodeString precision = preference.skeleton;
+        UnicodeString precision = preference->skeleton;
 
         // For now, we only have "precision-increment" in Units Preferences skeleton.
         // Therefore, we check if the skeleton starts with "precision-increment" and force the program to
@@ -103,7 +100,7 @@ void UnitsRouter::init(const MeasureUnit &inputUnit, StringPiece region, StringP
         outputUnits_.emplaceBackAndCheckErrorCode(status,
                                                   complexTargetUnitImpl.copy(status).build(status));
         converterPreferences_.emplaceBackAndCheckErrorCode(status, inputUnitImpl, complexTargetUnitImpl,
-                                                           preference.geq, std::move(precision),
+                                                           preference->geq, std::move(precision),
                                                            conversionRates, status);
 
         if (U_FAILURE(status)) {
diff --git a/deps/icu-small/source/i18n/units_router.h b/deps/icu-small/source/i18n/units_router.h
index d9fcffb2aa..978fdf91fd 100644
--- a/deps/icu-small/source/i18n/units_router.h
+++ b/deps/icu-small/source/i18n/units_router.h
@@ -11,6 +11,7 @@
 
 #include "cmemory.h"
 #include "measunit_impl.h"
+#include "unicode/locid.h"
 #include "unicode/measunit.h"
 #include "unicode/stringpiece.h"
 #include "unicode/uobject.h"
@@ -118,9 +119,10 @@ namespace units {
  */
 class U_I18N_API UnitsRouter {
   public:
-    UnitsRouter(StringPiece inputUnitIdentifier, StringPiece locale, StringPiece usage,
+    UnitsRouter(StringPiece inputUnitIdentifier, const Locale &locale, StringPiece usage,
+                UErrorCode &status);
+    UnitsRouter(const MeasureUnit &inputUnit, const Locale &locale, StringPiece usage,
                 UErrorCode &status);
-    UnitsRouter(const MeasureUnit &inputUnit, StringPiece locale, StringPiece usage, UErrorCode &status);
 
     /**
      * Performs locale and usage sensitive unit conversion.
@@ -153,7 +155,7 @@ class U_I18N_API UnitsRouter {
     static number::Precision parseSkeletonToPrecision(icu::UnicodeString precisionSkeleton,
                                                       UErrorCode &status);
 
-    void init(const MeasureUnit &inputUnit, StringPiece locale, StringPiece usage, UErrorCode &status);
+    void init(const MeasureUnit &inputUnit, const Locale &locale, StringPiece usage, UErrorCode &status);
 };
 
 } // namespace units
diff --git a/deps/icu-small/source/i18n/unum.cpp b/deps/icu-small/source/i18n/unum.cpp
index 7043f7adc1..d2ba7ae3a2 100644
--- a/deps/icu-small/source/i18n/unum.cpp
+++ b/deps/icu-small/source/i18n/unum.cpp
@@ -60,6 +60,7 @@ unum_open(  UNumberFormatStyle    style,
     case UNUM_CURRENCY_ACCOUNTING:
     case UNUM_CASH_CURRENCY:
     case UNUM_CURRENCY_STANDARD:
+    case UNUM_NUMBERING_SYSTEM:
         retVal = NumberFormat::createInstance(Locale(locale), style, *status);
         break;
 
@@ -112,10 +113,6 @@ unum_open(  UNumberFormatStyle    style,
     case UNUM_DURATION:
         retVal = new RuleBasedNumberFormat(URBNF_DURATION, Locale(locale), *status);
         break;
-
-    case UNUM_NUMBERING_SYSTEM:
-        retVal = new RuleBasedNumberFormat(URBNF_NUMBERING_SYSTEM, Locale(locale), *status);
-        break;
 #endif
 
     case UNUM_DECIMAL_COMPACT_SHORT:
@@ -508,6 +505,28 @@ unum_countAvailable()
     return uloc_countAvailable();
 }
 
+U_CAPI bool U_EXPORT2
+unum_hasAttribute(const UNumberFormat*          fmt,
+          UNumberFormatAttribute  attr)
+{
+    const NumberFormat* nf = reinterpret_cast<const NumberFormat*>(fmt);
+    bool isDecimalFormat = dynamic_cast<const DecimalFormat*>(nf) != NULL;
+    
+    switch (attr) {
+        case UNUM_LENIENT_PARSE:
+        case UNUM_MAX_INTEGER_DIGITS:
+        case UNUM_MIN_INTEGER_DIGITS:
+        case UNUM_INTEGER_DIGITS:
+        case UNUM_MAX_FRACTION_DIGITS:
+        case UNUM_MIN_FRACTION_DIGITS:
+        case UNUM_FRACTION_DIGITS:
+        case UNUM_ROUNDING_MODE:
+            return true;
+        default:
+            return isDecimalFormat;
+    }
+}
+
 U_CAPI int32_t U_EXPORT2
 unum_getAttribute(const UNumberFormat*          fmt,
           UNumberFormatAttribute  attr)
diff --git a/deps/icu-small/source/i18n/uregex.cpp b/deps/icu-small/source/i18n/uregex.cpp
index 514159e8b7..dd2ad2a81e 100644
--- a/deps/icu-small/source/i18n/uregex.cpp
+++ b/deps/icu-small/source/i18n/uregex.cpp
@@ -58,7 +58,7 @@ RegularExpression::RegularExpression() {
     fMatcher      = NULL;
     fText         = NULL;
     fTextLength   = 0;
-    fOwnsText     = FALSE;
+    fOwnsText     = false;
 }
 
 RegularExpression::~RegularExpression() {
@@ -82,22 +82,22 @@ U_NAMESPACE_USE
 //----------------------------------------------------------------------------------------
 //
 //   validateRE    Do boilerplate style checks on API function parameters.
-//                 Return TRUE if they look OK.
+//                 Return true if they look OK.
 //----------------------------------------------------------------------------------------
 static UBool validateRE(const RegularExpression *re, UBool requiresText, UErrorCode *status) {
     if (U_FAILURE(*status)) {
-        return FALSE;
+        return false;
     }
     if (re == NULL || re->fMagic != REXP_MAGIC) {
         *status = U_ILLEGAL_ARGUMENT_ERROR;
-        return FALSE;
+        return false;
     }
     // !!! Not sure how to update this with the new UText backing, which is stored in re->fMatcher anyway
     if (requiresText && re->fText == NULL && !re->fOwnsText) {
         *status = U_REGEX_INVALID_STATE;
-        return FALSE;
+        return false;
     }
-    return TRUE;
+    return true;
 }
 
 //----------------------------------------------------------------------------------------
@@ -270,7 +270,7 @@ U_CAPI void  U_EXPORT2
 uregex_close(URegularExpression  *re2) {
     RegularExpression *re = (RegularExpression*)re2;
     UErrorCode  status = U_ZERO_ERROR;
-    if (validateRE(re, FALSE, &status) == FALSE) {
+    if (validateRE(re, false, &status) == false) {
         return;
     }
     delete re;
@@ -285,7 +285,7 @@ uregex_close(URegularExpression  *re2) {
 U_CAPI URegularExpression * U_EXPORT2
 uregex_clone(const URegularExpression *source2, UErrorCode *status)  {
     RegularExpression *source = (RegularExpression*)source2;
-    if (validateRE(source, FALSE, status) == FALSE) {
+    if (validateRE(source, false, status) == false) {
         return NULL;
     }
 
@@ -325,7 +325,7 @@ uregex_pattern(const  URegularExpression *regexp2,
                       UErrorCode         *status)  {
     RegularExpression *regexp = (RegularExpression*)regexp2;
 
-    if (validateRE(regexp, FALSE, status) == FALSE) {
+    if (validateRE(regexp, false, status) == false) {
         return NULL;
     }
     if (patLength != NULL) {
@@ -356,7 +356,7 @@ uregex_patternUText(const URegularExpression *regexp2,
 U_CAPI int32_t U_EXPORT2
 uregex_flags(const URegularExpression *regexp2, UErrorCode *status)  {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, FALSE, status) == FALSE) {
+    if (validateRE(regexp, false, status) == false) {
         return 0;
     }
     int32_t flags = regexp->fPat->flags();
@@ -375,7 +375,7 @@ uregex_setText(URegularExpression *regexp2,
                int32_t             textLength,
                UErrorCode         *status)  {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, FALSE, status) == FALSE) {
+    if (validateRE(regexp, false, status) == false) {
         return;
     }
     if (text == NULL || textLength < -1) {
@@ -389,7 +389,7 @@ uregex_setText(URegularExpression *regexp2,
 
     regexp->fText       = text;
     regexp->fTextLength = textLength;
-    regexp->fOwnsText   = FALSE;
+    regexp->fOwnsText   = false;
 
     UText input = UTEXT_INITIALIZER;
     utext_openUChars(&input, text, textLength, status);
@@ -408,7 +408,7 @@ uregex_setUText(URegularExpression *regexp2,
                 UText              *text,
                 UErrorCode         *status) {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, FALSE, status) == FALSE) {
+    if (validateRE(regexp, false, status) == false) {
         return;
     }
     if (text == NULL) {
@@ -422,7 +422,7 @@ uregex_setUText(URegularExpression *regexp2,
 
     regexp->fText       = NULL; // only fill it in on request
     regexp->fTextLength = -1;
-    regexp->fOwnsText   = TRUE;
+    regexp->fOwnsText   = true;
     regexp->fMatcher->reset(text);
 }
 
@@ -438,7 +438,7 @@ uregex_getText(URegularExpression *regexp2,
                int32_t            *textLength,
                UErrorCode         *status)  {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, FALSE, status) == FALSE) {
+    if (validateRE(regexp, false, status) == false) {
         return NULL;
     }
 
@@ -449,7 +449,7 @@ uregex_getText(URegularExpression *regexp2,
         if (UTEXT_FULL_TEXT_IN_CHUNK(inputText, inputNativeLength)) {
             regexp->fText = inputText->chunkContents;
             regexp->fTextLength = (int32_t)inputNativeLength;
-            regexp->fOwnsText = FALSE; // because the UText owns it
+            regexp->fOwnsText = false; // because the UText owns it
         } else {
             UErrorCode lengthStatus = U_ZERO_ERROR;
             regexp->fTextLength = utext_extract(inputText, 0, inputNativeLength, NULL, 0, &lengthStatus); // buffer overflow error
@@ -457,7 +457,7 @@ uregex_getText(URegularExpression *regexp2,
 
             utext_extract(inputText, 0, inputNativeLength, inputChars, regexp->fTextLength+1, status);
             regexp->fText = inputChars;
-            regexp->fOwnsText = TRUE; // should already be set but just in case
+            regexp->fOwnsText = true; // should already be set but just in case
         }
     }
 
@@ -478,7 +478,7 @@ uregex_getUText(URegularExpression *regexp2,
                 UText              *dest,
                 UErrorCode         *status)  {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, FALSE, status) == FALSE) {
+    if (validateRE(regexp, false, status) == false) {
         return dest;
     }
     return regexp->fMatcher->getInput(dest, *status);
@@ -495,7 +495,7 @@ uregex_refreshUText(URegularExpression *regexp2,
                     UText              *text,
                     UErrorCode         *status) {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, FALSE, status) == FALSE) {
+    if (validateRE(regexp, false, status) == false) {
         return;
     }
     regexp->fMatcher->refreshInputText(text, *status);
@@ -519,8 +519,8 @@ uregex_matches64(URegularExpression *regexp2,
                  int64_t            startIndex,
                  UErrorCode        *status)  {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    UBool result = FALSE;
-    if (validateRE(regexp, TRUE, status) == FALSE) {
+    UBool result = false;
+    if (validateRE(regexp, true, status) == false) {
         return result;
     }
     if (startIndex == -1) {
@@ -549,8 +549,8 @@ uregex_lookingAt64(URegularExpression *regexp2,
                    int64_t             startIndex,
                    UErrorCode         *status)  {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    UBool result = FALSE;
-    if (validateRE(regexp, TRUE, status) == FALSE) {
+    UBool result = false;
+    if (validateRE(regexp, true, status) == false) {
         return result;
     }
     if (startIndex == -1) {
@@ -580,8 +580,8 @@ uregex_find64(URegularExpression *regexp2,
               int64_t             startIndex,
               UErrorCode         *status)  {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    UBool result = FALSE;
-    if (validateRE(regexp, TRUE, status) == FALSE) {
+    UBool result = false;
+    if (validateRE(regexp, true, status) == false) {
         return result;
     }
     if (startIndex == -1) {
@@ -603,8 +603,8 @@ U_CAPI UBool U_EXPORT2
 uregex_findNext(URegularExpression *regexp2,
                 UErrorCode         *status)  {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, TRUE, status) == FALSE) {
-        return FALSE;
+    if (validateRE(regexp, true, status) == false) {
+        return false;
     }
     UBool result = regexp->fMatcher->find(*status);
     return result;
@@ -619,7 +619,7 @@ U_CAPI int32_t U_EXPORT2
 uregex_groupCount(URegularExpression *regexp2,
                   UErrorCode         *status)  {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, FALSE, status) == FALSE) {
+    if (validateRE(regexp, false, status) == false) {
         return 0;
     }
     int32_t  result = regexp->fMatcher->groupCount();
@@ -638,7 +638,7 @@ uregex_groupNumberFromName(URegularExpression *regexp2,
                            int32_t             nameLength,
                            UErrorCode          *status) {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, FALSE, status) == FALSE) {
+    if (validateRE(regexp, false, status) == false) {
         return 0;
     }
     int32_t  result = regexp->fPat->groupNumberFromName(UnicodeString(groupName, nameLength), *status);
@@ -651,7 +651,7 @@ uregex_groupNumberFromCName(URegularExpression *regexp2,
                             int32_t             nameLength,
                             UErrorCode          *status) {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, FALSE, status) == FALSE) {
+    if (validateRE(regexp, false, status) == false) {
         return 0;
     }
     return regexp->fPat->groupNumberFromName(groupName, nameLength, *status);
@@ -669,7 +669,7 @@ uregex_group(URegularExpression *regexp2,
              int32_t             destCapacity,
              UErrorCode          *status)  {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, TRUE, status) == FALSE) {
+    if (validateRE(regexp, true, status) == false) {
         return 0;
     }
     if (destCapacity < 0 || (destCapacity > 0 && dest == NULL)) {
@@ -739,7 +739,7 @@ uregex_groupUText(URegularExpression *regexp2,
                   int64_t            *groupLength,
                   UErrorCode         *status)  {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, TRUE, status) == FALSE) {
+    if (validateRE(regexp, true, status) == false) {
         UErrorCode emptyTextStatus = U_ZERO_ERROR;
         return (dest ? dest : utext_openUChars(NULL, NULL, 0, &emptyTextStatus));
     }
@@ -764,7 +764,7 @@ uregex_start64(URegularExpression *regexp2,
                int32_t             groupNum,
                UErrorCode          *status)  {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, TRUE, status) == FALSE) {
+    if (validateRE(regexp, true, status) == false) {
         return 0;
     }
     int64_t result = regexp->fMatcher->start64(groupNum, *status);
@@ -788,7 +788,7 @@ uregex_end64(URegularExpression   *regexp2,
              int32_t               groupNum,
              UErrorCode           *status)  {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, TRUE, status) == FALSE) {
+    if (validateRE(regexp, true, status) == false) {
         return 0;
     }
     int64_t result = regexp->fMatcher->end64(groupNum, *status);
@@ -812,7 +812,7 @@ uregex_reset64(URegularExpression    *regexp2,
                int64_t               index,
                UErrorCode            *status)  {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, TRUE, status) == FALSE) {
+    if (validateRE(regexp, true, status) == false) {
         return;
     }
     regexp->fMatcher->reset(index, *status);
@@ -838,7 +838,7 @@ uregex_setRegion64(URegularExpression   *regexp2,
                    int64_t               regionLimit,
                    UErrorCode           *status)  {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, TRUE, status) == FALSE) {
+    if (validateRE(regexp, true, status) == false) {
         return;
     }
     regexp->fMatcher->region(regionStart, regionLimit, *status);
@@ -857,7 +857,7 @@ uregex_setRegionAndStart(URegularExpression   *regexp2,
                  int64_t               startIndex,
                  UErrorCode           *status)  {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, TRUE, status) == FALSE) {
+    if (validateRE(regexp, true, status) == false) {
         return;
     }
     regexp->fMatcher->region(regionStart, regionLimit, startIndex, *status);
@@ -878,7 +878,7 @@ U_CAPI int64_t U_EXPORT2
 uregex_regionStart64(const  URegularExpression   *regexp2,
                             UErrorCode           *status)  {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, TRUE, status) == FALSE) {
+    if (validateRE(regexp, true, status) == false) {
         return 0;
     }
     return regexp->fMatcher->regionStart();
@@ -900,7 +900,7 @@ U_CAPI int64_t U_EXPORT2
 uregex_regionEnd64(const  URegularExpression   *regexp2,
                           UErrorCode           *status)  {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, TRUE, status) == FALSE) {
+    if (validateRE(regexp, true, status) == false) {
         return 0;
     }
     return regexp->fMatcher->regionEnd();
@@ -916,8 +916,8 @@ U_CAPI UBool U_EXPORT2
 uregex_hasTransparentBounds(const  URegularExpression   *regexp2,
                                    UErrorCode           *status)  {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, FALSE, status) == FALSE) {
-        return FALSE;
+    if (validateRE(regexp, false, status) == false) {
+        return false;
     }
     return regexp->fMatcher->hasTransparentBounds();
 }
@@ -933,7 +933,7 @@ uregex_useTransparentBounds(URegularExpression    *regexp2,
                             UBool                  b,
                             UErrorCode            *status)  {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, FALSE, status) == FALSE) {
+    if (validateRE(regexp, false, status) == false) {
         return;
     }
     regexp->fMatcher->useTransparentBounds(b);
@@ -949,8 +949,8 @@ U_CAPI UBool U_EXPORT2
 uregex_hasAnchoringBounds(const  URegularExpression   *regexp2,
                                  UErrorCode           *status)  {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, FALSE, status) == FALSE) {
-        return FALSE;
+    if (validateRE(regexp, false, status) == false) {
+        return false;
     }
     return regexp->fMatcher->hasAnchoringBounds();
 }
@@ -966,7 +966,7 @@ uregex_useAnchoringBounds(URegularExpression    *regexp2,
                           UBool                  b,
                           UErrorCode            *status)  {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, FALSE, status) == FALSE) {
+    if (validateRE(regexp, false, status) == false) {
         return;
     }
     regexp->fMatcher->useAnchoringBounds(b);
@@ -982,8 +982,8 @@ U_CAPI UBool U_EXPORT2
 uregex_hitEnd(const  URegularExpression   *regexp2,
                      UErrorCode           *status)  {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, TRUE, status) == FALSE) {
-        return FALSE;
+    if (validateRE(regexp, true, status) == false) {
+        return false;
     }
     return regexp->fMatcher->hitEnd();
 }
@@ -998,8 +998,8 @@ U_CAPI UBool U_EXPORT2
 uregex_requireEnd(const  URegularExpression   *regexp2,
                          UErrorCode           *status)  {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, TRUE, status) == FALSE) {
-        return FALSE;
+    if (validateRE(regexp, true, status) == false) {
+        return false;
     }
     return regexp->fMatcher->requireEnd();
 }
@@ -1015,7 +1015,7 @@ uregex_setTimeLimit(URegularExpression   *regexp2,
                     int32_t               limit,
                     UErrorCode           *status) {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, FALSE, status)) {
+    if (validateRE(regexp, false, status)) {
         regexp->fMatcher->setTimeLimit(limit, *status);
     }
 }
@@ -1032,7 +1032,7 @@ uregex_getTimeLimit(const  URegularExpression   *regexp2,
                            UErrorCode           *status) {
     int32_t retVal = 0;
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, FALSE, status)) {
+    if (validateRE(regexp, false, status)) {
         retVal = regexp->fMatcher->getTimeLimit();
     }
     return retVal;
@@ -1050,7 +1050,7 @@ uregex_setStackLimit(URegularExpression   *regexp2,
                      int32_t               limit,
                      UErrorCode           *status) {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, FALSE, status)) {
+    if (validateRE(regexp, false, status)) {
         regexp->fMatcher->setStackLimit(limit, *status);
     }
 }
@@ -1067,7 +1067,7 @@ uregex_getStackLimit(const  URegularExpression   *regexp2,
                             UErrorCode           *status) {
     int32_t retVal = 0;
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, FALSE, status)) {
+    if (validateRE(regexp, false, status)) {
         retVal = regexp->fMatcher->getStackLimit();
     }
     return retVal;
@@ -1085,7 +1085,7 @@ uregex_setMatchCallback(URegularExpression      *regexp2,
                         const void              *context,
                         UErrorCode              *status) {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, FALSE, status)) {
+    if (validateRE(regexp, false, status)) {
         regexp->fMatcher->setMatchCallback(callback, context, *status);
     }
 }
@@ -1102,7 +1102,7 @@ uregex_getMatchCallback(const URegularExpression    *regexp2,
                         const void                 **context,
                         UErrorCode                  *status) {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-     if (validateRE(regexp, FALSE, status)) {
+     if (validateRE(regexp, false, status)) {
          regexp->fMatcher->getMatchCallback(*callback, *context, *status);
      }
 }
@@ -1119,7 +1119,7 @@ uregex_setFindProgressCallback(URegularExpression              *regexp2,
                                 const void                      *context,
                                 UErrorCode                      *status) {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, FALSE, status)) {
+    if (validateRE(regexp, false, status)) {
         regexp->fMatcher->setFindProgressCallback(callback, context, *status);
     }
 }
@@ -1136,7 +1136,7 @@ uregex_getFindProgressCallback(const URegularExpression          *regexp2,
                                 const void                        **context,
                                 UErrorCode                        *status) {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-     if (validateRE(regexp, FALSE, status)) {
+     if (validateRE(regexp, false, status)) {
          regexp->fMatcher->getFindProgressCallback(*callback, *context, *status);
      }
 }
@@ -1155,7 +1155,7 @@ uregex_replaceAll(URegularExpression    *regexp2,
                   int32_t                destCapacity,
                   UErrorCode            *status)  {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, TRUE, status) == FALSE) {
+    if (validateRE(regexp, true, status) == false) {
         return 0;
     }
     if (replacementText == NULL || replacementLength < -1 ||
@@ -1203,7 +1203,7 @@ uregex_replaceAllUText(URegularExpression    *regexp2,
                        UText                 *dest,
                        UErrorCode            *status)  {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, TRUE, status) == FALSE) {
+    if (validateRE(regexp, true, status) == false) {
         return 0;
     }
     if (replacementText == NULL) {
@@ -1229,7 +1229,7 @@ uregex_replaceFirst(URegularExpression  *regexp2,
                     int32_t              destCapacity,
                     UErrorCode          *status)  {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, TRUE, status) == FALSE) {
+    if (validateRE(regexp, true, status) == false) {
         return 0;
     }
     if (replacementText == NULL || replacementLength < -1 ||
@@ -1264,7 +1264,7 @@ uregex_replaceFirstUText(URegularExpression  *regexp2,
                          UText                 *dest,
                          UErrorCode            *status)  {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, TRUE, status) == FALSE) {
+    if (validateRE(regexp, true, status) == false) {
         return 0;
     }
     if (replacementText == NULL) {
@@ -1346,16 +1346,16 @@ int32_t RegexCImpl::appendReplacement(RegularExpression    *regexp,
     // If we come in with a buffer overflow error, don't suppress the operation.
     //  A series of appendReplacements, appendTail need to correctly preflight
     //  the buffer size when an overflow happens somewhere in the middle.
-    UBool pendingBufferOverflow = FALSE;
+    UBool pendingBufferOverflow = false;
     if (*status == U_BUFFER_OVERFLOW_ERROR && destCapacity != NULL && *destCapacity == 0) {
-        pendingBufferOverflow = TRUE;
+        pendingBufferOverflow = true;
         *status = U_ZERO_ERROR;
     }
 
     //
     // Validate all parameters
     //
-    if (validateRE(regexp, TRUE, status) == FALSE) {
+    if (validateRE(regexp, true, status) == false) {
         return 0;
     }
     if (replacementText == NULL || replacementLength < -1 ||
@@ -1367,7 +1367,7 @@ int32_t RegexCImpl::appendReplacement(RegularExpression    *regexp,
     }
 
     RegexMatcher *m = regexp->fMatcher;
-    if (m->fMatch == FALSE) {
+    if (m->fMatch == false) {
         *status = U_REGEX_INVALID_STATE;
         return 0;
     }
@@ -1477,7 +1477,7 @@ int32_t RegexCImpl::appendReplacement(RegularExpression    *regexp,
                     break;
                 }
                 U16_GET(replacementText, 0, replIdx, replacementLength, c32);
-                if (u_isdigit(c32) == FALSE) {
+                if (u_isdigit(c32) == false) {
                     break;
                 }
 
@@ -1623,13 +1623,13 @@ int32_t RegexCImpl::appendTail(RegularExpression    *regexp,
     // If we come in with a buffer overflow error, don't suppress the operation.
     //  A series of appendReplacements, appendTail need to correctly preflight
     //  the buffer size when an overflow happens somewhere in the middle.
-    UBool pendingBufferOverflow = FALSE;
+    UBool pendingBufferOverflow = false;
     if (*status == U_BUFFER_OVERFLOW_ERROR && destCapacity != NULL && *destCapacity == 0) {
-        pendingBufferOverflow = TRUE;
+        pendingBufferOverflow = true;
         *status = U_ZERO_ERROR;
     }
 
-    if (validateRE(regexp, TRUE, status) == FALSE) {
+    if (validateRE(regexp, true, status) == false) {
         return 0;
     }
 
@@ -1948,7 +1948,7 @@ uregex_split(URegularExpression      *regexp2,
              int32_t                  destFieldsCapacity,
              UErrorCode              *status) {
     RegularExpression *regexp = (RegularExpression*)regexp2;
-    if (validateRE(regexp, TRUE, status) == FALSE) {
+    if (validateRE(regexp, true, status) == false) {
         return 0;
     }
     if ((destBuf == NULL && destCapacity > 0) ||
diff --git a/deps/icu-small/source/i18n/usearch.cpp b/deps/icu-small/source/i18n/usearch.cpp
index 80b80fa3b4..0fecd709e7 100644
--- a/deps/icu-small/source/i18n/usearch.cpp
+++ b/deps/icu-small/source/i18n/usearch.cpp
@@ -76,7 +76,7 @@ U_CDECL_BEGIN
 static UBool U_CALLCONV
 usearch_cleanup(void) {
     g_nfcImpl = nullptr;
-    return TRUE;
+    return true;
 }
 U_CDECL_END
 
@@ -502,7 +502,7 @@ inline void setMatchNotFound(UStringSearch *strsrch, UErrorCode &status)
 * Checks if the offset runs out of the text string
 * @param offset
 * @param textlength of the text string
-* @return TRUE if offset is out of bounds, FALSE otherwise
+* @return true if offset is out of bounds, false otherwise
 */
 static
 inline UBool isOutOfBounds(int32_t textlength, int32_t offset)
@@ -515,13 +515,13 @@ inline UBool isOutOfBounds(int32_t textlength, int32_t offset)
 * @param strsrch string search data
 * @param start offset of possible match
 * @param end offset of possible match
-* @return TRUE if identical match is found
+* @return true if identical match is found
 */
 static
 inline UBool checkIdentical(const UStringSearch *strsrch, int32_t start, int32_t end)
 {
     if (strsrch->strength != UCOL_IDENTICAL) {
-        return TRUE;
+        return true;
     }
 
     // Note: We could use Normalizer::compare() or similar, but for short strings
@@ -529,10 +529,10 @@ inline UBool checkIdentical(const UStringSearch *strsrch, int32_t start, int32_t
     UErrorCode status = U_ZERO_ERROR;
     UnicodeString t2, p2;
     strsrch->nfd->normalize(
-        UnicodeString(FALSE, strsrch->search->text + start, end - start), t2, status);
+        UnicodeString(false, strsrch->search->text + start, end - start), t2, status);
     strsrch->nfd->normalize(
-        UnicodeString(FALSE, strsrch->pattern.text, strsrch->pattern.textLength), p2, status);
-    // return FALSE if NFD failed
+        UnicodeString(false, strsrch->pattern.text, strsrch->pattern.textLength), p2, status);
+    // return false if NFD failed
     return U_SUCCESS(status) && t2 == p2;
 }
 
@@ -570,7 +570,7 @@ U_CAPI UStringSearch * U_EXPORT2 usearch_open(const UChar *pattern,
             return nullptr;
         }
         else {
-            result->ownCollator = TRUE;
+            result->ownCollator = true;
         }
         return result;
     }
@@ -669,7 +669,7 @@ U_CAPI UStringSearch * U_EXPORT2 usearch_openFromCollator(
         }
 #endif
 
-        result->ownCollator           = FALSE;
+        result->ownCollator           = false;
         result->search->matchedLength = 0;
         result->search->matchedIndex  = USEARCH_DONE;
         result->utilIter              = nullptr;
@@ -681,11 +681,11 @@ U_CAPI UStringSearch * U_EXPORT2 usearch_openFromCollator(
             return nullptr;
         }
 
-        result->search->isOverlap          = FALSE;
-        result->search->isCanonicalMatch   = FALSE;
+        result->search->isOverlap          = false;
+        result->search->isCanonicalMatch   = false;
         result->search->elementComparisonType = 0;
-        result->search->isForwardSearching = TRUE;
-        result->search->reset              = TRUE;
+        result->search->isForwardSearching = true;
+        result->search->reset              = true;
 
         initialize(result, status);
 
@@ -734,17 +734,17 @@ U_CAPI void U_EXPORT2 usearch_close(UStringSearch *strsrch)
 namespace {
 
 UBool initTextProcessedIter(UStringSearch *strsrch, UErrorCode *status) {
-    if (U_FAILURE(*status)) { return FALSE; }
+    if (U_FAILURE(*status)) { return false; }
     if (strsrch->textProcessedIter == nullptr) {
         strsrch->textProcessedIter = new icu::UCollationPCE(strsrch->textIter);
         if (strsrch->textProcessedIter == nullptr) {
             *status = U_MEMORY_ALLOCATION_ERROR;
-            return FALSE;
+            return false;
         }
     } else {
         strsrch->textProcessedIter->init(strsrch->textIter);
     }
-    return TRUE;
+    return true;
 }
 
 }
@@ -764,7 +764,7 @@ U_CAPI void U_EXPORT2 usearch_setOffset(UStringSearch *strsrch,
         }
         strsrch->search->matchedIndex  = USEARCH_DONE;
         strsrch->search->matchedLength = 0;
-        strsrch->search->reset         = FALSE;
+        strsrch->search->reset         = false;
     }
 }
 
@@ -789,11 +789,11 @@ U_CAPI void U_EXPORT2 usearch_setAttribute(UStringSearch        *strsrch,
         switch (attribute)
         {
         case USEARCH_OVERLAP :
-            strsrch->search->isOverlap = (value == USEARCH_ON ? TRUE : FALSE);
+            strsrch->search->isOverlap = (value == USEARCH_ON ? true : false);
             break;
         case USEARCH_CANONICAL_MATCH :
-            strsrch->search->isCanonicalMatch = (value == USEARCH_ON ? TRUE :
-                                                                      FALSE);
+            strsrch->search->isCanonicalMatch = (value == USEARCH_ON ? true :
+                                                                      false);
             break;
         case USEARCH_ELEMENT_COMPARISON :
             if (value == USEARCH_PATTERN_BASE_WEIGHT_IS_WILDCARD || value == USEARCH_ANY_BASE_WEIGHT_IS_WILDCARD) {
@@ -819,10 +819,10 @@ U_CAPI USearchAttributeValue U_EXPORT2 usearch_getAttribute(
     if (strsrch) {
         switch (attribute) {
         case USEARCH_OVERLAP :
-            return (strsrch->search->isOverlap == TRUE ? USEARCH_ON :
+            return (strsrch->search->isOverlap == true ? USEARCH_ON :
                                                         USEARCH_OFF);
         case USEARCH_CANONICAL_MATCH :
-            return (strsrch->search->isCanonicalMatch == TRUE ? USEARCH_ON :
+            return (strsrch->search->isCanonicalMatch == true ? USEARCH_ON :
                                                                USEARCH_OFF);
         case USEARCH_ELEMENT_COMPARISON :
             {
@@ -936,7 +936,7 @@ U_CAPI void U_EXPORT2 usearch_setText(      UStringSearch *strsrch,
             ucol_setText(strsrch->textIter, text, textlength, status);
             strsrch->search->matchedIndex  = USEARCH_DONE;
             strsrch->search->matchedLength = 0;
-            strsrch->search->reset         = TRUE;
+            strsrch->search->reset         = true;
 #if !UCONFIG_NO_BREAK_ITERATION
             if (strsrch->search->breakIter != nullptr) {
                 ubrk_setText(strsrch->search->breakIter, text,
@@ -978,7 +978,7 @@ U_CAPI void U_EXPORT2 usearch_setCollator(      UStringSearch *strsrch,
             strsrch->textIter = strsrch->utilIter = nullptr;
             if (strsrch->ownCollator && (strsrch->collator != collator)) {
                 ucol_close((UCollator *)strsrch->collator);
-                strsrch->ownCollator = FALSE;
+                strsrch->ownCollator = false;
             }
             strsrch->collator    = collator;
             strsrch->strength    = ucol_getStrength(collator);
@@ -1064,7 +1064,7 @@ U_CAPI int32_t U_EXPORT2 usearch_first(UStringSearch *strsrch,
                                        UErrorCode    *status)
 {
     if (strsrch && U_SUCCESS(*status)) {
-        strsrch->search->isForwardSearching = TRUE;
+        strsrch->search->isForwardSearching = true;
         usearch_setOffset(strsrch, 0, status);
         if (U_SUCCESS(*status)) {
             return usearch_next(strsrch, status);
@@ -1078,7 +1078,7 @@ U_CAPI int32_t U_EXPORT2 usearch_following(UStringSearch *strsrch,
                                            UErrorCode    *status)
 {
     if (strsrch && U_SUCCESS(*status)) {
-        strsrch->search->isForwardSearching = TRUE;
+        strsrch->search->isForwardSearching = true;
         // position checked in usearch_setOffset
         usearch_setOffset(strsrch, position, status);
         if (U_SUCCESS(*status)) {
@@ -1092,7 +1092,7 @@ U_CAPI int32_t U_EXPORT2 usearch_last(UStringSearch *strsrch,
                                       UErrorCode    *status)
 {
     if (strsrch && U_SUCCESS(*status)) {
-        strsrch->search->isForwardSearching = FALSE;
+        strsrch->search->isForwardSearching = false;
         usearch_setOffset(strsrch, strsrch->search->textLength, status);
         if (U_SUCCESS(*status)) {
             return usearch_previous(strsrch, status);
@@ -1106,7 +1106,7 @@ U_CAPI int32_t U_EXPORT2 usearch_preceding(UStringSearch *strsrch,
                                            UErrorCode    *status)
 {
     if (strsrch && U_SUCCESS(*status)) {
-        strsrch->search->isForwardSearching = FALSE;
+        strsrch->search->isForwardSearching = false;
         // position checked in usearch_setOffset
         usearch_setOffset(strsrch, position, status);
         if (U_SUCCESS(*status)) {
@@ -1146,7 +1146,7 @@ U_CAPI int32_t U_EXPORT2 usearch_next(UStringSearch *strsrch,
         // or is set by the user
         int32_t      offset       = usearch_getOffset(strsrch);
         USearch     *search       = strsrch->search;
-        search->reset             = FALSE;
+        search->reset             = false;
         int32_t      textlength   = search->textLength;
         if (search->isForwardSearching) {
             if (offset == textlength ||
@@ -1164,7 +1164,7 @@ U_CAPI int32_t U_EXPORT2 usearch_next(UStringSearch *strsrch,
             // setOffset has been called or that previous ran off the text
             // string. the iterator would have been set to offset 0 if a
             // match is not found.
-            search->isForwardSearching = TRUE;
+            search->isForwardSearching = true;
             if (search->matchedIndex != USEARCH_DONE) {
                 // there's no need to set the collation element iterator
                 // the next call to next will set the offset.
@@ -1240,8 +1240,8 @@ U_CAPI int32_t U_EXPORT2 usearch_previous(UStringSearch *strsrch,
         USearch *search = strsrch->search;
         if (search->reset) {
             offset                     = search->textLength;
-            search->isForwardSearching = FALSE;
-            search->reset              = FALSE;
+            search->isForwardSearching = false;
+            search->reset              = false;
             setColEIterOffset(strsrch->textIter, offset, *status);
         }
         else {
@@ -1249,13 +1249,13 @@ U_CAPI int32_t U_EXPORT2 usearch_previous(UStringSearch *strsrch,
         }
 
         int32_t matchedindex = search->matchedIndex;
-        if (search->isForwardSearching == TRUE) {
+        if (search->isForwardSearching == true) {
             // switching direction.
             // if matchedIndex == USEARCH_DONE, it means that either a
             // setOffset has been called or that next ran off the text
             // string. the iterator would have been set to offset textLength if
             // a match is not found.
-            search->isForwardSearching = FALSE;
+            search->isForwardSearching = false;
             if (matchedindex != USEARCH_DONE) {
                 return matchedindex;
             }
@@ -1318,7 +1318,7 @@ U_CAPI void U_EXPORT2 usearch_reset(UStringSearch *strsrch)
     */
     if (strsrch) {
         UErrorCode status            = U_ZERO_ERROR;
-        UBool      sameCollAttribute = TRUE;
+        UBool      sameCollAttribute = true;
         uint32_t   ceMask;
         UBool      shift;
         uint32_t   varTop;
@@ -1327,14 +1327,14 @@ U_CAPI void U_EXPORT2 usearch_reset(UStringSearch *strsrch)
         UCollationStrength newStrength = ucol_getStrength(strsrch->collator);
         if ((strsrch->strength < UCOL_QUATERNARY && newStrength >= UCOL_QUATERNARY) ||
             (strsrch->strength >= UCOL_QUATERNARY && newStrength < UCOL_QUATERNARY)) {
-                sameCollAttribute = FALSE;
+                sameCollAttribute = false;
         }
 
         strsrch->strength    = ucol_getStrength(strsrch->collator);
         ceMask = getMask(strsrch->strength);
         if (strsrch->ceMask != ceMask) {
             strsrch->ceMask = ceMask;
-            sameCollAttribute = FALSE;
+            sameCollAttribute = false;
         }
 
         // if status is a failure, ucol_getAttribute returns UCOL_DEFAULT
@@ -1342,14 +1342,14 @@ U_CAPI void U_EXPORT2 usearch_reset(UStringSearch *strsrch)
                                   &status) == UCOL_SHIFTED;
         if (strsrch->toShift != shift) {
             strsrch->toShift  = shift;
-            sameCollAttribute = FALSE;
+            sameCollAttribute = false;
         }
 
         // if status is a failure, ucol_getVariableTop returns 0
         varTop = ucol_getVariableTop(strsrch->collator, &status);
         if (strsrch->variableTop != varTop) {
             strsrch->variableTop = varTop;
-            sameCollAttribute    = FALSE;
+            sameCollAttribute    = false;
         }
         if (!sameCollAttribute) {
             initialize(strsrch, &status);
@@ -1359,11 +1359,11 @@ U_CAPI void U_EXPORT2 usearch_reset(UStringSearch *strsrch)
                               &status);
         strsrch->search->matchedLength      = 0;
         strsrch->search->matchedIndex       = USEARCH_DONE;
-        strsrch->search->isOverlap          = FALSE;
-        strsrch->search->isCanonicalMatch   = FALSE;
+        strsrch->search->isOverlap          = false;
+        strsrch->search->isCanonicalMatch   = false;
         strsrch->search->elementComparisonType = 0;
-        strsrch->search->isForwardSearching = TRUE;
-        strsrch->search->reset              = TRUE;
+        strsrch->search->isForwardSearching = true;
+        strsrch->search->reset              = true;
     }
 }
 
@@ -1610,13 +1610,13 @@ static int32_t nextBoundaryAfter(UStringSearch *strsrch, int32_t startIndex, UEr
 }
 
 /*
- * Returns TRUE if index is on a break boundary. If the UStringSearch
+ * Returns true if index is on a break boundary. If the UStringSearch
  * has an external break iterator, test using that, otherwise test
  * using the internal character break iterator.
  */
 static UBool isBreakBoundary(UStringSearch *strsrch, int32_t index, UErrorCode &status) {
     if (U_FAILURE(status)) {
-        return TRUE;
+        return true;
     }
 #if 0
     const UChar *text = strsrch->search->text;
@@ -1626,7 +1626,7 @@ static UBool isBreakBoundary(UStringSearch *strsrch, int32_t index, UErrorCode &
     U_ASSERT(index<=textLen);
 
     if (index>=textLen || index<=0) {
-        return TRUE;
+        return true;
     }
 
     // If the character at the current index is not a GRAPHEME_EXTEND
@@ -1635,7 +1635,7 @@ static UBool isBreakBoundary(UStringSearch *strsrch, int32_t index, UErrorCode &
     U16_GET(text, 0, index, textLen, c);
     int32_t gcProperty = u_getIntPropertyValue(c, UCHAR_GRAPHEME_CLUSTER_BREAK);
     if (gcProperty != U_GCB_EXTEND && gcProperty != U_GCB_SPACING_MARK) {
-        return TRUE;
+        return true;
     }
 
     // We are at a combining mark.  If the preceding character is anything
@@ -1647,13 +1647,13 @@ static UBool isBreakBoundary(UStringSearch *strsrch, int32_t index, UErrorCode &
 #elif !UCONFIG_NO_BREAK_ITERATION
     UBreakIterator *breakiterator = getBreakIterator(strsrch, status);
     if (U_FAILURE(status)) {
-        return TRUE;
+        return true;
     }
 
     return ubrk_isBoundary(breakiterator, index);
 #else
     // **** or use the original code? ****
-    return TRUE;
+    return true;
 #endif
 }
 
@@ -1661,7 +1661,7 @@ static UBool isBreakBoundary(UStringSearch *strsrch, int32_t index, UErrorCode &
 static UBool onBreakBoundaries(const UStringSearch *strsrch, int32_t start, int32_t end, UErrorCode &status)
 {
     if (U_FAILURE(status)) {
-        return TRUE;
+        return true;
     }
 
 #if !UCONFIG_NO_BREAK_ITERATION
@@ -1673,7 +1673,7 @@ static UBool onBreakBoundaries(const UStringSearch *strsrch, int32_t start, int3
         // out-of-range indexes are never boundary positions
         if (start < startindex || start > endindex ||
             end < startindex || end > endindex) {
-            return FALSE;
+            return false;
         }
 
         return ubrk_isBoundary(breakiterator, start) &&
@@ -1681,7 +1681,7 @@ static UBool onBreakBoundaries(const UStringSearch *strsrch, int32_t start, int3
     }
 #endif
 
-    return TRUE;
+    return true;
 }
 #endif
 
@@ -1773,7 +1773,7 @@ U_CAPI UBool U_EXPORT2 usearch_search(UStringSearch  *strsrch,
                                        UErrorCode     *status)
 {
     if (U_FAILURE(*status)) {
-        return FALSE;
+        return false;
     }
 
     // TODO:  reject search patterns beginning with a combining char.
@@ -1796,7 +1796,7 @@ U_CAPI UBool U_EXPORT2 usearch_search(UStringSearch  *strsrch,
        startIdx > strsrch->search->textLength ||
        strsrch->pattern.ces == nullptr) {
            *status = U_ILLEGAL_ARGUMENT_ERROR;
-           return FALSE;
+           return false;
     }
 
     if (strsrch->pattern.pces == nullptr) {
@@ -1809,7 +1809,7 @@ U_CAPI UBool U_EXPORT2 usearch_search(UStringSearch  *strsrch,
     // An out-of-memory (OOM) failure can occur in the initializePatternPCETable function
     // or CEIBuffer constructor above, so we need to check the status.
     if (U_FAILURE(*status)) {
-        return FALSE;
+        return false;
     }
 
     int32_t    targetIx = 0;
@@ -1840,7 +1840,7 @@ U_CAPI UBool U_EXPORT2 usearch_search(UStringSearch  *strsrch,
     //
     for(targetIx=0; ; targetIx++)
     {
-        found = TRUE;
+        found = true;
         //  Inner loop checks for a match beginning at each
         //  position from the outer loop.
         int32_t targetIxOffset = 0;
@@ -1851,7 +1851,7 @@ U_CAPI UBool U_EXPORT2 usearch_search(UStringSearch  *strsrch,
         const CEI *firstCEI = ceb.get(targetIx);
         if (firstCEI == nullptr) {
             *status = U_INTERNAL_PROGRAM_ERROR;
-            found = FALSE;
+            found = false;
             break;
         }
         
@@ -1863,7 +1863,7 @@ U_CAPI UBool U_EXPORT2 usearch_search(UStringSearch  *strsrch,
             //    which will fail the compare, below.
             UCompareCEsResult ceMatch = compareCE64s(targetCEI->ce, patCE, strsrch->search->elementComparisonType);
             if ( ceMatch == U_CE_NO_MATCH ) {
-                found = FALSE;
+                found = false;
                 break;
             } else if ( ceMatch > U_CE_NO_MATCH ) {
                 if ( ceMatch == U_CE_SKIP_TARG ) {
@@ -1912,7 +1912,7 @@ U_CAPI UBool U_EXPORT2 usearch_search(UStringSearch  *strsrch,
             nextCEI  = ceb.get(targetIx + targetIxOffset);
             maxLimit = nextCEI->lowIndex;
             if (nextCEI->lowIndex == nextCEI->highIndex && nextCEI->ce != UCOL_PROCESSED_NULLORDER) {
-                found = FALSE;
+                found = false;
             }
         } else {
             for ( ; ; ++targetIxOffset ) {
@@ -1928,7 +1928,7 @@ U_CAPI UBool U_EXPORT2 usearch_search(UStringSearch  *strsrch,
                 if ( (((nextCEI->ce) >> 32) & 0xFFFF0000UL) == 0 ) {
                     UCompareCEsResult ceMatch = compareCE64s(nextCEI->ce, patCE, strsrch->search->elementComparisonType);
                     if ( ceMatch == U_CE_NO_MATCH || ceMatch == U_CE_SKIP_PATN ) {
-                        found = FALSE;
+                        found = false;
                         break;
                     }
                 // If lowIndex == highIndex, this target CE is part of an expansion of the last matched
@@ -1951,7 +1951,7 @@ U_CAPI UBool U_EXPORT2 usearch_search(UStringSearch  *strsrch,
         //   This type of match should be rejected for not completely consuming a
         //   combining sequence.
         if (!isBreakBoundary(strsrch, mStart, *status)) {
-            found = FALSE;
+            found = false;
         }
         if (U_FAILURE(*status)) {
             break;
@@ -1964,7 +1964,7 @@ U_CAPI UBool U_EXPORT2 usearch_search(UStringSearch  *strsrch,
         //    _following_ character.
         int32_t secondIx = firstCEI->highIndex;
         if (mStart == secondIx) {
-            found = FALSE;
+            found = false;
         }
 
         // Allow matches to end in the middle of a grapheme cluster if the following
@@ -1978,7 +1978,7 @@ U_CAPI UBool U_EXPORT2 usearch_search(UStringSearch  *strsrch,
         //   subsequent check for normalization boundary; however they are likely much faster
         //   tests in any case)
         // * the match limit is a normalization boundary
-        UBool allowMidclusterMatch = FALSE;
+        UBool allowMidclusterMatch = false;
         if (strsrch->search->text != nullptr && strsrch->search->textLength > maxLimit) {
             allowMidclusterMatch =
                     strsrch->search->breakIter == nullptr &&
@@ -2032,11 +2032,11 @@ U_CAPI UBool U_EXPORT2 usearch_search(UStringSearch  *strsrch,
             // If advancing to the end of a combining sequence in character indexing space
             //   advanced us beyond the end of the match in CE space, reject this match.
             if (mLimit > maxLimit) {
-                found = FALSE;
+                found = false;
             }
 
             if (!isBreakBoundary(strsrch, mLimit, *status)) {
-                found = FALSE;
+                found = false;
             }
             if (U_FAILURE(*status)) {
                 break;
@@ -2044,7 +2044,7 @@ U_CAPI UBool U_EXPORT2 usearch_search(UStringSearch  *strsrch,
         }
 
         if (! checkIdentical(strsrch, mStart, mLimit)) {
-            found = FALSE;
+            found = false;
         }
 
         if (found) {
@@ -2067,10 +2067,10 @@ U_CAPI UBool U_EXPORT2 usearch_search(UStringSearch  *strsrch,
     //
 
     if (U_FAILURE(*status)) {
-        found = FALSE; // No match if a failure occured.
+        found = false; // No match if a failure occured.
     }
 
-    if (found==FALSE) {
+    if (found==false) {
         mLimit = -1;
         mStart = -1;
     }
@@ -2093,7 +2093,7 @@ U_CAPI UBool U_EXPORT2 usearch_searchBackwards(UStringSearch  *strsrch,
                                                 UErrorCode     *status)
 {
     if (U_FAILURE(*status)) {
-        return FALSE;
+        return false;
     }
 
     // TODO:  reject search patterns beginning with a combining char.
@@ -2116,7 +2116,7 @@ U_CAPI UBool U_EXPORT2 usearch_searchBackwards(UStringSearch  *strsrch,
        startIdx > strsrch->search->textLength ||
        strsrch->pattern.ces == nullptr) {
            *status = U_ILLEGAL_ARGUMENT_ERROR;
-           return FALSE;
+           return false;
     }
 
     if (strsrch->pattern.pces == nullptr) {
@@ -2138,7 +2138,7 @@ U_CAPI UBool U_EXPORT2 usearch_searchBackwards(UStringSearch  *strsrch,
     if (startIdx < strsrch->search->textLength) {
         UBreakIterator *breakiterator = getBreakIterator(strsrch, *status);
         if (U_FAILURE(*status)) {
-            return FALSE;
+            return false;
         }
         int32_t next = ubrk_following(breakiterator, startIdx);
 
@@ -2155,7 +2155,7 @@ U_CAPI UBool U_EXPORT2 usearch_searchBackwards(UStringSearch  *strsrch,
 
     // An out-of-memory (OOM) failure can occur above, so we need to check the status.
     if (U_FAILURE(*status)) {
-        return FALSE;
+        return false;
     }
 
     const CEI *targetCEI = nullptr;
@@ -2178,14 +2178,14 @@ U_CAPI UBool U_EXPORT2 usearch_searchBackwards(UStringSearch  *strsrch,
     // and the beginning of the base text.
     for(targetIx = limitIx; ; targetIx += 1)
     {
-        found = TRUE;
+        found = true;
         // For targetIx > limitIx, this ceb.getPrevious gets a CE that is as far back in the ring buffer
         // (compared to the last CE fetched for the previous targetIx value) as we need to go
         // for this targetIx value, so if it is non-nullptr then other ceb.getPrevious calls should be OK.
         const CEI *lastCEI  = ceb.getPrevious(targetIx);
         if (lastCEI == nullptr) {
             *status = U_INTERNAL_PROGRAM_ERROR;
-            found = FALSE;
+            found = false;
              break;
         }
         //  Inner loop checks for a match beginning at each
@@ -2200,7 +2200,7 @@ U_CAPI UBool U_EXPORT2 usearch_searchBackwards(UStringSearch  *strsrch,
             //    which will fail the compare, below.
             UCompareCEsResult ceMatch = compareCE64s(targetCEI->ce, patCE, strsrch->search->elementComparisonType);
             if ( ceMatch == U_CE_NO_MATCH ) {
-                found = FALSE;
+                found = false;
                 break;
             } else if ( ceMatch > U_CE_NO_MATCH ) {
                 if ( ceMatch == U_CE_SKIP_TARG ) {
@@ -2240,7 +2240,7 @@ U_CAPI UBool U_EXPORT2 usearch_searchBackwards(UStringSearch  *strsrch,
         //   This type of match should be rejected for not completely consuming a
         //   combining sequence.
         if (!isBreakBoundary(strsrch, mStart, *status)) {
-            found = FALSE;
+            found = false;
         }
         if (U_FAILURE(*status)) {
             break;
@@ -2249,7 +2249,7 @@ U_CAPI UBool U_EXPORT2 usearch_searchBackwards(UStringSearch  *strsrch,
         // Look at the high index of the first CE in the match. If it's the same as the
         // low index, the first CE in the match is in the middle of an expansion.
         if (mStart == firstCEI->highIndex) {
-            found = FALSE;
+            found = false;
         }
 
 
@@ -2267,7 +2267,7 @@ U_CAPI UBool U_EXPORT2 usearch_searchBackwards(UStringSearch  *strsrch,
             const CEI *nextCEI  = ceb.getPrevious(targetIx - 1);
 
             if (nextCEI->lowIndex == nextCEI->highIndex && nextCEI->ce != UCOL_PROCESSED_NULLORDER) {
-                found = FALSE;
+                found = false;
             }
 
             mLimit = maxLimit = nextCEI->lowIndex;
@@ -2283,7 +2283,7 @@ U_CAPI UBool U_EXPORT2 usearch_searchBackwards(UStringSearch  *strsrch,
             //   subsequent check for normalization boundary; however they are likely much faster
             //   tests in any case)
             // * the match limit is a normalization boundary
-            UBool allowMidclusterMatch = FALSE;
+            UBool allowMidclusterMatch = false;
             if (strsrch->search->text != nullptr && strsrch->search->textLength > maxLimit) {
                 allowMidclusterMatch =
                         strsrch->search->breakIter == nullptr &&
@@ -2316,12 +2316,12 @@ U_CAPI UBool U_EXPORT2 usearch_searchBackwards(UStringSearch  *strsrch,
                 // If advancing to the end of a combining sequence in character indexing space
                 //   advanced us beyond the end of the match in CE space, reject this match.
                 if (mLimit > maxLimit) {
-                    found = FALSE;
+                    found = false;
                 }
 
                 // Make sure the end of the match is on a break boundary
                 if (!isBreakBoundary(strsrch, mLimit, *status)) {
-                    found = FALSE;
+                    found = false;
                 }
                 if (U_FAILURE(*status)) {
                     break;
@@ -2345,7 +2345,7 @@ U_CAPI UBool U_EXPORT2 usearch_searchBackwards(UStringSearch  *strsrch,
 
 
         if (! checkIdentical(strsrch, mStart, mLimit)) {
-            found = FALSE;
+            found = false;
         }
 
         if (found) {
@@ -2368,10 +2368,10 @@ U_CAPI UBool U_EXPORT2 usearch_searchBackwards(UStringSearch  *strsrch,
     //
 
     if (U_FAILURE(*status)) {
-        found = FALSE; // No match if a failure occured.
+        found = false; // No match if a failure occured.
     }
 
-    if (found==FALSE) {
+    if (found==false) {
         mLimit = -1;
         mStart = -1;
     }
@@ -2393,7 +2393,7 @@ UBool usearch_handleNextExact(UStringSearch *strsrch, UErrorCode *status)
 {
     if (U_FAILURE(*status)) {
         setMatchNotFound(strsrch, *status);
-        return FALSE;
+        return false;
     }
 
     int32_t textOffset = ucol_getOffset(strsrch->textIter);
@@ -2403,10 +2403,10 @@ UBool usearch_handleNextExact(UStringSearch *strsrch, UErrorCode *status)
     if (usearch_search(strsrch, textOffset, &start, &end, status)) {
         strsrch->search->matchedIndex  = start;
         strsrch->search->matchedLength = end - start;
-        return TRUE;
+        return true;
     } else {
         setMatchNotFound(strsrch, *status);
-        return FALSE;
+        return false;
     }
 }
 
@@ -2414,7 +2414,7 @@ UBool usearch_handleNextCanonical(UStringSearch *strsrch, UErrorCode *status)
 {
     if (U_FAILURE(*status)) {
         setMatchNotFound(strsrch, *status);
-        return FALSE;
+        return false;
     }
 
     int32_t textOffset = ucol_getOffset(strsrch->textIter);
@@ -2424,10 +2424,10 @@ UBool usearch_handleNextCanonical(UStringSearch *strsrch, UErrorCode *status)
     if (usearch_search(strsrch, textOffset, &start, &end, status)) {
         strsrch->search->matchedIndex  = start;
         strsrch->search->matchedLength = end - start;
-        return TRUE;
+        return true;
     } else {
         setMatchNotFound(strsrch, *status);
-        return FALSE;
+        return false;
     }
 }
 
@@ -2435,7 +2435,7 @@ UBool usearch_handlePreviousExact(UStringSearch *strsrch, UErrorCode *status)
 {
     if (U_FAILURE(*status)) {
         setMatchNotFound(strsrch, *status);
-        return FALSE;
+        return false;
     }
 
     int32_t textOffset;
@@ -2448,7 +2448,7 @@ UBool usearch_handlePreviousExact(UStringSearch *strsrch, UErrorCode *status)
             initializePatternPCETable(strsrch, status);
             if (!initTextProcessedIter(strsrch, status)) {
                 setMatchNotFound(strsrch, *status);
-                return FALSE;
+                return false;
             }
             for (int32_t nPCEs = 0; nPCEs < strsrch->pattern.pcesLength - 1; nPCEs++) {
                 int64_t pce = strsrch->textProcessedIter->nextProcessed(nullptr, nullptr, status);
@@ -2459,7 +2459,7 @@ UBool usearch_handlePreviousExact(UStringSearch *strsrch, UErrorCode *status)
             }
             if (U_FAILURE(*status)) {
                 setMatchNotFound(strsrch, *status);
-                return FALSE;
+                return false;
             }
             textOffset = ucol_getOffset(strsrch->textIter);
         }
@@ -2473,10 +2473,10 @@ UBool usearch_handlePreviousExact(UStringSearch *strsrch, UErrorCode *status)
     if (usearch_searchBackwards(strsrch, textOffset, &start, &end, status)) {
         strsrch->search->matchedIndex = start;
         strsrch->search->matchedLength = end - start;
-        return TRUE;
+        return true;
     } else {
         setMatchNotFound(strsrch, *status);
-        return FALSE;
+        return false;
     }
 }
 
@@ -2485,7 +2485,7 @@ UBool usearch_handlePreviousCanonical(UStringSearch *strsrch,
 {
     if (U_FAILURE(*status)) {
         setMatchNotFound(strsrch, *status);
-        return FALSE;
+        return false;
     }
 
     int32_t textOffset;
@@ -2498,7 +2498,7 @@ UBool usearch_handlePreviousCanonical(UStringSearch *strsrch,
             initializePatternPCETable(strsrch, status);
             if (!initTextProcessedIter(strsrch, status)) {
                 setMatchNotFound(strsrch, *status);
-                return FALSE;
+                return false;
             }
             for (int32_t nPCEs = 0; nPCEs < strsrch->pattern.pcesLength - 1; nPCEs++) {
                 int64_t pce = strsrch->textProcessedIter->nextProcessed(nullptr, nullptr, status);
@@ -2509,7 +2509,7 @@ UBool usearch_handlePreviousCanonical(UStringSearch *strsrch,
             }
             if (U_FAILURE(*status)) {
                 setMatchNotFound(strsrch, *status);
-                return FALSE;
+                return false;
             }
             textOffset = ucol_getOffset(strsrch->textIter);
         }
@@ -2523,10 +2523,10 @@ UBool usearch_handlePreviousCanonical(UStringSearch *strsrch,
     if (usearch_searchBackwards(strsrch, textOffset, &start, &end, status)) {
         strsrch->search->matchedIndex = start;
         strsrch->search->matchedLength = end - start;
-        return TRUE;
+        return true;
     } else {
         setMatchNotFound(strsrch, *status);
-        return FALSE;
+        return false;
     }
 }
 
diff --git a/deps/icu-small/source/i18n/uspoof.cpp b/deps/icu-small/source/i18n/uspoof.cpp
index dd4618baa7..f894dc44ca 100644
--- a/deps/icu-small/source/i18n/uspoof.cpp
+++ b/deps/icu-small/source/i18n/uspoof.cpp
@@ -41,7 +41,7 @@ U_NAMESPACE_USE
 static UnicodeSet *gInclusionSet = NULL;
 static UnicodeSet *gRecommendedSet = NULL;
 static const Normalizer2 *gNfdNormalizer = NULL;
-static UInitOnce gSpoofInitStaticsOnce = U_INITONCE_INITIALIZER;
+static UInitOnce gSpoofInitStaticsOnce {};
 
 namespace {
 
@@ -53,13 +53,13 @@ uspoof_cleanup(void) {
     gRecommendedSet = NULL;
     gNfdNormalizer = NULL;
     gSpoofInitStaticsOnce.reset();
-    return TRUE;
+    return true;
 }
 
 void U_CALLCONV initializeStatics(UErrorCode &status) {
     static const char16_t *inclusionPat =
-        u"['\\-.\\:\\u00B7\\u0375\\u058A\\u05F3\\u05F4\\u06FD\\u06FE\\u0F0B\\u200C"
-        u"\\u200D\\u2010\\u2019\\u2027\\u30A0\\u30FB]";
+        u"['\\-.\\:\\u00B7\\u0375\\u058A\\u05F3\\u05F4\\u06FD\\u06FE\\u0F0B\\u2010"
+        u"\\u2019\\u2027\\u30A0\\u30FB]";
     gInclusionSet = new UnicodeSet(UnicodeString(inclusionPat), status);
     if (gInclusionSet == NULL) {
         status = U_MEMORY_ALLOCATION_ERROR;
@@ -103,14 +103,14 @@ void U_CALLCONV initializeStatics(UErrorCode &status) {
         u"\\u0C56\\u0C5D\\u0C60\\u0C61\\u0C66-\\u0C6F\\u0C80\\u0C82\\u0C83\\u0C85-"
         u"\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-"
         u"\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDD\\u0CE0-\\u0CE3"
-        u"\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D00\\u0D02\\u0D03\\u0D05-\\u0D0C\\u0D0E-"
+        u"\\u0CE6-\\u0CEF\\u0CF1-\\u0CF3\\u0D00\\u0D02\\u0D03\\u0D05-\\u0D0C\\u0D0E-"
         u"\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D43\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-"
         u"\\u0D57\\u0D60\\u0D61\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-"
         u"\\u0D8E\\u0D91-\\u0D96\\u0D9A-\\u0DA5\\u0DA7-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD"
         u"\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDE\\u0DF2\\u0E01-"
         u"\\u0E32\\u0E34-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84"
         u"\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB2\\u0EB4-\\u0EBD\\u0EC0-"
-        u"\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDE\\u0EDF\\u0F00\\u0F20-"
+        u"\\u0EC4\\u0EC6\\u0EC8-\\u0ECE\\u0ED0-\\u0ED9\\u0EDE\\u0EDF\\u0F00\\u0F20-"
         u"\\u0F29\\u0F35\\u0F37\\u0F3E-\\u0F42\\u0F44-\\u0F47\\u0F49-\\u0F4C\\u0F4E-"
         u"\\u0F51\\u0F53-\\u0F56\\u0F58-\\u0F5B\\u0F5D-\\u0F68\\u0F6A-\\u0F6C\\u0F71"
         u"\\u0F72\\u0F74\\u0F7A-\\u0F80\\u0F82-\\u0F84\\u0F86-\\u0F92\\u0F94-\\u0F97"
@@ -131,17 +131,18 @@ void U_CALLCONV initializeStatics(UErrorCode &status) {
         u"\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-"
         u"\\u3007\\u3041-\\u3096\\u3099\\u309A\\u309D\\u309E\\u30A1-\\u30FA\\u30FC-"
         u"\\u30FE\\u3105-\\u312D\\u312F\\u31A0-\\u31BF\\u3400-\\u4DBF\\u4E00-\\u9FFF"
-        u"\\uA67F\\uA717-\\uA71F\\uA788\\uA78D\\uA792\\uA793\\uA7AA\\uA7AE\\uA7B8"
-        u"\\uA7B9\\uA7C0-\\uA7CA\\uA7D0\\uA7D1\\uA7D3\\uA7D5-\\uA7D9\\uA9E7-\\uA9FE"
-        u"\\uAA60-\\uAA76\\uAA7A-\\uAA7F\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16"
-        u"\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB66\\uAB67\\uAC00-\\uD7A3\\uFA0E\\uFA0F"
-        u"\\uFA11\\uFA13\\uFA14\\uFA1F\\uFA21\\uFA23\\uFA24\\uFA27-\\uFA29\\U00011301"
-        u"\\U00011303\\U0001133B\\U0001133C\\U00016FF0\\U00016FF1\\U0001B11F-"
-        u"\\U0001B122\\U0001B150-\\U0001B152\\U0001B164-\\U0001B167\\U0001DF00-"
-        u"\\U0001DF1E\\U0001E7E0-\\U0001E7E6\\U0001E7E8-\\U0001E7EB\\U0001E7ED"
-        u"\\U0001E7EE\\U0001E7F0-\\U0001E7FE\\U00020000-\\U0002A6DF\\U0002A700-"
-        u"\\U0002B738\\U0002B740-\\U0002B81D\\U0002B820-\\U0002CEA1\\U0002CEB0-"
-        u"\\U0002EBE0\\U00030000-\\U0003134A]";
+        u"\\uA67F\\uA717-\\uA71F\\uA788\\uA78D\\uA792\\uA793\\uA7AA\\uA7C0-\\uA7CA"
+        u"\\uA7D0\\uA7D1\\uA7D3\\uA7D5-\\uA7D9\\uA9E7-\\uA9FE\\uAA60-\\uAA76\\uAA7A-"
+        u"\\uAA7F\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-"
+        u"\\uAB2E\\uAB66\\uAB67\\uAC00-\\uD7A3\\uFA0E\\uFA0F\\uFA11\\uFA13\\uFA14"
+        u"\\uFA1F\\uFA21\\uFA23\\uFA24\\uFA27-\\uFA29\\U00011301\\U00011303"
+        u"\\U0001133B\\U0001133C\\U00016FF0\\U00016FF1\\U0001B11F-\\U0001B122"
+        u"\\U0001B132\\U0001B150-\\U0001B152\\U0001B155\\U0001B164-\\U0001B167"
+        u"\\U0001DF00-\\U0001DF1E\\U0001DF25-\\U0001DF2A\\U0001E08F\\U0001E7E0-"
+        u"\\U0001E7E6\\U0001E7E8-\\U0001E7EB\\U0001E7ED\\U0001E7EE\\U0001E7F0-"
+        u"\\U0001E7FE\\U00020000-\\U0002A6DF\\U0002A700-\\U0002B739\\U0002B740-"
+        u"\\U0002B81D\\U0002B820-\\U0002CEA1\\U0002CEB0-\\U0002EBE0\\U00030000-"
+        u"\\U0003134A\\U00031350-\\U000323AF]";
 
     gRecommendedSet = new UnicodeSet(UnicodeString(recommendedPat), status);
     if (gRecommendedSet == NULL) {
@@ -611,7 +612,7 @@ int32_t checkImpl(const SpoofImpl* This, const UnicodeString& id, CheckResult* c
         int32_t     i;
         UChar32     c;
         UChar32     firstNonspacingMark = 0;
-        UBool       haveMultipleMarks = FALSE;  
+        UBool       haveMultipleMarks = false;  
         UnicodeSet  marksSeenSoFar;   // Set of combining marks in a single combining sequence.
         
         for (i=0; i<nfdLength ;) {
@@ -621,7 +622,7 @@ int32_t checkImpl(const SpoofImpl* This, const UnicodeString& id, CheckResult* c
                 firstNonspacingMark = 0;
                 if (haveMultipleMarks) {
                     marksSeenSoFar.clear();
-                    haveMultipleMarks = FALSE;
+                    haveMultipleMarks = false;
                 }
                 continue;
             }
@@ -631,7 +632,7 @@ int32_t checkImpl(const SpoofImpl* This, const UnicodeString& id, CheckResult* c
             }
             if (!haveMultipleMarks) {
                 marksSeenSoFar.add(firstNonspacingMark);
-                haveMultipleMarks = TRUE;
+                haveMultipleMarks = true;
             }
             if (marksSeenSoFar.contains(c)) {
                 // report the error, and stop scanning.
@@ -656,13 +657,13 @@ uspoof_check2UnicodeString(const USpoofChecker *sc,
                           UErrorCode *status) {
     const SpoofImpl *This = SpoofImpl::validateThis(sc, *status);
     if (This == NULL) {
-        return FALSE;
+        return false;
     }
 
     if (checkResult != NULL) {
         CheckResult* ThisCheckResult = CheckResult::validateThis(checkResult, *status);
         if (ThisCheckResult == NULL) {
-            return FALSE;
+            return false;
         }
         return checkImpl(This, id, ThisCheckResult, status);
     } else {
diff --git a/deps/icu-small/source/i18n/uspoof_conf.cpp b/deps/icu-small/source/i18n/uspoof_conf.cpp
index 172c0711af..5ecc59c12a 100644
--- a/deps/icu-small/source/i18n/uspoof_conf.cpp
+++ b/deps/icu-small/source/i18n/uspoof_conf.cpp
@@ -407,7 +407,7 @@ void ConfusabledataBuilder::build(const char * confusables, int32_t confusablesL
 //
 void ConfusabledataBuilder::outputData(UErrorCode &status) {
 
-    U_ASSERT(fSpoofImpl->fSpoofData->fDataOwned == TRUE);
+    U_ASSERT(fSpoofImpl->fSpoofData->fDataOwned == true);
 
     //  The Key Table
     //     While copying the keys to the runtime array,
diff --git a/deps/icu-small/source/i18n/uspoof_impl.cpp b/deps/icu-small/source/i18n/uspoof_impl.cpp
index f96826f86c..e50344c469 100644
--- a/deps/icu-small/source/i18n/uspoof_impl.cpp
+++ b/deps/icu-small/source/i18n/uspoof_impl.cpp
@@ -320,10 +320,10 @@ URestrictionLevel SpoofImpl::getRestrictionLevel(const UnicodeString& input, UEr
     // Section 5.2 step 2
     // Java use a static UnicodeSet for this test.  In C++, avoid the static variable
     // and just do a simple for loop.
-    UBool allASCII = TRUE;
+    UBool allASCII = true;
     for (int32_t i=0, length=input.length(); i<length; i++) {
         if (input.charAt(i) > 0x7f) {
-            allASCII = FALSE;
+            allASCII = false;
             break;
         }
     }
@@ -495,9 +495,9 @@ UBool SpoofData::validateDataVersion(UErrorCode &status) const {
         fRawData->fFormatVersion[2] != 0 ||
         fRawData->fFormatVersion[3] != 0) {
             status = U_INVALID_FORMAT_ERROR;
-            return FALSE;
+            return false;
     }
-    return TRUE;
+    return true;
 }
 
 static UBool U_CALLCONV
@@ -518,9 +518,9 @@ spoofDataIsAcceptable(void *context,
         if(version != NULL) {
             uprv_memcpy(version, pInfo->dataVersion, 4);
         }
-        return TRUE;
+        return true;
     } else {
-        return FALSE;
+        return false;
     }
 }
 
@@ -538,7 +538,7 @@ spoofDataIsAcceptable(void *context,
 //  uspoof_cleanupDefaultData - Called during cleanup.
 //
 
-static UInitOnce gSpoofInitDefaultOnce = U_INITONCE_INITIALIZER;
+static UInitOnce gSpoofInitDefaultOnce {};
 static SpoofData* gDefaultSpoofData;
 
 static UBool U_CALLCONV
@@ -549,7 +549,7 @@ uspoof_cleanupDefaultData(void) {
         gDefaultSpoofData = nullptr;
         gSpoofInitDefaultOnce.reset();
     }
-    return TRUE;
+    return true;
 }
 
 static void U_CALLCONV uspoof_loadDefaultData(UErrorCode& status) {
@@ -655,7 +655,7 @@ SpoofData::SpoofData(UErrorCode &status) {
 //           Called by constructors to put things in a known initial state.
 void SpoofData::reset() {
    fRawData = NULL;
-   fDataOwned = FALSE;
+   fDataOwned = false;
    fUDM      = NULL;
    fMemLimit = 0;
    fRefCount = 1;
diff --git a/deps/icu-small/source/i18n/uspoof_impl.h b/deps/icu-small/source/i18n/uspoof_impl.h
index e75ae262bd..68d7bedae1 100644
--- a/deps/icu-small/source/i18n/uspoof_impl.h
+++ b/deps/icu-small/source/i18n/uspoof_impl.h
@@ -28,6 +28,7 @@
 #ifdef __cplusplus
 
 #include "capi_helper.h"
+#include "umutex.h"
 
 U_NAMESPACE_BEGIN
 
diff --git a/deps/icu-small/source/i18n/utf16collationiterator.cpp b/deps/icu-small/source/i18n/utf16collationiterator.cpp
index f1bdfabe73..912163a0a3 100644
--- a/deps/icu-small/source/i18n/utf16collationiterator.cpp
+++ b/deps/icu-small/source/i18n/utf16collationiterator.cpp
@@ -78,9 +78,9 @@ UBool
 UTF16CollationIterator::foundNULTerminator() {
     if(limit == NULL) {
         limit = --pos;
-        return TRUE;
+        return true;
     } else {
-        return FALSE;
+        return false;
     }
 }
 
@@ -241,9 +241,9 @@ UBool
 FCDUTF16CollationIterator::foundNULTerminator() {
     if(limit == NULL) {
         limit = rawLimit = --pos;
-        return TRUE;
+        return true;
     } else {
-        return FALSE;
+        return false;
     }
 }
 
@@ -361,7 +361,7 @@ FCDUTF16CollationIterator::switchToForward() {
             // Switch to checking forward from it.
             pos = start = segmentStart = segmentLimit;
             // Note: If this segment is at the end of the input text,
-            // then it might help to return FALSE to indicate that, so that
+            // then it might help to return false to indicate that, so that
             // we do not have to re-check and normalize when we turn around and go backwards.
             // However, that would complicate the call sites for an optimization of an unusual case.
         }
@@ -372,7 +372,7 @@ FCDUTF16CollationIterator::switchToForward() {
 
 UBool
 FCDUTF16CollationIterator::nextSegment(UErrorCode &errorCode) {
-    if(U_FAILURE(errorCode)) { return FALSE; }
+    if(U_FAILURE(errorCode)) { return false; }
     U_ASSERT(checkDir > 0 && pos != limit);
     // The input text [segmentStart..pos[ passes the FCD check.
     const UChar *p = pos;
@@ -392,7 +392,7 @@ FCDUTF16CollationIterator::nextSegment(UErrorCode &errorCode) {
             do {
                 q = p;
             } while(p != rawLimit && nfcImpl.nextFCD16(p, rawLimit) > 0xff);
-            if(!normalize(pos, q, errorCode)) { return FALSE; }
+            if(!normalize(pos, q, errorCode)) { return false; }
             pos = start;
             break;
         }
@@ -405,7 +405,7 @@ FCDUTF16CollationIterator::nextSegment(UErrorCode &errorCode) {
     }
     U_ASSERT(pos != limit);
     checkDir = 0;
-    return TRUE;
+    return true;
 }
 
 void
@@ -436,7 +436,7 @@ FCDUTF16CollationIterator::switchToBackward() {
 
 UBool
 FCDUTF16CollationIterator::previousSegment(UErrorCode &errorCode) {
-    if(U_FAILURE(errorCode)) { return FALSE; }
+    if(U_FAILURE(errorCode)) { return false; }
     U_ASSERT(checkDir < 0 && pos != start);
     // The input text [pos..segmentLimit[ passes the FCD check.
     const UChar *p = pos;
@@ -458,7 +458,7 @@ FCDUTF16CollationIterator::previousSegment(UErrorCode &errorCode) {
                 q = p;
             } while(fcd16 > 0xff && p != rawStart &&
                     (fcd16 = nfcImpl.previousFCD16(rawStart, p)) != 0);
-            if(!normalize(q, pos, errorCode)) { return FALSE; }
+            if(!normalize(q, pos, errorCode)) { return false; }
             pos = limit;
             break;
         }
@@ -471,7 +471,7 @@ FCDUTF16CollationIterator::previousSegment(UErrorCode &errorCode) {
     }
     U_ASSERT(pos != start);
     checkDir = 0;
-    return TRUE;
+    return true;
 }
 
 UBool
@@ -479,14 +479,14 @@ FCDUTF16CollationIterator::normalize(const UChar *from, const UChar *to, UErrorC
     // NFD without argument checking.
     U_ASSERT(U_SUCCESS(errorCode));
     nfcImpl.decompose(from, to, normalized, (int32_t)(to - from), errorCode);
-    if(U_FAILURE(errorCode)) { return FALSE; }
+    if(U_FAILURE(errorCode)) { return false; }
     // Switch collation processing into the FCD buffer
     // with the result of normalizing [segmentStart, segmentLimit[.
     segmentStart = from;
     segmentLimit = to;
     start = normalized.getBuffer();
     limit = start + normalized.length();
-    return TRUE;
+    return true;
 }
 
 U_NAMESPACE_END
diff --git a/deps/icu-small/source/i18n/utf8collationiterator.cpp b/deps/icu-small/source/i18n/utf8collationiterator.cpp
index 345b1994ef..5a6cf7fd1b 100644
--- a/deps/icu-small/source/i18n/utf8collationiterator.cpp
+++ b/deps/icu-small/source/i18n/utf8collationiterator.cpp
@@ -80,15 +80,15 @@ UBool
 UTF8CollationIterator::foundNULTerminator() {
     if(length < 0) {
         length = --pos;
-        return TRUE;
+        return true;
     } else {
-        return FALSE;
+        return false;
     }
 }
 
 UBool
 UTF8CollationIterator::forbidSurrogateCodePoints() const {
-    return TRUE;
+    return true;
 }
 
 UChar32
@@ -224,7 +224,7 @@ FCDUTF8CollationIterator::nextHasLccc() const {
     // The lowest code point with ccc!=0 is U+0300 which is CC 80 in UTF-8.
     // CJK U+4000..U+DFFF except U+Axxx are also FCD-inert. (Lead bytes E4..ED except EA.)
     UChar32 c = u8[pos];
-    if(c < 0xcc || (0xe4 <= c && c <= 0xed && c != 0xea)) { return FALSE; }
+    if(c < 0xcc || (0xe4 <= c && c <= 0xed && c != 0xea)) { return false; }
     int32_t i = pos;
     U8_NEXT_OR_FFFD(u8, i, length, c);
     if(c > 0xffff) { c = U16_LEAD(c); }
@@ -235,7 +235,7 @@ UBool
 FCDUTF8CollationIterator::previousHasTccc() const {
     U_ASSERT(state == CHECK_BWD && pos != 0);
     UChar32 c = u8[pos - 1];
-    if(U8_IS_SINGLE(c)) { return FALSE; }
+    if(U8_IS_SINGLE(c)) { return false; }
     int32_t i = pos;
     U8_PREV_OR_FFFD(u8, 0, i, c);
     if(c > 0xffff) { c = U16_LEAD(c); }
@@ -255,9 +255,9 @@ UBool
 FCDUTF8CollationIterator::foundNULTerminator() {
     if(state == CHECK_FWD && length < 0) {
         length = --pos;
-        return TRUE;
+        return true;
     } else {
-        return FALSE;
+        return false;
     }
 }
 
@@ -383,7 +383,7 @@ FCDUTF8CollationIterator::switchToForward() {
 
 UBool
 FCDUTF8CollationIterator::nextSegment(UErrorCode &errorCode) {
-    if(U_FAILURE(errorCode)) { return FALSE; }
+    if(U_FAILURE(errorCode)) { return false; }
     U_ASSERT(state == CHECK_FWD && pos != length);
     // The input text [start..pos[ passes the FCD check.
     int32_t segmentStart = pos;
@@ -414,12 +414,12 @@ FCDUTF8CollationIterator::nextSegment(UErrorCode &errorCode) {
                 }
                 s.append(c);
             }
-            if(!normalize(s, errorCode)) { return FALSE; }
+            if(!normalize(s, errorCode)) { return false; }
             start = segmentStart;
             limit = pos;
             state = IN_NORMALIZED;
             pos = 0;
-            return TRUE;
+            return true;
         }
         prevCC = (uint8_t)fcd16;
         if(pos == length || prevCC == 0) {
@@ -431,7 +431,7 @@ FCDUTF8CollationIterator::nextSegment(UErrorCode &errorCode) {
     pos = segmentStart;
     U_ASSERT(pos != limit);
     state = IN_FCD_SEGMENT;
-    return TRUE;
+    return true;
 }
 
 void
@@ -462,7 +462,7 @@ FCDUTF8CollationIterator::switchToBackward() {
 
 UBool
 FCDUTF8CollationIterator::previousSegment(UErrorCode &errorCode) {
-    if(U_FAILURE(errorCode)) { return FALSE; }
+    if(U_FAILURE(errorCode)) { return false; }
     U_ASSERT(state == CHECK_BWD && pos != 0);
     // The input text [pos..limit[ passes the FCD check.
     int32_t segmentLimit = pos;
@@ -496,12 +496,12 @@ FCDUTF8CollationIterator::previousSegment(UErrorCode &errorCode) {
                 s.append(c);
             }
             s.reverse();
-            if(!normalize(s, errorCode)) { return FALSE; }
+            if(!normalize(s, errorCode)) { return false; }
             limit = segmentLimit;
             start = pos;
             state = IN_NORMALIZED;
             pos = normalized.length();
-            return TRUE;
+            return true;
         }
         nextCC = (uint8_t)(fcd16 >> 8);
         if(pos == 0 || nextCC == 0) {
@@ -513,7 +513,7 @@ FCDUTF8CollationIterator::previousSegment(UErrorCode &errorCode) {
     pos = segmentLimit;
     U_ASSERT(pos != start);
     state = IN_FCD_SEGMENT;
-    return TRUE;
+    return true;
 }
 
 UBool
diff --git a/deps/icu-small/source/i18n/vtzone.cpp b/deps/icu-small/source/i18n/vtzone.cpp
index 06f0b84c0f..bd81ee73e6 100644
--- a/deps/icu-small/source/i18n/vtzone.cpp
+++ b/deps/icu-small/source/i18n/vtzone.cpp
@@ -110,12 +110,12 @@ static int32_t parseAsciiDigits(const UnicodeString& str, int32_t start, int32_t
 }
 
 static UnicodeString& appendAsciiDigits(int32_t number, uint8_t length, UnicodeString& str) {
-    UBool negative = FALSE;
+    UBool negative = false;
     int32_t digits[10]; // max int32_t is 10 decimal digits
     int32_t i;
 
     if (number < 0) {
-        negative = TRUE;
+        negative = true;
         number *= -1;
     }
 
@@ -145,7 +145,7 @@ static UnicodeString& appendAsciiDigits(int32_t number, uint8_t length, UnicodeS
 }
 
 static UnicodeString& appendMillis(UDate date, UnicodeString& str) {
-    UBool negative = FALSE;
+    UBool negative = false;
     int32_t digits[20]; // max int64_t is 20 decimal digits
     int32_t i;
     int64_t number;
@@ -158,7 +158,7 @@ static UnicodeString& appendMillis(UDate date, UnicodeString& str) {
         number = (int64_t)date;
     }
     if (number < 0) {
-        negative = TRUE;
+        negative = true;
         number *= -1;
     }
     i = 0;
@@ -222,8 +222,8 @@ static UDate parseDateTimeString(const UnicodeString& str, int32_t offset, UErro
     }
 
     int32_t year = 0, month = 0, day = 0, hour = 0, min = 0, sec = 0;
-    UBool isUTC = FALSE;
-    UBool isValid = FALSE;
+    UBool isUTC = false;
+    UBool isValid = false;
     do {
         int length = str.length();
         if (length != 15 && length != 16) {
@@ -240,7 +240,7 @@ static UDate parseDateTimeString(const UnicodeString& str, int32_t offset, UErro
                 // invalid format
                 break;
             }
-            isUTC = TRUE;
+            isUTC = true;
         }
 
         year = parseAsciiDigits(str, 0, 4, status);
@@ -261,7 +261,7 @@ static UDate parseDateTimeString(const UnicodeString& str, int32_t offset, UErro
             break;
         }
 
-        isValid = TRUE;
+        isValid = true;
     } while(false);
 
     if (!isValid) {
@@ -285,7 +285,7 @@ static int32_t offsetStrToMillis(const UnicodeString& str, UErrorCode& status) {
         return 0;
     }
 
-    UBool isValid = FALSE;
+    UBool isValid = false;
     int32_t sign = 0, hour = 0, min = 0, sec = 0;
 
     do {
@@ -383,19 +383,19 @@ static void parseRRULE(const UnicodeString& rrule, int32_t& month, int32_t& dow,
     wim = 0;
     until = MIN_MILLIS;
 
-    UBool yearly = FALSE;
-    //UBool parseError = FALSE;
+    UBool yearly = false;
+    //UBool parseError = false;
 
     int32_t prop_start = 0;
     int32_t prop_end;
     UnicodeString prop, attr, value;
-    UBool nextProp = TRUE;
+    UBool nextProp = true;
 
     while (nextProp) {
         prop_end = rrule.indexOf(SEMICOLON, prop_start);
         if (prop_end == -1) {
             prop.setTo(rrule, prop_start);
-            nextProp = FALSE;
+            nextProp = false;
         } else {
             prop.setTo(rrule, prop_start, prop_end - prop_start);
             prop_start = prop_end + 1;
@@ -411,7 +411,7 @@ static void parseRRULE(const UnicodeString& rrule, int32_t& month, int32_t& dow,
         if (attr.compare(ICAL_FREQ, -1) == 0) {
             // only support YEARLY frequency type
             if (value.compare(ICAL_YEARLY, -1) == 0) {
-                yearly = TRUE;
+                yearly = true;
             } else {
                 goto rruleParseError;
             }
@@ -478,12 +478,12 @@ static void parseRRULE(const UnicodeString& rrule, int32_t& month, int32_t& dow,
             int32_t dom_idx = 0;
             int32_t dom_start = 0;
             int32_t dom_end;
-            UBool nextDOM = TRUE;
+            UBool nextDOM = true;
             while (nextDOM) {
                 dom_end = value.indexOf(COMMA, dom_start);
                 if (dom_end == -1) {
                     dom_end = value.length();
-                    nextDOM = FALSE;
+                    nextDOM = false;
                 }
                 if (dom_idx < domCount) {
                     dom[dom_idx] = parseAsciiDigits(value, dom_start, dom_end - dom_start, status);
@@ -563,10 +563,10 @@ static TimeZoneRule* createRuleByRRULE(const UnicodeString& zonename, int rawOff
             }
             // Make sure days are continuous
             for (i = 1; i < 7; i++) {
-                UBool found = FALSE;
+                UBool found = false;
                 for (j = 0; j < 7; j++) {
                     if (days[j] == firstDay + i) {
-                        found = TRUE;
+                        found = true;
                         break;
                     }
                 }
@@ -703,7 +703,7 @@ static TimeZoneRule* createRuleByRRULE(const UnicodeString& zonename, int rawOff
     } else if (dayOfWeek != 0 && nthDayOfWeek == 0 && dayOfMonth != 0) {
         // First day of week after day of month rule, for example,
         // first Sunday after 15th day in the month
-        adtr = new DateTimeRule(month, dayOfMonth, dayOfWeek, TRUE, startMID, DateTimeRule::WALL_TIME);
+        adtr = new DateTimeRule(month, dayOfMonth, dayOfWeek, true, startMID, DateTimeRule::WALL_TIME);
     }
     if (adtr == nullptr) {
         goto unsupportedRRule;
@@ -759,36 +759,36 @@ static TimeZoneRule* createRuleByRDATE(const UnicodeString& zonename, int32_t ra
  */
 static UBool isEquivalentDateRule(int32_t month, int32_t weekInMonth, int32_t dayOfWeek, const DateTimeRule *dtrule) {
     if (month != dtrule->getRuleMonth() || dayOfWeek != dtrule->getRuleDayOfWeek()) {
-        return FALSE;
+        return false;
     }
     if (dtrule->getTimeRuleType() != DateTimeRule::WALL_TIME) {
         // Do not try to do more intelligent comparison for now.
-        return FALSE;
+        return false;
     }
     if (dtrule->getDateRuleType() == DateTimeRule::DOW
             && dtrule->getRuleWeekInMonth() == weekInMonth) {
-        return TRUE;
+        return true;
     }
     int32_t ruleDOM = dtrule->getRuleDayOfMonth();
     if (dtrule->getDateRuleType() == DateTimeRule::DOW_GEQ_DOM) {
         if (ruleDOM%7 == 1 && (ruleDOM + 6)/7 == weekInMonth) {
-            return TRUE;
+            return true;
         }
         if (month != UCAL_FEBRUARY && (MONTHLENGTH[month] - ruleDOM)%7 == 6
                 && weekInMonth == -1*((MONTHLENGTH[month]-ruleDOM+1)/7)) {
-            return TRUE;
+            return true;
         }
     }
     if (dtrule->getDateRuleType() == DateTimeRule::DOW_LEQ_DOM) {
         if (ruleDOM%7 == 0 && ruleDOM/7 == weekInMonth) {
-            return TRUE;
+            return true;
         }
         if (month != UCAL_FEBRUARY && (MONTHLENGTH[month] - ruleDOM)%7 == 0
                 && weekInMonth == -1*((MONTHLENGTH[month] - ruleDOM)/7 + 1)) {
-            return TRUE;
+            return true;
         }
     }
-    return FALSE;
+    return false;
 }
 
 /*
@@ -1139,9 +1139,9 @@ UBool
 VTimeZone::getTZURL(UnicodeString& url) const {
     if (tzurl.length() > 0) {
         url = tzurl;
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 void
@@ -1153,9 +1153,9 @@ UBool
 VTimeZone::getLastModified(UDate& lastModified) const {
     if (lastmod != MAX_MILLIS) {
         lastModified = lastmod;
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 void
@@ -1269,12 +1269,12 @@ VTimeZone::load(VTZReader& reader, UErrorCode& status) {
     if (U_FAILURE(status)) {
         return;
     }
-    UBool eol = FALSE;
-    UBool start = FALSE;
-    UBool success = FALSE;
+    UBool eol = false;
+    UBool start = false;
+    UBool success = false;
     UnicodeString line;
 
-    while (TRUE) {
+    while (true) {
         UChar ch = reader.read();
         if (ch == 0xFFFF) {
             // end of file
@@ -1284,7 +1284,7 @@ VTimeZone::load(VTZReader& reader, UErrorCode& status) {
                 if (U_FAILURE(status)) {
                     return;
                 }
-                success = TRUE;
+                success = true;
             }
             break;
         }
@@ -1309,11 +1309,11 @@ VTimeZone::load(VTZReader& reader, UErrorCode& status) {
                     line.append(ch);
                 }
             }
-            eol = FALSE;
+            eol = false;
         } else {
             if (ch == 0x000A) {
                 // LF
-                eol = TRUE;
+                eol = true;
                 if (start) {
                     if (line.startsWith(ICAL_END_VTIMEZONE, -1)) {
                         LocalPointer<UnicodeString> element(new UnicodeString(line), status);
@@ -1321,7 +1321,7 @@ VTimeZone::load(VTZReader& reader, UErrorCode& status) {
                         if (U_FAILURE(status)) {
                             return;
                         }
-                        success = TRUE;
+                        success = true;
                         break;
                     }
                 } else {
@@ -1332,8 +1332,8 @@ VTimeZone::load(VTZReader& reader, UErrorCode& status) {
                             return;
                         }
                         line.remove();
-                        start = TRUE;
-                        eol = FALSE;
+                        start = true;
+                        eol = false;
                     }
                 }
             } else {
@@ -1374,12 +1374,12 @@ VTimeZone::parse(UErrorCode& status) {
 
     int32_t state = INI;
     int32_t n = 0;
-    UBool dst = FALSE;      // current zone type
+    UBool dst = false;      // current zone type
     UnicodeString from;     // current zone from offset
     UnicodeString to;       // current zone offset
     UnicodeString zonename;   // current zone name
     UnicodeString dtstart;  // current zone starts
-    UBool isRRULE = FALSE;  // true if the rule is described by RRULE
+    UBool isRRULE = false;  // true if the rule is described by RRULE
     int32_t initialRawOffset = 0;   // initial offset
     int32_t initialDSTSavings = 0;  // initial offset
     UDate firstStart = MAX_MILLIS;  // the earliest rule start time
@@ -1438,7 +1438,7 @@ VTimeZone::parse(UErrorCode& status) {
                     if (dates.size() != 0) {
                         dates.removeAllElements();
                     }
-                    isRRULE = FALSE;
+                    isRRULE = false;
                     from.remove();
                     to.remove();
                     zonename.remove();
@@ -1469,14 +1469,14 @@ VTimeZone::parse(UErrorCode& status) {
                 }
                 // RDATE value may contain multiple date delimited
                 // by comma
-                UBool nextDate = TRUE;
+                UBool nextDate = true;
                 int32_t dstart = 0;
                 LocalPointer<UnicodeString> dstr;
                 while (nextDate) {
                     int32_t dend = value.indexOf(COMMA, dstart);
                     if (dend == -1) {
                         dstr.adoptInsteadAndCheckErrorCode(new UnicodeString(value, dstart), status);
-                        nextDate = FALSE;
+                        nextDate = false;
                     } else {
                         dstr.adoptInsteadAndCheckErrorCode(new UnicodeString(value, dstart, dend - dstart), status);
                     }
@@ -1591,7 +1591,7 @@ VTimeZone::parse(UErrorCode& status) {
     }
 
     // Create a initial rule
-    getDefaultTZName(tzid, FALSE, zonename);
+    getDefaultTZName(tzid, false, zonename);
     LocalPointer<InitialTimeZoneRule> initialRule(
         new InitialTimeZoneRule(zonename, initialRawOffset, initialDSTSavings), status);
     if (U_FAILURE(status)) {
@@ -1652,7 +1652,7 @@ VTimeZone::parse(UErrorCode& status) {
                     finalRule->getNextStart(lastStart,
                         r->getRawOffset(),
                         r->getDSTSavings(),
-                        FALSE,
+                        false,
                         start);
                 }
             }
@@ -1898,19 +1898,19 @@ VTimeZone::writeZone(VTZWriter& w, BasicTimeZone& basictz,
     AnnualTimeZoneRule *finalStdRule = nullptr;
 
     int32_t year, month, dom, dow, doy, mid;
-    UBool hasTransitions = FALSE;
+    UBool hasTransitions = false;
     TimeZoneTransition tzt;
     UBool tztAvail;
     UnicodeString name;
     UBool isDst;
 
     // Going through all transitions
-    while (TRUE) {
-        tztAvail = basictz.getNextTransition(t, FALSE, tzt);
+    while (true) {
+        tztAvail = basictz.getNextTransition(t, false, tzt);
         if (!tztAvail) {
             break;
         }
-        hasTransitions = TRUE;
+        hasTransitions = true;
         t = tzt.getTime();
         tzt.getTo()->getName(name);
         isDst = (tzt.getTo()->getDSTSavings() != 0);
@@ -1919,7 +1919,7 @@ VTimeZone::writeZone(VTZWriter& w, BasicTimeZone& basictz,
         int32_t toOffset = tzt.getTo()->getRawOffset() + tzt.getTo()->getDSTSavings();
         Grego::timeToFields(tzt.getTime() + fromOffset, year, month, dom, dow, doy, mid);
         int32_t weekInMonth = Grego::dayOfWeekInMonth(year, month, dom);
-        UBool sameRule = FALSE;
+        UBool sameRule = false;
         const AnnualTimeZoneRule *atzrule;
         if (isDst) {
             if (finalDstRule == nullptr
@@ -1940,14 +1940,14 @@ VTimeZone::writeZone(VTZWriter& w, BasicTimeZone& basictz,
                     // Update until time
                     dstUntilTime = t;
                     dstCount++;
-                    sameRule = TRUE;
+                    sameRule = true;
                 }
                 if (!sameRule) {
                     if (dstCount == 1) {
-                        writeZonePropsByTime(w, TRUE, dstName, dstFromOffset, dstToOffset, dstStartTime,
-                                TRUE, status);
+                        writeZonePropsByTime(w, true, dstName, dstFromOffset, dstToOffset, dstStartTime,
+                                true, status);
                     } else {
-                        writeZonePropsByDOW(w, TRUE, dstName, dstFromOffset, dstToOffset,
+                        writeZonePropsByDOW(w, true, dstName, dstFromOffset, dstToOffset,
                                 dstMonth, dstWeekInMonth, dstDayOfWeek, dstStartTime, dstUntilTime, status);
                     }
                     if (U_FAILURE(status)) {
@@ -1991,14 +1991,14 @@ VTimeZone::writeZone(VTZWriter& w, BasicTimeZone& basictz,
                     // Update until time
                     stdUntilTime = t;
                     stdCount++;
-                    sameRule = TRUE;
+                    sameRule = true;
                 }
                 if (!sameRule) {
                     if (stdCount == 1) {
-                        writeZonePropsByTime(w, FALSE, stdName, stdFromOffset, stdToOffset, stdStartTime,
-                                TRUE, status);
+                        writeZonePropsByTime(w, false, stdName, stdFromOffset, stdToOffset, stdStartTime,
+                                true, status);
                     } else {
-                        writeZonePropsByDOW(w, FALSE, stdName, stdFromOffset, stdToOffset,
+                        writeZonePropsByDOW(w, false, stdName, stdFromOffset, stdToOffset,
                                 stdMonth, stdWeekInMonth, stdDayOfWeek, stdStartTime, stdUntilTime, status);
                     }
                     if (U_FAILURE(status)) {
@@ -2028,7 +2028,7 @@ VTimeZone::writeZone(VTZWriter& w, BasicTimeZone& basictz,
     if (!hasTransitions) {
         // No transition - put a single non transition RDATE
         int32_t raw, dst, offset;
-        basictz.getOffset(0.0/*any time*/, FALSE, raw, dst, status);
+        basictz.getOffset(0.0/*any time*/, false, raw, dst, status);
         if (U_FAILURE(status)) {
             goto cleanupWriteZone;
         }
@@ -2038,7 +2038,7 @@ VTimeZone::writeZone(VTZWriter& w, BasicTimeZone& basictz,
         basictz.getID(tzid);
         getDefaultTZName(tzid, isDst, name);        
         writeZonePropsByTime(w, isDst, name,
-                offset, offset, DEF_TZSTARTTIME - offset, FALSE, status);    
+                offset, offset, DEF_TZSTARTTIME - offset, false, status);    
         if (U_FAILURE(status)) {
             goto cleanupWriteZone;
         }
@@ -2046,10 +2046,10 @@ VTimeZone::writeZone(VTZWriter& w, BasicTimeZone& basictz,
         if (dstCount > 0) {
             if (finalDstRule == nullptr) {
                 if (dstCount == 1) {
-                    writeZonePropsByTime(w, TRUE, dstName, dstFromOffset, dstToOffset, dstStartTime,
-                            TRUE, status);
+                    writeZonePropsByTime(w, true, dstName, dstFromOffset, dstToOffset, dstStartTime,
+                            true, status);
                 } else {
-                    writeZonePropsByDOW(w, TRUE, dstName, dstFromOffset, dstToOffset,
+                    writeZonePropsByDOW(w, true, dstName, dstFromOffset, dstToOffset,
                             dstMonth, dstWeekInMonth, dstDayOfWeek, dstStartTime, dstUntilTime, status);
                 }
                 if (U_FAILURE(status)) {
@@ -2057,16 +2057,16 @@ VTimeZone::writeZone(VTZWriter& w, BasicTimeZone& basictz,
                 }
             } else {
                 if (dstCount == 1) {
-                    writeFinalRule(w, TRUE, finalDstRule,
+                    writeFinalRule(w, true, finalDstRule,
                             dstFromOffset - dstFromDSTSavings, dstFromDSTSavings, dstStartTime, status);
                 } else {
                     // Use a single rule if possible
                     if (isEquivalentDateRule(dstMonth, dstWeekInMonth, dstDayOfWeek, finalDstRule->getRule())) {
-                        writeZonePropsByDOW(w, TRUE, dstName, dstFromOffset, dstToOffset,
+                        writeZonePropsByDOW(w, true, dstName, dstFromOffset, dstToOffset,
                                 dstMonth, dstWeekInMonth, dstDayOfWeek, dstStartTime, MAX_MILLIS, status);
                     } else {
                         // Not equivalent rule - write out two different rules
-                        writeZonePropsByDOW(w, TRUE, dstName, dstFromOffset, dstToOffset,
+                        writeZonePropsByDOW(w, true, dstName, dstFromOffset, dstToOffset,
                                 dstMonth, dstWeekInMonth, dstDayOfWeek, dstStartTime, dstUntilTime, status);
                         if (U_FAILURE(status)) {
                             goto cleanupWriteZone;
@@ -2075,7 +2075,7 @@ VTimeZone::writeZone(VTZWriter& w, BasicTimeZone& basictz,
                         UBool nextStartAvail = finalDstRule->getNextStart(dstUntilTime, dstFromOffset - dstFromDSTSavings, dstFromDSTSavings, false, nextStart);
                         U_ASSERT(nextStartAvail);
                         if (nextStartAvail) {
-                            writeFinalRule(w, TRUE, finalDstRule,
+                            writeFinalRule(w, true, finalDstRule,
                                     dstFromOffset - dstFromDSTSavings, dstFromDSTSavings, nextStart, status);
                         }
                     }
@@ -2088,10 +2088,10 @@ VTimeZone::writeZone(VTZWriter& w, BasicTimeZone& basictz,
         if (stdCount > 0) {
             if (finalStdRule == nullptr) {
                 if (stdCount == 1) {
-                    writeZonePropsByTime(w, FALSE, stdName, stdFromOffset, stdToOffset, stdStartTime,
-                            TRUE, status);
+                    writeZonePropsByTime(w, false, stdName, stdFromOffset, stdToOffset, stdStartTime,
+                            true, status);
                 } else {
-                    writeZonePropsByDOW(w, FALSE, stdName, stdFromOffset, stdToOffset,
+                    writeZonePropsByDOW(w, false, stdName, stdFromOffset, stdToOffset,
                             stdMonth, stdWeekInMonth, stdDayOfWeek, stdStartTime, stdUntilTime, status);
                 }
                 if (U_FAILURE(status)) {
@@ -2099,16 +2099,16 @@ VTimeZone::writeZone(VTZWriter& w, BasicTimeZone& basictz,
                 }
             } else {
                 if (stdCount == 1) {
-                    writeFinalRule(w, FALSE, finalStdRule,
+                    writeFinalRule(w, false, finalStdRule,
                             stdFromOffset - stdFromDSTSavings, stdFromDSTSavings, stdStartTime, status);
                 } else {
                     // Use a single rule if possible
                     if (isEquivalentDateRule(stdMonth, stdWeekInMonth, stdDayOfWeek, finalStdRule->getRule())) {
-                        writeZonePropsByDOW(w, FALSE, stdName, stdFromOffset, stdToOffset,
+                        writeZonePropsByDOW(w, false, stdName, stdFromOffset, stdToOffset,
                                 stdMonth, stdWeekInMonth, stdDayOfWeek, stdStartTime, MAX_MILLIS, status);
                     } else {
                         // Not equivalent rule - write out two different rules
-                        writeZonePropsByDOW(w, FALSE, stdName, stdFromOffset, stdToOffset,
+                        writeZonePropsByDOW(w, false, stdName, stdFromOffset, stdToOffset,
                                 stdMonth, stdWeekInMonth, stdDayOfWeek, stdStartTime, stdUntilTime, status);
                         if (U_FAILURE(status)) {
                             goto cleanupWriteZone;
@@ -2117,7 +2117,7 @@ VTimeZone::writeZone(VTZWriter& w, BasicTimeZone& basictz,
                         UBool nextStartAvail = finalStdRule->getNextStart(stdUntilTime, stdFromOffset - stdFromDSTSavings, stdFromDSTSavings, false, nextStart);
                         U_ASSERT(nextStartAvail);
                         if (nextStartAvail) {
-                            writeFinalRule(w, FALSE, finalStdRule,
+                            writeFinalRule(w, false, finalStdRule,
                                     stdFromOffset - stdFromDSTSavings, stdFromDSTSavings, nextStart, status);
                         }
                     }
@@ -2447,13 +2447,13 @@ VTimeZone::writeFinalRule(VTZWriter& writer, UBool isDst, const AnnualTimeZoneRu
     if (U_FAILURE(status)) {
         return;
     }
-    UBool modifiedRule = TRUE;
+    UBool modifiedRule = true;
     const DateTimeRule *dtrule = toWallTimeRule(rule->getRule(), fromRawOffset, fromDSTSavings, status);
     if (U_FAILURE(status)) {
         return;
     }
     if (dtrule == nullptr) {
-        modifiedRule = FALSE;
+        modifiedRule = false;
         dtrule = rule->getRule();
     }
 
diff --git a/deps/icu-small/source/i18n/vzone.h b/deps/icu-small/source/i18n/vzone.h
index d1b6d8d820..bf9b45ea20 100644
--- a/deps/icu-small/source/i18n/vzone.h
+++ b/deps/icu-small/source/i18n/vzone.h
@@ -24,14 +24,12 @@
 #include "unicode/uobject.h"
 #include "ztrans.h"
 
-#ifndef UCNV_H
 struct VZone;
 /**
  * A UnicodeSet.  Use the vzone_* API to manipulate.  Create with
  * vzone_open*, and destroy with vzone_close.
  */
 typedef struct VZone VZone;
-#endif
 
 /*********************************************************************
  * VZone API
diff --git a/deps/icu-small/source/i18n/windtfmt.cpp b/deps/icu-small/source/i18n/windtfmt.cpp
index f6a990ea29..4676fd0aa1 100644
--- a/deps/icu-small/source/i18n/windtfmt.cpp
+++ b/deps/icu-small/source/i18n/windtfmt.cpp
@@ -84,7 +84,7 @@ UnicodeString* Win32DateFormat::getTimeDateFormat(const Calendar *cal, const Loc
     }
     const UChar *resStr = ures_getStringByIndex(patBundle, glueIndex, &resStrLen, &status);
 
-    result = new UnicodeString(TRUE, resStr, resStrLen);
+    result = new UnicodeString(true, resStr, resStrLen);
 
     ures_close(patBundle);
     ures_close(typBundle);
@@ -102,7 +102,7 @@ static UErrorCode GetEquivalentWindowsLocaleName(const Locale& locale, UnicodeSt
     char asciiBCP47Tag[LOCALE_NAME_MAX_LENGTH] = {};
 
     // Convert from names like "en_CA" and "de_DE@collation=phonebook" to "en-CA" and "de-DE-u-co-phonebk".
-    (void)uloc_toLanguageTag(locale.getName(), asciiBCP47Tag, UPRV_LENGTHOF(asciiBCP47Tag), FALSE, &status);
+    (void)uloc_toLanguageTag(locale.getName(), asciiBCP47Tag, UPRV_LENGTHOF(asciiBCP47Tag), false, &status);
 
     if (U_SUCCESS(status))
     {
@@ -380,7 +380,7 @@ UnicodeString Win32DateFormat::setTimeZoneInfo(TIME_ZONE_INFORMATION *tzi, const
 
         zone.getID(icuid);
         if (! uprv_getWindowsTimeZoneInfo(tzi, icuid.getBuffer(), icuid.length())) {
-            UBool found = FALSE;
+            UBool found = false;
             int32_t ec = TimeZone::countEquivalentIDs(icuid);
 
             for (int z = 0; z < ec; z += 1) {
diff --git a/deps/icu-small/source/i18n/winnmfmt.cpp b/deps/icu-small/source/i18n/winnmfmt.cpp
index 8b2a9a4f95..377d1af9bd 100644
--- a/deps/icu-small/source/i18n/winnmfmt.cpp
+++ b/deps/icu-small/source/i18n/winnmfmt.cpp
@@ -147,7 +147,7 @@ static UErrorCode GetEquivalentWindowsLocaleName(const Locale& locale, UnicodeSt
     char asciiBCP47Tag[LOCALE_NAME_MAX_LENGTH] = {};
 
     // Convert from names like "en_CA" and "de_DE@collation=phonebook" to "en-CA" and "de-DE-u-co-phonebk".
-    (void) uloc_toLanguageTag(locale.getName(), asciiBCP47Tag, UPRV_LENGTHOF(asciiBCP47Tag), FALSE, &status);
+    (void) uloc_toLanguageTag(locale.getName(), asciiBCP47Tag, UPRV_LENGTHOF(asciiBCP47Tag), false, &status);
 
     if (U_SUCCESS(status))
     {
@@ -204,7 +204,7 @@ static UErrorCode GetEquivalentWindowsLocaleName(const Locale& locale, UnicodeSt
 }
 
 Win32NumberFormat::Win32NumberFormat(const Locale &locale, UBool currency, UErrorCode &status)
-  : NumberFormat(), fCurrency(currency), fFormatInfo(NULL), fFractionDigitsSet(FALSE), fWindowsLocaleName(nullptr)
+  : NumberFormat(), fCurrency(currency), fFormatInfo(NULL), fFractionDigitsSet(false), fWindowsLocaleName(nullptr)
 {
     if (!U_FAILURE(status)) {
         fLCID = locale.getLCID();
@@ -325,13 +325,13 @@ void Win32NumberFormat::parse(const UnicodeString& text, Formattable& result, Pa
 }
 void Win32NumberFormat::setMaximumFractionDigits(int32_t newValue)
 {
-    fFractionDigitsSet = TRUE;
+    fFractionDigitsSet = true;
     NumberFormat::setMaximumFractionDigits(newValue);
 }
 
 void Win32NumberFormat::setMinimumFractionDigits(int32_t newValue)
 {
-    fFractionDigitsSet = TRUE;
+    fFractionDigitsSet = true;
     NumberFormat::setMinimumFractionDigits(newValue);
 }
 
diff --git a/deps/icu-small/source/i18n/wintzimpl.cpp b/deps/icu-small/source/i18n/wintzimpl.cpp
index a6d9330063..5f70d091be 100644
--- a/deps/icu-small/source/i18n/wintzimpl.cpp
+++ b/deps/icu-small/source/i18n/wintzimpl.cpp
@@ -39,7 +39,7 @@ U_NAMESPACE_USE
 
 static UBool getSystemTimeInformation(TimeZone *tz, SYSTEMTIME &daylightDate, SYSTEMTIME &standardDate, int32_t &bias, int32_t &daylightBias, int32_t &standardBias) {
     UErrorCode status = U_ZERO_ERROR;
-    UBool result = TRUE;
+    UBool result = true;
     BasicTimeZone *btz = (BasicTimeZone*)tz; // we should check type
     InitialTimeZoneRule *initial = NULL;
     AnnualTimeZoneRule *std = NULL, *dst = NULL;
@@ -107,7 +107,7 @@ static UBool getSystemTimeInformation(TimeZone *tz, SYSTEMTIME &daylightDate, SY
             daylightDate.wMilliseconds = static_cast<WORD>(mil);
         }
     } else {
-        result = FALSE;
+        result = false;
     }
 
     delete initial;
@@ -118,7 +118,7 @@ static UBool getSystemTimeInformation(TimeZone *tz, SYSTEMTIME &daylightDate, SY
 }
 
 static UBool getWindowsTimeZoneInfo(TIME_ZONE_INFORMATION *zoneInfo, const UChar *icuid, int32_t length) {
-    UBool result = FALSE;
+    UBool result = false;
     UnicodeString id = UnicodeString(icuid, length);
     TimeZone *tz = TimeZone::createTimeZone(id);
     
@@ -137,7 +137,7 @@ static UBool getWindowsTimeZoneInfo(TIME_ZONE_INFORMATION *zoneInfo, const UChar
             zoneInfo->DaylightDate  = daylightDate;
             zoneInfo->StandardDate  = standardDate;
 
-            result = TRUE;
+            result = true;
         }
     }
 
@@ -152,9 +152,9 @@ U_CAPI UBool U_EXPORT2
 uprv_getWindowsTimeZoneInfo(TIME_ZONE_INFORMATION *zoneInfo, const UChar *icuid, int32_t length)
 {
     if (getWindowsTimeZoneInfo(zoneInfo, icuid, length)) {
-        return TRUE;
+        return true;
     } else {
-        return FALSE;
+        return false;
     }
 }
 
diff --git a/deps/icu-small/source/i18n/zonemeta.cpp b/deps/icu-small/source/i18n/zonemeta.cpp
index e60215c998..7cf3a5e131 100644
--- a/deps/icu-small/source/i18n/zonemeta.cpp
+++ b/deps/icu-small/source/i18n/zonemeta.cpp
@@ -34,21 +34,21 @@ static icu::UMutex gZoneMetaLock;
 
 // CLDR Canonical ID mapping table
 static UHashtable *gCanonicalIDCache = NULL;
-static icu::UInitOnce gCanonicalIDCacheInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gCanonicalIDCacheInitOnce {};
 
 // Metazone mapping table
 static UHashtable *gOlsonToMeta = NULL;
-static icu::UInitOnce gOlsonToMetaInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gOlsonToMetaInitOnce {};
 
 // Available metazone IDs vector and table
 static icu::UVector *gMetaZoneIDs = NULL;
 static UHashtable *gMetaZoneIDTable = NULL;
-static icu::UInitOnce gMetaZoneIDsInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gMetaZoneIDsInitOnce {};
 
 // Country info vectors
 static icu::UVector *gSingleZoneCountries = NULL;
 static icu::UVector *gMultiZonesCountries = NULL;
-static icu::UInitOnce gCountryInfoVectorsInitOnce = U_INITONCE_INITIALIZER;
+static icu::UInitOnce gCountryInfoVectorsInitOnce {};
 
 U_CDECL_BEGIN
 
@@ -85,7 +85,7 @@ static UBool U_CALLCONV zoneMeta_cleanup(void)
     gMultiZonesCountries = NULL;
     gCountryInfoVectorsInitOnce.reset();
 
-    return TRUE;
+    return true;
 }
 
 /**
@@ -266,7 +266,7 @@ ZoneMeta::getCanonicalCLDRID(const UnicodeString &tzid, UErrorCode& status) {
     }
 
     // If not, resolve CLDR canonical ID with resource data
-    UBool isInputCanonical = FALSE;
+    UBool isInputCanonical = false;
     char id[ZID_KEY_MAX + 1];
     tzid.extract(0, 0x7fffffff, id, UPRV_LENGTHOF(id), US_INV);
 
@@ -286,7 +286,7 @@ ZoneMeta::getCanonicalCLDRID(const UnicodeString &tzid, UErrorCode& status) {
         // type entry (canonical) found
         // the input is the canonical ID. resolve to const UChar*
         canonicalID = TimeZone::findID(tzid);
-        isInputCanonical = TRUE;
+        isInputCanonical = true;
     }
 
     if (canonicalID == NULL) {
@@ -328,7 +328,7 @@ ZoneMeta::getCanonicalCLDRID(const UnicodeString &tzid, UErrorCode& status) {
                     canonicalID = canonical;
                 } else {
                     canonicalID = derefer;
-                    isInputCanonical = TRUE;
+                    isInputCanonical = true;
                 }
             }
         }
@@ -373,7 +373,7 @@ ZoneMeta::getCanonicalCLDRID(const UnicodeString &tzid, UnicodeString &systemID,
         systemID.setToBogus();
         return systemID;
     }
-    systemID.setTo(TRUE, canonicalID, -1);
+    systemID.setTo(true, canonicalID, -1);
     return systemID;
 }
 
@@ -414,7 +414,7 @@ static void U_CALLCONV countryInfoVectorsInit(UErrorCode &status) {
 UnicodeString& U_EXPORT2
 ZoneMeta::getCanonicalCountry(const UnicodeString &tzid, UnicodeString &country, UBool *isPrimary /* = NULL */) {
     if (isPrimary != NULL) {
-        *isPrimary = FALSE;
+        *isPrimary = false;
     }
 
     const UChar *region = TimeZone::getRegion(tzid);
@@ -436,8 +436,8 @@ ZoneMeta::getCanonicalCountry(const UnicodeString &tzid, UnicodeString &country,
         }
 
         // Check if it was already cached
-        UBool cached = FALSE;
-        UBool singleZone = FALSE;
+        UBool cached = false;
+        UBool singleZone = false;
         umtx_lock(&gZoneMetaLock);
         {
             singleZone = cached = gSingleZoneCountries->contains((void*)region);
@@ -459,7 +459,7 @@ ZoneMeta::getCanonicalCountry(const UnicodeString &tzid, UnicodeString &country,
             int32_t idsLen = ids->count(status);
             if (U_SUCCESS(status) && idsLen == 1) {
                 // only the single zone is available for the region
-                singleZone = TRUE;
+                singleZone = true;
             }
             delete ids;
 
@@ -481,7 +481,7 @@ ZoneMeta::getCanonicalCountry(const UnicodeString &tzid, UnicodeString &country,
         }
 
         if (singleZone) {
-            *isPrimary = TRUE;
+            *isPrimary = true;
         } else {
             // Note: We may cache the primary zone map in future.
 
@@ -497,13 +497,13 @@ ZoneMeta::getCanonicalCountry(const UnicodeString &tzid, UnicodeString &country,
             const UChar *primaryZone = ures_getStringByKey(rb, regionBuf, &idLen, &status);
             if (U_SUCCESS(status)) {
                 if (tzid.compare(primaryZone, idLen) == 0) {
-                    *isPrimary = TRUE;
+                    *isPrimary = true;
                 } else {
                     // The given ID might not be a canonical ID
                     UnicodeString canonicalID;
                     TimeZone::getCanonicalID(tzid, canonicalID, status);
                     if (U_SUCCESS(status) && canonicalID.compare(primaryZone, idLen) == 0) {
-                        *isPrimary = TRUE;
+                        *isPrimary = true;
                     }
                 }
             }
@@ -516,14 +516,14 @@ ZoneMeta::getCanonicalCountry(const UnicodeString &tzid, UnicodeString &country,
 
 UnicodeString& U_EXPORT2
 ZoneMeta::getMetazoneID(const UnicodeString &tzid, UDate date, UnicodeString &result) {
-    UBool isSet = FALSE;
+    UBool isSet = false;
     const UVector *mappings = getMetazoneMappings(tzid);
     if (mappings != NULL) {
         for (int32_t i = 0; i < mappings->size(); i++) {
             OlsonToMetaMappingEntry *mzm = (OlsonToMetaMappingEntry*)mappings->elementAt(i);
             if (mzm->from <= date && mzm->to > date) {
                 result.setTo(mzm->mzid, -1);
-                isSet = TRUE;
+                isSet = true;
                 break;
             }
         }
@@ -828,10 +828,10 @@ ZoneMeta::findTimeZoneID(const UnicodeString& tzid) {
 
 TimeZone*
 ZoneMeta::createCustomTimeZone(int32_t offset) {
-    UBool negative = FALSE;
+    UBool negative = false;
     int32_t tmp = offset;
     if (offset < 0) {
-        negative = TRUE;
+        negative = true;
         tmp = -offset;
     }
     uint8_t hour, min, sec;
diff --git a/deps/icu-small/source/i18n/zonemeta.h b/deps/icu-small/source/i18n/zonemeta.h
index dd4fec957f..97c0e6057d 100644
--- a/deps/icu-small/source/i18n/zonemeta.h
+++ b/deps/icu-small/source/i18n/zonemeta.h
@@ -113,7 +113,7 @@ public:
     static const UChar* U_EXPORT2 getShortID(const UnicodeString& id);
 
 private:
-    ZoneMeta(); // Prevent construction.
+    ZoneMeta() = delete; // Prevent construction.
     static UVector* createMetazoneMappings(const UnicodeString &tzid);
     static UnicodeString& formatCustomID(uint8_t hour, uint8_t min, uint8_t sec, UBool negative, UnicodeString& id);
     static const UChar* getShortIDFromCanonical(const UChar* canonicalID);
diff --git a/deps/icu-small/source/i18n/zrule.h b/deps/icu-small/source/i18n/zrule.h
index f395ad4c3f..2bea64c6d4 100644
--- a/deps/icu-small/source/i18n/zrule.h
+++ b/deps/icu-small/source/i18n/zrule.h
@@ -20,8 +20,6 @@
 
 #include "unicode/uobject.h"
 
-#ifndef UCNV_H
-
 /**
  * A TimeZoneRule.  Use the zrule_* API to manipulate.  Create with
  * zrule_open*, and destroy with zrule_close.
@@ -43,8 +41,6 @@ typedef struct IZRule IZRule;
 struct AZRule;
 typedef struct AZRule AZRule;
 
-#endif
-
 /*********************************************************************
  * ZRule API
  *********************************************************************/
diff --git a/deps/icu-small/source/i18n/ztrans.h b/deps/icu-small/source/i18n/ztrans.h
index b23bb4fc70..a1f3910055 100644
--- a/deps/icu-small/source/i18n/ztrans.h
+++ b/deps/icu-small/source/i18n/ztrans.h
@@ -20,8 +20,6 @@
 
 #include "unicode/uobject.h"
 
-#ifndef UCNV_H
-
 /**
  * A TimeZoneTransition.  Use the ztrans_* API to manipulate.  Create with
  * ztrans_open*, and destroy with ztrans_close.
@@ -29,8 +27,6 @@
 struct ZTrans;
 typedef struct ZTrans ZTrans;
 
-#endif
-
 /**
  * Constructs a time zone transition with the time and the rules before/after
  * the transition.
diff --git a/deps/icu-small/source/stubdata/BUILD.bazel b/deps/icu-small/source/stubdata/BUILD.bazel
index abb73519ec..20344ef499 100644
--- a/deps/icu-small/source/stubdata/BUILD.bazel
+++ b/deps/icu-small/source/stubdata/BUILD.bazel
@@ -16,6 +16,7 @@ package(
 cc_library(
     name = "stubdata",
     srcs = ["stubdata.cpp"],
+    hdrs = ["stubdata.h"],
     deps = ["//icu4c/source/common:headers"],
     local_defines = [
         "U_COMMON_IMPLEMENTATION",
diff --git a/deps/icu-small/source/stubdata/stubdata.cpp b/deps/icu-small/source/stubdata/stubdata.cpp
index 0fcab4faa8..3f33661242 100644
--- a/deps/icu-small/source/stubdata/stubdata.cpp
+++ b/deps/icu-small/source/stubdata/stubdata.cpp
@@ -19,26 +19,8 @@
 *   for running the data building tools.
 *
 */
-#include "unicode/utypes.h"
-#include "unicode/udata.h"
-#include "unicode/uversion.h"
 
-
-typedef struct {
-    uint16_t headerSize;
-    uint8_t magic1, magic2;
-    UDataInfo info;
-    char padding[8];
-    uint32_t count, reserved;
-    /*
-    const struct {
-    const char *const name; 
-    const void *const data;
-    } toc[1];
-    */
-   int   fakeNameAndData[4];       /* TODO:  Change this header type from */
-                                   /*        pointerTOC to OffsetTOC.     */
-} ICU_Data_Header;
+#include "stubdata.h"
 
 extern "C" U_EXPORT const ICU_Data_Header U_ICUDATA_ENTRY_POINT = {
     32,          /* headerSize */
diff --git a/deps/icu-small/source/stubdata/stubdata.h b/deps/icu-small/source/stubdata/stubdata.h
new file mode 100644
index 0000000000..9879f40164
--- /dev/null
+++ b/deps/icu-small/source/stubdata/stubdata.h
@@ -0,0 +1,52 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html
+/******************************************************************************
+*
+*   Copyright (C) 2001, International Business Machines
+*   Corporation and others.  All Rights Reserved.
+*
+*******************************************************************************
+*   file name:  stubdata.h
+*
+*   This header file is intended to be internal and only included in the 
+*   accompanying implementation file. This file declares a single entry
+*   point for visibility of tools like TAPI.
+*
+*   Define initialized data that will build into a valid, but empty
+*   ICU data library.  Used to bootstrap the ICU build, which has these
+*   dependencies:
+*       ICU Common library depends on ICU data
+*       ICU data requires data building tools.
+*       ICU data building tools require the ICU common library.
+*
+*   The stub data library (for which this file is the source) is sufficient
+*   for running the data building tools.
+*
+*/
+
+#ifndef __STUBDATA_H__
+#define __STUBDATA_H__
+
+#include "unicode/utypes.h"
+#include "unicode/udata.h"
+#include "unicode/uversion.h"
+
+typedef struct {
+    uint16_t headerSize;
+    uint8_t magic1, magic2;
+    UDataInfo info;
+    char padding[8];
+    uint32_t count, reserved;
+    /*
+    const struct {
+    const char *const name;
+    const void *const data;
+    } toc[1];
+    */
+   int   fakeNameAndData[4];       /* TODO:  Change this header type from */
+                                   /*        pointerTOC to OffsetTOC.     */
+} ICU_Data_Header;
+
+extern "C" U_EXPORT const ICU_Data_Header U_ICUDATA_ENTRY_POINT;
+
+#endif /* __STUBDATA_H__ */
diff --git a/deps/icu-small/source/tools/genccode/genccode.c b/deps/icu-small/source/tools/genccode/genccode.c
index c5bbdf60d7..219335f183 100644
--- a/deps/icu-small/source/tools/genccode/genccode.c
+++ b/deps/icu-small/source/tools/genccode/genccode.c
@@ -48,6 +48,7 @@
 #   define ICU_ENTRY_OFFSET 0
 #endif
 
+#include <stdbool.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include "unicode/putil.h"
@@ -96,7 +97,7 @@ static UOption options[]={
 #define CALL_WRITEOBJECT    'o'
 extern int
 main(int argc, char* argv[]) {
-    UBool verbose = TRUE;
+    UBool verbose = true;
     char writeCode;
 
     U_MAIN_INIT_ARGS(argc, argv);
@@ -166,7 +167,7 @@ main(int argc, char* argv[]) {
             /* TODO: remove writeCode=&writeCCode; */
         }
         if (options[kOptQuiet].doesOccur) {
-            verbose = FALSE;
+            verbose = false;
         }
         while(--argc) {
             filename=getLongPathname(argv[argc]);
diff --git a/deps/icu-small/source/tools/genrb/derb.cpp b/deps/icu-small/source/tools/genrb/derb.cpp
index 70546e1915..aba5c59529 100644
--- a/deps/icu-small/source/tools/genrb/derb.cpp
+++ b/deps/icu-small/source/tools/genrb/derb.cpp
@@ -40,7 +40,7 @@
 
 static const int32_t indentsize = 4;
 static int32_t truncsize = DERB_DEFAULT_TRUNC;
-static UBool opt_truncate = FALSE;
+static UBool opt_truncate = false;
 
 static const char *getEncodingName(const char *encoding);
 static void reportError(const char *pname, UErrorCode *status, const char *when);
@@ -66,8 +66,8 @@ static UOption options[]={
 /* 11 */   { "suppressAliases", NULL, NULL, NULL, 'A', UOPT_NO_ARG, 0 },
 };
 
-static UBool verbose = FALSE;
-static UBool suppressAliases = FALSE;
+static UBool verbose = false;
+static UBool suppressAliases = false;
 static UFILE *ustderr = NULL;
 
 extern int
@@ -140,18 +140,18 @@ main(int argc, char* argv[]) {
     }
 
     if(options[4].doesOccur) {
-        opt_truncate = TRUE;
+        opt_truncate = true;
         if(options[4].value != NULL) {
             truncsize = atoi(options[4].value); /* user defined printable size */
         } else {
             truncsize = DERB_DEFAULT_TRUNC; /* we'll use default omitting size */
         }
     } else {
-        opt_truncate = FALSE;
+        opt_truncate = false;
     }
 
     if(options[5].doesOccur) {
-        verbose = TRUE;
+        verbose = true;
     }
 
     if (options[6].doesOccur) {
@@ -171,7 +171,7 @@ main(int argc, char* argv[]) {
     }
 
     if (options[11].doesOccur) {
-      suppressAliases = TRUE;
+      suppressAliases = true;
     }
 
     fflush(stderr); // use ustderr now.
@@ -577,7 +577,7 @@ static void printOutBundle(UFILE *out, UResourceBundle *resource, int32_t indent
             }
             printString(out, cr, UPRV_LENGTHOF(cr));
 
-            if(suppressAliases == FALSE) {
+            if(suppressAliases == false) {
               while(U_SUCCESS(*status) && ures_hasNext(resource)) {
                   t = ures_getNextResource(resource, t, status);
                   if(U_SUCCESS(*status)) {
diff --git a/deps/icu-small/source/tools/genrb/errmsg.c b/deps/icu-small/source/tools/genrb/errmsg.c
index 91dfd3265e..a99d797ec5 100644
--- a/deps/icu-small/source/tools/genrb/errmsg.c
+++ b/deps/icu-small/source/tools/genrb/errmsg.c
@@ -18,6 +18,7 @@
 */
 
 #include <stdarg.h>
+#include <stdbool.h>
 #include <stdio.h>
 #include "cstring.h"
 #include "errmsg.h"
@@ -34,7 +35,7 @@ U_CFUNC void error(uint32_t linenumber, const char *msg, ...)
     va_end(va);
 }
 
-static UBool gShowWarning = TRUE;
+static UBool gShowWarning = true;
 
 U_CFUNC void setShowWarning(UBool val)
 {
@@ -45,14 +46,14 @@ U_CFUNC UBool getShowWarning(){
     return gShowWarning;
 }
 
-static UBool gStrict =FALSE;
+static UBool gStrict =false;
 U_CFUNC UBool isStrict(){
     return gStrict;
 }
 U_CFUNC void setStrict(UBool val){
     gStrict = val;
 }
-static UBool gVerbose =FALSE;
+static UBool gVerbose =false;
 U_CFUNC UBool isVerbose(){
     return gVerbose;
 }
diff --git a/deps/icu-small/source/tools/genrb/genrb.cpp b/deps/icu-small/source/tools/genrb/genrb.cpp
index a739b91143..9deca097e9 100644
--- a/deps/icu-small/source/tools/genrb/genrb.cpp
+++ b/deps/icu-small/source/tools/genrb/genrb.cpp
@@ -33,6 +33,7 @@
 #include "filterrb.h"
 #include "reslist.h"
 #include "ucmndata.h"  /* TODO: for reading the pool bundle */
+#include "collationroot.h"
 
 U_NAMESPACE_USE
 
@@ -84,7 +85,9 @@ enum
     WRITE_POOL_BUNDLE,
     USE_POOL_BUNDLE,
     INCLUDE_UNIHAN_COLL,
-    FILTERDIR
+    FILTERDIR,
+    ICU4X_MODE,
+    UCADATA
 };
 
 UOption options[]={
@@ -111,10 +114,12 @@ UOption options[]={
                       UOPTION_DEF("usePoolBundle", '\x01', UOPT_OPTIONAL_ARG),/* 20 */
                       UOPTION_DEF("includeUnihanColl", '\x01', UOPT_NO_ARG),/* 21 */ /* temporary, don't display in usage info */
                       UOPTION_DEF("filterDir", '\x01', UOPT_OPTIONAL_ARG), /* 22 */
+                      UOPTION_DEF("icu4xMode", 'X', UOPT_NO_ARG),/* 23 */
+                      UOPTION_DEF("ucadata", '\x01', UOPT_REQUIRES_ARG),/* 24 */
                   };
 
-static     UBool       write_java = FALSE;
-static     UBool       write_xliff = FALSE;
+static     UBool       write_java = false;
+static     UBool       write_xliff = false;
 static     const char* outputEnc ="";
 
 static ResFile poolBundle;
@@ -133,7 +138,7 @@ main(int argc,
     const char *filterDir = NULL;
     const char *encoding  = "";
     int         i;
-    UBool illegalArg = FALSE;
+    UBool illegalArg = false;
 
     U_MAIN_INIT_ARGS(argc, argv);
 
@@ -144,24 +149,28 @@ main(int argc,
     /* error handling, printing usage message */
     if(argc<0) {
         fprintf(stderr, "%s: error in command line argument \"%s\"\n", argv[0], argv[-argc]);
-        illegalArg = TRUE;
+        illegalArg = true;
     } else if(argc<2) {
-        illegalArg = TRUE;
+        illegalArg = true;
     }
     if(options[WRITE_POOL_BUNDLE].doesOccur && options[USE_POOL_BUNDLE].doesOccur) {
         fprintf(stderr, "%s: cannot combine --writePoolBundle and --usePoolBundle\n", argv[0]);
-        illegalArg = TRUE;
+        illegalArg = true;
+    }
+    if (options[ICU4X_MODE].doesOccur && !options[UCADATA].doesOccur) {
+        fprintf(stderr, "%s: --icu4xMode requires --ucadata\n", argv[0]);
+        illegalArg = true;
     }
     if(options[FORMAT_VERSION].doesOccur) {
         const char *s = options[FORMAT_VERSION].value;
         if(uprv_strlen(s) != 1 || (s[0] < '1' && '3' < s[0])) {
             fprintf(stderr, "%s: unsupported --formatVersion %s\n", argv[0], s);
-            illegalArg = TRUE;
+            illegalArg = true;
         } else if(s[0] == '1' &&
                   (options[WRITE_POOL_BUNDLE].doesOccur || options[USE_POOL_BUNDLE].doesOccur)
         ) {
             fprintf(stderr, "%s: cannot combine --formatVersion 1 with --writePoolBundle or --usePoolBundle\n", argv[0]);
-            illegalArg = TRUE;
+            illegalArg = true;
         } else {
             setFormatVersion(s[0] - '0');
         }
@@ -173,7 +182,7 @@ main(int argc,
                 "%s error: command line argument --java-package or --bundle-name "
                 "without --write-java\n",
                 argv[0]);
-        illegalArg = TRUE;
+        illegalArg = true;
     }
 
     if(options[VERSION].doesOccur) {
@@ -246,17 +255,17 @@ main(int argc,
     }
 
     if(options[VERBOSE].doesOccur) {
-        setVerbose(TRUE);
+        setVerbose(true);
     }
 
     if(options[QUIET].doesOccur) {
-        setShowWarning(FALSE);
+        setShowWarning(false);
     }
     if(options[STRICT].doesOccur) {
-        setStrict(TRUE);
+        setStrict(true);
     }
     if(options[COPYRIGHT].doesOccur){
-        setIncludeCopyright(TRUE);
+        setIncludeCopyright(true);
     }
 
     if(options[SOURCEDIR].doesOccur) {
@@ -291,17 +300,26 @@ main(int argc,
     }
     status = U_ZERO_ERROR;
     if(options[WRITE_JAVA].doesOccur) {
-        write_java = TRUE;
+        write_java = true;
         outputEnc = options[WRITE_JAVA].value;
     }
 
     if(options[WRITE_XLIFF].doesOccur) {
-        write_xliff = TRUE;
+        write_xliff = true;
         if(options[WRITE_XLIFF].value != NULL){
             xliffOutputFileName = options[WRITE_XLIFF].value;
         }
     }
 
+    if (options[UCADATA].doesOccur) {
+#if !UCONFIG_NO_COLLATION
+        CollationRoot::forceLoadFromFile(options[UCADATA].value, status);
+#else
+        fprintf(stderr, "--ucadata was used with UCONFIG_NO_COLLATION\n");
+        return status;
+#endif
+    }
+
     initParser();
 
     /*added by Jing*/
@@ -311,7 +329,7 @@ main(int argc,
 
     LocalPointer<SRBRoot> newPoolBundle;
     if(options[WRITE_POOL_BUNDLE].doesOccur) {
-        newPoolBundle.adoptInsteadAndCheckErrorCode(new SRBRoot(NULL, TRUE, status), status);
+        newPoolBundle.adoptInsteadAndCheckErrorCode(new SRBRoot(NULL, true, status), status);
         if(U_FAILURE(status)) {
             fprintf(stderr, "unable to create an empty bundle for the pool keys: %s\n", u_errorName(status));
             return status;
@@ -494,7 +512,7 @@ main(int argc,
         }
 
         T_FileStream_close(poolFile);
-        setUsePoolBundle(TRUE);
+        setUsePoolBundle(true);
         if (isVerbose() && poolBundle.fStrings != NULL) {
             printf("number of shared strings: %d\n", (int)poolBundle.fStrings->fCount);
             int32_t length = poolBundle.fStringIndexLimit + 1;  // incl. last NUL
@@ -639,7 +657,7 @@ processFile(const char *filename, const char *cp,
         return;
     }
 
-    ucbuf.adoptInstead(ucbuf_open(openFileName.data(), &cp,getShowWarning(),TRUE, &status));
+    ucbuf.adoptInstead(ucbuf_open(openFileName.data(), &cp,getShowWarning(),true, &status));
     if(status == U_FILE_ACCESS_ERROR) {
 
         fprintf(stderr, "couldn't open file %s\n", openFileName.data());
@@ -656,7 +674,7 @@ processFile(const char *filename, const char *cp,
     }
     /* Parse the data into an SRBRoot */
     data.adoptInstead(parse(ucbuf.getAlias(), inputDir, outputDir, filename,
-            !omitBinaryCollation, options[NO_COLLATION_RULES].doesOccur, &status));
+            !omitBinaryCollation, options[NO_COLLATION_RULES].doesOccur, options[ICU4X_MODE].doesOccur, &status));
 
     if (data.isNull() || U_FAILURE(status)) {
         fprintf(stderr, "couldn't parse the file %s. Error:%s\n", filename, u_errorName(status));
@@ -730,11 +748,11 @@ processFile(const char *filename, const char *cp,
                 filename, u_errorName(status));
         return;
     }
-    if(write_java== TRUE){
+    if(write_java== true){
         bundle_write_java(data.getAlias(), outputDir, outputEnc,
                           outputFileName, sizeof(outputFileName),
                           options[JAVA_PACKAGE].value, options[BUNDLE_NAME].value, &status);
-    }else if(write_xliff ==TRUE){
+    }else if(write_xliff ==true){
         bundle_write_xml(data.getAlias(), outputDir, outputEnc,
                          filename, outputFileName, sizeof(outputFileName),
                          language, xliffOutputFileName, &status);
diff --git a/deps/icu-small/source/tools/genrb/parse.cpp b/deps/icu-small/source/tools/genrb/parse.cpp
index 7d5ffe1fc7..2c5d495243 100644
--- a/deps/icu-small/source/tools/genrb/parse.cpp
+++ b/deps/icu-small/source/tools/genrb/parse.cpp
@@ -21,6 +21,8 @@
 */
 
 // Safer use of UnicodeString.
+#include <cstdint>
+#include "unicode/umachine.h"
 #ifndef UNISTR_FROM_CHAR_EXPLICIT
 #   define UNISTR_FROM_CHAR_EXPLICIT explicit
 #endif
@@ -42,6 +44,7 @@
 #include "reslist.h"
 #include "rbt_pars.h"
 #include "genrb.h"
+#include "unicode/normalizer2.h"
 #include "unicode/stringpiece.h"
 #include "unicode/unistr.h"
 #include "unicode/ustring.h"
@@ -59,6 +62,7 @@
 #include "collationruleparser.h"
 #include "collationtailoring.h"
 #include <stdio.h>
+#include "writesrc.h"
 
 /* Number of tokens to read ahead of the current stream position */
 #define MAX_LOOKAHEAD   3
@@ -76,6 +80,9 @@
 #define OPENSQBRACKET    0x005B
 #define CLOSESQBRACKET   0x005D
 
+#define ICU4X_DIACRITIC_BASE  0x0300
+#define ICU4X_DIACRITIC_LIMIT 0x034F
+
 using icu::CharString;
 using icu::LocalMemory;
 using icu::LocalPointer;
@@ -119,6 +126,7 @@ typedef struct {
     const char     *filename;
     UBool           makeBinaryCollation;
     UBool           omitCollationRules;
+    UBool           icu4xMode;
 } ParseState;
 
 typedef struct SResource *
@@ -315,7 +323,7 @@ parseUCARules(ParseState* state, char *tag, uint32_t startline, const struct USt
     char              filename[256] = { '\0' };
     char              cs[128]       = { '\0' };
     uint32_t          line;
-    UBool quoted = FALSE;
+    UBool quoted = false;
     UCHARBUF *ucbuf=NULL;
     UChar32   c     = 0;
     const char* cp  = NULL;
@@ -359,7 +367,7 @@ parseUCARules(ParseState* state, char *tag, uint32_t startline, const struct USt
         return res_none();
     }
 
-    ucbuf = ucbuf_open(filename, &cp, getShowWarning(),FALSE, status);
+    ucbuf = ucbuf_open(filename, &cp, getShowWarning(),false, status);
 
     if (U_FAILURE(*status)) {
         error(line, "An error occurred while opening the input file %s\n", filename);
@@ -497,7 +505,7 @@ parseTransliterator(ParseState* state, char *tag, uint32_t startline, const stru
     uprv_strcat(filename, cs);
 
 
-    ucbuf = ucbuf_open(filename, &cp, getShowWarning(),FALSE, status);
+    ucbuf = ucbuf_open(filename, &cp, getShowWarning(),false, status);
 
     if (U_FAILURE(*status)) {
         error(line, "An error occurred while opening the input file %s\n", filename);
@@ -752,7 +760,7 @@ GenrbImporter::getRules(
     // printf("GenrbImporter::getRules(%s, %s) reads %s\n", localeID, collationType, openFileName.data());
     const char* cp = "";
     LocalUCHARBUFPointer ucbuf(
-            ucbuf_open(openFileName.data(), &cp, getShowWarning(), TRUE, &errorCode));
+            ucbuf_open(openFileName.data(), &cp, getShowWarning(), true, &errorCode));
     if(errorCode == U_FILE_ACCESS_ERROR) {
         fprintf(stderr, "couldn't open file %s\n", openFileName.data());
         return;
@@ -764,7 +772,7 @@ GenrbImporter::getRules(
 
     /* Parse the data into an SRBRoot */
     LocalPointer<SRBRoot> data(
-            parse(ucbuf.getAlias(), inputDir, outputDir, filename.data(), FALSE, FALSE, &errorCode));
+            parse(ucbuf.getAlias(), inputDir, outputDir, filename.data(), false, false, false, &errorCode));
     if (U_FAILURE(errorCode)) {
         return;
     }
@@ -807,6 +815,333 @@ escape(const UChar *s, char *buffer) {
 
 }  // namespace
 
+static FILE*
+openTOML(const char* outputdir, const char* name, const char* collationType, const char* structType, UErrorCode *status) {
+    CharString baseName;
+    baseName.append(name, *status);
+    baseName.append("_", *status);
+    baseName.append(collationType, *status);
+    baseName.append("_", *status);
+    baseName.append(structType, *status);
+
+    CharString outFileName;
+    if (outputdir && *outputdir) {
+        outFileName.append(outputdir, *status).ensureEndsWithFileSeparator(*status);
+    }
+    outFileName.append(baseName, *status);
+    outFileName.append(".toml", *status);
+    if (U_FAILURE(*status)) {
+        return NULL;
+    }
+
+    FILE* f = fopen(outFileName.data(), "w");
+    if (!f) {
+        *status = U_FILE_ACCESS_ERROR;
+        return NULL;
+    }
+    usrc_writeFileNameGeneratedBy(f, "#", baseName.data(), "genrb -X");
+
+    return f;
+}
+
+static void
+writeCollationMetadataTOML(const char* outputdir, const char* name, const char* collationType, const uint32_t metadataBits, UErrorCode *status) {
+    FILE* f = openTOML(outputdir, name, collationType, "meta", status);
+    if (!f) {
+        return;
+    }
+    // printf("writeCollationMetadataTOML %s %s\n", name, collationType);
+    fprintf(f, "bits = 0x%X\n", metadataBits);
+    fclose(f);
+}
+
+static UChar32
+writeCollationDiacriticsTOML(const char* outputdir, const char* name, const char* collationType, const icu::CollationData* data, UErrorCode *status) {
+    UChar32 limit = ICU4X_DIACRITIC_LIMIT;
+    FILE* f = openTOML(outputdir, name, collationType, "dia", status);
+    if (!f) {
+        return limit;
+    }
+    // printf("writeCollationDiacriticsTOML %s %s\n", name, collationType);
+    uint16_t secondaries[ICU4X_DIACRITIC_LIMIT-ICU4X_DIACRITIC_BASE];
+    for (UChar32 c = ICU4X_DIACRITIC_BASE; c < ICU4X_DIACRITIC_LIMIT; ++c) {
+        uint16_t secondary = 0;
+        uint32_t ce32 = data->getCE32(c);
+        if (ce32 == icu::Collation::FALLBACK_CE32) {
+            ce32 = data->base->getCE32(c);
+        }
+        if (c == 0x0340 || c == 0x0341 || c == 0x0343 || c == 0x0344) {
+            // These never occur in NFD data
+        } else if (!icu::Collation::isSimpleOrLongCE32(ce32)) {
+            if (uprv_strcmp(name, "root") == 0) {
+                printf("UNSUPPORTED DIACRITIC CE32 in root: TAG: %X CE32: %X char: %X\n", icu::Collation::tagFromCE32(ce32), ce32, c);
+                fclose(f);
+                *status = U_INTERNAL_PROGRAM_ERROR;
+                return limit;
+            }
+            limit = c;
+            break;
+        } else {
+            uint64_t ce = uint64_t(icu::Collation::ceFromCE32(ce32));
+            if ((ce & 0xFFFFFFFF0000FFFF) != uint64_t(icu::Collation::COMMON_TERTIARY_CE)) {
+                // Not a CE where only the secondary weight differs from the expected
+                // pattern.
+                limit = c;
+                break;
+            }
+            secondary = uint16_t(ce >> 16);
+        }
+        secondaries[c - ICU4X_DIACRITIC_BASE] = secondary;
+
+    }
+    usrc_writeArray(f, "secondaries = [\n  ", secondaries, 16, limit-ICU4X_DIACRITIC_BASE, "  ", "\n]\n");
+    fclose(f);
+    return limit;
+}
+
+static void
+writeCollationReorderingTOML(const char* outputdir, const char* name, const char* collationType, const icu::CollationSettings* settings, UErrorCode *status) {
+    FILE* f = openTOML(outputdir, name, collationType, "reord", status);
+    if (!f) {
+        return;
+    }
+    // printf("writeCollationReorderingTOML %s %s\n", name, collationType);
+    fprintf(f, "min_high_no_reorder = 0x%X\n", settings->minHighNoReorder);
+    usrc_writeArray(f, "reorder_table = [\n  ", settings->reorderTable, 8, 256, "  ", "\n]\n");
+    usrc_writeArray(f, "reorder_ranges = [\n  ", settings->reorderRanges, 32, settings->reorderRangesLength, "  ", "\n]\n");
+    fclose(f);
+}
+
+
+static void
+writeCollationJamoTOML(const char* outputdir, const char* name, const char* collationType, const icu::CollationData* data, UErrorCode *status) {
+    FILE* f = openTOML(outputdir, name, collationType, "jamo", status);
+    if (!f) {
+        printf("writeCollationJamoTOML FAILED TO OPEN FILE %s %s\n", name, collationType);
+        return;
+    }
+    uint32_t jamo[0x1200-0x1100];
+    for (UChar32 c = 0x1100; c < 0x1200; ++c) {
+        uint32_t ce32 = data->getCE32(c);
+        if (ce32 == icu::Collation::FALLBACK_CE32) {
+            ce32 = data->base->getCE32(c);
+        }
+        // Can't reject complex CE32s, because search collations have expansions.
+        // These expansions refer to the tailoring, which foils the reuse of the
+        // these jamo tables.
+        // XXX Figure out what to do. Perhaps instead of having Latin mini expansions,
+        // there should be Hangul mini expansions.
+        // XXX in any case, validate that modern jamo are self-contained.
+        jamo[c - 0x1100] = ce32;
+
+    }
+    usrc_writeArray(f, "ce32s = [\n  ", jamo, 32, 0x1200-0x1100, "  ", "\n]\n");
+    fclose(f);
+}
+
+static UBool
+convertTrie(const void *context, UChar32 start, UChar32 end, uint32_t value) {
+    if (start >= 0x1100 && start < 0x1200 && end >= 0x1100 && end < 0x1200) {
+        // Range entirely in conjoining jamo block.
+        return true;
+    }
+    icu::IcuToolErrorCode status("genrb: convertTrie");
+    umutablecptrie_setRange((UMutableCPTrie*)context, start, end, value, status);
+    return !U_FAILURE(*status);
+}
+
+static void
+writeCollationDataTOML(const char* outputdir, const char* name, const char* collationType, const icu::CollationData* data, UBool root, UChar32 diacriticLimit, UErrorCode *status) {
+    FILE* f = openTOML(outputdir, name, collationType, "data", status);
+    if (!f) {
+        return;
+    }
+    // printf("writeCollationDataTOML %s %s\n", name, collationType);
+
+    icu::UnicodeSet tailoringSet;
+
+    if (data->base) {
+        tailoringSet.addAll(*(data->unsafeBackwardSet));
+        tailoringSet.removeAll(*(data->base->unsafeBackwardSet));
+    } else {
+        tailoringSet.addAll(*(data->unsafeBackwardSet));
+    }
+
+    // Use the same value for out-of-range and default in the hope of not having to allocate
+    // different blocks, since ICU4X never does out-of-range queries.
+    uint32_t trieDefault = root ? icu::Collation::UNASSIGNED_CE32 : icu::Collation::FALLBACK_CE32;
+    icu::LocalUMutableCPTriePointer builder(umutablecptrie_open(trieDefault, trieDefault, status));
+
+    utrie2_enum(data->trie, NULL, &convertTrie, builder.getAlias());
+
+    // If the diacritic table was cut short, copy CE32s between the lowered
+    // limit and the max limit from the root to the tailoring. As of June 2022,
+    // no collation in CLDR needs this.
+    for (UChar32 c = diacriticLimit; c < ICU4X_DIACRITIC_LIMIT; ++c) {
+        if (c == 0x0340 || c == 0x0341 || c == 0x0343 || c == 0x0344) {
+            // These never occur in NFD data.
+            continue;
+        }
+        uint32_t ce32 = data->getCE32(c);
+        if (ce32 == icu::Collation::FALLBACK_CE32) {
+            ce32 = data->base->getCE32(c);
+            umutablecptrie_set(builder.getAlias(), c, ce32, status);
+        }
+    }
+
+    // Ensure that the range covered by the diacritic table isn't duplicated
+    // in the trie.
+    for (UChar32 c = ICU4X_DIACRITIC_BASE; c < diacriticLimit; ++c) {
+        if (umutablecptrie_get(builder.getAlias(), c) != trieDefault) {
+            umutablecptrie_set(builder.getAlias(), c, trieDefault, status);
+        }
+    }
+
+    icu::LocalUCPTriePointer utrie(umutablecptrie_buildImmutable(
+    builder.getAlias(),
+    UCPTRIE_TYPE_SMALL,
+    UCPTRIE_VALUE_BITS_32,
+    status));
+    usrc_writeArray(f, "contexts = [\n  ", data->contexts, 16, data->contextsLength, "  ", "\n]\n");
+    usrc_writeArray(f, "ce32s = [\n  ", data->ce32s, 32, data->ce32sLength, "  ", "\n]\n");
+    usrc_writeArray(f, "ces = [\n  ", data->ces, 64, data->cesLength, "  ", "\n]\n");
+    fprintf(f, "[trie]\n");
+    usrc_writeUCPTrie(f, "trie", utrie.getAlias(), UPRV_TARGET_SYNTAX_TOML);
+
+    fclose(f);
+}
+
+static void
+writeCollationSpecialPrimariesTOML(const char* outputdir, const char* name, const char* collationType, const icu::CollationData* data, UErrorCode *status) {
+    FILE* f = openTOML(outputdir, name, collationType, "prim", status);
+    if (!f) {
+        return;
+    }
+    // printf("writeCollationSpecialPrimariesTOML %s %s\n", name, collationType);
+
+    uint16_t lastPrimaries[4];
+    for (int32_t i = 0; i < 4; ++i) {
+        // getLastPrimaryForGroup subtracts one from a 16-bit value, so we add one
+        // back to get a value that fits in 16 bits.
+        lastPrimaries[i] = (uint16_t)((data->getLastPrimaryForGroup(UCOL_REORDER_CODE_FIRST + i) + 1) >> 16);
+    }
+
+    uint32_t numericPrimary = data->numericPrimary;
+    if (numericPrimary & 0xFFFFFF) {
+        printf("Lower 24 bits set in numeric primary");
+        *status = U_INTERNAL_PROGRAM_ERROR;
+        return;
+    }
+
+    usrc_writeArray(f, "last_primaries = [\n  ", lastPrimaries, 16, 4, "  ", "\n]\n");
+    fprintf(f, "numeric_primary = 0x%X\n", numericPrimary >> 24);
+    fclose(f);
+}
+
+static void
+writeCollationTOML(const char* outputdir, const char* name, const char* collationType, const icu::CollationData* data, const icu::CollationSettings* settings, UErrorCode *status) {
+    UBool tailored = false;
+    UBool tailoredDiacritics = false;
+    UBool lithuanianDotAbove = (uprv_strcmp(name, "lt") == 0);
+    UBool reordering = false;
+    UBool isRoot = uprv_strcmp(name, "root") == 0;
+    UChar32 diacriticLimit = ICU4X_DIACRITIC_LIMIT;
+    if (!data->base && isRoot) {
+        diacriticLimit = writeCollationDiacriticsTOML(outputdir, name, collationType, data, status);
+        if (U_FAILURE(*status)) {
+            return;
+        }
+        writeCollationJamoTOML(outputdir, name, collationType, data, status);
+        if (U_FAILURE(*status)) {
+            return;
+        }
+        writeCollationSpecialPrimariesTOML(outputdir, name, collationType, data, status);
+        if (U_FAILURE(*status)) {
+            return;
+        }
+    } else if (data->base && !lithuanianDotAbove) {
+        for (UChar32 c = ICU4X_DIACRITIC_BASE; c < ICU4X_DIACRITIC_LIMIT; ++c) {
+            if (c == 0x0340 || c == 0x0341 || c == 0x0343 || c == 0x0344) {
+                // These never occur in NFD data.
+                continue;
+            }
+            uint32_t ce32 = data->getCE32(c);
+            if ((ce32 != icu::Collation::FALLBACK_CE32) && (ce32 != data->base->getCE32(c))) {
+                tailoredDiacritics = true;
+                diacriticLimit = writeCollationDiacriticsTOML(outputdir, name, collationType, data, status);
+                if (U_FAILURE(*status)) {
+                    return;
+                }
+                break;
+            }
+        }
+    }
+
+    if (settings->hasReordering()) {
+        reordering = true;
+        // Note: There are duplicate reorderings. Expecting the ICU4X provider
+        // to take care of deduplication.
+        writeCollationReorderingTOML(outputdir, name, collationType, settings, status);
+        if (U_FAILURE(*status)) {
+            return;
+        }
+    }
+
+    // Write collation data if either base is non-null or the name is root.
+    // Languages that only reorder scripts are otherwise root-like and have
+    // null base.
+    if (data->base || isRoot) {
+        tailored = !isRoot;
+        writeCollationDataTOML(outputdir, name, collationType, data, (!data->base && isRoot), diacriticLimit, status);
+        if (U_FAILURE(*status)) {
+            return;
+        }
+    }
+
+    uint32_t maxVariable = (uint32_t)settings->getMaxVariable();
+    if (maxVariable >= 4) {
+        printf("Max variable out of range");
+        *status = U_INTERNAL_PROGRAM_ERROR;
+        return;
+    }
+
+    uint32_t metadataBits = maxVariable;
+    if (tailored) {
+        metadataBits |= (1 << 3);
+    }
+    if (tailoredDiacritics) {
+        metadataBits |= (1 << 4);
+    }
+    if (reordering) {
+        metadataBits |= (1 << 5);
+    }
+    if (lithuanianDotAbove) {
+        metadataBits |= (1 << 6);
+    }
+    if ((settings->options & icu::CollationSettings::BACKWARD_SECONDARY) != 0) {
+        metadataBits |= (1 << 7);
+    }
+    if (settings->getAlternateHandling() == UCOL_SHIFTED) {
+        metadataBits |= (1 << 8);
+    }
+    switch (settings->getCaseFirst()) {
+        case UCOL_OFF:
+            break;
+        case UCOL_UPPER_FIRST:
+            metadataBits |= (1 << 9);
+            metadataBits |= (1 << 10);
+            break;
+        case UCOL_LOWER_FIRST:
+            metadataBits |= (1 << 9);
+            break;
+        default:
+            *status = U_INTERNAL_PROGRAM_ERROR;
+            return;
+    }
+
+    writeCollationMetadataTOML(outputdir, name, collationType, metadataBits, status);
+}
+
 #endif  // !UCONFIG_NO_COLLATION
 
 static TableResource *
@@ -820,7 +1155,7 @@ addCollation(ParseState* state, TableResource  *result, const char *collationTyp
     enum   ETokenType  token;
     char               subtag[1024];
     UnicodeString      rules;
-    UBool              haveRules = FALSE;
+    UBool              haveRules = false;
     UVersionInfo       version;
     uint32_t           line;
 
@@ -898,7 +1233,7 @@ addCollation(ParseState* state, TableResource  *result, const char *collationTyp
         {
             StringResource *sr = static_cast<StringResource *>(member);
             rules = sr->fString;
-            haveRules = TRUE;
+            haveRules = true;
             // Defer building the collator until we have seen
             // all sub-elements of the collation table, including the Version.
             /* in order to achieve smaller data files, we can direct genrb */
@@ -952,9 +1287,9 @@ addCollation(ParseState* state, TableResource  *result, const char *collationTyp
         res_close(result);
         return NULL;  // TODO: use LocalUResourceBundlePointer for result
     }
-    icu::CollationBuilder builder(base, intStatus);
-    if(uprv_strncmp(collationType, "search", 6) == 0) {
-        builder.disableFastLatin();  // build fast-Latin table unless search collator
+    icu::CollationBuilder builder(base, state->icu4xMode, intStatus);
+    if(state->icu4xMode || (uprv_strncmp(collationType, "search", 6) == 0)) {
+        builder.disableFastLatin();  // build fast-Latin table unless search collator or ICU4X
     }
     LocalPointer<icu::CollationTailoring> t(
             builder.parseAndBuild(rules, version, &importer, &parseError, intStatus));
@@ -977,6 +1312,19 @@ addCollation(ParseState* state, TableResource  *result, const char *collationTyp
             return NULL;
         }
     }
+    if (state->icu4xMode) {
+        char *nameWithoutSuffix = static_cast<char *>(uprv_malloc(uprv_strlen(state->filename) + 1));
+        if (nameWithoutSuffix == NULL) {
+            *status = U_MEMORY_ALLOCATION_ERROR;
+            res_close(result);
+            return NULL;
+        }
+        uprv_strcpy(nameWithoutSuffix, state->filename);
+        *uprv_strrchr(nameWithoutSuffix, '.') = 0;
+
+        writeCollationTOML(state->outputdir, nameWithoutSuffix, collationType, t->data, t->settings, status);
+        uprv_free(nameWithoutSuffix);
+    }
     icu::LocalMemory<uint8_t> buffer;
     int32_t capacity = 100000;
     uint8_t *dest = buffer.allocateInsteadAndCopy(capacity);
@@ -1036,7 +1384,7 @@ addCollation(ParseState* state, TableResource  *result, const char *collationTyp
 
 static UBool
 keepCollationType(const char * /*type*/) {
-    return TRUE;
+    return true;
 }
 
 static struct SResource *
@@ -1177,7 +1525,7 @@ realParseTable(ParseState* state, TableResource *table, char *tag, uint32_t star
     enum   ETokenType token;
     char              subtag[1024];
     uint32_t          line;
-    UBool             readToken = FALSE;
+    UBool             readToken = false;
 
     /* '{' . (name resource)* '}' */
 
@@ -1242,7 +1590,7 @@ realParseTable(ParseState* state, TableResource *table, char *tag, uint32_t star
             error(line, "parse error. Stopped parsing table with %s", u_errorName(*status));
             return NULL;
         }
-        readToken = TRUE;
+        readToken = true;
         ustr_deinit(&comment);
    }
 
@@ -1257,11 +1605,11 @@ parseTable(ParseState* state, char *tag, uint32_t startline, const struct UStrin
 {
     if (tag != NULL && uprv_strcmp(tag, "CollationElements") == 0)
     {
-        return parseCollationElements(state, tag, startline, FALSE, status);
+        return parseCollationElements(state, tag, startline, false, status);
     }
     if (tag != NULL && uprv_strcmp(tag, "collations") == 0)
     {
-        return parseCollationElements(state, tag, startline, TRUE, status);
+        return parseCollationElements(state, tag, startline, true, status);
     }
     if(isVerbose()){
         printf(" table %s at line %i \n",  (tag == NULL) ? "(null)" : tag, (int)startline);
@@ -1283,7 +1631,7 @@ parseArray(ParseState* state, char *tag, uint32_t startline, const struct UStrin
     struct UString    *tokenValue;
     struct UString    memberComments;
     enum   ETokenType token;
-    UBool             readToken = FALSE;
+    UBool             readToken = false;
 
     ArrayResource  *result = array_open(state->bundle, tag, comment, status);
 
@@ -1356,7 +1704,7 @@ parseArray(ParseState* state, char *tag, uint32_t startline, const struct UStrin
             res_close(result);
             return NULL;
         }
-        readToken = TRUE;
+        readToken = true;
     }
 
     ustr_deinit(&memberComments);
@@ -1369,7 +1717,7 @@ parseIntVector(ParseState* state, char *tag, uint32_t startline, const struct US
     enum   ETokenType  token;
     char              *string;
     int32_t            value;
-    UBool              readToken = FALSE;
+    UBool              readToken = false;
     char              *stopstring;
     struct UString     memberComments;
 
@@ -1440,7 +1788,7 @@ parseIntVector(ParseState* state, char *tag, uint32_t startline, const struct US
         {
             getToken(state, NULL, NULL, NULL, status);
         }
-        readToken = TRUE;
+        readToken = true;
     }
 
     /* not reached */
@@ -1681,7 +2029,7 @@ parseInclude(ParseState* state, char *tag, uint32_t startline, const struct UStr
         uprv_strcpy(fullname,filename);
     }
 
-    ucbuf = ucbuf_open(fullname, &cp,getShowWarning(),FALSE,status);
+    ucbuf = ucbuf_open(fullname, &cp,getShowWarning(),false,status);
 
     if (U_FAILURE(*status)) {
         error(line, "couldn't open input file %s\n", filename);
@@ -1966,7 +2314,7 @@ parseResource(ParseState* state, char *tag, const struct UString *comment, UErro
 /* parse the top-level resource */
 struct SRBRoot *
 parse(UCHARBUF *buf, const char *inputDir, const char *outputDir, const char *filename,
-      UBool makeBinaryCollation, UBool omitCollationRules, UErrorCode *status)
+      UBool makeBinaryCollation, UBool omitCollationRules, UBool icu4xMode, UErrorCode *status)
 {
     struct UString    *tokenValue;
     struct UString    comment;
@@ -1992,11 +2340,12 @@ parse(UCHARBUF *buf, const char *inputDir, const char *outputDir, const char *fi
     state.filename = filename;
     state.makeBinaryCollation = makeBinaryCollation;
     state.omitCollationRules = omitCollationRules;
+    state.icu4xMode = icu4xMode;
 
     ustr_init(&comment);
     expect(&state, TOK_STRING, &tokenValue, &comment, NULL, status);
 
-    state.bundle = new SRBRoot(&comment, FALSE, *status);
+    state.bundle = new SRBRoot(&comment, false, *status);
 
     if (state.bundle == NULL || U_FAILURE(*status))
     {
@@ -2053,7 +2402,7 @@ parse(UCHARBUF *buf, const char *inputDir, const char *outputDir, const char *fi
          * This is the same as a regular table, but also sets the
          * URES_ATT_NO_FALLBACK flag in indexes[URES_INDEX_ATTRIBUTES] .
          */
-        state.bundle->fNoFallback=TRUE;
+        state.bundle->fNoFallback=true;
     }
     /* top-level tables need not handle special table names like "collations" */
     assert(!state.bundle->fIsPoolBundle);
diff --git a/deps/icu-small/source/tools/genrb/parse.h b/deps/icu-small/source/tools/genrb/parse.h
index bcd8e798f9..fa90ede9d2 100644
--- a/deps/icu-small/source/tools/genrb/parse.h
+++ b/deps/icu-small/source/tools/genrb/parse.h
@@ -31,7 +31,7 @@ void initParser();
 /* Parse a ResourceBundle text file */
 struct SRBRoot* parse(UCHARBUF *buf, const char* inputDir, const char* outputDir,
                       const char *filename,
-                      UBool makeBinaryCollation, UBool omitCollationRules, UErrorCode *status);
+                      UBool makeBinaryCollation, UBool omitCollationRules, UBool icu4xMode, UErrorCode *status);
 
 U_CDECL_END
 
diff --git a/deps/icu-small/source/tools/genrb/read.c b/deps/icu-small/source/tools/genrb/read.c
index 7314f6b742..0d4a318a89 100644
--- a/deps/icu-small/source/tools/genrb/read.c
+++ b/deps/icu-small/source/tools/genrb/read.c
@@ -18,6 +18,8 @@
 *******************************************************************************
 */
 
+#include <stdbool.h>
+
 #include "read.h"
 #include "errmsg.h"
 #include "toolutil.h"
@@ -77,7 +79,7 @@ getNextToken(UCHARBUF* buf,
     }
 
     /* Skip whitespace */
-    c = getNextChar(buf, TRUE, comment, status);
+    c = getNextChar(buf, true, comment, status);
 
     if (U_FAILURE(*status)) {
         return TOK_ERROR;
@@ -127,8 +129,8 @@ static enum ETokenType getStringToken(UCHARBUF* buf,
     UChar    target[3] = { '\0' };
     UChar    *pTarget   = target;
     int      len=0;
-    UBool    isFollowingCharEscaped=FALSE;
-    UBool    isNLUnescaped = FALSE;
+    UBool    isFollowingCharEscaped=false;
+    UBool    isNLUnescaped = false;
     UChar32  prevC=0;
 
     /* We are guaranteed on entry that initialChar is not a whitespace
@@ -141,7 +143,7 @@ static enum ETokenType getStringToken(UCHARBUF* buf,
     }
 
     /* setup */
-    lastStringWasQuoted = FALSE;
+    lastStringWasQuoted = false;
     c = initialChar;
     ustr_setlen(token, 0, status);
 
@@ -159,7 +161,7 @@ static enum ETokenType getStringToken(UCHARBUF* buf,
                 }
             }
 
-            lastStringWasQuoted = TRUE;
+            lastStringWasQuoted = true;
 
             for (;;) {
                 c = ucbuf_getc(buf,status);
@@ -186,23 +188,23 @@ static enum ETokenType getStringToken(UCHARBUF* buf,
                         return TOK_ERROR;
                     }
                     if(c == CR || c == LF){
-                        isNLUnescaped = TRUE;
+                        isNLUnescaped = true;
                     }
                 }               
 
                 if(c==ESCAPE && !isFollowingCharEscaped){
-                    isFollowingCharEscaped = TRUE;
+                    isFollowingCharEscaped = true;
                 }else{
                     U_APPEND_CHAR32(c, pTarget,len);
                     pTarget = target;
                     ustr_uscat(token, pTarget,len, status);
-                    isFollowingCharEscaped = FALSE;
+                    isFollowingCharEscaped = false;
                     len=0;
                     if(c == CR || c == LF){
-                        if(isNLUnescaped == FALSE && prevC!=CR){
+                        if(isNLUnescaped == false && prevC!=CR){
                             lineCount++;
                         }
-                        isNLUnescaped = FALSE;
+                        isNLUnescaped = false;
                     }
                 }
                 
@@ -230,7 +232,7 @@ static enum ETokenType getStringToken(UCHARBUF* buf,
 
             }
 
-            lastStringWasQuoted = FALSE;
+            lastStringWasQuoted = false;
             
             /* if we reach here we are mixing 
              * quoted and unquoted strings
@@ -259,7 +261,7 @@ static enum ETokenType getStringToken(UCHARBUF* buf,
 
             for (;;) {
                 /* DON'T skip whitespace */
-                c = getNextChar(buf, FALSE, NULL, status);
+                c = getNextChar(buf, false, NULL, status);
 
                 /* EOF reached */
                 if (c == U_EOF) {
@@ -304,7 +306,7 @@ static enum ETokenType getStringToken(UCHARBUF* buf,
         }
 
         /* DO skip whitespace */
-        c = getNextChar(buf, TRUE, NULL, status);
+        c = getNextChar(buf, true, NULL, status);
 
         if (U_FAILURE(*status)) {
             return TOK_STRING;
@@ -455,10 +457,10 @@ static UBool isWhitespace(UChar32 c) {
     case 0x0020:
     case 0x0009:
     case 0xFEFF:
-        return TRUE;
+        return true;
 
     default:
-        return FALSE;
+        return false;
     }
 }
 
@@ -469,9 +471,9 @@ static UBool isNewline(UChar32 c) {
     case 0x2029:
         lineCount++;
     case 0x000D:
-        return TRUE;
+        return true;
 
     default:
-        return FALSE;
+        return false;
     }
 }
diff --git a/deps/icu-small/source/tools/genrb/reslist.cpp b/deps/icu-small/source/tools/genrb/reslist.cpp
index b9e0d7d8c4..4c854bd55b 100644
--- a/deps/icu-small/source/tools/genrb/reslist.cpp
+++ b/deps/icu-small/source/tools/genrb/reslist.cpp
@@ -71,9 +71,9 @@
 
 U_NAMESPACE_USE
 
-static UBool gIncludeCopyright = FALSE;
-static UBool gUsePoolBundle = FALSE;
-static UBool gIsDefaultFormatVersion = TRUE;
+static UBool gIncludeCopyright = false;
+static UBool gUsePoolBundle = false;
+static UBool gIsDefaultFormatVersion = true;
 static int32_t gFormatVersion = 3;
 
 /* How do we store string values? */
@@ -131,7 +131,7 @@ UBool getIncludeCopyright(void){
 }
 
 void setFormatVersion(int32_t formatVersion) {
-    gIsDefaultFormatVersion = FALSE;
+    gIsDefaultFormatVersion = false;
     gFormatVersion = formatVersion;
 }
 
@@ -149,14 +149,14 @@ struct SResource* res_none() {
 }
 
 SResource::SResource()
-        : fType(URES_NONE), fWritten(FALSE), fRes(RES_BOGUS), fRes16(-1), fKey(-1), fKey16(-1),
+        : fType(URES_NONE), fWritten(false), fRes(RES_BOGUS), fRes16(-1), fKey(-1), fKey16(-1),
           line(0), fNext(NULL) {
     ustr_init(&fComment);
 }
 
 SResource::SResource(SRBRoot *bundle, const char *tag, int8_t type, const UString* comment,
                      UErrorCode &errorCode)
-        : fType(type), fWritten(FALSE), fRes(RES_BOGUS), fRes16(-1),
+        : fType(type), fWritten(false), fRes(RES_BOGUS), fRes16(-1),
           fKey(bundle != NULL ? bundle->addTag(tag, errorCode) : -1), fKey16(-1),
           line(0), fNext(NULL) {
     ustr_init(&fComment);
@@ -274,7 +274,7 @@ StringBaseResource::StringBaseResource(SRBRoot *bundle, const char *tag, int8_t
         : SResource(bundle, tag, type, comment, errorCode) {
     if (len == 0 && gFormatVersion > 1) {
         fRes = URES_MAKE_EMPTY_RESOURCE(type);
-        fWritten = TRUE;
+        fWritten = true;
         return;
     }
 
@@ -290,7 +290,7 @@ StringBaseResource::StringBaseResource(SRBRoot *bundle, int8_t type,
         : SResource(bundle, NULL, type, NULL, errorCode), fString(value) {
     if (value.isEmpty() && gFormatVersion > 1) {
         fRes = URES_MAKE_EMPTY_RESOURCE(type);
-        fWritten = TRUE;
+        fWritten = true;
         return;
     }
 
@@ -303,7 +303,7 @@ StringBaseResource::StringBaseResource(SRBRoot *bundle, int8_t type,
 // Pool bundle string, alias the buffer. Guaranteed NUL-terminated and not empty.
 StringBaseResource::StringBaseResource(int8_t type, const UChar *value, int32_t len,
                                        UErrorCode &errorCode)
-        : SResource(NULL, NULL, type, NULL, errorCode), fString(TRUE, value, len) {
+        : SResource(NULL, NULL, type, NULL, errorCode), fString(true, value, len) {
     assert(len > 0);
     assert(!fString.isBogus());
 }
@@ -332,7 +332,7 @@ IntResource::IntResource(SRBRoot *bundle, const char *tag, int32_t value,
         : SResource(bundle, tag, URES_INT, comment, errorCode) {
     fValue = value;
     fRes = URES_MAKE_RESOURCE(URES_INT, value & RES_MAX_OFFSET);
-    fWritten = TRUE;
+    fWritten = true;
 }
 
 IntResource::~IntResource() {}
@@ -395,7 +395,7 @@ BinaryResource::BinaryResource(SRBRoot *bundle, const char *tag,
     } else {
         if (gFormatVersion > 1) {
             fRes = URES_MAKE_EMPTY_RESOURCE(URES_BINARY);
-            fWritten = TRUE;
+            fWritten = true;
         }
     }
 }
@@ -544,14 +544,14 @@ ContainerResource::writeAllRes16(SRBRoot *bundle) {
     for (SResource *current = fFirst; current != NULL; current = current->fNext) {
         bundle->f16BitUnits.append((UChar)current->fRes16);
     }
-    fWritten = TRUE;
+    fWritten = true;
 }
 
 void
 ArrayResource::handleWrite16(SRBRoot *bundle) {
     if (fCount == 0 && gFormatVersion > 1) {
         fRes = URES_MAKE_EMPTY_RESOURCE(URES_ARRAY);
-        fWritten = TRUE;
+        fWritten = true;
         return;
     }
 
@@ -571,7 +571,7 @@ void
 TableResource::handleWrite16(SRBRoot *bundle) {
     if (fCount == 0 && gFormatVersion > 1) {
         fRes = URES_MAKE_EMPTY_RESOURCE(URES_TABLE);
-        fWritten = TRUE;
+        fWritten = true;
         return;
     }
     /* Find the smallest table type that fits the data. */
@@ -607,7 +607,7 @@ TableResource::handleWrite16(SRBRoot *bundle) {
 void
 PseudoListResource::handleWrite16(SRBRoot * /*bundle*/) {
     fRes = URES_MAKE_EMPTY_RESOURCE(URES_TABLE);
-    fWritten = TRUE;
+    fWritten = true;
 }
 
 void
@@ -669,7 +669,7 @@ void
 IntVectorResource::handlePreWrite(uint32_t *byteOffset) {
     if (fCount == 0 && gFormatVersion > 1) {
         fRes = URES_MAKE_EMPTY_RESOURCE(URES_INT_VECTOR);
-        fWritten = TRUE;
+        fWritten = true;
     } else {
         fRes = URES_MAKE_RESOURCE(URES_INT_VECTOR, *byteOffset >> 2);
         *byteOffset += (1 + fCount) * 4;
@@ -734,7 +734,7 @@ SResource::preWrite(uint32_t *byteOffset) {
 
 void
 SResource::handlePreWrite(uint32_t * /*byteOffset*/) {
-    assert(FALSE);
+    assert(false);
 }
 
 /*
@@ -748,7 +748,7 @@ StringBaseResource::handleWrite(UNewDataMemory *mem, uint32_t *byteOffset) {
     udata_write32(mem, len);
     udata_writeUString(mem, getBuffer(), len + 1);
     *byteOffset += 4 + (len + 1) * U_SIZEOF_UCHAR;
-    fWritten = TRUE;
+    fWritten = true;
 }
 
 void
@@ -839,12 +839,12 @@ SResource::write(UNewDataMemory *mem, uint32_t *byteOffset) {
         udata_writePadding(mem, paddingSize);
         *byteOffset += paddingSize;
     }
-    fWritten = TRUE;
+    fWritten = true;
 }
 
 void
 SResource::handleWrite(UNewDataMemory * /*mem*/, uint32_t * /*byteOffset*/) {
-    assert(FALSE);
+    assert(false);
 }
 
 void SRBRoot::write(const char *outputDir, const char *outputPkg,
@@ -996,7 +996,7 @@ void SRBRoot::write(const char *outputDir, const char *outputPkg,
     uprv_memcpy(dataInfo.formatVersion, gFormatVersions + formatVersion, sizeof(UVersionInfo));
 
     mem = udata_create(outputDir, "res", dataName,
-                       &dataInfo, (gIncludeCopyright==TRUE)? U_COPYRIGHT_STRING:NULL, &errorCode);
+                       &dataInfo, (gIncludeCopyright==true)? U_COPYRIGHT_STRING:NULL, &errorCode);
     if(U_FAILURE(errorCode)){
         return;
     }
@@ -1133,7 +1133,7 @@ struct SResource *bin_open(struct SRBRoot *bundle, const char *tag, uint32_t len
 }
 
 SRBRoot::SRBRoot(const UString *comment, UBool isPoolBundle, UErrorCode &errorCode)
-        : fRoot(NULL), fLocale(NULL), fIndexLength(0), fMaxTableLength(0), fNoFallback(FALSE),
+        : fRoot(NULL), fLocale(NULL), fIndexLength(0), fMaxTableLength(0), fNoFallback(false),
           fStringsForm(STRINGS_UTF16_V1), fIsPoolBundle(isPoolBundle),
           fKeys(NULL), fKeyMap(NULL),
           fKeysBottom(0), fKeysTop(0), fKeysCapacity(0),
@@ -1413,7 +1413,7 @@ SRBRoot::compactKeys(UErrorCode &errorCode) {
     }
     /* Sort the keys so that each one is immediately followed by all of its suffixes. */
     uprv_sortArray(map, keysCount, (int32_t)sizeof(KeyMapEntry),
-                   compareKeySuffixes, this, FALSE, &errorCode);
+                   compareKeySuffixes, this, false, &errorCode);
     /*
      * Make suffixes point into earlier, longer strings that contain them
      * and mark the old, now unused suffix bytes as deleted.
@@ -1466,7 +1466,7 @@ SRBRoot::compactKeys(UErrorCode &errorCode) {
          * to squeeze out unused bytes, and readjust the newpos offsets.
          */
         uprv_sortArray(map, keysCount, (int32_t)sizeof(KeyMapEntry),
-                       compareKeyNewpos, NULL, FALSE, &errorCode);
+                       compareKeyNewpos, NULL, false, &errorCode);
         if (U_SUCCESS(errorCode)) {
             int32_t oldpos, newpos, limit;
             oldpos = newpos = fKeysBottom;
@@ -1491,7 +1491,7 @@ SRBRoot::compactKeys(UErrorCode &errorCode) {
             fKeysTop = newpos;
             /* Re-sort once more, by old offsets for binary searching. */
             uprv_sortArray(map, keysCount, (int32_t)sizeof(KeyMapEntry),
-                           compareKeyOldpos, NULL, FALSE, &errorCode);
+                           compareKeyOldpos, NULL, false, &errorCode);
             if (U_SUCCESS(errorCode)) {
                 /* key size reduction by limit - newpos */
                 fKeyMap = map;
@@ -1550,7 +1550,7 @@ void
 StringResource::writeUTF16v2(int32_t base, UnicodeString &dest) {
     int32_t len = length();
     fRes = URES_MAKE_RESOURCE(URES_STRING_V2, base + dest.length());
-    fWritten = TRUE;
+    fWritten = true;
     switch(fNumCharsForLength) {
     case 0:
         break;
@@ -1591,7 +1591,7 @@ SRBRoot::compactStringsV2(UHashtable *stringSet, UErrorCode &errorCode) {
     }
     /* Sort the strings so that each one is immediately followed by all of its suffixes. */
     uprv_sortArray(array.getAlias(), count, (int32_t)sizeof(struct SResource **),
-                   compareStringSuffixes, NULL, FALSE, &errorCode);
+                   compareStringSuffixes, NULL, false, &errorCode);
     if (U_FAILURE(errorCode)) {
         return;
     }
@@ -1631,7 +1631,7 @@ SRBRoot::compactStringsV2(UHashtable *stringSet, UErrorCode &errorCode) {
                         if (poolStringIndex >= fPoolStringIndexLimit) {
                             fPoolStringIndexLimit = poolStringIndex + 1;
                         }
-                        suffixRes->fWritten = TRUE;
+                        suffixRes->fWritten = true;
                     }
                     res->fNumUnitsSaved += suffixRes->fNumCopies * suffixRes->get16BitStringsLength();
                 } else {
@@ -1649,7 +1649,7 @@ SRBRoot::compactStringsV2(UHashtable *stringSet, UErrorCode &errorCode) {
      * Keep as many as possible within reach of 16-bit offsets.
      */
     uprv_sortArray(array.getAlias(), count, (int32_t)sizeof(struct SResource **),
-                   compareStringLengths, NULL, FALSE, &errorCode);
+                   compareStringLengths, NULL, false, &errorCode);
     if (U_FAILURE(errorCode)) {
         return;
     }
@@ -1672,7 +1672,7 @@ SRBRoot::compactStringsV2(UHashtable *stringSet, UErrorCode &errorCode) {
             } else {
                 numUnitsNotSaved += res->fNumUnitsSaved;
                 res->fRes = URES_MAKE_EMPTY_RESOURCE(URES_STRING);
-                res->fWritten = TRUE;
+                res->fWritten = true;
             }
         }
         if (f16BitUnits.isBogus()) {
@@ -1734,7 +1734,7 @@ SRBRoot::compactStringsV2(UHashtable *stringSet, UErrorCode &errorCode) {
             if (localStringIndex >= fLocalStringIndexLimit) {
                 fLocalStringIndexLimit = localStringIndex + 1;
             }
-            res->fWritten = TRUE;
+            res->fWritten = true;
         }
     }
     // +1 to account for the initial zero in f16BitUnits
diff --git a/deps/icu-small/source/tools/genrb/wrtjava.cpp b/deps/icu-small/source/tools/genrb/wrtjava.cpp
index 3ad0a94cf3..0d2ddcd25a 100644
--- a/deps/icu-small/source/tools/genrb/wrtjava.cpp
+++ b/deps/icu-small/source/tools/genrb/wrtjava.cpp
@@ -324,7 +324,7 @@ static void
 string_write_java(const StringResource *res,UErrorCode *status) {
     (void)res->getKeyString(srBundle);
 
-    str_write_java(res->getBuffer(), res->length(), TRUE, status);
+    str_write_java(res->getBuffer(), res->length(), true, status);
 }
 
 static void
@@ -333,7 +333,7 @@ array_write_java(const ArrayResource *res, UErrorCode *status) {
     uint32_t  i         = 0;
     const char* arr ="new String[] { \n";
     struct SResource *current = NULL;
-    UBool allStrings    = TRUE;
+    UBool allStrings    = true;
 
     if (U_FAILURE(*status)) {
         return;
@@ -345,14 +345,14 @@ array_write_java(const ArrayResource *res, UErrorCode *status) {
         i = 0;
         while(current != NULL){
             if(!current->isString()){
-                allStrings = FALSE;
+                allStrings = false;
                 break;
             }
             current= current->fNext;
         }
 
         current = res->fFirst;
-        if(allStrings==FALSE){
+        if(allStrings==false){
             const char* object = "new Object[]{\n";
             write_tabs(out);
             T_FileStream_write(out, object, (int32_t)uprv_strlen(object));
@@ -506,7 +506,7 @@ bytes_write_java(const BinaryResource *res, UErrorCode * /*status*/) {
 
 }
 
-static UBool start = TRUE;
+static UBool start = true;
 
 static void
 table_write_java(const TableResource *res, UErrorCode *status) {
@@ -519,12 +519,12 @@ table_write_java(const TableResource *res, UErrorCode *status) {
     }
 
     if (res->fCount > 0) {
-        if(start==FALSE){
+        if(start==false){
             write_tabs(out);
             T_FileStream_write(out, obj, (int32_t)uprv_strlen(obj));
             tabCount++;
         }
-        start = FALSE;
+        start = false;
         current = res->fFirst;
         i       = 0;
 
@@ -624,10 +624,10 @@ bundle_write_java(struct SRBRoot *bundle, const char *outputDir,const char* outp
     char fileName[256] = {'\0'};
     char className[256]={'\0'};
     /*char constructor[1000] = { 0 };*/
-    /*UBool j1 =FALSE;*/
+    /*UBool j1 =false;*/
     /*outDir = outputDir;*/
 
-    start = TRUE;                        /* Reset the start indicator*/
+    start = true;                        /* Reset the start indicator*/
 
     bName = (bundleName==NULL) ? "LocaleElements" : bundleName;
     pName = (packageName==NULL)? "com.ibm.icu.impl.data" : packageName;
diff --git a/deps/icu-small/source/tools/genrb/wrtxml.cpp b/deps/icu-small/source/tools/genrb/wrtxml.cpp
index fa2105d908..069f091656 100644
--- a/deps/icu-small/source/tools/genrb/wrtxml.cpp
+++ b/deps/icu-small/source/tools/genrb/wrtxml.cpp
@@ -332,7 +332,7 @@ static char* convertAndEscape(char** pDest, int32_t destCap, int32_t* destLength
                     dest[destLen++]=(char)c;
                 }
             }else{
-                UBool isError = FALSE;
+                UBool isError = false;
                 U8_APPEND((unsigned char*)dest,destLen,destCap,c,isError);
                 if(isError){
                     *status = U_ILLEGAL_CHAR_FOUND;
@@ -584,7 +584,7 @@ static char *printContainer(SResource *res, const char *container, const char *r
     tabCount += 1;
     if (res->fComment.fLength > 0) {
         /* printComments will print the closing ">\n" */
-        printComments(&res->fComment, resname, TRUE, status);
+        printComments(&res->fComment, resname, true, status);
     } else {
         write_utf8_file(out, UnicodeString(">\n"));
     }
@@ -706,7 +706,7 @@ array_write_xml(ArrayResource *res, const char* id, const char* language, UError
         index += 1;
         subId = getID(sid, c, subId);
 
-        res_write_xml(current, subId, language, FALSE, status);
+        res_write_xml(current, subId, language, false, status);
         uprv_free(subId);
         subId = NULL;
 
@@ -940,7 +940,7 @@ table_write_xml(TableResource *res, const char* id, const char* language, UBool
     current = res->fFirst;
 
     while (current != NULL) {
-        res_write_xml(current, sid, language, FALSE, status);
+        res_write_xml(current, sid, language, false, status);
 
         if(U_FAILURE(*status)){
             return;
@@ -1185,7 +1185,7 @@ bundle_write_xml(struct SRBRoot *bundle, const char *outputDir,const char* outpu
     write_utf8_file(out, UnicodeString(bodyStart));
 
 
-    res_write_xml(bundle->fRoot, bundle->fLocale, lang, TRUE, status);
+    res_write_xml(bundle->fRoot, bundle->fLocale, lang, true, status);
 
     tabCount -= 1;
     write_tabs(out);
diff --git a/deps/icu-small/source/tools/icuexportdata/icuexportdata.cpp b/deps/icu-small/source/tools/icuexportdata/icuexportdata.cpp
index 7431ac74ab..cafdfb8847 100644
--- a/deps/icu-small/source/tools/icuexportdata/icuexportdata.cpp
+++ b/deps/icu-small/source/tools/icuexportdata/icuexportdata.cpp
@@ -1,7 +1,15 @@
 // © 2016 and later: Unicode, Inc. and others.
 // License & terms of use: http://www.unicode.org/copyright.html
 
+#include <cstddef>
+#include <cstdint>
+#include <cstdio>
 #include <iostream>
+#include <unicode/localpointer.h>
+#include <unicode/umachine.h>
+#include <unicode/unistr.h>
+#include <unicode/urename.h>
+#include <unicode/uset.h>
 #include <vector>
 #include <algorithm>
 #include "toolutil.h"
@@ -15,7 +23,10 @@
 #include "unicode/uscript.h"
 #include "unicode/putil.h"
 #include "unicode/umutablecptrie.h"
+#include "unicode/ucharstriebuilder.h"
 #include "ucase.h"
+#include "unicode/normalizer2.h"
+#include "normalizer2impl.h"
 #include "writesrc.h"
 
 U_NAMESPACE_USE
@@ -23,10 +34,10 @@ U_NAMESPACE_USE
 /*
  * Global - verbosity
  */
-UBool VERBOSE = FALSE;
-UBool QUIET = FALSE;
+UBool VERBOSE = false;
+UBool QUIET = false;
 
-UBool haveCopyright = TRUE;
+UBool haveCopyright = true;
 UCPTrieType trieType = UCPTRIE_TYPE_SMALL;
 const char* destdir = "";
 
@@ -299,6 +310,642 @@ FILE* prepareOutputFile(const char* basename) {
     return f;
 }
 
+#if !UCONFIG_NO_NORMALIZATION
+
+struct PendingDescriptor {
+    UChar32 scalar;
+    uint32_t descriptor;
+    UBool supplementary;
+};
+
+void writeCanonicalCompositions(USet* backwardCombiningStarters) {
+    IcuToolErrorCode status("icuexportdata: computeCanonicalCompositions");
+    const char* basename = "compositions";
+    FILE* f = prepareOutputFile(basename);
+
+    LocalPointer<UCharsTrieBuilder> backwardBuilder(new UCharsTrieBuilder(status), status);
+
+    const int32_t DECOMPOSITION_BUFFER_SIZE = 20;
+    UChar32 utf32[DECOMPOSITION_BUFFER_SIZE];
+
+    const Normalizer2* nfc = Normalizer2::getNFCInstance(status);
+    for (UChar32 c = 0; c <= 0x10FFFF; ++c) {
+        if (c >= 0xD800 && c < 0xE000) {
+            // Surrogate
+            continue;
+        }
+        UnicodeString decomposition;
+        if (!nfc->getRawDecomposition(c, decomposition)) {
+            continue;
+        }
+        int32_t len = decomposition.toUTF32(utf32, DECOMPOSITION_BUFFER_SIZE, status);
+        if (len != 2) {
+            continue;
+        }
+        UChar32 starter = utf32[0];
+        UChar32 second = utf32[1];
+        UChar32 composite = nfc->composePair(starter, second);
+        if (composite < 0) {
+            continue;
+        }
+        if (c != composite) {
+            status.set(U_INTERNAL_PROGRAM_ERROR);
+            handleError(status, basename);
+        }
+        if (!u_getCombiningClass(second)) {
+            uset_add(backwardCombiningStarters, second);
+        }
+        if (composite >= 0xAC00 && composite <= 0xD7A3) {
+            // Hangul syllable
+            continue;
+        }
+
+        UnicodeString backward;
+        backward.append(second);
+        backward.append(starter);
+        backwardBuilder->add(backward, int32_t(composite), status);
+    }
+    UnicodeString canonicalCompositionTrie;
+    backwardBuilder->buildUnicodeString(USTRINGTRIE_BUILD_SMALL, canonicalCompositionTrie, status);
+
+    usrc_writeArray(f, "compositions = [\n  ", canonicalCompositionTrie.getBuffer(), 16, canonicalCompositionTrie.length(), "  ", "\n]\n");
+    fclose(f);
+    handleError(status, basename);
+}
+
+void writeDecompositionTables(const char* basename, const uint16_t* ptr16, size_t len16, const uint32_t* ptr32, size_t len32) {
+    FILE* f = prepareOutputFile(basename);
+    usrc_writeArray(f, "scalars16 = [\n  ", ptr16, 16, len16, "  ", "\n]\n");
+    usrc_writeArray(f, "scalars32 = [\n  ", ptr32, 32, len32, "  ", "\n]\n");
+    fclose(f);
+}
+
+void writeDecompositionData(const char* basename, uint32_t baseSize16, uint32_t baseSize32, uint32_t supplementSize16, USet* uset, USet* reference, const std::vector<PendingDescriptor>& pendingTrieInsertions, char16_t passthroughCap) {
+    IcuToolErrorCode status("icuexportdata: writeDecompositionData");
+    FILE* f = prepareOutputFile(basename);
+
+    // Zero is a magic number that means the character decomposes to itself.
+    LocalUMutableCPTriePointer builder(umutablecptrie_open(0, 0, status));
+
+    // Iterate backwards to insert lower code points in the trie first in case it matters
+    // for trie block allocation.
+    for (int32_t i = pendingTrieInsertions.size() - 1; i >= 0; --i) {
+        const PendingDescriptor& pending = pendingTrieInsertions[i];
+        uint32_t additional = 0;
+        if (!(pending.descriptor & 0xFFFE0000)) {
+            uint32_t offset = pending.descriptor & 0xFFF;
+            if (!pending.supplementary) {
+                if (offset >= baseSize16) {
+                    // This is a offset to supplementary 16-bit data. We have
+                    // 16-bit base data and 32-bit base data before. However,
+                    // the 16-bit base data length is already part of offset.
+                    additional = baseSize32;
+                }
+            } else {
+                if (offset >= baseSize32) {
+                    // This is an offset to supplementary 32-bit data. We have 16-bit
+                    // base data, 32-bit base data, and 16-bit supplementary data before.
+                    // However, the 32-bit base data length is already part
+                    // of offset.
+                    additional = baseSize16 + supplementSize16;
+                } else {
+                    // This is an offset to 32-bit base data. We have 16-bit
+                    // base data before.
+                    additional = baseSize16;
+                }
+            }
+            if (offset + additional > 0xFFF) {
+                status.set(U_INTERNAL_PROGRAM_ERROR);
+                handleError(status, basename);
+            }
+        }
+        // It turns out it's better to swap the halves compared to the initial
+        // idea in order to put special marker values close to zero so that
+        // an important marker value becomes 1, so it's efficient to compare
+        // "1 or 0". Unfortunately, going through all the code to swap
+        // things is too error prone, so let's do the swapping here in one
+        // place.
+        uint32_t oldTrieValue = pending.descriptor + additional;
+        uint32_t swappedTrieValue = (oldTrieValue >> 16) | (oldTrieValue << 16);
+        umutablecptrie_set(builder.getAlias(), pending.scalar, swappedTrieValue, status);
+    }
+    LocalUCPTriePointer utrie(umutablecptrie_buildImmutable(
+        builder.getAlias(),
+        trieType,
+        UCPTRIE_VALUE_BITS_32,
+        status));
+    handleError(status, basename);
+
+    if (reference) {
+        if (uset_contains(reference, 0xFF9E) || uset_contains(reference, 0xFF9F) || !uset_contains(reference, 0x0345)) {
+            // NFD expectations don't hold. The set must not contain the half-width
+            // kana voicing marks and must contain iota subscript.
+            status.set(U_INTERNAL_PROGRAM_ERROR);
+            handleError(status, basename);
+        }
+
+        USet* halfWidthVoicing = uset_openEmpty();
+        uset_add(halfWidthVoicing, 0xFF9E);
+        uset_add(halfWidthVoicing, 0xFF9F);
+
+        USet* iotaSubscript = uset_openEmpty();
+        uset_add(iotaSubscript, 0x0345);
+
+        uint8_t flags = 0;
+
+        USet* halfWidthCheck = uset_cloneAsThawed(uset);
+        uset_removeAll(halfWidthCheck, reference);
+        if (uset_equals(halfWidthCheck, halfWidthVoicing)) {
+            flags |= 1;
+        } else if (!uset_isEmpty(halfWidthCheck)) {
+            // The result was neither empty nor contained exactly
+            // the two half-width voicing marks. The ICU4X
+            // normalizer doesn't know how to deal with this case.
+            status.set(U_INTERNAL_PROGRAM_ERROR);
+            handleError(status, basename);
+        }
+        uset_close(halfWidthCheck);
+
+        USet* iotaCheck = uset_cloneAsThawed(reference);
+        uset_removeAll(iotaCheck, uset);
+        if (!(uset_equals(iotaCheck, iotaSubscript)) && !uset_isEmpty(iotaCheck)) {
+            // The result was neither empty nor contained exactly
+            // the iota subscript. The ICU4X normalizer doesn't
+            // know how to deal with this case.
+            status.set(U_INTERNAL_PROGRAM_ERROR);
+            handleError(status, basename);
+        }
+        uset_close(halfWidthCheck);
+
+        uset_close(iotaSubscript);
+        uset_close(halfWidthVoicing);
+
+        fprintf(f, "flags = 0x%X\n", flags);
+        fprintf(f, "cap = 0x%X\n", passthroughCap);
+    }
+    fprintf(f, "[trie]\n");
+    usrc_writeUCPTrie(f, "trie", utrie.getAlias(), UPRV_TARGET_SYNTAX_TOML);
+    fclose(f);
+    handleError(status, basename);
+}
+
+// Special marker for the NFKD form of U+FDFA
+const int32_t FDFA_MARKER = 3;
+
+// Special marker for characters whose decomposition starts with a non-starter
+// and the decomposition isn't the character itself.
+const int32_t SPECIAL_NON_STARTER_DECOMPOSITION_MARKER = 2;
+
+// Special marker for starters that decompose to themselves but that may
+// combine backwards under canonical composition
+const int32_t BACKWARD_COMBINING_STARTER_MARKER = 1;
+
+/// Marker that a complex decomposition isn't round-trippable
+/// under re-composition.
+const uint32_t NON_ROUND_TRIP_MARKER = 1;
+
+UBool permissibleBmpPair(UBool knownToRoundTrip, UChar32 c, UChar32 second) {
+    if (knownToRoundTrip) {
+        return true;
+    }
+    // Nuktas, Hebrew presentation forms and polytonic Greek with oxia
+    // are special-cased in ICU4X.
+    if (c >= 0xFB1D && c <= 0xFB4E) {
+        // Hebrew presentation forms
+        return true;
+    }
+    if (c >= 0x1F71 && c <= 0x1FFB) {
+        // Polytonic Greek with oxia
+        return true;
+    }
+    if ((second & 0x7F) == 0x3C && second >= 0x0900 && second <= 0x0BFF) {
+        // Nukta
+        return true;
+    }
+    // To avoid more branchiness, 4 characters that decompose to
+    // a BMP starter followed by a BMP non-starter are excluded
+    // from being encoded directly into the trie value and are
+    // handled as complex decompositions instead. These are:
+    // U+0F76 TIBETAN VOWEL SIGN VOCALIC R
+    // U+0F78 TIBETAN VOWEL SIGN VOCALIC L
+    // U+212B ANGSTROM SIGN
+    // U+2ADC FORKING
+    return false;
+}
+
+// Computes data for canonical decompositions
+void computeDecompositions(const char* basename,
+                           const USet* backwardCombiningStarters,
+                           std::vector<uint16_t>& storage16,
+                           std::vector<uint32_t>& storage32,
+                           USet* decompositionStartsWithNonStarter,
+                           USet* decompositionStartsWithBackwardCombiningStarter,
+                           std::vector<PendingDescriptor>& pendingTrieInsertions,
+                           UChar32& decompositionPassthroughBound,
+                           UChar32& compositionPassthroughBound) {
+    IcuToolErrorCode status("icuexportdata: computeDecompositions");
+    const Normalizer2* mainNormalizer;
+    const Normalizer2* nfdNormalizer = Normalizer2::getNFDInstance(status);
+    const Normalizer2* nfcNormalizer = Normalizer2::getNFCInstance(status);
+    FILE* f = NULL;
+    std::vector<uint32_t> nonRecursive32;
+    LocalUMutableCPTriePointer nonRecursiveBuilder(umutablecptrie_open(0, 0, status));
+
+    if (uprv_strcmp(basename, "nfkd") == 0) {
+        mainNormalizer = Normalizer2::getNFKDInstance(status);
+    } else if (uprv_strcmp(basename, "uts46d") == 0) {
+        mainNormalizer = Normalizer2::getInstance(NULL, "uts46", UNORM2_COMPOSE, status);
+    } else {
+        mainNormalizer = nfdNormalizer;
+        f = prepareOutputFile("decompositionex");
+    }
+
+    // Max length as of Unicode 14 is 4 for NFD. For NFKD the max
+    // is 18 (U+FDFA; special-cased), and the next longest is 8 (U+FDFB).
+    const int32_t LONGEST_ENCODABLE_LENGTH_16 = 9;
+    const int32_t LONGEST_ENCODABLE_LENGTH_32 = 8;
+    const int32_t DECOMPOSITION_BUFFER_SIZE = 20;
+    UChar32 utf32[DECOMPOSITION_BUFFER_SIZE];
+    const int32_t RAW_DECOMPOSITION_BUFFER_SIZE = 2;
+    UChar32 rawUtf32[RAW_DECOMPOSITION_BUFFER_SIZE];
+
+    // Iterate over all scalar values excluding Hangul syllables.
+    //
+    // We go backwards in order to better find overlapping decompositions.
+    //
+    // As of Unicode 14:
+    // Iterate forward without overlap search:
+    // nfd: 16 size: 896, 32 size: 173
+    // nfkd: 16 size: 3854, 32 size: 179
+    //
+    // Iterate forward with overlap search:
+    // nfd: 16 size: 888, 32 size: 173
+    // nfkd: 16 size: 3266, 32 size: 179
+    //
+    // Iterate backward with overlap search:
+    // nfd: 16 size: 776, 32 size: 173
+    // nfkd: 16 size: 2941, 32 size: 179
+    //
+    // UChar32 is signed!
+    for (UChar32 c = 0x10FFFF; c >= 0; --c) {
+        if (c >= 0xAC00 && c <= 0xD7A3) {
+            // Hangul syllable
+            continue;
+        }
+        if (c >= 0xD800 && c < 0xE000) {
+            // Surrogate
+            continue;
+        }
+        UnicodeString src;
+        UnicodeString dst;
+        // True if we're building non-NFD or we're building NFD but
+        // the `c` round trips to NFC.
+        // False if we're building NFD and `c` does not round trip to NFC.
+        UBool nonNfdOrRoundTrips = true;
+        src.append(c);
+        if (mainNormalizer != nfdNormalizer) {
+            UnicodeString inter;
+            mainNormalizer->normalize(src, inter, status);
+            nfdNormalizer->normalize(inter, dst, status);
+        } else {
+            nfdNormalizer->normalize(src, dst, status);
+            UnicodeString nfc;
+            nfcNormalizer->normalize(dst, nfc, status);
+            nonNfdOrRoundTrips = (src == nfc);
+        }
+        int32_t len = dst.toUTF32(utf32, DECOMPOSITION_BUFFER_SIZE, status);
+        if (!len || (len == 1 && utf32[0] == 0xFFFD && c != 0xFFFD)) {
+            // Characters that normalize to nothing or to U+FFFD (without the
+            // input being U+FFFD) in ICU4C's UTS 46 normalization normalize
+            // as in NFD in ICU4X's UTF 46 normalization in the interest
+            // of data size and ICU4X's normalizer being unable to handle
+            // normalizing to nothing.
+            // When UTS 46 is implemented on top of ICU4X, a preprocessing
+            // step is supposed to remove these characters before the
+            // normalization step.
+            if (uprv_strcmp(basename, "uts46d") != 0) {
+                status.set(U_INTERNAL_PROGRAM_ERROR);
+                handleError(status, basename);
+            }
+            nfdNormalizer->normalize(src, dst, status);
+            len = dst.toUTF32(utf32, DECOMPOSITION_BUFFER_SIZE, status);
+            if (!len || (len == 1 && utf32[0] == 0xFFFD && c != 0xFFFD)) {
+                status.set(U_INTERNAL_PROGRAM_ERROR);
+                handleError(status, basename);
+            }
+        }
+        if (len > DECOMPOSITION_BUFFER_SIZE) {
+            status.set(U_INTERNAL_PROGRAM_ERROR);
+            handleError(status, basename);
+        }
+        uint8_t firstCombiningClass = u_getCombiningClass(utf32[0]);
+        bool specialNonStarterDecomposition = false;
+        bool startsWithBackwardCombiningStarter = false;
+        if (firstCombiningClass) {
+            decompositionPassthroughBound = c;
+            compositionPassthroughBound = c;
+            uset_add(decompositionStartsWithNonStarter, c);
+            if (src != dst) {
+                if (c == 0x0340 || c == 0x0341 || c == 0x0343 || c == 0x0344 || c == 0x0F73 || c == 0x0F75 || c == 0x0F81 || c == 0xFF9E || c == 0xFF9F) {
+                    specialNonStarterDecomposition = true;
+                } else {
+                    // A character whose decomposition starts with a non-starter and isn't the same as the character itself and isn't already hard-coded into ICU4X.
+                    status.set(U_INTERNAL_PROGRAM_ERROR);
+                    handleError(status, basename);
+                }
+            }
+        } else if (uset_contains(backwardCombiningStarters, utf32[0])) {
+            compositionPassthroughBound = c;
+            startsWithBackwardCombiningStarter = true;
+            uset_add(decompositionStartsWithBackwardCombiningStarter, c);
+        }
+        if (c != BACKWARD_COMBINING_STARTER_MARKER && len == 1 && utf32[0] == BACKWARD_COMBINING_STARTER_MARKER) {
+            status.set(U_INTERNAL_PROGRAM_ERROR);
+            handleError(status, basename);
+        }
+        if (c != SPECIAL_NON_STARTER_DECOMPOSITION_MARKER && len == 1 && utf32[0] == SPECIAL_NON_STARTER_DECOMPOSITION_MARKER) {
+            status.set(U_INTERNAL_PROGRAM_ERROR);
+            handleError(status, basename);
+        }
+        if (c != FDFA_MARKER && len == 1 && utf32[0] == FDFA_MARKER) {
+            status.set(U_INTERNAL_PROGRAM_ERROR);
+            handleError(status, basename);
+        }
+        if (mainNormalizer != nfdNormalizer) {
+            UnicodeString nfd;
+            nfdNormalizer->normalize(src, nfd, status);
+            if (dst == nfd) {
+                continue;
+            }
+            decompositionPassthroughBound = c;
+            compositionPassthroughBound = c;
+        } else if (firstCombiningClass) {
+            len = 1;
+            if (specialNonStarterDecomposition) {
+                utf32[0] = SPECIAL_NON_STARTER_DECOMPOSITION_MARKER; // magic value
+            } else {
+                // Use the surrogate range to store the canonical combining class
+                utf32[0] = 0xD800 | UChar32(firstCombiningClass);
+            }
+        } else {
+            if (src == dst) {
+                if (startsWithBackwardCombiningStarter) {
+                    pendingTrieInsertions.push_back({c, BACKWARD_COMBINING_STARTER_MARKER << 16, false});
+                }
+                continue;
+            }
+            decompositionPassthroughBound = c;
+            // ICU4X hard-codes ANGSTROM SIGN
+            if (c != 0x212B) {
+                UnicodeString raw;
+                if (!nfdNormalizer->getRawDecomposition(c, raw)) {
+                    // We're always supposed to have a non-recursive decomposition
+                    // if we had a recursive one.
+                    status.set(U_INTERNAL_PROGRAM_ERROR);
+                    handleError(status, basename);
+                }
+                // In addition to actual difference, put the whole range that contains characters
+                // with oxia into the non-recursive trie in order to catch cases where characters
+                // with oxia have singleton decompositions to corresponding characters with tonos.
+                // This way, the run-time decision to fall through can be done on the range
+                // without checking for individual characters inside the range.
+                if (raw != dst || (c >= 0x1F71 && c <= 0x1FFB)) {
+                    int32_t rawLen = raw.toUTF32(rawUtf32, RAW_DECOMPOSITION_BUFFER_SIZE, status);
+                    if (!rawLen) {
+                        status.set(U_INTERNAL_PROGRAM_ERROR);
+                        handleError(status, basename);
+                    }
+                    if (rawLen == 1) {
+                        if (c >= 0xFFFF) {
+                            status.set(U_INTERNAL_PROGRAM_ERROR);
+                            handleError(status, basename);
+                        }
+                        umutablecptrie_set(nonRecursiveBuilder.getAlias(), c, uint32_t(rawUtf32[0]), status);
+                    } else if (rawUtf32[0] <= 0xFFFF && rawUtf32[1] <= 0xFFFF) {
+                        if (!rawUtf32[0] || !rawUtf32[1]) {
+                            status.set(U_INTERNAL_PROGRAM_ERROR);
+                            handleError(status, basename);
+                        }
+                        // Swapped for consistency with the primary trie
+                        uint32_t bmpPair = uint32_t(rawUtf32[1]) << 16 | uint32_t(rawUtf32[0]);
+                        umutablecptrie_set(nonRecursiveBuilder.getAlias(), c, bmpPair, status);
+                    } else {
+                        // Let's add 1 to index to make it always non-zero to distinguish
+                        // it from the default zero.
+                        uint32_t index = nonRecursive32.size() + 1;
+                        nonRecursive32.push_back(uint32_t(rawUtf32[0]));
+                        nonRecursive32.push_back(uint32_t(rawUtf32[1]));
+                        if (index > 0xFFFF) {
+                            status.set(U_INTERNAL_PROGRAM_ERROR);
+                            handleError(status, basename);
+                        }
+                        umutablecptrie_set(nonRecursiveBuilder.getAlias(), c, index << 16, status);
+                    }
+                }
+            }
+        }
+        if (!nonNfdOrRoundTrips) {
+            compositionPassthroughBound = c;
+        }
+        if (len == 1 && utf32[0] <= 0xFFFF) {
+            if (startsWithBackwardCombiningStarter) {
+                if (mainNormalizer == nfdNormalizer) {
+                    // Not supposed to happen in NFD
+                    status.set(U_INTERNAL_PROGRAM_ERROR);
+                    handleError(status, basename);
+                } else if (!((utf32[0] >= 0x1161 && utf32[0] <= 0x1175) || (utf32[0] >= 0x11A8 && utf32[0] <= 0x11C2))) {
+                    // Other than conjoining jamo vowels and trails
+                    // unsupported for non-NFD.
+                    status.set(U_INTERNAL_PROGRAM_ERROR);
+                    handleError(status, basename);
+                }
+            }
+            pendingTrieInsertions.push_back({c, uint32_t(utf32[0]) << 16, false});
+        } else if (len == 2 &&
+                   utf32[0] <= 0xFFFF &&
+                   utf32[1] <= 0xFFFF &&
+                   !u_getCombiningClass(utf32[0]) &&
+                   u_getCombiningClass(utf32[1]) &&
+                   permissibleBmpPair(nonNfdOrRoundTrips, c, utf32[1])) {
+            for (int32_t i = 0; i < len; ++i) {
+                if (((utf32[i] == 0x0345) && (uprv_strcmp(basename, "uts46d") == 0)) || utf32[i] == 0xFF9E || utf32[i] == 0xFF9F) {
+                    // Assert that iota subscript and half-width voicing marks never occur in these
+                    // expansions in the normalization forms where they are special.
+                    status.set(U_INTERNAL_PROGRAM_ERROR);
+                    handleError(status, basename);
+                }
+            }
+            if (startsWithBackwardCombiningStarter) {
+                status.set(U_INTERNAL_PROGRAM_ERROR);
+                handleError(status, basename);
+            }
+            pendingTrieInsertions.push_back({c, (uint32_t(utf32[0]) << 16) | uint32_t(utf32[1]), false});
+        } else {
+            if (startsWithBackwardCombiningStarter) {
+                status.set(U_INTERNAL_PROGRAM_ERROR);
+                handleError(status, basename);
+            }
+
+            UBool supplementary = false;
+            UBool nonInitialStarter = false;
+            for (int32_t i = 0; i < len; ++i) {
+                if (((utf32[i] == 0x0345) && (uprv_strcmp(basename, "uts46d") == 0)) || utf32[i] == 0xFF9E || utf32[i] == 0xFF9F) {
+                    // Assert that iota subscript and half-width voicing marks never occur in these
+                    // expansions in the normalization forms where they are special.
+                    status.set(U_INTERNAL_PROGRAM_ERROR);
+                    handleError(status, basename);
+                }
+
+                if (utf32[i] > 0xFFFF) {
+                    supplementary = true;
+                }
+                if (utf32[i] == 0) {
+                    status.set(U_INTERNAL_PROGRAM_ERROR);
+                    handleError(status, basename);
+                }
+                if (i != 0 && !u_getCombiningClass(utf32[i])) {
+                    nonInitialStarter = true;
+                }
+            }
+            if (!supplementary) {
+                if (len > LONGEST_ENCODABLE_LENGTH_16 || !len || len == 1) {
+                    if (len == 18 && c == 0xFDFA) {
+                        // Special marker for the one character whose decomposition
+                        // is too long.
+                        pendingTrieInsertions.push_back({c, FDFA_MARKER << 16, supplementary});
+                        continue;
+                    } else {
+                        status.set(U_INTERNAL_PROGRAM_ERROR);
+                        handleError(status, basename);
+                    }
+                }
+            } else if (len > LONGEST_ENCODABLE_LENGTH_32 || !len) {
+                status.set(U_INTERNAL_PROGRAM_ERROR);
+                handleError(status, basename);
+            }
+            // Complex decomposition
+            // Format for 16-bit value:
+            // 15..13: length minus two for 16-bit case and length minus one for
+            //         the 32-bit case. Length 8 needs to fit in three bits in
+            //         the 16-bit case, and this way the value is future-proofed
+            //         up to 9 in the 16-bit case. Zero is unused and length one
+            //         in the 16-bit case goes directly into the trie.
+            //     12: 1 if all trailing characters are guaranteed non-starters,
+            //         0 if no guarantees about non-starterness.
+            //         Note: The bit choice is this way around to allow for
+            //         dynamically falling back to not having this but instead
+            //         having one more bit for length by merely choosing
+            //         different masks.
+            //  11..0: Start offset in storage. The offset is to the logical
+            //         sequence of scalars16, scalars32, supplementary_scalars16,
+            //         supplementary_scalars32.
+            uint32_t descriptor = uint32_t(!nonInitialStarter) << 12;
+            if (!supplementary) {
+                descriptor |= (uint32_t(len) - 2) << 13;
+            } else {
+                descriptor |= (uint32_t(len) - 1) << 13;
+            }
+            if (descriptor & 0xFFF) {
+                status.set(U_INTERNAL_PROGRAM_ERROR);
+                handleError(status, basename);
+            }
+            size_t index = 0;
+            bool writeToStorage = false;
+            // Sadly, C++ lacks break and continue by label, so using goto in the
+            // inner loops to break or continue the outer loop.
+            if (!supplementary) {
+                outer16: for (;;) {
+                    if (index == storage16.size()) {
+                        writeToStorage = true;
+                        break;
+                    }
+                    if (storage16[index] == utf32[0]) {
+                        for (int32_t i = 1; i < len; ++i) {
+                            if (storage16[index + i] != uint32_t(utf32[i])) {
+                                ++index;
+                                // continue outer
+                                goto outer16;
+                            }
+                        }
+                        // break outer
+                        goto after;
+                    }
+                    ++index;
+                }
+            } else {
+                outer32: for (;;) {
+                    if (index == storage32.size()) {
+                        writeToStorage = true;
+                        break;
+                    }
+                    if (storage32[index] == uint32_t(utf32[0])) {
+                        for (int32_t i = 1; i < len; ++i) {
+                            if (storage32[index + i] != uint32_t(utf32[i])) {
+                                ++index;
+                                // continue outer
+                                goto outer32;
+                            }
+                        }
+                        // break outer
+                        goto after;
+                    }
+                    ++index;
+                }
+            }
+            after:
+            if (index > 0xFFF) {
+                status.set(U_INTERNAL_PROGRAM_ERROR);
+                handleError(status, basename);
+            }
+            descriptor |= uint32_t(index);
+            if (!descriptor || descriptor > 0xFFFF) {
+                // > 0xFFFF should never happen if the code above is correct.
+                // == 0 should not happen due to the nature of the data.
+                status.set(U_INTERNAL_PROGRAM_ERROR);
+                handleError(status, basename);
+            }
+            if (writeToStorage) {
+                if (!supplementary) {
+                    for (int32_t i = 0; i < len; ++i) {
+                        storage16.push_back(uint16_t(utf32[i]));
+                    }
+                } else {
+                    for (int32_t i = 0; i < len; ++i) {
+                        storage32.push_back(uint32_t(utf32[i]));
+                    }
+                }
+            }
+
+            uint32_t nonRoundTripMarker = 0;
+            if (!nonNfdOrRoundTrips) {
+                nonRoundTripMarker = (NON_ROUND_TRIP_MARKER << 16);
+            }
+            pendingTrieInsertions.push_back({c, descriptor | nonRoundTripMarker, supplementary});
+        }
+    }
+    if (storage16.size() + storage32.size() > 0xFFF) {
+        status.set(U_INTERNAL_PROGRAM_ERROR);
+    }
+    if (f) {
+        usrc_writeArray(f, "scalars32 = [\n  ", nonRecursive32.data(), 32, nonRecursive32.size(), "  ", "\n]\n");
+
+        LocalUCPTriePointer utrie(umutablecptrie_buildImmutable(
+            nonRecursiveBuilder.getAlias(),
+            trieType,
+            UCPTRIE_VALUE_BITS_32,
+            status));
+        handleError(status, basename);
+
+        fprintf(f, "[trie]\n");
+        usrc_writeUCPTrie(f, "trie", utrie.getAlias(), UPRV_TARGET_SYNTAX_TOML);
+
+        fclose(f);
+    }
+    handleError(status, basename);
+}
+
+#endif // !UCONFIG_NO_NORMALIZATION
+
 enum {
     OPT_HELP_H,
     OPT_HELP_QUESTION_MARK,
@@ -341,7 +988,7 @@ void printHelp(FILE* stdfile, const char* program) {
           "options:\n"
           "\t-h or -? or --help  this usage text\n"
           "\t-V or --version     show a version message\n"
-          "\t-m or --mode        mode: currently only 'uprops' and 'ucase', but more may be added\n"
+          "\t-m or --mode        mode: currently only 'uprops', 'ucase', and 'norm', but more may be added\n"
           "\t      --trie-type   set the trie type (small or fast, default small)\n"
           "\t-d or --destdir     destination directory, followed by the path\n"
           "\t      --all         write out all properties known to icuexportdata\n"
@@ -387,6 +1034,46 @@ int exportUprops(int argc, char* argv[]) {
         }
     }
 
+    if (propNames.empty()
+            || options[OPT_HELP_H].doesOccur
+            || options[OPT_HELP_QUESTION_MARK].doesOccur
+            || !options[OPT_MODE].doesOccur) {
+        FILE *stdfile=argc<0 ? stderr : stdout;
+        fprintf(stdfile,
+            "usage: %s -m uprops [-options] [--all | properties...]\n"
+            "\tdump Unicode property data to .toml files\n"
+            "options:\n"
+            "\t-h or -? or --help  this usage text\n"
+            "\t-V or --version     show a version message\n"
+            "\t-m or --mode        mode: currently only 'uprops', but more may be added\n"
+            "\t      --trie-type   set the trie type (small or fast, default small)\n"
+            "\t-d or --destdir     destination directory, followed by the path\n"
+            "\t      --all         write out all properties known to icuexportdata\n"
+            "\t      --index       write an _index.toml summarizing all data exported\n"
+            "\t-c or --copyright   include a copyright notice\n"
+            "\t-v or --verbose     Turn on verbose output\n"
+            "\t-q or --quiet       do not display warnings and progress\n",
+            argv[0]);
+        return argc<0 ? U_ILLEGAL_ARGUMENT_ERROR : U_ZERO_ERROR;
+    }
+
+    const char* mode = options[OPT_MODE].value;
+    if (uprv_strcmp(mode, "uprops") != 0) {
+        fprintf(stderr, "Invalid option for --mode (must be uprops)\n");
+        return U_ILLEGAL_ARGUMENT_ERROR;
+    }
+
+    if (options[OPT_TRIE_TYPE].doesOccur) {
+        if (uprv_strcmp(options[OPT_TRIE_TYPE].value, "fast") == 0) {
+            trieType = UCPTRIE_TYPE_FAST;
+        } else if (uprv_strcmp(options[OPT_TRIE_TYPE].value, "small") == 0) {
+            trieType = UCPTRIE_TYPE_SMALL;
+        } else {
+            fprintf(stderr, "Invalid option for --trie-type (must be small or fast)\n");
+            return U_ILLEGAL_ARGUMENT_ERROR;
+        }
+    }
+
     for (const char* propName : propNames) {
         UProperty propEnum = u_getPropertyEnum(propName);
         if (propEnum == UCHAR_INVALID_CODE) {
@@ -443,7 +1130,7 @@ addRangeToUCPTrie(const void* context, UChar32 start, UChar32 end, uint32_t valu
     umutablecptrie_setRange(ucptrie, start, end, value, status);
     handleError(status, "setRange");
 
-    return TRUE;
+    return true;
 }
 
 int exportCase(int argc, char* argv[]) {
@@ -505,6 +1192,126 @@ int exportCase(int argc, char* argv[]) {
     return 0;
 }
 
+#if !UCONFIG_NO_NORMALIZATION
+
+int exportNorm() {
+    IcuToolErrorCode status("icuexportdata: exportNorm");
+    USet* backwardCombiningStarters = uset_openEmpty();
+    writeCanonicalCompositions(backwardCombiningStarters);
+
+    std::vector<uint16_t> storage16;
+    std::vector<uint32_t> storage32;
+
+    // Note: the USets are not exported. They are only used to check that a new
+    // Unicode version doesn't violate expectations that are hard-coded in ICU4X.
+    USet* nfdDecompositionStartsWithNonStarter = uset_openEmpty();
+    USet* nfdDecompositionStartsWithBackwardCombiningStarter = uset_openEmpty();
+    std::vector<PendingDescriptor> nfdPendingTrieInsertions;
+    UChar32 nfdBound = 0x10FFFF;
+    UChar32 nfcBound = 0x10FFFF;
+    computeDecompositions("nfd",
+                          backwardCombiningStarters,
+                          storage16,
+                          storage32,
+                          nfdDecompositionStartsWithNonStarter,
+                          nfdDecompositionStartsWithBackwardCombiningStarter,
+                          nfdPendingTrieInsertions,
+                          nfdBound,
+                          nfcBound);
+    if (!(nfdBound == 0xC0 && nfcBound == 0x300)) {
+        // Unexpected bounds for NFD/NFC.
+        status.set(U_INTERNAL_PROGRAM_ERROR);
+        handleError(status, "exportNorm");
+    }
+
+    uint32_t baseSize16 = storage16.size();
+    uint32_t baseSize32 = storage32.size();
+
+    USet* nfkdDecompositionStartsWithNonStarter = uset_openEmpty();
+    USet* nfkdDecompositionStartsWithBackwardCombiningStarter = uset_openEmpty();
+    std::vector<PendingDescriptor> nfkdPendingTrieInsertions;
+    UChar32 nfkdBound = 0x10FFFF;
+    UChar32 nfkcBound = 0x10FFFF;
+    computeDecompositions("nfkd",
+                          backwardCombiningStarters,
+                          storage16,
+                          storage32,
+                          nfkdDecompositionStartsWithNonStarter,
+                          nfkdDecompositionStartsWithBackwardCombiningStarter,
+                          nfkdPendingTrieInsertions,
+                          nfkdBound,
+                          nfkcBound);
+    if (!(nfkdBound <= 0xC0 && nfkcBound <= 0x300)) {
+        status.set(U_INTERNAL_PROGRAM_ERROR);
+        handleError(status, "exportNorm");
+    }
+    if (nfkcBound > 0xC0) {
+        if (nfkdBound != 0xC0) {
+            status.set(U_INTERNAL_PROGRAM_ERROR);
+            handleError(status, "exportNorm");
+        }
+    } else {
+        if (nfkdBound != nfkcBound) {
+            status.set(U_INTERNAL_PROGRAM_ERROR);
+            handleError(status, "exportNorm");
+        }
+    }
+
+    USet* uts46DecompositionStartsWithNonStarter = uset_openEmpty();
+    USet* uts46DecompositionStartsWithBackwardCombiningStarter = uset_openEmpty();
+    std::vector<PendingDescriptor> uts46PendingTrieInsertions;
+    UChar32 uts46dBound = 0x10FFFF;
+    UChar32 uts46Bound = 0x10FFFF;
+    computeDecompositions("uts46d",
+                          backwardCombiningStarters,
+                          storage16,
+                          storage32,
+                          uts46DecompositionStartsWithNonStarter,
+                          uts46DecompositionStartsWithBackwardCombiningStarter,
+                          uts46PendingTrieInsertions,
+                          uts46dBound,
+                          uts46Bound);
+    if (!(uts46dBound <= 0xC0 && uts46Bound <= 0x300)) {
+        status.set(U_INTERNAL_PROGRAM_ERROR);
+        handleError(status, "exportNorm");
+    }
+    if (uts46Bound > 0xC0) {
+        if (uts46dBound != 0xC0) {
+            status.set(U_INTERNAL_PROGRAM_ERROR);
+            handleError(status, "exportNorm");
+        }
+    } else {
+        if (uts46dBound != uts46Bound) {
+            status.set(U_INTERNAL_PROGRAM_ERROR);
+            handleError(status, "exportNorm");
+        }
+    }
+
+    uint32_t supplementSize16 = storage16.size() - baseSize16;
+    uint32_t supplementSize32 = storage32.size() - baseSize32;
+
+    writeDecompositionData("nfd", baseSize16, baseSize32, supplementSize16, nfdDecompositionStartsWithNonStarter, nullptr, nfdPendingTrieInsertions, char16_t(nfcBound));
+    writeDecompositionData("nfkd", baseSize16, baseSize32, supplementSize16, nfkdDecompositionStartsWithNonStarter, nfdDecompositionStartsWithNonStarter, nfkdPendingTrieInsertions, char16_t(nfkcBound));
+    writeDecompositionData("uts46d", baseSize16, baseSize32, supplementSize16, uts46DecompositionStartsWithNonStarter, nfdDecompositionStartsWithNonStarter, uts46PendingTrieInsertions, char16_t(uts46Bound));
+
+    writeDecompositionTables("nfdex", storage16.data(), baseSize16, storage32.data(), baseSize32);
+    writeDecompositionTables("nfkdex", storage16.data() + baseSize16, supplementSize16, storage32.data() + baseSize32, supplementSize32);
+
+    uset_close(nfdDecompositionStartsWithNonStarter);
+    uset_close(nfkdDecompositionStartsWithNonStarter);
+    uset_close(uts46DecompositionStartsWithNonStarter);
+
+    uset_close(nfdDecompositionStartsWithBackwardCombiningStarter);
+    uset_close(nfkdDecompositionStartsWithBackwardCombiningStarter);
+    uset_close(uts46DecompositionStartsWithBackwardCombiningStarter);
+
+    uset_close(backwardCombiningStarters);
+    handleError(status, "exportNorm");
+    return 0;
+}
+
+#endif // !UCONFIG_NO_NORMALIZATION
+
 int main(int argc, char* argv[]) {
     U_MAIN_INIT_ARGS(argc, argv);
 
@@ -553,12 +1360,20 @@ int main(int argc, char* argv[]) {
     }
 
     const char* mode = options[OPT_MODE].value;
+    if (uprv_strcmp(mode, "norm") == 0) {
+#if !UCONFIG_NO_NORMALIZATION
+        return exportNorm();
+#else
+    fprintf(stderr, "Exporting normalization data not supported when compiling without normalization support.\n");
+    return U_ILLEGAL_ARGUMENT_ERROR;
+#endif
+    }
     if (uprv_strcmp(mode, "uprops") == 0) {
         return exportUprops(argc, argv);
     } else if (uprv_strcmp(mode, "ucase") == 0) {
         return exportCase(argc, argv);
     }
 
-    fprintf(stderr, "Invalid option for --mode (must be uprops or ucase)\n");
+    fprintf(stderr, "Invalid option for --mode (must be uprops, ucase, or norm)\n");
     return U_ILLEGAL_ARGUMENT_ERROR;
 }
diff --git a/deps/icu-small/source/tools/icupkg/icupkg.cpp b/deps/icu-small/source/tools/icupkg/icupkg.cpp
index 39707946b0..a12e956d19 100644
--- a/deps/icu-small/source/tools/icupkg/icupkg.cpp
+++ b/deps/icu-small/source/tools/icupkg/icupkg.cpp
@@ -278,7 +278,7 @@ main(int argc, char *argv[]) {
     argc=u_parseArgs(argc, argv, UPRV_LENGTHOF(options), options);
     isHelp=options[OPT_HELP_H].doesOccur || options[OPT_HELP_QUESTION_MARK].doesOccur;
     if(isHelp) {
-        printUsage(pname, TRUE);
+        printUsage(pname, true);
         return U_ZERO_ERROR;
     }
 
@@ -287,7 +287,7 @@ main(int argc, char *argv[]) {
         fprintf(stderr, "icupkg: not enough memory\n");
         return U_MEMORY_ALLOCATION_ERROR;
     }
-    isModified=FALSE;
+    isModified=false;
 
     int autoPrefix=0;
     if(options[OPT_AUTO_TOC_PREFIX].doesOccur) {
@@ -297,14 +297,14 @@ main(int argc, char *argv[]) {
     if(options[OPT_AUTO_TOC_PREFIX_WITH_TYPE].doesOccur) {
         if(options[OPT_TOC_PREFIX].doesOccur) {
             fprintf(stderr, "icupkg: --auto_toc_prefix_with_type and also --toc_prefix\n");
-            printUsage(pname, FALSE);
+            printUsage(pname, false);
             return U_ILLEGAL_ARGUMENT_ERROR;
         }
         pkg->setAutoPrefixWithType();
         ++autoPrefix;
     }
     if(argc<2 || 3<argc || autoPrefix>1) {
-        printUsage(pname, FALSE);
+        printUsage(pname, false);
         return U_ILLEGAL_ARGUMENT_ERROR;
     }
 
@@ -324,27 +324,27 @@ main(int argc, char *argv[]) {
     if(0==strcmp(argv[1], "new")) {
         if(autoPrefix) {
             fprintf(stderr, "icupkg: --auto_toc_prefix[_with_type] but no input package\n");
-            printUsage(pname, FALSE);
+            printUsage(pname, false);
             return U_ILLEGAL_ARGUMENT_ERROR;
         }
         inFilename=NULL;
-        isPackage=TRUE;
+        isPackage=true;
     } else {
         inFilename=argv[1];
         if(isPackageName(inFilename)) {
             pkg->readPackage(inFilename);
-            isPackage=TRUE;
+            isPackage=true;
         } else {
             /* swap a single file (icuswap replacement) rather than work on a package */
             pkg->addFile(sourcePath, inFilename);
-            isPackage=FALSE;
+            isPackage=false;
         }
     }
 
     if(argc>=3) {
         outFilename=argv[2];
         if(0!=strcmp(argv[1], argv[2])) {
-            isModified=TRUE;
+            isModified=true;
         }
     } else if(isPackage) {
         outFilename=NULL;
@@ -358,7 +358,7 @@ main(int argc, char *argv[]) {
         const char *type=options[OPT_OUT_TYPE].value;
         if(type[0]==0 || type[1]!=0) {
             /* the type must be exactly one letter */
-            printUsage(pname, FALSE);
+            printUsage(pname, false);
             return U_ILLEGAL_ARGUMENT_ERROR;
         }
         outType=type[0];
@@ -368,7 +368,7 @@ main(int argc, char *argv[]) {
         case 'e':
             break;
         default:
-            printUsage(pname, FALSE);
+            printUsage(pname, false);
             return U_ILLEGAL_ARGUMENT_ERROR;
         }
 
@@ -386,7 +386,7 @@ main(int argc, char *argv[]) {
     }
 
     if(options[OPT_WRITEPKG].doesOccur) {
-        isModified=TRUE;
+        isModified=true;
     }
 
     if(!isPackage) {
@@ -402,7 +402,7 @@ main(int argc, char *argv[]) {
             options[OPT_EXTRACT_LIST].doesOccur ||
             options[OPT_LIST_ITEMS].doesOccur
         ) {
-            printUsage(pname, FALSE);
+            printUsage(pname, false);
             return U_ILLEGAL_ARGUMENT_ERROR;
         }
         if(isModified) {
@@ -427,7 +427,7 @@ main(int argc, char *argv[]) {
         if(0==strcmp(options[OPT_MATCHMODE].value, "noslash")) {
             pkg->setMatchMode(Package::MATCH_NOSLASH);
         } else {
-            printUsage(pname, FALSE);
+            printUsage(pname, false);
             return U_ILLEGAL_ARGUMENT_ERROR;
         }
     }
@@ -439,12 +439,12 @@ main(int argc, char *argv[]) {
             fprintf(stderr, "icupkg: not enough memory\n");
             exit(U_MEMORY_ALLOCATION_ERROR);
         }
-        if(readList(NULL, options[OPT_REMOVE_LIST].value, FALSE, listPkg)) {
+        if(readList(NULL, options[OPT_REMOVE_LIST].value, false, listPkg)) {
             pkg->removeItems(*listPkg);
             delete listPkg;
-            isModified=TRUE;
+            isModified=true;
         } else {
-            printUsage(pname, FALSE);
+            printUsage(pname, false);
             return U_ILLEGAL_ARGUMENT_ERROR;
         }
     }
@@ -461,12 +461,12 @@ main(int argc, char *argv[]) {
             fprintf(stderr, "icupkg: not enough memory\n");
             exit(U_MEMORY_ALLOCATION_ERROR);
         }
-        if(readList(sourcePath, options[OPT_ADD_LIST].value, TRUE, addListPkg)) {
+        if(readList(sourcePath, options[OPT_ADD_LIST].value, true, addListPkg)) {
             pkg->addItems(*addListPkg);
             // delete addListPkg; deferred until after writePackage()
-            isModified=TRUE;
+            isModified=true;
         } else {
-            printUsage(pname, FALSE);
+            printUsage(pname, false);
             return U_ILLEGAL_ARGUMENT_ERROR;
         }
     }
@@ -478,11 +478,11 @@ main(int argc, char *argv[]) {
             fprintf(stderr, "icupkg: not enough memory\n");
             exit(U_MEMORY_ALLOCATION_ERROR);
         }
-        if(readList(NULL, options[OPT_EXTRACT_LIST].value, FALSE, listPkg)) {
+        if(readList(NULL, options[OPT_EXTRACT_LIST].value, false, listPkg)) {
             pkg->extractItems(destPath, *listPkg, outType);
             delete listPkg;
         } else {
-            printUsage(pname, FALSE);
+            printUsage(pname, false);
             return U_ILLEGAL_ARGUMENT_ERROR;
         }
     }
diff --git a/deps/icu-small/source/tools/pkgdata/pkgdata.cpp b/deps/icu-small/source/tools/pkgdata/pkgdata.cpp
index 8de99cb9ce..e1edcd3cac 100644
--- a/deps/icu-small/source/tools/pkgdata/pkgdata.cpp
+++ b/deps/icu-small/source/tools/pkgdata/pkgdata.cpp
@@ -76,7 +76,7 @@ static int32_t pkg_executeOptions(UPKGOptions *o);
 #ifdef WINDOWS_WITH_MSVC
 static int32_t pkg_createWindowsDLL(const char mode, const char *gencFilePath, UPKGOptions *o);
 #endif
-static int32_t pkg_createSymLinks(const char *targetDir, UBool specialHandling=FALSE);
+static int32_t pkg_createSymLinks(const char *targetDir, UBool specialHandling=false);
 static int32_t pkg_installLibrary(const char *installDir, const char *dir, UBool noVersion);
 static int32_t pkg_installFileMode(const char *installDir, const char *srcDir, const char *fileListName);
 static int32_t pkg_installCommonMode(const char *installDir, const char *fileName);
@@ -91,13 +91,13 @@ static void pkg_destroyOptMatchArch(char *optMatchArch);
 #endif
 
 static int32_t pkg_createWithAssemblyCode(const char *targetDir, const char mode, const char *gencFilePath);
-static int32_t pkg_generateLibraryFile(const char *targetDir, const char mode, const char *objectFile, char *command = NULL, UBool specialHandling=FALSE);
+static int32_t pkg_generateLibraryFile(const char *targetDir, const char mode, const char *objectFile, char *command = NULL, UBool specialHandling=false);
 static int32_t pkg_archiveLibrary(const char *targetDir, const char *version, UBool reverseExt);
 static void createFileNames(UPKGOptions *o, const char mode, const char *version_major, const char *version, const char *libName, const UBool reverseExt, UBool noVersion);
 static int32_t initializePkgDataFlags(UPKGOptions *o);
 
 static int32_t pkg_getPkgDataPath(UBool verbose, UOption *option);
-static int runCommand(const char* command, UBool specialHandling=FALSE);
+static int runCommand(const char* command, UBool specialHandling=false);
 
 #define IN_COMMON_MODE(mode) (mode == 'a' || mode == 'c')
 #define IN_DLL_MODE(mode)    (mode == 'd' || mode == 'l')
@@ -275,7 +275,7 @@ main(int argc, char* argv[]) {
     /* FileStream  *out; */
     UPKGOptions  o;
     CharList    *tail;
-    UBool        needsHelp = FALSE;
+    UBool        needsHelp = false;
     UErrorCode   status = U_ZERO_ERROR;
     /* char         tmp[1024]; */
     uint32_t i;
@@ -295,7 +295,7 @@ main(int argc, char* argv[]) {
     many options to just display them all of the time. */
 
     if(options[HELP].doesOccur || options[HELP_QUESTION_MARK].doesOccur) {
-        needsHelp = TRUE;
+        needsHelp = true;
     }
     else {
         if(!needsHelp && argc<0) {
@@ -399,21 +399,21 @@ main(int argc, char* argv[]) {
     }
 
     if(options[QUIET].doesOccur) {
-      o.quiet = TRUE;
+      o.quiet = true;
     } else {
-      o.quiet = FALSE;
+      o.quiet = false;
     }
 
     if(options[PDS_BUILD].doesOccur) {
 #if U_PLATFORM == U_PF_OS390
-      o.pdsbuild = TRUE;
+      o.pdsbuild = true;
 #else
-      o.pdsbuild = FALSE;
+      o.pdsbuild = false;
       fprintf(stdout, "Warning: You are using the -z option which only works on z/OS.\n");
 
 #endif
     } else {
-      o.pdsbuild = FALSE;
+      o.pdsbuild = false;
     }
 
     o.verbose   = options[VERBOSE].doesOccur;
@@ -464,13 +464,13 @@ main(int argc, char* argv[]) {
         o.entryName = o.cShortName;
     }
 
-    o.withoutAssembly = FALSE;
+    o.withoutAssembly = false;
     if (options[WITHOUT_ASSEMBLY].doesOccur) {
 #ifndef BUILD_DATA_WITHOUT_ASSEMBLY
         fprintf(stdout, "Warning: You are using the option to build without assembly code which is not supported on this platform.\n");
         fprintf(stdout, "Warning: This option will be ignored.\n");
 #else
-        o.withoutAssembly = TRUE;
+        o.withoutAssembly = true;
 #endif
     }
 
@@ -594,7 +594,7 @@ static int32_t pkg_executeOptions(UPKGOptions *o) {
         }
         return result;
     } else /* if (IN_COMMON_MODE(mode) || IN_DLL_MODE(mode) || IN_STATIC_MODE(mode)) */ {
-        UBool noVersion = FALSE;
+        UBool noVersion = false;
 
         uprv_strcpy(targetDir, o->targetDir);
         uprv_strcat(targetDir, PKGDATA_FILE_SEP_STRING);
@@ -657,7 +657,7 @@ static int32_t pkg_executeOptions(UPKGOptions *o) {
         } else /* if (IN_STATIC_MODE(mode) || IN_DLL_MODE(mode)) */ {
             char gencFilePath[SMALL_BUFFER_MAX_SIZE] = "";
             char version_major[10] = "";
-            UBool reverseExt = FALSE;
+            UBool reverseExt = false;
 
 #if !defined(WINDOWS_WITH_MSVC) || defined(USING_CYGWIN)
             /* Get the version major number. */
@@ -670,7 +670,7 @@ static int32_t pkg_executeOptions(UPKGOptions *o) {
                     version_major[i] = o->version[i];
                 }
             } else {
-                noVersion = TRUE;
+                noVersion = true;
                 if (IN_DLL_MODE(mode)) {
                     fprintf(stdout, "Warning: Providing a revision number with the -r option is recommended when packaging data in the current mode.\n");
                 }
@@ -678,20 +678,20 @@ static int32_t pkg_executeOptions(UPKGOptions *o) {
 
 #if U_PLATFORM != U_PF_OS400
             /* Certain platforms have different library extension ordering. (e.g. libicudata.##.so vs libicudata.so.##)
-             * reverseExt is FALSE if the suffix should be the version number.
+             * reverseExt is false if the suffix should be the version number.
              */
             if (pkgDataFlags[LIB_EXT_ORDER][uprv_strlen(pkgDataFlags[LIB_EXT_ORDER])-1] == pkgDataFlags[SO_EXT][uprv_strlen(pkgDataFlags[SO_EXT])-1]) {
-                reverseExt = TRUE;
+                reverseExt = true;
             }
 #endif
             /* Using the base libName and version number, generate the library file names. */
             createFileNames(o, mode, version_major, o->version == NULL ? "" : o->version, o->libName, reverseExt, noVersion);
 
-            if ((o->version!=NULL || IN_STATIC_MODE(mode)) && o->rebuild == FALSE && o->pdsbuild == FALSE) {
+            if ((o->version!=NULL || IN_STATIC_MODE(mode)) && o->rebuild == false && o->pdsbuild == false) {
                 /* Check to see if a previous built data library file exists and check if it is the latest. */
                 sprintf(checkLibFile, "%s%s", targetDir, libFileNames[LIB_FILE_VERSION]);
                 if (T_FileStream_file_exists(checkLibFile)) {
-                    if (isFileModTimeLater(checkLibFile, o->srcDir, TRUE) && isFileModTimeLater(checkLibFile, o->options)) {
+                    if (isFileModTimeLater(checkLibFile, o->srcDir, true) && isFileModTimeLater(checkLibFile, o->options)) {
                         if (o->install != NULL) {
                           if(o->verbose) {
                             fprintf(stdout, "# Installing already-built library into %s\n", o->install);
@@ -777,7 +777,7 @@ static int32_t pkg_executeOptions(UPKGOptions *o) {
                         NULL,
                         gencFilePath,
                         sizeof(gencFilePath),
-                        TRUE);
+                        true);
                     pkg_destroyOptMatchArch(optMatchArch);
 #if U_PLATFORM_IS_LINUX_BASED
                     result = pkg_generateLibraryFile(targetDir, mode, gencFilePath);
@@ -1196,7 +1196,7 @@ static int32_t pkg_installLibrary(const char *installDir, const char *targetDir,
     if (noVersion) {
         return result;
     } else {
-        return pkg_createSymLinks(installDir, TRUE);
+        return pkg_createSymLinks(installDir, true);
     }
 }
 
@@ -1365,7 +1365,7 @@ static int32_t pkg_archiveLibrary(const char *targetDir, const char *version, UB
 static int32_t pkg_generateLibraryFile(const char *targetDir, const char mode, const char *objectFile, char *command, UBool specialHandling) {
     int32_t result = 0;
     char *cmd = NULL;
-    UBool freeCmd = FALSE;
+    UBool freeCmd = false;
     int32_t length = 0;
 
     (void)specialHandling;  // Suppress unused variable compiler warnings on platforms where all usage
@@ -1387,7 +1387,7 @@ static int32_t pkg_generateLibraryFile(const char *targetDir, const char mode, c
                 fprintf(stderr, "Unable to allocate memory for command.\n");
                 return -1;
             }
-            freeCmd = TRUE;
+            freeCmd = true;
         }
         sprintf(cmd, "%s %s %s%s %s",
                 pkgDataFlags[AR],
@@ -1421,7 +1421,7 @@ static int32_t pkg_generateLibraryFile(const char *targetDir, const char mode, c
                 fprintf(stderr, "Unable to allocate memory for command.\n");
                 return -1;
             }
-            freeCmd = TRUE;
+            freeCmd = true;
         }
 #if U_PLATFORM == U_PF_MINGW
         sprintf(cmd, "%s%s%s %s -o %s%s %s %s%s %s %s",
@@ -1652,7 +1652,7 @@ static int32_t pkg_createWithoutAssemblyCode(UPKGOptions *o, const char *targetD
 
         if (i == 0) {
             /* The first iteration calls the gencmn function and initializes the buffer. */
-            createCommonDataFile(o->tmpDir, o->shortName, o->entryName, NULL, o->srcDir, o->comment, o->fileListFiles->str, 0, TRUE, o->verbose, gencmnFile);
+            createCommonDataFile(o->tmpDir, o->shortName, o->entryName, NULL, o->srcDir, o->comment, o->fileListFiles->str, 0, true, o->verbose, gencmnFile);
             buffer[0] = 0;
 #ifdef USE_SINGLE_CCODE_FILE
             uprv_strcpy(tempObjectFile, gencmnFile);
@@ -1915,7 +1915,7 @@ static int32_t pkg_createWindowsDLL(const char mode, const char *gencFilePath, U
         );
     }
 
-    result = runCommand(cmd, TRUE);
+    result = runCommand(cmd, true);
     if (result != 0) {
         fprintf(stderr, "Error creating Windows DLL library. Failed command: %s\n", cmd);
     }
@@ -2192,10 +2192,10 @@ static UBool getPkgDataPath(const char *cmd, UBool verbose, char *buf, size_t it
     if (p.isNull() || (n = fread(buf, 1, items-1, p.getAlias())) <= 0) {
         fprintf(stderr, "%s: Error calling '%s'\n", progname, cmd);
         *buf = 0;
-        return FALSE;
+        return false;
     }
 
-    return TRUE;
+    return true;
 }
 #endif
 
@@ -2203,7 +2203,7 @@ static UBool getPkgDataPath(const char *cmd, UBool verbose, char *buf, size_t it
 static int32_t pkg_getPkgDataPath(UBool verbose, UOption *option) {
 #if U_HAVE_POPEN
     static char buf[512] = "";
-    UBool pkgconfigIsValid = TRUE;
+    UBool pkgconfigIsValid = true;
     const char *pkgconfigCmd = "pkg-config --variable=pkglibdir icu-uc";
     const char *icuconfigCmd = "icu-config --incpkgdatafile";
     const char *pkgdata = "pkgdata.inc";
@@ -2214,7 +2214,7 @@ static int32_t pkg_getPkgDataPath(UBool verbose, UOption *option) {
             return -1;
         }
 
-        pkgconfigIsValid = FALSE;
+        pkgconfigIsValid = false;
     }
 
     for (int32_t length = strlen(buf) - 1; length >= 0; length--) {
@@ -2238,7 +2238,7 @@ static int32_t pkg_getPkgDataPath(UBool verbose, UOption *option) {
     buf[strlen(buf)] = 0;
 
     option->value = buf;
-    option->doesOccur = TRUE;
+    option->doesOccur = true;
 
     return 0;
 #else
diff --git a/deps/icu-small/source/tools/toolutil/dbgutil.cpp b/deps/icu-small/source/tools/toolutil/dbgutil.cpp
index 399ec6d16c..7b72d42485 100644
--- a/deps/icu-small/source/tools/toolutil/dbgutil.cpp
+++ b/deps/icu-small/source/tools/toolutil/dbgutil.cpp
@@ -47,7 +47,7 @@ static void udbg_cleanup(void) {
 static UBool tu_cleanup(void)
 {
     udbg_cleanup();
-    return TRUE;
+    return true;
 }
 
 static void udbg_register_cleanup(void) {
diff --git a/deps/icu-small/source/tools/toolutil/filestrm.cpp b/deps/icu-small/source/tools/toolutil/filestrm.cpp
index a926848985..d4bb448a79 100644
--- a/deps/icu-small/source/tools/toolutil/filestrm.cpp
+++ b/deps/icu-small/source/tools/toolutil/filestrm.cpp
@@ -84,9 +84,9 @@ T_FileStream_file_exists(const char* filename)
     FILE* temp = fopen(filename, "r");
     if (temp) {
         fclose(temp);
-        return TRUE;
+        return true;
     } else
-        return FALSE;
+        return false;
 }
 
 /*static const int32_t kEOF;
diff --git a/deps/icu-small/source/tools/toolutil/filetools.cpp b/deps/icu-small/source/tools/toolutil/filetools.cpp
index 0f0e9c5984..08bb9a4aef 100644
--- a/deps/icu-small/source/tools/toolutil/filetools.cpp
+++ b/deps/icu-small/source/tools/toolutil/filetools.cpp
@@ -39,17 +39,17 @@ static int32_t whichFileModTimeIsLater(const char *file1, const char *file2);
 
 /*
  * Goes through the given directory recursive to compare each file's modification time with that of the file given.
- * Also can be given just one file to check against. Default value for isDir is FALSE.
+ * Also can be given just one file to check against. Default value for isDir is false.
  */
 U_CAPI UBool U_EXPORT2
 isFileModTimeLater(const char *filePath, const char *checkAgainst, UBool isDir) {
-    UBool isLatest = TRUE;
+    UBool isLatest = true;
 
     if (filePath == NULL || checkAgainst == NULL) {
-        return FALSE;
+        return false;
     }
 
-    if (isDir == TRUE) {
+    if (isDir == true) {
 #if U_HAVE_DIRENT_H
         DIR *pDir = NULL;
         if ((pDir= opendir(checkAgainst)) != NULL) {
@@ -64,7 +64,7 @@ isFileModTimeLater(const char *filePath, const char *checkAgainst, UBool isDir)
                     newpath.append(dirEntry->d_name, -1, status);
                     if (U_FAILURE(status)) {
                         fprintf(stderr, "%s:%d: %s\n", __FILE__, __LINE__, u_errorName(status));
-                        return FALSE;
+                        return false;
                     }
 
                     if ((subDirp = opendir(newpath.data())) != NULL) {
@@ -77,7 +77,7 @@ isFileModTimeLater(const char *filePath, const char *checkAgainst, UBool isDir)
                     } else {
                         int32_t latest = whichFileModTimeIsLater(filePath, newpath.data());
                         if (latest < 0 || latest == 2) {
-                            isLatest = FALSE;
+                            isLatest = false;
                             break;
                         }
                     }
@@ -87,17 +87,17 @@ isFileModTimeLater(const char *filePath, const char *checkAgainst, UBool isDir)
             closedir(pDir);
         } else {
             fprintf(stderr, "Unable to open directory: %s\n", checkAgainst);
-            return FALSE;
+            return false;
         }
 #endif
     } else {
         if (T_FileStream_file_exists(checkAgainst)) {
             int32_t latest = whichFileModTimeIsLater(filePath, checkAgainst);
             if (latest < 0 || latest == 2) {
-                isLatest = FALSE;
+                isLatest = false;
             }
         } else {
-            isLatest = FALSE;
+            isLatest = false;
         }
     }
 
diff --git a/deps/icu-small/source/tools/toolutil/flagparser.cpp b/deps/icu-small/source/tools/toolutil/flagparser.cpp
index 65513f3611..3fca179db4 100644
--- a/deps/icu-small/source/tools/toolutil/flagparser.cpp
+++ b/deps/icu-small/source/tools/toolutil/flagparser.cpp
@@ -25,7 +25,7 @@ U_CAPI int32_t U_EXPORT2
 parseFlagsFile(const char *fileName, char **flagBuffer, int32_t flagBufferSize, const char ** flagNames, int32_t numOfFlags, UErrorCode *status) {
     char* buffer = NULL;
     char* tmpFlagBuffer = NULL;
-    UBool allocateMoreSpace = FALSE;
+    UBool allocateMoreSpace = false;
     int32_t idx, i;
     int32_t result = 0;
 
@@ -45,7 +45,7 @@ parseFlagsFile(const char *fileName, char **flagBuffer, int32_t flagBufferSize,
 
     do {
         if (allocateMoreSpace) {
-            allocateMoreSpace = FALSE;
+            allocateMoreSpace = false;
             currentBufferSize *= 2;
             uprv_free(buffer);
             buffer = (char *)uprv_malloc(sizeof(char) * currentBufferSize);
@@ -65,7 +65,7 @@ parseFlagsFile(const char *fileName, char **flagBuffer, int32_t flagBufferSize,
 
             if ((int32_t)uprv_strlen(buffer) == (currentBufferSize - 1) && buffer[currentBufferSize-2] != '\n') {
                 /* Allocate more space for buffer if it did not read the entire line */
-                allocateMoreSpace = TRUE;
+                allocateMoreSpace = true;
                 T_FileStream_rewind(f);
                 break;
             } else {
@@ -118,7 +118,7 @@ static int32_t extractFlag(char* buffer, int32_t bufferSize, char* flag, int32_t
     int32_t i, idx = -1;
     char *pBuffer;
     int32_t offset=0;
-    UBool bufferWritten = FALSE;
+    UBool bufferWritten = false;
 
     if (buffer[0] != 0) {
         /* Get the offset (i.e. position after the '=') */
@@ -137,7 +137,7 @@ static int32_t extractFlag(char* buffer, int32_t bufferSize, char* flag, int32_t
 
             flag[i] = pBuffer[i];
             if (i == 0) {
-                bufferWritten = TRUE;
+                bufferWritten = true;
             }
         }
     }
diff --git a/deps/icu-small/source/tools/toolutil/package.cpp b/deps/icu-small/source/tools/toolutil/package.cpp
index f4e428a37e..2e8b5037c0 100644
--- a/deps/icu-small/source/tools/toolutil/package.cpp
+++ b/deps/icu-small/source/tools/toolutil/package.cpp
@@ -382,7 +382,7 @@ U_CDECL_END
 U_NAMESPACE_BEGIN
 
 Package::Package()
-        : doAutoPrefix(FALSE), prefixEndsWithType(FALSE) {
+        : doAutoPrefix(false), prefixEndsWithType(false) {
     inPkgName[0]=0;
     pkgPrefix[0]=0;
     inData=NULL;
@@ -655,7 +655,7 @@ Package::readPackage(const char *filename) {
                 }
                 items[i-1].type=makeTypeLetter(typeEnum);
             }
-            items[i].isDataOwned=FALSE;
+            items[i].isDataOwned=false;
         }
         // set the last item's length
         items[itemCount-1].length=length-ds->readUInt32(inEntries[itemCount-1].dataOffset);
@@ -728,10 +728,10 @@ Package::writePackage(const char *filename, char outType, const char *comment) {
     // one type (TYPE_LE) is bogus
     errorCode=U_ZERO_ERROR;
     i=makeTypeEnum(outType);
-    ds[TYPE_B]= i==TYPE_B ? NULL : udata_openSwapper(TRUE, U_ASCII_FAMILY, outIsBigEndian, outCharset, &errorCode);
-    ds[TYPE_L]= i==TYPE_L ? NULL : udata_openSwapper(FALSE, U_ASCII_FAMILY, outIsBigEndian, outCharset, &errorCode);
+    ds[TYPE_B]= i==TYPE_B ? NULL : udata_openSwapper(true, U_ASCII_FAMILY, outIsBigEndian, outCharset, &errorCode);
+    ds[TYPE_L]= i==TYPE_L ? NULL : udata_openSwapper(false, U_ASCII_FAMILY, outIsBigEndian, outCharset, &errorCode);
     ds[TYPE_LE]=NULL;
-    ds[TYPE_E]= i==TYPE_E ? NULL : udata_openSwapper(TRUE, U_EBCDIC_FAMILY, outIsBigEndian, outCharset, &errorCode);
+    ds[TYPE_E]= i==TYPE_E ? NULL : udata_openSwapper(true, U_EBCDIC_FAMILY, outIsBigEndian, outCharset, &errorCode);
     if(U_FAILURE(errorCode)) {
         fprintf(stderr, "icupkg: udata_openSwapper() failed - %s\n", u_errorName(errorCode));
         exit(errorCode);
@@ -798,7 +798,7 @@ Package::writePackage(const char *filename, char outType, const char *comment) {
     // create the output item names in sorted order, with the package name prepended to each
     for(i=0; i<itemCount; ++i) {
         length=(int32_t)strlen(items[i].name);
-        name=allocString(FALSE, length+prefixLength);
+        name=allocString(false, length+prefixLength);
         memcpy(name, prefix, prefixLength);
         memcpy(name+prefixLength, items[i].name, length+1);
         items[i].name=name;
@@ -810,7 +810,7 @@ Package::writePackage(const char *filename, char outType, const char *comment) {
     offset=basenameOffset+outStringTop;
     if((length=(offset&15))!=0) {
         length=16-length;
-        memset(allocString(FALSE, length-1), 0xaa, length);
+        memset(allocString(false, length-1), 0xaa, length);
         offset+=length;
     }
 
@@ -1021,7 +1021,7 @@ Package::setMatchMode(uint32_t mode) {
 
 void
 Package::addItem(const char *name) {
-    addItem(name, NULL, 0, FALSE, U_ICUDATA_TYPE_LETTER[0]);
+    addItem(name, NULL, 0, false, U_ICUDATA_TYPE_LETTER[0]);
 }
 
 void
@@ -1043,7 +1043,7 @@ Package::addItem(const char *name, uint8_t *data, int32_t length, UBool isDataOw
         memset(items+idx, 0, sizeof(Item));
 
         // copy the item's name
-        items[idx].name=allocString(TRUE, static_cast<int32_t>(strlen(name)));
+        items[idx].name=allocString(true, static_cast<int32_t>(strlen(name)));
         strcpy(items[idx].name, name);
         pathToTree(items[idx].name);
     } else {
@@ -1070,7 +1070,7 @@ Package::addFile(const char *filesPath, const char *name) {
 
     data=readFile(filesPath, name, length, type);
     // readFile() exits the tool if it fails
-    addItem(name, data, length, TRUE, type);
+    addItem(name, data, length, true, type);
 }
 
 void
@@ -1079,7 +1079,7 @@ Package::addItems(const Package &listPkg) {
     int32_t i;
 
     for(pItem=listPkg.items, i=0; i<listPkg.itemCount; ++pItem, ++i) {
-        addItem(pItem->name, pItem->data, pItem->length, FALSE, pItem->type);
+        addItem(pItem->name, pItem->data, pItem->length, false, pItem->type);
     }
 }
 
@@ -1224,14 +1224,14 @@ Package::checkDependency(void *context, const char *itemName, const char *target
     // check dependency: make sure the target item is in the package
     Package *me=(Package *)context;
     if(me->findItem(targetName)<0) {
-        me->isMissingItems=TRUE;
+        me->isMissingItems=true;
         fprintf(stderr, "Item %s depends on missing item %s\n", itemName, targetName);
     }
 }
 
 UBool
 Package::checkDependencies() {
-    isMissingItems=FALSE;
+    isMissingItems=false;
     enumDependencies(this, checkDependency);
     return (UBool)!isMissingItems;
 }
@@ -1274,7 +1274,7 @@ Package::allocString(UBool in, int32_t length) {
 void
 Package::sortItems() {
     UErrorCode errorCode=U_ZERO_ERROR;
-    uprv_sortArray(items, itemCount, (int32_t)sizeof(Item), compareItems, NULL, FALSE, &errorCode);
+    uprv_sortArray(items, itemCount, (int32_t)sizeof(Item), compareItems, NULL, false, &errorCode);
     if(U_FAILURE(errorCode)) {
         fprintf(stderr, "icupkg: sorting item names failed - %s\n", u_errorName(errorCode));
         exit(errorCode);
diff --git a/deps/icu-small/source/tools/toolutil/pkg_genc.cpp b/deps/icu-small/source/tools/toolutil/pkg_genc.cpp
index 17347bac5d..1f81bf94a4 100644
--- a/deps/icu-small/source/tools/toolutil/pkg_genc.cpp
+++ b/deps/icu-small/source/tools/toolutil/pkg_genc.cpp
@@ -252,11 +252,11 @@ checkAssemblyHeaderName(const char* optAssembly) {
         if (uprv_strcmp(optAssembly, assemblyHeader[idx].name) == 0) {
             assemblyHeaderIndex = idx;
             hexType = assemblyHeader[idx].hexType; /* set the hex type */
-            return TRUE;
+            return true;
         }
     }
 
-    return FALSE;
+    return false;
 }
 
 
@@ -778,7 +778,7 @@ getArchitecture(uint16_t *pCPU, uint16_t *pBits, UBool *pIsBigEndian, const char
         *pIsBigEndian=(UBool)(U_IS_BIG_ENDIAN ? ELFDATA2MSB : ELFDATA2LSB);
 #elif U_PLATFORM_HAS_WIN32_API
         // Windows always runs in little-endian mode.
-        *pIsBigEndian = FALSE;
+        *pIsBigEndian = false;
 
         // Note: The various _M_<arch> macros are predefined by the MSVC compiler based
         // on the target compilation architecture.
@@ -865,7 +865,7 @@ getArchitecture(uint16_t *pCPU, uint16_t *pBits, UBool *pIsBigEndian, const char
      */
     *pBits= *pCPU==IMAGE_FILE_MACHINE_I386 ? 32 : 64;
     /* Windows always runs on little-endian CPUs. */
-    *pIsBigEndian=FALSE;
+    *pIsBigEndian=false;
 #else
 #   error "Unknown platform for CAN_GENERATE_OBJECTS."
 #endif
diff --git a/deps/icu-small/source/tools/toolutil/pkg_icu.cpp b/deps/icu-small/source/tools/toolutil/pkg_icu.cpp
index ce0bfc215b..06ddbb89b8 100644
--- a/deps/icu-small/source/tools/toolutil/pkg_icu.cpp
+++ b/deps/icu-small/source/tools/toolutil/pkg_icu.cpp
@@ -42,10 +42,10 @@ isListTextFile(const char *listname) {
         suffix=listFileSuffixes[i].suffix;
         length=listFileSuffixes[i].length;
         if((listNameEnd-listname)>length && 0==memcmp(listNameEnd-length, suffix, length)) {
-            return TRUE;
+            return true;
         }
     }
-    return FALSE;
+    return false;
 }
 
 /*
@@ -163,7 +163,7 @@ writePackageDatFile(const char *outFilename, const char *outComment, const char
         }
         pkg = ownedPkg.getAlias();
 
-        addListPkg.adoptInstead(readList(sourcePath, addList, TRUE, NULL));
+        addListPkg.adoptInstead(readList(sourcePath, addList, true, NULL));
         if(addListPkg.isValid()) {
             pkg->addItems(*addListPkg);
         } else {
diff --git a/deps/icu-small/source/tools/toolutil/pkgitems.cpp b/deps/icu-small/source/tools/toolutil/pkgitems.cpp
index af45867797..79e076c0c2 100644
--- a/deps/icu-small/source/tools/toolutil/pkgitems.cpp
+++ b/deps/icu-small/source/tools/toolutil/pkgitems.cpp
@@ -277,44 +277,46 @@ checkAlias(const char *itemName,
  * Enumerate one resource item and its children and extract dependencies from
  * aliases.
  */
-static void
+static UBool
 ures_enumDependencies(const char *itemName,
                       const ResourceData *pResData,
                       Resource res, const char *inKey, const char *parentKey, int32_t depth,
                       CheckDependency check, void *context,
                       Package *pkg,
                       UErrorCode *pErrorCode) {
+    UBool doCheckParent = true;  // always remains true if depth>1
     switch(res_getPublicType(res)) {
     case URES_STRING:
-        {
-            UBool useResSuffix = TRUE;
-            // Check for %%ALIAS
-            if(depth==1 && inKey!=NULL) {
-                if(0!=strcmp(inKey, "%%ALIAS")) {
-                    break;
-                }
-            }
-            // Check for %%DEPENDENCY
-            else if(depth==2 && parentKey!=NULL) {
-                if(0!=strcmp(parentKey, "%%DEPENDENCY")) {
-                    break;
-                }
-                useResSuffix = FALSE;
-            } else {
-                // we ignore all other strings
-                break;
-            }
+        if(depth==1 && inKey!=NULL &&
+                (0==strcmp(inKey, "%%ALIAS") || 0==strcmp(inKey, "%%Parent"))) {
+            // Top-level %%ALIAS string:
+            //   The alias resource bundle will be used instead of this one.
+            // Top-level %%Parent string:
+            //   We use this bundle as well as the explicit parent bundle.
+            // Either way, the truncation parent is ignored.
+            doCheckParent = false;
+            // No tracing: build tool
             int32_t length;
+            const UChar *alias=res_getStringNoTrace(pResData, res, &length);
+            checkAlias(itemName, res, alias, length, /*useResSuffix=*/ true,
+                       check, context, pErrorCode);
+            // If there is a %%ALIAS, then there should be nothing else in this resource bundle.
+        } else if(depth==2 && parentKey!=NULL && 0==strcmp(parentKey, "%%DEPENDENCY")) {
+            // Second-level %%DEPENDENCY string:
+            // Explicit declaration of a dependency of this item on that one.
             // No tracing: build tool
+            int32_t length;
             const UChar *alias=res_getStringNoTrace(pResData, res, &length);
-            checkAlias(itemName, res, alias, length, useResSuffix, check, context, pErrorCode);
+            checkAlias(itemName, res, alias, length, /*useResSuffix=*/ false,
+                       check, context, pErrorCode);
         }
+        // we ignore all other strings
         break;
     case URES_ALIAS:
         {
             int32_t length;
             const UChar *alias=res_getAlias(pResData, res, &length);
-            checkAlias(itemName, res, alias, length, TRUE, check, context, pErrorCode);
+            checkAlias(itemName, res, alias, length, true, check, context, pErrorCode);
         }
         break;
     case URES_TABLE:
@@ -324,7 +326,9 @@ ures_enumDependencies(const char *itemName,
             for(int32_t i=0; i<count; ++i) {
                 const char *itemKey;
                 Resource item=res_getTableItemByIndex(pResData, res, i, &itemKey);
-                ures_enumDependencies(
+                // This doCheckParent return value is needed to
+                // propagate the possible false value from depth=1 to depth=0.
+                doCheckParent &= ures_enumDependencies(
                         itemName, pResData,
                         item, itemKey,
                         inKey, depth+1,
@@ -363,6 +367,7 @@ ures_enumDependencies(const char *itemName,
     default:
         break;
     }
+    return doCheckParent;
 }
 
 static void
@@ -380,17 +385,6 @@ ures_enumDependencies(const char *itemName, const UDataInfo *pInfo,
         exit(U_UNSUPPORTED_ERROR);
     }
 
-    /*
-     * if the bundle attributes are present and the nofallback flag is not set,
-     * then add the parent bundle as a dependency
-     */
-    if(pInfo->formatVersion[0]>1 || (pInfo->formatVersion[0]==1 && pInfo->formatVersion[1]>=1)) {
-        if(!resData.noFallback) {
-            /* this bundle participates in locale fallback */
-            checkParent(itemName, check, context, pErrorCode);
-        }
-    }
-
     icu::NativeItem nativePool;
 
     if(resData.usesPoolBundle) {
@@ -431,12 +425,26 @@ ures_enumDependencies(const char *itemName, const UDataInfo *pInfo,
         }
     }
 
-    ures_enumDependencies(
+    UBool doCheckParent = ures_enumDependencies(
         itemName, &resData,
         resData.rootRes, NULL, NULL, 0,
         check, context,
         pkg,
         pErrorCode);
+    if(!doCheckParent) {
+        return;
+    }
+
+    /*
+     * if the bundle attributes are present and the nofallback flag is not set,
+     * then add the parent bundle as a dependency
+     */
+    if(pInfo->formatVersion[0]>1 || (pInfo->formatVersion[0]==1 && pInfo->formatVersion[1]>=1)) {
+        if(!resData.noFallback) {
+            /* this bundle participates in locale fallback */
+            checkParent(itemName, check, context, pErrorCode);
+        }
+    }
 }
 
 // get dependencies from conversion tables --------------------------------- ***
diff --git a/deps/icu-small/source/tools/toolutil/ppucd.cpp b/deps/icu-small/source/tools/toolutil/ppucd.cpp
index bf90588407..b31755947d 100644
--- a/deps/icu-small/source/tools/toolutil/ppucd.cpp
+++ b/deps/icu-small/source/tools/toolutil/ppucd.cpp
@@ -211,7 +211,7 @@ PreparsedUCD::getProps(UnicodeSet &newValues, UErrorCode &errorCode) {
     UChar32 start, end;
     if(!parseCodePointRange(field, start, end, errorCode)) { return NULL; }
     UniProps *props;
-    UBool insideBlock=FALSE;  // TRUE if cp or unassigned range inside the block range.
+    UBool insideBlock=false;  // true if cp or unassigned range inside the block range.
     switch(lineType) {
     case DEFAULTS_LINE:
         // Should occur before any block/cp/unassigned line.
@@ -247,7 +247,7 @@ PreparsedUCD::getProps(UnicodeSet &newValues, UErrorCode &errorCode) {
     case CP_LINE:
     case UNASSIGNED_LINE:
         if(blockProps.start<=start && end<=blockProps.end) {
-            insideBlock=TRUE;
+            insideBlock=true;
             if(lineType==CP_LINE) {
                 // Code point range fully inside the last block inherits the block properties.
                 cpProps=blockProps;
@@ -313,7 +313,7 @@ static const struct {
     { "Turkic_Case_Folding", PPUCD_TURKIC_CASE_FOLDING }
 };
 
-// Returns TRUE for "ok to continue parsing fields".
+// Returns true for "ok to continue parsing fields".
 UBool
 PreparsedUCD::parseProperty(UniProps &props, const char *field, UnicodeSet &newValues,
                             UErrorCode &errorCode) {
@@ -328,7 +328,7 @@ PreparsedUCD::parseProperty(UniProps &props, const char *field, UnicodeSet &newV
                     "enum-property syntax '%s' on line %ld\n",
                     field, (long)lineNumber);
             errorCode=U_PARSE_ERROR;
-            return FALSE;
+            return false;
         }
         binaryValue=0;
         ++p;
@@ -346,7 +346,7 @@ PreparsedUCD::parseProperty(UniProps &props, const char *field, UnicodeSet &newV
         for(int32_t i=0;; ++i) {
             if(i==UPRV_LENGTHOF(ppucdProperties)) {
                 // Ignore unknown property names.
-                return TRUE;
+                return true;
             }
             if(0==uprv_stricmp(p, ppucdProperties[i].name)) {
                 prop=ppucdProperties[i].prop;
@@ -498,23 +498,23 @@ PreparsedUCD::parseProperty(UniProps &props, const char *field, UnicodeSet &newV
             break;
         default:
             // Ignore unhandled properties.
-            return TRUE;
+            return true;
         }
     }
     if(U_SUCCESS(errorCode)) {
         newValues.add((UChar32)prop);
-        return TRUE;
+        return true;
     } else {
-        return FALSE;
+        return false;
     }
 }
 
 UBool
 PreparsedUCD::getRangeForAlgNames(UChar32 &start, UChar32 &end, UErrorCode &errorCode) {
-    if(U_FAILURE(errorCode)) { return FALSE; }
+    if(U_FAILURE(errorCode)) { return false; }
     if(lineType!=ALG_NAMES_RANGE_LINE) {
         errorCode=U_ILLEGAL_ARGUMENT_ERROR;
-        return FALSE;
+        return false;
     }
     firstField();
     const char *field=nextField();
@@ -525,7 +525,7 @@ PreparsedUCD::getRangeForAlgNames(UChar32 &start, UChar32 &end, UErrorCode &erro
                 "(no second field) on line %ld\n",
                 (long)lineNumber);
         errorCode=U_PARSE_ERROR;
-        return FALSE;
+        return false;
     }
     return parseCodePointRange(field, start, end, errorCode);
 }
@@ -552,11 +552,11 @@ PreparsedUCD::parseCodePointRange(const char *s, UChar32 &start, UChar32 &end, U
         fprintf(stderr,
                 "error in preparsed UCD: '%s' is not a valid code point range on line %ld\n",
                 s, (long)lineNumber);
-        return FALSE;
+        return false;
     }
     start=(UChar32)st;
     end=(UChar32)e;
-    return TRUE;
+    return true;
 }
 
 void
diff --git a/deps/icu-small/source/tools/toolutil/ppucd.h b/deps/icu-small/source/tools/toolutil/ppucd.h
index 7c9c34af6f..bf455d0e14 100644
--- a/deps/icu-small/source/tools/toolutil/ppucd.h
+++ b/deps/icu-small/source/tools/toolutil/ppucd.h
@@ -120,7 +120,7 @@ public:
     /** Returns the Unicode version when or after the UNICODE_VERSION_LINE has been read. */
     const UVersionInfo &getUnicodeVersion() const { return ucdVersion; }
 
-    /** Returns TRUE if the current line has property values. */
+    /** Returns true if the current line has property values. */
     UBool lineHasPropertyValues() const {
         return DEFAULTS_LINE<=lineType && lineType<=UNASSIGNED_LINE;
     }
diff --git a/deps/icu-small/source/tools/toolutil/toolutil.cpp b/deps/icu-small/source/tools/toolutil/toolutil.cpp
index a9dc37377a..070c6034af 100644
--- a/deps/icu-small/source/tools/toolutil/toolutil.cpp
+++ b/deps/icu-small/source/tools/toolutil/toolutil.cpp
@@ -204,9 +204,9 @@ U_CAPI UBool U_EXPORT2
 uprv_fileExists(const char *file) {
   struct stat stat_buf;
   if (stat(file, &stat_buf) == 0) {
-    return TRUE;
+    return true;
   } else {
-    return FALSE;
+    return false;
   }
 }
 #endif
@@ -351,7 +351,7 @@ utm_hasCapacity(UToolMemory *mem, int32_t capacity) {
         mem->capacity=newCapacity;
     }
 
-    return TRUE;
+    return true;
 }
 
 U_CAPI void * U_EXPORT2
diff --git a/deps/icu-small/source/tools/toolutil/toolutil.h b/deps/icu-small/source/tools/toolutil/toolutil.h
index 1c9f06758f..98b2155551 100644
--- a/deps/icu-small/source/tools/toolutil/toolutil.h
+++ b/deps/icu-small/source/tools/toolutil/toolutil.h
@@ -23,13 +23,6 @@
 
 #include "unicode/utypes.h"
 
-#ifndef TRUE
-#   define TRUE  1
-#endif
-#ifndef FALSE
-#   define FALSE 0
-#endif
-
 #ifdef __cplusplus
 
 #include "unicode/errorcode.h"
@@ -118,9 +111,9 @@ uprv_mkdir(const char *pathname, UErrorCode *status);
 
 #if !UCONFIG_NO_FILE_IO
 /**
- * Return TRUE if the named item exists
+ * Return true if the named item exists
  * @param file filename
- * @return TRUE if named item (file, dir, etc) exists, FALSE otherwise
+ * @return true if named item (file, dir, etc) exists, false otherwise
  */
 U_CAPI UBool U_EXPORT2
 uprv_fileExists(const char *file);
diff --git a/deps/icu-small/source/tools/toolutil/ucbuf.cpp b/deps/icu-small/source/tools/toolutil/ucbuf.cpp
index c8e906f2d5..f269748205 100644
--- a/deps/icu-small/source/tools/toolutil/ucbuf.cpp
+++ b/deps/icu-small/source/tools/toolutil/ucbuf.cpp
@@ -73,7 +73,7 @@ ucbuf_autodetect_fs(FileStream* in, const char** cp, UConverter** conv, int32_t*
 
     if(*cp==NULL){
         *conv =NULL;
-        return FALSE;
+        return false;
     }
 
     /* open the converter for the detected Unicode charset */
@@ -82,7 +82,7 @@ ucbuf_autodetect_fs(FileStream* in, const char** cp, UConverter** conv, int32_t*
     /* convert and ignore initial U+FEFF, and the buffer overflow */
     pTarget = target;
     pStart = start;
-    ucnv_toUnicode(*conv, &pTarget, target+1, &pStart, start+*signatureLength, NULL, FALSE, error);
+    ucnv_toUnicode(*conv, &pTarget, target+1, &pStart, start+*signatureLength, NULL, false, error);
     *signatureLength = (int32_t)(pStart - start);
     if(*error==U_BUFFER_OVERFLOW_ERROR) {
         *error=U_ZERO_ERROR;
@@ -94,40 +94,40 @@ ucbuf_autodetect_fs(FileStream* in, const char** cp, UConverter** conv, int32_t*
     }
 
 
-    return TRUE; 
+    return true; 
 }
 static UBool ucbuf_isCPKnown(const char* cp){
     if(ucnv_compareNames("UTF-8",cp)==0){
-        return TRUE;
+        return true;
     }
     if(ucnv_compareNames("UTF-16BE",cp)==0){
-        return TRUE;
+        return true;
     }
     if(ucnv_compareNames("UTF-16LE",cp)==0){
-        return TRUE;
+        return true;
     }
     if(ucnv_compareNames("UTF-16",cp)==0){
-        return TRUE;
+        return true;
     }
     if(ucnv_compareNames("UTF-32",cp)==0){
-        return TRUE;
+        return true;
     }
     if(ucnv_compareNames("UTF-32BE",cp)==0){
-        return TRUE;
+        return true;
     }
     if(ucnv_compareNames("UTF-32LE",cp)==0){
-        return TRUE;
+        return true;
     }
     if(ucnv_compareNames("SCSU",cp)==0){
-        return TRUE;
+        return true;
     }
     if(ucnv_compareNames("BOCU-1",cp)==0){
-        return TRUE;
+        return true;
     }
     if(ucnv_compareNames("UTF-7",cp)==0){
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 U_CAPI FileStream * U_EXPORT2
@@ -234,7 +234,7 @@ ucbuf_fillucbuf( UCHARBUF* buf,UErrorCode* error){
             /* use erro1 to preserve the error code */
             UErrorCode error1 =U_ZERO_ERROR;
             
-            if( buf->showWarning==TRUE){
+            if( buf->showWarning==true){
                 fprintf(stderr,"\n###WARNING: Encountered abnormal bytes while"
                                " converting input stream to target encoding: %s\n",
                                u_errorName(*error));
@@ -263,7 +263,7 @@ ucbuf_fillucbuf( UCHARBUF* buf,UErrorCode* error){
             /* null terminate the buffer */
             postContext[stop-start] = 0;
 
-            if(buf->showWarning ==TRUE){
+            if(buf->showWarning ==true){
                 /* print out the context */
                 fprintf(stderr,"\tPre-context: %s\n",preContext);
                 fprintf(stderr,"\tContext: %s\n",context);
@@ -324,7 +324,7 @@ ucbuf_fillucbuf( UCHARBUF* buf,UErrorCode* error){
 U_CAPI int32_t U_EXPORT2
 ucbuf_getc(UCHARBUF* buf,UErrorCode* error){
     if(error==NULL || U_FAILURE(*error)){
-        return FALSE;
+        return false;
     }
     if(buf->currentPos>=buf->bufLimit){
         if(buf->remaining==0){
@@ -344,7 +344,7 @@ U_CAPI int32_t U_EXPORT2
 ucbuf_getc32(UCHARBUF* buf,UErrorCode* error){
     int32_t retVal = (int32_t)U_EOF;
     if(error==NULL || U_FAILURE(*error)){
-        return FALSE;
+        return false;
     }
     if(buf->currentPos+1>=buf->bufLimit){
         if(buf->remaining==0){
@@ -377,7 +377,7 @@ ucbuf_getcx32(UCHARBUF* buf,UErrorCode* error) {
     int32_t offset;
     UChar32 c32,c1,c2;
     if(error==NULL || U_FAILURE(*error)){
-        return FALSE;
+        return false;
     }
     /* Fill the buffer if it is empty */
     if (buf->currentPos >=buf->bufLimit-2) {
@@ -457,7 +457,7 @@ ucbuf_open(const char* fileName,const char** cp,UBool showWarning, UBool buffere
     }
     if(cp==NULL || fileName==NULL){
         *error = U_ILLEGAL_ARGUMENT_ERROR;
-        return FALSE;
+        return NULL;
     }
     if (!uprv_strcmp(fileName, "-")) {
         in = T_FileStream_stdin();
@@ -495,7 +495,7 @@ ucbuf_open(const char* fileName,const char** cp,UBool showWarning, UBool buffere
             return NULL;
         }
         
-        if((buf->conv==NULL) && (buf->showWarning==TRUE)){
+        if((buf->conv==NULL) && (buf->showWarning==true)){
             fprintf(stderr,"###WARNING: No converter defined. Using codepage of system.\n");
         }
         buf->remaining=fileSize-buf->signatureLength;
@@ -597,7 +597,7 @@ ucbuf_rewind(UCHARBUF* buf,UErrorCode* error){
             /* convert and ignore initial U+FEFF, and the buffer overflow */
             pTarget = target;
             pStart = start;
-            ucnv_toUnicode(buf->conv, &pTarget, target+1, &pStart, start+numRead, NULL, FALSE, error);
+            ucnv_toUnicode(buf->conv, &pTarget, target+1, &pStart, start+numRead, NULL, false, error);
             if(*error==U_BUFFER_OVERFLOW_ERROR) {
                 *error=U_ZERO_ERROR;
             }
@@ -706,9 +706,9 @@ static UBool ucbuf_isCharNewLine(UChar c){
     case 0x0085: /* NEL */
     case 0x2028: /* LS  */
     case 0x2029: /* PS  */
-        return TRUE;
+        return true;
     default:
-        return FALSE;
+        return false;
     }
 }
 
diff --git a/deps/icu-small/source/tools/toolutil/ucbuf.h b/deps/icu-small/source/tools/toolutil/ucbuf.h
index 9214d41971..117920b794 100644
--- a/deps/icu-small/source/tools/toolutil/ucbuf.h
+++ b/deps/icu-small/source/tools/toolutil/ucbuf.h
@@ -52,7 +52,7 @@ struct  ULine {
  *                  If *codepage is NULL on input the API will try to autodetect
  *                  popular Unicode encodings
  * @param showWarning Flag to print out warnings to STDOUT
- * @param buffered  If TRUE performs a buffered read of the input file. If FALSE reads
+ * @param buffered  If true performs a buffered read of the input file. If false reads
  *                  the whole file into memory and converts it.
  * @param err is a pointer to a valid <code>UErrorCode</code> value. If this value
  *        indicates a failure on entry, the function will immediately return.
diff --git a/deps/icu-small/source/tools/toolutil/ucm.cpp b/deps/icu-small/source/tools/toolutil/ucm.cpp
index 28c3f3f4f8..f2f3a66e70 100644
--- a/deps/icu-small/source/tools/toolutil/ucm.cpp
+++ b/deps/icu-small/source/tools/toolutil/ucm.cpp
@@ -182,11 +182,11 @@ compareMappings(UCMTable *lTable, const UCMapping *l,
         /* Unicode then bytes */
         result=compareUnicode(lTable, l, rTable, r);
         if(result==0) {
-            result=compareBytes(lTable, l, rTable, r, FALSE); /* not lexically, like canonucm */
+            result=compareBytes(lTable, l, rTable, r, false); /* not lexically, like canonucm */
         }
     } else {
         /* bytes then Unicode */
-        result=compareBytes(lTable, l, rTable, r, TRUE); /* lexically, for builder */
+        result=compareBytes(lTable, l, rTable, r, true); /* lexically, for builder */
         if(result==0) {
             result=compareUnicode(lTable, l, rTable, r);
         }
@@ -205,7 +205,7 @@ static int32_t  U_CALLCONV
 compareMappingsUnicodeFirst(const void *context, const void *left, const void *right) {
     return compareMappings(
         (UCMTable *)context, (const UCMapping *)left,
-        (UCMTable *)context, (const UCMapping *)right, TRUE);
+        (UCMTable *)context, (const UCMapping *)right, true);
 }
 
 /* sorting by bytes first sorts the reverseMap; use indirection to mappings */
@@ -215,7 +215,7 @@ compareMappingsBytesFirst(const void *context, const void *left, const void *rig
     int32_t l=*(const int32_t *)left, r=*(const int32_t *)right;
     return compareMappings(
         table, table->mappings+l,
-        table, table->mappings+r, FALSE);
+        table, table->mappings+r, false);
 }
 U_CDECL_END
 
@@ -233,7 +233,7 @@ ucm_sortTable(UCMTable *t) {
     /* 1. sort by Unicode first */
     uprv_sortArray(t->mappings, t->mappingsLength, sizeof(UCMapping),
                    compareMappingsUnicodeFirst, t,
-                   FALSE, &errorCode);
+                   false, &errorCode);
 
     /* build the reverseMap */
     if(t->reverseMap==NULL) {
@@ -256,7 +256,7 @@ ucm_sortTable(UCMTable *t) {
     /* 2. sort reverseMap by mappings bytes first */
     uprv_sortArray(t->reverseMap, t->mappingsLength, sizeof(int32_t),
                    compareMappingsBytesFirst, t,
-                   FALSE, &errorCode);
+                   false, &errorCode);
 
     if(U_FAILURE(errorCode)) {
         fprintf(stderr, "ucm error: sortTable()/uprv_sortArray() fails - %s\n",
@@ -264,7 +264,7 @@ ucm_sortTable(UCMTable *t) {
         exit(errorCode);
     }
 
-    t->isSorted=TRUE;
+    t->isSorted=true;
 }
 
 /*
@@ -296,7 +296,7 @@ ucm_moveMappings(UCMTable *base, UCMTable *ext) {
             }
             --mbLimit;
             --base->mappingsLength;
-            base->isSorted=FALSE;
+            base->isSorted=false;
         } else {
             ++mb;
         }
@@ -469,7 +469,7 @@ checkBaseExtBytes(UCMStates *baseStates, UCMTable *base, UCMTable *ext,
         }
 
         /* compare the base and extension mappings */
-        cmp=compareBytes(base, mb, ext, me, TRUE);
+        cmp=compareBytes(base, mb, ext, me, true);
         if(cmp<0) {
             if(intersectBase) {
                 /* mapping in base but not in ext, move it */
@@ -539,13 +539,13 @@ ucm_checkValidity(UCMTable *table, UCMStates *baseStates) {
 
     m=table->mappings;
     mLimit=m+table->mappingsLength;
-    isOK=TRUE;
+    isOK=true;
 
     while(m<mLimit) {
         count=ucm_countChars(baseStates, UCM_GET_BYTES(table, m), m->bLen);
         if(count<1) {
             ucm_printMapping(table, m, stderr);
-            isOK=FALSE;
+            isOK=false;
         }
         ++m;
     }
@@ -562,11 +562,11 @@ ucm_checkBaseExt(UCMStates *baseStates,
     /* if we have an extension table, we must always use precision flags */
     if(base->flagsType&UCM_FLAGS_IMPLICIT) {
         fprintf(stderr, "ucm error: the base table contains mappings without precision flags\n");
-        return FALSE;
+        return false;
     }
     if(ext->flagsType&UCM_FLAGS_IMPLICIT) {
         fprintf(stderr, "ucm error: extension table contains mappings without precision flags\n");
-        return FALSE;
+        return false;
     }
 
     /* checking requires both tables to be sorted */
@@ -579,7 +579,7 @@ ucm_checkBaseExt(UCMStates *baseStates,
         checkBaseExtBytes(baseStates, base, ext, (UBool)(moveTarget!=NULL), intersectBase);
 
     if(result&HAS_ERRORS) {
-        return FALSE;
+        return false;
     }
 
     if(result&NEEDS_MOVE) {
@@ -592,7 +592,7 @@ ucm_checkBaseExt(UCMStates *baseStates,
         }
     }
 
-    return TRUE;
+    return true;
 }
 
 /* merge tables for rptp2ucm ------------------------------------------------ */
@@ -616,7 +616,7 @@ ucm_mergeTables(UCMTable *fromUTable, UCMTable *toUTable,
     fromUIndex=toUIndex=0;
 
     while(fromUIndex<fromUTop && toUIndex<toUTop) {
-        cmp=compareMappings(fromUTable, fromUMapping, toUTable, toUMapping, TRUE);
+        cmp=compareMappings(fromUTable, fromUMapping, toUTable, toUMapping, true);
         if(cmp==0) {
             /* equal: roundtrip, nothing to do (flags are initially 0) */
             ++fromUMapping;
@@ -689,7 +689,7 @@ ucm_mergeTables(UCMTable *fromUTable, UCMTable *toUTable,
         ++toUIndex;
     }
 
-    fromUTable->isSorted=FALSE;
+    fromUTable->isSorted=false;
 }
 
 /* separate extension mappings out of base table for rptp2ucm --------------- */
@@ -705,15 +705,15 @@ ucm_separateMappings(UCMFile *ucm, UBool isSISO) {
     m=table->mappings;
     mLimit=m+table->mappingsLength;
 
-    needsMove=FALSE;
-    isOK=TRUE;
+    needsMove=false;
+    isOK=true;
 
     for(; m<mLimit; ++m) {
         if(isSISO && m->bLen==1 && (m->b.bytes[0]==0xe || m->b.bytes[0]==0xf)) {
             fprintf(stderr, "warning: removing illegal mapping from an SI/SO-stateful table\n");
             ucm_printMapping(table, m, stderr);
             m->moveFlag|=UCM_REMOVE_MAPPING;
-            needsMove=TRUE;
+            needsMove=true;
             continue;
         }
 
@@ -723,22 +723,22 @@ ucm_separateMappings(UCMFile *ucm, UBool isSISO) {
         if(type<0) {
             /* illegal byte sequence */
             printMapping(m, UCM_GET_CODE_POINTS(table, m), UCM_GET_BYTES(table, m), stderr);
-            isOK=FALSE;
+            isOK=false;
         } else if(type>0) {
             m->moveFlag|=UCM_MOVE_TO_EXT;
-            needsMove=TRUE;
+            needsMove=true;
         }
     }
 
     if(!isOK) {
-        return FALSE;
+        return false;
     }
     if(needsMove) {
         ucm_moveMappings(ucm->base, ucm->ext);
-        return ucm_checkBaseExt(&ucm->states, ucm->base, ucm->ext, ucm->ext, FALSE);
+        return ucm_checkBaseExt(&ucm->states, ucm->base, ucm->ext, ucm->ext, false);
     } else {
         ucm_sortTable(ucm->base);
-        return TRUE;
+        return true;
     }
 }
 
@@ -810,16 +810,16 @@ ucm_parseMappingLine(UCMapping *m,
             *end!='>'
         ) {
             fprintf(stderr, "ucm error: Unicode code point must be formatted as <UXXXX> (1..6 hex digits) - \"%s\"\n", line);
-            return FALSE;
+            return false;
         }
         if((uint32_t)cp>0x10ffff || U_IS_SURROGATE(cp)) {
             fprintf(stderr, "ucm error: Unicode code point must be 0..d7ff or e000..10ffff - \"%s\"\n", line);
-            return FALSE;
+            return false;
         }
 
         if(uLen==UCNV_EXT_MAX_UCHARS) {
             fprintf(stderr, "ucm error: too many code points on \"%s\"\n", line);
-            return FALSE;
+            return false;
         }
         codePoints[uLen++]=cp;
         s=end+1;
@@ -827,7 +827,7 @@ ucm_parseMappingLine(UCMapping *m,
 
     if(uLen==0) {
         fprintf(stderr, "ucm error: no Unicode code points on \"%s\"\n", line);
-        return FALSE;
+        return false;
     } else if(uLen==1) {
         m->u=codePoints[0];
     } else {
@@ -837,7 +837,7 @@ ucm_parseMappingLine(UCMapping *m,
             u16Length>UCNV_EXT_MAX_UCHARS
         ) {
             fprintf(stderr, "ucm error: too many UChars on \"%s\"\n", line);
-            return FALSE;
+            return false;
         }
     }
 
@@ -847,10 +847,10 @@ ucm_parseMappingLine(UCMapping *m,
     bLen=ucm_parseBytes(bytes, line, &s);
 
     if(bLen<0) {
-        return FALSE;
+        return false;
     } else if(bLen==0) {
         fprintf(stderr, "ucm error: no bytes on \"%s\"\n", line);
-        return FALSE;
+        return false;
     } else if(bLen<=4) {
         uprv_memcpy(m->b.bytes, bytes, bLen);
     }
@@ -864,7 +864,7 @@ ucm_parseMappingLine(UCMapping *m,
             f=(int8_t)(s[1]-'0');
             if((uint8_t)f>4) {
                 fprintf(stderr, "ucm error: fallback indicator must be |0..|4 - \"%s\"\n", line);
-                return FALSE;
+                return false;
             }
             break;
         }
@@ -874,7 +874,7 @@ ucm_parseMappingLine(UCMapping *m,
     m->uLen=uLen;
     m->bLen=bLen;
     m->f=f;
-    return TRUE;
+    return true;
 }
 
 /* general APIs ------------------------------------------------------------- */
@@ -909,7 +909,7 @@ ucm_resetTable(UCMTable *table) {
         table->flagsType=0;
         table->unicodeMask=0;
         table->bytesLength=table->codePointsLength=0;
-        table->isSorted=FALSE;
+        table->isSorted=false;
     }
 }
 
@@ -1008,7 +1008,7 @@ ucm_addMapping(UCMTable *table,
     tm=table->mappings+table->mappingsLength++;
     uprv_memcpy(tm, m, sizeof(UCMapping));
 
-    table->isSorted=FALSE;
+    table->isSorted=false;
 }
 
 U_CAPI UCMFile * U_EXPORT2
@@ -1099,7 +1099,7 @@ ucm_addMappingAuto(UCMFile *ucm, UBool forBase, UCMStates *baseStates,
     if(m->f==2 && m->uLen>1) {
         fprintf(stderr, "ucm error: illegal <subchar1> |2 mapping from multiple code points\n");
         printMapping(m, codePoints, bytes, stderr);
-        return FALSE;
+        return false;
     }
 
     if(baseStates!=NULL) {
@@ -1108,7 +1108,7 @@ ucm_addMappingAuto(UCMFile *ucm, UBool forBase, UCMStates *baseStates,
         if(type<0) {
             /* illegal byte sequence */
             printMapping(m, codePoints, bytes, stderr);
-            return FALSE;
+            return false;
         }
     } else {
         /* not used - adding a mapping for an extension-only table before its base table is read */
@@ -1125,7 +1125,7 @@ ucm_addMappingAuto(UCMFile *ucm, UBool forBase, UCMStates *baseStates,
         ucm_addMapping(ucm->ext, m, codePoints, bytes);
     }
 
-    return TRUE;
+    return true;
 }
 
 U_CAPI UBool U_EXPORT2
@@ -1138,7 +1138,7 @@ ucm_addMappingFromLine(UCMFile *ucm, const char *line, UBool forBase, UCMStates
 
     /* ignore empty and comment lines */
     if(line[0]=='#' || *(s=u_skipWhitespace(line))==0 || *s=='\n' || *s=='\r') {
-        return TRUE;
+        return true;
     }
 
     return
@@ -1158,13 +1158,13 @@ ucm_readTable(UCMFile *ucm, FileStream* convFile,
         return;
     }
 
-    isOK=TRUE;
+    isOK=true;
 
     for(;;) {
         /* read the next line */
         if(!T_FileStream_readLine(convFile, line, sizeof(line))) {
             fprintf(stderr, "incomplete charmap section\n");
-            isOK=FALSE;
+            isOK=false;
             break;
         }
 
diff --git a/deps/icu-small/source/tools/toolutil/ucm.h b/deps/icu-small/source/tools/toolutil/ucm.h
index 04e6b2030d..8ea90604d4 100644
--- a/deps/icu-small/source/tools/toolutil/ucm.h
+++ b/deps/icu-small/source/tools/toolutil/ucm.h
@@ -207,7 +207,7 @@ ucm_checkValidity(UCMTable *ext, UCMStates *baseStates);
  *
  * Sort both tables, and then for each mapping direction:
  *
- * If intersectBase is TRUE and the base table contains a mapping
+ * If intersectBase is true and the base table contains a mapping
  * that does not exist in the extension table, then this mapping is moved
  * to moveTarget.
  *
@@ -223,7 +223,7 @@ ucm_checkValidity(UCMTable *ext, UCMStates *baseStates);
  * - if moveTarget!=NULL: move the base mapping to the moveTarget table
  * - else: error
  *
- * @return FALSE in case of an irreparable error
+ * @return false in case of an irreparable error
  */
 U_CAPI UBool U_EXPORT2
 ucm_checkBaseExt(UCMStates *baseStates, UCMTable *base, UCMTable *ext,
diff --git a/deps/icu-small/source/tools/toolutil/ucmstate.cpp b/deps/icu-small/source/tools/toolutil/ucmstate.cpp
index 1ff2d7d193..d46b73ed30 100644
--- a/deps/icu-small/source/tools/toolutil/ucmstate.cpp
+++ b/deps/icu-small/source/tools/toolutil/ucmstate.cpp
@@ -226,12 +226,12 @@ ucm_parseHeaderLine(UCMFile *ucm,
     /* skip leading white space and ignore empty lines */
     s=(char *)u_skipWhitespace(line);
     if(*s==0) {
-        return TRUE;
+        return true;
     }
 
     /* stop at the beginning of the mapping section */
     if(uprv_memcmp(s, "CHARMAP", 7)==0) {
-        return FALSE;
+        return false;
     }
 
     /* get the key name, bracketed in <> */
@@ -275,7 +275,7 @@ ucm_parseHeaderLine(UCMFile *ucm,
             fprintf(stderr, "ucm error: unknown <uconv_class> %s\n", *pValue);
             exit(U_INVALID_TABLE_FORMAT);
         }
-        return TRUE;
+        return true;
     } else if(uprv_strcmp(*pKey, "mb_cur_max")==0) {
         c=**pValue;
         if('1'<=c && c<='4' && (*pValue)[1]==0) {
@@ -285,7 +285,7 @@ ucm_parseHeaderLine(UCMFile *ucm,
             fprintf(stderr, "ucm error: illegal <mb_cur_max> %s\n", *pValue);
             exit(U_INVALID_TABLE_FORMAT);
         }
-        return TRUE;
+        return true;
     } else if(uprv_strcmp(*pKey, "mb_cur_min")==0) {
         c=**pValue;
         if('1'<=c && c<='4' && (*pValue)[1]==0) {
@@ -294,7 +294,7 @@ ucm_parseHeaderLine(UCMFile *ucm,
             fprintf(stderr, "ucm error: illegal <mb_cur_min> %s\n", *pValue);
             exit(U_INVALID_TABLE_FORMAT);
         }
-        return TRUE;
+        return true;
     } else if(uprv_strcmp(*pKey, "icu:state")==0) {
         /* if an SBCS/DBCS/EBCDIC_STATEFUL converter has icu:state, then turn it into MBCS */
         switch(states->conversionType) {
@@ -315,17 +315,17 @@ ucm_parseHeaderLine(UCMFile *ucm,
             exit(U_INVALID_TABLE_FORMAT);
         }
         ucm_addState(states, *pValue);
-        return TRUE;
+        return true;
     } else if(uprv_strcmp(*pKey, "icu:base")==0) {
         if(**pValue==0) {
             fprintf(stderr, "ucm error: <icu:base> without a base table name\n");
             exit(U_INVALID_TABLE_FORMAT);
         }
         uprv_strcpy(ucm->baseName, *pValue);
-        return TRUE;
+        return true;
     }
 
-    return FALSE;
+    return false;
 }
 
 /* post-processing ---------------------------------------------------------- */
@@ -343,12 +343,12 @@ sumUpStates(UCMStates *states) {
      * the offsets sum of that state needs to be added.
      * This is achieved in at most countStates iterations.
      */
-    allStatesReady=FALSE;
+    allStatesReady=false;
     for(count=states->countStates; !allStatesReady && count>=0; --count) {
-        allStatesReady=TRUE;
+        allStatesReady=true;
         for(state=states->countStates-1; state>=0; --state) {
             if(!(states->stateFlags[state]&MBCS_STATE_FLAG_READY)) {
-                allStatesReady=FALSE;
+                allStatesReady=false;
                 sum=0;
 
                 /* at first, add up only the final delta offsets to keep them <512 */
@@ -848,7 +848,7 @@ findUnassigned(UCMStates *states,
     UBool haveAssigned;
 
     localSavings=belowSavings=0;
-    haveAssigned=FALSE;
+    haveAssigned=false;
     for(i=0; i<256; ++i) {
         entry=states->stateTable[state][i];
         if(MBCS_ENTRY_IS_TRANSITION(entry)) {
@@ -859,7 +859,7 @@ findUnassigned(UCMStates *states,
                         offset+MBCS_ENTRY_TRANSITION_OFFSET(entry),
                         (b<<8)|(uint32_t)i);
             if(savings<0) {
-                haveAssigned=TRUE;
+                haveAssigned=true;
             } else if(savings>0) {
                 printf("    all-unassigned sequences from prefix 0x%02lx state %ld use %ld bytes\n",
                     (unsigned long)((b<<8)|i), (long)state, (long)savings);
@@ -872,7 +872,7 @@ findUnassigned(UCMStates *states,
                 if(unicodeCodeUnits[entry]==0xfffe && ucm_findFallback(toUFallbacks, countToUFallbacks, entry)<0) {
                     localSavings+=2;
                 } else {
-                    haveAssigned=TRUE;
+                    haveAssigned=true;
                 }
                 break;
             case MBCS_STATE_VALID_16_PAIR:
@@ -880,7 +880,7 @@ findUnassigned(UCMStates *states,
                 if(unicodeCodeUnits[entry]==0xfffe) {
                     localSavings+=4;
                 } else {
-                    haveAssigned=TRUE;
+                    haveAssigned=true;
                 }
                 break;
             default:
@@ -968,7 +968,7 @@ ucm_optimizeStates(UCMStates *states,
         errorCode=U_ZERO_ERROR; /* nothing bad will happen... */
         uprv_sortArray(toUFallbacks, countToUFallbacks,
                        sizeof(_MBCSToUFallback),
-                       compareFallbacks, NULL, FALSE, &errorCode);
+                       compareFallbacks, NULL, false, &errorCode);
     }
 }
 
diff --git a/deps/icu-small/source/tools/toolutil/udbgutil.cpp b/deps/icu-small/source/tools/toolutil/udbgutil.cpp
index 993694546f..dcf71b2887 100644
--- a/deps/icu-small/source/tools/toolutil/udbgutil.cpp
+++ b/deps/icu-small/source/tools/toolutil/udbgutil.cpp
@@ -239,7 +239,7 @@ static const Field names_UDebugEnumType[] =
 
 /**
  * @param type type of item
- * @param actual TRUE: for the actual enum's type (UCAL_FIELD_COUNT, etc), or FALSE for the string count
+ * @param actual true: for the actual enum's type (UCAL_FIELD_COUNT, etc), or false for the string count
  */
 static int32_t _udbg_enumCount(UDebugEnumType type, UBool actual) {
 	switch(type) {
@@ -288,16 +288,16 @@ static const Field* _udbg_enumFields(UDebugEnumType type) {
 // implementation
 
 int32_t  udbg_enumCount(UDebugEnumType type) {
-	return _udbg_enumCount(type, FALSE);
+	return _udbg_enumCount(type, false);
 }
 
 int32_t  udbg_enumExpectedCount(UDebugEnumType type) {
-	return _udbg_enumCount(type, TRUE);
+	return _udbg_enumCount(type, true);
 }
 
 const char *  udbg_enumName(UDebugEnumType type, int32_t field) {
 	if(field<0 ||
-				field>=_udbg_enumCount(type,FALSE)) { // also will catch unsupported items
+				field>=_udbg_enumCount(type,false)) { // also will catch unsupported items
 		return NULL;
 	} else {
 		const Field *fields = _udbg_enumFields(type);
@@ -311,7 +311,7 @@ const char *  udbg_enumName(UDebugEnumType type, int32_t field) {
 
 int32_t  udbg_enumArrayValue(UDebugEnumType type, int32_t field) {
 	if(field<0 ||
-				field>=_udbg_enumCount(type,FALSE)) { // also will catch unsupported items
+				field>=_udbg_enumCount(type,false)) { // also will catch unsupported items
 		return -1;
 	} else {
 		const Field *fields = _udbg_enumFields(type);
@@ -324,18 +324,18 @@ int32_t  udbg_enumArrayValue(UDebugEnumType type, int32_t field) {
 }
 
 int32_t udbg_enumByName(UDebugEnumType type, const char *value) {
-    if(type<0||type>=_udbg_enumCount(UDBG_UDebugEnumType, TRUE)) {
+    if(type<0||type>=_udbg_enumCount(UDBG_UDebugEnumType, true)) {
         return -1; // type out of range
     }
 	const Field *fields = _udbg_enumFields(type);
     if (fields != NULL) {
-        for(int32_t field = 0;field<_udbg_enumCount(type, FALSE);field++) {
+        for(int32_t field = 0;field<_udbg_enumCount(type, false);field++) {
             if(!strcmp(value, fields[field].str + fields[field].prefix)) {
                 return fields[field].num;
             }
         }
         // try with the prefix
-        for(int32_t field = 0;field<_udbg_enumCount(type, FALSE);field++) {
+        for(int32_t field = 0;field<_udbg_enumCount(type, false);field++) {
             if(!strcmp(value, fields[field].str)) {
                 return fields[field].num;
             }
@@ -490,7 +490,7 @@ U_CAPI  int32_t
 paramLocaleDefaultBcp47(const USystemParams * /* param */, char *target, int32_t targetCapacity, UErrorCode *status) {
   if(U_FAILURE(*status))return 0;
   const char *def = uloc_getDefault();
-  return uloc_toLanguageTag(def,target,targetCapacity,FALSE,status);
+  return uloc_toLanguageTag(def,target,targetCapacity,false,status);
 }
 
 
@@ -650,18 +650,18 @@ void KnownIssues::add(const char *ticketStr, const char *where, const UChar *msg
 {
   const std::string ticket = mapTicketId(ticketStr);
   if(fTable.find(ticket) == fTable.end()) {
-    if(firstForTicket!=NULL) *firstForTicket = TRUE;
+    if(firstForTicket!=NULL) *firstForTicket = true;
     fTable[ticket] = std::map < std::string, std::set < std::string > >();
   } else {
-    if(firstForTicket!=NULL) *firstForTicket = FALSE;
+    if(firstForTicket!=NULL) *firstForTicket = false;
   }
   if(where==NULL) return;
 
   if(fTable[ticket].find(where) == fTable[ticket].end()) {
-    if(firstForWhere!=NULL) *firstForWhere = TRUE;
+    if(firstForWhere!=NULL) *firstForWhere = true;
     fTable[ticket][where] = std::set < std::string >();
   } else {
-    if(firstForWhere!=NULL) *firstForWhere = FALSE;
+    if(firstForWhere!=NULL) *firstForWhere = false;
   }
   if(msg==NULL || !*msg) return;
 
@@ -674,18 +674,18 @@ void KnownIssues::add(const char *ticketStr, const char *where, const char *msg,
 {
   const std::string ticket = mapTicketId(ticketStr);
   if(fTable.find(ticket) == fTable.end()) {
-    if(firstForTicket!=NULL) *firstForTicket = TRUE;
+    if(firstForTicket!=NULL) *firstForTicket = true;
     fTable[ticket] = std::map < std::string, std::set < std::string > >();
   } else {
-    if(firstForTicket!=NULL) *firstForTicket = FALSE;
+    if(firstForTicket!=NULL) *firstForTicket = false;
   }
   if(where==NULL) return;
 
   if(fTable[ticket].find(where) == fTable[ticket].end()) {
-    if(firstForWhere!=NULL) *firstForWhere = TRUE;
+    if(firstForWhere!=NULL) *firstForWhere = true;
     fTable[ticket][where] = std::set < std::string >();
   } else {
-    if(firstForWhere!=NULL) *firstForWhere = FALSE;
+    if(firstForWhere!=NULL) *firstForWhere = false;
   }
   if(msg==NULL || !*msg) return;
 
@@ -696,7 +696,7 @@ void KnownIssues::add(const char *ticketStr, const char *where, const char *msg,
 UBool KnownIssues::print()
 {
   if(fTable.empty()) {
-    return FALSE;
+    return false;
   }
 
   std::cout << "KNOWN ISSUES" << std::endl;
@@ -723,7 +723,7 @@ UBool KnownIssues::print()
       }
     }
   }
-  return TRUE;
+  return true;
 }
 
 U_CAPI void *udbg_knownIssue_openU(void *ptr, const char *ticket, char *where, const UChar *msg, UBool *firstForTicket,
@@ -753,10 +753,10 @@ U_CAPI void *udbg_knownIssue_open(void *ptr, const char *ticket, char *where, co
 U_CAPI UBool udbg_knownIssue_print(void *ptr) {
   KnownIssues *t = static_cast<KnownIssues*>(ptr);
   if(t==NULL) {
-    return FALSE;
+    return false;
   } else {
     t->print();
-    return TRUE;
+    return true;
   }
 }
 
diff --git a/deps/icu-small/source/tools/toolutil/udbgutil.h b/deps/icu-small/source/tools/toolutil/udbgutil.h
index b9af132da5..e3ed513839 100644
--- a/deps/icu-small/source/tools/toolutil/udbgutil.h
+++ b/deps/icu-small/source/tools/toolutil/udbgutil.h
@@ -133,7 +133,7 @@ U_CAPI void *udbg_knownIssue_open(void *ptr, const char *ticket, char *where, co
 /**
  * Print 'known issue' table, to std::cout.
  * @param ptr pointer from udbg_knownIssue
- * @return TRUE if there were any issues.
+ * @return true if there were any issues.
  */
 U_CAPI UBool udbg_knownIssue_print(void *ptr);
 
diff --git a/deps/icu-small/source/tools/toolutil/writesrc.cpp b/deps/icu-small/source/tools/toolutil/writesrc.cpp
index 143254a7f3..0bd8b85bb8 100644
--- a/deps/icu-small/source/tools/toolutil/writesrc.cpp
+++ b/deps/icu-small/source/tools/toolutil/writesrc.cpp
@@ -19,6 +19,7 @@
 */
 
 #include <stdio.h>
+#include <inttypes.h>
 #include <time.h>
 #include "unicode/utypes.h"
 #include "unicode/putil.h"
@@ -143,12 +144,14 @@ usrc_writeArray(FILE *f,
     const uint8_t *p8;
     const uint16_t *p16;
     const uint32_t *p32;
-    uint32_t value;
+    const int64_t *p64; // Signed due to TOML!
+    int64_t value; // Signed due to TOML!
     int32_t i, col;
 
     p8=NULL;
     p16=NULL;
     p32=NULL;
+    p64=NULL;
     switch(width) {
     case 8:
         p8=(const uint8_t *)p;
@@ -159,6 +162,9 @@ usrc_writeArray(FILE *f,
     case 32:
         p32=(const uint32_t *)p;
         break;
+    case 64:
+        p64=(const int64_t *)p;
+        break;
     default:
         fprintf(stderr, "usrc_writeArray(width=%ld) unrecognized width\n", (long)width);
         return;
@@ -186,11 +192,14 @@ usrc_writeArray(FILE *f,
         case 32:
             value=p32[i];
             break;
+        case 64:
+            value=p64[i];
+            break;
         default:
             value=0; /* unreachable */
             break;
         }
-        fprintf(f, value<=9 ? "%lu" : "0x%lx", (unsigned long)value);
+        fprintf(f, value<=9 ? "%" PRId64 : "0x%" PRIx64, value);
     }
     if(postfix!=NULL) {
         fputs(postfix, f);
@@ -251,7 +260,7 @@ usrc_writeUTrie2Struct(FILE *f,
         "    0x%lx,\n"          /* errorValue */
         "    0x%lx,\n"          /* highStart */
         "    0x%lx,\n"          /* highValueIndex */
-        "    NULL, 0, FALSE, FALSE, 0, NULL\n",
+        "    NULL, 0, false, false, 0, NULL\n",
         (long)pTrie->indexLength, (long)pTrie->dataLength,
         (short)pTrie->index2NullOffset, (short)pTrie->dataNullOffset,
         (long)pTrie->initialValue, (long)pTrie->errorValue,
diff --git a/deps/icu-small/source/tools/toolutil/writesrc.h b/deps/icu-small/source/tools/toolutil/writesrc.h
index 784a9b9c7a..9c0be5a100 100644
--- a/deps/icu-small/source/tools/toolutil/writesrc.h
+++ b/deps/icu-small/source/tools/toolutil/writesrc.h
@@ -69,7 +69,7 @@ usrc_writeFileNameGeneratedBy(
         const char *generator);
 
 /**
- * Writes the contents of an array of 8/16/32-bit words.
+ * Writes the contents of an array of 8/16/32/64-bit words.
  * The prefix and postfix are optional (can be NULL) and are written first/last.
  * The prefix may contain a %ld or similar field for the array length.
  * The {} and declaration etc. need to be included in prefix/postfix or
diff --git a/deps/icu-small/source/tools/toolutil/xmlparser.cpp b/deps/icu-small/source/tools/toolutil/xmlparser.cpp
index a6569903bc..104a99c93e 100644
--- a/deps/icu-small/source/tools/toolutil/xmlparser.cpp
+++ b/deps/icu-small/source/tools/toolutil/xmlparser.cpp
@@ -221,7 +221,7 @@ UXMLParser::parseFile(const char *filename, UErrorCode &errorCode) {
             cnv,
             &pu, buffer+src.getCapacity(),
             &pb, bytes+bytesLength,
-            NULL, TRUE, &errorCode);
+            NULL, true, &errorCode);
         src.releaseBuffer(U_SUCCESS(errorCode) ? (int32_t)(pu-buffer) : 0);
         ucnv_close(cnv);
         cnv=NULL;
@@ -272,7 +272,7 @@ UXMLParser::parseFile(const char *filename, UErrorCode &errorCode) {
     capacity=fileLength;        // estimated capacity
     src.getBuffer(capacity);
     src.releaseBuffer(0);       // zero length
-    flush=FALSE;
+    flush=false;
     for(;;) {
         // convert contents of bytes[bytesLength]
         pb=bytes;
@@ -289,7 +289,7 @@ UXMLParser::parseFile(const char *filename, UErrorCode &errorCode) {
             ucnv_toUnicode(
                 cnv, &pu, buffer+src.getCapacity(),
                 &pb, bytes+bytesLength,
-                NULL, FALSE, &errorCode);
+                NULL, false, &errorCode);
             src.releaseBuffer(U_SUCCESS(errorCode) ? (int32_t)(pu-buffer) : 0);
             if(errorCode==U_BUFFER_OVERFLOW_ERROR) {
                 errorCode=U_ZERO_ERROR;
@@ -311,7 +311,7 @@ UXMLParser::parseFile(const char *filename, UErrorCode &errorCode) {
         bytesLength=T_FileStream_read(f, bytes, (int32_t)sizeof(bytes));
         if(bytesLength==0) {
             // reached end of file, convert once more to flush the converter
-            flush=TRUE;
+            flush=true;
         }
     }
 
@@ -373,7 +373,7 @@ UXMLParser::parse(const UnicodeString &src, UErrorCode &status) {
         root = createElement(mXMLElemEmpty, status);
         fPos = mXMLElemEmpty.end(status);
     } else {
-        if (mXMLElemStart.lookingAt(fPos, status) == FALSE) {
+        if (mXMLElemStart.lookingAt(fPos, status) == false) {
             error("Root Element expected", status);
             goto errorExit;
         }
@@ -403,7 +403,7 @@ UXMLParser::parse(const UnicodeString &src, UErrorCode &status) {
             UnicodeString s = scanContent(status);
             if (s.length() > 0) {
                 mXMLSP.reset(s);
-                if (mXMLSP.matches(status) == FALSE) {
+                if (mXMLSP.matches(status) == false) {
                     // This chunk of text contains something other than just
                     //  white space. Make a child node for it.
                     replaceCharRefs(s, status);
diff --git a/deps/icu-small/source/tools/toolutil/xmlparser.h b/deps/icu-small/source/tools/toolutil/xmlparser.h
index 5a3a24c5ed..7f798f66f7 100644
--- a/deps/icu-small/source/tools/toolutil/xmlparser.h
+++ b/deps/icu-small/source/tools/toolutil/xmlparser.h
@@ -61,7 +61,7 @@ public:
     /**
      * Get the text contents of the element.
      * Append the contents of all text child nodes.
-     * @param recurse If TRUE, also recursively appends the contents of all
+     * @param recurse If true, also recursively appends the contents of all
      *        text child nodes of element children.
      * @return The text contents.
      */
diff --git a/test/parallel/test-icu-env.js b/test/parallel/test-icu-env.js
index 368f829234..9db276e5bb 100644
--- a/test/parallel/test-icu-env.js
+++ b/test/parallel/test-icu-env.js
@@ -122,17 +122,17 @@ if (isMockable) {
   assert.deepStrictEqual(
     locales.map((LANG) => runEnvOutside({ LANG, TZ: 'Europe/Zurich' }, 'new Date(333333333333).toLocaleString()')),
     [
-      '7/25/1980, 1:35:33 AM',
+      '7/25/1980, 1:35:33 AM',
       '1980/7/25 01:35:33',
       '25/7/1980, 1:35:33 am',
       '25/7/1980, 1:35:33',
       '25/07/1980 01:35:33',
-      '٢٥‏/٧‏/١٩٨٠, ١:٣٥:٣٣ ص',
-      '২৫/৭/১৯৮০ ১:৩৫:৩৩ AM',
+      '٢٥‏/٧‏/١٩٨٠، ١:٣٥:٣٣ ص',
+      '২৫/৭/১৯৮০, ১:৩৫:৩৩ AM',
       '25.07.1980, 01:35:33',
-      '25/07/1980 01:35:33',
-      '25/7/1980 1:35:33 AM',
-      '25/7/1980 01.35.33',
+      '25/07/1980, 01:35:33',
+      '25/7/1980، 1:35:33 AM',
+      '25/7/1980, 01.35.33',
       '25.7.1980, 01:35:33',
       '1980/7/25 1:35:33',
       '25/7/1980 01:35:33',
diff --git a/test/parallel/test-intl.js b/test/parallel/test-intl.js
index 7d1742f2c7..2cf3efe11a 100644
--- a/test/parallel/test-intl.js
+++ b/test/parallel/test-intl.js
@@ -97,7 +97,11 @@ if (!common.hasIntl) {
   // Test format
   {
     const localeString = date0.toLocaleString(['en'], optsGMT);
-    assert.strictEqual(localeString, '1/1/1970, 12:00:00 AM');
+    if (Number(process.versions.cldr) >= 42) {
+      assert.strictEqual(localeString, '1/1/1970, 12:00:00 AM');
+    } else {
+      assert.strictEqual(localeString, '1/1/1970, 12:00:00 AM');
+    }
   }
   // number format
   {
diff --git a/tools/icu/current_ver.dep b/tools/icu/current_ver.dep
index 9d2ca52eda..297963af04 100644
--- a/tools/icu/current_ver.dep
+++ b/tools/icu/current_ver.dep
@@ -1,6 +1,6 @@
 [
   {
-    "url": "https://github.com/unicode-org/icu/releases/download/release-71-1/icu4c-71_1-src.tgz",
-    "md5": "e06ffc96f59762bd3c929b217445aaec"
+    "url": "https://github.com/unicode-org/icu/releases/download/release-72-1/icu4c-72_1-src.tgz",
+    "md5": "4de6484a6c460d3d1468a6fe50369439"
   }
 ]
