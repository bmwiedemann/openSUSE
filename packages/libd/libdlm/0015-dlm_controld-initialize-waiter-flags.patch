From 0834ed4b596d0d77dd4f7e52e4f9b045778b2ced Mon Sep 17 00:00:00 2001
From: Andreas Gruenbacher <agruenba@redhat.com>
Date: Mon, 13 Mar 2023 22:22:55 +0100
Subject: [PATCH 15/24] dlm_controld: initialize waiter->flags

In function add_waiter(), waiter->flags is left uninitialized.  Fix that.

In function add_lock(), the allocated lock is zeroed out and then all
fields except po->flags are initialized.  That's not wrong, but it seems
easier to initialize po->flags instead, like add_waiter() does now.
---
 dlm_controld/plock.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/dlm_controld/plock.c b/dlm_controld/plock.c
index 24ad777a69b6..f03f3abea983 100644
--- a/dlm_controld/plock.c
+++ b/dlm_controld/plock.c
@@ -455,7 +455,6 @@ static int add_lock(struct resource *r, uint32_t nodeid, uint64_t owner,
 	po = malloc(sizeof(struct posix_lock));
 	if (!po)
 		return -ENOMEM;
-	memset(po, 0, sizeof(struct posix_lock));
 
 	po->start = start;
 	po->end = end;
@@ -463,6 +462,7 @@ static int add_lock(struct resource *r, uint32_t nodeid, uint64_t owner,
 	po->owner = owner;
 	po->pid = pid;
 	po->ex = ex;
+	po->flags = 0;
 	list_add_tail(&po->list, &r->locks);
 
 	return 0;
@@ -680,6 +680,7 @@ static int add_waiter(struct lockspace *ls, struct resource *r,
 	if (!w)
 		return -ENOMEM;
 	memcpy(&w->info, in, sizeof(struct dlm_plock_info));
+	w->flags = 0;
 	list_add_tail(&w->list, &r->waiters);
 	return 0;
 }
@@ -1095,6 +1096,7 @@ static void save_pending_plock(struct lockspace *ls, struct resource *r,
 		return;
 	}
 	memcpy(&w->info, in, sizeof(struct dlm_plock_info));
+	w->flags = 0;
 	list_add_tail(&w->list, &r->pending);
 }
 
@@ -1967,6 +1969,7 @@ void receive_plocks_data(struct lockspace *ls, struct dlm_header *hd, int len)
 			w->info.pid	= le32_to_cpu(pp->pid);
 			w->info.nodeid	= le32_to_cpu(pp->nodeid);
 			w->info.ex	= pp->ex;
+			w->flags	= 0;
 			list_add_tail(&w->list, &r->waiters);
 		}
 		pp++;
-- 
2.35.3

