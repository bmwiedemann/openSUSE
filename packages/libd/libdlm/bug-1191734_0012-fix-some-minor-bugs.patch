From cf99a9770359cef56a5aabce8c5bf2d4aeb4f2f8 Mon Sep 17 00:00:00 2001
From: Heming Zhao <heming.zhao@suse.com>
Date: Fri, 8 Oct 2021 09:33:40 +0800
Subject: [PATCH 12/14] fix some minor bugs
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

1>
log_config() should print "0" when m_buf or j_buf or l_buf is empty.

2>
parameter "%d" lacks object in confchg_cb_daemon().

3>
in run_helper():
running_count doesn't work for run_helper process.
running_count limits cmd numbers not to beyond 32. This assessment should
be put in run_helper while(1).

4>
fix decode_arguments() naming mistake for fence_ack command.

5>
removing a gcc warning for decode_arguments()

message:

```
/usr/include/bits/string_fortified.h:95:10: warning: ‘__builtin_strncpy’
specified bound 64 equals destination size [-Wstringop-truncation]
   95 |   return __builtin___strncpy_chk (__dest, __src, __len,
      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   96 |                                   __glibc_objsize (__dest));
      |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~
```

uuid is generated by uuid_generate(), which is 37-byte (36-byte uuid
plus tailing '\0'). In exist code, uuid[] is 64-byte array, which has
enough space to fill 37-byte string. So we could safely do one-byte
less copy in strncpy().

Signed-off-by: Heming Zhao <heming.zhao@suse.com>
---
 dlm_controld/daemon_cpg.c |  5 +++--
 dlm_controld/helper.c     | 10 +++++-----
 dlm_tool/main.c           | 12 ++++++++----
 3 files changed, 16 insertions(+), 11 deletions(-)

diff --git a/dlm_controld/daemon_cpg.c b/dlm_controld/daemon_cpg.c
index 392e0ff63cd8..65593e80dec4 100644
--- a/dlm_controld/daemon_cpg.c
+++ b/dlm_controld/daemon_cpg.c
@@ -174,7 +174,8 @@ void log_config(const struct cpg_name *group_name,
 
 	log_debug("%s conf %zu %zu %zu memb%s join%s left%s", group_name->value,
 		  member_list_entries, joined_list_entries, left_list_entries,
-		  m_buf, j_buf, l_buf);
+		  strlen(m_buf) ? m_buf : " 0", strlen(j_buf) ? j_buf : " 0",
+		  strlen(l_buf) ? l_buf : " 0");
 }
 
 void log_ringid(const char *name,
@@ -2335,7 +2336,7 @@ static void confchg_cb_daemon(cpg_handle_t handle,
 				   valid proto from it (is_clean_daemon_member) */
 				log_error("daemon joined %d needs fencing", node->nodeid);
 			} else {
-				log_debug("daemon joined %d");
+				log_debug("daemon joined %d", node->nodeid);
 			}
 		} else {
 			if (!node->daemon_member)
diff --git a/dlm_controld/helper.c b/dlm_controld/helper.c
index 469dd22095f0..f31ccd954826 100644
--- a/dlm_controld/helper.c
+++ b/dlm_controld/helper.c
@@ -286,11 +286,6 @@ int run_helper(int in_fd, int out_fd, int log_stderr)
 
 	_log_stderr = log_stderr;
 
-	if (running_count >= MAX_RUNNING) {
-		log_helper("too many running commands");
-		return -1;
-	}
-
 	rv = setgroups(0, NULL);
 	if (rv < 0)
 		log_helper("error clearing helper groups errno %i", errno);
@@ -335,6 +330,11 @@ int run_helper(int in_fd, int out_fd, int log_stderr)
 			if (hd->type == DLM_MSG_RUN_REQUEST) {
 				int cmd_pipe[2];
 
+				if (running_count >= MAX_RUNNING) {
+					log_helper("too many running commands");
+					exit(1);
+				}
+
 				/*
 				 * Child writes cmd_buf to cmd_pipe, parent reads
 				 * cmd_buf from cmd_pipe.  cmd_buf contains the
diff --git a/dlm_tool/main.c b/dlm_tool/main.c
index bce5c1da3c95..04ff40f874c8 100644
--- a/dlm_tool/main.c
+++ b/dlm_tool/main.c
@@ -461,12 +461,16 @@ static void decode_arguments(int argc, char **argv)
 	if (optind < argc - 1) {
 		if (need_lsname)
 			lsname = argv[opt_ind];
-		else if (need_uuid)
-			strncpy(run_uuid, argv[opt_ind], DLMC_RUN_UUID_LEN);
-		else if (need_command)
+		else if (need_uuid) {
+			strncpy(run_uuid, argv[opt_ind], DLMC_RUN_UUID_LEN - 1);
+			run_uuid[DLMC_RUN_UUID_LEN - 1] = '\0';
+		} else if (need_command)
 			goto copy_command;
 	} else if (need_lsname) {
-		fprintf(stderr, "lockspace name required\n");
+		if (operation == OP_FENCE_ACK)
+			fprintf(stderr, "nodeid required\n");
+		else
+			fprintf(stderr, "lockspace name required\n");
 		exit(EXIT_FAILURE);
 	} else if (need_command) {
 		fprintf(stderr, "command required\n");
-- 
2.33.0

