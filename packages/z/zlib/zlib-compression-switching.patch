Index: zlib-1.2.11/configure
===================================================================
--- zlib-1.2.11.orig/configure
+++ zlib-1.2.11/configure
@@ -923,7 +923,7 @@ cat > $test.c << EOF
 #include <sys/sdt.h>
 int main() { return 0; }
 EOF
-if try ${CC} ${CFLAGS} $test.c; then
+if try $CC -c $CFLAGS $test.c; then
     echo "Checking for sys/sdt.h ... Yes." | tee -a configure.log
     CFLAGS="$CFLAGS -DHAVE_SYS_SDT_H"
     SFLAGS="$SFLAGS -DHAVE_SYS_SDT_H"
Index: zlib-1.2.11/contrib/s390/dfltcc.c
===================================================================
--- zlib-1.2.11.orig/contrib/s390/dfltcc.c
+++ zlib-1.2.11/contrib/s390/dfltcc.c
@@ -350,8 +350,12 @@ int ZLIB_INTERNAL dfltcc_deflate(strm, f
     int soft_bcc;
     int no_flush;
 
-    if (!dfltcc_can_deflate(strm))
+    if (!dfltcc_can_deflate(strm)) {
+        /* Clear history. */
+        if (flush == Z_FULL_FLUSH)
+            param->hl = 0;
         return 0;
+    }
 
 again:
     masked_avail_in = 0;
@@ -376,7 +380,8 @@ again:
         /* Clear history. */
         if (flush == Z_FULL_FLUSH)
             param->hl = 0;
-        *result = need_more;
+        /* Trigger block post-processing if necessary. */
+        *result = no_flush ? need_more : block_done;
         return 1;
     }
 
@@ -403,13 +408,18 @@ again:
             param->bcf = 0;
             dfltcc_state->block_threshold =
                 strm->total_in + dfltcc_state->block_size;
-            if (strm->avail_out == 0) {
-                *result = need_more;
-                return 1;
-            }
         }
     }
 
+    /* No space for compressed data. If we proceed, dfltcc_cmpr() will return
+     * DFLTCC_CC_OP1_TOO_SHORT without buffering header bits, but we will still
+     * set BCF=1, which is wrong. Avoid complications and return early.
+     */
+    if (strm->avail_out == 0) {
+        *result = need_more;
+        return 1;
+    }
+
     /* The caller gave us too much data. Pass only one block worth of
      * uncompressed data to DFLTCC and mask the rest, so that on the next
      * iteration we start a new block.
@@ -679,10 +689,15 @@ local inline int is_dfltcc_enabled(void)
      * compiling with -m31, gcc defaults to ESA mode, however, since the kernel
      * is 64-bit, it's always z/Architecture mode at runtime.
      */
-    __asm__ volatile(".machinemode push\n"
+    __asm__ volatile(
+#ifndef __clang__
+                     ".machinemode push\n"
                      ".machinemode zarch\n"
+#endif
                      "stfle %[facilities]\n"
+#ifndef __clang__
                      ".machinemode pop\n"
+#endif
                      : [facilities] "=Q" (facilities)
                      , [r0] "+r" (r0)
                      :
@@ -835,6 +850,28 @@ int ZLIB_INTERNAL dfltcc_deflate_params(
     return Z_OK;
 }
 
+int ZLIB_INTERNAL dfltcc_deflate_done(strm, flush)
+    z_streamp strm;
+    int flush;
+{
+    deflate_state FAR *state = (deflate_state FAR *)strm->state;
+    struct dfltcc_state FAR *dfltcc_state = GET_DFLTCC_STATE(state);
+    struct dfltcc_param_v0 FAR *param = &dfltcc_state->param;
+
+    /* When deflate(Z_FULL_FLUSH) is called with small avail_out, it might
+     * close the block without resetting the compression state. Detect this
+     * situation and return that deflation is not done.
+     */
+    if (flush == Z_FULL_FLUSH && strm->avail_out == 0)
+        return 0;
+
+    /* Return that deflation is not done if DFLTCC is used and either it
+     * buffered some data (Continuation Flag is set), or has not written EOBS
+     * yet (Block-Continuation Flag is set).
+     */
+    return !dfltcc_can_deflate(strm) || (!param->cf && !param->bcf);
+}
+
 /*
    Preloading history.
 */
@@ -888,6 +925,7 @@ int ZLIB_INTERNAL dfltcc_deflate_set_dic
 
     append_history(param, state->window, dictionary, dict_length);
     state->strstart = 1; /* Add FDICT to zlib header */
+    state->block_start = state->strstart; /* Make deflate_stored happy */
     return Z_OK;
 }
 
Index: zlib-1.2.11/contrib/s390/dfltcc_deflate.h
===================================================================
--- zlib-1.2.11.orig/contrib/s390/dfltcc_deflate.h
+++ zlib-1.2.11/contrib/s390/dfltcc_deflate.h
@@ -11,6 +11,7 @@ int ZLIB_INTERNAL dfltcc_deflate_params
                                             int level,
                                             int strategy,
                                             int *flush));
+int ZLIB_INTERNAL dfltcc_deflate_done OF((z_streamp strm, int flush));
 int ZLIB_INTERNAL dfltcc_deflate_set_dictionary OF((z_streamp strm,
                                                     const Bytef *dictionary,
                                                     uInt dict_length));
@@ -41,6 +42,7 @@ int ZLIB_INTERNAL dfltcc_deflate_get_dic
         if (err == Z_STREAM_ERROR) \
             return err; \
     } while (0)
+#define DEFLATE_DONE dfltcc_deflate_done
 #define DEFLATE_BOUND_ADJUST_COMPLEN(strm, complen, source_len) \
     do { \
         if (dfltcc_can_deflate((strm))) \
Index: zlib-1.2.11/deflate.c
===================================================================
--- zlib-1.2.11.orig/deflate.c
+++ zlib-1.2.11/deflate.c
@@ -75,6 +75,7 @@ const char deflate_copyright[] =
 #define DEFLATE_GET_DICTIONARY_HOOK(strm, dict, dict_len) do {} while (0)
 #define DEFLATE_RESET_KEEP_HOOK(strm) do {} while (0)
 #define DEFLATE_PARAMS_HOOK(strm, level, strategy, hook_flush) do {} while (0)
+#define DEFLATE_DONE(strm, flush) 1
 #define DEFLATE_BOUND_ADJUST_COMPLEN(strm, complen, sourceLen) do {} while (0)
 #define DEFLATE_NEED_CONSERVATIVE_BOUND(strm) 0
 #define DEFLATE_HOOK(strm, flush, bstate) 0
@@ -600,14 +601,15 @@ int ZEXPORT deflateParams(strm, level, s
     DEFLATE_PARAMS_HOOK(strm, level, strategy, &hook_flush);
     func = configuration_table[s->level].func;
 
-    if ((strategy != s->strategy || func != configuration_table[level].func ||
-         hook_flush != Z_NO_FLUSH) && s->last_flush != -2) {
+    if (((strategy != s->strategy || func != configuration_table[level].func) &&
+         s->last_flush != -2) || hook_flush != Z_NO_FLUSH) {
         /* Flush the last buffer: */
-        int err = deflate(strm, RANK(hook_flush) > RANK(Z_BLOCK) ?
-                          hook_flush : Z_BLOCK);
+        int flush = RANK(hook_flush) > RANK(Z_BLOCK) ? hook_flush : Z_BLOCK;
+        int err = deflate(strm, flush);
         if (err == Z_STREAM_ERROR)
             return err;
-        if (strm->avail_in || (s->strstart - s->block_start) + s->lookahead)
+        if (strm->avail_in || (s->strstart - s->block_start) + s->lookahead ||
+            !DEFLATE_DONE(strm, flush))
             return Z_BUF_ERROR;
     }
     if (s->level != level) {
Index: zlib-1.2.11/test/infcover.c
===================================================================
--- zlib-1.2.11.orig/test/infcover.c
+++ zlib-1.2.11/test/infcover.c
@@ -373,7 +373,7 @@ local void cover_support(void)
     mem_setup(&strm);
     strm.avail_in = 0;
     strm.next_in = Z_NULL;
-    ret = inflateInit_(&strm, ZLIB_VERSION - 1, (int)sizeof(z_stream));
+    ret = inflateInit_(&strm, &ZLIB_VERSION[1], (int)sizeof(z_stream));
                                                 assert(ret == Z_VERSION_ERROR);
     mem_done(&strm, "wrong version");
 
