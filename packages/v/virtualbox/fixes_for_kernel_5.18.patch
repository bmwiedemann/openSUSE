Index: VirtualBox-6.1.34/src/VBox/HostDrivers/VBoxNetFlt/linux/VBoxNetFlt-linux.c
===================================================================
--- VirtualBox-6.1.34.orig/src/VBox/HostDrivers/VBoxNetFlt/linux/VBoxNetFlt-linux.c
+++ VirtualBox-6.1.34/src/VBox/HostDrivers/VBoxNetFlt/linux/VBoxNetFlt-linux.c
@@ -2311,7 +2311,13 @@ int  vboxNetFltPortOsXmit(PVBOXNETFLTINS
                 vboxNetFltDumpPacket(pSG, true, "host", (fDst & INTNETTRUNKDIR_WIRE) ? 0 : 1);
                 Log6(("vboxNetFltPortOsXmit: pBuf->cb dump:\n%.*Rhxd\n", sizeof(pBuf->cb), pBuf->cb));
                 Log6(("vboxNetFltPortOsXmit: netif_rx_ni(%p)\n", pBuf));
+#if RTLNX_VER_MIN(5,18,0)
+                local_bh_disable();
+                err = netif_rx(pBuf);
+                local_bh_enable();
+#else
                 err = netif_rx_ni(pBuf);
+#endif
                 if (err)
                     rc = RTErrConvertFromErrno(err);
             }
Index: VirtualBox-6.1.34/src/VBox/HostDrivers/Support/SUPDrv.cpp
===================================================================
--- VirtualBox-6.1.34.orig/src/VBox/HostDrivers/Support/SUPDrv.cpp
+++ VirtualBox-6.1.34/src/VBox/HostDrivers/Support/SUPDrv.cpp
@@ -98,7 +98,18 @@
 # endif
 #endif
 
-
+#if defined(RT_OS_LINUX) && !defined(__NO_FORTIFY) && defined(__OPTIMIZE__) && defined(CONFIG_FORTIFY_SOURCE)
+/* In Linux 5.18-rc1, memcpy became a wrapper which does fortify checks
+ * before triggering __underlying_memcpy() call. We do not pass these checks here,
+ * so bypass them for now.  */
+# if RTLNX_VER_MIN(5,18,0)
+#  define SUPDRV_MEMCPY __underlying_memcpy
+# else
+# define SUPDRV_MEMCPY  memcpy
+# endif
+#else
+# define SUPDRV_MEMCPY  memcpy
+#endif
 /*
  * Logging assignments:
  *      Log     - useful stuff, like failures.
@@ -267,6 +278,8 @@ static SUPFUNC g_aFunctions[] =
     SUPEXP_STK_BACK(    2,  SUPR0ChangeCR4),
     SUPEXP_STK_BACK(    1,  SUPR0EnableVTx),
     SUPEXP_STK_BACK(    0,  SUPR0SuspendVTxOnCpu),
+    SUPEXP_STK_OKAY(    1,  SUPR0FpuBegin),
+    SUPEXP_STK_OKAY(    1,  SUPR0FpuEnd),
     SUPEXP_STK_BACK(    1,  SUPR0ResumeVTxOnCpu),
     SUPEXP_STK_OKAY(    1,  SUPR0GetCurrentGdtRw),
     SUPEXP_STK_OKAY(    0,  SUPR0GetKernelFeatures),
@@ -1742,7 +1755,7 @@ static int supdrvIOCtlInnerUnrestricted(
 
             /* execute */
             pReq->u.Out.cFunctions = RT_ELEMENTS(g_aFunctions);
-            memcpy(&pReq->u.Out.aFunctions[0], g_aFunctions, sizeof(g_aFunctions));
+	    SUPDRV_MEMCPY(&pReq->u.Out.aFunctions[0], g_aFunctions, sizeof(g_aFunctions));
             pReq->Hdr.rc = VINF_SUCCESS;
             return 0;
         }
Index: VirtualBox-6.1.34/src/VBox/HostDrivers/Support/SUPLib.cpp
===================================================================
--- VirtualBox-6.1.34.orig/src/VBox/HostDrivers/Support/SUPLib.cpp
+++ VirtualBox-6.1.34/src/VBox/HostDrivers/Support/SUPLib.cpp
@@ -505,7 +505,7 @@ static int supInitFake(PSUPDRVSESSION *p
     if (g_pSupFunctions)
     {
         g_pSupFunctions->u.Out.cFunctions = RT_ELEMENTS(s_aFakeFunctions);
-        memcpy(&g_pSupFunctions->u.Out.aFunctions[0], &s_aFakeFunctions[0], sizeof(s_aFakeFunctions));
+	memcpy(&g_pSupFunctions->u.Out.aFunctions, &s_aFakeFunctions[0], sizeof(s_aFakeFunctions));
         g_pSession = (PSUPDRVSESSION)(void *)g_pSupFunctions;
         if (ppSession)
             *ppSession = g_pSession;
Index: VirtualBox-6.1.34/src/VBox/Additions/linux/sharedfolders/regops.c
===================================================================
--- VirtualBox-6.1.34.orig/src/VBox/Additions/linux/sharedfolders/regops.c
+++ VirtualBox-6.1.34/src/VBox/Additions/linux/sharedfolders/regops.c
@@ -3823,7 +3823,9 @@ struct address_space_operations vbsf_reg
     .readpage       = vbsf_readpage,
     .writepage      = vbsf_writepage,
     /** @todo Need .writepages if we want msync performance...  */
-#if RTLNX_VER_MIN(2,5,12)
+#if RTLNX_VER_MIN(5,18,0)
+    .dirty_folio    = block_dirty_folio,
+#elif RTLNX_VER_MIN(2,5,12)
     .set_page_dirty = __set_page_dirty_buffers,
 #endif
 #if RTLNX_VER_MIN(5,14,0)
Index: VirtualBox-6.1.34/Config.kmk
===================================================================
--- VirtualBox-6.1.34.orig/Config.kmk
+++ VirtualBox-6.1.34/Config.kmk
@@ -4502,11 +4502,14 @@ ifeq ($(VBOX_LDR_FMT),elf)
 TEMPLATE_VBoxR0_TOOL                = $(VBOX_GCC_TOOL)
 TEMPLATE_VBoxR0_CFLAGS              = -fno-pie -nostdinc -g $(VBOX_GCC_pipe) $(VBOX_GCC_WERR) $(VBOX_GCC_PEDANTIC_C) \
 	$(VBOX_GCC_Wno-variadic-macros) $(VBOX_GCC_R0_OPT) $(VBOX_GCC_R0_FP) -fno-strict-aliasing -fno-exceptions \
-	$(VBOX_GCC_fno-stack-protector) -fno-common $(VBOX_GCC_fvisibility-hidden) -std=gnu99 $(VBOX_GCC_IPRT_FMT_CHECK)
+	$(VBOX_GCC_fno-stack-protector) -fno-common -ffreestanding $(VBOX_GCC_fvisibility-hidden) -std=gnu99 $(VBOX_GCC_IPRT_FMT_CHECK)
 TEMPLATE_VBoxR0_CXXFLAGS            = -fno-pie -nostdinc -g $(VBOX_GCC_pipe) $(VBOX_GCC_WERR) $(VBOX_GCC_PEDANTIC_CXX) \
 	$(VBOX_GCC_Wno-variadic-macros) $(VBOX_GCC_R0_OPT) $(VBOX_GCC_R0_FP) -fno-strict-aliasing -fno-exceptions \
 	$(VBOX_GCC_fno-stack-protector) -fno-common $(VBOX_GCC_fvisibility-inlines-hidden) $(VBOX_GCC_fvisibility-hidden) \
 	-fno-rtti $(VBOX_GCC_IPRT_FMT_CHECK)
+ if $(VBOX_GCC_VERSION_CC) >= 40500 # 4.1.2 complains, 4.5.2 is okay, didn't check which version inbetween made it okay with g++.
+	TEMPLATE_VBoxR0_CXXFLAGS           += -ffreestanding
+ endif
 TEMPLATE_VBoxR0_CFLAGS.amd64        = -m64 -mno-red-zone -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -fasynchronous-unwind-tables -ffreestanding
 TEMPLATE_VBoxR0_CXXFLAGS.amd64      = -m64 -mno-red-zone -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -fasynchronous-unwind-tables
 TEMPLATE_VBoxR0_CXXFLAGS.freebsd    = -ffreestanding
Index: VirtualBox-6.1.34/include/VBox/sup.h
===================================================================
--- VirtualBox-6.1.34.orig/include/VBox/sup.h
+++ VirtualBox-6.1.34/include/VBox/sup.h
@@ -2142,7 +2142,25 @@ RT_IPRT_FORMAT_ATTR(1, 2) SUPR0Printf(co
  */
 SUPR0DECL(uint32_t) SUPR0GetKernelFeatures(void);
 
-/** @copydoc RTLogGetDefaultInstanceEx
+/**
+ * Notification from R0 VMM prior to loading the guest-FPU register state.
+ *
+ * @returns Whether the host-FPU register state has been saved by the host kernel.
+ * @param   fCtxHook    Whether thread-context hooks are enabled.
+ *
+ * @remarks Called with preemption disabled.
+ */
+SUPR0DECL(bool) SUPR0FpuBegin(bool fCtxHook);
+
+/**
+ * Notification from R0 VMM prior to saving the guest-FPU register state (and
+ * potentially restoring the host-FPU register state) in ring-0.
+ *
+ * @param   fCtxHook    Whether thread-context hooks are enabled.
+ *
+ * @remarks Called with preemption disabled.
+ */
+SUPR0DECL(void) SUPR0FpuEnd(bool fCtxHook); /** @copydoc RTLogGetDefaultInstanceEx
  * @remarks To allow overriding RTLogGetDefaultInstanceEx locally. */
 SUPR0DECL(struct RTLOGGER *) SUPR0GetDefaultLogInstanceEx(uint32_t fFlagsAndGroup);
 /** @copydoc RTLogRelGetDefaultInstanceEx
Index: VirtualBox-6.1.34/src/VBox/VMM/VMMR0/CPUMR0.cpp
===================================================================
--- VirtualBox-6.1.34.orig/src/VBox/VMM/VMMR0/CPUMR0.cpp
+++ VirtualBox-6.1.34/src/VBox/VMM/VMMR0/CPUMR0.cpp
@@ -440,6 +440,8 @@ VMMR0_INT_DECL(int) CPUMR0LoadGuestFPU(P
     Assert(!(pVCpu->cpum.s.fUseFlags & CPUM_USED_FPU_GUEST));
     Assert(!(pVCpu->cpum.s.fUseFlags & CPUM_SYNC_FPU_STATE));
 
+    /* Notify the support driver prior to loading the guest-FPU register state. */
+    SUPR0FpuBegin(false /* unused */);
     if (!pVM->cpum.s.HostFeatures.fLeakyFxSR)
     {
         Assert(!(pVCpu->cpum.s.fUseFlags & CPUM_USED_MANUAL_XMM_RESTORE));
@@ -485,6 +487,8 @@ VMMR0_INT_DECL(bool) CPUMR0FpuStateMaybe
     if (pVCpu->cpum.s.fUseFlags & (CPUM_USED_FPU_GUEST | CPUM_USED_FPU_HOST))
     {
         fSavedGuest = RT_BOOL(pVCpu->cpum.s.fUseFlags & CPUM_USED_FPU_GUEST);
+        /* Notify the support driver prior to loading the host-FPU register state. */
+        SUPR0FpuEnd(false /* unused */);
         if (!(pVCpu->cpum.s.fUseFlags & CPUM_USED_MANUAL_XMM_RESTORE))
             cpumR0SaveGuestRestoreHostFPUState(&pVCpu->cpum.s);
         else
Index: VirtualBox-6.1.34/src/VBox/HostDrivers/Support/darwin/SUPDrv-darwin.cpp
===================================================================
--- VirtualBox-6.1.34.orig/src/VBox/HostDrivers/Support/darwin/SUPDrv-darwin.cpp
+++ VirtualBox-6.1.34/src/VBox/HostDrivers/Support/darwin/SUPDrv-darwin.cpp
@@ -2002,6 +2002,17 @@ SUPR0DECL(uint32_t) SUPR0GetKernelFeatur
 }
 
 
+SUPR0DECL(bool) SUPR0FpuBegin(bool fCtxHook)
+{
+    RT_NOREF(fCtxHook);
+    return false;
+}
+
+
+SUPR0DECL(void) SUPR0FpuEnd(bool fCtxHook)
+{
+    RT_NOREF(fCtxHook);
+}
 /*
  *
  * org_virtualbox_SupDrv
Index: VirtualBox-6.1.34/src/VBox/HostDrivers/Support/freebsd/SUPDrv-freebsd.c
===================================================================
--- VirtualBox-6.1.34.orig/src/VBox/HostDrivers/Support/freebsd/SUPDrv-freebsd.c
+++ VirtualBox-6.1.34/src/VBox/HostDrivers/Support/freebsd/SUPDrv-freebsd.c
@@ -640,3 +640,15 @@ SUPR0DECL(uint32_t) SUPR0GetKernelFeatur
     return 0;
 }
 
+SUPR0DECL(bool) SUPR0FpuBegin(bool fCtxHook)
+{
+    RT_NOREF(fCtxHook);
+    return false;
+}
+
+
+SUPR0DECL(void) SUPR0FpuEnd(bool fCtxHook)
+{
+    RT_NOREF(fCtxHook);
+}
+
Index: VirtualBox-6.1.34/src/VBox/HostDrivers/Support/os2/SUPDrv-os2.cpp
===================================================================
--- VirtualBox-6.1.34.orig/src/VBox/HostDrivers/Support/os2/SUPDrv-os2.cpp
+++ VirtualBox-6.1.34/src/VBox/HostDrivers/Support/os2/SUPDrv-os2.cpp
@@ -541,3 +541,15 @@ SUPR0DECL(uint32_t) SUPR0GetKernelFeatur
     return 0;
 }
 
+SUPR0DECL(bool) SUPR0FpuBegin(bool fCtxHook)
+{
+    RT_NOREF(fCtxHook);
+    return false;
+}
+
+
+SUPR0DECL(void) SUPR0FpuEnd(bool fCtxHook)
+{
+    RT_NOREF(fCtxHook);
+}
+
Index: VirtualBox-6.1.34/src/VBox/HostDrivers/Support/win/SUPDrv-win.cpp
===================================================================
--- VirtualBox-6.1.34.orig/src/VBox/HostDrivers/Support/win/SUPDrv-win.cpp
+++ VirtualBox-6.1.34/src/VBox/HostDrivers/Support/win/SUPDrv-win.cpp
@@ -2703,6 +2703,16 @@ SUPR0DECL(uint32_t) SUPR0GetKernelFeatur
     return 0;
 }
 
+SUPR0DECL(bool) SUPR0FpuBegin(bool fCtxHook)
+{
+    RT_NOREF(fCtxHook);
+    return false;
+}
+
+SUPR0DECL(void) SUPR0FpuEnd(bool fCtxHook)
+{
+    RT_NOREF(fCtxHook);
+}
 
 SUPR0DECL(int) SUPR0IoCtlSetupForHandle(PSUPDRVSESSION pSession, intptr_t hHandle, uint32_t fFlags, PSUPR0IOCTLCTX *ppCtx)
 {
Index: VirtualBox-6.1.34/src/VBox/HostDrivers/Support/solaris/SUPDrv-solaris.c
===================================================================
--- VirtualBox-6.1.34.orig/src/VBox/HostDrivers/Support/solaris/SUPDrv-solaris.c
+++ VirtualBox-6.1.34/src/VBox/HostDrivers/Support/solaris/SUPDrv-solaris.c
@@ -1309,3 +1309,15 @@ SUPR0DECL(uint32_t) SUPR0GetKernelFeatur
     return 0;
 }
 
+SUPR0DECL(bool) SUPR0FpuBegin(bool fCtxHook)
+{
+    RT_NOREF(fCtxHook);
+    return false;
+}
+
+
+SUPR0DECL(void) SUPR0FpuEnd(bool fCtxHook)
+{
+    RT_NOREF(fCtxHook);
+}
+
Index: VirtualBox-6.1.34/src/VBox/HostDrivers/Support/linux/SUPDrv-linux.c
===================================================================
--- VirtualBox-6.1.34.orig/src/VBox/HostDrivers/Support/linux/SUPDrv-linux.c
+++ VirtualBox-6.1.34/src/VBox/HostDrivers/Support/linux/SUPDrv-linux.c
@@ -1454,6 +1454,31 @@ SUPR0DECL(uint32_t) SUPR0GetKernelFeatur
 }
 
 
+SUPR0DECL(bool) SUPR0FpuBegin(bool fCtxHook)
+{
+    RT_NOREF(fCtxHook);
+#if RTLNX_VER_MIN(5,18,0)
+    kernel_fpu_begin();
+    /* if (fCtxHook) */
+        preempt_enable();  /* HACK ALERT! undo the implicit preempt_disable() in kernel_fpu_begin(). */
+    return true;
+#else
+    return false;
+#endif
+}
+
+
+SUPR0DECL(void) SUPR0FpuEnd(bool fCtxHook)
+{
+    RT_NOREF(fCtxHook);
+#if RTLNX_VER_MIN(5,18,0)
+    /* if (fCtxHook) */
+        preempt_disable();  /* HACK ALERT! undo the implicit preempt_enable() in SUPR0FpuBegin(). */
+    kernel_fpu_end();
+#endif
+}
+
+
 int VBOXCALL    supdrvOSGetCurrentGdtRw(RTHCUINTPTR *pGdtRw)
 {
 #if RTLNX_VER_MIN(4,12,0)
