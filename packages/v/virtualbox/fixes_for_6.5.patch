Index: VirtualBox-7.0.10/src/VBox/Additions/linux/drm/vbox_fb.c
===================================================================
--- VirtualBox-7.0.10.orig/src/VBox/Additions/linux/drm/vbox_fb.c
+++ VirtualBox-7.0.10/src/VBox/Additions/linux/drm/vbox_fb.c
@@ -197,9 +197,13 @@ static struct fb_ops vboxfb_ops = {
 	.owner = THIS_MODULE,
 	.fb_check_var = drm_fb_helper_check_var,
 	.fb_set_par = drm_fb_helper_set_par,
+#if RTLNX_VER_MIN(6, 5, 0)
+	FB_DEFAULT_SYS_OPS,
+#else
 	.fb_fillrect = drm_fb_helper_sys_fillrect,
 	.fb_copyarea = drm_fb_helper_sys_copyarea,
 	.fb_imageblit = drm_fb_helper_sys_imageblit,
+#endif
 	.fb_pan_display = drm_fb_helper_pan_display,
 	.fb_blank = drm_fb_helper_blank,
 	.fb_setcmap = drm_fb_helper_setcmap,
Index: VirtualBox-7.0.10/include/iprt/cdefs.h
===================================================================
--- VirtualBox-7.0.10.orig/include/iprt/cdefs.h
+++ VirtualBox-7.0.10/include/iprt/cdefs.h
@@ -38,8 +38,9 @@
 #ifndef RT_WITHOUT_PRAGMA_ONCE
 # pragma once
 #endif
-
-
+#if defined(DECLARE_FLEX_ARRAY)
+# include <linux/version.h>
+#endif
 /** @defgroup grp_rt_cdefs  IPRT Common Definitions and Macros
  * @{
  */
@@ -2961,6 +2962,12 @@
  * @note    GCC does not permit using this in nested structures, where as MSC
  *          does.  So, use RT_FLEXIBLE_ARRAY_NESTED for that.
  *
+ * @note    Linux kernels 6.5+ enforce field-spanning write operations
+ *          and require flexible arrays to end with 'array[]' rather than array[1].
+ *          This construct fails with unions, but VB does not have any such unions.
+ *          This header is used with both kernel- and user-mode code. In user-mode,
+ *          the old method works. If DECLARE_FLEX_ARRAY is defined, we are
+ *          building kernel-mode code and RT_FLEXIBLE_ARRAY is set to blank.
  * @sa      RT_FLEXIBLE_ARRAY_NESTED, RT_FLEXIBLE_ARRAY_IN_UNION
  */
 #if RT_MSC_PREREQ(RT_MSC_VER_VS2005) /** @todo Probably much much earlier. */ \
@@ -2976,10 +2983,18 @@
 # if __STDC_VERSION__ >= 1999901L
 #  define RT_FLEXIBLE_ARRAY
 # else
-#  define RT_FLEXIBLE_ARRAY                     1
+#  if defined(DECLARE_FLEX_ARRAY)
+#    define RT_FLEXIBLE_ARRAY
+#  else
+#    define RT_FLEXIBLE_ARRAY                     1
+#  endif
 # endif
 #else
+# if defined(DECLARE_FLEX_ARRAY)
+#  define RT_FLEXIBLE_ARRAY
+# else
 # define RT_FLEXIBLE_ARRAY                      1
+# endif
 #endif
 
 /** @def RT_FLEXIBLE_ARRAY_EXTENSION
@@ -3008,7 +3023,9 @@
 #ifdef _MSC_VER
 # define RT_FLEXIBLE_ARRAY_NESTED               RT_FLEXIBLE_ARRAY
 #else
+# if !defined(DECLARE_FLEX_ARRAY)
 # define RT_FLEXIBLE_ARRAY_NESTED               1
+# endif
 #endif
 
 /** @def RT_FLEXIBLE_ARRAY_IN_UNION
@@ -3024,7 +3041,9 @@
 #ifdef _MSC_VER
 # define RT_FLEXIBLE_ARRAY_IN_UNION             RT_FLEXIBLE_ARRAY
 #else
-# define RT_FLEXIBLE_ARRAY_IN_UNION             1
+# if !defined(DECLARE_FLEX_ARRAY)
+#  define RT_FLEXIBLE_ARRAY_IN_UNION             1
+# endif
 #endif
 
 /** @def RT_FLEXIBLE_ARRAY_IN_NESTED_UNION
@@ -3037,7 +3056,9 @@
 #ifdef _MSC_VER
 # define RT_FLEXIBLE_ARRAY_IN_NESTED_UNION      RT_FLEXIBLE_ARRAY_NESTED
 #else
-# define RT_FLEXIBLE_ARRAY_IN_NESTED_UNION      1
+# if !defined(DECLARE_FLEX_ARRAY)
+#  define RT_FLEXIBLE_ARRAY_IN_NESTED_UNION      1
+# endif
 #endif
 
 /** @def RT_UNION_NM
Index: VirtualBox-7.0.10/include/VBox/VBoxGuest.h
===================================================================
--- VirtualBox-7.0.10.orig/include/VBox/VBoxGuest.h
+++ VirtualBox-7.0.10/include/VBox/VBoxGuest.h
@@ -458,8 +458,12 @@ typedef struct VBGLIOCLOG
         {
             /** The log message.
              * The length is determined from the input size and zero termination. */
-            char                    szMsg[RT_FLEXIBLE_ARRAY_IN_NESTED_UNION];
-        } In;
+#if defined(DECLARE_FLEX_ARRAY)
+		DECLARE_FLEX_ARRAY(char, szMsg);
+#else	
+		char                    szMsg[RT_FLEXIBLE_ARRAY_IN_NESTED_UNION];
+#endif
+     	} In;
     } u;
 } VBGLIOCLOG, RT_FAR *PVBGLIOCLOG;
 /** @} */
Index: VirtualBox-7.0.10/src/VBox/Additions/linux/sharedfolders/regops.c
===================================================================
--- VirtualBox-7.0.10.orig/src/VBox/Additions/linux/sharedfolders/regops.c
+++ VirtualBox-7.0.10/src/VBox/Additions/linux/sharedfolders/regops.c
@@ -1,4 +1,4 @@
-/* $Id: regops.c $ */
+/* $Id: regops.c 100799 2023-08-04 18:04:14Z vboxsync $ */
 /** @file
  * vboxsf - VBox Linux Shared Folders VFS, regular file inode and file operations.
  */
@@ -58,6 +58,14 @@
 # define SEEK_END 2
 #endif
 
+#if RTLNX_VER_MIN(6,4,0)
+# define VBOX_ITER_IOV_ADDR(a_iter)  iter_iov_addr(a_iter)
+#elif RTLNX_VER_MIN(3,19,0)
+# define VBOX_ITER_IOV_ADDR(a_iter)  (a_iter->kvec->iov_base + a_iter->iov_offset)
+#else
+# define VBOX_ITER_IOV_ADDR(a_iter)  (a_iter->iov->iov_base  + a_iter->iov_offset)
+#endif
+
 #if RTLNX_VER_MAX(3,16,0)
 # define iter_is_iovec(a_pIter) ( !((a_pIter)->type & ITER_KVEC) )
 #elif RTLNX_VER_MAX(3,19,0)
@@ -96,6 +104,14 @@
 # define VBSF_GET_ITER_IOV(_iter) iter->iov
 #endif
 
+/** @def  VBOX_IOV_ITER_IS_KVEC
+ * Test if iov iter type is ITER_KVEC. */
+#if RTLNX_VER_MIN(4,20,0)
+# define VBOX_IOV_ITER_IS_KVEC(a_iter)  iov_iter_is_kvec(a_iter)
+#else
+# define VBOX_IOV_ITER_IS_KVEC(a_iter)  (VBSF_GET_ITER_TYPE(iter) & ITER_KVEC)
+#endif
+
 
 /*********************************************************************************************************************************
 *   Structures and Typedefs                                                                                                      *
@@ -254,7 +270,11 @@ static ssize_t vbsf_iov_iter_get_pages(s
             size_t              cPagesLocked;
 
             down_read(&pTask->mm->mmap_sem);
-            cPagesLocked = get_user_pages(pTask, pTask->mm, uPtrFrom, cPages, iter->v_write, 1 /*force*/, papPages, NULL);
+            cPagesLocked = get_user_pages(pTask, pTask->mm, uPtrFrom, cPages, iter->v_write, 1 /*force*/, papPages,
+# if RTLNX_VER_MAX(6, 5, 0)
+					  NULL
+# endif
+					  );
             up_read(&pTask->mm->mmap_sem);
             if (cPagesLocked == cPages) {
                 size_t cbRet = (cPages << PAGE_SHIFT) - offPg0;
@@ -367,8 +387,8 @@ static size_t copy_from_iter(uint8_t *pb
                 if (cbThisCopy > cbToCopy)
                     cbThisCopy = cbToCopy;
                 if (pSrcIter->type & ITER_KVEC)
-                    memcpy(pbDst, (void *)pSrcIter->iov->iov_base + pSrcIter->iov_offset, cbThisCopy);
-                else if (copy_from_user(pbDst, pSrcIter->iov->iov_base + pSrcIter->iov_offset, cbThisCopy) != 0)
+                    memcpy(pbDst, (void *)VBOX_ITER_IOV_ADDR(pSrcIter), cbThisCopy);
+                else if (copy_from_user(pbDst, VBOX_ITER_IOV_ADDR(pSrcIter), cbThisCopy) != 0)
                     break;
                 pbDst    += cbThisCopy;
                 cbToCopy -= cbThisCopy;
@@ -406,8 +426,8 @@ static size_t copy_to_iter(uint8_t const
                 if (cbThisCopy > cbToCopy)
                     cbThisCopy = cbToCopy;
                 if (pDstIter->type & ITER_KVEC)
-                    memcpy((void *)pDstIter->iov->iov_base + pDstIter->iov_offset, pbSrc, cbThisCopy);
-                else if (copy_to_user(pDstIter->iov->iov_base + pDstIter->iov_offset, pbSrc, cbThisCopy) != 0) {
+                    memcpy((void *)VBOX_ITER_IOV_ADDR(pDstIter), pbSrc, cbThisCopy);
+                else if (copy_to_user(VBOX_ITER_IOV_ADDR(pDstIter), pbSrc, cbThisCopy) != 0) {
                     break;
                 }
                 pbSrc    += cbThisCopy;
@@ -1462,12 +1482,16 @@ DECLINLINE(int) vbsf_lock_user_pages(uin
     ssize_t cPagesLocked = get_user_pages_unlocked(current, current->mm, uPtrFrom, cPages, papPages,
                                                    fWrite ? FOLL_WRITE | FOLL_FORCE : FOLL_FORCE);
 # elif RTLNX_VER_MIN(4,0,0)
-    ssize_t cPagesLocked = get_user_pages_unlocked(current, current->mm, uPtrFrom, cPages, fWrite, 1 /*force*/, papPages);
-# else
+	    ssize_t cPagesLocked = get_user_pages_unlocked(current, current->mm, uPtrFrom, cPages, fWrite, 1 /*force*/, papPages);
+	# else
     struct task_struct *pTask = current;
     ssize_t cPagesLocked;
     down_read(&pTask->mm->mmap_sem);
-    cPagesLocked = get_user_pages(pTask, pTask->mm, uPtrFrom, cPages, fWrite, 1 /*force*/, papPages, NULL);
+    cPagesLocked = get_user_pages(pTask, pTask->mm, uPtrFrom, cPages, fWrite, 1 /*force*/, papPages,
+# if RTLNX_VER_MAX(6, 5, 0)
+    NULL
+#endif
+    );
     up_read(&pTask->mm->mmap_sem);
 # endif
     *pfLockPgHack = false;
@@ -2152,7 +2176,8 @@ static int vbsf_iter_lock_pages(struct i
     int    rc       = 0;
 
     Assert(iov_iter_count(iter) + pStash->cb > 0);
-    if (!(VBSF_GET_ITER_TYPE(iter) & ITER_KVEC)) {
+    if (!VBOX_IOV_ITER_IS_KVEC(iter))
+    {
         /*
          * Do we have a stashed page?
          */
@@ -2309,11 +2334,7 @@ static int vbsf_iter_lock_pages(struct i
                 cbSeg = iov_iter_single_seg_count(iter);
             }
 
-# if RTLNX_VER_MIN(3,19,0)
-            pbBuf    = iter->kvec->iov_base + iter->iov_offset;
-# else
-            pbBuf    = iter->iov->iov_base  + iter->iov_offset;
-# endif
+            pbBuf = VBOX_ITER_IOV_ADDR(iter);
             offStart = (uintptr_t)pbBuf & PAGE_OFFSET_MASK;
             if (!cPages)
                 offPage0 = offStart;
