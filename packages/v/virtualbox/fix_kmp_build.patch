Index: VirtualBox-7.0.4/Config.kmk
===================================================================
--- VirtualBox-7.0.4.orig/Config.kmk
+++ VirtualBox-7.0.4/Config.kmk
@@ -782,6 +782,7 @@ if1of ($(KBUILD_TARGET), linux solaris)
  VBOX_WITH_XPCOM_NAMESPACE_CLEANUP = 1
 endif
 # The webservices api.
+# disabled for now due to pending license clarification
 VBOX_WITH_WEBSERVICES = 1
 VBOX_WITH_WEBSERVICES_SSL = 1
 # The Qt GUI.
@@ -1408,7 +1409,7 @@ endif
 VBOX_ONLY_BUILD_NEW := $(strip $(foreach x, ADDITIONS DOCS EXTPACKS SDK VALIDATIONKIT\
 	, $(if-expr defined(VBOX_ONLY_$(x)),VBOX_ONLY_$(x))))
 ifneq ($(VBOX_ONLY_BUILD),$(VBOX_ONLY_BUILD_NEW))
- $(error VBox: LocalConfig.kmk changed the VBOX_ONLY_ build status, VBOX_ONLY_* must be on the kmk command line or in the environment: $(VBOX_ONLY_BUILD) -> $(VBOX_ONLY_BUILD_NEW))
+# $(error VBox: LocalConfig.kmk changed the VBOX_ONLY_ build status, VBOX_ONLY_* must be on the kmk command line or in the environment: $(VBOX_ONLY_BUILD) -> $(VBOX_ONLY_BUILD_NEW))
 endif
 
 #
@@ -1578,7 +1579,7 @@ endif
 #
 ifdef VBOX_HEADLESS
  VBOX_WITH_QTGUI=
- VBOX_WITH_VBOXSDL=
+# VBOX_WITH_VBOXSDL=
  VBOX_WITH_VRDP_RDESKTOP=
 endif
 
Index: VirtualBox-7.0.4/configure
===================================================================
--- VirtualBox-7.0.4.orig/configure
+++ VirtualBox-7.0.4/configure
@@ -1202,8 +1202,8 @@ check_sdl()
   if [ -n "$foundsdl" ]; then
     cat > $ODIR.tmp_src.cc << EOF
 #include <cstdio>
-#include <SDL.h>
-#include <SDL_main.h>
+#include <SDL/SDL.h>
+#include <SDL/SDL_main.h>
 #undef main
 extern "C" int main(int argc, char** argv)
 {
Index: VirtualBox-7.0.4/src/VBox/Frontends/VBoxSDL/VBoxSDL.h
===================================================================
--- VirtualBox-7.0.4.orig/src/VBox/Frontends/VBoxSDL/VBoxSDL.h
+++ VirtualBox-7.0.4/src/VBox/Frontends/VBoxSDL/VBoxSDL.h
@@ -45,7 +45,7 @@
 # pragma warning(disable: 4121) /* warning C4121: 'SDL_SysWMmsg' : alignment of a member was sensitive to packing*/
 # pragma warning(disable: 4668) /* warning C4668: '__GNUC__' is not defined as a preprocessor macro, replacing with '0' for '#if/#elif' */
 #endif
-#include <SDL.h>
+#include <SDL/SDL.h>
 #ifdef _MSC_VER
 # pragma warning(pop)
 #endif
Index: VirtualBox-7.0.4/src/VBox/Frontends/Makefile.kmk
===================================================================
--- VirtualBox-7.0.4.orig/src/VBox/Frontends/Makefile.kmk
+++ VirtualBox-7.0.4/src/VBox/Frontends/Makefile.kmk
@@ -44,9 +44,9 @@ ifndef VBOX_ONLY_DOCS
    include $(PATH_SUB_CURRENT)/VBoxBugReport/Makefile.kmk
   endif
  endif
- ifdef VBOX_WITH_VBOXSDL
+# ifdef VBOX_WITH_VBOXSDL
   include $(PATH_SUB_CURRENT)/VBoxSDL/Makefile.kmk
- endif
+# endif
  ifdef VBOX_WITH_VBOXFB
   include $(PATH_SUB_CURRENT)/VBoxFB/Makefile.kmk
  endif
Index: VirtualBox-7.0.4/src/libs/Makefile.kmk
===================================================================
--- VirtualBox-7.0.4.orig/src/libs/Makefile.kmk
+++ VirtualBox-7.0.4/src/libs/Makefile.kmk
@@ -104,13 +104,7 @@ endif
 
 
 # SoftFloat is used by the VMM for FPU emulation.
-if  (!defined(VBOX_ONLY_BUILD) && "$(intersects $(KBUILD_TARGET_ARCH),$(VBOX_SUPPORTED_HOST_ARCHS))" != "") \
- || (   defined(VBOX_WITH_NOCRT_STATIC) \
-     && "$(KBUILD_TARGET)" == "win" \
-     && (   defined(VBOX_ONLY_ADDITIONS) \
-         || (!defined(VBOX_ONLY_BUILD) && defined(VBOX_WITH_ADDITIONS))))
  include $(PATH_SUB_CURRENT)/softfloat-3e/Makefile.kmk
-endif
 
 
 # zlib is used by the IPRT compression code, libpng and others.
Index: VirtualBox-7.0.4/src/VBox/Additions/x11/vboxvideo/VBoxVideoIPRT.h
===================================================================
--- VirtualBox-7.0.4.orig/src/VBox/Additions/x11/vboxvideo/VBoxVideoIPRT.h
+++ VirtualBox-7.0.4/src/VBox/Additions/x11/vboxvideo/VBoxVideoIPRT.h
@@ -49,7 +49,6 @@ typedef enum
 # define RT_C_DECLS_END }
 #endif
 
-#if defined(IN_XF86_MODULE) && !defined(NO_ANSIC)
 # ifdef __cplusplus
 /* xf86Module.h redefines this. */
 #  define NULL 0
@@ -57,7 +56,6 @@ typedef enum
 RT_C_DECLS_BEGIN
 # include "xf86_ansic.h"
 RT_C_DECLS_END
-#endif  /* defined(IN_XF86_MODULE) && !defined(NO_ANSIC) */
 #define __STDC_LIMIT_MACROS  /* define *INT*_MAX on C++ too. */
 #include "compiler.h"  /* Can pull in <sdtint.h>.  Must come after xf86_ansic.h on XFree86. */
 #include <X11/Xfuncproto.h>
Index: VirtualBox-7.0.4/src/VBox/Additions/x11/vboxvideo/xf86_ansic.h
===================================================================
--- /dev/null
+++ VirtualBox-7.0.4/src/VBox/Additions/x11/vboxvideo/xf86_ansic.h
@@ -0,0 +1,351 @@
+/*
+ * Copyright 1997-2000 by The XFree86 Project, Inc
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the names of the above listed copyright holders
+ * not be used in advertising or publicity pertaining to distribution of
+ * the software without specific, written prior permission.  The above listed
+ * copyright holders make no representations about the suitability of this
+ * software for any purpose.  It is provided "as is" without express or
+ * implied warranty.
+ *
+ * THE ABOVE LISTED COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD
+ * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
+ * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+ * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/xf86_ansic.h,v 3.49 2003/02/22 06:00:39 dawes Exp $ */
+
+#ifndef _XF86_ANSIC_H
+#define _XF86_ANSIC_H
+
+/* Handle <stdarg.h> */
+
+#ifndef IN_MODULE
+# include <stdarg.h>
+#else /* !IN_MODULE */
+# ifndef __OS2ELF__
+#  include <stdarg.h>
+# else /* __OS2ELF__ */
+   /* EMX/gcc_elf under OS/2 does not have native header files */
+#  if !defined (_VA_LIST)
+#   define _VA_LIST
+    typedef char *va_list;
+#  endif
+#  define _VA_ROUND(t) ((sizeof (t) + 3) & -4)
+#  if !defined (va_start)
+#   define va_start(ap,v) ap = (va_list)&v + ((sizeof (v) + 3) & -4)
+#   define va_end(ap) (ap = 0, (void)0)
+#   define va_arg(ap,t) (ap += _VA_ROUND (t), *(t *)(ap - _VA_ROUND (t)))
+#  endif
+# endif /* __OS2ELF__ */
+#endif /* IN_MODULE */
+
+/*
+ * The first set of definitions are required both for modules and
+ * libc_wrapper.c.
+ */
+
+#if defined(XFree86LOADER) || defined(NEED_XF86_TYPES)
+
+#if !defined(SYSV) && !defined(SVR4) && !defined(Lynx) || defined(SCO)
+#define HAVE_VSSCANF
+#define HAVE_VFSCANF
+#endif
+
+#ifndef NULL
+#if (defined(SVR4) || defined(SYSV)) && !defined(__GNUC__)
+#define NULL 0
+#else
+#define NULL ((void *)0)
+#endif
+#endif
+#ifndef EOF
+#define EOF (-1)
+#endif
+
+#ifndef PATH_MAX
+#define PATH_MAX 1024
+#endif
+
+/* <limits.h> stuff */
+#define x_BITSPERBYTE 8
+#define x_BITS(type)  (x_BITSPERBYTE * (int)sizeof(type))
+#define x_SHORTBITS x_BITS(short)
+#define x_INTBITS x_BITS(int)
+#define x_LONGBITS x_BITS(long)
+#ifndef SHRT_MIN
+#define SHRT_MIN ((short)(1 << (x_SHORTBITS - 1)))
+#endif
+
+#ifndef FONTMODULE
+#include "misc.h"
+#endif
+#include "xf86_libc.h"
+#ifndef SHRT_MAX
+#define SHRT_MAX ((short)~SHRT_MIN)
+#endif
+#ifndef USHRT_MAX
+#define USHRT_MAX ((unsigned short)~0)
+#endif
+#ifndef MINSHORT
+#define MINSHORT SHRT_MIN
+#endif
+#ifndef MAXSHORT
+#define MAXSHORT SHRT_MAX
+#endif
+#ifndef INT_MIN
+#define INT_MIN (1 << (x_INTBITS - 1))
+#endif
+#ifndef INT_MAX
+#define INT_MAX (~INT_MIN)
+#endif
+#ifndef UINT_MAX
+#define UINT_MAX (~0)
+#endif
+#ifndef MININT
+#define MININT INT_MIN
+#endif
+#ifndef MAXINT
+#define MAXINT INT_MAX
+#endif
+#ifndef LONG_MIN
+#define LONG_MIN ((long)(1 << (x_LONGBITS - 1)))
+#endif
+#ifndef LONG_MAX
+#define LONG_MAX ((long)~LONG_MIN)
+#endif
+#ifndef ULONG_MAX
+#define ULONG_MAX ((unsigned long)~0UL)
+#endif
+#ifndef MINLONG
+#define MINLONG LONG_MIN
+#endif
+#ifndef MAXLONG
+#define MAXLONG LONG_MAX
+#endif
+
+#endif /* XFree86LOADER || NEED_XF86_TYPES */
+
+#if defined(XFree86LOADER) || defined(NEED_XF86_PROTOTYPES)
+/*
+ * ANSI C compilers only.
+ */
+
+/* ANSI C emulation library */
+
+extern void xf86abort(void);
+extern int xf86abs(int);
+extern double xf86acos(double);
+extern double xf86asin(double);
+extern double xf86atan(double);
+extern double xf86atan2(double,double);
+extern double xf86atof(const char*);
+extern int xf86atoi(const char*);
+extern long xf86atol(const char*);
+extern void *xf86bsearch(const void *, const void *, xf86size_t, xf86size_t,
+			 int (*)(const void *, const void *));
+extern double xf86ceil(double);
+extern void* xf86calloc(xf86size_t,xf86size_t);
+extern void xf86clearerr(XF86FILE*);
+extern double xf86cos(double);
+extern void xf86exit(int);
+extern double xf86exp(double);
+extern double xf86fabs(double);
+extern int xf86fclose(XF86FILE*);
+extern int xf86feof(XF86FILE*);
+extern int xf86ferror(XF86FILE*);
+extern int xf86fflush(XF86FILE*);
+extern int xf86fgetc(XF86FILE*);
+extern int xf86getc(XF86FILE*);
+extern int xf86fgetpos(XF86FILE*,XF86fpos_t*);
+extern char* xf86fgets(char*,INT32,XF86FILE*);
+extern int xf86finite(double);
+extern double xf86floor(double);
+extern double xf86fmod(double,double);
+extern XF86FILE* xf86fopen(const char*,const char*);
+extern double xf86frexp(double, int*);
+extern int xf86printf(const char*,...);
+extern int xf86fprintf(XF86FILE*,const char*,...);
+extern int xf86fputc(int,XF86FILE*);
+extern int xf86fputs(const char*,XF86FILE*);
+extern xf86size_t xf86fread(void*,xf86size_t,xf86size_t,XF86FILE*);
+extern void xf86free(void*);
+extern XF86FILE* xf86freopen(const char*,const char*,XF86FILE*);
+#if defined(HAVE_VFSCANF) || !defined(NEED_XF86_PROTOTYPES)
+extern int xf86fscanf(XF86FILE*,const char*,...);
+#else
+extern int xf86fscanf(/*XF86FILE*,const char*,char *,char *,char *,char *,
+			char *,char *,char *,char *,char *,char * */);
+#endif
+extern int xf86fseek(XF86FILE*,long,int);
+extern int xf86fsetpos(XF86FILE*,const XF86fpos_t*);
+extern long xf86ftell(XF86FILE*);
+extern xf86size_t xf86fwrite(const void*,xf86size_t,xf86size_t,XF86FILE*);
+extern char* xf86getenv(const char*);
+extern int xf86isalnum(int);
+extern int xf86isalpha(int);
+extern int xf86iscntrl(int);
+extern int xf86isdigit(int);
+extern int xf86isgraph(int);
+extern int xf86islower(int);
+extern int xf86isprint(int);
+extern int xf86ispunct(int);
+extern int xf86isspace(int);
+extern int xf86isupper(int);
+extern int xf86isxdigit(int);
+extern long xf86labs(long);
+extern double xf86ldexp(double,int);
+extern double xf86log(double);
+extern double xf86log10(double);
+extern void* xf86malloc(xf86size_t);
+extern void* xf86memchr(const void*,int,xf86size_t);
+extern int xf86memcmp(const void*,const void*,xf86size_t);
+extern void* xf86memcpy(void*,const void*,xf86size_t);
+extern void* xf86memmove(void*,const void*,xf86size_t);
+extern void* xf86memset(void*,int,xf86size_t);
+extern double xf86modf(double,double*);
+extern void xf86perror(const char*);
+extern double xf86pow(double,double);
+extern void xf86qsort(void*, xf86size_t, xf86size_t,
+                      int(*)(const void*, const void*));
+extern void* xf86realloc(void*,xf86size_t);
+extern int xf86remove(const char*);
+extern int xf86rename(const char*,const char*);
+extern void xf86rewind(XF86FILE*);
+extern int xf86setbuf(XF86FILE*,char*);
+extern int xf86setvbuf(XF86FILE*,char*,int,xf86size_t);
+extern double xf86sin(double);
+extern int xf86sprintf(char*,const char*,...);
+extern int xf86snprintf(char*,xf86size_t,const char*,...);
+extern double xf86sqrt(double);
+#if defined(HAVE_VSSCANF) || !defined(NEED_XF86_PROTOTYPES)
+extern int xf86sscanf(char*,const char*,...);
+#else
+extern int xf86sscanf(/*char*,const char*,char *,char *,char *,char *,
+			char *,char *,char *,char *,char *,char * */);
+#endif
+extern char* xf86strcat(char*,const char*);
+extern char* xf86strchr(const char*, int c);
+extern int xf86strcmp(const char*,const char*);
+extern int xf86strcasecmp(const char*,const char*);
+extern char* xf86strcpy(char*,const char*);
+extern xf86size_t xf86strcspn(const char*,const char*);
+extern char* xf86strerror(int);
+extern xf86size_t xf86strlen(const char*);
+extern char* xf86strncat(char *, const char *, xf86size_t);
+extern int xf86strncmp(const char*,const char*,xf86size_t);
+extern int xf86strncasecmp(const char*,const char*,xf86size_t);
+extern char* xf86strncpy(char*,const char*,xf86size_t);
+extern char* xf86strpbrk(const char*,const char*);
+extern char* xf86strrchr(const char*,int);
+extern xf86size_t xf86strspn(const char*,const char*);
+extern char* xf86strstr(const char*,const char*);
+extern double xf86strtod(const char*,char**);
+extern char* xf86strtok(char*,const char*);
+extern long xf86strtol(const char*,char**,int);
+extern unsigned long xf86strtoul(const char*,char**,int);
+extern double xf86tan(double);
+extern XF86FILE* xf86tmpfile(void);
+extern char* xf86tmpnam(char*);
+extern int xf86tolower(int);
+extern int xf86toupper(int);
+extern int xf86ungetc(int,XF86FILE*);
+extern int xf86vfprintf(XF86FILE*,const char*,va_list);
+extern int xf86vsprintf(char*,const char*,va_list);
+extern int xf86vsnprintf(char*,xf86size_t,const char*,va_list);
+
+extern int xf86open(const char*, int,...);
+extern int xf86close(int);
+extern long xf86lseek(int, long, int);
+extern int xf86ioctl(int, unsigned long, pointer);
+extern xf86ssize_t xf86read(int, void *, xf86size_t);
+extern xf86ssize_t xf86write(int, const void *, xf86size_t);
+extern void* xf86mmap(void*, xf86size_t, int, int, int, xf86size_t /* off_t */);
+extern int xf86munmap(void*, xf86size_t);
+extern int xf86stat(const char *, struct xf86stat_s *);
+extern int xf86fstat(int, struct xf86stat_s *);
+extern int xf86access(const char *, int);
+extern int xf86errno;
+extern int xf86GetErrno(void);
+
+extern double xf86HUGE_VAL;
+
+extern double xf86hypot(double,double);
+
+/* non-ANSI C functions */
+extern XF86DIR* xf86opendir(const char*);
+extern int xf86closedir(XF86DIR*);
+extern XF86DIRENT* xf86readdir(XF86DIR*);
+extern void xf86rewinddir(XF86DIR*);
+extern void xf86bcopy(const void*,void*,xf86size_t);
+extern int xf86ffs(int);
+extern char* xf86strdup(const char*);
+extern void xf86bzero(void*,unsigned int);
+extern int xf86execl(const char *, const char *, ...);
+extern long xf86fpossize(void);
+extern int xf86chmod(const char *, xf86mode_t);
+extern int xf86chown(const char *, xf86uid_t, xf86gid_t);
+extern xf86uid_t xf86geteuid(void);
+extern xf86gid_t xf86getegid(void);
+extern int xf86getpid(void);
+extern int xf86mknod(const char *, xf86mode_t, xf86dev_t);
+extern int xf86mkdir(const char *, xf86mode_t);
+unsigned int xf86sleep(unsigned int seconds);
+/* sysv IPC */
+extern int xf86shmget(xf86key_t key, int size, int xf86shmflg);
+extern char * xf86shmat(int id, char *addr, int xf86shmflg);
+extern int xf86shmdt(char *addr);
+extern int xf86shmctl(int id, int xf86cmd, pointer buf);
+
+extern int xf86setjmp(xf86jmp_buf env);
+extern int xf86setjmp1(xf86jmp_buf env, int);
+extern int xf86setjmp1_arg2(void);
+extern int xf86setjmperror(xf86jmp_buf env);
+extern int xf86getjmptype(void);
+extern void xf86longjmp(xf86jmp_buf env, int val);
+#define xf86setjmp_macro(env) \
+	(xf86getjmptype() == 0 ? xf86setjmp((env)) : \
+	(xf86getjmptype() == 1 ? xf86setjmp1((env), xf86setjmp1_arg2()) : \
+		xf86setjmperror((env))))
+
+#else /* XFree86LOADER || NEED_XF86_PROTOTYPES */
+#include <unistd.h>
+#include <stdio.h>
+#include <sys/ioctl.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <ctype.h>
+#ifdef HAVE_SYSV_IPC
+#include <sys/ipc.h>
+#include <sys/shm.h>
+#endif
+#include <sys/stat.h>
+#define stat_t struct stat
+#endif /* XFree86LOADER || NEED_XF86_PROTOTYPES */
+
+/*
+ * These things are always required by drivers (but not by libc_wrapper.c),
+ * even for a static server because some OSs don't provide them.
+ */
+
+extern int xf86getpagesize(void);
+extern void xf86usleep(unsigned long);
+extern void xf86getsecs(long *, long *);
+#ifndef DONT_DEFINE_WRAPPERS
+#undef getpagesize
+#define getpagesize()		xf86getpagesize()
+#undef usleep
+#define usleep(ul)		xf86usleep(ul)
+#undef getsecs
+#define getsecs(a, b)		xf86getsecs(a, b)
+#endif
+#endif /* _XF86_ANSIC_H */
Index: VirtualBox-7.0.4/src/VBox/Additions/x11/vboxvideo/compiler.h
===================================================================
--- /dev/null
+++ VirtualBox-7.0.4/src/VBox/Additions/x11/vboxvideo/compiler.h
@@ -0,0 +1,1743 @@
+/* $XFree86: xc/programs/Xserver/hw/xfree86/common/compiler.h,v 3.99 2003/01/29 15:23:20 tsi Exp $ */
+/*
+ * Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Thomas Roell not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Thomas Roell makes no representations
+ * about the suitability of this software for any purpose.  It is provided
+ * "as is" without express or implied warranty.
+ *
+ * THOMAS ROELL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THOMAS ROELL BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+/* $XConsortium: compiler.h /main/16 1996/10/25 15:38:34 kaleb $ */
+
+#ifndef _COMPILER_H
+
+# if !defined(_XF86_ANSIC_H) && defined(XFree86Module)
+#  error missing #include "xf86_ansic.h" before #include "compiler.h"
+# endif
+
+# define _COMPILER_H
+
+/* Allow drivers to use the GCC-supported __inline__ and/or __inline. */
+# ifndef __inline__
+#  if defined(__GNUC__)
+    /* gcc has __inline__ */
+#  elif defined(__HIGHC__)
+#   define __inline__ _Inline
+#  else
+#   define __inline__ /**/
+#  endif
+# endif /* __inline__ */
+# ifndef __inline
+#  if defined(__GNUC__)
+    /* gcc has __inline */
+#  elif defined(__HIGHC__)
+#   define __inline _Inline
+#  else
+#   define __inline /**/
+#  endif
+# endif /* __inline */
+
+# if defined(IODEBUG) && defined(__GNUC__)
+#  define outb RealOutb
+#  define outw RealOutw
+#  define outl RealOutl
+#  define inb RealInb
+#  define inw RealInw
+#  define inl RealInl
+# endif
+
+# if defined(QNX4) /* Do this for now to keep Watcom happy */
+#  define outb outp
+#  define outw outpw
+#  define outl outpd
+#  define inb inp
+#  define inw inpw
+#  define inl inpd
+
+/* Define the ffs function for inlining */
+extern int ffs(unsigned long);
+#  pragma aux ffs_ = \
+        "bsf edx, eax"          \
+        "jnz bits_set"          \
+        "xor eax, eax"          \
+        "jmp exit1"             \
+        "bits_set:"             \
+        "mov eax, edx"          \
+        "inc eax"               \
+        "exit1:"                \
+        __parm [eax]            \
+        __modify [eax edx]      \
+        __value [eax]           \
+        ;
+# endif
+
+# if defined(NO_INLINE) || defined(DO_PROTOTYPES)
+
+#  if !defined(__sparc__) && !defined(__arm32__) \
+      && !(defined(__alpha__) && defined(linux))
+
+extern void outb(unsigned short, unsigned char);
+extern void outw(unsigned short, unsigned short);
+extern void outl(unsigned short, unsigned int);
+extern unsigned int inb(unsigned short);
+extern unsigned int inw(unsigned short);
+extern unsigned int inl(unsigned short);
+
+#  else /* __sparc__,  __arm32__, __alpha__*/
+
+extern void outb(unsigned long, unsigned char);
+extern void outw(unsigned long, unsigned short);
+extern void outl(unsigned long, unsigned int);
+extern unsigned int inb(unsigned long);
+extern unsigned int inw(unsigned long);
+extern unsigned int inl(unsigned long);
+
+#  endif /* __sparc__,  __arm32__, __alpha__ */
+
+extern unsigned long ldq_u(unsigned long *);
+extern unsigned long ldl_u(unsigned int *);
+extern unsigned long ldw_u(unsigned short *);
+extern void stq_u(unsigned long, unsigned long *);
+extern void stl_u(unsigned long, unsigned int *);
+extern void stw_u(unsigned long, unsigned short *);
+extern void mem_barrier(void);
+extern void write_mem_barrier(void);
+extern void stl_brx(unsigned long, volatile unsigned char *, int);
+extern void stw_brx(unsigned short, volatile unsigned char *, int);
+extern unsigned long ldl_brx(volatile unsigned char *, int);
+extern unsigned short ldw_brx(volatile unsigned char *, int);
+
+# endif
+
+# ifndef NO_INLINE
+#  ifdef __GNUC__
+#   if (defined(linux) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)) && defined(__alpha__)
+
+#    ifdef linux
+/* for Linux on Alpha, we use the LIBC _inx/_outx routines */
+/* note that the appropriate setup via "ioperm" needs to be done */
+/*  *before* any inx/outx is done. */
+
+extern void (*_alpha_outb)(char val, unsigned long port);
+static __inline__ void
+outb(unsigned long port, unsigned char val)
+{
+    _alpha_outb(val, port);
+}
+
+extern void (*_alpha_outw)(short val, unsigned long port);
+static __inline__ void
+outw(unsigned long port, unsigned short val)
+{
+    _alpha_outw(val, port);
+}
+
+extern void (*_alpha_outl)(int val, unsigned long port);
+static __inline__ void
+outl(unsigned long port, unsigned int val)
+{
+    _alpha_outl(val, port);
+}
+
+extern unsigned int (*_alpha_inb)(unsigned long port);
+static __inline__ unsigned int
+inb(unsigned long port)
+{
+  return _alpha_inb(port);
+}
+
+extern unsigned int (*_alpha_inw)(unsigned long port);
+static __inline__ unsigned int
+inw(unsigned long port)
+{
+  return _alpha_inw(port);
+}
+
+extern unsigned int (*_alpha_inl)(unsigned long port);
+static __inline__ unsigned int
+inl(unsigned long port)
+{
+  return _alpha_inl(port);
+}
+
+#    endif /* linux */
+
+#    if (defined(__FreeBSD__) || defined(__OpenBSD__)) \
+      && !defined(DO_PROTOTYPES)
+
+/* for FreeBSD and OpenBSD on Alpha, we use the libio (resp. libalpha) */
+/*  inx/outx routines */
+/* note that the appropriate setup via "ioperm" needs to be done */
+/*  *before* any inx/outx is done. */
+
+extern void outb(unsigned int port, unsigned char val);
+extern void outw(unsigned int port, unsigned short val);
+extern void outl(unsigned int port, unsigned int val);
+extern unsigned char inb(unsigned int port);
+extern unsigned short inw(unsigned int port);
+extern unsigned int inl(unsigned int port);
+
+#    endif /* (__FreeBSD__ || __OpenBSD__ ) && !DO_PROTOTYPES */
+
+
+#if defined(__NetBSD__)
+#include <machine/pio.h>
+#endif /* __NetBSD__ */
+
+/*
+ * inline functions to do unaligned accesses
+ * from linux/include/asm-alpha/unaligned.h
+ */
+
+/*
+ * EGCS 1.1 knows about arbitrary unaligned loads.  Define some
+ * packed structures to talk about such things with.
+ */
+
+struct __una_u64 { unsigned long  x __attribute__((packed)); };
+struct __una_u32 { unsigned int   x __attribute__((packed)); };
+struct __una_u16 { unsigned short x __attribute__((packed)); };
+
+/*
+ * Elemental unaligned loads
+ */
+/* let's try making these things static */
+
+static __inline__ unsigned long ldq_u(unsigned long * r11)
+{
+#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
+	const struct __una_u64 *ptr = (const struct __una_u64 *) r11;
+	return ptr->x;
+#    else
+	unsigned long r1,r2;
+	__asm__("ldq_u %0,%3\n\t"
+		"ldq_u %1,%4\n\t"
+		"extql %0,%2,%0\n\t"
+		"extqh %1,%2,%1"
+		:"=&r" (r1), "=&r" (r2)
+		:"r" (r11),
+		 "m" (*r11),
+		 "m" (*(const unsigned long *)(7+(char *) r11)));
+	return r1 | r2;
+#    endif
+}
+
+static __inline__ unsigned long ldl_u(unsigned int * r11)
+{
+#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
+	const struct __una_u32 *ptr = (const struct __una_u32 *) r11;
+	return ptr->x;
+#    else
+	unsigned long r1,r2;
+	__asm__("ldq_u %0,%3\n\t"
+		"ldq_u %1,%4\n\t"
+		"extll %0,%2,%0\n\t"
+		"extlh %1,%2,%1"
+		:"=&r" (r1), "=&r" (r2)
+		:"r" (r11),
+		 "m" (*r11),
+		 "m" (*(const unsigned long *)(3+(char *) r11)));
+	return r1 | r2;
+#    endif
+}
+
+static __inline__ unsigned long ldw_u(unsigned short * r11)
+{
+#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
+	const struct __una_u16 *ptr = (const struct __una_u16 *) r11;
+	return ptr->x;
+#    else
+	unsigned long r1,r2;
+	__asm__("ldq_u %0,%3\n\t"
+		"ldq_u %1,%4\n\t"
+		"extwl %0,%2,%0\n\t"
+		"extwh %1,%2,%1"
+		:"=&r" (r1), "=&r" (r2)
+		:"r" (r11),
+		 "m" (*r11),
+		 "m" (*(const unsigned long *)(1+(char *) r11)));
+	return r1 | r2;
+#    endif
+}
+
+/*
+ * Elemental unaligned stores
+ */
+
+static __inline__ void stq_u(unsigned long r5, unsigned long * r11)
+{
+#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
+	struct __una_u64 *ptr = (struct __una_u64 *) r11;
+	ptr->x = r5;
+#    else
+	unsigned long r1,r2,r3,r4;
+
+	__asm__("ldq_u %3,%1\n\t"
+		"ldq_u %2,%0\n\t"
+		"insqh %6,%7,%5\n\t"
+		"insql %6,%7,%4\n\t"
+		"mskqh %3,%7,%3\n\t"
+		"mskql %2,%7,%2\n\t"
+		"bis %3,%5,%3\n\t"
+		"bis %2,%4,%2\n\t"
+		"stq_u %3,%1\n\t"
+		"stq_u %2,%0"
+		:"=m" (*r11),
+		 "=m" (*(unsigned long *)(7+(char *) r11)),
+		 "=&r" (r1), "=&r" (r2), "=&r" (r3), "=&r" (r4)
+		:"r" (r5), "r" (r11));
+#    endif
+}
+
+static __inline__ void stl_u(unsigned long r5, unsigned int * r11)
+{
+#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
+	struct __una_u32 *ptr = (struct __una_u32 *) r11;
+	ptr->x = r5;
+#    else
+	unsigned long r1,r2,r3,r4;
+
+	__asm__("ldq_u %3,%1\n\t"
+		"ldq_u %2,%0\n\t"
+		"inslh %6,%7,%5\n\t"
+		"insll %6,%7,%4\n\t"
+		"msklh %3,%7,%3\n\t"
+		"mskll %2,%7,%2\n\t"
+		"bis %3,%5,%3\n\t"
+		"bis %2,%4,%2\n\t"
+		"stq_u %3,%1\n\t"
+		"stq_u %2,%0"
+		:"=m" (*r11),
+		 "=m" (*(unsigned long *)(3+(char *) r11)),
+		 "=&r" (r1), "=&r" (r2), "=&r" (r3), "=&r" (r4)
+		:"r" (r5), "r" (r11));
+#    endif
+}
+
+static __inline__ void stw_u(unsigned long r5, unsigned short * r11)
+{
+#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
+	struct __una_u16 *ptr = (struct __una_u16 *) r11;
+	ptr->x = r5;
+#    else
+	unsigned long r1,r2,r3,r4;
+
+	__asm__("ldq_u %3,%1\n\t"
+		"ldq_u %2,%0\n\t"
+		"inswh %6,%7,%5\n\t"
+		"inswl %6,%7,%4\n\t"
+		"mskwh %3,%7,%3\n\t"
+		"mskwl %2,%7,%2\n\t"
+		"bis %3,%5,%3\n\t"
+		"bis %2,%4,%2\n\t"
+		"stq_u %3,%1\n\t"
+		"stq_u %2,%0"
+		:"=m" (*r11),
+		 "=m" (*(unsigned long *)(1+(char *) r11)),
+		 "=&r" (r1), "=&r" (r2), "=&r" (r3), "=&r" (r4)
+		:"r" (r5), "r" (r11));
+#    endif
+}
+
+/* to flush the I-cache before jumping to code which just got loaded */
+#    define PAL_imb 134
+#    define istream_mem_barrier() \
+	__asm__ __volatile__("call_pal %0 #imb" : : "i" (PAL_imb) : "memory")
+#    define mem_barrier()        __asm__ __volatile__("mb"  : : : "memory")
+#    ifdef __ELF__
+#     define write_mem_barrier()  __asm__ __volatile__("wmb" : : : "memory")
+#    else  /*  ECOFF gas 2.6 doesn't know "wmb" :-(  */
+#     define write_mem_barrier()  mem_barrier()
+#    endif
+
+
+#   elif defined(linux) && defined(__ia64__)
+
+#    include <inttypes.h>
+
+#    include <sys/io.h>
+
+struct __una_u64 { uint64_t x __attribute__((packed)); };
+struct __una_u32 { uint32_t x __attribute__((packed)); };
+struct __una_u16 { uint16_t x __attribute__((packed)); };
+
+static __inline__ unsigned long
+__uldq (const unsigned long * r11)
+{
+	const struct __una_u64 *ptr = (const struct __una_u64 *) r11;
+	return ptr->x;
+}
+
+static __inline__ unsigned long
+__uldl (const unsigned int * r11)
+{
+	const struct __una_u32 *ptr = (const struct __una_u32 *) r11;
+	return ptr->x;
+}
+
+static __inline__ unsigned long
+__uldw (const unsigned short * r11)
+{
+	const struct __una_u16 *ptr = (const struct __una_u16 *) r11;
+	return ptr->x;
+}
+
+static __inline__ void
+__ustq (unsigned long r5, unsigned long * r11)
+{
+	struct __una_u64 *ptr = (struct __una_u64 *) r11;
+	ptr->x = r5;
+}
+
+static __inline__ void
+__ustl (unsigned long r5, unsigned int * r11)
+{
+	struct __una_u32 *ptr = (struct __una_u32 *) r11;
+	ptr->x = r5;
+}
+
+static __inline__ void
+__ustw (unsigned long r5, unsigned short * r11)
+{
+	struct __una_u16 *ptr = (struct __una_u16 *) r11;
+	ptr->x = r5;
+}
+
+#    define ldq_u(p)	__uldq(p)
+#    define ldl_u(p)	__uldl(p)
+#    define ldw_u(p)	__uldw(p)
+#    define stq_u(v,p)	__ustq(v,p)
+#    define stl_u(v,p)	__ustl(v,p)
+#    define stw_u(v,p)	__ustw(v,p)
+
+#    define mem_barrier()        __asm__ __volatile__ ("mf" ::: "memory")
+#    define write_mem_barrier()  __asm__ __volatile__ ("mf" ::: "memory")
+
+/*
+ * This is overkill, but for different reasons depending on where it is used.
+ * This is thus general enough to be used everywhere cache flushes are needed.
+ * It doesn't handle memory access serialisation by other processors, though.
+ */
+#    define ia64_flush_cache(Addr) \
+	__asm__ __volatile__ ( \
+		"fc %0;;;" \
+		"sync.i;;;" \
+		"mf;;;" \
+		"srlz.i;;;" \
+		:: "r"(Addr) : "memory")
+
+#    undef outb
+#    undef outw
+#    undef outl
+
+#    define outb(a,b)	_outb(b,a)
+#    define outw(a,b)	_outw(b,a)
+#    define outl(a,b)	_outl(b,a)
+
+#   elif defined(linux) && defined(__x86_64__)
+
+#    include <inttypes.h>
+
+#    define ldq_u(p)	(*((unsigned long  *)(p)))
+#    define ldl_u(p)	(*((unsigned int   *)(p)))
+#    define ldw_u(p)	(*((unsigned short *)(p)))
+#    define stq_u(v,p)	(*(unsigned long  *)(p)) = (v)
+#    define stl_u(v,p)	(*(unsigned int   *)(p)) = (v)
+#    define stw_u(v,p)	(*(unsigned short *)(p)) = (v)
+
+#    define mem_barrier() \
+       __asm__ __volatile__ ("lock; addl $0,0(%%rsp)": : :"memory")
+#    define write_mem_barrier() \
+       __asm__ __volatile__ ("": : :"memory")
+
+
+static __inline__ void
+outb(unsigned short port, unsigned char val)
+{
+   __asm__ __volatile__("outb %0,%1" : :"a" (val), "d" (port));
+}
+
+
+static __inline__ void
+outw(unsigned short port, unsigned short val)
+{
+   __asm__ __volatile__("outw %0,%1" : :"a" (val), "d" (port));
+}
+
+static __inline__ void
+outl(unsigned short port, unsigned int val)
+{
+   __asm__ __volatile__("outl %0,%1" : :"a" (val), "d" (port));
+}
+
+static __inline__ unsigned int
+inb(unsigned short port)
+{
+   unsigned char ret;
+   __asm__ __volatile__("inb %1,%0" :
+       "=a" (ret) :
+       "d" (port));
+   return ret;
+}
+
+static __inline__ unsigned int
+inw(unsigned short port)
+{
+   unsigned short ret;
+   __asm__ __volatile__("inw %1,%0" :
+       "=a" (ret) :
+       "d" (port));
+   return ret;
+}
+
+static __inline__ unsigned int
+inl(unsigned short port)
+{
+   unsigned int ret;
+   __asm__ __volatile__("inl %1,%0" :
+       "=a" (ret) :
+       "d" (port));
+   return ret;
+}
+
+#   elif (defined(linux) || defined(Lynx) || defined(sun) || defined(__OpenBSD__)) && defined(__sparc__)
+
+#    if !defined(Lynx)
+#     ifndef ASI_PL
+#      define ASI_PL 0x88
+#     endif
+
+#     define barrier() __asm__ __volatile__(".word 0x8143e00a": : :"memory")
+
+static __inline__ void
+outb(unsigned long port, unsigned char val)
+{
+	__asm__ __volatile__("stba %0, [%1] %2"
+			     : /* No outputs */
+			     : "r" (val), "r" (port), "i" (ASI_PL));
+	barrier();
+}
+
+static __inline__ void
+outw(unsigned long port, unsigned short val)
+{
+	__asm__ __volatile__("stha %0, [%1] %2"
+			     : /* No outputs */
+			     : "r" (val), "r" (port), "i" (ASI_PL));
+	barrier();
+}
+
+static __inline__ void
+outl(unsigned long port, unsigned int val)
+{
+	__asm__ __volatile__("sta %0, [%1] %2"
+			     : /* No outputs */
+			     : "r" (val), "r" (port), "i" (ASI_PL));
+	barrier();
+}
+
+static __inline__ unsigned int
+inb(unsigned long port)
+{
+	unsigned int ret;
+	__asm__ __volatile__("lduba [%1] %2, %0"
+			     : "=r" (ret)
+			     : "r" (port), "i" (ASI_PL));
+	return ret;
+}
+
+static __inline__ unsigned int
+inw(unsigned long port)
+{
+	unsigned int ret;
+	__asm__ __volatile__("lduha [%1] %2, %0"
+			     : "=r" (ret)
+			     : "r" (port), "i" (ASI_PL));
+	return ret;
+}
+
+static __inline__ unsigned int
+inl(unsigned long port)
+{
+	unsigned int ret;
+	__asm__ __volatile__("lda [%1] %2, %0"
+			     : "=r" (ret)
+			     : "r" (port), "i" (ASI_PL));
+	return ret;
+}
+
+static __inline__ unsigned char
+xf86ReadMmio8(__volatile__ void *base, const unsigned long offset)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+	unsigned char ret;
+
+	__asm__ __volatile__("lduba [%1] %2, %0"
+			     : "=r" (ret)
+			     : "r" (addr), "i" (ASI_PL));
+	return ret;
+}
+
+static __inline__ unsigned short
+xf86ReadMmio16Be(__volatile__ void *base, const unsigned long offset)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+	unsigned short ret;
+
+	__asm__ __volatile__("lduh [%1], %0"
+			     : "=r" (ret)
+			     : "r" (addr));
+	return ret;
+}
+
+static __inline__ unsigned short
+xf86ReadMmio16Le(__volatile__ void *base, const unsigned long offset)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+	unsigned short ret;
+
+	__asm__ __volatile__("lduha [%1] %2, %0"
+			     : "=r" (ret)
+			     : "r" (addr), "i" (ASI_PL));
+	return ret;
+}
+
+static __inline__ unsigned int
+xf86ReadMmio32Be(__volatile__ void *base, const unsigned long offset)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+	unsigned int ret;
+
+	__asm__ __volatile__("ld [%1], %0"
+			     : "=r" (ret)
+			     : "r" (addr));
+	return ret;
+}
+
+static __inline__ unsigned int
+xf86ReadMmio32Le(__volatile__ void *base, const unsigned long offset)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+	unsigned int ret;
+
+	__asm__ __volatile__("lda [%1] %2, %0"
+			     : "=r" (ret)
+			     : "r" (addr), "i" (ASI_PL));
+	return ret;
+}
+
+static __inline__ void
+xf86WriteMmio8(__volatile__ void *base, const unsigned long offset,
+	       const unsigned int val)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+
+	__asm__ __volatile__("stba %0, [%1] %2"
+			     : /* No outputs */
+			     : "r" (val), "r" (addr), "i" (ASI_PL));
+	barrier();
+}
+
+static __inline__ void
+xf86WriteMmio16Be(__volatile__ void *base, const unsigned long offset,
+		  const unsigned int val)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+
+	__asm__ __volatile__("sth %0, [%1]"
+			     : /* No outputs */
+			     : "r" (val), "r" (addr));
+	barrier();
+}
+
+static __inline__ void
+xf86WriteMmio16Le(__volatile__ void *base, const unsigned long offset,
+		  const unsigned int val)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+
+	__asm__ __volatile__("stha %0, [%1] %2"
+			     : /* No outputs */
+			     : "r" (val), "r" (addr), "i" (ASI_PL));
+	barrier();
+}
+
+static __inline__ void
+xf86WriteMmio32Be(__volatile__ void *base, const unsigned long offset,
+		  const unsigned int val)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+
+	__asm__ __volatile__("st %0, [%1]"
+			     : /* No outputs */
+			     : "r" (val), "r" (addr));
+	barrier();
+}
+
+static __inline__ void
+xf86WriteMmio32Le(__volatile__ void *base, const unsigned long offset,
+		  const unsigned int val)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+
+	__asm__ __volatile__("sta %0, [%1] %2"
+			     : /* No outputs */
+			     : "r" (val), "r" (addr), "i" (ASI_PL));
+	barrier();
+}
+
+static __inline__ void
+xf86WriteMmio8NB(__volatile__ void *base, const unsigned long offset,
+		 const unsigned int val)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+
+	__asm__ __volatile__("stba %0, [%1] %2"
+			     : /* No outputs */
+			     : "r" (val), "r" (addr), "i" (ASI_PL));
+}
+
+static __inline__ void
+xf86WriteMmio16BeNB(__volatile__ void *base, const unsigned long offset,
+		    const unsigned int val)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+
+	__asm__ __volatile__("sth %0, [%1]"
+			     : /* No outputs */
+			     : "r" (val), "r" (addr));
+}
+
+static __inline__ void
+xf86WriteMmio16LeNB(__volatile__ void *base, const unsigned long offset,
+		    const unsigned int val)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+
+	__asm__ __volatile__("stha %0, [%1] %2"
+			     : /* No outputs */
+			     : "r" (val), "r" (addr), "i" (ASI_PL));
+}
+
+static __inline__ void
+xf86WriteMmio32BeNB(__volatile__ void *base, const unsigned long offset,
+		    const unsigned int val)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+
+	__asm__ __volatile__("st %0, [%1]"
+			     : /* No outputs */
+			     : "r" (val), "r" (addr));
+}
+
+static __inline__ void
+xf86WriteMmio32LeNB(__volatile__ void *base, const unsigned long offset,
+		    const unsigned int val)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+
+	__asm__ __volatile__("sta %0, [%1] %2"
+			     : /* No outputs */
+			     : "r" (val), "r" (addr), "i" (ASI_PL));
+}
+
+#    endif	/* !Lynx */
+
+/*
+ * EGCS 1.1 knows about arbitrary unaligned loads.  Define some
+ * packed structures to talk about such things with.
+ */
+
+#    if defined(__arch64__) || defined(__sparcv9)
+struct __una_u64 { unsigned long  x __attribute__((packed)); };
+#    endif
+struct __una_u32 { unsigned int   x __attribute__((packed)); };
+struct __una_u16 { unsigned short x __attribute__((packed)); };
+
+static __inline__ unsigned long ldq_u(unsigned long *p)
+{
+#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
+#     if defined(__arch64__) || defined(__sparcv9)
+	const struct __una_u64 *ptr = (const struct __una_u64 *) p;
+#     else
+	const struct __una_u32 *ptr = (const struct __una_u32 *) p;
+#     endif
+	return ptr->x;
+#    else
+	unsigned long ret;
+	memmove(&ret, p, sizeof(*p));
+	return ret;
+#    endif
+}
+
+static __inline__ unsigned long ldl_u(unsigned int *p)
+{
+#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
+	const struct __una_u32 *ptr = (const struct __una_u32 *) p;
+	return ptr->x;
+#    else
+	unsigned int ret;
+	memmove(&ret, p, sizeof(*p));
+	return ret;
+#    endif
+}
+
+static __inline__ unsigned long ldw_u(unsigned short *p)
+{
+#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
+	const struct __una_u16 *ptr = (const struct __una_u16 *) p;
+	return ptr->x;
+#    else
+	unsigned short ret;
+	memmove(&ret, p, sizeof(*p));
+	return ret;
+#    endif
+}
+
+static __inline__ void stq_u(unsigned long val, unsigned long *p)
+{
+#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
+#     if defined(__arch64__) || defined(__sparcv9)
+	struct __una_u64 *ptr = (struct __una_u64 *) p;
+#     else
+	struct __una_u32 *ptr = (struct __una_u32 *) p;
+#     endif
+	ptr->x = val;
+#    else
+	unsigned long tmp = val;
+	memmove(p, &tmp, sizeof(*p));
+#    endif
+}
+
+static __inline__ void stl_u(unsigned long val, unsigned int *p)
+{
+#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
+	struct __una_u32 *ptr = (struct __una_u32 *) p;
+	ptr->x = val;
+#    else
+	unsigned int tmp = val;
+	memmove(p, &tmp, sizeof(*p));
+#    endif
+}
+
+static __inline__ void stw_u(unsigned long val, unsigned short *p)
+{
+#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
+	struct __una_u16 *ptr = (struct __una_u16 *) p;
+	ptr->x = val;
+#    else
+	unsigned short tmp = val;
+	memmove(p, &tmp, sizeof(*p));
+#    endif
+}
+
+#    define mem_barrier()         /* XXX: nop for now */
+#    define write_mem_barrier()   /* XXX: nop for now */
+
+#   elif defined(__mips__) || defined(__arm32__)
+#ifdef __arm32__
+#define PORT_SIZE long
+#else
+#define PORT_SIZE short
+#endif
+
+unsigned int IOPortBase;  /* Memory mapped I/O port area */
+
+static __inline__ void
+outb(unsigned PORT_SIZE port, unsigned char val)
+{
+	*(volatile unsigned char*)(((unsigned PORT_SIZE)(port))+IOPortBase) = val;
+}
+
+static __inline__ void
+outw(unsigned PORT_SIZE port, unsigned short val)
+{
+	*(volatile unsigned short*)(((unsigned PORT_SIZE)(port))+IOPortBase) = val;
+}
+
+static __inline__ void
+outl(unsigned PORT_SIZE port, unsigned int val)
+{
+	*(volatile unsigned int*)(((unsigned PORT_SIZE)(port))+IOPortBase) = val;
+}
+
+static __inline__ unsigned int
+inb(unsigned PORT_SIZE port)
+{
+	return *(volatile unsigned char*)(((unsigned PORT_SIZE)(port))+IOPortBase);
+}
+
+static __inline__ unsigned int
+inw(unsigned PORT_SIZE port)
+{
+	return *(volatile unsigned short*)(((unsigned PORT_SIZE)(port))+IOPortBase);
+}
+
+static __inline__ unsigned int
+inl(unsigned PORT_SIZE port)
+{
+	return *(volatile unsigned int*)(((unsigned PORT_SIZE)(port))+IOPortBase);
+}
+
+
+#    if defined(__mips__)
+static __inline__ unsigned long ldq_u(unsigned long * r11)
+{
+	unsigned long r1;
+	__asm__("lwr %0,%2\n\t"
+		"lwl %0,%3\n\t"
+		:"=&r" (r1)
+		:"r" (r11),
+		 "m" (*r11),
+		 "m" (*(unsigned long *)(3+(char *) r11)));
+	return r1;
+}
+
+static __inline__ unsigned long ldl_u(unsigned int * r11)
+{
+	unsigned long r1;
+	__asm__("lwr %0,%2\n\t"
+		"lwl %0,%3\n\t"
+		:"=&r" (r1)
+		:"r" (r11),
+		 "m" (*r11),
+		 "m" (*(unsigned long *)(3+(char *) r11)));
+	return r1;
+}
+
+static __inline__ unsigned long ldw_u(unsigned short * r11)
+{
+	unsigned long r1;
+	__asm__("lwr %0,%2\n\t"
+		"lwl %0,%3\n\t"
+		:"=&r" (r1)
+		:"r" (r11),
+		 "m" (*r11),
+		 "m" (*(unsigned long *)(1+(char *) r11)));
+	return r1;
+}
+
+#     ifdef linux	/* don't mess with other OSs */
+
+/*
+ * EGCS 1.1 knows about arbitrary unaligned loads (and we don't support older
+ * versions anyway. Define some packed structures to talk about such things
+ * with.
+ */
+
+struct __una_u32 { unsigned int   x __attribute__((packed)); };
+struct __una_u16 { unsigned short x __attribute__((packed)); };
+
+static __inline__ void stw_u(unsigned long val, unsigned short *p)
+{
+	struct __una_u16 *ptr = (struct __una_u16 *) p;
+	ptr->x = val;
+}
+
+static __inline__ void stl_u(unsigned long val, unsigned int *p)
+{
+	struct __una_u32 *ptr = (struct __una_u32 *) p;
+	ptr->x = val;
+}
+
+#       if X_BYTE_ORDER == X_BIG_ENDIAN
+static __inline__ unsigned int
+xf86ReadMmio32Be(__volatile__ void *base, const unsigned long offset)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+	unsigned int ret;
+
+	__asm__ __volatile__("lw %0, 0(%1)"
+			     : "=r" (ret)
+			     : "r" (addr));
+	return ret;
+}
+
+static __inline__ void
+xf86WriteMmio32Be(__volatile__ void *base, const unsigned long offset,
+		  const unsigned int val)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+
+	__asm__ __volatile__("sw %0, 0(%1)"
+			     : /* No outputs */
+			     : "r" (val), "r" (addr));
+}
+#      endif
+
+#      define mem_barrier() \
+        __asm__ __volatile__(					\
+		"# prevent instructions being moved around\n\t"	\
+		".set\tnoreorder\n\t"				\
+		"# 8 nops to fool the R4400 pipeline\n\t"	\
+		"nop;nop;nop;nop;nop;nop;nop;nop\n\t"		\
+		".set\treorder"					\
+		: /* no output */				\
+		: /* no input */				\
+		: "memory")
+#      define write_mem_barrier() mem_barrier()
+
+#     else  /* !linux */
+
+#      define stq_u(v,p)	stl_u(v,p)
+#      define stl_u(v,p)	(*(unsigned char *)(p)) = (v); \
+			(*(unsigned char *)(p)+1) = ((v) >> 8);  \
+			(*(unsigned char *)(p)+2) = ((v) >> 16); \
+			(*(unsigned char *)(p)+3) = ((v) >> 24)
+
+#      define stw_u(v,p)	(*(unsigned char *)(p)) = (v); \
+				(*(unsigned char *)(p)+1) = ((v) >> 8)
+
+#      define mem_barrier()   /* NOP */
+#     endif /* !linux */
+#    endif /* __mips__ */
+
+#    if defined(__arm32__)
+#     define ldq_u(p)	(*((unsigned long  *)(p)))
+#     define ldl_u(p)	(*((unsigned int   *)(p)))
+#     define ldw_u(p)	(*((unsigned short *)(p)))
+#     define stq_u(v,p)	(*(unsigned long  *)(p)) = (v)
+#     define stl_u(v,p)	(*(unsigned int   *)(p)) = (v)
+#     define stw_u(v,p)	(*(unsigned short *)(p)) = (v)
+#     define mem_barrier()	/* NOP */
+#     define write_mem_barrier()	/* NOP */
+#    endif /* __arm32__ */
+
+#   elif (defined(Lynx) || defined(linux) || defined(__OpenBSD__) || defined(__NetBSD__)) && defined(__powerpc__)
+
+#    ifndef MAP_FAILED
+#     define MAP_FAILED ((void *)-1)
+#    endif
+
+extern volatile unsigned char *ioBase;
+
+#    define eieio()		__asm__ __volatile__ ("eieio" ::: "memory")
+
+static __inline__ unsigned char
+xf86ReadMmio8(__volatile__ void *base, const unsigned long offset)
+{
+        register unsigned char val;
+        __asm__ __volatile__(
+                        "lbzx %0,%1,%2\n\t"
+                        "eieio"
+                        : "=r" (val)
+                        : "b" (base), "r" (offset),
+                        "m" (*((volatile unsigned char *)base+offset)));
+        return val;
+}
+
+static __inline__ unsigned short
+xf86ReadMmio16Be(__volatile__ void *base, const unsigned long offset)
+{
+        register unsigned short val;
+        __asm__ __volatile__(
+                        "lhzx %0,%1,%2\n\t"
+                        "eieio"
+                        : "=r" (val)
+                        : "b" (base), "r" (offset),
+                        "m" (*((volatile unsigned char *)base+offset)));
+        return val;
+}
+
+static __inline__ unsigned short
+xf86ReadMmio16Le(__volatile__ void *base, const unsigned long offset)
+{
+        register unsigned short val;
+        __asm__ __volatile__(
+                        "lhbrx %0,%1,%2\n\t"
+                        "eieio"
+                        : "=r" (val)
+                        : "b" (base), "r" (offset),
+                        "m" (*((volatile unsigned char *)base+offset)));
+        return val;
+}
+
+static __inline__ unsigned int
+xf86ReadMmio32Be(__volatile__ void *base, const unsigned long offset)
+{
+        register unsigned int val;
+        __asm__ __volatile__(
+                        "lwzx %0,%1,%2\n\t"
+                        "eieio"
+                        : "=r" (val)
+                        : "b" (base), "r" (offset),
+                        "m" (*((volatile unsigned char *)base+offset)));
+        return val;
+}
+
+static __inline__ unsigned int
+xf86ReadMmio32Le(__volatile__ void *base, const unsigned long offset)
+{
+        register unsigned int val;
+        __asm__ __volatile__(
+                        "lwbrx %0,%1,%2\n\t"
+                        "eieio"
+                        : "=r" (val)
+                        : "b" (base), "r" (offset),
+                        "m" (*((volatile unsigned char *)base+offset)));
+        return val;
+}
+
+static __inline__ void
+xf86WriteMmioNB8(__volatile__ void *base, const unsigned long offset,
+		 const unsigned char val)
+{
+        __asm__ __volatile__(
+                        "stbx %1,%2,%3\n\t"
+                        : "=m" (*((volatile unsigned char *)base+offset))
+                        : "r" (val), "b" (base), "r" (offset));
+}
+
+static __inline__ void
+xf86WriteMmioNB16Le(__volatile__ void *base, const unsigned long offset,
+		    const unsigned short val)
+{
+        __asm__ __volatile__(
+                        "sthbrx %1,%2,%3\n\t"
+                        : "=m" (*((volatile unsigned char *)base+offset))
+                        : "r" (val), "b" (base), "r" (offset));
+}
+
+static __inline__ void
+xf86WriteMmioNB16Be(__volatile__ void *base, const unsigned long offset,
+		    const unsigned short val)
+{
+        __asm__ __volatile__(
+                        "sthx %1,%2,%3\n\t"
+                        : "=m" (*((volatile unsigned char *)base+offset))
+                        : "r" (val), "b" (base), "r" (offset));
+}
+
+static __inline__ void
+xf86WriteMmioNB32Le(__volatile__ void *base, const unsigned long offset,
+		    const unsigned int val)
+{
+        __asm__ __volatile__(
+                        "stwbrx %1,%2,%3\n\t"
+                        : "=m" (*((volatile unsigned char *)base+offset))
+                        : "r" (val), "b" (base), "r" (offset));
+}
+
+static __inline__ void
+xf86WriteMmioNB32Be(__volatile__ void *base, const unsigned long offset,
+		    const unsigned int val)
+{
+        __asm__ __volatile__(
+                        "stwx %1,%2,%3\n\t"
+                        : "=m" (*((volatile unsigned char *)base+offset))
+                        : "r" (val), "b" (base), "r" (offset));
+}
+
+static __inline__ void
+xf86WriteMmio8(__volatile__ void *base, const unsigned long offset,
+               const unsigned char val)
+{
+        xf86WriteMmioNB8(base, offset, val);
+        eieio();
+}
+
+static __inline__ void
+xf86WriteMmio16Le(__volatile__ void *base, const unsigned long offset,
+                  const unsigned short val)
+{
+        xf86WriteMmioNB16Le(base, offset, val);
+        eieio();
+}
+
+static __inline__ void
+xf86WriteMmio16Be(__volatile__ void *base, const unsigned long offset,
+                  const unsigned short val)
+{
+        xf86WriteMmioNB16Be(base, offset, val);
+        eieio();
+}
+
+static __inline__ void
+xf86WriteMmio32Le(__volatile__ void *base, const unsigned long offset,
+                  const unsigned int val)
+{
+        xf86WriteMmioNB32Le(base, offset, val);
+        eieio();
+}
+
+static __inline__ void
+xf86WriteMmio32Be(__volatile__ void *base, const unsigned long offset,
+                  const unsigned int val)
+{
+        xf86WriteMmioNB32Be(base, offset, val);
+        eieio();
+}
+
+
+static __inline__ void
+outb(unsigned short port, unsigned char value)
+{
+        if(ioBase == MAP_FAILED) return;
+        xf86WriteMmio8((void *)ioBase, port, value);
+}
+
+static __inline__ void
+outw(unsigned short port, unsigned short value)
+{
+        if(ioBase == MAP_FAILED) return;
+        xf86WriteMmio16Le((void *)ioBase, port, value);
+}
+
+static __inline__ void
+outl(unsigned short port, unsigned int value)
+{
+        if(ioBase == MAP_FAILED) return;
+        xf86WriteMmio32Le((void *)ioBase, port, value);
+}
+
+static __inline__ unsigned int
+inb(unsigned short port)
+{
+        if(ioBase == MAP_FAILED) return 0;
+        return xf86ReadMmio8((void *)ioBase, port);
+}
+
+static __inline__ unsigned int
+inw(unsigned short port)
+{
+        if(ioBase == MAP_FAILED) return 0;
+        return xf86ReadMmio16Le((void *)ioBase, port);
+}
+
+static __inline__ unsigned int
+inl(unsigned short port)
+{
+        if(ioBase == MAP_FAILED) return 0;
+        return xf86ReadMmio32Le((void *)ioBase, port);
+}
+
+#    define ldq_u(p)	ldl_u(p)
+#    define ldl_u(p)	((*(unsigned char *)(p))	| \
+			(*((unsigned char *)(p)+1)<<8)	| \
+			(*((unsigned char *)(p)+2)<<16)	| \
+			(*((unsigned char *)(p)+3)<<24))
+#    define ldw_u(p)	((*(unsigned char *)(p)) | \
+			(*((unsigned char *)(p)+1)<<8))
+
+#    define stq_u(v,p)	stl_u(v,p)
+#    define stl_u(v,p)	(*(unsigned char *)(p)) = (v); \
+				(*((unsigned char *)(p)+1)) = ((v) >> 8);  \
+				(*((unsigned char *)(p)+2)) = ((v) >> 16); \
+				(*((unsigned char *)(p)+3)) = ((v) >> 24)
+#    define stw_u(v,p)	(*(unsigned char *)(p)) = (v); \
+				(*((unsigned char *)(p)+1)) = ((v) >> 8)
+
+#    define mem_barrier()	eieio()
+#    define write_mem_barrier()	eieio()
+
+#   else /* ix86 */
+
+#    define ldq_u(p)	(*((unsigned long  *)(p)))
+#    define ldl_u(p)	(*((unsigned int   *)(p)))
+#    define ldw_u(p)	(*((unsigned short *)(p)))
+#    define stq_u(v,p)	(*(unsigned long  *)(p)) = (v)
+#    define stl_u(v,p)	(*(unsigned int   *)(p)) = (v)
+#    define stw_u(v,p)	(*(unsigned short *)(p)) = (v)
+#    define mem_barrier()   /* NOP */
+#    define write_mem_barrier()   /* NOP */
+
+#    if !defined(FAKEIT) && !defined(__mc68000__) && !defined(__arm__) && !defined(__sh__) && !defined(__hppa__)
+#     ifdef GCCUSESGAS
+
+/*
+ * If gcc uses gas rather than the native assembler, the syntax of these
+ * inlines has to be different.		DHD
+ */
+
+static __inline__ void
+outb(unsigned short port, unsigned char val)
+{
+   __asm__ __volatile__("outb %0,%1" : :"a" (val), "d" (port));
+}
+
+
+static __inline__ void
+outw(unsigned short port, unsigned short val)
+{
+   __asm__ __volatile__("outw %0,%1" : :"a" (val), "d" (port));
+}
+
+static __inline__ void
+outl(unsigned short port, unsigned int val)
+{
+   __asm__ __volatile__("outl %0,%1" : :"a" (val), "d" (port));
+}
+
+static __inline__ unsigned int
+inb(unsigned short port)
+{
+   unsigned char ret;
+   __asm__ __volatile__("inb %1,%0" :
+       "=a" (ret) :
+       "d" (port));
+   return ret;
+}
+
+static __inline__ unsigned int
+inw(unsigned short port)
+{
+   unsigned short ret;
+   __asm__ __volatile__("inw %1,%0" :
+       "=a" (ret) :
+       "d" (port));
+   return ret;
+}
+
+static __inline__ unsigned int
+inl(unsigned short port)
+{
+   unsigned int ret;
+   __asm__ __volatile__("inl %1,%0" :
+       "=a" (ret) :
+       "d" (port));
+   return ret;
+}
+
+#     else	/* GCCUSESGAS */
+
+static __inline__ void
+outb(unsigned short port, unsigned char val)
+{
+  __asm__ __volatile__("out%B0 (%1)" : :"a" (val), "d" (port));
+}
+
+static __inline__ void
+outw(unsigned short port, unsigned short val)
+{
+  __asm__ __volatile__("out%W0 (%1)" : :"a" (val), "d" (port));
+}
+
+static __inline__ void
+outl(unsigned short port, unsigned int val)
+{
+  __asm__ __volatile__("out%L0 (%1)" : :"a" (val), "d" (port));
+}
+
+static __inline__ unsigned int
+inb(unsigned short port)
+{
+  unsigned char ret;
+  __asm__ __volatile__("in%B0 (%1)" :
+		   "=a" (ret) :
+		   "d" (port));
+  return ret;
+}
+
+static __inline__ unsigned int
+inw(unsigned short port)
+{
+  unsigned short ret;
+  __asm__ __volatile__("in%W0 (%1)" :
+		   "=a" (ret) :
+		   "d" (port));
+  return ret;
+}
+
+static __inline__ unsigned int
+inl(unsigned short port)
+{
+  unsigned int ret;
+  __asm__ __volatile__("in%L0 (%1)" :
+                   "=a" (ret) :
+                   "d" (port));
+  return ret;
+}
+
+#     endif /* GCCUSESGAS */
+
+#    else /* !defined(FAKEIT) && !defined(__mc68000__)  && !defined(__arm__) && !defined(__sh__) && !defined(__hppa__)*/
+
+static __inline__ void
+outb(unsigned short port, unsigned char val)
+{
+}
+
+static __inline__ void
+outw(unsigned short port, unsigned short val)
+{
+}
+
+static __inline__ void
+outl(unsigned short port, unsigned int val)
+{
+}
+
+static __inline__ unsigned int
+inb(unsigned short port)
+{
+  return 0;
+}
+
+static __inline__ unsigned int
+inw(unsigned short port)
+{
+  return 0;
+}
+
+static __inline__ unsigned int
+inl(unsigned short port)
+{
+  return 0;
+}
+
+#    endif /* FAKEIT */
+
+#   endif /* ix86 */
+
+#  elif defined(__powerpc__) /* && !__GNUC__ */
+/*
+ * NON-GCC PowerPC - Presumed to be PowerMAX OS for now
+ */
+#   ifndef PowerMAX_OS
+#    error - Non-gcc PowerPC and !PowerMAXOS ???
+#   endif
+
+#   define PPCIO_DEBUG  0
+#   define PPCIO_INLINE 1
+#   define USE_ABS_MACRO 1
+/*
+ * Use compiler intrinsics to access certain PPC machine instructions
+ */
+#   define eieio()	      __inst_eieio()
+#   define stw_brx(val,base,ndx) __inst_sthbrx(val,base,ndx)
+#   define stl_brx(val,base,ndx) __inst_stwbrx(val,base,ndx)
+#   define ldw_brx(base,ndx)     __inst_lhbrx(base,ndx)
+#   define ldl_brx(base,ndx)     __inst_lwbrx(base,ndx)
+
+#   define ldq_u(p)	(*((unsigned long long  *)(p)))
+#   define ldl_u(p)	(*((unsigned long   *)(p)))
+#   define ldw_u(p)	(*((unsigned short *)(p)))
+#   define stq_u(v,p)	(*(unsigned long long *)(p)) = (v)
+#   define stl_u(v,p)	(*(unsigned long  *)(p)) = (v)
+#   define stw_u(v,p)	(*(unsigned short *)(p)) = (v)
+#   define mem_barrier()         eieio()
+#   define write_mem_barrier()   eieio()
+
+extern volatile unsigned char *ioBase;
+
+#   if !defined(abs) && defined(USE_ABS_MACRO)
+#    define abs(x) ((x) >= 0 ? (x) : -(x))
+#   endif
+
+#   undef inb
+#   undef inw
+#   undef inl
+#   undef outb
+#   undef outw
+#   undef outl
+
+#   if PPCIO_DEBUG
+
+extern void debug_outb(unsigned int a, unsigned char b, int line, char *file);
+extern void debug_outw(unsigned int a, unsigned short w, int line, char *file);
+extern void debug_outl(unsigned int a, unsigned int l, int line, char *file);
+extern unsigned char debug_inb(unsigned int a, int line, char *file);
+extern unsigned short debug_inw(unsigned int a, int line, char *file);
+extern unsigned int debug_inl(unsigned int a, int line, char *file);
+
+#    define outb(a,b) debug_outb(a,b, __LINE__, __FILE__)
+#    define outw(a,w) debug_outw(a,w, __LINE__, __FILE__)
+#    define outl(a,l) debug_outl(a,l, __LINE__, __FILE__)
+#    define inb(a)    debug_inb(a, __LINE__, __FILE__)
+#    define inw(a)    debug_inw(a, __LINE__, __FILE__)
+#    define inl(a)    debug_inl(a, __LINE__, __FILE__)
+
+#   else /* !PPCIO_DEBUG */
+
+extern unsigned char  inb(unsigned int a);
+extern unsigned short inw(unsigned int a);
+extern unsigned int   inl(unsigned int a);
+
+#    if PPCIO_INLINE
+
+#     define outb(a,b) \
+            (*((volatile unsigned char *)(ioBase + (a))) = (b), eieio())
+#     define outw(a,w) (stw_brx((w),ioBase,(a)), eieio())
+#     define outl(a,l) (stl_brx((l),ioBase,(a)), eieio())
+
+#    else /* !PPCIO_INLINE */
+
+extern void outb(unsigned int a, unsigned char b);
+extern void outw(unsigned int a, unsigned short w);
+extern void outl(unsigned int a, unsigned int l);
+
+#    endif /* PPCIO_INLINE */
+
+#   endif /* !PPCIO_DEBUG */
+
+#  else /* !GNUC && !PPC */
+#   if !defined(QNX4)
+#    if defined(__STDC__) && (__STDC__ == 1)
+#     ifndef asm
+#      define asm __asm
+#     endif
+#    endif
+#    ifdef SVR4
+#if 0
+#     include <sys/types.h>
+#endif
+#     ifndef __HIGHC__
+#      ifndef __USLC__
+#       define __USLC__
+#      endif
+#     endif
+#    endif
+#    ifndef SCO325
+#     if defined(USL)
+#      if defined(IN_MODULE)
+#     /* avoid including <sys/types.h> for <sys/inline.h> on UnixWare */
+#       define ushort unsigned short
+#       define ushort_t unsigned short
+#       define ulong unsigned long
+#       define ulong_t unsigned long
+#       define uint_t unsigned int
+#       define uchar_t unsigned char
+#      else
+#       include <sys/types.h>
+#      endif /* IN_MODULE */
+#     endif /* USL */
+#     include <sys/inline.h>
+#    else
+#     include "scoasm.h"
+#    endif
+#    if !defined(__HIGHC__) && !defined(SCO325)
+#     pragma asm partial_optimization outl
+#     pragma asm partial_optimization outw
+#     pragma asm partial_optimization outb
+#     pragma asm partial_optimization inl
+#     pragma asm partial_optimization inw
+#     pragma asm partial_optimization inb
+#    endif
+#   endif
+#   define ldq_u(p)	(*((unsigned long  *)(p)))
+#   define ldl_u(p)	(*((unsigned int   *)(p)))
+#   define ldw_u(p)	(*((unsigned short *)(p)))
+#   define stq_u(v,p)	(*(unsigned long  *)(p)) = (v)
+#   define stl_u(v,p)	(*(unsigned int   *)(p)) = (v)
+#   define stw_u(v,p)	(*(unsigned short *)(p)) = (v)
+#   define mem_barrier()   /* NOP */
+#   define write_mem_barrier()   /* NOP */
+#  endif /* __GNUC__ */
+
+#  if defined(QNX4)
+#   include <sys/types.h>
+extern unsigned  inb(unsigned port);
+extern unsigned  inw(unsigned port);
+extern unsigned  inl(unsigned port);
+extern void outb(unsigned port, unsigned val);
+extern void outw(unsigned port, unsigned val);
+extern void outl(unsigned port, unsigned val);
+#  endif /* QNX4 */
+
+#  if defined(IODEBUG) && defined(__GNUC__)
+#   undef inb
+#   undef inw
+#   undef inl
+#   undef outb
+#   undef outw
+#   undef outl
+#   define inb(a) __extension__ ({unsigned char __c=RealInb(a); ErrorF("inb(0x%03x) = 0x%02x\t@ line %4d, file %s\n", a, __c, __LINE__, __FILE__);__c;})
+#   define inw(a) __extension__ ({unsigned short __c=RealInw(a); ErrorF("inw(0x%03x) = 0x%04x\t@ line %4d, file %s\n", a, __c, __LINE__, __FILE__);__c;})
+#   define inl(a) __extension__ ({unsigned int __c=RealInl(a); ErrorF("inl(0x%03x) = 0x%08x\t@ line %4d, file %s\n", a, __c, __LINE__, __FILE__);__c;})
+
+#   define outb(a,b) (ErrorF("outb(0x%03x, 0x%02x)\t@ line %4d, file %s\n", a, b, __LINE__, __FILE__),RealOutb(a,b))
+#   define outw(a,b) (ErrorF("outw(0x%03x, 0x%04x)\t@ line %4d, file %s\n", a, b, __LINE__, __FILE__),RealOutw(a,b))
+#   define outl(a,b) (ErrorF("outl(0x%03x, 0x%08x)\t@ line %4d, file %s\n", a, b, __LINE__, __FILE__),RealOutl(a,b))
+#  endif
+
+# endif /* NO_INLINE */
+
+# ifdef __alpha__
+/* entry points for Mmio memory access routines */
+extern int (*xf86ReadMmio8)(void *, unsigned long);
+extern int (*xf86ReadMmio16)(void *, unsigned long);
+extern int (*xf86ReadMmio32)(void *, unsigned long);
+extern void (*xf86WriteMmio8)(int, void *, unsigned long);
+extern void (*xf86WriteMmio16)(int, void *, unsigned long);
+extern void (*xf86WriteMmio32)(int, void *, unsigned long);
+extern void (*xf86WriteMmioNB8)(int, void *, unsigned long);
+extern void (*xf86WriteMmioNB16)(int, void *, unsigned long);
+extern void (*xf86WriteMmioNB32)(int, void *, unsigned long);
+extern void xf86JensenMemToBus(char *, long, long, int);
+extern void xf86JensenBusToMem(char *, char *, unsigned long, int);
+extern void xf86SlowBCopyFromBus(unsigned char *, unsigned char *, int);
+extern void xf86SlowBCopyToBus(unsigned char *, unsigned char *, int);
+
+/* Some macros to hide the system dependencies for MMIO accesses */
+/* Changed to kill noise generated by gcc's -Wcast-align */
+#  define MMIO_IN8(base, offset) (*xf86ReadMmio8)(base, offset)
+#  define MMIO_IN16(base, offset) (*xf86ReadMmio16)(base, offset)
+#  define MMIO_IN32(base, offset) (*xf86ReadMmio32)(base, offset)
+
+#  if defined (JENSEN_SUPPORT)
+#   define MMIO_OUT32(base, offset, val) \
+    (*xf86WriteMmio32)((CARD32)(val), base, offset)
+#   define MMIO_ONB32(base, offset, val) \
+    (*xf86WriteMmioNB32)((CARD32)(val), base, offset)
+#  else
+#   define MMIO_OUT32(base, offset, val) \
+    do { \
+	write_mem_barrier(); \
+	*(volatile CARD32 *)(void *)(((CARD8*)(base)) + (offset)) = (val); \
+    } while (0)
+#   define MMIO_ONB32(base, offset, val) \
+	*(volatile CARD32 *)(void *)(((CARD8*)(base)) + (offset)) = (val)
+#  endif
+
+#  define MMIO_OUT8(base, offset, val) \
+    (*xf86WriteMmio8)((CARD8)(val), base, offset)
+#  define MMIO_OUT16(base, offset, val) \
+    (*xf86WriteMmio16)((CARD16)(val), base, offset)
+#  define MMIO_ONB8(base, offset, val) \
+    (*xf86WriteMmioNB8)((CARD8)(val), base, offset)
+#  define MMIO_ONB16(base, offset, val) \
+    (*xf86WriteMmioNB16)((CARD16)(val), base, offset)
+#  define MMIO_MOVE32(base, offset, val) \
+    MMIO_OUT32(base, offset, val)
+
+# elif defined(__powerpc__)
+ /*
+  * we provide byteswapping and no byteswapping functions here
+  * with byteswapping as default,
+  * drivers that don't need byteswapping should define PPC_MMIO_IS_BE
+  */
+#  define MMIO_IN8(base, offset) xf86ReadMmio8(base, offset)
+#  define MMIO_OUT8(base, offset, val) \
+    xf86WriteMmio8(base, offset, (CARD8)(val))
+#  define MMIO_ONB8(base, offset, val) \
+    xf86WriteMmioNB8(base, offset, (CARD8)(val))
+
+#  if defined(PPC_MMIO_IS_BE) /* No byteswapping */
+#   define MMIO_IN16(base, offset) xf86ReadMmio16Be(base, offset)
+#   define MMIO_IN32(base, offset) xf86ReadMmio32Be(base, offset)
+#   define MMIO_OUT16(base, offset, val) \
+    xf86WriteMmio16Be(base, offset, (CARD16)(val))
+#   define MMIO_OUT32(base, offset, val) \
+    xf86WriteMmio32Be(base, offset, (CARD32)(val))
+#   define MMIO_ONB16(base, offset, val) \
+    xf86WriteMmioNB16Be(base, offset, (CARD16)(val))
+#   define MMIO_ONB32(base, offset, val) \
+    xf86WriteMmioNB32Be(base, offset, (CARD32)(val))
+#  else /* byteswapping is the default */
+#   define MMIO_IN16(base, offset) xf86ReadMmio16Le(base, offset)
+#   define MMIO_IN32(base, offset) xf86ReadMmio32Le(base, offset)
+#   define MMIO_OUT16(base, offset, val) \
+     xf86WriteMmio16Le(base, offset, (CARD16)(val))
+#   define MMIO_OUT32(base, offset, val) \
+     xf86WriteMmio32Le(base, offset, (CARD32)(val))
+#   define MMIO_ONB16(base, offset, val) \
+     xf86WriteMmioNB16Le(base, offset, (CARD16)(val))
+#   define MMIO_ONB32(base, offset, val) \
+     xf86WriteMmioNB32Le(base, offset, (CARD32)(val))
+#  endif
+
+#  define MMIO_MOVE32(base, offset, val) \
+       xf86WriteMmio32Be(base, offset, (CARD32)(val))
+
+static __inline__ void ppc_flush_icache(char *addr)
+{
+	__asm__ volatile (
+		"dcbf 0,%0;"
+		"sync;"
+		"icbi 0,%0;"
+		"sync;"
+		"isync;"
+		: : "r"(addr) : "memory");
+}
+
+# elif defined(__sparc__)
+ /*
+  * Like powerpc, we provide byteswapping and no byteswapping functions
+  * here with byteswapping as default, drivers that don't need byteswapping
+  * should define SPARC_MMIO_IS_BE (perhaps create a generic macro so that we
+  * do not need to use PPC_MMIO_IS_BE and the sparc one in all the same places
+  * of drivers?).
+  */
+#  define MMIO_IN8(base, offset) xf86ReadMmio8(base, offset)
+#  define MMIO_OUT8(base, offset, val) \
+    xf86WriteMmio8(base, offset, (CARD8)(val))
+#  define MMIO_ONB8(base, offset, val) \
+    xf86WriteMmio8NB(base, offset, (CARD8)(val))
+
+#  if defined(SPARC_MMIO_IS_BE) /* No byteswapping */
+#   define MMIO_IN16(base, offset) xf86ReadMmio16Be(base, offset)
+#   define MMIO_IN32(base, offset) xf86ReadMmio32Be(base, offset)
+#   define MMIO_OUT16(base, offset, val) \
+     xf86WriteMmio16Be(base, offset, (CARD16)(val))
+#   define MMIO_OUT32(base, offset, val) \
+     xf86WriteMmio32Be(base, offset, (CARD32)(val))
+#   define MMIO_ONB16(base, offset, val) \
+     xf86WriteMmio16BeNB(base, offset, (CARD16)(val))
+#   define MMIO_ONB32(base, offset, val) \
+     xf86WriteMmio32BeNB(base, offset, (CARD32)(val))
+#  else /* byteswapping is the default */
+#   define MMIO_IN16(base, offset) xf86ReadMmio16Le(base, offset)
+#   define MMIO_IN32(base, offset) xf86ReadMmio32Le(base, offset)
+#   define MMIO_OUT16(base, offset, val) \
+     xf86WriteMmio16Le(base, offset, (CARD16)(val))
+#   define MMIO_OUT32(base, offset, val) \
+     xf86WriteMmio32Le(base, offset, (CARD32)(val))
+#   define MMIO_ONB16(base, offset, val) \
+     xf86WriteMmio16LeNB(base, offset, (CARD16)(val))
+#   define MMIO_ONB32(base, offset, val) \
+     xf86WriteMmio32LeNB(base, offset, (CARD32)(val))
+#  endif
+
+#  define MMIO_MOVE32(base, offset, val) \
+       xf86WriteMmio32Be(base, offset, (CARD32)(val))
+
+# else /* !__alpha__ && !__powerpc__ && !__sparc__ */
+
+#  define MMIO_IN8(base, offset) \
+	*(volatile CARD8 *)(((CARD8*)(base)) + (offset))
+#  define MMIO_IN16(base, offset) \
+	*(volatile CARD16 *)(void *)(((CARD8*)(base)) + (offset))
+#  define MMIO_IN32(base, offset) \
+	*(volatile CARD32 *)(void *)(((CARD8*)(base)) + (offset))
+#  define MMIO_OUT8(base, offset, val) \
+	*(volatile CARD8 *)(((CARD8*)(base)) + (offset)) = (val)
+#  define MMIO_OUT16(base, offset, val) \
+	*(volatile CARD16 *)(void *)(((CARD8*)(base)) + (offset)) = (val)
+#  define MMIO_OUT32(base, offset, val) \
+	*(volatile CARD32 *)(void *)(((CARD8*)(base)) + (offset)) = (val)
+#  define MMIO_ONB8(base, offset, val) MMIO_OUT8(base, offset, val)
+#  define MMIO_ONB16(base, offset, val) MMIO_OUT16(base, offset, val)
+#  define MMIO_ONB32(base, offset, val) MMIO_OUT32(base, offset, val)
+
+#  define MMIO_MOVE32(base, offset, val) MMIO_OUT32(base, offset, val)
+
+# endif /* __alpha__ */
+
+/*
+ * With Intel, the version in os-support/misc/SlowBcopy.s is used.
+ * This avoids port I/O during the copy (which causes problems with
+ * some hardware).
+ */
+# ifdef __alpha__
+#  define slowbcopy_tobus(src,dst,count) xf86SlowBCopyToBus(src,dst,count)
+#  define slowbcopy_frombus(src,dst,count) xf86SlowBCopyFromBus(src,dst,count)
+# else /* __alpha__ */
+#  define slowbcopy_tobus(src,dst,count) xf86SlowBcopy(src,dst,count)
+#  define slowbcopy_frombus(src,dst,count) xf86SlowBcopy(src,dst,count)
+# endif /* __alpha__ */
+
+#endif /* _COMPILER_H */
Index: VirtualBox-7.0.4/src/VBox/Additions/x11/vboxvideo/xorg-server.h
===================================================================
--- /dev/null
+++ VirtualBox-7.0.4/src/VBox/Additions/x11/vboxvideo/xorg-server.h
@@ -0,0 +1,247 @@
+/* include/xorg-server.h.  Generated from xorg-server.h.in by configure.  */
+/* xorg-server.h.in						-*- c -*-
+ *
+ * This file is the template file for the xorg-server.h file which gets
+ * installed as part of the SDK.  The #defines in this file overlap
+ * with those from config.h, but only for those options that we want
+ * to export to external modules.  Boilerplate autotool #defines such
+ * as HAVE_STUFF and PACKAGE_NAME is kept in config.h
+ *
+ * It is still possible to update config.h.in using autoheader, since
+ * autoheader only creates a .h.in file for the first
+ * AM_CONFIG_HEADER() line, and thus does not overwrite this file.
+ *
+ * However, it should be kept in sync with this file.
+ */
+
+#ifndef _XORG_SERVER_H_
+#define _XORG_SERVER_H_
+
+/* Support BigRequests extension */
+#define BIGREQS 1
+
+/* Default font path */
+#define COMPILEDDEFAULTFONTPATH "/usr/local/lib/X11/fonts/misc/,/usr/local/lib/X11/fonts/TTF/,/usr/local/lib/X11/fonts/OTF,/usr/local/lib/X11/fonts/Type1/,/usr/local/lib/X11/fonts/100dpi/,/usr/local/lib/X11/fonts/75dpi/"
+
+/* Support Composite Extension */
+#define COMPOSITE 1
+
+/* Use OsVendorInit */
+#define DDXOSINIT 1
+
+/* Build DPMS extension */
+#define DPMSExtension 1
+
+/* Build GLX extension */
+#define GLXEXT 1
+
+/* Include handhelds.org h3600 touchscreen driver */
+/* #undef H3600_TS */
+
+/* Support XDM-AUTH*-1 */
+#define HASXDMAUTH 1
+
+/* Support SHM */
+#define HAS_SHM 1
+
+/* Support IPv6 for TCP connections */
+#define IPv6 1
+
+/* Support MIT Misc extension */
+#define MITMISC 1
+
+/* Support MIT-SHM Extension */
+#define MITSHM 1
+
+/* Disable some debugging code */
+#define NDEBUG 1
+
+/* Need XFree86 helper functions */
+#define NEED_XF86_PROTOTYPES 1
+
+/* Need XFree86 typedefs */
+#define NEED_XF86_TYPES 1
+
+/* Internal define for Xinerama */
+#define PANORAMIX 1
+
+/* Support RANDR extension */
+#define RANDR 1
+
+/* Support RENDER extension */
+#define RENDER 1
+
+/* Support X resource extension */
+#define RES 1
+
+/* Support MIT-SCREEN-SAVER extension */
+#define SCREENSAVER 1
+
+/* Use a lock to prevent multiple servers on a display */
+#define SERVER_LOCK 1
+
+/* Support SHAPE extension */
+#define SHAPE 1
+
+/* Include time-based scheduler */
+#define SMART_SCHEDULE 1
+
+/* Define to 1 on systems derived from System V Release 4 */
+/* #undef SVR4 */
+
+/* Support TCP socket connections */
+#define TCPCONN 1
+
+/* Enable touchscreen support */
+/* #undef TOUCHSCREEN */
+
+/* Support tslib touchscreen abstraction library */
+/* #undef TSLIB */
+
+/* Support UNIX socket connections */
+#define UNIXCONN 1
+
+/* unaligned word accesses behave as expected */
+/* #undef WORKING_UNALIGNED_INT */
+
+/* Support XCMisc extension */
+#define XCMISC 1
+
+/* Support Xdmcp */
+#define XDMCP 1
+
+/* Build XFree86 BigFont extension */
+/* #undef XF86BIGFONT */
+
+/* Support XFree86 miscellaneous extensions */
+#define XF86MISC 1
+
+/* Support XFree86 Video Mode extension */
+#define XF86VIDMODE 1
+
+/* Build XDGA support */
+#define XFreeXDGA 1
+
+/* Support Xinerama extension */
+#define XINERAMA 1
+
+/* Support X Input extension */
+#define XINPUT 1
+
+/* Build XKB */
+#define XKB 1
+
+/* Enable XKB per default */
+#define XKB_DFLT_DISABLED 0
+
+/* Build XKB server */
+#define XKB_IN_SERVER 1
+
+/* Support loadable input and output drivers */
+/* #undef XLOADABLE */
+
+/* Build DRI extension */
+#define XF86DRI 1
+
+/* Build DRI2 extension */
+/* #undef DRI2 */
+
+/* Build Xorg server */
+#define XORGSERVER 1
+
+/* Vendor release */
+/* #undef XORG_RELEASE */
+
+/* Current Xorg version */
+#define XORG_VERSION_CURRENT (((1) * 10000000) + ((5) * 100000) + ((3) * 1000) + 0)
+
+/* Build Xv Extension */
+#define XvExtension 1
+
+/* Build XvMC Extension */
+#define XvMCExtension 1
+
+/* Build XRes extension */
+#define XResExtension 1
+
+/* Support XSync extension */
+#define XSYNC 1
+
+/* Support XTest extension */
+#define XTEST 1
+
+/* Support XTrap extension */
+/* #undef XTRAP */
+
+/* Support Xv Extension */
+#define XV 1
+
+/* Vendor name */
+#define XVENDORNAME "The X.Org Foundation"
+
+/* Endian order */
+#define _X_BYTE_ORDER X_LITTLE_ENDIAN
+/* Deal with multiple architecture compiles on Mac OS X */
+#ifndef __APPLE_CC__
+#define X_BYTE_ORDER _X_BYTE_ORDER
+#else
+#ifdef __BIG_ENDIAN__
+#define X_BYTE_ORDER X_BIG_ENDIAN
+#else
+#define X_BYTE_ORDER X_LITTLE_ENDIAN
+#endif
+#endif
+
+/* BSD-compliant source */
+/* #undef _BSD_SOURCE */
+
+/* POSIX-compliant source */
+/* #undef _POSIX_SOURCE */
+
+/* X/Open-compliant source */
+/* #undef _XOPEN_SOURCE */
+
+/* Vendor web address for support */
+#define __VENDORDWEBSUPPORT__ "http://wiki.x.org"
+
+/* Location of configuration file */
+#define __XCONFIGFILE__ "xorg.conf"
+
+/* XKB default rules */
+#define __XKBDEFRULES__ "xorg"
+
+/* Name of X server */
+#define __XSERVERNAME__ "Xorg"
+
+/* Define to 1 if unsigned long is 64 bits. */
+/* #undef _XSERVER64 */
+
+/* Building vgahw module */
+#define WITH_VGAHW 1
+
+/* System is BSD-like */
+/* #undef CSRG_BASED */
+
+/* Solaris 8 or later? */
+/* #undef __SOL8__ */
+
+/* System has PC console */
+/* #undef PCCONS_SUPPORT */
+
+/* System has PCVT console */
+/* #undef PCVT_SUPPORT */
+
+/* System has syscons console */
+/* #undef SYSCONS_SUPPORT */
+
+/* System has wscons console */
+/* #undef WSCONS_SUPPORT */
+
+/* Loadable XFree86 server awesomeness */
+#define XFree86LOADER 1
+
+/* Use libpciaccess */
+#define XSERVER_LIBPCIACCESS 1
+
+#endif /* _XORG_SERVER_H_ */
+
Index: VirtualBox-7.0.4/src/VBox/Additions/x11/vboxvideo/Makefile.kmk
===================================================================
--- VirtualBox-7.0.4.orig/src/VBox/Additions/x11/vboxvideo/Makefile.kmk
+++ VirtualBox-7.0.4/src/VBox/Additions/x11/vboxvideo/Makefile.kmk
@@ -410,7 +410,7 @@ ifdef VBOX_USE_SYSTEM_XORG_HEADERS
  SYSMODS := $(filter-out vboxvideo_drv%,$(SYSMODS))
  vboxvideo_drv_system_TEMPLATE = VBOXGUESTR3XORGMOD
  vboxvideo_drv_system_CFLAGS := \
-        $(vboxvideo_drv_70_CFLAGS) -include xorg-server.h
+        $(vboxvideo_drv_70_CFLAGS) -Isrc/VBox/Additions/x11/x11include/XFree86-4.3/Xserver/ -Isrc/VBox/Additions/x11/x11include/XFree86-4.3/X11/
  vboxvideo_drv_system_DEFS := $(filter-out _XORG_SERVER_H_ _DIX_CONFIG_H_, $(vboxvideo_15_DEFS))
  vboxvideo_drv_system_INCS += \
         $(PATH_ROOT)/src/VBox/Runtime/include \

