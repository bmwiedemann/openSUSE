Index: coregrind/m_debuginfo/debuginfo.c
===================================================================
--- coregrind/m_debuginfo/debuginfo.c.orig
+++ coregrind/m_debuginfo/debuginfo.c
@@ -49,6 +49,7 @@
 #include "pub_core_oset.h"
 #include "pub_core_stacktrace.h" // VG_(get_StackTrace) XXX: circular dependency
 #include "pub_core_ume.h"
+#include "pub_core_mallocfree.h"
 
 #include "priv_misc.h"           /* dinfo_zalloc/free */
 #include "priv_image.h"
@@ -1430,6 +1431,132 @@ void VG_(di_notify_pdb_debuginfo)( Int f
 #endif /* defined(VGO_linux) || defined(VGO_darwin) || defined(VGO_solaris) */
 
 
+/* Storing and retrieving information caused by JITted code.  TODO:
+   move somewhere more suitable. */
+
+typedef
+   struct {
+      Char *name;
+      Addr  start, end;
+   }
+   JitEntry;
+
+static JitEntry *jit_entries;
+static Int       jit_entries_size;
+static Int       jit_entry_count;
+
+#define JITSYMS_START_SIZE 128
+#define JITSYMS_INCREMENT   64
+
+void VG_(register_jited_code) ( Char *name, Addr start, SizeT len)
+{
+   Int l, u, mid, slot, j;
+   JitEntry* e = NULL;
+
+   if (jit_entry_count + 1 >= jit_entries_size) {
+      if (jit_entries == NULL) {
+         jit_entries = VG_(arena_calloc)(
+		 VG_AR_DINFO, "jit-register",
+                          JITSYMS_START_SIZE, sizeof(JitEntry)
+                       );
+         jit_entries_size = JITSYMS_START_SIZE;
+      } else {
+         jit_entries = VG_(arena_realloc)(
+		 VG_AR_DINFO, "jit-register", jit_entries,
+                          (jit_entries_size + JITSYMS_INCREMENT)
+                             * sizeof(JitEntry)
+                       );
+         jit_entries_size += JITSYMS_INCREMENT;
+      }
+   }        
+   l = 0;
+   u = jit_entry_count;
+   while (l < u) {
+      mid = (l + u) / 2;
+      e = &jit_entries [mid];
+      if (e->start < start) {
+         l = mid + 1;
+      } else if (e->start > start) {
+         u = mid;
+      } else
+         break;
+   }
+   if (e == NULL) {
+      if (jit_entry_count != 0) {
+         /* this would be an error */
+      }
+      slot = 0;
+   } else if (e->start < start)
+      slot = mid + 1;
+   else
+      slot = mid;
+
+   if (e != NULL) {
+      for (j = jit_entry_count; j > mid+1; j--)
+         jit_entries [j] = jit_entries [j-1];
+   }
+
+   jit_entries [slot].name = VG_(strdup)("jit-register", name);
+   jit_entries [slot].start = start;
+   jit_entries [slot].end = start + len;
+   jit_entry_count++;
+}
+
+void VG_(unregister_jited_code) ( Addr start )
+{
+   Int l, u, mid;
+   JitEntry* e = NULL;
+
+   l = 0;
+   u = jit_entry_count;
+   while (l < u) {
+      mid = (l + u) / 2;
+      e = &jit_entries [mid];
+
+      if (e->start < start) {
+         l = mid + 1;
+      } else if (e->start > start) {
+         u = mid;
+      } else {
+         break;
+      }
+   }
+   if (e != NULL && start == e->start){
+      Int j;
+      VG_(free)(e->name);
+      for (j = mid + 1; j < jit_entry_count; j++)
+         jit_entries [j-1] = jit_entries [j];
+   }
+}
+
+static
+JitEntry* jit_lookup ( Addr pc, Char* buf, Int nbuf )
+{
+   Int l, u, mid;
+   JitEntry* e = NULL;
+
+   l = 0;
+   u = jit_entry_count;
+   while (l < u) {
+      mid = (l + u) / 2;
+      e = &jit_entries [mid];
+
+      if (e->end < pc) {
+         l = mid + 1;
+      } else if (e->start > pc) {
+         u = mid;
+      } else {
+         break;
+      }
+   }
+   if (e != NULL && pc >= e->start && pc < e->end){
+      VG_(strncpy_safely)(buf, e->name, nbuf);
+      return e;
+   }
+   return NULL;
+}
+
+
 /*------------------------------------------------------------*/
 /*---                                                      ---*/
 /*--- TOP LEVEL: QUERYING EXISTING DEBUG INFO              ---*/
@@ -1755,8 +1882,18 @@ Bool get_sym_name ( Bool do_cxx_demangli
    PtrdiffT   offset;
 
    search_all_symtabs ( a, &di, &sno, match_anywhere_in_sym, findText );
-   if (di == NULL) {
+   if (di == NULL)
+   {
       *buf = "";
+      if (findText)
+      {
+        JitEntry* je = jit_lookup (a, buf, nbuf);
+        if (!je)
+           return False;
+        if (offsetP)
+           *offsetP = a - je->start;
+        return True;
+      }
       return False;
    }
 
Index: coregrind/m_scheduler/scheduler.c
===================================================================
--- coregrind/m_scheduler/scheduler.c.orig
+++ coregrind/m_scheduler/scheduler.c
@@ -2087,6 +2087,16 @@ void do_client_request ( ThreadId tid )
          LibVEX_InitIRI ( (IRICB *)arg[1] );
          break;
 
+      case VG_USERREQ__JIT_REGISTER_MAP:
+         VG_(register_jited_code)( (Char*)arg[1], arg[2], arg[3] );
+         SET_CLREQ_RETVAL( tid, 0 );     /* return value is meaningless */
+         break;
+
+      case VG_USERREQ__JIT_UNREGISTER_MAP:
+         VG_(unregister_jited_code)( arg[1] );
+         SET_CLREQ_RETVAL( tid, 0 );     /* return value is meaningless */
+         break;
+	 
       default:
        my_default:
 	 if (os_client_request(tid, arg)) {
Index: coregrind/pub_core_debuginfo.h
===================================================================
--- coregrind/pub_core_debuginfo.h.orig
+++ coregrind/pub_core_debuginfo.h
@@ -101,6 +101,12 @@ Bool VG_(get_fnname_no_cxx_demangle) ( A
 extern
 Bool VG_(get_inst_offset_in_function)( Addr a, /*OUT*/PtrdiffT* offset );
 
+/* Register/deregister symbols created by JITs. */
+extern
+void VG_(register_jited_code)( Char* name, Addr start, SizeT len );
+
+extern
+void VG_(unregister_jited_code)( Addr start );
 
 /* Use DWARF2/3 CFA information to do one step of stack unwinding.
    D3UnwindRegs holds the current register values, and is
Index: include/valgrind.h
===================================================================
--- include/valgrind.h.orig
+++ include/valgrind.h
@@ -6706,6 +6706,10 @@ typedef
           /* Querying of debug info. */
           VG_USERREQ__MAP_IP_TO_SRCLOC = 0x1701,
 
+          /* JIT support */
+          VG_USERREQ__JIT_REGISTER_MAP = 0x1702,
+          VG_USERREQ__JIT_UNREGISTER_MAP = 0x1703,
+
           /* Disable/enable error reporting level.  Takes a single
              Word arg which is the delta to this thread's error
              disablement indicator.  Hence 1 disables or further
@@ -6873,6 +6877,19 @@ VALGRIND_PRINTF_BACKTRACE(const char *fo
                                     _qyy_arg1, _qyy_arg2,               \
                                     _qyy_arg3, 0)
 
+#define VALGRIND_JIT_REGISTER_MAP(name, start, end)               \
+   {unsigned int _qzz_res;                                        \
+    VALGRIND_DO_CLIENT_REQUEST(_qzz_res, 0,                       \
+                             VG_USERREQ__JIT_REGISTER_MAP,        \
+                             name, start, end, 0, 0);             \
+   }
+
+#define VALGRIND_JIT_UNREGISTER_MAP(name, start)                  \
+   {unsigned int _qzz_res;                                        \
+    VALGRIND_DO_CLIENT_REQUEST(_qzz_res, 0,                       \
+                             VG_USERREQ__JIT_REGISTER_MAP,        \
+                             start, 0, 0, 0, 0);                  \
+   }
 
 /* Counts the number of errors that have been recorded by a tool.  Nb:
    the tool must record the errors with VG_(maybe_record_error)() or
