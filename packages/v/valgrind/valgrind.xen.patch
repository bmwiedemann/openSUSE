The following changes since commit ddfc274b24a1ae3b57166ada1fe97acb433b9b79:

  s390x: More fixes for z13 support (2018-11-22 13:45:56 +0100)

are available in the Git repository at:

  https://github.com/olafhering/valgrind bug390553-20181125-ddfc274b2

for you to fetch changes up to 1c102a54e05843c6525f536c4844b68fafaa0955:

  fix whitespace in syswrap-xen.c (2018-11-25 21:11:03 +0100)

----------------------------------------------------------------
Olaf Hering (101):
      Remove dead code from XEN_DOMCTL_monitor_op
      fix xen_sysctl_numainfo handling
      Expect earliest version for versioned xen domctl/sysctl
      fix typo in xen domctl and sysctl header
      remove unhelpful comments from xen domctl
      merge two xen domctl values for clearity
      mention sysctl and domctl numbers from ancient Xen versions
      xen: include vki-xen-physdev.h earlier in vki-xen.h
      xen-3.0: versioned xen_domctl_settimeoffset
      xen-3.0.4: versioned xen_domctl_createdomain
      xen-3.1: handle IOCTL_GNTDEV_MAP_GRANT_REF
      xen-3.1: handle IOCTL_GNTDEV_UNMAP_GRANT_REF
      xen-3.1: handle IOCTL_GNTDEV_GET_OFFSET_FOR_VADDR
      xen-3.3: handle IOCTL_GNTDEV_SET_MAX_GRANTS
      xen-3.4: handle XENMEM_set_pod_target/XENMEM_get_pod_target
      xen-3.4: versioned hvmcontext_partial
      xen-4.1: versioned XEN_SYSCTL_numainfo
      xen-4.2: handle IOCTL_GNTALLOC_ALLOC_GREF
      xen-4.2: handle IOCTL_GNTALLOC_DEALLOC_GREF
      xen-4.2: handle IOCTL_GNTALLOC_SET_UNMAP_NOTIFY
      xen-4.2: define sharing_op
      xen-4.4: define add_to_physmap_batch
      xen-4.5: define sysctl psr_cmt_op
      xen-4.5: define GNTTABOP_cache_flush
      xen-4.5: define domctl setvnumainfo
      xen-4.5: define domctl psr_cmt_op
      xen-4.5: define domctl arm_configure_domain
      xen-4.5: define XENMEM_get_vnumainfo
      xen-4.5: versioned XEN_SYSCTL_topologyinfo
      xen-4.5: handle all versioned domctl ops
      xen-4.6: adjust case value for VKI_XEN_DOMCTL_monitor_op
      xen-4.6: new sysctl value
      xen-4.6: versioned xen_domctl_createdomain
      xen-4.6: versioned xen_domctl_settimeoffset
      xen-4.6: define domctl psr_cat_op
      xen-4.6: define XENMEM_reserved_device_memory_map
      xen-4.6: versioned XEN_SYSCTL_numainfo
      xen-4.6: handle XEN_SYSCTL_cputopoinfo
      xen-4.6: handle XEN_SYSCTL_pcitopoinfo
      xen-4.6: define sysctl psr_cat_op
      xen-4.6: define sysctl tmem_op
      xen-4.6: define hypercall xenpmu_op
      xen-4.6: handle all versioned domctl ops
      xen-4.6: handle all versioned sysctl ops
      xen-4.7: new sysctl value
      xen-4.7: fix domctl value in comment
      xen-4.7: versioned xen_arch_domainconfig
      xen-4.7: define XEN_VCPUAFFINITY_FORCE
      xen-4.7: define SCHEDOP put/getvcpuinfo
      xen-4.7: handle domctl soft_reset
      xen-4.7: define SCHEDOP_pin_override
      xen-4.7: versioned XEN_SYSCTL_get_cpu_featureset
      xen-4.7: define sysctl get_cpu_levelling_caps
      xen-4.7: define sysctl livepatch_op
      xen-4.7: handle XENVER_build_id
      xen-4.7: handle all versioned sysctl ops
      xen-4.8: new domctl value
      xen-4.8: new sysctl value
      xen-4.8: handle IOCTL_GNTDEV_GRANT_COPY
      xen-4.8: versioned xen_domctl_monitor_op
      xen-4.8: handle all versioned domctl ops
      xen-4.8: handle all versioned sysctl ops
      xen-4.9: new domctl value
      xen-4.9: new sysctl value
      xen-4.9: define NULL scheduler
      xen-4.9: define monitor event INTERRUPT and DESC_ACCESS
      xen-4.9: define sysctl gcov_op, which replaces coverage_op
      xen-4.9: handle dm_op hypercall
      xen-4.9: handle IOCTL_PRIVCMD_DM_OP
      xen-4.9: handle IOCTL_PRIVCMD_RESTRICT
      xen-4.9: handle all versioned domctl ops
      xen-4.9: handle all versioned sysctl ops
      xen-4.10: add domctl value
      xen-4.10: new sysctl value
      xen-4.10: handle xen_domctl_assign_device
      xen-4.10: versioned hvmcontext_partial
      xen-4.10: versioned xen_domctl_monitor_op
      xen-4.10: define monitor event EMUL_UNIMPLEMENTED
      xen-4.10: support xen_domctl_set_gnttab_limits
      xen-4.10: define domctl vuart_op
      xen-4.10: versioned xen_sysctl_physinfo
      xen-4.10: define sysctl set_parameter
      xen-4.10: handle all versioned domctl ops
      xen-4.10: handle all versioned sysctl ops
      xen-4.10.1: new domctl value from shim
      xen-4.10.1: versioned xen_domctl_getdomaininfo
      xen-4.10.1: handle all versioned domctl ops
      xen-4.11: new domctl value
      xen-4.11: new sysctl value
      xen-4.11: versioned xen_domctl_monitor_op
      xen-4.11: handle IOCTL_PRIVCMD_MMAP_RESOURCE
      xen-4.11: handle all versioned domctl ops
      xen-4.11: handle all versioned sysctl ops
      xen-4.12: new domctl value
      xen-4.12: new sysctl value
      xen-4.12: define sysctl get_cpu_policy
      xen-4.12: handle IOCTL_PRIVCMD_UNIMPLEMENTED
      xen-4.12: versioned xen_domctl_createdomain
      xen-4.12: handle all versioned domctl ops
      xen-4.12: handle all versioned sysctl ops
      fix whitespace in syswrap-xen.c

 coregrind/m_syswrap/syswrap-linux.c |  154 ++++++
 coregrind/m_syswrap/syswrap-xen.c   | 1014 +++++++++++++++++++++++++++++------
 include/vki/vki-linux.h             |  110 ++++
 include/vki/vki-xen-domctl.h        |  246 ++++++++-
 include/vki/vki-xen-gnttab.h        |    1 +
 include/vki/vki-xen-memory.h        |   12 +
 include/vki/vki-xen-physdev.h       |    9 +
 include/vki/vki-xen-schedop.h       |    2 +
 include/vki/vki-xen-sysctl.h        |   99 +++-
 include/vki/vki-xen-version.h       |   11 +
 include/vki/vki-xen.h               |    4 +-
 11 files changed, 1469 insertions(+), 193 deletions(-)

diff --git a/coregrind/m_syswrap/syswrap-linux.c b/coregrind/m_syswrap/syswrap-linux.c
index 90d4a8586..b98007082 100644
--- a/coregrind/m_syswrap/syswrap-linux.c
+++ b/coregrind/m_syswrap/syswrap-linux.c
@@ -8219,6 +8219,38 @@ PRE(sys_ioctl)
                     (Addr)args->arr, sizeof(*(args->arr)) * args->num);
       break;
    }
+   case VKI_XEN_IOCTL_PRIVCMD_DM_OP: {
+      struct vki_xen_privcmd_dm_op *args =
+         (struct vki_xen_privcmd_dm_op *)(ARG3);
+      PRE_MEM_READ("VKI_XEN_IOCTL_PRIVCMD_DM_OP(dom)",
+                  (Addr)&args->dom, sizeof(args->dom));
+      PRE_MEM_READ("VKI_XEN_IOCTL_PRIVCMD_DM_OP(num)",
+                  (Addr)&args->num, sizeof(args->num));
+      PRE_MEM_READ("VKI_XEN_IOCTL_PRIVCMD_DM_OP(ubufs)",
+                  (Addr)args->ubufs, sizeof(*(args->ubufs)) * args->num);
+      break;
+   }
+   case VKI_XEN_IOCTL_PRIVCMD_RESTRICT:
+      break;
+   case VKI_XEN_IOCTL_PRIVCMD_MMAP_RESOURCE: {
+      struct vki_xen_privcmd_mmap_resource *args =
+         (struct vki_xen_privcmd_mmap_resource *)(ARG3);
+      PRE_MEM_READ("VKI_XEN_IOCTL_PRIVCMD_MMAP_RESOURCE(dom)",
+                  (Addr)&args->dom, sizeof(args->dom));
+      PRE_MEM_READ("VKI_XEN_IOCTL_PRIVCMD_MMAP_RESOURCE(type)",
+                  (Addr)&args->type, sizeof(args->type));
+      PRE_MEM_READ("VKI_XEN_IOCTL_PRIVCMD_MMAP_RESOURCE(id)",
+                  (Addr)&args->id, sizeof(args->id));
+      PRE_MEM_READ("VKI_XEN_IOCTL_PRIVCMD_MMAP_RESOURCE(idx)",
+                  (Addr)&args->idx, sizeof(args->idx));
+      PRE_MEM_READ("VKI_XEN_IOCTL_PRIVCMD_MMAP_RESOURCE(num)",
+                  (Addr)&args->num, sizeof(args->num));
+      PRE_MEM_READ("VKI_XEN_IOCTL_PRIVCMD_MMAP_RESOURCE(addr)",
+                  (Addr)&args->addr, sizeof(args->addr));
+      break;
+   }
+   case VKI_XEN_IOCTL_PRIVCMD_UNIMPLEMENTED:
+      break;
 
    case VKI_XEN_IOCTL_EVTCHN_BIND_VIRQ: {
          struct vki_xen_ioctl_evtchn_bind_virq *args =
@@ -8260,6 +8292,80 @@ PRE(sys_ioctl)
    case VKI_XEN_IOCTL_EVTCHN_RESET:
       /* No input*/
       break;
+   case VKI_XEN_IOCTL_GNTDEV_MAP_GRANT_REF: {
+      struct vki_xen_ioctl_gntdev_map_grant_ref *args =
+         (struct vki_xen_ioctl_gntdev_map_grant_ref*)(Addr)(ARG3);
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTDEV_map_grant_ref(count)",
+                  (Addr)&args->count, sizeof(args->count));
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTDEV_map_grant_ref(refs)",
+                  (Addr)args->refs, sizeof(*(args->refs)) * args->count);
+      }
+      break;
+   case VKI_XEN_IOCTL_GNTDEV_UNMAP_GRANT_REF: {
+      struct vki_xen_ioctl_gntdev_map_grant_ref *args =
+         (struct vki_xen_ioctl_gntdev_map_grant_ref*)(Addr)(ARG3);
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTDEV_map_grant_ref(index)",
+                  (Addr)&args->index, sizeof(args->index));
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTDEV_map_grant_ref(count)",
+                  (Addr)&args->count, sizeof(args->count));
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTDEV_map_grant_ref(pad)",
+                  (Addr)&args->pad, sizeof(args->pad));
+      }
+      break;
+   case VKI_XEN_IOCTL_GNTDEV_GET_OFFSET_FOR_VADDR: {
+      struct vki_xen_ioctl_gntdev_get_offset_for_vaddr *args =
+         (struct vki_xen_ioctl_gntdev_get_offset_for_vaddr*)(Addr)(ARG3);
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTDEV_map_grant_ref(vaddr)",
+                  (Addr)&args->vaddr, sizeof(args->vaddr));
+      }
+      break;
+   case VKI_XEN_IOCTL_GNTDEV_SET_MAX_GRANTS: {
+      struct vki_xen_ioctl_gntdev_set_max_grants *args =
+         (struct vki_xen_ioctl_gntdev_set_max_grants*)(Addr)(ARG3);
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTDEV_set_max_grants(count)",
+                  (Addr)&args->count, sizeof(args->count));
+      }
+      break;
+   case VKI_XEN_IOCTL_GNTALLOC_ALLOC_GREF: {
+      struct vki_xen_ioctl_gntalloc_alloc_gref *args =
+         (struct vki_xen_ioctl_gntalloc_alloc_gref*)(Addr)(ARG3);
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTALLOC_alloc_gref(domid)",
+                  (Addr)&args->domid, sizeof(args->domid));
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTALLOC_alloc_gref(flags)",
+                  (Addr)&args->flags, sizeof(args->flags));
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTALLOC_alloc_gref(count)",
+                  (Addr)&args->count, sizeof(args->count));
+      }
+      break;
+   case VKI_XEN_IOCTL_GNTALLOC_DEALLOC_GREF: {
+      struct vki_xen_ioctl_gntalloc_dealloc_gref *args =
+         (struct vki_xen_ioctl_gntalloc_dealloc_gref*)(Addr)(ARG3);
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTALLOC_dealloc_gref(index)",
+                  (Addr)&args->index, sizeof(args->index));
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTALLOC_dealloc_gref(count)",
+                  (Addr)&args->count, sizeof(args->count));
+      }
+      break;
+   case VKI_XEN_IOCTL_GNTALLOC_SET_UNMAP_NOTIFY: {
+      struct vki_xen_ioctl_gntalloc_set_unmap_notify *args =
+         (struct vki_xen_ioctl_gntalloc_set_unmap_notify*)(Addr)(ARG3);
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTALLOC_set_unmap_notify(index)",
+                  (Addr)&args->index, sizeof(args->index));
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTALLOC_set_unmap_notify(action)",
+                  (Addr)&args->action, sizeof(args->action));
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTALLOC_set_unmap_notify(event_channel_port)",
+                  (Addr)&args->event_channel_port, sizeof(args->event_channel_port));
+      }
+      break;
+   case VKI_XEN_IOCTL_GNTDEV_GRANT_COPY: {
+      struct vki_xen_ioctl_gntdev_grant_copy *args =
+         (struct vki_xen_ioctl_gntdev_grant_copy*)(Addr)(ARG3);
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTDEV_grant_copy(count)",
+                  (Addr)&args->count, sizeof(args->count));
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTDEV_grant_copy(segments)",
+                  (Addr)args->segments, sizeof(*(args->segments)) * args->count);
+      }
+      break;
 #endif
 
    /* Lustre */
@@ -10726,6 +10832,16 @@ POST(sys_ioctl)
        POST_MEM_WRITE((Addr)args->err, sizeof(*(args->err)) * args->num);
       }
       break;
+   case VKI_XEN_IOCTL_PRIVCMD_DM_OP: {
+      struct vki_xen_privcmd_dm_op *args =
+         (struct vki_xen_privcmd_dm_op *)(ARG3);
+      POST_MEM_WRITE((Addr)args->ubufs, sizeof(*(args->ubufs)) * args->num);
+      }
+      break;
+   case VKI_XEN_IOCTL_PRIVCMD_RESTRICT:
+   case VKI_XEN_IOCTL_PRIVCMD_MMAP_RESOURCE:
+   case VKI_XEN_IOCTL_PRIVCMD_UNIMPLEMENTED:
+      break;
 
    case VKI_XEN_IOCTL_EVTCHN_BIND_VIRQ:
    case VKI_XEN_IOCTL_EVTCHN_BIND_INTERDOMAIN:
@@ -10735,6 +10851,44 @@ POST(sys_ioctl)
    case VKI_XEN_IOCTL_EVTCHN_RESET:
       /* No output */
       break;
+   case VKI_XEN_IOCTL_GNTDEV_MAP_GRANT_REF: {
+       struct vki_xen_ioctl_gntdev_map_grant_ref *args =
+            (struct vki_xen_ioctl_gntdev_map_grant_ref*)(Addr)(ARG3);
+       POST_FIELD_WRITE(args->index);
+      }
+      break;
+   case VKI_XEN_IOCTL_GNTDEV_UNMAP_GRANT_REF:
+      /* No output */
+      break;
+   case VKI_XEN_IOCTL_GNTDEV_GET_OFFSET_FOR_VADDR: {
+      struct vki_xen_ioctl_gntdev_get_offset_for_vaddr *args =
+         (struct vki_xen_ioctl_gntdev_get_offset_for_vaddr*)(Addr)(ARG3);
+      POST_FIELD_WRITE(args->count);
+      POST_FIELD_WRITE(args->offset);
+      }
+      break;
+   case VKI_XEN_IOCTL_GNTDEV_SET_MAX_GRANTS:
+      /* No output */
+      break;
+   case VKI_XEN_IOCTL_GNTALLOC_ALLOC_GREF: {
+      struct vki_xen_ioctl_gntalloc_alloc_gref *args =
+         (struct vki_xen_ioctl_gntalloc_alloc_gref*)(Addr)(ARG3);
+      POST_FIELD_WRITE(args->index);
+      POST_FIELD_WRITE(args->count);
+      POST_MEM_WRITE((Addr)&args->gref_ids,
+                     sizeof(args->gref_ids) * sizeof(args->count));
+      }
+      break;
+   case VKI_XEN_IOCTL_GNTALLOC_DEALLOC_GREF:
+   case VKI_XEN_IOCTL_GNTALLOC_SET_UNMAP_NOTIFY:
+      /* No output */
+      break;
+   case VKI_XEN_IOCTL_GNTDEV_GRANT_COPY: {
+      struct vki_xen_ioctl_gntdev_grant_copy *args =
+         (struct vki_xen_ioctl_gntdev_grant_copy*)(Addr)(ARG3);
+      POST_MEM_WRITE((Addr)args->segments, sizeof(*(args->segments)) * args->count);
+      }
+      break;
 #endif
 
    /* Lustre */
diff --git a/coregrind/m_syswrap/syswrap-xen.c b/coregrind/m_syswrap/syswrap-xen.c
index 54153ab1c..35e5ab453 100644
--- a/coregrind/m_syswrap/syswrap-xen.c
+++ b/coregrind/m_syswrap/syswrap-xen.c
@@ -137,7 +137,7 @@ PRE(memory_op)
 
    case VKI_XENMEM_set_memory_map: {
       struct vki_xen_foreign_memory_map *arg =
-	      (struct vki_xen_foreign_memory_map *)ARG2;
+         (struct vki_xen_foreign_memory_map *)ARG2;
       PRE_MEM_READ("XENMEM_set_memory_map domid",
                    (Addr)&arg->domid, sizeof(arg->domid));
       PRE_MEM_READ("XENMEM_set_memory_map map",
@@ -148,7 +148,7 @@ PRE(memory_op)
    case VKI_XENMEM_memory_map:
    case VKI_XENMEM_machine_memory_map: {
       struct vki_xen_memory_map *arg =
-	      (struct vki_xen_memory_map *)ARG2;
+         (struct vki_xen_memory_map *)ARG2;
       PRE_MEM_READ("XENMEM_memory_map nr_entries",
                    (Addr)&arg->nr_entries, sizeof(arg->nr_entries));
       break;
@@ -171,7 +171,7 @@ PRE(memory_op)
          PRE_MEM_READ(which,
                       (Addr)memory_reservation->extent_start.p,
                       sizeof(vki_xen_pfn_t) * memory_reservation->nr_extents);
-	 break;
+         break;
       case VKI_XENMEM_populate_physmap:
          which = "XENMEM_populate_physmap";
          PRE_MEM_READ(which,
@@ -234,6 +234,16 @@ PRE(memory_op)
    case VKI_XENMEM_get_sharing_shared_pages:
       break;
 
+   case VKI_XENMEM_get_pod_target:
+   case VKI_XENMEM_set_pod_target: {
+      struct vki_xen_pod_target *arg =
+         (struct vki_xen_pod_target *)ARG2;
+      PRE_MEM_READ("XENMEM_set_pod_target target_pages",
+                  (Addr)&arg->target_pages, sizeof(arg->target_pages));
+      PRE_MEM_READ("XENMEM_set_pod_target domid",
+                  (Addr)&arg->domid, sizeof(arg->domid));
+      break;
+   }
    case VKI_XENMEM_access_op: {
        struct vki_xen_mem_event_op *arg =
             (struct vki_xen_mem_event_op *)ARG2;
@@ -469,9 +479,9 @@ PRE(physdev_op)
 
    PRINT("__HYPERVISOR_physdev_op ( %ld, %#lx )", SARG1, ARG2);
 
-#define PRE_XEN_PHYSDEVOP_READ(_op, _field)		\
-   PRE_MEM_READ("XEN_PHYSDEVOP_" #_op " ." #_field,	\
-                (Addr)&arg->_field,			\
+#define PRE_XEN_PHYSDEVOP_READ(_op, _field) \
+   PRE_MEM_READ("XEN_PHYSDEVOP_" #_op " ." #_field, \
+                (Addr)&arg->_field, \
                 sizeof(arg->_field))
 
    switch (cmd) {
@@ -532,6 +542,7 @@ PRE(xen_version)
    case VKI_XENVER_pagesize:
    case VKI_XENVER_guest_handle:
    case VKI_XENVER_commandline:
+   case VKI_XENVER_build_id:
       /* No inputs */
       break;
 
@@ -548,11 +559,11 @@ PRE(grant_table_op)
    switch (ARG1) {
    case VKI_XEN_GNTTABOP_setup_table: {
       struct vki_xen_gnttab_setup_table *gst =
-	      (struct vki_xen_gnttab_setup_table*)ARG2;
+         (struct vki_xen_gnttab_setup_table*)ARG2;
       PRE_MEM_READ("VKI_XEN_GNTTABOP_setup_table dom",
-		   (Addr)&gst->dom, sizeof(gst->dom));
+                  (Addr)&gst->dom, sizeof(gst->dom));
       PRE_MEM_READ("VKI_XEN_GNTTABOP_setup_table nr_frames",
-                   (Addr)&gst->nr_frames, sizeof(gst->nr_frames));
+                  (Addr)&gst->nr_frames, sizeof(gst->nr_frames));
       break;
    }
    default:
@@ -584,16 +595,23 @@ PRE(sysctl) {
    case 0x00000009:
    case 0x0000000a:
    case 0x0000000b:
-	   break;
+   case 0x0000000c:
+   case 0x0000000d:
+   case 0x0000000e:
+   case 0x0000000f:
+   case 0x00000010:
+   case 0x00000011:
+   case 0x00000012:
+      break;
    default:
       bad_intf_version(tid, layout, arrghs, status, flags,
                        "__HYPERVISOR_sysctl", sysctl->interface_version);
       return;
    }
 
-#define __PRE_XEN_SYSCTL_READ(_sysctl, _union, _field)			\
-      PRE_MEM_READ("XEN_SYSCTL_" #_sysctl " u." #_union "." #_field,	\
-                   (Addr)&sysctl->u._union._field,			\
+#define __PRE_XEN_SYSCTL_READ(_sysctl, _union, _field) \
+      PRE_MEM_READ("XEN_SYSCTL_" #_sysctl " u." #_union "." #_field, \
+                   (Addr)&sysctl->u._union._field, \
                    sizeof(sysctl->u._union._field))
 #define PRE_XEN_SYSCTL_READ(_sysctl, _field) \
       __PRE_XEN_SYSCTL_READ(_sysctl, _sysctl, _field)
@@ -615,27 +633,33 @@ PRE(sysctl) {
       switch (sysctl->interface_version)
       {
       case 0x00000008:
-	 PRE_XEN_SYSCTL_READ(getdomaininfolist_00000008, first_domain);
-	 PRE_XEN_SYSCTL_READ(getdomaininfolist_00000008, max_domains);
-	 PRE_XEN_SYSCTL_READ(getdomaininfolist_00000008, buffer);
-	 break;
+         PRE_XEN_SYSCTL_READ(getdomaininfolist_00000008, first_domain);
+         PRE_XEN_SYSCTL_READ(getdomaininfolist_00000008, max_domains);
+         PRE_XEN_SYSCTL_READ(getdomaininfolist_00000008, buffer);
+         break;
       case 0x00000009:
-	 PRE_XEN_SYSCTL_READ(getdomaininfolist_00000009, first_domain);
-	 PRE_XEN_SYSCTL_READ(getdomaininfolist_00000009, max_domains);
-	 PRE_XEN_SYSCTL_READ(getdomaininfolist_00000009, buffer);
-	 break;
+         PRE_XEN_SYSCTL_READ(getdomaininfolist_00000009, first_domain);
+         PRE_XEN_SYSCTL_READ(getdomaininfolist_00000009, max_domains);
+         PRE_XEN_SYSCTL_READ(getdomaininfolist_00000009, buffer);
+         break;
       case 0x0000000a:
       case 0x0000000b:
-	 PRE_XEN_SYSCTL_READ(getdomaininfolist_0000000a, first_domain);
-	 PRE_XEN_SYSCTL_READ(getdomaininfolist_0000000a, max_domains);
-	 PRE_XEN_SYSCTL_READ(getdomaininfolist_0000000a, buffer);
-	 break;
+      case 0x0000000c:
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
+      case 0x00000012:
+         PRE_XEN_SYSCTL_READ(getdomaininfolist_0000000a, first_domain);
+         PRE_XEN_SYSCTL_READ(getdomaininfolist_0000000a, max_domains);
+         PRE_XEN_SYSCTL_READ(getdomaininfolist_0000000a, buffer);
+         break;
       default:
-          VG_(dmsg)("WARNING: XEN_SYSCTL_getdomaininfolist for sysctl version "
-                    "%"PRIx32" not implemented yet\n",
-                    sysctl->interface_version);
-          SET_STATUS_Failure(VKI_EINVAL);
-          return;
+         VG_(dmsg)("WARNING: XEN_SYSCTL_getdomaininfolist for sysctl version "
+                  "%"PRIx32" not implemented yet\n", sysctl->interface_version);
+         SET_STATUS_Failure(VKI_EINVAL);
+         return;
       }
       break;
 
@@ -680,18 +704,87 @@ PRE(sysctl) {
       /* No input params */
       break;
 
-   case VKI_XEN_SYSCTL_topologyinfo:
-      PRE_XEN_SYSCTL_READ(topologyinfo, max_cpu_index);
-      PRE_XEN_SYSCTL_READ(topologyinfo, cpu_to_core);
-      PRE_XEN_SYSCTL_READ(topologyinfo, cpu_to_socket);
-      PRE_XEN_SYSCTL_READ(topologyinfo, cpu_to_node);
+   case VKI_XEN_SYSCTL_topologyinfo | VKI_XEN_SYSCTL_cputopoinfo:
+      switch (sysctl->interface_version)
+      {
+      case 0x00000007:
+      case 0x00000008:
+      case 0x00000009:
+      case 0x0000000a:
+      case 0x0000000b:
+         PRE_XEN_SYSCTL_READ(topologyinfo, max_cpu_index);
+         PRE_XEN_SYSCTL_READ(topologyinfo, cpu_to_core);
+         PRE_XEN_SYSCTL_READ(topologyinfo, cpu_to_socket);
+         PRE_XEN_SYSCTL_READ(topologyinfo, cpu_to_node);
+         break;
+      case 0x0000000c:
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
+      case 0x00000012:
+         PRE_XEN_SYSCTL_READ(cputopoinfo_0000000c, num_cpus);
+         PRE_XEN_SYSCTL_READ(cputopoinfo_0000000c, cputopo);
+         break;
+      }
       break;
 
    case VKI_XEN_SYSCTL_numainfo:
-      PRE_XEN_SYSCTL_READ(numainfo, max_node_index);
-      PRE_XEN_SYSCTL_READ(numainfo, node_to_memsize);
-      PRE_XEN_SYSCTL_READ(numainfo, node_to_memfree);
-      PRE_XEN_SYSCTL_READ(numainfo, node_to_node_distance);
+      switch (sysctl->interface_version)
+      {
+      case 0x00000008:
+      case 0x00000009:
+      case 0x0000000a:
+      case 0x0000000b:
+         PRE_XEN_SYSCTL_READ(numainfo_00000008, max_node_index);
+         PRE_XEN_SYSCTL_READ(numainfo_00000008, node_to_memsize);
+         PRE_XEN_SYSCTL_READ(numainfo_00000008, node_to_memfree);
+         PRE_XEN_SYSCTL_READ(numainfo_00000008, node_to_node_distance);
+         break;
+      case 0x0000000c:
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
+      case 0x00000012:
+         PRE_XEN_SYSCTL_READ(numainfo_0000000c, num_nodes);
+         PRE_XEN_SYSCTL_READ(numainfo_0000000c, meminfo);
+         PRE_XEN_SYSCTL_READ(numainfo_0000000c, distance);
+         break;
+      }
+      break;
+
+   case VKI_XEN_SYSCTL_pcitopoinfo:
+      switch (sysctl->interface_version)
+      {
+      case 0x0000000c:
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
+      case 0x00000012:
+         PRE_XEN_SYSCTL_READ(pcitopoinfo_0000000c, num_devs);
+         PRE_XEN_SYSCTL_READ(pcitopoinfo_0000000c, devs);
+         break;
+      }
+      break;
+
+   case VKI_XEN_SYSCTL_get_cpu_featureset:
+      switch (sysctl->interface_version)
+      {
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
+      case 0x00000012:
+         PRE_XEN_SYSCTL_READ(cpu_featureset_0000000d, index);
+         PRE_XEN_SYSCTL_READ(cpu_featureset_0000000d, nr_features);
+         break;
+      }
       break;
 
    default:
@@ -716,8 +809,8 @@ PRE(domctl)
     *    vki_xen_domid_t  domain;
     */
    PRE_MEM_READ("__HYPERVISOR_domctl", ARG1,
-                sizeof(vki_uint32_t) + sizeof(vki_uint32_t)
-		+ sizeof(vki_xen_domid_t));
+               sizeof(vki_uint32_t) + sizeof(vki_uint32_t)
+               + sizeof(vki_xen_domid_t));
 
    if (!domctl)
       return;
@@ -730,16 +823,21 @@ PRE(domctl)
    case 0x0000000a:
    case 0x0000000b:
    case 0x0000000c:
-	   break;
+   case 0x0000000d:
+   case 0x0000000e:
+   case 0x0000000f:
+   case 0x00000010:
+   case 0x00000011:
+      break;
    default:
       bad_intf_version(tid, layout, arrghs, status, flags,
                        "__HYPERVISOR_domctl", domctl->interface_version);
       return;
    }
 
-#define __PRE_XEN_DOMCTL_READ(_domctl, _union, _field)			\
-      PRE_MEM_READ("XEN_DOMCTL_" #_domctl " u." #_union "." #_field,	\
-                   (Addr)&domctl->u._union._field,			\
+#define __PRE_XEN_DOMCTL_READ(_domctl, _union, _field) \
+      PRE_MEM_READ("XEN_DOMCTL_" #_domctl " u." #_union "." #_field, \
+                   (Addr)&domctl->u._union._field, \
                    sizeof(domctl->u._union._field))
 #define PRE_XEN_DOMCTL_READ(_domctl, _field) \
       __PRE_XEN_DOMCTL_READ(_domctl, _domctl, _field)
@@ -753,13 +851,67 @@ PRE(domctl)
    case VKI_XEN_DOMCTL_getdomaininfo:
    case VKI_XEN_DOMCTL_unpausedomain:
    case VKI_XEN_DOMCTL_resumedomain:
+   case VKI_XEN_DOMCTL_soft_reset:
       /* No input fields. */
       break;
 
    case VKI_XEN_DOMCTL_createdomain:
-      PRE_XEN_DOMCTL_READ(createdomain, ssidref);
-      PRE_XEN_DOMCTL_READ(createdomain, handle);
-      PRE_XEN_DOMCTL_READ(createdomain, flags);
+      switch (domctl->interface_version) {
+      case 0x00000007:
+      case 0x00000008:
+      case 0x00000009:
+      case 0x0000000a:
+         PRE_XEN_DOMCTL_READ(createdomain_00000004, ssidref);
+         PRE_XEN_DOMCTL_READ(createdomain_00000004, handle);
+         PRE_XEN_DOMCTL_READ(createdomain_00000004, flags);
+         break;
+      case 0x0000000b:
+         PRE_XEN_DOMCTL_READ(createdomain_0000000b, ssidref);
+         PRE_XEN_DOMCTL_READ(createdomain_0000000b, handle);
+         PRE_XEN_DOMCTL_READ(createdomain_0000000b, flags);
+#if defined(__i386__) || defined(__x86_64__)
+         __PRE_XEN_DOMCTL_READ(createdomain_0000000b, createdomain_0000000b, config.dummy);
+#endif
+#if defined(__arm__) || defined(__aarch64__)
+         __PRE_XEN_DOMCTL_READ(createdomain_0000000b, createdomain_0000000b, config.gic_version);
+         __PRE_XEN_DOMCTL_READ(createdomain_0000000b, createdomain_0000000b, config.nr_spis);
+         __PRE_XEN_DOMCTL_READ(createdomain_0000000b, createdomain_0000000b, config.clock_frequency);
+#endif
+         break;
+      case 0x0000000c:
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+         PRE_XEN_DOMCTL_READ(createdomain_0000000c, ssidref);
+         PRE_XEN_DOMCTL_READ(createdomain_0000000c, handle);
+         PRE_XEN_DOMCTL_READ(createdomain_0000000c, flags);
+#if defined(__i386__) || defined(__x86_64__)
+         __PRE_XEN_DOMCTL_READ(createdomain_0000000c, createdomain_0000000c, config.emulation_flags);
+#endif
+#if defined(__arm__) || defined(__aarch64__)
+         __PRE_XEN_DOMCTL_READ(createdomain_0000000c, createdomain_0000000c, config.gic_version);
+         __PRE_XEN_DOMCTL_READ(createdomain_0000000c, createdomain_0000000c, config.nr_spis);
+         __PRE_XEN_DOMCTL_READ(createdomain_0000000c, createdomain_0000000c, config.clock_frequency);
+#endif
+         break;
+      case 0x00000011:
+         PRE_XEN_DOMCTL_READ(createdomain_00000011, ssidref);
+         PRE_XEN_DOMCTL_READ(createdomain_00000011, handle);
+         PRE_XEN_DOMCTL_READ(createdomain_00000011, flags);
+         PRE_XEN_DOMCTL_READ(createdomain_00000011, max_vcpus);
+         PRE_XEN_DOMCTL_READ(createdomain_00000011, max_evtchn_port);
+         PRE_XEN_DOMCTL_READ(createdomain_00000011, max_maptrack_frames);
+#if defined(__i386__) || defined(__x86_64__)
+         __PRE_XEN_DOMCTL_READ(createdomain_00000011, createdomain_00000011, config.emulation_flags);
+#endif
+#if defined(__arm__) || defined(__aarch64__)
+         __PRE_XEN_DOMCTL_READ(createdomain_00000011, createdomain_00000011, config.gic_version);
+         __PRE_XEN_DOMCTL_READ(createdomain_00000011, createdomain_00000011, config.nr_spis);
+         __PRE_XEN_DOMCTL_READ(createdomain_00000011, createdomain_00000011, config.clock_frequency);
+#endif
+         break;
+      }
       break;
 
    case VKI_XEN_DOMCTL_gethvmcontext:
@@ -780,30 +932,69 @@ PRE(domctl)
        break;
 
    case VKI_XEN_DOMCTL_gethvmcontext_partial:
-       __PRE_XEN_DOMCTL_READ(gethvmcontext_partial, hvmcontext_partial, type);
-       __PRE_XEN_DOMCTL_READ(gethvmcontext_partial, hvmcontext_partial, instance);
-       __PRE_XEN_DOMCTL_READ(gethvmcontext_partial, hvmcontext_partial, buffer);
-
-       switch (domctl->u.hvmcontext_partial.type) {
-       case VKI_HVM_SAVE_CODE(CPU):
-           if ( domctl->u.hvmcontext_partial.buffer.p )
-                PRE_MEM_WRITE("XEN_DOMCTL_gethvmcontext_partial *buffer",
-                   (Addr)domctl->u.hvmcontext_partial.buffer.p,
-                   VKI_HVM_SAVE_LENGTH(CPU));
-           break;
-       case VKI_HVM_SAVE_CODE(MTRR):
-           if ( domctl->u.hvmcontext_partial.buffer.p )
-	        PRE_MEM_WRITE("XEN_DOMCTL_gethvmcontext_partial *buffer",
-		   (Addr)domctl->u.hvmcontext_partial.buffer.p,
-		   VKI_HVM_SAVE_LENGTH(MTRR));
-           break;
-       default:
-           bad_subop(tid, layout, arrghs, status, flags,
-                         "__HYPERVISOR_domctl_gethvmcontext_partial type",
-                         domctl->u.hvmcontext_partial.type);
-           break;
-       }
-       break;
+      switch (domctl->interface_version) {
+      case 0x00000007:
+      case 0x00000008:
+      case 0x00000009:
+      case 0x0000000a:
+      case 0x0000000b:
+      case 0x0000000c:
+      case 0x0000000d:
+         __PRE_XEN_DOMCTL_READ(gethvmcontext_partial, hvmcontext_partial_00000005, type);
+         __PRE_XEN_DOMCTL_READ(gethvmcontext_partial, hvmcontext_partial_00000005, instance);
+         __PRE_XEN_DOMCTL_READ(gethvmcontext_partial, hvmcontext_partial_00000005, buffer);
+
+         switch (domctl->u.hvmcontext_partial_00000005.type) {
+         case VKI_HVM_SAVE_CODE(CPU):
+            if ( domctl->u.hvmcontext_partial_00000005.buffer.p )
+               PRE_MEM_WRITE("XEN_DOMCTL_gethvmcontext_partial *buffer",
+                           (Addr)domctl->u.hvmcontext_partial_00000005.buffer.p,
+                           VKI_HVM_SAVE_LENGTH(CPU));
+            break;
+         case VKI_HVM_SAVE_CODE(MTRR):
+            if ( domctl->u.hvmcontext_partial_00000005.buffer.p )
+               PRE_MEM_WRITE("XEN_DOMCTL_gethvmcontext_partial *buffer",
+                           (Addr)domctl->u.hvmcontext_partial_00000005.buffer.p,
+                           VKI_HVM_SAVE_LENGTH(MTRR));
+            break;
+         default:
+            bad_subop(tid, layout, arrghs, status, flags,
+                      "__HYPERVISOR_domctl_gethvmcontext_partial type",
+                      domctl->u.hvmcontext_partial_00000005.type);
+            break;
+         }
+         break;
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
+         __PRE_XEN_DOMCTL_READ(gethvmcontext_partial, hvmcontext_partial_0000000e, type);
+         __PRE_XEN_DOMCTL_READ(gethvmcontext_partial, hvmcontext_partial_0000000e, instance);
+         __PRE_XEN_DOMCTL_READ(gethvmcontext_partial, hvmcontext_partial_0000000e, bufsz);
+         __PRE_XEN_DOMCTL_READ(gethvmcontext_partial, hvmcontext_partial_0000000e, buffer);
+
+         switch (domctl->u.hvmcontext_partial_0000000e.type) {
+         case VKI_HVM_SAVE_CODE(CPU):
+            if ( domctl->u.hvmcontext_partial_0000000e.buffer.p )
+               PRE_MEM_WRITE("XEN_DOMCTL_gethvmcontext_partial *buffer",
+                           (Addr)domctl->u.hvmcontext_partial_0000000e.buffer.p,
+                           VKI_HVM_SAVE_LENGTH(CPU));
+            break;
+         case VKI_HVM_SAVE_CODE(MTRR):
+            if ( domctl->u.hvmcontext_partial_0000000e.buffer.p )
+               PRE_MEM_WRITE("XEN_DOMCTL_gethvmcontext_partial *buffer",
+                           (Addr)domctl->u.hvmcontext_partial_0000000e.buffer.p,
+                           VKI_HVM_SAVE_LENGTH(MTRR));
+            break;
+         default:
+            bad_subop(tid, layout, arrghs, status, flags,
+                     "__HYPERVISOR_domctl_gethvmcontext_partial type",
+                     domctl->u.hvmcontext_partial_0000000e.type);
+            break;
+         }
+         break;
+      }
+      break;
 
    case VKI_XEN_DOMCTL_max_mem:
       PRE_XEN_DOMCTL_READ(max_mem, max_memkb);
@@ -815,13 +1006,15 @@ PRE(domctl)
 
    case VKI_XEN_DOMCTL_test_assign_device:
       switch (domctl->interface_version) {
-      case 0x00000007: /* pre-4.6 */
+      case 0x00000007:
       case 0x00000008:
       case 0x00000009:
       case 0x0000000a:
          __PRE_XEN_DOMCTL_READ(test_assign_device, assign_device_00000007, machine_sbdf);
          break;
       case 0x0000000b:
+      case 0x0000000c:
+      case 0x0000000d:
          __PRE_XEN_DOMCTL_READ(test_assign_device, assign_device_0000000b, dev);
          __PRE_XEN_DOMCTL_READ(test_assign_device, assign_device_0000000b, flag);
          switch (domctl->u.assign_device_0000000b.dev) {
@@ -841,17 +1034,42 @@ PRE(domctl)
             break;
          }
          break;
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
+         __PRE_XEN_DOMCTL_READ(test_assign_device, assign_device_0000000e, dev);
+         __PRE_XEN_DOMCTL_READ(test_assign_device, assign_device_0000000e, flags);
+         switch (domctl->u.assign_device_0000000e.dev) {
+         case VKI_XEN_DOMCTL_DEV_PCI:
+            __PRE_XEN_DOMCTL_READ(test_assign_device, assign_device_0000000e, u.pci);
+            break;
+         case VKI_XEN_DOMCTL_DEV_DT:
+            __PRE_XEN_DOMCTL_READ(test_assign_device, assign_device_0000000e, u.dt);
+            PRE_MEM_READ("XEN_DOMTCL_test_assign_device.dt",
+                          (Addr)domctl->u.assign_device_0000000e.u.dt.path.p,
+                          domctl->u.assign_device_0000000e.u.dt.size);
+            break;
+         default:
+            bad_subop(tid, layout, arrghs, status, flags,
+                         "__HYPERVISOR_domctl_test_assign_device dev",
+                         domctl->u.assign_device_0000000e.dev);
+            break;
+         }
+         break;
       }
       break;
    case VKI_XEN_DOMCTL_assign_device:
       switch (domctl->interface_version) {
-      case 0x00000007: /* pre-4.6 */
+      case 0x00000007:
       case 0x00000008:
       case 0x00000009:
       case 0x0000000a:
          __PRE_XEN_DOMCTL_READ(assign_device, assign_device_00000007, machine_sbdf);
          break;
       case 0x0000000b:
+      case 0x0000000c:
+      case 0x0000000d:
          __PRE_XEN_DOMCTL_READ(assign_device, assign_device_0000000b, dev);
          __PRE_XEN_DOMCTL_READ(assign_device, assign_device_0000000b, flag);
          switch (domctl->u.assign_device_0000000b.dev) {
@@ -871,17 +1089,37 @@ PRE(domctl)
             break;
          }
          break;
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
+         __PRE_XEN_DOMCTL_READ(assign_device, assign_device_0000000e, dev);
+         __PRE_XEN_DOMCTL_READ(assign_device, assign_device_0000000e, flags);
+         switch (domctl->u.assign_device_0000000e.dev) {
+         case VKI_XEN_DOMCTL_DEV_PCI:
+            __PRE_XEN_DOMCTL_READ(assign_device, assign_device_0000000e, u.pci);
+            break;
+         case VKI_XEN_DOMCTL_DEV_DT:
+            __PRE_XEN_DOMCTL_READ(assign_device, assign_device_0000000e, u.dt);
+            PRE_MEM_READ("XEN_DOMTCL_assign_device.dt",
+                        (Addr)domctl->u.assign_device_0000000e.u.dt.path.p,
+                        domctl->u.assign_device_0000000e.u.dt.size);
+            break;
+         }
+         break;
       }
       break;
    case VKI_XEN_DOMCTL_deassign_device:
       switch (domctl->interface_version) {
-      case 0x00000007: /* pre-4.6 */
+      case 0x00000007:
       case 0x00000008:
       case 0x00000009:
       case 0x0000000a:
          __PRE_XEN_DOMCTL_READ(deassign_device, assign_device_00000007, machine_sbdf);
          break;
       case 0x0000000b:
+      case 0x0000000c:
+      case 0x0000000d:
          __PRE_XEN_DOMCTL_READ(deassign_device, assign_device_0000000b, dev);
          __PRE_XEN_DOMCTL_READ(deassign_device, assign_device_0000000b, flag);
          switch (domctl->u.assign_device_0000000b.dev) {
@@ -901,12 +1139,30 @@ PRE(domctl)
             break;
          }
          break;
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
+         __PRE_XEN_DOMCTL_READ(deassign_device, assign_device_0000000e, dev);
+         __PRE_XEN_DOMCTL_READ(deassign_device, assign_device_0000000e, flags);
+         switch (domctl->u.assign_device_0000000e.dev) {
+         case VKI_XEN_DOMCTL_DEV_PCI:
+            __PRE_XEN_DOMCTL_READ(deassign_device, assign_device_0000000e, u.pci);
+            break;
+         case VKI_XEN_DOMCTL_DEV_DT:
+            __PRE_XEN_DOMCTL_READ(deassign_device, assign_device_0000000e, u.dt);
+            PRE_MEM_READ("XEN_DOMTCL_assign_device.dt",
+                        (Addr)domctl->u.assign_device_0000000e.u.dt.path.p,
+                        domctl->u.assign_device_0000000e.u.dt.size);
+            break;
+         }
+         break;
       }
       break;
 
    case VKI_XEN_DOMCTL_settscinfo:
       switch (domctl->interface_version) {
-      case 0x00000007: /* pre-4.6 */
+      case 0x00000007:
       case 0x00000008:
       case 0x00000009:
       case 0x0000000a:
@@ -916,6 +1172,12 @@ PRE(domctl)
          __PRE_XEN_DOMCTL_READ(settscinfo, tsc_info_00000007, info.elapsed_nsec);
          break;
       case 0x0000000b:
+      case 0x0000000c:
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
          __PRE_XEN_DOMCTL_READ(settscinfo, tsc_info_0000000b, tsc_mode);
          __PRE_XEN_DOMCTL_READ(settscinfo, tsc_info_0000000b, gtsc_khz);
          __PRE_XEN_DOMCTL_READ(settscinfo, tsc_info_0000000b, incarnation);
@@ -946,8 +1208,24 @@ PRE(domctl)
       break;
 
    case VKI_XEN_DOMCTL_settimeoffset:
-       PRE_XEN_DOMCTL_READ(settimeoffset, time_offset_seconds);
-       break;
+      switch (domctl->interface_version) {
+      case 0x00000007:
+      case 0x00000008:
+      case 0x00000009:
+      case 0x0000000a:
+         PRE_XEN_DOMCTL_READ(settimeoffset_00000001, time_offset_seconds);
+         break;
+      case 0x0000000b:
+      case 0x0000000c:
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
+         PRE_XEN_DOMCTL_READ(settimeoffset_0000000b, time_offset_seconds);
+         break;
+      }
+      break;
 
    case VKI_XEN_DOMCTL_getvcpuinfo:
       PRE_XEN_DOMCTL_READ(getvcpuinfo, vcpu);
@@ -991,6 +1269,13 @@ PRE(domctl)
          __PRE_XEN_DOMCTL_READ(getvcpuaffinity, vcpuaffinity_00000009, cpumap.nr_bits);
          break;
       case 0x0000000a:
+      case 0x0000000b:
+      case 0x0000000c:
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
          __PRE_XEN_DOMCTL_READ(getvcpuaffinity, vcpuaffinity_0000000a, vcpu);
          if (domctl->u.vcpuaffinity_0000000a.flags & VKI_XEN_VCPUAFFINITY_HARD)
             __PRE_XEN_DOMCTL_READ(
@@ -1014,6 +1299,13 @@ PRE(domctl)
                       domctl->u.vcpuaffinity_00000009.cpumap.nr_bits / 8);
          break;
       case 0x0000000a:
+      case 0x0000000b:
+      case 0x0000000c:
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
          __PRE_XEN_DOMCTL_READ(setvcpuaffinity, vcpuaffinity_0000000a, vcpu);
          __PRE_XEN_DOMCTL_READ(setvcpuaffinity, vcpuaffinity_0000000a, flags);
          if (domctl->u.vcpuaffinity_0000000a.flags & VKI_XEN_VCPUAFFINITY_HARD) {
@@ -1070,6 +1362,14 @@ PRE(domctl)
          break;
 
       case 0x00000009:
+      case 0x0000000a:
+      case 0x0000000b:
+      case 0x0000000c:
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
          __PRE_XEN_DOMCTL_READ(get_ext_vcpucontext, ext_vcpucontext_00000009, vcpu);
          break;
 
@@ -1110,6 +1410,14 @@ PRE(domctl)
            break;
 
        case 0x00000009:
+       case 0x0000000a:
+      case 0x0000000b:
+      case 0x0000000c:
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
            __PRE_XEN_DOMCTL_READ(set_ext_vcpucontext, ext_vcpucontext_00000009, vcpu);
            __PRE_XEN_DOMCTL_READ(set_ext_vcpucontext, ext_vcpucontext_00000009, size);
 #if defined(__i386__) || defined(__x86_64__)
@@ -1137,7 +1445,7 @@ PRE(domctl)
                                      mci_ctl2_bank1);
            }
 #endif
-	   break;
+         break;
 
        default:
            VG_(dmsg)("WARNING: VKI_XEN_DOMCTL_set_ext_vcpucontext  domctl version %#"
@@ -1237,10 +1545,9 @@ PRE(domctl)
       PRE_XEN_DOMCTL_READ(access_required, access_required);
       break;
 
-   case VKI_XEN_DOMCTL_mem_event_op:
-   //case VKI_XEN_DOMCTL_vm_event_op: /* name change in 4.6 */
+   case VKI_XEN_DOMCTL_mem_event_op | VKI_XEN_DOMCTL_vm_event_op:
       switch (domctl->interface_version) {
-      case 0x00000007: /* pre-4.6 */
+      case 0x00000007:
       case 0x00000008:
       case 0x00000009:
       case 0x0000000a:
@@ -1248,6 +1555,12 @@ PRE(domctl)
          __PRE_XEN_DOMCTL_READ(mem_event_op, mem_event_op_00000007, mode);
          break;
       case 0x0000000b:
+      case 0x0000000c:
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
          __PRE_XEN_DOMCTL_READ(vm_event_op, vm_event_op_0000000b, op);
          __PRE_XEN_DOMCTL_READ(vm_event_op, vm_event_op_0000000b, mode);
          break;
@@ -1277,7 +1590,7 @@ PRE(domctl)
 
    case VKI_XEN_DOMCTL_monitor_op:
       switch (domctl->interface_version) {
-      case 0x000000b:
+      case 0x0000000b:
           if (domctl->u.monitor_op_0000000b.op == VKI_XEN_DOMCTL_MONITOR_OP_ENABLE ||
               domctl->u.monitor_op_0000000b.op == VKI_XEN_DOMCTL_MONITOR_OP_DISABLE) {
              switch (domctl->u.monitor_op_0000000b.event) {
@@ -1290,7 +1603,67 @@ PRE(domctl)
              case VKI_XEN_DOMCTL_MONITOR_EVENT_GUEST_REQUEST:
                 __PRE_XEN_DOMCTL_READ(monitor_op, monitor_op_0000000b, u.guest_request);
                 break;
-             case VKI_XEN_DOMCTL_MONITOR_OP_GET_CAPABILITIES:
+             }
+          }
+
+         break;
+      case 0x0000000c:
+      case 0x0000000d:
+         if (domctl->u.monitor_op_0000000c.op == VKI_XEN_DOMCTL_MONITOR_OP_ENABLE ||
+            domctl->u.monitor_op_0000000c.op == VKI_XEN_DOMCTL_MONITOR_OP_DISABLE) {
+            switch (domctl->u.monitor_op_0000000c.event) {
+            case VKI_XEN_DOMCTL_MONITOR_EVENT_WRITE_CTRLREG:
+               __PRE_XEN_DOMCTL_READ(monitor_op, monitor_op_0000000c, u.mov_to_cr);
+               break;
+            case VKI_XEN_DOMCTL_MONITOR_EVENT_MOV_TO_MSR:
+               __PRE_XEN_DOMCTL_READ(monitor_op, monitor_op_0000000c, u.mov_to_msr);
+               break;
+            case VKI_XEN_DOMCTL_MONITOR_EVENT_GUEST_REQUEST:
+               __PRE_XEN_DOMCTL_READ(monitor_op, monitor_op_0000000c, u.guest_request);
+               break;
+            case VKI_XEN_DOMCTL_MONITOR_EVENT_DEBUG_EXCEPTION:
+               __PRE_XEN_DOMCTL_READ(monitor_op, monitor_op_0000000c, u.debug_exception);
+               break;
+            }
+         }
+         break;
+      case 0x0000000e:
+      case 0x0000000f:
+          if (domctl->u.monitor_op_0000000e.op == VKI_XEN_DOMCTL_MONITOR_OP_ENABLE ||
+              domctl->u.monitor_op_0000000e.op == VKI_XEN_DOMCTL_MONITOR_OP_DISABLE) {
+             switch (domctl->u.monitor_op_0000000e.event) {
+             case VKI_XEN_DOMCTL_MONITOR_EVENT_WRITE_CTRLREG:
+                __PRE_XEN_DOMCTL_READ(monitor_op, monitor_op_0000000e, u.mov_to_cr);
+                break;
+             case VKI_XEN_DOMCTL_MONITOR_EVENT_MOV_TO_MSR:
+                __PRE_XEN_DOMCTL_READ(monitor_op, monitor_op_0000000e, u.mov_to_msr);
+                break;
+             case VKI_XEN_DOMCTL_MONITOR_EVENT_GUEST_REQUEST:
+                __PRE_XEN_DOMCTL_READ(monitor_op, monitor_op_0000000e, u.guest_request);
+                break;
+             case VKI_XEN_DOMCTL_MONITOR_EVENT_DEBUG_EXCEPTION:
+                __PRE_XEN_DOMCTL_READ(monitor_op, monitor_op_0000000e, u.debug_exception);
+                break;
+             }
+          }
+
+         break;
+      case 0x00000010:
+      case 0x00000011:
+          if (domctl->u.monitor_op_00000010.op == VKI_XEN_DOMCTL_MONITOR_OP_ENABLE ||
+              domctl->u.monitor_op_00000010.op == VKI_XEN_DOMCTL_MONITOR_OP_DISABLE) {
+             switch (domctl->u.monitor_op_00000010.event) {
+             case VKI_XEN_DOMCTL_MONITOR_EVENT_WRITE_CTRLREG:
+                __PRE_XEN_DOMCTL_READ(monitor_op, monitor_op_00000010, u.mov_to_cr);
+                break;
+             case VKI_XEN_DOMCTL_MONITOR_EVENT_MOV_TO_MSR:
+                __PRE_XEN_DOMCTL_READ(monitor_op, monitor_op_00000010, u.mov_to_msr);
+                break;
+             case VKI_XEN_DOMCTL_MONITOR_EVENT_GUEST_REQUEST:
+                __PRE_XEN_DOMCTL_READ(monitor_op, monitor_op_00000010, u.guest_request);
+                break;
+             case VKI_XEN_DOMCTL_MONITOR_EVENT_DEBUG_EXCEPTION:
+                __PRE_XEN_DOMCTL_READ(monitor_op, monitor_op_00000010, u.debug_exception);
                 break;
              }
           }
@@ -1299,6 +1672,11 @@ PRE(domctl)
       }
       break;
 
+   case VKI_XEN_DOMCTL_set_gnttab_limits:
+      PRE_XEN_DOMCTL_READ(set_gnttab_limits_0000000e, grant_frames);
+      PRE_XEN_DOMCTL_READ(set_gnttab_limits_0000000e, maptrack_frames);
+      break;
+
    default:
       bad_subop(tid, layout, arrghs, status, flags,
                 "__HYPERVISOR_domctl", domctl->cmd);
@@ -1465,6 +1843,16 @@ PRE(tmem_op)
 #undef __PRE_XEN_TMEMOP_READ
 }
 
+PRE(dm_op)
+{
+   unsigned int domid = ARG1, num = ARG2;
+   struct vki_xen_privcmd_dm_op_buf *args = (void *)(ARG3);
+
+   PRINT("__HYPERVISOR_dm_op ( %u, %u, %p )", domid, num, args);
+
+   PRE_MEM_READ("__HYPERVISOR_dm_op ubuf", (Addr)args, sizeof(*args) * num);
+}
+
 POST(memory_op)
 {
    switch (ARG1) {
@@ -1474,6 +1862,7 @@ POST(memory_op)
    case VKI_XENMEM_claim_pages:
    case VKI_XENMEM_maximum_gpfn:
    case VKI_XENMEM_remove_from_physmap:
+   case VKI_XENMEM_set_pod_target:
    case VKI_XENMEM_access_op:
       /* No outputs */
       break;
@@ -1518,6 +1907,15 @@ POST(memory_op)
    case VKI_XENMEM_get_sharing_shared_pages:
        /* No outputs */
        break;
+   case VKI_XENMEM_get_pod_target: {
+      struct vki_xen_pod_target *arg =
+         (struct vki_xen_pod_target *)ARG2;
+      POST_MEM_WRITE((Addr)&arg->tot_pages, sizeof(arg->tot_pages));
+      POST_MEM_WRITE((Addr)&arg->pod_cache_pages, sizeof(arg->pod_cache_pages));
+      POST_MEM_WRITE((Addr)&arg->pod_entries, sizeof(arg->pod_entries));
+      }
+      break;
+
    }
 }
 
@@ -1643,6 +2041,9 @@ POST(xen_version)
    case VKI_XENVER_commandline:
       POST_MEM_WRITE((Addr)ARG2, sizeof(vki_xen_commandline_t));
       break;
+   case VKI_XENVER_build_id:
+      POST_MEM_WRITE((Addr)ARG2, sizeof(struct vki_xen_build_id));
+      break;
    }
 }
 
@@ -1651,7 +2052,7 @@ POST(grant_table_op)
    switch (ARG1) {
    case VKI_XEN_GNTTABOP_setup_table: {
       struct vki_xen_gnttab_setup_table *gst =
-	      (struct vki_xen_gnttab_setup_table*)ARG2;
+         (struct vki_xen_gnttab_setup_table*)ARG2;
       PRE_MEM_WRITE("VKI_XEN_GNTTABOP_setup_table",
                     (Addr)&gst->status, sizeof(gst->status));
       PRE_MEM_WRITE("VKI_XEN_GNTTABOP_setup_table",
@@ -1672,7 +2073,14 @@ POST(sysctl)
    case 0x00000009:
    case 0x0000000a:
    case 0x0000000b:
-	   break;
+   case 0x0000000c:
+   case 0x0000000d:
+   case 0x0000000e:
+   case 0x0000000f:
+   case 0x00000010:
+   case 0x00000011:
+   case 0x00000012:
+      break;
    default:
       return;
    }
@@ -1693,24 +2101,31 @@ POST(sysctl)
       switch (sysctl->interface_version)
       {
       case 0x00000008:
-	 POST_XEN_SYSCTL_WRITE(getdomaininfolist_00000008, num_domains);
-	 POST_MEM_WRITE((Addr)sysctl->u.getdomaininfolist_00000008.buffer.p,
-			sizeof(*sysctl->u.getdomaininfolist_00000008.buffer.p)
-			* sysctl->u.getdomaininfolist_00000008.num_domains);
-	 break;
+         POST_XEN_SYSCTL_WRITE(getdomaininfolist_00000008, num_domains);
+         POST_MEM_WRITE((Addr)sysctl->u.getdomaininfolist_00000008.buffer.p,
+                        sizeof(*sysctl->u.getdomaininfolist_00000008.buffer.p)
+                        * sysctl->u.getdomaininfolist_00000008.num_domains);
+         break;
       case 0x00000009:
-	 POST_XEN_SYSCTL_WRITE(getdomaininfolist_00000009, num_domains);
-	 POST_MEM_WRITE((Addr)sysctl->u.getdomaininfolist_00000009.buffer.p,
-			sizeof(*sysctl->u.getdomaininfolist_00000009.buffer.p)
-			* sysctl->u.getdomaininfolist_00000009.num_domains);
-	 break;
+         POST_XEN_SYSCTL_WRITE(getdomaininfolist_00000009, num_domains);
+         POST_MEM_WRITE((Addr)sysctl->u.getdomaininfolist_00000009.buffer.p,
+                        sizeof(*sysctl->u.getdomaininfolist_00000009.buffer.p)
+                        * sysctl->u.getdomaininfolist_00000009.num_domains);
+         break;
       case 0x0000000a:
       case 0x0000000b:
-	 POST_XEN_SYSCTL_WRITE(getdomaininfolist_0000000a, num_domains);
-	 POST_MEM_WRITE((Addr)sysctl->u.getdomaininfolist_0000000a.buffer.p,
-			sizeof(*sysctl->u.getdomaininfolist_0000000a.buffer.p)
-			* sysctl->u.getdomaininfolist_0000000a.num_domains);
-	 break;
+      case 0x0000000c:
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
+      case 0x00000012:
+         POST_XEN_SYSCTL_WRITE(getdomaininfolist_0000000a, num_domains);
+         POST_MEM_WRITE((Addr)sysctl->u.getdomaininfolist_0000000a.buffer.p,
+                        sizeof(*sysctl->u.getdomaininfolist_0000000a.buffer.p)
+                        * sysctl->u.getdomaininfolist_0000000a.num_domains);
+         break;
       }
       break;
 
@@ -1751,6 +2166,10 @@ POST(sysctl)
          break;
       case 0x0000000a:
       case 0x0000000b:
+      case 0x0000000c:
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
          POST_XEN_SYSCTL_WRITE(physinfo_0000000a, threads_per_core);
          POST_XEN_SYSCTL_WRITE(physinfo_0000000a, cores_per_socket);
          POST_XEN_SYSCTL_WRITE(physinfo_0000000a, nr_cpus);
@@ -1765,30 +2184,125 @@ POST(sysctl)
          POST_XEN_SYSCTL_WRITE(physinfo_0000000a, hw_cap[8]);
          POST_XEN_SYSCTL_WRITE(physinfo_0000000a, capabilities);
          break;
+      case 0x00000010:
+      case 0x00000011:
+      case 0x00000012:
+         POST_XEN_SYSCTL_WRITE(physinfo_00000010, threads_per_core);
+         POST_XEN_SYSCTL_WRITE(physinfo_00000010, cores_per_socket);
+         POST_XEN_SYSCTL_WRITE(physinfo_00000010, nr_cpus);
+         POST_XEN_SYSCTL_WRITE(physinfo_00000010, max_cpu_id);
+         POST_XEN_SYSCTL_WRITE(physinfo_00000010, nr_nodes);
+         POST_XEN_SYSCTL_WRITE(physinfo_00000010, max_node_id);
+         POST_XEN_SYSCTL_WRITE(physinfo_00000010, cpu_khz);
+         POST_XEN_SYSCTL_WRITE(physinfo_00000010, capabilities);
+         POST_XEN_SYSCTL_WRITE(physinfo_00000010, total_pages);
+         POST_XEN_SYSCTL_WRITE(physinfo_00000010, free_pages);
+         POST_XEN_SYSCTL_WRITE(physinfo_00000010, scrub_pages);
+         POST_XEN_SYSCTL_WRITE(physinfo_00000010, outstanding_pages);
+         POST_XEN_SYSCTL_WRITE(physinfo_00000010, max_mfn);
+         POST_XEN_SYSCTL_WRITE(physinfo_00000010, hw_cap[8]);
+         break;
       }
       break;
 
-   case VKI_XEN_SYSCTL_topologyinfo:
-      POST_XEN_SYSCTL_WRITE(topologyinfo, max_cpu_index);
-      if (sysctl->u.topologyinfo.cpu_to_core.p)
-         POST_MEM_WRITE((Addr)sysctl->u.topologyinfo.cpu_to_core.p,
-                     sizeof(uint32_t) * sysctl->u.topologyinfo.max_cpu_index);
-      if (sysctl->u.topologyinfo.cpu_to_socket.p)
-         POST_MEM_WRITE((Addr)sysctl->u.topologyinfo.cpu_to_socket.p,
-                     sizeof(uint32_t) * sysctl->u.topologyinfo.max_cpu_index);
-      if (sysctl->u.topologyinfo.cpu_to_node.p)
-         POST_MEM_WRITE((Addr)sysctl->u.topologyinfo.cpu_to_node.p,
-                     sizeof(uint32_t) * sysctl->u.topologyinfo.max_cpu_index);
+   case VKI_XEN_SYSCTL_topologyinfo | VKI_XEN_SYSCTL_cputopoinfo:
+      switch (sysctl->interface_version)
+      {
+      case 0x00000007:
+      case 0x00000008:
+      case 0x00000009:
+      case 0x0000000a:
+      case 0x0000000b:
+         POST_XEN_SYSCTL_WRITE(topologyinfo, max_cpu_index);
+         if (sysctl->u.topologyinfo.cpu_to_core.p)
+            POST_MEM_WRITE((Addr)sysctl->u.topologyinfo.cpu_to_core.p,
+                           sizeof(uint32_t) * sysctl->u.topologyinfo.max_cpu_index);
+         if (sysctl->u.topologyinfo.cpu_to_socket.p)
+            POST_MEM_WRITE((Addr)sysctl->u.topologyinfo.cpu_to_socket.p,
+                           sizeof(uint32_t) * sysctl->u.topologyinfo.max_cpu_index);
+         if (sysctl->u.topologyinfo.cpu_to_node.p)
+            POST_MEM_WRITE((Addr)sysctl->u.topologyinfo.cpu_to_node.p,
+                           sizeof(uint32_t) * sysctl->u.topologyinfo.max_cpu_index);
+         break;
+      case 0x0000000c:
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
+      case 0x00000012:
+         POST_XEN_SYSCTL_WRITE(cputopoinfo_0000000c, num_cpus);
+         if (sysctl->u.cputopoinfo_0000000c.cputopo.p)
+            POST_MEM_WRITE((Addr)sysctl->u.cputopoinfo_0000000c.cputopo.p,
+                           sizeof(vki_xen_sysctl_cputopo_0000000c_t) * sysctl->u.cputopoinfo_0000000c.num_cpus);
+         break;
+      }
       break;
 
    case VKI_XEN_SYSCTL_numainfo:
-      POST_XEN_SYSCTL_WRITE(numainfo, max_node_index);
-      POST_MEM_WRITE((Addr)sysctl->u.numainfo.node_to_memsize.p,
-                     sizeof(uint64_t) * sysctl->u.numainfo.max_node_index);
-      POST_MEM_WRITE((Addr)sysctl->u.numainfo.node_to_memfree.p,
-                     sizeof(uint64_t) * sysctl->u.numainfo.max_node_index);
-      POST_MEM_WRITE((Addr)sysctl->u.numainfo.node_to_node_distance.p,
-                     sizeof(uint32_t) * sysctl->u.numainfo.max_node_index);
+      switch (sysctl->interface_version)
+      {
+      case 0x00000008:
+      case 0x00000009:
+      case 0x0000000a:
+      case 0x0000000b:
+         POST_XEN_SYSCTL_WRITE(numainfo_00000008, max_node_index);
+         POST_MEM_WRITE((Addr)sysctl->u.numainfo_00000008.node_to_memsize.p,
+                        sizeof(uint64_t) * sysctl->u.numainfo_00000008.max_node_index);
+         POST_MEM_WRITE((Addr)sysctl->u.numainfo_00000008.node_to_memfree.p,
+                        sizeof(uint64_t) * sysctl->u.numainfo_00000008.max_node_index);
+         POST_MEM_WRITE((Addr)sysctl->u.numainfo_00000008.node_to_node_distance.p,
+                        sizeof(uint32_t) *
+                        (sysctl->u.numainfo_00000008.max_node_index * sysctl->u.numainfo_00000008.max_node_index));
+         break;
+      case 0x0000000c:
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
+      case 0x00000012:
+         POST_XEN_SYSCTL_WRITE(numainfo_0000000c, num_nodes);
+         POST_MEM_WRITE((Addr)sysctl->u.numainfo_0000000c.meminfo.p,
+                        sizeof(uint64_t) * sysctl->u.numainfo_0000000c.num_nodes);
+         POST_MEM_WRITE((Addr)sysctl->u.numainfo_0000000c.distance.p,
+                        sizeof(uint32_t) *
+                        (sysctl->u.numainfo_0000000c.num_nodes * sysctl->u.numainfo_0000000c.num_nodes));
+         break;
+      }
+      break;
+
+   case VKI_XEN_SYSCTL_pcitopoinfo:
+      switch (sysctl->interface_version)
+      {
+      case 0x0000000c:
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
+      case 0x00000012:
+         POST_XEN_SYSCTL_WRITE(pcitopoinfo_0000000c, num_devs);
+         POST_MEM_WRITE((Addr)sysctl->u.pcitopoinfo_0000000c.nodes.p,
+                        sizeof(uint32_t) *  sysctl->u.pcitopoinfo_0000000c.num_devs);
+         break;
+      }
+      break;
+
+   case VKI_XEN_SYSCTL_get_cpu_featureset:
+      switch (sysctl->interface_version)
+      {
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
+      case 0x00000012:
+         POST_XEN_SYSCTL_WRITE(cpu_featureset_0000000d, nr_features);
+         POST_MEM_WRITE((Addr)sysctl->u.cpu_featureset_0000000d.features.p,
+                        sizeof(uint32_t) *  sysctl->u.cpu_featureset_0000000d.nr_features);
+         break;
+      }
       break;
 
    /* No outputs */
@@ -1808,9 +2322,15 @@ POST(domctl){
    case 0x00000009:
    case 0x0000000a:
    case 0x0000000b:
-	   break;
+   case 0x0000000c:
+   case 0x0000000d:
+   case 0x0000000e:
+   case 0x0000000f:
+   case 0x00000010:
+   case 0x00000011:
+      break;
    default:
-	   return;
+      return;
    }
 
 #define __POST_XEN_DOMCTL_WRITE(_domctl, _union, _field)        \
@@ -1847,6 +2367,7 @@ POST(domctl){
    case VKI_XEN_DOMCTL_resumedomain:
    case VKI_XEN_DOMCTL_set_vcpu_msrs:
    case VKI_XEN_DOMCTL_set_access_required:
+   case VKI_XEN_DOMCTL_soft_reset:
       /* No output fields */
       break;
 
@@ -1860,7 +2381,7 @@ POST(domctl){
 
    case VKI_XEN_DOMCTL_gettscinfo:
       switch (domctl->interface_version) {
-      case 0x00000007: /* pre-4.6 */
+      case 0x00000007:
       case 0x00000008:
       case 0x00000009:
       case 0x0000000a:
@@ -1869,6 +2390,11 @@ POST(domctl){
                         sizeof(vki_xen_guest_tsc_info_t));
          break;
       case 0x0000000b:
+      case 0x0000000c:
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000011:
          __POST_XEN_DOMCTL_WRITE(gettscinfo, tsc_info_0000000b, tsc_mode);
          __POST_XEN_DOMCTL_WRITE(gettscinfo, tsc_info_0000000b, gtsc_khz);
          __POST_XEN_DOMCTL_WRITE(gettscinfo, tsc_info_0000000b, incarnation);
@@ -1897,14 +2423,34 @@ POST(domctl){
        break;
 
    case VKI_XEN_DOMCTL_gethvmcontext_partial:
-       switch (domctl->u.hvmcontext_partial.type) {
-       case VKI_HVM_SAVE_CODE(CPU):
-           if ( domctl->u.hvmcontext_partial.buffer.p )
-                POST_MEM_WRITE((Addr)domctl->u.hvmcontext_partial.buffer.p,
-                   VKI_HVM_SAVE_LENGTH(CPU));
-           break;
-       }
-       break;
+      switch (domctl->interface_version) {
+      case 0x00000007:
+      case 0x00000008:
+      case 0x00000009:
+      case 0x0000000a:
+      case 0x0000000b:
+      case 0x0000000c:
+      case 0x0000000d:
+         switch (domctl->u.hvmcontext_partial_00000005.type) {
+         case VKI_HVM_SAVE_CODE(CPU):
+            if ( domctl->u.hvmcontext_partial_00000005.buffer.p )
+               POST_MEM_WRITE((Addr)domctl->u.hvmcontext_partial_00000005.buffer.p,
+                              VKI_HVM_SAVE_LENGTH(CPU));
+            break;
+         }
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000011:
+         switch (domctl->u.hvmcontext_partial_0000000e.type) {
+         case VKI_HVM_SAVE_CODE(CPU):
+            if ( domctl->u.hvmcontext_partial_0000000e.buffer.p )
+               POST_MEM_WRITE((Addr)domctl->u.hvmcontext_partial_0000000e.buffer.p,
+                              VKI_HVM_SAVE_LENGTH(CPU));
+            break;
+         }
+         break;
+      }
+      break;
 
    case VKI_XEN_DOMCTL_scheduler_op:
       if ( domctl->u.scheduler_op.cmd == VKI_XEN_DOMCTL_SCHEDOP_getinfo ) {
@@ -1943,6 +2489,12 @@ POST(domctl){
                         domctl->u.vcpuaffinity_00000009.cpumap.nr_bits / 8);
          break;
       case 0x0000000a:
+      case 0x0000000b:
+      case 0x0000000c:
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000011:
          if (domctl->u.vcpuaffinity_0000000a.flags & VKI_XEN_VCPUAFFINITY_HARD)
             POST_MEM_WRITE(
                (Addr)domctl->u.vcpuaffinity_0000000a.cpumap_hard.bitmap.p,
@@ -1962,51 +2514,80 @@ POST(domctl){
    case VKI_XEN_DOMCTL_getdomaininfo:
       switch (domctl->interface_version) {
       case 0x00000007:
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000007, domain);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000007, flags);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000007, tot_pages);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000007, max_pages);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000007, shr_pages);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000007, shared_info_frame);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000007, cpu_time);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000007, nr_online_vcpus);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000007, max_vcpu_id);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000007, ssidref);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000007, handle);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000007, cpupool);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000007, domain);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000007, flags);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000007, tot_pages);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000007, max_pages);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000007, shr_pages);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000007, shared_info_frame);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000007, cpu_time);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000007, nr_online_vcpus);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000007, max_vcpu_id);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000007, ssidref);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000007, handle);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000007, cpupool);
       break;
       case 0x00000008:
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000008, domain);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000008, flags);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000008, tot_pages);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000008, max_pages);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000008, shr_pages);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000008, paged_pages);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000008, shared_info_frame);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000008, cpu_time);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000008, nr_online_vcpus);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000008, max_vcpu_id);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000008, ssidref);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000008, handle);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000008, cpupool);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000008, domain);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000008, flags);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000008, tot_pages);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000008, max_pages);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000008, shr_pages);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000008, paged_pages);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000008, shared_info_frame);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000008, cpu_time);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000008, nr_online_vcpus);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000008, max_vcpu_id);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000008, ssidref);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000008, handle);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000008, cpupool);
       break;
       case 0x00000009:
       case 0x0000000a:
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, domain);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, flags);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, tot_pages);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, max_pages);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, outstanding_pages);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, shr_pages);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, paged_pages);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, shared_info_frame);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, cpu_time);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, nr_online_vcpus);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, max_vcpu_id);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, ssidref);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, handle);
-	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, cpupool);
-      break;
+      case 0x0000000b:
+      case 0x0000000c:
+      case 0x0000000d:
+      case 0x0000000e:
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, domain);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, flags);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, tot_pages);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, max_pages);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, outstanding_pages);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, shr_pages);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, paged_pages);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, shared_info_frame);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, cpu_time);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, nr_online_vcpus);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, max_vcpu_id);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, ssidref);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, handle);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, cpupool);
+      case 0x0000000f:
+      case 0x00000011:
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, domain);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, flags);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, tot_pages);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, max_pages);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, outstanding_pages);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, shr_pages);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, paged_pages);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, shared_info_frame);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, cpu_time);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, nr_online_vcpus);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, max_vcpu_id);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, ssidref);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, handle);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, cpupool);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, arch_config);
+#if defined(__i386__) || defined(__x86_64__)
+         __POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, getdomaininfo_0000000f, arch_config.emulation_flags);
+#endif
+#if defined(__arm__) || defined(__aarch64__)
+         __POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, getdomaininfo_0000000f, arch_config.gic_version);
+         __POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, getdomaininfo_0000000f, arch_config.nr_spis);
+         __POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, getdomaininfo_0000000f, arch_config.clock_frequency);
+#endif
+         break;
       }
       break;
    case VKI_XEN_DOMCTL_getvcpucontext:
@@ -2043,7 +2624,14 @@ POST(domctl){
 #endif
            break;
 
-       case 0x00000009:
+      case 0x00000009:
+      case 0x0000000a:
+      case 0x0000000b:
+      case 0x0000000c:
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000011:
            __POST_XEN_DOMCTL_WRITE(get_ext_vcpucontext, ext_vcpucontext_00000009, size);
 #if defined(__i386__) || defined(__x86_64__)
            __POST_XEN_DOMCTL_WRITE(get_ext_vcpucontext, ext_vcpucontext_00000009,
@@ -2066,7 +2654,7 @@ POST(domctl){
            __POST_XEN_DOMCTL_WRITE(get_ext_vcpucontext, ext_vcpucontext_00000009,
                                    mci_ctl2_bank1);
 #endif
-	   break;
+         break;
        }
        break;
 
@@ -2110,16 +2698,20 @@ POST(domctl){
                         domctl->u.vcpu_msrs.msr_count);
       break;
 
-   case VKI_XEN_DOMCTL_mem_event_op:
-   //case VKI_XEN_DOMCTL_vm_event_op: /* name change in 4.6 */
+   case VKI_XEN_DOMCTL_mem_event_op | VKI_XEN_DOMCTL_vm_event_op:
       switch (domctl->interface_version) {
-      case 0x00000007: /* pre-4.6 */
+      case 0x00000007:
       case 0x00000008:
       case 0x00000009:
       case 0x0000000a:
          __POST_XEN_DOMCTL_WRITE(mem_event_op, mem_event_op_00000007, port);
          break;
       case 0x0000000b:
+      case 0x0000000c:
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000011:
          __POST_XEN_DOMCTL_WRITE(vm_event_op, vm_event_op_0000000b, port);
          break;
       }
@@ -2127,7 +2719,7 @@ POST(domctl){
 
    case VKI_XEN_DOMCTL_monitor_op:
       switch (domctl->interface_version) {
-      case 0x000000b:
+      case 0x0000000b:
           if (domctl->u.monitor_op_0000000b.op == VKI_XEN_DOMCTL_MONITOR_OP_GET_CAPABILITIES) {
              switch(domctl->u.monitor_op_0000000b.event) {
              case VKI_XEN_DOMCTL_MONITOR_EVENT_WRITE_CTRLREG:
@@ -2142,6 +2734,66 @@ POST(domctl){
              }
           }
 
+         break;
+      case 0x0000000c:
+      case 0x0000000d:
+         if (domctl->u.monitor_op_0000000c.op == VKI_XEN_DOMCTL_MONITOR_OP_GET_CAPABILITIES) {
+            switch(domctl->u.monitor_op_0000000c.event) {
+            case VKI_XEN_DOMCTL_MONITOR_EVENT_WRITE_CTRLREG:
+               __POST_XEN_DOMCTL_WRITE(monitor_op, monitor_op_0000000c, u.mov_to_cr);
+               break;
+            case VKI_XEN_DOMCTL_MONITOR_EVENT_MOV_TO_MSR:
+               __POST_XEN_DOMCTL_WRITE(monitor_op, monitor_op_0000000c, u.mov_to_msr);
+               break;
+            case VKI_XEN_DOMCTL_MONITOR_EVENT_GUEST_REQUEST:
+               __POST_XEN_DOMCTL_WRITE(monitor_op, monitor_op_0000000c, u.guest_request);
+               break;
+            case VKI_XEN_DOMCTL_MONITOR_EVENT_DEBUG_EXCEPTION:
+               __POST_XEN_DOMCTL_WRITE(monitor_op, monitor_op_0000000c, u.debug_exception);
+               break;
+            }
+         }
+
+         break;
+      case 0x0000000e:
+      case 0x0000000f:
+          if (domctl->u.monitor_op_0000000e.op == VKI_XEN_DOMCTL_MONITOR_OP_GET_CAPABILITIES) {
+             switch(domctl->u.monitor_op_0000000e.event) {
+             case VKI_XEN_DOMCTL_MONITOR_EVENT_WRITE_CTRLREG:
+                __POST_XEN_DOMCTL_WRITE(monitor_op, monitor_op_0000000e, u.mov_to_cr);
+                break;
+             case VKI_XEN_DOMCTL_MONITOR_EVENT_MOV_TO_MSR:
+                __POST_XEN_DOMCTL_WRITE(monitor_op, monitor_op_0000000e, u.mov_to_msr);
+                break;
+             case VKI_XEN_DOMCTL_MONITOR_EVENT_GUEST_REQUEST:
+                __POST_XEN_DOMCTL_WRITE(monitor_op, monitor_op_0000000e, u.guest_request);
+                break;
+             case VKI_XEN_DOMCTL_MONITOR_EVENT_DEBUG_EXCEPTION:
+                __POST_XEN_DOMCTL_WRITE(monitor_op, monitor_op_0000000e, u.debug_exception);
+                break;
+             }
+          }
+
+         break;
+      case 0x00000010:
+      case 0x00000011:
+         if (domctl->u.monitor_op_00000010.op == VKI_XEN_DOMCTL_MONITOR_OP_GET_CAPABILITIES) {
+            switch(domctl->u.monitor_op_00000010.event) {
+            case VKI_XEN_DOMCTL_MONITOR_EVENT_WRITE_CTRLREG:
+               __POST_XEN_DOMCTL_WRITE(monitor_op, monitor_op_00000010, u.mov_to_cr);
+               break;
+            case VKI_XEN_DOMCTL_MONITOR_EVENT_MOV_TO_MSR:
+               __POST_XEN_DOMCTL_WRITE(monitor_op, monitor_op_00000010, u.mov_to_msr);
+               break;
+            case VKI_XEN_DOMCTL_MONITOR_EVENT_GUEST_REQUEST:
+               __POST_XEN_DOMCTL_WRITE(monitor_op, monitor_op_00000010, u.guest_request);
+               break;
+            case VKI_XEN_DOMCTL_MONITOR_EVENT_DEBUG_EXCEPTION:
+               __POST_XEN_DOMCTL_WRITE(monitor_op, monitor_op_00000010, u.debug_exception);
+               break;
+            }
+         }
+
          break;
       }
       break;
@@ -2203,6 +2855,14 @@ POST(tmem_op)
     }
 }
 
+POST(dm_op)
+{
+   unsigned int num = ARG2;
+   struct vki_xen_privcmd_dm_op_buf *args = (void *)(ARG3);
+
+   POST_MEM_WRITE((Addr) args, sizeof(*args) * num);
+}
+
 typedef
    struct {
       SyscallTableEntry entry;
@@ -2264,6 +2924,8 @@ static XenHypercallTableEntry hypercall_table[] = {
    HYPXY(__VKI_XEN_domctl,                  domctl,            1), // 36
    //    __VKI_XEN_kexec_op                                        // 37
    HYPXY(__VKI_XEN_tmem_op,                 tmem_op,           1), // 38
+   //    __VKI_XEN_xenpmu_op                                       // 40
+   HYPXY(__VKI_XEN_dm_op,                   dm_op,             3), // 41
 };
 
 static void bad_before ( ThreadId              tid,
diff --git a/include/vki/vki-linux.h b/include/vki/vki-linux.h
index b4c60854a..c99503c62 100644
--- a/include/vki/vki-linux.h
+++ b/include/vki/vki-linux.h
@@ -3384,12 +3384,37 @@ struct vki_xen_privcmd_mmapbatch_v2 {
         int __user *err;  /* array of error codes */
 };
 
+struct vki_xen_privcmd_dm_op_buf {
+        void __user *uptr;
+        __vki_kernel_size_t size;
+};
+
+struct vki_xen_privcmd_dm_op {
+        __vki_u16 dom;
+        __vki_u16 num;
+        const struct vki_xen_privcmd_dm_op_buf __user *ubufs;
+};
+
+struct vki_xen_privcmd_mmap_resource {
+        __vki_u16 dom;
+        __vki_u32 type;
+        __vki_u32 id;
+        __vki_u32 idx;
+        __vki_u64 num;
+        __vki_u64 addr;
+};
+
 #define VKI_XEN_IOCTL_PRIVCMD_HYPERCALL    _VKI_IOC(_VKI_IOC_NONE, 'P', 0, sizeof(struct vki_xen_privcmd_hypercall))
 #define VKI_XEN_IOCTL_PRIVCMD_MMAP         _VKI_IOC(_VKI_IOC_NONE, 'P', 2, sizeof(struct vki_xen_privcmd_mmap))
 
 #define VKI_XEN_IOCTL_PRIVCMD_MMAPBATCH    _VKI_IOC(_VKI_IOC_NONE, 'P', 3, sizeof(struct vki_xen_privcmd_mmapbatch))
 #define VKI_XEN_IOCTL_PRIVCMD_MMAPBATCH_V2 _VKI_IOC(_VKI_IOC_NONE, 'P', 4, sizeof(struct vki_xen_privcmd_mmapbatch_v2))
 
+#define VKI_XEN_IOCTL_PRIVCMD_DM_OP        _VKI_IOC(_VKI_IOC_NONE, 'P', 5, sizeof(struct vki_xen_privcmd_dm_op))
+#define VKI_XEN_IOCTL_PRIVCMD_RESTRICT     _VKI_IOC(_VKI_IOC_NONE, 'P', 6, sizeof(__vki_u16))
+#define VKI_XEN_IOCTL_PRIVCMD_MMAP_RESOURCE _VKI_IOC(_VKI_IOC_NONE, 'P', 7, sizeof(struct vki_xen_privcmd_mmap_resource))
+#define VKI_XEN_IOCTL_PRIVCMD_UNIMPLEMENTED _VKI_IOC(_VKI_IOC_NONE, 'P', 0xff, 0)
+
 //----------------------------------------------------------------------
 // Xen evtchn IOCTL
 //----------------------------------------------------------------------
@@ -3428,6 +3453,91 @@ struct vki_xen_ioctl_evtchn_notify {
 #define VKI_XEN_IOCTL_EVTCHN_RESET				\
 	_VKI_IOC(_VKI_IOC_NONE, 'E', 5, 0)
 
+//----------------------------------------------------------------------
+// Xen gnttdev IOCTL
+//----------------------------------------------------------------------
+
+#define VKI_XEN_IOCTL_GNTDEV_MAP_GRANT_REF			\
+   _VKI_IOC(_VKI_IOC_NONE, 'G', 0, sizeof(struct vki_xen_ioctl_gntdev_map_grant_ref))
+struct vki_xen_ioctl_gntdev_grant_ref {
+   vki_u32 domid;
+   vki_u32 ref;
+};
+struct vki_xen_ioctl_gntdev_map_grant_ref {
+   vki_u32 count;
+   vki_u32 pad;
+   __vki_u64 index;
+   struct vki_xen_ioctl_gntdev_grant_ref refs[1];
+};
+
+#define VKI_XEN_IOCTL_GNTDEV_UNMAP_GRANT_REF			\
+	_VKI_IOC(_VKI_IOC_NONE, 'G', 1, sizeof(struct vki_xen_ioctl_gntdev_unmap_grant_ref))
+struct vki_xen_ioctl_gntdev_unmap_grant_ref {
+   __vki_u64 index;
+   vki_u32 count;
+   vki_u32 pad;
+};
+
+#define VKI_XEN_IOCTL_GNTDEV_GET_OFFSET_FOR_VADDR			\
+	_VKI_IOC(_VKI_IOC_NONE, 'G', 2, sizeof(struct vki_xen_ioctl_gntdev_get_offset_for_vaddr))
+struct vki_xen_ioctl_gntdev_get_offset_for_vaddr {
+   __vki_u64 vaddr;
+   __vki_u64 offset;
+   vki_u32 count;
+   vki_u32 pad;
+};
+
+#define VKI_XEN_IOCTL_GNTDEV_SET_MAX_GRANTS			\
+	_VKI_IOC(_VKI_IOC_NONE, 'G', 3, sizeof(struct vki_xen_ioctl_gntdev_set_max_grants))
+struct vki_xen_ioctl_gntdev_set_max_grants {
+   vki_u32 count;
+};
+
+#define VKI_XEN_IOCTL_GNTALLOC_ALLOC_GREF			\
+	_VKI_IOC(_VKI_IOC_NONE, 'G', 5, sizeof(struct vki_xen_ioctl_gntalloc_alloc_gref))
+struct vki_xen_ioctl_gntalloc_alloc_gref {
+   vki_u16 domid;
+   vki_u16 flags;
+   vki_u32 count;
+   __vki_u64 index;
+   vki_u32 gref_ids[1];
+};
+
+#define VKI_XEN_IOCTL_GNTALLOC_DEALLOC_GREF			\
+	_VKI_IOC(_VKI_IOC_NONE, 'G', 6, sizeof(struct vki_xen_ioctl_gntalloc_dealloc_gref))
+struct vki_xen_ioctl_gntalloc_dealloc_gref {
+   __vki_u64 index;
+   vki_u32 count;
+};
+
+#define VKI_XEN_IOCTL_GNTALLOC_SET_UNMAP_NOTIFY			\
+	_VKI_IOC(_VKI_IOC_NONE, 'G', 7, sizeof(struct vki_xen_ioctl_gntalloc_set_unmap_notify))
+struct vki_xen_ioctl_gntalloc_set_unmap_notify {
+   __vki_u64 index;
+   vki_u32 action;
+   vki_u32 event_channel_port;
+};
+
+#define VKI_XEN_IOCTL_GNTDEV_GRANT_COPY				\
+	_VKI_IOC(_VKI_IOC_NONE, 'G', 8, sizeof(struct vki_xen_ioctl_gntdev_grant_copy))
+struct vki_xen_gntdev_grant_copy_segment {
+   union {
+      void *virt;
+      struct {
+         vki_u32 ref; /* grant_ref_t */
+         vki_u16 offset;
+         vki_u16 domid; /* domid_t */
+      } foreign;
+   } source, dest;
+   vki_u16 len;
+   vki_u16 flags;  /* GNTCOPY_* */
+   __vki_s16 status; /* GNTST_* */
+};
+
+struct vki_xen_ioctl_gntdev_grant_copy {
+   vki_uint32_t count;
+   struct vki_xen_gntdev_grant_copy_segment *segments;
+};
 
 //----------------------------------------------------------------------
 // From linux-3.4.0/include/linux/fs.h
diff --git a/include/vki/vki-xen-domctl.h b/include/vki/vki-xen-domctl.h
index 9e8b5ef1f..644912092 100644
--- a/include/vki/vki-xen-domctl.h
+++ b/include/vki/vki-xen-domctl.h
@@ -30,21 +30,30 @@
 
 /*
  * The domctl interface is versioned via the interface_version
- * field. This structures in this header supports domctl interfaces:
+ * field. The structures in this header supports domctl interfaces:
  *
+ * - 0x00000003: Xen 3.0.3 (unhandled)
+ * - 0x00000004: Xen 3.0.4 (unhandled)
+ * - 0x00000005: Xen 3.1 (unhandled)   
+ * - 0x00000006: Xen 4.0 (unhandled)
  * - 0x00000007: Xen 4.1
  * - 0x00000008: Xen 4.2
  * - 0x00000009: Xen 4.3 & 4.4
  * - 0x0000000a: Xen 4.5
- * - 0x0000000b: Xen 4.6
- * - 0x0000000c: Xen 4.7
+ * - 0x0000000b: Xen 4.6 & 4.7
+ * - 0x0000000c: Xen 4.8
+ * - 0x0000000d: Xen 4.9
+ * - 0x0000000e: Xen 4.10
+ * - 0x0000000f: Xen 4.10.1
+ * - 0x00000010: Xen 4.11
+ * - 0x00000011: Xen 4.12
  *
  * When adding a new subop be sure to include the variants used by all
  * of the above, both here and in syswrap-xen.c
  *
  * Structs which are identical in all supported versions have no
  * version suffix. Structs which do differ are defined multiple times
- * and use the suffix of the latest version to contain that particular
+ * and use the suffix of the earliest version to contain that particular
  * variant.
  */
 
@@ -119,19 +128,81 @@
 #define VKI_XEN_DOMCTL_cacheflush                    71
 #define VKI_XEN_DOMCTL_get_vcpu_msrs                 72
 #define VKI_XEN_DOMCTL_set_vcpu_msrs                 73
+#define VKI_XEN_DOMCTL_setvnumainfo                  74
+#define VKI_XEN_DOMCTL_psr_cmt_op                    75
+#define VKI_XEN_DOMCTL_arm_configure_domain          76
 #define VKI_XEN_DOMCTL_monitor_op                    77 /* new in 4.6 */
+#define VKI_XEN_DOMCTL_psr_cat_op                    78
+#define VKI_XEN_DOMCTL_soft_reset                    79
+#define VKI_XEN_DOMCTL_set_gnttab_limits             80
+#define VKI_XEN_DOMCTL_vuart_op                      81
 #define VKI_XEN_DOMCTL_gdbsx_guestmemio            1000
 #define VKI_XEN_DOMCTL_gdbsx_pausevcpu             1001
 #define VKI_XEN_DOMCTL_gdbsx_unpausevcpu           1002
 #define VKI_XEN_DOMCTL_gdbsx_domstatus             1003
 
-struct vki_xen_domctl_createdomain {
+struct vki_xen_domctl_createdomain_00000004 {
     /* IN parameters */
     vki_uint32_t ssidref;
     vki_xen_domain_handle_t handle;
     vki_uint32_t flags;
 };
 
+struct vki_xen_arch_domainconfig_0000000b {
+#if defined(__i386__) || defined(__x86_64__)
+    vki_uint8_t dummy;
+#endif
+#if defined(__arm__) || defined(__aarch64__)
+    /* IN/OUT */
+    vki_uint8_t gic_version;
+    /* IN */
+    vki_uint32_t nr_spis;
+    vki_uint32_t clock_frequency;
+#endif
+};
+
+struct vki_xen_domctl_createdomain_0000000b {
+    /* IN parameters */
+    vki_uint32_t ssidref;
+    vki_xen_domain_handle_t handle;
+    vki_uint32_t flags;
+    struct vki_xen_arch_domainconfig_0000000b config;
+};
+
+/* The layout changed in 4.07, which shares domctl with 4.06 */
+struct vki_xen_arch_domainconfig_0000000c {
+#if defined(__i386__) || defined(__x86_64__)
+    vki_uint32_t emulation_flags;
+#endif
+#if defined(__arm__) || defined(__aarch64__)
+    /* IN/OUT */
+    vki_uint8_t gic_version;
+    /* IN */
+    vki_uint32_t nr_spis;
+    vki_uint32_t clock_frequency;
+#endif
+};
+
+struct vki_xen_domctl_createdomain_0000000c {
+    /* IN parameters */
+    vki_uint32_t ssidref;
+    vki_xen_domain_handle_t handle;
+    vki_uint32_t flags;
+    struct vki_xen_arch_domainconfig_0000000c config;
+};
+
+struct vki_xen_domctl_createdomain_00000011 {
+    /* IN parameters */
+    vki_uint32_t ssidref;
+    vki_xen_domain_handle_t handle;
+    vki_uint32_t flags;
+    vki_uint32_t max_vcpus;
+    vki_uint32_t max_evtchn_port;
+    vki_uint32_t max_grant_frames;
+    vki_uint32_t max_maptrack_frames;
+    struct vki_xen_arch_domainconfig_0000000c config;
+};
+
 struct vki_xen_domctl_getdomaininfo_00000007 {
     /* OUT variables. */
     vki_xen_domid_t  domain;
@@ -192,6 +263,28 @@ DEFINE_VKI_XEN_GUEST_HANDLE(vki_xen_domctl_getdomaininfo_00000009_t);
 
 /* vki_xen_domctl_getdomaininfo_0000000a is the same as 00000009 */
 
+struct vki_xen_domctl_getdomaininfo_0000000f {
+    /* OUT variables. */
+    vki_xen_domid_t  domain;
+    vki_uint32_t flags;
+    vki_xen_uint64_aligned_t tot_pages;
+    vki_xen_uint64_aligned_t max_pages;
+    vki_xen_uint64_aligned_t outstanding_pages;
+    vki_xen_uint64_aligned_t shr_pages;
+    vki_xen_uint64_aligned_t paged_pages;
+    vki_xen_uint64_aligned_t shared_info_frame;
+    vki_xen_uint64_aligned_t cpu_time;
+    vki_uint32_t nr_online_vcpus;
+    vki_uint32_t max_vcpu_id;
+    vki_uint32_t ssidref;
+    vki_xen_domain_handle_t handle;
+    vki_uint32_t cpupool;
+    struct vki_xen_arch_domainconfig_0000000c arch_config;
+};
+typedef struct vki_xen_domctl_getdomaininfo_0000000f vki_xen_domctl_getdomaininfo_0000000f_t;
+DEFINE_VKI_XEN_GUEST_HANDLE(vki_xen_domctl_getdomaininfo_0000000f_t);
+
+
 /* Get/set the NUMA node(s) with which the guest has affinity with. */
 /* XEN_DOMCTL_setnodeaffinity */
 /* XEN_DOMCTL_getnodeaffinity */
@@ -215,6 +308,7 @@ struct vki_xen_domctl_vcpuaffinity_0000000a {
     vki_uint32_t  vcpu;              /* IN */
 #define VKI_XEN_VCPUAFFINITY_HARD   (1U<<0)
 #define VKI_XEN_VCPUAFFINITY_SOFT   (1U<<1)
+#define VKI_XEN_VCPUAFFINITY_FORCE  (1U<<2)
     vki_uint32_t  flags;              /* IN */
     struct vki_xenctl_bitmap cpumap_hard; /* IN/OUT */
     struct vki_xenctl_bitmap cpumap_soft; /* IN/OUT */
@@ -282,9 +376,12 @@ struct vki_xen_domctl_scheduler_op {
 #define VKI_XEN_SCHEDULER_CREDIT2  6
 #define VKI_XEN_SCHEDULER_ARINC653 7
 #define VKI_XEN_SCHEDULER_RTDS     8
+#define VKI_XEN_SCHEDULER_NULL     9
     vki_uint32_t cmd;       /* VKI_XEN_DOMCTL_SCHEDOP_* */
 #define VKI_XEN_DOMCTL_SCHEDOP_putinfo 0
 #define VKI_XEN_DOMCTL_SCHEDOP_getinfo 1
+#define VKI_XEN_DOMCTL_SCHEDOP_putvcpuinfo 2
+#define VKI_XEN_DOMCTL_SCHEDOP_getvcpuinfo 3
     union {
         struct xen_domctl_sched_sedf {
             vki_xen_uint64_aligned_t period;
@@ -333,10 +430,14 @@ struct vki_xen_domctl_hypercall_init {
     vki_xen_uint64_aligned_t  gmfn;           /* GMFN to be initialised */
 };
 
-struct vki_xen_domctl_settimeoffset {
+struct vki_xen_domctl_settimeoffset_00000001 {
     vki_int32_t time_offset_seconds;
 };
 
+struct vki_xen_domctl_settimeoffset_0000000b {
+    vki_int64_t time_offset_seconds;
+};
+
 struct vki_xen_domctl_cpuid {
   vki_uint32_t input[2];
   vki_uint32_t eax;
@@ -378,14 +479,22 @@ struct vki_xen_domctl_hvmcontext {
 typedef struct vki_xen_domctl_hvmcontext vki_xen_domctl_hvmcontext_t;
 DEFINE_VKI_XEN_GUEST_HANDLE(vki_xen_domctl_hvmcontext_t);
 
-struct vki_xen_domctl_hvmcontext_partial {
+struct vki_xen_domctl_hvmcontext_partial_00000005 {
     vki_uint32_t type; /* IN */
     vki_uint32_t instance; /* IN */
     VKI_XEN_GUEST_HANDLE_64(vki_uint8) buffer; /* IN/OUT buffer */
 };
-typedef struct vki_xen_domctl_hvmcontext_partial vki_xen_domctl_hvmcontext_partial_t;
-DEFINE_VKI_XEN_GUEST_HANDLE(vki_xen_domctl_hvmcontext_partial_t);
+typedef struct vki_xen_domctl_hvmcontext_partial_00000005 vki_xen_domctl_hvmcontext_partial_00000005_t;
+DEFINE_VKI_XEN_GUEST_HANDLE(vki_xen_domctl_hvmcontext_partial_00000005_t);
 
+struct vki_xen_domctl_hvmcontext_partial_0000000e {
+    vki_uint32_t type; /* IN */
+    vki_uint32_t instance; /* IN */
+    vki_xen_uint64_aligned_t bufsz; /* IN */
+    VKI_XEN_GUEST_HANDLE_64(vki_uint8) buffer; /* IN/OUT buffer */
+};
+typedef struct vki_xen_domctl_hvmcontext_partial_0000000e vki_xen_domctl_hvmcontext_partial_0000000e_t;
+DEFINE_VKI_XEN_GUEST_HANDLE(vki_xen_domctl_hvmcontext_partial_0000000e_t);
 
 struct vki_xen_domctl_pin_mem_cacheattr {
     vki_xen_uint64_aligned_t start, end; /* IN */
@@ -464,6 +573,20 @@ struct vki_xen_domctl_assign_device_0000000b {
     vki_uint32_t  flag;   /* flag of assigned device */
 };
 
+struct vki_xen_domctl_assign_device_0000000e {
+    vki_uint32_t dev;   /* XEN_DOMCTL_DEV_* */
+    vki_uint32_t flags;
+    union {
+        struct {
+            vki_uint32_t machine_sbdf;   /* machine PCI ID of assigned device */
+        } pci;
+        struct {
+            vki_uint32_t size; /* Length of the path */
+            VKI_XEN_GUEST_HANDLE_64(vki_uint8) path; /* path to the device tree node */
+        } dt;
+    } u;
+};
+
 struct vki_xen_domctl_debug_op {
     vki_uint32_t op;   /* IN */
     vki_uint32_t vcpu; /* IN */
@@ -515,6 +638,12 @@ struct vki_xen_domctl_vcpu_msrs {
 #define VKI_XEN_DOMCTL_MONITOR_EVENT_SINGLESTEP            2
 #define VKI_XEN_DOMCTL_MONITOR_EVENT_SOFTWARE_BREAKPOINT   3
 #define VKI_XEN_DOMCTL_MONITOR_EVENT_GUEST_REQUEST         4
+#define VKI_XEN_DOMCTL_MONITOR_EVENT_DEBUG_EXCEPTION       5
+#define VKI_XEN_DOMCTL_MONITOR_EVENT_CPUID                 6
+#define VKI_XEN_DOMCTL_MONITOR_EVENT_PRIVILEGED_CALL       7
+#define VKI_XEN_DOMCTL_MONITOR_EVENT_INTERRUPT             8
+#define VKI_XEN_DOMCTL_MONITOR_EVENT_DESC_ACCESS           9
+#define VKI_XEN_DOMCTL_MONITOR_EVENT_EMUL_UNIMPLEMENTED    10
 
 struct vki_xen_domctl_monitor_op_0000000b {
     vki_uint32_t op; /* vki_xen_DOMCTL_MONITOR_OP_* */
@@ -553,6 +682,78 @@ struct vki_xen_domctl_monitor_op_0000000b {
     } u;
 };
 
+struct vki_xen_domctl_monitor_op_0000000c {
+    vki_uint32_t op; /* vki_xen_DOMCTL_MONITOR_OP_* */
+    vki_uint32_t event;
+    union {
+        struct {
+            vki_uint8_t index;
+            vki_uint8_t sync;
+            vki_uint8_t onchangeonly;
+        } mov_to_cr;
+        struct {
+            vki_uint32_t msr;
+        } mov_to_msr;
+        struct {
+            vki_uint8_t sync;
+        } guest_request;
+        struct {
+            vki_uint8_t sync;
+        } debug_exception;
+    } u;
+};
+
+struct vki_xen_domctl_monitor_op_0000000e {
+    vki_uint32_t op; /* vki_xen_DOMCTL_MONITOR_OP_* */
+    vki_uint32_t event;
+    union {
+        struct {
+            vki_uint8_t index;
+            vki_uint8_t sync;
+            vki_uint8_t onchangeonly;
+            vki_uint8_t pad1;
+            vki_uint32_t pad2;
+            vki_xen_uint64_aligned_t bitmask;
+        } mov_to_cr;
+        struct {
+            vki_uint32_t msr;
+        } mov_to_msr;
+        struct {
+            vki_uint8_t sync;
+            vki_uint8_t allow_userspace;
+        } guest_request;
+        struct {
+            vki_uint8_t sync;
+        } debug_exception;
+    } u;
+};
+
+struct vki_xen_domctl_monitor_op_00000010 {
+    vki_uint32_t op; /* vki_xen_DOMCTL_MONITOR_OP_* */
+    vki_uint32_t event;
+    union {
+        struct {
+            vki_uint8_t index;
+            vki_uint8_t sync;
+            vki_uint8_t onchangeonly;
+            vki_uint8_t pad1;
+            vki_uint32_t pad2;
+            vki_xen_uint64_aligned_t bitmask;
+        } mov_to_cr;
+        struct {
+            vki_uint32_t msr;
+            vki_uint8_t onchangeonly;
+        } mov_to_msr;
+        struct {
+            vki_uint8_t sync;
+            vki_uint8_t allow_userspace;
+        } guest_request;
+        struct {
+            vki_uint8_t sync;
+        } debug_exception;
+    } u;
+};
+
 
 struct vki_xen_domctl_monitor_op {
     vki_uint32_t op;
@@ -576,15 +777,24 @@ struct vki_xen_domctl_monitor_op {
     } u;
 };
 
+struct vki_xen_domctl_set_gnttab_limits_0000000e {
+    vki_uint32_t grant_frames;
+    vki_uint32_t maptrack_frames;
+};
+
 struct vki_xen_domctl {
     vki_uint32_t cmd;
     vki_uint32_t interface_version; /* XEN_DOMCTL_INTERFACE_VERSION */
     vki_xen_domid_t  domain;
     union {
-        struct vki_xen_domctl_createdomain      createdomain;
+        struct vki_xen_domctl_createdomain_00000004  createdomain_00000004;
+        struct vki_xen_domctl_createdomain_0000000b  createdomain_0000000b;
+        struct vki_xen_domctl_createdomain_0000000c  createdomain_0000000c;
+        struct vki_xen_domctl_createdomain_00000011  createdomain_00000011;
         struct vki_xen_domctl_getdomaininfo_00000007 getdomaininfo_00000007;
         struct vki_xen_domctl_getdomaininfo_00000008 getdomaininfo_00000008;
         struct vki_xen_domctl_getdomaininfo_00000009 getdomaininfo_00000009;
+        struct vki_xen_domctl_getdomaininfo_0000000f getdomaininfo_0000000f;
         //struct vki_xen_domctl_getmemlist        getmemlist;
         //struct vki_xen_domctl_getpageframeinfo  getpageframeinfo;
         //struct vki_xen_domctl_getpageframeinfo2 getpageframeinfo2;
@@ -605,18 +815,21 @@ struct vki_xen_domctl {
         struct vki_xen_domctl_ioport_permission ioport_permission;
         struct vki_xen_domctl_hypercall_init    hypercall_init;
         //struct vki_xen_domctl_arch_setup        arch_setup;
-        struct vki_xen_domctl_settimeoffset     settimeoffset;
+        struct vki_xen_domctl_settimeoffset_00000001     settimeoffset_00000001;
+        struct vki_xen_domctl_settimeoffset_0000000b     settimeoffset_0000000b;
         //struct vki_xen_domctl_disable_migrate   disable_migrate;
         struct vki_xen_domctl_tsc_info_00000007   tsc_info_00000007;
         struct vki_xen_domctl_tsc_info_0000000b   tsc_info_0000000b;
         //struct vki_xen_domctl_real_mode_area    real_mode_area;
         struct vki_xen_domctl_hvmcontext        hvmcontext;
-        struct vki_xen_domctl_hvmcontext_partial hvmcontext_partial;
+        struct vki_xen_domctl_hvmcontext_partial_00000005 hvmcontext_partial_00000005;
+        struct vki_xen_domctl_hvmcontext_partial_0000000e hvmcontext_partial_0000000e;
         struct vki_xen_domctl_address_size      address_size;
         //struct vki_xen_domctl_sendtrigger       sendtrigger;
         //struct vki_xen_domctl_get_device_group  get_device_group;
         struct vki_xen_domctl_assign_device_00000007 assign_device_00000007;
         struct vki_xen_domctl_assign_device_0000000b assign_device_0000000b;
+        struct vki_xen_domctl_assign_device_0000000e assign_device_0000000e;
         //struct vki_xen_domctl_bind_pt_irq       bind_pt_irq;
         //struct vki_xen_domctl_memory_mapping    memory_mapping;
         //struct vki_xen_domctl_ioport_mapping    ioport_mapping;
@@ -644,6 +857,15 @@ struct vki_xen_domctl {
         //struct vki_xen_domctl_gdbsx_pauseunp_vcpu gdbsx_pauseunp_vcpu;
         //struct vki_xen_domctl_gdbsx_domstatus   gdbsx_domstatus;
         struct vki_xen_domctl_monitor_op_0000000b monitor_op_0000000b;
+        struct vki_xen_domctl_monitor_op_0000000c monitor_op_0000000c;
+        struct vki_xen_domctl_monitor_op_0000000e monitor_op_0000000e;
+        struct vki_xen_domctl_monitor_op_00000010 monitor_op_00000010;
+        //struct vki_xen_domctl_vnuma             vnuma;
+        //struct vki_xen_domctl_psr_cmt_op        psr_cmt_op;
+        //struct vki_xen_domctl_psr_cat_op        psr_cat_op;
+        //struct vki_xen_domctl_arm_configuredomain configuredomain;
+        struct vki_xen_domctl_set_gnttab_limits_0000000e set_gnttab_limits_0000000e;
+        //struct vki_xen_domctl_vuart_op          vuart_op;
         vki_uint8_t                         pad[128];
     } u;
 };
diff --git a/include/vki/vki-xen-gnttab.h b/include/vki/vki-xen-gnttab.h
index 3e6c36cdb..73af94409 100644
--- a/include/vki/vki-xen-gnttab.h
+++ b/include/vki/vki-xen-gnttab.h
@@ -42,6 +42,7 @@ typedef vki_uint32_t vki_xen_grant_ref_t;
 #define VKI_XEN_GNTTABOP_get_status_frames    9
 #define VKI_XEN_GNTTABOP_get_version          10
 #define VKI_XEN_GNTTABOP_swap_grant_ref	      11
+#define VKI_XEN_GNTTABOP_cache_flush          12
 
 struct vki_xen_gnttab_setup_table {
     /* IN parameters. */
diff --git a/include/vki/vki-xen-memory.h b/include/vki/vki-xen-memory.h
index 3b6f9e519..ae77d49c7 100644
--- a/include/vki/vki-xen-memory.h
+++ b/include/vki/vki-xen-memory.h
@@ -48,8 +48,12 @@
 #define VKI_XENMEM_get_sharing_freed_pages    18
 #define VKI_XENMEM_get_sharing_shared_pages   19
 #define VKI_XENMEM_access_op                  21
+#define VKI_XENMEM_sharing_op                 22
+#define VKI_XENMEM_add_to_physmap_batch       23
 #define VKI_XENMEM_claim_pages                24
 #define VKI_XENMEM_machphys_compat_mfn_list   25
+#define VKI_XENMEM_get_vnumainfo              26
+#define VKI_XENMEM_reserved_device_memory_map 27
 
 struct vki_xen_memory_map {
     unsigned int nr_entries;
@@ -95,6 +99,14 @@ struct vki_xen_remove_from_physmap {
     vki_xen_pfn_t gpfn;
 };
 
+struct vki_xen_pod_target {
+    vki_uint64_t    target_pages;
+    vki_uint64_t    tot_pages;
+    vki_uint64_t    pod_cache_pages;
+    vki_uint64_t    pod_entries;
+    vki_xen_domid_t domid;
+};
+
 struct vki_xen_mem_event_op {
     vki_uint8_t     op;
     vki_xen_domid_t     domain;
diff --git a/include/vki/vki-xen-physdev.h b/include/vki/vki-xen-physdev.h
index 6f8c2c84c..225119821 100644
--- a/include/vki/vki-xen-physdev.h
+++ b/include/vki/vki-xen-physdev.h
@@ -60,6 +60,15 @@ struct vki_xen_physdev_unmap_pirq {
     int pirq;
 };
 
+struct vki_physdev_pci_device {
+    /* IN */
+    vki_uint16_t seg;
+    vki_uint8_t bus;
+    vki_uint8_t devfn;
+};
+typedef struct vki_physdev_pci_device vki_physdev_pci_device_t;
+DEFINE_VKI_XEN_GUEST_HANDLE(vki_physdev_pci_device_t);
+
 #endif // __VKI_XEN_PHYSDEV_H
 
 /*--------------------------------------------------------------------*/
diff --git a/include/vki/vki-xen-schedop.h b/include/vki/vki-xen-schedop.h
index 3c5b2ceeb..b18cdf4bf 100644
--- a/include/vki/vki-xen-schedop.h
+++ b/include/vki/vki-xen-schedop.h
@@ -47,4 +47,6 @@ typedef struct vki_xen_remote_shutdown vki_xen_remote_shutdown_t;
 
 #define VKI_XEN_SCHEDOP_watchdog        6
 
+#define VKI_XEN_SCHEDOP_pin_override    7
+
 #endif /* __VKI_XEN_SCHED_OP_H */
diff --git a/include/vki/vki-xen-sysctl.h b/include/vki/vki-xen-sysctl.h
index 8f4eac124..88e966ccf 100644
--- a/include/vki/vki-xen-sysctl.h
+++ b/include/vki/vki-xen-sysctl.h
@@ -3,19 +3,30 @@
 
 /*
  * The sysctl interface is versioned via the interface_version
- * field. This structures in this header supports sysctl interfaces:
+ * field. The structures in this header supports sysctl interfaces:
  *
+ * - 0x00000002: Xen 3.0.3 (unhandled)
+ * - 0x00000003: Xen 3.1.0 (unhandled)
+ * - 0x00000006: Xen 3.2 (unhandled)   
+ * - 0x00000007: Xen 4.0 (unhandled)
  * - 0x00000008: Xen 4.1
  * - 0x00000009: Xen 4.2
  * - 0x0000000a: Xen 4.3 & 4.4
  * - 0x0000000b: Xen 4.5
+ * - 0x0000000c: Xen 4.6
+ * - 0x0000000d: Xen 4.7
+ * - 0x0000000e: Xen 4.8
+ * - 0x0000000f: Xen 4.9
+ * - 0x00000010: Xen 4.10
+ * - 0x00000011: Xen 4.11
+ * - 0x00000012: Xen 4.12
  *
  * When adding a new subop be sure to include the variants used by all
  * of the above, both here and in syswrap-xen.c
  *
  * Structs which are identical in all supported versions have no
  * version suffix. Structs which do differ are defined multiple times
- * and use the suffix of the latest version to contain that particular
+ * and use the suffix of the earliest version to contain that particular
  * variant.
  */
 
@@ -34,10 +45,21 @@
 #define VKI_XEN_SYSCTL_page_offline_op               14
 #define VKI_XEN_SYSCTL_lockprof_op                   15
 #define VKI_XEN_SYSCTL_topologyinfo                  16
+#define VKI_XEN_SYSCTL_cputopoinfo                   16 /* Since xen-4.6 */
 #define VKI_XEN_SYSCTL_numainfo                      17
 #define VKI_XEN_SYSCTL_cpupool_op                    18
 #define VKI_XEN_SYSCTL_scheduler_op                  19
 #define VKI_XEN_SYSCTL_coverage_op                   20
+#define VKI_XEN_SYSCTL_gcov_op                       20 /* Since xen-4.9 */
+#define VKI_XEN_SYSCTL_psr_cmt_op                    21
+#define VKI_XEN_SYSCTL_pcitopoinfo                   22
+#define VKI_XEN_SYSCTL_psr_cat_op                    23
+#define VKI_XEN_SYSCTL_tmem_op                       24
+#define VKI_XEN_SYSCTL_get_cpu_levelling_caps        25
+#define VKI_XEN_SYSCTL_get_cpu_featureset            26
+#define VKI_XEN_SYSCTL_livepatch_op                  27
+#define VKI_XEN_SYSCTL_set_parameter                 28
+#define VKI_XEN_SYSCTL_get_cpu_policy                29
 
 struct vki_xen_sysctl_readconsole {
     /* IN */
@@ -120,12 +142,45 @@ struct vki_xen_sysctl_topologyinfo {
     VKI_XEN_GUEST_HANDLE_64(vki_uint32) cpu_to_node;
 };
 
-struct vki_xen_sysctl_numainfo {
+struct vki_xen_sysctl_cputopo_0000000c {
+    vki_uint32_t core;
+    vki_uint32_t socket;
+    vki_uint32_t node;
+};
+typedef struct vki_xen_sysctl_cputopo_0000000c vki_xen_sysctl_cputopo_0000000c_t;
+DEFINE_VKI_XEN_GUEST_HANDLE(vki_xen_sysctl_cputopo_0000000c_t);
+
+struct vki_xen_sysctl_cputopoinfo_0000000c {
+    vki_uint32_t num_cpus;
+    VKI_XEN_GUEST_HANDLE_64(vki_xen_sysctl_cputopo_0000000c_t) cputopo;
+};
+
+struct vki_xen_sysctl_pcitopoinfo_0000000c {
+    vki_uint32_t num_devs;
+    VKI_XEN_GUEST_HANDLE_64(vki_physdev_pci_device_t) devs;
+    VKI_XEN_GUEST_HANDLE_64(vki_uint32) nodes;
+};
+
+struct vki_xen_sysctl_numainfo_00000008 {
     vki_uint32_t max_node_index;
     VKI_XEN_GUEST_HANDLE_64(vki_uint64) node_to_memsize;
     VKI_XEN_GUEST_HANDLE_64(vki_uint64) node_to_memfree;
     VKI_XEN_GUEST_HANDLE_64(vki_uint32) node_to_node_distance;
 };
+
+struct vki_xen_xen_sysctl_meminfo_0000000c {
+    vki_uint64_t memsize;
+    vki_uint64_t memfree;
+};
+typedef struct vki_xen_xen_sysctl_meminfo_0000000c vki_xen_xen_sysctl_meminfo_0000000c_t;
+DEFINE_VKI_XEN_GUEST_HANDLE(vki_xen_xen_sysctl_meminfo_0000000c_t);
+
+struct vki_xen_sysctl_numainfo_0000000c {
+    vki_uint32_t num_nodes;
+    VKI_XEN_GUEST_HANDLE_64(vki_xen_xen_sysctl_meminfo_0000000c_t) meminfo;
+    VKI_XEN_GUEST_HANDLE_64(vki_uint32) distance;
+};
+
 struct vki_xen_sysctl_physinfo_00000008 {
     vki_uint32_t threads_per_core;
     vki_uint32_t cores_per_socket;
@@ -159,6 +214,23 @@ struct vki_xen_sysctl_physinfo_0000000a {
     vki_uint32_t capabilities;
 };
 
+struct vki_xen_sysctl_physinfo_00000010 {
+    vki_uint32_t threads_per_core;
+    vki_uint32_t cores_per_socket;
+    vki_uint32_t nr_cpus;     /* # CPUs currently online */
+    vki_uint32_t max_cpu_id;  /* Largest possible CPU ID on this host */
+    vki_uint32_t nr_nodes;    /* # nodes currently online */
+    vki_uint32_t max_node_id; /* Largest possible node ID on this host */
+    vki_uint32_t cpu_khz;
+    vki_uint32_t capabilities; /* XEN_SYSCTL_PHYSCAP_??? */
+    vki_xen_uint64_aligned_t total_pages;
+    vki_xen_uint64_aligned_t free_pages;
+    vki_xen_uint64_aligned_t scrub_pages;
+    vki_xen_uint64_aligned_t outstanding_pages;
+    vki_xen_uint64_aligned_t max_mfn; /* Largest possible MFN on this host */
+    vki_uint32_t hw_cap[8];
+};
+
 /* vki_xen_sysctl_physinfo_0000000b is the same as 0000000a */
 
 struct vki_xen_sysctl_sched_id {
@@ -166,6 +238,12 @@ struct vki_xen_sysctl_sched_id {
     vki_uint32_t              sched_id;
 };
 
+struct vki_xen_sysctl_cpu_featureset_0000000d {
+    vki_uint32_t index;
+    vki_uint32_t nr_features;
+    VKI_XEN_GUEST_HANDLE_64(vki_uint32) features;
+};
+
 struct vki_xen_sysctl {
     vki_uint32_t cmd;
     vki_uint32_t interface_version; /* XEN_SYSCTL_INTERFACE_VERSION */
@@ -174,8 +252,12 @@ struct vki_xen_sysctl {
         //struct vki_xen_sysctl_tbuf_op           tbuf_op;
         struct vki_xen_sysctl_physinfo_00000008 physinfo_00000008;
         struct vki_xen_sysctl_physinfo_0000000a physinfo_0000000a;
+        struct vki_xen_sysctl_physinfo_00000010 physinfo_00000010;
         struct vki_xen_sysctl_topologyinfo      topologyinfo;
-        struct vki_xen_sysctl_numainfo          numainfo;
+        struct vki_xen_sysctl_cputopoinfo_0000000c cputopoinfo_0000000c;
+        struct vki_xen_sysctl_pcitopoinfo_0000000c pcitopoinfo_0000000c;
+        struct vki_xen_sysctl_numainfo_00000008 numainfo_00000008;
+        struct vki_xen_sysctl_numainfo_0000000c numainfo_0000000c;
         struct vki_xen_sysctl_sched_id          sched_id;
         //struct vki_xen_sysctl_perfc_op          perfc_op;
         struct vki_xen_sysctl_getdomaininfolist_00000008 getdomaininfolist_00000008;
@@ -192,6 +274,15 @@ struct vki_xen_sysctl {
         struct vki_xen_sysctl_cpupool_op        cpupool_op;
         //struct vki_xen_sysctl_scheduler_op      scheduler_op;
         //struct vki_xen_sysctl_coverage_op       coverage_op;
+        //struct vki_xen_sysctl_gcov_op           gcov_op;
+        //struct vki_xen_sysctl_psr_cmt_op        psr_cmt_op;
+        //struct vki_xen_sysctl_psr_cat_op        psr_cat_op;
+        //struct vki_xen_sysctl_tmem_op           tmem_op;
+        //struct vki_xen_sysctl_cpu_levelling_caps cpu_levelling_caps;
+        struct vki_xen_sysctl_cpu_featureset_0000000d cpu_featureset_0000000d;
+        //struct vki_xen_sysctl_livepatch_op      livepatch;
+        //struct vki_xen_sysctl_set_parameter     set_parameter;
+        //struct vki_xen_sysctl_get_cpu_policy    get_cpu_policy;
 
         vki_uint8_t                             pad[128];
     } u;
diff --git a/include/vki/vki-xen-version.h b/include/vki/vki-xen-version.h
index dfaf7c07e..72bc56625 100644
--- a/include/vki/vki-xen-version.h
+++ b/include/vki/vki-xen-version.h
@@ -38,6 +38,7 @@
 #define VKI_XENVER_pagesize 7
 #define VKI_XENVER_guest_handle 8
 #define VKI_XENVER_commandline 9
+#define VKI_XENVER_build_id 10
 
 typedef char vki_xen_extraversion_t[16];
 
@@ -63,6 +64,16 @@ struct vki_xen_feature_info {
 
 typedef char vki_xen_commandline_t[1024];
 
+struct vki_xen_build_id {
+    unsigned int len;    /* IN: size of buf[]. */
+#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+    unsigned char   buf[];
+#elif defined(__GNUC__)
+    unsigned char   buf[1]; /* OUT: Variable length buffer with build_id. */
+#endif
+
+};
+
 #endif // __VKI_XEN_VERSION_H
 
 /*--------------------------------------------------------------------*/
diff --git a/include/vki/vki-xen.h b/include/vki/vki-xen.h
index c0dfee36b..ac8b21400 100644
--- a/include/vki/vki-xen.h
+++ b/include/vki/vki-xen.h
@@ -69,6 +69,8 @@
 #define __VKI_XEN_kexec_op             37
 #define __VKI_XEN_tmem_op              38
 #define __VKI_XEN_xc_reserved_op       39 /* reserved for XenClient */
+#define __VKI_XEN_xenpmu_op            40
+#define __VKI_XEN_dm_op                41
 
 #define __DEFINE_VKI_XEN_GUEST_HANDLE(name, type) \
     ___DEFINE_VKI_XEN_GUEST_HANDLE(name, type);   \
@@ -104,6 +106,7 @@ struct vki_xenctl_bitmap {
     vki_uint32_t nr_bits;
 };
 
+#include <vki/vki-xen-physdev.h>
 #include <vki/vki-xen-domctl.h>
 #include <vki/vki-xen-sysctl.h>
 #include <vki/vki-xen-mmuext.h>
@@ -115,7 +118,6 @@ struct vki_xenctl_bitmap {
 #include <vki/vki-xen-hvm.h>
 #include <vki/vki-xen-tmem.h>
 #include <vki/vki-xen-xsm.h>
-#include <vki/vki-xen-physdev.h>
 
 #endif // __VKI_XEN_H
 
