From 2cfbb502504f7c19c0e528d94b7372d1b052ca8b Mon Sep 17 00:00:00 2001
From: Olaf Hering <olaf@aepfle.de>
Date: Wed, 26 Feb 2020 15:27:42 +0100
Subject: [PATCH 001/112] track xenversion for unversioned interfaces

Only domctl and sysctl contain a version info. Other interfaces lack
this essential info. But their layout of arguments may change across Xen
versions.

Track the current Xen version based on info obtained from domctl and
sysctl calls. In case these versioned interfaces are called prior calls
to unversioned interfaces, valgrind will have a chance to guess the
correct layout of arguments.

Upcoming changes will start to make use of this interface.

bz#390553
---
 coregrind/m_syswrap/syswrap-xen.c | 71 +++++++++++++++++++++++++++++++
 1 file changed, 71 insertions(+)

Index: valgrind-3.24.0/coregrind/m_syswrap/syswrap-xen.c
===================================================================
--- valgrind-3.24.0.orig/coregrind/m_syswrap/syswrap-xen.c
+++ valgrind-3.24.0/coregrind/m_syswrap/syswrap-xen.c
@@ -60,6 +60,57 @@
 
 #include <inttypes.h>
 
+typedef enum {
+   vki_xenversion_unset = 0,
+   vki_xenversion_401,
+   vki_xenversion_402,
+   /* value shared between 4.3 and 4.4 */
+   vki_xenversion_404,
+   vki_xenversion_405,
+   vki_xenversion_406_or_407,
+   vki_xenversion_406,
+   vki_xenversion_407,
+   vki_xenversion_408,
+   vki_xenversion_409,
+   vki_xenversion_410,
+   vki_xenversion_4101,
+   vki_xenversion_411,
+   vki_xenversion_412_or_413,
+   vki_xenversion_412,
+   vki_xenversion_413,
+   vki_xenversion_414,
+} vki_assumed_xenversion_t;
+static vki_assumed_xenversion_t vki_assumed_xenversion;
+
+/*
+ * Some of the interfaces to Xen are versioned, like domctl and sysctl.
+ * Other interfaces lack a version number to derive the layout of arguments.
+ * Track the assumed Xen version for them, based on prior domctl or sysctl.
+ */
+static void vki_set_assumed_xenversion(vki_assumed_xenversion_t v)
+{
+   switch (vki_assumed_xenversion) {
+      case vki_xenversion_unset:
+         vki_assumed_xenversion = v;
+         break;
+      case vki_xenversion_406_or_407:
+         if (v == vki_xenversion_406 || v == vki_xenversion_407)
+            vki_assumed_xenversion = v;
+         break;
+      case vki_xenversion_412_or_413:
+         if (v == vki_xenversion_412 || v == vki_xenversion_413)
+            vki_assumed_xenversion = v;
+         break;
+      default:
+         break;
+   }
+}
+
+static void vki_report_unknown_xenversion(const char *str)
+{
+   VG_(dmsg)("WARNING: %s prior domctl/sysctl. Assuming latest interface version.\n", str);
+}
+
 #define PRE(name) static DEFN_PRE_TEMPLATE(xen, name)
 #define POST(name) static DEFN_POST_TEMPLATE(xen, name)
 
@@ -232,6 +283,16 @@ PRE(memory_op)
    case VKI_XENMEM_get_sharing_shared_pages:
       break;
 
+   case VKI_XENMEM_get_pod_target:
+   case VKI_XENMEM_set_pod_target: {
+      struct vki_xen_pod_target *arg =
+         (struct vki_xen_pod_target *)ARG2;
+      PRE_MEM_READ("XENMEM_set_pod_target target_pages",
+                  (Addr)&arg->target_pages, sizeof(arg->target_pages));
+      PRE_MEM_READ("XENMEM_set_pod_target domid",
+                  (Addr)&arg->domid, sizeof(arg->domid));
+      break;
+   }
    case VKI_XENMEM_access_op: {
        struct vki_xen_mem_event_op *arg =
             (struct vki_xen_mem_event_op *)ARG2;
@@ -530,6 +591,7 @@ PRE(xen_version)
    case VKI_XENVER_pagesize:
    case VKI_XENVER_guest_handle:
    case VKI_XENVER_commandline:
+   case VKI_XENVER_build_id:
       /* No inputs */
       break;
 
@@ -579,16 +641,40 @@ PRE(sysctl) {
    switch (sysctl->interface_version)
    {
    case 0x00000008:
+      vki_set_assumed_xenversion(vki_xenversion_401);
+	   break;
    case 0x00000009:
+      vki_set_assumed_xenversion(vki_xenversion_402);
+	   break;
    case 0x0000000a:
+      vki_set_assumed_xenversion(vki_xenversion_404);
+	   break;
    case 0x0000000b:
+      vki_set_assumed_xenversion(vki_xenversion_405);
+	   break;
    case 0x0000000c:
+      vki_set_assumed_xenversion(vki_xenversion_406);
+	   break;
    case 0x0000000d:
+      vki_set_assumed_xenversion(vki_xenversion_407);
+	   break;
    case 0x0000000e:
+      vki_set_assumed_xenversion(vki_xenversion_408);
+	   break;
    case 0x0000000f:
+      vki_set_assumed_xenversion(vki_xenversion_409);
+	   break;
    case 0x00000010:
+      vki_set_assumed_xenversion(vki_xenversion_410);
+	   break;
    case 0x00000011:
+      vki_set_assumed_xenversion(vki_xenversion_411);
+	   break;
    case 0x00000012:
+      vki_set_assumed_xenversion(vki_xenversion_412_or_413);
+	   break;
+   case 0x00000013:
+      vki_set_assumed_xenversion(vki_xenversion_414);
 	   break;
    default:
       bad_intf_version(tid, layout, arrghs, status, flags,
@@ -617,35 +703,53 @@ PRE(sysctl) {
        break;
 
    case VKI_XEN_SYSCTL_getdomaininfolist:
-      switch (sysctl->interface_version)
-      {
+      switch (sysctl->interface_version) {
+      case 0x00000007:
+         PRE_XEN_SYSCTL_READ(getdomaininfolist_00000007, first_domain);
+         PRE_XEN_SYSCTL_READ(getdomaininfolist_00000007, max_domains);
+         PRE_XEN_SYSCTL_READ(getdomaininfolist_00000007, buffer);
+         break;
       case 0x00000008:
-	 PRE_XEN_SYSCTL_READ(getdomaininfolist_00000008, first_domain);
-	 PRE_XEN_SYSCTL_READ(getdomaininfolist_00000008, max_domains);
-	 PRE_XEN_SYSCTL_READ(getdomaininfolist_00000008, buffer);
-	 break;
+         PRE_XEN_SYSCTL_READ(getdomaininfolist_00000008, first_domain);
+         PRE_XEN_SYSCTL_READ(getdomaininfolist_00000008, max_domains);
+         PRE_XEN_SYSCTL_READ(getdomaininfolist_00000008, buffer);
+         break;
       case 0x00000009:
-	 PRE_XEN_SYSCTL_READ(getdomaininfolist_00000009, first_domain);
-	 PRE_XEN_SYSCTL_READ(getdomaininfolist_00000009, max_domains);
-	 PRE_XEN_SYSCTL_READ(getdomaininfolist_00000009, buffer);
-	 break;
       case 0x0000000a:
       case 0x0000000b:
       case 0x0000000c:
       case 0x0000000d:
       case 0x0000000e:
+         PRE_XEN_SYSCTL_READ(getdomaininfolist_00000009, first_domain);
+         PRE_XEN_SYSCTL_READ(getdomaininfolist_00000009, max_domains);
+         PRE_XEN_SYSCTL_READ(getdomaininfolist_00000009, buffer);
+         break;
       case 0x0000000f:
-	 PRE_XEN_SYSCTL_READ(getdomaininfolist_0000000a, first_domain);
-	 PRE_XEN_SYSCTL_READ(getdomaininfolist_0000000a, max_domains);
-	 PRE_XEN_SYSCTL_READ(getdomaininfolist_0000000a, buffer);
-	 break;
       case 0x00000010:
       case 0x00000011:
       case 0x00000012:
-     PRE_XEN_SYSCTL_READ(getdomaininfolist_00000010, first_domain);
-     PRE_XEN_SYSCTL_READ(getdomaininfolist_00000010, max_domains);
-     PRE_XEN_SYSCTL_READ(getdomaininfolist_00000010, buffer);
-	 break;
+      case 0x00000013:
+         switch (vki_assumed_xenversion) {
+         case vki_xenversion_412:
+            PRE_XEN_SYSCTL_READ(getdomaininfolist_0000000f, first_domain);
+            PRE_XEN_SYSCTL_READ(getdomaininfolist_0000000f, max_domains);
+            PRE_XEN_SYSCTL_READ(getdomaininfolist_0000000f, buffer);
+            break;
+         case vki_xenversion_unset:
+         case vki_xenversion_412_or_413:
+            vki_report_unknown_xenversion("VKI_XEN_SYSCTL_getdomaininfolist");
+            /* fallthrough */
+         case vki_xenversion_413:
+         default:
+            PRE_XEN_SYSCTL_READ(getdomaininfolist_00000012, first_domain);
+            PRE_XEN_SYSCTL_READ(getdomaininfolist_00000012, max_domains);
+            PRE_XEN_SYSCTL_READ(getdomaininfolist_00000012, buffer);
+            break;
+         }
+         PRE_XEN_SYSCTL_READ(getdomaininfolist_0000000f, first_domain);
+         PRE_XEN_SYSCTL_READ(getdomaininfolist_0000000f, max_domains);
+         PRE_XEN_SYSCTL_READ(getdomaininfolist_0000000f, buffer);
+         break;
       default:
           VG_(dmsg)("WARNING: XEN_SYSCTL_getdomaininfolist for sysctl version "
                     "%"PRIx32" not implemented yet\n",
@@ -696,18 +800,103 @@ PRE(sysctl) {
       /* No input params */
       break;
 
-   case VKI_XEN_SYSCTL_topologyinfo:
-      PRE_XEN_SYSCTL_READ(topologyinfo, max_cpu_index);
-      PRE_XEN_SYSCTL_READ(topologyinfo, cpu_to_core);
-      PRE_XEN_SYSCTL_READ(topologyinfo, cpu_to_socket);
-      PRE_XEN_SYSCTL_READ(topologyinfo, cpu_to_node);
+   case VKI_XEN_SYSCTL_topologyinfo | VKI_XEN_SYSCTL_cputopoinfo:
+      switch (sysctl->interface_version)
+      {
+      case 0x00000007:
+      case 0x00000008:
+      case 0x00000009:
+      case 0x0000000a:
+      case 0x0000000b:
+         PRE_XEN_SYSCTL_READ(topologyinfo, max_cpu_index);
+         PRE_XEN_SYSCTL_READ(topologyinfo, cpu_to_core);
+         PRE_XEN_SYSCTL_READ(topologyinfo, cpu_to_socket);
+         PRE_XEN_SYSCTL_READ(topologyinfo, cpu_to_node);
+         break;
+      case 0x0000000c:
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
+      case 0x00000012:
+      case 0x00000013:
+         PRE_XEN_SYSCTL_READ(cputopoinfo_0000000c, num_cpus);
+         PRE_XEN_SYSCTL_READ(cputopoinfo_0000000c, cputopo);
+         break;
+      }
       break;
 
    case VKI_XEN_SYSCTL_numainfo:
-      PRE_XEN_SYSCTL_READ(numainfo, max_node_index);
-      PRE_XEN_SYSCTL_READ(numainfo, node_to_memsize);
-      PRE_XEN_SYSCTL_READ(numainfo, node_to_memfree);
-      PRE_XEN_SYSCTL_READ(numainfo, node_to_node_distance);
+      switch (sysctl->interface_version)
+      {
+      case 0x00000008:
+      case 0x00000009:
+      case 0x0000000a:
+      case 0x0000000b:
+         PRE_XEN_SYSCTL_READ(numainfo_00000008, max_node_index);
+         PRE_XEN_SYSCTL_READ(numainfo_00000008, node_to_memsize);
+         PRE_XEN_SYSCTL_READ(numainfo_00000008, node_to_memfree);
+         PRE_XEN_SYSCTL_READ(numainfo_00000008, node_to_node_distance);
+         break;
+      case 0x0000000c:
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
+      case 0x00000012:
+      case 0x00000013:
+         PRE_XEN_SYSCTL_READ(numainfo_0000000c, num_nodes);
+         PRE_XEN_SYSCTL_READ(numainfo_0000000c, meminfo);
+         PRE_XEN_SYSCTL_READ(numainfo_0000000c, distance);
+         break;
+      }
+      break;
+
+   case VKI_XEN_SYSCTL_pcitopoinfo:
+      switch (sysctl->interface_version)
+      {
+      case 0x0000000c:
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
+      case 0x00000012:
+      case 0x00000013:
+         PRE_XEN_SYSCTL_READ(pcitopoinfo_0000000c, num_devs);
+         PRE_XEN_SYSCTL_READ(pcitopoinfo_0000000c, devs);
+         break;
+      }
+      break;
+
+   case VKI_XEN_SYSCTL_get_cpu_featureset:
+      switch (sysctl->interface_version)
+      {
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
+      case 0x00000012:
+      case 0x00000013:
+         PRE_XEN_SYSCTL_READ(cpu_featureset_0000000d, index);
+         PRE_XEN_SYSCTL_READ(cpu_featureset_0000000d, nr_features);
+         break;
+      }
+      break;
+
+   case VKI_XEN_SYSCTL_get_cpu_policy:
+      switch (sysctl->interface_version)
+      {
+      case 0x00000012:
+         PRE_XEN_SYSCTL_READ(get_cpu_policy_00000012, index);
+         PRE_XEN_SYSCTL_READ(get_cpu_policy_00000012, nr_leaves);
+         PRE_XEN_SYSCTL_READ(get_cpu_policy_00000012, nr_msrs);
+         PRE_XEN_SYSCTL_READ(get_cpu_policy_00000012, _rsvd);
+         break;
+      }
       break;
 
    default:
@@ -741,16 +930,40 @@ PRE(domctl)
    switch (domctl->interface_version)
    {
    case 0x00000007:
+      vki_set_assumed_xenversion(vki_xenversion_401);
+	   break;
    case 0x00000008:
+      vki_set_assumed_xenversion(vki_xenversion_402);
+	   break;
    case 0x00000009:
+      vki_set_assumed_xenversion(vki_xenversion_404);
+	   break;
    case 0x0000000a:
+      vki_set_assumed_xenversion(vki_xenversion_405);
+	   break;
    case 0x0000000b:
+      vki_set_assumed_xenversion(vki_xenversion_406_or_407);
+	   break;
    case 0x0000000c:
+      vki_set_assumed_xenversion(vki_xenversion_408);
+	   break;
    case 0x0000000d:
+      vki_set_assumed_xenversion(vki_xenversion_409);
+      break;
+   case 0x0000000e:
+      vki_set_assumed_xenversion(vki_xenversion_410);
+	   break;
    case 0x0000000f:
+      vki_set_assumed_xenversion(vki_xenversion_4101);
+	   break;
    case 0x00000010:
+      vki_set_assumed_xenversion(vki_xenversion_411);
+	   break;
    case 0x00000011:
+      vki_set_assumed_xenversion(vki_xenversion_412);
+	   break;
    case 0x00000012:
+      vki_set_assumed_xenversion(vki_xenversion_413);
 	   break;
    default:
       bad_intf_version(tid, layout, arrghs, status, flags,
@@ -774,13 +987,95 @@ PRE(domctl)
    case VKI_XEN_DOMCTL_getdomaininfo:
    case VKI_XEN_DOMCTL_unpausedomain:
    case VKI_XEN_DOMCTL_resumedomain:
+   case VKI_XEN_DOMCTL_soft_reset:
       /* No input fields. */
       break;
 
    case VKI_XEN_DOMCTL_createdomain:
-      PRE_XEN_DOMCTL_READ(createdomain, ssidref);
-      PRE_XEN_DOMCTL_READ(createdomain, handle);
-      PRE_XEN_DOMCTL_READ(createdomain, flags);
+      switch (domctl->interface_version) {
+      case 0x00000007:
+      case 0x00000008:
+      case 0x00000009:
+      case 0x0000000a:
+         PRE_XEN_DOMCTL_READ(createdomain_00000004, ssidref);
+         PRE_XEN_DOMCTL_READ(createdomain_00000004, handle);
+         PRE_XEN_DOMCTL_READ(createdomain_00000004, flags);
+         break;
+      case 0x0000000b:
+      case 0x0000000c:
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+         switch (vki_assumed_xenversion) {
+         case vki_xenversion_406:
+            PRE_XEN_DOMCTL_READ(createdomain_0000000b, ssidref);
+            PRE_XEN_DOMCTL_READ(createdomain_0000000b, handle);
+            PRE_XEN_DOMCTL_READ(createdomain_0000000b, flags);
+#if defined(__i386__) || defined(__x86_64__)
+            __PRE_XEN_DOMCTL_READ(createdomain_0000000b, createdomain_0000000b, config.dummy);
+#endif
+#if defined(__arm__) || defined(__aarch64__)
+            __PRE_XEN_DOMCTL_READ(createdomain_0000000b, createdomain_0000000b, config.gic_version);
+            __PRE_XEN_DOMCTL_READ(createdomain_0000000b, createdomain_0000000b, config.nr_spis);
+            __PRE_XEN_DOMCTL_READ(createdomain_0000000b, createdomain_0000000b, config.clock_frequency);
+#endif
+            break;
+         case vki_xenversion_unset:
+         case vki_xenversion_406_or_407:
+            vki_report_unknown_xenversion("VKI_XEN_DOMCTL_createdomain");
+            /* fallthrough */
+         case vki_xenversion_407:
+         default:
+            PRE_XEN_DOMCTL_READ(createdomain_0000000c, ssidref);
+            PRE_XEN_DOMCTL_READ(createdomain_0000000c, handle);
+            PRE_XEN_DOMCTL_READ(createdomain_0000000c, flags);
+#if defined(__i386__) || defined(__x86_64__)
+            __PRE_XEN_DOMCTL_READ(createdomain_0000000c, createdomain_0000000c, config.emulation_flags);
+#endif
+#if defined(__arm__) || defined(__aarch64__)
+            __PRE_XEN_DOMCTL_READ(createdomain_0000000c, createdomain_0000000c, config.gic_version);
+            __PRE_XEN_DOMCTL_READ(createdomain_0000000c, createdomain_0000000c, config.nr_spis);
+            __PRE_XEN_DOMCTL_READ(createdomain_0000000c, createdomain_0000000c, config.clock_frequency);
+#endif
+            break;
+         }
+         break;
+      case 0x00000011:
+         PRE_XEN_DOMCTL_READ(createdomain_00000011, ssidref);
+         PRE_XEN_DOMCTL_READ(createdomain_00000011, handle);
+         PRE_XEN_DOMCTL_READ(createdomain_00000011, flags);
+         PRE_XEN_DOMCTL_READ(createdomain_00000011, max_vcpus);
+         PRE_XEN_DOMCTL_READ(createdomain_00000011, max_evtchn_port);
+         PRE_XEN_DOMCTL_READ(createdomain_00000011, max_maptrack_frames);
+#if defined(__i386__) || defined(__x86_64__)
+         __PRE_XEN_DOMCTL_READ(createdomain_00000011, createdomain_00000011, config.emulation_flags);
+#endif
+#if defined(__arm__) || defined(__aarch64__)
+         __PRE_XEN_DOMCTL_READ(createdomain_00000011, createdomain_00000011, config.gic_version);
+         __PRE_XEN_DOMCTL_READ(createdomain_00000011, createdomain_00000011, config.nr_spis);
+         __PRE_XEN_DOMCTL_READ(createdomain_00000011, createdomain_00000011, config.clock_frequency);
+#endif
+         break;
+      case 0x00000012:
+         PRE_XEN_DOMCTL_READ(createdomain_00000012, ssidref);
+         PRE_XEN_DOMCTL_READ(createdomain_00000012, handle);
+         PRE_XEN_DOMCTL_READ(createdomain_00000012, flags);
+         PRE_XEN_DOMCTL_READ(createdomain_00000012, iommu_opts);
+         PRE_XEN_DOMCTL_READ(createdomain_00000012, max_vcpus);
+         PRE_XEN_DOMCTL_READ(createdomain_00000012, max_evtchn_port);
+         PRE_XEN_DOMCTL_READ(createdomain_00000012, max_maptrack_frames);
+#if defined(__i386__) || defined(__x86_64__)
+         __PRE_XEN_DOMCTL_READ(createdomain_00000012, createdomain_00000012, config.emulation_flags);
+#endif
+#if defined(__arm__) || defined(__aarch64__)
+         __PRE_XEN_DOMCTL_READ(createdomain_00000012, createdomain_00000012, config.gic_version);
+         __PRE_XEN_DOMCTL_READ(createdomain_00000012, createdomain_00000012, config.tee_type);
+         __PRE_XEN_DOMCTL_READ(createdomain_00000012, createdomain_00000012, config.nr_spis);
+         __PRE_XEN_DOMCTL_READ(createdomain_00000012, createdomain_00000012, config.clock_frequency);
+#endif
+         break;
+      }
       break;
 
    case VKI_XEN_DOMCTL_gethvmcontext:
@@ -801,30 +1096,66 @@ PRE(domctl)
        break;
 
    case VKI_XEN_DOMCTL_gethvmcontext_partial:
-       __PRE_XEN_DOMCTL_READ(gethvmcontext_partial, hvmcontext_partial_00000007, type);
-       __PRE_XEN_DOMCTL_READ(gethvmcontext_partial, hvmcontext_partial_00000007, instance);
-       __PRE_XEN_DOMCTL_READ(gethvmcontext_partial, hvmcontext_partial_00000007, buffer);
-
-       switch (domctl->u.hvmcontext_partial_00000007.type) {
-       case VKI_HVM_SAVE_CODE(CPU):
-           if ( domctl->u.hvmcontext_partial_00000007.buffer.p )
-                PRE_MEM_WRITE("XEN_DOMCTL_gethvmcontext_partial *buffer",
-                   (Addr)domctl->u.hvmcontext_partial_00000007.buffer.p,
-                   VKI_HVM_SAVE_LENGTH(CPU));
-           break;
-       case VKI_HVM_SAVE_CODE(MTRR):
-           if ( domctl->u.hvmcontext_partial_00000007.buffer.p )
-	        PRE_MEM_WRITE("XEN_DOMCTL_gethvmcontext_partial *buffer",
-		   (Addr)domctl->u.hvmcontext_partial_00000007.buffer.p,
-		   VKI_HVM_SAVE_LENGTH(MTRR));
-           break;
-       default:
-           bad_subop(tid, layout, arrghs, status, flags,
-                         "__HYPERVISOR_domctl_gethvmcontext_partial type",
-                         domctl->u.hvmcontext_partial_00000007.type);
-           break;
-       }
-       break;
+      switch (domctl->interface_version) {
+      case 0x00000007:
+      case 0x00000008:
+      case 0x00000009:
+      case 0x0000000a:
+      case 0x0000000b:
+      case 0x0000000c:
+      case 0x0000000d:
+         __PRE_XEN_DOMCTL_READ(gethvmcontext_partial, hvmcontext_partial_00000005, type);
+         __PRE_XEN_DOMCTL_READ(gethvmcontext_partial, hvmcontext_partial_00000005, instance);
+         __PRE_XEN_DOMCTL_READ(gethvmcontext_partial, hvmcontext_partial_00000005, buffer);
+
+         switch (domctl->u.hvmcontext_partial_00000005.type) {
+         case VKI_HVM_SAVE_CODE(CPU):
+            if ( domctl->u.hvmcontext_partial_00000005.buffer.p )
+               PRE_MEM_WRITE("XEN_DOMCTL_gethvmcontext_partial *buffer",
+                             (Addr)domctl->u.hvmcontext_partial_00000005.buffer.p,
+                             VKI_HVM_SAVE_LENGTH(CPU));
+            break;
+         case VKI_HVM_SAVE_CODE(MTRR):
+            if ( domctl->u.hvmcontext_partial_00000005.buffer.p )
+               PRE_MEM_WRITE("XEN_DOMCTL_gethvmcontext_partial *buffer",
+                             (Addr)domctl->u.hvmcontext_partial_00000005.buffer.p,
+                             VKI_HVM_SAVE_LENGTH(MTRR));
+            break;
+         default:
+            bad_subop(tid, layout, arrghs, status, flags,
+                      "__HYPERVISOR_domctl_gethvmcontext_partial type",
+                      domctl->u.hvmcontext_partial_00000005.type);
+            break;
+         }
+         break;
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
+      case 0x00000012:
+         __PRE_XEN_DOMCTL_READ(gethvmcontext_partial, hvmcontext_partial_0000000e, type);
+         __PRE_XEN_DOMCTL_READ(gethvmcontext_partial, hvmcontext_partial_0000000e, instance);
+         __PRE_XEN_DOMCTL_READ(gethvmcontext_partial, hvmcontext_partial_0000000e, bufsz);
+         __PRE_XEN_DOMCTL_READ(gethvmcontext_partial, hvmcontext_partial_0000000e, buffer);
+
+         switch (domctl->u.hvmcontext_partial_0000000e.type) {
+         case VKI_HVM_SAVE_CODE(CPU):
+            if ( domctl->u.hvmcontext_partial_0000000e.buffer.p )
+               PRE_MEM_WRITE("XEN_DOMCTL_gethvmcontext_partial *buffer", (Addr)domctl->u.hvmcontext_partial_0000000e.buffer.p, VKI_HVM_SAVE_LENGTH(CPU));
+            break;
+         case VKI_HVM_SAVE_CODE(MTRR):
+            if ( domctl->u.hvmcontext_partial_0000000e.buffer.p )
+               PRE_MEM_WRITE("XEN_DOMCTL_gethvmcontext_partial *buffer", (Addr)domctl->u.hvmcontext_partial_0000000e.buffer.p, VKI_HVM_SAVE_LENGTH(MTRR));
+            break;
+         default:
+            bad_subop(tid, layout, arrghs, status, flags,
+                     "__HYPERVISOR_domctl_gethvmcontext_partial type",
+                     domctl->u.hvmcontext_partial_0000000e.type);
+            break;
+         }
+         break;
+      }
+      break;
 
    case VKI_XEN_DOMCTL_max_mem:
       PRE_XEN_DOMCTL_READ(max_mem, max_memkb);
@@ -836,7 +1167,7 @@ PRE(domctl)
 
    case VKI_XEN_DOMCTL_test_assign_device:
       switch (domctl->interface_version) {
-      case 0x00000007: /* pre-4.6 */
+      case 0x00000007:
       case 0x00000008:
       case 0x00000009:
       case 0x0000000a:
@@ -845,11 +1176,6 @@ PRE(domctl)
       case 0x0000000b:
       case 0x0000000c:
       case 0x0000000d:
-      case 0x0000000e:
-      case 0x0000000f:
-      case 0x00000010:
-      case 0x00000011:
-      case 0x00000012:
          __PRE_XEN_DOMCTL_READ(test_assign_device, assign_device_0000000b, dev);
          __PRE_XEN_DOMCTL_READ(test_assign_device, assign_device_0000000b, flag);
          switch (domctl->u.assign_device_0000000b.dev) {
@@ -869,11 +1195,35 @@ PRE(domctl)
             break;
          }
          break;
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
+      case 0x00000012:
+         __PRE_XEN_DOMCTL_READ(test_assign_device, assign_device_0000000e, dev);
+         __PRE_XEN_DOMCTL_READ(test_assign_device, assign_device_0000000e, flags);
+         switch (domctl->u.assign_device_0000000e.dev) {
+         case VKI_XEN_DOMCTL_DEV_PCI:
+            __PRE_XEN_DOMCTL_READ(test_assign_device, assign_device_0000000e, u.pci);
+            break;
+         case VKI_XEN_DOMCTL_DEV_DT:
+            __PRE_XEN_DOMCTL_READ(test_assign_device, assign_device_0000000e, u.dt);
+            PRE_MEM_READ("XEN_DOMTCL_test_assign_device.dt",
+                          (Addr)domctl->u.assign_device_0000000e.u.dt.path.p,
+                          domctl->u.assign_device_0000000e.u.dt.size);
+            break;
+         default:
+            bad_subop(tid, layout, arrghs, status, flags,
+                         "__HYPERVISOR_domctl_test_assign_device dev",
+                         domctl->u.assign_device_0000000e.dev);
+            break;
+         }
+         break;
       }
       break;
    case VKI_XEN_DOMCTL_assign_device:
       switch (domctl->interface_version) {
-      case 0x00000007: /* pre-4.6 */
+      case 0x00000007:
       case 0x00000008:
       case 0x00000009:
       case 0x0000000a:
@@ -882,11 +1232,6 @@ PRE(domctl)
       case 0x0000000b:
       case 0x0000000c:
       case 0x0000000d:
-      case 0x0000000e:
-      case 0x0000000f:
-      case 0x00000010:
-      case 0x00000011:
-      case 0x00000012:
          __PRE_XEN_DOMCTL_READ(assign_device, assign_device_0000000b, dev);
          __PRE_XEN_DOMCTL_READ(assign_device, assign_device_0000000b, flag);
          switch (domctl->u.assign_device_0000000b.dev) {
@@ -906,11 +1251,30 @@ PRE(domctl)
             break;
          }
          break;
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
+      case 0x00000012:
+         __PRE_XEN_DOMCTL_READ(assign_device, assign_device_0000000e, dev);
+         __PRE_XEN_DOMCTL_READ(assign_device, assign_device_0000000e, flags);
+         switch (domctl->u.assign_device_0000000e.dev) {
+         case VKI_XEN_DOMCTL_DEV_PCI:
+            __PRE_XEN_DOMCTL_READ(assign_device, assign_device_0000000e, u.pci);
+            break;
+         case VKI_XEN_DOMCTL_DEV_DT:
+            __PRE_XEN_DOMCTL_READ(assign_device, assign_device_0000000e, u.dt);
+            PRE_MEM_READ("XEN_DOMTCL_assign_device.dt",
+                        (Addr)domctl->u.assign_device_0000000e.u.dt.path.p,
+                        domctl->u.assign_device_0000000e.u.dt.size);
+            break;
+         }
+         break;
       }
       break;
    case VKI_XEN_DOMCTL_deassign_device:
       switch (domctl->interface_version) {
-      case 0x00000007: /* pre-4.6 */
+      case 0x00000007:
       case 0x00000008:
       case 0x00000009:
       case 0x0000000a:
@@ -919,11 +1283,6 @@ PRE(domctl)
       case 0x0000000b:
       case 0x0000000c:
       case 0x0000000d:
-      case 0x0000000e:
-      case 0x0000000f:
-      case 0x00000010:
-      case 0x00000011:
-      case 0x00000012:
          __PRE_XEN_DOMCTL_READ(deassign_device, assign_device_0000000b, dev);
          __PRE_XEN_DOMCTL_READ(deassign_device, assign_device_0000000b, flag);
          switch (domctl->u.assign_device_0000000b.dev) {
@@ -943,12 +1302,31 @@ PRE(domctl)
             break;
          }
          break;
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
+      case 0x00000012:
+         __PRE_XEN_DOMCTL_READ(deassign_device, assign_device_0000000e, dev);
+         __PRE_XEN_DOMCTL_READ(deassign_device, assign_device_0000000e, flags);
+         switch (domctl->u.assign_device_0000000e.dev) {
+         case VKI_XEN_DOMCTL_DEV_PCI:
+            __PRE_XEN_DOMCTL_READ(deassign_device, assign_device_0000000e, u.pci);
+            break;
+         case VKI_XEN_DOMCTL_DEV_DT:
+            __PRE_XEN_DOMCTL_READ(deassign_device, assign_device_0000000e, u.dt);
+            PRE_MEM_READ("XEN_DOMTCL_assign_device.dt",
+                        (Addr)domctl->u.assign_device_0000000e.u.dt.path.p,
+                        domctl->u.assign_device_0000000e.u.dt.size);
+            break;
+         }
+         break;
       }
       break;
 
    case VKI_XEN_DOMCTL_settscinfo:
       switch (domctl->interface_version) {
-      case 0x00000007: /* pre-4.6 */
+      case 0x00000007:
       case 0x00000008:
       case 0x00000009:
       case 0x0000000a:
@@ -995,8 +1373,25 @@ PRE(domctl)
       break;
 
    case VKI_XEN_DOMCTL_settimeoffset:
-       PRE_XEN_DOMCTL_READ(settimeoffset, time_offset_seconds);
-       break;
+      switch (domctl->interface_version) {
+      case 0x00000007:
+      case 0x00000008:
+      case 0x00000009:
+      case 0x0000000a:
+         PRE_XEN_DOMCTL_READ(settimeoffset_00000001, time_offset_seconds);
+         break;
+      case 0x0000000b:
+      case 0x0000000c:
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
+      case 0x00000012:
+         PRE_XEN_DOMCTL_READ(settimeoffset_0000000b, time_offset_seconds);
+         break;
+      }
+      break;
 
    case VKI_XEN_DOMCTL_getvcpuinfo:
       PRE_XEN_DOMCTL_READ(getvcpuinfo, vcpu);
@@ -1320,16 +1715,18 @@ PRE(domctl)
       PRE_XEN_DOMCTL_READ(access_required, access_required);
       break;
 
-   case VKI_XEN_DOMCTL_mem_event_op:
-   //case VKI_XEN_DOMCTL_vm_event_op: /* name change in 4.6 */
+   case VKI_XEN_DOMCTL_mem_event_op | VKI_XEN_DOMCTL_vm_event_op:
       switch (domctl->interface_version) {
-      case 0x00000007: /* pre-4.6 */
-      case 0x00000008:
-      case 0x00000009:
-      case 0x0000000a:
+      case 0x00000007:
          __PRE_XEN_DOMCTL_READ(mem_event_op, mem_event_op_00000007, op);
          __PRE_XEN_DOMCTL_READ(mem_event_op, mem_event_op_00000007, mode);
+         __PRE_XEN_DOMCTL_READ(mem_event_op, mem_event_op_00000007, shared_addr);
+         __PRE_XEN_DOMCTL_READ(mem_event_op, mem_event_op_00000007, ring_addr);
+         __PRE_XEN_DOMCTL_READ(mem_event_op, mem_event_op_00000007, gfn);
          break;
+      case 0x00000008:
+      case 0x00000009:
+      case 0x0000000a:
       case 0x0000000b:
       case 0x0000000c:
       case 0x0000000d:
@@ -1337,8 +1734,8 @@ PRE(domctl)
       case 0x0000000f:
       case 0x00000010:
       case 0x00000011:
-         __PRE_XEN_DOMCTL_READ(vm_event_op, vm_event_op_0000000b, op);
-         __PRE_XEN_DOMCTL_READ(vm_event_op, vm_event_op_0000000b, mode);
+         __PRE_XEN_DOMCTL_READ(mem_event_op, vm_event_op_00000008, op);
+         __PRE_XEN_DOMCTL_READ(mem_event_op, vm_event_op_00000008, mode);
          break;
       case 0x00000012:
          __PRE_XEN_DOMCTL_READ(vm_event_op, vm_event_op_00000012, op);
@@ -1371,12 +1768,7 @@ PRE(domctl)
 
    case VKI_XEN_DOMCTL_monitor_op:
       switch (domctl->interface_version) {
-      case 0x000000b:
-      case 0x000000c:
-      case 0x000000d:
-      case 0x000000e:
-      case 0x000000f:
-      case 0x0000010:
+      case 0x0000000b:
           if (domctl->u.monitor_op_0000000b.op == VKI_XEN_DOMCTL_MONITOR_OP_ENABLE ||
               domctl->u.monitor_op_0000000b.op == VKI_XEN_DOMCTL_MONITOR_OP_DISABLE) {
              switch (domctl->u.monitor_op_0000000b.event) {
@@ -1389,31 +1781,105 @@ PRE(domctl)
              case VKI_XEN_DOMCTL_MONITOR_EVENT_GUEST_REQUEST:
                 __PRE_XEN_DOMCTL_READ(monitor_op, monitor_op_0000000b, u.guest_request);
                 break;
-             case VKI_XEN_DOMCTL_MONITOR_OP_GET_CAPABILITIES:
+             }
+          }
+
+         break;
+      case 0x0000000c:
+      case 0x0000000d:
+         if (domctl->u.monitor_op_0000000c.op == VKI_XEN_DOMCTL_MONITOR_OP_ENABLE ||
+            domctl->u.monitor_op_0000000c.op == VKI_XEN_DOMCTL_MONITOR_OP_DISABLE) {
+            switch (domctl->u.monitor_op_0000000c.event) {
+            case VKI_XEN_DOMCTL_MONITOR_EVENT_WRITE_CTRLREG:
+               __PRE_XEN_DOMCTL_READ(monitor_op, monitor_op_0000000c, u.mov_to_cr);
+               break;
+            case VKI_XEN_DOMCTL_MONITOR_EVENT_MOV_TO_MSR:
+               __PRE_XEN_DOMCTL_READ(monitor_op, monitor_op_0000000c, u.mov_to_msr);
+               break;
+            case VKI_XEN_DOMCTL_MONITOR_EVENT_GUEST_REQUEST:
+               __PRE_XEN_DOMCTL_READ(monitor_op, monitor_op_0000000c, u.guest_request);
+               break;
+            case VKI_XEN_DOMCTL_MONITOR_EVENT_DEBUG_EXCEPTION:
+               __PRE_XEN_DOMCTL_READ(monitor_op, monitor_op_0000000c, u.debug_exception);
+               break;
+            }
+         }
+         break;
+      case 0x0000000e:
+      case 0x0000000f:
+          if (domctl->u.monitor_op_0000000e.op == VKI_XEN_DOMCTL_MONITOR_OP_ENABLE ||
+              domctl->u.monitor_op_0000000e.op == VKI_XEN_DOMCTL_MONITOR_OP_DISABLE) {
+             switch (domctl->u.monitor_op_0000000e.event) {
+             case VKI_XEN_DOMCTL_MONITOR_EVENT_WRITE_CTRLREG:
+                __PRE_XEN_DOMCTL_READ(monitor_op, monitor_op_0000000e, u.mov_to_cr);
+                break;
+             case VKI_XEN_DOMCTL_MONITOR_EVENT_MOV_TO_MSR:
+                __PRE_XEN_DOMCTL_READ(monitor_op, monitor_op_0000000e, u.mov_to_msr);
+                break;
+             case VKI_XEN_DOMCTL_MONITOR_EVENT_GUEST_REQUEST:
+                __PRE_XEN_DOMCTL_READ(monitor_op, monitor_op_0000000e, u.guest_request);
+                break;
+             case VKI_XEN_DOMCTL_MONITOR_EVENT_DEBUG_EXCEPTION:
+                __PRE_XEN_DOMCTL_READ(monitor_op, monitor_op_0000000e, u.debug_exception);
                 break;
              }
           }
 
          break;
+      case 0x00000010:
       case 0x0000011:
       case 0x0000012:
-          if (domctl->u.monitor_op_00000011.op == VKI_XEN_DOMCTL_MONITOR_OP_ENABLE ||
-              domctl->u.monitor_op_00000011.op == VKI_XEN_DOMCTL_MONITOR_OP_DISABLE) {
-             switch (domctl->u.monitor_op_00000011.event) {
+          if (domctl->u.monitor_op_00000010.op == VKI_XEN_DOMCTL_MONITOR_OP_ENABLE ||
+              domctl->u.monitor_op_00000010.op == VKI_XEN_DOMCTL_MONITOR_OP_DISABLE) {
+             switch (domctl->u.monitor_op_00000010.event) {
              case VKI_XEN_DOMCTL_MONITOR_EVENT_WRITE_CTRLREG:
-                __PRE_XEN_DOMCTL_READ(monitor_op, monitor_op_00000011, u.mov_to_cr);
+                __PRE_XEN_DOMCTL_READ(monitor_op, monitor_op_00000010, u.mov_to_cr);
                 break;
              case VKI_XEN_DOMCTL_MONITOR_EVENT_MOV_TO_MSR:
-                __PRE_XEN_DOMCTL_READ(monitor_op, monitor_op_00000011, u.mov_to_msr);
+                __PRE_XEN_DOMCTL_READ(monitor_op, monitor_op_00000010, u.mov_to_msr);
                 break;
              case VKI_XEN_DOMCTL_MONITOR_EVENT_GUEST_REQUEST:
-                __PRE_XEN_DOMCTL_READ(monitor_op, monitor_op_00000011, u.guest_request);
+                __PRE_XEN_DOMCTL_READ(monitor_op, monitor_op_00000010, u.guest_request);
                 break;
-             case VKI_XEN_DOMCTL_MONITOR_OP_GET_CAPABILITIES:
+             case VKI_XEN_DOMCTL_MONITOR_EVENT_DEBUG_EXCEPTION:
+                __PRE_XEN_DOMCTL_READ(monitor_op, monitor_op_00000010, u.debug_exception);
                 break;
              }
           }
+         break;
+      }
+      break;
+
+   case VKI_XEN_DOMCTL_set_gnttab_limits:
+      PRE_XEN_DOMCTL_READ(set_gnttab_limits_0000000e, grant_frames);
+      PRE_XEN_DOMCTL_READ(set_gnttab_limits_0000000e, maptrack_frames);
+      break;
 
+   case VKI_XEN_DOMCTL_get_cpu_policy:
+      switch (domctl->interface_version) {
+      case 0x00000011:
+      case 0x00000012:
+         PRE_XEN_DOMCTL_READ(cpu_policy_00000011, nr_leaves);
+         PRE_XEN_DOMCTL_READ(cpu_policy_00000011, nr_msrs);
+         break;
+      }
+      break;
+
+   case VKI_XEN_DOMCTL_set_cpu_policy:
+      switch (domctl->interface_version) {
+      case 0x00000012:
+         PRE_XEN_DOMCTL_READ(cpu_policy_00000012, nr_leaves);
+         PRE_XEN_DOMCTL_READ(cpu_policy_00000012, nr_msrs);
+         if (domctl->u.cpu_policy_00000012.cpuid_policy.p)
+            PRE_MEM_READ("XEN_DOMCTL_set_cpu_policy_00000012 *u.cpu_policy_00000012.cpuid_policy.p",
+                         (Addr)domctl->u.cpu_policy_00000012.cpuid_policy.p,
+                         sizeof(vki_xen_cpuid_leaf_00000012_t) *
+                         domctl->u.cpu_policy_00000012.nr_leaves);
+         if (domctl->u.cpu_policy_00000012.msr_policy.p)
+            PRE_MEM_READ("XEN_DOMCTL_set_cpu_policy_00000012 *u.cpu_policy_00000012.msr_policy.p",
+                         (Addr)domctl->u.cpu_policy_00000012.msr_policy.p,
+                         sizeof(vki_xen_msr_entry_00000012_t) *
+                         domctl->u.cpu_policy_00000012.nr_msrs);
          break;
       }
       break;
@@ -1511,13 +1977,28 @@ PRE(hvm_op)
       break;
 
    case VKI_XEN_HVMOP_inject_trap:
-      PRE_XEN_HVMOP_READ(inject_trap, domid);
-      PRE_XEN_HVMOP_READ(inject_trap, vcpuid);
-      PRE_XEN_HVMOP_READ(inject_trap, vector);
-      PRE_XEN_HVMOP_READ(inject_trap, type);
-      PRE_XEN_HVMOP_READ(inject_trap, error_code);
-      PRE_XEN_HVMOP_READ(inject_trap, insn_len);
-      PRE_XEN_HVMOP_READ(inject_trap, cr2);
+      switch (vki_assumed_xenversion) {
+         case vki_xenversion_401:
+         PRE_XEN_HVMOP_READ(inject_trap_0401, domid);
+         PRE_XEN_HVMOP_READ(inject_trap_0401, vcpuid);
+         PRE_XEN_HVMOP_READ(inject_trap_0401, trap);
+         PRE_XEN_HVMOP_READ(inject_trap_0401, error_code);
+         PRE_XEN_HVMOP_READ(inject_trap_0401, cr2);
+         break;
+         case vki_xenversion_unset:
+            vki_report_unknown_xenversion("VKI_XEN_HVMOP_inject_trap");
+            /* fallthrough */
+         case vki_xenversion_402:
+         default:
+         PRE_XEN_HVMOP_READ(inject_trap_0402, domid);
+         PRE_XEN_HVMOP_READ(inject_trap_0402, vcpuid);
+         PRE_XEN_HVMOP_READ(inject_trap_0402, vector);
+         PRE_XEN_HVMOP_READ(inject_trap_0402, type);
+         PRE_XEN_HVMOP_READ(inject_trap_0402, error_code);
+         PRE_XEN_HVMOP_READ(inject_trap_0402, insn_len);
+         PRE_XEN_HVMOP_READ(inject_trap_0402, cr2);
+         break;
+      }
       break;
 
    case VKI_XEN_HVMOP_altp2m: {
@@ -1616,6 +2097,16 @@ PRE(tmem_op)
 #undef __PRE_XEN_TMEMOP_READ
 }
 
+PRE(dm_op)
+{
+   unsigned int domid = ARG1, num = ARG2;
+   struct vki_xen_privcmd_dm_op_buf *args = (void *)(ARG3);
+
+   PRINT("__HYPERVISOR_dm_op ( %u, %u, %p )", domid, num, args);
+
+   PRE_MEM_READ("__HYPERVISOR_dm_op ubuf", (Addr)args, sizeof(*args) * num);
+}
+
 POST(memory_op)
 {
    switch (ARG1) {
@@ -1625,6 +2116,7 @@ POST(memory_op)
    case VKI_XENMEM_claim_pages:
    case VKI_XENMEM_maximum_gpfn:
    case VKI_XENMEM_remove_from_physmap:
+   case VKI_XENMEM_set_pod_target:
    case VKI_XENMEM_access_op:
       /* No outputs */
       break;
@@ -1669,6 +2161,15 @@ POST(memory_op)
    case VKI_XENMEM_get_sharing_shared_pages:
        /* No outputs */
        break;
+   case VKI_XENMEM_get_pod_target: {
+      struct vki_xen_pod_target *arg =
+         (struct vki_xen_pod_target *)ARG2;
+      POST_MEM_WRITE((Addr)&arg->tot_pages, sizeof(arg->tot_pages));
+      POST_MEM_WRITE((Addr)&arg->pod_cache_pages, sizeof(arg->pod_cache_pages));
+      POST_MEM_WRITE((Addr)&arg->pod_entries, sizeof(arg->pod_entries));
+      }
+      break;
+
    }
 }
 
@@ -1794,6 +2295,9 @@ POST(xen_version)
    case VKI_XENVER_commandline:
       POST_MEM_WRITE((Addr)ARG2, sizeof(vki_xen_commandline_t));
       break;
+   case VKI_XENVER_build_id:
+      POST_MEM_WRITE((Addr)ARG2, sizeof(struct vki_xen_build_id));
+      break;
    }
 }
 
@@ -1830,6 +2334,7 @@ POST(sysctl)
    case 0x00000010:
    case 0x00000011:
    case 0x00000012:
+   case 0x00000013:
 	   break;
    default:
       return;
@@ -1848,39 +2353,58 @@ POST(sysctl)
        break;
 
    case VKI_XEN_SYSCTL_getdomaininfolist:
-      switch (sysctl->interface_version)
-      {
+      switch (sysctl->interface_version) {
+      case 0x00000007:
+         POST_XEN_SYSCTL_WRITE(getdomaininfolist_00000007, num_domains);
+         if (sysctl->u.getdomaininfolist_00000007.num_domains > 0)
+            POST_MEM_WRITE((Addr)sysctl->u.getdomaininfolist_00000007.buffer.p,
+               sizeof(*sysctl->u.getdomaininfolist_00000007.buffer.p) *
+               sysctl->u.getdomaininfolist_00000007.num_domains);
+         break;
       case 0x00000008:
-	 POST_XEN_SYSCTL_WRITE(getdomaininfolist_00000008, num_domains);
-	 POST_MEM_WRITE((Addr)sysctl->u.getdomaininfolist_00000008.buffer.p,
-			sizeof(*sysctl->u.getdomaininfolist_00000008.buffer.p)
-			* sysctl->u.getdomaininfolist_00000008.num_domains);
-	 break;
+         POST_XEN_SYSCTL_WRITE(getdomaininfolist_00000008, num_domains);
+         if (sysctl->u.getdomaininfolist_00000008.num_domains > 0)
+            POST_MEM_WRITE((Addr)sysctl->u.getdomaininfolist_00000008.buffer.p,
+               sizeof(*sysctl->u.getdomaininfolist_00000008.buffer.p) *
+               sysctl->u.getdomaininfolist_00000008.num_domains);
+         break;
       case 0x00000009:
-	 POST_XEN_SYSCTL_WRITE(getdomaininfolist_00000009, num_domains);
-	 POST_MEM_WRITE((Addr)sysctl->u.getdomaininfolist_00000009.buffer.p,
-			sizeof(*sysctl->u.getdomaininfolist_00000009.buffer.p)
-			* sysctl->u.getdomaininfolist_00000009.num_domains);
-	 break;
       case 0x0000000a:
       case 0x0000000b:
       case 0x0000000c:
       case 0x0000000d:
       case 0x0000000e:
+         POST_XEN_SYSCTL_WRITE(getdomaininfolist_00000009, num_domains);
+         if (sysctl->u.getdomaininfolist_00000009.num_domains > 0)
+            POST_MEM_WRITE((Addr)sysctl->u.getdomaininfolist_00000009.buffer.p,
+               sizeof(*sysctl->u.getdomaininfolist_00000009.buffer.p) *
+               sysctl->u.getdomaininfolist_00000009.num_domains);
+         break;
       case 0x0000000f:
-	 POST_XEN_SYSCTL_WRITE(getdomaininfolist_0000000a, num_domains);
-	 POST_MEM_WRITE((Addr)sysctl->u.getdomaininfolist_0000000a.buffer.p,
-			sizeof(*sysctl->u.getdomaininfolist_0000000a.buffer.p)
-			* sysctl->u.getdomaininfolist_0000000a.num_domains);
-	 break;
       case 0x00000010:
       case 0x00000011:
       case 0x00000012:
-	 POST_XEN_SYSCTL_WRITE(getdomaininfolist_00000010, num_domains);
-	 POST_MEM_WRITE((Addr)sysctl->u.getdomaininfolist_00000010.buffer.p,
-			sizeof(*sysctl->u.getdomaininfolist_00000010.buffer.p)
-			* sysctl->u.getdomaininfolist_00000010.num_domains);
-	 break;
+      case 0x00000013:
+         switch (vki_assumed_xenversion) {
+         case vki_xenversion_412:
+            POST_XEN_SYSCTL_WRITE(getdomaininfolist_0000000f, num_domains);
+            if (sysctl->u.getdomaininfolist_0000000f.num_domains > 0)
+               POST_MEM_WRITE((Addr)sysctl->u.getdomaininfolist_0000000f.buffer.p,
+                  sizeof(*sysctl->u.getdomaininfolist_0000000f.buffer.p) *
+                  sysctl->u.getdomaininfolist_0000000f.num_domains);
+            break;
+         case vki_xenversion_unset:
+         case vki_xenversion_412_or_413:
+         case vki_xenversion_413:
+         default:
+            POST_XEN_SYSCTL_WRITE(getdomaininfolist_00000012, num_domains);
+            if (sysctl->u.getdomaininfolist_00000012.num_domains > 0)
+               POST_MEM_WRITE((Addr)sysctl->u.getdomaininfolist_00000012.buffer.p,
+                  sizeof(*sysctl->u.getdomaininfolist_00000012.buffer.p) *
+                  sysctl->u.getdomaininfolist_00000012.num_domains);
+            break;
+         }
+         break;
       }
       break;
 
@@ -1942,6 +2466,7 @@ POST(sysctl)
       case 0x00000010:
       case 0x00000011:
       case 0x00000012:
+      case 0x00000013:
          POST_XEN_SYSCTL_WRITE(physinfo_00000010, threads_per_core);
          POST_XEN_SYSCTL_WRITE(physinfo_00000010, cores_per_socket);
          POST_XEN_SYSCTL_WRITE(physinfo_00000010, nr_cpus);
@@ -1959,27 +2484,124 @@ POST(sysctl)
       }
       break;
 
-   case VKI_XEN_SYSCTL_topologyinfo:
-      POST_XEN_SYSCTL_WRITE(topologyinfo, max_cpu_index);
-      if (sysctl->u.topologyinfo.cpu_to_core.p)
-         POST_MEM_WRITE((Addr)sysctl->u.topologyinfo.cpu_to_core.p,
-                     sizeof(uint32_t) * sysctl->u.topologyinfo.max_cpu_index);
-      if (sysctl->u.topologyinfo.cpu_to_socket.p)
-         POST_MEM_WRITE((Addr)sysctl->u.topologyinfo.cpu_to_socket.p,
-                     sizeof(uint32_t) * sysctl->u.topologyinfo.max_cpu_index);
-      if (sysctl->u.topologyinfo.cpu_to_node.p)
-         POST_MEM_WRITE((Addr)sysctl->u.topologyinfo.cpu_to_node.p,
-                     sizeof(uint32_t) * sysctl->u.topologyinfo.max_cpu_index);
+   case VKI_XEN_SYSCTL_topologyinfo | VKI_XEN_SYSCTL_cputopoinfo:
+      switch (sysctl->interface_version)
+      {
+      case 0x00000007:
+      case 0x00000008:
+      case 0x00000009:
+      case 0x0000000a:
+      case 0x0000000b:
+         POST_XEN_SYSCTL_WRITE(topologyinfo, max_cpu_index);
+         if (sysctl->u.topologyinfo.cpu_to_core.p)
+            POST_MEM_WRITE((Addr)sysctl->u.topologyinfo.cpu_to_core.p,
+                           sizeof(uint32_t) * sysctl->u.topologyinfo.max_cpu_index);
+         if (sysctl->u.topologyinfo.cpu_to_socket.p)
+            POST_MEM_WRITE((Addr)sysctl->u.topologyinfo.cpu_to_socket.p,
+                           sizeof(uint32_t) * sysctl->u.topologyinfo.max_cpu_index);
+         if (sysctl->u.topologyinfo.cpu_to_node.p)
+            POST_MEM_WRITE((Addr)sysctl->u.topologyinfo.cpu_to_node.p,
+                           sizeof(uint32_t) * sysctl->u.topologyinfo.max_cpu_index);
+         break;
+      case 0x0000000c:
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
+      case 0x00000012:
+      case 0x00000013:
+         POST_XEN_SYSCTL_WRITE(cputopoinfo_0000000c, num_cpus);
+         if (sysctl->u.cputopoinfo_0000000c.cputopo.p)
+            POST_MEM_WRITE((Addr)sysctl->u.cputopoinfo_0000000c.cputopo.p,
+                           sizeof(vki_xen_sysctl_cputopo_0000000c_t) * sysctl->u.cputopoinfo_0000000c.num_cpus);
+         break;
+      }
       break;
 
    case VKI_XEN_SYSCTL_numainfo:
-      POST_XEN_SYSCTL_WRITE(numainfo, max_node_index);
-      POST_MEM_WRITE((Addr)sysctl->u.numainfo.node_to_memsize.p,
-                     sizeof(uint64_t) * sysctl->u.numainfo.max_node_index);
-      POST_MEM_WRITE((Addr)sysctl->u.numainfo.node_to_memfree.p,
-                     sizeof(uint64_t) * sysctl->u.numainfo.max_node_index);
-      POST_MEM_WRITE((Addr)sysctl->u.numainfo.node_to_node_distance.p,
-                     sizeof(uint32_t) * sysctl->u.numainfo.max_node_index);
+      switch (sysctl->interface_version)
+      {
+      case 0x00000008:
+      case 0x00000009:
+      case 0x0000000a:
+      case 0x0000000b:
+         POST_XEN_SYSCTL_WRITE(numainfo_00000008, max_node_index);
+         POST_MEM_WRITE((Addr)sysctl->u.numainfo_00000008.node_to_memsize.p,
+                        sizeof(uint64_t) * sysctl->u.numainfo_00000008.max_node_index);
+         POST_MEM_WRITE((Addr)sysctl->u.numainfo_00000008.node_to_memfree.p,
+                        sizeof(uint64_t) * sysctl->u.numainfo_00000008.max_node_index);
+         POST_MEM_WRITE((Addr)sysctl->u.numainfo_00000008.node_to_node_distance.p,
+                        sizeof(uint32_t) *
+                        (sysctl->u.numainfo_00000008.max_node_index * sysctl->u.numainfo_00000008.max_node_index));
+         break;
+      case 0x0000000c:
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
+      case 0x00000012:
+      case 0x00000013:
+         POST_XEN_SYSCTL_WRITE(numainfo_0000000c, num_nodes);
+         POST_MEM_WRITE((Addr)sysctl->u.numainfo_0000000c.meminfo.p,
+                        sizeof(uint64_t) * sysctl->u.numainfo_0000000c.num_nodes);
+         POST_MEM_WRITE((Addr)sysctl->u.numainfo_0000000c.distance.p,
+                        sizeof(uint32_t) *
+			(sysctl->u.numainfo_0000000c.num_nodes * sysctl->u.numainfo_0000000c.num_nodes));
+         break;
+      }
+      break;
+
+   case VKI_XEN_SYSCTL_pcitopoinfo:
+      switch (sysctl->interface_version)
+      {
+      case 0x0000000c:
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
+      case 0x00000012:
+      case 0x00000013:
+         POST_XEN_SYSCTL_WRITE(pcitopoinfo_0000000c, num_devs);
+         POST_MEM_WRITE((Addr)sysctl->u.pcitopoinfo_0000000c.nodes.p,
+                        sizeof(uint32_t) *  sysctl->u.pcitopoinfo_0000000c.num_devs);
+         break;
+      }
+      break;
+
+   case VKI_XEN_SYSCTL_get_cpu_featureset:
+      switch (sysctl->interface_version)
+      {
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
+      case 0x00000012:
+      case 0x00000013:
+         POST_XEN_SYSCTL_WRITE(cpu_featureset_0000000d, nr_features);
+         POST_MEM_WRITE((Addr)sysctl->u.cpu_featureset_0000000d.features.p,
+                        sizeof(uint32_t) *  sysctl->u.cpu_featureset_0000000d.nr_features);
+         break;
+      }
+      break;
+
+   case VKI_XEN_SYSCTL_get_cpu_policy:
+      switch (sysctl->interface_version)
+      {
+      case 0x00000012:
+         POST_XEN_SYSCTL_WRITE(get_cpu_policy_00000012, index);
+         POST_XEN_SYSCTL_WRITE(get_cpu_policy_00000012, nr_leaves);
+         POST_XEN_SYSCTL_WRITE(get_cpu_policy_00000012, nr_msrs);
+         POST_XEN_SYSCTL_WRITE(get_cpu_policy_00000012, _rsvd);
+         POST_MEM_WRITE((Addr)sysctl->u.get_cpu_policy_00000012.cpuid_policy.p,
+                        sizeof(vki_xen_cpuid_leaf_00000012_t) *  sysctl->u.get_cpu_policy_00000012.nr_leaves);
+         POST_MEM_WRITE((Addr)sysctl->u.get_cpu_policy_00000012.msr_policy.p,
+                        sizeof(vki_xen_msr_entry_00000012_t) *  sysctl->u.get_cpu_policy_00000012.nr_msrs);
+         break;
+      }
       break;
 
    /* No outputs */
@@ -2045,6 +2667,7 @@ POST(domctl){
    case VKI_XEN_DOMCTL_resumedomain:
    case VKI_XEN_DOMCTL_set_vcpu_msrs:
    case VKI_XEN_DOMCTL_set_access_required:
+   case VKI_XEN_DOMCTL_soft_reset:
       /* No output fields */
       break;
 
@@ -2058,7 +2681,7 @@ POST(domctl){
 
    case VKI_XEN_DOMCTL_gettscinfo:
       switch (domctl->interface_version) {
-      case 0x00000007: /* pre-4.6 */
+      case 0x00000007:
       case 0x00000008:
       case 0x00000009:
       case 0x0000000a:
@@ -2102,14 +2725,34 @@ POST(domctl){
        break;
 
    case VKI_XEN_DOMCTL_gethvmcontext_partial:
-       switch (domctl->u.hvmcontext_partial_00000007.type) {
-       case VKI_HVM_SAVE_CODE(CPU):
-           if ( domctl->u.hvmcontext_partial_00000007.buffer.p )
-                POST_MEM_WRITE((Addr)domctl->u.hvmcontext_partial_00000007.buffer.p,
-                   VKI_HVM_SAVE_LENGTH(CPU));
-           break;
-       }
-       break;
+      switch (domctl->interface_version) {
+      case 0x00000007:
+      case 0x00000008:
+      case 0x00000009:
+      case 0x0000000a:
+      case 0x0000000b:
+      case 0x0000000c:
+      case 0x0000000d:
+         switch (domctl->u.hvmcontext_partial_00000005.type) {
+         case VKI_HVM_SAVE_CODE(CPU):
+            if ( domctl->u.hvmcontext_partial_00000005.buffer.p )
+               POST_MEM_WRITE((Addr)domctl->u.hvmcontext_partial_00000005.buffer.p, VKI_HVM_SAVE_LENGTH(CPU));
+            break;
+         }
+         break;
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000011:
+      case 0x00000012:
+         switch (domctl->u.hvmcontext_partial_0000000e.type) {
+         case VKI_HVM_SAVE_CODE(CPU):
+            if ( domctl->u.hvmcontext_partial_0000000e.buffer.p )
+               POST_MEM_WRITE((Addr)domctl->u.hvmcontext_partial_0000000e.buffer.p, VKI_HVM_SAVE_LENGTH(CPU));
+            break;
+         }
+         break;
+      }
+      break;
 
    case VKI_XEN_DOMCTL_scheduler_op:
       if ( domctl->u.scheduler_op.cmd == VKI_XEN_DOMCTL_SCHEDOP_getinfo ) {
@@ -2209,10 +2852,6 @@ POST(domctl){
       case 0x0000000c:
       case 0x0000000d:
       case 0x0000000e:
-      case 0x0000000f:
-      case 0x00000010:
-      case 0x00000011:
-      case 0x00000012:
 	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, domain);
 	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, flags);
 	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, tot_pages);
@@ -2228,6 +2867,34 @@ POST(domctl){
 	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, handle);
 	 POST_XEN_DOMCTL_WRITE(getdomaininfo_00000009, cpupool);
       break;
+      case 0x0000000f:
+      case 0x00000010:
+      case 0x00000011:
+      case 0x00000012:
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, domain);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, flags);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, tot_pages);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, max_pages);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, outstanding_pages);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, shr_pages);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, paged_pages);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, shared_info_frame);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, cpu_time);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, nr_online_vcpus);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, max_vcpu_id);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, ssidref);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, handle);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, cpupool);
+         POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, arch);
+#if defined(__i386__) || defined(__x86_64__)
+         __POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, getdomaininfo_0000000f, arch.emulation_flags);
+#endif
+#if defined(__arm__) || defined(__aarch64__)
+         __POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, getdomaininfo_0000000f, arch.gic_version);
+         __POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, getdomaininfo_0000000f, arch.nr_spis);
+         __POST_XEN_DOMCTL_WRITE(getdomaininfo_0000000f, getdomaininfo_0000000f, arch.clock_frequency);
+#endif
+         break;
       }
       break;
    case VKI_XEN_DOMCTL_getvcpucontext:
@@ -2265,6 +2932,14 @@ POST(domctl){
            break;
 
        case 0x00000009:
+       case 0x0000000a:
+      case 0x0000000b:
+      case 0x0000000c:
+      case 0x0000000d:
+      case 0x0000000e:
+      case 0x0000000f:
+      case 0x00000011:
+      case 0x00000012:
            __POST_XEN_DOMCTL_WRITE(get_ext_vcpucontext, ext_vcpucontext_00000009, size);
 #if defined(__i386__) || defined(__x86_64__)
            __POST_XEN_DOMCTL_WRITE(get_ext_vcpucontext, ext_vcpucontext_00000009,
@@ -2331,15 +3006,13 @@ POST(domctl){
                         domctl->u.vcpu_msrs.msr_count);
       break;
 
-   case VKI_XEN_DOMCTL_mem_event_op:
-   //case VKI_XEN_DOMCTL_vm_event_op: /* name change in 4.6 */
+   case VKI_XEN_DOMCTL_mem_event_op | VKI_XEN_DOMCTL_vm_event_op:
       switch (domctl->interface_version) {
-      case 0x00000007: /* pre-4.6 */
+      case 0x00000007:
+         break;
       case 0x00000008:
       case 0x00000009:
       case 0x0000000a:
-         __POST_XEN_DOMCTL_WRITE(mem_event_op, mem_event_op_00000007, port);
-         break;
       case 0x0000000b:
       case 0x0000000c:
       case 0x0000000d:
@@ -2347,7 +3020,7 @@ POST(domctl){
       case 0x0000000f:
       case 0x00000010:
       case 0x00000011:
-         __POST_XEN_DOMCTL_WRITE(vm_event_op, vm_event_op_0000000b, port);
+         __POST_XEN_DOMCTL_WRITE(mem_event_op, vm_event_op_00000008, port);
          break;
       case 0x00000012:
          __POST_XEN_DOMCTL_WRITE(vm_event_op, vm_event_op_00000012, u.enable.port);
@@ -2357,7 +3030,7 @@ POST(domctl){
 
    case VKI_XEN_DOMCTL_monitor_op:
       switch (domctl->interface_version) {
-      case 0x000000b:
+      case 0x0000000b:
           if (domctl->u.monitor_op_0000000b.op == VKI_XEN_DOMCTL_MONITOR_OP_GET_CAPABILITIES) {
              switch(domctl->u.monitor_op_0000000b.event) {
              case VKI_XEN_DOMCTL_MONITOR_EVENT_WRITE_CTRLREG:
@@ -2371,26 +3044,103 @@ POST(domctl){
                 break;
              }
           }
+         break;
+      case 0x0000000c:
+      case 0x0000000d:
+         if (domctl->u.monitor_op_0000000c.op == VKI_XEN_DOMCTL_MONITOR_OP_GET_CAPABILITIES) {
+            switch(domctl->u.monitor_op_0000000c.event) {
+            case VKI_XEN_DOMCTL_MONITOR_EVENT_WRITE_CTRLREG:
+               __POST_XEN_DOMCTL_WRITE(monitor_op, monitor_op_0000000c, u.mov_to_cr);
+               break;
+            case VKI_XEN_DOMCTL_MONITOR_EVENT_MOV_TO_MSR:
+               __POST_XEN_DOMCTL_WRITE(monitor_op, monitor_op_0000000c, u.mov_to_msr);
+               break;
+            case VKI_XEN_DOMCTL_MONITOR_EVENT_GUEST_REQUEST:
+               __POST_XEN_DOMCTL_WRITE(monitor_op, monitor_op_0000000c, u.guest_request);
+               break;
+            case VKI_XEN_DOMCTL_MONITOR_EVENT_DEBUG_EXCEPTION:
+               __POST_XEN_DOMCTL_WRITE(monitor_op, monitor_op_0000000c, u.debug_exception);
+               break;
+            }
+         }
+         break;
+      case 0x0000000e:
+      case 0x0000000f:
+          if (domctl->u.monitor_op_0000000e.op == VKI_XEN_DOMCTL_MONITOR_OP_GET_CAPABILITIES) {
+             switch(domctl->u.monitor_op_0000000e.event) {
+             case VKI_XEN_DOMCTL_MONITOR_EVENT_WRITE_CTRLREG:
+                __POST_XEN_DOMCTL_WRITE(monitor_op, monitor_op_0000000e, u.mov_to_cr);
+                break;
+             case VKI_XEN_DOMCTL_MONITOR_EVENT_MOV_TO_MSR:
+                __POST_XEN_DOMCTL_WRITE(monitor_op, monitor_op_0000000e, u.mov_to_msr);
+                break;
+             case VKI_XEN_DOMCTL_MONITOR_EVENT_GUEST_REQUEST:
+                __POST_XEN_DOMCTL_WRITE(monitor_op, monitor_op_0000000e, u.guest_request);
+                break;
+             case VKI_XEN_DOMCTL_MONITOR_EVENT_DEBUG_EXCEPTION:
+                __POST_XEN_DOMCTL_WRITE(monitor_op, monitor_op_0000000e, u.debug_exception);
+                break;
+             }
+          }
 
          break;
+      case 0x0000010:
       case 0x0000011:
-          if (domctl->u.monitor_op_00000011.op == VKI_XEN_DOMCTL_MONITOR_OP_GET_CAPABILITIES) {
-             switch(domctl->u.monitor_op_00000011.event) {
+      case 0x00000012:
+          if (domctl->u.monitor_op_00000010.op == VKI_XEN_DOMCTL_MONITOR_OP_GET_CAPABILITIES) {
+             switch(domctl->u.monitor_op_00000010.event) {
              case VKI_XEN_DOMCTL_MONITOR_EVENT_WRITE_CTRLREG:
-                __POST_XEN_DOMCTL_WRITE(monitor_op, monitor_op_00000011, u.mov_to_cr);
+                __POST_XEN_DOMCTL_WRITE(monitor_op, monitor_op_00000010, u.mov_to_cr);
                 break;
              case VKI_XEN_DOMCTL_MONITOR_EVENT_MOV_TO_MSR:
-                __POST_XEN_DOMCTL_WRITE(monitor_op, monitor_op_00000011, u.mov_to_msr);
+                __POST_XEN_DOMCTL_WRITE(monitor_op, monitor_op_00000010, u.mov_to_msr);
                 break;
              case VKI_XEN_DOMCTL_MONITOR_EVENT_GUEST_REQUEST:
-                __POST_XEN_DOMCTL_WRITE(monitor_op, monitor_op_00000011, u.guest_request);
+                __POST_XEN_DOMCTL_WRITE(monitor_op, monitor_op_00000010, u.guest_request);
                 break;
+            case VKI_XEN_DOMCTL_MONITOR_EVENT_DEBUG_EXCEPTION:
+               __POST_XEN_DOMCTL_WRITE(monitor_op, monitor_op_00000010, u.debug_exception);
+               break;
              }
           }
 
          break;
       }
       break;
+   case VKI_XEN_DOMCTL_get_cpu_policy:
+      switch (domctl->interface_version) {
+      case 0x00000011:
+      case 0x00000012:
+         POST_XEN_DOMCTL_WRITE(cpu_policy_00000011, nr_leaves);
+         POST_XEN_DOMCTL_WRITE(cpu_policy_00000011, nr_msrs);
+         if (domctl->u.cpu_policy_00000011.cpuid_policy.p)
+            POST_MEM_WRITE((Addr)domctl->u.cpu_policy_00000011.cpuid_policy.p,
+                           domctl->u.cpu_policy_00000011.nr_leaves);
+         if (domctl->u.cpu_policy_00000011.msr_policy.p)
+            POST_MEM_WRITE((Addr)domctl->u.cpu_policy_00000011.msr_policy.p,
+                           domctl->u.cpu_policy_00000011.nr_msrs);
+         break;
+      }
+      break;
+   case VKI_XEN_DOMCTL_set_cpu_policy:
+      switch (domctl->interface_version) {
+      case 0x00000012:
+         POST_XEN_DOMCTL_WRITE(cpu_policy_00000012, nr_leaves);
+         POST_XEN_DOMCTL_WRITE(cpu_policy_00000012, nr_msrs);
+         POST_XEN_DOMCTL_WRITE(cpu_policy_00000012, err_leaf);
+         POST_XEN_DOMCTL_WRITE(cpu_policy_00000012, err_subleaf);
+         POST_XEN_DOMCTL_WRITE(cpu_policy_00000012, err_msr);
+         if (domctl->u.cpu_policy_00000012.cpuid_policy.p)
+            POST_MEM_WRITE((Addr)domctl->u.cpu_policy_00000012.cpuid_policy.p,
+                           sizeof(vki_xen_cpuid_leaf_00000012_t) *
+                           domctl->u.cpu_policy_00000012.nr_leaves);
+         if (domctl->u.cpu_policy_00000012.msr_policy.p)
+            POST_MEM_WRITE((Addr)domctl->u.cpu_policy_00000012.msr_policy.p,
+                           sizeof(vki_xen_msr_entry_00000012_t) *
+                           domctl->u.cpu_policy_00000012.nr_msrs);
+         break;
+      }
+      break;
    }
 
 #undef POST_XEN_DOMCTL_WRITE
@@ -2449,6 +3199,14 @@ POST(tmem_op)
     }
 }
 
+POST(dm_op)
+{
+   unsigned int num = ARG2;
+   struct vki_xen_privcmd_dm_op_buf *args = (void *)(ARG3);
+
+   POST_MEM_WRITE((Addr) args, sizeof(*args) * num);
+}
+
 typedef
    struct {
       SyscallTableEntry entry;
@@ -2510,6 +3268,8 @@ static XenHypercallTableEntry hypercall_
    HYPXY(__VKI_XEN_domctl,                  domctl,            1), // 36
    //    __VKI_XEN_kexec_op                                        // 37
    HYPXY(__VKI_XEN_tmem_op,                 tmem_op,           1), // 38
+   //    __VKI_XEN_xenpmu_op                                       // 40
+   HYPXY(__VKI_XEN_dm_op,                   dm_op,             3), // 41
 };
 
 static void bad_before ( ThreadId              tid,
Index: valgrind-3.24.0/include/vki/vki-xen-domctl.h
===================================================================
--- valgrind-3.24.0.orig/include/vki/vki-xen-domctl.h
+++ valgrind-3.24.0/include/vki/vki-xen-domctl.h
@@ -28,21 +28,31 @@
 
 /*
  * The domctl interface is versioned via the interface_version
- * field. This structures in this header supports domctl interfaces:
+ * field. The structures in this header supports domctl interfaces:
  *
+ * - 0x00000003: Xen 3.0.3 (unhandled)
+ * - 0x00000004: Xen 3.0.4 (unhandled)
+ * - 0x00000005: Xen 3.1 (unhandled)
+ * - 0x00000006: Xen 4.0 (unhandled)
  * - 0x00000007: Xen 4.1
  * - 0x00000008: Xen 4.2
  * - 0x00000009: Xen 4.3 & 4.4
  * - 0x0000000a: Xen 4.5
- * - 0x0000000b: Xen 4.6
- * - 0x0000000c: Xen 4.7
+ * - 0x0000000b: Xen 4.6 & 4.7
+ * - 0x0000000c: Xen 4.8
+ * - 0x0000000d: Xen 4.9
+ * - 0x0000000e: Xen 4.10
+ * - 0x0000000f: Xen 4.10.1
+ * - 0x00000010: Xen 4.11
+ * - 0x00000011: Xen 4.12
+ * - 0x00000012: Xen 4.13
  *
  * When adding a new subop be sure to include the variants used by all
  * of the above, both here and in syswrap-xen.c
  *
  * Structs which are identical in all supported versions have no
  * version suffix. Structs which do differ are defined multiple times
- * and use the suffix of the latest version to contain that particular
+ * and use the suffix of the earliest version to contain that particular
  * variant.
  */
 
@@ -91,11 +101,11 @@
 #define VKI_XEN_DOMCTL_set_target                    46
 #define VKI_XEN_DOMCTL_deassign_device               47
 #define VKI_XEN_DOMCTL_unbind_pt_irq                 48
-#define VKI_XEN_DOMCTL_set_cpuid                     49
+#define VKI_XEN_DOMCTL_set_cpuid                     49 /* Obsolete in 4.13 */
 #define VKI_XEN_DOMCTL_get_device_group              50
-#define VKI_XEN_DOMCTL_set_machine_address_size      51
-#define VKI_XEN_DOMCTL_get_machine_address_size      52
-#define VKI_XEN_DOMCTL_suppress_spurious_page_faults 53
+#define VKI_XEN_DOMCTL_set_machine_address_size      51 /* Obsolete in 4.13 */
+#define VKI_XEN_DOMCTL_get_machine_address_size      52 /* Obsolete in 4.13 */
+#define VKI_XEN_DOMCTL_suppress_spurious_page_faults 53 /* Obsolete in 4.13 */
 #define VKI_XEN_DOMCTL_debug_op                      54
 #define VKI_XEN_DOMCTL_gethvmcontext_partial         55
 #define VKI_XEN_DOMCTL_mem_event_op                  56
@@ -117,19 +127,111 @@
 #define VKI_XEN_DOMCTL_cacheflush                    71
 #define VKI_XEN_DOMCTL_get_vcpu_msrs                 72
 #define VKI_XEN_DOMCTL_set_vcpu_msrs                 73
+#define VKI_XEN_DOMCTL_setvnumainfo                  74
+#define VKI_XEN_DOMCTL_psr_cmt_op                    75
+#define VKI_XEN_DOMCTL_arm_configure_domain          76
 #define VKI_XEN_DOMCTL_monitor_op                    77 /* new in 4.6 */
+#define VKI_XEN_DOMCTL_psr_cat_op                    78
+#define VKI_XEN_DOMCTL_soft_reset                    79
+#define VKI_XEN_DOMCTL_set_gnttab_limits             80
+#define VKI_XEN_DOMCTL_vuart_op                      81
+#define VKI_XEN_DOMCTL_get_cpu_policy                82
+#define VKI_XEN_DOMCTL_set_cpu_policy                83
 #define VKI_XEN_DOMCTL_gdbsx_guestmemio            1000
 #define VKI_XEN_DOMCTL_gdbsx_pausevcpu             1001
 #define VKI_XEN_DOMCTL_gdbsx_unpausevcpu           1002
 #define VKI_XEN_DOMCTL_gdbsx_domstatus             1003
 
-struct vki_xen_domctl_createdomain {
+struct vki_xen_domctl_createdomain_00000004 {
     /* IN parameters */
     vki_uint32_t ssidref;
     vki_xen_domain_handle_t handle;
     vki_uint32_t flags;
 };
 
+struct vki_xen_arch_domainconfig_0000000b {
+#if defined(__i386__) || defined(__x86_64__)
+    vki_uint8_t dummy;
+#endif
+#if defined(__arm__) || defined(__aarch64__)
+    /* IN/OUT */
+    vki_uint8_t gic_version;
+    /* IN */
+    vki_uint32_t nr_spis;
+    vki_uint32_t clock_frequency;
+#endif
+};
+
+/* The layout changed in 4.07, which shares domctl with 4.06 */
+struct vki_xen_arch_domainconfig_0000000c {
+#if defined(__i386__) || defined(__x86_64__)
+    vki_uint32_t emulation_flags;
+#endif
+#if defined(__arm__) || defined(__aarch64__)
+    /* IN/OUT */
+    vki_uint8_t gic_version;
+    /* IN */
+    vki_uint32_t nr_spis;
+    vki_uint32_t clock_frequency;
+#endif
+};
+
+struct vki_xen_arch_domainconfig_00000012 {
+#if defined(__i386__) || defined(__x86_64__)
+    vki_uint32_t emulation_flags;
+#endif
+#if defined(__arm__) || defined(__aarch64__)
+    /* IN/OUT */
+    vki_uint8_t gic_version;
+    /* IN */
+    vki_uint16_t tee_type;
+    /* IN */
+    vki_uint32_t nr_spis;
+    vki_uint32_t clock_frequency;
+#endif
+};
+
+struct vki_xen_domctl_createdomain_0000000b {
+    /* IN parameters */
+    vki_uint32_t ssidref;
+    vki_xen_domain_handle_t handle;
+    vki_uint32_t flags;
+    struct vki_xen_arch_domainconfig_0000000b config;
+};
+
+struct vki_xen_domctl_createdomain_0000000c {
+    /* IN parameters */
+    vki_uint32_t ssidref;
+    vki_xen_domain_handle_t handle;
+    vki_uint32_t flags;
+    struct vki_xen_arch_domainconfig_0000000c config;
+};
+
+struct vki_xen_domctl_createdomain_00000011 {
+    /* IN parameters */
+    vki_uint32_t ssidref;
+    vki_xen_domain_handle_t handle;
+    vki_uint32_t flags;
+    vki_uint32_t max_vcpus;
+    vki_uint32_t max_evtchn_port;
+    vki_uint32_t max_grant_frames;
+    vki_uint32_t max_maptrack_frames;
+    struct vki_xen_arch_domainconfig_0000000c config;
+};
+
+struct vki_xen_domctl_createdomain_00000012 {
+    /* IN parameters */
+    vki_uint32_t ssidref;
+    vki_xen_domain_handle_t handle;
+    vki_uint32_t flags;
+    vki_uint32_t iommu_opts;
+    vki_uint32_t max_vcpus;
+    vki_uint32_t max_evtchn_port;
+    vki_uint32_t max_grant_frames;
+    vki_uint32_t max_maptrack_frames;
+    struct vki_xen_arch_domainconfig_00000012 config;
+};
+
 struct vki_xen_domctl_getdomaininfo_00000007 {
     /* OUT variables. */
     vki_xen_domid_t  domain;
@@ -137,7 +239,6 @@ struct vki_xen_domctl_getdomaininfo_0000
     vki_xen_uint64_aligned_t tot_pages;
     vki_xen_uint64_aligned_t max_pages;
     vki_xen_uint64_aligned_t shr_pages;
-    vki_xen_uint64_aligned_t paged_pages;
     vki_xen_uint64_aligned_t shared_info_frame;
     vki_xen_uint64_aligned_t cpu_time;
     vki_uint32_t nr_online_vcpus;
@@ -188,12 +289,28 @@ struct vki_xen_domctl_getdomaininfo_0000
 typedef struct vki_xen_domctl_getdomaininfo_00000009 vki_xen_domctl_getdomaininfo_00000009_t;
 DEFINE_VKI_XEN_GUEST_HANDLE(vki_xen_domctl_getdomaininfo_00000009_t);
 
-// x86 version only for now
-struct vki_xen_arch_domainconfig_00000010 {
-    vki_uint32_t emulation_flags;
+struct vki_xen_domctl_getdomaininfo_0000000f {
+    /* OUT variables. */
+    vki_xen_domid_t  domain;
+    vki_uint32_t flags;
+    vki_xen_uint64_aligned_t tot_pages;
+    vki_xen_uint64_aligned_t max_pages;
+    vki_xen_uint64_aligned_t outstanding_pages;
+    vki_xen_uint64_aligned_t shr_pages;
+    vki_xen_uint64_aligned_t paged_pages;
+    vki_xen_uint64_aligned_t shared_info_frame;
+    vki_xen_uint64_aligned_t cpu_time;
+    vki_uint32_t nr_online_vcpus;
+    vki_uint32_t max_vcpu_id;
+    vki_uint32_t ssidref;
+    vki_xen_domain_handle_t handle;
+    vki_uint32_t cpupool;
+    struct vki_xen_arch_domainconfig_0000000c arch;
 };
+typedef struct vki_xen_domctl_getdomaininfo_0000000f vki_xen_domctl_getdomaininfo_0000000f_t;
+DEFINE_VKI_XEN_GUEST_HANDLE(vki_xen_domctl_getdomaininfo_0000000f_t);
 
-struct vki_xen_domctl_getdomaininfo_00000010 {
+struct vki_xen_domctl_getdomaininfo_00000012 {
     /* OUT variables. */
     vki_xen_domid_t  domain;
     vki_uint32_t flags;
@@ -209,12 +326,10 @@ struct vki_xen_domctl_getdomaininfo_0000
     vki_uint32_t ssidref;
     vki_xen_domain_handle_t handle;
     vki_uint32_t cpupool;
-    struct vki_xen_arch_domainconfig_00000010 arch;
+    struct vki_xen_arch_domainconfig_00000012 arch;
 };
-typedef struct vki_xen_domctl_getdomaininfo_00000010 vki_xen_domctl_getdomaininfo_00000010_t;
-DEFINE_VKI_XEN_GUEST_HANDLE(vki_xen_domctl_getdomaininfo_00000010_t);
-
-/* vki_xen_domctl_getdomaininfo_0000000a is the same as 00000009 */
+typedef struct vki_xen_domctl_getdomaininfo_00000012 vki_xen_domctl_getdomaininfo_00000012_t;
+DEFINE_VKI_XEN_GUEST_HANDLE(vki_xen_domctl_getdomaininfo_00000012_t);
 
 /* Get/set the NUMA node(s) with which the guest has affinity with. */
 /* XEN_DOMCTL_setnodeaffinity */
@@ -239,6 +354,7 @@ struct vki_xen_domctl_vcpuaffinity_00000
     vki_uint32_t  vcpu;              /* IN */
 #define VKI_XEN_VCPUAFFINITY_HARD   (1U<<0)
 #define VKI_XEN_VCPUAFFINITY_SOFT   (1U<<1)
+#define VKI_XEN_VCPUAFFINITY_FORCE  (1U<<2)
     vki_uint32_t  flags;              /* IN */
     struct vki_xenctl_bitmap cpumap_hard; /* IN/OUT */
     struct vki_xenctl_bitmap cpumap_soft; /* IN/OUT */
@@ -306,9 +422,12 @@ struct vki_xen_domctl_scheduler_op {
 #define VKI_XEN_SCHEDULER_CREDIT2  6
 #define VKI_XEN_SCHEDULER_ARINC653 7
 #define VKI_XEN_SCHEDULER_RTDS     8
+#define VKI_XEN_SCHEDULER_NULL     9
     vki_uint32_t cmd;       /* VKI_XEN_DOMCTL_SCHEDOP_* */
 #define VKI_XEN_DOMCTL_SCHEDOP_putinfo 0
 #define VKI_XEN_DOMCTL_SCHEDOP_getinfo 1
+#define VKI_XEN_DOMCTL_SCHEDOP_putvcpuinfo 2
+#define VKI_XEN_DOMCTL_SCHEDOP_getvcpuinfo 3
     union {
         struct xen_domctl_sched_sedf {
             vki_xen_uint64_aligned_t period;
@@ -357,10 +476,14 @@ struct vki_xen_domctl_hypercall_init {
     vki_xen_uint64_aligned_t  gmfn;           /* GMFN to be initialised */
 };
 
-struct vki_xen_domctl_settimeoffset {
+struct vki_xen_domctl_settimeoffset_00000001 {
     vki_int32_t time_offset_seconds;
 };
 
+struct vki_xen_domctl_settimeoffset_0000000b {
+    vki_int64_t time_offset_seconds;
+};
+
 struct vki_xen_domctl_cpuid {
   vki_uint32_t input[2];
   vki_uint32_t eax;
@@ -402,13 +525,13 @@ struct vki_xen_domctl_hvmcontext {
 typedef struct vki_xen_domctl_hvmcontext vki_xen_domctl_hvmcontext_t;
 DEFINE_VKI_XEN_GUEST_HANDLE(vki_xen_domctl_hvmcontext_t);
 
-struct vki_xen_domctl_hvmcontext_partial_00000007 {
+struct vki_xen_domctl_hvmcontext_partial_00000005 {
     vki_uint32_t type; /* IN */
     vki_uint32_t instance; /* IN */
     VKI_XEN_GUEST_HANDLE_64(vki_uint8) buffer; /* IN/OUT buffer */
 };
-typedef struct vki_xen_domctl_hvmcontext_partial_00000007 vki_xen_domctl_hvmcontext_partial_00000007_t;
-DEFINE_VKI_XEN_GUEST_HANDLE(vki_xen_domctl_hvmcontext_partial_00000007_t);
+typedef struct vki_xen_domctl_hvmcontext_partial_00000005 vki_xen_domctl_hvmcontext_partial_00000005_t;
+DEFINE_VKI_XEN_GUEST_HANDLE(vki_xen_domctl_hvmcontext_partial_00000005_t);
 
 struct vki_xen_domctl_hvmcontext_partial_0000000e {
     vki_uint32_t type; /* IN */
@@ -496,6 +619,20 @@ struct vki_xen_domctl_assign_device_0000
     vki_uint32_t  flag;   /* flag of assigned device */
 };
 
+struct vki_xen_domctl_assign_device_0000000e {
+    vki_uint32_t dev;   /* XEN_DOMCTL_DEV_* */
+    vki_uint32_t flags;
+    union {
+        struct {
+            vki_uint32_t machine_sbdf;   /* machine PCI ID of assigned device */
+        } pci;
+        struct {
+            vki_uint32_t size; /* Length of the path */
+            VKI_XEN_GUEST_HANDLE_64(vki_uint8) path; /* path to the device tree node */
+        } dt;
+    } u;
+};
+
 struct vki_xen_domctl_debug_op {
     vki_uint32_t op;   /* IN */
     vki_uint32_t vcpu; /* IN */
@@ -505,11 +642,16 @@ typedef struct vki_xen_domctl_debug_op v
 struct vki_xen_domctl_mem_event_op_00000007 {
     vki_uint32_t op; /* IN */
     vki_uint32_t mode; /* IN */
-    vki_uint32_t port; /* OUT */
+    __vki_aligned_u64 shared_addr; /* IN */
+    __vki_aligned_u64 ring_addr; /* IN */
+    __vki_aligned_u64 gfn; /* IN */
 };
 
-/* only a name change in 4.6 */
-typedef struct vki_xen_domctl_mem_event_op_00000007 vki_xen_domctl_vm_event_op_0000000b;
+struct vki_xen_domctl_vm_event_op_00000008 {
+    vki_uint32_t op; /* IN */
+    vki_uint32_t mode; /* IN */
+    vki_uint32_t port; /* OUT */
+};
 
 struct vki_xen_domctl_vm_event_op_00000012 {
     vki_uint32_t op; /* IN */
@@ -606,66 +748,113 @@ struct vki_xen_domctl_monitor_op_0000000
     } u;
 };
 
-struct vki_xen_domctl_monitor_op_00000011 {
+struct vki_xen_domctl_monitor_op_0000000c {
     vki_uint32_t op; /* vki_xen_DOMCTL_MONITOR_OP_* */
-
-    /*
-     * When used with ENABLE/DISABLE this has to be set to
-     * the requested vki_xen_DOMCTL_MONITOR_EVENT_* value.
-     * With GET_CAPABILITIES this field returns a bitmap of
-     * events supported by the platform, in the format
-     * (1 << vki_xen_DOMCTL_MONITOR_EVENT_*).
-     */
     vki_uint32_t event;
+    union {
+        struct {
+            vki_uint8_t index;
+            vki_uint8_t sync;
+            vki_uint8_t onchangeonly;
+        } mov_to_cr;
+        struct {
+            vki_uint32_t msr;
+        } mov_to_msr;
+        struct {
+            vki_uint8_t sync;
+        } guest_request;
+        struct {
+            vki_uint8_t sync;
+        } debug_exception;
+    } u;
+};
 
-    /*
-     * Further options when issuing vki_xen_DOMCTL_MONITOR_OP_ENABLE.
-     */
+struct vki_xen_domctl_monitor_op_0000000e {
+    vki_uint32_t op; /* vki_xen_DOMCTL_MONITOR_OP_* */
+    vki_uint32_t event;
     union {
         struct {
-            /* Which control register */
             vki_uint8_t index;
-            /* Pause vCPU until response */
             vki_uint8_t sync;
-            /* Send event only on a change of value */
             vki_uint8_t onchangeonly;
-            /* Allignment padding */
             vki_uint8_t pad1;
             vki_uint32_t pad2;
-            /*
-             * Send event only if the changed bit in the control register
-             * is not masked.
-             */
             vki_xen_uint64_aligned_t bitmask;
         } mov_to_cr;
+        struct {
+            vki_uint32_t msr;
+        } mov_to_msr;
+        struct {
+            vki_uint8_t sync;
+            vki_uint8_t allow_userspace;
+        } guest_request;
+        struct {
+            vki_uint8_t sync;
+        } debug_exception;
+    } u;
+};
 
+struct vki_xen_domctl_monitor_op_00000010 {
+    vki_uint32_t op; /* vki_xen_DOMCTL_MONITOR_OP_* */
+    vki_uint32_t event;
+    union {
+        struct {
+            vki_uint8_t index;
+            vki_uint8_t sync;
+            vki_uint8_t onchangeonly;
+            vki_uint8_t pad1;
+            vki_uint32_t pad2;
+            vki_xen_uint64_aligned_t bitmask;
+        } mov_to_cr;
         struct {
             vki_uint32_t msr;
             vki_uint8_t onchangeonly;
         } mov_to_msr;
-
         struct {
-            /* Pause vCPU until response */
             vki_uint8_t sync;
             vki_uint8_t allow_userspace;
         } guest_request;
-
         struct {
-            /* Pause vCPU until response */
             vki_uint8_t sync;
         } debug_exception;
     } u;
 };
 
+struct vki_xen_domctl_set_gnttab_limits_0000000e {
+    vki_uint32_t grant_frames;
+    vki_uint32_t maptrack_frames;
+};
+
+struct vki_xen_domctl_cpu_policy_00000011 {
+    vki_uint32_t nr_leaves;
+    vki_uint32_t nr_msrs;
+    VKI_XEN_GUEST_HANDLE_64(vki_xen_cpuid_leaf_00000012_t) cpuid_policy;
+    VKI_XEN_GUEST_HANDLE_64(vki_xen_msr_entry_00000012_t) msr_policy;
+};
+
+struct vki_xen_domctl_cpu_policy_00000012 {
+    vki_uint32_t nr_leaves;
+    vki_uint32_t nr_msrs;
+    VKI_XEN_GUEST_HANDLE_64(vki_xen_cpuid_leaf_00000012_t) cpuid_policy;
+    VKI_XEN_GUEST_HANDLE_64(vki_xen_msr_entry_00000012_t) msr_policy;
+    vki_uint32_t err_leaf, err_subleaf, err_msr;
+};
+
 struct vki_xen_domctl {
     vki_uint32_t cmd;
     vki_uint32_t interface_version; /* XEN_DOMCTL_INTERFACE_VERSION */
     vki_xen_domid_t  domain;
     union {
-        struct vki_xen_domctl_createdomain      createdomain;
+        struct vki_xen_domctl_createdomain_00000004  createdomain_00000004;
+        struct vki_xen_domctl_createdomain_0000000b  createdomain_0000000b;
+        struct vki_xen_domctl_createdomain_0000000c  createdomain_0000000c;
+        struct vki_xen_domctl_createdomain_00000011  createdomain_00000011;
+        struct vki_xen_domctl_createdomain_00000012  createdomain_00000012;
         struct vki_xen_domctl_getdomaininfo_00000007 getdomaininfo_00000007;
         struct vki_xen_domctl_getdomaininfo_00000008 getdomaininfo_00000008;
         struct vki_xen_domctl_getdomaininfo_00000009 getdomaininfo_00000009;
+        struct vki_xen_domctl_getdomaininfo_0000000f getdomaininfo_0000000f;
+        struct vki_xen_domctl_getdomaininfo_00000012 getdomaininfo_00000012;
         //struct vki_xen_domctl_getmemlist        getmemlist;
         //struct vki_xen_domctl_getpageframeinfo  getpageframeinfo;
         //struct vki_xen_domctl_getpageframeinfo2 getpageframeinfo2;
@@ -686,19 +875,21 @@ struct vki_xen_domctl {
         struct vki_xen_domctl_ioport_permission ioport_permission;
         struct vki_xen_domctl_hypercall_init    hypercall_init;
         //struct vki_xen_domctl_arch_setup        arch_setup;
-        struct vki_xen_domctl_settimeoffset     settimeoffset;
+        struct vki_xen_domctl_settimeoffset_00000001     settimeoffset_00000001;
+        struct vki_xen_domctl_settimeoffset_0000000b     settimeoffset_0000000b;
         //struct vki_xen_domctl_disable_migrate   disable_migrate;
         struct vki_xen_domctl_tsc_info_00000007   tsc_info_00000007;
         struct vki_xen_domctl_tsc_info_0000000b   tsc_info_0000000b;
         //struct vki_xen_domctl_real_mode_area    real_mode_area;
         struct vki_xen_domctl_hvmcontext        hvmcontext;
-        struct vki_xen_domctl_hvmcontext_partial_0000000e hvmcontext_partial_00000007;
+        struct vki_xen_domctl_hvmcontext_partial_00000005 hvmcontext_partial_00000005;
         struct vki_xen_domctl_hvmcontext_partial_0000000e hvmcontext_partial_0000000e;
         struct vki_xen_domctl_address_size      address_size;
         //struct vki_xen_domctl_sendtrigger       sendtrigger;
         //struct vki_xen_domctl_get_device_group  get_device_group;
         struct vki_xen_domctl_assign_device_00000007 assign_device_00000007;
         struct vki_xen_domctl_assign_device_0000000b assign_device_0000000b;
+        struct vki_xen_domctl_assign_device_0000000e assign_device_0000000e;
         //struct vki_xen_domctl_bind_pt_irq       bind_pt_irq;
         //struct vki_xen_domctl_memory_mapping    memory_mapping;
         //struct vki_xen_domctl_ioport_mapping    ioport_mapping;
@@ -709,7 +900,7 @@ struct vki_xen_domctl {
         //struct vki_xen_domctl_subscribe         subscribe;
         struct vki_xen_domctl_debug_op          debug_op;
         struct vki_xen_domctl_mem_event_op_00000007 mem_event_op_00000007;
-        vki_xen_domctl_vm_event_op_0000000b vm_event_op_0000000b;
+        struct vki_xen_domctl_vm_event_op_00000008 vm_event_op_00000008;
         struct vki_xen_domctl_vm_event_op_00000012 vm_event_op_00000012;
         //struct vki_xen_domctl_mem_sharing_op    mem_sharing_op;
 #if defined(__i386__) || defined(__x86_64__)
@@ -727,7 +918,17 @@ struct vki_xen_domctl {
         //struct vki_xen_domctl_gdbsx_pauseunp_vcpu gdbsx_pauseunp_vcpu;
         //struct vki_xen_domctl_gdbsx_domstatus   gdbsx_domstatus;
         struct vki_xen_domctl_monitor_op_0000000b monitor_op_0000000b;
-        struct vki_xen_domctl_monitor_op_00000011 monitor_op_00000011;
+        struct vki_xen_domctl_monitor_op_0000000c monitor_op_0000000c;
+        struct vki_xen_domctl_monitor_op_0000000e monitor_op_0000000e;
+        struct vki_xen_domctl_monitor_op_00000010 monitor_op_00000010;
+        //struct vki_xen_domctl_vnuma             vnuma;
+        //struct vki_xen_domctl_psr_cmt_op        psr_cmt_op;
+        //struct vki_xen_domctl_psr_cat_op        psr_cat_op;
+        //struct vki_xen_domctl_arm_configuredomain configuredomain;
+        struct vki_xen_domctl_set_gnttab_limits_0000000e set_gnttab_limits_0000000e;
+        //struct vki_xen_domctl_vuart_op          vuart_op;
+        struct vki_xen_domctl_cpu_policy_00000011 cpu_policy_00000011;
+        struct vki_xen_domctl_cpu_policy_00000012 cpu_policy_00000012;
         vki_uint8_t                         pad[128];
     } u;
 };
Index: valgrind-3.24.0/include/vki/vki-xen-sysctl.h
===================================================================
--- valgrind-3.24.0.orig/include/vki/vki-xen-sysctl.h
+++ valgrind-3.24.0/include/vki/vki-xen-sysctl.h
@@ -3,19 +3,31 @@
 
 /*
  * The sysctl interface is versioned via the interface_version
- * field. This structures in this header supports sysctl interfaces:
+ * field. The structures in this header supports sysctl interfaces:
  *
+ * - 0x00000002: Xen 3.0.3 (unhandled)
+ * - 0x00000003: Xen 3.1.0 (unhandled)
+ * - 0x00000006: Xen 3.2 (unhandled)
+ * - 0x00000007: Xen 4.0 (unhandled)
  * - 0x00000008: Xen 4.1
  * - 0x00000009: Xen 4.2
  * - 0x0000000a: Xen 4.3 & 4.4
  * - 0x0000000b: Xen 4.5
+ * - 0x0000000c: Xen 4.6
+ * - 0x0000000d: Xen 4.7
+ * - 0x0000000e: Xen 4.8
+ * - 0x0000000f: Xen 4.9
+ * - 0x00000010: Xen 4.10
+ * - 0x00000011: Xen 4.11
+ * - 0x00000012: Xen 4.12 & 4.13
+ * - 0x00000013: Xen 4.14
  *
  * When adding a new subop be sure to include the variants used by all
  * of the above, both here and in syswrap-xen.c
  *
  * Structs which are identical in all supported versions have no
  * version suffix. Structs which do differ are defined multiple times
- * and use the suffix of the latest version to contain that particular
+ * and use the suffix of the earliest version to contain that particular
  * variant.
  */
 
@@ -34,10 +46,21 @@
 #define VKI_XEN_SYSCTL_page_offline_op               14
 #define VKI_XEN_SYSCTL_lockprof_op                   15
 #define VKI_XEN_SYSCTL_topologyinfo                  16
+#define VKI_XEN_SYSCTL_cputopoinfo                   16 /* Since xen-4.6 */
 #define VKI_XEN_SYSCTL_numainfo                      17
 #define VKI_XEN_SYSCTL_cpupool_op                    18
 #define VKI_XEN_SYSCTL_scheduler_op                  19
 #define VKI_XEN_SYSCTL_coverage_op                   20
+#define VKI_XEN_SYSCTL_gcov_op                       20 /* Since xen-4.9 */
+#define VKI_XEN_SYSCTL_psr_cmt_op                    21
+#define VKI_XEN_SYSCTL_pcitopoinfo                   22
+#define VKI_XEN_SYSCTL_psr_cat_op                    23
+#define VKI_XEN_SYSCTL_tmem_op                       24
+#define VKI_XEN_SYSCTL_get_cpu_levelling_caps        25
+#define VKI_XEN_SYSCTL_get_cpu_featureset            26
+#define VKI_XEN_SYSCTL_livepatch_op                  27
+#define VKI_XEN_SYSCTL_set_parameter                 28
+#define VKI_XEN_SYSCTL_get_cpu_policy                29
 
 struct vki_xen_sysctl_readconsole {
     /* IN */
@@ -60,7 +83,7 @@ struct vki_xen_sysctl_readconsole {
     vki_uint32_t count;
 };
 
-struct vki_xen_sysctl_getdomaininfolist_00000008 {
+struct vki_xen_sysctl_getdomaininfolist_00000007 {
     /* IN variables. */
     vki_xen_domid_t           first_domain;
     vki_uint32_t              max_domains;
@@ -68,8 +91,7 @@ struct vki_xen_sysctl_getdomaininfolist_
     /* OUT variables. */
     vki_uint32_t              num_domains;
 };
-
-struct vki_xen_sysctl_getdomaininfolist_00000009 {
+struct vki_xen_sysctl_getdomaininfolist_00000008 {
     /* IN variables. */
     vki_xen_domid_t           first_domain;
     vki_uint32_t              max_domains;
@@ -78,7 +100,7 @@ struct vki_xen_sysctl_getdomaininfolist_
     vki_uint32_t              num_domains;
 };
 
-struct vki_xen_sysctl_getdomaininfolist_0000000a {
+struct vki_xen_sysctl_getdomaininfolist_00000009 {
     /* IN variables. */
     vki_xen_domid_t           first_domain;
     vki_uint32_t              max_domains;
@@ -87,16 +109,23 @@ struct vki_xen_sysctl_getdomaininfolist_
     vki_uint32_t              num_domains;
 };
 
-struct vki_xen_sysctl_getdomaininfolist_00000010 {
+struct vki_xen_sysctl_getdomaininfolist_0000000f {
     /* IN variables. */
     vki_xen_domid_t           first_domain;
     vki_uint32_t              max_domains;
-    VKI_XEN_GUEST_HANDLE_64(vki_xen_domctl_getdomaininfo_00000010_t) buffer;
+    VKI_XEN_GUEST_HANDLE_64(vki_xen_domctl_getdomaininfo_0000000f_t) buffer;
     /* OUT variables. */
     vki_uint32_t              num_domains;
 };
 
-/* vki_xen_sysctl_getdomaininfolist_0000000b is the same as 0000000a */
+struct vki_xen_sysctl_getdomaininfolist_00000012 {
+    /* IN variables. */
+    vki_xen_domid_t           first_domain;
+    vki_uint32_t              max_domains;
+    VKI_XEN_GUEST_HANDLE_64(vki_xen_domctl_getdomaininfo_00000012_t) buffer;
+    /* OUT variables. */
+    vki_uint32_t              num_domains;
+};
 
 #define VKI_XEN_SYSCTL_CPUPOOL_OP_CREATE                1  /* C */
 #define VKI_XEN_SYSCTL_CPUPOOL_OP_DESTROY               2  /* D */
@@ -129,12 +158,45 @@ struct vki_xen_sysctl_topologyinfo {
     VKI_XEN_GUEST_HANDLE_64(vki_uint32) cpu_to_node;
 };
 
-struct vki_xen_sysctl_numainfo {
+struct vki_xen_sysctl_cputopo_0000000c {
+    vki_uint32_t core;
+    vki_uint32_t socket;
+    vki_uint32_t node;
+};
+typedef struct vki_xen_sysctl_cputopo_0000000c vki_xen_sysctl_cputopo_0000000c_t;
+DEFINE_VKI_XEN_GUEST_HANDLE(vki_xen_sysctl_cputopo_0000000c_t);
+
+struct vki_xen_sysctl_cputopoinfo_0000000c {
+    vki_uint32_t num_cpus;
+    VKI_XEN_GUEST_HANDLE_64(vki_xen_sysctl_cputopo_0000000c_t) cputopo;
+};
+
+struct vki_xen_sysctl_pcitopoinfo_0000000c {
+    vki_uint32_t num_devs;
+    VKI_XEN_GUEST_HANDLE_64(vki_physdev_pci_device_t) devs;
+    VKI_XEN_GUEST_HANDLE_64(vki_uint32) nodes;
+};
+
+struct vki_xen_sysctl_numainfo_00000008 {
     vki_uint32_t max_node_index;
     VKI_XEN_GUEST_HANDLE_64(vki_uint64) node_to_memsize;
     VKI_XEN_GUEST_HANDLE_64(vki_uint64) node_to_memfree;
     VKI_XEN_GUEST_HANDLE_64(vki_uint32) node_to_node_distance;
 };
+
+struct vki_xen_xen_sysctl_meminfo_0000000c {
+    vki_uint64_t memsize;
+    vki_uint64_t memfree;
+};
+typedef struct vki_xen_xen_sysctl_meminfo_0000000c vki_xen_xen_sysctl_meminfo_0000000c_t;
+DEFINE_VKI_XEN_GUEST_HANDLE(vki_xen_xen_sysctl_meminfo_0000000c_t);
+
+struct vki_xen_sysctl_numainfo_0000000c {
+    vki_uint32_t num_nodes;
+    VKI_XEN_GUEST_HANDLE_64(vki_xen_xen_sysctl_meminfo_0000000c_t) meminfo;
+    VKI_XEN_GUEST_HANDLE_64(vki_uint32) distance;
+};
+
 struct vki_xen_sysctl_physinfo_00000008 {
     vki_uint32_t threads_per_core;
     vki_uint32_t cores_per_socket;
@@ -191,6 +253,21 @@ struct vki_xen_sysctl_sched_id {
     vki_uint32_t              sched_id;
 };
 
+struct vki_xen_sysctl_cpu_featureset_0000000d {
+    vki_uint32_t index;
+    vki_uint32_t nr_features;
+    VKI_XEN_GUEST_HANDLE_64(vki_uint32) features;
+};
+
+struct vki_xen_sysctl_get_cpu_policy_00000012 {
+    vki_uint32_t index;
+    vki_uint32_t nr_leaves;
+    vki_uint64_t nr_msrs;
+    vki_uint64_t _rsvd;
+    VKI_XEN_GUEST_HANDLE_64(vki_xen_cpuid_leaf_00000012_t) cpuid_policy;
+    VKI_XEN_GUEST_HANDLE_64(vki_xen_msr_entry_00000012_t) msr_policy;
+};
+
 struct vki_xen_sysctl {
     vki_uint32_t cmd;
     vki_uint32_t interface_version; /* XEN_SYSCTL_INTERFACE_VERSION */
@@ -201,13 +278,18 @@ struct vki_xen_sysctl {
         struct vki_xen_sysctl_physinfo_0000000a physinfo_0000000a;
         struct vki_xen_sysctl_physinfo_00000010 physinfo_00000010;
         struct vki_xen_sysctl_topologyinfo      topologyinfo;
-        struct vki_xen_sysctl_numainfo          numainfo;
+        struct vki_xen_sysctl_cputopoinfo_0000000c cputopoinfo_0000000c;
+        struct vki_xen_sysctl_pcitopoinfo_0000000c pcitopoinfo_0000000c;
+        struct vki_xen_sysctl_numainfo_00000008 numainfo_00000008;
+        struct vki_xen_sysctl_numainfo_0000000c numainfo_0000000c;
         struct vki_xen_sysctl_sched_id          sched_id;
         //struct vki_xen_sysctl_perfc_op          perfc_op;
+        /* getdomaininfolist (sysctl) suffix is the getdomaininfo (domctl) suffix */
+        struct vki_xen_sysctl_getdomaininfolist_00000007 getdomaininfolist_00000007;
         struct vki_xen_sysctl_getdomaininfolist_00000008 getdomaininfolist_00000008;
         struct vki_xen_sysctl_getdomaininfolist_00000009 getdomaininfolist_00000009;
-        struct vki_xen_sysctl_getdomaininfolist_0000000a getdomaininfolist_0000000a;
-        struct vki_xen_sysctl_getdomaininfolist_00000010 getdomaininfolist_00000010;
+        struct vki_xen_sysctl_getdomaininfolist_0000000f getdomaininfolist_0000000f;
+        struct vki_xen_sysctl_getdomaininfolist_00000012 getdomaininfolist_00000012;
         struct vki_xen_sysctl_debug_keys        debug_keys;
         //struct vki_xen_sysctl_getcpuinfo        getcpuinfo;
         //struct vki_xen_sysctl_availheap         availheap;
@@ -219,6 +301,15 @@ struct vki_xen_sysctl {
         struct vki_xen_sysctl_cpupool_op        cpupool_op;
         //struct vki_xen_sysctl_scheduler_op      scheduler_op;
         //struct vki_xen_sysctl_coverage_op       coverage_op;
+        //struct vki_xen_sysctl_gcov_op           gcov_op;
+        //struct vki_xen_sysctl_psr_cmt_op        psr_cmt_op;
+        //struct vki_xen_sysctl_psr_cat_op        psr_cat_op;
+        //struct vki_xen_sysctl_tmem_op           tmem_op;
+        //struct vki_xen_sysctl_cpu_levelling_caps cpu_levelling_caps;
+        struct vki_xen_sysctl_cpu_featureset_0000000d cpu_featureset_0000000d;
+        //struct vki_xen_sysctl_livepatch_op      livepatch;
+        //struct vki_xen_sysctl_set_parameter     set_parameter;
+        struct vki_xen_sysctl_get_cpu_policy_00000012 get_cpu_policy_00000012;
 
         vki_uint8_t                             pad[128];
     } u;
Index: valgrind-3.24.0/include/vki/vki-xen-hvm.h
===================================================================
--- valgrind-3.24.0.orig/include/vki/vki-xen-hvm.h
+++ valgrind-3.24.0/include/vki/vki-xen-hvm.h
@@ -95,7 +95,16 @@ struct vki_xen_hvm_get_mem_access {
 typedef struct vki_xen_hvm_get_mem_access vki_xen_hvm_get_mem_access_t;
 
 #define VKI_XEN_HVMOP_inject_trap            14
-struct vki_xen_hvm_inject_trap {
+struct vki_xen_hvm_inject_trap_0401 {
+    vki_xen_domid_t domid;
+    vki_uint32_t vcpuid;
+    vki_uint32_t trap;
+    vki_uint32_t error_code;
+    vki_uint64_t cr2;
+};
+typedef struct vki_xen_hvm_inject_trap_0401 vki_xen_hvm_inject_trap_0401_t;
+
+struct vki_xen_hvm_inject_trap_0402 {
     vki_xen_domid_t domid;
     vki_uint32_t vcpuid;
     vki_uint32_t vector;
@@ -104,7 +113,7 @@ struct vki_xen_hvm_inject_trap {
     vki_uint32_t insn_len;
     vki_uint64_t cr2;
 };
-typedef struct vki_xen_hvm_inject_trap vki_xen_hvm_inject_trap_t;
+typedef struct vki_xen_hvm_inject_trap_0402 vki_xen_hvm_inject_trap_0402_t;
 
 #define VKI_XEN_HVMOP_altp2m 25
 #define VKI_XEN_HVMOP_altp2m_get_domain_state     1
Index: valgrind-3.24.0/include/vki/vki-xen.h
===================================================================
--- valgrind-3.24.0.orig/include/vki/vki-xen.h
+++ valgrind-3.24.0/include/vki/vki-xen.h
@@ -67,6 +67,8 @@
 #define __VKI_XEN_kexec_op             37
 #define __VKI_XEN_tmem_op              38
 #define __VKI_XEN_xc_reserved_op       39 /* reserved for XenClient */
+#define __VKI_XEN_xenpmu_op            40
+#define __VKI_XEN_dm_op                41
 
 #define __DEFINE_VKI_XEN_GUEST_HANDLE(name, type) \
     ___DEFINE_VKI_XEN_GUEST_HANDLE(name, type);   \
@@ -102,6 +104,7 @@ struct vki_xenctl_bitmap {
     vki_uint32_t nr_bits;
 };
 
+#include <vki/vki-xen-physdev.h>
 #include <vki/vki-xen-domctl.h>
 #include <vki/vki-xen-sysctl.h>
 #include <vki/vki-xen-mmuext.h>
@@ -113,7 +116,6 @@ struct vki_xenctl_bitmap {
 #include <vki/vki-xen-hvm.h>
 #include <vki/vki-xen-tmem.h>
 #include <vki/vki-xen-xsm.h>
-#include <vki/vki-xen-physdev.h>
 
 #endif // __VKI_XEN_H
 
Index: valgrind-3.24.0/coregrind/m_syswrap/syswrap-linux.c
===================================================================
--- valgrind-3.24.0.orig/coregrind/m_syswrap/syswrap-linux.c
+++ valgrind-3.24.0/coregrind/m_syswrap/syswrap-linux.c
@@ -9158,6 +9158,38 @@ PRE(sys_ioctl)
                     (Addr)args->arr, sizeof(*(args->arr)) * args->num);
       break;
    }
+   case VKI_XEN_IOCTL_PRIVCMD_DM_OP: {
+      struct vki_xen_privcmd_dm_op *args =
+         (struct vki_xen_privcmd_dm_op *)(ARG3);
+      PRE_MEM_READ("VKI_XEN_IOCTL_PRIVCMD_DM_OP(dom)",
+                  (Addr)&args->dom, sizeof(args->dom));
+      PRE_MEM_READ("VKI_XEN_IOCTL_PRIVCMD_DM_OP(num)",
+                  (Addr)&args->num, sizeof(args->num));
+      PRE_MEM_READ("VKI_XEN_IOCTL_PRIVCMD_DM_OP(ubufs)",
+                  (Addr)args->ubufs, sizeof(*(args->ubufs)) * args->num);
+      break;
+   }
+   case VKI_XEN_IOCTL_PRIVCMD_RESTRICT:
+      break;
+   case VKI_XEN_IOCTL_PRIVCMD_MMAP_RESOURCE: {
+      struct vki_xen_privcmd_mmap_resource *args =
+         (struct vki_xen_privcmd_mmap_resource *)(ARG3);
+      PRE_MEM_READ("VKI_XEN_IOCTL_PRIVCMD_MMAP_RESOURCE(dom)",
+                  (Addr)&args->dom, sizeof(args->dom));
+      PRE_MEM_READ("VKI_XEN_IOCTL_PRIVCMD_MMAP_RESOURCE(type)",
+                  (Addr)&args->type, sizeof(args->type));
+      PRE_MEM_READ("VKI_XEN_IOCTL_PRIVCMD_MMAP_RESOURCE(id)",
+                  (Addr)&args->id, sizeof(args->id));
+      PRE_MEM_READ("VKI_XEN_IOCTL_PRIVCMD_MMAP_RESOURCE(idx)",
+                  (Addr)&args->idx, sizeof(args->idx));
+      PRE_MEM_READ("VKI_XEN_IOCTL_PRIVCMD_MMAP_RESOURCE(num)",
+                  (Addr)&args->num, sizeof(args->num));
+      PRE_MEM_READ("VKI_XEN_IOCTL_PRIVCMD_MMAP_RESOURCE(addr)",
+                  (Addr)&args->addr, sizeof(args->addr));
+      break;
+   }
+   case VKI_XEN_IOCTL_PRIVCMD_UNIMPLEMENTED:
+      break;
 
    case VKI_XEN_IOCTL_EVTCHN_BIND_VIRQ: {
          struct vki_xen_ioctl_evtchn_bind_virq *args =
@@ -9199,6 +9231,80 @@ PRE(sys_ioctl)
    case VKI_XEN_IOCTL_EVTCHN_RESET:
       /* No input*/
       break;
+   case VKI_XEN_IOCTL_GNTDEV_MAP_GRANT_REF: {
+      struct vki_xen_ioctl_gntdev_map_grant_ref *args =
+         (struct vki_xen_ioctl_gntdev_map_grant_ref*)(Addr)(ARG3);
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTDEV_map_grant_ref(count)",
+                  (Addr)&args->count, sizeof(args->count));
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTDEV_map_grant_ref(refs)",
+                  (Addr)args->refs, sizeof(*(args->refs)) * args->count);
+      }
+      break;
+   case VKI_XEN_IOCTL_GNTDEV_UNMAP_GRANT_REF: {
+      struct vki_xen_ioctl_gntdev_map_grant_ref *args =
+         (struct vki_xen_ioctl_gntdev_map_grant_ref*)(Addr)(ARG3);
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTDEV_map_grant_ref(index)",
+                  (Addr)&args->index, sizeof(args->index));
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTDEV_map_grant_ref(count)",
+                  (Addr)&args->count, sizeof(args->count));
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTDEV_map_grant_ref(pad)",
+                  (Addr)&args->pad, sizeof(args->pad));
+      }
+      break;
+   case VKI_XEN_IOCTL_GNTDEV_GET_OFFSET_FOR_VADDR: {
+      struct vki_xen_ioctl_gntdev_get_offset_for_vaddr *args =
+         (struct vki_xen_ioctl_gntdev_get_offset_for_vaddr*)(Addr)(ARG3);
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTDEV_map_grant_ref(vaddr)",
+                  (Addr)&args->vaddr, sizeof(args->vaddr));
+      }
+      break;
+   case VKI_XEN_IOCTL_GNTDEV_SET_MAX_GRANTS: {
+      struct vki_xen_ioctl_gntdev_set_max_grants *args =
+         (struct vki_xen_ioctl_gntdev_set_max_grants*)(Addr)(ARG3);
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTDEV_set_max_grants(count)",
+                  (Addr)&args->count, sizeof(args->count));
+      }
+      break;
+   case VKI_XEN_IOCTL_GNTALLOC_ALLOC_GREF: {
+      struct vki_xen_ioctl_gntalloc_alloc_gref *args =
+         (struct vki_xen_ioctl_gntalloc_alloc_gref*)(Addr)(ARG3);
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTALLOC_alloc_gref(domid)",
+                  (Addr)&args->domid, sizeof(args->domid));
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTALLOC_alloc_gref(flags)",
+                  (Addr)&args->flags, sizeof(args->flags));
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTALLOC_alloc_gref(count)",
+                  (Addr)&args->count, sizeof(args->count));
+      }
+      break;
+   case VKI_XEN_IOCTL_GNTALLOC_DEALLOC_GREF: {
+      struct vki_xen_ioctl_gntalloc_dealloc_gref *args =
+         (struct vki_xen_ioctl_gntalloc_dealloc_gref*)(Addr)(ARG3);
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTALLOC_dealloc_gref(index)",
+                  (Addr)&args->index, sizeof(args->index));
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTALLOC_dealloc_gref(count)",
+                  (Addr)&args->count, sizeof(args->count));
+      }
+      break;
+   case VKI_XEN_IOCTL_GNTALLOC_SET_UNMAP_NOTIFY: {
+      struct vki_xen_ioctl_gntalloc_set_unmap_notify *args =
+         (struct vki_xen_ioctl_gntalloc_set_unmap_notify*)(Addr)(ARG3);
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTALLOC_set_unmap_notify(index)",
+                  (Addr)&args->index, sizeof(args->index));
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTALLOC_set_unmap_notify(action)",
+                  (Addr)&args->action, sizeof(args->action));
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTALLOC_set_unmap_notify(event_channel_port)",
+                  (Addr)&args->event_channel_port, sizeof(args->event_channel_port));
+      }
+      break;
+   case VKI_XEN_IOCTL_GNTDEV_GRANT_COPY: {
+      struct vki_xen_ioctl_gntdev_grant_copy *args =
+         (struct vki_xen_ioctl_gntdev_grant_copy*)(Addr)(ARG3);
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTDEV_grant_copy(count)",
+                  (Addr)&args->count, sizeof(args->count));
+      PRE_MEM_READ("VKI_XEN_IOCTL_GNTDEV_grant_copy(segments)",
+                  (Addr)args->segments, sizeof(*(args->segments)) * args->count);
+      }
+      break;
 #endif
 
    /* Lustre */
@@ -11864,6 +11970,16 @@ POST(sys_ioctl)
        POST_MEM_WRITE((Addr)args->err, sizeof(*(args->err)) * args->num);
       }
       break;
+   case VKI_XEN_IOCTL_PRIVCMD_DM_OP: {
+      struct vki_xen_privcmd_dm_op *args =
+         (struct vki_xen_privcmd_dm_op *)(ARG3);
+      POST_MEM_WRITE((Addr)args->ubufs, sizeof(*(args->ubufs)) * args->num);
+      }
+      break;
+   case VKI_XEN_IOCTL_PRIVCMD_RESTRICT:
+   case VKI_XEN_IOCTL_PRIVCMD_MMAP_RESOURCE:
+   case VKI_XEN_IOCTL_PRIVCMD_UNIMPLEMENTED:
+      break;
 
    case VKI_XEN_IOCTL_EVTCHN_BIND_VIRQ:
    case VKI_XEN_IOCTL_EVTCHN_BIND_INTERDOMAIN:
@@ -11873,6 +11989,44 @@ POST(sys_ioctl)
    case VKI_XEN_IOCTL_EVTCHN_RESET:
       /* No output */
       break;
+   case VKI_XEN_IOCTL_GNTDEV_MAP_GRANT_REF: {
+       struct vki_xen_ioctl_gntdev_map_grant_ref *args =
+            (struct vki_xen_ioctl_gntdev_map_grant_ref*)(Addr)(ARG3);
+       POST_FIELD_WRITE(args->index);
+      }
+      break;
+   case VKI_XEN_IOCTL_GNTDEV_UNMAP_GRANT_REF:
+      /* No output */
+      break;
+   case VKI_XEN_IOCTL_GNTDEV_GET_OFFSET_FOR_VADDR: {
+      struct vki_xen_ioctl_gntdev_get_offset_for_vaddr *args =
+         (struct vki_xen_ioctl_gntdev_get_offset_for_vaddr*)(Addr)(ARG3);
+      POST_FIELD_WRITE(args->count);
+      POST_FIELD_WRITE(args->offset);
+      }
+      break;
+   case VKI_XEN_IOCTL_GNTDEV_SET_MAX_GRANTS:
+      /* No output */
+      break;
+   case VKI_XEN_IOCTL_GNTALLOC_ALLOC_GREF: {
+      struct vki_xen_ioctl_gntalloc_alloc_gref *args =
+         (struct vki_xen_ioctl_gntalloc_alloc_gref*)(Addr)(ARG3);
+      POST_FIELD_WRITE(args->index);
+      POST_FIELD_WRITE(args->count);
+      POST_MEM_WRITE((Addr)&args->gref_ids,
+                     sizeof(args->gref_ids) * sizeof(args->count));
+      }
+      break;
+   case VKI_XEN_IOCTL_GNTALLOC_DEALLOC_GREF:
+   case VKI_XEN_IOCTL_GNTALLOC_SET_UNMAP_NOTIFY:
+      /* No output */
+      break;
+   case VKI_XEN_IOCTL_GNTDEV_GRANT_COPY: {
+      struct vki_xen_ioctl_gntdev_grant_copy *args =
+         (struct vki_xen_ioctl_gntdev_grant_copy*)(Addr)(ARG3);
+      POST_MEM_WRITE((Addr)args->segments, sizeof(*(args->segments)) * args->count);
+      }
+      break;
 #endif
 
    /* Lustre */
Index: valgrind-3.24.0/include/vki/vki-linux.h
===================================================================
--- valgrind-3.24.0.orig/include/vki/vki-linux.h
+++ valgrind-3.24.0/include/vki/vki-linux.h
@@ -3552,12 +3552,37 @@ struct vki_xen_privcmd_mmapbatch_v2 {
         int __user *err;  /* array of error codes */
 };
 
+struct vki_xen_privcmd_dm_op_buf {
+        void __user *uptr;
+        __vki_kernel_size_t size;
+};
+
+struct vki_xen_privcmd_dm_op {
+        __vki_u16 dom;
+        __vki_u16 num;
+        const struct vki_xen_privcmd_dm_op_buf __user *ubufs;
+};
+
+struct vki_xen_privcmd_mmap_resource {
+        __vki_u16 dom;
+        __vki_u32 type;
+        __vki_u32 id;
+        __vki_u32 idx;
+        __vki_u64 num;
+        __vki_u64 addr;
+};
+
 #define VKI_XEN_IOCTL_PRIVCMD_HYPERCALL    _VKI_IOC(_VKI_IOC_NONE, 'P', 0, sizeof(struct vki_xen_privcmd_hypercall))
 #define VKI_XEN_IOCTL_PRIVCMD_MMAP         _VKI_IOC(_VKI_IOC_NONE, 'P', 2, sizeof(struct vki_xen_privcmd_mmap))
 
 #define VKI_XEN_IOCTL_PRIVCMD_MMAPBATCH    _VKI_IOC(_VKI_IOC_NONE, 'P', 3, sizeof(struct vki_xen_privcmd_mmapbatch))
 #define VKI_XEN_IOCTL_PRIVCMD_MMAPBATCH_V2 _VKI_IOC(_VKI_IOC_NONE, 'P', 4, sizeof(struct vki_xen_privcmd_mmapbatch_v2))
 
+#define VKI_XEN_IOCTL_PRIVCMD_DM_OP        _VKI_IOC(_VKI_IOC_NONE, 'P', 5, sizeof(struct vki_xen_privcmd_dm_op))
+#define VKI_XEN_IOCTL_PRIVCMD_RESTRICT     _VKI_IOC(_VKI_IOC_NONE, 'P', 6, sizeof(__vki_u16))
+#define VKI_XEN_IOCTL_PRIVCMD_MMAP_RESOURCE _VKI_IOC(_VKI_IOC_NONE, 'P', 7, sizeof(struct vki_xen_privcmd_mmap_resource))
+#define VKI_XEN_IOCTL_PRIVCMD_UNIMPLEMENTED _VKI_IOC(_VKI_IOC_NONE, 'P', 0xff, 0)
+
 //----------------------------------------------------------------------
 // Xen evtchn IOCTL
 //----------------------------------------------------------------------
@@ -3596,6 +3621,91 @@ struct vki_xen_ioctl_evtchn_notify {
 #define VKI_XEN_IOCTL_EVTCHN_RESET				\
 	_VKI_IOC(_VKI_IOC_NONE, 'E', 5, 0)
 
+//----------------------------------------------------------------------
+// Xen gnttdev IOCTL
+//----------------------------------------------------------------------
+
+#define VKI_XEN_IOCTL_GNTDEV_MAP_GRANT_REF			\
+   _VKI_IOC(_VKI_IOC_NONE, 'G', 0, sizeof(struct vki_xen_ioctl_gntdev_map_grant_ref))
+struct vki_xen_ioctl_gntdev_grant_ref {
+   vki_u32 domid;
+   vki_u32 ref;
+};
+struct vki_xen_ioctl_gntdev_map_grant_ref {
+   vki_u32 count;
+   vki_u32 pad;
+   __vki_u64 index;
+   struct vki_xen_ioctl_gntdev_grant_ref refs[1];
+};
+
+#define VKI_XEN_IOCTL_GNTDEV_UNMAP_GRANT_REF			\
+	_VKI_IOC(_VKI_IOC_NONE, 'G', 1, sizeof(struct vki_xen_ioctl_gntdev_unmap_grant_ref))
+struct vki_xen_ioctl_gntdev_unmap_grant_ref {
+   __vki_u64 index;
+   vki_u32 count;
+   vki_u32 pad;
+};
+
+#define VKI_XEN_IOCTL_GNTDEV_GET_OFFSET_FOR_VADDR			\
+	_VKI_IOC(_VKI_IOC_NONE, 'G', 2, sizeof(struct vki_xen_ioctl_gntdev_get_offset_for_vaddr))
+struct vki_xen_ioctl_gntdev_get_offset_for_vaddr {
+   __vki_u64 vaddr;
+   __vki_u64 offset;
+   vki_u32 count;
+   vki_u32 pad;
+};
+
+#define VKI_XEN_IOCTL_GNTDEV_SET_MAX_GRANTS			\
+	_VKI_IOC(_VKI_IOC_NONE, 'G', 3, sizeof(struct vki_xen_ioctl_gntdev_set_max_grants))
+struct vki_xen_ioctl_gntdev_set_max_grants {
+   vki_u32 count;
+};
+
+#define VKI_XEN_IOCTL_GNTALLOC_ALLOC_GREF			\
+	_VKI_IOC(_VKI_IOC_NONE, 'G', 5, sizeof(struct vki_xen_ioctl_gntalloc_alloc_gref))
+struct vki_xen_ioctl_gntalloc_alloc_gref {
+   vki_u16 domid;
+   vki_u16 flags;
+   vki_u32 count;
+   __vki_u64 index;
+   vki_u32 gref_ids[1];
+};
+
+#define VKI_XEN_IOCTL_GNTALLOC_DEALLOC_GREF			\
+	_VKI_IOC(_VKI_IOC_NONE, 'G', 6, sizeof(struct vki_xen_ioctl_gntalloc_dealloc_gref))
+struct vki_xen_ioctl_gntalloc_dealloc_gref {
+   __vki_u64 index;
+   vki_u32 count;
+};
+
+#define VKI_XEN_IOCTL_GNTALLOC_SET_UNMAP_NOTIFY			\
+	_VKI_IOC(_VKI_IOC_NONE, 'G', 7, sizeof(struct vki_xen_ioctl_gntalloc_set_unmap_notify))
+struct vki_xen_ioctl_gntalloc_set_unmap_notify {
+   __vki_u64 index;
+   vki_u32 action;
+   vki_u32 event_channel_port;
+};
+
+#define VKI_XEN_IOCTL_GNTDEV_GRANT_COPY				\
+	_VKI_IOC(_VKI_IOC_NONE, 'G', 8, sizeof(struct vki_xen_ioctl_gntdev_grant_copy))
+struct vki_xen_gntdev_grant_copy_segment {
+   union {
+      void *virt;
+      struct {
+         vki_u32 ref; /* grant_ref_t */
+         vki_u16 offset;
+         vki_u16 domid; /* domid_t */
+      } foreign;
+   } source, dest;
+   vki_u16 len;
+   vki_u16 flags;  /* GNTCOPY_* */
+   __vki_s16 status; /* GNTST_* */
+};
+
+struct vki_xen_ioctl_gntdev_grant_copy {
+   vki_uint32_t count;
+   struct vki_xen_gntdev_grant_copy_segment *segments;
+};
 
 //----------------------------------------------------------------------
 // From linux-3.4.0/include/linux/fs.h
Index: valgrind-3.24.0/include/vki/vki-xen-memory.h
===================================================================
--- valgrind-3.24.0.orig/include/vki/vki-xen-memory.h
+++ valgrind-3.24.0/include/vki/vki-xen-memory.h
@@ -45,9 +45,14 @@
 #define VKI_XENMEM_get_pod_target       17
 #define VKI_XENMEM_get_sharing_freed_pages    18
 #define VKI_XENMEM_get_sharing_shared_pages   19
+#define VKI_XENMEM_paging_op                  20
 #define VKI_XENMEM_access_op                  21
+#define VKI_XENMEM_sharing_op                 22
+#define VKI_XENMEM_add_to_physmap_batch       23
 #define VKI_XENMEM_claim_pages                24
 #define VKI_XENMEM_machphys_compat_mfn_list   25
+#define VKI_XENMEM_get_vnumainfo              26
+#define VKI_XENMEM_reserved_device_memory_map 27
 
 struct vki_xen_memory_map {
     unsigned int nr_entries;
@@ -93,6 +98,14 @@ struct vki_xen_remove_from_physmap {
     vki_xen_pfn_t gpfn;
 };
 
+struct vki_xen_pod_target {
+    vki_uint64_t    target_pages;
+    vki_uint64_t    tot_pages;
+    vki_uint64_t    pod_cache_pages;
+    vki_uint64_t    pod_entries;
+    vki_xen_domid_t domid;
+};
+
 struct vki_xen_mem_event_op {
     vki_uint8_t     op;
     vki_xen_domid_t     domain;
Index: valgrind-3.24.0/include/vki/vki-xen-gnttab.h
===================================================================
--- valgrind-3.24.0.orig/include/vki/vki-xen-gnttab.h
+++ valgrind-3.24.0/include/vki/vki-xen-gnttab.h
@@ -40,6 +40,7 @@ typedef vki_uint32_t vki_xen_grant_ref_t
 #define VKI_XEN_GNTTABOP_get_status_frames    9
 #define VKI_XEN_GNTTABOP_get_version          10
 #define VKI_XEN_GNTTABOP_swap_grant_ref	      11
+#define VKI_XEN_GNTTABOP_cache_flush          12
 
 struct vki_xen_gnttab_setup_table {
     /* IN parameters. */
Index: valgrind-3.24.0/include/vki/vki-xen-physdev.h
===================================================================
--- valgrind-3.24.0.orig/include/vki/vki-xen-physdev.h
+++ valgrind-3.24.0/include/vki/vki-xen-physdev.h
@@ -58,6 +58,15 @@ struct vki_xen_physdev_unmap_pirq {
     int pirq;
 };
 
+struct vki_physdev_pci_device {
+    /* IN */
+    vki_uint16_t seg;
+    vki_uint8_t bus;
+    vki_uint8_t devfn;
+};
+typedef struct vki_physdev_pci_device vki_physdev_pci_device_t;
+DEFINE_VKI_XEN_GUEST_HANDLE(vki_physdev_pci_device_t);
+
 #endif // __VKI_XEN_PHYSDEV_H
 
 /*--------------------------------------------------------------------*/
Index: valgrind-3.24.0/include/vki/vki-xen-schedop.h
===================================================================
--- valgrind-3.24.0.orig/include/vki/vki-xen-schedop.h
+++ valgrind-3.24.0/include/vki/vki-xen-schedop.h
@@ -45,4 +45,6 @@ typedef struct vki_xen_remote_shutdown v
 
 #define VKI_XEN_SCHEDOP_watchdog        6
 
+#define VKI_XEN_SCHEDOP_pin_override    7
+
 #endif /* __VKI_XEN_SCHED_OP_H */
Index: valgrind-3.24.0/include/vki/vki-xen-version.h
===================================================================
--- valgrind-3.24.0.orig/include/vki/vki-xen-version.h
+++ valgrind-3.24.0/include/vki/vki-xen-version.h
@@ -36,6 +36,7 @@
 #define VKI_XENVER_pagesize 7
 #define VKI_XENVER_guest_handle 8
 #define VKI_XENVER_commandline 9
+#define VKI_XENVER_build_id 10
 
 typedef char vki_xen_extraversion_t[16];
 
@@ -61,6 +62,16 @@ struct vki_xen_feature_info {
 
 typedef char vki_xen_commandline_t[1024];
 
+struct vki_xen_build_id {
+    unsigned int len;    /* IN: size of buf[]. */
+#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+    unsigned char   buf[];
+#elif defined(__GNUC__)
+    unsigned char   buf[1]; /* OUT: Variable length buffer with build_id. */
+#endif
+
+};
+
 #endif // __VKI_XEN_VERSION_H
 
 /*--------------------------------------------------------------------*/
Index: valgrind-3.24.0/include/vki/vki-xen-x86.h
===================================================================
--- valgrind-3.24.0.orig/include/vki/vki-xen-x86.h
+++ valgrind-3.24.0/include/vki/vki-xen-x86.h
@@ -281,6 +281,20 @@ struct vki_hvm_hw_mtrr {
 
 VKI_DECLARE_HVM_SAVE_TYPE(MTRR, 14, struct vki_hvm_hw_mtrr);
 
+struct vki_xen_cpuid_leaf_00000012 {
+    vki_uint32_t leaf, subleaf;
+    vki_uint32_t a, b, c, d;
+};
+typedef struct vki_xen_cpuid_leaf_00000012 vki_xen_cpuid_leaf_00000012_t;
+DEFINE_VKI_XEN_GUEST_HANDLE(vki_xen_cpuid_leaf_00000012_t);
+
+struct vki_xen_msr_entry_00000012 {
+    vki_uint32_t leaf, subleaf;
+    vki_uint32_t a, b, c, d;
+};
+typedef struct vki_xen_msr_entry_00000012 vki_xen_msr_entry_00000012_t;
+DEFINE_VKI_XEN_GUEST_HANDLE(vki_xen_msr_entry_00000012_t);
+
 #endif // __VKI_XEN_H
 
 /*--------------------------------------------------------------------*/
