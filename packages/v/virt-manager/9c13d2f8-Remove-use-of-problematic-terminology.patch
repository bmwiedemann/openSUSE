Subject: Remove use of problematic terminology
From: Cole Robinson crobinso@redhat.com Wed Sep 23 14:33:17 2020 -0400
Date: Wed Sep 23 14:33:17 2020 -0400:
Git: 9c13d2f8788414f1ab5b0300ce82b5d9ce277880

Following kernel recommendation here:
https://lkml.org/lkml/2020/7/4/229

Signed-off-by: Cole Robinson <crobinso@redhat.com>

Index: virt-manager-3.0.0/man/virt-install.rst
===================================================================
--- virt-manager-3.0.0.orig/man/virt-install.rst
+++ virt-manager-3.0.0/man/virt-install.rst
@@ -1247,7 +1247,7 @@ Connect the guest to the host network. E
     Tell virt-install not to add any default network interface.
 
 If ``--network`` is omitted a single NIC will be created in the guest. If
-there is a bridge device in the host with a physical interface enslaved,
+there is a bridge device in the host with a physical interface attached,
 that will be used for connectivity. Failing that, the virtual network
 called ``default`` will be used. This option can be specified multiple
 times to setup more than one NIC.
Index: virt-manager-3.0.0/tests/uitests/test_addhardware.py
===================================================================
--- virt-manager-3.0.0.orig/tests/uitests/test_addhardware.py
+++ virt-manager-3.0.0/tests/uitests/test_addhardware.py
@@ -310,7 +310,7 @@ class AddHardware(lib.testcase.UITestCas
         self.app.open(break_setfacl=True)
         details = self.app.open_details_window("test-clone-simple")
 
-        # Say 'Yes' and it should fail, then blacklist the paths
+        # Say 'Yes' and it should fail, then denylist the paths
         addhw = self._open_addhw_window(details)
         tab = self._select_hw(addhw, "Storage", "storage-tab")
         tab.find_fuzzy("Select or create", "radio").click()
Index: virt-manager-3.0.0/tests/uitests/test_connection.py
===================================================================
--- virt-manager-3.0.0.orig/tests/uitests/test_connection.py
+++ virt-manager-3.0.0/tests/uitests/test_connection.py
@@ -15,7 +15,7 @@ class UITestConnection(lib.testcase.UITe
 
     def testConnectionBlacklist(self):
         self.app.open(
-            extra_opts=["--test-options=object-blacklist=test-many-devices"])
+            extra_opts=["--test-options=object-denylist=test-many-devices"])
         manager = self.app.topwin
 
         def _delete_vm(vmname):
Index: virt-manager-3.0.0/virtManager/connection.py
===================================================================
--- virt-manager-3.0.0.orig/virtManager/connection.py
+++ virt-manager-3.0.0/virtManager/connection.py
@@ -38,46 +38,46 @@ class _ObjectList(vmmGObject):
         vmmGObject.__init__(self)
 
         self._objects = []
-        self._blacklist = {}
+        self._denylist = {}
         self._lock = threading.Lock()
 
     def _cleanup(self):
         self._objects = []
 
-    def _blacklist_key(self, obj):
+    def _denylist_key(self, obj):
         return str(obj.__class__) + obj.get_name()
 
-    def add_blacklist(self, obj):
+    def add_denylist(self, obj):
         """
-        Add an object to the blacklist. Basically a list of objects we
+        Add an object to the denylist. Basically a list of objects we
         choose not to poll, because they threw an error at init time
 
-        :param obj: vmmLibvirtObject to blacklist
+        :param obj: vmmLibvirtObject to denylist
         :returns: number of added object to list
         """
-        key = self._blacklist_key(obj)
-        count = self._blacklist.get(key, 0)
-        self._blacklist[key] = count + 1
-        return self._blacklist[key]
+        key = self._denylist_key(obj)
+        count = self._denylist.get(key, 0)
+        self._denylist[key] = count + 1
+        return self._denylist[key]
 
-    def remove_blacklist(self, obj):
+    def remove_denylist(self, obj):
         """
-        :param obj: vmmLibvirtObject to remove from blacklist
-        :returns: True if object was blacklisted or False otherwise.
+        :param obj: vmmLibvirtObject to remove from denylist
+        :returns: True if object was denylisted or False otherwise.
         """
-        key = self._blacklist_key(obj)
-        return bool(self._blacklist.pop(key, 0))
+        key = self._denylist_key(obj)
+        return bool(self._denylist.pop(key, 0))
 
-    def in_blacklist(self, obj):
+    def in_denylist(self, obj):
         """
-        If an object is in list only once don't consider it blacklisted,
+        If an object is in list only once don't consider it denylisted,
         give it one more chance.
 
         :param obj: vmmLibvirtObject to check
-        :returns: True if object is blacklisted
+        :returns: True if object is denylisted
         """
-        key = self._blacklist_key(obj)
-        return self._blacklist.get(key, 0) >= _ObjectList.BLACKLIST_COUNT
+        key = self._denylist_key(obj)
+        return self._denylist.get(key, 0) >= _ObjectList.BLACKLIST_COUNT
 
     def remove(self, obj):
         """
@@ -90,7 +90,7 @@ class _ObjectList(vmmGObject):
             # Identity check is sufficient here, since we should never be
             # asked to remove an object that wasn't at one point in the list.
             if obj not in self._objects:
-                return self.remove_blacklist(obj)
+                return self.remove_denylist(obj)
 
             self._objects.remove(obj)
             return True
@@ -1060,11 +1060,11 @@ class vmmConnection(vmmGObject):
 
             if initialize_failed:
                 log.debug("Blacklisting %s=%s", class_name, obj.get_name())
-                count = self._objects.add_blacklist(obj)
-                log.debug("Object added in blacklist, count=%d", count)
+                count = self._objects.add_denylist(obj)
+                log.debug("Object added in denylist, count=%d", count)
                 return
 
-            self._objects.remove_blacklist(obj)
+            self._objects.remove_denylist(obj)
             if not self._objects.add(obj):
                 log.debug("New %s=%s requested, but it's already tracked.",
                     class_name, obj.get_name())
@@ -1134,7 +1134,7 @@ class vmmConnection(vmmGObject):
 
             gone_objects.extend(gone)
             preexisting_objects.extend([o for o in master if o not in new])
-            new = [n for n in new if not self._objects.in_blacklist(n)]
+            new = [n for n in new if not self._objects.in_denylist(n)]
             return new
 
         new_vms = _process_objects("vms")
Index: virt-manager-3.0.0/virtManager/lib/testmock.py
===================================================================
--- virt-manager-3.0.0.orig/virtManager/lib/testmock.py
+++ virt-manager-3.0.0/virtManager/lib/testmock.py
@@ -157,7 +157,7 @@ class CLITestOptionsClass:
         Spice doesn't return values here when we are just testing
         against seabios in uitests, this fakes it to hit more code paths
     * fake-systray: Enable the fake systray window
-    * object-blacklist=NAME: Make object initialize for that name
+    * object-denylist=NAME: Make object initialize for that name
         fail to test some connection code paths
     * conn-crash: Test connection abruptly closing like when
         libvirtd is restarted.
@@ -205,7 +205,7 @@ class CLITestOptionsClass:
         self.fake_vnc_username = _get("fake-vnc-username")
         self.fake_console_resolution = _get("fake-console-resolution")
         self.fake_systray = _get("fake-systray")
-        self.object_blacklist = _get_value("object-blacklist")
+        self.object_denylist = _get_value("object-denylist")
         self.conn_crash = _get("conn-crash")
         self.fake_agent_event = _get_value("fake-agent-event")
         self.fake_nodedev_event = _get_value("fake-nodedev-event")
Index: virt-manager-3.0.0/virtManager/object/domain.py
===================================================================
--- virt-manager-3.0.0.orig/virtManager/object/domain.py
+++ virt-manager-3.0.0/virtManager/object/domain.py
@@ -393,7 +393,7 @@ class vmmDomain(vmmLibvirtObject):
             self.get_uuid() == "00000000-0000-0000-0000-000000000000"):
             # We don't want virt-manager to track Domain-0 since it
             # doesn't work with our UI. Raising an error will ensures it
-            # is blacklisted.
+            # is denylisted.
             raise RuntimeError(  # pragma: no cover
                     "Can't track Domain-0 as a vmmDomain")
 
Index: virt-manager-3.0.0/virtManager/object/libvirtobject.py
===================================================================
--- virt-manager-3.0.0.orig/virtManager/object/libvirtobject.py
+++ virt-manager-3.0.0/virtManager/object/libvirtobject.py
@@ -171,7 +171,7 @@ class vmmLibvirtObject(vmmGObject):
 
         initialize_failed = False
         try:
-            if self.config.CLITestOptions.object_blacklist == self._name:
+            if self.config.CLITestOptions.object_denylist == self._name:
                 raise RuntimeError("fake initialization error")
 
             self._init_libvirt_state()
Index: virt-manager-3.0.0/virtinst/devices/graphics.py
===================================================================
--- virt-manager-3.0.0.orig/virtinst/devices/graphics.py
+++ virt-manager-3.0.0/virtinst/devices/graphics.py
@@ -151,7 +151,7 @@ class DeviceGraphics(Device):
     def _spice_supported(self):
         if not self.conn.is_qemu() and not self.conn.is_test():
             return False
-        # Spice has issues on some host arches, like ppc, so whitelist it
+        # Spice has issues on some host arches, like ppc, so allow it
         if self.conn.caps.host.cpu.arch not in ["i686", "x86_64"]:
             return False
         return True
Index: virt-manager-3.0.0/virtinst/devices/interface.py
===================================================================
--- virt-manager-3.0.0.orig/virtinst/devices/interface.py
+++ virt-manager-3.0.0/virtinst/devices/interface.py
@@ -72,7 +72,7 @@ def _host_default_bridge():
         return dev  # pragma: no cover
 
     # Old style, peth0 == phys dev, eth0 == netloop, xenbr0 == bridge,
-    # vif0.0 == netloop enslaved, eth0 == default route
+    # vif0.0 == netloop attached, eth0 == default route
     try:
         defn = int(dev[-1])
     except Exception:  # pragma: no cover
