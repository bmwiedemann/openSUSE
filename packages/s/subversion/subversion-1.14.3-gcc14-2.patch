------------------------------------------------------------------------
r1915239 | futatuki | 2024-01-14 20:45:41 +0100 (Sun, 14 Jan 2024) | 15 lines

swig-rb: Add type casting for some generic function pointers

With r1915236 and this commit, we can build swig-rb by using clang 16
without masking int-conversion and incompatible-function-pointer-types
errors.

* subversion/bindings/swig/ruby/libsvn_swig_ruby/swigutil_rb.c
  (svn_swig_rb_set_pool, svn_swig_rb_set_pool_for_no_swig_type,
  svn_swig_rb_to_apr_array_row_prop, svn_swig_rb_to_apr_array_prop,
  r2c_hash, invoke_callback, callback_handle_error,
  invoke_callback_handle_error, svn_swig_rb_set_baton):
   Add type casting for generic functions in Ruby C API functions. 
  (svn_swig_rb_hash_to_apr_hash_swig_type):
   Add type casting for generic function on apr_hash_t

------------------------------------------------------------------------
Index: trunk/subversion/bindings/swig/ruby/libsvn_swig_ruby/swigutil_rb.c
===================================================================
--- trunk/subversion/bindings/swig/ruby/libsvn_swig_ruby/swigutil_rb.c	(revision 1915238)
+++ trunk/subversion/bindings/swig/ruby/libsvn_swig_ruby/swigutil_rb.c	(revision 1915239)
@@ -788,7 +788,7 @@
     struct rb_set_pool_for_hash_arg arg;
     arg.set = FALSE;
     arg.pool = pool;
-    rb_hash_foreach(target, rb_set_pool_for_hash_callback, (VALUE)&arg);
+    rb_hash_foreach(target, (int(*)(ANYARGS))rb_set_pool_for_hash_callback, (VALUE)&arg);
     return arg.set;
   } else {
     return rb_set_pool_if_swig_type_object(target, pool);
@@ -806,7 +806,7 @@
     target = rb_ary_new3(1, target);
   }
 
-  rb_iterate(rb_each, target, rb_set_pool, pool);
+  rb_iterate((VALUE(*)())rb_each, target, (VALUE(*)())rb_set_pool, pool);
 }
 
 void
@@ -1070,7 +1070,8 @@
     result = apr_array_make(pool, 0, sizeof(svn_prop_t));
     arg.array = result;
     arg.pool = pool;
-    rb_hash_foreach(array_or_hash, svn_swig_rb_to_apr_array_row_prop_callback,
+    rb_hash_foreach(array_or_hash,
+                    (int(*)(ANYARGS))svn_swig_rb_to_apr_array_row_prop_callback,
                     (VALUE)&arg);
     return result;
   } else {
@@ -1125,7 +1126,8 @@
     result = apr_array_make(pool, 0, sizeof(svn_prop_t *));
     arg.array = result;
     arg.pool = pool;
-    rb_hash_foreach(array_or_hash, svn_swig_rb_to_apr_array_prop_callback,
+    rb_hash_foreach(array_or_hash,
+                    (int(*)(ANYARGS))svn_swig_rb_to_apr_array_prop_callback,
                     (VALUE)&arg);
     return result;
   } else {
@@ -1548,7 +1550,7 @@
     data.func = func;
     data.pool = pool;
 
-    rb_hash_foreach(hash, r2c_hash_i, (VALUE)&data);
+    rb_hash_foreach(hash, (int(*)(ANYARGS))r2c_hash_i, (VALUE)&data);
 
     return apr_hash;
   }
@@ -1570,7 +1572,9 @@
 apr_hash_t *
 svn_swig_rb_hash_to_apr_hash_swig_type(VALUE hash, const char *typename, apr_pool_t *pool)
 {
-  return r2c_hash(hash, r2c_swig_type, (void *)typename, pool);
+  /* Note: casting to r2c_cunc for r2c_swig_type may unsafe, because
+         it contains the cast from "const void *" to "void *" */
+  return r2c_hash(hash, (r2c_func)r2c_swig_type, (void *)typename, pool);
 }
 
 apr_hash_t *
@@ -1651,7 +1655,8 @@
   argv[0] = pool;
   svn_swig_rb_get_pool(1, argv, Qnil, &subpool, NULL);
   cbb->pool = subpool;
-  return rb_ensure(callback, baton, callback_ensure, subpool);
+  return rb_ensure((VALUE(*)(ANYARGS))callback, baton,
+                   (VALUE(*)(ANYARGS))callback_ensure, subpool);
 }
 
 static VALUE
@@ -1660,9 +1665,9 @@
   callback_handle_error_baton_t *handle_error_baton;
   handle_error_baton = (callback_handle_error_baton_t *)baton;
 
-  return rb_rescue2(callback,
+  return rb_rescue2((VALUE(*)(ANYARGS))callback,
                     (VALUE)(handle_error_baton->callback_baton),
-                    callback_rescue,
+                    (VALUE(*)(ANYARGS))callback_rescue,
                     (VALUE)(handle_error_baton->rescue_baton),
                     rb_svn_error(),
                     (VALUE)0);
@@ -1681,8 +1686,9 @@
   handle_error_baton.callback_baton = cbb;
   handle_error_baton.rescue_baton = &rescue_baton;
 
-  return rb_ensure(callback_handle_error, (VALUE)&handle_error_baton,
-                   callback_ensure, pool);
+  return rb_ensure((VALUE(*)(ANYARGS))callback_handle_error,
+                   (VALUE)&handle_error_baton,
+                   (VALUE(*)(ANYARGS))callback_ensure, pool);
 }
 
 
@@ -1735,7 +1741,8 @@
     target = rb_ary_new3(1, target);
   }
 
-  rb_iterate(rb_each, target, add_baton_if_delta_editor, baton);
+  rb_iterate((VALUE(*)())rb_each, target,
+             (VALUE(*)())add_baton_if_delta_editor, baton);
 }
 
 
