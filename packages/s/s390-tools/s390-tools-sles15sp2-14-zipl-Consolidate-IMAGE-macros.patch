Subject: [PATCH] [FEAT VS1804] zipl: Consolidate IMAGE macros
From: Marc Hartmayer <mhartmay@linux.ibm.com>

Summary:     genprotimg: Introduce new tool for the creation of PV images
Description: genprotimg takes a kernel, host-key documents, optionally an
             initrd, optionally a file with the kernel command line, and it
             generates a single, loadable image file. The image consists of a
             concatenation of a plain text boot loader, the encrypted
             components for kernel, initrd, and cmdline, and the
             integrity-protected PV header, containing metadata necessary for
             running the guest in PV mode. It's possible to use this image file
             as a kernel for zIPL or for a direct kernel boot using QEMU.
Upstream-ID: cb614ed1ee61f05fb521a7e3ac0d27eb2eb45672
Problem-ID:  VS1804

Upstream-Description:

             zipl: Consolidate IMAGE macros

             Combine the different macros for 0x10000 and use a consistent naming
             schema.

             Signed-off-by: Philipp Rudo <prudo@linux.ibm.com>
             Reviewed-by: Stefan Haberland <sth@linux.ibm.com>
             Signed-off-by: Jan HÃ¶ppner <hoeppner@linux.ibm.com>


Signed-off-by: Marc Hartmayer <mhartmay@linux.ibm.com>
---
 zipl/boot/stage3.c  |    7 ++++---
 zipl/boot/stage3.h  |    2 --
 zipl/include/zipl.h |    8 +++++---
 zipl/src/bootmap.c  |    8 ++++----
 zipl/src/job.c      |   17 +++++++++--------
 5 files changed, 22 insertions(+), 20 deletions(-)

--- a/zipl/boot/stage3.c
+++ b/zipl/boot/stage3.c
@@ -13,6 +13,7 @@
 #include "s390.h"
 #include "stage3.h"
 #include "error.h"
+#include "zipl.h"
 
 #define for_each_rb_entry(entry, rb) \
 	for (entry = rb->entries; \
@@ -272,7 +273,7 @@ void start(void)
 	 * verified component. If it is not IPL is aborted.
 	 */
 	if (secure_boot_enabled()) {
-		if (_image_addr != DEFAULT_IMAGE_ADDR ||
+		if (_image_addr != IMAGE_LOAD_ADDRESS ||
 		    _load_psw != DEFAULT_PSW_LOAD)
 			panic(ESECUREBOOT, "%s", msg_sipl_inval);
 
@@ -283,8 +284,8 @@ void start(void)
 	 * cut the kernel header
 	 */
 	memmove((void *)_image_addr,
-		(void *)_image_addr + KERNEL_HEADER_SIZE,
-		_image_len - KERNEL_HEADER_SIZE);
+		(void *)_image_addr + IMAGE_LOAD_ADDRESS,
+		_image_len - IMAGE_LOAD_ADDRESS);
 
 	/* store subchannel ID into low core and into new kernel space */
 	subchannel_id = S390_lowcore.subchannel_id;
--- a/zipl/boot/stage3.h
+++ b/zipl/boot/stage3.h
@@ -29,10 +29,8 @@
 
 #define IPL_FLAG_SECURE		 0x40
 
-#define DEFAULT_IMAGE_ADDR	 0x10000
 #define DEFAULT_PSW_LOAD	 0x0008000080010000UL
 #define PSW_ADDR_MASK		 0x000000007FFFFFFFUL
-#define KERNEL_HEADER_SIZE	 65536
 
 #define UNSPECIFIED_ADDRESS		-1UL
 
--- a/zipl/include/zipl.h
+++ b/zipl/include/zipl.h
@@ -19,13 +19,15 @@
 #define ZIPL_MAGIC_SIZE			4
 #define DISK_LAYOUT_ID			0x00000001
 
+#define IMAGE_ENTRY			0x10000UL
+#define IMAGE_ENTRY_KDUMP		0x10010UL
+
 #define ZIPL_STAGE2_LOAD_ADDRESS	0x2000UL
 #define ZIPL_STAGE3_ENTRY_ADDRESS	0xa000UL
-#define DEFAULT_IMAGE_ADDRESS		0x10000UL
-#define KDUMP_IMAGE_ADDRESS		0x10010UL
 #define DEFAULT_STAGE3_ADDRESS		0xa000UL
 #define DEFAULT_STAGE3_PARAMS_ADDRESS	0x9000UL
-#define MINIMUM_ADDRESS			0x10000UL
+#define IMAGE_LOAD_ADDRESS		IMAGE_ENTRY
+
 #define ADDRESS_LIMIT			0x80000000UL
 #define ADDRESS_LIMIT_KDUMP		0x2000000UL /* HSA size: 32 MiB */
 #define UNSPECIFIED_ADDRESS		-1UL
--- a/zipl/src/bootmap.c
+++ b/zipl/src/bootmap.c
@@ -644,8 +644,8 @@ add_ipl_program(int fd, struct job_ipl_d
 	rc = boot_get_stage3_parms(&stage3_params, &stage3_params_size,
 				   ipl->parm_addr, ipl->ramdisk_addr,
 				   ramdisk_size,
-				   ipl->is_kdump ? ipl->image_addr + 0x10 :
-				   ipl->image_addr,
+				   ipl->is_kdump ? IMAGE_ENTRY_KDUMP :
+				   IMAGE_ENTRY,
 				   (info->type == disk_type_scsi) ? 0 : 1,
 				   flags, ipl->image_addr, image_size);
 	if (rc) {
@@ -1187,7 +1187,7 @@ bootmap_create(struct job_data *job, dis
 		ulong unused_size;
 
 		/* Use approximated stage 3 size as starting point */
-		size = MINIMUM_ADDRESS;
+		size = IMAGE_LOAD_ADDRESS;
 
 		/* Ramdisk */
 		if (job->data.dump.ramdisk != NULL) {
@@ -1199,7 +1199,7 @@ bootmap_create(struct job_data *job, dis
 		/* Kernel */
 		if (stat(job->data.dump.image, &st))
 			goto out_misc_free_temp_dev;
-		size += DIV_ROUND_UP(st.st_size - 0x10000,
+		size += DIV_ROUND_UP(st.st_size - IMAGE_LOAD_ADDRESS,
 				     info->phy_block_size);
 		/* Parmfile */
 		size += DIV_ROUND_UP(DUMP_PARAM_MAX_LEN, info->phy_block_size);
--- a/zipl/src/job.c
+++ b/zipl/src/job.c
@@ -23,6 +23,7 @@
 #include "job.h"
 #include "misc.h"
 #include "scan.h"
+#include "zipl.h"
 
 /* Command line options */
 static struct option options[] = {
@@ -663,12 +664,12 @@ check_component_address_data(struct comp
 				     address_limit);
 			return -1;
 		}
-		if (*cl[i].addrp < MINIMUM_ADDRESS) {
+		if (*cl[i].addrp < IMAGE_LOAD_ADDRESS) {
 			if (name != NULL)
 				error_text("Section '%s'", name);
 			error_reason("Component '%s' falls below available "
 				     "address space (limit is 0x%08x)",
-				     cl[i].name, MINIMUM_ADDRESS);
+				     cl[i].name, IMAGE_LOAD_ADDRESS);
 			return -1;
 		}
 	}
@@ -706,12 +707,12 @@ finalize_component_address_data(struct c
 		for (j = -1; j < i; j++) {
 			if (j < 0) {
 				/* Try address before first component */
-				addr = MINIMUM_ADDRESS;
+				addr = IMAGE_LOAD_ADDRESS;
 			} else {
 				/* Try address after component j */
 				addr = *cl[j].addrp + cl[j].size;
-				if (addr < MINIMUM_ADDRESS)
-					addr = MINIMUM_ADDRESS;
+				if (addr < IMAGE_LOAD_ADDRESS)
+					addr = IMAGE_LOAD_ADDRESS;
 			}
 			addr = ALIGN(addr, cl[i].align);
 			if (addr + cl[i].size > address_limit) {
@@ -905,7 +906,7 @@ check_job_dump_images(struct job_dump_da
 	dump->image = misc_strdup(ZFCPDUMP_IMAGE);
 	if (dump->image == NULL)
 		return -1;
-	dump->image_addr = DEFAULT_IMAGE_ADDRESS;
+	dump->image_addr = IMAGE_LOAD_ADDRESS;
 
 	/* Ramdisk is no longer required with new initramfs dump system */
 	if (misc_check_readable_file(ZFCPDUMP_INITRD))
@@ -1351,7 +1352,7 @@ get_job_from_section_data(char* data[],
 			return -1;
 		if (extract_address(job->data.ipl.image,
 				    &job->data.ipl.image_addr)) {
-			job->data.ipl.image_addr = DEFAULT_IMAGE_ADDRESS;
+			job->data.ipl.image_addr = IMAGE_LOAD_ADDRESS;
 		}
 		/* Fill in parmline */
 		rc = get_parmline(data[(int) scan_keyword_parmfile],
@@ -1406,7 +1407,7 @@ get_job_from_section_data(char* data[],
 			return -1;
 		if (extract_address(job->data.ipl_tape.image,
 				    &job->data.ipl_tape.image_addr)) {
-			job->data.ipl_tape.image_addr = DEFAULT_IMAGE_ADDRESS;
+			job->data.ipl_tape.image_addr = IMAGE_LOAD_ADDRESS;
 		}
 		/* Fill in parmline */
 		rc = get_parmline(data[(int) scan_keyword_parmfile],
