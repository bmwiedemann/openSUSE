Subject: [PATCH] [FEAT VS1804] zipl: use STATIC_ASSERT macro for no padding verification
From: Marc Hartmayer <mhartmay@linux.ibm.com>

Summary:     genprotimg: Introduce new tool for the creation of PV images
Description: genprotimg takes a kernel, host-key documents, optionally an
             initrd, optionally a file with the kernel command line, and it
             generates a single, loadable image file. The image consists of a
             concatenation of a plain text boot loader, the encrypted
             components for kernel, initrd, and cmdline, and the
             integrity-protected PV header, containing metadata necessary for
             running the guest in PV mode. It's possible to use this image file
             as a kernel for zIPL or for a direct kernel boot using QEMU.
Upstream-ID: cc16e41595d6dcb942f84443f27a1b52d06d17da
Problem-ID:  VS1804

Upstream-Description:

             zipl: use STATIC_ASSERT macro for no padding verification

             A simple comment above the struct declaration to indicate that the
             structure must not have any padding is prone to error. Therefore let's
             add a check for the structure size at compile time.

             Reviewed-by: Jan Höppner <hoeppner@linux.ibm.com>
             Signed-off-by: Marc Hartmayer <mhartmay@linux.ibm.com>
             Signed-off-by: Jan Höppner <hoeppner@linux.ibm.com>


Signed-off-by: Marc Hartmayer <mhartmay@linux.ibm.com>
---
 zipl/boot/sclp.h        |    2 ++
 zipl/boot/sclp_stage3.h |    2 ++
 zipl/boot/stage3.h      |    4 ++++
 3 files changed, 8 insertions(+)

--- a/zipl/boot/sclp.h
+++ b/zipl/boot/sclp.h
@@ -60,6 +60,7 @@ struct sccb_header {
 	uint8_t      control_mask[3];
 	uint16_t     response_code;
 };
+STATIC_ASSERT(sizeof(struct sccb_header) == 2 + 1 + 3 + 2)
 
 /* Structure must not have any padding */
 struct evbuf_header {
@@ -68,6 +69,7 @@ struct evbuf_header {
 	uint8_t      flags;
 	uint16_t     _reserved;
 };
+STATIC_ASSERT(sizeof(struct evbuf_header) == 2 + 1 + 1 + 2)
 
 struct mto {
 	uint16_t length;
--- a/zipl/boot/sclp_stage3.h
+++ b/zipl/boot/sclp_stage3.h
@@ -42,6 +42,8 @@ struct sdias_sccb {
 	struct sccb_header  header;
 	struct sdias_evbuf  evbuf;
 };
+STATIC_ASSERT(sizeof(struct sdias_sccb) ==
+	      sizeof(struct sccb_header) + sizeof(struct sdias_evbuf))
 
 
 int sclp_hsa_copy(void *, unsigned long, unsigned long);
--- a/zipl/boot/stage3.h
+++ b/zipl/boot/stage3.h
@@ -15,6 +15,8 @@
 #include "libc.h"
 #include "s390.h"
 
+#include "lib/zt_common.h"
+
 #define IPL_DEVICE		 0x10404UL
 #define INITRD_START		 0x10408UL
 #define INITRD_SIZE		 0x10410UL
@@ -128,6 +130,7 @@ struct ipl_rb_hdr {
 	uint8_t  rbt;
 	uint8_t  reserved1[11];
 };
+STATIC_ASSERT(sizeof(struct ipl_rb_hdr) == 4 + 1 + 11)
 
 /* IPL Report Block types */
 enum ipl_rbt {
@@ -168,6 +171,7 @@ struct ipl_rb_components {
 	uint8_t  reserved1[11];
 	struct ipl_rb_component_entry entries[];
 };
+STATIC_ASSERT(sizeof(struct ipl_rb_components) == 4 + 1 + 11)
 
 extern unsigned long long _parm_addr;   /* address of parmline */
 extern unsigned long long _initrd_addr; /* address of initrd */
