From 93216d916c479ee1292aa1d598ac9c0e7f585bd8 Mon Sep 17 00:00:00 2001
From: Steffen Eiden <seiden@linux.ibm.com>
Date: Wed, 12 Jun 2024 16:35:15 +0200
Subject: [PATCH] rust/pv*: Support longer secret lists
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Make use of the enhanced list secrets UAPI for the uvdevice in the latest kernel
version. This allows fetching secret lists with more than 85 entries via
reserving more userspace memory in the IOCTL argument.

While at it, move the errno readout next to the ioctl-syscall.

Acked-by: Marc Hartmayer <marc@linux.ibm.com>
Reviewed-by: Christoph Schlameuss <schlameuss@linux.ibm.com>
Signed-off-by: Steffen Eiden <seiden@linux.ibm.com>
Signed-off-by: Jan HÃ¶ppner <hoeppner@linux.ibm.com>
---
 rust/pv_core/src/uvdevice.rs        |  6 ++++--
 rust/pv_core/src/uvdevice/secret.rs | 11 +++++++++++
 rust/pvsecret/src/cmd/list.rs       | 28 +++++++++++++++++++++-------
 3 files changed, 36 insertions(+), 9 deletions(-)

diff --git a/rust/pv_core/src/uvdevice.rs b/rust/pv_core/src/uvdevice.rs
index e701366d..689748a1 100644
--- a/rust/pv_core/src/uvdevice.rs
+++ b/rust/pv_core/src/uvdevice.rs
@@ -59,11 +59,13 @@ fn ioctl_raw(raw_fd: RawFd, cmd: c_ulong, cb: &mut IoctlCb) -> Result<()> {
         rc = ioctl(raw_fd, cmd, cb.as_ptr_mut());
     }
 
+    // NOTE io::Error handles all errnos ioctl uses
+    let errno = std::io::Error::last_os_error();
+
     debug!("ioctl resulted with {cb:?}");
     match rc {
         0 => Ok(()),
-        // NOTE io::Error handles all errnos ioctl uses
-        _ => Err(std::io::Error::last_os_error().into()),
+        _ => Err(errno.into()),
     }
 }
 
diff --git a/rust/pv_core/src/uvdevice/secret.rs b/rust/pv_core/src/uvdevice/secret.rs
index 263f17d5..cb5b7233 100644
--- a/rust/pv_core/src/uvdevice/secret.rs
+++ b/rust/pv_core/src/uvdevice/secret.rs
@@ -24,6 +24,17 @@ impl ListCmd {
         Self(vec![0; size])
     }
 
+    /// Create a new list secrets command with `pages` capacity.
+    ///
+    /// * `pages` - number pf pages to allocate for this IOCTL
+    ///
+    /// # Panic
+    /// This function will trigger a panic if the allocation size is larger than [`usize::MAX`].
+    /// Very likely an OOM situation occurs way before this!
+    pub fn with_pages(pages: usize) -> Self {
+        Self::with_size(pages * PAGESIZE)
+    }
+
     /// Create a new list secrets command with a one page capacity
     pub fn new() -> Self {
         Self::with_size(PAGESIZE)
diff --git a/rust/pvsecret/src/cmd/list.rs b/rust/pvsecret/src/cmd/list.rs
index 0bd9eca4..56294cac 100644
--- a/rust/pvsecret/src/cmd/list.rs
+++ b/rust/pvsecret/src/cmd/list.rs
@@ -2,19 +2,33 @@
 //
 // Copyright IBM Corp. 2023
 
+use std::io::ErrorKind;
+
 use crate::cli::{ListSecretOpt, ListSecretOutputType};
 use anyhow::{Context, Error, Result};
-use log::warn;
-use pv::uv::{ListCmd, SecretList, UvDevice, UvcSuccess};
+use log::{info, warn};
+use pv::uv::{ListCmd, SecretList, UvDevice};
 use utils::{get_writer_from_cli_file_arg, STDOUT};
 
+const SECRET_LIST_BUF_SIZE: usize = 4;
+
 /// Do a List Secrets UVC
 pub fn list_uvc(uv: &UvDevice) -> Result<SecretList> {
-    let mut cmd = ListCmd::default();
-    match uv.send_cmd(&mut cmd)? {
-        UvcSuccess::RC_SUCCESS => (),
-        UvcSuccess::RC_MORE_DATA => warn!("There is more data available than expected"),
-    };
+    let mut cmd = ListCmd::with_pages(SECRET_LIST_BUF_SIZE);
+    let more_data = match uv.send_cmd(&mut cmd) {
+        Ok(v) => Ok(v),
+        Err(pv::PvCoreError::Io(e)) if e.kind() == ErrorKind::InvalidInput => {
+            info!("Uvdevice does not suport longer list. Fallback to one page list.");
+            cmd = ListCmd::default();
+            uv.send_cmd(&mut cmd)
+        }
+        Err(e) => Err(e),
+    }?
+    .more_data();
+    if more_data {
+        warn!("The secret list contains more data but the uvdevice cannot show all.");
+    }
+
     cmd.try_into().map_err(Error::new)
 }
 
