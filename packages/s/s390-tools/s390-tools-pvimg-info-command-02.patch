From 3f6572e901ddcc654021c4302cb2a99999acb87a Mon Sep 17 00:00:00 2001
From: Marc Hartmayer <mhartmay@linux.ibm.com>
Date: Wed, 18 Dec 2024 13:41:13 +0100
Subject: [PATCH] rust/utils: mkdtemp: fix memory leak
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Fix memory leak of @template_raw. The documentation of CString::into_raw
reads:

"Consumes the CString and transfers ownership of the string to a C
caller.
...
Failure to call CString::from_raw will lead to a memory leak." [1]

Let's fix the memory leak by always calling `CString::from_raw` and
therefore reclaim the ownership.

[1] https://doc.rust-lang.org/std/ffi/struct.CString.html#method.into_raw

Fixes: e56acf4f14b0 ("pv_core: add `TemporaryDirectory`")
Reviewed-by: Steffen Eiden <seiden@linux.ibm.com>
Signed-off-by: Marc Hartmayer <mhartmay@linux.ibm.com>
Signed-off-by: Jan HÃ¶ppner <hoeppner@linux.ibm.com>
---
 rust/utils/src/tmpfile.rs | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/rust/utils/src/tmpfile.rs b/rust/utils/src/tmpfile.rs
index 07acdba8..883d5586 100644
--- a/rust/utils/src/tmpfile.rs
+++ b/rust/utils/src/tmpfile.rs
@@ -16,13 +16,14 @@ fn mkdtemp<P: AsRef<Path>>(template: P) -> Result<PathBuf, std::io::Error> {
         // SAFETY: template_raw is a valid CString because it was generated by
         // the `CString::new`.
         let ret = libc::mkdtemp(template_raw);
+        // SAFETY: `template_raw` is still a valid CString because it was
+        // generated by `CString::new` and modified by `libc::mkdtemp`.
+        let path_cstr = std::ffi::CString::from_raw(template_raw);
 
         if ret.is_null() {
+            drop(path_cstr);
             Err(std::io::Error::last_os_error())
         } else {
-            // SAFETY: `template_raw` is still a valid CString because it was
-            // generated by `CString::new` and modified by `libc::mkdtemp`.
-            let path_cstr = std::ffi::CString::from_raw(template_raw);
             let path = OsStr::from_bytes(path_cstr.as_bytes());
             let path = std::path::PathBuf::from(path);
 
