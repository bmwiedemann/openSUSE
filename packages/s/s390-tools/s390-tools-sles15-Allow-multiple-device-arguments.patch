From d6582bbaf0f3986a42f562046dc0caa9de89c75e Mon Sep 17 00:00:00 2001
From: Hannes Reinecke <hare@suse.de>
Date: Fri, 6 Oct 2017 08:58:17 +0200
Subject: [PATCH] dasdfmt: Allow multiple device arguments

Allow the user to specify several devices as arguments to dasdfmt.

Signed-off-by: Hannes Reinecke <hare@suse.com>
---
 dasdfmt/dasdfmt.8 |   5 +-
 dasdfmt/dasdfmt.c | 175 ++++++++++++++++++++++++++++++------------------------
 2 files changed, 100 insertions(+), 80 deletions(-)

diff --git a/dasdfmt/dasdfmt.8 b/dasdfmt/dasdfmt.8
index 99da9ed..e7fc501 100644
--- a/dasdfmt/dasdfmt.8
+++ b/dasdfmt/dasdfmt.8
@@ -11,14 +11,15 @@ dasdfmt \- formatting of DASD (ECKD) disk drives.
 .br
         [-r \fIcylinder\fR] [-b \fIblksize\fR] [-l \fIvolser\fR] [-d \fIlayout\fR]
 .br
-        [-L] [-V] [-F] [-k] [-C] [-M \fImode\fR] \fIdevice\fR
+        [-L] [-V] [-F] [-k] [-C] [-M \fImode\fR] \fIdevice\fR [\fIdevice\fR]
 
 .SH DESCRIPTION
-\fBdasdfmt\fR formats a DASD (ECKD) disk drive to prepare it
+\fBdasdfmt\fR formats one or several DASD (ECKD) disk drive to prepare it
 for usage with Linux for S/390. 
 The \fIdevice\fR is the node of the device (e.g. '/dev/dasda').
 Any device node created by udev for kernel 2.6 can be used 
 (e.g. '/dev/dasd/0.0.b100/disc').
+It is possible to specify up to 512 devices.
 .br
 
 \fBWARNING\fR: Careless usage of \fBdasdfmt\fR can result in 
diff --git a/dasdfmt/dasdfmt.c b/dasdfmt/dasdfmt.c
index b79cff0..607fd1c 100644
--- a/dasdfmt/dasdfmt.c
+++ b/dasdfmt/dasdfmt.c
@@ -21,6 +21,7 @@
 
 #include "dasdfmt.h"
 
+#define MAX_DEVICES 512
 #define BUSIDSIZE  8
 #define SEC_PER_DAY (60 * 60 * 24)
 #define SEC_PER_HOUR (60 * 60)
@@ -456,44 +457,40 @@ static void program_interrupt_signal(int sig)
 /*
  * check given device name for blanks and some special characters
  */
-static void get_device_name(char *devname,
-			    int optind, int argc, char *argv[])
+static void get_device_name(char **devname, int numdev,
+			    char argv[])
 {
 	struct util_proc_dev_entry dev_entry;
 	struct stat dev_stat;
 
-	if (optind + 1 < argc)
-		ERRMSG_EXIT(EXIT_MISUSE,
-			    "%s: More than one device specified!\n", prog_name);
-
-	if (optind >= argc)
-		ERRMSG_EXIT(EXIT_MISUSE, "%s: No device specified!\n",
-			    prog_name);
-
-	if (strlen(argv[optind]) >= PATH_MAX)
+	if (strlen(argv) >= PATH_MAX)
 		ERRMSG_EXIT(EXIT_MISUSE, "%s: device name too long!\n",
 			    prog_name);
-	strcpy(devname, argv[optind]);
 
-	if (stat(devname, &dev_stat) != 0)
-		ERRMSG_EXIT(EXIT_MISUSE, "%s: Could not get information for "
-			    "device node %s: %s\n", prog_name, devname,
-			    strerror(errno));
+	devname[numdev] = argv;
+	if (stat(devname[numdev], &dev_stat) != 0)
+		ERRMSG_EXIT(EXIT_MISUSE,
+			    "%s: Could not get information for "
+			    "device node %s: %s\n", prog_name,
+			    devname[numdev], strerror(errno));
 
 	if (minor(dev_stat.st_rdev) & PARTN_MASK) {
-		ERRMSG_EXIT(EXIT_MISUSE, "%s: Unable to format partition %s. "
+		ERRMSG_EXIT(EXIT_MISUSE,
+			    "%s: Unable to format partition %s. "
 			    "Please specify a device.\n", prog_name,
-			    devname);
+			    devname[numdev]);
 	}
 
-	if (util_proc_dev_get_entry(dev_stat.st_rdev, 1, &dev_entry) == 0) {
+	if (util_proc_dev_get_entry(dev_stat.st_rdev, 1,
+				    &dev_entry) == 0) {
 		if (strncmp(dev_entry.name, "dasd", 4) != 0)
 			ERRMSG_EXIT(EXIT_MISUSE,
 				    "%s: Unsupported device type '%s'.\n",
 				    prog_name, dev_entry.name);
 	} else {
-		printf("%s WARNING: Unable to get driver name for device node %s",
-		       prog_name, devname);
+		printf("%s WARNING: Unable to get driver name"
+		       " for device node %s",
+		       prog_name, devname[numdev]);
 	}
 }
 
@@ -1457,24 +1454,86 @@ static void do_format_dasd(dasdfmt_info_t *info, char *devname,
 	}
 }
 
+void do_dasdfmt(char *dev_filename, dasdfmt_info_t *info,
+		volume_label_t *orig_vlabel)
+{
+	volume_label_t vlabel;
+	char old_volser[7];
+	char str[ERR_LENGTH];
+	unsigned int cylinders, heads;
+
+	filedes = open(dev_filename, O_RDWR);
+	if (filedes == -1)
+		ERRMSG_EXIT(EXIT_FAILURE, "%s: Unable to open device %s: %s\n",
+			    prog_name, dev_filename, strerror(errno));
+
+	get_device_info(info);
+	memcpy(&vlabel, orig_vlabel, sizeof(vlabel));
+	/* Either let the user specify the blksize or get it from the kernel */
+	if (!info->blksize_specified) {
+		if (!(mode == FULL ||
+		      info->dasd_info.format == DASD_FORMAT_NONE)
+		    || info->check)
+			get_blocksize(&format_params.blksize);
+		else
+			format_params = ask_user_for_blksize(format_params);
+	}
+
+	if (info->keep_volser) {
+		if (info->labelspec) {
+			ERRMSG_EXIT(EXIT_MISUSE, "%s: The -k and -l options "
+				    "are mutually exclusive\n", prog_name);
+		}
+		if (!(format_params.intensity & DASD_FMT_INT_COMPAT)) {
+			printf("WARNING: VOLSER cannot be kept "
+			       "when using the ldl format!\n");
+			exit(1);
+		}
+
+		if (dasdfmt_get_volser(dev_filename,
+				       &info->dasd_info, old_volser) == 0)
+			vtoc_volume_label_set_volser(&vlabel, old_volser);
+		else
+			ERRMSG_EXIT(EXIT_FAILURE,
+				    "%s: VOLSER not found on device %s\n",
+				    prog_name, dev_filename);
+	}
+
+	check_disk(info, dev_filename);
+
+	if (check_param(str, ERR_LENGTH, &format_params) < 0)
+		ERRMSG_EXIT(EXIT_MISUSE, "%s: %s\n", prog_name, str);
+
+	set_geo(info, &cylinders, &heads);
+	set_label(info, &vlabel, &format_params, cylinders);
+
+	if (info->check)
+		check_disk_format(info, cylinders, heads, &format_params);
+	else
+		do_format_dasd(info, dev_filename, &vlabel,
+			       &format_params, cylinders, heads);
+
+	if (close(filedes) != 0)
+		ERRMSG("%s: error during close: %s\ncontinuing...\n",
+		       prog_name, strerror(errno));
+
+}
+
 int main(int argc, char *argv[])
 {
 	dasdfmt_info_t info = {
 		.dasd_info = {0},
 	};
 	volume_label_t vlabel;
-	char old_volser[7];
 
-	char dev_filename[PATH_MAX];
-	char str[ERR_LENGTH];
+	char *dev_filename[MAX_DEVICES];
 	char buf[7];
 
 	char *blksize_param_str = NULL;
 	char *reqsize_param_str = NULL;
 	char *hashstep_str      = NULL;
 
-	int rc;
-	unsigned int cylinders, heads;
+	int rc, numdev = 0, i;
 
 	/* Establish a handler for interrupt signals. */
 	signal(SIGTERM, program_interrupt_signal);
@@ -1634,61 +1693,21 @@ int main(int argc, char *argv[])
 	if (info.print_hashmarks)
 		PARSE_PARAM_INTO(info.hashstep, hashstep_str, 10, "hashstep");
 
-	get_device_name(dev_filename, optind, argc, argv);
-
-	filedes = open(dev_filename, O_RDWR);
-	if (filedes == -1)
-		ERRMSG_EXIT(EXIT_FAILURE, "%s: Unable to open device %s: %s\n",
-			    prog_name, dev_filename, strerror(errno));
-
-	get_device_info(&info);
+	while (optind < argc) {
+		if (optind >= argc)
+			ERRMSG_EXIT(EXIT_MISUSE, "%s: No device specified!\n",
+				    prog_name);
 
-	/* Either let the user specify the blksize or get it from the kernel */
-	if (!info.blksize_specified) {
-		if (!(mode == FULL ||
-		      info.dasd_info.format == DASD_FORMAT_NONE) || info.check)
-			get_blocksize(&format_params.blksize);
-		else
-			format_params = ask_user_for_blksize(format_params);
+		get_device_name(dev_filename, numdev, argv[optind]);
+		optind++;
+		numdev++;
 	}
 
-	if (info.keep_volser) {
-		if (info.labelspec) {
-			ERRMSG_EXIT(EXIT_MISUSE, "%s: The -k and -l options "
-				    "are mutually exclusive\n", prog_name);
-		}
-		if (!(format_params.intensity & DASD_FMT_INT_COMPAT)) {
-			printf("WARNING: VOLSER cannot be kept "
-			       "when using the ldl format!\n");
-			exit(1);
-		}
-
-		if (dasdfmt_get_volser(dev_filename,
-				       &info.dasd_info, old_volser) == 0)
-			vtoc_volume_label_set_volser(&vlabel, old_volser);
-		else
-			ERRMSG_EXIT(EXIT_FAILURE,
-				    "%s: VOLSER not found on device %s\n",
-				    prog_name, dev_filename);
-	}
-
-	check_disk(&info, dev_filename);
-
-	if (check_param(str, ERR_LENGTH, &format_params) < 0)
-		ERRMSG_EXIT(EXIT_MISUSE, "%s: %s\n", prog_name, str);
-
-	set_geo(&info, &cylinders, &heads);
-	set_label(&info, &vlabel, &format_params, cylinders);
-
-	if (info.check)
-		check_disk_format(&info, cylinders, heads, &format_params);
-	else
-		do_format_dasd(&info, dev_filename, &vlabel,
-			       &format_params, cylinders, heads);
-
-	if (close(filedes) != 0)
-		ERRMSG("%s: error during close: %s\ncontinuing...\n",
-		       prog_name, strerror(errno));
+	if (!numdev)
+		ERRMSG_EXIT(EXIT_MISUSE, "%s: No device specified!\n",
+			    prog_name);
 
+	for (i = 0; i < numdev; i++)
+		do_dasdfmt(dev_filename[i], &info, &vlabel);
 	return 0;
 }
-- 
1.7.12.4

