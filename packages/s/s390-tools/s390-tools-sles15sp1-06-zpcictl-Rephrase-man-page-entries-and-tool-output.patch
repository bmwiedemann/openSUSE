Subject: zpcictl: Rephrase man page entries and tool output
From: Jan Hoeppner <jan.hoeppner@de.ibm.com>

Summary:     zpcictl: Add tool to manage PCI devices
Description: Use the zpcictl tool to manage PCI devices on the IBM Z
             platform.  Initial functions include generating firmware
             error logs, resetting PCI devices, and preparing a device
             for further repair actions.
Upstream-ID: d03be735366de57be0c642f6f21b06b1f2df6a6e
Problem-ID:  RAS1703

Upstream-Description:

             zpcictl: Rephrase man page entries and tool output

             Reviewed-by: Hendrik Brueckner <brueckner@linux.ibm.com>
             Signed-off-by: Jan HÃ¶ppner <hoeppner@linux.ibm.com>


Signed-off-by: Jan Hoeppner <jan.hoeppner@de.ibm.com>
---
 zpcictl/zpcictl.8 |   13 ++++++++-----
 zpcictl/zpcictl.c |    9 +++++----
 2 files changed, 13 insertions(+), 9 deletions(-)

--- a/zpcictl/zpcictl.8
+++ b/zpcictl/zpcictl.8
@@ -1,4 +1,4 @@
-.\" Copyright 2017 IBM Corp.
+.\" Copyright IBM Corp. 2018
 .\" s390-tools is free software; you can redistribute it and/or modify
 .\" it under the terms of the MIT license. See LICENSE for details.
 .\"
@@ -30,9 +30,10 @@ zpcictl - Manage PCI devices on z System
 .
 .
 .SH DESCRIPTION
+With
 .B zpcictl
-is a tool for managing PCI devices on the IBM z Systems platform. It is
-especially used for reporting errorneous PCI devices to the service element.
+, you can manage PCI devices on the IBM z Systems platform. It is especially
+used for reporting erroneous PCI devices to the service element.
 
 .B Note:
 For NVMe devices additional data (such as S.M.A.R.T. data) is collected and sent
@@ -44,7 +45,9 @@ for this to work.
 .SH DEVICE
 .B DEVICE
 can be either the PCI slot address (e.g. 0000:00:00.0) or the main device node
-of an NVMe device (e.g. /dev/nvme0).
+of an NVMe device (e.g.
+.I /dev/nvme0
+).
 .
 .
 .SH OPTIONS
@@ -52,7 +55,7 @@ of an NVMe device (e.g. /dev/nvme0).
 .OD reset "" "DEVICE"
 Reset
 .I DEVICE
-and initiate a re-initialisation of the adapter.
+and initiate a re-initialization of the PCI device.
 .PP
 .
 .OD deconfigure "" "DEVICE"
--- a/zpcictl/zpcictl.c
+++ b/zpcictl/zpcictl.c
@@ -240,7 +240,7 @@ static int device_exists(char *dev)
 static void get_device_info(struct zpci_device *pdev, char *dev)
 {
 	if (!device_exists(dev))
-		errx(EXIT_FAILURE, "Device %s not found", dev);
+		errx(EXIT_FAILURE, "Could not find device %s", dev);
 	if (is_blk_dev(dev))
 		errx(EXIT_FAILURE, "Unsupported device type %s", dev);
 	if (is_char_dev(dev)) {
@@ -254,9 +254,10 @@ static void get_device_info(struct zpci_
 	pdev->fid = sysfs_read_value(pdev, "function_id");
 	pdev->pchid = sysfs_read_value(pdev, "pchid");
 
-	/* In case a slot address was specified, we still need to figure out
-	 * the device node for NVMe devices. Otherwise we won't be able to
-	 * collect S.M.A.R.T. data at a later point.
+	/*
+	 * In case a slot address was specified, the device node for NVMe
+	 * devices is still needed. Otherwise it won't be possible to collect
+	 * S.M.A.R.T. data at a later point.
 	 */
 	if (!pdev->device && pdev->class == PCI_CLASS_NVME)
 		get_device_node(pdev);
