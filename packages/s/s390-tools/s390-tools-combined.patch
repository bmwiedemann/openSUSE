diff -Naur a/etc/sysconfig/dumpconf b/etc/sysconfig/dumpconf
--- a/etc/sysconfig/dumpconf	2025-12-11 17:03:28.000000000 +0100
+++ b/etc/sysconfig/dumpconf	2026-02-06 14:03:46.482188674 +0100
@@ -1,3 +1,4 @@
+###########################################################################################
 #
 # s390 dump config
 #
@@ -78,3 +79,135 @@
 # dumpconf becomes active immediately during system startup.
 #
 # ON_PANIC=reipl
+
+############################ Begin Definitions ###########################################
+## Path:		System/Dumpconf
+## Description:		Configures the actions which should be performed after a kernel panic
+## Type:		list(stop,dump,vmcmd,reipl,dump_reipl)
+## Default:		"stop"
+## ServiceRestart:	dumpconf
+#
+# Define the action that should be taken if a kernel panic happens.
+#
+ON_PANIC="stop"
+
+## Type:		integer(0:300)
+## Default:		5
+## ServiceRestart:	dumpconf
+#
+# Using reipl or dump_reipl actions with ON_PANIC can lead to the system
+# looping with alternating IPLs and crashes. Use DELAY_MINUTES to prevent
+# such a loop. DELAY_MINUTES delays activating the specified panic action
+# for a newly started system. When the specified time has elapsed, dumpconf
+# activates the specified panic action. This action is taken should the
+# system subsequently crash. If the system crashes before the time has
+# elapsed the previously defined action is taken. If no previous action has
+# been defined the default action (STOP) is performed.
+#
+DELAY_MINUTES="5"
+
+## Type:		list(ccw,fcp,nvme)
+## Default:		""
+## ServiceRestart:	dumpconf
+#
+# Define the type, ccw for DASD, fcp for zFCP, or nvme for NVMe Disk.
+#
+DUMP_TYPE=""
+
+## Type:		string
+## Default:		""
+## ServiceRestart:	dumpconf
+#
+# Define the device id for a DASD or SCSI over zFCP dump device.
+#
+# For example (DASD and SCSI over zFCP have the same structure): DEVICE=0.0.4711
+#
+DEVICE=""
+
+# Type:		string
+## Default:		""
+## ServiceRestart:	dumpconf
+#
+# Define the WWPN for a zFCP dump device.
+#
+# For example: WWPN=0x5005076303004711
+#
+WWPN=""
+
+## Type:		string
+## Default:		""
+## ServiceRestart:	dumpconf
+#
+# Define the LUN for a zFCP dump device.
+#
+# For example: LUN=0x4711000000000000
+#
+LUN=""
+
+## Type:		integer(0:30)
+## Default:		"0"
+## ServiceRestart:	dumpconf
+#
+# Define the Boot program selector for a zFCP dump device.
+#
+# A decimal value between 0 and 30 specifying the program to be loaded from
+# the FCP-I/O device.
+#
+BOOTPROG="0"
+
+## Type:		string
+## Default:		"0"
+## ServiceRestart:	dumpconf
+#
+# Define the Boot record logical block address for a zFCP dump device.
+#
+# The hexadecimal digits designating the logical-block address of the boot record of the FCP-I/O device.
+# It must be a value from 0-FFFFFFFF FFFFFFFF. For values longer than 8 hex characters at least one separator
+# blank is required after the 8th character.
+#
+BR_LBA="0"
+
+## Type:		string
+## Default:		""
+## ServiceRestart:	dumpconf
+#
+# Define the Function ID for NVMe dump device.
+#
+# The hexadecimal digits designating the Function ID for the NMVe disk.
+#
+# For example: FID=0x00000300
+#
+FID=""
+
+## Type:		string
+## Default:		""
+## ServiceRestart:	dumpconf
+#
+# Define the Namespace ID for the NVMe dump device
+#
+# The hexadecimal digits designating the Namespace ID for the NMVe disk.
+#
+# For example: NSID=0x00000001
+#
+NSID=""
+
+## Type:		string
+## Default:		""
+## ServiceRestart:	dumpconf
+#
+# VMCMD_<X>
+# Specifies a CP command, <X> is a number from one to eight. You can
+# specify up to eight CP commands that are executed in case of a kernel
+# panic. Note that VM commands, device adresses, and VM guest names
+# must be uppercase.
+#
+VMCMD_1=""
+VMCMD_2=""
+VMCMD_3=""
+VMCMD_4=""
+VMCMD_5=""
+VMCMD_6=""
+VMCMD_7=""
+VMCMD_8=""
+
+############################### End Definitions ##############################################
diff -Naur a/etc/udev/rules.d/59-dasd.rules b/etc/udev/rules.d/59-dasd.rules
--- a/etc/udev/rules.d/59-dasd.rules	2025-12-11 17:03:28.000000000 +0100
+++ b/etc/udev/rules.d/59-dasd.rules	2026-02-06 15:49:49.132244953 +0100
@@ -6,16 +6,17 @@
 SUBSYSTEM!="block", GOTO="dasd_symlinks_end"
 KERNEL!="dasd*", GOTO="dasd_symlinks_end"
 
-ACTION!="change", GOTO="dasd_block_end"
+ACTION!="change|add", GOTO="dasd_block_end"
 # by-id (hardware serial number)
 KERNEL=="dasd*[!0-9]", ATTRS{status}=="online", IMPORT{program}="/sbin/dasdinfo -a -e -b $kernel"
+KERNEL=="dasd*[!0-9]", ATTRS{status}=="online", IMPORT{program}="/usr/sbin/dasdinfo -a -e -b $kernel"
 KERNEL=="dasd*[!0-9]", ENV{ID_SERIAL}=="?*", SYMLINK+="disk/by-id/$env{ID_BUS}-$env{ID_SERIAL}"
 KERNEL=="dasd*[!0-9]", ENV{ID_UID}=="?*", SYMLINK+="disk/by-id/$env{ID_BUS}-$env{ID_UID}"
 KERNEL=="dasd*[!0-9]", ENV{ID_XUID}=="?*", SYMLINK+="disk/by-id/$env{ID_BUS}-$env{ID_XUID}"
 
 LABEL="dasd_block_end"
 
-ACTION!="change|add", GOTO="dasd_symlinks_end"
+ACTION!="change|add", GOTO="dasd_partition_end"
 
 # for partitions import parent information
 KERNEL=="dasd*[0-9]", IMPORT{parent}=="ID_*"
@@ -24,6 +25,14 @@
 KERNEL=="dasd*[0-9]", ENV{ID_UID}=="?*", SYMLINK+="disk/by-id/$env{ID_BUS}-$env{ID_UID}-part%n"
 KERNEL=="dasd*[0-9]", ENV{ID_XUID}=="?*", SYMLINK+="disk/by-id/$env{ID_BUS}-$env{ID_XUID}-part%n"
 
+LABEL="dasd_partition_end"
+
+ENV{ID_SERIAL}!="?*", GOTO="dasd_symlinks_end"
+# by-label/by-uuid (filesystem properties)
+IMPORT{builtin}="blkid"
+ENV{ID_FS_USAGE}=="filesystem|other|crypto", ENV{ID_FS_UUID}=="?*", SYMLINK+="disk/by-uuid/$env{ID_FS_UUID}"
+ENV{ID_FS_USAGE}=="filesystem|other", ENV{ID_FS_LABEL_SAFE}=="?*", SYMLINK+="disk/by-label/$env{ID_FS_LABEL_SAFE}"
+
 LABEL="dasd_symlinks_end"
 
 # on device add set request queue scheduler to none
diff -Naur a/fdasd/fdasd.c b/fdasd/fdasd.c
--- a/fdasd/fdasd.c	2025-12-11 17:03:28.000000000 +0100
+++ b/fdasd/fdasd.c	2026-02-06 14:10:08.461803766 +0100
@@ -1232,10 +1232,13 @@
  */
 static void fdasd_reread_partition_table(fdasd_anchor_t *anc)
 {
+        int rc = 0 ;
+
 	if (!anc->silent)
 		printf("rereading partition table...\n");
 
-	if (dasd_reread_partition_table(options.device, 5) != 0) {
+        rc = dasd_reread_partition_table(options.device, 1);
+        if (rc == EINVAL && !anc->force_virtual) {
 		fdasd_error(anc, unable_to_ioctl, "Error while rereading "
 			    "partition table.\nPlease reboot!");
 	}
diff -Naur a/zdev/dracut/95zdev/parse-dasd.sh b/zdev/dracut/95zdev/parse-dasd.sh
--- a/zdev/dracut/95zdev/parse-dasd.sh	2025-12-11 17:03:28.000000000 +0100
+++ b/zdev/dracut/95zdev/parse-dasd.sh	2026-02-06 14:13:41.947730795 +0100
@@ -10,6 +10,8 @@
 #   parameters are evaluated and used to configure dasd devices.
 #
 
+zdev_dasd_base_args="--no-settle --yes --no-root-update --force"
+
 # shellcheck source=/dev/null
 type zdev_parse_dasd_list > /dev/null 2>&1 || . /lib/s390-tools/zdev-from-dasd_mod.dasd
 
@@ -27,9 +29,21 @@
 
 zdev_parse_rd_dasd() {
     local _zdev_dasd _zdev_dasd_list
-    for _zdev_dasd in $(getargs rd.dasd -d 'rd_DASD='); do
-        _zdev_dasd_list="${_zdev_dasd_list:+${_zdev_dasd_list},}$_zdev_dasd"
-    done
+    # autodetect active bootdev from zipl device
+    if ! getargbool 0 'rd.dasd' \
+        && [[ -f /sys/firmware/ipl/ipl_type ]] \
+        && [[ $(< /sys/firmware/ipl/ipl_type) == "ccw" ]]; then
+        read -r _ccw < /sys/firmware/ipl/device
+
+        if lszdev --offline "$_ccw" &>/dev/null; then
+            chzdev --offline --existing --enable --active $zdev_dasd_base_args \
+                   dasd "$_ccw"
+        fi
+    else
+        for _zdev_dasd in $(getargs rd.dasd -d 'rd_DASD='); do
+            _zdev_dasd_list="${_zdev_dasd_list:+${_zdev_dasd_list},}$_zdev_dasd"
+        done
+    fi    
     echo "$_zdev_dasd_list"
 }
 
diff -Naur a/zdev/dracut/95zdev/parse-zfcp.sh b/zdev/dracut/95zdev/parse-zfcp.sh
--- a/zdev/dracut/95zdev/parse-zfcp.sh	2025-12-11 17:03:28.000000000 +0100
+++ b/zdev/dracut/95zdev/parse-zfcp.sh	2026-02-12 10:49:05.939509610 +0100
@@ -11,26 +11,43 @@
 #
 
 zdev_zfcp_base_args="--no-settle --yes --no-root-update --force"
+zdev_vinfo() {
+    local _zdev_vinfo_line
+    while read -r _zdev_vinfo_line || [ -n "$_zdev_vinfo_line" ]; do
+        # Prefix "<30>" represents facility LOG_DAEMON 3 and loglevel INFO 6:
+        # (facility << 3) | level.
+        echo "<30>dracut: $_zdev_vinfo_line" > /dev/kmsg
+    done
+}
 
-for zdev_zfcp_arg in $(getargs rd.zfcp -d 'rd_ZFCP='); do
-    (
-        IFS_SAVED="$IFS"
-        IFS="," # did not work in front of built-in set command below
-        # shellcheck disable=SC2086
-        set -- $zdev_zfcp_arg
-        IFS=":" args="$*"
-        IFS="$IFS_SAVED"
-        echo "rd.zfcp ${zdev_zfcp_arg} :" | zdev_vinfo
-        if [ "$#" -eq 1 ]; then
+# autodetect active bootdev from zipl device
+if ! getargbool 0 'rd.zfcp' \
+    && [[ -f /sys/firmware/ipl/ipl_type ]] \
+    && [[ $(< /sys/firmware/ipl/ipl_type) == "fcp" ]]; then
+        chzdev --offline --existing --enable --active $zdev_zfcp_base_args \
+               zfcp-host 2>&1 | zdev_vinfo
+else
+    for zdev_zfcp_arg in $(getargs rd.zfcp -d 'rd_ZFCP='); do
+        (
+            IFS_SAVED="$IFS"
+            IFS="," # did not work in front of built-in set command below
             # shellcheck disable=SC2086
-            chzdev --enable --persistent $zdev_zfcp_base_args \
-                   zfcp-host "$args" 2>&1 | zdev_vinfo
-        else
-            # shellcheck disable=SC2086
-            chzdev --enable --persistent $zdev_zfcp_base_args \
-                   zfcp-lun "$args" 2>&1 | zdev_vinfo
-        fi
-    )
-done
+            set -- $zdev_zfcp_arg
+            IFS=":" args="$*"
+            IFS="$IFS_SAVED"
+            echo "rd.zfcp ${zdev_zfcp_arg} :" | zdev_vinfo
+            if [ "$#" -eq 1 ]; then
+                # shellcheck disable=SC2086
+                chzdev --enable --persistent $zdev_zfcp_base_args \
+                       zfcp-host "$args" 2>&1 | zdev_vinfo
+            else
+                # shellcheck disable=SC2086
+                chzdev --enable --persistent $zdev_zfcp_base_args \
+                       zfcp-lun "$args" 2>&1 | zdev_vinfo
+            fi
+        )
+    done
+fi
+
 unset zdev_zfcp_arg
 unset zdev_zfcp_base_args
diff -Naur a/zdev/dracut/95zdev-kdump/module-setup.sh b/zdev/dracut/95zdev-kdump/module-setup.sh
--- a/zdev/dracut/95zdev-kdump/module-setup.sh	2025-12-11 17:03:28.000000000 +0100
+++ b/zdev/dracut/95zdev-kdump/module-setup.sh	2026-02-06 14:20:29.803412303 +0100
@@ -78,6 +78,7 @@
     inst_multiple /lib/s390-tools/zdev-from-dasd_mod.dasd
 
     inst_rules "59-dasd.rules"
+    inst_rules "59-zfcp-compat.rules"
 
     # Obtain kdump target device configuration
 
diff -Naur a/zdev/src/zdev-root-update.dracut b/zdev/src/zdev-root-update.dracut
--- a/zdev/src/zdev-root-update.dracut	2025-12-11 17:03:28.000000000 +0100
+++ b/zdev/src/zdev-root-update.dracut	2026-02-06 14:25:03.817945754 +0100
@@ -20,10 +20,4 @@
 	exit 1
 }
 
-echo "Installing IPL record"
-zipl --noninteractive || {
-	echo "${TOOLNAME}: Error: Could not install IPL record" >&2
-	exit 1
-}
-
 exit 0
diff -Naur a/zipl/boot/menu.c b/zipl/boot/menu.c
--- a/zipl/boot/menu.c	2025-12-11 17:03:28.000000000 +0100
+++ b/zipl/boot/menu.c	2026-02-06 14:29:07.392321346 +0100
@@ -191,8 +191,11 @@
 	/* print config list */
 	menu_list();
 
-	if (is_zvm())
-		printf("Note: VM users please use '#cp vi vmsg <input>'\n");
+        if (is_zvm()) {
+                printf(" \n");
+                printf("Note: VM users please use '#cp vi vmsg <input> <kernel-parameters>'\n");
+                printf(" \n");
+        }
 
 	value = menu_read();
 
