From 6fc77c07c4a307063601c00869b03688bb4978b5 Mon Sep 17 00:00:00 2001
From: Michal Srb <msrb@redhat.com>
Date: Mon, 15 Apr 2024 10:08:26 +0200
Subject: [PATCH 2/2] Replace bundled gdata-java-client classes with
 commons-codec

---
 pom.xml                                       |  24 +
 .../gdata/util/common/base/Escaper.java       |  82 ----
 .../util/common/base/PercentEscaper.java      | 267 ----------
 .../util/common/base/UnicodeEscaper.java      | 462 ------------------
 .../org/yaml/snakeyaml/util/UriEncoder.java   |  36 +-
 .../issue318/ContextClassLoaderTest.java      |  20 +-
 .../issues/issue318/classpath.properties      |   1 +
 7 files changed, 72 insertions(+), 820 deletions(-)
 delete mode 100644 src/main/java/org/yaml/snakeyaml/external/com/google/gdata/util/common/base/Escaper.java
 delete mode 100644 src/main/java/org/yaml/snakeyaml/external/com/google/gdata/util/common/base/PercentEscaper.java
 delete mode 100644 src/main/java/org/yaml/snakeyaml/external/com/google/gdata/util/common/base/UnicodeEscaper.java

diff --git a/pom.xml b/pom.xml
index c242d07d..938712ea 100644
--- a/pom.xml
+++ b/pom.xml
@@ -15,6 +15,7 @@
         <maven.compiler.release>8</maven.compiler.release>
         <maven.javadoc.failOnError>false</maven.javadoc.failOnError>
         <maven-bundle-plugin.version>5.1.8</maven-bundle-plugin.version>
+        <maven-dependency-plugin.version>3.6.0</maven-dependency-plugin.version>
         <maven-resources-plugin.version>3.1.0</maven-resources-plugin.version><!-- for Github CI -->
         <maven-site-plugin.version>3.12.1</maven-site-plugin.version>
         <maven-surefire-plugin.version>3.0.0-M7</maven-surefire-plugin.version>
@@ -60,6 +61,11 @@
         </developer>
     </developers>
     <dependencies>
+        <dependency>
+            <groupId>commons-codec</groupId>
+            <artifactId>commons-codec</artifactId>
+            <version>1.16.1</version>
+        </dependency>
         <dependency>
             <groupId>junit</groupId>
             <artifactId>junit</artifactId>
@@ -369,6 +375,24 @@
                     </execution>
                 </executions>
             </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-dependency-plugin</artifactId>
+                <version>${maven-dependency-plugin.version}</version>
+                <executions>
+                    <execution>
+                        <id>build-classpath</id>
+                        <phase>generate-test-resources</phase>
+                        <goals>
+                            <goal>build-classpath</goal>
+                        </goals>
+                        <configuration>
+                            <outputProperty>runtime.classpath</outputProperty>
+                            <includeScope>runtime</includeScope>
+                        </configuration>
+                    </execution>
+                </executions>
+            </plugin>
         </plugins>
     </build>
     <reporting>
diff --git a/src/main/java/org/yaml/snakeyaml/external/com/google/gdata/util/common/base/Escaper.java b/src/main/java/org/yaml/snakeyaml/external/com/google/gdata/util/common/base/Escaper.java
deleted file mode 100644
index a94f6154..00000000
--- a/src/main/java/org/yaml/snakeyaml/external/com/google/gdata/util/common/base/Escaper.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright (c) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
- * in compliance with the License. You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package org.yaml.snakeyaml.external.com.google.gdata.util.common.base;
-
-/**
- * An object that converts literal text into a format safe for inclusion in a particular context
- * (such as an XML document). Typically (but not always), the inverse process of "unescaping" the
- * text is performed automatically by the relevant parser.
- *
- * <p>
- * For example, an XML escaper would convert the literal string {@code "Foo<Bar>"} into
- * {@code "Foo&lt;Bar&gt;"} to prevent {@code "<Bar>"} from being confused with an XML tag. When the
- * resulting XML document is parsed, the parser API will return this text as the original literal
- * string {@code "Foo<Bar>"}.
- *
- * <p>
- * An {@code Escaper} instance is required to be stateless, and safe when used concurrently by
- * multiple threads.
- *
- * <p>
- * Several popular escapers are defined as constants in the class {@link CharEscapers}. To create
- * your own escapers, use {@link CharEscaperBuilder}, or extend {@link CharEscaper} or
- * {@code UnicodeEscaper}.
- */
-public interface Escaper {
-
-  /**
-   * Returns the escaped form of a given literal string.
-   *
-   * <p>
-   * Note that this method may treat input characters differently depending on the specific escaper
-   * implementation.
-   * <ul>
-   * <li>{@link UnicodeEscaper} handles <a href="http://en.wikipedia.org/wiki/UTF-16">UTF-16</a>
-   * correctly, including surrogate character pairs. If the input is badly formed the escaper should
-   * throw {@link IllegalArgumentException}.
-   * <li>{@link CharEscaper} handles Java characters independently and does not verify the input for
-   * well formed characters. A CharEscaper should not be used in situations where input is not
-   * guaranteed to be restricted to the Basic Multilingual Plane (BMP).
-   * </ul>
-   *
-   * @param string the literal string to be escaped
-   * @return the escaped form of {@code string}
-   * @throws NullPointerException if {@code string} is null
-   * @throws IllegalArgumentException if {@code string} contains badly formed UTF-16 or cannot be
-   *         escaped for any other reason
-   */
-  String escape(String string);
-
-  /**
-   * Returns an {@code Appendable} instance which automatically escapes all text appended to it
-   * before passing the resulting text to an underlying {@code Appendable}.
-   *
-   * <p>
-   * Note that this method may treat input characters differently depending on the specific escaper
-   * implementation.
-   * <ul>
-   * <li>{@link UnicodeEscaper} handles <a href="http://en.wikipedia.org/wiki/UTF-16">UTF-16</a>
-   * correctly, including surrogate character pairs. If the input is badly formed the escaper should
-   * throw {@link IllegalArgumentException}.
-   * <li>{@link CharEscaper} handles Java characters independently and does not verify the input for
-   * well formed characters. A CharEscaper should not be used in situations where input is not
-   * guaranteed to be restricted to the Basic Multilingual Plane (BMP).
-   * </ul>
-   *
-   * @param out the underlying {@code Appendable} to append escaped output to
-   * @return an {@code Appendable} which passes text to {@code out} after escaping it.
-   */
-  Appendable escape(Appendable out);
-}
diff --git a/src/main/java/org/yaml/snakeyaml/external/com/google/gdata/util/common/base/PercentEscaper.java b/src/main/java/org/yaml/snakeyaml/external/com/google/gdata/util/common/base/PercentEscaper.java
deleted file mode 100644
index f115a2cc..00000000
--- a/src/main/java/org/yaml/snakeyaml/external/com/google/gdata/util/common/base/PercentEscaper.java
+++ /dev/null
@@ -1,267 +0,0 @@
-/*
- * Copyright (c) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
- * in compliance with the License. You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package org.yaml.snakeyaml.external.com.google.gdata.util.common.base;
-
-/**
- * A {@code UnicodeEscaper} that escapes some set of Java characters using the URI percent encoding
- * scheme. The set of safe characters (those which remain unescaped) can be specified on
- * construction.
- *
- * <p>
- * For details on escaping URIs for use in web pages, see section 2.4 of
- * <a href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986</a>.
- *
- * <p>
- * In most cases this class should not need to be used directly. If you have no special requirements
- * for escaping your URIs, you should use either {@link CharEscapers#uriEscaper()} or
- * {@link CharEscapers#uriEscaper(boolean)}.
- *
- * <p>
- * When encoding a String, the following rules apply:
- * <ul>
- * <li>The alphanumeric characters "a" through "z", "A" through "Z" and "0" through "9" remain the
- * same.
- * <li>Any additionally specified safe characters remain the same.
- * <li>If {@code plusForSpace} was specified, the space character " " is converted into a plus sign
- * "+".
- * <li>All other characters are converted into one or more bytes using UTF-8 encoding and each byte
- * is then represented by the 3-character string "%XY", where "XY" is the two-digit, uppercase,
- * hexadecimal representation of the byte value.
- * </ul>
- *
- * <p>
- * RFC 2396 specifies the set of unreserved characters as "-", "_", ".", "!", "~", "*", "'", "(" and
- * ")". It goes on to state:
- *
- * <p>
- * <i>Unreserved characters can be escaped without changing the semantics of the URI, but this
- * should not be done unless the URI is being used in a context that does not allow the unescaped
- * character to appear.</i>
- *
- * <p>
- * For performance reasons the only currently supported character encoding of this class is UTF-8.
- *
- * <p>
- * <b>Note</b>: This escaper produces uppercase hexidecimal sequences. From
- * <a href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986</a>:<br>
- * <i>"URI producers and normalizers should use uppercase hexadecimal digits for all
- * percent-encodings."</i>
- */
-public class PercentEscaper extends UnicodeEscaper {
-
-  /**
-   * A string of safe characters that mimics the behavior of {@link java.net.URLEncoder}.
-   */
-  public static final String SAFECHARS_URLENCODER = "-_.*";
-
-  /**
-   * A string of characters that do not need to be encoded when used in URI path segments, as
-   * specified in RFC 3986. Note that some of these characters do need to be escaped when used in
-   * other parts of the URI.
-   */
-  public static final String SAFEPATHCHARS_URLENCODER = "-_.!~*'()@:$&,;=";
-
-  /**
-   * A string of characters that do not need to be encoded when used in URI query strings, as
-   * specified in RFC 3986. Note that some of these characters do need to be escaped when used in
-   * other parts of the URI.
-   */
-  public static final String SAFEQUERYSTRINGCHARS_URLENCODER = "-_.!~*'()@:$,;/?:";
-
-  // In some uri escapers spaces are escaped to '+'
-  private static final char[] URI_ESCAPED_SPACE = {'+'};
-
-  private static final char[] UPPER_HEX_DIGITS = "0123456789ABCDEF".toCharArray();
-
-  /**
-   * If true we should convert space to the {@code +} character.
-   */
-  private final boolean plusForSpace;
-
-  /**
-   * An array of flags where for any {@code char c} if {@code safeOctets[c]} is true then {@code c}
-   * should remain unmodified in the output. If {@code c > safeOctets.length} then it should be
-   * escaped.
-   */
-  private final boolean[] safeOctets;
-
-  /**
-   * Constructs a URI escaper with the specified safe characters and optional handling of the space
-   * character.
-   *
-   * @param safeChars a non null string specifying additional safe characters for this escaper (the
-   *        ranges 0..9, a..z and A..Z are always safe and should not be specified here)
-   * @param plusForSpace true if ASCII space should be escaped to {@code +} rather than {@code %20}
-   * @throws IllegalArgumentException if any of the parameters were invalid
-   */
-  public PercentEscaper(String safeChars, boolean plusForSpace) {
-    // Avoid any misunderstandings about the behavior of this escaper
-    if (safeChars.matches(".*[0-9A-Za-z].*")) {
-      throw new IllegalArgumentException(
-          "Alphanumeric characters are always 'safe' and should not be " + "explicitly specified");
-    }
-    // Avoid ambiguous parameters. Safe characters are never modified so if
-    // space is a safe character then setting plusForSpace is meaningless.
-    if (plusForSpace && safeChars.contains(" ")) {
-      throw new IllegalArgumentException(
-          "plusForSpace cannot be specified when space is a 'safe' character");
-    }
-    if (safeChars.contains("%")) {
-      throw new IllegalArgumentException("The '%' character cannot be specified as 'safe'");
-    }
-    this.plusForSpace = plusForSpace;
-    this.safeOctets = createSafeOctets(safeChars);
-  }
-
-  /**
-   * Creates a boolean[] with entries corresponding to the character values for 0-9, A-Z, a-z and
-   * those specified in safeChars set to true. The array is as small as is required to hold the
-   * given character information.
-   */
-  private static boolean[] createSafeOctets(String safeChars) {
-    int maxChar = 'z';
-    char[] safeCharArray = safeChars.toCharArray();
-    for (char c : safeCharArray) {
-      maxChar = Math.max(c, maxChar);
-    }
-    boolean[] octets = new boolean[maxChar + 1];
-    for (int c = '0'; c <= '9'; c++) {
-      octets[c] = true;
-    }
-    for (int c = 'A'; c <= 'Z'; c++) {
-      octets[c] = true;
-    }
-    for (int c = 'a'; c <= 'z'; c++) {
-      octets[c] = true;
-    }
-    for (char c : safeCharArray) {
-      octets[c] = true;
-    }
-    return octets;
-  }
-
-  /*
-   * Overridden for performance. For unescaped strings this improved the performance of the uri
-   * escaper from ~760ns to ~400ns as measured by {@link CharEscapersBenchmark}.
-   */
-  @Override
-  protected int nextEscapeIndex(CharSequence csq, int index, int end) {
-    for (; index < end; index++) {
-      char c = csq.charAt(index);
-      if (c >= safeOctets.length || !safeOctets[c]) {
-        break;
-      }
-    }
-    return index;
-  }
-
-  /*
-   * Overridden for performance. For unescaped strings this improved the performance of the uri
-   * escaper from ~400ns to ~170ns as measured by {@link CharEscapersBenchmark}.
-   */
-  @Override
-  public String escape(String s) {
-    int slen = s.length();
-    for (int index = 0; index < slen; index++) {
-      char c = s.charAt(index);
-      if (c >= safeOctets.length || !safeOctets[c]) {
-        return escapeSlow(s, index);
-      }
-    }
-    return s;
-  }
-
-  /**
-   * Escapes the given Unicode code point in UTF-8.
-   */
-  @Override
-  protected char[] escape(int cp) {
-    // We should never get negative values here but if we do it will throw
-    // an
-    // IndexOutOfBoundsException, so at least it will get spotted.
-    if (cp < safeOctets.length && safeOctets[cp]) {
-      return null;
-    } else if (cp == ' ' && plusForSpace) {
-      return URI_ESCAPED_SPACE;
-    } else if (cp <= 0x7F) {
-      // Single byte UTF-8 characters
-      // Start with "%--" and fill in the blanks
-      char[] dest = new char[3];
-      dest[0] = '%';
-      dest[2] = UPPER_HEX_DIGITS[cp & 0xF];
-      dest[1] = UPPER_HEX_DIGITS[cp >>> 4];
-      return dest;
-    } else if (cp <= 0x7ff) {
-      // Two byte UTF-8 characters [cp >= 0x80 && cp <= 0x7ff]
-      // Start with "%--%--" and fill in the blanks
-      char[] dest = new char[6];
-      dest[0] = '%';
-      dest[3] = '%';
-      dest[5] = UPPER_HEX_DIGITS[cp & 0xF];
-      cp >>>= 4;
-      dest[4] = UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];
-      cp >>>= 2;
-      dest[2] = UPPER_HEX_DIGITS[cp & 0xF];
-      cp >>>= 4;
-      dest[1] = UPPER_HEX_DIGITS[0xC | cp];
-      return dest;
-    } else if (cp <= 0xffff) {
-      // Three byte UTF-8 characters [cp >= 0x800 && cp <= 0xffff]
-      // Start with "%E-%--%--" and fill in the blanks
-      char[] dest = new char[9];
-      dest[0] = '%';
-      dest[1] = 'E';
-      dest[3] = '%';
-      dest[6] = '%';
-      dest[8] = UPPER_HEX_DIGITS[cp & 0xF];
-      cp >>>= 4;
-      dest[7] = UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];
-      cp >>>= 2;
-      dest[5] = UPPER_HEX_DIGITS[cp & 0xF];
-      cp >>>= 4;
-      dest[4] = UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];
-      cp >>>= 2;
-      dest[2] = UPPER_HEX_DIGITS[cp];
-      return dest;
-    } else if (cp <= 0x10ffff) {
-      char[] dest = new char[12];
-      // Four byte UTF-8 characters [cp >= 0xffff && cp <= 0x10ffff]
-      // Start with "%F-%--%--%--" and fill in the blanks
-      dest[0] = '%';
-      dest[1] = 'F';
-      dest[3] = '%';
-      dest[6] = '%';
-      dest[9] = '%';
-      dest[11] = UPPER_HEX_DIGITS[cp & 0xF];
-      cp >>>= 4;
-      dest[10] = UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];
-      cp >>>= 2;
-      dest[8] = UPPER_HEX_DIGITS[cp & 0xF];
-      cp >>>= 4;
-      dest[7] = UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];
-      cp >>>= 2;
-      dest[5] = UPPER_HEX_DIGITS[cp & 0xF];
-      cp >>>= 4;
-      dest[4] = UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];
-      cp >>>= 2;
-      dest[2] = UPPER_HEX_DIGITS[cp & 0x7];
-      return dest;
-    } else {
-      // If this ever happens it is due to bug in UnicodeEscaper, not bad
-      // input.
-      throw new IllegalArgumentException("Invalid unicode character value " + cp);
-    }
-  }
-}
diff --git a/src/main/java/org/yaml/snakeyaml/external/com/google/gdata/util/common/base/UnicodeEscaper.java b/src/main/java/org/yaml/snakeyaml/external/com/google/gdata/util/common/base/UnicodeEscaper.java
deleted file mode 100644
index 00230df8..00000000
--- a/src/main/java/org/yaml/snakeyaml/external/com/google/gdata/util/common/base/UnicodeEscaper.java
+++ /dev/null
@@ -1,462 +0,0 @@
-/*
- * Copyright (c) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
- * in compliance with the License. You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package org.yaml.snakeyaml.external.com.google.gdata.util.common.base;
-
-import java.io.IOException;
-
-/**
- * An {@link Escaper} that converts literal text into a format safe for inclusion in a particular
- * context (such as an XML document). Typically (but not always), the inverse process of
- * "unescaping" the text is performed automatically by the relevant parser.
- *
- * <p>
- * For example, an XML escaper would convert the literal string {@code "Foo<Bar>"} into
- * {@code "Foo&lt;Bar&gt;"} to prevent {@code "<Bar>"} from being confused with an XML tag. When the
- * resulting XML document is parsed, the parser API will return this text as the original literal
- * string {@code "Foo<Bar>"}.
- *
- * <p>
- * <b>Note:</b> This class is similar to {@link CharEscaper} but with one very important difference.
- * A CharEscaper can only process Java <a href="http://en.wikipedia.org/wiki/UTF-16">UTF16</a>
- * characters in isolation and may not cope when it encounters surrogate pairs. This class
- * facilitates the correct escaping of all Unicode characters.
- *
- * <p>
- * As there are important reasons, including potential security issues, to handle Unicode correctly
- * if you are considering implementing a new escaper you should favor using UnicodeEscaper wherever
- * possible.
- *
- * <p>
- * A {@code UnicodeEscaper} instance is required to be stateless, and safe when used concurrently by
- * multiple threads.
- *
- * <p>
- * Several popular escapers are defined as constants in the class {@link CharEscapers}. To create
- * your own escapers extend this class and implement the {@link #escape(int)} method.
- */
-public abstract class UnicodeEscaper implements Escaper {
-
-  /**
-   * The amount of padding (chars) to use when growing the escape buffer.
-   */
-  private static final int DEST_PAD = 32;
-
-  /**
-   * Returns the escaped form of the given Unicode code point, or {@code null} if this code point
-   * does not need to be escaped. When called as part of an escaping operation, the given code point
-   * is guaranteed to be in the range {@code 0 <= cp <= Character#MAX_CODE_POINT}.
-   *
-   * <p>
-   * If an empty array is returned, this effectively strips the input character from the resulting
-   * text.
-   *
-   * <p>
-   * If the character does not need to be escaped, this method should return {@code null}, rather
-   * than an array containing the character representation of the code point. This enables the
-   * escaping algorithm to perform more efficiently.
-   *
-   * <p>
-   * If the implementation of this method cannot correctly handle a particular code point then it
-   * should either throw an appropriate runtime exception or return a suitable replacement
-   * character. It must never silently discard invalid input as this may constitute a security risk.
-   *
-   * @param cp the Unicode code point to escape if necessary
-   * @return the replacement characters, or {@code null} if no escaping was needed
-   */
-  protected abstract char[] escape(int cp);
-
-  /**
-   * Scans a sub-sequence of characters from a given {@link CharSequence}, returning the index of
-   * the next character that requires escaping.
-   *
-   * <p>
-   * <b>Note:</b> When implementing an escaper, it is a good idea to override this method for
-   * efficiency. The base class implementation determines successive Unicode code points and invokes
-   * {@link #escape(int)} for each of them. If the semantics of your escaper are such that code
-   * points in the supplementary range are either all escaped or all unescaped, this method can be
-   * implemented more efficiently using {@link CharSequence#charAt(int)}.
-   *
-   * <p>
-   * Note however that if your escaper does not escape characters in the supplementary range, you
-   * should either continue to validate the correctness of any surrogate characters encountered or
-   * provide a clear warning to users that your escaper does not validate its input.
-   *
-   * <p>
-   * See {@link PercentEscaper} for an example.
-   *
-   * @param csq a sequence of characters
-   * @param start the index of the first character to be scanned
-   * @param end the index immediately after the last character to be scanned
-   * @throws IllegalArgumentException if the scanned sub-sequence of {@code csq} contains invalid
-   *         surrogate pairs
-   */
-  protected int nextEscapeIndex(CharSequence csq, int start, int end) {
-    int index = start;
-    while (index < end) {
-      int cp = codePointAt(csq, index, end);
-      if (cp < 0 || escape(cp) != null) {
-        break;
-      }
-      index += Character.isSupplementaryCodePoint(cp) ? 2 : 1;
-    }
-    return index;
-  }
-
-  /**
-   * Returns the escaped form of a given literal string.
-   *
-   * <p>
-   * If you are escaping input in arbitrary successive chunks, then it is not generally safe to use
-   * this method. If an input string ends with an unmatched high surrogate character, then this
-   * method will throw {@link IllegalArgumentException}. You should either ensure your input is
-   * valid <a href="http://en.wikipedia.org/wiki/UTF-16">UTF-16</a> before calling this method or
-   * use an escaped {@link Appendable} (as returned by {@link #escape(Appendable)}) which can cope
-   * with arbitrarily split input.
-   *
-   * <p>
-   * <b>Note:</b> When implementing an escaper it is a good idea to override this method for
-   * efficiency by inlining the implementation of {@link #nextEscapeIndex(CharSequence, int, int)}
-   * directly. Doing this for {@link PercentEscaper} more than doubled the performance for unescaped
-   * strings (as measured by {@link CharEscapersBenchmark}).
-   *
-   * @param string the literal string to be escaped
-   * @return the escaped form of {@code string}
-   * @throws NullPointerException if {@code string} is null
-   * @throws IllegalArgumentException if invalid surrogate characters are encountered
-   */
-  public String escape(String string) {
-    int end = string.length();
-    int index = nextEscapeIndex(string, 0, end);
-    return index == end ? string : escapeSlow(string, index);
-  }
-
-  /**
-   * Returns the escaped form of a given literal string, starting at the given index. This method is
-   * called by the {@link #escape(String)} method when it discovers that escaping is required. It is
-   * protected to allow subclasses to override the fastpath escaping function to inline their
-   * escaping test. See {@link CharEscaperBuilder} for an example usage.
-   *
-   * <p>
-   * This method is not reentrant and may only be invoked by the top level {@link #escape(String)}
-   * method.
-   *
-   * @param s the literal string to be escaped
-   * @param index the index to start escaping from
-   * @return the escaped form of {@code string}
-   * @throws NullPointerException if {@code string} is null
-   * @throws IllegalArgumentException if invalid surrogate characters are encountered
-   */
-  protected final String escapeSlow(String s, int index) {
-    int end = s.length();
-
-    // Get a destination buffer and setup some loop variables.
-    char[] dest = DEST_TL.get();
-    int destIndex = 0;
-    int unescapedChunkStart = 0;
-
-    while (index < end) {
-      int cp = codePointAt(s, index, end);
-      if (cp < 0) {
-        throw new IllegalArgumentException("Trailing high surrogate at end of input");
-      }
-      char[] escaped = escape(cp);
-      if (escaped != null) {
-        int charsSkipped = index - unescapedChunkStart;
-
-        // This is the size needed to add the replacement, not the full
-        // size needed by the string. We only regrow when we absolutely
-        // must.
-        int sizeNeeded = destIndex + charsSkipped + escaped.length;
-        if (dest.length < sizeNeeded) {
-          int destLength = sizeNeeded + (end - index) + DEST_PAD;
-          dest = growBuffer(dest, destIndex, destLength);
-        }
-        // If we have skipped any characters, we need to copy them now.
-        if (charsSkipped > 0) {
-          s.getChars(unescapedChunkStart, index, dest, destIndex);
-          destIndex += charsSkipped;
-        }
-        if (escaped.length > 0) {
-          System.arraycopy(escaped, 0, dest, destIndex, escaped.length);
-          destIndex += escaped.length;
-        }
-      }
-      unescapedChunkStart = index + (Character.isSupplementaryCodePoint(cp) ? 2 : 1);
-      index = nextEscapeIndex(s, unescapedChunkStart, end);
-    }
-
-    // Process trailing unescaped characters - no need to account for
-    // escaped
-    // length or padding the allocation.
-    int charsSkipped = end - unescapedChunkStart;
-    if (charsSkipped > 0) {
-      int endIndex = destIndex + charsSkipped;
-      if (dest.length < endIndex) {
-        dest = growBuffer(dest, destIndex, endIndex);
-      }
-      s.getChars(unescapedChunkStart, end, dest, destIndex);
-      destIndex = endIndex;
-    }
-    return new String(dest, 0, destIndex);
-  }
-
-  /**
-   * Returns an {@code Appendable} instance which automatically escapes all text appended to it
-   * before passing the resulting text to an underlying {@code Appendable}.
-   *
-   * <p>
-   * Unlike {@link #escape(String)} it is permitted to append arbitrarily split input to this
-   * Appendable, including input that is split over a surrogate pair. In this case the pending high
-   * surrogate character will not be processed until the corresponding low surrogate is appended.
-   * This means that a trailing high surrogate character at the end of the input cannot be detected
-   * and will be silently ignored. This is unavoidable since the Appendable interface has no
-   * {@code close()} method, and it is impossible to determine when the last characters have been
-   * appended.
-   *
-   * <p>
-   * The methods of the returned object will propagate any exceptions thrown by the underlying
-   * {@code Appendable}.
-   *
-   * <p>
-   * For well formed <a href="http://en.wikipedia.org/wiki/UTF-16">UTF-16</a> the escaping behavior
-   * is identical to that of {@link #escape(String)} and the following code is equivalent to (but
-   * much slower than) {@code escaper.escape(string)}:
-   *
-   * <pre>
-   * {
-   *   &#064;code
-   *   StringBuilder sb = new StringBuilder();
-   *   escaper.escape(sb).append(string);
-   *   return sb.toString();
-   * }
-   * </pre>
-   *
-   * @param out the underlying {@code Appendable} to append escaped output to
-   * @return an {@code Appendable} which passes text to {@code out} after escaping it
-   * @throws NullPointerException if {@code out} is null
-   * @throws IllegalArgumentException if invalid surrogate characters are encountered
-   */
-  public Appendable escape(final Appendable out) {
-    assert out != null;
-
-    return new Appendable() {
-      int pendingHighSurrogate = -1;
-      final char[] decodedChars = new char[2];
-
-      public Appendable append(CharSequence csq) throws IOException {
-        return append(csq, 0, csq.length());
-      }
-
-      public Appendable append(CharSequence csq, int start, int end) throws IOException {
-        int index = start;
-        if (index < end) {
-          // This is a little subtle: index must never reference the
-          // middle of a
-          // surrogate pair but unescapedChunkStart can. The first
-          // time we enter
-          // the loop below it is possible that index !=
-          // unescapedChunkStart.
-          int unescapedChunkStart = index;
-          if (pendingHighSurrogate != -1) {
-            // Our last append operation ended halfway through a
-            // surrogate pair
-            // so we have to do some extra work first.
-            char c = csq.charAt(index++);
-            if (!Character.isLowSurrogate(c)) {
-              throw new IllegalArgumentException("Expected low surrogate character but got " + c);
-            }
-            char[] escaped = escape(Character.toCodePoint((char) pendingHighSurrogate, c));
-            if (escaped != null) {
-              // Emit the escaped character and adjust
-              // unescapedChunkStart to
-              // skip the low surrogate we have consumed.
-              outputChars(escaped, escaped.length);
-              unescapedChunkStart += 1;
-            } else {
-              // Emit pending high surrogate (unescaped) but do
-              // not modify
-              // unescapedChunkStart as we must still emit the low
-              // surrogate.
-              out.append((char) pendingHighSurrogate);
-            }
-            pendingHighSurrogate = -1;
-          }
-          while (true) {
-            // Find and append the next subsequence of unescaped
-            // characters.
-            index = nextEscapeIndex(csq, index, end);
-            if (index > unescapedChunkStart) {
-              out.append(csq, unescapedChunkStart, index);
-            }
-            if (index == end) {
-              break;
-            }
-            // If we are not finished, calculate the next code
-            // point.
-            int cp = codePointAt(csq, index, end);
-            if (cp < 0) {
-              // Our sequence ended half way through a surrogate
-              // pair so just
-              // record the state and exit.
-              pendingHighSurrogate = -cp;
-              break;
-            }
-            // Escape the code point and output the characters.
-            char[] escaped = escape(cp);
-            if (escaped != null) {
-              outputChars(escaped, escaped.length);
-            } else {
-              // This shouldn't really happen if nextEscapeIndex
-              // is correct but
-              // we should cope with false positives.
-              int len = Character.toChars(cp, decodedChars, 0);
-              outputChars(decodedChars, len);
-            }
-            // Update our index past the escaped character and
-            // continue.
-            index += (Character.isSupplementaryCodePoint(cp) ? 2 : 1);
-            unescapedChunkStart = index;
-          }
-        }
-        return this;
-      }
-
-      public Appendable append(char c) throws IOException {
-        if (pendingHighSurrogate != -1) {
-          // Our last append operation ended halfway through a
-          // surrogate pair
-          // so we have to do some extra work first.
-          if (!Character.isLowSurrogate(c)) {
-            throw new IllegalArgumentException(
-                "Expected low surrogate character but got '" + c + "' with value " + (int) c);
-          }
-          char[] escaped = escape(Character.toCodePoint((char) pendingHighSurrogate, c));
-          if (escaped != null) {
-            outputChars(escaped, escaped.length);
-          } else {
-            out.append((char) pendingHighSurrogate);
-            out.append(c);
-          }
-          pendingHighSurrogate = -1;
-        } else if (Character.isHighSurrogate(c)) {
-          // This is the start of a (split) surrogate pair.
-          pendingHighSurrogate = c;
-        } else {
-          if (Character.isLowSurrogate(c)) {
-            throw new IllegalArgumentException(
-                "Unexpected low surrogate character '" + c + "' with value " + (int) c);
-          }
-          // This is a normal (non surrogate) char.
-          char[] escaped = escape(c);
-          if (escaped != null) {
-            outputChars(escaped, escaped.length);
-          } else {
-            out.append(c);
-          }
-        }
-        return this;
-      }
-
-      private void outputChars(char[] chars, int len) throws IOException {
-        for (int n = 0; n < len; n++) {
-          out.append(chars[n]);
-        }
-      }
-    };
-  }
-
-  /**
-   * Returns the Unicode code point of the character at the given index.
-   *
-   * <p>
-   * Unlike {@link Character#codePointAt(CharSequence, int)} or {@link String#codePointAt(int)} this
-   * method will never fail silently when encountering an invalid surrogate pair.
-   *
-   * <p>
-   * The behaviour of this method is as follows:
-   * <ol>
-   * <li>If {@code index >= end}, {@link IndexOutOfBoundsException} is thrown.
-   * <li><b>If the character at the specified index is not a surrogate, it is returned.</b>
-   * <li>If the first character was a high surrogate value, then an attempt is made to read the next
-   * character.
-   * <ol>
-   * <li><b>If the end of the sequence was reached, the negated value of the trailing high surrogate
-   * is returned.</b>
-   * <li><b>If the next character was a valid low surrogate, the code point value of the high/low
-   * surrogate pair is returned.</b>
-   * <li>If the next character was not a low surrogate value, then {@link IllegalArgumentException}
-   * is thrown.
-   * </ol>
-   * <li>If the first character was a low surrogate value, {@link IllegalArgumentException} is
-   * thrown.
-   * </ol>
-   *
-   * @param seq the sequence of characters from which to decode the code point
-   * @param index the index of the first character to decode
-   * @param end the index beyond the last valid character to decode
-   * @return the Unicode code point for the given index or the negated value of the trailing high
-   *         surrogate character at the end of the sequence
-   */
-  protected static final int codePointAt(CharSequence seq, int index, int end) {
-    if (index < end) {
-      char c1 = seq.charAt(index++);
-      if (c1 < Character.MIN_HIGH_SURROGATE || c1 > Character.MAX_LOW_SURROGATE) {
-        // Fast path (first test is probably all we need to do)
-        return c1;
-      } else if (c1 <= Character.MAX_HIGH_SURROGATE) {
-        // If the high surrogate was the last character, return its
-        // inverse
-        if (index == end) {
-          return -c1;
-        }
-        // Otherwise look for the low surrogate following it
-        char c2 = seq.charAt(index);
-        if (Character.isLowSurrogate(c2)) {
-          return Character.toCodePoint(c1, c2);
-        }
-        throw new IllegalArgumentException("Expected low surrogate but got char '" + c2
-            + "' with value " + (int) c2 + " at index " + index);
-      } else {
-        throw new IllegalArgumentException("Unexpected low surrogate character '" + c1
-            + "' with value " + (int) c1 + " at index " + (index - 1));
-      }
-    }
-    throw new IndexOutOfBoundsException("Index exceeds specified range");
-  }
-
-  /**
-   * Helper method to grow the character buffer as needed, this only happens once in a while so it's
-   * ok if it's in a method call. If the index passed in is 0 then no copying will be done.
-   */
-  private static final char[] growBuffer(char[] dest, int index, int size) {
-    char[] copy = new char[size];
-    if (index > 0) {
-      System.arraycopy(dest, 0, copy, 0, index);
-    }
-    return copy;
-  }
-
-  /**
-   * A thread-local destination buffer to keep us from creating new buffers. The starting size is
-   * 1024 characters. If we grow past this we don't put it back in the threadlocal, we just keep
-   * going and grow as needed.
-   */
-  private static final ThreadLocal<char[]> DEST_TL = new ThreadLocal<char[]>() {
-    @Override
-    protected char[] initialValue() {
-      return new char[1024];
-    }
-  };
-}
diff --git a/src/main/java/org/yaml/snakeyaml/util/UriEncoder.java b/src/main/java/org/yaml/snakeyaml/util/UriEncoder.java
index 02c3e434..69fdc55d 100644
--- a/src/main/java/org/yaml/snakeyaml/util/UriEncoder.java
+++ b/src/main/java/org/yaml/snakeyaml/util/UriEncoder.java
@@ -22,18 +22,33 @@ import java.nio.charset.CharsetDecoder;
 import java.nio.charset.CodingErrorAction;
 import java.nio.charset.StandardCharsets;
 import org.yaml.snakeyaml.error.YAMLException;
-import org.yaml.snakeyaml.external.com.google.gdata.util.common.base.Escaper;
-import org.yaml.snakeyaml.external.com.google.gdata.util.common.base.PercentEscaper;
+import java.util.BitSet;
+
+import org.apache.commons.codec.net.URLCodec;
 
 public abstract class UriEncoder {
 
+  // default safe characters which can appear within URI and shouldn't be escaped
+  private static final BitSet allowedCharacters = new BitSet(256);
+
+  static {
+    for (int i = 'a'; i <= 'z'; i++) {
+      allowedCharacters.set(i);
+    }
+    for (int i = 'A'; i <= 'Z'; i++) {
+      allowedCharacters.set(i);
+    }
+    for (int i = '0'; i <= '9'; i++) {
+      allowedCharacters.set(i);
+    }
+    // http://yaml.org/spec/1.1/#escaping%20in%20URI/
+    for (char c : "-_.!~*'()@:$&,;=/[]".toCharArray()) {
+      allowedCharacters.set(c);
+    }
+  }
+
   private static final CharsetDecoder UTF8Decoder =
       StandardCharsets.UTF_8.newDecoder().onMalformedInput(CodingErrorAction.REPORT);
-  // Include the [] chars to the SAFEPATHCHARS_URLENCODER to avoid
-  // its escape as required by spec. See
-  // http://yaml.org/spec/1.1/#escaping%20in%20URI/
-  private static final String SAFE_CHARS = PercentEscaper.SAFEPATHCHARS_URLENCODER + "[]/";
-  private static final Escaper escaper = new PercentEscaper(SAFE_CHARS, false);
 
   /**
    * Escape special characters with '%'
@@ -42,7 +57,12 @@ public abstract class UriEncoder {
    * @return encoded URI
    */
   public static String encode(String uri) {
-    return escaper.escape(uri);
+    try {
+      byte[] rawdata = URLCodec.encodeUrl(allowedCharacters, uri.getBytes("UTF-8"));
+      return new String(rawdata, 0, rawdata.length, "US-ASCII");
+    } catch (UnsupportedEncodingException e) {
+      throw new YAMLException(e);
+    }
   }
 
   /**
diff --git a/src/test/java/org/yaml/snakeyaml/issues/issue318/ContextClassLoaderTest.java b/src/test/java/org/yaml/snakeyaml/issues/issue318/ContextClassLoaderTest.java
index 7d816c07..d4ab48cb 100644
--- a/src/test/java/org/yaml/snakeyaml/issues/issue318/ContextClassLoaderTest.java
+++ b/src/test/java/org/yaml/snakeyaml/issues/issue318/ContextClassLoaderTest.java
@@ -76,6 +76,7 @@ public class ContextClassLoaderTest {
 
   private URLClassLoader yamlCL;
   private URLClassLoader testYamlCL;
+  private URLClassLoader depsCL = null;
 
   @Before
   public void before() throws MalformedURLException {
@@ -87,10 +88,17 @@ public class ContextClassLoaderTest {
       fail(e2.getLocalizedMessage());
     }
 
+    String runtimeClasspath = classpath.getProperty("runtime_classpath");
+    String[] classpathEntries = runtimeClasspath.split(File.pathSeparator);
+    for (String classpathEntry : classpathEntries) {
+      File file = new File(classpathEntry);
+      depsCL = new URLClassLoader(new URL[] {file.toURI().toURL()}, depsCL);
+    }
+
     File runtimeClassesDir = new File(classpath.getProperty("runtime_classes_dir"));
     File testClassesDir = new File(classpath.getProperty("test_classes_dir"));
 
-    yamlCL = new URLClassLoader(new URL[] {runtimeClassesDir.toURI().toURL()}, null);
+    yamlCL = new URLClassLoader(new URL[] {runtimeClassesDir.toURI().toURL()}, depsCL);
     testYamlCL = new URLClassLoader(new URL[] {testClassesDir.toURI().toURL()}, yamlCL);
   }
 
@@ -115,6 +123,16 @@ public class ContextClassLoaderTest {
         yamlCL = null;
       }
     }
+
+    if (depsCL != null) {
+      try {
+        depsCL.close();
+      } catch (IOException e) {
+        e.printStackTrace();
+      } finally {
+        depsCL = null;
+      }
+    }
   }
 
   @Test(expected = ClassNotFoundException.class)
diff --git a/src/test/resources/org/yaml/snakeyaml/issues/issue318/classpath.properties b/src/test/resources/org/yaml/snakeyaml/issues/issue318/classpath.properties
index a0ee78cf..b8b86b4b 100644
--- a/src/test/resources/org/yaml/snakeyaml/issues/issue318/classpath.properties
+++ b/src/test/resources/org/yaml/snakeyaml/issues/issue318/classpath.properties
@@ -1,2 +1,3 @@
 runtime_classes_dir=${project.build.outputDirectory}
 test_classes_dir=${project.build.testOutputDirectory}
+runtime_classpath=${runtime.classpath}
-- 
2.44.0

