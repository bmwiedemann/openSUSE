From: Frank Ch. Eigler <fche@redhat.com>
Date: Thu Jan 25 14:28:38 2024 -0500
Subject: PR31288: build with gcc14
Git-commit: 2604d135069f74cf5a223631cf92c9d0d818ef9c
References: bsc#1221706
Signed-off-by: Tony Jones <tonyj@suse.de>
X-Info: adjust patch, no 80642fc0d22abf9d5e19e705adfd7f12599ace7c

    PR31288: build with gcc14
    
    GCC14 makes -Wmissing-prototypes defaultish on, which triggers on such
    gentle-spirited code as:
    
        void foo(void) { }
    
    when you should darn well know to have an exact duplicate declaration
    prototype first.  Because of course.
    
        void foo(void);
        void foo(void) { }
    
    So anyway, with our fondness for -Werror, this broke the stap runtime
    autoconf* business, bits of the runtime, bits of the translator.
    Probably more stuff as yet unidentified.  If your testsuite logs show:
    
     [...]: error: no previous prototype for ‘[...]’ [-Werror=missing-prototypes]
    
    this is probably to blame.
    
    Since this is coming to clang as well, we now get buildrun.cxx to
    force -Wmissing-prototypes on all the time, so as to try to notice
    occurrences of this problem earlier.

diff --git a/buildrun.cxx b/buildrun.cxx
index 76551415c..bb7bdcc9d 100644
--- a/buildrun.cxx
+++ b/buildrun.cxx
@@ -315,6 +315,7 @@ compile_pass (systemtap_session& s)
   o << "CHECK_BUILD := $(CC) -DMODULE $(NOSTDINC_FLAGS) $(KBUILD_CPPFLAGS) $(CPPFLAGS) "
     << "$(LINUXINCLUDE) $(_KBUILD_CFLAGS) $(CFLAGS_KERNEL) $(EXTRA_CFLAGS) "
     << "$(CFLAGS) -DKBUILD_BASENAME=\\\"" << s.module_name << "\\\" "
+    << "-Wmissing-prototypes "  // GCC14 prep, PR31288
     << WERROR << " -S -o /dev/null -xc " << endl;
   o << "stap_check_build = $(shell " << superverbose << " if $(CHECK_BUILD) $(1) "
     << redirecterrors << " ; then echo \"$(2)\"; else echo \"$(3)\"; fi)" << endl;
@@ -345,6 +346,8 @@ compile_pass (systemtap_session& s)
   // o << module_cflags << " += -Iusr/include" << endl;
   // since such headers are cleansed of _KERNEL_ pieces that we need
 
+  o << module_cflags << " += -Wmissing-prototypes" << endl; // GCC14 prep, PR31288
+  
   o << "STAPCONF_HEADER := " << s.tmpdir << "/" << s.stapconf_name << endl;
   o << ".DELETE_ON_ERROR: $(STAPCONF_HEADER)" << endl;
   o << "$(STAPCONF_HEADER):" << endl;
diff --git a/runtime/linux/autoconf-access_ok_2args.c b/runtime/linux/autoconf-access_ok_2args.c
index 2e5c79a65..3e6041dd2 100644
--- a/runtime/linux/autoconf-access_ok_2args.c
+++ b/runtime/linux/autoconf-access_ok_2args.c
@@ -1,5 +1,7 @@
 #include <linux/uaccess.h>
 
+int __something(void);
+
 int __something(void)
 {
    return access_ok ((void*) 0, 4);
diff --git a/runtime/linux/autoconf-alloc-percpu-align.c b/runtime/linux/autoconf-alloc-percpu-align.c
index 158d579c0..912361269 100644
--- a/runtime/linux/autoconf-alloc-percpu-align.c
+++ b/runtime/linux/autoconf-alloc-percpu-align.c
@@ -1,6 +1,7 @@
 #include <linux/percpu.h>
 
 /* kernel commit f2a8205c */
+void foo (void);
 void foo (void) {
    (void) __alloc_percpu(sizeof(int), 8);
 }
diff --git a/runtime/linux/autoconf-asm-access-ok.c b/runtime/linux/autoconf-asm-access-ok.c
index 1d0e61776..7a95758c2 100644
--- a/runtime/linux/autoconf-asm-access-ok.c
+++ b/runtime/linux/autoconf-asm-access-ok.c
@@ -1,5 +1,6 @@
 #include <linux/uaccess.h>
 
+bool foo(const void __user *ptr, size_t size);
 bool foo(const void __user *ptr, size_t size)
 {
 	return __access_ok(ptr, size);
diff --git a/runtime/linux/autoconf-atomic_fetch_add_unless.c b/runtime/linux/autoconf-atomic_fetch_add_unless.c
index b765c39ef..b79c4742d 100644
--- a/runtime/linux/autoconf-atomic_fetch_add_unless.c
+++ b/runtime/linux/autoconf-atomic_fetch_add_unless.c
@@ -1,5 +1,7 @@
 #include <linux/atomic.h>
 
+int foo(atomic_t *v);
+
 int foo(atomic_t *v)
 {
 	return atomic_fetch_add_unless(v, 1, 0);
diff --git a/runtime/linux/autoconf-bio-bi_opf.c b/runtime/linux/autoconf-bio-bi_opf.c
index 20db781f3..047ccd68c 100644
--- a/runtime/linux/autoconf-bio-bi_opf.c
+++ b/runtime/linux/autoconf-bio-bi_opf.c
@@ -19,6 +19,8 @@
  *       No intended functional changes in this commit.
  */
 
+void bar (void);
+
 void bar (void)
 {
         struct bio foo;
diff --git a/runtime/linux/autoconf-cpu-clock.c b/runtime/linux/autoconf-cpu-clock.c
index b501bcdf3..6c80afdad 100644
--- a/runtime/linux/autoconf-cpu-clock.c
+++ b/runtime/linux/autoconf-cpu-clock.c
@@ -29,7 +29,8 @@
 //     reference sched_clock_cpu(). Thus it must be exported with the
 //     EXPORT_SYMBOL_GPL macro.
 //
-
+void foo (void);
+        
 void foo (void) {
    (void) cpu_clock(0);
 }
diff --git a/runtime/linux/autoconf-d-real-inode.c b/runtime/linux/autoconf-d-real-inode.c
index 4ab820b8e..b8acdeafe 100644
--- a/runtime/linux/autoconf-d-real-inode.c
+++ b/runtime/linux/autoconf-d-real-inode.c
@@ -2,7 +2,7 @@
 
 /* kernel function d_real_inode() is missing in older kernels like
  * kernel-3.10.0-327.el7.x86_64 */
-
+void foo(void);
 void foo(void) {
 	struct inode *ino = d_real_inode(NULL);
 	(void) ino;
diff --git a/runtime/linux/autoconf-dpath-path.c b/runtime/linux/autoconf-dpath-path.c
index c3654604b..fd2ae2c3c 100644
--- a/runtime/linux/autoconf-dpath-path.c
+++ b/runtime/linux/autoconf-dpath-path.c
@@ -1,6 +1,8 @@
 #include <linux/path.h>
 #include <linux/dcache.h>
 
+void ____autoconf_func(struct path *p);
+
 void ____autoconf_func(struct path *p)
 {
 	(void)d_path(p, NULL, 0);
diff --git a/runtime/linux/autoconf-files_lookup_fd_raw.c b/runtime/linux/autoconf-files_lookup_fd_raw.c
index 9e98aa064..5e8fd37d3 100644
--- a/runtime/linux/autoconf-files_lookup_fd_raw.c
+++ b/runtime/linux/autoconf-files_lookup_fd_raw.c
@@ -1,6 +1,8 @@
 #include <linux/fdtable.h>
 #include <linux/file.h>
 
+void foo(void);
+
 void
 foo(void)
 {
diff --git a/runtime/linux/autoconf-from_kuid_munged.c b/runtime/linux/autoconf-from_kuid_munged.c
index 444dac1a6..6405a3bd7 100644
--- a/runtime/linux/autoconf-from_kuid_munged.c
+++ b/runtime/linux/autoconf-from_kuid_munged.c
@@ -1,6 +1,7 @@
 #include <linux/uidgid.h>
 
 /* We need to check for an exported or inlined from_kuid_munged() */
+uid_t bar (struct user_namespace *ns, kuid_t uid);
 uid_t bar (struct user_namespace *ns, kuid_t uid) { 
     return (from_kuid_munged(ns, uid));
 }
diff --git a/runtime/linux/autoconf-fs_supers-hlist.c b/runtime/linux/autoconf-fs_supers-hlist.c
index 3d626ce90..d49845548 100644
--- a/runtime/linux/autoconf-fs_supers-hlist.c
+++ b/runtime/linux/autoconf-fs_supers-hlist.c
@@ -11,6 +11,8 @@ vfs: convert fs_supers to hlist
 Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
 */
 
+int foo (struct super_block *sb);
+
 int foo (struct super_block *sb) {
   return (hlist_unhashed (& sb->s_instances));
 }
diff --git a/runtime/linux/autoconf-get-kretprobe.c b/runtime/linux/autoconf-get-kretprobe.c
index ae5b4ab51..f25c1eae5 100644
--- a/runtime/linux/autoconf-get-kretprobe.c
+++ b/runtime/linux/autoconf-get-kretprobe.c
@@ -1,5 +1,7 @@
 #include <linux/kprobes.h>
 
+void* foo(struct kretprobe_instance* ri);
+
 void* foo(struct kretprobe_instance* ri)
 {
         return get_kretprobe(ri);
diff --git a/runtime/linux/autoconf-get_user_page_vma_remote.c b/runtime/linux/autoconf-get_user_page_vma_remote.c
index df3d05d27..78b28ce8e 100644
--- a/runtime/linux/autoconf-get_user_page_vma_remote.c
+++ b/runtime/linux/autoconf-get_user_page_vma_remote.c
@@ -31,6 +31,11 @@
 //    This forms part of a broader set of patches intended to eliminate the vmas
 //    parameter altogether.
 
+struct page *get_user_page_vma_remote_wrapper(struct mm_struct *mm,
+                                              unsigned long addr,
+                                              unsigned int gup_flags,
+                                              struct vm_area_struct **vmaps);
+
 struct page *get_user_page_vma_remote_wrapper(struct mm_struct *mm,
                    unsigned long addr,
                    unsigned int gup_flags,
diff --git a/runtime/linux/autoconf-get_user_pages-flags.c b/runtime/linux/autoconf-get_user_pages-flags.c
index f135afa11..1bc317bb7 100644
--- a/runtime/linux/autoconf-get_user_pages-flags.c
+++ b/runtime/linux/autoconf-get_user_pages-flags.c
@@ -32,6 +32,11 @@
 //                     struct vm_area_struct **vmas);
 //
 
+long gupr_wrapper(struct task_struct *tsk, struct mm_struct *mm,
+		  unsigned long start, unsigned long nr_pages,
+		  unsigned int gup_flags, struct page **pages,
+		  struct vm_area_struct **vmas);
+
 long gupr_wrapper(struct task_struct *tsk, struct mm_struct *mm,
 		  unsigned long start, unsigned long nr_pages,
 		  unsigned int gup_flags, struct page **pages,
diff --git a/runtime/linux/autoconf-get_user_pages-notask_struct.c b/runtime/linux/autoconf-get_user_pages-notask_struct.c
index 15bb73bd2..4def2b4e2 100644
--- a/runtime/linux/autoconf-get_user_pages-notask_struct.c
+++ b/runtime/linux/autoconf-get_user_pages-notask_struct.c
@@ -29,6 +29,11 @@
 //                     struct vm_area_struct **vmas);
 //
 
+long gupr_wrapper(struct mm_struct *mm,
+		  unsigned long start, unsigned long nr_pages,
+		  unsigned int gup_flags, struct page **pages,
+		  struct vm_area_struct **vmas);
+
 long gupr_wrapper(struct mm_struct *mm,
 		  unsigned long start, unsigned long nr_pages,
 		  unsigned int gup_flags, struct page **pages,
diff --git a/runtime/linux/autoconf-get_user_pages_remote-flags.c b/runtime/linux/autoconf-get_user_pages_remote-flags.c
index c0c23609f..1ff9fff76 100644
--- a/runtime/linux/autoconf-get_user_pages_remote-flags.c
+++ b/runtime/linux/autoconf-get_user_pages_remote-flags.c
@@ -30,6 +30,11 @@
 //                            struct vm_area_struct **vmas);
 //
 
+long gupr_wrapper(struct task_struct *tsk, struct mm_struct *mm,
+		  unsigned long start, unsigned long nr_pages,
+		  unsigned int gup_flags, struct page **pages,
+		  struct vm_area_struct **vmas);
+
 long gupr_wrapper(struct task_struct *tsk, struct mm_struct *mm,
 		  unsigned long start, unsigned long nr_pages,
 		  unsigned int gup_flags, struct page **pages,
diff --git a/runtime/linux/autoconf-get_user_pages_remote-flags_locked.c b/runtime/linux/autoconf-get_user_pages_remote-flags_locked.c
index bb9b56717..bda2919a0 100644
--- a/runtime/linux/autoconf-get_user_pages_remote-flags_locked.c
+++ b/runtime/linux/autoconf-get_user_pages_remote-flags_locked.c
@@ -23,6 +23,11 @@
 //                            struct vm_area_struct **vmas, int *locked);
 //
 
+long gupr_wrapper2(struct task_struct *tsk, struct mm_struct *mm,
+                   unsigned long start, unsigned long nr_pages,
+                   unsigned int gup_flags, struct page **pages,
+                   struct vm_area_struct **vmas, int *locked);
+
 long gupr_wrapper2(struct task_struct *tsk, struct mm_struct *mm,
                    unsigned long start, unsigned long nr_pages,
                    unsigned int gup_flags, struct page **pages,
diff --git a/runtime/linux/autoconf-get_user_pages_remote-notask_struct.c b/runtime/linux/autoconf-get_user_pages_remote-notask_struct.c
index 3b849af3c..0b50f23ef 100644
--- a/runtime/linux/autoconf-get_user_pages_remote-notask_struct.c
+++ b/runtime/linux/autoconf-get_user_pages_remote-notask_struct.c
@@ -29,6 +29,11 @@
 //                             struct vm_area_struct **vmas, int *locked);
 //
 
+long gupr_wrapper(struct mm_struct *mm,
+		  unsigned long start, unsigned long nr_pages,
+		  unsigned int gup_flags, struct page **pages,
+		  struct vm_area_struct **vmas, int *locked);
+
 long gupr_wrapper(struct mm_struct *mm,
 		  unsigned long start, unsigned long nr_pages,
 		  unsigned int gup_flags, struct page **pages,
diff --git a/runtime/linux/autoconf-grsecurity.c b/runtime/linux/autoconf-grsecurity.c
index ee2e4e55f..2b34290a3 100644
--- a/runtime/linux/autoconf-grsecurity.c
+++ b/runtime/linux/autoconf-grsecurity.c
@@ -5,6 +5,7 @@
 struct module *t;
 unsigned size;
 
+void foo (void);
 void foo (void)
 {
    size += t->init_size_rw + t->init_size_rx + t->core_size_rw + t->core_size_rx;  
diff --git a/runtime/linux/autoconf-hlist-4args.c b/runtime/linux/autoconf-hlist-4args.c
index ab9f8a5fe..8b504c50d 100644
--- a/runtime/linux/autoconf-hlist-4args.c
+++ b/runtime/linux/autoconf-hlist-4args.c
@@ -7,6 +7,7 @@ struct foo {
 
 struct hlist_head *h;
 
+void foo (void);
 void foo (void)
 {
         struct hlist_node *n;
diff --git a/runtime/linux/autoconf-hlist_add_tail_rcu.c b/runtime/linux/autoconf-hlist_add_tail_rcu.c
index 2c4660837..e5bc4a75f 100644
--- a/runtime/linux/autoconf-hlist_add_tail_rcu.c
+++ b/runtime/linux/autoconf-hlist_add_tail_rcu.c
@@ -1,5 +1,8 @@
 #include <linux/rculist.h>
 
+void foo(struct hlist_node *n, struct hlist_head *h);
+
+
 void foo(struct hlist_node *n, struct hlist_head *h)
 {
 	hlist_add_tail_rcu(n, h);
diff --git a/runtime/linux/autoconf-hrtimer-getset-expires.c b/runtime/linux/autoconf-hrtimer-getset-expires.c
index 951cb99b3..39a0c23fc 100644
--- a/runtime/linux/autoconf-hrtimer-getset-expires.c
+++ b/runtime/linux/autoconf-hrtimer-getset-expires.c
@@ -1,5 +1,6 @@
 #include <linux/hrtimer.h>
 
+void ____autoconf_func(struct hrtimer *t);
 void ____autoconf_func(struct hrtimer *t)
 {
     hrtimer_set_expires(t, hrtimer_get_expires(t));
diff --git a/runtime/linux/autoconf-hw_breakpoint_context.c b/runtime/linux/autoconf-hw_breakpoint_context.c
index 0b625657c..d59d29360 100644
--- a/runtime/linux/autoconf-hw_breakpoint_context.c
+++ b/runtime/linux/autoconf-hw_breakpoint_context.c
@@ -2,6 +2,10 @@
 
 /* void *context parameter is new since linux commit 4dc0da. */
 struct perf_event * __percpu *
+hw_breakpoint_context(struct perf_event_attr *attr,
+		      perf_overflow_handler_t triggered,
+		      void *context);
+struct perf_event * __percpu *
 hw_breakpoint_context(struct perf_event_attr *attr,
 		      perf_overflow_handler_t triggered,
 		      void *context)
diff --git a/runtime/linux/autoconf-kernel_read-new-args.c b/runtime/linux/autoconf-kernel_read-new-args.c
index f77c7ccf1..4de0cb7d3 100644
--- a/runtime/linux/autoconf-kernel_read-new-args.c
+++ b/runtime/linux/autoconf-kernel_read-new-args.c
@@ -27,6 +27,8 @@
 
 #include <linux/fs.h>
 
+ssize_t foo(struct file *file, void *buf, size_t count, loff_t *pos);
+
 ssize_t foo(struct file *file, void *buf, size_t count, loff_t *pos)
 {
 	return kernel_read(file, buf, count, pos);
diff --git a/runtime/linux/autoconf-kprobe-symbol-name.c b/runtime/linux/autoconf-kprobe-symbol-name.c
index eeb3f840e..6ee187330 100644
--- a/runtime/linux/autoconf-kprobe-symbol-name.c
+++ b/runtime/linux/autoconf-kprobe-symbol-name.c
@@ -1,5 +1,7 @@
 #include <linux/kprobes.h>
 
+void func(struct kprobe *kp);
+
 void func(struct kprobe *kp)
 {
   kp->symbol_name = "dummy";
diff --git a/runtime/linux/autoconf-ktime-get-real.c b/runtime/linux/autoconf-ktime-get-real.c
index 67b71409d..37164da17 100644
--- a/runtime/linux/autoconf-ktime-get-real.c
+++ b/runtime/linux/autoconf-ktime-get-real.c
@@ -1,5 +1,5 @@
 #include <linux/ktime.h>
-
+void ____autoconf_func(struct timespec *ts);
 void ____autoconf_func(struct timespec *ts)
 {
 	ktime_get_real_ts(ts);
diff --git a/runtime/linux/autoconf-local-clock.c b/runtime/linux/autoconf-local-clock.c
index d148c873a..f4385ff2f 100644
--- a/runtime/linux/autoconf-local-clock.c
+++ b/runtime/linux/autoconf-local-clock.c
@@ -29,6 +29,7 @@
 //     reference sched_clock_cpu(). Thus it must be exported with the
 //     EXPORT_SYMBOL_GPL macro.
 //
+void foo (void);
 
 void foo (void) {
    (void) local_clock();
diff --git a/runtime/linux/autoconf-lockdown-debugfs.c b/runtime/linux/autoconf-lockdown-debugfs.c
index 33fe50a54..c9a89ab80 100644
--- a/runtime/linux/autoconf-lockdown-debugfs.c
+++ b/runtime/linux/autoconf-lockdown-debugfs.c
@@ -1,5 +1,7 @@
 #include <linux/security.h>
 
+int foo(void);
+
 int foo(void) {
         return security_locked_down(LOCKDOWN_DEBUGFS);
 }
diff --git a/runtime/linux/autoconf-lockdown-kernel.c b/runtime/linux/autoconf-lockdown-kernel.c
index 90c241437..d4439c2fe 100644
--- a/runtime/linux/autoconf-lockdown-kernel.c
+++ b/runtime/linux/autoconf-lockdown-kernel.c
@@ -1,5 +1,7 @@
 #include <linux/kernel.h>
 
+int foo(void);
+
 int foo(void) {
   return kernel_is_locked_down("something");
 }
diff --git a/runtime/linux/autoconf-mm-context-vdso-base.c b/runtime/linux/autoconf-mm-context-vdso-base.c
index 99748fb75..c1428b492 100644
--- a/runtime/linux/autoconf-mm-context-vdso-base.c
+++ b/runtime/linux/autoconf-mm-context-vdso-base.c
@@ -1,5 +1,6 @@
 #include <linux/sched.h>
 
+int context_vdso(struct task_struct *tsk);
 int context_vdso(struct task_struct *tsk)
 {
   return (tsk->mm->context.vdso_base == 0L);
diff --git a/runtime/linux/autoconf-mm-context-vdso.c b/runtime/linux/autoconf-mm-context-vdso.c
index d2babc108..38e88fde1 100644
--- a/runtime/linux/autoconf-mm-context-vdso.c
+++ b/runtime/linux/autoconf-mm-context-vdso.c
@@ -1,5 +1,5 @@
 #include <linux/sched.h>
-
+int context_vdso(struct task_struct *tsk);
 int context_vdso(struct task_struct *tsk)
 {
   return (tsk->mm->context.vdso == NULL);
diff --git a/runtime/linux/autoconf-mm-shmempages.c b/runtime/linux/autoconf-mm-shmempages.c
index 2ce742be7..7f914be21 100644
--- a/runtime/linux/autoconf-mm-shmempages.c
+++ b/runtime/linux/autoconf-mm-shmempages.c
@@ -1,5 +1,7 @@
 #include <linux/sched.h>
 
+void foo (void);
+
 void foo (void) {
     (void) MM_SHMEMPAGES;
 }
diff --git a/runtime/linux/autoconf-mmap_lock.c b/runtime/linux/autoconf-mmap_lock.c
index 42119dc84..194e337a7 100644
--- a/runtime/linux/autoconf-mmap_lock.c
+++ b/runtime/linux/autoconf-mmap_lock.c
@@ -1,6 +1,8 @@
 #include <linux/mm_types.h>
 #include <linux/mmap_lock.h>
 
+int foobar(struct mm_struct *mm);
+
 int foobar(struct mm_struct *mm) { 
         mmap_write_lock (mm);
         mmap_read_unlock (mm);
diff --git a/runtime/linux/autoconf-module-sect-attrs.c b/runtime/linux/autoconf-module-sect-attrs.c
index f589dca30..78c0ada49 100644
--- a/runtime/linux/autoconf-module-sect-attrs.c
+++ b/runtime/linux/autoconf-module-sect-attrs.c
@@ -1,5 +1,7 @@
 #include <linux/module.h>
 
+unsigned long foobar(struct module_sect_attrs *moosas);
+
 unsigned long foobar(struct module_sect_attrs *moosas)
 {
   struct module_sect_attr msa = moosas->attrs[0];
diff --git a/runtime/linux/autoconf-netfilter-313b.c b/runtime/linux/autoconf-netfilter-313b.c
index 3b1883077..41fbaaef0 100644
--- a/runtime/linux/autoconf-netfilter-313b.c
+++ b/runtime/linux/autoconf-netfilter-313b.c
@@ -5,6 +5,13 @@
 // to kernel-3.10.0-284.el7 per rhbz1230935#c4 as patch no 119478.
 // This fixes PR18711.
 
+unsigned int
+new_style_hook(const struct nf_hook_ops *ops,
+               struct sk_buff *skb,
+               const struct net_device *nf_in,
+               const struct net_device *nf_out,
+               const struct nf_hook_state *state);
+
 unsigned int
 new_style_hook(const struct nf_hook_ops *ops,
 		 struct sk_buff *skb,
diff --git a/runtime/linux/autoconf-netfilter-4_1.c b/runtime/linux/autoconf-netfilter-4_1.c
index 9f3ba01d5..a18b46c2b 100644
--- a/runtime/linux/autoconf-netfilter-4_1.c
+++ b/runtime/linux/autoconf-netfilter-4_1.c
@@ -14,6 +14,11 @@
 //   
 //   Signed-off-by: David S. Miller <davem@davemloft.net>
 
+unsigned int
+newer_style_hook(const struct nf_hook_ops *ops,
+		 struct sk_buff *skb,
+		 const struct nf_hook_state *state);
+
 unsigned int
 newer_style_hook(const struct nf_hook_ops *ops,
 		 struct sk_buff *skb,
diff --git a/runtime/linux/autoconf-netfilter-4_4.c b/runtime/linux/autoconf-netfilter-4_4.c
index ad953efc3..9e1743515 100644
--- a/runtime/linux/autoconf-netfilter-4_4.c
+++ b/runtime/linux/autoconf-netfilter-4_4.c
@@ -28,6 +28,10 @@
 //   So we can simply remove all of the owner handling -- when module is
 //   removed it also needs to unregister all its hooks.
 
+unsigned int even_newer_style_hook(void *priv,
+				   struct sk_buff *skb,
+				   const struct nf_hook_state *state);
+
 unsigned int even_newer_style_hook(void *priv,
 				   struct sk_buff *skb,
 				   const struct nf_hook_state *state)
diff --git a/runtime/linux/autoconf-netfilter.c b/runtime/linux/autoconf-netfilter.c
index f12266416..42e83fdb7 100644
--- a/runtime/linux/autoconf-netfilter.c
+++ b/runtime/linux/autoconf-netfilter.c
@@ -1,5 +1,11 @@
 #include <linux/netfilter.h>
 
+unsigned int
+new_style_hook(const struct nf_hook_ops *ops,  /* not: unsigned int hook; */
+               struct sk_buff *skb,
+               const struct net_device *in, const struct net_device *out,
+               int (*okfn)(struct sk_buff *));
+
 unsigned int
 new_style_hook(const struct nf_hook_ops *ops,  /* not: unsigned int hook; */
                struct sk_buff *skb,
diff --git a/runtime/linux/autoconf-nmi-uaccess-okay.c b/runtime/linux/autoconf-nmi-uaccess-okay.c
index fd4f54957..0cb4f63db 100644
--- a/runtime/linux/autoconf-nmi-uaccess-okay.c
+++ b/runtime/linux/autoconf-nmi-uaccess-okay.c
@@ -3,6 +3,8 @@
 
 /* this function was no longer an inline since upstream kernel commit
  * af5c40c6ee */
+bool foo(void);
+
 bool foo(void)
 {
     return nmi_uaccess_okay();
diff --git a/runtime/linux/autoconf-pagefault_disable.c b/runtime/linux/autoconf-pagefault_disable.c
index c1b2c3a33..2a65f3f08 100644
--- a/runtime/linux/autoconf-pagefault_disable.c
+++ b/runtime/linux/autoconf-pagefault_disable.c
@@ -1,5 +1,6 @@
 #include <linux/uaccess.h>
-
+int foo (int c);
+        
 int foo (int c)
 {
         pagefault_disable();
diff --git a/runtime/linux/autoconf-pde_data.c b/runtime/linux/autoconf-pde_data.c
index e8b582330..d5f7d5b0d 100644
--- a/runtime/linux/autoconf-pde_data.c
+++ b/runtime/linux/autoconf-pde_data.c
@@ -4,6 +4,8 @@
 
 #include <linux/proc_fs.h>
 
+void* __something(const struct inode* i);
+
 void* __something(const struct inode* i)
 {
         return pde_data (i);
diff --git a/runtime/linux/autoconf-perf-structpid.c b/runtime/linux/autoconf-perf-structpid.c
index cbf07ffa1..4fd390821 100644
--- a/runtime/linux/autoconf-perf-structpid.c
+++ b/runtime/linux/autoconf-perf-structpid.c
@@ -1,5 +1,7 @@
 #include <linux/perf_event.h>
 
+void fn (void);
+
 void fn (void) {
   struct perf_event_attr *attr = NULL;
   int cpu = 0;
diff --git a/runtime/linux/autoconf-proc_ops.c b/runtime/linux/autoconf-proc_ops.c
index e3d2f93a9..1d302a254 100644
--- a/runtime/linux/autoconf-proc_ops.c
+++ b/runtime/linux/autoconf-proc_ops.c
@@ -7,6 +7,9 @@
 #include <linux/fs.h>
 #include <linux/proc_fs.h>
 
+int
+proc_open_file_test(struct inode *inode, struct file *filp);
+
 int
 proc_open_file_test(struct inode *inode, struct file *filp)
 {
diff --git a/runtime/linux/autoconf-procfs-owner.c b/runtime/linux/autoconf-procfs-owner.c
index dcec58b19..0545a0a50 100644
--- a/runtime/linux/autoconf-procfs-owner.c
+++ b/runtime/linux/autoconf-procfs-owner.c
@@ -1,7 +1,7 @@
 #include <linux/proc_fs.h>
 
 /* kernel commit 4d38a69c6 */
-
+void bar (void);
 void bar (void) {
         struct proc_dir_entry foo;
 	foo.owner = (void*) 0;
diff --git a/runtime/linux/autoconf-rcu_is_watching.c b/runtime/linux/autoconf-rcu_is_watching.c
index aca153e2a..4636e9057 100644
--- a/runtime/linux/autoconf-rcu_is_watching.c
+++ b/runtime/linux/autoconf-rcu_is_watching.c
@@ -4,7 +4,8 @@
 //
 // We need to use rcu_is_watching() where available to skip probes in
 // rcu-idle state.
-
+struct context * _stp_runtime_get_context(void);
+        
 struct context * _stp_runtime_get_context(void)
 {
         if (! rcu_is_watching())
diff --git a/runtime/linux/autoconf-real-parent.c b/runtime/linux/autoconf-real-parent.c
index 16c26c479..fe7e3b567 100644
--- a/runtime/linux/autoconf-real-parent.c
+++ b/runtime/linux/autoconf-real-parent.c
@@ -8,6 +8,7 @@
 
 struct task_struct t;
 
+void foo (void);
 void foo (void)
 {
   struct task_struct *p;
diff --git a/runtime/linux/autoconf-regset.c b/runtime/linux/autoconf-regset.c
index 9d994b03c..895f58fd9 100644
--- a/runtime/linux/autoconf-regset.c
+++ b/runtime/linux/autoconf-regset.c
@@ -1,5 +1,6 @@
 #include <linux/regset.h>
 
+int foobar(int n);
 int foobar(int n) { 
   const struct user_regset_view *rsv = task_user_regset_view(current);  
   const struct user_regset *rs = & rsv->regsets[0];
diff --git a/runtime/linux/autoconf-relay-umode_t.c b/runtime/linux/autoconf-relay-umode_t.c
index a9e5126c0..6ebadbcda 100644
--- a/runtime/linux/autoconf-relay-umode_t.c
+++ b/runtime/linux/autoconf-relay-umode_t.c
@@ -27,6 +27,8 @@ static struct rchan_callbacks __stp_relay_callbacks = {
    .create_buf_file = umode_t_callback,
 };
 
+void foo (void);
+
 void foo (void) {
    (void) __stp_relay_callbacks.create_buf_file;
 }
diff --git a/runtime/linux/autoconf-relay_buf-per_cpu_ptr.c b/runtime/linux/autoconf-relay_buf-per_cpu_ptr.c
index c105b3301..aae72376b 100644
--- a/runtime/linux/autoconf-relay_buf-per_cpu_ptr.c
+++ b/runtime/linux/autoconf-relay_buf-per_cpu_ptr.c
@@ -19,6 +19,8 @@
 #include <linux/percpu.h>
 #include <linux/bug.h>
 
+struct rchan_buf *relay_buf_test(struct rchan *chan, unsigned int cpu);
+
 struct rchan_buf *relay_buf_test(struct rchan *chan, unsigned int cpu)
 {
     BUILD_BUG_ON(sizeof(chan->buf) != sizeof(struct rchan_buf **));
diff --git a/runtime/linux/autoconf-ring_buffer-flags.c b/runtime/linux/autoconf-ring_buffer-flags.c
index 7d7b8df03..7f4e5fa3e 100644
--- a/runtime/linux/autoconf-ring_buffer-flags.c
+++ b/runtime/linux/autoconf-ring_buffer-flags.c
@@ -1,5 +1,5 @@
 #include <linux/ring_buffer.h>
-
+void ___autoconf_func(void);
 void ___autoconf_func(void)
 {
     (void)ring_buffer_lock_reserve(NULL, 0, 0);
diff --git a/runtime/linux/autoconf-ring_buffer_lost_events.c b/runtime/linux/autoconf-ring_buffer_lost_events.c
index df3e315b3..52f3f7982 100644
--- a/runtime/linux/autoconf-ring_buffer_lost_events.c
+++ b/runtime/linux/autoconf-ring_buffer_lost_events.c
@@ -2,7 +2,7 @@
    ring_buffer peek and consume calls. */
 #include <linux/types.h>
 #include <linux/ring_buffer.h>
-
+struct ring_buffer_event *foo (void);
 struct ring_buffer_event *foo (void)
 {
   /* last field is not always there */
diff --git a/runtime/linux/autoconf-ring_buffer_read_prepare.c b/runtime/linux/autoconf-ring_buffer_read_prepare.c
index 03dc6ea10..22fa46d44 100644
--- a/runtime/linux/autoconf-ring_buffer_read_prepare.c
+++ b/runtime/linux/autoconf-ring_buffer_read_prepare.c
@@ -2,6 +2,7 @@
 #include <linux/types.h>
 #include <linux/ring_buffer.h>
 
+void foo (void);
 void foo (void)
 {
   ring_buffer_read_prepare(NULL, 1);
diff --git a/runtime/linux/autoconf-save-stack-trace-no-bp.c b/runtime/linux/autoconf-save-stack-trace-no-bp.c
index 5c940f2d3..f1485ef8a 100644
--- a/runtime/linux/autoconf-save-stack-trace-no-bp.c
+++ b/runtime/linux/autoconf-save-stack-trace-no-bp.c
@@ -3,6 +3,8 @@
 #include <linux/stacktrace.h>
 #include <asm/stacktrace.h>
 
+void foo(struct task_struct *foo);
+
 void foo(struct task_struct *foo)
 {
   struct stack_trace trace;
diff --git a/runtime/linux/autoconf-save-stack-trace.c b/runtime/linux/autoconf-save-stack-trace.c
index 07d45c312..922017126 100644
--- a/runtime/linux/autoconf-save-stack-trace.c
+++ b/runtime/linux/autoconf-save-stack-trace.c
@@ -3,6 +3,8 @@
 #include <linux/stacktrace.h>
 #include <asm/stacktrace.h>
 
+void foo(struct task_struct *foo);
+
 void foo(struct task_struct *foo)
 {
   struct stack_trace trace;
@@ -16,6 +18,8 @@ void foo(struct task_struct *foo)
 
 static const struct stacktrace_ops print_stack_ops;
 
+void dumper(struct task_struct *foo);
+
 void dumper(struct task_struct *foo)
 {
   dump_trace(foo, 0, 0, 0, &print_stack_ops, 0);
diff --git a/runtime/linux/autoconf-set_fs.c b/runtime/linux/autoconf-set_fs.c
index 939e22f83..3fbdf8fac 100644
--- a/runtime/linux/autoconf-set_fs.c
+++ b/runtime/linux/autoconf-set_fs.c
@@ -1,6 +1,7 @@
 #include <linux/uaccess.h>
 
 // XXX set_fs is an inline function, so we can't detect it with exportconf:
+void __something(void);
 void __something(void)
 {
   mm_segment_t oldfs = get_fs();
diff --git a/runtime/linux/autoconf-smpcall-4args.c b/runtime/linux/autoconf-smpcall-4args.c
index 2966d95ee..168b6c991 100644
--- a/runtime/linux/autoconf-smpcall-4args.c
+++ b/runtime/linux/autoconf-smpcall-4args.c
@@ -1,11 +1,15 @@
 #include <linux/kernel.h>
 #include <linux/smp.h>
 
+void foo (void *arg);
+
 void foo (void *arg)
 {
         (void) arg;
 }
 
+void bar (void);
+
 void bar (void)
 {
         smp_call_function_single (0, &foo, 0, 1);
diff --git a/runtime/linux/autoconf-smpcall-5args.c b/runtime/linux/autoconf-smpcall-5args.c
index 83060f48d..1c8a948ea 100644
--- a/runtime/linux/autoconf-smpcall-5args.c
+++ b/runtime/linux/autoconf-smpcall-5args.c
@@ -1,11 +1,15 @@
 #include <linux/kernel.h>
 #include <linux/smp.h>
 
+void foo (void *arg);
+
 void foo (void *arg)
 {
         (void) arg;
 }
 
+void bar (void);
+
 void bar (void)
 {
         smp_call_function_single (0, &foo, 0, 1, 0);
diff --git a/runtime/linux/autoconf-stack-trace-save-regs.c b/runtime/linux/autoconf-stack-trace-save-regs.c
index 1fd515f8f..d1e541a9f 100644
--- a/runtime/linux/autoconf-stack-trace-save-regs.c
+++ b/runtime/linux/autoconf-stack-trace-save-regs.c
@@ -1,5 +1,7 @@
 #include <linux/stacktrace.h>
 
+unsigned int foo (void);
+
 unsigned int foo (void)
 {
         unsigned long e[10];
diff --git a/runtime/linux/autoconf-stacktrace_h.c b/runtime/linux/autoconf-stacktrace_h.c
index ced52b2cb..236e41331 100644
--- a/runtime/linux/autoconf-stacktrace_h.c
+++ b/runtime/linux/autoconf-stacktrace_h.c
@@ -3,6 +3,8 @@
 // Check to see if there is an <asm/stacktrace.h>
 // and a struc stack_frame defined.
 // Older kernels have struct stack_frame in <asm/processor.h>.
+int stack_frame_size(void);
+
 int stack_frame_size(void) {
   return sizeof(struct stack_frame);
 }
diff --git a/runtime/linux/autoconf-stacktrace_ops-int-address.c b/runtime/linux/autoconf-stacktrace_ops-int-address.c
index 8ca277a6e..fb215ef11 100644
--- a/runtime/linux/autoconf-stacktrace_ops-int-address.c
+++ b/runtime/linux/autoconf-stacktrace_ops-int-address.c
@@ -4,6 +4,10 @@
 // check for 4.6 patch which changed the function signature of
 // stacktrace_ops 'address' member.
 
+int print_stack_address(void *data __attribute__ ((unused)),
+			unsigned long addr __attribute__ ((unused)),
+			int reliable __attribute__ ((unused)));
+
 int print_stack_address(void *data __attribute__ ((unused)),
 			unsigned long addr __attribute__ ((unused)),
 			int reliable __attribute__ ((unused)))
diff --git a/runtime/linux/autoconf-stacktrace_ops-warning.c b/runtime/linux/autoconf-stacktrace_ops-warning.c
index 9c00f0583..75243e79f 100644
--- a/runtime/linux/autoconf-stacktrace_ops-warning.c
+++ b/runtime/linux/autoconf-stacktrace_ops-warning.c
@@ -2,6 +2,8 @@
 #include <linux/sched.h>
 #include <asm/stacktrace.h>
 
+void foo (void);
+
 void foo (void)
 {
   struct stacktrace_ops t;
diff --git a/runtime/linux/autoconf-syscall_get_args_3args.c b/runtime/linux/autoconf-syscall_get_args_3args.c
index c08faa915..3435d99b0 100644
--- a/runtime/linux/autoconf-syscall_get_args_3args.c
+++ b/runtime/linux/autoconf-syscall_get_args_3args.c
@@ -7,6 +7,7 @@ struct task_struct *task;
 struct pt_regs *regs;
 unsigned long *args;
 
+void __something(void);
 void __something(void)
 {
 	syscall_get_arguments(task, regs, args);
diff --git a/runtime/linux/autoconf-task-state.c b/runtime/linux/autoconf-task-state.c
index 27a1d7c13..2941f2ef3 100644
--- a/runtime/linux/autoconf-task-state.c
+++ b/runtime/linux/autoconf-task-state.c
@@ -13,6 +13,8 @@
 
 #include <linux/sched.h>
 
+unsigned int bar (struct task_struct *foo);
+
 unsigned int bar (struct task_struct *foo) { 
   return (foo->state = 0); 
 }
diff --git a/runtime/linux/autoconf-task-uid.c b/runtime/linux/autoconf-task-uid.c
index 8e40f8314..614b450e2 100644
--- a/runtime/linux/autoconf-task-uid.c
+++ b/runtime/linux/autoconf-task-uid.c
@@ -1,5 +1,7 @@
 #include <linux/sched.h>
 
+int bar (struct task_struct *foo);
+
 int bar (struct task_struct *foo) { 
   return (foo->uid = 0); 
 }
diff --git a/runtime/linux/autoconf-task_work-struct.c b/runtime/linux/autoconf-task_work-struct.c
index b6dbf14d2..aedaea9ed 100644
--- a/runtime/linux/autoconf-task_work-struct.c
+++ b/runtime/linux/autoconf-task_work-struct.c
@@ -2,6 +2,8 @@
 
 /* Original task_work code used 'struct task_work' (and
  * init_task_work() had 3 arguments). */
+void __autoconf_func(void);
+
 void __autoconf_func(void)
 {
 	struct task_work work;
diff --git a/runtime/linux/autoconf-trace-printk.c b/runtime/linux/autoconf-trace-printk.c
index c7515bc64..dbed8880c 100644
--- a/runtime/linux/autoconf-trace-printk.c
+++ b/runtime/linux/autoconf-trace-printk.c
@@ -1,6 +1,7 @@
 #include <linux/kernel.h>
 #include <linux/string.h>
 
+int bar (void);
 int bar (void) {
   static char *fmt = "%s\n";
   trace_printk (fmt, "hello world");
diff --git a/runtime/linux/autoconf-tracepoint-has-data.c b/runtime/linux/autoconf-tracepoint-has-data.c
index 777c31378..c34c6db38 100644
--- a/runtime/linux/autoconf-tracepoint-has-data.c
+++ b/runtime/linux/autoconf-tracepoint-has-data.c
@@ -1,6 +1,9 @@
 #include <linux/tracepoint.h>
 #include <trace/events/sched.h>
 
+
+void baz (void *cb_data, struct task_struct *parent, struct task_struct *child);
+
 void baz (void *cb_data, struct task_struct *parent, struct task_struct *child) {
 	(void) cb_data;
 	(void) parent;
@@ -10,6 +13,8 @@ void baz (void *cb_data, struct task_struct *parent, struct task_struct *child)
 /* Until 2.6.35 (commit 38516ab59fbc5b), register_trace_* took one argument.
    Until 5.7.0 (commit a2806ef77ff9a9), this could be checked by checking
    for the absence of DECLARE_TRACE_NOARGS. Now _NOARGS variant is removed. */
+void bar (void);
+
 void bar (void) {
 	register_trace_sched_process_fork(baz, NULL);
 }
diff --git a/runtime/linux/autoconf-tracepoint-strings.c b/runtime/linux/autoconf-tracepoint-strings.c
index 1b4785c8d..fcfaa0c2e 100644
--- a/runtime/linux/autoconf-tracepoint-strings.c
+++ b/runtime/linux/autoconf-tracepoint-strings.c
@@ -1,6 +1,7 @@
 #include <linux/tracepoint.h>
 
 /* Until 3.15 (commit de7b2973903c), tracepoints used strings to register.  */
+void foo (void);
 void foo (void) {
 	(void) tracepoint_probe_register("foo", NULL, NULL);
 	tracepoint_probe_unregister("foo", NULL, NULL);
diff --git a/runtime/linux/autoconf-twa_resume.c b/runtime/linux/autoconf-twa_resume.c
index 306cd28ef..5a6a1d958 100644
--- a/runtime/linux/autoconf-twa_resume.c
+++ b/runtime/linux/autoconf-twa_resume.c
@@ -2,6 +2,8 @@
 
 // Check to see if there is a define or enum for TWA_RESUME.
 // Older kernels just pass in true or false into task_work_add()
+int twa_resume_exist(void);
+
 int twa_resume_exist(void) {
   return (TWA_RESUME == TWA_RESUME);
 }
diff --git a/runtime/linux/autoconf-udelay_simple.c b/runtime/linux/autoconf-udelay_simple.c
index 3a7b19fb3..755448e7c 100644
--- a/runtime/linux/autoconf-udelay_simple.c
+++ b/runtime/linux/autoconf-udelay_simple.c
@@ -1,5 +1,7 @@
 #include <asm/delay.h>
 
+void foo (unsigned long long usecs);
+
 void foo (unsigned long long usecs)
 {
     udelay_simple(usecs);
diff --git a/runtime/linux/autoconf-unwind-stack-trace.c b/runtime/linux/autoconf-unwind-stack-trace.c
index 2ec399e67..8f784ffa4 100644
--- a/runtime/linux/autoconf-unwind-stack-trace.c
+++ b/runtime/linux/autoconf-unwind-stack-trace.c
@@ -1,6 +1,8 @@
 #include <linux/sched.h>
 #include <asm/unwind.h>
 
+void unwind_stack_trace (void);
+
 void unwind_stack_trace (void)
 {
   struct unwind_state state;
diff --git a/runtime/linux/autoconf-user-access-begin-2-args.c b/runtime/linux/autoconf-user-access-begin-2-args.c
index 2ecc5af9e..32a82ae7a 100644
--- a/runtime/linux/autoconf-user-access-begin-2-args.c
+++ b/runtime/linux/autoconf-user-access-begin-2-args.c
@@ -1,5 +1,7 @@
 #include <linux/uaccess.h>
 
+bool foo(const void __user *ptr, size_t size);
+
 bool foo(const void __user *ptr, size_t size)
 {
 	return user_access_begin(ptr, size);
diff --git a/runtime/linux/autoconf-user-access-begin-3-args.c b/runtime/linux/autoconf-user-access-begin-3-args.c
index 2942ddf08..2bb795b5f 100644
--- a/runtime/linux/autoconf-user-access-begin-3-args.c
+++ b/runtime/linux/autoconf-user-access-begin-3-args.c
@@ -1,5 +1,7 @@
 #include <linux/uaccess.h>
 
+bool foo(int mode, const void __user *ptr, size_t size);
+
 bool foo(int mode, const void __user *ptr, size_t size)
 {
 	return user_access_begin(mode, ptr, size);
diff --git a/runtime/linux/autoconf-user-access-end.c b/runtime/linux/autoconf-user-access-end.c
index 4eafb8222..6109d42b6 100644
--- a/runtime/linux/autoconf-user-access-end.c
+++ b/runtime/linux/autoconf-user-access-end.c
@@ -1,5 +1,5 @@
 #include <linux/uaccess.h>
-
+void foo(void);
 void foo(void)
 {
 	user_access_end();
diff --git a/runtime/linux/autoconf-utrace-via-tracepoints.c b/runtime/linux/autoconf-utrace-via-tracepoints.c
index 89ba29822..95f844015 100644
--- a/runtime/linux/autoconf-utrace-via-tracepoints.c
+++ b/runtime/linux/autoconf-utrace-via-tracepoints.c
@@ -13,6 +13,10 @@
 #error "CONFIG_TRACEPOINTS is not enabled"
 #endif
 
+void __sched_process_fork(void *cb_data __attribute__((unused)),
+			  struct task_struct *parent __attribute__((unused)),
+			  struct task_struct *child __attribute__((unused)));
+
 void __sched_process_fork(void *cb_data __attribute__((unused)),
 			  struct task_struct *parent __attribute__((unused)),
 			  struct task_struct *child __attribute__((unused)))
@@ -20,12 +24,18 @@ void __sched_process_fork(void *cb_data __attribute__((unused)),
 	return;
 }
 
+void __sched_process_exit(void *cb_data __attribute__((unused)),
+			  struct task_struct *task __attribute__((unused)));
 void __sched_process_exit(void *cb_data __attribute__((unused)),
 			  struct task_struct *task __attribute__((unused)))
 {
 	return;
 }
 
+void __sched_process_exec(void *cb_data __attribute__ ((unused)),
+			  struct task_struct *task __attribute__((unused)),
+			  pid_t old_pid __attribute__((unused)),
+			  struct linux_binprm *bprm __attribute__((unused)));
 void __sched_process_exec(void *cb_data __attribute__ ((unused)),
 			  struct task_struct *task __attribute__((unused)),
 			  pid_t old_pid __attribute__((unused)),
@@ -34,6 +44,9 @@ void __sched_process_exec(void *cb_data __attribute__ ((unused)),
 	return;
 }
 
+void __sys_enter(void *cb_data __attribute__ ((unused)),
+		 struct pt_regs *regs __attribute__((unused)),
+		 long id __attribute__((unused)));
 void __sys_enter(void *cb_data __attribute__ ((unused)),
 		 struct pt_regs *regs __attribute__((unused)),
 		 long id __attribute__((unused)))
@@ -41,6 +54,9 @@ void __sys_enter(void *cb_data __attribute__ ((unused)),
 	return;
 }
 
+void __sys_exit(void *cb_data __attribute__ ((unused)),
+		struct pt_regs *regs __attribute__((unused)),
+		long ret __attribute__((unused)));
 void __sys_exit(void *cb_data __attribute__ ((unused)),
 		struct pt_regs *regs __attribute__((unused)),
 		long ret __attribute__((unused)))
@@ -48,7 +64,8 @@ void __sys_exit(void *cb_data __attribute__ ((unused)),
 	return;
 }
 
-void __autoconf_func(void)
+void __autoconf_func(void);
+void __autoconf_func(void)        
 {
 	(void) register_trace_sched_process_fork(__sched_process_fork, NULL);
 	(void) register_trace_sched_process_exit(__sched_process_exit, NULL);
diff --git a/runtime/linux/autoconf-vm-area-pte.c b/runtime/linux/autoconf-vm-area-pte.c
index 6493cb0d1..f1541e931 100644
--- a/runtime/linux/autoconf-vm-area-pte.c
+++ b/runtime/linux/autoconf-vm-area-pte.c
@@ -1,6 +1,8 @@
 #include <linux/vmalloc.h>
 
 /* kernel commit cd12909cb576d373 */
+struct vm_struct * foo (void);
+
 struct vm_struct * foo (void) {
    return alloc_vm_area(PAGE_SIZE, NULL);
 }
diff --git a/runtime/linux/autoconf-walk-stack.c b/runtime/linux/autoconf-walk-stack.c
index c6c972917..2b02e45ba 100644
--- a/runtime/linux/autoconf-walk-stack.c
+++ b/runtime/linux/autoconf-walk-stack.c
@@ -2,6 +2,8 @@
 #include <linux/sched.h>
 #include <asm/stacktrace.h>
 
+void foo (void);
+
 void foo (void)
 {
   struct stacktrace_ops t;
diff --git a/runtime/linux/perf_event_counter_context.c b/runtime/linux/perf_event_counter_context.c
index 04d5912cb..88ff2bc87 100644
--- a/runtime/linux/perf_event_counter_context.c
+++ b/runtime/linux/perf_event_counter_context.c
@@ -1,6 +1,13 @@
 #include <linux/perf_event.h>
 
 /* void *context parameter is new since linux commit 4dc0da. */
+struct perf_event *
+pref_ec_context(struct perf_event_attr *attr,
+		int cpu,
+		struct task_struct *task,
+		perf_overflow_handler_t callback,
+		void *context);
+
 struct perf_event *
 pref_ec_context(struct perf_event_attr *attr,
 		int cpu,
diff --git a/runtime/linux/runtime.h b/runtime/linux/runtime.h
index a0a9ac389..1fa62c7ed 100644
--- a/runtime/linux/runtime.h
+++ b/runtime/linux/runtime.h
@@ -457,6 +457,7 @@ static int stap_init_module (void)
 
 module_init(stap_init_module);
 
+void stap_cleanup_module(void);
 void stap_cleanup_module(void)
 {
   _stp_transport_close();
diff --git a/runtime/linux/task_finder2.c b/runtime/linux/task_finder2.c
index 3e97dd817..9c2f5ad88 100644
--- a/runtime/linux/task_finder2.c
+++ b/runtime/linux/task_finder2.c
@@ -695,6 +695,10 @@ __stp_call_callbacks(struct stap_task_finder_target *tgt,
 	}
 }
 
+bool
+__verify_build_id(struct task_struct *tsk, unsigned long addr,
+                  unsigned const char *build_id, int build_id_len);
+
 bool
 __verify_build_id(struct task_struct *tsk, unsigned long addr,
 			  unsigned const char *build_id, int build_id_len)
diff --git a/runtime/sym.c b/runtime/sym.c
index 720ba2239..d702d1f11 100644
--- a/runtime/sym.c
+++ b/runtime/sym.c
@@ -368,9 +368,9 @@ static void _stp_filename_lookup_5(struct _stp_module *mod, char ** filename,
 
 #endif /* STP_NEED_LINE_DATA */
 
-unsigned long _stp_linenumber_lookup(unsigned long addr, struct task_struct *task,
-                                     char ** filename, int need_filename,
-                                     struct context *c)
+static unsigned long _stp_linenumber_lookup(unsigned long addr, struct task_struct *task,
+                                            char ** filename, int need_filename,
+                                            struct context *c)
 {
   struct _stp_module *m;
   struct _stp_section *sec;
diff --git a/runtime/transport/symbols.c b/runtime/transport/symbols.c
index 64ade9e0f..92635f3be 100644
--- a/runtime/transport/symbols.c
+++ b/runtime/transport/symbols.c
@@ -154,6 +154,8 @@ struct stap_module_sect_attrs
 void get_module_sect_attrs(struct module* mod,
                            struct stap_module_sect_attrs* as);
 
+void put_module_sect_attrs(struct stap_module_sect_attrs* as);
+
 void put_module_sect_attrs(struct stap_module_sect_attrs* as)
 {
         _stp_kfree(as->sections);
diff --git a/tapset/linux/aux_syscalls.stp b/tapset/linux/aux_syscalls.stp
index 0a7cd74dc..cf54aa152 100644
--- a/tapset/linux/aux_syscalls.stp
+++ b/tapset/linux/aux_syscalls.stp
@@ -152,6 +152,8 @@ _stp_lookup_or_str(const _stp_val_array * const array, long val, char *ptr,
 
 #ifndef STAPCONF_SIGSET_FROM_COMPAT_EXPORTED
 void
+sigset_from_compat(sigset_t *set, compat_sigset_t *compat);
+void
 sigset_from_compat(sigset_t *set, compat_sigset_t *compat)
 {
 	switch (_NSIG_WORDS) {
diff --git a/tapsets.cxx b/tapsets.cxx
index 4b8fa853d..05ad07e75 100644
--- a/tapsets.cxx
+++ b/tapsets.cxx
@@ -12229,6 +12229,7 @@ tracepoint_derived_probe_group::emit_module_decls (systemtap_session& s)
       if (used_args.empty())
         {
           tpop->newline() << "STP_TRACE_ENTER_REAL_NOARGS(" << enter_real_fn << ");";
+          s.op->newline() << "STP_TRACE_ENTER_REAL_NOARGS(" << enter_real_fn << ");";
           s.op->newline() << "STP_TRACE_ENTER_REAL_NOARGS(" << enter_real_fn << ")";
         }
       else
@@ -12242,6 +12243,14 @@ tracepoint_derived_probe_group::emit_module_decls (systemtap_session& s)
               s.op->newline() << ", int64_t __tracepoint_arg_" << used_args[j]->name;
             }
           tpop->line() << ");";
+          s.op->newline() << ");";
+          s.op->indent(-2);
+          s.op->newline() << "STP_TRACE_ENTER_REAL(" << enter_real_fn;
+          s.op->indent(2);
+          for (unsigned j = 0; j < used_args.size(); ++j)
+            {
+              s.op->newline() << ", int64_t __tracepoint_arg_" << used_args[j]->name;
+            }
           s.op->newline() << ")";
           s.op->indent(-2);
         }
@@ -12294,6 +12303,8 @@ tracepoint_derived_probe_group::emit_module_decls (systemtap_session& s)
 
 
       // emit normalized registration functions
+      s.op->newline() << "int register_tracepoint_probe_" << i << "(void);";
+      tpop->newline() << "int register_tracepoint_probe_" << i << "(void);" << endl;
       tpop->newline() << "int register_tracepoint_probe_" << i << "(void) {";
       tpop->newline(1) << "return STP_TRACE_REGISTER(" << p->tracepoint_name
                        << ", " << enter_fn << ");";
@@ -12303,16 +12314,16 @@ tracepoint_derived_probe_group::emit_module_decls (systemtap_session& s)
       // can only occur if the tracepoint doesn't exist (yet?), or if we
       // weren't even registered.  The former should be OKed by the initial
       // registration call, and the latter is safe to ignore.
+      
+      // declare normalized registration functions
+      s.op->newline() << "void unregister_tracepoint_probe_" << i << "(void);";
+      tpop->newline() << "void unregister_tracepoint_probe_" << i << "(void);" << endl;
       tpop->newline() << "void unregister_tracepoint_probe_" << i << "(void) {";
       tpop->newline(1) << "(void) STP_TRACE_UNREGISTER(" << p->tracepoint_name
                        << ", " << enter_fn << ");";
       tpop->newline(-1) << "}";
       tpop->newline();
 
-      // declare normalized registration functions
-      s.op->newline() << "int register_tracepoint_probe_" << i << "(void);";
-      s.op->newline() << "void unregister_tracepoint_probe_" << i << "(void);";
-
       tpop->assert_0_indent();
     }
 
diff --git a/translate.cxx b/translate.cxx
index 675ef589f..24091d62b 100644
--- a/translate.cxx
+++ b/translate.cxx
@@ -1211,6 +1211,7 @@ c_unparser::emit_common_header ()
       o->newline( 0)  << "#define STP_ON_THE_FLY_INTERVAL (100*1000*1000)"; // default to 100 ms
       o->newline( 0)  << "#endif";
 
+      o->newline( 0)  << "hrtimer_return_t module_refresh_timer_cb(struct hrtimer *timer);";
       o->newline( 0)  << "hrtimer_return_t module_refresh_timer_cb(struct hrtimer *timer) {";
       o->newline(+1)  <<   "if (atomic_cmpxchg(&need_module_refresh, 1, 0) == 1)";
       // NB: one might like to invoke systemtap_module_refresh(NULL) directly from
