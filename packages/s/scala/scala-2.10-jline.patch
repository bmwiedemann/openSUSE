--- scala-2.10.7/src/compiler/scala/tools/nsc/interpreter/JLineReader.scala	2019-11-27 16:04:03.141644641 +0100
+++ scala-2.10.7/src/compiler/scala/tools/nsc/interpreter/JLineReader.scala	2019-11-27 16:04:24.461764259 +0100
@@ -45,7 +45,7 @@
     def readOneKey(prompt: String) = {
       this.print(prompt)
       this.flush()
-      this.readVirtualKey()
+      this.readCharacter()
     }
     def eraseLine() = consoleReader.resetPromptLine("", "", 0)
     def redrawLineAndFlush(): Unit = { flush() ; drawLine() ; flush() }
--- scala-2.10.7/src/compiler/scala/tools/nsc/interpreter/session/FileBackedHistory.scala	2019-11-27 16:04:03.141644641 +0100
+++ scala-2.10.7/src/compiler/scala/tools/nsc/interpreter/session/FileBackedHistory.scala	2019-11-27 16:05:14.034042924 +0100
@@ -15,7 +15,7 @@
 /** TODO: file locking.
  */
 trait FileBackedHistory extends JLineHistory with JPersistentHistory {
-  def maxSize: Int
+  def maxSize: Int = 2500
 
   // For a history file in the standard location, always try to restrict permission,
   // creating an empty file if none exists.
--- scala-2.10.7/src/compiler/scala/tools/nsc/interpreter/session/JLineHistory.scala	2019-11-27 16:04:03.141644641 +0100
+++ scala-2.10.7/src/compiler/scala/tools/nsc/interpreter/session/JLineHistory.scala	2019-11-27 16:04:24.461764259 +0100
@@ -13,7 +13,6 @@
 trait JLineHistory extends JHistory with History {
   def size: Int
   def isEmpty: Boolean
-  def index: Int
   def clear(): Unit
   def get(index: Int): CharSequence
   def add(line: CharSequence): Unit
@@ -42,7 +41,8 @@
         addLineToFile(item)
       }
     }
-    override def toString = "History(size = " + size + ", index = " + index + ")"
+    override def toString = "History(size = " + size + ", _index = " + index + ")"
+    override def maxSize: Int = 2500
   }
 
   def apply(): JLineHistory = try new JLineFileHistory catch { case x: Exception => new SimpleHistory() }
--- scala-2.10.7/src/compiler/scala/tools/nsc/interpreter/session/SimpleHistory.scala	2019-11-27 16:04:03.141644641 +0100
+++ scala-2.10.7/src/compiler/scala/tools/nsc/interpreter/session/SimpleHistory.scala	2019-11-27 16:04:24.461764259 +0100
@@ -10,7 +10,7 @@
 import scala.collection.mutable.{ Buffer, ListBuffer }
 import scala.collection.JavaConverters._
 
-class SimpleHistory extends JLineHistory {
+class SimpleHistory extends JMemoryHistory with JLineHistory {
   private var _index: Int = 0
   private val buf: Buffer[String] = new ListBuffer[String]
   private def toEntries(): Seq[JEntry] = buf.zipWithIndex map { case (x, i) => Entry(i, x) }
@@ -32,27 +32,27 @@
   def maxSize: Int = 2500
   def last = if (isEmpty) fail("last") else buf.last
 
-  def size = buf.size
-  def index = _index
-  def isEmpty = buf.isEmpty
-  def clear() = buf.clear()
-  def get(idx: Int): CharSequence = buf(idx)
-  def add(item: CharSequence): Unit = buf += item
-  def replace(item: CharSequence): Unit = {
+  override def size = buf.size
+  override def index = _index
+  override def isEmpty = buf.isEmpty
+  override def clear() = buf.clear()
+  override def get(idx: Int): CharSequence = buf(idx)
+  override def add(item: CharSequence): Unit = buf += item
+  override def replace(item: CharSequence): Unit = {
     buf trimEnd 1
     add(item)
   }
-  def entries(idx: Int): JListIterator[JEntry] = toEntries().asJava.listIterator(idx)
-  def entries(): JListIterator[JEntry]         = toEntries().asJava.listIterator()
-  def iterator: JIterator[JEntry]              = toEntries().iterator.asJava
-
-  def current()         = if (index >= 0 && index < buf.size) buf(index) else fail("current()")
-  def previous()        = (index > 0) && minusOne
-  def next()            = (index <= lastIndex) && plusOne
-  def moveToFirst()     = (size > 0) && (index != 0) && setTo(0)
-  def moveToLast()      = (size > 0) && (index < lastIndex) && setTo(lastIndex)
-  def moveTo(idx: Int)  = (idx > 0) && (idx <= lastIndex) && setTo(idx)
-  def moveToEnd(): Unit = setTo(size)
+  override def entries(idx: Int): JListIterator[JEntry] = toEntries().asJava.listIterator(idx)
+  override def entries(): JListIterator[JEntry]         = toEntries().asJava.listIterator()
+  override def iterator: JIterator[JEntry]              = toEntries().iterator.asJava
+
+  override def current()         = if (index >= 0 && index < buf.size) buf(index) else fail("current()")
+  override def previous()        = (index > 0) && minusOne
+  override def next()            = (index <= lastIndex) && plusOne
+  override def moveToFirst()     = (size > 0) && (index != 0) && setTo(0)
+  override def moveToLast()      = (size > 0) && (index < lastIndex) && setTo(lastIndex)
+  override def moveTo(idx: Int)  = (idx > 0) && (idx <= lastIndex) && setTo(idx)
+  override def moveToEnd(): Unit = setTo(size)
 
   // scala legacy interface
   def asList: List[JEntry] = toEntries().toList
