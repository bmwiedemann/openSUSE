From 17811ce518f2db3db4ecb15c81ed774593715713 Mon Sep 17 00:00:00 2001
From: Mladen Milinkovic <maxrd2@smoothware.net>
Date: Thu, 14 Oct 2021 02:32:16 +0200
Subject: [PATCH] Fix crashes on empty lines list

---
 src/gui/treeview/linesmodel.cpp          | 15 ++++++++++++---
 src/gui/treeview/linesselectionmodel.cpp | 17 +++++++++++++----
 2 files changed, 25 insertions(+), 7 deletions(-)

diff --git a/src/gui/treeview/linesmodel.cpp b/src/gui/treeview/linesmodel.cpp
index e36c2dd..afcd1db 100644
--- a/src/gui/treeview/linesmodel.cpp
+++ b/src/gui/treeview/linesmodel.cpp
@@ -314,12 +314,14 @@ LinesModel::onLinesRemoved(int firstIndex, int lastIndex)
 void
 LinesModel::onModelReset()
 {
-	beginResetModel();
-	endResetModel();
-
 	LinesWidget *w = static_cast<LinesWidget *>(parent());
 	QItemSelectionModel *sm = w->selectionModel();
 
+	const QModelIndex prevIndex = sm->currentIndex();;
+
+	beginResetModel();
+	endResetModel();
+
 	if(sm->hasSelection()) {
 		if(!sm->currentIndex().isValid()) {
 			const QModelIndex idx = index(sm->selection().first().top());
@@ -332,6 +334,13 @@ LinesModel::onModelReset()
 			sm->select(QItemSelection(first, last), QItemSelectionModel::ClearAndSelect);
 		}
 		sm->setCurrentIndex(first, QItemSelectionModel::Rows);
+	} else {
+		if(prevIndex.isValid() && !sm->currentIndex().isValid()) {
+			// model reset should invalidate current index and prevent signals
+			QSignalBlocker s(sm); // make sure nothing fires anyway
+			sm->setCurrentIndex(prevIndex, QItemSelectionModel::Rows);
+		}
+		sm->clear();
 	}
 
 	if(w->scrollFollowsModel())
diff --git a/src/gui/treeview/linesselectionmodel.cpp b/src/gui/treeview/linesselectionmodel.cpp
index 2dc14d5..9a1ccd2 100644
--- a/src/gui/treeview/linesselectionmodel.cpp
+++ b/src/gui/treeview/linesselectionmodel.cpp
@@ -28,7 +28,8 @@ LinesSelectionModel::LinesSelectionModel(LinesModel *model)
 void
 LinesSelectionModel::setCurrentIndex(const QModelIndex &index, QItemSelectionModel::SelectionFlags command)
 {
-	m_currentLine = static_cast<LinesModel *>(model())->subtitle()->line(index.row());
+	Subtitle *sub = static_cast<LinesModel *>(model())->subtitle();
+	m_currentLine = sub ? sub->line(index.row()) : nullptr;
 	QItemSelectionModel::setCurrentIndex(index, command);
 }
 
@@ -50,6 +51,9 @@ LinesSelectionModel::select(const QItemSelection &selection, QItemSelectionModel
 		m_selection.clear();
 
 	const Subtitle *subtitle = static_cast<LinesModel *>(model())->subtitle();
+	if(!subtitle)
+		return;
+
 	QModelIndexList sel = selection.indexes();
 	while(!sel.empty()) {
 		const SubtitleLine *line = subtitle->line(sel.takeFirst().row());
@@ -83,11 +87,16 @@ LinesSelectionModel::reset()
 	QItemSelectionModel::reset();
 	m_resetInProgress = false;
 
-	if(m_currentLine)
-		QItemSelectionModel::setCurrentIndex(model()->index(m_currentLine->index(), 0), QItemSelectionModel::Current);
-
 	const LinesModel *model = static_cast<LinesModel *>(this->model());
 	Subtitle *subtitle = model->subtitle();
+	if(!subtitle) {
+		QItemSelectionModel::clear();
+		return;
+	}
+
+	if(m_currentLine)
+		QItemSelectionModel::setCurrentIndex(model->index(m_currentLine->index(), 0), QItemSelectionModel::Current);
+
 	const int lastCol = model->columnCount() - 1;
 	for(auto it = m_selection.cbegin(); it != m_selection.cend(); ++it) {
 		const SubtitleLine *line = *it;
-- 
GitLab

