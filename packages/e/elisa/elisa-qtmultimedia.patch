From f110ef437587dceda1ca0e89b83576a1da092765 Mon Sep 17 00:00:00 2001
From: Jack Hill <jackhill3103@gmail.com>
Date: Wed, 14 Feb 2024 14:00:59 +0000
Subject: [PATCH] Fix qt multimedia backend stopping playback after a track has
 finished

When reaching the end of a track the QMediaPlayer first sets
playbackState to Stopped and then sets mediaStatus to EndOfMedia.

The ManageAudioPlayer class is currently designed to handle changes the
other way round because that's how the old Qt5 backend worked. I.e. set
EndOfMedia first and then set Stopped. This meant the audio player would
first see the Stopped signal and did not know that we should start
playing the next track immediately.

Now we cache the signals from QMediaPlayer and emit them in the order
expected by ManageAudioPlayer.
---
 src/audiowrapper.h                |  4 ++++
 src/audiowrapper_qtmultimedia.cpp | 37 ++++++++++++++++++++++++++-----
 2 files changed, 36 insertions(+), 5 deletions(-)

diff --git a/src/audiowrapper.h b/src/audiowrapper.h
index f0be2d40..8d02beff 100644
--- a/src/audiowrapper.h
+++ b/src/audiowrapper.h
@@ -165,6 +165,10 @@ private Q_SLOTS:
 
     void playerSeekableSignalChanges(bool isSeekable);
 
+    void queueStatusChanged();
+
+    void notifyStatusChanges();
+
     friend class AudioWrapperPrivate;
 
     std::unique_ptr<AudioWrapperPrivate> d;
diff --git a/src/audiowrapper_qtmultimedia.cpp b/src/audiowrapper_qtmultimedia.cpp
index 6e085ffe..fdf762f1 100644
--- a/src/audiowrapper_qtmultimedia.cpp
+++ b/src/audiowrapper_qtmultimedia.cpp
@@ -32,6 +32,11 @@ class AudioWrapperPrivate
 
     bool mHasSavedPosition = false;
 
+    QMediaPlayer::PlaybackState mCurrentPlaybackState = mPlayer.playbackState();
+
+    QMediaPlayer::MediaStatus mCurrentMediaStatus = mPlayer.mediaStatus();
+
+    bool mQueuedStatusUpdate = false;
 };
 
 AudioWrapper::AudioWrapper(QObject *parent) : QObject(parent), d(std::make_unique<AudioWrapperPrivate>())
@@ -40,10 +45,9 @@ AudioWrapper::AudioWrapper(QObject *parent) : QObject(parent), d(std::make_uniqu
     connect(&d->mOutput, &QAudioOutput::mutedChanged, this, &AudioWrapper::playerMutedChanged);
     connect(&d->mOutput, &QAudioOutput::volumeChanged, this, &AudioWrapper::playerVolumeChanged);
     connect(&d->mPlayer, &QMediaPlayer::sourceChanged, this, &AudioWrapper::sourceChanged);
-    connect(&d->mPlayer, &QMediaPlayer::playbackStateChanged, this, &AudioWrapper::playbackStateChanged);
-    connect(&d->mPlayer, &QMediaPlayer::playbackStateChanged, this, &AudioWrapper::playerStateChanged);
+    connect(&d->mPlayer, &QMediaPlayer::playbackStateChanged, this, &AudioWrapper::queueStatusChanged);
     connect(&d->mPlayer, QOverload<QMediaPlayer::Error, const QString &>::of(&QMediaPlayer::errorOccurred), this, &AudioWrapper::errorChanged);
-    connect(&d->mPlayer, &QMediaPlayer::mediaStatusChanged, this, &AudioWrapper::statusChanged);
+    connect(&d->mPlayer, &QMediaPlayer::mediaStatusChanged, this, &AudioWrapper::queueStatusChanged);
     connect(&d->mPlayer, &QMediaPlayer::mediaStatusChanged, this, &AudioWrapper::mediaStatusChanged);
     connect(&d->mPlayer, &QMediaPlayer::durationChanged, this, &AudioWrapper::durationChanged);
     connect(&d->mPlayer, &QMediaPlayer::positionChanged, this, &AudioWrapper::positionChanged);
@@ -99,12 +103,12 @@ bool AudioWrapper::seekable() const
 
 QMediaPlayer::PlaybackState AudioWrapper::playbackState() const
 {
-    return d->mPlayer.playbackState();
+    return d->mCurrentPlaybackState;
 }
 
 QMediaPlayer::MediaStatus AudioWrapper::status() const
 {
-    return d->mPlayer.mediaStatus();
+    return d->mCurrentMediaStatus;
 }
 
 void AudioWrapper::setMuted(bool muted)
@@ -289,5 +293,28 @@ void AudioWrapper::savePosition(qint64 position)
     }
 }
 
+void AudioWrapper::notifyStatusChanges()
+{
+    d->mQueuedStatusUpdate = false;
+
+    if (d->mPlayer.mediaStatus() != d->mCurrentMediaStatus) {
+        d->mCurrentMediaStatus = d->mPlayer.mediaStatus();
+        Q_EMIT statusChanged(d->mCurrentMediaStatus);
+    }
+    if (d->mPlayer.playbackState() != d->mCurrentPlaybackState) {
+        d->mCurrentPlaybackState = d->mPlayer.playbackState();
+        Q_EMIT playbackStateChanged(d->mCurrentPlaybackState);
+        playerStateChanged();
+    }
+}
+
+void AudioWrapper::queueStatusChanged()
+{
+    if (!d->mQueuedStatusUpdate) {
+        QTimer::singleShot(0, this, &AudioWrapper::notifyStatusChanges);
+        d->mQueuedStatusUpdate = true;
+    }
+}
+
 
 #include "moc_audiowrapper.cpp"
