diff -Nura ibus-chewing-1.6.1/Modules/CmakeFedoraScript.cmake ibus-chewing-1.6.1_new/Modules/CmakeFedoraScript.cmake
--- ibus-chewing-1.6.1/Modules/CmakeFedoraScript.cmake	1970-01-01 08:00:00.000000000 +0800
+++ ibus-chewing-1.6.1_new/Modules/CmakeFedoraScript.cmake	2015-12-17 17:43:31.000000000 +0800
@@ -0,0 +1,240 @@
+# - Cmake Fedora Script
+# Scripts to be invoked in command line
+#
+
+MACRO(CMAKE_FEDORA_SCRIPT_PRINT_USAGE)
+    MESSAGE("cmake-fedora utility scripts
+
+cmake -D cmd=configure_file 
+      -D inputFile=<inputFile> -D outputFile=<outputFile>
+      [-D atOnly=1]
+      [-D cmake_fedora_module_dir=<dir>]
+      [-D escape_quotes=1]
+      [\"-D <VAR>=<VAULE>\"]
+    -P <CmakeModulePath>/CmakeFedoraScript.cmake
+  Copy a file to another location and modify its contents.
+  This is a wrapper of CONFIGURE_FILE command in cmake.
+
+  Note: Please pass the necessary variables via -Dvar=VALUE,
+    e.g. -DPROJECT_NAME=cmake-fedora
+  Options:
+    inputFile: input file
+    outPutFile: output file
+    atOnly: Replace only the variables surround by '@', like @VAR@.
+      Same as passing '@ONLY' to CONFIGURE_FILE.
+    cmake_fedora_module_dir:
+      Specify this if cmake and cmake-fedora failed to find 
+      the location of CMake Fedora modules. 
+    escape_quotes: Substituted quotes will be C-style escape.
+      Same as passing 'ESCAPE_QUOTES' to CONFIGURE_FILE.
+    
+cmake -D cmd=find_file|find_program -D \"names=<name1;name2>\"
+      [-D cmake_fedora_module_dir=<dir>]
+      [-D paths=\"<path1>;<path2>\"]
+      [-D error_msg=<msg>]
+      [-D verbose_level=<verboseLevel>]
+      [-D no_default_path=1]
+    -P <CmakeModulePath>/CmakeFedoraScript.cmake
+  Find a file or program with name1 or name2, 
+    with proper error handling.
+  Options:
+    cmake_fedora_module_dir:
+      Specify this if cmake and cmake-fedora failed to find 
+      the location of CMake Fedora modules. 
+    paths: Paths that files might be located.
+    error_msg: Error message to be shown if not-found.
+    verbose_level: Verbose level for not-found message.
+      1: Critical (The 'not found' message is shown as critical)
+      2: Error (The 'not found' message is shown as error)
+      3: Warning (The 'not found' message is shown as warning)
+      4: Off (The 'not found' message is shown as off, 
+         that is, turn off certain functionality).
+      5: Info1
+      6: Info2
+      7: Info3
+      Default: 3 (Warning)
+    no_default_path: CMake default paths will not be search.
+      Useful if you only want to search the file list in -Dpaths.
+	   
+cmake -D cmd=manage_file_cache -D \"run=<command arg1 ...>\"
+      -D cache_file=<cacheFileWithoutDirectory>
+      [-D cmake_fedora_module_dir=<dir>]
+      [-D expiry_seconds=seconds]
+      [-D cache_dir=dir]
+    -P <CmakeModulePath>/CmakeFedoraScript.cmake
+  Output from either cache file or run command.
+  Command is run when 1) cache expired or 2) no cache.
+  Cache will be update after run command.
+  Options:
+    run=<command arg1 ...>: The command that provide output.
+    cache_file=<file>: The path to cache file.
+    cmake_fedora_module_dir=<dir>:
+      Specify this if cmake and cmake-fedora failed to find 
+      the location of CMake Fedora modules. 
+    expiry_seconds=<seconds>: After <seconds> the cache should expired.
+    cache_dir=<dir>: The directory to put cache.
+
+
+cmake -D cmd=get_variable -Dvar=<varName>
+      [-D noescape_semicolon=1]
+    -P <CmakeModulePath>/CmakeFedoraScript.cmake
+  Get variable value from cmake-fedora.conf.
+  Options:
+    noescape_semicolon=1: Do not escape semicolon, 
+    so ';' split strings can be interpreted as list.
+
+")
+ENDMACRO(CMAKE_FEDORA_SCRIPT_PRINT_USAGE)
+
+FUNCTION(CONFIGURE_FILE_SCRIPT)
+    IF(NOT inputFile)
+	CMAKE_FEDORA_SCRIPT_PRINT_USAGE()
+	M_MSG(${M_FATAL} "Requires -DinputFile=<file>")
+    ENDIF()
+    IF(NOT EXISTS "${inputFile}")
+	M_MSG(${M_FATAL} "Input file not exists: ${inputFile}")
+    ENDIF()
+    IF(NOT outputFile)
+	CMAKE_FEDORA_SCRIPT_PRINT_USAGE()
+	M_MSG(${M_FATAL} "Requires -DoutputFile=<file>")
+    ENDIF()
+    SET(_opts)
+    IF(escape_quotes)
+	LIST(APPEND _opts "ESCAPE_QUOTES")
+    ENDIF()
+    IF(at_only)
+	LIST(APPEND _opts "@ONLY")
+    ENDIF()
+
+    CONFIGURE_FILE("${inputFile}" "${outputFile}" ${_opts})
+ENDFUNCTION(CONFIGURE_FILE_SCRIPT)
+
+MACRO(FIND_FILE_OR_PROGRAM)
+    SET(_args "")
+    IF(error_msg)
+	LIST(APPEND _args "ERROR_MSG" "${error_msg}")
+    ENDIF()
+
+    SET(_verboseLevel "${M_WARN}")
+    IF(DEFINED verbose_level)
+	SET(_verboseLevel "${verbose_level}")
+    ENDIF()
+    LIST(APPEND _args "VERBOSE_LEVEL" "${_verboseLevel}")
+
+    IF(DEFINED no_default_path)
+	LIST(APPEND _args "NO_DEFAULT_PATH")
+    ENDIF()
+
+    LIST(APPEND _args "FIND_ARGS" "NAMES" "${names}")
+
+    IF(paths)
+	LIST(APPEND _args "PATHS" "${paths}")
+    ENDIF()
+
+    IF(cmd STREQUAL "find_file")
+	FIND_FILE_ERROR_HANDLING(_var ${_args})
+    ELSEIF(cmd STREQUAL "find_program")
+	FIND_PROGRAM_ERROR_HANDLING(_var ${_args})
+    ENDIF()
+    IF(_var STREQUAL "_var-NOTFOUND")
+	M_MSG(${_verboseLevel} "${cmd}: '${names}' not found!")
+    ELSE()
+	M_OUT("${_var}")
+    ENDIF()
+    UNSET(_verboseLevel CACHE)
+ENDMACRO(FIND_FILE_OR_PROGRAM)
+
+FUNCTION(MANAGE_FILE_CACHE_SCRIPT)
+    IF(NOT run)
+	CMAKE_FEDORA_SCRIPT_PRINT_USAGE()
+	M_MSG(${M_FATAL} "Requires -Drun=<executable>")
+    ENDIF()
+    IF(NOT cache_file)
+	CMAKE_FEDORA_SCRIPT_PRINT_USAGE()
+	M_MSG(${M_FATAL} "Requires -Dcache_file=<filenameWithoutDir>")
+    ENDIF()
+
+    SET(_opts "")
+    IF(expiry_seconds)
+	LIST(APPEND _opts EXPIRY_SECONDS "${expiry_seconds}")
+    ENDIF()
+
+    IF(cache_dir) 
+	LIST(APPEND _opts CACHE_DIR "${cache_dir}")
+    ENDIF() 
+
+    MANAGE_FILE_CACHE(v ${cache_file} ${_opts} COMMAND sh -c "${run}")
+    M_OUT("${v}")
+ENDFUNCTION(MANAGE_FILE_CACHE_SCRIPT)
+
+FUNCTION(CMAKE_FEDORA_GET_VARIABLE_SCRIPT)
+    IF(NOT var)
+	CMAKE_FEDORA_SCRIPT_PRINT_USAGE()
+	M_MSG(${M_FATAL} "Requires -Dvar=<variable>")
+    ENDIF(NOT var)
+    SET(opts)
+    IF(noescape_semicolon)
+	LIST(APPEND opts "NOESCAPE_SEMICOLON")
+    ENDIF()
+    CMAKE_FEDORA_CONF_GET_ALL_VARIABLES(${opts})
+    M_OUT("${${var}}")
+ENDFUNCTION(CMAKE_FEDORA_GET_VARIABLE_SCRIPT)
+
+#######################################
+# Init
+#
+SET(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS ON)
+
+##== Determine CMAKE_FEDORA_MODULE_DIR ==
+## It is possible that current dir is in NO_PACK/FedPkg/<prj>
+LIST(INSERT CMAKE_MODULE_PATH 0
+    ${CMAKE_SOURCE_DIR}/Modules ${CMAKE_SOURCE_DIR}/cmake-fedora/Modules 
+    ${CMAKE_SOURCE_DIR}/../../../Modules
+    ${CMAKE_SOURCE_DIR}/../../../cmake-fedora/Modules
+    ${CMAKE_SOURCE_DIR}
+    )
+
+IF(CMAKE_SCRIPT_MODE_FILE)
+    GET_FILENAME_COMPONENT(CMAKE_FEDORA_SCRIPT_DIR ${CMAKE_SCRIPT_MODE_FILE}
+	PATH)
+    LIST(INSERT CMAKE_MODULE_PATH 0 "${CMAKE_FEDORA_SCRIPT_DIR}")
+ENDIF()
+
+IF(cmake_fedora_module_dir)
+    LIST(INSERT CMAKE_MODULE_PATH 0 "${cmake_fedora_module_dir}")
+ENDIF()
+
+##== Policies ==
+IF(POLICY CMP0017)
+    CMAKE_POLICY(SET CMP0017 NEW)
+ENDIF()
+ 
+##== Module Includes ==
+INCLUDE(ManageMessage RESULT_VARIABLE MANAGE_MODULE_PATH)
+IF(NOT MANAGE_MODULE_PATH)
+    MESSAGE(FATAL_ERROR "ManageMessage.cmake cannot be found in ${CMAKE_MODULE_PATH}")
+ENDIF()
+INCLUDE(ManageFile)
+
+#######################################
+# Parse Arguments and Run
+#
+IF(NOT DEFINED cmd)
+    CMAKE_FEDORA_SCRIPT_PRINT_USAGE()
+ELSEIF(cmd STREQUAL "find_file" OR cmd STREQUAL "find_program")
+    IF(NOT names)
+	CMAKE_FEDORA_SCRIPT_PRINT_USAGE()
+	M_MSG(${M_FATAL} "Requires -Dnames=\"<name1;name2>\"")
+    ENDIF(NOT names)
+    FIND_FILE_OR_PROGRAM()
+ELSEIF(cmd STREQUAL "configure_file")
+    CONFIGURE_FILE_SCRIPT()
+ELSEIF(cmd STREQUAL "manage_file_cache")
+    MANAGE_FILE_CACHE_SCRIPT()
+ELSEIF(cmd STREQUAL "get_variable")
+    CMAKE_FEDORA_GET_VARIABLE_SCRIPT()
+ELSE()
+    CMAKE_FEDORA_SCRIPT_PRINT_USAGE()
+    M_MSG(${M_FATAL} "Invalid cmd ${cmd}")
+ENDIF()
+
diff -Nura ibus-chewing-1.6.1/Modules/CMakeLists.txt ibus-chewing-1.6.1_new/Modules/CMakeLists.txt
--- ibus-chewing-1.6.1/Modules/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ ibus-chewing-1.6.1_new/Modules/CMakeLists.txt	2015-12-17 17:43:31.000000000 +0800
@@ -0,0 +1,10 @@
+FILE(GLOB CMAKE_FEDORA_MODULES RELATIVE "${CMAKE_CURRENT_SOURCE_DIR}" "[A-Z]*.cmake")
+
+## Remove Generated Modules
+LIST(REMOVE_ITEM CMAKE_FEDORA_MODULES "CTestTestfile.cmake")
+
+LIST(APPEND CMAKE_FEDORA_MODULES cmake_uninstall.cmake.in)
+INSTALL(FILES ${CMAKE_FEDORA_MODULES} 
+    DESTINATION ${DATA_DIR}/cmake/Modules
+    )
+
diff -Nura ibus-chewing-1.6.1/Modules/cmake_uninstall.cmake.in ibus-chewing-1.6.1_new/Modules/cmake_uninstall.cmake.in
--- ibus-chewing-1.6.1/Modules/cmake_uninstall.cmake.in	1970-01-01 08:00:00.000000000 +0800
+++ ibus-chewing-1.6.1_new/Modules/cmake_uninstall.cmake.in	2014-10-28 13:05:31.000000000 +0800
@@ -0,0 +1,21 @@
+IF(NOT EXISTS "@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt")
+  MESSAGE(FATAL_ERROR "Cannot find install manifest: \"@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt\"")
+ENDIF(NOT EXISTS "@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt")
+
+FILE(READ "@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt" files)
+STRING(REGEX REPLACE "\n" ";" files "${files}")
+FOREACH(file ${files})
+  MESSAGE(STATUS "Uninstalling \"$ENV{DESTDIR}${file}\"")
+  IF(EXISTS "$ENV{DESTDIR}${file}")
+    EXEC_PROGRAM(
+      "@CMAKE_COMMAND@" ARGS "-E remove \"$ENV{DESTDIR}${file}\""
+      OUTPUT_VARIABLE rm_out
+      RETURN_VALUE rm_retval
+      )
+    IF(NOT "${rm_retval}" STREQUAL 0)
+      MESSAGE(FATAL_ERROR "Problem when removing \"$ENV{DESTDIR}${file}\"")
+    ENDIF(NOT "${rm_retval}" STREQUAL 0)
+  ELSE(EXISTS "$ENV{DESTDIR}${file}")
+    MESSAGE(STATUS "File \"$ENV{DESTDIR}${file}\" does not exist.")
+  ENDIF(EXISTS "$ENV{DESTDIR}${file}")
+ENDFOREACH(file)
diff -Nura ibus-chewing-1.6.1/Modules/DateTimeFormat.cmake ibus-chewing-1.6.1_new/Modules/DateTimeFormat.cmake
--- ibus-chewing-1.6.1/Modules/DateTimeFormat.cmake	1970-01-01 08:00:00.000000000 +0800
+++ ibus-chewing-1.6.1_new/Modules/DateTimeFormat.cmake	2014-10-28 13:05:31.000000000 +0800
@@ -0,0 +1,38 @@
+# - Date/time format module.
+#
+# Define the following variables:
+#   - TODAY_CHANGELOG: Today in the format that is used in RPM Changelog.
+#      e.g. Wed 08 Aug 2010
+#   - TODAY_SHORT: Short presentation of today, e.g. 20100818.
+#
+# Defines the following macros:
+#    TODAY(<date_var> <format> [<locale>])
+#      - Get date of today in specified format and locale.
+#        * Parameters:
+#     	   + date_var: Result date string
+#          + format: date format for date(1)
+#          + locale: locale of the string.
+#            Use current locale setting if locale is not given.
+#
+#
+
+IF(DEFINED _DATE_TIME_FORMAT_CMAKE_)
+    RETURN()
+ENDIF(DEFINED _DATE_TIME_FORMAT_CMAKE_)
+SET(_DATE_TIME_FORMAT_CMAKE_ "DEFINED")
+
+FUNCTION(TODAY date_var format)
+    SET(_locale ${ARGV2})
+    IF(_locale)
+	SET(ENV{LC_ALL} ${_locale})
+    ENDIF(_locale)
+    EXECUTE_PROCESS(COMMAND date -u "${format}"
+	OUTPUT_VARIABLE _ret
+	OUTPUT_STRIP_TRAILING_WHITESPACE
+	)
+    SET(${date_var} "${_ret}" PARENT_SCOPE)
+ENDFUNCTION(TODAY date_var format)
+
+TODAY(TODAY_CHANGELOG "+%a %b %d %Y" "C")
+TODAY(TODAY_SHORT "+%Y%m%d" "C")
+
diff -Nura ibus-chewing-1.6.1/Modules/ManageAPIDoc.cmake ibus-chewing-1.6.1_new/Modules/ManageAPIDoc.cmake
--- ibus-chewing-1.6.1/Modules/ManageAPIDoc.cmake	1970-01-01 08:00:00.000000000 +0800
+++ ibus-chewing-1.6.1_new/Modules/ManageAPIDoc.cmake	2014-10-28 13:05:31.000000000 +0800
@@ -0,0 +1,120 @@
+# - Manage generated API documents
+# This module provide functions for API document generation.
+#
+# Included Modules:
+#   - ManageDependency
+#   - ManageMessage
+# 
+# Defines following functions:
+#   MANAGE_APIDOC_DOXYGEN([DOXYGEN <Doxyfile>]
+#     [OUTPUT_DIRECTORY <dir>] ...
+#     )
+#     - Provide Doxygen processing and targets.
+#       DOXYGEN options can also be provided here.
+#       For example:
+#         MANAGE_APIDOC_DOXYGEN(DOXYGEN Doxyfile
+#           OUTPUT_DIRECTORY doc
+#           CREATE_SUBDIR no
+#           )
+#       Will write the configure file to Doxyfile, generate documents
+#       will be put in doc/, and CREATE_SUBDIR is set as "no".
+#
+#       * Parameters:
+#         + DOXYGEN Doxyfile: Doxygen file.
+#           Default: ${CMAKE_BINARY_DIR}/Doxygn
+#         + OUTPUT_DIRECTORYCREATE_SUBDIR dir: Directory for generated
+#           documents.
+#         + ... : Other Doxygen options.
+#         + docSrcdir: Document source directory to be copied from.
+#       * Targets:
+#         + doxygen: Make doxygen documents.
+#         + doxygen_update_doxyfile: Update Doxyfile.
+#           Doxyfile configuration options such as PROJECT_NUMBER will be
+#           updated according to project information.
+#       * Reads following variable:
+#         + PRJ_DOC_DIR: Directory for installed documents.
+#           Default: /usr/share/doc/${PROJECT_NAME}
+#
+IF(DEFINED _MANAGE_APIDOC_CMAKE_)
+    RETURN()
+ENDIF(DEFINED _MANAGE_APIDOC_CMAKE_)
+SET(_MANAGE_APIDOC_CMAKE_ "DEFINED")
+INCLUDE(ManageMessage)
+INCLUDE(ManageDependency)
+
+FUNCTION(MANAGE_APIDOC_DOXYGEN_ADD_OPTION doxyfile listVar key value)
+    LIST(APPEND ${listVar}
+	"COMMAND" "sed" "-i" "-e"
+	's|^${key}\\s*=.*|${key}="${value}"|' "${doxyfile}"
+	)
+    SET(${listVar} "${${listVar}}" PARENT_SCOPE)
+ENDFUNCTION(MANAGE_APIDOC_DOXYGEN_ADD_OPTION)
+
+FUNCTION(MANAGE_APIDOC_DOXYGEN)
+    LIST(APPEND SOURCE_ARCHIVE_IGNORE_FILES "/Doxyfile$")
+    SET(_manage_apidoc_doxygen_dependency_missing 0)
+    MANAGE_DEPENDENCY(BUILD_REQUIRES DOXYGEN PROGRAM_NAMES "doxygen")
+    IF(NOT DEFINED DOXYGEN_FOUND)
+	RETURN()
+    ENDIF(NOT DEFINED DOXYGEN_FOUND)
+    IF("${PRJ_DOC_DIR}" STREQUAL "")
+	SET(PRJ_DOC_DIR "/usr/share/doc/${PROJECT_NAME}"
+	    CACHE PATH "Project document dir"
+	    )
+    ENDIF("${PRJ_DOC_DIR}" STREQUAL "")
+    M_MSG(${M_INFO2} "PRJ_DOC_DIR=${PRJ_DOC_DIR}")
+
+    SET(_stage "key")
+    SET(_key "")
+    SET(_doxygenOptList "")
+    FOREACH(_arg ${ARGN})
+	IF(_stage STREQUAL "key")
+	    SET(_key "${_arg}")
+	    SET(_stage "value")
+	ELSE(_stage STREQUAL "key")
+	    SET(_opt_${_key} "${_arg}")
+	    IF(NOT "${_key}" STREQUAL "DOXYGEN")
+		MANAGE_APIDOC_DOXYGEN_ADD_OPTION("${_opt_DOXYGEN}"
+		    _doxygenOptList "${_key}" "${_arg}"
+		    )
+	    ENDIF(NOT "${_key}" STREQUAL "DOXYGEN")
+	    SET(_stage "key")
+	ENDIF(_stage STREQUAL "key")
+    ENDFOREACH(_arg)
+
+    IF("${_opt_DOXYGEN}" STREQUAL "")
+	SET(_opt_DOXYGEN "${CMAKE_BINARY_DIR}/Doxyfile")
+    ENDIF("${_opt_DOXYGEN}" STREQUAL "")
+
+    IF("${_opt_OUTPUT_DIRECTORY}" STREQUAL "")
+	SET(_opt_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/doc")
+    ENDIF("${_opt_OUTPUT_DIRECTORY}" STREQUAL "")
+
+    ADD_CUSTOM_TARGET(doxygen
+	COMMAND "${DOXYGEN_EXECUTABLE}" "${opt_DOXYGEN}"
+	DEPENDS ${_opt_DOXYGEN}
+	COMMENT "doxygen: ${opt_DOXYGEN}"
+	)
+
+    MANAGE_APIDOC_DOXYGEN_ADD_OPTION("${_opt_DOXYGEN}"
+	_doxygenOptList "PROJECT_NAME" "${PROJECT_NAME}"
+	)
+    MANAGE_APIDOC_DOXYGEN_ADD_OPTION("${_opt_DOXYGEN}"
+	_doxygenOptList "PROJECT_NUMBER" "${PRJ_VER}"
+	)
+    MANAGE_APIDOC_DOXYGEN_ADD_OPTION("${_opt_DOXYGEN}"
+	_doxygenOptList "PROJECT_BRIEF" "${PRJ_SUMMARY}"
+	)
+
+    ADD_CUSTOM_TARGET_COMMAND(doxygen_update_doxyfile
+	OUTPUT "${_opt_DOXYGEN}"
+	COMMAND "${DOXYGEN_EXECUTABLE}" -g "${_opt_DOXYGEN}"
+	${_doxygenOptList}
+	COMMENT "doxygen_update_doxyfile: ${_opt_DOXYGEN}"
+	)
+
+    INSTALL(DIRECTORY ${_opt_OUTPUT_DIRECTORY}
+	DESTINATION "${PRJ_DOC_DIR}"
+	)
+ENDFUNCTION(MANAGE_APIDOC_DOXYGEN doxygen_template)
+
diff -Nura ibus-chewing-1.6.1/Modules/ManageArchive.cmake ibus-chewing-1.6.1_new/Modules/ManageArchive.cmake
--- ibus-chewing-1.6.1/Modules/ManageArchive.cmake	1970-01-01 08:00:00.000000000 +0800
+++ ibus-chewing-1.6.1_new/Modules/ManageArchive.cmake	2016-01-07 15:39:34.000000000 +0800
@@ -0,0 +1,341 @@
+# - Manage Source Archive and track its content.
+# This module manages source archive by:
+#  - Handle the ChangeLog
+#  - Build the source archive
+#  - Exclude unwanted files, either from ignore files of source version
+#    control, or add them to SOURCE_ARCHIVE_IGNORE_FILES
+#  - Track the contents in source archive, when it updates, the source 
+#    Archive should be updated.
+#
+# This module provide a convenient wrapper of CPack. 
+# CPack itself, by default, pack everything under the source directory,
+# this is usually undesirable. 
+# We avoid this by using the sane default ignore list.
+#
+# Included Modules:
+#   - ManageFile
+#   - ManageTarget
+#   - ManageVersion
+#   - CPack
+#
+# Targets:
+#   - pack_src_pre: Target that depends on other targets that need to be made
+#       before pack_src.
+#
+# Defines following functions:
+#   SOURCE_ARCHIVE_CONTENTS_ADD(<filename>)
+#   - Add a file to source archive if the file is not in the archive.
+#     * Parameters:
+#       - filename: Filename to be added.
+#
+#   SOURCE_ARCHIVE_CONTENTS_ADD_NO_CHECK(<filename>)
+#   - Add a file to source archive without check.
+#     * Parameters:
+#       - filename: Filename to be added.
+#
+# Defines following macros:
+#   PACK_SOURCE_ARCHIVE([<outputDir> | OUTPUT_FILE <file>] 
+#     [GENERATOR <cpackGenerator>] 
+#     [GITIGNORE <gitignoreFile>] [INCLUDE <file ...>])
+#     )
+#     - Pack source archive..
+#       * Parameters:
+#         + outputDir: Directory to write source archive.
+#         + OUTPUT_FILE file: Output file with path.
+#           Default: SOURCES/<projectName>-<PRJ_VER>-Source.<packFormat>
+#         + GENERATOR cpackGenerator: The CPack generator
+#           Default: TGZ (.tar.gz) 
+#         + GITIGNORE gitignoreFile: Specify path to .gitignore for using .gitignore
+#             to exclude the unwanted files.
+#         + INCLUDE file ...: Add back those files to source archive.
+#             You can add back the files that would otherwise be excluded,
+#             e.g. .pot files.
+#             otherwise those will be excluded.
+#       * Variables to be cached:
+#         + SOURCE_ARCHIVE_CONTENTS: List of files to be packed.
+#         + SOURCE_ARCHIVE_FILE: Path of source archive (with path).
+#         + SOURCE_ARCHIVE_FILE_EXTENSION: File extension of 
+#             the source package
+#         + SOURCE_ARCHIVE_IGNORE_FILES: List of files to be 
+#             ignored to archive.
+#         + SOURCE_ARCHIVE_NAME: Name of source archive (without path).
+#       * Targets:
+#         + pack_src: Always pack source files in OUTPUT_FILE
+#         + pack_src_no_force: Only pack source files in OUTPUT_FILE when necessary.
+#         + dist: Alias of pack_src_no_force
+#         + clean_pack_src: Remove all source archives.
+#         + clean_old_pack_src: Remove all old source package.
+#
+#
+IF(DEFINED _MANAGE_ARCHIVE_CMAKE_)
+    RETURN()
+ENDIF(DEFINED _MANAGE_ARCHIVE_CMAKE_)
+SET (_MANAGE_ARCHIVE_CMAKE_ "DEFINED")
+
+SET(SOURCE_ARCHIVE_IGNORE_FILES_COMMON
+    "/\\\\.svn/"  "/CVS/" "/\\\\.git/" "/\\\\.hg/" "NO_PACK")
+
+SET(SOURCE_ARCHIVE_IGNORE_FILES_CMAKE 
+    "/CMakeFiles/" "_CPack_Packages/" "/Testing/"
+    "\\\\.directory$" "CMakeCache\\\\.txt$"
+    "/install_manifest.txt$"
+    "/cmake_install\\\\.cmake$" "/cmake_uninstall\\\\.cmake$"
+    "/CPack.*\\\\.cmake$" "/CTestTestfile\\\\.cmake$"
+    "Makefile$" "/${PROJECT_NAME}-${PRJ_VER}-SOURCE/"
+    )
+SET(SOURCE_ARCHIVE_IGNORE_FILES 
+    ${SOURCE_ARCHIVE_IGNORE_FILES_CMAKE}
+    ${SOURCE_ARCHIVE_IGNORE_FILES_COMMON}
+    )
+
+INCLUDE(ManageVersion)
+INCLUDE(ManageFile)
+
+ADD_CUSTOM_TARGET(pack_src_pre
+    COMMENT "pack_src_pre: Before pack_src"
+    )
+
+FUNCTION(SOURCE_ARCHIVE_CONTENTS_SET value)
+    SET(SOURCE_ARCHIVE_CONTENTS "${value}" CACHE INTERNAL "Source archive file list")
+ENDFUNCTION(SOURCE_ARCHIVE_CONTENTS_SET)
+SOURCE_ARCHIVE_CONTENTS_SET("")
+
+## Add whatever it's told
+FUNCTION(SOURCE_ARCHIVE_CONTENTS_ADD_FAST value)
+    LIST(APPEND SOURCE_ARCHIVE_CONTENTS "${value}")
+    SOURCE_ARCHIVE_CONTENTS_SET("${SOURCE_ARCHIVE_CONTENTS}")
+ENDFUNCTION(SOURCE_ARCHIVE_CONTENTS_ADD_FAST)
+
+FUNCTION(SOURCE_ARCHIVE_CONTENTS_ADD)
+    FOREACH(filename ${ARGN})
+	GET_FILENAME_COMPONENT(_file "${filename}" ABSOLUTE)
+	FILE(RELATIVE_PATH _f ${CMAKE_SOURCE_DIR} "${_file}")
+	LIST(FIND SOURCE_ARCHIVE_CONTENTS "${_f}" _index)
+	IF(_index LESS 0)
+	    SOURCE_ARCHIVE_CONTENTS_ADD_FAST("${_f}")
+	ENDIF(_index LESS 0)
+    ENDFOREACH(filename)
+ENDFUNCTION(SOURCE_ARCHIVE_CONTENTS_ADD)
+
+FUNCTION(SOURCE_ARCHIVE_CONTENTS_ADD_NO_CHECK)
+    FOREACH(filename ${ARGN})
+	GET_FILENAME_COMPONENT(_file "${filename}" ABSOLUTE)
+	FILE(RELATIVE_PATH _f ${CMAKE_SOURCE_DIR} "${_file}")
+	SOURCE_ARCHIVE_CONTENTS_ADD_FAST("${_f}")
+    ENDFOREACH(filename)
+ENDFUNCTION(SOURCE_ARCHIVE_CONTENTS_ADD_NO_CHECK)
+
+# Internal:  SOURCE_ARCHIVE_GET_CONTENTS()
+#   - Return all source file to be packed.
+#     This is called by SOURCE_ARCHIVE(),
+#     So no need to call it again.
+FUNCTION(SOURCE_ARCHIVE_GET_CONTENTS )
+    SET(_fileList "")
+    FILE(GLOB_RECURSE _ls FOLLOW_SYMLINKS "*" )
+    STRING(REPLACE "\\\\" "\\" _ignore_files
+        "${SOURCE_ARCHIVE_IGNORE_FILES}")
+
+    FOREACH(_file ${_ls})
+	SET(_matched 0)
+	FOREACH(filePattern ${_ignore_files})
+	    M_MSG(${M_INFO3} "_file=${_file} filePattern=${filePattern}")
+
+	    IF(_file MATCHES "${filePattern}")
+		SET(_matched 1)
+		BREAK()
+	    ENDIF(_file MATCHES "${filePattern}")
+	ENDFOREACH(filePattern ${_ignore_files})
+	IF(NOT _matched)
+	    SOURCE_ARCHIVE_CONTENTS_ADD_NO_CHECK("${_file}")
+	ENDIF(NOT _matched)
+    ENDFOREACH(_file ${_ls})
+    M_MSG(${M_INFO2} "SOURCE_ARCHIVE_CONTENTS=${SOURCE_ARCHIVE_CONTENTS}")
+ENDFUNCTION(SOURCE_ARCHIVE_GET_CONTENTS)
+
+MACRO(CMAKE_REGEX_TO_REGEX var cmrgx)
+    STRING(REPLACE "\\\\" "\\" ${var} "${cmrgx}")
+ENDMACRO(CMAKE_REGEX_TO_REGEX var cmrgx)
+
+MACRO(SOURCE_ARCHIVE_GET_IGNORE_LIST _ignoreListVar _includeListVar)
+    IF(${_ignoreListVar})
+	FILE(STRINGS "${${_ignoreListVar}}" _content REGEX "^[^#]")
+	FOREACH(_s ${_content})
+	    STRING(STRIP "${_s}" _s)
+	    STRING(LENGTH "${_s}" _l)
+	    IF(_l GREATER 0)
+		## Covert the string from glob to cmake regex
+		GIT_GLOB_TO_CMAKE_REGEX(_cmrgx ${_s})
+		LIST(APPEND SOURCE_ARCHIVE_IGNORE_FILES "${_cmrgx}")
+	    ENDIF(_l GREATER 0)
+	ENDFOREACH(_s ${_content})
+    ENDIF(${_ignoreListVar})
+
+    ## regex match one of include files
+    ## then remove that line
+    FOREACH(_ignore_pattern ${SOURCE_ARCHIVE_IGNORE_FILES})
+	CMAKE_REGEX_TO_REGEX(_ip "${_ignore_pattern}")
+	FOREACH(_i ${${_includeListVar}})
+	    STRING(REGEX MATCH "${_ip}" _ret "${_i}")
+	    IF(_ret)
+		LIST(REMOVE_ITEM SOURCE_ARCHIVE_IGNORE_FILES "${_ignore_pattern}")
+	    ENDIF(_ret)
+	ENDFOREACH(_i ${${_includeListVar}})
+    ENDFOREACH(_ignore_pattern ${SOURCE_ARCHIVE_IGNORE_FILES})
+ENDMACRO(SOURCE_ARCHIVE_GET_IGNORE_LIST _ignoreListVar _includeListVar)
+
+MACRO(PACK_SOURCE_CPACK var)
+    SET(_valid_options "GENERATOR" "INCLUDE" "GITIGNORE")
+    VARIABLE_PARSE_ARGN(_opt _valid_options ${ARGN})
+    IF(NOT _opt_GENERATOR)
+	SET(_opt_GENERATOR "TGZ")
+    ENDIF(NOT _opt_GENERATOR)
+    SET(CPACK_GENERATOR "${_opt_GENERATOR}")
+    SET(CPACK_SOURCE_GENERATOR ${CPACK_GENERATOR})
+    IF(${CPACK_GENERATOR} STREQUAL "TGZ")
+	SET(SOURCE_ARCHIVE_FILE_EXTENSION "tar.gz")
+    ELSEIF(${CPACK_GENERATOR} STREQUAL "TBZ2")
+	SET(SOURCE_ARCHIVE_FILE_EXTENSION "tar.bz2")
+    ELSEIF(${CPACK_GENERATOR} STREQUAL "ZIP")
+	SET(SOURCE_ARCHIVE_FILE_EXTENSION "zip")
+    ENDIF(${CPACK_GENERATOR} STREQUAL "TGZ")
+    SET(CPACK_PACKAGE_VERSION ${PRJ_VER})
+    IF(PRJ_SUMMARY)
+	SET(CPACK_PACKAGE_DESCRIPTION_SUMMARY "${PRJ_SUMMARY}")
+    ENDIF(PRJ_SUMMARY)
+    IF(EXISTS ${CMAKE_SOURCE_DIR}/COPYING)
+	SET(CPACK_RESOURCE_FILE_LICENSE ${CMAKE_SOURCE_DIR}/COPYING)
+    ENDIF(EXISTS ${CMAKE_SOURCE_DIR}/COPYING)
+
+    IF(EXISTS ${CMAKE_SOURCE_DIR}/README)
+	SET(CPACK_PACKAGE_DESCRIPTION_FILE ${CMAKE_SOURCE_DIR}/README)
+    ENDIF(EXISTS ${CMAKE_SOURCE_DIR}/README)
+    SET(CPACK_PACKAGE_VENDOR "${VENDOR}")
+
+    SET(CPACK_SOURCE_PACKAGE_FILE_NAME "${PROJECT_NAME}-${PRJ_VER}-Source")
+    LIST(APPEND SOURCE_ARCHIVE_IGNORE_FILES "${PROJECT_NAME}-[^/]*-Source")
+    SET(SOURCE_ARCHIVE_NAME 
+	"${CPACK_SOURCE_PACKAGE_FILE_NAME}.${SOURCE_ARCHIVE_FILE_EXTENSION}" 
+	CACHE STRING "Source archive name" FORCE
+	)
+    SET(${var} "${SOURCE_ARCHIVE_NAME}")
+
+    SOURCE_ARCHIVE_GET_IGNORE_LIST(_opt_GITIGNORE _opt_INCLUDE)
+    LIST(APPEND CPACK_SOURCE_IGNORE_FILES ${SOURCE_ARCHIVE_IGNORE_FILES})
+    INCLUDE(CPack)
+ENDMACRO(PACK_SOURCE_CPACK var)
+
+MACRO(PACK_SOURCE_ARCHIVE)
+    SET(_valid_options "OUTPUT_FILE" "GENERATOR" "INCLUDE" "GITIGNORE")
+    VARIABLE_PARSE_ARGN(_opt _valid_options ${ARGN})
+    IF(PRJ_VER STREQUAL "")
+	M_MSG(${M_FATAL} "PRJ_VER not defined")
+    ENDIF(PRJ_VER STREQUAL "")
+
+    ## PACK_SOURCE_CPACK to pack with default output file
+    VARIABLE_TO_ARGN(_cpack_source_pack_opts _opt _valid_options)
+    PACK_SOURCE_CPACK(_source_archive_file
+	${_cpack_source_pack_opts})
+
+    ## Does user want his own output file or directory
+    SET(_own 0)
+    SET(_own_dir 0)
+    SET(_own_file 0)
+    IF(_opt)
+	SET(_outputDir "${_opt}")
+    ENDIF(_opt)
+    IF(_opt_OUTPUT_FILE)
+	GET_FILENAME_COMPONENT(_outputDir ${_opt_OUTPUT_FILE} PATH)
+	GET_FILENAME_COMPONENT(_outputFile ${_opt_OUTPUT_FILE} NAME)
+    ENDIF(_opt_OUTPUT_FILE)
+
+    GET_FILENAME_COMPONENT(_currentDir_real "${CMAKE_CURRENT_BINARY_DIR}" REALPATH)
+    IF(_outputDir)
+	GET_FILENAME_COMPONENT(_outputDir_real ${_outputDir} REALPATH)
+    ELSE(_outputDir)
+	SET(_outputDir_real ${_currentDir_real})
+    ENDIF(_outputDir)
+
+    IF(NOT _outputFile)
+	SET(_outputFile "${_source_archive_file}")
+    ENDIF(NOT _outputFile)
+
+    IF(NOT _outputDir_real STREQUAL "${_currentDir_real}")
+	SET(_own_dir 1)
+	SET(_own 1)
+    ENDIF(NOT _outputDir_real STREQUAL "${_currentDir_real}")
+    IF(NOT _outputFile STREQUAL "${_source_archive_file}")
+	SET(_own_file 1)
+	SET(_own 1)
+    ENDIF(NOT _outputFile STREQUAL "${_source_archive_file}")
+    GET_FILENAME_COMPONENT(SOURCE_ARCHIVE_FILE 
+	"${_outputDir_real}/${_outputFile}" ABSOLUTE)
+    SET(SOURCE_ARCHIVE_FILE ${SOURCE_ARCHIVE_FILE}
+	CACHE FILEPATH "Source archive file" FORCE)
+    SET(SOURCE_ARCHIVE_NAME "${_outputFile}" 
+	CACHE FILEPATH "Source archive name" FORCE)
+
+    SET(SOURCE_ARCHIVE_CONTENTS_ABSOLUTE "")
+    FOREACH(_file ${SOURCE_ARCHIVE_CONTENTS})
+	LIST(APPEND SOURCE_ARCHIVE_CONTENTS_ABSOLUTE
+	    "${CMAKE_HOME_DIRECTORY}/${_file}"
+	    )
+    ENDFOREACH(_file ${SOURCE_ARCHIVE_CONTENTS})
+
+    SET(_dep_list "${SOURCE_ARCHIVE_CONTENTS_ABSOLUTE}")
+    ## If own directory,
+    IF(_own_dir)
+	### Need to create it
+	ADD_CUSTOM_COMMAND(OUTPUT ${_outputDir_real}
+	    COMMAND ${CMAKE_COMMAND} -E make_directory ${_outputDir_real}
+	    COMMENT "Create dir for source archive output."
+	    )
+	LIST(APPEND _dep_list ${_outputDir_real})
+    ENDIF(_own_dir)
+
+    ## If own, need to move to it
+    SET(moveCommands "")
+
+    IF(_own)
+	SET(moveCommands 
+	    COMMAND ${CMAKE_COMMAND} -E copy "${_source_archive_file}" "${SOURCE_ARCHIVE_FILE}"
+	    COMMAND ${CMAKE_COMMAND} -E remove "${_source_archive_file}"
+	    )
+    ENDIF(_own)
+
+    INCLUDE(ManageTarget)
+    ADD_CUSTOM_TARGET_COMMAND(pack_src
+	NO_FORCE
+	OUTPUT ${SOURCE_ARCHIVE_FILE}
+	COMMAND make pack_src_pre
+	COMMAND make package_source
+	${moveCommands}
+	DEPENDS  ${_dep_list}
+	COMMENT "Packing the source as: ${SOURCE_ARCHIVE_FILE}"
+	VERBATIM
+	)
+
+    ADD_DEPENDENCIES(pack_src changelog)
+    ADD_DEPENDENCIES(pack_src_no_force changelog_no_force)
+
+    ADD_CUSTOM_TARGET(dist
+	)
+
+    ADD_DEPENDENCIES(dist pack_src_no_force)
+
+    ADD_CUSTOM_TARGET(clean_old_pack_src
+	COMMAND find .
+	-name '${PROJECT_NAME}*.${SOURCE_ARCHIVE_FILE_EXTENSION}' ! -name '${PROJECT_NAME}-${PRJ_VER}-*.${SOURCE_ARCHIVE_FILE_EXTENSION}'
+	-print -delete
+	COMMENT "Cleaning old source archives"
+	)
+
+    ADD_DEPENDENCIES(clean_old_pack_src changelog_no_force )
+
+    ADD_CUSTOM_TARGET(clean_pack_src
+	COMMAND find .
+	-name '${PROJECT_NAME}*.${SOURCE_ARCHIVE_FILE_EXTENSION}'
+	-print -delete
+	COMMENT "Cleaning all source archives"
+	)
+ENDMACRO(PACK_SOURCE_ARCHIVE)
+
diff -Nura ibus-chewing-1.6.1/Modules/ManageChangeLogScript.cmake ibus-chewing-1.6.1_new/Modules/ManageChangeLogScript.cmake
--- ibus-chewing-1.6.1/Modules/ManageChangeLogScript.cmake	1970-01-01 08:00:00.000000000 +0800
+++ ibus-chewing-1.6.1_new/Modules/ManageChangeLogScript.cmake	2016-01-07 15:39:34.000000000 +0800
@@ -0,0 +1,205 @@
+# - Manage ChangeLog
+#
+# Note that ChangeLog will be updated only when
+#
+# cmake -D cmd=update [Options] -P ManageChangeLogScript.cmake
+#
+# is run. This is triggered by:
+# 1. Target changelog
+# 2. Before source archive being built.
+#
+MACRO(MANAGE_CHANGELOG_SCRIPT_PRINT_USAGE)
+    MESSAGE("Manage ChangeLog script: This script is not recommend for end users.
+
+cmake -D cmd=make
+      -D changelog=<path/ChangeLog> 
+      -D release=<path/RELEASE-NOTES.txt>
+      -D prj_info=<path/prj_info.cmake>
+      [-D \"<var>=<value>\"]
+    -P <CmakeModulePath>/ManageChangeLogScript.cmake
+    Always update ChangeLog.
+
+cmake -D cmd=update 
+      -D changelog=<path/ChangeLog> 
+      -D release=<path/RELEASE-NOTES.txt>
+      -D prj_info=<path/prj_info.cmake>
+      -D cmakecache=<path/CMakeCache.txt>
+      [-D cmake_source_dir=<dir>]
+      [-D \"<var>=<value>\"]
+    -P <CmakeModulePath>/ManageChangeLogScript.cmake
+    This command updates ChangeLog only at one of following condition.
+    1) ChangeLog does not exists
+    2) RELEASE-NOTES.txt is newer than CMakeCache.txt
+    3) RELEASE-NOTES.txt is newer than ChangeLog
+
+cmake -D cmd=extract_current
+      -D release=<path/RELEASE-NOTES.txt>
+      [-D \"<var>=<value>\"]
+    -P <CmakeModulePath>/ManageChangeLogScript.cmake
+  Extract current Changelog items from RELEASE-NOTES.txt
+
+cmake -D cmd=extract_prev
+      -D ver=<ver>
+      -D changelog=<path/ChangeLog> 
+      [-D \"<var>=<value>\"]
+    -P <CmakeModulePath>/ManageChangeLogScript.cmake
+  Extract prev Changelog items from ChangeLog.
+
+"
+	)
+ENDMACRO()
+
+MACRO(EXTRACT_CURRENT_FROM_RELEASE strVar release)
+    IF("${release}" STREQUAL "")
+	MANAGE_CHANGELOG_SCRIPT_PRINT_USAGE()
+	M_MSG(${M_FATAL} "Requires \"-Drelease=RELEASE-NOTES.txt\"")
+    ENDIF()
+    IF(NOT EXISTS "${release}")
+	M_MSG(${M_FATAL} "File not found:${release}")
+    ENDIF()
+    RELEASE_NOTES_FILE_EXTRACT_CHANGELOG_CURRENT(${strVar} ${release})
+ENDMACRO()
+
+MACRO(EXTRACT_PREV_FROM_CHANGELOG strVar ver changeLogFile)
+    IF("${ver}" STREQUAL "")
+	MANAGE_CHANGELOG_SCRIPT_PRINT_USAGE()
+	M_MSG(${M_FATAL} "EXTRACT_PREV_FROM_CHANGELOG: Requires \"ver\"")
+    ENDIF()
+    IF("${changeLogFile}" STREQUAL "")
+	MANAGE_CHANGELOG_SCRIPT_PRINT_USAGE()
+	M_MSG(${M_FATAL} "Requires \"-Dchangelog=ChangeLog\"")
+    ENDIF()
+    IF(NOT EXISTS "${changeLogFile}")
+	M_MSG(${M_FATAL} "File not found:${changeLogFile}")
+    ENDIF()
+
+    SET(_this "")
+    SET(_prev "")
+    SET(_isThis 0)
+    SET(_isPrev 0)
+    EXECUTE_PROCESS(COMMAND cat "${changeLogFile}"
+	OUTPUT_VARIABLE _changeLogFileBuf
+	OUTPUT_STRIP_TRAILING_WHITESPACE)
+
+    STRING_SPLIT(_lines "\n" "${_changeLogFileBuf}" ALLOW_EMPTY)
+
+    ## List should not ingore empty elements 
+    CMAKE_POLICY(SET CMP0007 NEW)
+    LIST(LENGTH _lines _lineCount)
+    MATH(EXPR _lineCount ${_lineCount}-1)
+    FOREACH(_i RANGE ${_lineCount})
+	LIST(GET _lines ${_i} _line)
+	STRING(REGEX MATCH "^\\* [A-Za-z]+ [A-Za-z]+ [0-9]+ [0-9]+ .*<.+> - (.*)$" _match  "${_line}")
+	IF("${_match}" STREQUAL "")
+	    # Not a version line
+	    IF(_isThis)
+		STRING_APPEND(_this "${_line}" "\n")
+	    ELSEIF(_isPrev)
+		STRING_APPEND(_prev "${_line}" "\n")
+	    ELSE(_isThis)
+		M_MSG(${M_ERROR} "ChangeLog: Cannot distinguish version for line :${_line}")
+	    ENDIF(_isThis)
+	ELSE("${_match}" STREQUAL "")
+	    # Is a version line
+	    SET(_cV "${CMAKE_MATCH_1}")
+	    IF("${_cV}" STREQUAL "${ver}")
+		SET(_isThis 1)
+		SET(_isPrev 0)
+	    ELSE("${_cV}" STREQUAL "${ver}")
+		SET(_isThis 0)
+		SET(_isPrev 1)
+		STRING_APPEND(_prev "${_line}" "\n")
+	    ENDIF("${_cV}" STREQUAL "${ver}")
+	ENDIF("${_match}" STREQUAL "")
+    ENDFOREACH(_i RANGE _lineCount)
+    SET(${strVar} "${_prev}")
+ENDMACRO()
+
+MACRO(CHANGELOG_MAKE prj_info release changelog)
+    PRJ_INFO_CMAKE_READ("${prj_info}")
+
+    EXTRACT_CURRENT_FROM_RELEASE(currentStr "${release}")
+    IF(EXISTS "${changelog}")
+	EXTRACT_PREV_FROM_CHANGELOG(prevStr "${PRJ_VER}" "${changelog}")
+    ENDIF()
+    FILE(WRITE "${changelog}" "* ${TODAY_CHANGELOG} ${MAINTAINER} - ${PRJ_VER}\n")
+    FILE(APPEND "${changelog}" "${currentStr}\n\n")
+    FILE(APPEND "${changelog}" "${prevStr}")
+ENDMACRO()
+
+SET(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS ON)
+#######################################
+# Determine CMAKE_FEDORA_MODULE_DIR
+#
+
+## It is possible that current dir is in NO_PACK/FedPkg/<prj>
+LIST(INSERT CMAKE_MODULE_PATH 0
+    ${CMAKE_SOURCE_DIR}/Modules ${CMAKE_SOURCE_DIR}/cmake-fedora/Modules 
+    ${CMAKE_SOURCE_DIR}/../../../Modules
+    ${CMAKE_SOURCE_DIR}/../../../cmake-fedora/Modules
+    ${CMAKE_SOURCE_DIR}
+    )
+
+IF(CMAKE_SCRIPT_MODE_FILE)
+    GET_FILENAME_COMPONENT(CMAKE_FEDORA_SCRIPT_DIR ${CMAKE_SCRIPT_MODE_FILE}
+       PATH
+       )
+    LIST(INSERT CMAKE_MODULE_PATH 0 "${CMAKE_FEDORA_SCRIPT_DIR}")
+ENDIF()
+
+IF(cmake_fedora_module_dir)
+    LIST(INSERT CMAKE_MODULE_PATH 0 "${cmake_fedora_module_dir}")
+ENDIF()
+
+INCLUDE(ManageMessage RESULT_VARIABLE MANAGE_MODULE_PATH)
+IF(NOT MANAGE_MODULE_PATH)
+    MESSAGE(FATAL_ERROR "ManageMessage.cmake cannot be found in ${CMAKE_MODULE_PATH}")
+ENDIF()
+GET_FILENAME_COMPONENT(CMAKE_FEDORA_MODULE_DIR 
+    "${MANAGE_MODULE_PATH}" PATH)
+
+INCLUDE(ManageEnvironmentCommon)
+INCLUDE(DateTimeFormat)
+INCLUDE(ManageVersion)
+IF(NOT DEFINED cmd)
+    MANAGE_CHANGELOG_SCRIPT_PRINT_USAGE()
+ELSE()
+    IF("${cmd}" STREQUAL "make")
+	CHANGELOG_MAKE(${prj_info} ${release} ${changelog})
+    ELSEIF("${cmd}" STREQUAL "update")
+	RELEASE_NOTES_READ_FILE(${release})
+	SET(updateRequired 0)
+	IF(cmake_source_dir STREQUAL "")
+	    SET(cmake_source_dir ".")
+	ENDIF()
+	IF(EXISTS "${changelog}")
+	    IF(${release} IS_NEWER_THAN ${changelog})
+		EXECUTE_PROCESS(COMMAND ${CMAKE_COMMAND} ${cmake_source_dir})
+		SET(updateRequired 1)
+	    ELSEIF(NOT PRJ_VER EQUAL PRJ_VER_CACHED)
+		EXECUTE_PROCESS(COMMAND ${CMAKE_COMMAND} ${cmake_source_dir})
+		SET(updateRequired 1)
+	    ENDIF()
+	ELSE()
+	    SET(updateRequired 1)
+	ENDIF()
+
+	IF(updateRequired)
+	    CHANGELOG_MAKE(${prj_info} ${release} ${changelog})
+	ENDIF()
+    ELSEIF("${cmd}" STREQUAL "extract_current")
+	EXTRACT_CURRENT_FROM_RELEASE(outVar ${release})
+	M_OUT("${outVar}")
+    ELSEIF("${cmd}" STREQUAL "extract_prev")
+	IF("${ver}" STREQUAL "")
+	    MANAGE_CHANGELOG_SCRIPT_PRINT_USAGE()
+	    M_MSG(${M_FATAL} "Requires \"-Dver=ver\"")
+	ENDIF()
+	EXTRACT_PREV_FROM_CHANGELOG(outVar ${ver} ${changelog})
+	M_OUT("${outVar}")
+    ELSE()
+	MANAGE_CHANGELOG_SCRIPT_PRINT_USAGE()
+	M_MSG(${M_FATAL} "Invalid cmd ${cmd}")
+    ENDIF()
+ENDIF()
+
diff -Nura ibus-chewing-1.6.1/Modules/ManageDependency.cmake ibus-chewing-1.6.1_new/Modules/ManageDependency.cmake
--- ibus-chewing-1.6.1/Modules/ManageDependency.cmake	1970-01-01 08:00:00.000000000 +0800
+++ ibus-chewing-1.6.1_new/Modules/ManageDependency.cmake	2016-01-29 16:14:12.000000000 +0800
@@ -0,0 +1,244 @@
+# - Dependency Management Module
+# This module handle dependencies by using pkg-config and/or
+# search the executable.
+# 
+# Included Modules:
+#  - ManageFile
+#  - ManageString
+#  - ManageVariable
+#
+# Variable to be read:
+#  + MANAGE_DEPENDENCY_PACKAGE_EXISTS_CMD: Command and options that check
+#      the existence of a package
+#    Default: rpm -q
+#
+#  + MANAGE_DEPENDENCY_PACKAGE_INSTALL_CMD: Command and options that install
+#      a package
+#    Default: yum -y install
+#
+# Defines following functions:
+#   MANAGE_DEPENDENCY(<listVar> <var> [VER <ver> [EXACT]] [REQUIRED] 
+#     [PROGRAM_NAMES <name1> ...] [PROGRAM_SEARCH_PATHS <path1> ...] 
+#     [PKG_CONFIG <pkgConfigName1> ...]
+#     [PACKAGE_NAME <packageName> | DEVEL]
+#     )
+#     - Add a new dependency to a list. 
+#       The dependency will also be searched.
+#       If found, ${var}_FOUND is set as 1.
+#       If not found:
+#         + If REQUIRED is specified: a M_ERROR message will be printed. #	     + If REQUIRED is not specified: a M_OFF message will be printed.
+#       See "Variables to cache" for the variable overridden and output.
+#       * Parameters:
+#         + listVar: List variable store a kind of dependencies.
+#           Recognized lists:
+#           - BUILD_REQUIRES: Dependencies in build stage
+#           - REQUIRES:       Dependencies for runtime
+#           - REQUIRES_PRE:   Dependencies before the package install
+#           - REQUIRES_PREUN: Dependencies before the package uninstall
+#           - REQUIRES_POST:  Dependencies after the package install
+#           - REQUIRES_POSTUN:Dependencies after the package uninstall
+#         + var: Main variable. Uppercase variable name is recommended,
+#           (e.g. GETTEXT)
+#         + VER ver [EXACT]: Minimum version.
+#           Specify the exact version by providing "EXACT".
+#         + REQUIRED: The dependency is required at cmake build time.
+#         + PROGRAM_NAMES name1 ...: Executable to be found.
+#             name2 and others are aliases to name1.
+#             If found, ${var}_EXECUTABLE is defined as the full path 
+#             to the executable; if not found; the whole dependency is
+#             deemed as not found.
+#         + PROGRAM_SEARCH_PATHS path1 ...: Additional program search path.
+#             It will act as PATHS arguments for FIND_PROGRAM.
+#         + PKG_CONFIG pkgConfigName1 ...: List of the pkg-config file
+#             exclude the directory and .pc. e.g. "gtk+-2.0"
+#         + PACKAGE_NAME packageName: The actual package name in repository. 
+#             If not specified, use the lowercase of ${var}.
+#             For example, use following to specify libchewing as dependency 
+#             under the name CHEWING:
+#           MANAGE_DEPENDENCY(REQUIRES CHEWING PACKAGE_NAME "libchewing")
+#         + DEVEL: search lowercase of ${var}-devel.
+#             A shortcut to PACKAGE_NAME ${var}-devel.
+#       * Variables to cache:
+#         + ${listVar}_${listVar}_${var}_PACKAGE_NAME: The actual package name in repository.
+#             Override this if your system is different from Fedora.
+#         + ${listVar}_${var}_PKG_CONFIG: List of pkg-config files.
+#             Override this if your system is different from Fedora.
+#         + ${var}_<print_variable>: The pkg-config variables.
+#             For example, datadir=/usr/share/chewing will be
+#           ${var}_DATADIR, whose value is "/usr/share/chewing"
+#
+IF(DEFINED _MANAGE_DEPENDENCY_CMAKE_)
+    RETURN()
+ENDIF(DEFINED _MANAGE_DEPENDENCY_CMAKE_)
+SET(_MANAGE_DEPENDENCY_CMAKE_ "DEFINED")
+INCLUDE(ManageFile)
+INCLUDE(ManageVariable)
+INCLUDE(ManageString)
+SET(MANAGE_DEPENDENCY_PACKAGE_EXISTS_CMD rpm -q 
+    CACHE STRING "Package exist command"
+    )
+
+SET(MANAGE_DEPENDENCY_PACKAGE_INSTALL_CMD yum -y install 
+    CACHE STRING "Package exist command"
+    )
+
+## This need to be here, otherwise the variable won't be available
+## the 2nd time called.
+FIND_PACKAGE(PkgConfig)
+
+## This is declared as function, because 
+## macro does not play nice if listVar is required in different
+## source dir.
+FUNCTION(MANAGE_DEPENDENCY listVar var)
+    SET(_validOptions "VER" "EXACT" "REQUIRED" 
+	"PROGRAM_NAMES" "PROGRAM_SEARCH_PATHS" "PKG_CONFIG" "PACKAGE_NAME" "DEVEL")
+    VARIABLE_PARSE_ARGN(_opt _validOptions ${ARGN})
+    SET(_dirty 0)
+
+    IF("${${listVar}_${var}_PACKAGE_NAME}" STREQUAL "")
+	IF(_opt_PACKAGE_NAME)
+	    IF(DEFINED _opt_DEVEL)
+		M_MSG(${M_ERROR} "PACKAGE_NAME cannot use with DEVEL")
+	    ENDIF()
+	    SET(${listVar}_${var}_PACKAGE_NAME "${_opt_PACKAGE_NAME}")
+	ELSE(_opt_PACKAGE_NAME)
+	    STRING(TOLOWER "${var}" ${listVar}_${var}_PACKAGE_NAME)
+	    IF(DEFINED _opt_DEVEL)
+		STRING_APPEND(${listVar}_${var}_PACKAGE_NAME "-devel")
+	    ENDIF()
+	ENDIF(_opt_PACKAGE_NAME)
+	SET(${listVar}_${var}_PACKAGE_NAME "${${listVar}_${var}_PACKAGE_NAME}" 
+	    CACHE STRING "${listVar}_${var}_PACKAGE_NAME")
+    ENDIF()
+    SET(pkgName "${${listVar}_${var}_PACKAGE_NAME}")
+
+    IF(DEFINED _opt_REQUIRED)
+	SET(_verbose "${M_ERROR}")
+	SET(_required "REQUIRED")
+	SET(_progNotFoundMsg 
+	    "Program names ${_opt_PROGRAM_NAMES} not found, install ${pkgName}")
+    ELSE(DEFINED _opt_REQUIRED)
+	SET(_verbose "${M_OFF}")
+	SET(_required "")
+	SET(_progNotFoundMsg 
+	    "Program names ${_opt_PROGRAM_NAMES} not found, ${var} support disabled")
+    ENDIF(DEFINED _opt_REQUIRED)
+
+    IF(_opt_VER)
+	IF(DEFINED _opt_EXACT)
+	    SET(_rel "=")
+	    SET(_exact "EXACT")
+	ELSE(DEFINED _opt_EXACT)
+	    SET(_rel ">=")
+	    SET(_exact "")
+	ENDIF(DEFINED _opt_EXACT)
+    ENDIF(_opt_VER)
+
+    IF(_opt_PROGRAM_NAMES)
+	M_MSG(${M_INFO2} "ManageDependency: Finding program names ${_opt_PROGRAM_NAMES}")
+	SET(_findArgs FIND_ARGS NAMES "${_opt_PROGRAM_NAMES}")
+	IF(_opt_PROGRAM_SEARCH_PATHS)
+	    LIST(APPEND _findArgs PATHS ${_opt_PROGRAM_SEARCH_PATHS})
+	ENDIF()
+	FIND_PROGRAM_ERROR_HANDLING(${var}_EXECUTABLE
+	    ERROR_VAR _dirty
+	    ERROR_MSG "${_progNotFoundMsg}"
+	    VERBOSE_LEVEL "${_verbose}"
+	    ${_findArgs}
+	    )
+	MARK_AS_ADVANCED(${var}_EXECUTABLE)
+    ENDIF(_opt_PROGRAM_NAMES)
+
+    IF("${_opt_VER}" STREQUAL "")
+	SET(_newDep  "${pkgName}")
+    ELSE("${_opt_VER}" STREQUAL "")
+	SET(_newDep  "${pkgName} ${_rel} ${_opt_VER}")
+    ENDIF("${_opt_VER}" STREQUAL "")
+
+    ## Check package exist
+    SET(pkgExistsCmdMissing 0)
+    LIST(GET MANAGE_DEPENDENCY_PACKAGE_EXISTS_CMD 0 pkgExistsCmd)
+    FIND_PROGRAM_ERROR_HANDLING(PKG_EXISTS_CMD
+	ERROR_VAR pkgExistsCmdMissing
+	ERROR_MSG "ManageDependency: Program ${pkgExistsCmd} not found, dependency check disabled."
+	VERBOSE_LEVEL ${M_OFF}
+	FIND_ARGS ${pkgExistsCmd}
+	)
+
+    IF(NOT pkgExistsCmdMissing)
+	EXECUTE_PROCESS(COMMAND ${MANAGE_DEPENDENCY_PACKAGE_EXISTS_CMD} ${pkgName}
+	    RESULT_VARIABLE pkgMissing
+	    OUTPUT_QUIET
+	    ERROR_QUIET
+	    )
+	IF(pkgMissing)
+	    ## Dependency not found
+	    M_MSG(${_verbose} "Package ${pkgName} is not installed")
+	    SET(_dirty 1)
+	ENDIF(pkgMissing)
+    ENDIF()
+
+    ## PKG_CONFIG
+    IF("${${listVar}_${var}_PKG_CONFIG}" STREQUAL "")
+	IF(_opt_PKG_CONFIG)
+	    SET(${listVar}_${var}_PKG_CONFIG "${_opt_PKG_CONFIG}" 
+		CACHE STRING "${listVar}_${var}_PKG_CONFIG")
+	ENDIF(_opt_PKG_CONFIG)
+    ENDIF()
+    SET(pkgConf "${${listVar}_${var}_PKG_CONFIG}")
+
+    IF(pkgConf)
+	IF(PKG_CONFIG_EXECUTABLE)
+	    ## Add pkgconfig itself as dependency
+	    SET(PKG_CONFIG_PACKAGE_NAME "pkgconfig" 
+		CACHE STRING "PKG_CONFIG_PACKAGE_NAME")
+	    LIST(FIND ${listVar} "${PKG_CONFIG_PACKAGE_NAME}" _index)
+	    IF(_index EQUAL -1)
+		LIST(APPEND ${listVar} "${PKG_CONFIG_PACKAGE_NAME}")
+	    ENDIF(_index EQUAL -1)
+	ELSE(PKG_CONFIG_EXECUTABLE)
+	    M_MSG(${M_ERROR} "pkgconfig is required with ${var}")
+	ENDIF(PKG_CONFIG_EXECUTABLE)
+	SET(pCList "")
+	FOREACH(pC ${pkgConf})
+	    LIST(APPEND pCList "${pC}${_rel}${_opt_VER}")
+	    ## Get all variables
+	    EXECUTE_PROCESS(COMMAND ${PKG_CONFIG_EXECUTABLE}
+		--print-variables "${pC}"
+		OUTPUT_VARIABLE _variables
+		OUTPUT_STRIP_TRAILING_WHITESPACE
+		RESULT_VARIABLE pkgconfigFailed
+		)
+	    IF(NOT pkgconfigFailed)
+		STRING_SPLIT(${var}_VARIABLES "\n" "${_variables}")
+		FOREACH(_v ${${var}_VARIABLES})
+		    STRING(TOUPPER "${_v}" _u)
+		    EXECUTE_PROCESS(COMMAND ${PKG_CONFIG_EXECUTABLE}
+			--variable "${_v}" "${pC}"
+			OUTPUT_VARIABLE ${var}_${pC}_${_u}
+			OUTPUT_STRIP_TRAILING_WHITESPACE
+			)
+		    SET(${var}_${pC}_${_u} "${${var}_${pC}_${_u}}" 
+			CACHE INTERNAL "pkgconfig ${${var}_${pC}_${_u}}")
+
+		    MARK_AS_ADVANCED(${${var}_${pC}_${_u}})
+		    M_MSG(${M_INFO1} "${var}_${pC}_${_u}=${${var}_${pC}_${_u}}")
+		ENDFOREACH(_v)
+
+	    ENDIF(NOT pkgconfigFailed)
+	ENDFOREACH(pC)
+	PKG_CHECK_MODULES(${var} ${_required}
+	    ${pCList})
+    ENDIF(pkgConf)
+
+    ## Insert when it's not duplicated
+    IF(NOT _dirty)
+	SET(${var}_FOUND "1" CACHE INTERNAL "Found ${var}")
+    ENDIF(NOT _dirty)
+    LIST(FIND ${listVar} "${_newDep}" _index)
+    IF(_index EQUAL -1)
+	LIST(APPEND ${listVar} "${_newDep}")
+	SET(${listVar} "${${listVar}}" CACHE INTERNAL "${listVar} package list")
+    ENDIF(_index EQUAL -1)
+ENDFUNCTION(MANAGE_DEPENDENCY)
+
diff -Nura ibus-chewing-1.6.1/Modules/ManageEnvironment.cmake ibus-chewing-1.6.1_new/Modules/ManageEnvironment.cmake
--- ibus-chewing-1.6.1/Modules/ManageEnvironment.cmake	1970-01-01 08:00:00.000000000 +0800
+++ ibus-chewing-1.6.1_new/Modules/ManageEnvironment.cmake	2016-01-29 15:15:26.000000000 +0800
@@ -0,0 +1,168 @@
+# - Manage environment in build mode after project information is defined.
+#
+# This module manages build mode environment, including variables, compiler 
+# flags and CMake policies.
+#
+# The main difference between this module and ManageEnvironmentCommon are:
+#   - ManageEnvironmentCommon is called by both script and build mode;
+#       while this module is called by only build mode.
+#   - ManageEnvironmentCommon should be invoked before project definition;
+#       this module should be invoked after project definition.
+#   - ManageEnvironmentCommon caches only variables; 
+#       this module not only caches variables, but also set the compiler flags.
+#
+# Included Modules:
+#   - ManageMessage
+#
+# Reads following variables:
+#   - CMAKE_INSTALL_PREFIX: Install directory used by install.
+#   - PROJECT_NAME: Project name.
+#
+# Set cache for following variables:
+#   - PRJ_DATA_DIR: Project data dir
+#     Default: ${DATA_DIR}/${PROJECT_NAME}
+#   - PRJ_DOC_DIR: Project doc dir
+#     Default: ${DOC_DIR}/${PROJECT_NAME}
+#
+# Defines following compile flags: (which use variables with same names)
+#   - CMAKE_INSTALL_PREFIX
+#   - PROJECT_NAME
+#   - BIN_DIR
+#   - DATA_DIR
+#   - DOC_DIR
+#   - SYSCONF_DIR
+#   - LIB_DIR
+#   - LIBEXEC_DIR
+#   - PRJ_DATA_DIR
+#   - PRJ_DOC_DIR
+#
+# Note: compile flag PRJ_VER is defined in ManageVersion.
+#
+# Defines following functions:
+#   SET_COMPILE_ENV(<var> [<defaultValue>] [ENV_NAME <envName>]
+#       [CACHE <type> <docstring> [FORCE]]
+#     )
+#     - Ensure a variable is set to nonempty value, then set the value
+#       to the compile flags with same name.
+#
+#       The value is determined by first non-empty value:
+#       1. Value of <var>.
+#       2. Value of environment variable <var>, 
+#          or if ENV_NAME is specified, value of <envName>.
+#       3. <defaultValue>
+#       * Parameters:
+#         + var: Variable to be set
+#         + defaultValue: Default value of the var
+#         + envName: (Optional)The name of environment variable.
+#           Only need if different from var.
+#         + CACHE type docstring [FORCE]:
+#           Same with "SET" command.
+#
+
+IF(DEFINED _MANAGE_ENVIRONMENT_CMAKE_)
+    RETURN()
+ENDIF(DEFINED _MANAGE_ENVIRONMENT_CMAKE_)
+SET(_MANAGE_ENVIRONMENT_CMAKE_ "DEFINED")
+
+FUNCTION(SET_COMPILE_ENV var)
+    SET(_stage "")
+    SET(_env "${var}")
+    SET(_setOpts "")
+    SET(_force 0)
+    SET(_defaultValue "")
+    CMAKE_POLICY(PUSH)
+    IF(POLICY CMP0054)
+	CMAKE_POLICY(SET CMP0054 OLD)
+    ENDIF()
+
+    FOREACH(_arg ${ARGN})
+	IF("${_arg}" STREQUAL "ENV_NAME")
+	    SET(_stage "ENV_NAME")
+	ELSEIF("${_arg}" STREQUAL "CACHE")
+	    SET(_stage "_CACHE")
+	ELSE()
+	    IF("${_stage}" STREQUAL "ENV_NAME")
+		SET(_env "${_arg}")
+	    ELSEIF("${_stage}" STREQUAL "_CACHE")
+		LIST(APPEND _setOpts "${_arg}")
+		IF("${_arg}" STREQUAL "FORCE")
+		    SET(_force 1)
+		ENDIF()
+	    ELSE()
+		SET(_defaultValue "${_arg}")
+	    ENDIF()
+	ENDIF()
+    ENDFOREACH(_arg ${ARGN})
+
+    IF("${_setOpts}" STREQUAL "")
+	SET(_setOpts "PARENT_SCOPE")
+    ELSE()
+	LIST(INSERT _setOpts 0 "CACHE")
+    ENDIF()
+
+    # Set the variable
+    IF(NOT "${${var}}" STREQUAL "")
+	SET(${var} "${${var}}" ${_setOpts})
+    ELSEIF(NOT "$ENV{${_env}}" STREQUAL "")
+	SET(${var} "$ENV{${_env}}" ${_setOpts})
+    ELSE()
+	## Use default value
+	SET(${var} "${_defaultValue}" ${_setOpts})
+    ENDIF()
+
+    # Enforce CMP0005 to new, yet pop after ADD_DEFINITION
+    CMAKE_POLICY(SET CMP0005 NEW)
+    ADD_DEFINITIONS(-D${_env}=${${var}})
+    CMAKE_POLICY(POP)
+    M_MSG(${M_INFO2} "SET_COMPILE_ENV: ${var}=${${var}}")
+ENDFUNCTION(SET_COMPILE_ENV)
+
+MACRO(MANAGE_CMAKE_POLICY policyName defaultValue)
+    IF(POLICY ${policyName})
+	CMAKE_POLICY(GET "${policyName}" _cmake_policy_value)
+	IF(_cmake_policy_value STREQUAL "")
+	    # Policy not defined yet
+	    CMAKE_POLICY(SET "${policyName}" "${defaultValue}")
+	ENDIF(_cmake_policy_value STREQUAL "")
+    ENDIF(POLICY ${policyName})
+ENDMACRO(MANAGE_CMAKE_POLICY policyName defaultValue)
+
+####################################################################
+# Variables settings
+# 
+
+## CMAKE_FEODRA_MODULE_DIR: Directory contains cmake-fedora modules
+INCLUDE(ManageMessage RESULT_VARIABLE MANAGE_ENVIRONMENT_PATH)
+GET_FILENAME_COMPONENT(CMAKE_FEDORA_MODULE_DIR 
+    "${MANAGE_ENVIRONMENT_PATH}" PATH CACHE
+    )
+
+FILE(MAKE_DIRECTORY "${CMAKE_FEDORA_TMP_DIR}")
+
+## Print CMake system information
+M_MSG(${M_INFO1} "CMAKE_HOST_SYSTEM=${CMAKE_HOST_SYSTEM}")
+M_MSG(${M_INFO1} "CMAKE_HOST_SYSTEM_PROCESSOR=${CMAKE_HOST_SYSTEM_PROCESSOR}")
+M_MSG(${M_INFO1} "CMAKE_SYSTEM=${CMAKE_SYSTEM}")
+M_MSG(${M_INFO1} "CMAKE_SYSTEM_PROCESSOR=${CMAKE_SYSTEM_PROCESSOR}")
+
+## Set compile flags
+SET_COMPILE_ENV(BIN_DIR)
+SET_COMPILE_ENV(DATA_DIR)
+SET_COMPILE_ENV(DOC_DIR)
+SET_COMPILE_ENV(SYSCONF_DIR)
+SET_COMPILE_ENV(LIB_DIR)
+SET_COMPILE_ENV(LIBEXEC_DIR)
+
+IF(CMAKE_SYSTEM_PROCESSOR MATCHES "64")
+    SET_COMPILE_ENV(IS_64)
+ENDIF(CMAKE_SYSTEM_PROCESSOR MATCHES "64")
+
+SET_COMPILE_ENV(PRJ_DATA_DIR "${DATA_DIR}/${PROJECT_NAME}"
+    CACHE PATH "Project data dir"
+    )
+SET_COMPILE_ENV(PRJ_DOC_DIR "${DOC_DIR}/${PROJECT_NAME}"
+    CACHE PATH "Project doc dir"
+    )
+
+SET_COMPILE_ENV(PROJECT_NAME)
+
diff -Nura ibus-chewing-1.6.1/Modules/ManageEnvironmentCommon.cmake ibus-chewing-1.6.1_new/Modules/ManageEnvironmentCommon.cmake
--- ibus-chewing-1.6.1/Modules/ManageEnvironmentCommon.cmake	1970-01-01 08:00:00.000000000 +0800
+++ ibus-chewing-1.6.1_new/Modules/ManageEnvironmentCommon.cmake	2015-12-17 17:43:31.000000000 +0800
@@ -0,0 +1,75 @@
+# - cmake-fedora environment common setting.
+#
+# This module defines the common settings of both normal and script mode.
+# Normally this module should be the first to call.
+#
+# Set cache for following variables:
+#   - CMAKE_INSTALL_PREFIX:
+#     Default: "/usr"
+#   - BIN_DIR: Binary dir
+#     Default: "${CMAKE_INSTALL_PREFIX}/bin"
+#   - DATA_DIR: Data dir
+#     Default: "${CMAKE_INSTALL_PREFIX}/share"
+#   - DOC_DIR: Documentation dir
+#     Default: "${DATA_DIR}/doc"
+#   - SYSCONF_DIR: System configuration dir
+#     Default: "/etc"
+#   - LIB_DIR: System wide library path.
+#     Default: ${CMAKE_INSTALL_PREFIX}/lib for 32 bit,
+#              ${CMAKE_INSTALL_PREFIX}/lib64 for 64 bit.
+#   - LIBEXEC_DIR: Directory for executables that should not called by 
+#       end-user directly
+#     Default: "${CMAKE_INSTALL_PREFIX}/libexec"
+#   - CMAKE_FEDORA_SCRIPT_PATH_HINTS: PATH hints to find cmake-fedora scripts
+#   - CMAKE_FEDORA_TMP_DIR: Director that stores cmake-fedora
+#       temporary items.
+#     Default: ${CMAKE_BINARY_DIR}/NO_PACK
+#   - MANAGE_MESSAGE_LEVEL: Message (Verbose) Level
+#     Default: 5
+#
+#
+#
+IF(DEFINED _MANAGE_ENVIRONMENT_COMMON_CMAKE_)
+    RETURN()
+ENDIF(DEFINED _MANAGE_ENVIRONMENT_COMMON_CMAKE_)
+SET(_MANAGE_ENVIRONMENT_COMMON_CMAKE_ "DEFINED")
+SET(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS ON)
+
+# Default CMAKE_INSTALL_PREFIX should be set before PROJECT()
+SET(CMAKE_INSTALL_PREFIX "/usr" CACHE PATH "Install dir prefix")
+
+SET(BIN_DIR     "${CMAKE_INSTALL_PREFIX}/bin"     CACHE PATH "Binary dir")
+SET(DATA_DIR    "${CMAKE_INSTALL_PREFIX}/share"   CACHE PATH "Data dir")
+SET(DOC_DIR     "${DATA_DIR}/doc"                 CACHE PATH "Doc dir")
+SET(LIBEXEC_DIR "${CMAKE_INSTALL_PREFIX}/libexec" CACHE PATH "Libexec dir")
+SET(SYSCONF_DIR "/etc"                            CACHE PATH 
+    "System configuration dir"
+    )
+
+
+## CMAKE_SYSTEM_PROCESSOR does not see to be defined yet
+EXECUTE_PROCESS(COMMAND uname -p
+    OUTPUT_VARIABLE UNAME_P
+    OUTPUT_STRIP_TRAILING_WHITESPACE
+    )
+IF("${UNAME_P}" MATCHES "64")
+    SET(IS_64 "64" CACHE STRING "IS_64")
+ENDIF()
+SET(LIB_DIR "${CMAKE_INSTALL_PREFIX}/lib${IS_64}"
+    CACHE PATH "Library dir"
+    )
+
+SET(CMAKE_FEDORA_SCRIPT_PATH_HINTS 
+    ${CMAKE_SOURCE_DIR}/scripts ${CMAKE_SOURCE_DIR}/cmake-fedora/scripts
+    ${CMAKE_SOURCE_DIR}/../scripts ${CMAKE_SOURCE_DIR}/../cmake-fedora/scripts
+    ${CMAKE_SOURCE_DIR}/../../scripts ${CMAKE_SOURCE_DIR}/../../cmake-fedora/scripts
+    CACHE INTERNAL "CMAKE_FEDORA_SCRIPT_PATH_HINTS"
+    )
+
+## CMAKE_FEDORA_TMP_DIR: Directory stores temporary files.
+SET(CMAKE_FEDORA_TMP_DIR "${CMAKE_BINARY_DIR}/NO_PACK" 
+    CACHE PATH "cmake-fedora tmp dir")
+
+## Message level INFO1 (5)
+SET(MANAGE_MESSAGE_LEVEL 5 CACHE STRING "Message (Verbose) Level")
+
diff -Nura ibus-chewing-1.6.1/Modules/ManageFile.cmake ibus-chewing-1.6.1_new/Modules/ManageFile.cmake
--- ibus-chewing-1.6.1/Modules/ManageFile.cmake	1970-01-01 08:00:00.000000000 +0800
+++ ibus-chewing-1.6.1_new/Modules/ManageFile.cmake	2015-12-17 17:43:31.000000000 +0800
@@ -0,0 +1,505 @@
+# - Manage files
+#
+# Included Modules:
+#   - ManageMessage
+#   - ManageVariable
+#
+# Defines following functions:
+#   FIND_FILE_ERROR_HANDLING(<var>
+#     [ERROR_MSG <errorMessage>]
+#     [ERROR_VAR <errorVar>]
+#     [VERBOSE_LEVEL <verboseLevel>]
+#     [FIND_ARGS ...]
+#     )
+#     - Find a file, with proper error handling.
+#       It is essentially a wrapper of FIND_FILE
+#       * Parameters:
+#         + var: The variable that stores the path of the found program.
+#         + name: The filename of the command.
+#         + verboseLevel: See ManageMessage for semantic of 
+#           each verbose level.
+#         + ERROR_MSG errorMessage: Error message to be append.
+#         + ERROR_VAR errorVar: Variable that will be  set to 1 
+#           when not found.
+#         + FIND_ARGS: A list of arguments to be passed 
+#           to FIND_FILE
+#
+#   FIND_PROGRAM_ERROR_HANDLING(<var>
+#     [ERROR_MSG <errorMessage>]
+#     [ERROR_VAR <errorVar>]
+#     [VERBOSE_LEVEL <verboseLevel>]
+#     [FIND_ARGS ...]
+#     )
+#     - Find an executable program, with proper error handling.
+#       It is essentially a wrapper of FIND_PROGRAM
+#       * Parameters:
+#         + var: The variable that stores the path of the found program.
+#         + name: The filename of the command.
+#         + verboseLevel: See ManageMessage for semantic of 
+#           each verbose level.
+#         + ERROR_MSG errorMessage: Error message to be append.
+#         + ERROR_VAR errorVar: Variable that will be  set to 1 
+#           when not found.
+#         + FIND_ARGS: A list of arguments to be passed 
+#             to FIND_PROGRAM
+#
+#   GIT_GLOB_TO_CMAKE_REGEX(<var> <glob>)
+#     - Convert git glob to cmake file regex
+#       This macro covert git glob used in gitignore to
+#       cmake file regex used in CPACK_SOURCE_IGNORE_FILES
+#       * Parameters:
+#         + var: Variable that hold the result.
+#         + glob: Glob to be converted
+#
+#   MANAGE_CMAKE_FEDORA_CONF(<var>
+#     [ERROR_MSG <errorMessage>]
+#     [ERROR_VAR <errorVar>]
+#     [VERBOSE_LEVEL <verboseLevel>]
+#     )
+#     - Locate cmake-fedora.conf
+#       Return the location of cmake-fedora.conf.
+#       It search following places:
+#       ${CMAKE_SOURCE_DIR}, ${CMAKE_SOURCE_DIR}/cmake-fedora,
+#       current dir, ./cmake-fedora and /etc.
+#       * Parameters:
+#         + var: The variable that returns the path of cmake-fedora.conf
+#         + verboseLevel: See ManageMessage for semantic of 
+#           each verbose level.
+#         + ERROR_MSG errorMessage: Error message to be append.
+#         + ERROR_VAR errorVar: This variable will be set to 1
+#           when cmake-fedora.conf is not found.
+#
+#   MANAGE_FILE_COMMON_DIR(<var> <file1> ...>)
+#     - Get the longest common path. 
+#       Note that this function just do string comparison, it does not convert to real path.
+#       It is recommended to use all absolute paths or all relative paths.
+#       * Parameters:
+#         + var: The variable that returns the file expiry status.
+#           Valid status: ERROR, NOT_FOUND, EXPIRED, NOT_EXPIRED.
+#         + file1 ...: files to compare.
+#
+#
+#   MANAGE_FILE_CACHE(<var> <file> [EXPIRY_SECONDS <expirySecond>]
+#     [CACHE_DIR <dir>] [ERROR_VAR <errorVar>] [RESULT_VAR resultVar]
+#     COMMAND <cmd ...>
+#     )
+#     - Manage cached program output.
+#       If cache is not existed, it runs the command and create the cache;
+#       otherwise if cache is not expired, it returns the cached content;
+#       otherwise if cache is expired, it run sthe command and update the 
+#       cache.
+#       Then this program returns cache content.
+#       * Parameters:
+#         + var: The variable the stores the content of the cache file.
+#         + file: File to be processed. 
+#         + EXPIRY_SECONDS expirySecond: (Optional) Seconds 
+#           before the file expired.
+#           If not specified, it will use the value LOCAL_CACHE_EXPIRY 
+#           in cmake-fedora.conf, or 259200 (3 days).
+#         + CACHE_DIR dir: (Optional) Directory of <file>.
+#           If not specified, it will use the value 
+#           LOCAL_CACHE_DIR in cmake-fedora.conf,
+#           or $ENV{HOME}/.cache/cmake-fedora .
+#         + ERROR_VAR errorVar: This variable will be set to 1
+#           when cache cannot be created.
+#         + RESULT_VAR resultVar: This variable returns the exit code
+#           for <cmd>.
+#         + COMMAND <cmd ...>: Command to produceoutput.
+#
+#   MANAGE_FILE_EXPIRY(<var> <file> <expirySecond>)
+#     - Tell whether a file is expired.
+#       A file is deemed as expired if (currenTime - mtime) is greater
+#       than specified expiry time in seconds.
+#       * Parameters:
+#         + var: The variable that returns the file expiry status.
+#           Valid status: ERROR, NOT_FOUND, EXPIRED, NOT_EXPIRED.
+#         + file: File to be processed.
+#         + expirySecond: Seconds before the file expired.
+#
+#
+# Defines following macros:
+#   MANAGE_FILE_INSTALL(<fileType>
+#     [<files> | FILES <files>] [DEST_SUBDIR <subDir>] 
+#     [RENAME <newName>] [ARGS <args>]
+#     )
+#     - (Deprecated) Manage file installation.
+#       You can use cmake built-in INSTALL after cmake-fedora-2.0.0
+#       * Parameters:
+#         + fileType: Type of files. Valid values:
+#           BIN, PRJ_DOC, DATA, PRJ_DATA, 
+#           SYSCONF, SYSCONF_NO_REPLACE, 
+#           LIB, LIBEXEC, TARGETS
+#         + DEST_SUBDIR subDir: Subdir of Destination dir
+#         + files: Files to be installed.
+#         + RENAME newName: Destination filename.
+#         + ARGS args: Arguments for INSTALL.
+#
+
+IF(DEFINED _MANAGE_FILE_CMAKE_)
+    RETURN()
+ENDIF(DEFINED _MANAGE_FILE_CMAKE_)
+SET(_MANAGE_FILE_CMAKE_ "DEFINED")
+SET(FILE_INSTALL_LIST_TYPES 
+    "BIN" "PRJ_DOC" "DATA" "PRJ_DATA" "SYSCONF" "SYSCONF_NO_REPLACE"
+    "LIB" "LIBEXEC"
+    )
+INCLUDE(ManageMessage RESULT_VARIABLE MANAGE_MODULE_PATH)
+GET_FILENAME_COMPONENT(CMAKE_FEDORA_MODULE_DIR "${MANAGE_MODULE_PATH}" PATH)
+INCLUDE(ManageVariable)
+INCLUDE(ManageString)
+
+## Common path between two
+FUNCTION(MANAGE_FILE_COMMON_DIR_2 var file1 file2 separator)
+    SET(result "")
+    IF("${file1}" STREQUAL "${file2}")
+	SET(result "${file1}")
+    ELSE()
+	STRING_SPLIT(dirA1 "${separator}" "${file1}")
+	LIST(LENGTH dirA1 dirA1Len)
+	STRING_SPLIT(dirA2 "${separator}" "${file2}")
+	LIST(LENGTH dirA2 dirA2Len)
+	SET(i 0)
+	WHILE(i LESS dirA1Len)
+	    IF(NOT i LESS dirA2Len)
+		BREAK()
+	    ENDIF()
+	    LIST(GET dirA1 ${i} token1)
+	    LIST(GET dirA2 ${i} token2)
+	    IF(NOT "${token1}" STREQUAL "${token2}")
+		BREAK()
+	    ENDIF()
+	    STRING_APPEND(result "${token1}" "${separator}")
+	    MATH(EXPR i ${i}+1)
+	ENDWHILE()
+    ENDIF()
+    SET(${var} "${result}" PARENT_SCOPE)
+ENDFUNCTION(MANAGE_FILE_COMMON_DIR_2)
+
+FUNCTION(MANAGE_FILE_COMMON_DIR var file1)
+    SET(separator "/")
+    IF(EXISTS "${file1}")
+	IF(IS_DIRECTORY "${file1}")
+	    SET(commonDir "${file1}")
+	ELSE()
+	    GET_FILENAME_COMPONENT(commonDir "${file1}" PATH)
+	ENDIF()
+    ELSE()
+	SET(commonDir "${file1}")
+    ENDIF()
+
+    FOREACH(f ${ARGN})
+	MANAGE_FILE_COMMON_DIR_2(commonDir "${commonDir}" "${f}" "${separator}")
+	IF("${commonDir}" STREQUAL "")
+	    BREAK()
+	ENDIF()
+    ENDFOREACH(f)
+    SET(${var} "${commonDir}" PARENT_SCOPE)
+ENDFUNCTION(MANAGE_FILE_COMMON_DIR)
+
+MACRO(_MANAGE_FILE_SET_FILE_INSTALL_LIST fileType)
+    SET(FILE_INSTALL_${fileType}_LIST "${FILE_INSTALL_${fileType}_LIST}"
+	CACHE INTERNAL "List of files install as ${fileType}" FORCE
+	)
+ENDMACRO(_MANAGE_FILE_SET_FILE_INSTALL_LIST fileType)
+
+FOREACH(_fLT ${FILE_INSTALL_LIST_TYPES})
+    SET(FILE_INSTALL_${_fLT}_LIST "")
+    _MANAGE_FILE_SET_FILE_INSTALL_LIST(${_fLT})
+ENDFOREACH(_fLT ${FILE_INSTALL_LIST_TYPES})
+
+MACRO(_MANAGE_FILE_INSTALL_FILE_OR_DIR fileType)
+    IF(_opt_RENAME)
+	SET(_install_options "RENAME" "${_opt_RENAME}")
+    ELSE(_opt_RENAME)
+	SET(_install_options "")
+    ENDIF (_opt_RENAME)
+    FOREACH(_f ${_fileList})
+	GET_FILENAME_COMPONENT(_a "${_f}" ABSOLUTE)
+	SET(_absolute "")
+	STRING(REGEX MATCH "^/" _absolute "${_f}")
+	IF(IS_DIRECTORY "${_a}") 
+	    SET(_install_type "DIRECTORY")
+	ELSE(IS_DIRECTORY "${_a}")
+	    IF("${fileType}" STREQUAL "BIN")
+		SET(_install_type "PROGRAMS")
+	    ELSE("${fileType}" STREQUAL "BIN")
+		SET(_install_type "FILES")
+	    ENDIF("${fileType}" STREQUAL "BIN")
+	ENDIF(IS_DIRECTORY "${_a}")
+	INSTALL(${_install_type} ${_f} DESTINATION "${_destDir}"
+	    ${_install_options} ${ARGN})
+	IF(_opt_RENAME)
+	    SET(_n "${_opt_RENAME}")
+	ELSEIF(_absolute)
+	    GET_FILENAME_COMPONENT(_n "${_f}" NAME)
+	ELSE(_opt_RENAME)
+	    SET(_n "${_f}")
+	ENDIF(_opt_RENAME)
+
+	IF(_opt_DEST_SUBDIR)
+	    LIST(APPEND FILE_INSTALL_${fileType}_LIST
+		"${_opt_DEST_SUBDIR}/${_n}")
+	ELSE(_opt_DEST_SUBDIR)
+	    LIST(APPEND FILE_INSTALL_${fileType}_LIST
+		"${_n}")
+	ENDIF(_opt_DEST_SUBDIR)
+    ENDFOREACH(_f ${_fileList})
+    _MANAGE_FILE_SET_FILE_INSTALL_LIST("${fileType}")
+
+ENDMACRO(_MANAGE_FILE_INSTALL_FILE_OR_DIR fileType)
+
+MACRO(_MANAGE_FILE_INSTALL_TARGET)
+    SET(_installValidOptions "RUNTIME" "LIBEXEC" "LIBRARY" "ARCHIVE")
+    VARIABLE_PARSE_ARGN(_oT _installValidOptions ${ARGN})
+    SET(_installOptions "")
+    FOREACH(_f ${_fileList})
+	GET_TARGET_PROPERTY(_tP "${_f}" TYPE)
+	IF(_tP STREQUAL "EXECUTABLE")
+	    LIST(APPEND _installOptions RUNTIME)
+	    IF(_oT_RUNTIME)
+		LIST(APPEND FILE_INSTALL_BIN_LIST ${_f})
+		_MANAGE_FILE_SET_FILE_INSTALL_LIST("BIN")
+		LIST(APPEND _installOptions "${_oT_RUNTIME}")
+	    ELSEIF(_oT_LIBEXEC)
+		LIST(APPEND FILE_INSTALL_LIBEXEC_LIST ${_f})
+		_MANAGE_FILE_SET_FILE_INSTALL_LIST("LIBEXEC")
+		LIST(APPEND _installOptions "${_oT_LIBEXEC}")
+	    ELSE(_oT_RUNTIME)
+		M_MSG(${M_ERROR} 
+		    "MANAGE_FILE_INSTALL_TARGETS: Type ${_tP} is not yet implemented.")
+	    ENDIF(_oT_RUNTIME)
+	ELSEIF(_tP STREQUAL "SHARED_LIBRARY")
+	    LIST(APPEND FILE_INSTALL_LIB_LIST ${_f})
+	    _MANAGE_FILE_SET_FILE_INSTALL_LIST("LIB")
+	    LIST(APPEND _installOptions "LIBRARY" "${_oT_LIBRARY}")
+	ELSEIF(_tP STREQUAL "STATIC_LIBRARY")
+	    M_MSG(${M_OFF} 
+		"MANAGE_FILE_INSTALL_TARGETS: Fedora does not recommend type ${_tP}, excluded from rpm")
+	    LIST(APPEND _installOptions "ARCHIVE" "${_oT_ARCHIVE}")
+	ELSE(_tP STREQUAL "EXECUTABLE")
+	    M_MSG(${M_ERROR} 
+		"MANAGE_FILE_INSTALL_TARGETS: Type ${_tP} is not yet implemented.")
+	ENDIF(_tP STREQUAL "EXECUTABLE")
+    ENDFOREACH(_f ${_fileList})
+    INSTALL(TARGETS ${_fileList} ${_installOptions})
+ENDMACRO(_MANAGE_FILE_INSTALL_TARGET)
+
+MACRO(MANAGE_FILE_INSTALL fileType)
+    SET(_validOptions "DEST_SUBDIR" "FILES" "ARGS" "RENAME")
+    VARIABLE_PARSE_ARGN(_opt _validOptions ${ARGN})
+    SET(_fileList "")
+    LIST(APPEND _fileList ${_opt} ${_opt_FILES})
+
+    IF("${fileType}" STREQUAL "SYSCONF_NO_REPLACE")
+	SET(_destDir "${SYSCONF_DIR}/${_opt_DEST_SUBDIR}")
+	_MANAGE_FILE_INSTALL_FILE_OR_DIR("${fileType}")
+    ELSEIF("${fileType}" STREQUAL "TARGETS")
+	_MANAGE_FILE_INSTALL_TARGET(${_opt_ARGS})
+    ELSE("${fileType}" STREQUAL "SYSCONF_NO_REPLACE")
+	SET(_destDir "${${fileType}_DIR}/${_opt_DEST_SUBDIR}")
+	_MANAGE_FILE_INSTALL_FILE_OR_DIR("${fileType}")
+    ENDIF("${fileType}" STREQUAL "SYSCONF_NO_REPLACE")
+ENDMACRO(MANAGE_FILE_INSTALL fileType)
+
+FUNCTION(FIND_ERROR_HANDLING type vari)
+    SET(_verboseLevel ${M_ERROR})
+    SET(_errorMsg "")
+    SET(_errorVar "")
+    SET(_findFileArgList "")
+    SET(_state "")
+    FOREACH(_arg ${ARGN})
+	IF(_state STREQUAL "ERROR_MSG")
+	    SET(_errorMsg "${_arg}")
+	    SET(_state "")
+	ELSEIF(_state STREQUAL "ERROR_VAR")
+	    SET(_errorVar "${_arg}")
+	    SET(_state "")
+	ELSEIF(_state STREQUAL "VERBOSE_LEVEL")
+	    SET(_verboseLevel "${_arg}")
+	    SET(_state "")
+	ELSEIF(_state STREQUAL "FIND_ARGS")
+	    LIST(APPEND _findFileArgList "${_arg}")
+	ELSE(_state STREQUAL "ERROR_MSG")
+	    IF(_arg STREQUAL "ERROR_MSG")
+		SET(_state "${_arg}")
+	    ELSEIF(_arg STREQUAL "ERROR_VAR")
+		SET(_state "${_arg}")
+	    ELSEIF(_arg STREQUAL "VERBOSE_LEVEL")
+		SET(_state "${_arg}")
+	    ELSE(_arg STREQUAL "ERROR_MSG")
+		SET(_state "FIND_ARGS")
+		IF(NOT _arg STREQUAL "FIND_ARGS")
+		    LIST(APPEND _findFileArgList "${_arg}")
+		ENDIF(NOT _arg STREQUAL "FIND_ARGS")
+	    ENDIF(_arg STREQUAL "ERROR_MSG")
+	ENDIF(_state STREQUAL "ERROR_MSG")
+    ENDFOREACH(_arg ${ARGN})
+
+    ## FIND_PROGRAM and FIND_FILE caches the result
+    ## And won't find again until the cache is cleaned
+    IF("${type}" STREQUAL "PROGRAM")
+	SET(_type "Program")
+	FIND_PROGRAM(${vari} ${_findFileArgList})
+    ELSE("${type}" STREQUAL "PROGRAM")
+	SET(_type "File")
+	FIND_FILE(${vari} ${_findFileArgList})
+    ENDIF("${type}" STREQUAL "PROGRAM")
+
+    IF("${${vari}}" STREQUAL "${vari}-NOTFOUND")
+	IF(NOT _errorMsg)
+	    SET(_str "")
+	    FOREACH(_s ${_findFileArgList})
+		SET(_str "${_str} ${_s}")
+	    ENDFOREACH(_s ${_findFileArgList})
+
+	    SET(_errorMsg "${_type} cannot be found with following arguments: ${_str}")
+	ENDIF(NOT _errorMsg)
+
+	M_MSG(${_verboseLevel} "${_errorMsg}")
+	IF (NOT _errorVar STREQUAL "")
+	    SET(${_errorVar} 1 PARENT_SCOPE)
+	ENDIF(NOT _errorVar STREQUAL "")
+    ENDIF("${${vari}}" STREQUAL "${vari}-NOTFOUND")
+ENDFUNCTION(FIND_ERROR_HANDLING type vari)
+
+FUNCTION(FIND_FILE_ERROR_HANDLING var)
+    FIND_ERROR_HANDLING(FILE ${var} ${ARGN})
+ENDFUNCTION(FIND_FILE_ERROR_HANDLING var)
+
+FUNCTION(FIND_PROGRAM_ERROR_HANDLING var)
+    FIND_ERROR_HANDLING(PROGRAM ${var} ${ARGN})
+ENDFUNCTION(FIND_PROGRAM_ERROR_HANDLING var)
+
+FUNCTION(MANAGE_CMAKE_FEDORA_CONF var)
+    FIND_FILE_ERROR_HANDLING(${var} ${ARGN}
+	FIND_ARGS cmake-fedora.conf 
+	PATHS ${CMAKE_SOURCE_DIR} ${CMAKE_SOURCE_DIR}/cmake-fedora
+	. cmake-fedora /etc 
+	${CMAKE_FEDORA_MODULE_DIR}/..
+	${CMAKE_FEDORA_MODULE_DIR}/../cmake-fedora
+	${CMAKE_SOURCE_DIR}/../../..
+	${CMAKE_SOURCE_DIR}/../../../cmake-fedora
+	${CMAKE_SOURCE_DIR}/../..
+	${CMAKE_SOURCE_DIR}/../../cmake-fedora
+	)
+    SET(${var} "${${var}}" PARENT_SCOPE)
+ENDFUNCTION(MANAGE_CMAKE_FEDORA_CONF var)
+
+FUNCTION(MANAGE_FILE_CACHE var file)
+    SET(_validOptions "CACHE_DIR" 
+	"EXPIRY_SECONDS" "ERROR_VAR" "RESULT_VAR" "COMMAND")
+    VARIABLE_PARSE_ARGN(_o _validOptions ${ARGN})
+    IF(NOT DEFINED _o_ERROR_VAR)
+	SET(_o_ERROR_VAR "${var}_ERROR")
+	SET(${var}_ERROR 0)
+    ENDIF(NOT DEFINED _o_ERROR_VAR)
+    SET(_commandOptList "")
+    IF(DEFINED _o_RESULT_VAR)
+	SET(_commandOptList RESULT_VARIABLE ${_o_RESULT_VAR})
+    ENDIF(DEFINED _o_RESULT_VAR)
+
+    CMAKE_FEDORA_CONF_GET_ALL_VARIABLES()
+    SET(_toRun TRUE)
+    IF(NOT DEFINED LOCAL_CACHE)
+	SET(LOCAL_CACHE 1)
+    ENDIF(NOT DEFINED LOCAL_CACHE)
+    IF(LOCAL_CACHE)
+	IF(NOT _o_CACHE_DIR)
+	    IF(LOCAL_CACHE_DIR)
+		SET(_o_CACHE_DIR ${LOCAL_CACHE_DIR})
+	    ELSE(LOCAL_CACHE_DIR)
+		SET(_o_CACHE_DIR "${HOME}/.cache/cmake-fedora")
+	    ENDIF(LOCAL_CACHE_DIR)
+	ENDIF(NOT _o_CACHE_DIR)
+	IF(NOT _o_EXPIRY_SECONDS)
+	    IF(LOCAL_CACHE_EXPIRY)
+		SET(_o_EXPIRY_SECONDS ${LOCAL_CACHE_EXPIRY})
+	    ELSE(LOCAL_CACHE_EXPIRY)
+		SET(_o_EXPIRY_SECONDS 259200) # 3 days
+	    ENDIF(LOCAL_CACHE_EXPIRY)
+	ENDIF(NOT  _o_EXPIRY_SECONDS)
+
+	IF(NOT EXISTS ${_o_CACHE_DIR})
+	    EXECUTE_PROCESS(COMMAND 
+		${CMAKE_COMMAND} -E make_directory "${_o_CACHE_DIR}"
+		RESULT_VARIABLE ${_o_ERROR_VAR}
+		OUTPUT_QUIET
+		ERROR_QUIET
+		)
+	ENDIF(NOT EXISTS ${_o_CACHE_DIR})
+	IF(NOT ${${_o_ERROR_VAR}} EQUAL 0)
+	    ## Error when creating cache dir
+	    RETURN()
+	ENDIF(NOT ${${_o_ERROR_VAR}} EQUAL 0)
+
+	SET(_cacheFile "${_o_CACHE_DIR}/${file}")
+	MANAGE_FILE_EXPIRY(_isExpired ${_cacheFile} ${_o_EXPIRY_SECONDS})
+	IF(_isExpired STREQUAL "NOT_EXIST")
+	    SET(_toRun TRUE)
+	ELSEIF(_isExpired STREQUAL "NOT_EXPIRED")
+	    SET(_toRun FALSE)
+	ELSEIF(_isExpired STREQUAL "EXPIRED")
+	    SET(_toRun TRUE)
+	ELSE(_isExpired STREQUAL "NOT_EXIST")
+	    M_MSG(${M_ERROR} "Failed on checking file expirary")
+	ENDIF(_isExpired STREQUAL "NOT_EXIST")
+    ELSE(LOCAL_CACHE)
+	SET(_cacheFile "/tmp/cmake_fedora_cache_${cache_file}")
+    ENDIF(LOCAL_CACHE)
+    
+    IF(_toRun)
+	EXECUTE_PROCESS(COMMAND ${_o_COMMAND}
+	    ${_commandOptList}
+	    OUTPUT_FILE ${_cacheFile}
+	    OUTPUT_STRIP_TRAILING_WHITESPACE
+	    )
+    ENDIF(_toRun)
+    FILE(READ ${_cacheFile} _value)
+    STRING(STRIP "${_value}" _value)
+    SET(${var} "${_value}" PARENT_SCOPE)
+ENDFUNCTION(MANAGE_FILE_CACHE)
+
+FUNCTION(MANAGE_FILE_EXPIRY var file expirySecond)
+    IF(EXISTS "${file}")
+	EXECUTE_PROCESS(COMMAND stat --format "%Y" "${file}"
+	    OUTPUT_VARIABLE _fileTime
+	    OUTPUT_STRIP_TRAILING_WHITESPACE
+	    )
+	EXECUTE_PROCESS(COMMAND date "+%s"
+	    OUTPUT_VARIABLE _currentTime
+	    OUTPUT_STRIP_TRAILING_WHITESPACE
+	    )
+	MATH(EXPR _expireAt "${_fileTime}+${expirySecond}")
+	IF(_currentTime LESS _expireAt)
+	    ## Not Expired
+	    SET(${var} "NOT_EXPIRED" PARENT_SCOPE)
+	ELSE(_currentTime LESS _expireAt)
+	    SET(${var} "EXPIRED" PARENT_SCOPE)
+	ENDIF(_currentTime LESS _expireAt)
+    ELSE(EXISTS "${file}")
+	SET(${var} "NOT_EXIST" PARENT_SCOPE)
+    ENDIF(EXISTS "${file}")
+ENDFUNCTION(MANAGE_FILE_EXPIRY var file expirySecond)
+
+FUNCTION(GIT_GLOB_TO_CMAKE_REGEX var glob)
+    SET(_s "${glob}")
+    STRING(REGEX REPLACE "!" "!e" _s "${_s}")
+    STRING(REGEX REPLACE "[*]{2}" "!d" _s "${_s}")
+    STRING(REGEX REPLACE "[*]" "!s" _s "${_s}")
+    STRING(REGEX REPLACE "[?]" "!q" _s "${_s}")
+    STRING(REGEX REPLACE "[.]" "\\\\\\\\." _s "${_s}")
+    STRING(REGEX REPLACE "!d" ".*" _s "${_s}")
+    STRING(REGEX REPLACE "!s" "[^/]*" _s "${_s}")
+    STRING(REGEX REPLACE "!q" "[^/]" _s "${_s}")
+    STRING(REGEX REPLACE "!e" "!" _s "${_s}")
+    STRING(LENGTH "${_s}" _len)
+    MATH(EXPR _l ${_len}-1)
+    STRING(SUBSTRING "${_s}" ${_l} 1 _t)
+    IF( _t STREQUAL "/")
+	SET(_s "/${_s}")
+    ELSE( _t STREQUAL "/")
+	SET(_s "${_s}\$")
+    ENDIF( _t STREQUAL "/")
+    SET(${var} "${_s}" PARENT_SCOPE)
+ENDFUNCTION(GIT_GLOB_TO_CMAKE_REGEX)
+
diff -Nura ibus-chewing-1.6.1/Modules/ManageGConf.cmake ibus-chewing-1.6.1_new/Modules/ManageGConf.cmake
--- ibus-chewing-1.6.1/Modules/ManageGConf.cmake	1970-01-01 08:00:00.000000000 +0800
+++ ibus-chewing-1.6.1_new/Modules/ManageGConf.cmake	2015-12-17 17:43:31.000000000 +0800
@@ -0,0 +1,84 @@
+# - GConf relative targets such as install/unstall schemas.
+# This module finds gconftool-2 or gconftool for GConf manipulation.
+#
+# Defines the following macros:
+#   MANAGE_GCONF_SCHEMAS([FILE <schemasFile>] 
+#       [INSTALL_DIR <dir>] [CONFIG_SOURCE <source>]
+#     )
+#     - Process schemas file.
+#       * Parameters:
+#         + FILE <schemasFile>: (Optional) Path to GConf .schema.
+#           Default: ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}.schemas
+#         + INSTALL_DIR <dir>: (Optional) Directory to install GConf .schemas file.
+#	    Default: ${SYSCONF_DIR}/gconf/schemas
+#         + CONFIG_SOURCE <source>: (Optional) Configuration source.
+#           Default: "" (Use the system default) 
+#       * Variables to cache:
+#         + GCONF2_PKG_CONFIG: GConf2 pkg-config name
+#           Default: gconf-2.0
+#         + GCONF2_DEVEL_PACKAGE_NAME: GConf2 devel package name
+#           Default: GConf2-devel
+#       * Defines following targets:
+#         + install_schemas: install schemas.
+#         + uninstall_schemas: uninstall schemas.
+#
+
+IF(DEFINED _MANAGE_GCONF_CMAKE_)
+    RETURN()
+ENDIF(DEFINED _MANAGE_GCONF_CMAKE_)
+SET(_MANAGE_GCONF_CMAKE_ DEFINED)
+INCLUDE(ManageDependency)
+SET(GCONF2_PKG_CONFIG "gconf-2.0" CACHE STRING "GConf2 pkg-config name")
+SET(GCONF2_PACKAGE_NAME "GConf2" CACHE STRING "GConf2 package name")
+SET(GCONF2_DEVEL_PACKAGE_NAME "GConf2-devel" CACHE STRING "GConf2 devel package name")
+MANAGE_DEPENDENCY(REQUIRES GCONF2 REQUIRED PACKAGE_NAME "GConf2")
+MANAGE_DEPENDENCY(BUILD_REQUIRES GCONF2 REQUIRED 
+    PKG_CONFIG ${GCONF2_PKG_CONFIG} PACKAGE_NAME "${GCONF2_DEVEL_PACKAGE_NAME}"
+    )
+MANAGE_DEPENDENCY(REQUIRES_PRE GCONF2 REQUIRED 
+    PACKAGE_NAME "${GCONF2_PACKAGE_NAME}"
+    )
+MANAGE_DEPENDENCY(REQUIRES_PREUN GCONF2 REQUIRED 
+    PACKAGE_NAME "${GCONF2_PACKAGE_NAME}"
+    )
+MANAGE_DEPENDENCY(REQUIRES_POST GCONF2 REQUIRED 
+    PACKAGE_NAME "${GCONF2_PACKAGE_NAME}"
+    )
+
+SET(MANAGE_GCONF_SCHEMAS_VALID_OPTIONS "FILE" "INSTALL_DIR" "CONFIG_SOURCE")
+FUNCTION(MANAGE_GCONF_SCHEMAS)
+    INCLUDE(ManageVersion)
+    VARIABLE_PARSE_ARGN(_o MANAGE_GCONF_SCHEMAS_VALID_OPTIONS ${ARGN})
+
+    IF(NOT _o_FILE)
+	SET(_o_FILE "${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}.schemas")
+    ENDIF()
+
+    GET_FILENAME_COMPONENT(schemasBasename ${_o_FILE} NAME)
+
+    IF(NOT _o_INSTALL_DIR)
+	SET(_o_INSTALL_DIR  "${SYSCONF_DIR}/gconf/schemas")
+    ENDIF()
+
+
+    ADD_CUSTOM_TARGET(uninstall_schemas
+	COMMAND GCONF_CONFIG_SOURCE=${_o_CONFIG_SOURCE}
+	${GCONF2_EXECUTABLE} --makefile-uninstall-rule
+	"${_o_INSTALL_DIR}/${schemasBasename}"
+	COMMENT "uninstall_schemas"
+	VERBATIM
+	)
+
+    ADD_CUSTOM_TARGET(install_schemas
+	COMMAND ${CMAKE_COMMAND} -E copy "${_o_FILE}" "${_o_INSTALL_DIR}/${schemasBasename}"
+	COMMAND GCONF_CONFIG_SOURCE=${GCONF_CONFIG_SOURCE}
+	${GCONF2_EXECUTABLE} --makefile-install-rule
+	"${_o_INSTALL_DIR}/${schemasBasename}"
+	DEPENDS "${_o_FILE}"
+	COMMENT "install_schemas"
+	VERBATIM
+	)
+
+    INSTALL(FILES ${_o_FILE} DESTINATION "${SYSCONF_DIR}/gconf/schemas")
+ENDFUNCTION(MANAGE_GCONF_SCHEMAS)
+
diff -Nura ibus-chewing-1.6.1/Modules/ManageGettextScript.cmake ibus-chewing-1.6.1_new/Modules/ManageGettextScript.cmake
--- ibus-chewing-1.6.1/Modules/ManageGettextScript.cmake	1970-01-01 08:00:00.000000000 +0800
+++ ibus-chewing-1.6.1_new/Modules/ManageGettextScript.cmake	2015-12-17 17:43:31.000000000 +0800
@@ -0,0 +1,251 @@
+# Manage Gettext scripts 
+MACRO(MANAGE_GETTEXT_SCRIPT_PRINT_USAGE)
+    MESSAGE(
+	"Manage gettext script: This script is not recommend for end users
+
+cmake -D cmd=pot_make
+	-D pot=<path/project.pot>
+	-D \"exec:STRING=<cmd;--opt1;--opt2;value; ...>\"
+	[\"-D<var>=<value>\"]
+	[\"-D <var:TYPE>=<value>\"]
+	-P <CmakeModulePath>/ManageGettextScript.cmake
+    Update or create a POT file.
+    Options:
+	pot: Path to pot file
+	exec:STRING: Command and options to create the POT file.
+	    Note that \"STRING\" is needed, as its quite likely to pass the options 
+	    like: \"--keyword=C_:1c,2;--keyword=NC_:1c,2\" which make cmake failed to
+	    set the exec variable.
+
+cmake -D cmd=po_make
+      -D pot=<path/project.pot>
+      [-D \"options:STRING=<--opt1;--opt2;value; ...>\"]
+      [\"-Dlocales=<locale1;locale2...>\"  | -Dsystem_locales]
+      [-Dpo_dir=<dir>]
+      [\"-D<var>=<value>\"]
+      [\"-D <var:TYPE>=<value>\"]
+      -P <CmakeModulePath>/ManageGettextScript.cmake
+    Update existing or create new PO files.
+    Specifiy the PO of locales to be managed by either 
+    locales or system_locales.
+    If both are not specified, it will find the existing PO files. 
+    Options:
+	pot: Path to pot file
+	options: Options to pass to msgmerge
+	    Note that \"STRING\" is needed, as its quite likely to pass the options 
+	    like: \"--keyword=C_:1c,2;--keyword=NC_:1c,2\" which make cmake failed to
+	    set the exec variable.
+	locales: Locale to be created
+	system_locales: All locales in system would be created.
+	po_dir: Directory to put po, otherwise it would use the path to pot.
+
+cmake -D cmd=mo_make
+      -D po_dir=<dir>
+      [-D mo_dir=<dir>]
+      [-D \"options=<--opt1;--opt2=value; ...>\"
+      [-D \"locales=<locale1;locale2...>\"  | -Dsystem_locales]
+      [-D \"<var>=<value>\"]
+      -P <CmakeModulePath>/ManageGettextScript.cmake
+    Update or create MO files.
+    Options:
+	prj_info: Path to prj_info.cmake
+	po_dir: Directory that contains po.
+	mo_dir: Directory to output mo.
+	options:STRING: Options to pass to msgmerge
+	    Note that \"STRING\" is needed, as its quite likely to pass the options 
+	    like: \"--keyword=C_:1c,2;--keyword=NC_:1c,2\" which make cmake failed to
+	    set the exec variable.
+	locales: Locale to be created
+	system_locales: All locales in system would be created.
+
+cmake -D cmd=find_locales
+      [-D po_dir=<dir>]
+      [-Dsystem_locales]
+      [-D \"<var>=<value>\"]
+      -P <CmakeModulePath>/ManageGettextScript.cmake
+    Find locales from local system.
+    Options:
+	po_dir: Base directory that contains po.
+	system_locales: All locales in system would be created.
+	options:STRING: Options to pass to msgmerge
+	    Note that \"STRING\" is needed, as its quite likely to pass the options 
+	    like: \"--keyword=C_:1c,2;--keyword=NC_:1c,2\" which make cmake failed to
+	    set the exec variable.
+    "
+    )
+ENDMACRO(MANAGE_GETTEXT_SCRIPT_PRINT_USAGE)
+
+FUNCTION(CMD_TO_LIST listVar cmd)
+    SET(_listNew "")
+    FOREACH(_l ${cmd})
+	IF( "${_l}" MATCHES "^-.+=.+")
+	    SETTING_STRING_GET_VARIABLE(_k _v "${_l}")
+	    LIST(APPEND _listNew "${_k}" "${_v}")
+	ELSE()
+	    LIST(APPEND _listNew "${_l}")
+	ENDIF()
+    ENDFOREACH(_l)
+    SET(${listVar} "${_listNew}" PARENT_SCOPE)
+ENDFUNCTION(CMD_TO_LIST)
+
+FUNCTION(FIND_LOCALES localeListVar)
+    SET(_gettext_locale_opts "")
+    IF(DEFINED system_locales)
+	LIST(APPEND _gettext_locale_opts "SYSTEM_LOCALES")
+    ELSEIF(NOT "${locales}" STREQUAL "")
+	LIST(APPEND _gettext_locale_opts "LOCALES" ${locales})
+    ENDIF()
+    MANAGE_GETTEXT_LOCALES(v WORKING_DIRECTORY "${po_dir}" ${_gettext_locale_opts})
+    SET(${localeListVar} "${v}" PARENT_SCOPE)
+ENDFUNCTION(FIND_LOCALES)
+
+MACRO(FIND_LOCALES_VARIABLE_CHECK)
+    IF("${po_dir}" STREQUAL "")
+	SET(po_dir ".")
+    ENDIF()
+    IF(NOT EXISTS ${po_dir})
+	M_MSG(${M_FATAL} "Failed to find ${po_dir}")
+    ENDIF()
+    FIND_LOCALES(localeList)
+    M_OUT(${localeList})
+ENDMACRO(FIND_LOCALES_VARIABLE_CHECK)
+
+MACRO(POT_MAKE)
+    EXECUTE_PROCESS(COMMAND ${exec}
+	RESULT_VARIABLE _res
+	OUTPUT_VARIABLE _out
+	ERROR_VARIABLE _err
+	OUTPUT_STRIP_TRAILING_WHITESPACE
+	)
+    IF(NOT _res EQUAL 0)
+	M_MSG(${M_FATAL} "Failed ${exec}: ${_out} | ${_err}")
+    ENDIF()
+ENDMACRO(POT_MAKE)
+
+MACRO(POT_MAKE_VARIABLE_CHECK)
+    IF("${pot}" STREQUAL "")
+	M_MSG(${M_FATAL} "Requires \"-Dpot=<path/project.pot>\"")
+    ENDIF()
+    IF("${exec}" STREQUAL "")
+	M_MSG(${M_FATAL} "Requires \"-Dexec=<cmd;--opt1;...>\"")
+    ENDIF()
+    POT_MAKE()
+ENDMACRO(POT_MAKE_VARIABLE_CHECK)
+
+MACRO(PO_MAKE)
+    FIND_LOCALES(localeList)
+    FOREACH(_l ${localeList})
+	SET(_poFile "${po_dir}/${_l}.po")
+	IF(EXISTS ${_poFile})
+	    SET(exec "msgmerge" "--lang=${_l}" ${options} ${pot} ${_poFile})
+	ELSE()
+	    ## Po file does not exist, run msginit
+	    SET(exec "msginit" "--locale=${_l}.utf8" 
+		"--input=${pot}" "--output-file=${_poFile}"
+		"--no-translator"
+		)
+	ENDIF()
+	EXECUTE_PROCESS(COMMAND ${exec}
+	    RESULT_VARIABLE _res
+	    OUTPUT_VARIABLE _out
+	    ERROR_VARIABLE _err
+	    OUTPUT_STRIP_TRAILING_WHITESPACE
+	    )
+	IF(NOT _res EQUAL 0)
+	    M_MSG(${M_FATAL} "Failed ${exec}: ${_out} | ${_err}")
+	ENDIF()
+    ENDFOREACH(_l)
+ENDMACRO(PO_MAKE)
+
+MACRO(PO_MAKE_VARIABLE_CHECK)
+    IF("${pot}" STREQUAL "")
+	M_MSG(${M_FATAL} "Requires -D \"pot=<path/project.pot>\"")
+    ENDIF()
+    IF(NOT EXISTS ${pot})
+	M_MSG(${M_FATAL} "Failed to find ${pot}")
+    ENDIF()
+    PO_MAKE()
+ENDMACRO(PO_MAKE_VARIABLE_CHECK)
+
+MACRO(MO_MAKE)
+    FIND_LOCALES(localeList)
+    FOREACH(_l ${localeList})
+	SET(exec "msgfmt" "--locale=${_l}" ${options} -o ${mo_dir}/${_l}.gmo ${po_dir}/${_l}.po)
+	EXECUTE_PROCESS(COMMAND ${exec}
+	    RESULT_VARIABLE _res
+	    OUTPUT_VARIABLE _out
+	    ERROR_VARIABLE _err
+	    OUTPUT_STRIP_TRAILING_WHITESPACE
+	    )
+	IF(NOT _res EQUAL 0)
+	    M_MSG(${M_FATAL} "Failed ${exec}: ${_out} | ${_err}")
+	ENDIF()
+    ENDFOREACH(_l)
+ENDMACRO(MO_MAKE)
+
+MACRO(MO_MAKE_VARIABLE_CHECK)
+    IF("${po_dir}" STREQUAL "")
+	M_MSG(${M_FATAL} "Requires -D \"po_dir=<dir>\"")
+    ENDIF()
+    IF(NOT EXISTS ${po_dir})
+	M_MSG(${M_FATAL} "Failed to find ${po_dir}")
+    ENDIF()
+    MO_MAKE()
+ENDMACRO(MO_MAKE_VARIABLE_CHECK)
+
+SET(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS ON)
+#######################################
+# Determine CMAKE_FEDORA_MODULE_DIR
+#
+
+## It is possible that current dir is in NO_PACK/FedPkg/<prj>
+LIST(INSERT CMAKE_MODULE_PATH 0
+    ${CMAKE_SOURCE_DIR}/Modules ${CMAKE_SOURCE_DIR}/cmake-fedora/Modules 
+    ${CMAKE_SOURCE_DIR}/../../../Modules
+    ${CMAKE_SOURCE_DIR}/../../../cmake-fedora/Modules
+    ${CMAKE_SOURCE_DIR}
+    )
+
+IF(CMAKE_SCRIPT_MODE_FILE)
+    GET_FILENAME_COMPONENT(CMAKE_FEDORA_SCRIPT_DIR ${CMAKE_SCRIPT_MODE_FILE}
+	PATH)
+    LIST(INSERT CMAKE_MODULE_PATH 0 "${CMAKE_FEDORA_SCRIPT_DIR}")
+ENDIF()
+
+IF(cmake_fedora_module_dir)
+    LIST(INSERT CMAKE_MODULE_PATH 0 "${cmake_fedora_module_dir}")
+ENDIF()
+
+INCLUDE(ManageMessage RESULT_VARIABLE MANAGE_MODULE_PATH)
+IF(NOT MANAGE_MODULE_PATH)
+    MESSAGE(FATAL_ERROR "ManageMessage.cmake cannot be found in ${CMAKE_MODULE_PATH}")
+ENDIF()
+GET_FILENAME_COMPONENT(CMAKE_FEDORA_MODULE_DIR 
+    "${MANAGE_MODULE_PATH}" PATH
+    )
+
+INCLUDE(ManageEnvironmentCommon)
+INCLUDE(ManageString)
+INCLUDE(ManageVariable)
+INCLUDE(ManageFile)
+INCLUDE(ManageTranslation)
+
+IF(NOT DEFINED cmd)
+    MANAGE_GETTEXT_SCRIPT_PRINT_USAGE()
+ELSE()
+    IF("${cmd}" STREQUAL "pot_make")
+	#POT_MAKE_VARIABLE_CHECK()
+    ELSEIF("${cmd}" STREQUAL "po_make")
+	PO_MAKE_VARIABLE_CHECK()
+    ELSEIF("${cmd}" STREQUAL "mo_make")
+	MO_MAKE_VARIABLE_CHECK()
+    ELSEIF("${cmd}" STREQUAL "find_locales")
+	FIND_LOCALES_VARIABLE_CHECK()
+    ELSE()
+	MANAGE_GETTEXT_SCRIPT_PRINT_USAGE()
+	M_MSG(${M_FATAL} "Invalid cmd ${cmd}")
+    ENDIF()
+ENDIF()
+
+
+
diff -Nura ibus-chewing-1.6.1/Modules/ManageGitScript.cmake ibus-chewing-1.6.1_new/Modules/ManageGitScript.cmake
--- ibus-chewing-1.6.1/Modules/ManageGitScript.cmake	1970-01-01 08:00:00.000000000 +0800
+++ ibus-chewing-1.6.1_new/Modules/ManageGitScript.cmake	2015-12-17 17:43:31.000000000 +0800
@@ -0,0 +1,99 @@
+# - Manage Git Script
+# Scripts to be invoked in command line
+#
+
+MACRO(MANAGE_GIT_SCRIPT_PRINT_USAGE)
+    MESSAGE("cmake-fedora utility scripts
+
+cmake -D cmd=make_tag_file 
+    -D ver=<ver> -D output_file=<output_file>
+    [-D \"msg=<message>\"]
+    [-D cmake_fedora_module_dir=<dir>]
+    [\"-D <VAR>=<VAULE>\"]
+    -P <CmakeModulePath>/ManageGitScript.cmake
+  Make a tag file, which indicates the build process is passed and 
+  the branch is tagged with <ver>.
+
+  Options:
+     ver: project version
+     outputFile: Tag file
+     msg: message associate with tag
+     cmake_fedora_module_dir: 
+        Specify this if cmake and cmake-fedora failed to find 
+        the location of CMake Fedora modules. 
+
+    ")
+ENDMACRO(MANAGE_GIT_SCRIPT_PRINT_USAGE)
+
+FUNCTION(MAKE_TAG_FILE)
+    EXECUTE_PROCESS(
+	COMMAND git tag -l ${ver}
+	OUTPUT_VARIABLE tagLine
+	OUTPUT_STRIP_TRAILING_WHITESPACE
+	)
+    IF("${msg}" STREQUAL "")
+	SET(msg "${ver}")
+    ENDIF()
+
+    IF("${tagLine}" STREQUAL "")
+	## No tag
+	EXECUTE_PROCESS(
+	    COMMAND make VERBOSE=1 tag_pre
+	    RESULT_VARIABLE tagResult
+	    )
+	IF(NOT tagResult EQUAL 0)
+	    M_MSG(${M_FATAL} "Failed to build before tagging")
+	ENDIF()
+	EXECUTE_PROCESS(COMMAND git tag -a -m "${msg}" "${ver}" HEAD)
+    ENDIF()
+    FILE(WRITE "${output_file}" "${msg}")
+
+ENDFUNCTION(MAKE_TAG_FILE)
+
+SET(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS ON)
+
+#######################################
+# Determine CMAKE_FEDORA_MODULE_DIR
+#
+
+## It is possible that current dir is in NO_PACK/FedPkg/<prj>
+LIST(INSERT CMAKE_MODULE_PATH 0
+    ${CMAKE_SOURCE_DIR}/Modules ${CMAKE_SOURCE_DIR}/cmake-fedora/Modules 
+    ${CMAKE_SOURCE_DIR}/../../../Modules
+    ${CMAKE_SOURCE_DIR}/../../../cmake-fedora/Modules
+    ${CMAKE_SOURCE_DIR}
+    )
+
+IF(CMAKE_SCRIPT_MODE_FILE)
+    GET_FILENAME_COMPONENT(CMAKE_FEDORA_SCRIPT_DIR ${CMAKE_SCRIPT_MODE_FILE}
+	PATH)
+    LIST(INSERT CMAKE_MODULE_PATH 0 "${CMAKE_FEDORA_SCRIPT_DIR}")
+ENDIF()
+
+IF(cmake_fedora_module_dir)
+    LIST(INSERT CMAKE_MODULE_PATH 0 "${cmake_fedora_module_dir}")
+ENDIF()
+
+INCLUDE(ManageMessage RESULT_VARIABLE MANAGE_MODULE_PATH)
+IF(NOT MANAGE_MODULE_PATH)
+    MESSAGE(FATAL_ERROR "ManageMessage.cmake cannot be found in ${CMAKE_MODULE_PATH}")
+ENDIF()
+INCLUDE(ManageFile)
+
+IF(NOT DEFINED cmd)
+    MANAGE_GIT_SCRIPT_PRINT_USAGE()
+ELSEIF(cmd STREQUAL "make_tag_file")
+    IF(NOT ver)
+	MANAGE_GIT_SCRIPT_PRINT_USAGE()
+	M_MSG(${M_FATAL} "Requires -D ver=<ver>")
+    ENDIF()
+    IF(NOT output_file)
+	MANAGE_GIT_SCRIPT_PRINT_USAGE()
+	M_MSG(${M_FATAL} "Requires -D output_file=<output_file>")
+    ENDIF()
+    MAKE_TAG_FILE()
+ELSE()
+    MANAGE_GIT_SCRIPT_PRINT_USAGE()
+    M_MSG(${M_FATAL} "Invalid cmd ${cmd}")
+ENDIF()
+
diff -Nura ibus-chewing-1.6.1/Modules/ManageMessage.cmake ibus-chewing-1.6.1_new/Modules/ManageMessage.cmake
--- ibus-chewing-1.6.1/Modules/ManageMessage.cmake	1970-01-01 08:00:00.000000000 +0800
+++ ibus-chewing-1.6.1_new/Modules/ManageMessage.cmake	2014-10-28 13:05:31.000000000 +0800
@@ -0,0 +1,71 @@
+# - Manage the output and debug messages.
+# This module has macros that control how many messages to be shown
+# by defining the desire message level.
+#
+# Defined variables that represent verbose levels:
+#   1: M_FATAL - Critical error,Should stop immediately
+#   2: M_ERROR - Error that will Eventually fail
+#   3: M_WARN  - General Warning.
+#   4: M_OFF   - Optional functionalities are turned-off because requirement is not met.
+#   5: M_INFO1 - Info/debug message
+#   6: M_INFO2 - Info/debug message
+#   7: M_INFO3 - Info/debug message
+#
+# Read following variable:
+#   + MANAGE_MESSAGE_LEVEL: Message level in integer.
+#     Messages with greater level will be suppressed.
+#     Default is ${M_OFF}
+#   + MANAGE_MESSAGE_LABELS: Labels that printed in front of the message for
+#     corresponding message level.
+#     Default is "[Fatal] ;[Error] ;[Warn] ;[Off] ;[Info1] ;[Info2] ;[Info3] ")
+#
+# Define following functions:
+#   M_MSG(<level> <msg>)
+#   - Surpress the message if level is higher than MANAGE_MESSAGE_LEVEL
+#     Otherwise show the message.
+#     * Parameters:
+#       + level: level of the message.
+#       + msg: Message to show.
+#
+#   M_OUT(<msg>)
+#   - Output the message to stdout
+#     In cmake-2.6.2, MESSAGE(...) output to stderr.
+#     This function make it output to stdout instead.
+#     * Parameters:
+#       + msg: Message to show.
+
+IF(DEFINED _MANAGE_MESSAGE_CMAKE_)
+    RETURN()
+ENDIF(DEFINED _MANAGE_MESSAGE_CMAKE_)
+SET(_MANAGE_MESSAGE_CMAKE_ "DEFINED")
+
+SET(M_FATAL 1)
+SET(M_ERROR 2)
+SET(M_WARN 3)
+SET(M_OFF  4)
+SET(M_INFO1 5)
+SET(M_INFO2 6)
+SET(M_INFO3 7)
+IF(NOT DEFINED MANAGE_MESSAGE_LABELS)
+    SET(MANAGE_MESSAGE_LABELS
+	"[Fatal] ;[Error] ;[Warn] ;[Off] ;[Info1] ;[Info2] ;[Info3] ")
+ENDIF(NOT DEFINED MANAGE_MESSAGE_LABELS)
+
+SET(MANAGE_MESSAGE_LEVEL ${M_OFF} CACHE STRING "Message (Verbose) Level")
+
+MACRO(M_MSG level)
+    IF(NOT ${level} GREATER ${MANAGE_MESSAGE_LEVEL})
+	MATH(EXPR _lvl ${level}-1)
+	LIST(GET MANAGE_MESSAGE_LABELS ${_lvl} _label)
+	IF(${level} EQUAL 1)
+	    MESSAGE(FATAL_ERROR "${_label}${ARGN}")
+	ELSE(${level} EQUAL 1)
+	    MESSAGE("${_label}${ARGN}")
+	ENDIF(${level} EQUAL 1)
+    ENDIF(NOT ${level} GREATER ${MANAGE_MESSAGE_LEVEL})
+ENDMACRO(M_MSG level)
+
+FUNCTION(M_OUT)
+    EXECUTE_PROCESS(COMMAND ${CMAKE_COMMAND} -E echo "${ARGN}")
+ENDFUNCTION(M_OUT)
+
diff -Nura ibus-chewing-1.6.1/Modules/ManageRelease.cmake ibus-chewing-1.6.1_new/Modules/ManageRelease.cmake
--- ibus-chewing-1.6.1/Modules/ManageRelease.cmake	1970-01-01 08:00:00.000000000 +0800
+++ ibus-chewing-1.6.1_new/Modules/ManageRelease.cmake	2016-01-07 15:39:34.000000000 +0800
@@ -0,0 +1,60 @@
+# - Manage release by provides release related targets.
+#
+# Included Modules:
+#   - ManageMessage
+#   - ManageVariable
+#
+#  Defines following functions:
+#  MANAGE_RELEASE([<releaseTarget ...>] [DEPENDS <dependFile ...>])
+#    - Run release targets.
+#      This macro skips the missing targets so distro package maintainers
+#      do not have to get the irrelevant dependencies.
+#      For the "hard" dependency, use cmake command "ADD_DEPENDENCIES".
+#      * Parameters:
+#        + releaseTarget ...: Targets to be executed before a release.
+#          Note that sequence of the targets does not guarantee the
+#          sequence of execution.
+#        + DEPENDS dependFile ...: Files that target "release" depends on.
+#      * Defines following targets:
+#        + release: Perform everything required for a release.
+#
+
+IF(DEFINED _MANAGE_RELEASE_CMAKE_)
+    RETURN()
+ENDIF(DEFINED _MANAGE_RELEASE_CMAKE_)
+SET(_MANAGE_RELEASE_CMAKE_ "DEFINED")
+INCLUDE(ManageMessage)
+INCLUDE(ManageVariable)
+
+FUNCTION(MANAGE_RELEASE)
+    SET(_validOptions "DEPENDS")
+    VARIABLE_PARSE_ARGN(_o _validOptions ${ARGN})
+    SET(_releaseDependOptList "")
+
+    IF(NOT "${_o_DEPENDS}" STREQUAL "")
+	SET(_releaseDependOptList DEPENDS ${_o_DEPENDS})
+    ENDIF(NOT "${_o_DEPENDS}" STREQUAL "")
+
+    ADD_CUSTOM_TARGET(release
+	${_releaseDependOptList}
+	COMMENT "release: ${PROJECT_NAME}-${PRJ_VER}"
+	)
+
+    IF(TARGET tag)
+	ADD_DEPENDENCIES(release tag)
+    ENDIF(TARGET tag)
+
+    ## Add dependent targets that actually exists
+    SET(_releaseTargets "")
+    FOREACH(_target ${_o})
+	IF(TARGET ${_target})
+	    LIST(APPEND _releaseTargets "${_target}")
+	    ## Release targets should be build after target tag
+	    ADD_DEPENDENCIES(${_target} tag)
+	    ADD_DEPENDENCIES(release ${_target})
+	ELSE(TARGET ${_target})
+	    M_MSG(${M_OFF} "MANAGE_RELEASE: Target ${_target} does not exist, skipped.")
+	ENDIF(TARGET ${_target})
+    ENDFOREACH(_target)
+ENDFUNCTION(MANAGE_RELEASE)
+
diff -Nura ibus-chewing-1.6.1/Modules/ManageReleaseFedora.cmake ibus-chewing-1.6.1_new/Modules/ManageReleaseFedora.cmake
--- ibus-chewing-1.6.1/Modules/ManageReleaseFedora.cmake	1970-01-01 08:00:00.000000000 +0800
+++ ibus-chewing-1.6.1_new/Modules/ManageReleaseFedora.cmake	2014-10-28 13:05:31.000000000 +0800
@@ -0,0 +1,253 @@
+# - Manage Fedora and EPEL releases.
+#
+# This module provides convenient targets and functions for Fedora and 
+# EPEL releases with fedpkg, koji, and bodhi.
+# 
+# In cmake-fedora, this release steps are:
+#  1. Create SRPM and RPMs
+#  2. Whether SRPM and RPMs pass rpmlint
+#  3. Whether SRPM can be build with koji scratch build
+#  4. Tag the release with PRJ_VER
+#  5. Build SRPM with FedPkg
+#  6. Release to Bodhi
+#
+# Consequently, function RELEASE_FEDORA() should be run after 
+# PACK_RPM() and source version control functions like
+# MANAGE_SOURCE_VERSION_CONTROL_GIT().
+#
+# If CMAKE_FEDORA_ENABLE_FEDORA=1, this module will proceed;
+# otherwise, this module is skipped.
+#
+# This module check following files for dependencies:
+#   - ~/.fedora-upload-ca.cert : Ensure it has certificate file to
+#     submit to Fedora.
+#   - fedpkg : Required to submit to fedora.
+#   - koji : Required to submit to fedora.
+#   - bodhi : Required to submit to fedora.
+# If any of above files are missing, this module will be skipped.
+#
+# This module read the supported release information from 
+# cmake-fedora.conf, it finds cmake-fedora.conf in following order:
+#  1. Current directory
+#  2. Path as defined CMAKE_SOURCE_DIR
+#  3. /etc/cmake-fedora.conf
+#
+# Included Modules:
+#   - ManageFile
+#   - ManageMessage
+#   - ManageTarget
+#   - ManageRPM
+#   - ManageVariable
+#
+# Reads following variables:
+#   - CMAKE_FEDORA_TMP_DIR
+#   - PRJ_SRPM_FILE: Project 
+#
+# Defines following variables:
+#   - CMAKE_FEDORA_CONF: Path to cmake_fedora.conf
+#   - FEDPKG_EXECUTABLE: Path to fedpkg
+#   - KOJI_EXECUTABLE: Path to koji
+#   - GIT_EXECUTABLE: Path to git
+#   - BODHI_EXECUTABLE: Path to bodhi
+#   - KOJI_BUILD_SCRATCH_EXECUTABLE: Path to koji-build-scratch
+#   - FEDPKG_DIR: Dir for FedPkg checkout. 
+#       It will use environment variable FEDPKG_DIR, then use
+#       ${CMAKE_FEDORA_TMP_DIR}/FedPkg.
+#   - FEDORA_KAMA: Fedora Karma. Default:3
+#   - FEDORA_UNSTABLE_KARMA: Fedora unstable Karma. Default:3
+#
+# Defines following functions:
+#   RELEASE_FEDORA([<scope> ...] 
+#       [DEPENDS <dependFile> ...]
+#       [TARGETS <target> ...]
+#     )
+#     - Release this project to specified Fedora and EPEL releases.
+#       * Parameters:
+#         + scope ...: List of Fedora and EPEL release to be build.
+#           Valid values:
+#           - rawhide: Build rawhide.
+#           - fedora: Build actives fedora releases, including Rawhide.
+#           - fedora_1: Build the latest supported fedora releases.
+#             This is one release eariler than rawhide.
+#           - fedora_2: Build the second latest supported fedora releases.
+#             This is two releases eariler than rawhide.
+#           - f22 f21 ...: Build the specified fedora releases.
+#           - epel: Build the currently supported EPEL releases.
+#           - epel_1: Build the latest supported EPEL releases.
+#           - epel_2: Build the second latest supported EPEL releases.
+#           - el7 el6 ... : The EPEL releases to be built.
+#           If not specified, "fedora epel" will be used.
+#         + DEPENDS dependFile ...: Files that target "release-fedora"
+#             depends on.
+#         + TARGETS target ...: Targets that target "release-fedora"
+#             depends on. 
+#             Note that if a target does not exist, a M_ERROR message 
+#             will be shown.
+#
+#       * Reads following variables:
+#         + PRJ_SRPM_FILE: Project SRPM
+#         + FEDPKG_DIR: Directory for fedpkg checkout.
+#       * Defines following targets:
+#         + fedpkg_build: Build with fedpkg and push to bodhi.
+#            This depends on the tag file from source control
+#            (i.e. MANAGE_SOURCE_VERSION_CONTROL_TAG_FILE)
+#         + koji_build_scratch: Scratch build using koji.
+#            This depends on target "rpmlint".
+#            Target "tag_pre" should be dependent on this target.
+#            A M_ERROR message will shown if target "tag_pre" does not
+#            exist.
+#         + release_fedora: Releases on fedora and/or EPEL.
+#            This depends on target "fedpkg_build".
+#            After this target is built, release on Fedora should be
+#            completed.
+#
+
+IF(NOT CMAKE_FEDORA_ENABLE_FEDORA_BUILD)
+    RETURN()
+ENDIF(NOT CMAKE_FEDORA_ENABLE_FEDORA_BUILD)
+IF(DEFINED _MANAGE_RELEASE_FEDORA_)
+    RETURN()
+ENDIF(DEFINED _MANAGE_RELEASE_FEDORA_)
+SET(_MANAGE_RELEASE_FEDORA_ "DEFINED")
+INCLUDE(ManageMessage)
+INCLUDE(ManageFile)
+INCLUDE(ManageTarget)
+INCLUDE(ManageRPM)
+INCLUDE(ManageVariable)
+SET(_manage_release_fedora_dependencies_missing 0)
+
+MANAGE_CMAKE_FEDORA_CONF(CMAKE_FEDORA_CONF
+    ERROR_MSG "cmake-fedora.conf not found. Fedora release support disabled."
+    ERROR_VAR _manage_release_fedora_dependencies_missing
+    VERBOSE_LEVEL ${M_OFF}
+    )
+
+MACRO(RELEASE_FEDORA_FIND_FILE_DEPENDENCY var name)
+    FIND_FILE_ERROR_HANDLING(${var}
+	ERROR_MSG "${name} not found, Fedora release support disabled."
+	ERROR_VAR _manage_release_fedora_dependencies_missing
+	VERBOSE_LEVEL ${M_OFF}
+	FIND_ARGS NAMES ${name} ${ARGN}
+	)
+ENDMACRO(RELEASE_FEDORA_FIND_FILE_DEPENDENCY)
+
+MACRO(RELEASE_FEDORA_FIND_DEPENDENCY var name)
+    FIND_PROGRAM_ERROR_HANDLING(${var}
+	ERROR_MSG "${name} not found, Fedora release support disabled."
+	ERROR_VAR _manage_release_fedora_dependencies_missing
+	VERBOSE_LEVEL ${M_OFF}
+	FIND_ARGS NAMES ${name} ${ARGN}
+	)
+ENDMACRO(RELEASE_FEDORA_FIND_DEPENDENCY var)
+
+RELEASE_FEDORA_FIND_FILE_DEPENDENCY(FEDORA_UPLOAD_CA_CERT 
+    ".fedora-upload-ca.cert" PATHS $ENV{HOME})
+RELEASE_FEDORA_FIND_DEPENDENCY(FEDPKG_EXECUTABLE fedpkg)
+RELEASE_FEDORA_FIND_DEPENDENCY(KOJI_EXECUTABLE koji)
+RELEASE_FEDORA_FIND_DEPENDENCY(GIT_EXECUTABLE git)
+## Workaround for Bug 1115136 otherwise el7 won't work
+RELEASE_FEDORA_FIND_DEPENDENCY(BODHI-CLIENT_EXECUTABLE bodhi client.py 
+    PATHS "/usr/bin/bodhi")
+RELEASE_FEDORA_FIND_DEPENDENCY(CMAKE_FEDORA_KOJI_EXECUTABLE "cmake-fedora-koji"
+    HINTS ${CMAKE_FEDORA_SCRIPT_PATH_HINTS})
+RELEASE_FEDORA_FIND_DEPENDENCY(CMAKE_FEDORA_FEDPKG_EXECUTABLE "cmake-fedora-fedpkg"
+    HINTS ${CMAKE_FEDORA_SCRIPT_PATH_HINTS})
+RELEASE_FEDORA_FIND_DEPENDENCY(KOJI_BUILD_SCRATCH_EXECUTABLE "koji-build-scratch"
+    HINTS ${CMAKE_FEDORA_SCRIPT_PATH_HINTS})
+
+## Set variables
+IF(_manage_release_fedora_dependencies_missing)
+    RETURN()
+ENDIF(_manage_release_fedora_dependencies_missing)
+# Set release tags according to CMAKE_FEDORA_CONF
+SETTING_FILE_GET_ALL_VARIABLES(${CMAKE_FEDORA_CONF})
+
+SET(BODHI_TEMPLATE_FILE "${CMAKE_FEDORA_TMP_DIR}/bodhi.template"
+    CACHE FILEPATH "Bodhi template file"
+    )
+
+GET_ENV(FEDPKG_DIR "${CMAKE_FEDORA_TMP_DIR}/FedPkg" CACHE PATH "FedPkg dir")
+
+## Fedora package variables
+SET(FEDORA_KARMA "3" CACHE STRING "Fedora Karma")
+SET(FEDORA_UNSTABLE_KARMA "-3" CACHE STRING "Fedora unstable Karma")
+
+FUNCTION(RELEASE_FEDORA_KOJI_BUILD_SCRATCH)
+    IF(_manage_release_fedora_dependencies_missing)
+	RETURN()
+    ENDIF(_manage_release_fedora_dependencies_missing)
+    ADD_CUSTOM_TARGET(koji_build_scratch
+	COMMAND ${KOJI_BUILD_SCRATCH_EXECUTABLE} ${PRJ_SRPM_FILE} ${ARGN}
+	DEPENDS "${PRJ_SRPM_FILE}"
+	COMMENT "koji_build_scratch: SRPM=${PRJ_SRPM_FILE}"
+	VERBATIM
+	)
+    ADD_DEPENDENCIES(koji_build_scratch rpmlint)
+    IF(TARGET tag_pre)
+	ADD_DEPENDENCIES(tag_pre koji_build_scratch)
+    ELSE(TARGET tag_pre)
+	M_MSG(${M_ERROR} 
+	    "RELEASE_FEDORA: Target tag_pre does not exist.")
+    ENDIF(TARGET tag_pre)
+ENDFUNCTION(RELEASE_FEDORA_KOJI_BUILD_SCRATCH)
+
+FUNCTION(RELEASE_FEDORA_FEDPKG)
+    IF(_manage_release_fedora_dependencies_missing)
+	RETURN()
+    ENDIF(_manage_release_fedora_dependencies_missing)
+    SET(_cmdOpts "")
+    IF ("${CHANGE_SUMMARY}" STREQUAL "")
+	SET(CHANGE_SUMMARY "Release ${PROJECT_NAME}-${PRJ_VER}")
+    ENDIF("${CHANGE_SUMMARY}" STREQUAL "")
+
+    IF (NOT "${REDHAT_BUGZILLA}" STREQUAL "")
+	LIST(APPEND _cmdOpts "-b" "${REDHAT_BUGZILLA}")
+    ENDIF(NOT "${REDHAT_BUGZILLA}" STREQUAL "")
+
+    ADD_CUSTOM_TARGET(fedpkg_build
+	COMMAND ${CMAKE_FEDORA_FEDPKG_EXECUTABLE} -d "${FEDPKG_DIR}"
+	-m "${CHANGE_SUMMARY}"
+	${_cmdOpts} "${PRJ_SRPM_FILE}" ${ARGN}
+	VERBATIM
+	)
+    ADD_DEPENDENCIES(fedpkg_build tag_post)
+ENDFUNCTION(RELEASE_FEDORA_FEDPKG)
+
+FUNCTION(RELEASE_FEDORA)
+    IF(_manage_release_fedora_dependencies_missing)
+	RETURN()
+    ENDIF(_manage_release_fedora_dependencies_missing)
+
+    ## Parse tags
+    SET(_validOptions "DEPENDS" "TARGETS")
+    VARIABLE_PARSE_ARGN(_o _validOptions ${ARGN})
+    SET(_releaseDependOptList "")
+
+    IF(NOT "${_o_DEPENDS}" STREQUAL "")
+	SET(_releaseDependOptList DEPENDS ${_o_DEPENDS})
+    ENDIF(NOT "${_o_DEPENDS}" STREQUAL "")
+
+    SET(_scopeList ${_o})
+    RELEASE_FEDORA_KOJI_BUILD_SCRATCH(${_scopeList})
+    RELEASE_FEDORA_FEDPKG(${_scopeList})
+    ADD_CUSTOM_TARGET(release_fedora
+	${_releaseDependOptList}
+	COMMENT "release_fedora: ${_scopeList}"
+	)
+    ADD_DEPENDENCIES(release_fedora fedpkg_build)
+
+    ## Add dependent targets that actually exists
+    SET(_releaseTargets "")
+    FOREACH(_target ${_o_TARGETS})
+	IF(TARGET ${_target})
+	    LIST(APPEND _releaseTargets "${_target}")
+	    ## Release targets should be build after target tag
+	    ADD_DEPENDENCIES(${_target} tag)
+	    ADD_DEPENDENCIES(release_fedora ${_target})
+	ELSE(TARGET ${_target})
+	    M_MSG(${M_ERROR} 
+		"RELEASE_FEDORA: Target ${_target} does not exist.")
+	ENDIF(TARGET ${_target})
+    ENDFOREACH(_target)
+ENDFUNCTION(RELEASE_FEDORA)
+
diff -Nura ibus-chewing-1.6.1/Modules/ManageRPM.cmake ibus-chewing-1.6.1_new/Modules/ManageRPM.cmake
--- ibus-chewing-1.6.1/Modules/ManageRPM.cmake	1970-01-01 08:00:00.000000000 +0800
+++ ibus-chewing-1.6.1_new/Modules/ManageRPM.cmake	2014-10-28 13:05:31.000000000 +0800
@@ -0,0 +1,483 @@
+# - RPM generation, maintaining (remove old rpm) and verification (rpmlint).
+# This module provides macros that provides various rpm building and
+# verification targets.
+#
+# This module needs variables from ManageArchive, so
+# INCLUDE(ManageArchive)
+# before this module.
+#
+# Included Modules:
+#   - ManageFile
+#   - ManageTarget
+#   - ManageVariable
+#
+# Reads and defines following variables:
+#   - RPM_SPEC_CMAKE_FLAGS: cmake flags in RPM spec.
+#   - RPM_SPEC_MAKE_FLAGS: "make flags in RPM spec.
+#
+# Reads and defines following variables if dependencies are satisfied:
+#   - PRJ_RPM_SPEC_FILE: spec file for rpmbuild.
+#   - RPM_SPEC_BUILD_ARCH: (optional) Set "BuildArch:"
+#   - RPM_BUILD_ARCH: (optional) Arch that will be built."
+#   - RPM_DIST_TAG: (optional) Current distribution tag such as el5, fc10.
+#     Default: Distribution tag from rpm --showrc
+#
+#   - RPM_BUILD_TOPDIR: (optional) Directory of  the rpm topdir.
+#     Default: ${CMAKE_BINARY_DIR}
+#
+#   - RPM_BUILD_SPECS: (optional) Directory of generated spec files
+#       and RPM-ChangeLog.
+#     Note this variable is not for locating SPEC template file
+#       (i.e. project.spec.in). The SPEC template file should be
+#       specified in PACK_RPM()
+#     Default: ${RPM_BUILD_TOPDIR}/SPECS
+#
+#   - RPM_BUILD_SOURCES: (optional) Directory of source archive files.
+#     Default: ${RPM_BUILD_TOPDIR}/SOURCES
+#
+#   - RPM_BUILD_SRPMS: (optional) Directory of source rpm files.
+#     Default: ${RPM_BUILD_TOPDIR}/SRPMS
+#
+#   - RPM_BUILD_RPMS: (optional) Directory of generated rpm files.
+#     Default: ${RPM_BUILD_TOPDIR}/RPMS
+#
+#   - RPM_BUILD_BUILD: (optional) Directory for RPM build.
+#     Default: ${RPM_BUILD_TOPDIR}/BUILD
+#
+#   - RPM_BUILD_BUILDROOT: (optional) Directory for RPM buildroot.
+#     Default: ${RPM_BUILD_TOPDIR}/BUILDROOT
+#
+#   - RPM_RELEASE_NO: (optional) RPM release number.
+#     Default: 1
+#
+# Defines following variables:
+#   - RPM_IGNORE_FILES: A list of exclude file patterns for PackSource.
+#     This value is appended to SOURCE_ARCHIVE_IGNORE_FILES after
+#     including this module.
+#
+# Defines following Functions:
+#   RPM_SPEC_STRING_ADD(<var> <str> [<position>])
+#   - Add a string to SPEC string.
+#     * Parameters:
+#       + var: Variable that hold results in string format.
+#       + str: String to be added.
+#       + position: (Optional) position to put the tag. 
+#       Valid value: FRONT for inserting in the beginning.
+#       Default: Append in the end of string.
+#       of string.
+#
+#   RPM_SPEC_STRING_ADD_DIRECTIVE <var> <directive> <attribute> <content>)
+#   - Add a SPEC directive (e.g. %description -l zh_TW) to SPEC string.
+#     * Parameters:
+#       + var: Variable that hold results in string format.
+#       + directive: Directive to be added.
+#       + attribute: Attribute of tag. That is, string between '()'
+#       + value: Value fot the tag.
+#       + position: (Optional) position to put the tag. 
+#         Valid value: FRONT for inserting in the beginning.
+#         Default: Append in the end of string.
+#
+#   RPM_SPEC_STRING_ADD_TAG(<var> <tag> <attribute> <value> [<position>])
+#   - Add a SPEC tag (e.g. BuildArch: noarch) to SPEC string.
+#     * Parameters:
+#       + var: Variable that hold results in string format.
+#       + tag: Tag to be added.
+#       + attribute: Attribute of tag. That is, string between '()'
+#       + value: Value fot the tag.
+#       + position: (Optional) position to put the tag. 
+#         Valid value: FRONT for inserting in the beginning.
+#         Default: Append in the end of string.
+#
+# Defines following Macros:
+#   PACK_RPM([SPEC_IN <specInFile>] [SPEC <specFile>]
+#       [CONFIG_REPLACE <file1> ...])
+#     - Generate spec and pack rpm  according to the spec file.
+#       * Parameters:
+#         + SPEC_IN specInFile: RPM SPEC template file as .spec.in
+#         + SPEC specFile: Output RPM SPEC file 
+#           Default: ${RPM_BUILD_SPEC}/${PROJECT_NAME}.spec
+#         + CONFIG_REPLACE <file1> ...: Configure file that should be
+#             replaced after update. 
+#           Example: 
+#              CONFIG_REPLACE ${SYSCONF_DIR}/${PROJECT_NAME}.conf
+#       * Targets:
+#         + srpm: Build srpm (rpmbuild -bs).
+#         + rpm: Build binary rpm (rpmbuild -bb)
+#         + rpmlint: Run rpmlint to generated RPMs.
+#         + install_rpm: Install all RPMs of this version,
+#             excepts debug-info.
+#         + clean_rpm: Clean all rpm and build files.
+#         + clean_pkg": Clean all source packages, rpm and build files.
+#         + clean_old_rpm: Remove old rpm and build files.
+#         + clean_old_pkg: Remove old source packages and rpms.
+#       * Variables defined:
+#         + PRJ_RELEASE: Project release with distribution tags. 
+#           (e.g. 1.fc13)
+#         + RPM_RELEASE_NO: Project release number, without 
+#           distribution tags. (e.g. 1)
+#         + PRJ_SRPM_FILE: Path to generated SRPM file, including
+#           relative path.
+#         + PRJ_RPM_FILES: Binary RPM files to be build.
+#
+#   RPM_MOCK_BUILD([MOCK_CONFIG <mockConfig> ...])
+#     - Add mock related targets.
+#       * Parameters:
+#         + MOCK_CONFIG mockConfig ... : Mock config name without .cfg.
+#            (e.g. fedora-rawhide-i386, epel-7-x86_64)
+#           Default: default
+#       * Targets:
+#         + rpm_mock_<mockConfig>: Build RPM with <mockConfig>.
+#
+
+IF(DEFINED _MANAGE_RPM_CMAKE_)
+    RETURN()
+ENDIF(DEFINED _MANAGE_RPM_CMAKE_)
+SET (_MANAGE_RPM_CMAKE_ "DEFINED")
+
+INCLUDE(ManageFile)
+INCLUDE(ManageTarget)
+SET(_manage_rpm_dependency_missing 0)
+
+# Variables to be passed for SPEC building
+SET(RPM_SPEC_IN_VARIABLE_LIST
+    "REQUIRES"
+    "REQUIRES_PRE"
+    "REQUIRES_PREUN"
+    "REQUIRES_POST"
+    "REQUIRES_POSTUN"
+    "BUILD_REQUIRES"
+    "RPM_SPEC_BUILD_OUTPUT"
+    "RPM_SPEC_SUB_PACKAGE_OUTPUT"
+    "RPM_SPEC_INSTALL_SECTION_OUTPUT"
+    "RPM_SPEC_SCRIPT_OUTPUT"
+    )
+
+SET(RPM_SPEC_CMAKE_FLAGS "-DCMAKE_FEDORA_ENABLE_FEDORA_BUILD=1"
+    CACHE STRING "CMake flags in RPM SPEC"
+    )
+SET(RPM_SPEC_MAKE_FLAGS "VERBOSE=1 %{?_smp_mflags}"
+    CACHE STRING "Make flags in RPM SPEC"
+    )
+
+SET(RPM_SPEC_BUILD_OUTPUT 
+    "%cmake ${RPM_SPEC_CMAKE_FLAGS} .
+make ${RPM_SPEC_MAKE_FLAGS}"
+    )
+
+M_MSG(${M_INFO2} "CMAKE_FEDORA_SCRIPT_PATH_HINTS=${CMAKE_FEDORA_SCRIPT_PATH_HINTS}")
+
+FIND_PROGRAM_ERROR_HANDLING(RPM_EXECUTABLE
+    ERROR_MSG "ManageRPM: rpm not found, rpm build support is disabled."
+    ERROR_VAR _manage_rpm_dependency_missing
+    VERBOSE_LEVEL ${M_OFF}
+    FIND_ARGS NAMES rpm
+    )
+
+FIND_PROGRAM_ERROR_HANDLING(RPMBUILD_CMD
+    ERROR_MSG "ManageRPM: rpmbuild-md5 or rpmbuild not found, rpm build support is disabled."
+    ERROR_VAR _manage_rpm_dependency_missing
+    VERBOSE_LEVEL ${M_OFF}
+    FIND_ARGS NAMES "rpmbuild-md5" "rpmbuild"
+    )
+
+FIND_PROGRAM_ERROR_HANDLING(CMAKE_FEDORA_KOJI_CMD
+    ERROR_MSG "ManageRPM: cmake-fedora-koji not found, rpm build support is disabled."
+    ERROR_VAR _manage_rpm_dependency_missing
+    VERBOSE_LEVEL ${M_OFF}
+    FIND_ARGS NAMES cmake-fedora-koji
+    HINTS  ${CMAKE_FEDORA_SCRIPT_PATH_HINTS}
+    )
+
+
+IF(_manage_rpm_dependency_missing)
+    RETURN()
+ENDIF(_manage_rpm_dependency_missing)
+INCLUDE(ManageVariable)
+CMAKE_FEDORA_CONF_GET_ALL_VARIABLES()
+
+
+## arch
+IF(BUILD_ARCH STREQUAL "noarch")
+    SET(RPM_BUILD_ARCH ${BUILD_ARCH})
+ELSE(BUILD_ARCH STREQUAL "noarch")
+    EXECUTE_PROCESS(COMMAND ${RPM_EXECUTABLE} -E "%{_arch}"
+	COMMAND sed -e "s/^\\.//"
+	OUTPUT_VARIABLE RPM_BUILD_ARCH
+	OUTPUT_STRIP_TRAILING_WHITESPACE
+	)
+ENDIF(BUILD_ARCH STREQUAL "noarch")
+
+## %{dist}
+EXECUTE_PROCESS(COMMAND ${RPM_EXECUTABLE} -E "%{dist}"
+    COMMAND sed -e "s/^\\.//"
+    OUTPUT_VARIABLE _RPM_DIST_TAG
+    OUTPUT_STRIP_TRAILING_WHITESPACE
+    )
+SET(RPM_DIST_TAG "${_RPM_DIST_TAG}" CACHE STRING "RPM Dist Tag")
+
+SET(RPM_RELEASE_NO "1" CACHE STRING "RPM Release Number")
+
+SET(RPM_BUILD_TOPDIR "${CMAKE_BINARY_DIR}" CACHE PATH "RPM topdir")
+
+IF(SOURCE_ARCHIVE_DIR)
+    SET(RPM_BUILD_SOURCES "${SOURCE_ARCHIVE_DIR}" CACHE PATH "RPM SOURCE dir")
+ELSE()
+    SET(RPM_BUILD_SOURCES "${RPM_BUILD_TOPDIR}/SOURCES" CACHE PATH "RPM SOURCE dir")
+ENDIF()
+
+SET(RPM_IGNORE_FILES "debug.*s.list")
+FOREACH(_dir "SPECS" "SRPMS" "RPMS" "BUILD" "BUILDROOT")
+    IF(NOT RPM_BUILD_${_dir})
+	SET(RPM_BUILD_${_dir} "${RPM_BUILD_TOPDIR}/${_dir}" 
+	    CACHE PATH "RPM ${_dir} dir"
+	    )
+	MARK_AS_ADVANCED(RPM_BUILD_${_dir})
+	IF(NOT "${_dir}" STREQUAL "SPECS")
+	    LIST(APPEND RPM_IGNORE_FILES "/${_dir}/")
+	ENDIF(NOT "${_dir}" STREQUAL "SPECS")
+	FILE(MAKE_DIRECTORY "${RPM_BUILD_${_dir}}")
+    ENDIF(NOT RPM_BUILD_${_dir})
+ENDFOREACH(_dir "SPECS" "SOURCES" "SRPMS" "RPMS" "BUILD" "BUILDROOT")
+
+# Add RPM build directories in ignore file list.
+LIST(APPEND SOURCE_ARCHIVE_IGNORE_FILES ${RPM_IGNORE_FILES})
+
+FUNCTION(RPM_SPEC_STRING_ADD var str)
+    IF("${ARGN}" STREQUAL "FRONT")
+	STRING_PREPEND(${var} "${str}" "\n")
+	SET(pos "${ARGN}")
+    ELSE("${ARGN}" STREQUAL "FRONT")
+	STRING_APPEND(${var} "${str}" "\n")
+    ENDIF("${ARGN}" STREQUAL "FRONT")
+    SET(${var} "${${var}}" PARENT_SCOPE)
+ENDFUNCTION(RPM_SPEC_STRING_ADD var str)
+
+FUNCTION(RPM_SPEC_STRING_ADD_DIRECTIVE var directive attribute content)
+    SET(_str "%${directive}")
+    IF(NOT attribute STREQUAL "")
+	STRING_APPEND(_str " ${attribute}")
+    ENDIF(NOT attribute STREQUAL "")
+
+    IF(NOT content STREQUAL "")
+	STRING_APPEND(_str "\n${content}")
+    ENDIF(NOT content STREQUAL "")
+    STRING_APPEND(_str "\n")
+    RPM_SPEC_STRING_ADD(${var} "${_str}" ${ARGN})
+    SET(${var} "${${var}}" PARENT_SCOPE)
+ENDFUNCTION(RPM_SPEC_STRING_ADD_DIRECTIVE var directive attribute content)
+
+FUNCTION(RPM_SPEC_STRING_ADD_TAG var tag attribute value)
+    IF("${attribute}" STREQUAL "")
+	SET(_str "${tag}:")
+    ELSE("${attribute}" STREQUAL "")
+	SET(_str "${tag}(${attribute}):")
+    ENDIF("${attribute}" STREQUAL "")
+    STRING_PADDING(_str "${_str}" ${RPM_SPEC_TAG_PADDING})
+    STRING_APPEND(_str "${value}")
+    RPM_SPEC_STRING_ADD(${var} "${_str}" ${ARGN})
+    SET(${var} "${${var}}" PARENT_SCOPE)
+ENDFUNCTION(RPM_SPEC_STRING_ADD_TAG var tag attribute value)
+
+MACRO(MANAGE_RPM_SPEC)
+    IF(NOT _opt_SPEC_IN)
+	FIND_FILE_ERROR_HANDLING(_opt_SPEC_IN
+	    ERROR_MSG " spec.in is not found"
+	    VERBOSE_LEVEL ${M_ERROR}
+	    NAMES "project.spec.in" "${PROJECT_NAME}.spec.in"
+	    PATHS ${CMAKE_CURRENT_SOURCE_DIR} ${CMAKE_SOURCE_DIR}
+	    ${CMAKE_CURRENT_SOURCE_DIR}/SPECS
+	    ${CMAKE_SOURCE_DIR}/SPECS
+	    ${CMAKE_CURRENT_SOURCE_DIR}/rpm
+	    ${CMAKE_SOURCE_DIR}/rpm
+	    ${RPM_BUILD_SPECS}
+	    ${CMAKE_ROOT_DIR}/Templates/fedora
+	    ${CMAKE_CURRENT_SOURCE_DIR}/cmake-fedora/Templates/fedora
+	    )
+    ENDIF(NOT _opt_SPEC_IN)
+
+    IF(NOT _opt_SPEC)
+    	SET(_opt_SPEC "${RPM_BUILD_SPECS}/${PROJECT_NAME}.spec")
+    ENDIF(NOT _opt_SPEC)
+
+    SET(INSTALL_MANIFESTS_FILE "${CMAKE_BINARY_DIR}/install_manifest.txt")
+    ADD_CUSTOM_COMMAND(OUTPUT ${INSTALL_MANIFESTS_FILE}
+	COMMAND cmake -Dcmd=make_manifests
+	-Dmanifests=${INSTALL_MANIFESTS_FILE}
+	-Dtmp_dir=${CMAKE_FEDORA_TMP_DIR}
+	-P ${CMAKE_FEDORA_MODULE_DIR}/ManageRPMScript.cmake
+	COMMENT "install_manifest.txt: ${INSTALL_MANIFESTS_FILE}"
+	)
+
+    FOREACH(v ${RPM_SPEC_IN_VARIABLE_LIST})
+	PRJ_INFO_CMAKE_APPEND(${v})
+    ENDFOREACH(v)
+
+    SET(_specInOptList "")
+    IF(_opt_CONFIG_REPLACE)
+	LIST(APPEND _specInOptList "\"-Dconfig_replace=${_opt_CONFIG_REPLACE}\"")
+    ENDIF(_opt_CONFIG_REPLACE)
+
+    ADD_CUSTOM_TARGET_COMMAND(spec OUTPUT ${_opt_SPEC}
+	COMMAND cmake -Dcmd=spec
+            -Dspec=${_opt_SPEC}
+            -Dspec_in=${_opt_SPEC_IN}
+	    -Dmanifests=${INSTALL_MANIFESTS_FILE}
+	    -Drelease=${RELEASE_NOTES_FILE}
+	    -Dprj_info=${PRJ_INFO_CMAKE_FILE}
+	    ${_specInOptList}
+	    -P ${CMAKE_FEDORA_MODULE_DIR}/ManageRPMScript.cmake
+	    DEPENDS ${_opt_SPEC_IN} ${RELEASE_NOTES_FILE}
+	    ${INSTALL_MANIFESTS_FILE}
+	    ${SOURCE_ARCHIVE_FILE}
+	    COMMENT "spec: ${_opt_SPEC}"
+	    )
+ENDMACRO(MANAGE_RPM_SPEC)
+
+MACRO(PACK_RPM)
+    IF(_manage_rpm_dependency_missing)
+	RETURN()
+    ENDIF(_manage_rpm_dependency_missing)
+
+    SET(_validOptions "SPEC_IN" "SPEC" "CONFIG_REPLACE")
+    VARIABLE_PARSE_ARGN(_opt _validOptions ${ARGN})
+    MANAGE_RPM_SPEC()
+
+    SET(PRJ_SRPM_FILE "${RPM_BUILD_SRPMS}/${PROJECT_NAME}-${PRJ_VER}-${RPM_RELEASE_NO}.${RPM_DIST_TAG}.src.rpm"
+	CACHE STRING "RPM files" FORCE)
+
+    SET(PRJ_RPM_FILES "${RPM_BUILD_RPMS}/${RPM_BUILD_ARCH}/${PROJECT_NAME}-${PRJ_VER}-${RPM_RELEASE_NO}.${RPM_DIST_TAG}.${RPM_BUILD_ARCH}.rpm"
+	CACHE STRING "Building RPM files" FORCE)
+
+    #-------------------------------------------------------------------
+    # RPM build commands and targets
+
+    ADD_CUSTOM_TARGET_COMMAND(srpm
+	NO_FORCE
+	OUTPUT ${PRJ_SRPM_FILE}
+	COMMAND ${RPMBUILD_CMD} -bs ${_opt_SPEC}
+	--define '_sourcedir ${RPM_BUILD_SOURCES}'
+	--define '_builddir ${RPM_BUILD_BUILD}'
+	--define '_srcrpmdir ${RPM_BUILD_SRPMS}'
+	--define '_specdir ${RPM_BUILD_SPECS}'
+	DEPENDS ${_opt_SPEC} ${SOURCE_ARCHIVE_FILE}
+	COMMENT "srpm: ${PRJ_SRPM_FILE}"
+	)
+    ADD_DEPENDENCIES(srpm_no_force dist)
+    ADD_DEPENDENCIES(srpm dist)
+
+    # Binary RPMs
+    ADD_CUSTOM_TARGET_COMMAND(rpm
+	OUTPUT ${PRJ_RPM_FILES}
+	NO_FORCE
+	COMMAND ${RPMBUILD_CMD} --rebuild ${PRJ_SRPM_FILE}
+	--define '_rpmdir ${RPM_BUILD_RPMS}'
+	--define '_builddir ${RPM_BUILD_BUILD}'
+	--define '_buildrootdir ${RPM_BUILD_BUILDROOT}'
+	DEPENDS ${PRJ_SRPM_FILE}
+	COMMENT "rpm: ${PRJ_RPM_FILES}"
+	)
+    ADD_DEPENDENCIES(rpm_no_force srpm_no_force)
+    ADD_DEPENDENCIES(rpm srpm)
+
+    ADD_CUSTOM_TARGET(install_rpms
+	COMMAND find ${RPM_BUILD_RPMS}/${RPM_BUILD_ARCH}
+	-name '${PROJECT_NAME}*-${PRJ_VER}-${RPM_RELEASE_NO}.*.${RPM_BUILD_ARCH}.rpm' !
+	-name '${PROJECT_NAME}-debuginfo-${RPM_RELEASE_NO}.*.${RPM_BUILD_ARCH}.rpm'
+	-print -exec sudo rpm --upgrade --hash --verbose '{}' '\\;'
+	COMMENT "install_rpm: Install all rpms except debuginfo"
+	)
+    ADD_DEPENDENCIES(install_rpms rpm_no_force)
+
+    ADD_CUSTOM_TARGET(rpmlint
+	COMMAND find .
+	-name '${PROJECT_NAME}*-${PRJ_VER}-${RPM_RELEASE_NO}.*.rpm'
+	| xargs rpmlint -i -v
+	DEPENDS ${PRJ_SRPM_FILE} ${PRJ_RPM_FILES}
+	COMMENT "rpmlint: ${PRJ_SRPM_FILE} ${PRJ_RPM_FILES}"
+	)
+
+    ADD_CUSTOM_TARGET(clean_old_rpm
+	COMMAND find .
+	-name '${PROJECT_NAME}*.rpm' ! -name '${PROJECT_NAME}*-${PRJ_VER}-${RPM_RELEASE_NO}.*.rpm'
+	-print -delete
+	COMMAND find ${RPM_BUILD_BUILD}
+	-path '${PROJECT_NAME}*' ! -path '${RPM_BUILD_BUILD}/${PROJECT_NAME}-${PRJ_VER}-*'
+	-print -delete
+	COMMENT "Cleaning old rpms and build."
+	)
+
+    ADD_CUSTOM_TARGET(clean_old_pkg
+	)
+
+    ADD_DEPENDENCIES(clean_old_pkg clean_old_rpm clean_old_pack_src)
+
+    ADD_CUSTOM_TARGET(clean_rpm
+	COMMAND find . -name '${PROJECT_NAME}-*.rpm' -print -delete
+	COMMENT "Cleaning rpms.."
+	)
+    ADD_CUSTOM_TARGET(clean_pkg
+	)
+
+    ADD_DEPENDENCIES(clean_rpm clean_old_rpm)
+    ADD_DEPENDENCIES(clean_pkg clean_rpm clean_pack_src)
+ENDMACRO(PACK_RPM)
+
+MACRO(RPM_MOCK_BUILD)
+    IF(_manage_rpm_dependency_missing)
+	RETURN()
+    ENDIF(_manage_rpm_dependency_missing)
+
+    SET(_mock_missing 0)
+    FIND_PROGRAM_ERROR_HANDLING(MOCK_CMD
+	ERROR_MSG "mock not found, mock build support is disabled."
+	ERROR_VAR _mock_missing
+	VERBOSE_LEVEL ${M_OFF}
+	FIND_ARGS NAMES mock
+	)
+
+    IF(_manage_rpm_dependency_missing)
+	RETURN()
+    ENDIF(_manage_rpm_dependency_missing)
+
+    IF(_mock_missing)
+	RETURN()
+    ENDIF(_mock_missing)
+
+    SET(_validOptions "MOCK_CONFIG")
+    VARIABLE_PARSE_ARGN(_o _validOptions ${ARGN})
+
+    IF("${_o_MOCK_CONFIG}" STREQUAL "")
+	SET(_o_MOCK_CONFIG "default")
+    ENDIF("${_o_MOCK_CONFIG}" STREQUAL "")
+
+    FOREACH(_mName ${_o_MOCK_CONFIG})
+	## Filter out mock config that does not exists
+	## Figure out the actual config file (which has arch)
+	GET_FILENAME_COMPONENT(_mCfg "/etc/mock/${_mName}.cfg" REALPATH)
+	IF(EXISTS "${_mCfg}")
+	    IF("${RPM_BUILD_ARCH}" STREQUAL "noarch")
+		SET(_resultDir ${RPM_BUILD_RPMS}/noarch)
+	    ELSEIF("${_mCfg}" MATCHES "-x86_64.cfg")
+		SET(_resultDir ${RPM_BUILD_RPMS}/x86_64)
+	    ELSEIF("${_mCfg}" MATCHES "-i386.cfg")
+		SET(_resultDir ${RPM_BUILD_RPMS}/i386)
+	    ELSE()
+		M_MSG(${M_OFF} "RPM_MOCK_BUILD: ${_mCfg} is not supported yet.")
+		SET(_resultDir "")
+	    ENDIF("${RPM_BUILD_ARCH}" STREQUAL "noarch")
+	    IF(NOT "${_resultDir}" STREQUAL "")
+		ADD_CUSTOM_TARGET(rpm_mock_${_mName}
+		    COMMAND ${CMAKE_COMMAND} -E make_directory ${_resultDir}
+		    COMMAND ${MOCK_CMD} -r  "${_mName}" --resultdir="${_resultDir}" ${PRJ_SRPM_FILE}
+		    DEPENDS ${PRJ_SRPM_FILE}
+		    COMMENT "rpm_mock_${_mName}: ${PRJ_SRPM_FILE}"
+		    )
+	    ENDIF(NOT "${_resultDir}" STREQUAL "")
+	ELSE(EXISTS "${_mCfg}")
+	    M_MSG(${M_OFF} 
+		"RPM_MOCK_BUILD: mock config ${_mCfg} does not exists"
+		)
+	ENDIF(EXISTS "${_mCfg}")
+    ENDFOREACH(_mName)
+ENDMACRO(RPM_MOCK_BUILD)
+
diff -Nura ibus-chewing-1.6.1/Modules/ManageRPMScript.cmake ibus-chewing-1.6.1_new/Modules/ManageRPMScript.cmake
--- ibus-chewing-1.6.1/Modules/ManageRPMScript.cmake	1970-01-01 08:00:00.000000000 +0800
+++ ibus-chewing-1.6.1_new/Modules/ManageRPMScript.cmake	2015-12-17 17:43:31.000000000 +0800
@@ -0,0 +1,405 @@
+# - Manage RPM Script
+# RPM related scripts to be invoked in command line.
+
+MACRO(MANAGE_RPM_SCRIPT_PRINT_USAGE)
+    MESSAGE(
+	"Manage RPM script: This script is not recommend for end users
+	
+cmake -Dcmd=spec -Dspec=<project.spec> -Dspec_in=<project.spec.in>
+      -Dmanifests=<path/install_manifests.txt>
+      -Drelease=<path/RELEASE-NOTES.txt>
+      -Dprj_info=<path/prj_info.cmake>
+      [\"-Dconfig_replace=<file1;file2>\"]
+      [\"-D<var>=<value>\"]
+    -P <CmakeModulePath>/ManageRPMScript.cmake
+  Make project spec file according to spec_in and prj_info.cmake
+  Options:
+    -Dconfig_replace: List of configure files that should use
+      %config instead of %config(noreplace)
+    -Dmainfests: Path to install_manifests.txt
+    -Drelease: Path to RELEASE-NOTES.txt
+  Note: Please pass the necessary variables via -Dvar=VALUE,
+      e.g. \"-DPROJECT_NAME=cmake-fedora\"
+
+cmake -Dcmd=spec_manifests
+      -Dmanifests=<path/install_manifests.txt>
+      -Dprj_info=<path/prj_info.cmake>
+      [\"-Dconfig_replace=<file1;file2>\"]
+      [\"-D<var>=<value>\"]
+    -P <CmakeModulePath>/ManageRPMScript.cmake
+  Convert install_manifests.txt to part of a SPEC file.
+  Options:
+    -Dconfig_replace: List of configure files that should use
+      %config instead of %config(noreplace)
+    -Dmainfests: Path to install_manifests.txt
+  Note: Please pass the necessary variables via -Dvar=VALUE,
+    e.g. \"-DPROJECT_NAME=cmake-fedora\"
+    
+cmake -Dcmd=spec_changelog
+      -Dmanifests=<path/install_manifests.txt>
+      -Drelease=<path/RELEASE-NOTES.txt>
+      -Dprj_info=<path/prj_info.cmake>
+      [\"-D<var>=<value>\"]
+    -P <CmakeModulePath>/ManageRPMScript.cmake
+  Convert RELEASE-NOTES.txt to ChangeLog a SPEC file.
+    Options:
+      -Dmainfests: Path to install_manifests.txt
+    Note: Please pass the necessary variables via -Dvar=VALUE,
+       e.g. \"-DPROJECT_NAME=cmake-fedora\"
+
+cmake -Dcmd=make_manifests
+       [\"-Dmanifests=<path>/install_manifests.txt>\"]
+       [\"-Dtmp_dir=<dir>\"]
+  Make install_manifests.txt.
+  Options:
+    -Dmainfests: Path to install_manifests.txt
+    -Dtmp_dir: Directory for tempory files. 
+       Default is CMAKE_FEDORA_TMP_DIR
+
+"
+)
+ENDMACRO(MANAGE_RPM_SCRIPT_PRINT_USAGE)
+
+MACRO(MANIFEST_TO_STRING strVar hasTransVar manifestsFile)
+    SET(${hasTransVar} 0)
+
+    FILE(STRINGS ${manifestsFile} _filesInManifests)
+    SET(_docList "")
+    SET(_fileList "")
+    FOREACH(_file ${_filesInManifests})
+	SET(_addToFileList 1)
+	SET(_config_replace_detected 0)
+	IF(config_replace)
+	    FOREACH(_mF ${config_replace})
+		IF("${_file}" STREQUAL "${_mF}")
+		    SET(_config_replace_detected 1)
+		    BREAK()
+		ENDIF()
+	    ENDFOREACH()		
+	ENDIF()
+	STRING(REPLACE "${PROJECT_NAME}" "%{name}" _file "${_file}")
+        IF("${_file}" MATCHES "^/usr/bin/")
+	    STRING(REGEX REPLACE "^/usr/bin/" "%{_bindir}/" _file ${_file})
+	ELSEIF("${_file}" MATCHES "^/usr/sbin/")
+	    STRING(REGEX REPLACE "^/usr/sbin/" "%{_sbindir}/" _file ${_file})
+	ELSEIF("${_file}" MATCHES "^/usr/libexec/")
+	    STRING(REGEX REPLACE "^/usr/libexec/" "%{_libexecdir}/" _file ${_file})
+	ELSEIF("${_file}" MATCHES "^/usr/lib")
+	    STRING(REGEX REPLACE "^/usr/lib(64)?/" "%{_libdir}/" _file ${_file})
+	ELSEIF("${_file}" MATCHES "^/usr/include/")
+	    STRING(REGEX REPLACE "^/usr/include/" "%{_includedir}/" _file ${_file})
+	ELSEIF("${_file}" MATCHES "^/etc/rc.d/init.d/")
+	    STRING(REGEX REPLACE "^/etc/rc.d/init.d/" "%{_initrddir}/" _f "${_file}")
+	ELSEIF("${_file}" MATCHES "^/etc/")
+	    STRING(REGEX REPLACE "^/etc/" "%config(noreplace) %{_sysconfdir}/" _file "${_file}")
+	ELSEIF("${_file}" MATCHES "^/usr/share/info/")
+	    STRING(REGEX REPLACE "^/usr/share/info/" "%{_infodir}/" _file ${_file})
+	ELSEIF("${_file}" MATCHES "^/usr/share/doc/")
+	    SET(_addToFileList 0)
+	    STRING(REGEX REPLACE "^/usr/share/doc/%{name}[^/]*/" "" _file ${_file})
+	    LIST(APPEND _docList ${_file})
+	ELSEIF("${_file}" MATCHES "^/usr/share/man/")
+	    STRING(REGEX REPLACE "^/usr/share/man/" "%{_mandir}/" _file ${_file})
+	ELSEIF("${_file}" MATCHES "^/usr/share/")
+	    IF(_file MATCHES "^/usr/share/locale/")
+		SET(_addToFileList 0)
+		SET(${hasTransVar} 1)
+	    ENDIF()
+	    STRING(REGEX REPLACE "^/usr/share/" "%{_datadir}/" _file ${_file})
+	ELSEIF("${_file}" MATCHES "^/var/lib/")
+	    STRING(REGEX REPLACE "^/var/lib/" "%{_sharedstatedir}/" _file ${_file})
+	ELSEIF("${_file}" MATCHES "^/var/")
+	    STRING(REGEX REPLACE "^/var/" "%{_localstatedir}/" _file ${_file})
+	ELSE()
+	    M_MSG(${M_ERROR} "ManageRPMScript: Unhandled file: ${_file}")
+	ENDIF()
+	IF(_config_replace_detected)
+	    IF("${_file}" MATCHES "%config\\(noreplace\\)")
+		STRING(REPLACE "%config(noreplace)" "%config" 
+		    _file ${_file})
+	    ELSE()
+		STRING(REGEX REPLACE "^%" "%config %" _file ${_file})
+	    ENDIF()
+	ENDIF()
+
+	IF(_addToFileList)
+	    LIST(APPEND _fileList "${_file}")
+	ENDIF(_addToFileList)
+    ENDFOREACH(_file ${_filesInManifests})
+    IF(${hasTransVar} EQUAL 1)
+	STRING_APPEND(${strVar} "%files -f %{name}.lang" "\n")
+    ELSE()
+	STRING_APPEND(${strVar} "%files" "\n")
+    ENDIF()
+    STRING_APPEND(${strVar} "%defattr(-, root, root, -)" "\n")
+    # Append %doc
+    STRING_JOIN(_docStr " " ${_docList})
+    STRING_APPEND(${strVar} "%doc ${_docStr}" "\n")
+
+    # Append rest of files
+    LIST(SORT _fileList)
+    FOREACH(_f ${_fileList})
+	STRING_APPEND(${strVar} "${_f}" "\n")
+    ENDFOREACH(_f ${_fileList})
+ENDMACRO(MANIFEST_TO_STRING)
+
+FUNCTION(SPEC_MANIFESTS)
+    IF(NOT manifests)
+	MANAGE_RPM_SCRIPT_PRINT_USAGE()
+	M_MSG(${M_FATAL} "Requires \"-Dmanifests=<install_manifests.txt>\"")
+    ENDIF()
+    SET(RPM_FAKE_INSTALL_DIR "/tmp/cmake-fedora-fake-install")
+    EXECUTE_PROCESS(COMMAND make DESTDIR=${RPM_FAKE_INSTALL_DIR} install)
+    MANIFEST_TO_STRING(mStr hasTrans ${manifests})
+    M_OUT("${mStr}")
+ENDFUNCTION(SPEC_MANIFESTS)
+
+MACRO(CHANGELOG_TO_STRING strVar)
+    EXECUTE_PROCESS(
+	COMMAND ${CMAKE_COMMAND}
+	-Dcmd=extract_current
+	-Drelease=${release}
+	-P ${CMAKE_FEDORA_MODULE_DIR}/ManageChangeLogScript.cmake
+	OUTPUT_VARIABLE _changeLogThis
+	OUTPUT_STRIP_TRAILING_WHITESPACE
+	)
+
+    FIND_PROGRAM_ERROR_HANDLING(CMAKE_FEDORA_KOJI_CMD
+	FIND_ARGS NAMES cmake-fedora-koji
+	PATHS  ${CMAKE_FEDORA_SCRIPT_PATH_HINTS}
+	)
+
+    SET(CMAKE_FEDORA_TMP_DIR "/tmp")
+    SET(RPM_CHANGELOG_TMP_FILE "${CMAKE_FEDORA_TMP_DIR}/${PROJECT_NAME}.changelog")
+
+    EXECUTE_PROCESS(
+	COMMAND ${CMAKE_FEDORA_KOJI_CMD} newest-changelog "${PROJECT_NAME}" | tail -n +2
+	OUTPUT_VARIABLE _changeLogPrev
+	OUTPUT_STRIP_TRAILING_WHITESPACE
+	)
+
+    SET(${strVar} "%changelog")
+    STRING_APPEND(${strVar} "* ${TODAY_CHANGELOG} ${MAINTAINER} - ${PRJ_VER}-${RPM_RELEASE_NO}" "\n")
+    STRING_APPEND(${strVar} "${_changeLogThis}\n" "\n")
+    STRING_APPEND(${strVar} "${_changeLogPrev}" "\n")
+ENDMACRO(CHANGELOG_TO_STRING strVar)
+
+FUNCTION(SPEC_CHANGELOG)
+    IF(NOT release)
+	MANAGE_RPM_SCRIPT_PRINT_USAGE()
+	M_MSG(${M_FATAL} "Requires \"-Drelease=<RELEASE-NOTES.txt>\"")
+    ENDIF()
+    PRJ_INFO_CMAKE_READ(${prj_info})
+    CHANGELOG_TO_STRING(_changeLogStr)
+    M_OUT("${_changeLogStr}")
+ENDFUNCTION(SPEC_CHANGELOG)
+
+# Not exactly a header, but the first half
+MACRO(SPEC_WRITE_HEADER)
+    ## Summary
+    RPM_SPEC_STRING_ADD_TAG(RPM_SPEC_SUMMARY_OUTPUT
+	"Summary" "" "${PRJ_SUMMARY}"
+	)
+    SET(_lang "")
+    FOREACH(_sT ${SUMMARY_TRANSLATIONS})
+	IF(_lang STREQUAL "")
+	    SET(_lang "${_sT}")
+	ELSE(_lang STREQUAL "")
+	    RPM_SPEC_STRING_ADD_TAG(RPM_SPEC_SUMMARY_OUTPUT
+		"Summary" "${_lang}" "${_sT}"
+		)
+	    SET(_lang "")
+	ENDIF(_lang STREQUAL "")
+    ENDFOREACH(_sT ${SUMMARY_TRANSLATIONS})
+
+    ## Url
+    SET(RPM_SPEC_URL_OUTPUT "${RPM_SPEC_URL}")
+
+    ## Source
+    SET(_buf "")
+    SET(_i 0)
+    FOREACH(_s ${RPM_SPEC_SOURCES})
+	RPM_SPEC_STRING_ADD_TAG(_buf "Source${_i}" "" "${_s}")
+	MATH(EXPR _i ${_i}+1)
+    ENDFOREACH(_s ${RPM_SPEC_SOURCES})
+    RPM_SPEC_STRING_ADD(RPM_SPEC_SOURCE_OUTPUT "${_buf}" FRONT)
+
+    ## Requires and BuildRequires
+    SET(_buf "")
+    FOREACH(_s ${BUILD_REQUIRES})
+	RPM_SPEC_STRING_ADD_TAG(_buf "BuildRequires" "" "${_s}")
+    ENDFOREACH(_s)
+
+    FOREACH(_s ${REQUIRES})
+	RPM_SPEC_STRING_ADD_TAG(_buf "Requires" "" "${_s}")
+    ENDFOREACH(_s)
+    FOREACH(_s ${REQUIRES_PRE})
+	RPM_SPEC_STRING_ADD_TAG(_buf "Requires" "pre" "${_s}")
+    ENDFOREACH(_s)
+    FOREACH(_s ${REQUIRES_PREUN})
+	RPM_SPEC_STRING_ADD_TAG(_buf "Requires" "preun" "${_s}")
+    ENDFOREACH(_s)
+    FOREACH(_s ${REQUIRES_POST})
+	RPM_SPEC_STRING_ADD_TAG(_buf "Requires" "post" "${_s}")
+    ENDFOREACH(_s)
+    FOREACH(_s ${REQUIRES_POSTUN})
+	RPM_SPEC_STRING_ADD_TAG(_buf "Requires" "postun" "${_s}")
+    ENDFOREACH(_s)
+    RPM_SPEC_STRING_ADD(RPM_SPEC_REQUIRES_OUTPUT "${_buf}" FRONT)
+
+    ## Description
+    RPM_SPEC_STRING_ADD_DIRECTIVE(RPM_SPEC_DESCRIPTION_OUTPUT
+	"description" "" "${PRJ_DESCRIPTION}"
+	)
+    SET(_lang "")
+    FOREACH(_sT ${DESCRIPTION_TRANSLATIONS})
+	IF(_lang STREQUAL "")
+	    SET(_lang "${_sT}")
+	ELSE(_lang STREQUAL "")
+	    RPM_SPEC_STRING_ADD_DIRECTIVE(RPM_SPEC_DESCRIPTION_OUTPUT
+		"description" "-l ${_lang}" "${_sT}" "\n"
+		)
+	    SET(_lang "")
+	ENDIF(_lang STREQUAL "")
+    ENDFOREACH(_sT ${DESCRIPTION_TRANSLATIONS})
+
+    ## Header
+    ## %{_build_arch}
+    IF("${BUILD_ARCH}" STREQUAL "")
+	EXECUTE_PROCESS(COMMAND ${RPM_CMD} -E "%{_build_arch}"
+	    OUTPUT_VARIABLE _RPM_BUILD_ARCH
+	    OUTPUT_STRIP_TRAILING_WHITESPACE)
+	SET(RPM_BUILD_ARCH "${_RPM_BUILD_ARCH}" 
+	    CACHE STRING "RPM Arch")
+    ELSE("${BUILD_ARCH}" STREQUAL "")
+	SET(RPM_BUILD_ARCH "${BUILD_ARCH}" 
+	    CACHE STRING "RPM Arch")
+	RPM_SPEC_STRING_ADD_TAG(RPM_SPEC_HEADER_OUTPUT
+	    "BuildArch" "" "${BUILD_ARCH}"
+	    )
+    ENDIF("${BUILD_ARCH}" STREQUAL "")
+
+    ## Install
+    RPM_SPEC_STRING_ADD_DIRECTIVE(RPM_SPEC_INSTALL_SECTION_OUTPUT
+	"install" "" "rm -rf %{buildroot}
+make install DESTDIR=%{buildroot}"
+        )
+
+    RPM_SPEC_STRING_ADD(RPM_SPEC_INSTALL_SECTION_OUTPUT
+    "# We install document using doc 
+rm -fr %{buildroot}%{_docdir}/*")
+
+ENDMACRO(SPEC_WRITE_HEADER)
+
+FUNCTION(SPEC_MAKE)
+    IF(NOT manifests)
+	MANAGE_RPM_SCRIPT_PRINT_USAGE()
+	M_MSG(${M_FATAL} "Requires \"-Dmanifests=<install_manifests.txt>\"")
+    ENDIF()
+    IF(NOT release)
+	MANAGE_RPM_SCRIPT_PRINT_USAGE()
+	M_MSG(${M_FATAL} "Requires \"-Drelease=<RELEASE-NOTES.txt>\"")
+    ENDIF()
+    IF(NOT prj_info)
+	MANAGE_RPM_SCRIPT_PRINT_USAGE()
+	M_MSG(${M_FATAL} "Requires -Dprj_info=<prj_info.cmake>")
+    ENDIF()
+    PRJ_INFO_CMAKE_READ(${prj_info})
+    SPEC_WRITE_HEADER()
+    MANIFEST_TO_STRING(RPM_SPEC_FILES_SECTION_OUTPUT hasTrans ${manifests})
+    IF(hasTrans)
+	RPM_SPEC_STRING_ADD(RPM_SPEC_INSTALL_SECTION_OUTPUT 
+	    "\n%find_lang %{name}\n")
+    ENDIF()
+    CHANGELOG_TO_STRING(RPM_SPEC_CHANGELOG_SECTION_OUTPUT)
+    CONFIGURE_FILE(${spec_in} ${spec} @ONLY)
+ENDFUNCTION(SPEC_MAKE)
+
+FUNCTION(MAKE_MANIFESTS)
+    IF(NOT tmp_dir)
+	SET(tmp_dir "${CMAKE_FEDORA_TMP_DIR}")
+    ENDIF(NOT tmp_dir)
+    SET(_opts "")
+    IF(manifests)
+	GET_FILENAME_COMPONENT(manifestsDir "${manifests}" PATH)
+	SET(_opts "WORKING_DIRECTORY" "${manifestsDir}")
+    ENDIF()
+    
+    EXECUTE_PROCESS(COMMAND make install DESTDIR=${tmp_dir}
+	${_opts})
+ENDFUNCTION(MAKE_MANIFESTS)
+
+SET(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS ON)
+#######################################
+# Determine CMAKE_FEDORA_MODULE_DIR
+#
+
+## It is possible that current dir is in NO_PACK/FedPkg/<prj>
+LIST(INSERT CMAKE_MODULE_PATH 0
+    ${CMAKE_SOURCE_DIR}/Modules ${CMAKE_SOURCE_DIR}/cmake-fedora/Modules 
+    ${CMAKE_SOURCE_DIR}/../../../Modules
+    ${CMAKE_SOURCE_DIR}/../../../cmake-fedora/Modules
+    ${CMAKE_SOURCE_DIR}
+    )
+
+IF(CMAKE_SCRIPT_MODE_FILE)
+    GET_FILENAME_COMPONENT(CMAKE_FEDORA_SCRIPT_DIR ${CMAKE_SCRIPT_MODE_FILE}
+	PATH)
+    LIST(INSERT CMAKE_MODULE_PATH 0 "${CMAKE_FEDORA_SCRIPT_DIR}")
+ENDIF()
+
+IF(cmake_fedora_module_dir)
+    LIST(INSERT CMAKE_MODULE_PATH 0 "${cmake_fedora_module_dir}")
+ENDIF()
+
+INCLUDE(ManageMessage RESULT_VARIABLE MANAGE_MODULE_PATH)
+IF(NOT MANAGE_MODULE_PATH)
+    MESSAGE(FATAL_ERROR "ManageMessage.cmake cannot be found in ${CMAKE_MODULE_PATH}")
+ENDIF()
+GET_FILENAME_COMPONENT(CMAKE_FEDORA_MODULE_DIR 
+    "${MANAGE_MODULE_PATH}" PATH)
+
+INCLUDE(ManageEnvironmentCommon)
+INCLUDE(ManageString)
+INCLUDE(ManageVariable)
+CMAKE_FEDORA_CONF_GET_ALL_VARIABLES()
+INCLUDE(DateTimeFormat)
+INCLUDE(ManageVersion)
+INCLUDE(ManageRPM)
+
+IF(NOT DEFINED cmd)
+    MANAGE_RPM_SCRIPT_PRINT_USAGE()
+ELSE()
+    ## Append FILE_INSTALL_SYSCONF_LIST as config_replace
+    FOREACH(_f ${FILE_INSTALL_SYSCONF_LIST})
+	LIST(APPEND _config_replace "/etc/${_f}")
+    ENDFOREACH(_f ${FILE_INSTALL_SYSCONF_LIST})
+    FOREACH(_f ${FILE_INSTALL_PRJ_SYSCONF_LIST})
+	LIST(APPEND _config_replace "/etc/${PROJECT_NAME}/${_f}")
+    ENDFOREACH(_f ${FILE_INSTALL_PRJ_SYSCONF_LIST})
+    IF (POLICY CMP0054)
+	CMAKE_POLICY(PUSH)
+	CMAKE_POLICY(SET CMP0054 "NEW")
+    ENDIF()
+    IF("${cmd}" STREQUAL "spec")
+	IF(NOT spec)
+	    MANAGE_RPM_SCRIPT_PRINT_USAGE()
+	    M_MSG(${M_FATAL} "Requires -Dspec=<file.spec>")
+	ENDIF(NOT spec)
+	SPEC_MAKE()
+    ELSEIF("${cmd}" STREQUAL "spec_manifests")
+	SPEC_MANIFESTS()
+    ELSEIF("${cmd}" STREQUAL "spec_changelog")
+	SPEC_CHANGELOG()
+    ELSEIF("${cmd}" STREQUAL "make_manifests")
+	MAKE_MANIFESTS()
+    ELSE()
+	MANAGE_RPM_SCRIPT_PRINT_USAGE()
+	M_MSG(${M_FATAL} "Invalid cmd ${cmd}")
+    ENDIF()
+    IF (POLICY CMP0054)
+	CMAKE_POLICY(POP)
+    ENDIF()
+ENDIF()
+
+
diff -Nura ibus-chewing-1.6.1/Modules/ManageSourceVersionControl.cmake ibus-chewing-1.6.1_new/Modules/ManageSourceVersionControl.cmake
--- ibus-chewing-1.6.1/Modules/ManageSourceVersionControl.cmake	1970-01-01 08:00:00.000000000 +0800
+++ ibus-chewing-1.6.1_new/Modules/ManageSourceVersionControl.cmake	2016-01-07 15:39:34.000000000 +0800
@@ -0,0 +1,192 @@
+# - Module for manipulate source version control systems.
+# This module provides an universal interface for supported
+# source version control systems, namely:
+# Git, Mercurial and SVN.
+#
+# Following targets are defined for each source version control 
+#   (in Git terminology):
+#   - tag: Tag the working tree with ${PRJ_VER} and ${CHANGE_SUMMARY}.
+#      This target also ensure there is nothing uncommitted.
+#   - tag_pre: Target that will be executed before target "tag".
+#      So use ADD_DEPENDENCIES(tag_pre <target> ...) for the targets
+#      that need to be done before target <tag>.
+#   - tag_post: Target that will be executed after target "tag".
+#      This target will push the tagged commit to server.
+#      This target depends (directly or indirectly) on target "tag".
+#      So use ADD_DEPENDENCIES(tag_post <target> ...) for the targets
+#      that need to be done after target <tag>.
+#
+#
+# Included Modoule:
+#   - ManageTarget
+#   - ManageVariable
+#
+# Define following functions:
+#   MANAGE_SOURCE_VERSION_CONTROL_GIT(
+#       [PRE_TARGETS <target> ...] [POST_TARGETS <target> ...]
+#     )
+#     - Use Git as source version control.
+#       * Parameters:
+#         + PRE_TARGETS target ...: Targets before target "tag".
+#         + POST_TARGETS target ... : Target after target "tag".
+#       * Targets:
+#         + tag: Tag the commit with ${PRJ_VER}
+#         + tag_pre: Target hook for action before target "tag".
+#         + tag_post: Target hook for action after target "tag".
+#         + tag_push: Push tag and commit to server
+#
+#   MANAGE_SOURCE_VERSION_CONTROL_HG(
+#       [PRE_TARGETS <target> ...] [POST_TARGETS <target> ...]
+#     )
+#     - (Experimental) Use Mercurial (HG)  as source version control.
+#       * Parameters:
+#         + PRE_TARGETS target ...: Targets before target "tag".
+#         + POST_TARGETS target ... : Target after target "tag".
+#       * Targets:
+#         + tag: Tag the commit with ${PRJ_VER}
+#         + tag_pre: Target hook for action before target "tag".
+#         + tag_post: Target hook for action after target "tag".
+#         + tag_push: Push tag and commit to server
+#
+#   MANAGE_SOURCE_VERSION_CONTROL_SVN(
+#       SVN_URL <svnUrl>
+#       [PRE_TARGETS <target> ...] [POST_TARGETS <target> ...]
+#     ) 
+#     - (Experimental) Use Subversion (SVN)  as source version control.
+#       * Parameters:
+#         + SVN_URL url: URL to svn repostory.
+#             (e.g. http://server.com/repo/project)
+#         + PRE_TARGETS target ...: Targets before target "tag".
+#         + POST_TARGETS target ... : Target after target "tag".
+#       * Targets:
+#         + tag: Tag the commit with ${PRJ_VER}
+#         + tag_pre: Target hook for action before target "tag".
+#         + tag_post: Target hook for action after target "tag".
+#
+
+IF(DEFINED _MANAGE_SOURCE_VERSION_CONTROL_CMAKE_)
+    RETURN()
+ENDIF(DEFINED _MANAGE_SOURCE_VERSION_CONTROL_CMAKE_)
+SET(_MANAGE_SOURCE_VERSION_CONTROL_CMAKE_ "DEFINED")
+INCLUDE(ManageTarget)
+INCLUDE(ManageVariable)
+
+FUNCTION(MANAGE_SOURCE_VERSION_CONTROL_COMMON)
+    SET(_valid_options "PRE_TARGETS" "POST_TARGETS")
+    VARIABLE_PARSE_ARGN(_o _valid_options ${ARGN})
+
+    ADD_CUSTOM_TARGET(tag_pre
+	COMMENT "tag_pre: ${_o} Pre-tagging check "
+	)
+
+    ## Source Archive should be created before tag
+    ADD_DEPENDENCIES(tag_pre pack_src_no_force)
+
+    ADD_CUSTOM_TARGET(tag_post
+	COMMENT "tag_pre: ${_o} Post-tagging actions "
+	)
+
+    ## Set the pre and post targets from argn
+    IF(NOT "${_o_PRE_TARGETS}" STREQUAL "")
+	ADD_DEPENDENCIES(tag_pre ${_o_PRE_TARGETS})
+    ENDIF(NOT "${_o_PRE_TARGETS}" STREQUAL "")
+    IF(NOT "${_o_POST_TARGETS}" STREQUAL "")
+	ADD_DEPENDENCIES(tag_pre ${_o_POST_TARGETS})
+    ENDIF(NOT "${_o_POST_TARGETS}" STREQUAL "")
+ENDFUNCTION(MANAGE_SOURCE_VERSION_CONTROL_COMMON)
+
+FUNCTION(MANAGE_SOURCE_VERSION_CONTROL_GIT)
+    MANAGE_SOURCE_VERSION_CONTROL_COMMON(git ${ARGN})
+    SET(MANAGE_SOURCE_VERSION_CONTROL_TAG_FILE
+	${CMAKE_FEDORA_TMP_DIR}/target-tag-${PRJ_VER}
+	CACHE PATH "Source Version Control Tag File" FORCE)
+
+    ADD_CUSTOM_TARGET(tag
+	DEPENDS ${MANAGE_SOURCE_VERSION_CONTROL_TAG_FILE}
+	COMMENT "tag: tag ${PRJ_VER} in Git"
+	VERBATIM
+	)
+
+    ADD_DEPENDENCIES(tag changelog_no_force)
+
+    ADD_CUSTOM_COMMAND(OUTPUT ${MANAGE_SOURCE_VERSION_CONTROL_TAG_FILE}
+	COMMAND make tag_pre
+	COMMAND git diff --exit-code
+	COMMAND cmake -D "cmd=make_tag_file" -D "ver=${PRJ_VER}" 
+	-D "output_file=${MANAGE_SOURCE_VERSION_CONTROL_TAG_FILE}" 
+	-P ${CMAKE_FEDORA_MODULE_DIR}/ManageGitScript.cmake
+	COMMAND make tag_post
+	COMMENT "Tagging the source as ver ${PRJ_VER}"
+	VERBATIM
+	)
+
+    ## Pre tags
+    ADD_CUSTOM_TARGET(commit_clean
+	COMMAND git diff --exit-code
+	COMMENT "Is git commit clean?"
+	VERBATIM
+	)
+    ADD_DEPENDENCIES(tag_pre commit_clean)
+
+    ## Post tags
+    ADD_CUSTOM_TARGET(tag_push
+	COMMAND git push
+	COMMAND git push --tags
+	DEPENDS "${MANAGE_SOURCE_VERSION_CONTROL_TAG_FILE}"
+	COMMENT "Push to git"
+	)
+
+    ADD_DEPENDENCIES(tag_post tag_push)
+ENDFUNCTION(MANAGE_SOURCE_VERSION_CONTROL_GIT)
+
+FUNCTION(MANAGE_SOURCE_VERSION_CONTROL_HG)
+    MANAGE_SOURCE_VERSION_CONTROL_COMMON(Hg ${ARGN})
+
+    ADD_CUSTOM_TARGET(tag
+	COMMAND eval "hg sum | grep -qs -e '^commit: (clean)'"
+	COMMAND make tag_pre
+	COMMAND hg tag -m "${CHANGE_SUMMARY}" "${PRJ_VER}"
+	COMMAND make tag_post
+	COMMENT "tag: Hg tagging ${PRJ_VER} "
+	VERBATIM
+	)
+
+    ADD_DEPENDENCIES(tag changelog_no_force)
+
+    ## Post tags
+    ADD_CUSTOM_TARGET(tag_push
+	COMMAND hg push
+	COMMENT "Push to hg"
+	)
+    ADD_DEPENDENCIES(tag_post tag_push)
+ENDFUNCTION(MANAGE_SOURCE_VERSION_CONTROL_HG)
+
+FUNCTION(MANAGE_SOURCE_VERSION_CONTROL_SVN)
+    MANAGE_SOURCE_VERSION_CONTROL_COMMON(SVN ${ARGN})
+    SET(_valid_options "PRE_TARGETS" "POST_TARGETS" "SVN_URL")
+    VARIABLE_PARSE_ARGN(_o _valid_options ${ARGN})
+
+    SET(MANAGE_SOURCE_VERSION_CONTROL_TAG_FILE
+	${CMAKE_FEDORA_TMP_DIR}/SVN/${PRJ_VER}
+	CACHE PATH "Source Version Control Tag File" FORCE)
+
+    ADD_CUSTOM_TARGET(tag
+	DEPENDS "${MANAGE_SOURCE_VERSION_CONTROL_TAG_FILE}"
+	COMMENT "tag: SVN tagging ${PRJ_VER} "
+	)
+
+    ADD_DEPENDENCIES(tag changelog_no_force)
+
+    ## Only tag when it is not yet tagged
+    ADD_CUSTOM_COMMAND(OUTPUT ${MANAGE_SOURCE_VERSION_CONTROL_TAG_FILE}
+	COMMAND if svn ls ${_o_SVN_URL}/${PRJ_VER} --depth empty &>/dev/null; then return 1;else return 0; fi
+	COMMAND make tag_pre
+	COMMAND svn copy "${SOURCE_BASE_URL}/trunk" "${SOURCE_BASE_URL}/tags/${PRJ_VER}" -m "${CHANGE_SUMMARY}"
+	COMMAND cmake -E touch ${MANAGE_SOURCE_VERSION_CONTROL_TAG_FILE}
+	COMMAND make tag_post
+	COMMENT "Tagging the source as ver ${PRJ_VER}"
+	VERBATIM
+	)
+
+ENDFUNCTION(MANAGE_SOURCE_VERSION_CONTROL_SVN)
+
diff -Nura ibus-chewing-1.6.1/Modules/ManageString.cmake ibus-chewing-1.6.1_new/Modules/ManageString.cmake
--- ibus-chewing-1.6.1/Modules/ManageString.cmake	1970-01-01 08:00:00.000000000 +0800
+++ ibus-chewing-1.6.1_new/Modules/ManageString.cmake	2015-12-17 17:43:31.000000000 +0800
@@ -0,0 +1,450 @@
+# - Manage String by utility functions
+#
+# Defines the following functions:
+#   STRING_APPEND(<var> <str> [<separator>])
+#     - Append a string to a variable.
+#       * Parameters:
+#         + var: A variable that stores the result.
+#         + str: A string to be appended to end of line.
+#         + separator: Separator to separate between strings.
+#
+#   STRING_ESCAPE_BACKSLASH(<var> <str>)
+#     - Escape the backslash (\).
+#       * Parameters:
+#         + var: A variable that stores the result.
+#         + str: A string.
+#
+#   STRING_ESCAPE_DOLLAR(<var> <str>)
+#     - Escape the dollar sign ($).
+#       * Parameters:
+#         + var: A variable that stores the result.
+#         + str: A string.
+#
+#   STRING_ESCAPE_QUOTE(<var> <str>)
+#     - Escape the double quote (").
+#       * Parameters:
+#         + var: A variable that stores the result.
+#         + str: A string.
+#
+#   STRING_ESCAPE_SEMICOLON(<var> <str>)
+#     - Escape the semicolon (;).
+#       * Parameters:
+#         + var: A variable that stores the result.
+#         + str: A string.
+#
+#   STRING_PADDING(<var> <str> <length> [<padStr>])
+#     - Padding the string to specified length.
+#       * Parameters:
+#         + var: A variable that stores the result.
+#         + str: A string.
+#         + length: Required length.
+#         + padStr: String that used in padding. Default: " "
+#
+#   STRING_PREPEND(<var> <str> [<separator>])
+#     - Prepend a string to a variable.
+#       * Parameters:
+#         + var: A variable that stores the result.
+#         + str: A string to be appended to end of line.
+#         + separator: Separator to separate between strings.
+#
+#   STRING_SPLIT(<var> <delimiter> <str> 
+#       [NOESCAPE_SEMICOLON] [ESCAPE_VARIABLE] [ALLOW_EMPTY]
+#     )
+#     - Split a string into a list using a delimiter, 
+#       which can be in 1 or more characters long.
+#       * Parameters:
+#         + var: A variable that stores the result.
+#         + delimiter: To separate a string.
+#         + str: A string.
+#         + NOESCAPE_SEMICOLON: (Optional) Do not escape semicolons.
+#         + ESCAPE_VARIABLE: (Optional) Escape variables.
+#         + ALLOW_EMPTY: (Optional) Allow empty element exist in the array.
+#
+#   STRING_TRIM(<var> <str> [NOUNQUOTE])
+#     - Trim a string by removing the leading and trailing spaces,
+#       just like STRING(STRIP ...) in CMake 2.6 and later.
+#       This macro was developed as CMake 2.4 does not support 
+#        STRING(STRIP ..)
+#       This macro also remove quote and double quote marks around 
+#       the string, unless NOUNQUOTE is defined.
+#       * Parameters:
+#         + var: A variable that stores the result.
+#         + str: A string.
+#         + NOUNQUOTE: (Optional) do not remove the double quote mark
+#           around the string.
+#
+#   STRING_UNQUOTE(<var> <str>)
+#     - Remove double quote marks and quote marks around a string.
+#       If the string is not quoted, then content of str is copied to var
+#       * Parameters:
+#         + var: A variable that stores the result.
+#         + str: A string.
+#
+# Defines the following macros:
+#   STRING_JOIN(<var> <delimiter> <strList> [<str> ...])
+#     - Concatenate strings, with delimiter inserted between strings.
+#       * Parameters:
+#         + var: A variable that stores the result.
+#         + strList: A list of strings.
+#         + str: (Optional) more string to be join.
+#
+
+IF(DEFINED _MANAGE_STRING_CMAKE_)
+    RETURN()
+ENDIF(DEFINED _MANAGE_STRING_CMAKE_)
+SET(_MANAGE_STRING_CMAKE_ "DEFINED")
+
+FUNCTION(STRING_APPEND var str)
+    IF(${ARGC} GREATER 2)
+	SET(_sep "${ARGV2}")
+    ELSE(${ARGC} GREATER 2)
+	SET(_sep "")
+    ENDIF(${ARGC} GREATER 2)
+    IF (POLICY CMP0054)
+	CMAKE_POLICY(PUSH)
+	CMAKE_POLICY(SET CMP0054 "NEW")
+    ENDIF()
+    IF("${${var}}" STREQUAL "")
+	SET(${var} "${str}" PARENT_SCOPE)
+    ELSE("${${var}}" STREQUAL "")
+	SET(${var} "${${var}}${_sep}${str}" PARENT_SCOPE)
+    ENDIF("${${var}}" STREQUAL "")
+    IF (POLICY CMP0054)
+	CMAKE_POLICY(POP)
+    ENDIF()
+ENDFUNCTION(STRING_APPEND var str)
+
+FUNCTION(STRING_ESCAPE_BACKSLASH var str)
+    IF(str STREQUAL "")
+	SET(${var} "" PARENT_SCOPE)
+    ELSE(str STREQUAL "")
+	STRING(REPLACE "\\" "\\\\" output "${str}")
+	SET(${var} "${output}" PARENT_SCOPE)
+    ENDIF(str STREQUAL "")
+ENDFUNCTION(STRING_ESCAPE_BACKSLASH)
+
+FUNCTION(STRING_ESCAPE_DOLLAR var str)
+    IF(str STREQUAL "")
+	SET(${var} "" PARENT_SCOPE)
+    ELSE(str STREQUAL "")
+	STRING(REPLACE "\$" "\\\$" output "${str}")
+	SET(${var} "${output}" PARENT_SCOPE)
+    ENDIF(str STREQUAL "")
+ENDFUNCTION(STRING_ESCAPE_DOLLAR)
+
+FUNCTION(STRING_ESCAPE_QUOTE var str)
+    IF(str STREQUAL "")
+	SET(${var} "" PARENT_SCOPE)
+    ELSE(str STREQUAL "")
+	STRING(REPLACE "\"" "\\\"" output "${str}")
+	SET(${var} "${output}" PARENT_SCOPE)
+    ENDIF(str STREQUAL "")
+ENDFUNCTION(STRING_ESCAPE_QUOTE)
+
+FUNCTION(STRING_ESCAPE_SEMICOLON var str)
+    IF(str STREQUAL "")
+	SET(${var} "" PARENT_SCOPE)
+    ELSE(str STREQUAL "")
+	STRING(REPLACE ";" "\\;" output "${str}")
+	SET(${var} "${output}" PARENT_SCOPE)
+    ENDIF(str STREQUAL "")
+ENDFUNCTION(STRING_ESCAPE_SEMICOLON var str)
+
+FUNCTION(STRING_PADDING var str length)
+    SET(_ret "${str}")
+    IF(${ARGN})
+	SET(_padStr ${ARGN})
+    ELSE(${ARGN})
+	SET(_padStr " ")
+    ENDIF(${ARGN})
+    STRING(LENGTH "${str}" _strLen)
+    STRING(LENGTH "${_padStr}" _padLen)
+    WHILE( _strLen LESS length)
+	SET(_ret "${_ret}${_padStr}")
+	MATH(EXPR _strLen ${_strLen}+${_padLen})
+    ENDWHILE( _strLen LESS length)
+    SET(${var} "${_ret}" PARENT_SCOPE)
+ENDFUNCTION(STRING_PADDING var str length)
+
+FUNCTION(STRING_PREPEND var str)
+    IF(${ARGC} GREATER 2)
+	SET(_sep "${ARGV2}")
+    ELSE(${ARGC} GREATER 2)
+	SET(_sep "")
+    ENDIF(${ARGC} GREATER 2)
+    IF("${${var}}" STREQUAL "")
+	SET(${var} "${str}" PARENT_SCOPE)
+    ELSE("${${var}}" STREQUAL "")
+	SET(${var} "${str}${_sep}${${var}}" PARENT_SCOPE)
+    ENDIF("${${var}}" STREQUAL "")
+ENDFUNCTION(STRING_PREPEND var str)
+
+# Return (index of lefttmost non match character)
+# Return _strLen if all characters matches regex
+FUNCTION(STRING_LEFTMOST_NOTMATCH_INDEX var str regex)
+    STRING(LENGTH "${str}" _strLen)
+    SET(_index 0)
+    SET(_ret ${_strLen})
+    WHILE(_index LESS _strLen)
+	STRING(SUBSTRING "${str}" ${_index} 1 _strCursor)
+	#MESSAGE("***STRING_UNQUOTE: _i=${_index} _strCursor=${_strCursor}")
+	IF(NOT "${_strCursor}" MATCHES "${regex}")
+	    SET(_ret ${_index})
+	    SET(_index ${_strLen})
+	ENDIF(NOT "${_strCursor}" MATCHES "${regex}")
+
+	MATH(EXPR _index ${_index}+1)
+    ENDWHILE(_index LESS _strLen)
+    SET(${var} ${_ret} PARENT_SCOPE)
+ENDFUNCTION(STRING_LEFTMOST_NOTMATCH_INDEX var str)
+
+# Return (index of rightmost non match character) +1
+# Return 0 if all characters matches regex
+#
+FUNCTION(STRING_RIGHTMOST_NOTMATCH_INDEX var str regex)
+    STRING(LENGTH "${str}" _strLen)
+    MATH(EXPR _index ${_strLen})
+    SET(_ret 0)
+    WHILE(_index GREATER 0)
+	MATH(EXPR _index_1 ${_index}-1)
+	STRING(SUBSTRING "${str}" ${_index_1} 1 _strCursor)
+	#MESSAGE("***STRING_UNQUOTE: _i=${_index} _strCursor=${_strCursor}")
+
+	IF(NOT "${_strCursor}" MATCHES "${regex}")
+	    SET(_ret ${_index})
+	    SET(_index 0)
+	ENDIF(NOT "${_strCursor}" MATCHES "${regex}")
+	MATH(EXPR _index ${_index}-1)
+    ENDWHILE(_index GREATER 0)
+    SET(${var} ${_ret} PARENT_SCOPE)
+ENDFUNCTION(STRING_RIGHTMOST_NOTMATCH_INDEX var str)
+
+FUNCTION(STRING_TRIM var str)
+    #_STRING_ESCAPE(_ret "${str}" ${ARGN})
+    STRING_LEFTMOST_NOTMATCH_INDEX(_leftIndex "${str}" "[ \t\n\r]")
+    STRING_RIGHTMOST_NOTMATCH_INDEX(_rightIndex "${str}" "[ \t\n\r]")
+    # MESSAGE("_left=${_leftIndex} _rightIndex=${_rightIndex} str=|${str}|")
+    MATH(EXPR _subLen ${_rightIndex}-${_leftIndex})
+    SET(_NOUNQUOTE 0)
+    FOREACH( _arg ${ARGN})
+	IF(_arg STREQUAL "NOUNQUOTE")
+	    SET(_NOUNQUOTE 1)
+	ENDIF(_arg STREQUAL "NOUNQUOTE")
+    ENDFOREACH( _arg ${ARGN})
+
+    IF(_subLen GREATER 0)
+	STRING(SUBSTRING "${str}" ${_leftIndex} ${_subLen} _ret)
+	# IF _subLen > 1
+	#   IF UNQUOTE; then unquote
+	# Otherwise don't touch
+	IF (_subLen GREATER 1)
+	    IF(NOT _NOUNQUOTE)
+		STRING_UNQUOTE(_ret "${_ret}")
+	    ENDIF(NOT _NOUNQUOTE)
+	ENDIF (_subLen GREATER 1)
+    ELSE(_subLen GREATER 0)
+	SET(_ret "")
+    ENDIF(_subLen GREATER 0)
+    SET(${var} "${_ret}" PARENT_SCOPE)
+
+    # Unencoding
+    #_STRING_UNESCAPE(${var} "${_ret}" ${ARGN})
+ENDFUNCTION(STRING_TRIM var str)
+
+# Internal function
+# Nested Variable cannot be escaped here, as variable is already substituted
+# at the time it passes to this macro.
+FUNCTION(_STRING_ESCAPE var str)
+    # ';' and '\' are tricky, need to be encoded.
+    # '#' => '#H'
+    # '\' => '#B'
+    # ';' => '#S'
+    # '$' => '#D'
+    SET(_NOESCAPE_SEMICOLON "")
+    SET(_ESCAPE_VARIABLE "")
+
+    FOREACH(_arg ${ARGN})
+	IF(${_arg} STREQUAL "NOESCAPE_SEMICOLON")
+	    SET(_NOESCAPE_SEMICOLON "NOESCAPE_SEMICOLON")
+	ELSEIF(${_arg} STREQUAL "ESCAPE_VARIABLE")
+	    SET(_ESCAPE_VARIABLE "ESCAPE_VARIABLE")
+	ENDIF(${_arg} STREQUAL "NOESCAPE_SEMICOLON")
+    ENDFOREACH(_arg ${ARGN})
+
+    STRING(REGEX REPLACE "#" "#H" _ret "${str}")
+
+    STRING(REGEX REPLACE "\\\\" "#B" _ret "${_ret}")
+
+    IF(NOT _ESCAPE_VARIABLE STREQUAL "")
+	STRING(REGEX REPLACE "$" "#D" _ret "${_ret}")
+    ENDIF(NOT _ESCAPE_VARIABLE STREQUAL "")
+
+    IF(_NOESCAPE_SEMICOLON STREQUAL "")
+	STRING(REGEX REPLACE ";" "#S" _ret "${_ret}")
+    ENDIF(_NOESCAPE_SEMICOLON STREQUAL "")
+    #MESSAGE("_STRING_ESCAPE:_ret=${_ret}")
+    SET(${var} "${_ret}" PARENT_SCOPE)
+ENDFUNCTION(_STRING_ESCAPE var str)
+
+FUNCTION(_STRING_UNESCAPE var str)
+    # '#B' => '\'
+    # '#H' => '#'
+    # '#D' => '$'
+    # '#S' => ';'
+    SET(_ESCAPE_VARIABLE "")
+    SET(_NOESCAPE_SEMICOLON "")
+    SET(_ret "${str}")
+    FOREACH(_arg ${ARGN})
+	IF(${_arg} STREQUAL "NOESCAPE_SEMICOLON")
+	    SET(_NOESCAPE_SEMICOLON "NOESCAPE_SEMICOLON")
+	ELSEIF(${_arg} STREQUAL "ESCAPE_VARIABLE")
+	    SET(_ESCAPE_VARIABLE "ESCAPE_VARIABLE")
+	    STRING(REGEX REPLACE "#D" "$" _ret "${_ret}")
+	ENDIF(${_arg} STREQUAL "NOESCAPE_SEMICOLON")
+    ENDFOREACH(_arg ${ARGN})
+    #MESSAGE("###_STRING_UNESCAPE: var=${var} _ret=${_ret} _NOESCAPE_SEMICOLON=${_NOESCAPE_SEMICOLON} ESCAPE_VARIABLE=${_ESCAPE_VARIABLE}")
+
+    STRING(REGEX REPLACE "#B" "\\\\" _ret "${_ret}")
+    IF("${_NOESCAPE_SEMICOLON}" STREQUAL "")
+	# ESCAPE_SEMICOLON
+	STRING(REGEX REPLACE "#S" "\\\\;" _ret "${_ret}")
+    ELSE("${_NOESCAPE_SEMICOLON}" STREQUAL "")
+	# Don't ESCAPE_SEMICOLON
+	STRING(REGEX REPLACE "#S" ";" _ret "${_ret}")
+    ENDIF("${_NOESCAPE_SEMICOLON}" STREQUAL "")
+
+    IF(NOT _ESCAPE_VARIABLE STREQUAL "")
+	# '#D' => '$'
+	STRING(REGEX REPLACE "#D" "$" _ret "${_ret}")
+    ENDIF(NOT _ESCAPE_VARIABLE STREQUAL "")
+    STRING(REGEX REPLACE "#H" "#" _ret "${_ret}")
+    SET(${var} "${_ret}" PARENT_SCOPE)
+    #MESSAGE("*** _STRING_UNESCAPE: ${var}=${${var}}")
+ENDFUNCTION(_STRING_UNESCAPE var str)
+
+FUNCTION(STRING_UNQUOTE var str)
+    SET(_ret "${str}")
+    STRING(LENGTH "${str}" _strLen)
+
+    # IF _strLen > 1
+    #   IF lCh and rCh are both "\""
+    #      Remove _lCh and _rCh
+    #   ELSEIF lCh and rCh are both "'"
+    #      Remove _lCh and _rCh
+    # Otherwise don't touch
+    IF(_strLen GREATER 1)
+	STRING(SUBSTRING "${str}" 0 1 _lCh)
+	MATH(EXPR _strLen_1 ${_strLen}-1)
+	MATH(EXPR _strLen_2 ${_strLen_1}-1)
+	STRING(SUBSTRING "${str}" ${_strLen_1} 1 _rCh)
+	#MESSAGE("_lCh=${_lCh} _rCh=${_rCh} _ret=|${_ret}|")
+	IF("${_lCh}" STREQUAL "\"" AND "${_rCh}" STREQUAL "\"")
+	    STRING(SUBSTRING "${_ret}" 1 ${_strLen_2} _ret)
+	ELSEIF("${_lCh}" STREQUAL "'" AND "${_rCh}" STREQUAL "'")
+	    STRING(SUBSTRING "${_ret}" 1 ${_strLen_2} _ret)
+	ENDIF("${_lCh}" STREQUAL "\"" AND "${_rCh}" STREQUAL "\"")
+    ENDIF (_strLen GREATER 1)
+    SET(${var} "${_ret}" PARENT_SCOPE)
+ENDFUNCTION(STRING_UNQUOTE var str)
+
+MACRO(STRING_JOIN var delimiter)
+    SET(_ret "")
+    FOREACH(_str ${ARGN})
+	STRING_APPEND(_ret "${_str}" "${delimiter}")
+    ENDFOREACH(_str ${ARGN})
+    SET(${var} "${_ret}")
+ENDMACRO(STRING_JOIN var delimiter)
+
+FUNCTION(STRING_FIND var str search_str)
+    STRING(LENGTH "${str}" _str_len)
+    STRING(LENGTH "${search_str}" _search_len)
+    MATH(EXPR _str_end ${_str_len}-${_search_len}+1)
+
+    SET(_index 0)
+    SET(_str_remain "")
+    SET(_result -1)
+    WHILE(_index LESS _str_end)
+	STRING(SUBSTRING "${str}" ${_index} ${_search_len} _str_window)
+	IF(_str_window STREQUAL search_str)
+	    SET(_result ${_index})
+	    BREAK()
+	ELSE(_str_window STREQUAL search_str)
+	    MATH(EXPR _index ${_index}+1)
+	ENDIF(_str_window STREQUAL search_str)
+    ENDWHILE(_index LESS _str_end)
+    SET(${var} ${_result} PARENT_SCOPE)
+ENDFUNCTION(STRING_FIND var str search)
+
+FUNCTION(STRING_SPLIT_2 var str_remain has_delimiter delimiter str)
+    STRING_FIND(_index "${str}" "${delimiter}")
+    IF(_index EQUAL -1)
+	SET(${has_delimiter} "0" PARENT_SCOPE)
+	SET(${var} "${str}" PARENT_SCOPE)
+	SET(${str_remain} "" PARENT_SCOPE)
+    ELSE(_index EQUAL -1)
+	SET(${has_delimiter} "1" PARENT_SCOPE)
+	STRING(SUBSTRING "${str}" 0 ${_index} _var)
+	SET(${var} "${_var}" PARENT_SCOPE)
+
+	STRING(LENGTH "${str}" _str_len)
+	STRING(LENGTH "${delimiter}" _delimiter_len)
+	MATH(EXPR _str_2_start ${_index}+${_delimiter_len})
+	MATH(EXPR _str_2_len ${_str_len}-${_index}-${_delimiter_len})
+	STRING(SUBSTRING "${str}" ${_str_2_start} ${_str_2_len} _str_remain)
+	SET(${str_remain} "${_str_remain}" PARENT_SCOPE)
+    ENDIF(_index EQUAL -1)
+ENDFUNCTION(STRING_SPLIT_2 var str_remain has_delimiter delimiter str)
+
+FUNCTION(STRING_SPLIT var delimiter str)
+    #MESSAGE("***STRING_SPLIT: var=${var} str=${str}")
+    SET(_max_tokens "")
+    SET(_NOESCAPE_SEMICOLON "")
+    SET(_ESCAPE_VARIABLE "")
+    SET(_ALLOW_EMPTY "")
+    FOREACH(_arg ${ARGN})
+	IF(${_arg} STREQUAL "NOESCAPE_SEMICOLON")
+	    SET(_NOESCAPE_SEMICOLON "NOESCAPE_SEMICOLON")
+	ELSEIF(${_arg} STREQUAL "ESCAPE_VARIABLE")
+	    SET(_ESCAPE_VARIABLE "ESCAPE_VARIABLE")
+	ELSEIF(${_arg} STREQUAL "ALLOW_EMPTY")
+	    SET(_ALLOW_EMPTY "ALLOW_EMPTY")
+	ELSE(${_arg} STREQUAL "NOESCAPE_SEMICOLON")
+	    SET(_max_tokens ${_arg})
+	ENDIF(${_arg} STREQUAL "NOESCAPE_SEMICOLON")
+    ENDFOREACH(_arg ${ARGN})
+
+    IF(NOT _max_tokens)
+	SET(_max_tokens -1)
+    ENDIF(NOT _max_tokens)
+
+    _STRING_ESCAPE(_str "${str}" ${_NOESCAPE_SEMICOLON} ${_ESCAPE_VARIABLE})
+    _STRING_ESCAPE(_delimiter "${delimiter}" ${_NOESCAPE_SEMICOLON} ${_ESCAPE_VARIABLE})
+    SET(_str_list "")
+    SET(_token_count 1)
+
+    WHILE(NOT _token_count EQUAL _max_tokens)
+	STRING_SPLIT_2(_token _str _has_delimiter "${_delimiter}" "${_str}")
+	#MESSAGE("_token_count=${_token_count} _max_tokens=${_max_tokens} _token=|${_token}| _str=${_str}")
+	MATH(EXPR _token_count ${_token_count}+1)
+	# Use length check to avoid the reserved word like "type"
+	STRING(LENGTH "${_token}" _token_len)
+
+	IF(_token_len GREATER 0 OR _ALLOW_EMPTY)
+    	    LIST(APPEND _str_list "${_token}")
+	ENDIF(_token_len GREATER 0 OR _ALLOW_EMPTY)
+	IF(_has_delimiter EQUAL 0)
+	    ## No more tokens
+	    BREAK()
+	ENDIF(_has_delimiter EQUAL 0)
+    ENDWHILE(NOT _token_count EQUAL _max_tokens)
+
+    IF(_has_delimiter EQUAL 1)
+	LIST(APPEND _str_list "${_str}")
+    ENDIF(_has_delimiter EQUAL 1)
+
+    # Unencoding
+    _STRING_UNESCAPE(_var "${_str_list}" ${_NOESCAPE_SEMICOLON} ${_ESCAPE_VARIABLE})
+    #MESSAGE("***STRING_SPLIT: tokens=${${var}}")
+    SET(${var} "${_var}" PARENT_SCOPE)
+ENDFUNCTION(STRING_SPLIT var delimiter str)
+
diff -Nura ibus-chewing-1.6.1/Modules/ManageTarget.cmake ibus-chewing-1.6.1_new/Modules/ManageTarget.cmake
--- ibus-chewing-1.6.1/Modules/ManageTarget.cmake	1970-01-01 08:00:00.000000000 +0800
+++ ibus-chewing-1.6.1_new/Modules/ManageTarget.cmake	2014-10-28 13:05:31.000000000 +0800
@@ -0,0 +1,59 @@
+# - Manage targets and output files.
+#
+# Included Modules:
+#   - ManageVariable
+#
+# Defines following functions:
+#   ADD_CUSTOM_TARGET_COMMAND(<target> OUTPUT <file1> ...
+#     [ALL] [NO_FORCE] COMMAND <command1> ...
+#     [<addCustomTargetOpt> ...]
+#   )
+#   - Combine ADD_CUSTOM_TARGET and ADD_CUSTOM_COMMAND.
+#     This command is handy if you want a target that always refresh
+#     the output files without writing the same build recipes
+#     in separate ADD_CUSTOM_TARGET and ADD_CUSTOM_COMMAND.
+#
+#     If you also want a target that run only if output files 
+#     do not exist or outdated. Specify "NO_FORCE".
+#     The target for that will be "<target>_no_force".
+#     * Parameters:
+#       + target: target for this command
+#       + OUTPUT file1 ... : Files to be outputted by this command
+#       + ALL: (Optional) The target is built with target 'all'
+#       + NO_FORCE: (Optional) Produce a target that run only if 
+#         output files do not exist or outdated. 
+#       + COMMAND command ... : Command to be run. 
+#       + addCustomTargetOpt ...: ADD_CUSTOM_TARGET.options.
+#     * Targets:
+#       + <target>: Target to be invoke.
+#
+
+IF(DEFINED _MANAGE_TARGET_CMAKE_)
+    RETURN()
+ENDIF(DEFINED _MANAGE_TARGET_CMAKE_)
+SET(_MANAGE_TARGET_CMAKE_ "DEFINED")
+INCLUDE(ManageVariable)
+FUNCTION(ADD_CUSTOM_TARGET_COMMAND target)
+    SET(_validOptions "OUTPUT" "ALL" "NO_FORCE" "COMMAND")
+    VARIABLE_PARSE_ARGN(_opt _validOptions ${ARGN})
+    IF(DEFINED _opt_ALL)
+	SET(_all "ALL")
+    ELSE(DEFINED _opt_ALL)
+	SET(_all "")
+    ENDIF(DEFINED _opt_ALL)
+
+    ADD_CUSTOM_TARGET(${target} ${_all}
+	COMMAND ${_opt_COMMAND}
+	)
+
+    ADD_CUSTOM_COMMAND(OUTPUT ${_opt_OUTPUT} 
+	COMMAND ${_opt_COMMAND}
+	)
+
+    IF(DEFINED _opt_NO_FORCE)
+	ADD_CUSTOM_TARGET(${target}_no_force
+	    DEPENDS ${_opt_OUTPUT}
+	    )
+    ENDIF(DEFINED _opt_NO_FORCE)
+ENDFUNCTION(ADD_CUSTOM_TARGET_COMMAND)
+
diff -Nura ibus-chewing-1.6.1/Modules/ManageTranslation.cmake ibus-chewing-1.6.1_new/Modules/ManageTranslation.cmake
--- ibus-chewing-1.6.1/Modules/ManageTranslation.cmake	1970-01-01 08:00:00.000000000 +0800
+++ ibus-chewing-1.6.1_new/Modules/ManageTranslation.cmake	2016-02-25 22:53:41.000000000 +0800
@@ -0,0 +1,669 @@
+# - Manage Translation
+# This module supports software translation by:
+#   Creates gettext related targets.
+#   Communicate to Zanata servers.
+#
+# By calling MANAGE_GETTEXT(), following variables are available in cache:
+#   - MANAGE_TRANSLATION_LOCALES: Locales that would be processed.
+#
+# Included Modules:
+#   - ManageArchive
+#   - ManageDependency
+#   - ManageFile
+#   - ManageMessage
+#   - ManageString
+#   - ManageVariable
+#   - ManageZanataSuggest
+#
+# Defines following targets:
+#   + translations: Virtual target that make the translation files.
+#     Once MANAGE_GETTEXT is used, this target invokes targets that
+#     build translation.
+#
+# Defines following variables:
+#   + XGETTEXT_OPTIONS_C: Default xgettext options for C programs.
+# Defines or read from following variables:
+#   + MANAGE_TRANSLATION_MSGFMT_OPTIONS: msgfmt options
+#     Default: --check --check-compatibility --strict
+#   + MANAGE_TRANSLATION_MSGMERGE_OPTIONS: msgmerge options
+#     Default: --update --indent --backup=none
+#   + MANAGE_TRANSLATION_XGETEXT_OPTIONS: xgettext options
+#     Default: ${XGETTEXT_OPTIONS_C}
+#
+# Defines following functions:
+#   MANAGE_POT_FILE(<potFile> 
+#       [SRCS <src> ...]
+#       [PO_DIR <dir>]
+#       [MO_DIR <dir>|MO_LOCALE_DIR <dir>| NO_MO]
+#       [NO_MO]
+#	[LOCALES <locale> ... | SYSTEM_LOCALES]
+#	[XGETTEXT_OPTIONS <opt> ...]
+#       [MSGMERGE_OPTIONS <msgmergeOpt>]
+#       [MSGFMT_OPTIONS <msgfmtOpt>]
+#       [CLEAN]
+#       [COMMAND <cmd> ...]
+#       [DEPENDS <file> ...]
+#     )
+#     - Add a new pot file and source files that create the pot file.
+#       It is mandatory if for multiple pot files.
+#       By default, cmake-fedora will set the directory property
+#       PROPERTIES CLEAN_NO_CUSTOM as "1" to prevent po files get cleaned
+#       by "make clean". For this behavior to be effective, invoke this function
+#       in the directory that contains generated PO file.
+#       * Parameters:
+#         + <potFile>: .pot file with path.
+#         + SRCS <src> ... : Source files for xgettext to work on.
+#         + DOMAIN_NAME <domainName>: gettext domain name.
+#           Default: .pot filename without extension.
+#         + PO_DIR <dir>: Directory of .po files.
+#             This option is mandatory if .pot and associated .po files
+#             are not in the same directory.
+#           Default: Same directory of <potFile>.
+#         + MO_DIR dir: Directory to create .gmo files. The .gmo files 
+#           are created as: <dir>/<locale>.gmo
+#           This option collide with NO_MO and MO_LOCALE_DIR.
+#           Default: Same with PO_DIR
+#         + MO_LOCALE_DIR dir: Directory to create .mo files. The .mo files 
+#           are created as: <dir>/locale/<locale>/LC_MESSAGES/<domainName>.mo
+#           This option collide with NO_MO and MO_DIR.
+#         + NO_MO: Skip the mo generation, usually for document trnslation
+#           that do not require MO.
+#           This option collide with MO_DIR and MO_LOCALE_DIR.
+#         + LOCALES locale ... : (Optional) Locale list to be generated.
+#         + SYSTEM_LOCALES: (Optional) System locales from /usr/share/locale.
+#         + XGETTEXT_OPTIONS opt ... : xgettext options.
+#         + MSGMERGE_OPTIONS msgmergeOpt: (Optional) msgmerge options.
+#           Default: ${MANAGE_TRANSLATION_MSGMERGE_OPTIONS}, which is
+#         + MSGFMT_OPTIONS msgfmtOpt: (Optional) msgfmt options.
+#           Default: ${MANAGE_TRANSLATION_MSGFMT_OPTIONS}
+#         + CLEAN: Clean the POT, PO, MO files when doing make clean
+#             By default, cmake-fedora will set the directory property
+#             PROPERTIES CLEAN_NO_CUSTOM as "1" to prevent po files get cleaned.
+#             Specify "CLEAN" to override this behavior.
+#         + COMMAND cmd ... : Non-xgettext command that create pot file.
+#         + DEPENDS file ... : Files that pot file depends on.
+#             SRCS files are already depended on, so no need to list here.
+#       * Variables to cache:
+#         + MANAGE_TRANSLATION_GETTEXT_POT_FILES: List of pot files.
+#         + MANAGE_TRANSLATION_GETTEXT_PO_FILES: List of all po files.
+#         + MANAGE_TRANSLATION_GETTEXT_MO_FILES: List of all mo filess.
+#         + MANAGE_TRANSLATION_LOCALES: List of locales.
+#
+#   MANAGE_GETTEXT([ALL] 
+#       [POT_FILE <potFile>]
+#       [SRCS <src> ...]
+#       [PO_DIR <dir>]
+#       [MO_DIR <dir>]
+#       [NO_MO]
+#	[LOCALES <locale> ... | SYSTEM_LOCALES]
+#	[XGETTEXT_OPTIONS <opt> ...]
+#       [MSGMERGE_OPTIONS <msgmergeOpt>]
+#       [MSGFMT_OPTIONS <msgfmtOpt>]
+#       [CLEAN]
+#       [DEPENDS <file> ...]
+#     )
+#     - Manage Gettext support.
+#       If no POT files were added, it invokes MANAGE_POT_FILE and manage .pot, .po and .gmo files.
+#       This command creates targets for making the translation files.
+#       So naturally, this command should be invoke after the last MANAGE_POT_FILE command.
+#       The parameters are similar to the ones at MANAGE_POT_FILE, except:
+#       * Parameters:
+#         + ALL: (Optional) make target "all" depends on gettext targets.
+#         + POT_FILE potFile: (Optional) pot files with path.
+#           Default: ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}.pot
+#         Refer MANAGE_POT_FILE for rest of the parameters.
+#       * Targets:
+#         + pot_files: Generate pot files.
+#         + update_po: Update po files according to pot files.
+#         + gmo_files: Converts po files to mo files.
+#         + translation: Complete all translation tasks.
+#       * Variables to cache:
+#         + MANAGE_TRANSLATION_GETTEXT_POT_FILES: List of pot files.
+#         + MANAGE_TRANSLATION_GETTEXT_PO_FILES: List of all po files.
+#         + MANAGE_TRANSLATION_GETTEXT_MO_FILES: Lis of all mo filess.
+#         + MANAGE_TRANSLATION_LOCALES: List of locales. 
+#       * Variables to cache:
+#         + MSGINIT_EXECUTABLE: the full path to the msginit tool.
+#         + MSGMERGE_EXECUTABLE: the full path to the msgmerge tool.
+#         + MSGFMT_EXECUTABLE: the full path to the msgfmt tool.
+#         + XGETTEXT_EXECUTABLE: the full path to the xgettext.
+#         + MANAGE_LOCALES: Locales to be processed.
+#
+
+IF(DEFINED _MANAGE_TRANSLATION_CMAKE_)
+    RETURN()
+ENDIF(DEFINED _MANAGE_TRANSLATION_CMAKE_)
+SET(_MANAGE_TRANSLATION_CMAKE_ "DEFINED")
+INCLUDE(ManageMessage)
+INCLUDE(ManageFile)
+INCLUDE(ManageString)
+INCLUDE(ManageVariable)
+INCLUDE(ManageZanataSuggest)
+
+#######################################
+# GETTEXT support
+#
+
+SET(XGETTEXT_OPTIONS_COMMON --from-code=UTF-8 --indent
+    --sort-by-file
+    )
+
+SET(XGETTEXT_OPTIONS_C ${XGETTEXT_OPTIONS_COMMON} 
+    --language=C     
+    --keyword=_ --keyword=N_ --keyword=C_:1c,2 --keyword=NC_:1c,2 
+    --keyword=gettext --keyword=dgettext:2
+    --keyword=dcgettext:2 --keyword=ngettext:1,2
+    --keyword=dngettext:2,3 --keyword=dcngettext:2,3
+    --keyword=gettext_noop --keyword=pgettext:1c,2
+    --keyword=dpgettext:2c,3 --keyword=dcpgettext:2c,3
+    --keyword=npgettext:1c,2,3 --keyword=dnpgettext:2c,3,4 
+    --keyword=dcnpgettext:2c,3,4.
+    )
+
+SET(MANAGE_TRANSLATION_MSGFMT_OPTIONS 
+    "--check" CACHE STRING "msgfmt options"
+    )
+SET(MANAGE_TRANSLATION_MSGMERGE_OPTIONS 
+    "--indent" "--update" "--sort-by-file" "--backup=none" 
+    CACHE STRING "msgmerge options"
+    )
+SET(MANAGE_TRANSLATION_XGETTEXT_OPTIONS 
+    ${XGETTEXT_OPTIONS_C}
+    CACHE STRING "xgettext options"
+    )
+
+FUNCTION(MANAGE_TRANSLATION_GETTEXT_POT_FILES_SET value)
+    SET(MANAGE_TRANSLATION_GETTEXT_POT_FILES "${value}" CACHE INTERNAL "POT files")
+ENDFUNCTION()
+
+FUNCTION(MANAGE_TRANSLATION_GETTEXT_POT_FILES_ADD)
+    LIST(APPEND MANAGE_TRANSLATION_GETTEXT_POT_FILES ${ARGN})
+    MANAGE_TRANSLATION_GETTEXT_POT_FILES_SET("${MANAGE_TRANSLATION_GETTEXT_POT_FILES}")
+ENDFUNCTION()
+
+FUNCTION(MANAGE_TRANSLATION_GETTEXT_PO_FILES_SET value)
+    SET(MANAGE_TRANSLATION_GETTEXT_PO_FILES "${value}" CACHE INTERNAL "PO files")
+ENDFUNCTION()
+
+FUNCTION(MANAGE_TRANSLATION_GETTEXT_PO_FILES_ADD)
+    LIST(APPEND MANAGE_TRANSLATION_GETTEXT_PO_FILES ${ARGN})
+    MANAGE_TRANSLATION_GETTEXT_PO_FILES_SET("${MANAGE_TRANSLATION_GETTEXT_PO_FILES}")
+ENDFUNCTION()
+
+FUNCTION(MANAGE_TRANSLATION_GETTEXT_MO_FILES_SET value)
+    SET(MANAGE_TRANSLATION_GETTEXT_MO_FILES "${value}" CACHE INTERNAL "MO files")
+ENDFUNCTION()
+
+FUNCTION(MANAGE_TRANSLATION_GETTEXT_MO_FILES_ADD)
+    LIST(APPEND MANAGE_TRANSLATION_GETTEXT_MO_FILES ${ARGN})
+    MANAGE_TRANSLATION_GETTEXT_MO_FILES_SET("${MANAGE_TRANSLATION_GETTEXT_MO_FILES}")
+ENDFUNCTION()
+
+FUNCTION(MANAGE_TRANSLATION_LOCALES_SET value)
+    SET(MANAGE_TRANSLATION_LOCALES "${value}" CACHE INTERNAL "Translation Locales")
+ENDFUNCTION()
+
+FUNCTION(MANAGE_GETTEXT_INIT)
+    IF(DEFINED MANAGE_GETTEXT_SUPPORT)
+	RETURN()
+    ENDIF()
+    INCLUDE(ManageArchive)
+    INCLUDE(ManageDependency)
+    MANAGE_DEPENDENCY(BUILD_REQUIRES GETTEXT REQUIRED)
+    MANAGE_DEPENDENCY(BUILD_REQUIRES FINDUTILS REQUIRED)
+    MANAGE_DEPENDENCY(REQUIRES GETTEXT REQUIRED)
+
+    FOREACH(_name "xgettext" "msgmerge" "msgfmt" "msginit")
+	STRING(TOUPPER "${_name}" _cmd)
+	FIND_PROGRAM_ERROR_HANDLING(${_cmd}_EXECUTABLE
+	    ERROR_MSG " gettext support is disabled."
+	    ERROR_VAR _gettext_dependency_missing
+	    VERBOSE_LEVEL ${M_OFF}
+	    "${_name}"
+	    )
+	M_MSG(${M_INFO1} "${_cmd}_EXECUTABLE=${${_cmd}_EXECUTABLE}")
+    ENDFOREACH(_name "xgettext" "msgmerge" "msgfmt")
+
+    MANAGE_TRANSLATION_GETTEXT_POT_FILES_SET("")
+    IF(gettext_dependency_missing)
+	SET(MANAGE_GETTEXT_SUPPORT "0" CACHE INTERNAL "Gettext support")
+    ELSE()
+	SET(MANAGE_GETTEXT_SUPPORT "1" CACHE INTERNAL "Gettext support")
+	MANAGE_TRANSLATION_GETTEXT_PO_FILES_SET("")
+	MANAGE_TRANSLATION_GETTEXT_MO_FILES_SET("")
+	MANAGE_TRANSLATION_LOCALES_SET("")
+    ENDIF()
+ENDFUNCTION(MANAGE_GETTEXT_INIT)
+
+SET(MANAGE_POT_FILE_VALID_OPTIONS "SRCS" "DOMAIN_NAME" "PO_DIR" "MO_DIR"
+    "MO_LOCALE_DIR" "NO_MO" "LOCALES" "SYSTEM_LOCALES" "XGETTEXT_OPTIONS"
+    "MSGMERGE_OPTIONS" "MSGFMT_OPTIONS" "CLEAN" "COMMAND" "DEPENDS"
+    )
+## Internal
+FUNCTION(MANAGE_POT_FILE_SET_VARS potFile)
+    VARIABLE_PARSE_ARGN(_o MANAGE_POT_FILE_VALID_OPTIONS ${ARGN})
+    SET(cmdList "")
+    IF("${_o_COMMAND}" STREQUAL "")
+	LIST(APPEND cmdList ${XGETTEXT_EXECUTABLE})
+	IF(NOT _o_XGETTEXT_OPTIONS)
+	    SET(_o_XGETTEXT_OPTIONS 
+		"${MANAGE_TRANSLATION_XGETTEXT_OPTIONS}"
+		)
+	ENDIF()
+	LIST(APPEND cmdList ${_o_XGETTEXT_OPTIONS})
+	IF("${_o_SRCS}" STREQUAL "")
+	    M_MSG(${M_WARN} 
+		"MANAGE_POT_FILE: xgettext: No SRCS for ${potFile}"
+		)
+	ENDIF()
+	LIST(APPEND cmdList -o ${potFile}
+	    "--package-name=${PROJECT_NAME}"
+	    "--package-version=${PRJ_VER}"
+	    "--msgid-bugs-address=${MAINTAINER}"
+	    ${_o_SRCS}
+	    )
+    ELSE()
+	SET(cmdList "${_o_COMMAND}")
+    ENDIF()
+    SET(cmdList "${cmdList}" PARENT_SCOPE)
+    SET(srcs "${_o_SRCS}" PARENT_SCOPE)
+    SET(depends "${_o_DEPENDS}" PARENT_SCOPE)
+
+    GET_FILENAME_COMPONENT(_potDir "${potFile}" PATH)
+    IF("${_o_PO_DIR}" STREQUAL "")
+	SET(_o_PO_DIR "${_potDir}")
+    ENDIF()
+    SET(poDir "${_o_PO_DIR}" PARENT_SCOPE)
+
+    IF("${_o_DOMAIN_NAME}" STREQUAL "")
+	GET_FILENAME_COMPONENT(_domainName "${potFile}" NAME_WE)
+	SET(domainName "${_domainName}" PARENT_SCOPE)
+    ELSE()
+	SET(domainName "${_o_DOMAIN_NAME}" PARENT_SCOPE)
+    ENDIF()
+
+    IF("${_o_MSGMERGE_OPTIONS}" STREQUAL "")
+	SET(_o_MSGMERGE_OPTIONS "${MANAGE_TRANSLATION_MSGMERGE_OPTIONS}")
+    ENDIF()
+    SET(msgmergeOpts "${_o_MSGMERGE_OPTIONS}" PARENT_SCOPE)
+
+    IF("${_o_MSGFMT_OPTIONS}" STREQUAL "")
+	SET(_o_MSGFMT_OPTIONS "${MANAGE_TRANSLATION_MSGFMT_OPTIONS}")
+    ENDIF()
+    SET(msgfmtOpts "${_o_MSGFMT_OPTIONS}" PARENT_SCOPE)
+
+    IF(DEFINED _o_NO_MO)
+	SET(moMode "NO_MO")
+    ENDIF()
+
+    IF(DEFINED _o_MO_LOCALE_DIR)
+	IF(moMode)
+	    M_MSG(${M_ERROR} "MO_LOCALE_DIR cannot be used with ${moMode}")
+	ENDIF()
+	SET(moLocaleDir "${_o_MO_LOCALE_DIR}" PARENT_SCOPE)
+	SET(moMode "MO_LOCALE_DIR")
+    ENDIF()
+
+    IF(DEFINED _o_MO_DIR)
+	IF(moMode)
+	    M_MSG(${M_ERROR} "MO_DIR cannot be used with ${moMode}")
+	ENDIF()
+	SET(moDir "${_o_MO_DIR}" PARENT_SCOPE)
+	SET(moMode "MO_DIR")
+    ENDIF()
+
+    ## Default to MO_DIR if none are not specified, 
+    IF(NOT moMode)
+	SET(moDir "${_o_PO_DIR}" PARENT_SCOPE)
+	SET(moMode "MO_DIR")
+    ENDIF()
+    SET(moMode "${moMode}" PARENT_SCOPE)
+
+    IF(NOT DEFINED _o_CLEAN)
+	SET_DIRECTORY_PROPERTIES(PROPERTIES CLEAN_NO_CUSTOM "1")
+	SET(allClean 0 PARENT_SCOPE)
+    ELSE()
+	SET(allCleanVar 1 PARENT_SCOPE)
+    ENDIF()
+ENDFUNCTION(MANAGE_POT_FILE_SET_VARS)
+
+FUNCTION(MANAGE_POT_FILE_OBTAIN_TARGET_NAME var potFile)
+    FILE(RELATIVE_PATH potFileRel ${CMAKE_SOURCE_DIR} ${potFile})
+    STRING(REPLACE "/" "_" target "${potFileRel}")
+    STRING_PREPEND(target "pot_file_")
+    SET(${var} "${target}" PARENT_SCOPE)
+ENDFUNCTION(MANAGE_POT_FILE_OBTAIN_TARGET_NAME)
+
+## This function skip target setup when target exists
+## Use MANAGE_POT_FILE if you want check and warning
+FUNCTION(MANAGE_POT_FILE_INTERNAL showWarning potFile)
+    IF(NOT DEFINED MANAGE_GETTEXT_SUPPORT)
+	MANAGE_GETTEXT_INIT()
+    ENDIF()
+    IF(MANAGE_GETTEXT_SUPPORT EQUAL 0)
+	RETURN()
+    ENDIF()
+
+    ## Whether pot file already exists in MANAGE_TRANSLATION_GETTEXT_POT_FILES
+    MANAGE_POT_FILE_OBTAIN_TARGET_NAME(targetName "${potFile}")
+
+    IF(TARGET ${targetName})
+	IF(showWarning)
+	    M_MSG(${M_WARN} "MANAGE_POT_FILE: Target ${targetName} is already exists, skip")
+	ENDIF()
+	RETURN()
+    ENDIF()
+
+    MANAGE_POT_FILE_SET_VARS("${potFile}" ${ARGN})
+
+    ADD_CUSTOM_TARGET_COMMAND(${targetName}
+	OUTPUT ${potFile}
+	NO_FORCE
+	COMMAND ${cmdList}
+	DEPENDS ${srcs} ${depends}
+	COMMENT "${potFile}: ${cmdList}"
+	VERBATIM
+	)
+    MANAGE_TRANSLATION_GETTEXT_POT_FILES_ADD("${potFile}")
+    SOURCE_ARCHIVE_CONTENTS_ADD("${potFile}" ${srcs} ${depends})
+    SET(cleanList "${potFile}")
+
+    SET(_moInstallRoot "${DATA_DIR}/locale")
+    ## Not only POT, but also PO and MO as well
+    FOREACH(_l ${MANAGE_TRANSLATION_LOCALES})
+	## PO file
+	SET(_poFile "${poDir}/${_l}.po")
+	ADD_CUSTOM_COMMAND(OUTPUT ${_poFile}
+	    COMMAND ${CMAKE_BUILD_TOOL} ${targetName}_no_force
+	    COMMAND ${CMAKE_COMMAND} 
+	    -D cmd=po_make
+	    -D "pot=${potFile}"
+	    -D "locales=${_l}"
+	    -D "options=${msgmergeOpts}"
+	    -D "po_dir=${poDir}"
+	    -P ${CMAKE_FEDORA_MODULE_DIR}/ManageGettextScript.cmake
+	    COMMENT "Create ${_poFile} from ${potFile}"
+	    VERBATIM
+	    )
+	MANAGE_TRANSLATION_GETTEXT_PO_FILES_ADD("${_poFile}")
+	SOURCE_ARCHIVE_CONTENTS_ADD("${_poFile}")
+
+	## MO file
+	SET(_moInstallDir "${_moInstallRoot}/${_l}/LC_MESSAGES")
+	IF(NOT "${moDir}" STREQUAL "")
+	    SET(_moFile "${moDir}/${_l}.gmo")
+	    FILE(MAKE_DIRECTORY "${moDir}")
+	ELSEIF(moLocaleDir)
+	    SET(_moFile "${moLocaleDir}/locale/${_l}/LC_MESSAGES/${domainName}.mo")
+	    FILE(MAKE_DIRECTORY "${moLocaleDir}/locale/${_l}/LC_MESSAGES")
+	ENDIF()
+
+	IF(NOT "${moMode}" STREQUAL "NO_MO")
+	    ADD_CUSTOM_COMMAND(OUTPUT ${_moFile}
+		COMMAND ${MSGFMT_EXECUTABLE} 
+		-o "${_moFile}"
+		"${_poFile}"
+		DEPENDS ${_poFile}
+		)
+
+	    MANAGE_TRANSLATION_GETTEXT_MO_FILES_ADD("${_moFile}")
+
+	    INSTALL(FILES ${_moFile} DESTINATION "${_moInstallDir}"
+		RENAME "${domainName}.mo"
+		)
+	    LIST(APPEND cleanList "${_moFile}")
+	ENDIF()
+
+    ENDFOREACH(_l)
+    IF(NOT allClean)
+	SET_DIRECTORY_PROPERTIES(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES "${cleanList}")
+    ENDIF()
+ENDFUNCTION(MANAGE_POT_FILE_INTERNAL)
+
+FUNCTION(MANAGE_POT_FILE potFile)
+    MANAGE_POT_FILE_INTERNAL(1 "${potFile}" ${ARGN})
+ENDFUNCTION(MANAGE_POT_FILE)
+
+SET(MANAGE_GETTEXT_LOCALES_VALID_OPTIONS "WORKING_DIRECTORY" "LOCALES" "SYSTEM_LOCALES" "DETECT_PO_DIR" "SRCS")
+FUNCTION(MANAGE_GETTEXT_LOCALES localeListVar)
+    VARIABLE_PARSE_ARGN(_o MANAGE_GETTEXT_LOCALES_VALID_OPTIONS ${ARGN})
+    SET(_detectedPoDir "NOTFOUND")
+    IF(NOT "${_o_LOCALES}" STREQUAL "")
+	## Locale is defined
+    ELSEIF(DEFINED _o_SYSTEM_LOCALES)
+	EXECUTE_PROCESS(
+	    COMMAND ls -1 /usr/share/locale/
+	    COMMAND grep -e "^[a-z]*\\(_[A-Z]*\\)\\?\\(@.*\\)\\?$"
+	    COMMAND sort -u 
+	    COMMAND xargs 
+	    COMMAND sed -e "s/ /;/g"
+	    OUTPUT_VARIABLE _o_LOCALES
+	    OUTPUT_STRIP_TRAILING_WHITESPACE
+	    )
+    ELSE()
+	IF("${_o_WORKING_DIRECTORY}" STREQUAL "")
+	    SET(_o_WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}")
+	ENDIF()
+
+	## LOCALES is not specified, detect now
+	EXECUTE_PROCESS(
+	    COMMAND find . -name "*.po"
+	    COMMAND sed -e "s|^\\./||"
+	    COMMAND sort -u
+	    COMMAND xargs
+	    COMMAND sed -e "s/ /;/g"
+	    WORKING_DIRECTORY "${_o_WORKING_DIRECTORY}"
+	    OUTPUT_VARIABLE _poFileList
+	    OUTPUT_STRIP_TRAILING_WHITESPACE
+	    )
+	IF("${_poFileList}" STREQUAL "")
+	    M_MSG(${M_ERROR} "MANAGE_GETTEXT_LOCALES: Failed to find any .po files. Please either provide .po files, or specify SYSTEM_LOCALES or LOCALES")
+	ENDIF()
+	MANAGE_FILE_COMMON_DIR(_detectedPoDir ${_poFileList})
+
+	## Empty _detectedPoDir means the PO files are in current directory
+	IF("${_detectedPoDir}" STREQUAL "")
+	    SET(_commonPath "")
+	ELSE()
+	    GET_FILENAME_COMPONENT(_commonPath "${_o_WORKING_DIRECTORY}/${_detectedPoDir}" ABSOLUTE)
+	ENDIF()
+	FOREACH(_poFile ${_poFileList})
+	    IF("${_commonPath}" STREQUAL "")
+		SET(_rF "${_poFile}")
+	    ELSE()
+		GET_FILENAME_COMPONENT(_filePath "${_poFile}" ABSOLUTE)
+		FILE(RELATIVE_PATH _rF "${_commonPath}" "${_filePath}")
+	    ENDIF()
+	    LOCALE_IN_PATH(_l "${_rF}")
+	    IF(NOT "${_l}" STREQUAL "")
+		LIST(APPEND _o_LOCALES "${_l}")
+	    ENDIF()
+	ENDFOREACH()
+
+	IF("${_o_LOCALES}" STREQUAL "")
+	    ## Failed to find any locale
+	    M_MSG(${M_ERROR} "MANAGE_GETTEXT_LOCALES: Failed to detect locales. Please either provide .po files, or specify SYSTEM_LOCALES or  LOCALES")
+	ENDIF()
+	LIST(REMOVE_DUPLICATES _o_LOCALES)
+	LIST(SORT _o_LOCALES)
+    ENDIF()
+    MANAGE_TRANSLATION_LOCALES_SET("${_o_LOCALES}")
+    SET(${localeListVar} "${_o_LOCALES}" PARENT_SCOPE)
+
+    ## Return detected po dir if requested
+    IF(NOT "${_o_DETECT_PO_DIR}" STREQUAL "")
+	SET(${_o_DETECT_PO_DIR} "${detectedPoDir}" PARENT_SCOPE)
+    ENDIF()
+ENDFUNCTION(MANAGE_GETTEXT_LOCALES)
+
+SET(MANAGE_GETTEXT_VALID_OPTIONS ${MANAGE_POT_FILE_VALID_OPTIONS} "ALL" "POT_FILE")
+FUNCTION(MANAGE_GETTEXT)
+    IF(NOT DEFINED MANAGE_GETTEXT_SUPPORT)
+	MANAGE_GETTEXT_INIT()
+    ENDIF()
+
+    VARIABLE_PARSE_ARGN(_o MANAGE_GETTEXT_VALID_OPTIONS ${ARGN})
+    IF(DEFINED _o_ALL)
+	SET(_all "ALL")
+    ELSE()
+	SET(_all "")
+    ENDIF(DEFINED _o_ALL)
+
+    VARIABLE_TO_ARGN(_gettext_locales_argn _o MANAGE_GETTEXT_LOCALES_VALID_OPTIONS)
+    IF("${MANAGE_TRANSLATION_LOCALES}" STREQUAL "")
+	MANAGE_GETTEXT_LOCALES(_locales ${_gettext_locales_argn})
+    ENDIF()
+
+    ## Determine the pot files
+    VARIABLE_TO_ARGN(_addPotFileOptList _o MANAGE_POT_FILE_VALID_OPTIONS)
+    IF(NOT "${_o_POT_FILE}" STREQUAL "")
+	### pot file is specified
+	MANAGE_POT_FILE("${_o_POT_FILE}" ${_addPotFileOptList})
+    ELSE()
+	### pot file is not specified
+	IF("${MANAGE_TRANSLATION_GETTEXT_POT_FILES}" STREQUAL "")
+	    #### No previous pot files
+	    SET(_o_POT_FILE "${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}.pot")
+	    MANAGE_POT_FILE("${_o_POT_FILE}" ${_addPotFileOptList})
+	ELSE()
+	    FOREACH(_potFile ${MANAGE_TRANSLATION_GETTEXT_POT_FILES})
+		MANAGE_POT_FILE_INTERNAL(0 "${_potFile}" ${_addPotFileOptList})
+	    ENDFOREACH()
+	ENDIF()
+    ENDIF()
+
+    ## Target translation
+    ADD_CUSTOM_TARGET(translations ${_all}
+	COMMENT "translations: Making translations"
+	)
+
+    ## Target pot_files 
+    ## PO depends on POT, so no need to put ALL here
+    ADD_CUSTOM_TARGET(pot_files
+	COMMENT "pot_files: ${MANAGE_TRANSLATION_GETTEXT_POT_FILES}"
+	)
+
+    ## Depends on pot_file targets instead of pot files themselves
+    ## Otherwise it won't build when pot files is in sub CMakeLists.txt
+    FOREACH(potFile ${MANAGE_TRANSLATION_GETTEXT_POT_FILES})
+	MANAGE_POT_FILE_OBTAIN_TARGET_NAME(targetName "${potFile}")
+	ADD_DEPENDENCIES(pot_files ${targetName}_no_force)
+    ENDFOREACH(potFile)
+
+    ## Target update_po 
+    ADD_CUSTOM_TARGET(update_po
+	DEPENDS ${MANAGE_TRANSLATION_GETTEXT_PO_FILES}
+	COMMENT "update_po: ${MANAGE_TRANSLATION_GETTEXT_PO_FILES}"
+	)
+    ADD_DEPENDENCIES(update_po pot_files)
+
+    ## Target gmo_files 
+    IF(MANAGE_TRANSLATION_GETTEXT_MO_FILES)
+	ADD_CUSTOM_TARGET(gmo_files
+	    DEPENDS ${MANAGE_TRANSLATION_GETTEXT_MO_FILES}
+	    COMMENT "gmo_files: ${MANAGE_TRANSLATION_GETTEXT_MO_FILES}"
+	    )
+    ENDIF()
+
+    IF(TARGET gmo_files)
+	ADD_DEPENDENCIES(gmo_files update_po)
+	ADD_DEPENDENCIES(translations gmo_files)
+    ELSE()
+	ADD_DEPENDENCIES(translations update_po)
+    ENDIF()
+
+ENDFUNCTION(MANAGE_GETTEXT)
+
+SET(MANAGE_GETTEXT_DETECT_POT_DIR_VALID_OPTIONS "WORKING_DIRECTORY")
+FUNCTION(MANAGE_GETTEXT_DETECT_POT_DIR potDirVar)
+    VARIABLE_PARSE_ARGN(_o MANAGE_GETTEXT_DETECT_POT_DIR_VALID_OPTIONS ${ARGN})
+    SET(detectedPotDir "NOTFOUND")
+    IF("${_o_WORKING_DIRECTORY}" STREQUAL "")
+	SET(_o_WORKING_DIRECTORY "${CMAKE_HOME_DIR}")
+    ENDIF()
+    EXECUTE_PROCESS(
+	COMMAND find . -name "*.pot"
+	COMMAND sed -e "s|^\\./||"
+	COMMAND sort -u
+	COMMAND xargs
+	COMMAND sed -e "s/ /;/g"
+	WORKING_DIRECTORY "${_o_WORKING_DIRECTORY}"
+	OUTPUT_VARIABLE potFileList
+	OUTPUT_STRIP_TRAILING_WHITESPACE
+	)
+    LIST(LENGTH potFileList potFileListLen)
+    IF( potFileListLen EQUAL 0 )
+	## NOT_FOUND
+    ELSEIF( potFileListLen EQUAL 1 )
+	GET_FILENAME_COMPONENT(detectedPotDir "${potFileList}" PATH)
+    ELSE()
+	MANAGE_FILE_COMMON_DIR(detectedPotDir ${potFileList})
+    ENDIF()
+    SET(${potDirVar} "${detectedPotDir}" PARENT_SCOPE)
+ENDFUNCTION(MANAGE_GETTEXT_DETECT_POT_DIR)
+
+FUNCTION(LOCALE_PARSE_STRING language script country modifier str)
+    SET(_s "")
+    SET(_c "")
+    SET(_m "")
+    IF("${str}" MATCHES "(.*)@(.*)")
+	SET(_m "${CMAKE_MATCH_2}")
+	SET(_str "${CMAKE_MATCH_1}")
+    ELSE()
+	SET(_str "${str}")
+    ENDIF()
+    STRING(REPLACE "-" "_" _str "${_str}")
+    STRING_SPLIT(_lA "_" "${_str}")
+    LIST(LENGTH _lA _lLen)
+    LIST(GET _lA 0 _l)
+    IF(_lLen GREATER 2)
+	LIST(GET _lA 2 _c)
+    ENDIF()
+    IF(_lLen GREATER 1)
+	LIST(GET _lA 1 _x)
+	IF("${_x}" MATCHES "[A-Z][a-z][a-z][a-z]")
+	    SET(_s "${_x}")
+	ELSE()
+	    SET(_c "${_x}")
+	ENDIF()
+    ENDIF()
+
+    # Make sure the language is in the list
+    IF(NOT DEFINED ZANATA_SUGGEST_COUNTRY_${_l}__)
+	# empty language means invalid languages
+	SET(_l "")
+	SET(_s "")
+	SET(_c "")
+	SET(_m "")
+    ENDIF()
+
+    SET(${language} "${_l}" PARENT_SCOPE)
+    SET(${script} "${_s}" PARENT_SCOPE)
+    SET(${country} "${_c}" PARENT_SCOPE)
+    SET(${modifier} "${_m}" PARENT_SCOPE)
+ENDFUNCTION(LOCALE_PARSE_STRING)
+
+FUNCTION(LOCALE_IN_PATH var path)
+    GET_FILENAME_COMPONENT(_token "${path}" NAME_WE)
+    LOCALE_PARSE_STRING(language script country modifier "${_token}")
+    IF(NOT "${language}" STREQUAL "")
+	SET(${var} "${_token}" PARENT_SCOPE)
+	RETURN()
+    ENDIF()
+
+    GET_FILENAME_COMPONENT(_dir "${path}" PATH)
+    STRING_SPLIT(dirA "/" "${_dir}")
+    LIST(LENGTH dirA dirALen)
+    MATH(EXPR i ${dirALen}-1)
+    WHILE(NOT i LESS 0)
+	LIST(GET dirA ${i} _token)
+	LOCALE_PARSE_STRING(language script country modifier "${_token}")
+	IF(NOT "${language}" STREQUAL "")
+	    SET(${var} "${_token}" PARENT_SCOPE)
+	    RETURN()
+	ENDIF()
+	MATH(EXPR i ${i}-1)
+    ENDWHILE()
+
+    SET(${var} "" PARENT_SCOPE)
+ENDFUNCTION(LOCALE_IN_PATH)
diff -Nura ibus-chewing-1.6.1/Modules/ManageUninstall.cmake ibus-chewing-1.6.1_new/Modules/ManageUninstall.cmake
--- ibus-chewing-1.6.1/Modules/ManageUninstall.cmake	1970-01-01 08:00:00.000000000 +0800
+++ ibus-chewing-1.6.1_new/Modules/ManageUninstall.cmake	2014-10-28 13:05:31.000000000 +0800
@@ -0,0 +1,33 @@
+# - Provide uninstall target.
+# Use this module to provide uninstall target.
+#
+# Included Modules:
+#   - ManageMessage
+#   - ManageFile
+#
+# Define following targets
+#   uninstall: For uninstalling the package.
+#
+
+IF(DEFINED _MANAGE_UNINSTALL_CMAKE_)
+    RETURN()
+ENDIF(DEFINED _MANAGE_UNINSTALL_CMAKE_)
+SET(_MANAGE_UNINSTALL_CMAKE_ "DEFINED")
+
+SET(CMAKE_UNINSTALL_IN_SEARCH_PATH 
+    ${CMAKE_MODULE_PATH} ${CMAKE_ROOT}/Modules ${CMAKE_SOURCE_DIR} ${CMAKE_SOURCE_DIR}/Modules
+    )
+
+INCLUDE(ManageFile)
+FIND_FILE_ERROR_HANDLING(CMAKE_UNINSTALL_IN
+    FIND_ARGS cmake_uninstall.cmake.in PATHS ${CMAKE_UNINSTALL_IN_SEARCH_PATH}
+    )
+
+CONFIGURE_FILE("${CMAKE_UNINSTALL_IN}"
+    "${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake"
+    IMMEDIATE @ONLY)
+
+ADD_CUSTOM_TARGET(uninstall
+    "${CMAKE_COMMAND}" -P "${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake"
+    )
+
diff -Nura ibus-chewing-1.6.1/Modules/ManageUpload.cmake ibus-chewing-1.6.1_new/Modules/ManageUpload.cmake
--- ibus-chewing-1.6.1/Modules/ManageUpload.cmake	1970-01-01 08:00:00.000000000 +0800
+++ ibus-chewing-1.6.1_new/Modules/ManageUpload.cmake	2014-10-28 13:05:31.000000000 +0800
@@ -0,0 +1,312 @@
+# - Manage upload source archive to hosting site
+# cmake-fedora can upload source archive to hosting site by
+# scp, sftp or any other command.
+#
+# Included Modules:
+#   - ManageMessage
+#   - ManageVariable
+#
+# This module defines following functions:
+#   MANAGE_UPLOAD_TARGET(<targetName> 
+#       COMMAND <program> ... 
+#       [COMMENT <comment>]
+#       [ADD_CUSTOM_TARGET_ARGS <arg> ...]
+#     )
+#     - Make an upload target using arbitrary command.
+#       If COMMAND program exists the target <targetName> will be created;
+#       if not, a M_OFF message is shown and target will not be created.
+#       * Parameters:
+#         + targetName: target for use this command.
+#         + COMMAND program ... : Upload command and arguments
+#         + COMMENT comment (Optional) Comment when target is being built.
+#           Default: "<targetName>: Upload with <program> ..."
+#         + ADD_CUSTOM_TARGET_ARGS <arg> ...: (Optional) Other arguments to be 
+#             passed to ADD_CUSTOM_TARGET.
+#       * Targets:
+#         + <targetName>
+#
+#   MANAGE_UPLOAD_SCP(<targetName> 
+#       HOST_URL <url>
+#       [USER <user>]  [UPLOAD_FILES <file> ...] [DEPENDS <file> ...]
+#       [REMOTE_DIR <dir>] [OPTIONS <options>]
+#       [COMMENT <comment>]
+#       [ADD_CUSTOM_TARGET_ARGS <arg> ...]
+#     )
+#     - Make an upload target using scp. 
+#       This functions check whether scp exists, see MANAGE_UPLOAD_TARGET 
+#       for detailed behavior.
+#       * Parameters:
+#         + targetName: target for use this command.
+#         + HOST_URL url: scp server.
+#         + USER user: (Optional) scp user.
+#           Default: Environment variable $USER.
+#         + UPLOAD_FILES file ... : (Optional) Files to be uploaded.
+#             This will also tell cmake the build to those files,
+#             thus, <targetName> depends on those files.
+#           Default: ${SOURCE_ARCHIVE_FILE}
+#         + DEPENDS file ...: (Optional) Files that <targetName> should depends on,
+#             but no need to upload.
+#         + REMOTE_DIR dir: (Optional) Directory on the server.
+#         + OPTIONS options: (Optional) scp options.
+#         + COMMENT comment (Optional) Comment when target is being built.
+#           Default: "<targetName>: Upload with scp [<options>] user@url:dir/file1 ..."
+#         + ADD_CUSTOM_TARGET_ARGS <arg> ...: (Optional) Other arguments to be 
+#             passed to ADD_CUSTOM_TARGET.
+#       * Targets:
+#         + <targetName>
+#
+#   MANAGE_UPLOAD_SFTP(<targetName> 
+#       HOST_URL <url>
+#       [BATCH <batchFile>]
+#       [USER <user>] [UPLOAD_FILES <file> ...] [DEPENDS <file> ...]
+#       [REMOTE_DIR <dir>] [OPTIONS <options>]
+#       [COMMENT <comment>]
+#       [ADD_CUSTOM_TARGET_ARGS <arg> ...]
+#     )
+#     - Make an upload target using sftp. 
+#       This functions check whether sftp exists, see MANAGE_UPLOAD_TARGET 
+#       for detailed behavior.
+#       * Parameters:
+#         + targetName: target for use this command.
+#         + HOST_URL url: sftp server.
+#         + BATCH batchFile: (Optional) File of sftp batch command.
+#             If not specified, a batch file will be generated at 
+#             ${CMAKE_CURRENT_BINARY_DIR}/<targetName>-sftp-batch
+#         + USER user: (Optional) sftp user.
+#           Default: Environment variable $USER.
+#         + UPLOAD_FILES file ... : (Optional) Files to be uploaded.
+#             This will also tell cmake the build to those files,
+#             thus, <targetName> depends on those files.
+#           Default: ${SOURCE_ARCHIVE_FILE}
+#         + DEPENDS file ...: (Optional) Files that <targetName> should depends on,
+#             but no need to upload.
+#         + REMOTE_DIR dir: (Optional) Directory on the server.
+#         + OPTIONS options: (Optional) sftp options.
+#         + COMMENT comment (Optional) Comment when target is being built.
+#           Default: "<targetName>: Upload with sftp [<options>] user@url/dir/file1 ..."
+#         + ADD_CUSTOM_TARGET_ARGS <arg> ...: (Optional) Other arguments to be 
+#             passed to ADD_CUSTOM_TARGET.
+#       * Targets:
+#         + <targetName>
+#
+#
+#   MANAGE_UPLOAD_FEDORAHOSTED(<targetName> 
+#       [USER <user>]  [UPLOAD_FILES <file> ...] [DEPENDS <file> ...]
+#       [OPTIONS <options>]
+#       [COMMENT <comment>]
+#       [ADD_CUSTOM_TARGET_ARGS <arg> ...]
+#     )
+#     - Make an upload target to fedora hosted.
+#       This functions check whether scp exists, see MANAGE_UPLOAD_TARGET 
+#       for detailed behavior.
+#       * Parameters:
+#         + targetName: target for use this command.
+#         + USER user: (Optional) scp user.
+#           Default: Environment variable $USER.
+#         + UPLOAD_FILES file ... : (Optional) Files to be uploaded.
+#             This will also tell cmake the build to those files,
+#             thus, <targetName> depends on those files.
+#           Default: ${SOURCE_ARCHIVE_FILE}
+#         + DEPENDS file ...: (Optional) Files that <targetName> should depends on,
+#             but no need to upload.
+#         + OPTIONS options: (Optional) scp options.
+#         + COMMENT comment (Optional) Comment when target is being built.
+#           Default: "<targetName>: Upload with scp [<options>] user@url:dir/file1 ..."
+#         + ADD_CUSTOM_TARGET_ARGS <arg> ...: (Optional) Other arguments to be 
+#             passed to ADD_CUSTOM_TARGET.
+#       * Targets:
+#         + <targetName>
+#
+#   MANAGE_UPLOAD_SOURCEFORGE(<targetName> 
+#       [BATCH <batchFile>]
+#       [USER <user>] [UPLOAD_FILES <file> ...] [DEPENDS <file> ...]
+#       [OPTIONS <options>]
+#       [COMMENT <comment>]
+#       [ADD_CUSTOM_TARGET_ARGS <arg> ...]
+#     )
+#     - Make an upload target using sftp. 
+#       This functions check whether sftp exists, see MANAGE_UPLOAD_TARGET 
+#       for detailed behavior.
+#       * Parameters:
+#         + targetName: target for use this command.
+#         + BATCH batchFile: (Optional) File of sftp batch command.
+#             If not specified, a batch file will be generated at 
+#             ${CMAKE_CURRENT_BINARY_DIR}/<targetName>-sftp-batch
+#         + USER user: (Optional) sftp user.
+#           Default: Environment variable $USER.
+#         + UPLOAD_FILES file ... : (Optional) Files to be uploaded.
+#             This will also tell cmake the build to those files,
+#             thus, <targetName> depends on those files.
+#           Default: ${SOURCE_ARCHIVE_FILE}
+#         + DEPENDS file ...: (Optional) Files that <targetName> should depends on,
+#             but no need to upload.
+#         + OPTIONS options: (Optional) sftp options.
+#         + COMMENT comment (Optional) Comment when target is being built.
+#           Default: "<targetName>: Upload with sftp [<options>] user@url/dir/file1 ..."
+#         + ADD_CUSTOM_TARGET_ARGS <arg> ...: (Optional) Other arguments to be 
+#             passed to ADD_CUSTOM_TARGET.
+#       * Targets:
+#         + <targetName>
+#
+#   MANAGE_UPLOAD_FEDORAHOSTED(targetName 
+#     [USER user] [UPLOAD_FILES files] [OPTIONS options] [DEPENDS files]
+#     [COMMENT comments])
+#   - Make an upload target for uploading to FedoraHosted.
+#     Parameters:
+#     + targetName: target name in make.
+#     + USER user: scp user. Note that if USER is used but user is not defined.
+#       It produces M_OFF warning.
+#     + UPLOAD_FILES: Files to be uploaded. This will be in DEPENDS list.
+#     + OPTIONS options: scp options.
+#     + DEPENDS files: other files that should be in DEPENDS list.
+#     + COMMENT comments: Comment to be shown when building the target.
+#
+#   MANAGE_UPLOAD_SOURCEFORGE(targetName [BATCH batchFile] 
+#     [USER user] [UPLOAD_FILES files] [OPTIONS options] [DEPENDS files]
+#     [COMMENT comments])
+#     [UPLOAD_FILES files] [REMOTE_DIR remoteDir]
+#     [UPLOAD_OPTIONS options] [DEPENDS files])
+#   - Make an upload target for uploading to SourceForge
+#     Parameters:
+#     + targetName: target name in make.
+#     + BATCH batchFile to be used in sftp. (sftp -b )
+#     + USER user: sftp user. Note that if USER is used but user is not defined.
+#       It produces M_OFF warning.
+#     + UPLOAD_FILES: Files to be uploaded. This will be in DEPENDS list.
+#     + OPTIONS options: sftp options.
+#     + DEPENDS files: other files that should be in DEPENDS list.
+#     + COMMENT comments: Comment to be shown when building the target.
+#
+#
+
+IF(DEFINED _MANAGE_UPLOAD_CMAKE_)
+    RETURN()
+ENDIF()
+SET(_MANAGE_UPLOAD_CMAKE_ "DEFINED")
+
+INCLUDE(ManageMessage)
+INCLUDE(ManageString)
+INCLUDE(ManageVariable)
+
+FUNCTION(MANAGE_UPLOAD_TARGET targetName)
+    SET(_validOptions "COMMAND" "COMMENT" "ADD_CUSTOM_TARGET_ARGS")
+    VARIABLE_PARSE_ARGN(_o _validOptions ${ARGN})
+
+    LIST(GET _o_COMMAND 0 _cmd)
+    FIND_PROGRAM_ERROR_HANDLING(${targetName}_UPLOAD_EXECUTABLE
+	ERROR_MSG " Upload target ${targetName} disabled."
+	ERROR_VAR _upload_target_missing_dependency
+	VERBOSE_LEVEL ${M_OFF}
+	"${_cmd}"
+	)
+
+    IF("${_o_COMMENT}" STREQUAL "")
+	SET(_o "${targetName}: Upload with ${_o_COMMAND}")
+    ENDIF()
+
+    IF(NOT _upload_target_missing_dependency)
+	ADD_CUSTOM_TARGET(${targetName}
+	    COMMAND ${_o_COMMAND}
+	    COMMENT "${_o_COMMENT}"
+	    ${_o_ADD_CUSTOM_TARGET_ARGS}
+	    )
+    ENDIF()
+ENDFUNCTION(MANAGE_UPLOAD_TARGET targetName)
+
+## Internal
+FUNCTION(MANAGE_UPLOAD_MAKE_URL var user url)
+    IF(NOT "${user}" STREQUAL "")
+	SET(_str "${user}@${url}")
+    ELSE()
+	SET(_str "${url}")
+    ENDIF()
+    SET(${var} "${_str}" PARENT_SCOPE)
+ENDFUNCTION(MANAGE_UPLOAD_MAKE_URL)
+
+
+FUNCTION(MANAGE_UPLOAD_SCP targetName)
+    SET(_validOptions "HOST_URL" "USER" 
+	"UPLOAD_FILES" "DEPENDS" "REMOTE_DIR" "OPTIONS" "COMMENT"
+	"ADD_CUSTOM_TARGET_ARGS"
+	)
+    VARIABLE_PARSE_ARGN(_o _validOptions ${ARGN})
+
+    IF("${_o_HOST_URL}" STREQUAL "")
+        M_MSG(${M_ERROR} "HOST_URL is required.")
+    ENDIF()
+
+    IF("${_o_UPLOAD_FILES}" STREQUAL "")
+	SET(_o_UPLOAD_FILES "${SOURCE_ARCHIVE_FILE}")
+    ENDIF()
+
+    MANAGE_UPLOAD_MAKE_URL(_uploadUrl "${_o_USER}" "${_o_HOST_URL}")
+    IF(NOT "${_o_REMOTE_DIR}" STREQUAL "")
+	STRING_APPEND(_uploadUrl ":${_o_REMOTE_DIR}")
+    ENDIF()
+
+    IF("${_o_COMMENT}" STREQUAL "")
+	SET(_o "${targetName}: Upload with scp ${_o_OPTIONS} ${_o_UPLOAD_FILES} ${_uploadUrl}")
+    ENDIF()
+
+    MANAGE_UPLOAD_TARGET(${targetName}
+	COMMAND scp ${_o_OPTIONS} ${_o_UPLOAD_FILES} ${_uploadUrl}
+	DEPENDS ${_o_UPLOAD_FILES} ${_o_DEPENDS}
+	COMMENT "${_o_COMMENTS}"
+	ADD_CUSTOM_TARGET_ARGS VERBATIM ${_o_ADD_CUSTOM_TARGET_ARGS}
+	)
+ENDFUNCTION(MANAGE_UPLOAD_SCP fileAlias)
+
+FUNCTION(MANAGE_UPLOAD_SFTP targetName)
+    SET(_validOptions "HOST_URL" "USER" 
+	"BATCH"
+	"UPLOAD_FILES" "DEPENDS" "REMOTE_DIR" "OPTIONS" "COMMENT"
+	"ADD_CUSTOM_TARGET_ARGS"
+	)
+
+    VARIABLE_PARSE_ARGN(_o _validOptions ${ARGN})
+
+    IF("${_o_HOST_URL}" STREQUAL "")
+	M_MSG(${M_ERROR} "HOST_URL is required.")
+    ENDIF()
+
+    IF("${_o_UPLOAD_FILES}" STREQUAL "")
+	SET(_o_UPLOAD_FILES "${SOURCE_ARCHIVE_FILE}")
+    ENDIF()
+
+    MANAGE_UPLOAD_MAKE_URL(_uploadUrl "${_o_USER}" "${_o_HOST_URL}")
+
+    ## Generate batch
+    IF("${_o_BATCH}" STREQUAL "")
+	SET(_o_BATCH "${CMAKE_CURRENT_BINARY_DIR}/${targetName}-sftp-batch")
+	FILE(WRITE "${_o_BATCH}" "pwd\n")
+	FOREACH(_f ${_o_UPLOAD_FILES})
+	    FILE(APPEND "${_o_BATCH}" "put -p ${_f} ${_o_REMOTE_DIR}\n")
+	ENDFOREACH()
+	FILE(APPEND "${_o_BATCH}" "bye\n")
+    ENDIF()
+
+    IF("${_o_COMMENT}" STREQUAL "")
+	SET(_o "${targetName}: Upload with scp ${_o_OPTIONS} ${_o_UPLOAD_FILES} ${_uploadUrl}")
+    ENDIF()
+
+    MANAGE_UPLOAD_TARGET(${targetName}
+	COMMAND sftp -b ${_o_BATCH} ${_o_OPTIONS} ${_uploadUrl}
+	DEPENDS ${_o_UPLOAD_FILES} ${_o_DEPENDS}
+	COMMENT "${_o_COMMENTS}"
+	ADD_CUSTOM_TARGET_ARGS VERBATIM ${_o_ADD_CUSTOM_TARGET_ARGS}
+	)
+ENDFUNCTION(MANAGE_UPLOAD_SFTP targetName)
+
+FUNCTION(MANAGE_UPLOAD_FEDORAHOSTED targetName)
+    MANAGE_UPLOAD_SCP(${targetName} 
+	HOST_URL "fedorahosted.org" REMOTE_DIR "${PROJECT_NAME}" ${ARGN}
+	)
+ENDFUNCTION(MANAGE_UPLOAD_FEDORAHOSTED)
+
+FUNCTION(MANAGE_UPLOAD_SOURCEFORGE targetName)
+    MANAGE_UPLOAD_SFTP(${targetName} 
+	HOST_URL "frs.sourceforge.net" 
+	REMOTE_DIR  "/home/frs/project/${PROJECT_NAME}"	${ARGN}
+	)
+ENDFUNCTION(MANAGE_UPLOAD_SOURCEFORGE)
+
diff -Nura ibus-chewing-1.6.1/Modules/ManageVariable.cmake ibus-chewing-1.6.1_new/Modules/ManageVariable.cmake
--- ibus-chewing-1.6.1/Modules/ManageVariable.cmake	1970-01-01 08:00:00.000000000 +0800
+++ ibus-chewing-1.6.1_new/Modules/ManageVariable.cmake	2015-12-17 17:43:31.000000000 +0800
@@ -0,0 +1,398 @@
+# - Get or set variables from various sources.
+#
+# Included Modules:
+#   - ManageFile
+#   - ManageString
+#
+# Defines following functions:
+#   SETTING_STRING_GET_VARIABLE(<key> <value> <str> 
+#       [NOUNQUOTE] [NOREPLACE] [<setting_sign>]
+#     )
+#     - Split a setting string (e.g. VAR=value) to key and value.
+#         Note that if the first non-blank character is "#", then the 
+#         string is deemed as a comment thus will be skipped.
+#       * Parameters:
+#         + key: Key extracted from str.
+#         + value: Value extracted from str
+#         + str: String to be extracted variable and value from.
+#         + NOUNQUOTE: (Optional) do not remove the double quote mark around the string.
+#         + NOREPLACE (Optional) Without this parameter, this macro replaces
+#           previous defined variables, use NOREPLACE to prevent this.
+#         + NOESCAPE_SEMICOLON: (Optional) do not escape semicolons.
+#         + setting_sign: (Optional) The symbol that separate key name and its value.
+#           Default value: "="
+#
+# Defines following macros:
+#   CMAKE_FEDORA_CONF_GET_ALL_VARIABLES([NOUNQUOTE] [NOREPLACE] [NOESCAPE_SEMICOLON])
+#     - Get all variables from cmake-fedora.conf
+#       * Parameters:
+#         + NOUNQUOTE: (Optional) do not remove the double quote mark around the string.
+#         + NOREPLACE (Optional) Without this parameter, this macro replaces
+#           previous defined variables, use NOREPLACE to prevent this.
+#         + NOESCAPE_SEMICOLON: (Optional) Do not escape semicolons.
+#
+#   SETTING_FILE_GET_VARIABLES_PATTERN(<var> <key_pattern> <setting_file> 
+#       [NOUNQUOTE] [NOREPLACE]
+#       [NOESCAPE_SEMICOLON] [<setting_sign>]
+#     )
+#     - Get variable values from a setting file if their names matches given
+#         pattern. Note that if the first non-blank character is "#", then the 
+#         string is deemed as a comment thus will be skipped.
+#       * Parameters:
+#         + var: If specified, the value of setting string will be assign to the var;
+#             otherwise using matched key name as variable name.
+#         + key_pattern: Regex pattern of match the key name.
+#         + setting_file: Setting filename.
+#         + NOUNQUOTE: (Optional) do not remove the double quote mark around the string.
+#         + NOREPLACE (Optional) Without this parameter, this macro replaces
+#           previous defined variables, use NOREPLACE to prevent this.
+#         + NOESCAPE_SEMICOLON: (Optional) do not escape semicolons.
+#         + setting_sign: (Optional) The symbol that separate key name and its value.
+#           Default value: "="
+#
+#   SETTING_FILE_GET_ALL_VARIABLES(<setting_file> [NOUNQUOTE] [NOREPLACE]
+#       [NOESCAPE_SEMICOLON] [<setting_sign>]
+#     )
+#     - Get all variable values from a setting file.
+#         It is equivalent to:
+#         SETTING_FILE_GET_VARIABLES_PATTERN("" "[A-Za-z_][A-Za-z0-9_]*"
+#           "${setting_file}" ${ARGN})
+#         Note that if the first non-blank character is "#", then the 
+#           string is deemed as a comment thus will be skipped.
+#       * Parameters:
+#         + setting_file: Setting filename.
+#         + NOUNQUOTE: (Optional) do not remove the double quote mark around the string.
+#         + NOREPLACE (Optional) Without this parameter, this macro replaces
+#           previous defined variables, use NOREPLACE to prevent this.
+#         + NOESCAPE_SEMICOLON: (Optional) Do not escape semicolons.
+#         + setting_sign: (Optional) The symbol that separate key and value.
+#           Default value: "="
+#
+#   SETTING_FILE_GET_VARIABLE(<var> <key_name> <setting_file> 
+#     [NOUNQUOTE] [NOREPLACE]
+#     [NOESCAPE_SEMICOLON] [<setting_sign>]
+#     )
+#     - Get the value of a key from a setting file.
+#       It is equivalent to:
+#	SETTING_FILE_GET_VARIABLES_PATTERN(${var} "${key_name}"
+#	    "${setting_file}" ${ARGN})
+#      '#' is used to comment out setting.
+#       * Parameters:
+#         + var: Variable to store the value.
+#         + key_name: Name of the key.
+#         + setting_file: Setting filename.
+#         + NOUNQUOTE: (Optional) do not remove the double quote mark around the string.
+#         + NOREPLACE (Optional) Without this parameter, this macro replaces
+#           previous defined variables, use NOREPLACE to prevent this.
+#         + NOESCAPE_SEMICOLON: (Optional) do not escape semicolons.
+#         + setting_sign: (Optional) The symbol that separate key and value.
+#           Default value: "="
+#
+#   SETTING_FILE_GET_ALL_VARIABLES(<setting_file> [NOUNQUOTE] [NOREPLACE]
+#     [NOESCAPE_SEMICOLON] [<setting_sign>]
+#     )
+#     - Get all key values from a setting file.
+#       '#' is used to comment out setting.
+#       * Parameters:
+#         + setting_file: Setting filename.
+#         + NOUNQUOTE: (Optional) do not remove the double quote mark around the string.
+#         + NOREPLACE (Optional) Without this parameter, this macro replaces
+#           previous defined variables, use NOREPLACE to prevent this.
+#         + NOESCAPE_SEMICOLON: (Optional) Do not escape semicolons.
+#         + setting_sign: (Optional) The symbol that separate attribute name and its value.
+#           Default value: "="
+#
+#   GET_ENV(<var> <default_value> [<env>] 
+#      [[CACHE <type> <docstring> [FORCE]] | PARENT_SCOPE]
+#     )
+#     - Get the value of a environment variable, or use default
+#       if the environment variable does not exist or empty.
+#       * Parameters:
+#         + var: Variable to be set
+#         + default_value: Default value of the var
+#         + env: (Optional) The name of environment variable. Only need if different from var.
+#         + CACHE ... : Arguments for SET
+#         + PARENT_SCOPE: Arguments for SET
+#
+#   SET_VAR(<var> <untrimmed_value>)
+#     - Trim and set the value to a variable.
+#       * Parameters:
+#         + var: Variable to be set
+#         + untrimmed_value: Untrimmed values that may have space, \t, \n, \r in the front or back of the string.
+#
+#   VARIABLE_PARSE_ARGN(<var> <valid_option_list> [arguments ...])
+#     - Parse the arguments and put the result in var and var_<optName>
+#       * Parameters:
+#         + var: Main variable name.
+#         + valid_option_list: List name of valid options.
+#         + arguments ...: (Optional) variable to be parsed.
+#
+#   VARIABLE_TO_ARGN(<var> <prefix> <valid_option_list>)
+#     - Merge the variable and options to the form of ARGN.
+#         Like the reverse of VARIABLE_PARSE_ARGN
+#       * Parameters:
+#         + var: Variable that holds result.
+#         + prefix: Main variable name that to be processed.
+#         + valid_option_list: List name of valid options.
+#
+
+IF(DEFINED _MANAGE_VARIABLE_CMAKE_)
+    RETURN()
+ENDIF(DEFINED _MANAGE_VARIABLE_CMAKE_)
+SET(_MANAGE_VARIABLE_CMAKE_ "DEFINED")
+INCLUDE(ManageFile)
+INCLUDE(ManageString)
+
+# This macro is meant to be internal.
+MACRO(_MANAGE_VARIABLE_SET var value)
+    SET(${var} "${value}")
+ENDMACRO(_MANAGE_VARIABLE_SET var value)
+
+# it deals the "encoded" line.
+FUNCTION(SETTING_STRING_GET_VARIABLE var value str )
+    SET(setting_sign "=")
+    SET(_NOUNQUOTE "")
+    SET(_NOREPLACE "")
+    FOREACH(_arg ${ARGN})
+	IF (${_arg} STREQUAL "NOUNQUOTE")
+	    SET(_NOUNQUOTE "NOUNQUOTE")
+	ELSEIF (${_arg} STREQUAL "NOREPLACE")
+	    SET(_NOREPLACE "NOREPLACE")
+	ELSE(${_arg} STREQUAL "NOUNQUOTE")
+	    SET(setting_sign ${_arg})
+	ENDIF(${_arg} STREQUAL "NOUNQUOTE")
+    ENDFOREACH(_arg ${ARGN})
+
+    STRING_SPLIT(_tokens "${setting_sign}" "${str}" 2)
+    #MESSAGE("_tokens=${_tokens}")
+    SET(_varName "")
+    SET(_val "")
+    FOREACH(_token ${_tokens})
+	#MESSAGE("_varName=${_varName} _token=${_token}")
+	IF(_varName STREQUAL "")
+	    SET(_varName "${_token}")
+	ELSE(_varName STREQUAL "")
+	    SET(_val "${_token}")
+	ENDIF(_varName STREQUAL "")
+    ENDFOREACH(_token ${_tokens})
+    #MESSAGE("_varName=${_varName} _val=${_val}")
+
+    SET(${var} "${_varName}" PARENT_SCOPE)
+    # Set var when
+    # 1. NOREPLACE is not set, or
+    # 2. var has value already.
+    SET(_setVar 0)
+    IF(_NOREPLACE STREQUAL "")
+	STRING_TRIM(_value "${_val}" ${_NOUNQUOTE})
+    ELSEIF(${var} STREQUAL "")
+	STRING_TRIM(_value "${_val}" ${_NOUNQUOTE})
+    ELSE(_NOREPLACE STREQUAL "")
+	SET(_value "${${var}}")
+    ENDIF(_NOREPLACE STREQUAL "")
+    SET(${value} "${_value}" PARENT_SCOPE)
+    #MESSAGE("_varName=${_varName} _value=${_value}")
+
+ENDFUNCTION(SETTING_STRING_GET_VARIABLE var str)
+
+MACRO(CMAKE_FEDORA_CONF_GET_ALL_VARIABLES)
+    MANAGE_CMAKE_FEDORA_CONF(CMAKE_FEDORA_CONF)
+    SET(HOME "$ENV{HOME}")
+    SETTING_FILE_GET_ALL_VARIABLES(${CMAKE_FEDORA_CONF} ${ARGN})
+ENDMACRO(CMAKE_FEDORA_CONF_GET_ALL_VARIABLES)
+
+# Internal macro
+# Similar to STRING_ESCAPE, but read directly from file,
+# This avoid the variable substitution
+# Variable escape is enforced.
+MACRO(FILE_READ_ESCAPE var filename)
+    # '$' is very tricky.
+    # '$' => '#D'
+    GET_FILENAME_COMPONENT(_filename_abs "${filename}" ABSOLUTE)
+    EXECUTE_PROCESS(COMMAND cat ${filename}
+	COMMAND sed -e "s/#/#H/g"
+	COMMAND sed -e "s/[$]/#D/g"
+	COMMAND sed -e "s/;/#S/g"
+	COMMAND sed -e "s/[\\]/#B/g"
+	OUTPUT_VARIABLE _ret
+	OUTPUT_STRIP_TRAILING_WHITESPACE)
+
+    STRING(REGEX REPLACE "\n" ";" _ret "${_ret}")
+    #MESSAGE("_ret=|${_ret}|")
+    SET(${var} "${_ret}")
+ENDMACRO(FILE_READ_ESCAPE var filename)
+
+MACRO(SETTING_FILE_GET_VARIABLES_PATTERN var key_pattern setting_file)
+    IF("${setting_file}" STREQUAL "")
+	M_MSG(${M_FATAL} "SETTING_FILE_GET_VARIABLES_PATTERN: setting_file ${setting_file} is empty")
+    ENDIF("${setting_file}" STREQUAL "")
+    SET(setting_sign "=")
+    SET(_noUnQuoted "")
+    SET(_noEscapeSemicolon "")
+    SET(_noReplace "")
+    SET(_escapeVariable "")
+    FOREACH(_arg ${ARGN})
+	IF (${_arg} STREQUAL "NOUNQUOTE")
+	    SET(_noUnQuoted "NOUNQUOTE")
+	ELSEIF (${_arg} STREQUAL "NOREPLACE")
+	    SET(_noReplace "NOREPLACE")
+	ELSEIF (${_arg} STREQUAL "NOESCAPE_SEMICOLON")
+	    SET(_noEscapeSemicolon "NOESCAPE_SEMICOLON")
+	ELSEIF (${_arg} STREQUAL "ESCAPE_VARIABLE")
+	    SET(_escapeVariable "ESCAPE_VARIABLE")
+	ELSE(${_arg} STREQUAL "NOUNQUOTE")
+	    SET(setting_sign ${_arg})
+	ENDIF(${_arg} STREQUAL "NOUNQUOTE")
+    ENDFOREACH(_arg)
+
+    ## Escape everything to be safe.
+    FILE_READ_ESCAPE(_lines "${setting_file}")
+
+    #STRING_SPLIT(_lines "\n" "${_txt_content}")
+    #MESSAGE("_lines=|${_lines}|")
+    SET(_actual_line "")
+    SET(_join_next 0)
+    FOREACH(_line ${_lines})
+	#MESSAGE("_line=|${_line}|")
+	IF(NOT _line MATCHES "^[ \\t]*#H")
+	    ## Not a comment line.
+	    IF(_join_next EQUAL 1)
+		SET(_actual_line "${_actual_line}${_line}" )
+	    ELSE()
+		SET(_actual_line "${_line}")
+	    ENDIF()
+	    #MESSAGE("_actual_line=|${_actual_line}|")
+
+	    IF(_actual_line MATCHES "#B$")
+		## Join the lines that end with \\
+		SET(_join_next 1)
+		STRING(REGEX REPLACE "#B$" "" _actual_line "${_actual_line}")
+	    ELSE()
+		SET(_join_next 0)
+		IF(_actual_line MATCHES "[ \\t]*${key_pattern}[ \\t]*${setting_sign}")
+		    #MESSAGE("*** matched_line=|${_actual_line}|")
+		    SETTING_STRING_GET_VARIABLE(_attr _value
+			"${_actual_line}" ${setting_sign} ${_noUnQuoted} )
+		    #MESSAGE("*** _attr=${_attr} _value=${_value}")
+		    IF(_noReplace STREQUAL "" OR NOT DEFINED ${_attr})
+			## Unencoding
+			_STRING_UNESCAPE(_value "${_value}" ${_noEscapeSemicolon} ESCAPE_VARIABLE)
+			IF(_escapeVariable STREQUAL "")
+			    ## If "ESCAPE_VARIABLE" is not defined.
+			    ## then substitute the variable
+			    _MANAGE_VARIABLE_SET(_value "${_value}")
+			ENDIF()
+			IF("${var}" STREQUAL "")
+			    SET(${_attr} "${_value}")
+			ELSE()
+			    SET(${var} "${_value}")
+			ENDIF()
+		    ENDIF()
+		ENDIF()
+	    ENDIF(_actual_line MATCHES "#B$")
+	ENDIF(NOT _line MATCHES "^[ \\t]*#H")
+    ENDFOREACH(_line ${_lines})
+    #SET(${var} "${_value}")
+ENDMACRO(SETTING_FILE_GET_VARIABLES_PATTERN var key_pattern setting_file)
+
+MACRO(SETTING_FILE_GET_VARIABLE var key_name setting_file)
+    SETTING_FILE_GET_VARIABLES_PATTERN(${var} "${key_name}"
+	"${setting_file}" ${ARGN})
+ENDMACRO(SETTING_FILE_GET_VARIABLE var key_name setting_file)
+
+MACRO(SETTING_FILE_GET_ALL_VARIABLES setting_file)
+    SETTING_FILE_GET_VARIABLES_PATTERN("" "[A-Za-z_][A-Za-z0-9_.]*"
+	"${setting_file}" ${ARGN})
+ENDMACRO(SETTING_FILE_GET_ALL_VARIABLES setting_file)
+
+MACRO(GET_ENV var default_value)
+    SET(_env "${var}")
+    SET(_state "")
+    SET(_setArgList "")
+    FOREACH(_arg ${ARGN})
+	IF(_state STREQUAL "set_args")
+	    LIST(APPEND _setArgList "${_arg}")
+	ELSE(_state STREQUAL "set_args")
+	    IF (_arg STREQUAL "CACHE")
+		SET(_state "set_args")
+		LIST(APPEND _setArgList "${_arg}")
+	    ELSEIF (_arg STREQUAL "PARENT_SCOPE")
+		SET(_state "set_args")
+		LIST(APPEND _setArgList "${_arg}")
+	    ELSE(_arg STREQUAL "CACHE")
+		SET(_env "${_arg}")
+	    ENDIF(_arg STREQUAL "CACHE")
+	ENDIF(_state STREQUAL "set_args")
+    ENDFOREACH(_arg ${ARGN})
+
+    IF ("$ENV{${_env}}" STREQUAL "")
+	SET(${var} "${default_value}" ${_setArgList})
+    ELSE("$ENV{${_env}}" STREQUAL "")
+	SET(${var} "$ENV{${_env}}" ${_setArgList})
+    ENDIF("$ENV{${_env}}" STREQUAL "")
+    # MESSAGE("Variable ${var}=${${var}}")
+ENDMACRO(GET_ENV var default_value)
+
+MACRO(SET_VAR var untrimmedValue)
+    SET(_noUnQuoted "")
+    FOREACH(_arg ${ARGN})
+	IF (${_arg} STREQUAL "NOUNQUOTE")
+	    SET(_noUnQuoted "NOUNQUOTE")
+	ENDIF(${_arg} STREQUAL "NOUNQUOTE")
+    ENDFOREACH(_arg ${ARGN})
+    #MESSAGE("untrimmedValue=${untrimmedValue}")
+    IF ("${untrimmedValue}" STREQUAL "")
+	SET(${var} "")
+    ELSE("${untrimmedValue}" STREQUAL "")
+	STRING_TRIM(trimmedValue "${untrimmedValue}" ${_noUnQuoted})
+	#MESSAGE("***SET_VAR: trimmedValue=${trimmedValue}")
+	SET(${var} "${trimmedValue}")
+    ENDIF("${untrimmedValue}" STREQUAL "")
+    #SET(value "${${var}}")
+    #MESSAGE("***SET_VAR: ${var}=|${value}|")
+ENDMACRO(SET_VAR var untrimmedValue)
+
+MACRO(VARIABLE_PARSE_ARGN var valid_option_list)
+    SET(_optName "")	## Last _optName
+    SET(_listName ${var})
+
+    ## Unset all, otherwise ghost from previous running exists.
+    UNSET(${var})
+    FOREACH(_o ${${valid_option_list}})
+	UNSET(${var}_${_o})
+    ENDFOREACH(_o ${valid_option_list})
+
+    FOREACH(_arg ${ARGN})
+	LIST(FIND ${valid_option_list} "${_arg}" _optIndex)
+	IF(_optIndex EQUAL -1)
+	    ## Not an option name. Append to existing options
+	    LIST(APPEND ${_listName} "${_arg}")
+	ELSE(_optIndex EQUAL -1)
+	    ## _arg is an option name.
+	    SET(_listName "${var}_${_arg}")
+
+	    ## If the option already exists
+	    IF(DEFINED ${var}_${_arg})
+		### then append to it with option name
+		### this is especiall useful for ADD_CUSTOM_TARGET_COMMAND
+		LIST(APPEND ${_listName} "${_arg}")
+	    ELSE(DEFINED ${var}_${_arg})
+		### otherwise init the option name,
+		### , so it can be find by IF(DEFINED ...)
+		SET(${_listName} "")
+	    ENDIF(DEFINED ${var}_${_arg})
+	ENDIF(_optIndex EQUAL -1)
+    ENDFOREACH(_arg ${ARGN})
+ENDMACRO(VARIABLE_PARSE_ARGN var valid_option_list)
+
+MACRO(VARIABLE_TO_ARGN var prefix valid_option_list)
+    SET(${var} "${${prefix}}")
+    FOREACH(_o ${${valid_option_list}})
+	IF(DEFINED ${prefix}_${_o})
+	    LIST(APPEND ${var} "${_o}")
+	    IF(NOT "${${prefix}_${_o}}" STREQUAL "")
+		LIST(APPEND ${var} "${${prefix}_${_o}}")
+	    ENDIF()
+	ENDIF(DEFINED ${prefix}_${_o})
+    ENDFOREACH(_o ${${valid_option_list}})
+ENDMACRO(VARIABLE_TO_ARGN var prefix valid_option_list)
+
diff -Nura ibus-chewing-1.6.1/Modules/ManageVersion.cmake ibus-chewing-1.6.1_new/Modules/ManageVersion.cmake
--- ibus-chewing-1.6.1/Modules/ManageVersion.cmake	1970-01-01 08:00:00.000000000 +0800
+++ ibus-chewing-1.6.1_new/Modules/ManageVersion.cmake	2016-01-07 15:39:34.000000000 +0800
@@ -0,0 +1,192 @@
+# - Manage Version, ChangeLog and project information (prj_info.cmake)
+#
+# Included Modules:
+#   - DateTimeFormat
+#   - ManageString
+#   - ManageVariable
+#
+# Set cache for following variables:
+#   - CHANGELOG_FILE: Location of ChangeLog.
+#     Default: ${CMAKE_SOURCE_DIR}/ChangeLog
+#   - PRJ_INFO_CMAKE_FILE: Path to prj_info.cmake
+#     Default: ${CMAKE_FEDORA_TMP_DIR}/prj_info.cmake
+#
+# Defines following functions:
+#   RELEASE_NOTES_READ_FILE([<release_file>])
+#   - Load release file information.
+#     * Parameters:
+#       + release_file: (Optional) release file to be read.
+#         This file should contain following definition:
+#         - PRJ_VER: Release version.
+#         - SUMMARY: Summary of the release. Will be output as CHANGE_SUMMARY.
+#         - Section [Changes]:
+#           Changes of this release list below the section tag.
+#         Default:${CMAKE_SOURCE_DIR}/RELEASE-NOTES.txt
+#     * Values to cached:
+#       + PRJ_VER: Version.
+#       + CHANGE_SUMMARY: Summary of changes.
+#       + RELEASE_NOTES_FILE: The loaded release file.
+#     * Compile flags defined:
+#       + PRJ_VER: Project version.
+#
+#   PRJ_INFO_CMAKE_WRITE()
+#   - Write the project infomation to prj_info.cmake.
+#
+#   PRJ_INFO_CMAKE_APPEND(<var>)
+#   - Append  var to prj_info.cmake.
+#     * Parameters:
+#       + var: Variable to be append to prj_info.cmake.
+#
+# Defines following macros:
+#   PRJ_INFO_CMAKE_READ(<prj_info_file>)
+#   - Read prj_info.cmake and get the info of projects.
+#     This macro is meant to be run by ManageChangeLogScript script.
+#     So normally no need to call it manually.
+#     * Parameters:
+#       + prj_info_file: File name to be appended to.
+#         Default: ${PRJ_INFO_CMAKE_FILE}, otherwise ${CMAKE_FEDORA_TMP_DIR}/prj_info.cmake.
+#     * Targets:
+#       + changelog: Always update ChangeLog. So it updates the date in ChangeLog. 
+#       + changelog_no_force: Only update ChangeLog if necessary.
+
+IF(DEFINED _MANAGE_VERSION_CMAKE_)
+    RETURN()
+ENDIF(DEFINED _MANAGE_VERSION_CMAKE_)
+SET(_MANAGE_VERSION_CMAKE_ "DEFINED")
+INCLUDE(ManageMessage)
+INCLUDE(ManageVariable)
+INCLUDE(ManageFile)
+
+SET(PRJ_INFO_VARIABLE_LIST 
+    PROJECT_NAME PRJ_VER PRJ_SUMMARY SUMMARY_TRANSLATIONS
+    PRJ_DESCRIPTION DESCRIPTION_TRANSLATIONS 
+    LICENSE PRJ_GROUP MAINTAINER AUTHORS VENDER
+    BUILD_ARCH RPM_SPEC_URL RPM_SPEC_SOURCES
+    )
+
+SET(CHANGELOG_FILE "${CMAKE_SOURCE_DIR}/ChangeLog" CACHE FILEPATH "ChangeLog")
+SET(PRJ_INFO_CMAKE_FILE "${CMAKE_FEDORA_TMP_DIR}/prj_info.cmake" CACHE INTERNAL "prj_info.cmake")
+
+FUNCTION(PRJ_INFO_CMAKE_APPEND var)
+    IF(NOT "${${var}}" STREQUAL "")
+	STRING_ESCAPE_BACKSLASH(_str "${${var}}")
+	STRING_ESCAPE_DOLLAR(_str "${_str}")
+	STRING_ESCAPE_QUOTE(_str "${_str}")
+	FILE(APPEND ${PRJ_INFO_CMAKE_FILE} "SET(${var} \"${_str}\")\n")
+    ENDIF(NOT "${${var}}" STREQUAL "")
+ENDFUNCTION(PRJ_INFO_CMAKE_APPEND)
+
+MACRO(PRJ_INFO_CMAKE_READ prj_info_file)
+    IF("${prj_info_file}" STREQUAL "")
+	M_MSG(${M_EROR} "Requires prj_info.cmake")
+    ENDIF()
+    INCLUDE(${prj_info_file} RESULT_VARIABLE prjInfoPath)
+    IF("${prjInfoPath}" STREQUAL "NOTFOUND")
+	M_MSG(${M_ERROR} "Failed to read ${prj_info_file}")
+    ENDIF()
+ENDMACRO(PRJ_INFO_CMAKE_READ)
+
+FUNCTION(PRJ_INFO_CMAKE_WRITE)
+    FILE(REMOVE "${PRJ_INFO_CMAKE_FILE}")
+    FOREACH(_v ${PRJ_INFO_VARIABLE_LIST})
+	PRJ_INFO_CMAKE_APPEND(${_v})
+    ENDFOREACH(_v)
+ENDFUNCTION(PRJ_INFO_CMAKE_WRITE prj_info_file)
+
+## All variable should be specified eplicitly
+FUNCTION(RELEASE_NOTES_FILE_EXTRACT_CHANGELOG_CURRENT var releaseNoteFile )
+    FILE(STRINGS "${releaseNoteFile}" _releaseLines)
+    SET(_changeItemSection 0)
+    SET(_changeLogThis "")
+    ## Parse release file
+    INCLUDE(ManageString)
+    FOREACH(_line ${_releaseLines})
+	IF(_changeItemSection)
+	    ### Append lines in change section
+	    STRING_APPEND(_changeLogThis "${_line}" "\n")
+	ELSEIF("${_line}" MATCHES "^[[]Changes[]]")
+	    ### Start the change section
+	    SET(_changeItemSection 1)
+	ENDIF()
+    ENDFOREACH(_line ${_releaseLines})
+    SET(${var} "${_changeLogThis}" PARENT_SCOPE)
+ENDFUNCTION(RELEASE_NOTES_FILE_EXTRACT_CHANGELOG_CURRENT)
+
+FUNCTION(RELEASE_NOTES_READ_FILES_VARIABLES releaseNoteFile )
+    FILE(STRINGS "${RELEASE_NOTES_FILE}" _release_lines)
+
+    SET(CHANGELOG_CURRENT_FILE "${CMAKE_FEDORA_TMP_DIR}/ChangeLog.current" CACHE INTERNAL "ChangeLog.current")
+    ## Parse release file
+    IF (POLICY CMP0054)
+	CMAKE_POLICY(PUSH)
+	CMAKE_POLICY(SET CMP0054 "NEW")
+    ENDIF()
+    FOREACH(_line ${_release_lines})
+	IF("${_line}" MATCHES "^[[]Changes[]]")
+	    ### Start the change section
+	    BREAK()
+	ELSEIF(NOT "${_line}" MATCHES "^\\s*#")
+	    SETTING_STRING_GET_VARIABLE(var value "${_line}")
+
+	    IF("${var}" STREQUAL "PRJ_VER")
+		SET(${var} "${value}" CACHE STRING "Project Version" FORCE)
+	    ELSEIF("${var}" STREQUAL "SUMMARY")
+		SET(CHANGE_SUMMARY "${value}" CACHE STRING "Change Summary" FORCE)
+	    ELSE("${var}" STREQUAL "PRJ_VER")
+		SET(${var} "${value}" CACHE STRING "${var}" FORCE)
+	    ENDIF("${var}" STREQUAL "PRJ_VER")
+	ENDIF("${_line}" MATCHES "^[[]Changes[]]")
+    ENDFOREACH(_line)
+    IF (POLICY CMP0054)
+	CMAKE_POLICY(POP)
+    ENDIF()
+ENDFUNCTION(RELEASE_NOTES_READ_FILES_VARIABLES)
+
+FUNCTION(RELEASE_NOTES_READ_FILE)
+    FOREACH(_arg ${ARGN})
+	IF(EXISTS ${_arg})
+	    SET(RELEASE_NOTES_FILE ${_arg} CACHE FILEPATH "Release File")
+	ENDIF(EXISTS ${_arg})
+    ENDFOREACH(_arg ${ARGN})
+
+    IF(NOT RELEASE_NOTES_FILE)
+	SET(RELEASE_NOTES_FILE "${CMAKE_SOURCE_DIR}/RELEASE-NOTES.txt" CACHE FILEPATH "Release Notes")
+    ENDIF(NOT RELEASE_NOTES_FILE)
+
+    FILE(STRINGS "${RELEASE_NOTES_FILE}" _release_lines)
+
+    SET(_changeItemSection 0)
+    SET(CHANGELOG_CURRENT_FILE "${CMAKE_FEDORA_TMP_DIR}/ChangeLog.current" CACHE INTERNAL "ChangeLog.current")
+
+    ## Parse release file
+    RELEASE_NOTES_READ_FILES_VARIABLES(${RELEASE_NOTES_FILE})
+
+    IF(NOT CMAKE_SCRIPT_MODE_FILE)
+	## Non Script mode
+
+	INCLUDE(ManageTarget)
+
+	## Only update prj_info in non-script mode
+	PRJ_INFO_CMAKE_WRITE()
+
+	ADD_CUSTOM_TARGET(refresh_cmake_cache
+	    COMMAND ${CMAKE_COMMAND} -E remove -f ${CMAKE_SOURCE_DIR}/CMakeCache.txt
+	    COMMAND ${CMAKE_COMMAND} ${CMAKE_SOURCE_DIR}
+	    )
+
+	ADD_CUSTOM_TARGET_COMMAND(changelog
+	    NO_FORCE
+	    OUTPUT ${CHANGELOG_FILE}
+	    COMMAND ${CMAKE_COMMAND} -Dcmd=update 
+	    -Dchangelog=${CHANGELOG_FILE}
+	    -Drelease=${RELEASE_NOTES_FILE}
+	    -Dprj_info=${PRJ_INFO_CMAKE_FILE}
+	    -Dcmakecache=${CMAKE_BINARY_DIR}/CMakeCache.txt
+	    -Dcmake_source_dir=${CMAKE_SOURCE_DIR}
+	    -P ${CMAKE_FEDORA_MODULE_DIR}/ManageChangeLogScript.cmake
+	    DEPENDS ${RELEASE_NOTES_FILE}
+	    COMMENT "changelog: ${CHANGELOG_FILE}"
+	    )
+    ENDIF()
+ENDFUNCTION(RELEASE_NOTES_READ_FILE)
+
diff -Nura ibus-chewing-1.6.1/Modules/ManageZanata.cmake ibus-chewing-1.6.1_new/Modules/ManageZanata.cmake
--- ibus-chewing-1.6.1/Modules/ManageZanata.cmake	1970-01-01 08:00:00.000000000 +0800
+++ ibus-chewing-1.6.1_new/Modules/ManageZanata.cmake	2016-02-25 22:53:41.000000000 +0800
@@ -0,0 +1,973 @@
+# - Manage Zanata translation service support
+# 
+# Zanata is a web-based translation services, this module creates required targets. 
+# for common Zanata operation, like put-project, put-version, 
+#  push source and/or translation, pull translation and/or sources.
+# 
+#
+# Included Modules:
+#   - ManageFile
+#   - ManageMessage
+#   - ManageString
+#   - ManageTranslation
+#
+# Define following functions:
+#   MANAGE_ZANATA([[URL] <serverUrl>] [YES] [ERRORS] [DEBUG]
+#       [CHUNK_SIZE <sizeInByte>]
+#       [CLEAN_ZANATA_XML]
+#       [CLIENT_COMMAND <command> ]
+#       [COPY_TRANS <bool>]
+#       [CREATE_SKELETONS]
+#       [DISABLE_SSL_CERT]
+#       [ENCODE_TABS <bool>]
+#       [EXCLUDES <filePatternList>]
+#       [GENERATE_ZANATA_XML]
+#       [INCLUDES <filePatternList>]
+#       [LOCALES <locale1,locale2...> ]
+#       [PROJECT <projectId>]
+#       [PROJECT_CONFIG <zanata.xml>]
+#       [PROJECT_DESC "<Description>"]
+#       [PROJECT_NAME "<project name>"]
+#       [PROJECT_TYPE <projectType>]
+#       [SRC_DIR <srcDir>]
+#       [TRANS_DIR <transDir>]
+#       [TRANS_DIR_PULL <transDir>]
+#       [USER_CONFIG <zanata.ini>]
+#       [USERNAME <username>]
+#       [VERSION <ver>]
+#       [ZANATA_EXECUTABLE <command> ]
+#     )
+#     - Use Zanata as translation service.
+#         Zanata is a web-based translation manage system.
+#         It uses ${PROJECT_NAME} as project Id (slug);
+#         ${PRJ_NAME} as project name;
+#         ${PRJ_SUMMARY} as project description 
+#         (truncate to 80 characters);
+#         and ${PRJ_VER} as version, unless VERSION option is defined.
+#
+#         In order to use Zanata with command line, you will need either
+#         Zanata client:
+#         * zanata-cli: Zanata java command line client.
+#         * mvn: Maven build system.
+#         * zanata: Zanata python command line client.
+#
+#         In addition, ~/.config/zanata.ini is also required as it contains API key.
+#         API key should not be put in source tree, otherwise it might be
+#         misused.
+#
+#         Feature disabled warning (M_OFF) will be shown if Zanata client
+#         or zanata.ini is missing.
+#       * Parameters:
+#         + serverUrl: (Optional) The URL of Zanata server
+#           Default: https://translate.zanata.org/zanata/
+#         + YES: (Optional) Assume yes for all questions.
+#         + ERROR: (Optional) Show errors. As "-e" in maven.
+#         + DEBUG: (Optional) Show debug message. As "-X" in maven.
+#         + CLEAN_ZANATA_XML: (Optional) zanata.xml will be removed with 
+#             "make clean"
+#         + CLIENT_COMMAND command: (Optional)(Depreciated) command path to Zanata client.
+#           Use ZANATA_EXECUTABLE instead.
+#           Default: "zanata-cli"
+#         + COPY_TRANS bool: (Optional) Copy translation from existing versions.
+#           Default: "true"
+#         + CREATE_SKELETONS: (Optional) Create .po file even if there is no translation
+#         + DISABLE_SSL_CERT: (Optional) Disable SSL Cert check.
+#         + ENCODE_TABS bool: (Optional) Encode tab as "\t"/
+#         + EXCLUDES: (Optional) The file pattern that should not be pushed as source.
+#           e.g. **/debug*.properties
+#         + GENERATE_ZANATA_XML: (Optional) Automatic generate a zanata.xml
+#         + INCLUDES: (Optional) The file pattern that should be pushed as source.
+#           e.g. **/debug*.properties
+#         + LOCALES locales: Locales to sync with Zanata.
+#             Specify the locales to sync with this Zanata server.
+#             If not specified, it uses client side system locales.
+#         + PROJECT projectId: (Optional) This project ID in Zanata.
+#           (Space not allowed)
+#           Default: CMake Variable PROJECT_NAME
+#         + PROJECT_CONFIG zanata.xml: (Optoional) Path to zanata.xml
+#           If not specified, it will try to find zanata.xml in following directories:
+#              ${CMAKE_SOURCE_DIRECTORY}
+#              ${CMAKE_SOURCE_DIRECTORY}/po
+#              ${CMAKE_CURRENT_SOURCE_DIRECTORY}
+#              ${CMAKE_CURRENT_SOURCE_DIRECTORY}/po
+#              ${CMAKE_CURRENT_BINARY_DIR}
+#           if none found, it will set to:
+#           ${CMAKE_CURRENT_BINARY_DIR}/zanata.xml
+#         + PROJECT_DESC "Project description": (Optoional) Project description in Zanata.
+#           Default: ${PRJ_DESCRIPTION}
+#         + PROJECT_NAME "project name": (Optional) Project display name in Zanata.
+#           (Space allowed)
+#           Default: CMake Variable PROJECT_NAME
+#         + PROJECT_TYPE projectType::(Optional) Zanata project type 
+#             for this version.
+#	      Normally version inherit the project-type from project,
+#             if this is not the case, use this parameter to specify
+#             the project type.
+#           Valid values: file, gettext, podir, properties,
+#             utf8properties, xliff
+#         + SRC_DIR dir: (Optional) Directory to put source documents like .pot
+#             This value will be put in zanata.xml, so it should be relative.
+#           Default: "."
+#         + TRANS_DIR dir: (Optional) Relative directory to push the translated
+#             translated documents like .po
+#             This value will be put in zanata.xml, so it should be relative.
+#           Default: "."
+#         + TRANS_DIR_PULL dir: (Optional) Directory to pull translated documents.
+#           Default: CMAKE_CURRENT_BINARY_DIR
+#         + USER_CONFIG zanata.ini: (Optoional) Path to zanata.ini
+#             Feature disabled warning (M_OFF) will be shown if 
+#             if zanata.ini is missing.
+#           Default: $HOME/.config/zanata.ini
+#         + USERNAME username: (Optional) Zanata username
+#         + VERSION version: (Optional) The version to push
+#         + ZANATA_EXECUTABLE command : (Optional) command path to Zanata client.
+#           Default: "zanata-cli"
+#       * Targets:
+#         + zanata_put_projet: Put project in zanata server.
+#         + zanata_put_version: Put version in zanata server.
+#         + zanata_push: Push source messages to zanata server.
+#         + zanata_push_trans: Push translations to  zanata server.
+#         + zanata_push_both: Push source messages and translations to
+#             zanata server.
+#         + zanata_pull: Pull translations from zanata server.
+#       * Variable Cached:
+#         + ZANATA_CLIENT_EXECUTABLE: Full path of the client program.
+#         + ZANATA_CLIENT_TYPE: The type of Zanata client, either
+#             java: Java client
+#             python: Python client
+#             mvn: zanata-maven-plugin
+#
+
+
+IF(DEFINED _MANAGE_ZANATA_CMAKE_)
+    RETURN()
+ENDIF(DEFINED _MANAGE_ZANATA_CMAKE_)
+SET(_MANAGE_ZANATA_CMAKE_ "DEFINED")
+INCLUDE(ManageMessage)
+INCLUDE(ManageFile)
+INCLUDE(ManageString)
+INCLUDE(ManageTranslation)
+INCLUDE(ManageVariable)
+INCLUDE(ManageZanataDefinition)
+INCLUDE(ManageZanataSuggest)
+
+## Variable ZANATA_* are compulsory  
+SET(ZANATA_DESCRIPTION_SIZE 80 CACHE STRING "Zanata description size")
+
+#######################################
+# ZANATA "Object"
+#
+MACRO(MANAGE_ZANATA_XML_OBJECT_NEW var url )
+    SET(${var} "url")
+    SET(${var}_url "${url}")
+    FOREACH(arg ${ARGN})
+	IF("${${var}_project}" STREQUAL "")
+	    MANAGE_ZANATA_XML_OBJECT_ADD_PROPERTY(${var} "project" "${arg}")
+	ELSEIF("${${var}_version}" STREQUAL "")
+	    MANAGE_ZANATA_XML_OBJECT_ADD_PROPERTY(${var} "version" "${arg}")
+	ELSEIF("${${var}_type}" STREQUAL "")
+	    MANAGE_ZANATA_XML_OBJECT_ADD_PROPERTY(${var} "type" "${arg}")
+	ENDIF()
+    ENDFOREACH(arg)
+ENDMACRO(MANAGE_ZANATA_XML_OBJECT_NEW)
+
+MACRO(MANAGE_ZANATA_XML_OBJECT_ADD_PROPERTY var key value )
+    LIST(APPEND ${var} "${key}")
+    SET(${var}_${key} "${value}")
+ENDMACRO(MANAGE_ZANATA_XML_OBJECT_ADD_PROPERTY)
+
+FUNCTION(MANAGE_ZANATA_XML_OBJECT_TO_STRING outputVar var)
+    SET(buf "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>")
+    STRING_APPEND(buf "<config xmlns=\"http://zanata.org/namespace/config/\">" "\n")
+    STRING_APPEND(buf "  <url>${${var}_url}</url>" "\n")
+    STRING_APPEND(buf "  <project>${${var}_project}</project>" "\n")
+    STRING_APPEND(buf "  <project-version>${${var}_version}</project-version>" "\n")
+    STRING(TOLOWER "${${var}_type}" projectType)
+    STRING_APPEND(buf "  <project-type>${projectType}</project-type>" "\n")
+    IF(NOT "${${var}_srcdir}" STREQUAL "")
+	STRING_APPEND(buf "  <src-dir>${${var}_srcdir}</src-dyr>" "\n")
+    ENDIF()
+    IF(NOT "${${var}_transdir}" STREQUAL "")
+	STRING_APPEND(buf "  <trans-dir>${${var}_transdir}</trans-dir>" "\n")
+    ENDIF()
+    IF(NOT "${${var}_locales}" STREQUAL "")
+	STRING_APPEND(buf "  <locales>" "\n")
+	FOREACH(l ${${${var}_locales})
+	    IF(NOT "${${var}_locales_${l}}" STREQUAL "")
+		STRING_APPEND(buf "    <locale map-from=\"${${var}_locales_${l}}\">${l}</locale>" "\n")
+	    ELSE()
+		STRING_APPEND(buf "    <locale>${l}</locale>" "\n")
+	    ENDIF()
+	ENDFOREACH(l)
+	STRING_APPEND(buf "  </locales>" "\n")
+    ENDIF()
+    STRING_APPEND(buf "</config>" "\n")
+    SET(${outputVar} "${buf}" PARENT_SCOPE)
+ENDFUNCTION(MANAGE_ZANATA_XML_OBJECT_TO_STRING)
+
+#######################################
+## Option Conversion Function
+
+## ZANATA_STRING_DASH_TO_CAMEL_CASE(var opt)
+FUNCTION(ZANATA_STRING_DASH_TO_CAMEL_CASE var opt)
+    STRING_SPLIT(_strList "-" "${opt}")
+    SET(_first 1)
+    SET(_retStr "")
+    FOREACH(_s ${_strList})
+	IF("${_retStr}" STREQUAL "")
+	    SET(_retStr "${_s}")
+	ELSE()
+	    STRING(LENGTH "${_s}" _len)
+	    MATH(EXPR _tailLen ${_len}-1)
+	    STRING(SUBSTRING "${_s}" 0 1 _head)
+	    STRING(SUBSTRING "${_s}" 1 ${_tailLen} _tail)
+	    STRING(TOUPPER "${_head}" _head)
+	    STRING(TOLOWER "${_tail}" _tail)
+	    STRING_APPEND(_retStr "${_head}${_tail}")
+	ENDIF()
+    ENDFOREACH(_s)
+    SET(${var} "${_retStr}" PARENT_SCOPE)
+ENDFUNCTION(ZANATA_STRING_DASH_TO_CAMEL_CASE)
+
+FUNCTION(ZANATA_STRING_UPPERCASE_UNDERSCORE_TO_LOWERCASE_DASH var optName)
+    STRING(REPLACE "_" "-" result "${optName}")
+    STRING(TOLOWER "${result}" result)
+    SET(${var} "${result}" PARENT_SCOPE)
+ENDFUNCTION(ZANATA_STRING_UPPERCASE_UNDERSCORE_TO_LOWERCASE_DASH)
+
+FUNCTION(ZANATA_STRING_LOWERCASE_DASH_TO_UPPERCASE_UNDERSCORE var optName)
+    STRING(REPLACE "-" "_" result "${optName}")
+    STRING(TOUPPER "${result}" result)
+    SET(${var} "${result}" PARENT_SCOPE)
+ENDFUNCTION(ZANATA_STRING_LOWERCASE_DASH_TO_UPPERCASE_UNDERSCORE)
+
+FUNCTION(ZANATA_CLIENT_OPTNAME_LIST_APPEND_MVN listVar subCommandName optName)
+    IF("${optName}" STREQUAL "BATCH")
+	LIST(APPEND ${listVar} "-B")
+    ELSEIF("${optName}" STREQUAL "ERRORS")
+	LIST(APPEND ${listVar} "-e")
+    ELSEIF("${optName}" STREQUAL "DEBUG")
+	LIST(APPEND ${listVar} "-X")
+    ELSEIF("${optName}" STREQUAL "DISABLE_SSL_CERT")
+	LIST(APPEND ${listVar} "-Dzanata.disableSSLCert")
+    ELSEIF(DEFINED ZANATA_MVN_${subCommandName}_OPTION_NAME_${optName})
+	## Option name that changed in subCommandName
+	ZANATA_STRING_UPPERCASE_UNDERSCORE_TO_LOWERCASE_DASH(optNameReal
+	    "${ZANATA_MVN_${subCommandName}_OPTION_NAME_${optName}}")
+	ZANATA_STRING_DASH_TO_CAMEL_CASE(optNameReal "${optNameReal}")
+	IF(NOT "${ARGN}" STREQUAL "")
+	    LIST(APPEND ${listVar} "-Dzanata.${optNameReal}=${ARGN}")
+	ELSE()
+	    LIST(APPEND ${listVar} "-Dzanata.${optNameReal}")
+	ENDIF()
+    ELSE()
+	ZANATA_STRING_UPPERCASE_UNDERSCORE_TO_LOWERCASE_DASH(optNameReal "${optName}")
+	ZANATA_STRING_DASH_TO_CAMEL_CASE(optNameReal "${optNameReal}")
+	IF(NOT "${ARGN}" STREQUAL "")
+	    LIST(APPEND ${listVar} "-Dzanata.${optNameReal}=${ARGN}")
+	ELSE()
+	    LIST(APPEND ${listVar} "-Dzanata.${optNameReal}")
+	ENDIF()
+    ENDIF()
+    SET(${listVar} "${${listVar}}" PARENT_SCOPE)
+ENDFUNCTION(ZANATA_CLIENT_OPTNAME_LIST_APPEND_MVN)
+
+FUNCTION(ZANATA_CLIENT_OPTNAME_LIST_APPEND_JAVA listVar subCommandName optName)
+    IF("${optName}" STREQUAL "BATCH")
+	LIST(APPEND ${listVar} "-B")
+    ELSEIF("${optName}" STREQUAL "ERRORS")
+	LIST(APPEND ${listVar} "-e")
+    ELSEIF("${optName}" STREQUAL "DEBUG")
+	LIST(APPEND ${listVar} "-X")
+    ELSEIF(DEFINED ZANATA_MVN_${subCommandName}_OPTION_NAME_${optName})
+	## Option name that changed in subCommand
+	## Option name in mvn and zanata-cli is similar, 
+	## thus use ZANATA_MVN_<subCommandName>...
+	ZANATA_STRING_UPPERCASE_UNDERSCORE_TO_LOWERCASE_DASH(optNameReal
+	    "${ZANATA_MVN_${subCommandName}_OPTION_NAME_${optName}}")
+	IF(NOT "${ARGN}" STREQUAL "")
+	    LIST(APPEND ${listVar} "--${optNameReal}" "${ARGN}")
+	ELSE()
+	    LIST(APPEND ${listVar} "--${optNameReal}")
+	ENDIF()
+    ELSE()
+	ZANATA_STRING_UPPERCASE_UNDERSCORE_TO_LOWERCASE_DASH(optNameReal "${optName}")
+	IF(NOT "${ARGN}" STREQUAL "")
+	    LIST(APPEND ${listVar} "--${optNameReal}" "${ARGN}")
+	ELSE()
+	    LIST(APPEND ${listVar} "--${optNameReal}")
+	ENDIF()
+    ENDIF()
+    SET(${listVar} "${${listVar}}" PARENT_SCOPE)
+ENDFUNCTION(ZANATA_CLIENT_OPTNAME_LIST_APPEND_JAVA)
+
+FUNCTION(ZANATA_CLIENT_OPTNAME_LIST_APPEND_PYTHON listVar subCommandName optName)
+    IF("${optName}" STREQUAL "BATCH")
+	## Python client don't have BATCH
+    ELSEIF("${optName}" STREQUAL "ERRORS")
+	## Python client don't have ERRORS
+    ELSEIF("${optName}" STREQUAL "DEBUG")
+	## Python client don't have DEBUG
+    ELSE()
+	ZANATA_STRING_UPPERCASE_UNDERSCORE_TO_LOWERCASE_DASH(optNameReal "${optName}")
+	IF(NOT "${ARGN}" STREQUAL "")
+	    LIST(APPEND ${listVar} "--${optNameReal}" "${ARGN}")
+	ELSE()
+	    LIST(APPEND ${listVar} "--${optNameReal}")
+	ENDIF()
+    ENDIF()
+    SET(${listVar} "${${listVar}}" PARENT_SCOPE)
+ENDFUNCTION(ZANATA_CLIENT_OPTNAME_LIST_APPEND_PYTHON)
+
+FUNCTION(ZANATA_CLIENT_OPTNAME_LIST_APPEND listVar subCommand optName)
+    ZANATA_STRING_LOWERCASE_DASH_TO_UPPERCASE_UNDERSCORE(subCommandName "${subCommand}")
+    ## Skip Options that should not in the final command
+    IF(optName STREQUAL "ZANATA_EXECUTABLE")
+	RETURN()
+    ENDIF()
+
+    ## Invoke corresponding command
+    IF(ZANATA_CLIENT_TYPE STREQUAL "mvn")
+	ZANATA_CLIENT_OPTNAME_LIST_APPEND_MVN(${listVar} ${subCommandName} ${optName} ${ARGN})
+    ELSEIF(ZANATA_CLIENT_TYPE STREQUAL "java")
+	ZANATA_CLIENT_OPTNAME_LIST_APPEND_JAVA(${listVar} ${subCommandName} ${optName} ${ARGN})
+    ELSEIF(ZANATA_CLIENT_TYPE STREQUAL "python")
+	ZANATA_CLIENT_OPTNAME_LIST_APPEND_PYTHON(${listVar} ${subCommandName} ${optName} ${ARGN})
+    ELSE()
+	M_MSG(${M_ERROR} "ManageZanata: Unrecognized zanata client type ${ZANATA_CLIENT_TYPE}")
+    ENDIF()
+    SET(${listVar} "${${listVar}}" PARENT_SCOPE)
+ENDFUNCTION(ZANATA_CLIENT_OPTNAME_LIST_APPEND)
+
+## ZANATA_CLIENT_OPTNAME_LIST_PARSE_APPEND(var subCommand opt)
+## e.g ZANATA_CLIENT_OPTNAME_LIST_PARSE_APPEND(srcDir push "srcDir=.")
+FUNCTION(ZANATA_CLIENT_OPTNAME_LIST_PARSE_APPEND var subCommand opt)
+    STRING_SPLIT(_list "=" "${opt}")
+    ZANATA_CLIENT_OPTNAME_LIST_APPEND(${var} ${subCommand} ${_list})
+    SET(${var} "${${var}}" PARENT_SCOPE)
+ENDFUNCTION(ZANATA_CLIENT_OPTNAME_LIST_PARSE_APPEND)
+
+## Internal
+FUNCTION(ZANATA_CLIENT_SUB_COMMAND var subCommand)
+    IF(ZANATA_CLIENT_TYPE STREQUAL "mvn")
+	SET(${var} "${ZANATA_MAVEN_SUBCOMMAND_PREFIX}:${subCommand}" PARENT_SCOPE)
+    ELSEIF(ZANATA_CLIENT_TYPE STREQUAL "python")
+	## Python client
+	IF("${subCommand}" STREQUAL "put-project")
+	    SET(${var} "project" "create" PARENT_SCOPE)
+	ELSEIF("${subCommand}" STREQUAL "put-version")
+	    SET(${var} "version" "create" PARENT_SCOPE)
+	ELSE()
+	    SET(${var} "${subCommand}" PARENT_SCOPE)
+	ENDIF()
+    ELSE()
+	## java
+	SET(${var} "${subCommand}" PARENT_SCOPE)
+    ENDIF()
+ENDFUNCTION(ZANATA_CLIENT_SUB_COMMAND)
+
+## Set variable for ZANATA
+FUNCTION(ZANATA_SET_CACHE_VAR mapVar key)
+    IF(NOT DEFINED ZANATA_OPTION_NAME_${key}_VAR_TYPE)
+	M_MSG(${M_ERROR} "[ManageZanata] key ${key} is invalid")
+	RETURN()
+    ENDIF()
+
+    IF("${${mapVar}_${key}}" STREQUAL "")
+	IF(key STREQUAL "PROJECT")
+	    SET(v "${PROJECT_NAME}")
+	ELSEIF(key STREQUAL "PROJECT_CONFIG")
+	    SET(v "")
+	    FOREACH(d ${CMAKE_SOURCE_DIR} ${CMAKE_SOURCE_DIR}/po
+		    ${CMAKE_CURRENT_SOURCE_DIR} ${CMAKE_CURRENT_SOURCE_DIR}/po)
+		IF(EXISTS "${d}/zanata.xml")
+		    SET(v "${d}/zanata.xml")
+		    BREAK()
+		ENDIF()
+	    ENDFOREACH()
+	    IF("${v}" STREQUAL "")
+		SET(v "${CMAKE_CURRENT_BINARY_DIR}/zanata.xml")
+	    ENDIF()	
+	ELSEIF(key STREQUAL "USER_CONFIG")
+	    SET(v "$ENV{HOME}/.config/zanata.ini")
+	ELSE()
+	    SET(v "${ZANATA_OPTION_NAME_${key}_DEFAULT}")
+	ENDIF()
+	SET(force "")
+    ELSE()
+	SET(v "${${mapVar}_${key}}")
+	SET(force "FORCE")
+    ENDIF()
+    SET(ZANATA_${key} "${v}" CACHE "${ZANATA_OPTION_NAME_VAR_TYPE}" "ZANATA_${key}" ${force})
+ENDFUNCTION(ZANATA_SET_CACHE_VAR)
+
+## ZANATA_CMAKE_OPTIONS_PARSE_OPTIONSMAP <varPrefix> [ARGN]
+##   Parse the arguments from MANAGE_ZANATA.
+## Returns: <varPrefix> contains the specified arguments
+## Defines: <varPrefix>_<ARGUMENT> with value 
+FUNCTION(ZANATA_CMAKE_OPTIONS_PARSE_OPTIONS_MAP varPrefix)
+    ## isValue=2 Must be an option value
+    ## isValue=1 Maybe either
+    ## isValue=0 Must be an option name
+    SET(result "")
+    SET(isValue 1)
+    SET(isOptName 1)
+    SET(optName "")
+    SET(dependencyMissing 0)
+
+    FOREACH(opt ${ARGN})
+	IF(isValue EQUAL 1)
+	    ## Can be either, determine what it is
+	    IF(DEFINED ZANATA_OPTION_NAME_${opt})
+		## This is a new option name
+		SET(isValue 0)
+	    ELSEIF(NOT "${optName}" STREQUAL "")
+		## This should be an option value
+		SET(isValue 2)
+	    ELSEIF(opt MATCHES "^http")
+		## Zanata server url
+		SET(optName "URL")
+		SET(isValue 2)
+	        LIST(APPEND ${varPrefix} "${optName}")
+	    ELSE()
+		## Cannot decided
+		M_MSG(${M_ERROR} "ManageZanata: String '${opt}' is neither a option name, nor a value")
+	    ENDIF()
+	ENDIF()
+
+	IF (isValue EQUAL 0)
+	    ## Must be option name
+	    IF(NOT DEFINED ZANATA_OPTION_NAME_${opt})
+		M_MSG(${M_ERROR} "ManageZanata: Unrecognized option name ${opt}")
+	    ENDIF()
+
+	    IF(DEFINED ZANATA_OPTION_ALIAS_${opt})
+		SET(optName "${ZANATA_OPTION_ALIAS_${opt}}")
+	    ELSE()
+		SET(optName "${opt}")
+	    ENDIF()
+	    LIST(APPEND ${varPrefix} "${optName}")
+
+	    ## Find on next opt is value or option name
+	    LIST(GET ZANATA_OPTION_NAME_${optName} 0 isValue)
+
+	    ## Set value as 1 for no or optional value, as DEFINED is not reliable for sibling functions
+	    IF(isValue LESS 2)
+	        SET(${varPrefix}_${optName} "1")
+	        SET(${varPrefix}_${optName} "1" PARENT_SCOPE)
+	    ENDIF()
+	ELSEIF (${isValue} EQUAL 2)
+	    ## Must be option value
+	    IF("${optName}" STREQUAL "")
+		M_MSG(${M_ERROR} "ManageZanata: Value without associated option ${opt}")
+	    ENDIF()
+	    SET(${varPrefix}_${optName} "${opt}")
+	    SET(${varPrefix}_${optName} "${opt}" PARENT_SCOPE)
+	    SET(optName "")
+	    SET(isValue 0)
+	ELSE()
+	    ## Invalid Argument
+	    M_MSG(${M_ERROR} "ManageZanata: Error: isValue should not be ${isValue} with string '${opt}' ")
+	ENDIF()
+    ENDFOREACH()
+
+    ##== Set cache variable
+    FOREACH(optName ${ZANATA_OPTION_INIT_LIST})
+	ZANATA_SET_CACHE_VAR(${varPrefix} "${optName}")
+    ENDFOREACH()
+
+    ##== Variable that need to check
+    ## USER_CONFIG
+    IF(NOT EXISTS "${ZANATA_USER_CONFIG}")
+	SET(dependencyMissing 1)
+	M_MSG(${M_OFF} "MANAGE_ZANATA: Failed to find zanata.ini at ${ZANATA_USER_CONFIG}")
+    ENDIF()
+
+    ## ZANATA_CLIENT_EXECUTABLE
+    IF("${_o_ZANATA_EXECUTABLE}" STREQUAL "")
+	IF("${ZANATA_CLIENT_EXECUTABLE}" STREQUAL "")
+	    SET(zanataClientMissing 0)
+	    FIND_PROGRAM_ERROR_HANDLING(ZANATA_CLIENT_EXECUTABLE
+		ERROR_MSG " Zanata support is disabled."
+		ERROR_VAR zanataClientMissing
+		VERBOSE_LEVEL ${M_OFF}
+		FIND_ARGS NAMES zanata-cli mvn zanata
+		)
+	    IF(zanataClientMissing EQUAL 1)
+		SET(dependencyMissing 1)
+		M_MSG(${M_OFF} "MANAGE_ZANATA: Failed to find zanata client, Zanata support disabled")
+	    ELSE()
+		SET(ZANATA_CLIENT_EXECUTABLE "${ZANATA_CLIENT_EXECUTABLE}"
+		    CACHE FILEPATH "Zanata client excutable"
+		    )
+	    ENDIF()
+	ENDIF()
+    ELSE()
+	LIST(GET ${varPrefix}_ZANATA_EXECUTABLE 0 ZANATA_CLIENT_EXECUTABLE)
+	SET(ZANATA_CLIENT_EXECUTABLE "${${varPrefix}_ZANATA_EXECUTABLE}"
+	    CACHE FILEPATH "Zanata client excutable" FORCE
+	    )
+    ENDIF()
+    GET_FILENAME_COMPONENT(zanataClientFilename "${ZANATA_CLIENT_EXECUTABLE}" NAME)
+    IF(zanataClientFilename STREQUAL "zanata")
+	SET(ZANATA_CLIENT_TYPE "python" CACHE INTERNAL "Zanata Client Type")
+    ELSEIF(zanataClientFilename STREQUAL "zanata-cli")
+	SET(ZANATA_CLIENT_TYPE "java" CACHE INTERNAL "Zanata Client Type")
+    ELSEIF(zanataClientFilename STREQUAL "mvn")
+	SET(ZANATA_CLIENT_TYPE "mvn" CACHE INTERNAL "Zanata Client Type")
+    ELSE()
+	M_MSG(${M_OFF} "${ZANATA_CLIENT_EXECUTABLE} is not a supported Zanata client")
+	SET(dependencyMissing 1)
+    ENDIF()
+
+    IF(dependencyMissing EQUAL 1)
+	SET(${varPrefix}_DEPENDENCY_MISSING 1 PARENT_SCOPE)
+	RETURN()
+    ENDIF()
+
+    ##== Other Variables
+    IF("${${varPrefix}_PROJECT_DESC}" STREQUAL "")
+	SET(${varPrefix}_PROJECT_DESC "${PRJ_SUMMARY}")
+    ENDIF()
+    STRING(LENGTH "${${varPrefix}_PROJECT_DESC}" _prjSummaryLen)
+    IF(_prjSummaryLen GREATER ${ZANATA_DESCRIPTION_SIZE})
+	STRING(SUBSTRING "${${varPrefix}_PROJECT_DESC}" 0 ${ZANATA_DESCRIPTION_SIZE} 
+	    ${varPrefix}_PROJECT_DESC
+	    )
+    ENDIF()
+    SET(${varPrefix}_PROJECT_DESC "${${varPrefix}_PROJECT_DESC}" PARENT_SCOPE)
+
+    SET(${varPrefix} "${${varPrefix}}" PARENT_SCOPE)
+ENDFUNCTION(ZANATA_CMAKE_OPTIONS_PARSE_OPTIONS_MAP)
+
+#   MANAGE_ZANATA_OBTAIN_REAL_COMMAND(<cmdListVar>
+#       <subCommand> <optionMapVar>
+#       [YES] [BATCH] [ERRORS] [DEBUG]
+#       [DISABLE_SSL_CERT]
+#       [URL <url>]
+#       [USERNAME <username>]
+#       [KEY <key>]
+#       [USER_CONFIG <zanata.ini>]
+#       ...
+#     )
+
+FUNCTION(MANAGE_ZANATA_OBTAIN_REAL_COMMAND cmdListVar subCommand optionMapVar)
+    IF(${optionMapVar}_BATCH)
+	IF(${optionMapVar}_BACKEND STREQUAL "python")
+	    SET(result "yes" "|" "${ZANATA_CLIENT_EXECUTABLE}")
+	ELSE()
+	    SET(result "${ZANATA_CLIENT_EXECUTABLE}")
+	    ZANATA_CLIENT_OPTNAME_LIST_APPEND(result "${subCommand}" "BATCH" )
+	ENDIF()
+    ELSE()
+	SET(result "${ZANATA_CLIENT_EXECUTABLE}")
+    ENDIF()
+
+    FOREACH(optName "DEBUG" "ERRORS")
+	IF(${optionMapVar}_${optName})
+	    ZANATA_CLIENT_OPTNAME_LIST_APPEND(result "${subCommand}" "${optName}" )
+	ENDIF()
+    ENDFOREACH(optName)
+
+    ## Sub-command
+    ZANATA_CLIENT_SUB_COMMAND(subCommandReal "${subCommand}")
+    LIST(APPEND result "${subCommandReal}")
+
+    ## Explicit Options
+    FOREACH(optName ${${optionMapVar}})
+	IF(optName STREQUAL "BATCH")
+	ELSEIF(optName STREQUAL "DEBUG")
+	ELSEIF(optName STREQUAL "ERRORS")
+	ELSE()
+	    IF(${optionMapVar}_${optName})
+		IF(ZANATA_OPTION_NAME_${optName} EQUAL 1 AND "${${optionMapVar}_${optName}}" STREQUAL "1")
+		    ZANATA_CLIENT_OPTNAME_LIST_APPEND(result "${subCommand}" "${optName}")
+		ELSE()
+		    ZANATA_CLIENT_OPTNAME_LIST_APPEND(result "${subCommand}" "${optName}"  "${${optionMapVar}_${optName}}")
+		ENDIF()
+	    ENDIF()
+	ENDIF()
+    ENDFOREACH(optName)
+
+    ## Implied options: Mandatory options but not specified.
+    ZANATA_STRING_LOWERCASE_DASH_TO_UPPERCASE_UNDERSCORE(subCommandName "${subCommand}")
+    STRING(TOUPPER "${ZANATA_CLIENT_TYPE}" zanataClientTypeUpper)
+    
+    IF(DEFINED ZANATA_${zanataClientTypeUpper}_${subCommandName}_MANDATORY_OPTIONS)
+	FOREACH(optName ${ZANATA_${zanataClientTypeUpper}_${subCommandName}_MANDATORY_OPTIONS})
+	    IF(DEFINED ZANATA_${optName})
+		## Implied options
+		IF("${${optionMapVar}_${optName}}" STREQUAL "")
+		    ## Not yet append as exlicit options
+		    ZANATA_CLIENT_OPTNAME_LIST_APPEND(result "${subCommand}" "${optName}" "${ZANATA_${optName}}")
+		ENDIF()
+	    ENDIF()
+	ENDFOREACH(optName)
+    ENDIF()
+
+    SET(${cmdListVar} "${result}" PARENT_SCOPE) 
+ENDFUNCTION(MANAGE_ZANATA_OBTAIN_REAL_COMMAND)
+
+#######################################
+# ZANATA Put_Version
+#
+
+# MANAGE_ZANATA_OBTAIN_PUT_VERSION_COMMAND(<cmdListVar> <optionMapVar>)
+FUNCTION(MANAGE_ZANATA_OBTAIN_PUT_VERSION_COMMAND cmdListVar optionMapVar) 
+    ### zanata_put-version
+    MANAGE_ZANATA_OBTAIN_REAL_COMMAND(result put-version ${optionMapVar})
+    SET(${cmdListVar} "${result}" PARENT_SCOPE) 
+ENDFUNCTION(MANAGE_ZANATA_OBTAIN_PUT_VERSION_COMMAND)
+
+FUNCTION(MANAGE_ZANATA_PUT_VERSION_TARGETS cmdList)
+    ADD_CUSTOM_TARGET(zanata_put_version
+	COMMAND ${cmdList}
+	COMMENT "zanata_put-version: with ${cmdList}"
+	DEPENDS ${zanataXml}
+	)
+ENDFUNCTION(MANAGE_ZANATA_PUT_VERSION_TARGETS)
+
+
+#######################################
+# ZANATA Push
+#
+
+# MANAGE_ZANATA_OBTAIN_PUSH_COMMAND(<cmdListVar> <optionMapVar>)
+FUNCTION(MANAGE_ZANATA_OBTAIN_PUSH_COMMAND cmdListVar optionMapVar)
+    ### zanata_push
+    MANAGE_ZANATA_OBTAIN_REAL_COMMAND(result push ${optionMapVar})
+    SET(${cmdListVar} "${result}" PARENT_SCOPE) 
+ENDFUNCTION(MANAGE_ZANATA_OBTAIN_PUSH_COMMAND)
+
+FUNCTION(MANAGE_ZANATA_PUSH_TARGETS cmdList)
+    ADD_CUSTOM_TARGET(zanata_push
+	COMMAND ${cmdList}
+	COMMENT "zanata_push: with ${cmdList}"
+	DEPENDS ${zanataXml}
+	)
+
+    ### zanata_push_both
+    SET(extraOptions "")
+    ZANATA_CLIENT_OPTNAME_LIST_APPEND(extraOptions "PUSH_TYPE" "both")
+    ADD_CUSTOM_TARGET(zanata_push_both 
+	COMMAND ${cmdList} ${extraOptions}
+	COMMENT "zanata_push: with ${cmdList} ${extraOptions}"
+	DEPENDS ${zanataXml}
+	)
+
+    ### zanata_push_trans
+    SET(extraOptions "")
+    ZANATA_CLIENT_OPTNAME_LIST_APPEND(extraOptions "PUSH_TYPE" "trans")
+    ADD_CUSTOM_TARGET(zanata_push_trans 
+	COMMAND ${cmdList} ${extraOptions}
+	COMMENT "zanata_push: with ${cmdList} ${extraOptions}"
+	DEPENDS ${zanataXml}
+	)
+ENDFUNCTION(MANAGE_ZANATA_PUSH_TARGETS)
+
+#######################################
+# ZANATA Pull
+#
+
+# MANAGE_ZANATA_OBTAIN_PULL_COMMAND(<cmdListVar> <optionMapVar>)
+FUNCTION(MANAGE_ZANATA_OBTAIN_PULL_COMMAND cmdListVar optionMapVar)
+    ### zanata_pull
+    MANAGE_ZANATA_OBTAIN_REAL_COMMAND(result pull ${optionMapVar})
+    SET(${cmdListVar} "${result}" PARENT_SCOPE) 
+ENDFUNCTION(MANAGE_ZANATA_OBTAIN_PULL_COMMAND)
+
+FUNCTION(MANAGE_ZANATA_PULL_TARGETS cmdList)
+    ADD_CUSTOM_TARGET(zanata_pull
+	COMMAND ${cmdList}
+	COMMENT "zanata_pull: with ${cmdList}"
+	DEPENDS ${zanataXml}
+	)
+
+    ### zanata_pull_both
+    SET(extraOptions "")
+    ZANATA_CLIENT_OPTNAME_LIST_APPEND(extraOptions "PULL_TYPE" "both")
+    ADD_CUSTOM_TARGET(zanata_pull_both 
+	COMMAND ${cmdList} ${extraOptions}
+	COMMENT "zanata_pull: with ${cmdList} ${extraOptions}"
+	DEPENDS ${zanataXml}
+	)
+
+ENDFUNCTION(MANAGE_ZANATA_PULL_TARGETS)
+
+#######################################
+# ZANATA Main
+#
+
+FUNCTION(MANAGE_ZANATA)
+    ZANATA_CMAKE_OPTIONS_PARSE_OPTIONS_MAP(_o ${ARGN})
+
+    IF(_o_DEPENDENCIES_MISSING EQUAL 1)
+	RETURN()
+    ENDIF()
+
+    ### Common options
+    SET(zanataCommonOptions "")
+    FOREACH(optCName "URL" ${ZANATA_CLIENT_COMMON_VALID_OPTIONS})
+	SET(value "${_o_${optCName}}")
+	IF(value)
+	    ZANATA_CLIENT_OPTNAME_LIST_APPEND(zanataCommonOptions "${optCName}" "${value}")
+	ENDIF()
+    ENDFOREACH(optCName)
+
+    ### zanata_put_project
+    SET(exec "")
+    MANAGE_ZANATA_OBTAIN_REAL_COMMAND(exec put-project _o)
+    LIST(APPEND exec  ${zanataCommonOptions}) 
+    ADD_CUSTOM_TARGET(zanata_put_project
+	COMMAND ${exec}
+	COMMENT "zanata_put_project: with ${exec}"
+	)
+
+    ### zanata_put_version 
+    MANAGE_ZANATA_OBTAIN_PUT_VERSION_COMMAND(cmdPushList _o)
+    MANAGE_ZANATA_PUT_VERSION_TARGETS("${cmdPushList}")
+
+    ### zanata_push
+    MANAGE_ZANATA_OBTAIN_PUSH_COMMAND(cmdPushList _o)
+    MANAGE_ZANATA_PUSH_TARGETS("${cmdPushList}")
+
+    ### zanata_pull
+    MANAGE_ZANATA_OBTAIN_PULL_COMMAND(cmdPullList _o)
+    MANAGE_ZANATA_PULL_TARGETS("${cmdPullList}")
+ENDFUNCTION(MANAGE_ZANATA)
+
+#######################################
+# MANAGE_ZANATA_XML_MAKE
+#
+FUNCTION(ZANATA_LOCALE_COMPLETE var language script country modifier)
+    IF("${modifier}" STREQUAL "")
+	SET(sModifier "${ZANATA_SUGGEST_MODIFIER_${language}_${script}_}")
+	IF(NOT "${sModifier}" STREQUAL "")
+	    SET(modifier "${sModifier}")
+	ENDIF()
+    ENDIF()
+    IF("${country}" STREQUAL "")
+	SET(sCountry "${ZANATA_SUGGEST_COUNTRY_${language}_${script}_}")
+	IF(NOT "${sCountry}" STREQUAL "")
+	    SET(country "${sCountry}")
+	ENDIF()
+    ENDIF()
+    IF("${script}" STREQUAL "")
+	SET(sScript "${ZANATA_SUGGEST_SCRIPT_${language}_${country}_${modifier}}")
+	IF(NOT "${sScript}" STREQUAL "")
+	    SET(script "${sScript}")
+	ENDIF()
+    ENDIF()
+    SET(${var} "${language}_${script}_${country}_${modifier}" PARENT_SCOPE)
+ENDFUNCTION(ZANATA_LOCALE_COMPLETE var locale)
+
+FUNCTION(ZANATA_JSON_GET_VALUE var key string)
+    STRING(REGEX REPLACE ".*[{,]\"${key}\":\"([^\"]*)\".*" "\\1" ret "${string}")
+    SET(${var} "${ret}" PARENT_SCOPE)
+ENDFUNCTION(ZANATA_JSON_GET_VALUE)
+
+FUNCTION(ZANATA_JSON_TO_ARRAY var string)
+    STRING(REGEX REPLACE "[[]\(.*\)[]]" "\\1" ret1 "${string}")
+    STRING(REGEX REPLACE "},{" "};{" ret "${ret1}")
+    SET(${var} "${ret}" PARENT_SCOPE)
+ENDFUNCTION(ZANATA_JSON_TO_ARRAY)
+
+FUNCTION(ZANATA_REST_GET_PROJECT_VERSION_TYPE var url project version)
+    SET(restUrl "${url}rest/projects/p/${project}/iterations/i/${version}")
+    EXECUTE_PROCESS(COMMAND curl -f -G -s -H  "Content-Type:application/json" 
+	-H "Accept:application/json" "${restUrl}"
+	RESULT_VARIABLE curlRet
+	OUTPUT_VARIABLE curlOut)
+    IF(NOT curlRet EQUAL 0)
+	M_MSG(${M_OFF} "Failed to get project type from project ${project} to ${version} with ${url}")
+	RETURN()
+    ENDIF()
+    ZANATA_JSON_GET_VALUE(ret "projectType" "${curlOut}")
+    SET(${var} "${ret}" PARENT_SCOPE)
+ENDFUNCTION(ZANATA_REST_GET_PROJECT_VERSION_TYPE)
+
+FUNCTION(ZANATA_REST_GET_PROJECT_VERSION_LOCALES var url project version)
+    SET(restUrl "${url}rest/projects/p/${project}/iterations/i/${version}/locales")
+    EXECUTE_PROCESS(COMMAND curl -f -G -s -H  "Content-Type:application/json" 
+	-H "Accept:application/json" "${restUrl}"
+	RESULT_VARIABLE curlRet
+	OUTPUT_VARIABLE curlOut)
+    IF(NOT curlRet EQUAL 0)
+	M_MSG(${M_OFF} "Failed to get project type from project ${project} to ${version} with ${url}")
+	RETURN()
+    ENDIF()
+    ZANATA_JSON_TO_ARRAY(nodeArray "${curlOut}")
+    SET(retArray "")
+    FOREACH(node ${nodeArray})
+	ZANATA_JSON_GET_VALUE(l "localeId" "${node}")
+	LIST(APPEND retArray "${l}")
+    ENDFOREACH()
+    SET(${var} "${retArray}" PARENT_SCOPE)
+ENDFUNCTION(ZANATA_REST_GET_PROJECT_VERSION_LOCALES)
+
+FUNCTION(ZANATA_ZANATA_XML_DOWNLOAD zanataXml url project version)
+    GET_FILENAME_COMPONENT(zanataXmlDir "${zanataXml}" PATH)
+    IF(NOT zanataXmlDir)
+	SET(zanataXml "./${zanataXml}")
+    ENDIF()
+
+    ZANATA_REST_GET_PROJECT_VERSION_TYPE(pType "${url}" "${project}" "${version}")
+    MANAGE_ZANATA_XML_OBJECT_NEW(zObj "${url}" "${project}" "${version}" "${pType}")
+    MANAGE_ZANATA_XML_OBJECT_TO_STRING(buf zObj)
+    FILE(WRITE "${zanataXml}" "${buf}")
+ENDFUNCTION(ZANATA_ZANATA_XML_DOWNLOAD)
+
+FUNCTION(ZANATA_BEST_MATCH_LOCALES var serverLocales clientLocales)
+    ## Build "Client Hash"
+    SET(result "")
+    FOREACH(cL ${clientLocales})
+	LOCALE_PARSE_STRING(cLang cScript cCountry cModifier "${cL}")
+	SET(_ZANATA_CLIENT_LOCALE_${cLang}_${cScript}_${cCountry}_${cModifier} "${cL}")
+	ZANATA_LOCALE_COMPLETE(cCLocale "${cLang}" "${cScript}" "${cCountry}" "${cModifier}")
+	SET(compKey "_ZANATA_CLIENT_COMPLETE_LOCALE_${cCLocale}")
+	IF("${${compKey}}" STREQUAL "")
+	    SET("${compKey}" "${cL}")
+	ENDIF()
+    ENDFOREACH()
+
+    ## 1st pass: Exact match
+    FOREACH(sL ${serverLocales})
+	LOCALE_PARSE_STRING(sLang sScript sCountry sModifier "${sL}")
+	SET(scKey "_ZANATA_CLIENT_LOCALE_${sLang}_${sScript}_${sCountry}_${sModifier}")
+	## Exact match locale
+	SET(cLExact "${${scKey}}")
+	IF(NOT "${cLExact}" STREQUAL "")
+	    SET(_ZANATA_SERVER_LOCALE_${sL} "${cLExact}")
+	    SET(_ZANATA_CLIENT_LOCALE_${cLExact}  "${sL}")
+	    LIST(APPEND result "${sL},${cLExact}")
+	ENDIF()
+    ENDFOREACH() 
+
+    ## 2nd pass: Find the next best match
+    FOREACH(sL ${serverLocales})
+	IF("${_ZANATA_SERVER_LOCALE_${sL}}" STREQUAL "")
+	    ## no exact match
+	    LOCALE_PARSE_STRING(sLang sScript sCountry sModifier "${sL}")
+
+	    ## Locale completion
+	    ZANATA_LOCALE_COMPLETE(sCLocale "${sLang}" "${sScript}" "${sCountry}" "${sModifier}")
+	    SET(sCompKey "_ZANATA_CLIENT_COMPLETE_LOCALE_${sCLocale}")
+	    SET(bestMatch "")
+
+	    ## Match client locale after Locale completion
+	    SET(cLComp "${${sCompKey}}")
+	    IF(NOT "${cLComp}" STREQUAL "")
+		## And the client locale is not occupied
+		IF("${_ZANATA_CLIENT_LOCALE_${cLComp}}" STREQUAL "")
+		    SET(_ZANATA_SERVER_LOCALE_${sL} "${cLComp}")
+		    SET(_ZANATA_CLIENT_LOCALE_${cLComp}  "${sL}")
+		    SET(bestMatch "${cLComp}")
+		ENDIF()
+	    ENDIF()
+	    IF(bestMatch STREQUAL "")
+		## No matched, use corrected sL
+		STRING(REPLACE "-" "_" bestMatch "${sL}")
+		IF("${bestMatch}" STREQUAL "${sL}")
+		    M_MSG(${M_OFF} "${sL} does not have matched client locale, use as-is.")
+		ELSE()
+		    M_MSG(${M_OFF} "${sL} does not have matched client locale, use ${bestMatch}.")
+		ENDIF()
+	    ENDIF()
+	    LIST(APPEND result "${sL},${bestMatch}")
+	ENDIF()
+    ENDFOREACH() 
+    LIST(SORT result)
+    SET(${var} "${result}" PARENT_SCOPE)
+ENDFUNCTION(ZANATA_BEST_MATCH_LOCALES)
+
+FUNCTION(ZANATA_ZANATA_XML_MAP zanataXml zanataXmlIn workDir)
+    INCLUDE(ManageTranslation)
+    INCLUDE(ManageZanataSuggest)
+    FILE(STRINGS "${zanataXmlIn}" zanataXmlLines)
+    FILE(REMOVE ${zanataXml})
+
+    ## Start parsing zanataXmlIn and gather serverLocales
+    SET(serverLocales "")
+    SET(srcDirOrig "")
+    SET(transDirOrig "")
+    FOREACH(line ${zanataXmlLines})
+	IF("${line}" MATCHES "<locale>(.*)</locale>")
+	    ## Is a locale string
+	    SET(sL "${CMAKE_MATCH_1}")
+	    LIST(APPEND serverLocales "${sL}")
+	ELSEIF("${line}" MATCHES "<src-dir>(.*)</src-dir>")
+	    SET(srcDirOrig "${CMAKE_MATCH_1}")
+	ELSEIF("${line}" MATCHES "<trans-dir>(.*)</trans-dir>")
+	    SET(transDirOrig "${CMAKE_MATCH_1}")
+	ELSEIF("${line}" MATCHES "<url>(.*)</url>")
+	    SET(url "${CMAKE_MATCH_1}")
+	ELSEIF("${line}" MATCHES "<project>(.*)</project>")
+	    SET(project "${CMAKE_MATCH_1}")
+	ELSEIF("${line}" MATCHES "<project-version>(.*)</project-version>")
+	    SET(version "${CMAKE_MATCH_1}")
+	ELSEIF("${line}" MATCHES "<project-type>(.*)</project-type>")
+	    SET(projectType "${CMAKE_MATCH_1}")
+	ELSE()
+	    IF(zanataXmlIsHeader)
+		STRING_APPEND(zanataXmlHeader "${line}" "\n")
+	    ELSE()
+		STRING_APPEND(zanataXmlFooter "${line}" "\n")
+	    ENDIF()
+	    ## Not a locale string, write as-is
+	ENDIF()
+    ENDFOREACH()
+
+    MANAGE_ZANATA_XML_OBJECT_NEW(zObj ${url} ${project} ${version} ${projectType})
+
+    ## Build "Client Hash"
+    MANAGE_GETTEXT_LOCALES(clientLocales WORKING_DIRECTORY "${workDir}" DETECT_PO_DIR poDir ${ARGN})
+    IF(NOT "${srcDirOrig}" STREQUAL "")
+	SET(poDir "${srcDirOrig}")
+    ELSEIF("${poDir}" STREQUAL "")
+	SET(poDir ".")
+    ENDIF()
+
+    IF(NOT "${transDirOrig}" STREQUAL "")
+	SET(potDir "${transDirOrig}")
+    ELSE()
+	MANAGE_GETTEXT_DETECT_POT_DIR(potDir WORKING_DIRECTORY "${workDir}")
+	IF("${potDir}" STREQUAL "NOTFOUND")
+	    M_MSG(${M_ERROR} "ZANATA_ZANATA_XML_MAP: Failed to detect pot dir because .pot files are not found in ${workDir}")
+	ELSEIF("${potDir}" STREQUAL "")
+	    SET(potDir ".")
+	ENDIF()
+    ENDIF()
+    MANAGE_ZANATA_XML_OBJECT_ADD_PROPERTY(zObj "src-dir" "${potDir}")
+    MANAGE_ZANATA_XML_OBJECT_ADD_PROPERTY(zObj "trans-dir" "${poDir}")
+
+    
+    IF(NOT "${serverLocales}" STREQUAL "")
+	## If server locales are available, then start matching the client and server locales
+
+	## clientLocales if not specified
+	IF("${clientLocales}" STREQUAL "")
+	    MANAGE_GETTEXT_LOCALES(clientLocales SYSTEM_LOCALES)
+	ENDIF()
+	M_MSG(${M_INFO3} "clientLocales=${clientLocales}")
+
+	LIST(SORT serverLocales)
+	ZANATA_BEST_MATCH_LOCALES(bestMatches "${serverLocales}" "${clientLocales}")
+
+	FOREACH(bM ${bestMatches})
+	    STRING_SPLIT(lA "," "${bM}")
+	    LIST(GET lA 0 sLocale)
+	    LIST(GET lA 1 cLocale)
+	    LIST(APPEND zObj_locales "${sLocale}")
+
+	    IF(NOT "${sLocale}" STREQUAL "${cLocale}")
+		SET(zObj_locales_${sLocale} "${cLocale}")
+	    ENDIF()
+	ENDFOREACH(bM)
+    ENDIF(NOT "${serverLocales}" STREQUAL "")
+
+    MANAGE_ZANATA_XML_OBJECT_TO_STRING(outputBuf zObj)
+    FILE(WRITE "${zanataXml}" "${outputBuf}")
+ENDFUNCTION(ZANATA_ZANATA_XML_MAP)
+
+
+
diff -Nura ibus-chewing-1.6.1/Modules/ManageZanataDefinition.cmake ibus-chewing-1.6.1_new/Modules/ManageZanataDefinition.cmake
--- ibus-chewing-1.6.1/Modules/ManageZanataDefinition.cmake	1970-01-01 08:00:00.000000000 +0800
+++ ibus-chewing-1.6.1_new/Modules/ManageZanataDefinition.cmake	2016-01-29 15:15:26.000000000 +0800
@@ -0,0 +1,128 @@
+# Manage Zanata definition 
+
+IF(DEFINED _MANAGE_ZANATA_DEFINITION_)
+    RETURN()
+ENDIF(DEFINED _MANAGE_ZANATA_DEFINITION_)
+SET(_MANAGE_ZANATA_DEFINITION_ "DEFINED")
+SET(ZANATA_MAVEN_SUBCOMMAND_PREFIX "org.zanata:zanata-maven-plugin" )
+
+## ZANATA_OPTIONS_NAME_<OPTION> <HAS_VALUE> [<defaultvalue>]
+## OPTION_ID: Start with - : mvn/zanata-cli options
+##            Start with  : cmake-fedora options
+##            Others       : zanata-cli formatted long options
+## HAS_VALUE: 0 (no value)
+##            1 (optional value)
+##            2 (mandatory value)
+
+SET(ZANATA_OPTION_NAME_YES 0)
+SET(ZANATA_OPTION_NAME_BATCH 0)
+SET(ZANATA_OPTION_NAME_ERRORS 0)
+SET(ZANATA_OPTION_NAME_DEBUG 0)
+SET(ZANATA_OPTION_NAME_CLEAN_ZANATA_XML  0)
+SET(ZANATA_OPTION_NAME_CLIENT_COMMAND  2)
+SET(ZANATA_OPTION_NAME_ZANATA_EXECUTABLE 2)
+SET(ZANATA_OPTION_NAME_ZANATA_EXECUTABLE_VAR_TYPE "FILEPATH")
+SET(ZANATA_OPTION_NAME_COPY_TRANS 1)
+SET(ZANATA_OPTION_NAME_CREATE_SKELETONS 1)
+SET(ZANATA_OPTION_NAME_DISABLE_SSL_CERT 1)
+SET(ZANATA_OPTION_NAME_ENCODE_TABS 1)
+SET(ZANATA_OPTION_NAME_EXCLUDES 2)
+SET(ZANATA_OPTION_NAME_GENERATE_ZANATA_XML 0)
+SET(ZANATA_OPTION_NAME_INCLUDES 2)
+SET(ZANATA_OPTION_NAME_LOCALES 2)
+SET(ZANATA_OPTION_NAME_PROJECT 2)
+SET(ZANATA_OPTION_NAME_PROJECT_VAR_TYPE "STRING")
+SET(ZANATA_OPTION_NAME_PROJECT_CONFIG 2)
+SET(ZANATA_OPTION_NAME_PROJECT_CONFIG_VAR_TYPE "FILEPATH")
+SET(ZANATA_OPTION_NAME_PROJECT_DESC 2)
+SET(ZANATA_OPTION_NAME_PROJECT_NAME 2)
+SET(ZANATA_OPTION_NAME_PROJECT_TYPE 2)
+SET(ZANATA_OPTION_NAME_PROJECT_TYPE_DEFAULT "gettext")
+SET(ZANATA_OPTION_NAME_PROJECT_TYPE_VAR_TYPE "STRING")
+SET(ZANATA_OPTION_NAME_SRC_DIR  2)
+SET(ZANATA_OPTION_NAME_SRC_DIR_DEFAULT ".")
+SET(ZANATA_OPTION_NAME_SRC_DIR_VAR_TYPE "FILEPATH")
+SET(ZANATA_OPTION_NAME_TRANS_DIR 2)
+SET(ZANATA_OPTION_NAME_TRANS_DIR_DEFAULT ".")
+SET(ZANATA_OPTION_NAME_TRANS_DIR_VAR_TYPE "FILEPATH")
+SET(ZANATA_OPTION_NAME_TRANS_DIR_PULL 2)
+SET(ZANATA_OPTION_NAME_TRANS_DIR_PULL_VAR_TYPE "FILE_PATH")
+SET(ZANATA_OPTION_NAME_TRANS_DIR_PULL 2)
+SET(ZANATA_OPTION_NAME_URL 2)
+SET(ZANATA_OPTION_NAME_URL_DEFAULT "https://translate.zanata.org/zanata/")
+SET(ZANATA_OPTION_NAME_URL_VAR_TYPE "STRING")
+SET(ZANATA_OPTION_NAME_USERNAME 2)
+SET(ZANATA_OPTION_NAME_USER_CONFIG 2)
+SET(ZANATA_OPTION_NAME_USER_CONFIG_VAR_TYPE "FILE_PATH")
+SET(ZANATA_OPTION_NAME_VERSION 2)
+SET(ZANATA_OPTION_NAME_VERSION_DEFAULT "master")
+SET(ZANATA_OPTION_NAME_VERSION_VAR_TYPE "STRING")
+
+SET(ZANATA_OPTION_INIT_LIST PROJECT PROJECT_CONFIG SRC_DIR TRANS_DIR TRANS_DIR_PULL URL USER_CONFIG VERSION)
+
+SET(ZANATA_OPTION_ALIAS_YES "BATCH")
+SET(ZANATA_OPTION_ALIAS_CLIENT_COMMAND "ZANATA_EXECUTABLE")
+
+###== Start Option name substitute given sub-command
+### Format: ZANATA_<BACKEND>_<SUBCOMMAND>_OPTION_NAME_<OPTION> <ACTUAL_NAME_IN_SUBCOMMAND>
+###==== Start backend MVN and ZANATA_CLI
+SET(ZANATA_MVN_PUT_PROJECT_OPTION_NAME_PROJECT "PROJECT_SLUG")
+SET(ZANATA_MVN_PUT_PROJECT_OPTION_NAME_PROJECT_TYPE "DEFAULT_PROJECT_TYPE")
+SET(ZANATA_MVN_PUT_VERSION_OPTION_NAME_PROJECT "VERSION_PROJECT")
+SET(ZANATA_MVN_PUT_VERSION_OPTION_NAME_VERSION "VERSION_SLUG")
+SET(ZANATA_MVN_PUSH_OPTION_NAME_VERSION "PROJECT_VERSION")
+SET(ZANATA_MVN_PULL_OPTION_NAME_VERSION "PROJECT_VERSION")
+SET(ZANATA_MVN_PULL_OPTION_NAME_TRANS_DIR_PULL "TRANS_DIR")
+
+###==== Start backend ZANATA
+SET(ZANATA_ZANATA_PULL_OPTION_NAME_TRANS_DIR_PULL "TRANS_DIR")
+###== End Option name substitute given sub-command
+
+SET(ZANATA_MVN_PUT_PROJECT_MANDATORY_OPTIONS "PROJECT" "PROJECT_NAME" "PROJECT_DESC" "PROJECT_TYPE")
+SET(ZANATA_MVN_PUT_VERSION_MANDATORY_OPTIONS "PROJECT" "VERSION")
+SET(ZANATA_MVN_PUSH_MANDATORY_OPTIONS "PROJECT_CONFIG")
+SET(ZANATA_MVN_PULL_MANDATORY_OPTIONS "PROJECT_CONFIG")
+
+SET(ZANATA_JAVA_PUT_PROJECT_MANDATORY_OPTIONS "PROJECT" "PROJECT_NAME" "PROJECT_DESC" "PROJECT_TYPE")
+SET(ZANATA_JAVA_PUT_VERSION_MANDATORY_OPTIONS "PROJECT" "VERSION")
+SET(ZANATA_JAVA_PUSH_MANDATORY_OPTIONS "PROJECT_CONFIG")
+SET(ZANATA_JAVA_PULL_MANDATORY_OPTIONS "PROJECT_CONFIG")
+
+SET(ZANATA_PYTHON_PUT_PROJECT_MANDATORY_OPTIONS "PROJECT" "PROJECT_NAME" "PROJECT_DESC" "PROJECT_TYPE")
+SET(ZANATA_PYTHON_PUT_VERSION_MANDATORY_OPTIONS "PROJECT" "VERSION")
+SET(ZANATA_PYTHON_PUSH_MANDATORY_OPTIONS "PROJECT_CONFIG")
+SET(ZANATA_PYTHON_PULL_MANDATORY_OPTIONS "PROJECT_CONFIG")
+
+SET(ZANATA_CLIENT_COMMON_VALID_OPTIONS "DISABLE_SSL_CERT" "URL" "USERNAME" "KEY" "USER_CONFIG" "PROJECT" "PROJECT_TYPE")
+SET(ZANATA_CLIENT_PROJECT_VALID_OPTIONS "PROJECT_NAME" "PROJECT_DESC")
+SET(ZANATA_CLIENT_VERSION_COMMON_VALID_OPTIONS "VERSION" )
+SET(ZANATA_CLIENT_PUSH_PULL_VALID_OPTIONS "LOCALES" "PROJECT_CONFIG" "SRC_DIR" "TRANS_DIR" )
+SET(ZANATA_CLIENT_PUSH_VALID_OPTIONS "COPY_TRANS" "EXCLUDES" "INCLUDES" )
+SET(ZANATA_CLIENT_PULL_VALID_OPTIONS "CREATE_SKELETONS" "ENCODE_TABS" "TRANS_DIR_PULL")
+SET(MANAGE_ZANATA_VALID_OPTIONS "GENERATE_ZANATA_XML" "CLEAN_ZANATA_XML"
+    "CLIENT_COMMAND"
+    ${ZANATA_CLIENT_GLOBAL_VALID_OPTIONS}
+    ${ZANATA_CLIENT_COMMON_VALID_OPTIONS}
+    ${ZANATA_CLIENT_PROJECT_VALID_OPTIONS}
+    ${ZANATA_CLIENT_VERSION_COMMON_VALID_OPTIONS}
+    ${ZANATA_CLIENT_PUSH_PULL_VALID_OPTIONS}
+    ${ZANATA_CLIENT_PUSH_VALID_OPTIONS}
+    ${ZANATA_CLIENT_PULL_VALID_OPTIONS}
+    )
+
+## Valid subcommand for each client
+SET(ZANATA_SUBCOMMAND_PUT_PROJECT_VALID_OPTIONS
+    ${ZANATA_CLIENT_COMMON_VALID_OPTIONS} ${ZANATA_CLIENT_PROJECT_VALID_OPTIONS}
+    )
+SET(ZANATA_SUBCOMMAND_PUT_VERSION_VALID_OPTIONS
+    ${ZANATA_CLIENT_COMMON_VALID_OPTIONS} ${ZANATA_MVN_PUT_VERSION_MANDATORY_OPTIONS}
+    )
+SET(ZANATA_SUBCOMMAND_PUSH_VALID_OPTIONS
+    ${ZANATA_CLIENT_COMMON_VALID_OPTIONS} ${ZANATA_CLIENT_PUSH_PULL_VALID_OPTIONS}
+    ${ZANATA_CLIENT_PUSH_VALID_OPTIONS}
+    )
+SET(ZANATA_SUBCOMMAND_PULL_VALID_OPTIONS
+    ${ZANATA_CLIENT_COMMON_VALID_OPTIONS} ${ZANATA_CLIENT_PUSH_PULL_VALID_OPTIONS}
+    ${ZANATA_CLIENT_PULL_VALID_OPTIONS}
+    )
+
diff -Nura ibus-chewing-1.6.1/Modules/ManageZanataScript.cmake ibus-chewing-1.6.1_new/Modules/ManageZanataScript.cmake
--- ibus-chewing-1.6.1/Modules/ManageZanataScript.cmake	1970-01-01 08:00:00.000000000 +0800
+++ ibus-chewing-1.6.1_new/Modules/ManageZanataScript.cmake	2015-12-17 17:43:31.000000000 +0800
@@ -0,0 +1,201 @@
+# - Manage Zanata Script
+# Zanata related scripts to be invoked in command line.
+
+MACRO(MANAGE_ZANATA_SCRIPT_PRINT_USAGE)
+    MESSAGE("Manage Zanata script: This script is not recommend for end users
+
+cmake -D cmd=zanata_xml_download
+      -D url=<zanata_server_url>
+      -D project=<project_id>
+      -D version=<version_id>
+      [-D zanata_xml=<zanata.xml>]
+      [-D \"<var>=<value>\"]
+    -P <CmakeModulePath>/ManageZanataScript.cmake
+
+    Download zanata.xml from Zanata Server
+    Options:
+        url: Zanata server URL (e.g. https://translate.zanata.org/zanata/)
+	    This should be indentical to what is written in zanata.ini.
+	project: project ID in Zanata.
+	version: version ID in Zanata.
+	zanata_xml: (Optional) zanata.xml output file. 
+            Default: zanata.xml
+
+cmake -D cmd=zanata_xml_map
+      [-D \"locales=<locale1;locale2...>\"]
+      [-D system_locales=1]
+      [-D po_dir=<po_dir> ]
+      [-D trans_dir=<trans_dir> ]
+      [-D zanata_xml=<zanata.xml>]
+      [-D zanata_xml_in=<zanata.xml>]
+      [-D \"<var>=<value>\"]
+    -P <CmakeModulePath>/ManageZanataScript.cmake
+
+    Map the zanata server locales with client translation files,
+    so it will output correctly.
+    Options:
+        system_locales: use system locales in /usr/share/locale.
+        locales: client-side locales to be mapped.
+	po_dir: (Deprecated) Use trans_dir instead
+	trans_dir: (Optional) Specify base directory of translation files.
+	zanata_xml: (Optional) zanata.xml output file.
+	     Default: zanata.xml
+	zanata_xml_in: (Optional) zanata.xml input file.
+	     Default: zanata.xml
+
+cmake -D cmd=zanata_xml_make
+      -D url=<zanata_server_url>
+      -D project=<project_id>
+      -D version=<version_id>
+      [-D \"locales=<locale1;locale2...>\"]
+      [-D system_locales=1]
+      [-D po_dir=<po_dir> ]
+      [-D trans_dir=<trans_dir> ]
+      [-D zanata_xml=<zanata.xml>]
+      [-D \"<var>=<value>\"]
+    -P <CmakeModulePath>/ManageZanataScript.cmake
+
+    Make a working zanata.xml.
+    Options:
+        url: Zanata server URL (e.g. https://translate.zanata.org/zanata/)
+	    This should be indentical to what is written in zanata.ini.
+	po_dir: (Deprecated) Use trans_dir instead
+	trans_dir: (Optional) Specify base directory of translation files.
+	project: project ID in Zanata.
+	version: version ID in Zanata.
+	system_locales: use system locales in /usr/share/locale.
+	locales: client-side locales to be mapped.
+	zanata_xml: (Optional) zanata.xml output file.
+	     Default: zanata.xml
+	"
+	)
+ENDMACRO(MANAGE_ZANATA_SCRIPT_PRINT_USAGE)
+
+MACRO(ZANATA_XML_DOWNLOAD_CHECK)
+    SET(_requirementMet 1)
+    IF(NOT url)
+	M_MSG("${M_ERROR}" "Requires url")
+	SET(_requirementMet 0)
+    ENDIF()
+    IF(NOT project)
+	M_MSG("${M_ERROR}" "Requires project")
+	SET(_requirementMet 0)
+    ENDIF()
+    IF(NOT version)
+	M_MSG("${M_ERROR}" "Requires version")
+	SET(_requirementMet 0)
+    ENDIF()
+    IF(NOT _requirementMet)
+	RETURN()
+    ENDIF()
+    IF(NOT zanata_xml)
+	SET(zanata_xml "zanata.xml")
+    ENDIF()
+    ZANATA_ZANATA_XML_DOWNLOAD("${zanata_xml}" "${url}" "${project}" "${version}")
+ENDMACRO()
+
+MACRO(ZANATA_XML_MAP_CHECK)
+    SET(_requirementMet 1)
+    IF(NOT zanata_xml_in)
+	SET(zanata_xml_in "zanata.xml")
+    ENDIF()
+
+    IF(NOT EXISTS ${zanata_xml_in})
+	M_MSG("${M_ERROR}" "File not exists: ${zanata_xml_in}")
+	SET(_requirementMet 0)
+    ENDIF()
+
+    IF(NOT zanata_xml)
+	SET(zanata_xml "zanata.xml")
+    ENDIF()
+
+    IF(NOT _requirementMet)
+	RETURN()
+    ENDIF()
+
+    IF(NOT "${po_dir}" STREQUAL "")
+	SET(trans_dir "${po_dir}")
+    ENDIF()
+
+    IF("${trans_dir}" STREQUAL "")
+	SET(trans_dir ".")
+    ENDIF()
+
+    SET(extOptions "")
+    IF("${system_locales}" STREQUAL "1")
+	LIST(APPEND extOptions "SYSTEM_LOCALES")
+    ELSEIF(NOT "${locales}" STREQUAL "")
+	LIST(APPEND extOptions "LOCALES" "${locales}")
+    ENDIF()
+    ZANATA_ZANATA_XML_MAP("${zanata_xml}" "${zanata_xml_in}" "${trans_dir}" ${extOptions})
+ENDMACRO()
+
+FUNCTION(ZANATA_XML_MAKE_CHECK)
+    IF(NOT zanata_xml)
+	SET(zanata_xml "zanata.xml")
+    ENDIF()
+    SET(zanata_xml_in "${zanata_xml}")
+
+    IF(NOT EXISTS "${zanata_xml_in}")
+	ZANATA_XML_DOWNLOAD_CHECK()
+    ENDIF()
+
+    ZANATA_XML_MAP_CHECK()
+ENDFUNCTION()
+
+SET(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS ON)
+
+#######################################
+# Determine CMAKE_FEDORA_MODULE_DIR
+#
+
+## It is possible that current dir is in NO_PACK/FedPkg/<prj>
+LIST(INSERT CMAKE_MODULE_PATH 0
+    ${CMAKE_SOURCE_DIR}/Modules ${CMAKE_SOURCE_DIR}/cmake-fedora/Modules 
+    ${CMAKE_SOURCE_DIR}/../../../Modules
+    ${CMAKE_SOURCE_DIR}/../../../cmake-fedora/Modules
+    ${CMAKE_SOURCE_DIR}
+    )
+
+IF(CMAKE_SCRIPT_MODE_FILE)
+    GET_FILENAME_COMPONENT(CMAKE_FEDORA_SCRIPT_DIR ${CMAKE_SCRIPT_MODE_FILE}
+	PATH)
+    LIST(INSERT CMAKE_MODULE_PATH 0 "${CMAKE_FEDORA_SCRIPT_DIR}")
+ENDIF()
+
+IF(cmake_fedora_module_dir)
+    LIST(INSERT CMAKE_MODULE_PATH 0 "${cmake_fedora_module_dir}")
+ENDIF()
+
+INCLUDE(ManageMessage RESULT_VARIABLE MANAGE_MODULE_PATH)
+IF(NOT MANAGE_MODULE_PATH)
+    MESSAGE(FATAL_ERROR "ManageMessage.cmake cannot be found in ${CMAKE_MODULE_PATH}")
+ENDIF()
+GET_FILENAME_COMPONENT(CMAKE_FEDORA_MODULE_DIR 
+    "${MANAGE_MODULE_PATH}" PATH)
+
+INCLUDE(ManageEnvironmentCommon)
+INCLUDE(ManageString)
+INCLUDE(ManageVariable)
+INCLUDE(ManageVersion)
+INCLUDE(ManageZanata)
+
+IF(NOT DEFINED cmd)
+    MANAGE_ZANATA_SCRIPT_PRINT_USAGE()
+ELSE()
+    IF("${cmd}" STREQUAL "zanata_xml_download")
+	ZANATA_XML_DOWNLOAD_CHECK()
+    ELSEIF("${cmd}" STREQUAL "zanata_xml_map")
+	ZANATA_XML_MAP_CHECK()
+    ELSEIF("${cmd}" STREQUAL "zanata_xml_make")
+	ZANATA_XML_MAKE_CHECK()
+    ELSE()
+	MANAGE_ZANATA_SCRIPT_PRINT_USAGE()
+	M_MSG(${M_FATAL} "Invalid sub-command ${cmd}")
+    ENDIF()
+ENDIF()
+
+
+
+
+
diff -Nura ibus-chewing-1.6.1/Modules/ManageZanataSuggest.cmake ibus-chewing-1.6.1_new/Modules/ManageZanataSuggest.cmake
--- ibus-chewing-1.6.1/Modules/ManageZanataSuggest.cmake	1970-01-01 08:00:00.000000000 +0800
+++ ibus-chewing-1.6.1_new/Modules/ManageZanataSuggest.cmake	2015-12-17 17:43:31.000000000 +0800
@@ -0,0 +1,208 @@
+# Manage the list of suggest country
+# Initial generated on Fedora 20 with:
+# locale -a | grep -e "^[a-z]\+_[A-Z]\+$" | sort -u | sed -e "s/\([a-z]\+\)/SET(ZANATA_SUGGEST_COUNTRY_\1 /g" | sed -e 's/ _\([A-Z]\+\)/ "\1")/'
+
+IF(DEFINED _MANAGE_ZANATA_SUGGEST_)
+    RETURN()
+ENDIF(DEFINED _MANAGE_ZANATA_SUGGEST_)
+SET(_MANAGE_ZANATA_SUGGEST_ "DEFINED")
+
+SET(ZANATA_SUGGEST_COUNTRY_aa__ "ET")
+SET(ZANATA_SUGGEST_COUNTRY_ach__ "UG")
+SET(ZANATA_SUGGEST_COUNTRY_af__ "ZA")
+SET(ZANATA_SUGGEST_COUNTRY_am__ "ET")
+SET(ZANATA_SUGGEST_COUNTRY_aln__ "AL")
+SET(ZANATA_SUGGEST_COUNTRY_an__ "ES")
+SET(ZANATA_SUGGEST_COUNTRY_anp__ "IN")
+SET(ZANATA_SUGGEST_COUNTRY_ar__ "SA")
+SET(ZANATA_SUGGEST_COUNTRY_as__ "IN")
+SET(ZANATA_SUGGEST_COUNTRY_ast__ "ES")
+SET(ZANATA_SUGGEST_COUNTRY_ayc__ "PE")
+SET(ZANATA_SUGGEST_COUNTRY_az__ "AZ")
+SET(ZANATA_SUGGEST_COUNTRY_bal__ "PK")
+SET(ZANATA_SUGGEST_COUNTRY_be__ "BY")
+SET(ZANATA_SUGGEST_COUNTRY_bem__ "ZM")
+SET(ZANATA_SUGGEST_COUNTRY_ber__ "DZ")
+SET(ZANATA_SUGGEST_COUNTRY_bg__ "BG")
+SET(ZANATA_SUGGEST_COUNTRY_bho__ "IN")
+SET(ZANATA_SUGGEST_COUNTRY_bn__ "BD")
+SET(ZANATA_SUGGEST_COUNTRY_bo__ "CN")
+SET(ZANATA_SUGGEST_COUNTRY_br__ "FR")
+SET(ZANATA_SUGGEST_COUNTRY_brx__ "IN")
+SET(ZANATA_SUGGEST_COUNTRY_bs__ "BA")
+SET(ZANATA_SUGGEST_COUNTRY_byn__ "ER")
+SET(ZANATA_SUGGEST_COUNTRY_ca__ "AD")
+SET(ZANATA_SUGGEST_COUNTRY_crh__ "UA")
+SET(ZANATA_SUGGEST_COUNTRY_csb__ "PL")
+SET(ZANATA_SUGGEST_COUNTRY_cs__ "CZ")
+SET(ZANATA_SUGGEST_COUNTRY_cv__ "RU")
+SET(ZANATA_SUGGEST_COUNTRY_cy__ "GB")
+SET(ZANATA_SUGGEST_COUNTRY_da__ "DK")
+SET(ZANATA_SUGGEST_COUNTRY_de__ "DE")
+SET(ZANATA_SUGGEST_COUNTRY_doi__ "IN")
+SET(ZANATA_SUGGEST_COUNTRY_dv__ "MV")
+SET(ZANATA_SUGGEST_COUNTRY_dz__ "BT")
+SET(ZANATA_SUGGEST_COUNTRY_el__ "GR")
+SET(ZANATA_SUGGEST_COUNTRY_en__ "US")
+SET(ZANATA_SUGGEST_COUNTRY_eo__ "")
+SET(ZANATA_SUGGEST_COUNTRY_es__ "ES")
+SET(ZANATA_SUGGEST_COUNTRY_et__ "EE")
+SET(ZANATA_SUGGEST_COUNTRY_eu__ "ES")
+SET(ZANATA_SUGGEST_COUNTRY_fa__ "IR")
+SET(ZANATA_SUGGEST_COUNTRY_ff__ "SN")
+SET(ZANATA_SUGGEST_COUNTRY_fi__ "FI")
+SET(ZANATA_SUGGEST_COUNTRY_fil__ "PH")
+SET(ZANATA_SUGGEST_COUNTRY_fo__ "FO")
+SET(ZANATA_SUGGEST_COUNTRY_fr__ "FR")
+SET(ZANATA_SUGGEST_COUNTRY_fur__ "IT")
+SET(ZANATA_SUGGEST_COUNTRY_fy__ "DE")
+SET(ZANATA_SUGGEST_COUNTRY_ga__ "IE")
+SET(ZANATA_SUGGEST_COUNTRY_gd__ "GB")
+SET(ZANATA_SUGGEST_COUNTRY_gez__ "ER")
+SET(ZANATA_SUGGEST_COUNTRY_gl__ "ES")
+SET(ZANATA_SUGGEST_COUNTRY_gu__ "IN")
+SET(ZANATA_SUGGEST_COUNTRY_gv__ "GB")
+SET(ZANATA_SUGGEST_COUNTRY_ha__ "NG")
+SET(ZANATA_SUGGEST_COUNTRY_he__ "IL")
+SET(ZANATA_SUGGEST_COUNTRY_hi__ "IN")
+SET(ZANATA_SUGGEST_COUNTRY_hne__ "IN")
+SET(ZANATA_SUGGEST_COUNTRY_hr__ "HR")
+SET(ZANATA_SUGGEST_COUNTRY_hsb__ "DE")
+SET(ZANATA_SUGGEST_COUNTRY_ht__ "HT")
+SET(ZANATA_SUGGEST_COUNTRY_hu__ "HU")
+SET(ZANATA_SUGGEST_COUNTRY_hy__ "AM")
+SET(ZANATA_SUGGEST_COUNTRY_ia__ "FR")
+SET(ZANATA_SUGGEST_COUNTRY_id__ "ID")
+SET(ZANATA_SUGGEST_COUNTRY_ig__ "NG")
+SET(ZANATA_SUGGEST_COUNTRY_ilo__ "PH")
+SET(ZANATA_SUGGEST_COUNTRY_ik__ "CA")
+SET(ZANATA_SUGGEST_COUNTRY_is__ "IS")
+SET(ZANATA_SUGGEST_COUNTRY_it__ "IT")
+SET(ZANATA_SUGGEST_COUNTRY_iu__ "CA")
+SET(ZANATA_SUGGEST_COUNTRY_iw__ "IL")
+SET(ZANATA_SUGGEST_COUNTRY_ja__ "JP")
+SET(ZANATA_SUGGEST_COUNTRY_ka__ "GE")
+SET(ZANATA_SUGGEST_COUNTRY_kk__ "KZ")
+SET(ZANATA_SUGGEST_COUNTRY_kl__ "GL")
+SET(ZANATA_SUGGEST_COUNTRY_km__ "KH")
+SET(ZANATA_SUGGEST_COUNTRY_kn__ "IN")
+SET(ZANATA_SUGGEST_COUNTRY_kok__ "IN")
+SET(ZANATA_SUGGEST_COUNTRY_ko__ "KR")
+SET(ZANATA_SUGGEST_COUNTRY_ks__ "IN")
+SET(ZANATA_SUGGEST_COUNTRY_ku__ "TR")
+SET(ZANATA_SUGGEST_COUNTRY_kw__ "GB")
+SET(ZANATA_SUGGEST_COUNTRY_ky__ "KG")
+SET(ZANATA_SUGGEST_COUNTRY_lb__ "LU")
+SET(ZANATA_SUGGEST_COUNTRY_lg__ "UG")
+SET(ZANATA_SUGGEST_COUNTRY_li__ "BE")
+SET(ZANATA_SUGGEST_COUNTRY_lij__ "IT")
+SET(ZANATA_SUGGEST_COUNTRY_li__ "NL")
+SET(ZANATA_SUGGEST_COUNTRY_lo__ "LA")
+SET(ZANATA_SUGGEST_COUNTRY_lt__ "LT")
+SET(ZANATA_SUGGEST_COUNTRY_lv__ "LV")
+SET(ZANATA_SUGGEST_COUNTRY_mag__ "IN")
+SET(ZANATA_SUGGEST_COUNTRY_mai__ "IN")
+SET(ZANATA_SUGGEST_COUNTRY_mg__ "MG")
+SET(ZANATA_SUGGEST_COUNTRY_mhr__ "RU")
+SET(ZANATA_SUGGEST_COUNTRY_mi__ "NZ")
+SET(ZANATA_SUGGEST_COUNTRY_mk__ "MK")
+SET(ZANATA_SUGGEST_COUNTRY_ml__ "IN")
+SET(ZANATA_SUGGEST_COUNTRY_mni__ "IN")
+SET(ZANATA_SUGGEST_COUNTRY_mn__ "MN")
+SET(ZANATA_SUGGEST_COUNTRY_mr__ "IN")
+SET(ZANATA_SUGGEST_COUNTRY_ms__ "MY")
+SET(ZANATA_SUGGEST_COUNTRY_mt__ "MT")
+SET(ZANATA_SUGGEST_COUNTRY_my__ "MM")
+SET(ZANATA_SUGGEST_COUNTRY_nan__ "TW")
+SET(ZANATA_SUGGEST_COUNTRY_nb__ "NO")
+SET(ZANATA_SUGGEST_COUNTRY_nds__ "DE")
+SET(ZANATA_SUGGEST_COUNTRY_ne__ "NP")
+SET(ZANATA_SUGGEST_COUNTRY_nhn__ "MX")
+SET(ZANATA_SUGGEST_COUNTRY_niu__ "NU")
+SET(ZANATA_SUGGEST_COUNTRY_nl__ "NL")
+SET(ZANATA_SUGGEST_COUNTRY_nn__ "NO")
+SET(ZANATA_SUGGEST_COUNTRY_no__ "NO")
+SET(ZANATA_SUGGEST_COUNTRY_nr__ "ZA")
+SET(ZANATA_SUGGEST_COUNTRY_nso__ "ZA")
+SET(ZANATA_SUGGEST_COUNTRY_oc__ "FR")
+SET(ZANATA_SUGGEST_COUNTRY_om__ "ET")
+SET(ZANATA_SUGGEST_COUNTRY_or__ "IN")
+SET(ZANATA_SUGGEST_COUNTRY_os__ "RU")
+SET(ZANATA_SUGGEST_COUNTRY_pa__ "IN")
+SET(ZANATA_SUGGEST_COUNTRY_pap__ "AN")
+SET(ZANATA_SUGGEST_COUNTRY_pl__ "PL")
+SET(ZANATA_SUGGEST_COUNTRY_ps__ "AF")
+SET(ZANATA_SUGGEST_COUNTRY_pt__ "PT")
+SET(ZANATA_SUGGEST_COUNTRY_ro__ "RO")
+SET(ZANATA_SUGGEST_COUNTRY_ru__ "RU")
+SET(ZANATA_SUGGEST_COUNTRY_rw__ "RW")
+SET(ZANATA_SUGGEST_COUNTRY_sa__ "IN")
+SET(ZANATA_SUGGEST_COUNTRY_sat__ "IN")
+SET(ZANATA_SUGGEST_COUNTRY_sc__ "IT")
+SET(ZANATA_SUGGEST_COUNTRY_sd__ "IN")
+SET(ZANATA_SUGGEST_COUNTRY_se__ "NO")
+SET(ZANATA_SUGGEST_COUNTRY_shs__ "CA")
+SET(ZANATA_SUGGEST_COUNTRY_sid__ "ET")
+SET(ZANATA_SUGGEST_COUNTRY_si__ "LK")
+SET(ZANATA_SUGGEST_COUNTRY_sk__ "SK")
+SET(ZANATA_SUGGEST_COUNTRY_sl__ "SI")
+SET(ZANATA_SUGGEST_COUNTRY_so__ "SO")
+SET(ZANATA_SUGGEST_COUNTRY_sq__ "AL")
+SET(ZANATA_SUGGEST_COUNTRY_sq__ "MK")
+SET(ZANATA_SUGGEST_COUNTRY_sr__ "RS")
+SET(ZANATA_SUGGEST_COUNTRY_sr__latin "RS")
+SET(ZANATA_SUGGEST_COUNTRY_sr_Cyrl_ "RS")
+SET(ZANATA_SUGGEST_COUNTRY_sr_Latn_ "RS")
+SET(ZANATA_SUGGEST_COUNTRY_sr_Latn_latin "RS")
+SET(ZANATA_SUGGEST_COUNTRY_ss__ "ZA")
+SET(ZANATA_SUGGEST_COUNTRY_st__ "ZA")
+SET(ZANATA_SUGGEST_COUNTRY_sv__ "SE")
+SET(ZANATA_SUGGEST_COUNTRY_sw__ "TZ")
+SET(ZANATA_SUGGEST_COUNTRY_szl__ "PL")
+SET(ZANATA_SUGGEST_COUNTRY_ta__ "IN")
+SET(ZANATA_SUGGEST_COUNTRY_te__ "IN")
+SET(ZANATA_SUGGEST_COUNTRY_tg__ "TJ")
+SET(ZANATA_SUGGEST_COUNTRY_th__ "TH")
+SET(ZANATA_SUGGEST_COUNTRY_ti__ "ET")
+SET(ZANATA_SUGGEST_COUNTRY_tig__ "ER")
+SET(ZANATA_SUGGEST_COUNTRY_tk__ "TM")
+SET(ZANATA_SUGGEST_COUNTRY_tl__ "PH")
+SET(ZANATA_SUGGEST_COUNTRY_tn__ "ZA")
+SET(ZANATA_SUGGEST_COUNTRY_tr__ "TR")
+SET(ZANATA_SUGGEST_COUNTRY_ts__ "ZA")
+SET(ZANATA_SUGGEST_COUNTRY_tt__ "RU")
+SET(ZANATA_SUGGEST_COUNTRY_ug__ "CN")
+SET(ZANATA_SUGGEST_COUNTRY_uk__ "UA")
+SET(ZANATA_SUGGEST_COUNTRY_unm__ "US")
+SET(ZANATA_SUGGEST_COUNTRY_ur__ "PK")
+SET(ZANATA_SUGGEST_COUNTRY_uz__ "UZ")
+SET(ZANATA_SUGGEST_COUNTRY_ve__ "ZA")
+SET(ZANATA_SUGGEST_COUNTRY_vi__ "VN")
+SET(ZANATA_SUGGEST_COUNTRY_wa__ "BE")
+SET(ZANATA_SUGGEST_COUNTRY_wae__ "CH")
+SET(ZANATA_SUGGEST_COUNTRY_wal__ "ET")
+SET(ZANATA_SUGGEST_COUNTRY_wba__ "VE")
+SET(ZANATA_SUGGEST_COUNTRY_wo__ "SN")
+SET(ZANATA_SUGGEST_COUNTRY_xh__ "ZA")
+SET(ZANATA_SUGGEST_COUNTRY_yi__ "US")
+SET(ZANATA_SUGGEST_COUNTRY_yo__ "NG")
+SET(ZANATA_SUGGEST_COUNTRY_yue__ "HK")
+SET(ZANATA_SUGGEST_COUNTRY_zh__ "CN")
+SET(ZANATA_SUGGEST_COUNTRY_zh_Hans_ "CN")
+SET(ZANATA_SUGGEST_COUNTRY_zh_Hant_ "TW")
+SET(ZANATA_SUGGEST_COUNTRY_zu__ "ZA")
+
+SET(ZANATA_SUGGEST_SCRIPT_sr__ "Cyrl")
+SET(ZANATA_SUGGEST_SCRIPT_sr_RS_ "Cyrl")
+
+SET(ZANATA_SUGGEST_SCRIPT_sr__latin "Latn")
+SET(ZANATA_SUGGEST_SCRIPT_sr_RS_latin "Latn")
+SET(ZANATA_SUGGEST_SCRIPT_zh__ "Hans")
+SET(ZANATA_SUGGEST_SCRIPT_zh_CN_ "Hans")
+SET(ZANATA_SUGGEST_SCRIPT_zh_SG_ "Hans")
+SET(ZANATA_SUGGEST_SCRIPT_zh_TW_ "Hant")
+SET(ZANATA_SUGGEST_SCRIPT_zh_HG_ "Hant")
+SET(ZANATA_SUGGEST_SCRIPT_zh_MO_ "Hant")
+
+SET(ZANATA_SUGGEST_MODIFIER_sr_Latn_ "latin")
+
