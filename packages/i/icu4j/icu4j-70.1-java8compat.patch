--- a/main/classes/charset/src/com/ibm/icu/charset/Charset88591.java	2021-10-28 00:02:09.000000000 -0600
+++ b/main/classes/charset/src/com/ibm/icu/charset/Charset88591.java	2021-10-29 08:08:50.772614012 -0600
@@ -9,6 +9,7 @@
 
 package com.ibm.icu.charset;
 
+import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.nio.CharBuffer;
 import java.nio.charset.CharsetDecoder;
@@ -91,8 +92,8 @@ class Charset88591 extends CharsetASCII
              * early termination of the loop
              */
             if ((ch & 0xff00) != 0) {
-                source.position((i + 1) - source.arrayOffset());
-                target.position(i + offset);
+                ((Buffer)source).position((i + 1) - source.arrayOffset());
+                ((Buffer)target).position(i + offset);
                 return encodeMalformedOrUnmappable(source, ch, flush);
             } else
                 return null;
--- a/main/classes/charset/src/com/ibm/icu/charset/CharsetASCII.java	2021-10-28 00:02:09.000000000 -0600
+++ b/main/classes/charset/src/com/ibm/icu/charset/CharsetASCII.java	2021-10-29 08:08:50.772614012 -0600
@@ -10,6 +10,7 @@
  */
 package com.ibm.icu.charset;
 
+import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.nio.CharBuffer;
 import java.nio.IntBuffer;
@@ -80,12 +81,12 @@ class CharsetASCII extends CharsetICU {
                 cr = decodeLoopCoreOptimized(source, target, sourceArray, targetArray, sourceIndex, offset, limit);
                 if (cr == null) {
                     if (sourceLength <= targetLength) {
-                        source.position(oldSource + sourceLength);
-                        target.position(oldTarget + sourceLength);
+                        ((Buffer)source).position(oldSource + sourceLength);
+                        ((Buffer)target).position(oldTarget + sourceLength);
                         cr = CoderResult.UNDERFLOW;
                     } else {
-                        source.position(oldSource + targetLength);
-                        target.position(oldTarget + targetLength);
+                        ((Buffer)source).position(oldSource + targetLength);
+                        ((Buffer)target).position(oldTarget + targetLength);
                         cr = CoderResult.OVERFLOW;
                     }
                 }
@@ -125,8 +126,8 @@ class CharsetASCII extends CharsetICU {
              * early termination of the loop
              */
             if ((ch & 0x80) != 0) {
-                source.position(i + 1);
-                target.position(i + offset);
+                ((Buffer)source).position(i + 1);
+                ((Buffer)target).position(i + offset);
                 return decodeMalformedOrUnmappable(ch);
             } else
                 return null;
@@ -238,12 +239,12 @@ class CharsetASCII extends CharsetICU {
                     cr = encodeLoopCoreOptimized(source, target, sourceArray, targetArray, sourceIndex, offset, limit, flush);
                     if (cr == null) {
                         if (sourceLength <= targetLength) {
-                            source.position(oldSource + sourceLength);
-                            target.position(oldTarget + sourceLength);
+                            ((Buffer)source).position(oldSource + sourceLength);
+                            ((Buffer)target).position(oldTarget + sourceLength);
                             cr = CoderResult.UNDERFLOW;
                         } else {
-                            source.position(oldSource + targetLength);
-                            target.position(oldTarget + targetLength);
+                            ((Buffer)source).position(oldSource + targetLength);
+                            ((Buffer)target).position(oldTarget + targetLength);
                             cr = CoderResult.OVERFLOW;
                         }
                     }
@@ -286,8 +287,8 @@ class CharsetASCII extends CharsetICU {
              * early termination of the loop
              */
             if ((ch & 0xff80) != 0) {
-                source.position((i + 1) - source.arrayOffset());
-                target.position(i + offset);
+                ((Buffer)source).position((i + 1) - source.arrayOffset());
+                ((Buffer)target).position(i + offset);
                 return encodeMalformedOrUnmappable(source, ch, flush);
             } else
                 return null;
--- a/main/classes/charset/src/com/ibm/icu/charset/CharsetBOCU1.java	2021-10-28 00:02:09.000000000 -0600
+++ b/main/classes/charset/src/com/ibm/icu/charset/CharsetBOCU1.java	2021-10-29 08:08:50.773614012 -0600
@@ -8,6 +8,7 @@
  */
 package com.ibm.icu.charset;
 
+import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.nio.CharBuffer;
 import java.nio.IntBuffer;
@@ -446,7 +447,7 @@ class CharsetBOCU1 extends CharsetICU {
                     if(offsets!=null){
                         offsets.put(nextSourceIndex++);
                     }
-                    source.position(source.position()+1);
+                    ((Buffer)source).position(source.position()+1);
                     --targetCapacity;
                 }else {
                     diff = c-prev;
@@ -456,7 +457,7 @@ class CharsetBOCU1 extends CharsetICU {
                         if(offsets!=null){
                             offsets.put(nextSourceIndex++);
                         }
-                        source.position(source.position()+1);
+                        ((Buffer)source).position(source.position()+1);
                         --targetCapacity;
                     }else {
                         break;
@@ -471,7 +472,7 @@ class CharsetBOCU1 extends CharsetICU {
                 /*test the following code unit*/
                 char trail = source.get(source.position());
                 if(UTF16.isTrailSurrogate(trail)){
-                    source.position(source.position()+1);
+                    ((Buffer)source).position(source.position()+1);
                     ++nextSourceIndex;
                     c=UCharacter.getCodePoint(c, trail);
                 }
@@ -873,7 +874,7 @@ class CharsetBOCU1 extends CharsetICU {
                 } else {
                     break;
                 }
-                source.position(source.position()+1);
+                ((Buffer)source).position(source.position()+1);
                 --count;
             }
             sourceIndex=nextSourceIndex; /* wrong if offsets==NULL but does not matter */
--- a/main/classes/charset/src/com/ibm/icu/charset/CharsetCompoundText.java	2021-10-28 00:02:09.000000000 -0600
+++ b/main/classes/charset/src/com/ibm/icu/charset/CharsetCompoundText.java	2021-10-29 08:08:50.774614012 -0600
@@ -8,6 +8,7 @@
  */
 package com.ibm.icu.charset;
 
+import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.nio.CharBuffer;
 import java.nio.IntBuffer;
@@ -269,7 +270,7 @@ class CharsetCompoundText extends Charse
 
         if (matchFound) {
             state = i;
-            source.position(sourceIndex + (escSeqCompoundText[i].length - offset));
+            ((Buffer)source).position(sourceIndex + (escSeqCompoundText[i].length - offset));
         }
 
         return state;
@@ -371,8 +372,8 @@ class CharsetCompoundText extends Charse
                     }
 
                     targetLength = 0;
-                    tmpTargetBuffer.position(0);
-                    tmpTargetBuffer.limit(3);
+                    ((Buffer)tmpTargetBuffer).position(0);
+                    ((Buffer)tmpTargetBuffer).limit(3);
 
                     /* check if the char is a First surrogate */
                     if (UTF16.isSurrogate(sourceChar) || gotoGetTrail) {
@@ -385,7 +386,7 @@ class CharsetCompoundText extends Charse
                             if (source.hasRemaining()) {
                                 /* test the following code unit */
                                 char trail = source.get();
-                                source.position(source.position()-1);
+                                ((Buffer)source).position(source.position()-1);
                                 if (UTF16.isTrailSurrogate(trail)) {
                                     source.get();
                                     sourceChar = UCharacter.getCodePoint(sourceChar, trail);
@@ -423,18 +424,18 @@ class CharsetCompoundText extends Charse
                             err = gbEncoder[i].cnvMBCSFromUnicodeWithOffsets(CharBuffer.wrap(sourceCharArray), tmpTargetBuffer, offsets, true);
                             if (!err.isError()) {
                                 tmpState = (byte)i;
-                                tmpTargetBuffer.limit(tmpTargetBuffer.position());
+                                ((Buffer)tmpTargetBuffer).limit(tmpTargetBuffer.position());
                                 implReset();
                                 break;
                             }
                         }
                     } else if (tmpState == COMPOUND_TEXT_SINGLE_0) {
                         tmpTargetBuffer.put(0, (byte)sourceChar);
-                        tmpTargetBuffer.limit(1);
+                        ((Buffer)tmpTargetBuffer).limit(1);
                     } else {
                         err = gbEncoder[tmpState].cnvMBCSFromUnicodeWithOffsets(CharBuffer.wrap(sourceCharArray), tmpTargetBuffer, offsets, true);
                         if (!err.isError()) {
-                            tmpTargetBuffer.limit(tmpTargetBuffer.position());
+                            ((Buffer)tmpTargetBuffer).limit(tmpTargetBuffer.position());
                         }
                     }
                     if (err.isError()) {
@@ -568,7 +569,7 @@ class CharsetCompoundText extends Charse
                             }
                         }
                     } else if (source.hasRemaining()) {
-                        source.limit(findNextEsc(source));
+                        ((Buffer)source).limit(findNextEsc(source));
 
                         decoder = gbDecoder[currentState];
 
@@ -591,7 +592,7 @@ class CharsetCompoundText extends Charse
                             }
                         }
 
-                        source.limit(sourceLimit);
+                        ((Buffer)source).limit(sourceLimit);
                     }
 
                     if (err.isError()) {
--- a/main/classes/charset/src/com/ibm/icu/charset/CharsetDecoderICU.java	2021-10-28 00:02:09.000000000 -0600
+++ b/main/classes/charset/src/com/ibm/icu/charset/CharsetDecoderICU.java	2021-10-29 08:08:50.775614013 -0600
@@ -11,6 +11,7 @@
 
 package com.ibm.icu.charset;
 
+import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.nio.CharBuffer;
 import java.nio.IntBuffer;
@@ -248,14 +249,14 @@ public abstract class CharsetDecoderICU
 //            return CoderResult.UNDERFLOW;
 //        }
 
-        in.position(in.position() + toUCountPending());
+        ((Buffer)in).position(in.position() + toUCountPending());
 
         /* do the conversion */
         CoderResult ret = decode(in, out, null, false);
 
         // ok was there input held in the previous invocation of decodeLoop
         // that resulted in output in this invocation?
-        in.position(in.position() - toUCountPending());
+        ((Buffer)in).position(in.position() - toUCountPending());
 
         return ret;
     }
@@ -428,8 +429,8 @@ public abstract class CharsetDecoderICU
             //UConverterUtility.uprv_memcpy(replayArray, replayBegin, preToUArray, preToUBegin, -preToULength);
             replayArray.put(preToUArray,0, -preToULength);
             source=replayArray;
-            source.position(0);
-            source.limit(replayArrayIndex-preToULength);
+            ((Buffer)source).position(0);
+            ((Buffer)source).limit(replayArrayIndex-preToULength);
             flush=false;
             sourceIndex=-1;
             preToULength=0;
@@ -515,10 +516,10 @@ public abstract class CharsetDecoderICU
                         //UConverterUtility.uprv_memcpy(replayArray, replayBegin, preToUArray, preToUBegin, -preToULength);
                         replayArray.put(preToUArray,0, -preToULength);
                         // reset position
-                        replayArray.position(0);
+                        ((Buffer)replayArray).position(0);
 
                         source=replayArray;
-                        source.limit(replayArrayIndex-preToULength);
+                        ((Buffer)source).limit(replayArrayIndex-preToULength);
                         flush=false;
                         if((sourceIndex+=preToULength)<0) {
                             sourceIndex=-1;
--- a/main/classes/charset/src/com/ibm/icu/charset/CharsetEncoderICU.java	2021-10-28 00:02:09.000000000 -0600
+++ b/main/classes/charset/src/com/ibm/icu/charset/CharsetEncoderICU.java	2021-10-29 08:08:50.776614013 -0600
@@ -11,6 +11,7 @@
 
 package com.ibm.icu.charset;
 
+import java.nio.Buffer;
 import java.nio.BufferOverflowException;
 import java.nio.ByteBuffer;
 import java.nio.CharBuffer;
@@ -265,7 +266,7 @@ public abstract class CharsetEncoderICU
             //fromUnicodeReset();
             return CoderResult.UNDERFLOW;
         }
-        in.position(in.position() + fromUCountPending());
+        ((Buffer)in).position(in.position() + fromUCountPending());
         /* do the conversion */
         CoderResult ret = encode(in, out, null, false);
         setSourcePosition(in);
@@ -421,8 +422,8 @@ public abstract class CharsetEncoderICU
             //UConverterUtility.uprv_memcpy(replayArray, replayArrayIndex, preFromUArray, 0, -preFromULength*UMachine.U_SIZEOF_UCHAR);
             replayArray.put(preFromUArray, 0, -preFromULength);
             source = replayArray;
-            source.position(replayArrayIndex);
-            source.limit(replayArrayIndex - preFromULength); //preFromULength is negative, see declaration
+            ((Buffer)source).position(replayArrayIndex);
+            ((Buffer)source).limit(replayArrayIndex - preFromULength); //preFromULength is negative, see declaration
             flush = false;
 
             preFromULength = 0;
@@ -502,8 +503,8 @@ public abstract class CharsetEncoderICU
                         replayArray.put(preFromUArray, 0, -preFromULength);
 
                         source = replayArray;
-                        source.position(replayArrayIndex);
-                        source.limit(replayArrayIndex - preFromULength);
+                        ((Buffer)source).position(replayArrayIndex);
+                        ((Buffer)source).limit(replayArrayIndex - preFromULength);
                         flush = false;
                         if ((sourceIndex += preFromULength) < 0) {
                             sourceIndex = -1;
@@ -760,7 +761,7 @@ public abstract class CharsetEncoderICU
 
         // ok was there input held in the previous invocation of encodeLoop
         // that resulted in output in this invocation?
-        source.position(source.position() - fromUCountPending());
+        ((Buffer)source).position(source.position() - fromUCountPending());
     }
 
     /*
@@ -829,7 +830,7 @@ public abstract class CharsetEncoderICU
             /* start the new target at the first free slot in the error buffer */
             int errBuffLen = encoder.errorBufferLength;
             ByteBuffer newTarget = ByteBuffer.wrap(encoder.errorBuffer);
-            newTarget.position(errBuffLen); /* set the position at the end of the error buffer */
+            ((Buffer)newTarget).position(errBuffLen); /* set the position at the end of the error buffer */
             encoder.errorBufferLength = 0;
 
             encoder.encode(source, newTarget, null, false);
@@ -879,7 +880,7 @@ public abstract class CharsetEncoderICU
 
         if (!UTF16.isTrailSurrogate(trail)) {
             fromUChar32 = lead;
-            source.position(source.position() - 1);
+            ((Buffer)source).position(source.position() - 1);
             return CoderResult.malformedForLength(1);
         }
 
--- a/main/classes/charset/src/com/ibm/icu/charset/CharsetHZ.java	2021-10-28 00:02:09.000000000 -0600
+++ b/main/classes/charset/src/com/ibm/icu/charset/CharsetHZ.java	2021-10-29 08:08:50.777614013 -0600
@@ -8,6 +8,7 @@
  */
 package com.ibm.icu.charset;
 
+import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.nio.CharBuffer;
 import java.nio.IntBuffer;
@@ -125,7 +126,7 @@ class CharsetHZ extends CharsetICU {
                             if (isStateDBCS ? (0x21 <= mySourceChar && mySourceChar <= 0x7e) : mySourceChar <= 0x7f) {
                                 /* The current byte could be the start of a character: Back it out. */
                                 toULength = 1;
-                                source.position(source.position() - 1);
+                                ((Buffer)source).position(source.position() - 1);
                             } else {
                                 /* Include the current byte in the illegal sequence. */
                                 toUBytesArray[1] = (byte)mySourceChar;
@@ -170,7 +171,7 @@ class CharsetHZ extends CharsetICU {
                                 mySourceChar = (leadByte << 8) | mySourceChar;
                             } else if (trailIsOk) {
                                 /* report a single illegal byte and continue with the following DBCS starter byte */
-                                source.position(source.position() - 1);
+                                ((Buffer)source).position(source.position() - 1);
                                 mySourceChar = leadByte;
                             } else {
                                 /* report a pair of illegal bytes if the second byte is not a DBCS starter */
--- a/main/classes/charset/src/com/ibm/icu/charset/CharsetISO2022.java	2021-10-28 00:02:09.000000000 -0600
+++ b/main/classes/charset/src/com/ibm/icu/charset/CharsetISO2022.java	2021-10-29 08:08:50.779614013 -0600
@@ -8,6 +8,7 @@
  */
 package com.ibm.icu.charset;
 
+import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.nio.CharBuffer;
 import java.nio.IntBuffer;
@@ -701,7 +702,7 @@ class CharsetISO2022 extends CharsetICU
                 int bytesFromThisBuffer = decoder.toULength - initialToULength;
                 if (backOutDistance <= bytesFromThisBuffer) {
                     /* same as initialToULength<=1 */
-                    source.position(source.position() - backOutDistance);
+                    ((Buffer)source).position(source.position() - backOutDistance);
                 } else {
                     /* Back out bytes from the previous buffer: Need to replay them. */
                     decoder.preToULength = (byte)(bytesFromThisBuffer - backOutDistance);
@@ -710,7 +711,7 @@ class CharsetISO2022 extends CharsetICU
                     for (int i = 0; i < -(decoder.preToULength); i++) {
                         decoder.preToUArray[i] = decoder.toUBytesArray[i+1];
                     }
-                    source.position(source.position() - bytesFromThisBuffer);
+                    ((Buffer)source).position(source.position() - bytesFromThisBuffer);
                 }
                 decoder.toULength = 1;
             }
@@ -907,7 +908,7 @@ class CharsetISO2022 extends CharsetICU
 
                     case ESC_2022:
                         if (!gotoEscape) {
-                            source.position(source.position() - 1);
+                            ((Buffer)source).position(source.position() - 1);
                         } else {
                             gotoEscape = false;
                         }
@@ -1061,14 +1062,14 @@ class CharsetISO2022 extends CharsetICU
                         /* disassemble the surrogate pair and write to output */
                         targetUniChar -= 0x0010000;
                         target.put((char)(0xd800 + (char)(targetUniChar>>10)));
-                        target.position(target.position()-1);
+                        ((Buffer)target).position(target.position()-1);
                         if (offsets != null) {
                             offsets.put(target.remaining(), source.remaining() - (mySourceChar <= 0xff ? 1 : 2));
                         }
                         target.get();
                         if (target.hasRemaining()) {
                             target.put((char)(0xdc00+(char)(targetUniChar&0x3ff)));
-                            target.position(target.position()-1);
+                            ((Buffer)target).position(target.position()-1);
                             if (offsets != null) {
                                 offsets.put(target.remaining(), source.remaining() - (mySourceChar <= 0xff ? 1 : 2));
                             }
@@ -1167,7 +1168,7 @@ class CharsetISO2022 extends CharsetICU
 
                     case ESC_2022:
                         if (!gotoEscape) {
-                            source.position(source.position()-1);
+                            ((Buffer)source).position(source.position()-1);
                         }
 // escape label
                         gotoEscape = false;
@@ -1239,7 +1240,7 @@ class CharsetISO2022 extends CharsetICU
                                         tempBufLen = 2;
                                     }
                                     ByteBuffer tempBuffer = ByteBuffer.wrap(tempBuf);
-                                    tempBuffer.limit(tempBufLen);
+                                    ((Buffer)tempBuffer).limit(tempBufLen);
                                     targetUniChar = MBCSSimpleGetNextUChar(cnv, tempBuffer, false);
                                     mySourceChar = (mySourceChar << 8) | trailByte;
 
@@ -1366,7 +1367,7 @@ class CharsetISO2022 extends CharsetICU
                         continue;
                     } else if (!gotoGetTrailByte && (gotoEscape || mySourceChar == ESC_2022)) {
                         if (!gotoEscape) {
-                            source.position(source.position()-1);
+                            ((Buffer)source).position(source.position()-1);
                         }
 // escape label
                         gotoEscape = false; // reset gotoEscape flag
@@ -1419,11 +1420,11 @@ class CharsetISO2022 extends CharsetICU
                     } else if (mySourceChar <= 0x7f) {
                         int savedSourceLimit = source.limit();
                         int savedSourcePosition = source.position();
-                        source.limit(source.position());
-                        source.position(source.position()-1);
+                        ((Buffer)source).limit(source.position());
+                        ((Buffer)source).position(source.position()-1);
                         targetUniChar = MBCSSimpleGetNextUChar(myConverterData.currentConverter.sharedData, source, usingFallback);
-                        source.limit(savedSourceLimit);
-                        source.position(savedSourcePosition);
+                        ((Buffer)source).limit(savedSourceLimit);
+                        ((Buffer)source).position(savedSourcePosition);
                     } else {
                         targetUniChar = 0xffff;
                     }
@@ -1468,7 +1469,7 @@ class CharsetISO2022 extends CharsetICU
                     /* Find the end of the buffer e.g : Next Escape Seq | end of Buffer */
                     int oldSourcePos = source.position();
                     sourceLimit = getEndOfBuffer_2022(source);
-                    source.position(oldSourcePos);
+                    ((Buffer)source).position(oldSourcePos);
                     if (source.position() != sourceLimit) {
                         /*
                          * get the current partial byte sequence
@@ -1489,9 +1490,9 @@ class CharsetISO2022 extends CharsetICU
                          */
                         argTarget = target.position();
                         oldSourceLimit = source.limit(); // save the old source limit change to new one
-                        source.limit(sourceLimit);
+                        ((Buffer)source).limit(sourceLimit);
                         err = myConverterData.currentDecoder.cnvMBCSToUnicodeWithOffsets(source, target, offsets, flush);
-                        source.limit(oldSourceLimit); // restore source limit;
+                        ((Buffer)source).limit(oldSourceLimit); // restore source limit;
                         if (offsets != null && sourceStart != argSource) {
                             /* update offsets to base them on the actual start of the input */
                             int delta = argSource - sourceStart;
@@ -1770,7 +1771,7 @@ class CharsetISO2022 extends CharsetICU
                                 /* test the following code unit */
                                 char trail = source.get();
                                 /* go back to the previous position */
-                                source.position(source.position()-1);
+                                ((Buffer)source).position(source.position()-1);
                                 if (UTF16.isTrailSurrogate(trail)) {
                                     source.get();
                                     sourceChar = UCharacter.getCodePoint(sourceChar, trail);
@@ -2277,7 +2278,7 @@ class CharsetISO2022 extends CharsetICU
                             if (source.hasRemaining()) {
                                 /* test the following code unit */
                                 char trail = source.get();
-                                source.position(source.position()-1);
+                                ((Buffer)source).position(source.position()-1);
                                 if (UTF16.isTrailSurrogate(trail)) {
                                     source.get();
                                     sourceChar = UCharacter.getCodePoint(sourceChar, trail);
@@ -2777,7 +2778,7 @@ class CharsetISO2022 extends CharsetICU
                                 if (source.hasRemaining()) {
                                     /* test the following code unit */
                                     char trail = source.get();
-                                    source.position(source.position()-1);
+                                    ((Buffer)source).position(source.position()-1);
                                     if (UTF16.isTrailSurrogate(trail)) {
                                         source.get();
                                          sourceChar = UCharacter.getCodePoint(sourceChar, trail);
--- a/main/classes/charset/src/com/ibm/icu/charset/CharsetLMBCS.java	2021-10-28 00:02:09.000000000 -0600
+++ b/main/classes/charset/src/com/ibm/icu/charset/CharsetLMBCS.java	2021-10-29 08:08:50.780614013 -0600
@@ -8,6 +8,7 @@
  */
 package com.ibm.icu.charset;
 
+import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.nio.CharBuffer;
 import java.nio.IntBuffer;
@@ -597,13 +598,13 @@ class CharsetLMBCS extends CharsetICU {
             oldSourceLimit = source.limit();
             oldSourcePos = source.position();
 
-            source.position(oldSourcePos + positionOffset);
-            source.limit(source.position() + length);
+            ((Buffer)source).position(oldSourcePos + positionOffset);
+            ((Buffer)source).limit(source.position() + length);
 
             uniChar = extraInfo.decoder.simpleGetNextUChar(source, false);
 
-            source.limit(oldSourceLimit);
-            source.position(oldSourcePos);
+            ((Buffer)source).limit(oldSourceLimit);
+            ((Buffer)source).position(oldSourcePos);
 
             return uniChar;
         }
@@ -649,7 +650,7 @@ class CharsetLMBCS extends CharsetICU {
                     /* CHECK_SOURCE_LIMIT(1) */
                     if (source.position() + 1 > source.limit()) {
                         err[0] = CoderResult.OVERFLOW;
-                        source.position(source.limit());
+                        ((Buffer)source).position(source.limit());
                         return 0xFFFF;
                     }
                     C0C1byte = (short)(source.get() & UConverterConstants.UNSIGNED_BYTE_MASK);
@@ -658,7 +659,7 @@ class CharsetLMBCS extends CharsetICU {
                     /* CHECK_SOURCE_LIMIT(2) */
                     if (source.position() + 2 > source.limit()) {
                         err[0] = CoderResult.OVERFLOW;
-                        source.position(source.limit());
+                        ((Buffer)source).position(source.limit());
                         return 0xFFFF;
                     }
 
@@ -673,7 +674,7 @@ class CharsetLMBCS extends CharsetICU {
                         /* CHECK_SOURCE_LIMIT(2) */
                         if (source.position() + 2 > source.limit()) {
                             err[0] = CoderResult.OVERFLOW;
-                            source.position(source.limit());
+                            ((Buffer)source).position(source.limit());
                             return 0xFFFF;
                         }
 
@@ -693,7 +694,7 @@ class CharsetLMBCS extends CharsetICU {
                         /* CHECK_SOURCE_LIMIT(1) */
                         if (source.position() + 1 > source.limit()) {
                             err[0] = CoderResult.OVERFLOW;
-                            source.position(source.limit());
+                            ((Buffer)source).position(source.limit());
                             return 0xFFFF;
                         }
                         CurByte = (short)(source.get() & UConverterConstants.UNSIGNED_BYTE_MASK);
@@ -724,7 +725,7 @@ class CharsetLMBCS extends CharsetICU {
                             /* CHECK_SOURCE_LIMIT(0) */
                             if (source.position() + 0 > source.limit()) {
                                 err[0] = CoderResult.OVERFLOW;
-                                source.position(source.limit());
+                                ((Buffer)source).position(source.limit());
                                 return 0xFFFF;
                             }
 
@@ -734,7 +735,7 @@ class CharsetLMBCS extends CharsetICU {
                             /* CHECK_SOURCE_LIMIT(1) */
                             if (source.position() + 1 > source.limit()) {
                                 err[0] = CoderResult.OVERFLOW;
-                                source.position(source.limit());
+                                ((Buffer)source).position(source.limit());
                                 return 0xFFFF;
                             }
 
@@ -781,9 +782,9 @@ class CharsetLMBCS extends CharsetICU {
                         }
                     }
                     tmpSourceBuffer = ByteBuffer.wrap(LMBCS);
-                    tmpSourceBuffer.limit(savebytes);
+                    ((Buffer)tmpSourceBuffer).limit(savebytes);
                     uniChar = (char)LMBCSGetNextUCharWorker(tmpSourceBuffer, err);
-                    source.position(saveSource + tmpSourceBuffer.position() - size_old);
+                    ((Buffer)source).position(saveSource + tmpSourceBuffer.position() - size_old);
                     errSource = saveSource - size_old;
 
                     if (err[0].isOverflow()) { /* err == U_TRUNCATED_CHAR_FOUND */
@@ -792,7 +793,7 @@ class CharsetLMBCS extends CharsetICU {
                         for (int i = 0; i < savebytes; i++) {
                             toUBytesArray[i] = LMBCS[i];
                         }
-                        source.position(source.limit());
+                        ((Buffer)source).position(source.limit());
                         err[0] = CoderResult.UNDERFLOW;
                         return err[0];
                     } else {
--- a/main/classes/charset/src/com/ibm/icu/charset/CharsetMBCS.java	2021-10-28 00:02:09.000000000 -0600
+++ b/main/classes/charset/src/com/ibm/icu/charset/CharsetMBCS.java	2021-10-29 08:08:50.783614013 -0600
@@ -1458,7 +1458,7 @@ class CharsetMBCS extends CharsetICU {
         // TODO: It is very inefficient to create Buffer objects for each array access.
         // We should create an inner class Extensions (or sibling class CharsetMBCSExtensions)
         // which has buffers for the arrays, together with the code that works with them.
-        indexes.position(indexes.getInt(index << 2));
+        ((Buffer)indexes).position(indexes.getInt(index << 2));
         if (itemType == int.class)
             b = indexes.asIntBuffer();
         else if (itemType == char.class)
@@ -1468,12 +1468,12 @@ class CharsetMBCS extends CharsetICU {
         else
             // default or (itemType == byte.class)
             b = indexes.slice();
-        indexes.position(oldpos);
+        ((Buffer)indexes).position(oldpos);
         return b;
     }
 
     private static int GET_MAX_BYTES_PER_UCHAR(ByteBuffer indexes) {
-        indexes.position(0);
+        ((Buffer)indexes).position(0);
         return indexes.getInt(EXT_COUNT_BYTES) & 0xff;
     }
 
@@ -1649,7 +1649,7 @@ class CharsetMBCS extends CharsetICU {
             if (match > 0) {
                 if (match >= preToULength) {
                     /* advance src pointer for the consumed input */
-                    source.position(source.position() + match - preToULength);
+                    ((Buffer)source).position(source.position() + match - preToULength);
                     preToULength = 0;
                 } else {
                     /* the match did not use all of preToU[] - keep the rest for replay */
@@ -1670,7 +1670,7 @@ class CharsetMBCS extends CharsetICU {
                 for (j = preToULength; j < match; ++j) {
                     preToUArray[j] = source.get(sArrayIndex++);
                 }
-                source.position(sArrayIndex); /* same as *src=srcLimit; because we reached the end of input */
+                ((Buffer)source).position(sArrayIndex); /* same as *src=srcLimit; because we reached the end of input */
                 preToULength = (byte) match;
             } else /* match==0 */{
                 /*
@@ -1753,7 +1753,7 @@ class CharsetMBCS extends CharsetICU {
             for (;;) {
                 /* go to the next section */
                 int oldpos = toUTable.position();
-                toUSection = ((IntBuffer) toUTable.position(index)).slice();
+                toUSection = toUTable.position(index).slice();
                 toUTable.position(oldpos);
 
                 /* read first pair of the section */
@@ -1829,7 +1829,7 @@ class CharsetMBCS extends CharsetICU {
 
                 char[] a = new char[TO_U_GET_LENGTH(value)];
                 CharBuffer cb = ((CharBuffer) ARRAY(cx, EXT_TO_U_UCHARS_INDEX, char.class));
-                cb.position(TO_U_GET_INDEX(value));
+                ((Buffer)cb).position(TO_U_GET_INDEX(value));
                 cb.get(a, 0, a.length);
                 return toUWriteUChars(this, a, 0, a.length, target, offsets, srcIndex);
             }
@@ -1925,7 +1925,7 @@ class CharsetMBCS extends CharsetICU {
                     value, isToUUseFallback(), flush);
             if (match > 0) {
                 /* advance src pointer for the consumed input */
-                source.position(source.position() + match - firstLength);
+                ((Buffer)source).position(source.position() + match - firstLength);
 
                 /* write result to target */
                 cr[0] = writeToU(value[0], target, offsets, srcIndex);
@@ -1950,7 +1950,7 @@ class CharsetMBCS extends CharsetICU {
                 for (; j < match; ++j) {
                     preToUArray[j] = source.get(sArrayIndex++);
                 }
-                source.position(sArrayIndex);
+                ((Buffer)source).position(sArrayIndex);
                 preToULength = (byte) match;
                 return true;
             } else /* match==0 no match */{
@@ -2330,7 +2330,7 @@ class CharsetMBCS extends CharsetICU {
                 } else /* unassigned sequences indicated with byteIndex>0 */{
                     /* try an extension mapping */
                     int sourceBeginIndex = sourceArrayIndex;
-                    source.position(sourceArrayIndex);
+                    ((Buffer)source).position(sourceArrayIndex);
                     byteIndex = toU(byteIndex, source, target, offsets, sourceIndex, flush, cr);
                     sourceArrayIndex = source.position();
                     sourceIndex = nextSourceIndex += (sourceArrayIndex - sourceBeginIndex);
@@ -2348,7 +2348,7 @@ class CharsetMBCS extends CharsetICU {
             toULength = byteIndex;
 
             /* write back the updated pointers */
-            source.position(sourceArrayIndex);
+            ((Buffer)source).position(sourceArrayIndex);
 
             return cr[0];
         }
@@ -2446,7 +2446,7 @@ class CharsetMBCS extends CharsetICU {
                     /* try an extension mapping */
                     lastSource = sourceArrayIndex;
                     toUBytesArray[0] = source.get(sourceArrayIndex - 1);
-                    source.position(sourceArrayIndex);
+                    ((Buffer)source).position(sourceArrayIndex);
                     toULength = toU((byte) 1, source, target, offsets, sourceIndex, flush, cr);
                     sourceArrayIndex = source.position();
                     sourceIndex += 1 + (sourceArrayIndex - lastSource);
@@ -2480,7 +2480,7 @@ class CharsetMBCS extends CharsetICU {
             }
 
             /* write back the updated pointers */
-            source.position(sourceArrayIndex);
+            ((Buffer)source).position(sourceArrayIndex);
 
             return cr[0];
         }
@@ -2600,7 +2600,7 @@ class CharsetMBCS extends CharsetICU {
                     /* try an extension mapping */
                     int sourceBeginIndex = sourceArrayIndex;
                     toUBytesArray[0] = source.get(sourceArrayIndex - 1);
-                    source.position(sourceArrayIndex);
+                    ((Buffer)source).position(sourceArrayIndex);
                     toULength = toU((byte) 1, source, target, offsets, sourceIndex, flush, cr);
                     sourceArrayIndex = source.position();
                     sourceIndex += 1 + (sourceArrayIndex - sourceBeginIndex);
@@ -2613,7 +2613,7 @@ class CharsetMBCS extends CharsetICU {
             }
 
             /* write back the updated pointers */
-            source.position(sourceArrayIndex);
+            ((Buffer)source).position(sourceArrayIndex);
 
             return cr[0];
         }
@@ -2772,7 +2772,7 @@ class CharsetMBCS extends CharsetICU {
                 if (sharedData.mbcs.extIndexes != null) {
                     /* Increase the limit for proper handling. Used in LMBCS. */
                     if (source.limit() > i + length) {
-                        source.limit(i + length);
+                        ((Buffer)source).limit(i + length);
                     }
                     return simpleMatchToU(source, useFallback);
                 }
@@ -3358,7 +3358,7 @@ class CharsetMBCS extends CharsetICU {
                 fromUChar32 = c;
                 fromUnicodeStatus = prevLength;
 
-                source.position(sourceArrayIndex);
+                ((Buffer)source).position(sourceArrayIndex);
             } catch (BufferOverflowException ex) {
                 cr[0] = CoderResult.OVERFLOW;
             }
@@ -3533,7 +3533,7 @@ class CharsetMBCS extends CharsetICU {
 
                 if (match >= preFromULength) {
                     /* advance src pointer for the consumed input */
-                    source.position(source.position() + match - preFromULength);
+                    ((Buffer)source).position(source.position() + match - preFromULength);
                     preFromULength = 0;
                 } else {
                     /* the match did not use all of preFromU[] - keep the rest for replay */
@@ -3558,7 +3558,7 @@ class CharsetMBCS extends CharsetICU {
                 for (j = preFromULength; j < match; ++j) {
                     preFromUArray[j] = source.get(sArrayIndex++);
                 }
-                source.position(sArrayIndex); /* same as *src=srcLimit; because we reached the end of input */
+                ((Buffer)source).position(sArrayIndex); /* same as *src=srcLimit; because we reached the end of input */
                 preFromULength = (byte) match;
             } else { /* match==0 or 1 */
                 /*
@@ -3672,10 +3672,10 @@ class CharsetMBCS extends CharsetICU {
                 for (;;) {
                     /* go to the next section */
                     int oldpos = fromUTableUChars.position();
-                    fromUSectionUChars = ((CharBuffer) fromUTableUChars.position(index)).slice();
-                    fromUTableUChars.position(oldpos);
+                    fromUSectionUChars = ((CharBuffer) ((Buffer)fromUTableUChars).position(index)).slice();
+                    ((Buffer)fromUTableUChars).position(oldpos);
                     oldpos = fromUTableValues.position();
-                    fromUSectionValues = ((IntBuffer) fromUTableValues.position(index)).slice();
+                    fromUSectionValues = fromUTableValues.position(index).slice();
                     fromUTableValues.position(oldpos);
 
                     /* read first pair of the section */
@@ -3835,7 +3835,7 @@ class CharsetMBCS extends CharsetICU {
                 byte[] slice = new byte[length];
 
                 ByteBuffer bb = ((ByteBuffer) ARRAY(cx, EXT_FROM_U_BYTES_INDEX, byte.class));
-                bb.position(value);
+                ((Buffer)bb).position(value);
                 bb.get(slice, 0, slice.length);
 
                 resultArray = slice;
@@ -3943,7 +3943,7 @@ class CharsetMBCS extends CharsetICU {
             if (match >= 2
                     && !(FROM_U_GET_LENGTH(value[0]) == 1 && sharedData.mbcs.outputType == MBCS_OUTPUT_DBCS_ONLY)) {
                 /* advance src pointer for the consumed input */
-                source.position(source.position() + match - 2); /* remove 2 for the initial code point */
+                ((Buffer)source).position(source.position() + match - 2); /* remove 2 for the initial code point */
 
                 /* write result to target */
                 cr[0] = writeFromU(value[0], target, offsets, srcIndex);
@@ -3962,7 +3962,7 @@ class CharsetMBCS extends CharsetICU {
                 for (j = 0; j < match; ++j) {
                     preFromUArray[j] = source.get(sArrayIndex++);
                 }
-                source.position(sArrayIndex); /* same as *src=srcLimit; because we reached the end of input */
+                ((Buffer)source).position(sArrayIndex); /* same as *src=srcLimit; because we reached the end of input */
                 preFromULength = (byte) match;
                 return true;
             } else if (match == 1) {
@@ -4102,7 +4102,7 @@ class CharsetMBCS extends CharsetICU {
 
                     /* try an extension mapping */
                     lastSource = sourceArrayIndex;
-                    source.position(sourceArrayIndex);
+                    ((Buffer)source).position(sourceArrayIndex);
                     c = fromU(c, source, target, offsets, sourceIndex, length, flush, cr);
                     sourceArrayIndex = source.position();
                     sourceIndex += length + (sourceArrayIndex - lastSource);
@@ -4142,7 +4142,7 @@ class CharsetMBCS extends CharsetICU {
             fromUChar32 = c;
 
             /* write back the updated pointers */
-            source.position(sourceArrayIndex);
+            ((Buffer)source).position(sourceArrayIndex);
 
             return cr[0];
         }
@@ -4292,7 +4292,7 @@ class CharsetMBCS extends CharsetICU {
             fromUChar32 = c;
 
             /* write back the updated pointers */
-            source.position(sourceArrayIndex);
+            ((Buffer)source).position(sourceArrayIndex);
 
             return cr[0];
         }
@@ -4482,7 +4482,7 @@ class CharsetMBCS extends CharsetICU {
             fromUChar32 = c;
 
             /* write back the updated pointers */
-            source.position(sourceArrayIndex);
+            ((Buffer)source).position(sourceArrayIndex);
 
             return cr[0];
         }
@@ -4576,7 +4576,7 @@ class CharsetMBCS extends CharsetICU {
                 boolean flush, CoderResult[] cr) {
             /* try an extension mapping */
             int sourceBegin = x.sourceArrayIndex;
-            source.position(x.sourceArrayIndex);
+            ((Buffer)source).position(x.sourceArrayIndex);
             x.c = fromU(x.c, source, target, null, x.sourceIndex, x.nextSourceIndex, flush, cr);
             x.sourceArrayIndex = source.position();
             x.nextSourceIndex += x.sourceArrayIndex - sourceBegin;
@@ -4649,7 +4649,7 @@ class CharsetMBCS extends CharsetICU {
                 boolean flush, CoderResult[] cr) {
             /* try an extension mapping */
             int sourceBegin = x.sourceArrayIndex;
-            source.position(x.sourceArrayIndex);
+            ((Buffer)source).position(x.sourceArrayIndex);
             x.c = fromU(x.c, source, target, null, x.sourceIndex, x.nextSourceIndex, flush, cr);
             x.sourceArrayIndex = source.position();
             x.nextSourceIndex += x.sourceArrayIndex - sourceBegin;
--- a/main/classes/charset/src/com/ibm/icu/charset/CharsetSCSU.java	2021-10-28 00:02:09.000000000 -0600
+++ b/main/classes/charset/src/com/ibm/icu/charset/CharsetSCSU.java	2021-10-29 08:08:50.784614013 -0600
@@ -8,6 +8,7 @@
  */
 package com.ibm.icu.charset;
 
+import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.nio.CharBuffer;
 import java.nio.IntBuffer;
@@ -293,7 +294,7 @@ class CharsetSCSU extends CharsetICU{
 
                 if(state==readCommand){
                     while(source.hasRemaining() && target.hasRemaining() && (b=(short)(source.get(source.position()) & UConverterConstants.UNSIGNED_BYTE_MASK)) >= 0x20){
-                        source.position(source.position()+1);
+                        ((Buffer)source).position(source.position()+1);
                         ++nextSourceIndex;
                         if(b <= 0x7f){
                             /*Write US graphic character or DEL*/
--- a/main/classes/charset/src/com/ibm/icu/charset/CharsetUTF16.java	2021-10-28 00:02:09.000000000 -0600
+++ b/main/classes/charset/src/com/ibm/icu/charset/CharsetUTF16.java	2021-10-29 08:08:50.785614013 -0600
@@ -8,6 +8,7 @@
  */
 package com.ibm.icu.charset;
 
+import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.nio.CharBuffer;
 import java.nio.IntBuffer;
@@ -212,7 +213,7 @@ class CharsetUTF16 extends CharsetICU {
             if (!UTF16.isTrailSurrogate(trail)) {
                 // pretend like we didn't read the last 2 bytes
                 toULength = 2;
-                source.position(source.position() - 2);
+                ((Buffer)source).position(source.position() - 2);
 
                 // 2 bytes, lead malformed
                 toUnicodeStatus = 0;
--- a/main/classes/charset/src/com/ibm/icu/charset/CharsetUTF7.java	2021-10-28 00:02:09.000000000 -0600
+++ b/main/classes/charset/src/com/ibm/icu/charset/CharsetUTF7.java	2021-10-29 08:08:50.785614013 -0600
@@ -8,6 +8,7 @@
  */
 package com.ibm.icu.charset;
 
+import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.nio.CharBuffer;
 import java.nio.IntBuffer;
@@ -302,7 +303,7 @@ class CharsetUTF7 extends CharsetICU {
                                 if(base64Counter==-1) {
                                     /* illegal: + immediately followed by something other than base64 or minus sign */
                                     /* include the plus sign in the reported sequence, but not the subsequent char */
-                                    source.position(source.position() -1);
+                                    ((Buffer)source).position(source.position() -1);
                                     toUBytesArray[0]=PLUS;
                                     byteIndex=1;
                                     cr=CoderResult.malformedForLength(sourceArrayIndex);
@@ -310,7 +311,7 @@ class CharsetUTF7 extends CharsetICU {
                                 } else if(bits!=0) {
                                     /* bits are illegally left over, a UChar is incomplete */
                                     /* don't include current char (legal or illegal) in error seq */
-                                    source.position(source.position() -1);
+                                    ((Buffer)source).position(source.position() -1);
                                     --byteIndex;
                                     cr=CoderResult.malformedForLength(sourceArrayIndex);
                                     break directMode;
@@ -322,7 +323,7 @@ class CharsetUTF7 extends CharsetICU {
                                         break directMode;
                                     } else {
                                         /* un-read the current character in case it is a plus sign */
-                                        source.position(source.position() -1);
+                                        ((Buffer)source).position(source.position() -1);
                                         sourceIndex=nextSourceIndex-1;
                                         continue directMode;
                                     }
@@ -555,7 +556,7 @@ class CharsetUTF7 extends CharsetICU {
                         }
                     } else {
                         /* un-read this character and switch to unicode mode */
-                        source.position(source.position() - 1);
+                        ((Buffer)source).position(source.position() - 1);
                         target.put(useIMAP ? AMPERSAND : PLUS);
                         if (offsets != null) {
                             offsets.put(sourceIndex);
@@ -581,7 +582,7 @@ class CharsetUTF7 extends CharsetICU {
                             inDirectMode=1;
 
                             /* trick: back out this character to make this easier */
-                            source.position(source.position() - 1);
+                            ((Buffer)source).position(source.position() - 1);
 
                             /* terminate the base64 sequence */
                             if (base64Counter!=0) {
--- a/main/classes/charset/src/com/ibm/icu/charset/CharsetUTF8.java	2021-10-28 00:02:09.000000000 -0600
+++ b/main/classes/charset/src/com/ibm/icu/charset/CharsetUTF8.java	2021-10-29 08:08:50.786614013 -0600
@@ -11,6 +11,7 @@
 
 package com.ibm.icu.charset;
 
+import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.nio.CharBuffer;
 import java.nio.IntBuffer;
@@ -359,8 +360,8 @@ class CharsetUTF8 extends CharsetICU {
                     srcIdx = sourceIndex;
                     tgtIdx = targetIndex;
                     if (cr != null) {
-                        source.position(srcIdx - source.arrayOffset());
-                        target.position(tgtIdx - target.arrayOffset());
+                        ((Buffer)source).position(srcIdx - source.arrayOffset());
+                        ((Buffer)target).position(tgtIdx - target.arrayOffset());
                         return cr;
                     }
                 }
@@ -432,8 +433,8 @@ class CharsetUTF8 extends CharsetICU {
                 }
 
                 /* set the new source and target positions and return the CoderResult stored in cr */
-                source.position(srcIdx - source.arrayOffset());
-                target.position(tgtIdx - target.arrayOffset());
+                ((Buffer)source).position(srcIdx - source.arrayOffset());
+                ((Buffer)target).position(tgtIdx - target.arrayOffset());
                 return cr;
 
             } else {
--- a/main/classes/charset/src/com/ibm/icu/charset/UConverterDataReader.java	2021-10-28 00:02:09.000000000 -0600
+++ b/main/classes/charset/src/com/ibm/icu/charset/UConverterDataReader.java	2021-10-29 08:08:50.787614013 -0600
@@ -10,6 +10,7 @@
 package com.ibm.icu.charset;
 
 import java.io.IOException;
+import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.nio.CharBuffer;
 import java.nio.IntBuffer;
@@ -595,7 +596,7 @@ final class UConverterDataReader {
             throw new InvalidFormatException();
         }
         int numBytesExtensionStructure = b.getInt(31 * 4);
-        b.limit(numBytesExtensionStructure);
+        ((Buffer)b).limit(numBytesExtensionStructure);
         ICUBinary.skipBytes(byteBuffer, numBytesExtensionStructure);
         return b;
     }
--- a/main/classes/core/src/com/ibm/icu/impl/ICUBinary.java	2021-10-28 00:02:09.000000000 -0600
+++ b/main/classes/core/src/com/ibm/icu/impl/ICUBinary.java	2021-10-29 08:08:50.788614013 -0600
@@ -15,6 +15,7 @@ import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
+import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.nio.channels.FileChannel;
@@ -94,8 +95,8 @@ public final class ICUBinary {
             int index = binarySearch(bytes, key);
             if (index >= 0) {
                 ByteBuffer data = bytes.duplicate();
-                data.position(getDataOffset(bytes, index));
-                data.limit(getDataOffset(bytes, index + 1));
+                ((Buffer)data).position(getDataOffset(bytes, index));
+                ((Buffer)data).limit(getDataOffset(bytes, index + 1));
                 return ICUBinary.sliceWithOrder(data);
             } else {
                 return null;
@@ -609,7 +610,7 @@ public final class ICUBinary {
                             formatVersion[2] & 0xff, formatVersion[3] & 0xff));
         }
 
-        bytes.position(headerSize);
+        ((Buffer)bytes).position(headerSize);
         return  // dataVersion
                 (bytes.get(20) << 24) |
                 ((bytes.get(21) & 0xff) << 16) |
@@ -648,7 +649,7 @@ public final class ICUBinary {
 
     public static void skipBytes(ByteBuffer bytes, int skipLength) {
         if (skipLength > 0) {
-            bytes.position(bytes.position() + skipLength);
+            ((Buffer)bytes).position(bytes.position() + skipLength);
         }
     }
 
--- a/main/classes/core/src/com/ibm/icu/impl/ICUResourceBundleReader.java	2021-10-28 00:02:09.000000000 -0600
+++ b/main/classes/core/src/com/ibm/icu/impl/ICUResourceBundleReader.java	2021-10-29 08:08:50.789614013 -0600
@@ -11,6 +11,7 @@ package com.ibm.icu.impl;
 import java.io.IOException;
 import java.io.InputStream;
 import java.lang.ref.SoftReference;
+import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.nio.CharBuffer;
 import java.nio.IntBuffer;
@@ -294,7 +295,7 @@ public final class ICUResourceBundleRead
                 // unlike regular bundles' key strings for which indexes
                 // are based on the start of the bundle data.
                 keyBytes = new byte[(keysTop - keysBottom) << 2];
-                bytes.position(keysBottom << 2);
+                ((Buffer)bytes).position(keysBottom << 2);
             } else {
                 localKeyLimit = keysTop << 2;
                 keyBytes = new byte[localKeyLimit];
@@ -307,9 +308,9 @@ public final class ICUResourceBundleRead
             int _16BitTop = getIndexesInt(URES_INDEX_16BIT_TOP);
             if(_16BitTop > keysTop) {
                 int num16BitUnits = (_16BitTop - keysTop) * 2;
-                bytes.position(keysTop << 2);
+                ((Buffer)bytes).position(keysTop << 2);
                 b16BitUnits = bytes.asCharBuffer();
-                b16BitUnits.limit(num16BitUnits);
+                ((Buffer)b16BitUnits).limit(num16BitUnits);
                 maxOffset |= num16BitUnits - 1;
             } else {
                 b16BitUnits = EMPTY_16_BIT_UNITS;
@@ -327,7 +328,7 @@ public final class ICUResourceBundleRead
         }
 
         // Reset the position for future .asCharBuffer() etc.
-        bytes.position(0);
+        ((Buffer)bytes).position(0);
     }
 
     private int getIndexesInt(int i) {
@@ -387,7 +388,7 @@ public final class ICUResourceBundleRead
             }
         } else {
             CharBuffer temp = bytes.asCharBuffer();
-            temp.position(offset / 2);
+            ((Buffer)temp).position(offset / 2);
             temp.get(chars);
         }
         return chars;
@@ -403,7 +404,7 @@ public final class ICUResourceBundleRead
             }
         } else {
             IntBuffer temp = bytes.asIntBuffer();
-            temp.position(offset / 4);
+            ((Buffer)temp).position(offset / 4);
             temp.get(ints);
         }
         return ints;
@@ -418,7 +419,7 @@ public final class ICUResourceBundleRead
                 }
             } else {
                 CharBuffer temp = b16BitUnits.duplicate();
-                temp.position(offset);
+                ((Buffer)temp).position(offset);
                 temp.get(result);
             }
             return result;
@@ -665,7 +666,7 @@ public final class ICUResourceBundleRead
                     }
                 } else {
                     ByteBuffer temp = bytes.duplicate();
-                    temp.position(offset);
+                    ((Buffer)temp).position(offset);
                     temp.get(ba);
                 }
                 return ba;
@@ -696,7 +697,7 @@ public final class ICUResourceBundleRead
                 }
                 offset += 4;
                 ByteBuffer result = bytes.duplicate();
-                result.position(offset).limit(offset + length);
+                ((Buffer)result).position(offset).limit(offset + length);
                 result = ICUBinary.sliceWithOrder(result);
                 if(!result.isReadOnly()) {
                     result = result.asReadOnlyBuffer();
--- a/main/classes/core/src/com/ibm/icu/impl/RBBIDataWrapper.java	2021-10-28 00:02:09.000000000 -0600
+++ b/main/classes/core/src/com/ibm/icu/impl/RBBIDataWrapper.java	2021-10-29 08:08:50.790614013 -0600
@@ -11,6 +11,7 @@ package com.ibm.icu.impl;
 
 import java.io.DataOutputStream;
 import java.io.IOException;
+import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.nio.charset.StandardCharsets;
 import java.util.Arrays;
@@ -361,7 +362,7 @@ public final class RBBIDataWrapper {
         ICUBinary.skipBytes(bytes, This.fHeader.fTrie - pos);  // seek buffer from end of
         pos = This.fHeader.fTrie;               // previous section to the start of the trie
 
-        bytes.mark();                           // Mark position of start of TRIE in the input
+        ((Buffer)bytes).mark();                 // Mark position of start of TRIE in the input
                                                 //  and tell Java to keep the mark valid so long
                                                 //  as we don't go more than 100 bytes past the
                                                 //  past the end of the TRIE.
@@ -373,7 +374,7 @@ public final class RBBIDataWrapper {
                                                 //  at an unknown position, preceding the
                                                 //  padding between TRIE and following section.
 
-        bytes.reset();                          // Move buffer back to marked position at
+        ((Buffer)bytes).reset();                // Move buffer back to marked position at
                                                 //   the start of the serialized TRIE.  Now our
                                                 //   "pos" variable and the buffer are in
                                                 //   agreement.
--- a/main/classes/core/src/com/ibm/icu/text/SpoofChecker.java	2021-10-28 00:02:09.000000000 -0600
+++ b/main/classes/core/src/com/ibm/icu/text/SpoofChecker.java	2021-10-29 08:08:50.791614013 -0600
@@ -14,6 +14,7 @@ package com.ibm.icu.text;
 import java.io.IOException;
 import java.io.LineNumberReader;
 import java.io.Reader;
+import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.text.ParseException;
 import java.util.ArrayList;
@@ -1877,7 +1878,7 @@ public class SpoofChecker {
         // A ByteBuffer is what the ICU internal data loading functions provide.
         private SpoofData(ByteBuffer bytes) throws java.io.IOException {
             ICUBinary.readHeader(bytes, DATA_FORMAT, IS_ACCEPTABLE);
-            bytes.mark();
+            ((Buffer)bytes).mark();
             readData(bytes);
         }
 
@@ -1930,15 +1931,15 @@ public class SpoofChecker {
             // of the data items. Now read each in turn, first seeking the
             // input stream to the position of the data item.
 
-            bytes.reset();
+            ((Buffer)bytes).reset();
             ICUBinary.skipBytes(bytes, CFUKeysOffset);
             fCFUKeys = ICUBinary.getInts(bytes, CFUKeysSize, 0);
 
-            bytes.reset();
+            ((Buffer)bytes).reset();
             ICUBinary.skipBytes(bytes, CFUValuesOffset);
             fCFUValues = ICUBinary.getShorts(bytes, CFUValuesSize, 0);
 
-            bytes.reset();
+            ((Buffer)bytes).reset();
             ICUBinary.skipBytes(bytes, CFUStringTableOffset);
             fCFUStrings = ICUBinary.getString(bytes, CFUStringTableSize, 0);
         }
--- a/main/tests/charset/src/com/ibm/icu/dev/test/charset/TestCharset.java	2021-10-28 00:02:09.000000000 -0600
+++ b/main/tests/charset/src/com/ibm/icu/dev/test/charset/TestCharset.java	2021-10-29 08:10:04.130616650 -0600
@@ -9,6 +9,7 @@
 
 package com.ibm.icu.dev.test.charset;
 
+import java.nio.Buffer;
 import java.nio.BufferOverflowException;
 import java.nio.ByteBuffer;
 import java.nio.CharBuffer;
@@ -107,30 +108,30 @@ public class TestCharset extends TestFmw
             }
 
 
-            us.limit(us.position());
-            us.position(0);
+            ((Buffer)us).limit(us.position());
+            ((Buffer)us).position(0);
             if(us.length()==0){
                 continue;
             }
 
 
-            bs1.limit(bs1.position());
-            bs1.position(0);
+            ((Buffer)bs1).limit(bs1.position());
+            ((Buffer)bs1).position(0);
             ByteBuffer newBS = ByteBuffer.allocate(bs1.capacity());
             //newBS.put((byte)0xFE);
             //newBS.put((byte)0xFF);
             newBS.put(bs1);
-            bs1.position(0);
+            ((Buffer)bs1).position(0);
             smBufDecode(d1, "UTF-16", bs1, us);
             smBufEncode(e1, "UTF-16", us, newBS);
 
-            bs2.limit(bs2.position());
-            bs2.position(0);
-            newBS.clear();
+            ((Buffer)bs2).limit(bs2.position());
+            ((Buffer)bs2).position(0);
+            ((Buffer)newBS).clear();
             //newBS.put((byte)0xFF);
             //newBS.put((byte)0xFE);
             newBS.put(bs2);
-            bs2.position(0);
+            ((Buffer)bs2).position(0);
             smBufDecode(d2, "UTF16-LE", bs2, us);
             smBufEncode(e2, "UTF-16LE", us, newBS);
 
@@ -178,12 +179,12 @@ public class TestCharset extends TestFmw
                 bs2.put((byte) (c >>> 16));
                 bs2.put((byte) (c >>> 24));
             }
-            bs1.limit(bs1.position());
-            bs1.position(0);
-            bs2.limit(bs2.position());
-            bs2.position(0);
-            us.limit(us.position());
-            us.position(0);
+            ((Buffer)bs1).limit(bs1.position());
+            ((Buffer)bs1).position(0);
+            ((Buffer)bs2).limit(bs2.position());
+            ((Buffer)bs2).position(0);
+            ((Buffer)us).limit(us.position());
+            ((Buffer)us).position(0);
             if(us.length()==0){
                 continue;
             }
@@ -197,12 +198,12 @@ public class TestCharset extends TestFmw
             newBS.put((byte)0xFF);
 
             newBS.put(bs1);
-            bs1.position(0);
+            ((Buffer)bs1).position(0);
             smBufDecode(d1, "UTF-32", bs1, us);
             smBufEncode(e1, "UTF-32", us, newBS);
 
 
-            newBS.clear();
+            ((Buffer)newBS).clear();
 
             newBS.put((byte)0xFF);
             newBS.put((byte)0xFE);
@@ -210,7 +211,7 @@ public class TestCharset extends TestFmw
             newBS.put((byte)0x00);
 
             newBS.put(bs2);
-            bs2.position(0);
+            ((Buffer)bs2).position(0);
             smBufDecode(d2, "UTF-32LE", bs2, us);
             smBufEncode(e2, "UTF-32LE", us, newBS);
 
@@ -449,7 +450,7 @@ public class TestCharset extends TestFmw
         for (int index = 0; index < input.length; index++) {
             CharBuffer source = CharBuffer.wrap(input[index]);
             cr = encoder.encode(source, bs, true);
-            bs.rewind();
+            ((Buffer)bs).rewind();
             encoder.reset();
 
             // if cr != results[x]
@@ -464,7 +465,7 @@ public class TestCharset extends TestFmw
 
             source = CharBuffer.wrap(input[index].toCharArray());
             cr = encoder.encode(source, bs, true);
-            bs.rewind();
+            ((Buffer)bs).rewind();
             encoder.reset();
 
             // if cr != results[x]
@@ -563,8 +564,8 @@ public class TestCharset extends TestFmw
 
                 decoder.reset();
                 cr = decoder.decode(bs, us, true);
-                bs.rewind();
-                us.rewind();
+                ((Buffer)bs).rewind();
+                ((Buffer)us).rewind();
                 if (!cr.isMalformed() || cr.length() != 1) {
                     errln("Incorrect result in " + converter + " decoder for 0x"
                             + Integer.toHexString(i) + " received " + cr);
@@ -572,8 +573,8 @@ public class TestCharset extends TestFmw
                 }
                 encoder.reset();
                 cr = encoder.encode(us, bs, true);
-                bs.rewind();
-                us.rewind();
+                ((Buffer)bs).rewind();
+                ((Buffer)us).rewind();
                 if (!cr.isMalformed() || cr.length() != 1) {
                     errln("Incorrect result in " + converter + " encoder for 0x"
                             + Integer.toHexString(i) + " received " + cr);
@@ -585,8 +586,8 @@ public class TestCharset extends TestFmw
 
                 decoder.reset();
                 cr = decoder.decode(bs, us, true);
-                bs.rewind();
-                us.rewind();
+                ((Buffer)bs).rewind();
+                ((Buffer)us).rewind();
                 if (!cr.isMalformed() || cr.length() != 1) {
                     errln("Incorrect result in " + converter + " decoder for 0x"
                             + Integer.toHexString(i) + " received " + cr);
@@ -594,8 +595,8 @@ public class TestCharset extends TestFmw
                 }
                 encoder.reset();
                 cr = encoder.encode(us, bs, true);
-                bs.rewind();
-                us.rewind();
+                ((Buffer)bs).rewind();
+                ((Buffer)us).rewind();
                 if (!cr.isMalformed() || cr.length() != 1) {
                     errln("Incorrect result in " + converter + " encoder for 0x"
                             + Integer.toHexString(i) + " received " + cr);
@@ -669,9 +670,9 @@ public class TestCharset extends TestFmw
         int ccPositions[] = { 0, 0, 0, 2, 2 };
         for (int i = 0; i < testLoopSize; i++) {
             encoder.reset();
-            bb.limit(bbLimits[i]);
-            bb.position(bbPositions[i]);
-            cb.position(ccPositions[i]);
+            ((Buffer)bb).limit(bbLimits[i]);
+            ((Buffer)bb).position(bbPositions[i]);
+            ((Buffer)cb).position(ccPositions[i]);
             result = encoder.encode(cb, bb, true);
 
             if (i < 3) {
@@ -838,7 +839,7 @@ public class TestCharset extends TestFmw
             encoder.onUnmappableCharacter(CodingErrorAction.REPORT);
             encoder.onMalformedInput(CodingErrorAction.REPORT);
             for (int i=0; i<n; i++) {
-                source.limit(i+1);
+                ((Buffer)source).limit(i+1);
                 cr = encoder.encode(source, target, i == n - 1);
                 if (!(equals(cr, results[i])
                         || (results[i].isUnmappable() && cr.isUnderflow()) // mappability depends on the converter
@@ -1242,7 +1243,7 @@ public class TestCharset extends TestFmw
             decoder.reset();
             CoderResult result=null;
             for (int i = 1; i <= byteStr.length; i++) {
-                b.limit(i);
+                ((Buffer)b).limit(i);
                 result = decoder.decode(b, chars, false);
                 if(result.isOverflow()){
                     errln("ToChars single threw an overflow exception");
@@ -1270,9 +1271,9 @@ public class TestCharset extends TestFmw
         try {
             CharBuffer chars = CharBuffer.allocate(unistr.length());
             decoder.reset();
-            byes.rewind();
+            ((Buffer)byes).rewind();
             for (int i = 1; i <= byteStr.length; i++) {
-                byes.limit(i);
+                ((Buffer)byes).limit(i);
                 CoderResult result = decoder.decode(byes, chars, false);
                 if (result.isError()) {
                     errln("Error while decoding: "+result.toString());
@@ -1314,7 +1315,7 @@ public class TestCharset extends TestFmw
             if(result.isOverflow()){
                 errln("FromChars threw an overflow exception");
             }
-            bytes.position(0);
+            ((Buffer)bytes).position(0);
             if (!bytes.equals(expected)) {
                 errln("FromChars does not match");
                 printbytes(bytes);
@@ -1334,7 +1335,7 @@ public class TestCharset extends TestFmw
             encoder.reset();
             CoderResult result= null;
             for (int i = 1; i <= unistr.length(); i++) {
-                c.limit(i);
+                ((Buffer)c).limit(i);
                 result = encoder.encode(c, bytes, false);
                 if(result.isOverflow()){
                     errln("FromChars single threw an overflow exception");
@@ -1348,7 +1349,7 @@ public class TestCharset extends TestFmw
                 rc = 3;
             }
 
-            bytes.position(0);
+            ((Buffer)bytes).position(0);
             if (!bytes.equals(expected)) {
                 errln("FromChars single does not match");
                 printbytes(bytes);
@@ -1402,11 +1403,11 @@ public class TestCharset extends TestFmw
         int i;
         char[] chars = new char[buf.limit()];
         //save the current position
-        int pos = buf.position();
-        buf.position(0);
+        int pos = ((Buffer)buf).position();
+        ((Buffer)buf).position(0);
         buf.get(chars);
         //reset to old position
-        buf.position(pos);
+        ((Buffer)buf).position(pos);
         for (i = 0; i < chars.length; i++) {
             err(hex(chars[i]) + " ");
         }
@@ -1424,10 +1425,10 @@ public class TestCharset extends TestFmw
         byte[] bytes = new byte[buf.limit()];
         //save the current position
         int pos = buf.position();
-        buf.position(0);
+        ((Buffer)buf).position(0);
         buf.get(bytes);
         //reset to old position
-        buf.position(pos);
+        ((Buffer)buf).position(pos);
         for (i = 0; i < bytes.length; i++) {
             System.out.print(hex(bytes[i]) + " ");
         }
@@ -1464,10 +1465,10 @@ public class TestCharset extends TestFmw
         char[] chars = new char[buf.limit()];
         //save the current position
         int pos = buf.position();
-        buf.position(0);
+        ((Buffer)buf).position(0);
         buf.get(chars);
         //reset to old position
-        buf.position(pos);
+        ((Buffer)buf).position(pos);
         return equals(chars, compareTo);
     }
 
@@ -1501,10 +1502,10 @@ public class TestCharset extends TestFmw
         byte[] chars = new byte[buf.limit()];
         //save the current position
         int pos = buf.position();
-        buf.position(0);
+        ((Buffer)buf).position(0);
         buf.get(chars);
         //reset to old position
-        buf.position(pos);
+        ((Buffer)buf).position(pos);
         return equals(chars, compareTo);
     }
     public boolean equals(ByteBuffer buf, ByteBuffer compareTo) {
@@ -1736,7 +1737,7 @@ public class TestCharset extends TestFmw
             buffer.put(unibytes);
 
             //reset position
-            buffer.flip();
+            ((Buffer)buffer).flip();
 
             decoder.onMalformedInput(CodingErrorAction.REPLACE);
             CharBuffer out = decoder.decode(buffer);
@@ -1803,8 +1804,8 @@ public class TestCharset extends TestFmw
             errln("FAIL: \\ud800 is OK for ICU4JNI utf-8 encoder");
         }
 
-        in.position(0);
-        out.clear();
+        ((Buffer)in).position(0);
+        ((Buffer)out).clear();
 
         CharsetEncoder encoderJDK = Charset.forName("utf-8").newEncoder();
         result = encoderJDK.encode(in, out, true);
@@ -1855,9 +1856,9 @@ public class TestCharset extends TestFmw
         inBuf.put(in);
         CharsetEncoder encoder = cs.newEncoder();
         ByteBuffer outBuf = ByteBuffer.allocate(in.length*2+2);
-        inBuf.rewind();
+        ((Buffer)inBuf).rewind();
         encoder.encode(inBuf, outBuf, true);
-        outBuf.rewind();
+        ((Buffer)outBuf).rewind();
         if(outBuf.get(0)!= (byte)0xFE && outBuf.get(1)!= (byte)0xFF){
             errln("The UTF16 encoder did not appended bom. Length returned: " + outBuf.remaining());
         }
@@ -1865,7 +1866,7 @@ public class TestCharset extends TestFmw
             logln("0x"+hex(outBuf.get()));
         }
         CharsetDecoder decoder = cs.newDecoder();
-        outBuf.rewind();
+        ((Buffer)outBuf).rewind();
         CharBuffer rt = CharBuffer.allocate(in.length);
         CoderResult cr = decoder.decode(outBuf, rt, true);
         if(cr.isError()){
@@ -1873,8 +1874,8 @@ public class TestCharset extends TestFmw
         }
         equals(rt, in);
         {
-            rt.clear();
-            outBuf.rewind();
+            ((Buffer)rt).clear();
+            ((Buffer)outBuf).rewind();
             Charset utf16 = Charset.forName("UTF-16");
             CharsetDecoder dc = utf16.newDecoder();
             cr = dc.decode(outBuf, rt, true);
@@ -1912,9 +1913,9 @@ public class TestCharset extends TestFmw
 
         {
             decoder.reset();
-            myTarget.limit(target.limit());
-            mySource.limit(source.limit());
-            mySource.position(source.position());
+            ((Buffer)myTarget).limit(target.limit());
+            ((Buffer)mySource).limit(source.limit());
+            ((Buffer)mySource).position(source.position());
             CoderResult result = CoderResult.UNDERFLOW;
             result = decoder.decode(mySource, myTarget, true);
             if (flush) {
@@ -1934,9 +1935,9 @@ public class TestCharset extends TestFmw
                 errln("Test complete buffers while decoding threw overflow exception");
                 return;
             }
-            myTarget.limit(myTarget.position());
-            myTarget.position(0);
-            target.position(0);
+            ((Buffer)myTarget).limit(myTarget.position());
+            ((Buffer)myTarget).position(0);
+            ((Buffer)target).position(0);
             if (result.isUnderflow() && !equals(myTarget, target, targetLimit)) {
                 errln(" Test complete buffers while decoding  " + encoding + " TO Unicode--failed");
             }
@@ -1946,11 +1947,11 @@ public class TestCharset extends TestFmw
         }
         {
             decoder.reset();
-            myTarget.limit(target.position());
-            mySource.limit(source.position());
-            mySource.position(source.position());
-            myTarget.clear();
-            myTarget.position(0);
+            ((Buffer)myTarget).limit(target.position());
+            ((Buffer)mySource).limit(source.position());
+            ((Buffer)mySource).position(source.position());
+            ((Buffer)myTarget).clear();
+            ((Buffer)myTarget).position(0);
 
             int inputLen = mySource.remaining();
 
@@ -1981,18 +1982,18 @@ public class TestCharset extends TestFmw
         }
         {
             decoder.reset();
-            myTarget.limit(0);
-            mySource.limit(0);
-            mySource.position(source.position());
-            myTarget.clear();
+            ((Buffer)myTarget).limit(0);
+            ((Buffer)mySource).limit(0);
+            ((Buffer)mySource).position(source.position());
+            ((Buffer)myTarget).clear();
             while (true) {
                 CoderResult result = decoder.decode(mySource, myTarget, false);
                 if (result.isUnderflow()) {
                     if (mySource.limit() < source.limit())
-                        mySource.limit(mySource.limit() + 1);
+                        ((Buffer)mySource).limit(mySource.limit() + 1);
                 } else if (result.isOverflow()) {
                     if (myTarget.limit() < target.limit())
-                        myTarget.limit(myTarget.limit() + 1);
+                        ((Buffer)myTarget).limit(myTarget.limit() + 1);
                     else
                         break;
                 } else /*if (result.isError())*/ {
@@ -2041,17 +2042,17 @@ public class TestCharset extends TestFmw
             mySource = ByteBuffer.allocateDirect(source.capacity() * 2).asCharBuffer();
             myTarget = ByteBuffer.allocateDirect(target.capacity());
         }
-        mySource.position(source.position());
+        ((Buffer)mySource).position(source.position());
         for (int i = source.position(); i < source.limit(); i++)
             mySource.put(i, source.get(i));
 
-        myTarget.clear();
+        ((Buffer)myTarget).clear();
         {
             logln("Running tests on small input buffers for " + encoding);
             encoder.reset();
-            myTarget.limit(target.limit());
-            mySource.limit(source.limit());
-            mySource.position(source.position());
+            ((Buffer)myTarget).limit(target.limit());
+            ((Buffer)mySource).limit(source.limit());
+            ((Buffer)mySource).position(source.position());
             CoderResult result = null;
 
             result = encoder.encode(mySource, myTarget, true);
@@ -2084,10 +2085,10 @@ public class TestCharset extends TestFmw
         {
             logln("Running tests on small input buffers for " + encoding);
             encoder.reset();
-            myTarget.clear();
-            myTarget.limit(target.limit());
-            mySource.limit(source.limit());
-            mySource.position(source.position());
+            ((Buffer)myTarget).clear();
+            ((Buffer)myTarget).limit(target.limit());
+            ((Buffer)mySource).limit(source.limit());
+            ((Buffer)mySource).position(source.position());
             int inputLen = mySource.limit();
             CoderResult result = null;
             for (int i = 1; i <= inputLen; i++) {
@@ -2112,12 +2113,12 @@ public class TestCharset extends TestFmw
         {
             logln("Running tests on small output buffers for " + encoding);
             encoder.reset();
-            myTarget.clear();
-            myTarget.limit(target.limit());
-            mySource.limit(source.limit());
-            mySource.position(source.position());
-            mySource.position(0);
-            myTarget.position(0);
+            ((Buffer)myTarget).clear();
+            ((Buffer)myTarget).limit(target.limit());
+            ((Buffer)mySource).limit(source.limit());
+            ((Buffer)mySource).position(source.position());
+            ((Buffer)mySource).position(0);
+            ((Buffer)myTarget).position(0);
 
             logln("myTarget.limit: " + myTarget.limit() + " myTarget.capcity: " + myTarget.capacity());
 
@@ -2137,7 +2138,7 @@ public class TestCharset extends TestFmw
                         errln("Test small output buffers while encoding " + result.toString());
                     }
 
-                    myTarget.limit(myTarget.capacity());
+                    ((Buffer)myTarget).limit(myTarget.capacity());
                     result = encoder.flush(myTarget);
                     if (result.isError()) {
                         errln("Test small output buffers while encoding " + result.toString());
@@ -2563,8 +2564,8 @@ public class TestCharset extends TestFmw
             in.put((byte)i);
             i++;
         }
-        in.limit(in.position());
-        in.position(0);
+        ((Buffer)in).limit(in.position());
+        ((Buffer)in).position(0);
         CharsetDecoder decoder = cs.newDecoder();
         decoder.onMalformedInput(CodingErrorAction.IGNORE);
         decoder.onUnmappableCharacter(CodingErrorAction.REPORT);
@@ -2596,9 +2597,9 @@ public class TestCharset extends TestFmw
         inBuf.put(in);
         CharsetEncoder encoder = cs.newEncoder();
         ByteBuffer outBuf = ByteBuffer.allocate(in.length*4+4);
-        inBuf.rewind();
+        ((Buffer)inBuf).rewind();
         encoder.encode(inBuf, outBuf, true);
-        outBuf.rewind();
+        ((Buffer)outBuf).rewind();
         if(outBuf.get(0)!= (byte)0x00 && outBuf.get(1)!= (byte)0x00 &&
                 outBuf.get(2)!= (byte)0xFF && outBuf.get(3)!= (byte)0xFE){
             errln("The UTF32 encoder did not appended bom. Length returned: " + outBuf.remaining());
@@ -2607,8 +2608,8 @@ public class TestCharset extends TestFmw
             logln("0x"+hex(outBuf.get()));
         }
         CharsetDecoder decoder = cs.newDecoder();
-        outBuf.limit(outBuf.position());
-        outBuf.rewind();
+        ((Buffer)outBuf).limit(outBuf.position());
+        ((Buffer)outBuf).rewind();
         CharBuffer rt = CharBuffer.allocate(in.length);
         CoderResult cr = decoder.decode(outBuf, rt, true);
         if(cr.isError()){
@@ -2616,8 +2617,8 @@ public class TestCharset extends TestFmw
         }
         equals(rt, in);
         try{
-            rt.clear();
-            outBuf.rewind();
+            ((Buffer)rt).clear();
+            ((Buffer)outBuf).rewind();
             Charset utf16 = Charset.forName("UTF-32");
             CharsetDecoder dc = utf16.newDecoder();
             cr = dc.decode(outBuf, rt, true);
@@ -2745,16 +2746,16 @@ public class TestCharset extends TestFmw
            byteBuffer.put((byte)j);
         }
 
-        byteBuffer.limit(byteBufferLimit = byteBuffer.position());
-        byteBuffer.position(0);
-        charBuffer.limit(charBufferLimit = charBuffer.position());
-        charBuffer.position(0);
+        ((Buffer)byteBuffer).limit(byteBufferLimit = byteBuffer.position());
+        ((Buffer)byteBuffer).position(0);
+        ((Buffer)charBuffer).limit(charBufferLimit = charBuffer.position());
+        ((Buffer)charBuffer).position(0);
 
         //test for overflow
-        byteBufferTest.limit(byteBufferLimit - 5);
-        byteBufferTest.position(0);
-        charBufferTest.limit(charBufferLimit - 5);
-        charBufferTest.position(0);
+        ((Buffer)byteBufferTest).limit(byteBufferLimit - 5);
+        ((Buffer)byteBufferTest).position(0);
+        ((Buffer)charBufferTest).limit(charBufferLimit - 5);
+        ((Buffer)charBufferTest).position(0);
         try {
             smBufDecode(decoder, "ASCII", byteBuffer, charBufferTest, true, false);
             errln("Overflow exception while decoding ASCII should have been thrown.");
@@ -2806,10 +2807,10 @@ public class TestCharset extends TestFmw
         bs.put((byte)0x49); bs.put((byte)0x44); bs.put((byte)0x6b); bs.put((byte)0x51);
         bs.put((byte)0x4f); bs.put((byte)0x62); bs.put((byte)0x2e);
 
-        bs.limit(bs.position());
-        bs.position(0);
-        us.limit(us.position());
-        us.position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
 
         smBufDecode(decoder, "UTF-7", bs, us);
         smBufEncode(encoder, "UTF-7", us, bs);
@@ -2855,10 +2856,10 @@ public class TestCharset extends TestFmw
         ccbs.put((byte)0x0D); ccbs.put((byte)0x05);
         ccus.put((char)0x0000);
 
-        ccbs.limit(ccbs.position());
-        ccbs.position(0);
-        ccus.limit(ccus.position());
-        ccus.position(0);
+        ((Buffer)ccbs).limit(ccbs.position());
+        ((Buffer)ccbs).position(0);
+        ((Buffer)ccus).limit(ccus.position());
+        ((Buffer)ccus).position(0);
 
         try {
             smBufDecode(decoder, "UTF-7-CC-DE-1", ccbs, ccus, true, false);
@@ -2867,17 +2868,17 @@ public class TestCharset extends TestFmw
         catch (Exception ex) {
         }
 
-        ccbs.clear();
-        ccus.clear();
+        ((Buffer)ccbs).clear();
+        ((Buffer)ccus).clear();
 
         //test for illegal base64 character
         ccbs.put((byte)0x2b); ccbs.put((byte)0xff);
         ccus.put((char)0x0000);
 
-        ccbs.limit(ccbs.position());
-        ccbs.position(0);
-        ccus.limit(ccus.position());
-        ccus.position(0);
+        ((Buffer)ccbs).limit(ccbs.position());
+        ((Buffer)ccbs).position(0);
+        ((Buffer)ccus).limit(ccus.position());
+        ((Buffer)ccus).position(0);
 
         try {
             smBufDecode(decoder, "UTF-7-CC-DE-2", ccbs, ccus, true, false);
@@ -2886,17 +2887,17 @@ public class TestCharset extends TestFmw
         catch (Exception ex) {
         }
 
-        ccbs.clear();
-        ccus.clear();
+        ((Buffer)ccbs).clear();
+        ((Buffer)ccus).clear();
 
         //test for illegal order of the base64 character sequence
         ccbs.put((byte)0x2b); ccbs.put((byte)0x2d); ccbs.put((byte)0x2b); ccbs.put((byte)0x49); ccbs.put((byte)0x2d);
         ccus.put((char)0x0000); ccus.put((char)0x0000);
 
-        ccbs.limit(ccbs.position());
-        ccbs.position(0);
-        ccus.limit(ccus.position());
-        ccus.position(0);
+        ((Buffer)ccbs).limit(ccbs.position());
+        ((Buffer)ccbs).position(0);
+        ((Buffer)ccus).limit(ccus.position());
+        ((Buffer)ccus).position(0);
 
         try {
             smBufDecode(decoder, "UTF-7-CC-DE-3", ccbs, ccus, true, false);
@@ -2905,17 +2906,17 @@ public class TestCharset extends TestFmw
         catch (Exception ex) {
         }
 
-        ccbs.clear();
-        ccus.clear();
+        ((Buffer)ccbs).clear();
+        ((Buffer)ccus).clear();
 
         //test for illegal order of the base64 character sequence
         ccbs.put((byte)0x2b); ccbs.put((byte)0x0a); ccbs.put((byte)0x09);
         ccus.put((char)0x0000);
 
-        ccbs.limit(ccbs.position());
-        ccbs.position(0);
-        ccus.limit(ccus.position());
-        ccus.position(0);
+        ((Buffer)ccbs).limit(ccbs.position());
+        ((Buffer)ccbs).position(0);
+        ((Buffer)ccus).limit(ccus.position());
+        ((Buffer)ccus).position(0);
 
         try {
             smBufDecode(decoder, "UTF-7-CC-DE-4", ccbs, ccus, true, false);
@@ -2924,17 +2925,17 @@ public class TestCharset extends TestFmw
         catch (Exception ex) {
         }
 
-        ccbs.clear();
-        ccus.clear();
+        ((Buffer)ccbs).clear();
+        ((Buffer)ccus).clear();
 
         //test for illegal order of the base64 character sequence
         ccbs.put((byte)0x2b); ccbs.put((byte)0x49); ccbs.put((byte)0x0a);
         ccus.put((char)0x0000);
 
-        ccbs.limit(ccbs.position());
-        ccbs.position(0);
-        ccus.limit(ccus.position());
-        ccus.position(0);
+        ((Buffer)ccbs).limit(ccbs.position());
+        ((Buffer)ccbs).position(0);
+        ((Buffer)ccus).limit(ccus.position());
+        ((Buffer)ccus).position(0);
 
         try {
             smBufDecode(decoder, "UTF-7-CC-DE-5", ccbs, ccus, true, false);
@@ -2943,17 +2944,17 @@ public class TestCharset extends TestFmw
         catch (Exception ex) {
         }
 
-        ccbs.clear();
-        ccus.clear();
+        ((Buffer)ccbs).clear();
+        ((Buffer)ccus).clear();
 
         //test for illegal order of the base64 character sequence
         ccbs.put((byte)0x2b); ccbs.put((byte)0x00);
         ccus.put((char)0x0000);
 
-        ccbs.limit(ccbs.position());
-        ccbs.position(0);
-        ccus.limit(ccus.position());
-        ccus.position(0);
+        ((Buffer)ccbs).limit(ccbs.position());
+        ((Buffer)ccbs).position(0);
+        ((Buffer)ccus).limit(ccus.position());
+        ((Buffer)ccus).position(0);
 
         try {
             smBufDecode(decoder, "UTF-7-CC-DE-6", ccbs, ccus, true, false);
@@ -2962,16 +2963,16 @@ public class TestCharset extends TestFmw
         catch (Exception ex) {
         }
 
-        ccbs.clear();
-        ccus.clear();
+        ((Buffer)ccbs).clear();
+        ((Buffer)ccus).clear();
 
         //test for overflow buffer error
         ccbs.put((byte)0x2b); ccbs.put((byte)0x49);
 
-        ccbs.limit(ccbs.position());
-        ccbs.position(0);
-        ccus.limit(0);
-        ccus.position(0);
+        ((Buffer)ccbs).limit(ccbs.position());
+        ((Buffer)ccbs).position(0);
+        ((Buffer)ccus).limit(0);
+        ((Buffer)ccus).position(0);
 
         try {
             smBufDecode(decoder, "UTF-7-CC-DE-7", ccbs, ccus, true, false);
@@ -2980,16 +2981,16 @@ public class TestCharset extends TestFmw
         catch (Exception ex) {
         }
 
-        ccbs.clear();
-        ccus.clear();
+        ((Buffer)ccbs).clear();
+        ((Buffer)ccus).clear();
 
         //test for overflow buffer error
         ccbs.put((byte)0x0c); ccbs.put((byte)0x0c);
 
-        ccbs.limit(ccbs.position());
-        ccbs.position(0);
-        ccus.limit(0);
-        ccus.position(0);
+        ((Buffer)ccbs).limit(ccbs.position());
+        ((Buffer)ccbs).position(0);
+        ((Buffer)ccus).limit(0);
+        ((Buffer)ccus).position(0);
 
         try {
             smBufDecode(decoder, "UTF-7-CC-DE-8", ccbs, ccus, true, false);
@@ -3000,16 +3001,16 @@ public class TestCharset extends TestFmw
         //end of charset decoder code coverage code
 
         //start of charset encoder code coverage code
-        ccbs.clear();
-        ccus.clear();
+        ((Buffer)ccbs).clear();
+        ((Buffer)ccus).clear();
         //test for overflow buffer error
         ccus.put((char)0x002b);
         ccbs.put((byte)0x2b);
 
-        ccbs.limit(ccbs.position());
-        ccbs.position(0);
-        ccus.limit(ccus.position());
-        ccus.position(0);
+        ((Buffer)ccbs).limit(ccbs.position());
+        ((Buffer)ccbs).position(0);
+        ((Buffer)ccus).limit(ccus.position());
+        ((Buffer)ccus).position(0);
 
         try {
             smBufEncode(encoder, "UTF-7-CC-EN-1", ccus, ccbs, true, false);
@@ -3018,17 +3019,17 @@ public class TestCharset extends TestFmw
         catch (Exception ex) {
         }
 
-        ccbs.clear();
-        ccus.clear();
+        ((Buffer)ccbs).clear();
+        ((Buffer)ccus).clear();
 
         //test for overflow buffer error
         ccus.put((char)0x002b); ccus.put((char)0x2262);
         ccbs.put((byte)0x2b); ccbs.put((byte)0x2d); ccbs.put((byte)0x00); ccbs.put((byte)0x00);
 
-        ccbs.limit(ccbs.position());
-        ccbs.position(0);
-        ccus.limit(ccus.position());
-        ccus.position(0);
+        ((Buffer)ccbs).limit(ccbs.position());
+        ((Buffer)ccbs).position(0);
+        ((Buffer)ccus).limit(ccus.position());
+        ((Buffer)ccus).position(0);
 
         try {
             smBufEncode(encoder, "UTF-7-CC-EN-2", ccus, ccbs, true, false);
@@ -3037,16 +3038,16 @@ public class TestCharset extends TestFmw
         catch (Exception ex) {
         }
 
-        ccbs.clear();
-        ccus.clear();
+        ((Buffer)ccbs).clear();
+        ((Buffer)ccus).clear();
 
         //test for overflow buffer error
         ccus.put((char)0x2262); ccus.put((char)0x0049);
         ccbs.put((byte)0x00); ccbs.put((byte)0x00); ccbs.put((byte)0x00); ccbs.put((byte)0x00); ccbs.put((byte)0x00);
-        ccbs.limit(ccbs.position());
-        ccbs.position(0);
-        ccus.limit(ccus.position());
-        ccus.position(0);
+        ((Buffer)ccbs).limit(ccbs.position());
+        ((Buffer)ccbs).position(0);
+        ((Buffer)ccus).limit(ccus.position());
+        ((Buffer)ccus).position(0);
 
         try {
             smBufEncode(encoder, "UTF-7-CC-EN-3", ccus, ccbs, true, false);
@@ -3055,16 +3056,16 @@ public class TestCharset extends TestFmw
         catch (Exception ex) {
         }
 
-        ccbs.clear();
-        ccus.clear();
+        ((Buffer)ccbs).clear();
+        ((Buffer)ccus).clear();
 
         //test for overflow buffer error
         ccus.put((char)0x2262); ccus.put((char)0x0395);
         ccbs.put((byte)0x00); ccbs.put((byte)0x00); ccbs.put((byte)0x00); ccbs.put((byte)0x00);
-        ccbs.limit(ccbs.position());
-        ccbs.position(0);
-        ccus.limit(ccus.position());
-        ccus.position(0);
+        ((Buffer)ccbs).limit(ccbs.position());
+        ((Buffer)ccbs).position(0);
+        ((Buffer)ccus).limit(ccus.position());
+        ((Buffer)ccus).position(0);
 
         try {
             smBufEncode(encoder, "UTF-7-CC-EN-4", ccus, ccbs, true, false);
@@ -3073,16 +3074,16 @@ public class TestCharset extends TestFmw
         catch (Exception ex) {
         }
 
-        ccbs.clear();
-        ccus.clear();
+        ((Buffer)ccbs).clear();
+        ((Buffer)ccus).clear();
 
         //test for overflow buffer error
         ccus.put((char)0x2262); ccus.put((char)0x0395);
         ccbs.put((byte)0x00); ccbs.put((byte)0x00); ccbs.put((byte)0x00); ccbs.put((byte)0x00); ccbs.put((byte)0x00);
-        ccbs.limit(ccbs.position());
-        ccbs.position(0);
-        ccus.limit(ccus.position());
-        ccus.position(0);
+        ((Buffer)ccbs).limit(ccbs.position());
+        ((Buffer)ccbs).position(0);
+        ((Buffer)ccus).limit(ccus.position());
+        ((Buffer)ccus).position(0);
 
         try {
             smBufEncode(encoder, "UTF-7-CC-EN-5", ccus, ccbs, true, false);
@@ -3091,16 +3092,16 @@ public class TestCharset extends TestFmw
         catch (Exception ex) {
         }
 
-        ccbs.clear();
-        ccus.clear();
+        ((Buffer)ccbs).clear();
+        ((Buffer)ccus).clear();
 
         //test for overflow buffer error
         ccus.put((char)0x2262); ccus.put((char)0x0395); ccus.put((char)0x0391);
         ccbs.put((byte)0x00); ccbs.put((byte)0x00); ccbs.put((byte)0x00); ccbs.put((byte)0x00); ccbs.put((byte)0x00); ccbs.put((byte)0x00); ccbs.put((byte)0x00);
-        ccbs.limit(ccbs.position());
-        ccbs.position(0);
-        ccus.limit(ccus.position());
-        ccus.position(0);
+        ((Buffer)ccbs).limit(ccbs.position());
+        ((Buffer)ccbs).position(0);
+        ((Buffer)ccus).limit(ccus.position());
+        ((Buffer)ccus).position(0);
 
         try {
             smBufEncode(encoder, "UTF-7-CC-EN-6", ccus, ccbs, true, false);
@@ -3109,17 +3110,17 @@ public class TestCharset extends TestFmw
         catch (Exception ex) {
         }
 
-        ccbs.clear();
-        ccus.clear();
+        ((Buffer)ccbs).clear();
+        ((Buffer)ccus).clear();
 
         //test for overflow buffer error
         ccus.put((char)0x2262); ccus.put((char)0x0395); ccus.put((char)0x0391);
         ccbs.put((byte)0x00); ccbs.put((byte)0x00); ccbs.put((byte)0x00); ccbs.put((byte)0x00);
         ccbs.put((byte)0x00); ccbs.put((byte)0x00); ccbs.put((byte)0x00); ccbs.put((byte)0x00);
-        ccbs.limit(ccbs.position());
-        ccbs.position(0);
-        ccus.limit(ccus.position());
-        ccus.position(0);
+        ((Buffer)ccbs).limit(ccbs.position());
+        ((Buffer)ccbs).position(0);
+        ((Buffer)ccus).limit(ccus.position());
+        ((Buffer)ccus).position(0);
 
         try {
             smBufEncode(encoder, "UTF-7-CC-EN-7", ccus, ccbs, true, false);
@@ -3128,16 +3129,16 @@ public class TestCharset extends TestFmw
         catch (Exception ex) {
         }
 
-        ccbs.clear();
-        ccus.clear();
+        ((Buffer)ccbs).clear();
+        ((Buffer)ccus).clear();
 
         //test for overflow buffer error
         ccus.put((char)0x0049); ccus.put((char)0x0048);
         ccbs.put((byte)0x00);
-        ccbs.limit(ccbs.position());
-        ccbs.position(0);
-        ccus.limit(ccus.position());
-        ccus.position(0);
+        ((Buffer)ccbs).limit(ccbs.position());
+        ((Buffer)ccbs).position(0);
+        ((Buffer)ccus).limit(ccus.position());
+        ((Buffer)ccus).position(0);
 
         try {
             smBufEncode(encoder, "UTF-7-CC-EN-8", ccus, ccbs, true, false);
@@ -3146,16 +3147,16 @@ public class TestCharset extends TestFmw
         catch (Exception ex) {
         }
 
-        ccbs.clear();
-        ccus.clear();
+        ((Buffer)ccbs).clear();
+        ((Buffer)ccus).clear();
 
         //test for overflow buffer error
         ccus.put((char)0x2262);
         ccbs.put((byte)0x00);
-        ccbs.limit(ccbs.position());
-        ccbs.position(0);
-        ccus.limit(ccus.position());
-        ccus.position(0);
+        ((Buffer)ccbs).limit(ccbs.position());
+        ((Buffer)ccbs).position(0);
+        ((Buffer)ccus).limit(ccus.position());
+        ((Buffer)ccus).position(0);
 
         try {
             smBufEncode(encoder, "UTF-7-CC-EN-9", ccus, ccbs, true, false);
@@ -3164,16 +3165,16 @@ public class TestCharset extends TestFmw
         catch (Exception ex) {
         }
 
-        ccbs.clear();
-        ccus.clear();
+        ((Buffer)ccbs).clear();
+        ((Buffer)ccus).clear();
 
         //test for overflow buffer error
         ccus.put((char)0x2262); ccus.put((char)0x0049);
         ccbs.put((byte)0x00); ccbs.put((byte)0x00); ccbs.put((byte)0x00); ccbs.put((byte)0x00);
-        ccbs.limit(ccbs.position());
-        ccbs.position(0);
-        ccus.limit(ccus.position());
-        ccus.position(0);
+        ((Buffer)ccbs).limit(ccbs.position());
+        ((Buffer)ccbs).position(0);
+        ((Buffer)ccus).limit(ccus.position());
+        ((Buffer)ccus).position(0);
 
         try {
             smBufEncode(encoder, "UTF-7-CC-EN-10", ccus, ccbs, true, false);
@@ -3182,35 +3183,35 @@ public class TestCharset extends TestFmw
         catch (Exception ex) {
         }
 
-        ccbs.clear();
-        ccus.clear();
+        ((Buffer)ccbs).clear();
+        ((Buffer)ccus).clear();
 
         //test for overflow buffer error
         ccus.put((char)0x2262);
         ccbs.put((byte)0x2b); ccbs.put((byte)0x49); ccbs.put((byte)0x6d); ccbs.put((byte)0x49); ccbs.put((byte)0x2d);
 
-        ccbs.limit(ccbs.position());
-        ccbs.position(0);
-        ccus.limit(ccus.position());
-        ccus.position(0);
+        ((Buffer)ccbs).limit(ccbs.position());
+        ((Buffer)ccbs).position(0);
+        ((Buffer)ccus).limit(ccus.position());
+        ((Buffer)ccus).position(0);
         try {
             smBufEncode(encoder, "UTF-7-CC-EN-11", ccus, ccbs, false, true);
         } catch (Exception ex) {
             errln("Exception while encoding UTF-7 code coverage test should not have been thrown.");
         }
 
-        ccbs.clear();
-        ccus.clear();
+        ((Buffer)ccbs).clear();
+        ((Buffer)ccus).clear();
 
         //test for overflow buffer error
         encoder.reset();
         ccus.put((char)0x3980); ccus.put((char)0x2715);
         ccbs.put((byte)0x2b); ccbs.put((byte)0x4f); ccbs.put((byte)0x59); ccbs.put((byte)0x2d);
 
-        ccbs.limit(ccbs.position());
-        ccbs.position(0);
-        ccus.limit(ccus.position());
-        ccus.position(0);
+        ((Buffer)ccbs).limit(ccbs.position());
+        ((Buffer)ccbs).position(0);
+        ((Buffer)ccus).limit(ccus.position());
+        ((Buffer)ccus).position(0);
 
         result = encoder.encode(ccus, ccbs, true);
         result = encoder.flush(ccbs);
@@ -3394,12 +3395,12 @@ public class TestCharset extends TestFmw
         bsr.put((byte)0xBF); bsr.put((byte)0xE9); bsr.put((byte)0xC0); bsr.put((byte)0xE9); bsr.put((byte)0xC9); bsr.put((byte)0xE9);
         bsr.put((byte)0xD9); bsr.put((byte)0xE8); bsr.put((byte)0xCF); bsr.put((byte)0x00); bsr.put((byte)0xA0);
 
-        bs.limit(bs.position());
-        bs.position(0);
-        us.limit(us.position());
-        us.position(0);
-        bsr.limit(bsr.position());
-        bsr.position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
+        ((Buffer)bsr).limit(bsr.position());
+        ((Buffer)bsr).position(0);
 
         //round trip test
         try {
@@ -3427,15 +3428,15 @@ public class TestCharset extends TestFmw
         us.put(u_pts);
         bs.put(b_pts);
 
-        bs.limit(bs.position());
-        bs.position(0);
-        us.limit(us.position());
-        us.position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
 
         try {
             smBufDecode(decoder, "ISCII-update", bs, us, true, true);
-            bs.position(0);
-            us.position(0);
+            ((Buffer)bs).position(0);
+            ((Buffer)us).position(0);
             smBufEncode(encoder, "ISCII-update", us, bs, true, true);
         } catch (Exception ex) {
             errln("Error occurred while encoding/decoding ISCII with the new characters.");
@@ -3449,10 +3450,10 @@ public class TestCharset extends TestFmw
         //test overflow buffer
         ccbs.put((byte)0x49);
 
-        ccbs.limit(ccbs.position());
-        ccbs.position(0);
-        ccus.limit(0);
-        ccus.position(0);
+        ((Buffer)ccbs).limit(ccbs.position());
+        ((Buffer)ccbs).position(0);
+        ((Buffer)ccus).limit(0);
+        ((Buffer)ccus).position(0);
 
         try {
             smBufDecode(decoder, "ISCII-CC-DE-1", ccbs, ccus, true, false);
@@ -3461,17 +3462,17 @@ public class TestCharset extends TestFmw
         catch (Exception ex) {
         }
 
-        ccbs.clear();
-        ccus.clear();
+        ((Buffer)ccbs).clear();
+        ((Buffer)ccus).clear();
 
         //test atr overflow buffer
         ccbs.put((byte)0xEF); ccbs.put((byte)0x40); ccbs.put((byte)0xEF); ccbs.put((byte)0x20);
         ccus.put((char)0x00);
 
-        ccbs.limit(ccbs.position());
-        ccbs.position(0);
-        ccus.limit(ccus.position());
-        ccus.position(0);
+        ((Buffer)ccbs).limit(ccbs.position());
+        ((Buffer)ccbs).position(0);
+        ((Buffer)ccus).limit(ccus.position());
+        ((Buffer)ccus).position(0);
 
         try {
             smBufDecode(decoder, "ISCII-CC-DE-2", ccbs, ccus, true, false);
@@ -3482,17 +3483,17 @@ public class TestCharset extends TestFmw
 
         //end of charset decoder code coverage code
 
-        ccbs.clear();
-        ccus.clear();
+        ((Buffer)ccbs).clear();
+        ((Buffer)ccus).clear();
 
         //start of charset encoder code coverage code
         //test ascii overflow buffer
         ccus.put((char)0x41);
 
-        ccus.limit(ccus.position());
-        ccus.position(0);
-        ccbs.limit(0);
-        ccbs.position(0);
+        ((Buffer)ccus).limit(ccus.position());
+        ((Buffer)ccus).position(0);
+        ((Buffer)ccbs).limit(0);
+        ((Buffer)ccbs).position(0);
 
         try {
             smBufEncode(encoder, "ISCII-CC-EN-1", ccus, ccbs, true, false);
@@ -3501,17 +3502,17 @@ public class TestCharset extends TestFmw
         catch (Exception ex) {
         }
 
-        ccbs.clear();
-        ccus.clear();
+        ((Buffer)ccbs).clear();
+        ((Buffer)ccus).clear();
 
         //test ascii overflow buffer
         ccus.put((char)0x0A); ccus.put((char)0x0043);
         ccbs.put((byte)0x00); ccbs.put((byte)0x00);
 
-        ccus.limit(ccus.position());
-        ccus.position(0);
-        ccbs.limit(ccbs.position());
-        ccbs.position(0);
+        ((Buffer)ccus).limit(ccus.position());
+        ((Buffer)ccus).position(0);
+        ((Buffer)ccbs).limit(ccbs.position());
+        ((Buffer)ccbs).position(0);
 
         try {
             smBufEncode(encoder, "ISCII-CC-EN-2", ccus, ccbs, true, false);
@@ -3520,17 +3521,17 @@ public class TestCharset extends TestFmw
         catch (Exception ex) {
         }
 
-        ccbs.clear();
-        ccus.clear();
+        ((Buffer)ccbs).clear();
+        ((Buffer)ccus).clear();
 
         //test surrogate malform
         ccus.put((char)0x06E3);
         ccbs.put((byte)0x00);
 
-        ccus.limit(ccus.position());
-        ccus.position(0);
-        ccbs.limit(ccbs.position());
-        ccbs.position(0);
+        ((Buffer)ccus).limit(ccus.position());
+        ((Buffer)ccus).position(0);
+        ((Buffer)ccbs).limit(ccbs.position());
+        ((Buffer)ccbs).position(0);
 
         try {
             smBufEncode(encoder, "ISCII-CC-EN-3", ccus, ccbs, true, false);
@@ -3539,17 +3540,17 @@ public class TestCharset extends TestFmw
         catch (Exception ex) {
         }
 
-        ccbs.clear();
-        ccus.clear();
+        ((Buffer)ccbs).clear();
+        ((Buffer)ccus).clear();
 
         //test surrogate malform
         ccus.put((char)0xD801); ccus.put((char)0xDD01);
         ccbs.put((byte)0x00);
 
-        ccus.limit(ccus.position());
-        ccus.position(0);
-        ccbs.limit(ccbs.position());
-        ccbs.position(0);
+        ((Buffer)ccus).limit(ccus.position());
+        ((Buffer)ccus).position(0);
+        ((Buffer)ccbs).limit(ccbs.position());
+        ((Buffer)ccbs).position(0);
 
         try {
             smBufEncode(encoder, "ISCII-CC-EN-4", ccus, ccbs, true, false);
@@ -3558,17 +3559,17 @@ public class TestCharset extends TestFmw
         catch (Exception ex) {
         }
 
-        ccbs.clear();
-        ccus.clear();
+        ((Buffer)ccbs).clear();
+        ((Buffer)ccus).clear();
 
         //test trail surrogate malform
         ccus.put((char)0xDD01);
         ccbs.put((byte)0x00);
 
-        ccus.limit(ccus.position());
-        ccus.position(0);
-        ccbs.limit(ccbs.position());
-        ccbs.position(0);
+        ((Buffer)ccus).limit(ccus.position());
+        ((Buffer)ccus).position(0);
+        ((Buffer)ccbs).limit(ccbs.position());
+        ((Buffer)ccbs).position(0);
 
         try {
             smBufEncode(encoder, "ISCII-CC-EN-5", ccus, ccbs, true, false);
@@ -3577,17 +3578,17 @@ public class TestCharset extends TestFmw
         catch (Exception ex) {
         }
 
-        ccbs.clear();
-        ccus.clear();
+        ((Buffer)ccbs).clear();
+        ((Buffer)ccus).clear();
 
         //test lead surrogates malform
         ccus.put((char)0xD801); ccus.put((char)0xD802);
         ccbs.put((byte)0x00);
 
-        ccus.limit(ccus.position());
-        ccus.position(0);
-        ccbs.limit(ccbs.position());
-        ccbs.position(0);
+        ((Buffer)ccus).limit(ccus.position());
+        ((Buffer)ccus).position(0);
+        ((Buffer)ccbs).limit(ccbs.position());
+        ((Buffer)ccbs).position(0);
 
         try {
             smBufEncode(encoder, "ISCII-CC-EN-6", ccus, ccbs, true, false);
@@ -3596,17 +3597,17 @@ public class TestCharset extends TestFmw
         catch (Exception ex) {
         }
 
-        ccus.clear();
-        ccbs.clear();
+        ((Buffer)ccus).clear();
+        ((Buffer)ccbs).clear();
 
         //test overflow buffer
         ccus.put((char)0x0901);
         ccbs.put((byte)0x00);
 
-        ccus.limit(ccus.position());
-        ccus.position(0);
-        ccbs.limit(ccbs.position());
-        ccbs.position(0);
+        ((Buffer)ccus).limit(ccus.position());
+        ((Buffer)ccus).position(0);
+        ((Buffer)ccbs).limit(ccbs.position());
+        ((Buffer)ccbs).position(0);
 
         cs = provider.charsetForName("ISCII,version=0");
         encoder = cs.newEncoder();
@@ -3637,27 +3638,27 @@ public class TestCharset extends TestFmw
         bs.put((byte)0x41); bs.put((byte)0x2D); bs.put((byte)0x41);
 
 
-        bs.limit(bs.position());
-        bs.position(0);
-        us.limit(us.position());
-        us.position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
 
         smBufDecode(decoder, "IMAP", bs, us);
         smBufEncode(encoder, "IMAP", us, bs);
 
         //the rest of the code in this method is for better code coverage
-        us.clear();
-        bs.clear();
+        ((Buffer)us).clear();
+        ((Buffer)bs).clear();
 
         //start of charset encoder code coverage
         //test buffer overflow
         us.put((char)0x0026); us.put((char)0x17A9);
         bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00);
 
-        bs.limit(bs.position());
-        bs.position(0);
-        us.limit(us.position());
-        us.position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
 
         try {
             smBufEncode(encoder, "IMAP-EN-1", us, bs, true, false);
@@ -3665,17 +3666,17 @@ public class TestCharset extends TestFmw
         } catch(Exception ex) {
         }
 
-        us.clear();
-        bs.clear();
+        ((Buffer)us).clear();
+        ((Buffer)bs).clear();
 
         //test buffer overflow
         us.put((char)0x17A9); us.put((char)0x0941);
         bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00);
 
-        bs.limit(bs.position());
-        bs.position(0);
-        us.limit(us.position());
-        us.position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
 
         try {
             smBufEncode(encoder, "IMAP-EN-2", us, bs, true, false);
@@ -3683,17 +3684,17 @@ public class TestCharset extends TestFmw
         } catch(Exception ex) {
         }
 
-        us.clear();
-        bs.clear();
+        ((Buffer)us).clear();
+        ((Buffer)bs).clear();
 
         //test buffer overflow
         us.put((char)0x17A9); us.put((char)0x0941);
         bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00);
 
-        bs.limit(bs.position());
-        bs.position(0);
-        us.limit(us.position());
-        us.position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
 
         try {
             smBufEncode(encoder, "IMAP-EN-3", us, bs, true, false);
@@ -3701,18 +3702,18 @@ public class TestCharset extends TestFmw
         } catch(Exception ex) {
         }
 
-        us.clear();
-        bs.clear();
+        ((Buffer)us).clear();
+        ((Buffer)bs).clear();
 
         //test buffer overflow
         us.put((char)0x17A9); us.put((char)0x0941); us.put((char)0x0955);
         bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00);
         bs.put((byte)0x00);
 
-        bs.limit(bs.position());
-        bs.position(0);
-        us.limit(us.position());
-        us.position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
 
         try {
             smBufEncode(encoder, "IMAP-EN-4", us, bs, true, false);
@@ -3720,18 +3721,18 @@ public class TestCharset extends TestFmw
         } catch(Exception ex) {
         }
 
-        us.clear();
-        bs.clear();
+        ((Buffer)us).clear();
+        ((Buffer)bs).clear();
 
         //test buffer overflow
         us.put((char)0x17A9); us.put((char)0x0941); us.put((char)0x0955);
         bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00);
         bs.put((byte)0x00); bs.put((byte)0x00);
 
-        bs.limit(bs.position());
-        bs.position(0);
-        us.limit(us.position());
-        us.position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
 
         try {
             smBufEncode(encoder, "IMAP-EN-5", us, bs, true, false);
@@ -3739,18 +3740,18 @@ public class TestCharset extends TestFmw
         } catch(Exception ex) {
         }
 
-        us.clear();
-        bs.clear();
+        ((Buffer)us).clear();
+        ((Buffer)bs).clear();
 
         //test buffer overflow
         us.put((char)0x17A9); us.put((char)0x0941); us.put((char)0x0955); us.put((char)0x0970);
         bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00);
         bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00);
 
-        bs.limit(bs.position());
-        bs.position(0);
-        us.limit(us.position());
-        us.position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
 
         try {
             smBufEncode(encoder, "IMAP-EN-6", us, bs, true, false);
@@ -3758,18 +3759,18 @@ public class TestCharset extends TestFmw
         } catch(Exception ex) {
         }
 
-        us.clear();
-        bs.clear();
+        ((Buffer)us).clear();
+        ((Buffer)bs).clear();
 
         //test buffer overflow
         us.put((char)0x17A9); us.put((char)0x0941);
         bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00);  bs.put((byte)0x00); bs.put((byte)0x00);
         bs.put((byte)0x00);
 
-        bs.limit(bs.position());
-        bs.position(0);
-        us.limit(us.position());
-        us.position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
 
         try {
             smBufEncode(encoder, "IMAP-EN-7", us, bs, true, true);
@@ -3777,18 +3778,18 @@ public class TestCharset extends TestFmw
         } catch(Exception ex) {
         }
 
-        us.clear();
-        bs.clear();
+        ((Buffer)us).clear();
+        ((Buffer)bs).clear();
 
         //test flushing
         us.put((char)0x17A9); us.put((char)0x0941);
         bs.put((byte)0x26); bs.put((byte)0x46); bs.put((byte)0x36); bs.put((byte)0x6b);  bs.put((byte)0x4a); bs.put((byte)0x51);
         bs.put((byte)0x51); bs.put((byte)0x2d);
 
-        bs.limit(bs.position());
-        bs.position(0);
-        us.limit(us.position());
-        us.position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
 
         try {
             smBufEncode(encoder, "IMAP-EN-8", us, bs, true, true);
@@ -3803,10 +3804,10 @@ public class TestCharset extends TestFmw
         us.put((char)0x0061);
         bs.put((byte)0x61); bs.put((byte)0x00);
 
-        bs.limit(bs.position());
-        bs.position(0);
-        us.limit(us.position());
-        us.position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
 
         try {
             smBufEncode(encoder, "IMAP-EN-9", us, bs, true, true);
@@ -3823,10 +3824,10 @@ public class TestCharset extends TestFmw
         us.put((char)0x0000); us.put((char)0x0000);
         bs.put((byte)0x26); bs.put((byte)0x41); bs.put((byte)0x43); bs.put((byte)0x41);
 
-        bs.limit(bs.position());
-        bs.position(0);
-        us.limit(us.position());
-        us.position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
 
         try {
             smBufDecode(decoder, "IMAP-DE-1", bs, us, true, false);
@@ -3834,18 +3835,18 @@ public class TestCharset extends TestFmw
         } catch(Exception ex) {
         }
 
-        us.clear();
-        bs.clear();
+        ((Buffer)us).clear();
+        ((Buffer)bs).clear();
 
         //test malform case 5
         us.put((char)0x0000); us.put((char)0x0000); us.put((char)0x0000);
         bs.put((byte)0x26); bs.put((byte)0x41); bs.put((byte)0x41); bs.put((byte)0x41);
         bs.put((byte)0x41); bs.put((byte)0x49); bs.put((byte)0x41);
 
-        bs.limit(bs.position());
-        bs.position(0);
-        us.limit(us.position());
-        us.position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
 
         try {
             smBufDecode(decoder, "IMAP-DE-2", bs, us, true, false);
@@ -3853,8 +3854,8 @@ public class TestCharset extends TestFmw
         } catch(Exception ex) {
         }
 
-        us.clear();
-        bs.clear();
+        ((Buffer)us).clear();
+        ((Buffer)bs).clear();
 
         //test malform case 7
         us.put((char)0x0000); us.put((char)0x0000); us.put((char)0x0000); us.put((char)0x0000);
@@ -3862,10 +3863,10 @@ public class TestCharset extends TestFmw
         bs.put((byte)0x41); bs.put((byte)0x41); bs.put((byte)0x41); bs.put((byte)0x42);
         bs.put((byte)0x41);
 
-        bs.limit(bs.position());
-        bs.position(0);
-        us.limit(us.position());
-        us.position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
 
         try {
             smBufDecode(decoder, "IMAP-DE-3", bs, us, true, false);
@@ -3892,10 +3893,10 @@ public class TestCharset extends TestFmw
         us.put((char)0xD901);
         bs.put((byte)0x00);
 
-        bs.limit(bs.position());
-        bs.position(0);
-        us.limit(us.position());
-        us.position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
 
         try {
             smBufEncode(encoder, "UTF32LE-EN-1", us, bs, true, false);
@@ -3903,17 +3904,17 @@ public class TestCharset extends TestFmw
         } catch (Exception ex) {
         }
 
-        bs.clear();
-        us.clear();
+        ((Buffer)bs).clear();
+        ((Buffer)us).clear();
 
         //test malform surrogate
         us.put((char)0xD901); us.put((char)0xD902);
         bs.put((byte)0x00);
 
-        bs.limit(bs.position());
-        bs.position(0);
-        us.limit(us.position());
-        us.position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
 
         result = encoder.encode(us, bs, true);
 
@@ -3921,18 +3922,18 @@ public class TestCharset extends TestFmw
             errln("Error while encoding UTF32LE (2) should have occurred.");
         }
 
-        bs.clear();
-        us.clear();
+        ((Buffer)bs).clear();
+        ((Buffer)us).clear();
 
         //test overflow trail surrogate
         us.put((char)0xDD01); us.put((char)0xDD0E); us.put((char)0xDD0E);
         bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00);
         bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00);
 
-        bs.limit(bs.position());
-        bs.position(0);
-        us.limit(us.position());
-        us.position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
 
         result = encoder.encode(us, bs, true);
 
@@ -3940,17 +3941,17 @@ public class TestCharset extends TestFmw
             errln("Error while encoding UTF32LE (3) should have occurred.");
         }
 
-        bs.clear();
-        us.clear();
+        ((Buffer)bs).clear();
+        ((Buffer)us).clear();
 
         //test malform lead surrogate
         us.put((char)0xD90D); us.put((char)0xD90E);
         bs.put((byte)0x00);
 
-        bs.limit(bs.position());
-        bs.position(0);
-        us.limit(us.position());
-        us.position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
 
         try {
             smBufEncode(encoder, "UTF32LE-EN-4", us, bs, true, false);
@@ -3958,17 +3959,17 @@ public class TestCharset extends TestFmw
         } catch (Exception ex) {
         }
 
-        bs.clear();
-        us.clear();
+        ((Buffer)bs).clear();
+        ((Buffer)us).clear();
 
         //test overflow buffer
         us.put((char)0x0061);
         bs.put((byte)0x00);
 
-        bs.limit(bs.position());
-        bs.position(0);
-        us.limit(us.position());
-        us.position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
 
         try {
             smBufEncode(encoder, "UTF32LE-EN-5", us, bs, true, false);
@@ -3976,17 +3977,17 @@ public class TestCharset extends TestFmw
         } catch (Exception ex) {
         }
 
-        bs.clear();
-        us.clear();
+        ((Buffer)bs).clear();
+        ((Buffer)us).clear();
 
         //test malform trail surrogate
         us.put((char)0xDD01);
         bs.put((byte)0x00);
 
-        bs.limit(bs.position());
-        bs.position(0);
-        us.limit(us.position());
-        us.position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
 
         try {
             smBufEncode(encoder, "UTF32LE-EN-6", us, bs, true, false);
@@ -4021,10 +4022,10 @@ public class TestCharset extends TestFmw
         us.put(u_pts1);
         bs.put(b_pts1);
 
-        us.limit(1);
-        us.position(0);
-        bs.limit(1);
-        bs.position(0);
+        ((Buffer)us).limit(1);
+        ((Buffer)us).position(0);
+        ((Buffer)bs).limit(1);
+        ((Buffer)bs).position(0);
 
         result = encoder.encode(us, bs, true);
 
@@ -4034,10 +4035,10 @@ public class TestCharset extends TestFmw
         }
 
         // Test for malform surrogate from previous buffer
-        us.limit(4);
-        us.position(1);
-        bs.limit(7);
-        bs.position(1);
+        ((Buffer)us).limit(4);
+        ((Buffer)us).position(1);
+        ((Buffer)bs).limit(7);
+        ((Buffer)bs).position(1);
 
         result = encoder.encode(us, bs, true);
 
@@ -4048,17 +4049,17 @@ public class TestCharset extends TestFmw
         // Test for malform trail surrogate
         encoder.reset();
 
-        us.limit(1);
-        us.position(0);
-        bs.limit(1);
-        bs.position(0);
+        ((Buffer)us).limit(1);
+        ((Buffer)us).position(0);
+        ((Buffer)bs).limit(1);
+        ((Buffer)bs).position(0);
 
         result = encoder.encode(us, bs, true);
 
-        us.limit(6);
-        us.position(4);
-        bs.limit(4);
-        bs.position(1);
+        ((Buffer)us).limit(6);
+        ((Buffer)us).position(4);
+        ((Buffer)bs).limit(4);
+        ((Buffer)bs).position(1);
 
         result = encoder.encode(us, bs, true);
 
@@ -4099,10 +4100,10 @@ public class TestCharset extends TestFmw
         us.put(us_array);
         bs.put(bs_array1);
 
-        us.limit(us.position());
-        us.position(0);
-        bs.limit(bs.position());
-        bs.position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
 
         try {
             smBufDecode(decoder, "UTF32-DE-1", bs, us, true, false);
@@ -4115,10 +4116,10 @@ public class TestCharset extends TestFmw
         bs = ByteBuffer.allocate(bs_array2.length);
         bs.put(bs_array2);
 
-        us.limit(4);
-        us.position(0);
-        bs.limit(bs.position());
-        bs.position(0);
+        ((Buffer)us).limit(4);
+        ((Buffer)us).position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
 
         try {
             smBufDecode(decoder, "UTF32-DE-2", bs, us, true, false);
@@ -4128,16 +4129,16 @@ public class TestCharset extends TestFmw
         }
 
         //Test malform exception
-        bs.clear();
-        us.clear();
+        ((Buffer)bs).clear();
+        ((Buffer)us).clear();
 
         bs.put((byte)0x00); bs.put((byte)0xFE); bs.put((byte)0xFF); bs.put((byte)0x00); bs.put((byte)0x00);
         us.put((char)0x0000);
 
-        us.limit(us.position());
-        us.position(0);
-        bs.limit(bs.position());
-        bs.position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
 
         try {
             smBufDecode(decoder, "UTF32-DE-3", bs, us, true, false);
@@ -4146,16 +4147,16 @@ public class TestCharset extends TestFmw
         }
 
         //Test BOM testing
-        bs.clear();
-        us.clear();
+        ((Buffer)bs).clear();
+        ((Buffer)us).clear();
 
         bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0xFF); bs.put((byte)0xFE);
         us.put((char)0x0000);
 
-        us.limit(us.position());
-        us.position(0);
-        bs.limit(bs.position());
-        bs.position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
 
         try {
             smBufDecode(decoder, "UTF32-DE-4", bs, us, true, false);
@@ -4173,10 +4174,10 @@ public class TestCharset extends TestFmw
         us.put((char)0xDC01);
         bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00);
 
-        us.limit(us.position());
-        us.position(0);
-        bs.limit(bs.position());
-        bs.position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
 
         result = encoder.encode(us, bs, true);
         // must try to output BOM first for UTF-32 (not UTF-32BE or UTF-32LE)
@@ -4184,86 +4185,86 @@ public class TestCharset extends TestFmw
             errln("Buffer overflow error while encoding UTF32 charset (1) should have occurred.");
         }
 
-        us.clear();
-        bs.clear();
+        ((Buffer)us).clear();
+        ((Buffer)bs).clear();
 
         //test malform surrogate and store value in fromChar32
         us.put((char)0xD801); us.put((char)0xD802);
         bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00);
 
-        us.limit(us.position());
-        us.position(0);
-        bs.limit(bs.position());
-        bs.position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
 
         result = encoder.encode(us, bs, true);
         if (!result.isMalformed()) {
             errln("Malformed error while encoding UTF32 charset (2) should have occurred.");
         }
 
-        us.clear();
-        bs.clear();
+        ((Buffer)us).clear();
+        ((Buffer)bs).clear();
 
         //test malform surrogate
         us.put((char)0x0000); us.put((char)0xD902);
 
-        us.limit(us.position());
-        us.position(0);
-        bs.limit(bs.position());
-        bs.position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
 
         result = encoder.encode(us, bs, true);
         if (!result.isOverflow()) {
             errln("Overflow error while encoding UTF32 charset (3) should have occurred.");
         }
 
-        us.clear();
-        bs.clear();
+        ((Buffer)us).clear();
+        ((Buffer)bs).clear();
 
         //test malform surrogate
         encoder.reset();
         us.put((char)0xD801);
         bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00);
 
-        us.limit(us.position());
-        us.position(0);
-        bs.limit(bs.position());
-        bs.position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
 
         result = encoder.encode(us, bs, true);
         if (!result.isMalformed()) {
             errln("Malform error while encoding UTF32 charset (4) should have occurred.");
         }
 
-        us.clear();
-        bs.clear();
+        ((Buffer)us).clear();
+        ((Buffer)bs).clear();
 
         //test overflow surrogate
         us.put((char)0x0000); us.put((char)0xDDE1); us.put((char)0xD915); us.put((char)0xDDF2);
         bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00);
 
-        us.limit(us.position());
-        us.position(0);
-        bs.limit(bs.position());
-        bs.position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
 
         result = encoder.encode(us, bs, true);
         if (!result.isOverflow()) {
             errln("Overflow error while encoding UTF32 charset (5) should have occurred.");
         }
 
-        us.clear();
-        bs.clear();
+        ((Buffer)us).clear();
+        ((Buffer)bs).clear();
 
         //test malform surrogate
         encoder.reset();
         us.put((char)0xDDE1);
         bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00);
 
-        us.limit(us.position());
-        us.position(0);
-        bs.limit(bs.position());
-        bs.position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
 
         result = encoder.encode(us, bs, true);
         if (!result.isMalformed()) {
@@ -4287,10 +4288,10 @@ public class TestCharset extends TestFmw
         bs.put((byte)0x41); bs.put((byte)0xFF); bs.put((byte)0x01); bs.put((byte)0x00);
         us.put((char)0x0000);
 
-        us.limit(us.position());
-        us.position(0);
-        bs.limit(bs.position());
-        bs.position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
 
         try {
             smBufDecode(decoder, "UTF-32LE", bs, us, true, false);
@@ -4298,8 +4299,8 @@ public class TestCharset extends TestFmw
         } catch (Exception ex) {
         }
         // test overflow buffer handling in CharsetDecoderICU
-        bs.position(0);
-        us.position(0);
+        ((Buffer)bs).position(0);
+        ((Buffer)us).position(0);
         decoder.reset();
         result = decoder.decode(bs, us, true);
         if (result.isOverflow()) {
@@ -4311,16 +4312,16 @@ public class TestCharset extends TestFmw
             errln("Overflow buffer error while decoding UTF32LE should have occurred.");
         }
 
-        us.clear();
-        bs.clear();
+        ((Buffer)us).clear();
+        ((Buffer)bs).clear();
         //test malform buffer
         bs.put((byte)0x02); bs.put((byte)0xD9); bs.put((byte)0x00); bs.put((byte)0x00);
         us.put((char)0x0000);
 
-        us.limit(us.position());
-        us.position(0);
-        bs.limit(bs.position());
-        bs.position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
 
         try {
             smBufDecode(decoder, "UTF-32LE", bs, us, true, false);
@@ -4328,17 +4329,17 @@ public class TestCharset extends TestFmw
         } catch (Exception ex) {
         }
 
-        us.clear();
-        bs.clear();
+        ((Buffer)us).clear();
+        ((Buffer)bs).clear();
         //test malform buffer
         bs.put((byte)0xFF); bs.put((byte)0xFE); bs.put((byte)0x00); bs.put((byte)0x00);
         bs.put((byte)0xFF); bs.put((byte)0xDF); bs.put((byte)0x10);
         us.put((char)0x0000);
 
-        us.limit(us.position());
-        us.position(0);
-        bs.limit(bs.position());
-        bs.position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
 
         try {
             // must flush in order to exhibit malformed behavior
@@ -4347,17 +4348,17 @@ public class TestCharset extends TestFmw
         } catch (Exception ex) {
         }
 
-        us.clear();
-        bs.clear();
+        ((Buffer)us).clear();
+        ((Buffer)bs).clear();
         //test malform buffer
         bs.put((byte)0xFF); bs.put((byte)0xFE); bs.put((byte)0x00); bs.put((byte)0x00);
         bs.put((byte)0x02); bs.put((byte)0xD9); bs.put((byte)0x00); bs.put((byte)0x00);
         us.put((char)0x0000);
 
-        us.limit(us.position());
-        us.position(0);
-        bs.limit(bs.position());
-        bs.position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
 
         try {
             smBufDecode(decoder, "UTF-32LE", bs, us, true, false);
@@ -4365,17 +4366,17 @@ public class TestCharset extends TestFmw
         } catch (Exception ex) {
         }
 
-        us.clear();
-        bs.clear();
+        ((Buffer)us).clear();
+        ((Buffer)bs).clear();
         //test overflow buffer
         bs.put((byte)0xFF); bs.put((byte)0xFE); bs.put((byte)0x00); bs.put((byte)0x00);
         bs.put((byte)0xDD); bs.put((byte)0xFF); bs.put((byte)0x10); bs.put((byte)0x00);
         us.put((char)0x0000);
 
-        us.limit(us.position());
-        us.position(0);
-        bs.limit(bs.position());
-        bs.position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
 
         try {
             smBufDecode(decoder, "UTF-32LE", bs, us, true, false);
@@ -4384,8 +4385,8 @@ public class TestCharset extends TestFmw
         }
         //end of decode UTF32LE
 
-        bs.clear();
-        us.clear();
+        ((Buffer)bs).clear();
+        ((Buffer)us).clear();
 
         //decode UTF32BE
         decoder = provider.charsetForName("UTF-32BE").newDecoder();
@@ -4393,10 +4394,10 @@ public class TestCharset extends TestFmw
         bs.put((byte)0x00); bs.put((byte)0x01); bs.put((byte)0xFF); bs.put((byte)0x41);
         us.put((char)0x0000);
 
-        us.limit(us.position());
-        us.position(0);
-        bs.limit(bs.position());
-        bs.position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
 
         try {
             smBufDecode(decoder, "UTF-32BE", bs, us, true, false);
@@ -4404,16 +4405,16 @@ public class TestCharset extends TestFmw
         } catch (Exception ex) {
         }
 
-        bs.clear();
-        us.clear();
+        ((Buffer)bs).clear();
+        ((Buffer)us).clear();
         //test malform buffer
         bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0xD9); bs.put((byte)0x02);
         us.put((char)0x0000);
 
-        us.limit(us.position());
-        us.position(0);
-        bs.limit(bs.position());
-        bs.position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
 
         try {
             smBufDecode(decoder, "UTF-32BE", bs, us, true, false);
@@ -4421,17 +4422,17 @@ public class TestCharset extends TestFmw
         } catch (Exception ex) {
         }
 
-        bs.clear();
-        us.clear();
+        ((Buffer)bs).clear();
+        ((Buffer)us).clear();
         //test malform buffer
         bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0xFE); bs.put((byte)0xFF);
         bs.put((byte)0x10); bs.put((byte)0xFF); bs.put((byte)0xDF);
         us.put((char)0x0000);
 
-        us.limit(us.position());
-        us.position(0);
-        bs.limit(bs.position());
-        bs.position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
 
         try {
             // must flush to exhibit malformed behavior
@@ -4440,17 +4441,17 @@ public class TestCharset extends TestFmw
         } catch (Exception ex) {
         }
 
-        bs.clear();
-        us.clear();
+        ((Buffer)bs).clear();
+        ((Buffer)us).clear();
         //test overflow buffer
         bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0xFE); bs.put((byte)0xFF);
         bs.put((byte)0x00); bs.put((byte)0x10); bs.put((byte)0xFF); bs.put((byte)0xDD);
         us.put((char)0x0000);
 
-        us.limit(us.position());
-        us.position(0);
-        bs.limit(bs.position());
-        bs.position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
 
         try {
             smBufDecode(decoder, "UTF-32BE", bs, us, true, false);
@@ -4458,16 +4459,16 @@ public class TestCharset extends TestFmw
         } catch (Exception ex) {
         }
 
-        bs.clear();
-        us.clear();
+        ((Buffer)bs).clear();
+        ((Buffer)us).clear();
         //test malform buffer
         bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0xFE);
         us.put((char)0x0000);
 
-        us.limit(us.position());
-        us.position(0);
-        bs.limit(bs.position());
-        bs.position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
 
         try {
             // must flush to exhibit malformed behavior
@@ -4502,10 +4503,10 @@ public class TestCharset extends TestFmw
         limit_us = us.position();
         limit_bs = bs.position();
 
-        us.limit(limit_us);
-        us.position(0);
-        bs.limit(limit_bs);
-        bs.position(0);
+        ((Buffer)us).limit(limit_us);
+        ((Buffer)us).position(0);
+        ((Buffer)bs).limit(limit_bs);
+        ((Buffer)bs).position(0);
         bs2 = bs.asReadOnlyBuffer();
         us2 = us.asReadOnlyBuffer();
 
@@ -4514,18 +4515,18 @@ public class TestCharset extends TestFmw
             errln("Error while decoding UTF-8 (1) should not have occured.");
         }
 
-        us2.limit(limit_us);
-        us2.position(0);
-        bs.limit(limit_bs);
-        bs.position(0);
+        ((Buffer)us2).limit(limit_us);
+        ((Buffer)us2).position(0);
+        ((Buffer)bs).limit(limit_bs);
+        ((Buffer)bs).position(0);
 
         result = encoder.encode(us2, bs, true);
         if (!result.isUnderflow() || !equals(bs, bs2)) {
             errln("Error while encoding UTF-8 (1) should not have occured.");
         }
 
-        us.clear();
-        bs.clear();
+        ((Buffer)us).clear();
+        ((Buffer)bs).clear();
 
         //test overflow buffer while encoding
         //readonly buffer
@@ -4534,10 +4535,10 @@ public class TestCharset extends TestFmw
         bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00);
         limit_us = us.position();
         us2 = us.asReadOnlyBuffer();
-        us2.limit(limit_us);
-        us2.position(0);
-        bs.limit(1);
-        bs.position(0);
+        ((Buffer)us2).limit(limit_us);
+        ((Buffer)us2).position(0);
+        ((Buffer)bs).limit(1);
+        ((Buffer)bs).position(0);
         result = encoder.encode(us2, bs, true);
         if (!result.isOverflow()) {
             errln("Overflow Error should have occured while encoding UTF-8 (2).");
@@ -4545,10 +4546,10 @@ public class TestCharset extends TestFmw
 
         encoder.reset();
 
-        us2.limit(limit_us);
-        us2.position(1);
-        bs.limit(1);
-        bs.position(0);
+        ((Buffer)us2).limit(limit_us);
+        ((Buffer)us2).position(1);
+        ((Buffer)bs).limit(1);
+        ((Buffer)bs).position(0);
         result = encoder.encode(us2, bs, true);
         if (!result.isOverflow()) {
             errln("Overflow Error should have occured while encoding UTF-8 (3).");
@@ -4556,10 +4557,10 @@ public class TestCharset extends TestFmw
 
         encoder.reset();
 
-        us2.limit(limit_us);
-        us2.position(1);
-        bs.limit(2);
-        bs.position(0);
+        ((Buffer)us2).limit(limit_us);
+        ((Buffer)us2).position(1);
+        ((Buffer)bs).limit(2);
+        ((Buffer)bs).position(0);
         result = encoder.encode(us2, bs, true);
         if (!result.isOverflow()) {
             errln("Overflow Error should have occured while encoding UTF-8 (4).");
@@ -4567,10 +4568,10 @@ public class TestCharset extends TestFmw
 
         encoder.reset();
 
-        us2.limit(limit_us);
-        us2.position(0);
-        bs.limit(2);
-        bs.position(0);
+        ((Buffer)us2).limit(limit_us);
+        ((Buffer)us2).position(0);
+        ((Buffer)bs).limit(2);
+        ((Buffer)bs).position(0);
         result = encoder.encode(us2, bs, true);
         if (!result.isOverflow()) {
             errln("Overflow Error should have occured while encoding UTF-8 (5).");
@@ -4579,10 +4580,10 @@ public class TestCharset extends TestFmw
         //not readonly buffer
         encoder.reset();
 
-        us.limit(limit_us);
-        us.position(0);
-        bs.limit(1);
-        bs.position(0);
+        ((Buffer)us).limit(limit_us);
+        ((Buffer)us).position(0);
+        ((Buffer)bs).limit(1);
+        ((Buffer)bs).position(0);
         result = encoder.encode(us, bs, true);
         if (!result.isOverflow()) {
             errln("Overflow Error should have occured while encoding UTF-8 (6).");
@@ -4590,10 +4591,10 @@ public class TestCharset extends TestFmw
 
         encoder.reset();
 
-        us.limit(limit_us);
-        us.position(0);
-        bs.limit(3);
-        bs.position(0);
+        ((Buffer)us).limit(limit_us);
+        ((Buffer)us).position(0);
+        ((Buffer)bs).limit(3);
+        ((Buffer)bs).position(0);
         result = encoder.encode(us, bs, true);
         if (!result.isOverflow()) {
             errln("Overflow Error should have occured while encoding UTF-8 (7).");
@@ -4601,10 +4602,10 @@ public class TestCharset extends TestFmw
 
         encoder.reset();
 
-        us.limit(limit_us);
-        us.position(1);
-        bs.limit(2);
-        bs.position(0);
+        ((Buffer)us).limit(limit_us);
+        ((Buffer)us).position(1);
+        ((Buffer)bs).limit(2);
+        ((Buffer)bs).position(0);
         result = encoder.encode(us, bs, true);
         if (!result.isOverflow()) {
             errln("Overflow Error should have occured while encoding UTF-8 (8).");
@@ -4612,17 +4613,17 @@ public class TestCharset extends TestFmw
 
         encoder.reset();
 
-        us.limit(limit_us + 1);
-        us.position(1);
-        bs.limit(3);
-        bs.position(0);
+        ((Buffer)us).limit(limit_us + 1);
+        ((Buffer)us).position(1);
+        ((Buffer)bs).limit(3);
+        ((Buffer)bs).position(0);
         result = encoder.encode(us, bs, true);
         if (!result.isOverflow()) {
             errln("Overflow Error should have occured while encoding UTF-8 (9).");
         }
 
-        us.clear();
-        bs.clear();
+        ((Buffer)us).clear();
+        ((Buffer)bs).clear();
 
         //test encoding 4 byte characters
         encoder.reset();
@@ -4630,10 +4631,10 @@ public class TestCharset extends TestFmw
         bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00); bs.put((byte)0x00);
         limit_us = us.position();
         us2 = us.asReadOnlyBuffer();
-        us2.limit(limit_us);
-        us2.position(0);
-        bs.limit(1);
-        bs.position(0);
+        ((Buffer)us2).limit(limit_us);
+        ((Buffer)us2).position(0);
+        ((Buffer)bs).limit(1);
+        ((Buffer)bs).position(0);
         result = encoder.encode(us2, bs, true);
         if (!result.isOverflow()) {
             errln("Overflow Error should have occured while encoding UTF-8 (10).");
@@ -4641,10 +4642,10 @@ public class TestCharset extends TestFmw
 
         encoder.reset();
 
-        us2.limit(limit_us);
-        us2.position(0);
-        bs.limit(2);
-        bs.position(0);
+        ((Buffer)us2).limit(limit_us);
+        ((Buffer)us2).position(0);
+        ((Buffer)bs).limit(2);
+        ((Buffer)bs).position(0);
         result = encoder.encode(us2, bs, true);
         if (!result.isOverflow()) {
             errln("Overflow Error should have occured while encoding UTF-8 (11).");
@@ -4652,10 +4653,10 @@ public class TestCharset extends TestFmw
 
         encoder.reset();
 
-        us2.limit(limit_us);
-        us2.position(0);
-        bs.limit(3);
-        bs.position(0);
+        ((Buffer)us2).limit(limit_us);
+        ((Buffer)us2).position(0);
+        ((Buffer)bs).limit(3);
+        ((Buffer)bs).position(0);
         result = encoder.encode(us2, bs, true);
         if (!result.isOverflow()) {
             errln("Overflow Error should have occured while encoding UTF-8 (12).");
@@ -4663,17 +4664,17 @@ public class TestCharset extends TestFmw
 
         encoder.reset();
 
-        us2.limit(limit_us);
-        us2.position(0);
-        bs.limit(4);
-        bs.position(0);
+        ((Buffer)us2).limit(limit_us);
+        ((Buffer)us2).position(0);
+        ((Buffer)bs).limit(4);
+        ((Buffer)bs).position(0);
         result = encoder.encode(us2, bs, true);
         if (!result.isOverflow()) {
             errln("Overflow Error should have occured while encoding UTF-8 (13).");
         }
 
-        us.clear();
-        bs.clear();
+        ((Buffer)us).clear();
+        ((Buffer)bs).clear();
 
         //decoding code coverage
         //test malform error
@@ -4682,10 +4683,10 @@ public class TestCharset extends TestFmw
         us.put((char)0x0000);
         bs2 = bs.asReadOnlyBuffer();
 
-        us.limit(1);
-        us.position(0);
-        bs2.limit(1);
-        bs2.position(0);
+        ((Buffer)us).limit(1);
+        ((Buffer)us).position(0);
+        ((Buffer)bs2).limit(1);
+        ((Buffer)bs2).position(0);
 
         result = decoder.decode(bs2, us, true);
         result = decoder.flush(us);
@@ -4693,68 +4694,68 @@ public class TestCharset extends TestFmw
             errln("Malform error should have occurred while decoding UTF-8 (1).");
         }
 
-        us.limit(1);
-        us.position(0);
-        bs2.limit(1);
-        bs2.position(0);
+        ((Buffer)us).limit(1);
+        ((Buffer)us).position(0);
+        ((Buffer)bs2).limit(1);
+        ((Buffer)bs2).position(0);
 
         decoder.reset();
 
         result = decoder.decode(bs2, us, true);
-        us.limit(1);
-        us.position(0);
-        bs2.limit(2);
-        bs2.position(0);
+        ((Buffer)us).limit(1);
+        ((Buffer)us).position(0);
+        ((Buffer)bs2).limit(2);
+        ((Buffer)bs2).position(0);
         result = decoder.decode(bs2, us, true);
         if (!result.isMalformed()) {
             errln("Malform error should have occurred while decoding UTF-8 (2).");
         }
 
-        us.clear();
-        bs.clear();
+        ((Buffer)us).clear();
+        ((Buffer)bs).clear();
 
         //test overflow buffer
         bs.put((byte)0x01); bs.put((byte)0x41);
         us.put((char)0x0000);
         bs2 = bs.asReadOnlyBuffer();
-        us.limit(1);
-        us.position(0);
-        bs2.limit(2);
-        bs2.position(0);
+        ((Buffer)us).limit(1);
+        ((Buffer)us).position(0);
+        ((Buffer)bs2).limit(2);
+        ((Buffer)bs2).position(0);
 
         result = decoder.decode(bs2, us, true);
         if (!result.isOverflow()) {
             errln("Overflow error should have occurred while decoding UTF-8 (3).");
         }
 
-        us.clear();
-        bs.clear();
+        ((Buffer)us).clear();
+        ((Buffer)bs).clear();
 
         //test malform string
         decoder.reset();
         bs.put((byte)0xF5); bs.put((byte)0xB4); bs.put((byte)0x8A); bs.put((byte)0x8C);
         us.put((char)0x0000);
         bs2 = bs.asReadOnlyBuffer();
-        us.limit(1);
-        us.position(0);
-        bs2.limit(4);
-        bs2.position(0);
+        ((Buffer)us).limit(1);
+        ((Buffer)us).position(0);
+        ((Buffer)bs2).limit(4);
+        ((Buffer)bs2).position(0);
 
         result = decoder.decode(bs2, us, true);
         if (!result.isMalformed()) {
             errln("Malform error should have occurred while decoding UTF-8 (4).");
         }
 
-        bs.clear();
+        ((Buffer)bs).clear();
 
         //test overflow
         decoder.reset();
         bs.put((byte)0xF3); bs.put((byte)0xB4); bs.put((byte)0x8A); bs.put((byte)0x8C);
         bs2 = bs.asReadOnlyBuffer();
-        us.limit(1);
-        us.position(0);
-        bs2.limit(4);
-        bs2.position(0);
+        ((Buffer)us).limit(1);
+        ((Buffer)us).position(0);
+        ((Buffer)bs2).limit(4);
+        ((Buffer)bs2).position(0);
 
         result = decoder.decode(bs2, us, true);
         if (!result.isOverflow()) {
@@ -4763,10 +4764,10 @@ public class TestCharset extends TestFmw
 
         //test overflow
         decoder.reset();
-        us.limit(2);
-        us.position(0);
-        bs2.limit(5);
-        bs2.position(0);
+        ((Buffer)us).limit(2);
+        ((Buffer)us).position(0);
+        ((Buffer)bs2).limit(5);
+        ((Buffer)bs2).position(0);
 
         result = decoder.decode(bs2, us, true);
         if (!result.isOverflow()) {
@@ -4775,25 +4776,25 @@ public class TestCharset extends TestFmw
 
         //test overflow
         decoder.reset();
-        us.limit(1);
-        us.position(0);
-        bs.limit(5);
-        bs.position(0);
+        ((Buffer)us).limit(1);
+        ((Buffer)us).position(0);
+        ((Buffer)bs).limit(5);
+        ((Buffer)bs).position(0);
 
         result = decoder.decode(bs, us, true);
         if (!result.isOverflow()) {
             errln("Overflow error should have occurred while decoding UTF-8 (6).");
         }
 
-        bs.clear();
+        ((Buffer)bs).clear();
 
         //test overflow
         decoder.reset();
         bs.put((byte)0x41); bs.put((byte)0x42);
-        us.limit(1);
-        us.position(0);
-        bs.limit(2);
-        bs.position(0);
+        ((Buffer)us).limit(1);
+        ((Buffer)us).position(0);
+        ((Buffer)bs).limit(2);
+        ((Buffer)bs).position(0);
 
         result = decoder.decode(bs, us, true);
         if (!result.isOverflow()) {
@@ -4817,10 +4818,10 @@ public class TestCharset extends TestFmw
         bs.put((byte)0xFF);
         us.put((char)0x0000);
 
-        us.limit(us.position());
-        us.position(0);
-        bs.limit(bs.position());
-        bs.position(0);
+        ((Buffer)us).limit(us.position());
+        ((Buffer)us).position(0);
+        ((Buffer)bs).limit(bs.position());
+        ((Buffer)bs).position(0);
 
         result = decoder.decode(bs, us, true);
         result = decoder.flush(us);
@@ -4828,28 +4829,28 @@ public class TestCharset extends TestFmw
             errln("Malform error while decoding UTF-16 should have occurred.");
         }
 
-        us.clear();
-        bs.clear();
+        ((Buffer)us).clear();
+        ((Buffer)bs).clear();
 
         us.put((char)0xD902); us.put((char)0xDD01); us.put((char)0x0041);
 
-        us.limit(1);
-        us.position(0);
-        bs.limit(4);
-        bs.position(0);
+        ((Buffer)us).limit(1);
+        ((Buffer)us).position(0);
+        ((Buffer)bs).limit(4);
+        ((Buffer)bs).position(0);
 
         result = encoder.encode(us, bs, true);
-        us.limit(3);
-        us.position(0);
-        bs.limit(3);
-        bs.position(0);
+        ((Buffer)us).limit(3);
+        ((Buffer)us).position(0);
+        ((Buffer)bs).limit(3);
+        ((Buffer)bs).position(0);
         result = encoder.encode(us, bs, true);
         if (!result.isOverflow()) {
             errln("Overflow buffer while encoding UTF-16 should have occurred.");
         }
 
-        us.clear();
-        bs.clear();
+        ((Buffer)us).clear();
+        ((Buffer)bs).clear();
 
         //test overflow buffer
         decoder.reset();
@@ -4857,10 +4858,10 @@ public class TestCharset extends TestFmw
 
         bs.put((byte)0xFF); bs.put((byte)0xFE); bs.put((byte)0x41);
 
-        us.limit(0);
-        us.position(0);
-        bs.limit(3);
-        bs.position(0);
+        ((Buffer)us).limit(0);
+        ((Buffer)us).position(0);
+        ((Buffer)bs).limit(3);
+        ((Buffer)bs).position(0);
 
         result = decoder.decode(bs, us, true);
         if (!result.isOverflow()) {
@@ -5111,20 +5112,20 @@ public class TestCharset extends TestFmw
         ByteBuffer bb = ByteBuffer.wrap(bytearray);
         CharBuffer cb = CharBuffer.allocate(10);
 
-        bb.limit(4);
-        cb.limit(1); // Overflow should occur and is expected
+        ((Buffer)bb).limit(4);
+        ((Buffer)cb).limit(1); // Overflow should occur and is expected
         result = decoder.decode(bb, cb, false);
         if (result.isError()) {
             errln("Error occurred while decoding: " + charsetName + " with error: " + result);
         }
 
-        bb.limit(8);
+        ((Buffer)bb).limit(8);
         result = decoder.decode(bb, cb, false);
         if (result.isError()) {
             errln("Error occurred while decoding: " + charsetName + " with error: " + result);
         }
 
-        bb.limit(12);
+        ((Buffer)bb).limit(12);
         result = decoder.decode(bb, cb, true);
         if (result.isError()) {
             errln("Error occurred while decoding: " + charsetName + " with error: " + result);
@@ -5139,18 +5140,18 @@ public class TestCharset extends TestFmw
         cb = CharBuffer.wrap(chararray);
         bb = ByteBuffer.allocate(10);
 
-        bb.limit(2);
-        cb.limit(4);
+        ((Buffer)bb).limit(2);
+        ((Buffer)cb).limit(4);
         result = encoder.encode(cb, bb, false);
         if (result.isError()) {
             errln("Error occurred while encoding: " + charsetName + " with error: " + result);
         }
-        cb.limit(5);
+        ((Buffer)cb).limit(5);
         result = encoder.encode(cb, bb, false);
         if (result.isError()) {
             errln("Error occurred while encoding: " + charsetName + " with error: " + result);
         }
-        cb.limit(6);
+        ((Buffer)cb).limit(6);
         result = encoder.encode(cb, bb, true);
         if (!result.isError()) {
             errln("Error should have occurred while encoding: " + charsetName);
@@ -5337,21 +5338,21 @@ public class TestCharset extends TestFmw
             CharBuffer ubuf = CharBuffer.wrap(ccSrc[i]);
             encode.reset();
             decode.reset();
-            trgt.clear();
-            test.clear();
+            ((Buffer)trgt).clear();
+            ((Buffer)test).clear();
             ccResult = encode.encode(ubuf, trgt, true);
             if (ccResult.isError()) {
                 errln("Error while encoding " + charset.name() + " in test for code coverage[" + i + "].");
             } else {
-                trgt.limit(trgt.position());
-                trgt.position(0);
+                ((Buffer)trgt).limit(trgt.position());
+                ((Buffer)trgt).position(0);
                 ccResult = decode.decode(trgt, test, true);
                 if (ccResult.isError()) {
                     errln("Error while decoding " + charset.name() + " in test for code coverage[" + i + "].");
                 } else {
-                    ubuf.position(0);
-                    test.limit(test.position());
-                    test.position(0);
+                    ((Buffer)ubuf).position(0);
+                    ((Buffer)test).limit(test.position());
+                    ((Buffer)test).position(0);
                     if (!equals(test, ubuf)) {
                         errln("Roundtrip failed for " + charset.name() + " in test for code coverage[" + i + "].");
                     }
@@ -5513,7 +5514,7 @@ public class TestCharset extends TestFmw
             // Decoding
             CharBuffer decoderResult = decode.decode(decoderBuffer);
 
-            encoderBuffer.position(0);
+           ((Buffer)encoderBuffer).position(0);
             if(!decoderResult.equals(encoderBuffer)){
                 errln("Error occured while decoding "+ charset.name());
             }
@@ -5523,7 +5524,7 @@ public class TestCharset extends TestFmw
             ByteBuffer roundTrip = encoderResult;
             CharBuffer roundTripResult = decode.decode(roundTrip);
 
-            encoderBuffer.position(0);
+            ((Buffer)encoderBuffer).position(0);
             if(!roundTripResult.equals(encoderBuffer)){
                 errln("Error occured while encoding "+ charset.name());
             }
@@ -5647,10 +5648,10 @@ public class TestCharset extends TestFmw
         for (int n = 0; n < malformedLimits.length; n++) {
             malformedDecoderTest.reset();
 
-            malformedSrc.position(0);
-            malformedSrc.limit(malformedLimits[n]);
+            ((Buffer)malformedSrc).position(0);
+            ((Buffer)malformedSrc).limit(malformedLimits[n]);
 
-            malformedTrgt.clear();
+            ((Buffer)malformedTrgt).clear();
 
             malformedResult = malformedDecoderTest.decode(malformedSrc,malformedTrgt, true);
             if (!malformedResult.isMalformed()) {
@@ -5684,8 +5685,8 @@ public class TestCharset extends TestFmw
             }
             CharsetDecoder decoder = charset.newDecoder();
 
-            src.position(0);
-            trgt.clear();
+            ((Buffer)src).position(0);
+            ((Buffer)trgt).clear();
 
             result = decoder.decode(src, trgt, true);
             if (result.isError()) {
@@ -5785,14 +5786,14 @@ public class TestCharset extends TestFmw
         CharBuffer charBuffer = CharBuffer.allocate(firstLine.length() + secondLine.length());
         charBuffer.put(firstLine);
         charBuffer.put(secondLine);
-        charBuffer.flip();
+        ((Buffer)charBuffer).flip();
 
         for (int i = 0; i < charsetNames.length; i++) {
             encoder =  CharsetICU.forNameICU(charsetNames[i]).newEncoder();
 
-            charBuffer.position(firstLine.length());
+            ((Buffer)charBuffer).position(firstLine.length());
             CharBuffer charBufferSlice = charBuffer.slice();
-            charBufferSlice.limit(secondLine.length() - 2);
+            ((Buffer)charBufferSlice).limit(secondLine.length() - 2);
 
 
             try {
--- a/main/tests/charset/src/com/ibm/icu/dev/test/charset/TestConversion.java	2021-10-28 00:02:09.000000000 -0600
+++ b/main/tests/charset/src/com/ibm/icu/dev/test/charset/TestConversion.java	2021-10-29 08:08:50.800614014 -0600
@@ -9,6 +9,7 @@
 
 package com.ibm.icu.dev.test.charset;
 
+import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.nio.CharBuffer;
 import java.nio.charset.Charset;
@@ -337,13 +338,13 @@ public class TestConversion extends Test
 
             try {
                 out = encoder.encode(CharBuffer.wrap(cc.unicode.toCharArray()));
-                out.position(out.limit());
+                ((Buffer)out).position(out.limit());
                 if (out.limit() != out.capacity() || cc.finalFlush) {
                     int pos = out.position();
                     byte[] temp = out.array();
                     out = ByteBuffer.allocate(temp.length * 4);
                     out.put(temp);
-                    out.position(pos);
+                    ((Buffer)out).position(pos);
                     CoderResult cr = encoder.flush(out);
                     if (cr.isOverflow()) {
                         logln("Overflow error with flushing encoder");
@@ -391,8 +392,8 @@ public class TestConversion extends Test
         CoderResult cr = null;
 
         for (;;) {
-            source.limit(currentSourceLimit);
-            target.limit(currentTargetLimit);
+            ((Buffer)source).limit(currentSourceLimit);
+            ((Buffer)target).limit(currentTargetLimit);
 
             cr = encoder.encode(source, target, currentSourceLimit == sourceLen);
 
@@ -404,8 +405,8 @@ public class TestConversion extends Test
                     }
                     // Do a final flush for cleanup, then break out
                     // Encode loop, exits with cr==underflow in normal operation.
-                    //target.limit(targetLen);
-                    target.limit(targetLen);
+                    //((Buffer)target).limit(targetLen);
+                    ((Buffer)target).limit(targetLen);
                     cr = encoder.flush(target);
                     if (cr.isUnderflow()) {
                         // good
@@ -631,15 +632,15 @@ public class TestConversion extends Test
             CharBuffer out = null;
 
             try {
-                cc.bytes.rewind();
+                ((Buffer)cc.bytes).rewind();
                 out = decoder.decode(cc.bytes);
-                out.position(out.limit());
+                ((Buffer)out).position(out.limit());
                 if (out.limit() < cc.unicode.length()) {
                     int pos = out.position();
                     char[] temp = out.array();
                     out = CharBuffer.allocate(cc.bytes.limit());
                     out.put(temp);
-                    out.position(pos);
+                    ((Buffer)out).position(pos);
                     CoderResult cr = decoder.flush(out);
                     if (cr.isOverflow()) {
                         logln("Overflow error with flushing decodering");
@@ -677,9 +678,9 @@ public class TestConversion extends Test
         int sourceLen;
         source = cc.bytes;
         sourceLen = cc.bytes.limit();
-        source.position(0);
+        ((Buffer)source).position(0);
         target = CharBuffer.allocate(cc.unicode.length() + 4);
-        target.position(0);
+        ((Buffer)target).position(0);
         cc.toUnicodeResult = null;
         decoder.reset();
 
@@ -691,15 +692,15 @@ public class TestConversion extends Test
             for (;;) {
 
                 if (step != 0) {
-                    source.limit((iStep <= sourceLen) ? iStep : sourceLen);
-                    target.limit((oStep <= target.capacity()) ? oStep : target
+                    ((Buffer)source).limit((iStep <= sourceLen) ? iStep : sourceLen);
+                    ((Buffer)target).limit((oStep <= target.capacity()) ? oStep : target
                             .capacity());
                     flush = (cc.finalFlush && source.limit() == sourceLen);
 
                 } else {
                     //bulk mode
-                    source.limit(sourceLen);
-                    target.limit(target.capacity());
+                    ((Buffer)source).limit(sourceLen);
+                    ((Buffer)target).limit(target.capacity());
                     flush = cc.finalFlush;
                 }
                 // convert
@@ -711,7 +712,7 @@ public class TestConversion extends Test
                     if (cr.isOverflow()) {
                         // the partial target is filled, set a new limit,
                         oStep = (target.position() + step);
-                        target.limit((oStep < target.capacity()) ? oStep
+                        ((Buffer)target).limit((oStep < target.capacity()) ? oStep
                                 : target.capacity());
                         if (target.limit() > target.capacity()) {
                             //target has reached its limit, an error occurred or test case has an error code
@@ -736,7 +737,7 @@ public class TestConversion extends Test
                         //due to limitation of the API we need to check for target limit for expected
                         if (target.position() != cc.unicode.length()) {
                             if (target.limit() != cc.unicode.length()) {
-                                target.limit(cc.unicode.length());
+                                ((Buffer)target).limit(cc.unicode.length());
                             }
                             cr = decoder.flush(target);
                             if (cr.isError()) {
@@ -765,14 +766,14 @@ public class TestConversion extends Test
                 // convert
                 if ((step & 1) != 0 /* odd: -1, -3, -5, ... */) {
 
-                    target.limit(target.position() < target.capacity() ? target
+                    ((Buffer)target).limit(target.position() < target.capacity() ? target
                             .position() + 1 : target.capacity());
 
                     // decode behavior is return to output target 1 character
                     CoderResult cr = null;
 
                     //similar to getNextUChar() , input is the whole string, while outputs only 1 character
-                    source.limit(sourceLen);
+                    ((Buffer)source).limit(sourceLen);
                     while (target.position() != target.limit()
                             && source.hasRemaining()) {
                         cr = decoder.decode(source, target,
@@ -786,7 +787,7 @@ public class TestConversion extends Test
                                 break;
                             } else {
                                 //1 character has been consumed
-                                target.limit(target.position() + 1);
+                                ((Buffer)target).limit(target.position() + 1);
                                 break;
                             }
                         } else if (cr.isError()) {
@@ -801,7 +802,7 @@ public class TestConversion extends Test
                         else {
                             // one character has been consumed
                             if (target.limit() == target.position()) {
-                                target.limit(target.position() + 1);
+                                ((Buffer)target).limit(target.position() + 1);
                                 break;
                             }
                         }
@@ -814,7 +815,7 @@ public class TestConversion extends Test
                         cr = decoder.decode(source, target, true);
                         if (target.position() != cc.unicode.length()) {
 
-                            target.limit(cc.unicode.length());
+                            ((Buffer)target).limit(cc.unicode.length());
                             cr = decoder.flush(target);
                             if (cr.isError()) {
                                 errln("Flush operation failed");
@@ -829,14 +830,14 @@ public class TestConversion extends Test
                 } else {/* step is even */
                     // allow only one UChar output
 
-                    target.limit(target.position() < target.capacity() ? target
+                    ((Buffer)target).limit(target.position() < target.capacity() ? target
                             .position() + 1 : target.capacity());
                     if (step == -2) {
-                        source.limit(sourceLen);
+                        ((Buffer)source).limit(sourceLen);
                     } else {
-                        source.limit(source.position() + (-step - 2) / 2);
+                        ((Buffer)source).limit(source.position() + (-step - 2) / 2);
                         if (source.limit() > sourceLen) {
-                            source.limit(sourceLen);
+                            ((Buffer)source).limit(sourceLen);
                         }
                     }
                     CoderResult cr = decoder.decode(source, target, source
@@ -1003,43 +1004,43 @@ public class TestConversion extends Test
         if (start[0] == (byte) 0xFE && start[1] == (byte) 0xFF) {
             signatureLength = 2;
             sigUniCharset = "UTF-16BE";
-            source.position(signatureLength);
+            ((Buffer)source).position(signatureLength);
             return sigUniCharset;
         } else if (start[0] == (byte) 0xFF && start[1] == (byte) 0xFE) {
             if (start[2] == (byte) 0x00 && start[3] == (byte) 0x00) {
                 signatureLength = 4;
                 sigUniCharset = "UTF-32LE";
-                source.position(signatureLength);
+                ((Buffer)source).position(signatureLength);
                 return sigUniCharset;
             } else {
                 signatureLength = 2;
                 sigUniCharset = "UTF-16LE";
-                source.position(signatureLength);
+                ((Buffer)source).position(signatureLength);
                 return sigUniCharset;
             }
         } else if (start[0] == (byte) 0xEF && start[1] == (byte) 0xBB
                 && start[2] == (byte) 0xBF) {
             signatureLength = 3;
             sigUniCharset = "UTF-8";
-            source.position(signatureLength);
+            ((Buffer)source).position(signatureLength);
             return sigUniCharset;
         } else if (start[0] == (byte) 0x00 && start[1] == (byte) 0x00
                 && start[2] == (byte) 0xFE && start[3] == (byte) 0xFF) {
             signatureLength = 4;
             sigUniCharset = "UTF-32BE";
-            source.position(signatureLength);
+            ((Buffer)source).position(signatureLength);
             return sigUniCharset;
         } else if (start[0] == (byte) 0x0E && start[1] == (byte) 0xFE
                 && start[2] == (byte) 0xFF) {
             signatureLength = 3;
             sigUniCharset = "SCSU";
-            source.position(signatureLength);
+            ((Buffer)source).position(signatureLength);
             return sigUniCharset;
         } else if (start[0] == (byte) 0xFB && start[1] == (byte) 0xEE
                 && start[2] == (byte) 0x28) {
             signatureLength = 3;
             sigUniCharset = "BOCU-1";
-            source.position(signatureLength);
+            ((Buffer)source).position(signatureLength);
             return sigUniCharset;
         } else if (start[0] == (byte) 0x2B && start[1] == (byte) 0x2F
                 && start[2] == (byte) 0x76) {
@@ -1047,20 +1048,20 @@ public class TestConversion extends Test
             if (start[3] == (byte) 0x38 && start[4] == (byte) 0x2D) {
                 signatureLength = 5;
                 sigUniCharset = "UTF-7";
-                source.position(signatureLength);
+                ((Buffer)source).position(signatureLength);
                 return sigUniCharset;
             } else if (start[3] == (byte) 0x38 || start[3] == (byte) 0x39
                     || start[3] == (byte) 0x2B || start[3] == (byte) 0x2F) {
                 signatureLength = 4;
                 sigUniCharset = "UTF-7";
-                source.position(signatureLength);
+                ((Buffer)source).position(signatureLength);
                 return sigUniCharset;
             }
         } else if (start[0] == (byte) 0xDD && start[2] == (byte) 0x73
                 && start[2] == (byte) 0x66 && start[3] == (byte) 0x73) {
             signatureLength = 4;
             sigUniCharset = "UTF-EBCDIC";
-            source.position(signatureLength);
+            ((Buffer)source).position(signatureLength);
             return sigUniCharset;
         }
 
@@ -1074,7 +1075,7 @@ public class TestConversion extends Test
         for (int i = 0; i < pos; i++) {
             res += "(" + i + ")" + hex(buf.get(i) & 0xff).substring(2) + " ";
         }
-        buf.position(cur);
+        ((Buffer)buf).position(cur);
         return res + "]";
     }
 
@@ -1084,7 +1085,7 @@ public class TestConversion extends Test
         for (int i = 0; i < pos; i++) {
             res += "(" + i + ")" + hex(buf.get(i)) + " ";
         }
-        buf.position(cur);
+        ((Buffer)buf).position(cur);
         return res + "]";
     }
 
@@ -1092,9 +1093,9 @@ public class TestConversion extends Test
             ByteBuffer output) {
 
         boolean res = true;
-        expected.rewind();
-        output.limit(output.position());
-        output.rewind();
+        ((Buffer)expected).rewind();
+        ((Buffer)output).limit(output.position());
+        ((Buffer)output).rewind();
 
         // remove any BOM signature before checking
         if (!cc.charset.contains("UnicodeLittle") && !cc.charset.contains("UnicodeBig")) {
@@ -1137,8 +1138,8 @@ public class TestConversion extends Test
     private boolean checkResultsToUnicode(ConversionCase cc, String expected, CharBuffer output) {
 
         boolean res = true;
-        output.limit(output.position());
-        output.rewind();
+        ((Buffer)output).limit(output.position());
+        ((Buffer)output).rewind();
 
         // test to see if the conversion matches actual results
         if (output.limit() != expected.length()) {
--- a/main/tests/core/src/com/ibm/icu/dev/test/util/ICUBinaryTest.java	2021-10-28 00:02:10.000000000 -0600
+++ b/main/tests/core/src/com/ibm/icu/dev/test/util/ICUBinaryTest.java	2021-10-29 08:08:50.800614014 -0600
@@ -10,6 +10,7 @@
 package com.ibm.icu.dev.test.util;
 
 import java.io.IOException;
+import java.nio.Buffer;
 import java.nio.ByteBuffer;
 
 import org.junit.Test;
@@ -88,7 +89,7 @@ public final class ICUBinaryTest extends
         }
         // no restriction to the data version
         try {
-            bytes.rewind();
+            ((Buffer)bytes).rewind();
             ICUBinary.readHeader(bytes, formatid, null);
         } catch (IOException e) {
             errln("Failed: Null authenticate object should pass ICUBinary.readHeader");
@@ -96,7 +97,7 @@ public final class ICUBinaryTest extends
         // lenient data version
         array[17] = 9;
         try {
-            bytes.rewind();
+            ((Buffer)bytes).rewind();
             ICUBinary.readHeader(bytes, formatid, authenticate);
         } catch (IOException e) {
             errln("Failed: Lenient authenticate object should pass ICUBinary.readHeader");
@@ -104,7 +105,7 @@ public final class ICUBinaryTest extends
         // changing the version to an incorrect one, expecting failure
         array[16] = 2;
         try {
-            bytes.rewind();
+            ((Buffer)bytes).rewind();
             ICUBinary.readHeader(bytes, formatid, authenticate);
             errln("Failed: Invalid version number should not pass authenticate object");
         } catch (IOException e) {
--- a/perf-tests/src/com/ibm/icu/dev/test/perf/ConverterPerformanceTest.java	2021-10-28 00:02:10.000000000 -0600
+++ b/perf-tests/src/com/ibm/icu/dev/test/perf/ConverterPerformanceTest.java	2021-10-29 08:08:50.801614013 -0600
@@ -13,6 +13,7 @@ import java.io.ByteArrayOutputStream;
 import java.io.FileInputStream;
 import java.io.InputStreamReader;
 import java.io.OutputStreamWriter;
+import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.nio.CharBuffer;
 import java.nio.charset.Charset;
@@ -214,8 +215,8 @@ public class ConverterPerformanceTest ex
                     try{
                         decoder.decode(srcBuf,outBuf,false);
                         decoder.reset();
-                        srcBuf.rewind();
-                        outBuf.rewind();
+                        ((Buffer)srcBuf).rewind();
+                        ((Buffer)outBuf).rewind();
                     }catch(Exception e){
                         e.printStackTrace();
                         throw new RuntimeException(e.getMessage());
@@ -243,8 +244,8 @@ public class ConverterPerformanceTest ex
                     try{
                         encoder.encode(srcBuf,outBuf,false);
                         encoder.reset();
-                        srcBuf.rewind();
-                        outBuf.rewind();
+                        ((Buffer)srcBuf).rewind();
+                        ((Buffer)outBuf).rewind();
                     }catch(Exception e){
                         e.printStackTrace();
                         throw new RuntimeException(e.getMessage());
@@ -272,8 +273,8 @@ public class ConverterPerformanceTest ex
                     try{
                         decoder.decode(srcBuf,outBuf,false);
                         decoder.reset();
-                        srcBuf.rewind();
-                        outBuf.rewind();
+                        ((Buffer)srcBuf).rewind();
+                        ((Buffer)outBuf).rewind();
                     }catch(Exception e){
                         e.printStackTrace();
                         throw new RuntimeException(e.getMessage());
@@ -301,8 +302,8 @@ public class ConverterPerformanceTest ex
                     try{
                         encoder.encode(srcBuf,outBuf,false);
                         encoder.reset();
-                        srcBuf.rewind();
-                        outBuf.rewind();
+                        ((Buffer)srcBuf).rewind();
+                        ((Buffer)outBuf).rewind();
                     }catch(Exception e){
                         e.printStackTrace();
                         throw new RuntimeException(e.getMessage());
