From 5f803e68beee9f71c12c112ccda872997919f9cc Mon Sep 17 00:00:00 2001
From: Richard Biener <rguenther@suse.de>
Date: Wed, 10 May 2023 15:36:12 +0200
Subject: [PATCH 1/4] Avoid g++.dg/torture/pr106922.C FAIL with the pre-C++11
 ABI
To: gcc-patches@gcc.gnu.org

The following forces the g++.dg/torture/pr106922.C testcase to use
the C++11 libstdc++ ABI and checks whether that worked.

gcc/testsuite/
	* g++.dg/torture/pr106922.C: Force _GLIBCXX_USE_CXX11_ABI to 1.

(cherry picked from commit a056a9868e6ecab24b0b7e4e12e846097b8c8fb0)
---
 gcc/testsuite/g++.dg/torture/pr106922.C | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/gcc/testsuite/g++.dg/torture/pr106922.C b/gcc/testsuite/g++.dg/torture/pr106922.C
index 046fc6cce76..b0c1489fbdc 100644
--- a/gcc/testsuite/g++.dg/torture/pr106922.C
+++ b/gcc/testsuite/g++.dg/torture/pr106922.C
@@ -4,8 +4,16 @@
 // -O1 doesn't iterate VN and thus has bogus uninit diagnostics
 // { dg-skip-if "" { *-*-* } { "-O1" } { "" } }
 
+// The testcase still emits bogus diagnostics with the pre-C++11 ABI
+#undef _GLIBCXX_USE_CXX11_ABI
+#define _GLIBCXX_USE_CXX11_ABI 1
+
 #include <vector>
 
+// When the library is not dual-ABI and defaults to old just compile
+// an empty TU
+#if _GLIBCXX_USE_CXX11_ABI
+
 #include <optional>
 template <class T>
 using Optional = std::optional<T>;
@@ -46,3 +54,4 @@ void test()
         externals.external2 = internal2;
     }
 }
+#endif
-- 
2.35.3


From 35ca946985773e0fa49624d37323e0338a39c5f3 Mon Sep 17 00:00:00 2001
From: Richard Biener <rguenther@suse.de>
Date: Thu, 11 May 2023 09:13:31 +0200
Subject: [PATCH 3/4] testsuite/108776 - avoid c-c++-common/rotate-11.c FAIL
To: gcc-patches@gcc.gnu.org

On the branch ranger isn't powerful enough to handle some cases
appearing with logical-op-non-short-circuit evaluating to false
causing FAILs of the testcase for ppc64le and s390x.  The following
foces logical-op-non-short-circuit to true for this testcase
on the branch.

	PR testsuite/108776
	* c-c++-common/rotate-11.c: Add --param logical-op-non-short-circuit=1.
---
 gcc/testsuite/c-c++-common/rotate-11.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/gcc/testsuite/c-c++-common/rotate-11.c b/gcc/testsuite/c-c++-common/rotate-11.c
index e57db19d949..85cde2786e2 100644
--- a/gcc/testsuite/c-c++-common/rotate-11.c
+++ b/gcc/testsuite/c-c++-common/rotate-11.c
@@ -1,6 +1,6 @@
 /* PR tree-optimization/108440 */
 /* { dg-do compile { target { { ilp32 || lp64 } || llp64 } } } */
-/* { dg-options "-O2 -fdump-tree-optimized" } */
+/* { dg-options "-O2 -fdump-tree-optimized --param logical-op-non-short-circuit=1" } */
 /* { dg-final { scan-tree-dump-times " r<< " 5 "optimized" } } */
 /* { dg-final { scan-tree-dump-times " \\\& 7;" 4 "optimized" } } */
 
-- 
2.35.3


From 7b4ab70f2d7182f119bc927f15876a3178c0cc14 Mon Sep 17 00:00:00 2001
From: Richard Biener <rguenther@suse.de>
Date: Thu, 11 May 2023 09:30:52 +0200
Subject: [PATCH 4/4] Fix gcc.dg/vect/pr108950.c
To: gcc-patches@gcc.gnu.org

The following puts the dg-require-effective-target properly after
the dg-do.

	* gcc.dg/vect/pr108950.c: Re-order dg-require-effective-target
	and dg-do.
---
 gcc/testsuite/gcc.dg/vect/pr108950.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/gcc/testsuite/gcc.dg/vect/pr108950.c b/gcc/testsuite/gcc.dg/vect/pr108950.c
index ecf076c964b..563c4b9df38 100644
--- a/gcc/testsuite/gcc.dg/vect/pr108950.c
+++ b/gcc/testsuite/gcc.dg/vect/pr108950.c
@@ -1,5 +1,5 @@
-/* { dg-require-effective-target vect_simd_clones } */
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_simd_clones } */
 
 int m;
 short int n;
-- 
2.35.3

From 16a76499f916b5b6d11bccc03cc0d16b2b1ee31b Mon Sep 17 00:00:00 2001
From: Jonathan Wakely <jwakely@redhat.com>
Date: Wed, 16 Nov 2022 12:22:04 +0000
Subject: [PATCH] libstdc++: Fix std::any pretty printer
To: gcc-patches@gcc.gnu.org

The recent changes to FilteringTypePrinter affect the result of
gdb.lookup_type('std::string') in StdExpAnyPrinter, causing it to always
return the std::__cxx11::basic_string specialization. This then causes a
gdb.error exception when trying to lookup the std::any manager type for
a specialization using that string, but that manager was never
instantiated in the program. This causes FAILs when running the tests
with -D_GLIBCXX_USE_CXX11_ABI=0:

FAIL: libstdc++-prettyprinters/libfundts.cc print as
FAIL: libstdc++-prettyprinters/libfundts.cc print as

The ugly solution used in this patch is to repeat the lookup for every
type that std::string could be a typedef for, and hope it only works for
one of them.

libstdc++-v3/ChangeLog:

	* python/libstdcxx/v6/printers.py (StdExpAnyPrinter): Make
	expansion of std::string in manager name more robust.

(cherry picked from commit 3c54805d03ac1bcc3d8547ffb5e6c4e1f301a7a2)
---
 libstdc++-v3/python/libstdcxx/v6/printers.py | 31 ++++++++++++++++++--
 1 file changed, 28 insertions(+), 3 deletions(-)

diff --git a/libstdc++-v3/python/libstdcxx/v6/printers.py b/libstdc++-v3/python/libstdcxx/v6/printers.py
index bb06a4959ee..d27a25bd96f 100644
--- a/libstdc++-v3/python/libstdcxx/v6/printers.py
+++ b/libstdc++-v3/python/libstdcxx/v6/printers.py
@@ -1216,9 +1216,34 @@ class StdExpAnyPrinter(SingleObjContainerPrinter):
             mgrname = m.group(1)
             # FIXME need to expand 'std::string' so that gdb.lookup_type works
             if 'std::string' in mgrname:
-                mgrname = re.sub("std::string(?!\w)", str(gdb.lookup_type('std::string').strip_typedefs()), m.group(1))
-
-            mgrtype = gdb.lookup_type(mgrname)
+                # This lookup for std::string might return the __cxx11 version,
+                # but that's not necessarily the one used by the std::any
+                # manager function we're trying to find.
+                strings = {str(gdb.lookup_type('std::string').strip_typedefs())}
+                # So also consider all the other possible std::string types!
+                s = 'basic_string<char, std::char_traits<char>, std::allocator<char> >'
+                quals = ['std::', 'std::__cxx11::', 'std::' + _versioned_namespace]
+                strings |= {q+s for q in quals} # set of unique strings
+                mgrtypes = []
+                for s in strings:
+                    try:
+                        x = re.sub("std::string(?!\w)", s, m.group(1))
+                        # The following lookup might raise gdb.error if the
+                        # manager function was never instantiated for 's' in the
+                        # program, because there will be no such type.
+                        mgrtypes.append(gdb.lookup_type(x))
+                    except gdb.error:
+                        pass
+                if len(mgrtypes) != 1:
+                    # FIXME: this is unlikely in practice, but possible for
+                    # programs that use both old and new string types with
+                    # std::any in a single program. Can we do better?
+                    # Maybe find the address of each type's _S_manage and
+                    # compare to the address stored in _M_manager?
+                    raise ValueError('Cannot uniquely determine std::string type used in std::any')
+                mgrtype = mgrtypes[0]
+            else:
+                mgrtype = gdb.lookup_type(mgrname)
             self.contained_type = mgrtype.template_argument(0)
             valptr = None
             if '::_Manager_internal' in mgrname:
-- 
2.35.3

