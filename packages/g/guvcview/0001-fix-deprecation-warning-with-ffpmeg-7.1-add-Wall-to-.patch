From 150c054fe971e282515f4d13e42a061096bfdd6e Mon Sep 17 00:00:00 2001
From: Paulo Assis <pj.assis@gmail.com>
Date: Sat, 16 Nov 2024 20:04:52 +0000
Subject: [PATCH 1/2] fix deprecation warning with ffpmeg 7.1; add -Wall to
 compile flags

---
 guvcview/CMakeLists.txt        |   2 +
 gview_audio/CMakeLists.txt     |   2 +
 gview_encoder/CMakeLists.txt   |   2 +
 gview_encoder/audio_codecs.c   | 818 ++++++++++++++++-----------------
 gview_encoder/encoder.c        |  74 ++-
 gview_render/CMakeLists.txt    |   1 +
 gview_render/render_fx.c       |  53 ++-
 gview_render/render_sdl2.c     |   3 +-
 gview_render/render_sfml.cpp   |   4 +-
 gview_v4l2core/CMakeLists.txt  |   2 +
 gview_v4l2core/colorspaces.c   |   6 +-
 gview_v4l2core/frame_decoder.c |   2 +-
 gview_v4l2core/jpeg_decoder.c  |  34 +-
 gview_v4l2core/v4l2_controls.c |   2 +-
 14 files changed, 513 insertions(+), 492 deletions(-)

diff --git a/guvcview/CMakeLists.txt b/guvcview/CMakeLists.txt
index bb501bf..e087b64 100644
--- a/guvcview/CMakeLists.txt
+++ b/guvcview/CMakeLists.txt
@@ -18,6 +18,8 @@ add_executable(guvcview
   video_capture.c
 )
 
+add_definitions("-Wall")
+
 if(USE_GTK3)
   pkg_check_modules(GTK3 gtk+-3.0)
   if(GTK3_FOUND)
diff --git a/gview_audio/CMakeLists.txt b/gview_audio/CMakeLists.txt
index 9714745..6217ef9 100644
--- a/gview_audio/CMakeLists.txt
+++ b/gview_audio/CMakeLists.txt
@@ -18,6 +18,8 @@ set_target_properties(
   SOVERSION ${LIBSOVERSION}
 )
 
+add_definitions("-Wall")
+
 pkg_check_modules(PORTAUDIO2 REQUIRED portaudio-2.0)
 
 target_link_libraries(gviewaudio ${PORTAUDIO2_LIBRARIES})
diff --git a/gview_encoder/CMakeLists.txt b/gview_encoder/CMakeLists.txt
index 8942bae..dfd7c38 100644
--- a/gview_encoder/CMakeLists.txt
+++ b/gview_encoder/CMakeLists.txt
@@ -22,6 +22,8 @@ set_target_properties(
   SOVERSION ${LIBSOVERSION}
 )
 
+add_definitions("-Wall")
+
 pkg_check_modules(FFMPEG REQUIRED libavcodec libavutil)
 
 target_link_libraries(gviewencoder ${FFMPEG_LIBRARIES})
diff --git a/gview_encoder/audio_codecs.c b/gview_encoder/audio_codecs.c
index 5c9f764..6965df8 100644
--- a/gview_encoder/audio_codecs.c
+++ b/gview_encoder/audio_codecs.c
@@ -1,204 +1,195 @@
-/*******************************************************************************#
-#           guvcview              http://guvcview.sourceforge.net               #
-#                                                                               #
-#           Paulo Assis <pj.assis@gmail.com>                                    #
-#                                                                               #
-# This program is free software; you can redistribute it and/or modify          #
-# it under the terms of the GNU General Public License as published by          #
-# the Free Software Foundation; either version 2 of the License, or             #
-# (at your option) any later version.                                           #
-#                                                                               #
-# This program is distributed in the hope that it will be useful,               #
-# but WITHOUT ANY WARRANTY; without even the implied warranty of                #
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 #
-# GNU General Public License for more details.                                  #
-#                                                                               #
-# You should have received a copy of the GNU General Public License             #
-# along with this program; if not, write to the Free Software                   #
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA     #
-#                                                                               #
-********************************************************************************/
+/******************************************************************************#
+#           guvcview              http://guvcview.sourceforge.net              #
+#                                                                              #
+#           Paulo Assis <pj.assis@gmail.com>                                   #
+#                                                                              #
+# This program is free software; you can redistribute it and/or modify         #
+# it under the terms of the GNU General Public License as published by         #
+# the Free Software Foundation; either version 2 of the License, or            #
+# (at your option) any later version.                                          #
+#                                                                              #
+# This program is distributed in the hope that it will be useful,              #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
+# GNU General Public License for more details.                                 #
+#                                                                              #
+# You should have received a copy of the GNU General Public License            #
+# along with this program; if not, write to the Free Software                  #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
+#                                                                              #
+*******************************************************************************/
 
-#include <stdlib.h>
+#include <assert.h>
+#include <errno.h>
+#include <fcntl.h>
 #include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
 #include <sys/types.h>
 #include <unistd.h>
-#include <fcntl.h>
-#include <string.h>
-#include <errno.h>
-#include <assert.h>
 /* support for internationalization - i18n */
-#include <locale.h>
 #include <libintl.h>
+#include <locale.h>
 
-#include "gviewencoder.h"
-#include "gview.h"
 #include "encoder.h"
+#include "gview.h"
+#include "gviewencoder.h"
 
 extern int enc_verbosity;
 
 /* AAC object types index: MAIN = 1; LOW = 2; SSR = 3; LTP = 4*/
-static int AAC_OBJ_TYPE[5] =
-	{ FF_PROFILE_UNKNOWN, FF_PROFILE_AAC_MAIN, FF_PROFILE_AAC_LOW, FF_PROFILE_AAC_SSR, FF_PROFILE_AAC_LTP };
+static int AAC_OBJ_TYPE[5] = {FF_PROFILE_UNKNOWN, FF_PROFILE_AAC_MAIN,
+                              FF_PROFILE_AAC_LOW, FF_PROFILE_AAC_SSR,
+                              FF_PROFILE_AAC_LTP};
 /*-1 = reserved; 0 = freq. is writen explictly (increases header by 24 bits)*/
-static int AAC_SAMP_FREQ[16] =
-	{ 96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350, -1, -1, 0};
+static int AAC_SAMP_FREQ[16] = {96000, 88200, 64000, 48000, 44100, 32000,
+                                24000, 22050, 16000, 12000, 11025, 8000,
+                                7350,  -1,    -1,    0};
 
 /*NORMAL AAC HEADER*/
-/*2 bytes: object type index(5 bits) + sample frequency index(4bits) + channels(4 bits) + flags(3 bit) */
+/*2 bytes: object type index(5 bits) + sample frequency index(4bits) +
+ * channels(4 bits) + flags(3 bit) */
 /*default = MAIN(1)+44100(4)+stereo(2)+flags(0) = 0x0A10*/
-static uint8_t AAC_ESDS[2] = {0x0A,0x10};
+static uint8_t AAC_ESDS[2] = {0x0A, 0x10};
 /* if samprate index == 15 AAC_ESDS[5]:
- * object type index(5 bits) + sample frequency index(4bits) + samprate(24bits) + channels(4 bits) + flags(3 bit)
+ * object type index(5 bits) + sample frequency index(4bits) + samprate(24bits)
+ * + channels(4 bits) + flags(3 bit)
  */
 
-
-static audio_codec_t listSupCodecs[] = //list of software supported formats
-{
-	{
-		.valid        = 1,
-		.bits         = 32,
-    .monotonic_pts = 0,
-		.avi_4cc      = WAVE_FORMAT_IEEE_FLOAT,
-		.mkv_codec    = "A_PCM/FLOAT/IEEE",
-		.description  = N_("PCM - uncompressed (float 32 bit)"),
-		.bit_rate     = 0,
-		.codec_id     = AV_CODEC_ID_PCM_F32LE,
-		.codec_name   = "pcm_f32le",
-		.sample_format = AV_SAMPLE_FMT_FLT,
-		.profile      = FF_PROFILE_UNKNOWN,
-		.mkv_codpriv  = NULL,
-		.codpriv_size = 0,
-		.flags        = 0,
-		.name         = "pcm"
-	},
-	{
-		.valid        = 1,
-		.bits         = 0,
-		.monotonic_pts= 0,
-		.avi_4cc      = WAVE_FORMAT_MPEG12,
-		.mkv_codec    = "A_MPEG/L2",
-		.description  = N_("MP2 (MPEG audio layer 2)"),
-		.bit_rate     = 160000,
-		.codec_id     = AV_CODEC_ID_MP2,
-		.codec_name   = "mp2",
-		.sample_format = AV_SAMPLE_FMT_S16,
-		.profile      = FF_PROFILE_UNKNOWN,
-		.mkv_codpriv  = NULL,
-		.codpriv_size = 0,
-		.flags        = 0,
-		.name         = "mp2"
-	},
-	{
-		.valid        = 1,
-		.bits         = 0,
-		.monotonic_pts= 0,
-		.avi_4cc      = WAVE_FORMAT_MP3,
-		.mkv_codec    = "A_MPEG/L3",
-		.description  = N_("MP3 (MPEG audio layer 3)"),
-		.bit_rate     = 160000,
-		.codec_id     = AV_CODEC_ID_MP3,
-		.codec_name   = "libmp3lame",
-#if LIBAVCODEC_VER_AT_LEAST(54,31)
-		.sample_format = AV_SAMPLE_FMT_FLTP,
+static audio_codec_t listSupCodecs[] = // list of software supported formats
+    {{.valid = 1,
+      .bits = 32,
+      .monotonic_pts = 0,
+      .avi_4cc = WAVE_FORMAT_IEEE_FLOAT,
+      .mkv_codec = "A_PCM/FLOAT/IEEE",
+      .description = N_("PCM - uncompressed (float 32 bit)"),
+      .bit_rate = 0,
+      .codec_id = AV_CODEC_ID_PCM_F32LE,
+      .codec_name = "pcm_f32le",
+      .sample_format = AV_SAMPLE_FMT_FLT,
+      .profile = FF_PROFILE_UNKNOWN,
+      .mkv_codpriv = NULL,
+      .codpriv_size = 0,
+      .flags = 0,
+      .name = "pcm"},
+     {.valid = 1,
+      .bits = 0,
+      .monotonic_pts = 0,
+      .avi_4cc = WAVE_FORMAT_MPEG12,
+      .mkv_codec = "A_MPEG/L2",
+      .description = N_("MP2 (MPEG audio layer 2)"),
+      .bit_rate = 160000,
+      .codec_id = AV_CODEC_ID_MP2,
+      .codec_name = "mp2",
+      .sample_format = AV_SAMPLE_FMT_S16,
+      .profile = FF_PROFILE_UNKNOWN,
+      .mkv_codpriv = NULL,
+      .codpriv_size = 0,
+      .flags = 0,
+      .name = "mp2"},
+     {.valid = 1,
+      .bits = 0,
+      .monotonic_pts = 0,
+      .avi_4cc = WAVE_FORMAT_MP3,
+      .mkv_codec = "A_MPEG/L3",
+      .description = N_("MP3 (MPEG audio layer 3)"),
+      .bit_rate = 160000,
+      .codec_id = AV_CODEC_ID_MP3,
+      .codec_name = "libmp3lame",
+#if LIBAVCODEC_VER_AT_LEAST(54, 31)
+      .sample_format = AV_SAMPLE_FMT_FLTP,
 #else
-		.sample_format = AV_SAMPLE_FMT_S16,
+      .sample_format = AV_SAMPLE_FMT_S16,
 #endif
-		.profile      = FF_PROFILE_UNKNOWN,
-		.mkv_codpriv  = NULL,
-		.codpriv_size = 0,
-		.flags        = 0,
-		.name         = "mp3"
-	},
-	{
-		.valid        = 1,
-		.bits         = 0,
-		.monotonic_pts= 0,
-		.avi_4cc      = WAVE_FORMAT_AC3,
-		.mkv_codec    = "A_AC3",
-		.description  = N_("AC-3 (ATSC A/52A)"),
-		.bit_rate     = 160000,
-		.codec_id     = AV_CODEC_ID_AC3,
-		.codec_name   = "ac3",
-#if LIBAVCODEC_VER_AT_LEAST(54,31)
-		.sample_format = AV_SAMPLE_FMT_FLTP,
+      .profile = FF_PROFILE_UNKNOWN,
+      .mkv_codpriv = NULL,
+      .codpriv_size = 0,
+      .flags = 0,
+      .name = "mp3"},
+     {.valid = 1,
+      .bits = 0,
+      .monotonic_pts = 0,
+      .avi_4cc = WAVE_FORMAT_AC3,
+      .mkv_codec = "A_AC3",
+      .description = N_("AC-3 (ATSC A/52A)"),
+      .bit_rate = 160000,
+      .codec_id = AV_CODEC_ID_AC3,
+      .codec_name = "ac3",
+#if LIBAVCODEC_VER_AT_LEAST(54, 31)
+      .sample_format = AV_SAMPLE_FMT_FLTP,
 #else
-		.sample_format = AV_SAMPLE_FMT_FLT,
+      .sample_format = AV_SAMPLE_FMT_FLT,
 #endif
-		.profile      = FF_PROFILE_UNKNOWN,
-		.mkv_codpriv  = NULL,
-		.codpriv_size = 0,
-		.flags        = 0,
-		.name         = "ac3"
-	},
-	{
-		.valid        = 1,
-		.bits         = 16,
-		.monotonic_pts= 0,
-		.avi_4cc      = WAVE_FORMAT_AAC,
-		.mkv_codec    = "A_AAC",
-		.description  = N_("AAC (Advanced Audio Coding)"),
-		.bit_rate     = 64000,
-		.codec_id     = AV_CODEC_ID_AAC,
-		.codec_name   = "libvo_aacenc",
-#if LIBAVCODEC_VER_AT_LEAST(54,31)
-		.sample_format = AV_SAMPLE_FMT_FLTP,
+      .profile = FF_PROFILE_UNKNOWN,
+      .mkv_codpriv = NULL,
+      .codpriv_size = 0,
+      .flags = 0,
+      .name = "ac3"},
+     {.valid = 1,
+      .bits = 16,
+      .monotonic_pts = 0,
+      .avi_4cc = WAVE_FORMAT_AAC,
+      .mkv_codec = "A_AAC",
+      .description = N_("AAC (Advanced Audio Coding)"),
+      .bit_rate = 64000,
+      .codec_id = AV_CODEC_ID_AAC,
+      .codec_name = "libvo_aacenc",
+#if LIBAVCODEC_VER_AT_LEAST(54, 31)
+      .sample_format = AV_SAMPLE_FMT_FLTP,
 #else
-		.sample_format = AV_SAMPLE_FMT_S16,
+      .sample_format = AV_SAMPLE_FMT_S16,
 #endif
-		.profile      = FF_PROFILE_AAC_LOW,
-		.mkv_codpriv  = AAC_ESDS,
-		.codpriv_size = 2,
-		.flags        = 0,
-		.name         = "aac"
-	},
-	{
-		.valid        = 1,
-		.bits         = 16,
-		.monotonic_pts= 0,
-		.avi_4cc      = OGG_FORMAT_VORBIS,
-		.mkv_codec    = "A_VORBIS",
-		.description  = N_("Vorbis"),
-		.bit_rate     = 64000,
-		.codec_id     = AV_CODEC_ID_VORBIS,
-		.codec_name   = "libvorbis",
-#if LIBAVCODEC_VER_AT_LEAST(54,31)
-		.sample_format = AV_SAMPLE_FMT_FLTP,
+      .profile = FF_PROFILE_AAC_LOW,
+      .mkv_codpriv = AAC_ESDS,
+      .codpriv_size = 2,
+      .flags = 0,
+      .name = "aac"},
+     {.valid = 1,
+      .bits = 16,
+      .monotonic_pts = 0,
+      .avi_4cc = OGG_FORMAT_VORBIS,
+      .mkv_codec = "A_VORBIS",
+      .description = N_("Vorbis"),
+      .bit_rate = 64000,
+      .codec_id = AV_CODEC_ID_VORBIS,
+      .codec_name = "libvorbis",
+#if LIBAVCODEC_VER_AT_LEAST(54, 31)
+      .sample_format = AV_SAMPLE_FMT_FLTP,
 #else
-		.sample_format = AV_SAMPLE_FMT_S16,
+      .sample_format = AV_SAMPLE_FMT_S16,
 #endif
-		.profile      = FF_PROFILE_UNKNOWN,
-		.mkv_codpriv  =  NULL,
-		.codpriv_size =  0,
-		.flags        = 0,
-		.name         = "vorb"
-	}
-};
-
-static int get_aac_obj_ind(int profile)
-{
-	int i = 0;
-
-	for (i=0; i<5; i++)
-	 if(AAC_OBJ_TYPE[i] == profile) break;
-
-	 return i;
-}
+      .profile = FF_PROFILE_UNKNOWN,
+      .mkv_codpriv = NULL,
+      .codpriv_size = 0,
+      .flags = 0,
+      .name = "vorb"}};
 
-static int get_aac_samp_ind(int samprate)
-{
-	int i = 0;
+static int get_aac_obj_ind(int profile) {
+  int i = 0;
 
-	for (i=0; i<13; i++)
-	 if(AAC_SAMP_FREQ[i] == samprate) break;
+  for (i = 0; i < 5; i++) {
+    if (AAC_OBJ_TYPE[i] == profile)
+      break;
+  }
+
+  return i;
+}
 
-	 if (i>12)
-	 {
-		printf("WARNING: invalid sample rate for AAC encoding\n");
-		printf("valid(96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350)\n");
-		i=4; /*default 44100*/
-	 }
-	 return i;
+static int get_aac_samp_ind(int samprate) {
+  int i = 0;
+
+  for (i = 0; i < 13; i++) {
+    if (AAC_SAMP_FREQ[i] == samprate)
+      break;
+  }
+
+  if (i > 12) {
+    printf("WARNING: invalid sample rate for AAC encoding\n");
+    printf("valid(96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, "
+           "16000, 12000, 11025, 8000, 7350)\n");
+    i = 4; /*default 44100*/
+  }
+  return i;
 }
 
 /*
@@ -211,14 +202,13 @@ static int get_aac_samp_ind(int samprate)
  *
  * returns: listSupCodecs size (number of elements)
  */
-int encoder_get_audio_codec_list_size()
-{
-	int size = sizeof(listSupCodecs)/sizeof(audio_codec_t);
+int encoder_get_audio_codec_list_size() {
+  int size = sizeof(listSupCodecs) / sizeof(audio_codec_t);
 
-	if(enc_verbosity > 3)
-		printf("ENCODER: audio codec list size:%i\n", size);
+  if (enc_verbosity > 3)
+    printf("ENCODER: audio codec list size:%i\n", size);
 
-	return size;
+  return size;
 }
 
 /*
@@ -231,7 +221,7 @@ int encoder_get_audio_codec_list_size()
  *
  * returns: listSupCodecs valid number of elements
  */
-//int encoder_get_audio_codec_valid_list_size()
+// int encoder_get_audio_codec_valid_list_size()
 //{
 //	int valid_size = 0;
 //
@@ -244,7 +234,7 @@ int encoder_get_audio_codec_list_size()
 //		printf("ENCODER: audio codec valid list size:%i\n", valid_size);
 //
 //	return valid_size;
-//}
+// }
 
 /*
  * return the real (valid only) codec index
@@ -256,18 +246,16 @@ int encoder_get_audio_codec_list_size()
  *
  * returns: matching listSupCodecs index
  */
-static int get_real_index (int codec_ind)
-{
-	int i = 0;
-	int ind = -1;
-	for (i = 0; i < encoder_get_audio_codec_list_size(); ++i)
-	{
-		if(listSupCodecs[i].valid)
-			ind++;
-		if(ind == codec_ind)
-			return i;
-	}
-	return (codec_ind); //should never arrive
+static int get_real_index(int codec_ind) {
+  int i = 0;
+  int ind = -1;
+  for (i = 0; i < encoder_get_audio_codec_list_size(); ++i) {
+    if (listSupCodecs[i].valid)
+      ind++;
+    if (ind == codec_ind)
+      return i;
+  }
+  return (codec_ind); // should never arrive
 }
 
 /*
@@ -280,22 +268,19 @@ static int get_real_index (int codec_ind)
  *
  * returns: matching list index (with non valid removed)
  */
-static int get_list_index (int real_index)
-{
-	if( real_index < 0 ||
-		real_index >= encoder_get_audio_codec_list_size() ||
-		!listSupCodecs[real_index].valid )
-		return -1; //error: real index is not valid
-
-	int i = 0;
-	int ind = -1;
-	for (i = 0; i<= real_index; ++i)
-	{
-		if(listSupCodecs[i].valid)
-			ind++;
-	}
-
-	return (ind);
+static int get_list_index(int real_index) {
+  if (real_index < 0 || real_index >= encoder_get_audio_codec_list_size() ||
+      !listSupCodecs[real_index].valid)
+    return -1; // error: real index is not valid
+
+  int i = 0;
+  int ind = -1;
+  for (i = 0; i <= real_index; ++i) {
+    if (listSupCodecs[i].valid)
+      ind++;
+  }
+
+  return (ind);
 }
 
 /*
@@ -308,16 +293,14 @@ static int get_list_index (int real_index)
  *
  * returns: real index or -1 if none
  */
-int get_audio_codec_index(int codec_id)
-{
-	int i = 0;
-	for(i = 0; i < encoder_get_audio_codec_list_size(); ++i )
-	{
-		if(codec_id == listSupCodecs[i].codec_id)
-			return i;
-	}
-
-	return -1;
+int get_audio_codec_index(int codec_id) {
+  int i = 0;
+  for (i = 0; i < encoder_get_audio_codec_list_size(); ++i) {
+    if (codec_id == listSupCodecs[i].codec_id)
+      return i;
+  }
+
+  return -1;
 }
 
 /*
@@ -330,9 +313,8 @@ int get_audio_codec_index(int codec_id)
  *
  * returns: real index or -1 if none
  */
-int get_audio_codec_list_index(int codec_id)
-{
-	return get_list_index(get_audio_codec_index(codec_id));
+int get_audio_codec_list_index(int codec_id) {
+  return get_list_index(get_audio_codec_index(codec_id));
 }
 
 /*
@@ -345,17 +327,16 @@ int get_audio_codec_list_index(int codec_id)
  *
  * returns: list codec entry or NULL if none
  */
-audio_codec_t *encoder_get_audio_codec_defaults(int codec_ind)
-{
-	int real_index = get_real_index (codec_ind);
-
-	if(real_index >= 0 && real_index < encoder_get_audio_codec_list_size())
-		return (&(listSupCodecs[real_index]));
-	else
-	{
-		fprintf(stderr, "ENCODER: (audio codec defaults) bad codec index (%i)\n", codec_ind);
-		return NULL;
-	}
+audio_codec_t *encoder_get_audio_codec_defaults(int codec_ind) {
+  int real_index = get_real_index(codec_ind);
+
+  if (real_index >= 0 && real_index < encoder_get_audio_codec_list_size())
+    return (&(listSupCodecs[real_index]));
+  else {
+    fprintf(stderr, "ENCODER: (audio codec defaults) bad codec index (%i)\n",
+            codec_ind);
+    return NULL;
+  }
 }
 
 /*
@@ -368,15 +349,14 @@ audio_codec_t *encoder_get_audio_codec_defaults(int codec_ind)
  *
  * returns: 1 true; 0 false
  */
-int encoder_check_webm_audio_codec(int codec_ind)
-{
-	int real_index = get_real_index (codec_ind);
+int encoder_check_webm_audio_codec(int codec_ind) {
+  int real_index = get_real_index(codec_ind);
 
-	int ret = 0;
-	if(real_index >= 0 && real_index < encoder_get_audio_codec_list_size())
-		ret = (listSupCodecs[real_index].codec_id == AV_CODEC_ID_VORBIS) ? 1: 0;
+  int ret = 0;
+  if (real_index >= 0 && real_index < encoder_get_audio_codec_list_size())
+    ret = (listSupCodecs[real_index].codec_id == AV_CODEC_ID_VORBIS) ? 1 : 0;
 
-	return ret;
+  return ret;
 }
 
 /*
@@ -389,9 +369,8 @@ int encoder_check_webm_audio_codec(int codec_ind)
  *
  * returns: index for Vorbis codec or -1 if error
  */
-int encoder_get_webm_audio_codec_index()
-{
-	return get_audio_codec_list_index(AV_CODEC_ID_VORBIS);
+int encoder_get_webm_audio_codec_index() {
+  return get_audio_codec_list_index(AV_CODEC_ID_VORBIS);
 }
 
 /*
@@ -404,22 +383,20 @@ int encoder_get_webm_audio_codec_index()
  *
  * returns: number of valid audio codecs in list
  */
-int encoder_set_valid_audio_codec_list ()
-{
-	int ind = 0;
-	int num_codecs = 0;
-	for ( ind = 0; ind < encoder_get_audio_codec_list_size(); ++ind)
-	{
-		const AVCodec *codec = avcodec_find_encoder(listSupCodecs[ind].codec_id);
-		if (!codec)
-		{
-			printf("ENCODER: no audio codec detected for %s\n", listSupCodecs[ind].description);
-			listSupCodecs[ind].valid = 0;
-		}
-		else num_codecs++;
-	}
-
-	return num_codecs;
+int encoder_set_valid_audio_codec_list() {
+  int ind = 0;
+  int num_codecs = 0;
+  for (ind = 0; ind < encoder_get_audio_codec_list_size(); ++ind) {
+    const AVCodec *codec = avcodec_find_encoder(listSupCodecs[ind].codec_id);
+    if (!codec) {
+      printf("ENCODER: no audio codec detected for %s\n",
+             listSupCodecs[ind].description);
+      listSupCodecs[ind].valid = 0;
+    } else
+      num_codecs++;
+  }
+
+  return num_codecs;
 }
 
 /*
@@ -432,16 +409,15 @@ int encoder_set_valid_audio_codec_list ()
  *
  * returns: list codec entry or NULL if none
  */
-const char *encoder_get_audio_codec_description(int codec_ind)
-{
-	int real_index = get_real_index (codec_ind);
-	if(real_index >= 0 && real_index < encoder_get_audio_codec_list_size())
-		return (listSupCodecs[real_index].description);
-	else
-	{
-		fprintf(stderr, "ENCODER: (audio codec description) bad codec index (%i)\n", codec_ind);
-		return NULL;
-	}
+const char *encoder_get_audio_codec_description(int codec_ind) {
+  int real_index = get_real_index(codec_ind);
+  if (real_index >= 0 && real_index < encoder_get_audio_codec_list_size())
+    return (listSupCodecs[real_index].description);
+  else {
+    fprintf(stderr, "ENCODER: (audio codec description) bad codec index (%i)\n",
+            codec_ind);
+    return NULL;
+  }
 }
 
 /*
@@ -454,16 +430,15 @@ const char *encoder_get_audio_codec_description(int codec_ind)
  *
  * returns: mkv codec entry or NULL if none
  */
-const char *encoder_get_audio_mkv_codec(int codec_ind)
-{
-	int real_index = get_real_index (codec_ind);
-	if(real_index >= 0 && real_index < encoder_get_audio_codec_list_size())
-		return (listSupCodecs[real_index].mkv_codec);
-	else
-	{
-		fprintf(stderr, "ENCODER: (audio mkv codec) bad codec index (%i)\n", codec_ind);
-		return NULL;
-	}
+const char *encoder_get_audio_mkv_codec(int codec_ind) {
+  int real_index = get_real_index(codec_ind);
+  if (real_index >= 0 && real_index < encoder_get_audio_codec_list_size())
+    return (listSupCodecs[real_index].mkv_codec);
+  else {
+    fprintf(stderr, "ENCODER: (audio mkv codec) bad codec index (%i)\n",
+            codec_ind);
+    return NULL;
+  }
 }
 
 /*
@@ -476,16 +451,15 @@ const char *encoder_get_audio_mkv_codec(int codec_ind)
  *
  * returns: bits entry from audio codec list
  */
-int encoder_get_audio_bits(int codec_ind)
-{
-	int real_index = get_real_index (codec_ind);
-	if(real_index >= 0 && real_index < encoder_get_audio_codec_list_size())
-		return (listSupCodecs[real_index].bits);
-	else
-	{
-		fprintf(stderr, "ENCODER: (get_audio_bits) bad codec index (%i)\n", codec_ind);
-		return 0;
-	}
+int encoder_get_audio_bits(int codec_ind) {
+  int real_index = get_real_index(codec_ind);
+  if (real_index >= 0 && real_index < encoder_get_audio_codec_list_size())
+    return (listSupCodecs[real_index].bits);
+  else {
+    fprintf(stderr, "ENCODER: (get_audio_bits) bad codec index (%i)\n",
+            codec_ind);
+    return 0;
+  }
 }
 
 /*
@@ -498,16 +472,15 @@ int encoder_get_audio_bits(int codec_ind)
  *
  * returns: bit_rate entry from audio codec list
  */
-int encoder_get_audio_bit_rate(int codec_ind)
-{
-	int real_index = get_real_index (codec_ind);
-	if(real_index >= 0 && real_index < encoder_get_audio_codec_list_size())
-		return (listSupCodecs[real_index].bit_rate);
-	else
-	{
-		fprintf(stderr, "ENCODER: (get_audio_bit_rate) bad codec index (%i)\n", codec_ind);
-		return 0;
-	}
+int encoder_get_audio_bit_rate(int codec_ind) {
+  int real_index = get_real_index(codec_ind);
+  if (real_index >= 0 && real_index < encoder_get_audio_codec_list_size())
+    return (listSupCodecs[real_index].bit_rate);
+  else {
+    fprintf(stderr, "ENCODER: (get_audio_bit_rate) bad codec index (%i)\n",
+            codec_ind);
+    return 0;
+  }
 }
 
 /*
@@ -520,16 +493,15 @@ int encoder_get_audio_bit_rate(int codec_ind)
  *
  * returns: pointer to mkvCodecPriv data
  */
-void *encoder_get_audio_mkvCodecPriv(int codec_ind)
-{
-	int real_index = get_real_index (codec_ind);
-	if(real_index >= 0 && real_index < encoder_get_audio_codec_list_size())
-		return ((void *) listSupCodecs[real_index].mkv_codpriv);
-	else
-	{
-		fprintf(stderr, "ENCODER: (mkvCodecPriv) bad codec index (%i)\n", codec_ind);
-		return NULL;
-	}
+void *encoder_get_audio_mkvCodecPriv(int codec_ind) {
+  int real_index = get_real_index(codec_ind);
+  if (real_index >= 0 && real_index < encoder_get_audio_codec_list_size())
+    return ((void *)listSupCodecs[real_index].mkv_codpriv);
+  else {
+    fprintf(stderr, "ENCODER: (mkvCodecPriv) bad codec index (%i)\n",
+            codec_ind);
+    return NULL;
+  }
 }
 
 /*
@@ -542,100 +514,99 @@ void *encoder_get_audio_mkvCodecPriv(int codec_ind)
  *
  * returns: mkvCodecPriv size
  */
-int encoder_set_audio_mkvCodecPriv(encoder_context_t *encoder_ctx)
-{
-	/*assertions*/
-	assert(encoder_ctx != NULL);
-
-	/*assert audio encoder context is not null*/
-	assert( encoder_ctx->enc_audio_ctx);
-	encoder_codec_data_t *audio_codec_data = (encoder_codec_data_t *) encoder_ctx->enc_audio_ctx->codec_data;
-	/*assert video codec data is not null*/	
-	assert(audio_codec_data);
-
-	int codec_id = audio_codec_data->codec_context->codec_id;
-	int real_index = get_audio_codec_index(codec_id);
-
-
-	if (codec_id == AV_CODEC_ID_AAC)
-	{
-		int obj_type = get_aac_obj_ind(listSupCodecs[real_index].profile);
-		int sampind  = get_aac_samp_ind(encoder_ctx->audio_samprate);
-		AAC_ESDS[0] = (uint8_t) ((obj_type & 0x1F) << 3 ) + ((sampind & 0x0F) >> 1);
-		AAC_ESDS[1] = (uint8_t) ((sampind & 0x0F) << 7 ) + ((encoder_ctx->audio_channels & 0x0F) << 3);
-
-		return listSupCodecs[real_index].codpriv_size; /*return size = 2 */
-	}
-	else if(codec_id == AV_CODEC_ID_VORBIS)
-	{
-		//get the 3 first header packets
-		uint8_t *header_start[3];
-		int header_len[3];
-		int first_header_size;
-
-		first_header_size = 30; //theora = 42
-    	if (avpriv_split_xiph_headers(
-			audio_codec_data->codec_context->extradata,
-			audio_codec_data->codec_context->extradata_size,
-				first_header_size, header_start, header_len) < 0)
-        {
-			fprintf(stderr, "ENCODER: vorbis codec - Extradata corrupt.\n");
-			return -1;
-		}
-
-		//printf("Vorbis: header1: %i  header2: %i  header3:%i \n", header_len[0], header_len[1], header_len[2]);
-
-		//get the allocation needed for headers size
-		int header_lace_size[2];
-		header_lace_size[0]=0;
-		header_lace_size[1]=0;
-		int i;
-		for (i = 0; i < header_len[0] / 255; i++)
-			header_lace_size[0]++;
-		header_lace_size[0]++;
-		for (i = 0; i < header_len[1] / 255; i++)
-			header_lace_size[1]++;
-		header_lace_size[1]++;
-
-		int priv_data_size = 1 + //number of packets -1
-						header_lace_size[0] +  //first packet size
-						header_lace_size[1] +  //second packet size
-						header_len[0] + //first packet header
-						header_len[1] + //second packet header
-						header_len[2];  //third packet header
-
-		/*should check and clean before allocating ??*/
-		encoder_ctx->enc_audio_ctx->priv_data = calloc(priv_data_size, sizeof(uint8_t));
-		if(encoder_ctx->enc_audio_ctx->priv_data == NULL)
-		{
-			fprintf(stderr, "ENCODER: FATAL memory allocation failure (encoder_set_audio_mkvCodecPriv): %s\n", strerror(errno));
-			exit(-1);
-		}
-		//write header
-		uint8_t* tmp = encoder_ctx->enc_audio_ctx->priv_data;
-		*tmp++ = 0x02; //number of packets -1
-		//size of head 1
-		for (i = 0; i < header_len[0] / 0xff; i++)
-			*tmp++ = 0xff;
-		*tmp++ = header_len[0] % 0xff;
-		//size of head 2
-		for (i = 0; i < header_len[1] / 0xff; i++)
-			*tmp++ = 0xff;
-		*tmp++ = header_len[1] % 0xff;
-		//add headers
-		for(i=0; i<3; i++)
-		{
-			memcpy(tmp, header_start[i] , header_len[i]);
-			tmp += header_len[i];
-		}
-
-		listSupCodecs[real_index].mkv_codpriv = encoder_ctx->enc_audio_ctx->priv_data;
-		listSupCodecs[real_index].codpriv_size = priv_data_size;
-		return listSupCodecs[real_index].codpriv_size;
-	}
-
-
-	return 0;
+int encoder_set_audio_mkvCodecPriv(encoder_context_t *encoder_ctx) {
+  /*assertions*/
+  assert(encoder_ctx != NULL);
+
+  /*assert audio encoder context is not null*/
+  assert(encoder_ctx->enc_audio_ctx);
+  encoder_codec_data_t *audio_codec_data =
+      (encoder_codec_data_t *)encoder_ctx->enc_audio_ctx->codec_data;
+  /*assert video codec data is not null*/
+  assert(audio_codec_data);
+
+  int codec_id = audio_codec_data->codec_context->codec_id;
+  int real_index = get_audio_codec_index(codec_id);
+
+  if (codec_id == AV_CODEC_ID_AAC) {
+    int obj_type = get_aac_obj_ind(listSupCodecs[real_index].profile);
+    int sampind = get_aac_samp_ind(encoder_ctx->audio_samprate);
+    AAC_ESDS[0] = (uint8_t)((obj_type & 0x1F) << 3) + ((sampind & 0x0F) >> 1);
+    AAC_ESDS[1] = (uint8_t)((sampind & 0x0F) << 7) +
+                  ((encoder_ctx->audio_channels & 0x0F) << 3);
+
+    return listSupCodecs[real_index].codpriv_size; /*return size = 2 */
+  } else if (codec_id == AV_CODEC_ID_VORBIS) {
+    // get the 3 first header packets
+    uint8_t *header_start[3];
+    int header_len[3];
+    int first_header_size;
+
+    first_header_size = 30; // theora = 42
+    if (avpriv_split_xiph_headers(
+            audio_codec_data->codec_context->extradata,
+            audio_codec_data->codec_context->extradata_size, first_header_size,
+            header_start, header_len) < 0) {
+      fprintf(stderr, "ENCODER: vorbis codec - Extradata corrupt.\n");
+      return -1;
+    }
+
+    // printf("Vorbis: header1: %i  header2: %i  header3:%i \n", header_len[0],
+    // header_len[1], header_len[2]);
+
+    // get the allocation needed for headers size
+    int header_lace_size[2];
+    header_lace_size[0] = 0;
+    header_lace_size[1] = 0;
+    int i;
+    for (i = 0; i < header_len[0] / 255; i++)
+      header_lace_size[0]++;
+    header_lace_size[0]++;
+    for (i = 0; i < header_len[1] / 255; i++)
+      header_lace_size[1]++;
+    header_lace_size[1]++;
+
+    int priv_data_size = 1 +                   // number of packets -1
+                         header_lace_size[0] + // first packet size
+                         header_lace_size[1] + // second packet size
+                         header_len[0] +       // first packet header
+                         header_len[1] +       // second packet header
+                         header_len[2];        // third packet header
+
+    /*should check and clean before allocating ??*/
+    encoder_ctx->enc_audio_ctx->priv_data =
+        calloc(priv_data_size, sizeof(uint8_t));
+    if (encoder_ctx->enc_audio_ctx->priv_data == NULL) {
+      fprintf(stderr,
+              "ENCODER: FATAL memory allocation failure "
+              "(encoder_set_audio_mkvCodecPriv): %s\n",
+              strerror(errno));
+      exit(-1);
+    }
+    // write header
+    uint8_t *tmp = encoder_ctx->enc_audio_ctx->priv_data;
+    *tmp++ = 0x02; // number of packets -1
+    // size of head 1
+    for (i = 0; i < header_len[0] / 0xff; i++)
+      *tmp++ = 0xff;
+    *tmp++ = header_len[0] % 0xff;
+    // size of head 2
+    for (i = 0; i < header_len[1] / 0xff; i++)
+      *tmp++ = 0xff;
+    *tmp++ = header_len[1] % 0xff;
+    // add headers
+    for (i = 0; i < 3; i++) {
+      memcpy(tmp, header_start[i], header_len[i]);
+      tmp += header_len[i];
+    }
+
+    listSupCodecs[real_index].mkv_codpriv =
+        encoder_ctx->enc_audio_ctx->priv_data;
+    listSupCodecs[real_index].codpriv_size = priv_data_size;
+    return listSupCodecs[real_index].codpriv_size;
+  }
+
+  return 0;
 }
 
 /*
@@ -648,16 +619,16 @@ int encoder_set_audio_mkvCodecPriv(encoder_context_t *encoder_ctx)
  *
  * returns: codec name entry
  */
-const char *encoder_get_audio_codec_name(int codec_ind)
-{
-	int real_index = get_real_index (codec_ind);
-	if(real_index >= 0 && real_index < encoder_get_audio_codec_list_size())
-		return (listSupCodecs[real_index].name);
-	else
-	{
-		fprintf(stderr, "ENCODER: (audio codec name) bad codec index (%i)\n", codec_ind);;
-		return NULL;
-	}
+const char *encoder_get_audio_codec_name(int codec_ind) {
+  int real_index = get_real_index(codec_ind);
+  if (real_index >= 0 && real_index < encoder_get_audio_codec_list_size())
+    return (listSupCodecs[real_index].name);
+  else {
+    fprintf(stderr, "ENCODER: (audio codec name) bad codec index (%i)\n",
+            codec_ind);
+    ;
+    return NULL;
+  }
 }
 
 /*
@@ -670,17 +641,16 @@ const char *encoder_get_audio_codec_name(int codec_ind)
  *
  * returns: codec index or -1 if error
  */
-int encoder_get_audio_codec_ind_name(const char *codec_name)
-{
-	int real_index = 0;
-	int index = -1;
-	for(real_index = 0; real_index < encoder_get_audio_codec_list_size(); ++real_index)
-	{
-		if(listSupCodecs[real_index].valid)
-			index++;
-		if(strcasecmp(codec_name, listSupCodecs[real_index].name) == 0)
-			return index;
-	}
-
-	return -1;
+int encoder_get_audio_codec_ind_name(const char *codec_name) {
+  int real_index = 0;
+  int index = -1;
+  for (real_index = 0; real_index < encoder_get_audio_codec_list_size();
+       ++real_index) {
+    if (listSupCodecs[real_index].valid)
+      index++;
+    if (strcasecmp(codec_name, listSupCodecs[real_index].name) == 0)
+      return index;
+  }
+
+  return -1;
 }
diff --git a/gview_encoder/encoder.c b/gview_encoder/encoder.c
index 83d63a1..9d29669 100644
--- a/gview_encoder/encoder.c
+++ b/gview_encoder/encoder.c
@@ -212,6 +212,7 @@ void __attribute__((destructor)) gviewencoder_fini() {
 /*
  * check that a given sample format is supported by the encoder
  * args:
+ *    enc_ctx - pointer to AVCodecContext
  *    codec - pointer to AVCodec
  *    sample_fmt - audio sample format
  *
@@ -220,9 +221,21 @@ void __attribute__((destructor)) gviewencoder_fini() {
  *
  * returns: 1 - sample format is supported; 0 - is not supported
  */
-static int encoder_check_audio_sample_fmt(const AVCodec *codec,
+static int encoder_check_audio_sample_fmt(const AVCodecContext *enc_ctx,
+                                          const AVCodec *codec,
                                           enum AVSampleFormat sample_fmt) {
-  const enum AVSampleFormat *p = codec->sample_fmts;
+const enum AVSampleFormat *sample_fmts;
+
+#if LIBAVCODEC_VER_AT_LEAST(61, 19)
+
+avcodec_get_supported_config(enc_ctx, codec,
+                             AV_CODEC_CONFIG_SAMPLE_FORMAT, 0,
+                             (const void **) &(sample_fmts), NULL);
+#else
+  sample_fmts = codec->sample_fmts;
+#endif
+
+  const enum AVSampleFormat *p = sample_fmts;
 
   while (*p != AV_SAMPLE_FMT_NONE) {
     if (*p == sample_fmt)
@@ -235,6 +248,7 @@ static int encoder_check_audio_sample_fmt(const AVCodec *codec,
 /*
  * check that a given sample rate is supported by the encoder
  * args:
+ *    enc_ctx - pointer to AVCodecContext
  *    codec - pointer to AVCodec
  *    sample_rate - audio sample rate
  *
@@ -243,15 +257,28 @@ static int encoder_check_audio_sample_fmt(const AVCodec *codec,
  *
  * returns: sample_rate if supported or max supported sample rate if not
  */
-static int select_sample_rate(const AVCodec *codec, int sample_rate) {
+static int select_sample_rate(const AVCodecContext *enc_ctx, 
+                              const AVCodec *codec, 
+                              int sample_rate) {
   const int *p;
   int best_samplerate = 0;
+  const int *supported_samplerates;
+
+#if LIBAVCODEC_VER_AT_LEAST(61, 19)
 
-  if (!codec->supported_samplerates)
+  avcodec_get_supported_config(enc_ctx, codec,
+                             AV_CODEC_CONFIG_SAMPLE_RATE, 0,
+                             (const void **) &supported_samplerates, NULL);
+#else
+    supported_samplerates = codec->supported_samplerates;
+#endif
+ 
+  p = supported_samplerates;
+
+  if (!supported_samplerates)
     return sample_rate;
 
-  p = codec->supported_samplerates;
-  while (*p) {
+  while (*p != 0) {
     if (*p == sample_rate)
       return sample_rate;
 
@@ -260,6 +287,7 @@ static int select_sample_rate(const AVCodec *codec, int sample_rate) {
   }
   return best_samplerate;
 }
+
 /*
  * video encoder initialization for raw input
  *  (don't set a codec but set the proper codec 4cc)
@@ -834,7 +862,9 @@ encoder_audio_init(encoder_context_t *encoder_ctx) {
   audio_codec_data->codec_context->codec_type = AVMEDIA_TYPE_AUDIO;
 
   int best_samprate =
-      select_sample_rate(audio_codec_data->codec, encoder_ctx->audio_samprate);
+      select_sample_rate(audio_codec_data->codec_context,
+                         audio_codec_data->codec, 
+                         encoder_ctx->audio_samprate);
 
   if (best_samprate != encoder_ctx->audio_samprate) {
     fprintf(
@@ -848,20 +878,24 @@ encoder_audio_init(encoder_context_t *encoder_ctx) {
       (AVRational){1, encoder_ctx->audio_samprate};
 
   /*check if codec supports sample format*/
-  if (!encoder_check_audio_sample_fmt(audio_codec_data->codec,
+  if (!encoder_check_audio_sample_fmt(audio_codec_data->codec_context,
+                                      audio_codec_data->codec,
                                       audio_defaults->sample_format)) {
     /*replace by a supported format*/
     switch (audio_defaults->sample_format) {
     case AV_SAMPLE_FMT_S16:
-      if (encoder_check_audio_sample_fmt(audio_codec_data->codec,
+      if (encoder_check_audio_sample_fmt(audio_codec_data->codec_context,
+                                         audio_codec_data->codec,
                                          AV_SAMPLE_FMT_S16P)) {
         fprintf(stderr, "ENCODER: changing sample format (S16 -> S16P)\n");
         audio_defaults->sample_format = AV_SAMPLE_FMT_S16P;
-      } else if (encoder_check_audio_sample_fmt(audio_codec_data->codec,
+      } else if (encoder_check_audio_sample_fmt(audio_codec_data->codec_context,
+                                                audio_codec_data->codec,
                                                 AV_SAMPLE_FMT_FLT)) {
         fprintf(stderr, "ENCODER: changing sample format (S16 -> FLT)\n");
         audio_defaults->sample_format = AV_SAMPLE_FMT_FLT;
-      } else if (encoder_check_audio_sample_fmt(audio_codec_data->codec,
+      } else if (encoder_check_audio_sample_fmt(audio_codec_data->codec_context,
+                                                audio_codec_data->codec,
                                                 AV_SAMPLE_FMT_FLTP)) {
         fprintf(stderr, "ENCODER: changing sample format (S16 -> FLTP)\n");
         audio_defaults->sample_format = AV_SAMPLE_FMT_FLTP;
@@ -877,15 +911,18 @@ encoder_audio_init(encoder_context_t *encoder_ctx) {
       break;
 
     case AV_SAMPLE_FMT_FLT:
-      if (encoder_check_audio_sample_fmt(audio_codec_data->codec,
+      if (encoder_check_audio_sample_fmt(audio_codec_data->codec_context,
+                                         audio_codec_data->codec,
                                          AV_SAMPLE_FMT_S16)) {
         fprintf(stderr, "ENCODER: changing sample format (FLT -> S16)\n");
         audio_defaults->sample_format = AV_SAMPLE_FMT_S16;
-      } else if (encoder_check_audio_sample_fmt(audio_codec_data->codec,
+      } else if (encoder_check_audio_sample_fmt(audio_codec_data->codec_context,
+                                                audio_codec_data->codec,
                                                 AV_SAMPLE_FMT_S16P)) {
         fprintf(stderr, "ENCODER: changing sample format (FLT -> S16P)\n");
         audio_defaults->sample_format = AV_SAMPLE_FMT_S16P;
-      } else if (encoder_check_audio_sample_fmt(audio_codec_data->codec,
+      } else if (encoder_check_audio_sample_fmt(audio_codec_data->codec_context,
+                                                audio_codec_data->codec,
                                                 AV_SAMPLE_FMT_FLTP)) {
         fprintf(stderr, "ENCODER: changing sample format (FLT -> FLTP)\n");
         audio_defaults->sample_format = AV_SAMPLE_FMT_FLTP;
@@ -901,15 +938,18 @@ encoder_audio_init(encoder_context_t *encoder_ctx) {
       break;
 
     case AV_SAMPLE_FMT_FLTP:
-      if (encoder_check_audio_sample_fmt(audio_codec_data->codec,
+      if (encoder_check_audio_sample_fmt(audio_codec_data->codec_context,
+                                         audio_codec_data->codec,
                                          AV_SAMPLE_FMT_S16)) {
         fprintf(stderr, "ENCODER: changing sample format (FLTP -> S16)\n");
         audio_defaults->sample_format = AV_SAMPLE_FMT_S16;
-      } else if (encoder_check_audio_sample_fmt(audio_codec_data->codec,
+      } else if (encoder_check_audio_sample_fmt(audio_codec_data->codec_context,
+                                                audio_codec_data->codec,
                                                 AV_SAMPLE_FMT_S16P)) {
         fprintf(stderr, "ENCODER: changing sample format (FLTP -> S16P)\n");
         audio_defaults->sample_format = AV_SAMPLE_FMT_S16P;
-      } else if (encoder_check_audio_sample_fmt(audio_codec_data->codec,
+      } else if (encoder_check_audio_sample_fmt(audio_codec_data->codec_context,
+                                                audio_codec_data->codec,
                                                 AV_SAMPLE_FMT_FLT)) {
         fprintf(stderr, "ENCODER: changing sample format (FLTP -> FLT)\n");
         audio_defaults->sample_format = AV_SAMPLE_FMT_FLT;
diff --git a/gview_render/CMakeLists.txt b/gview_render/CMakeLists.txt
index e63ba39..4c9e2f3 100644
--- a/gview_render/CMakeLists.txt
+++ b/gview_render/CMakeLists.txt
@@ -17,6 +17,7 @@ set_target_properties(
   SOVERSION ${LIBSOVERSION}
 )
 
+add_definitions("-Wall")
 
 if(SDL2_FOUND)
   target_sources(gviewrender PRIVATE render_sdl2.c)
diff --git a/gview_render/render_fx.c b/gview_render/render_fx.c
index d65a4b2..ff2c9d5 100644
--- a/gview_render/render_fx.c
+++ b/gview_render/render_fx.c
@@ -1,18 +1,23 @@
-/*******************************************************************************#
-#           guvcview              http://guvcview.sourceforge.net # # # # Paulo
-Assis <pj.assis@gmail.com>                                    # # # # This
-program is free software; you can redistribute it and/or modify          # # it
-under the terms of the GNU General Public License as published by          # #
-the Free Software Foundation; either version 2 of the License, or             #
-# (at your option) any later version. # # # # This program is distributed in the
-hope that it will be useful,               # # but WITHOUT ANY WARRANTY; without
-even the implied warranty of                # # MERCHANTABILITY or FITNESS FOR A
-PARTICULAR PURPOSE.  See the                 # # GNU General Public License for
-more details.                                  # # # # You should have received
-a copy of the GNU General Public License             # # along with this
-program; if not, write to the Free Software                   # # Foundation,
-Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA     # # #
-********************************************************************************/
+/******************************************************************************#
+#           guvcview              http://guvcview.sourceforge.net              #
+#                                                                              #
+#           Paulo Assis <pj.assis@gmail.com>                                   #
+#                                                                              #
+# This program is free software; you can redistribute it and/or modify         #
+# it under the terms of the GNU General Public License as published by         #
+# the Free Software Foundation; either version 2 of the License, or            #
+# (at your option) any later version.                                          #
+#                                                                              #
+# This program is distributed in the hope that it will be useful,              #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
+# GNU General Public License for more details.                                 #
+#                                                                              #
+# You should have received a copy of the GNU General Public License            #
+# along with this program; if not, write to the Free Software                  #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
+#                                                                              #
+*******************************************************************************/
 
 #include <assert.h>
 #include <inttypes.h>
@@ -90,8 +95,8 @@ static void fx_yu12_mirror(uint8_t *frame, int width, int height) {
 
   int h = 0;
   int w = 0;
-  int y_sizeline = width;
-  int c_sizeline = width / 2;
+  //int y_sizeline = width;
+  //int c_sizeline = width / 2;
 
   uint8_t *end = NULL;
   uint8_t *end2 = NULL;
@@ -157,8 +162,8 @@ static void fx_yu12_half_mirror(uint8_t *frame, int width, int height) {
   uint8_t *pu = frame + (width * height);
   uint8_t *pv = pu + ((width * height) / 4);
 
-  uint8_t pixel = 0;
-  uint8_t pixel2 = 0;
+  //uint8_t pixel = 0;
+  //uint8_t pixel2 = 0;
 
   /*mirror y*/
   for (h = 0; h < height; h++) {
@@ -384,11 +389,11 @@ static void fx_yu12_binary(uint8_t *frame, int width, int height) {
  */
 static void fx_yu12_pieces(uint8_t *frame, int width, int height,
                            int piece_size) {
-  int numx = width / piece_size;  // number of pieces in x axis
-  int numy = height / piece_size; // number of pieces in y axis
+  //int numx = width / piece_size;  // number of pieces in x axis
+  //int numy = height / piece_size; // number of pieces in y axis
 
   uint8_t piece[(piece_size * piece_size * 3) / 2];
-  uint8_t *ppiece = piece;
+  //uint8_t *ppiece = piece;
 
   int i = 0, j = 0, w = 0, h = 0;
 
@@ -400,8 +405,8 @@ static void fx_yu12_pieces(uint8_t *frame, int width, int height,
   int rot = 0;
 
   uint8_t *py = NULL;
-  uint8_t *pu = NULL;
-  uint8_t *pv = NULL;
+  //uint8_t *pu = NULL;
+  //uint8_t *pv = NULL;
 
   for (h = 0; h < height; h += piece_size) {
     for (w = 0; w < width; w += piece_size) {
diff --git a/gview_render/render_sdl2.c b/gview_render/render_sdl2.c
index a2d336e..e671777 100644
--- a/gview_render/render_sdl2.c
+++ b/gview_render/render_sdl2.c
@@ -81,7 +81,8 @@ static int video_init(int width, int height, int flags, int win_w, int win_h) {
 
 
     SDL_SetHint("SDL_HINT_RENDER_SCALE_QUALITY", "1");
-
+    //SDL_SetHint("SDL_HINT_VIDEO_WAYLAND_ALLOW_LIBDECOR", "0");
+    
     sdl_window = SDL_CreateWindow("Guvcview Video",        // window title
                                   SDL_WINDOWPOS_UNDEFINED, // initial x position
                                   SDL_WINDOWPOS_UNDEFINED, // initial y position
diff --git a/gview_render/render_sfml.cpp b/gview_render/render_sfml.cpp
index 11e8fd5..ac47d32 100644
--- a/gview_render/render_sfml.cpp
+++ b/gview_render/render_sfml.cpp
@@ -149,8 +149,8 @@ static sf::View getLetterboxView(sf::View view, int windowWidth, int windowHeigh
 }
 
 SFMLRender::SFMLRender(int width, int height, int flags, int win_w, int win_h) {
-  int w = width;
-  int h = height;
+  unsigned int w = width;
+  unsigned int h = height;
 
   if (win_w > 0)
     w = win_w;
diff --git a/gview_v4l2core/CMakeLists.txt b/gview_v4l2core/CMakeLists.txt
index 1ca4aa1..5ec3198 100644
--- a/gview_v4l2core/CMakeLists.txt
+++ b/gview_v4l2core/CMakeLists.txt
@@ -28,6 +28,8 @@ set_target_properties(
   SOVERSION ${LIBSOVERSION}
 )
 
+add_definitions("-Wall")
+
 pkg_check_modules(V4L2 REQUIRED
   libv4l2 libudev libusb-1.0 libavcodec>=57.16 libavutil libpng)
 
diff --git a/gview_v4l2core/colorspaces.c b/gview_v4l2core/colorspaces.c
index 6a6951a..f849608 100644
--- a/gview_v4l2core/colorspaces.c
+++ b/gview_v4l2core/colorspaces.c
@@ -520,7 +520,7 @@ void vyuy_to_yu12(uint8_t *out, uint8_t *in, int width, int height) {
 
   int w = 0, h = 0;
   int y_sizeline = width;
-  int c_sizeline = width / 2;
+  //int c_sizeline = width / 2;
 
   uint8_t *in1 = in;                // first line
   uint8_t *in2 = in1 + (width * 2); // second line in yuyv buffer
@@ -570,7 +570,7 @@ void yuv422p_to_yu12(uint8_t *out, uint8_t *in, int width, int height) {
   memcpy(out, in, width * height);
 
   int w = 0, h = 0;
-  int c_sizeline = width / 2;
+  //int c_sizeline = width / 2;
 
   uint8_t *pu = out + (width * height);
   uint8_t *inu1 = in + (width * height);
@@ -613,7 +613,7 @@ void yyuv_to_yu12(uint8_t *out, uint8_t *in, int width, int height) {
 
   int w = 0, h = 0;
   int y_sizeline = width;
-  int c_sizeline = width / 2;
+  //int c_sizeline = width / 2;
 
   uint8_t *in1 = in;                // first line
   uint8_t *in2 = in1 + (width * 2); // second line in yyuv buffer
diff --git a/gview_v4l2core/frame_decoder.c b/gview_v4l2core/frame_decoder.c
index b2ec055..feb3acb 100644
--- a/gview_v4l2core/frame_decoder.c
+++ b/gview_v4l2core/frame_decoder.c
@@ -733,7 +733,7 @@ int decode_v4l2_frame(v4l2_dev_t *vd, v4l2_frame_buff_t *frame) {
    */
   int format = vd->requested_fmt;
 
-  int framesizeIn = (width * height << 1); // 2 bytes per pixel
+  //int framesizeIn = (width * height << 1); // 2 bytes per pixel
   switch (format) {
   case V4L2_PIX_FMT_H264:
     /*
diff --git a/gview_v4l2core/jpeg_decoder.c b/gview_v4l2core/jpeg_decoder.c
index eccfadf..15a0105 100644
--- a/gview_v4l2core/jpeg_decoder.c
+++ b/gview_v4l2core/jpeg_decoder.c
@@ -21,12 +21,6 @@
 #                                                                              #
 *******************************************************************************/
 
-/******************************************************************************#
-#                                                                              #
-#  M/Jpeg decoding and frame capture taken from luvcview                       #
-#                                                                              #
-*******************************************************************************/
-
 #include <assert.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -1315,7 +1309,7 @@ int jpeg_init_decoder(int width, int height) {
 #endif
   {
     fprintf(stderr, "V4L2_CORE: (mjpeg decoder) couldn't open codec\n");
-    
+
 #if LIBAVCODEC_VER_AT_LEAST(61, 3)
     avcodec_free_context(&codec_data->context);
 #else
@@ -1421,32 +1415,34 @@ int jpeg_decode(uint8_t *out_buf, uint8_t *in_buf, int size) {
                      codec_data->context->pix_fmt, jpeg_ctx->width,
                      jpeg_ctx->height, jpeg_ctx->tmp_frame, jpeg_ctx->pic_size);
 #endif
-    /* requested libavcodec output format is yuv422p 
+    /* requested libavcodec output format is yuv422p
      * but apparently for some cameras
-     * (https://sourceforge.net/u/shicetu/uos-guvcview/ci/fbdc4b23f0072c5285383d09d2724dbf962d8a7f/) 
+     * (https://sourceforge.net/u/shicetu/uos-guvcview/ci/fbdc4b23f0072c5285383d09d2724dbf962d8a7f/)
      * it can turn out be in yuv420p */
-    if (codec_data->context->pix_fmt == AV_PIX_FMT_YUV422P || 
+    if (codec_data->context->pix_fmt == AV_PIX_FMT_YUV422P ||
         codec_data->context->pix_fmt == AV_PIX_FMT_YUVJ422P) {
-      
-      yuv422p_to_yu12(out_buf, jpeg_ctx->tmp_frame, jpeg_ctx->width, jpeg_ctx->height);
+
+      yuv422p_to_yu12(out_buf, jpeg_ctx->tmp_frame, jpeg_ctx->width,
+                      jpeg_ctx->height);
       return jpeg_ctx->pic_size;
 
-    } else if (codec_data->context->pix_fmt == AV_PIX_FMT_YUVJ420P || 
+    } else if (codec_data->context->pix_fmt == AV_PIX_FMT_YUVJ420P ||
                codec_data->context->pix_fmt == AV_PIX_FMT_YUV420P) {
 
-      if (jpeg_ctx->pic_size > (size_t)(jpeg_ctx->width * jpeg_ctx->height * 3 / 2))
-        jpeg_ctx->pic_size  = (size_t)(jpeg_ctx->width * jpeg_ctx->height * 3 / 2);
+      if (jpeg_ctx->pic_size >
+          (size_t)(jpeg_ctx->width * jpeg_ctx->height * 3 / 2))
+        jpeg_ctx->pic_size =
+            (size_t)(jpeg_ctx->width * jpeg_ctx->height * 3 / 2);
 
       memcpy(out_buf, jpeg_ctx->tmp_frame, jpeg_ctx->pic_size);
       return jpeg_ctx->pic_size;
-    
+
     } else {
-      fprintf(stderr, "JPEG_DECODER: output pixel format not supported: %li\n", 
+      fprintf(stderr, "JPEG_DECODER: output pixel format not supported: %i\n",
               codec_data->context->pix_fmt);
     }
+  }
 
-  } 
-  
   return 0;
 }
 
diff --git a/gview_v4l2core/v4l2_controls.c b/gview_v4l2core/v4l2_controls.c
index ffae7cd..beca130 100644
--- a/gview_v4l2core/v4l2_controls.c
+++ b/gview_v4l2core/v4l2_controls.c
@@ -1208,7 +1208,7 @@ void set_control_defaults(v4l2_dev_t *vd) {
   }
 
   v4l2_ctrl_t *current = vd->list_device_controls;
-  v4l2_ctrl_t *next = current->next;
+  //v4l2_ctrl_t *next = current->next;
 
   if (verbosity > 0)
     printf("V4L2_CORE: loading defaults\n");
-- 
2.51.1

