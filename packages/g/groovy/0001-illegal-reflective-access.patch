From 301204fcec55c76dcf6a1dc162262791bbae62bd Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Fridrich=20=C5=A0trba?= <fridrich.strba@bluewin.ch>
Date: Fri, 20 May 2022 18:15:52 +0200
Subject: [PATCH] illegal reflective access

---
 build.gradle                                  |   16 +
 src/main/groovy/lang/MetaClassImpl.java       |   12 +-
 src/main/groovy/transform/Internal.java       |   32 +
 src/main/org/apache/groovy/util/Maps.java     | 5820 +++++++++++++++++
 .../org/codehaus/groovy/ast/PackageNode.java  |   90 +-
 .../groovy/ast/tools/GeneralUtils.java        |   20 +
 .../groovy/classgen/asm/util/TypeUtil.java    |  216 +
 .../reflection/AccessPermissionChecker.java   |  100 +
 .../CacheAccessControlException.java          |   29 +
 .../groovy/reflection/CachedClass.java        |   76 +-
 .../groovy/reflection/CachedConstructor.java  |   43 +-
 .../groovy/reflection/CachedField.java        |   36 +-
 .../groovy/reflection/CachedMethod.java       |   62 +-
 .../ClassLoaderForClassArtifacts.java         |    8 +-
 .../groovy/reflection/MixinInMetaClass.java   |    7 +-
 .../groovy/reflection/ReflectionUtils.java    |   94 +-
 .../groovy/runtime/DefaultGroovyMethods.java  |    5 +-
 .../runtime/callsite/CallSiteArray.java       |    4 +-
 .../runtime/callsite/CallSiteGenerator.java   |   12 +-
 .../runtime/callsite/CallSiteHelper.java      |   33 +
 .../callsite/GetEffectivePogoFieldSite.java   |    2 +-
 .../callsite/GetEffectivePojoFieldSite.java   |    2 +-
 .../runtime/callsite/MetaMethodSite.java      |    2 +-
 .../runtime/callsite/PogoMetaMethodSite.java  |    3 +
 .../runtime/callsite/PojoMetaMethodSite.java  |    4 +-
 .../metaclass/MetaClassRegistryImpl.java      |    2 +-
 .../metaclass/MethodSelectionException.java   |   13 +-
 .../codehaus/groovy/tools/DgmConverter.java   |    2 +-
 .../codehaus/groovy/vmplugin/VMPlugin.java    |   40 +-
 .../codehaus/groovy/vmplugin/v5/Java5.java    |  167 +-
 .../codehaus/groovy/vmplugin/v7/Java7.java    |   72 +-
 .../codehaus/groovy/vmplugin/v7/Selector.java |    4 +-
 .../codehaus/groovy/vmplugin/v9/Java9.java    |  253 +
 src/test/groovy/bugs/Groovy8339Bug.groovy     |   27 +
 .../groovy/reflection/SecurityTest.java       |  278 +
 .../src/main/java/groovy/util/AntBuilder.java |    5 +-
 .../java/org/codehaus/groovy/ant/Groovy.java  |    3 +-
 .../tools/shell/util/PackageHelperImpl.groovy |    4 +-
 .../groovy/binding/ClosureTriggerBinding.java |    5 +-
 .../groovy/beans/BindableSwingTest.groovy     |   11 +
 40 files changed, 7354 insertions(+), 260 deletions(-)
 create mode 100644 src/main/groovy/transform/Internal.java
 create mode 100644 src/main/org/apache/groovy/util/Maps.java
 create mode 100644 src/main/org/codehaus/groovy/classgen/asm/util/TypeUtil.java
 create mode 100644 src/main/org/codehaus/groovy/reflection/AccessPermissionChecker.java
 create mode 100644 src/main/org/codehaus/groovy/reflection/CacheAccessControlException.java
 create mode 100644 src/main/org/codehaus/groovy/runtime/callsite/CallSiteHelper.java
 create mode 100644 src/main/org/codehaus/groovy/vmplugin/v9/Java9.java
 create mode 100644 src/test/groovy/bugs/Groovy8339Bug.groovy
 create mode 100644 src/test/org/codehaus/groovy/reflection/SecurityTest.java

diff --git a/build.gradle b/build.gradle
index a9c2f70cd8..ea33c6d5b7 100644
--- a/build.gradle
+++ b/build.gradle
@@ -264,6 +264,10 @@ sourceSets {
                 exclude '**/v8/*'
                 exclude '**/vm7/*'
             }
+            if (!JavaVersion.current().isJava9Compatible()) {
+                exclude '**/v9/*'
+                exclude '**/vm9/*'
+            }
         }
         groovy {
             srcDirs = [
@@ -276,6 +280,10 @@ sourceSets {
                 exclude '**/v8/*'
                 exclude '**/vm7/*'
             }
+            if (!JavaVersion.current().isJava9Compatible()) {
+                exclude '**/v9/*'
+                exclude '**/vm9/*'
+            }
         }
         resources {
             srcDirs = ['src/main', 'src/resources']
@@ -287,6 +295,14 @@ sourceSets {
     test {
         groovy {
             srcDirs = ['src/test']
+            if (!JavaVersion.current().isJava8Compatible()) {
+                exclude '**/v8/*'
+                exclude '**/vm8/*'
+            }
+            if (!JavaVersion.current().isJava9Compatible()) {
+                exclude '**/v9/*'
+                exclude '**/vm9/*'
+            }
         }
         resources {
             srcDirs = ['src/test-resources']
diff --git a/src/main/groovy/lang/MetaClassImpl.java b/src/main/groovy/lang/MetaClassImpl.java
index 972c060fb2..7a90a417df 100644
--- a/src/main/groovy/lang/MetaClassImpl.java
+++ b/src/main/groovy/lang/MetaClassImpl.java
@@ -104,6 +104,9 @@ import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
+import static org.codehaus.groovy.ast.tools.GeneralUtils.inSamePackage;
+import static org.codehaus.groovy.ast.tools.GeneralUtils.isDefaultVisibility;
+
 /**
  * Allows methods to be dynamically added to existing classes at runtime
  *
@@ -1399,11 +1402,11 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
     public Constructor retrieveConstructor(Class[] arguments) {
         CachedConstructor constructor = (CachedConstructor) chooseMethod("<init>", constructors, arguments);
         if (constructor != null) {
-            return constructor.cachedConstructor;
+            return constructor.getCachedConstructor();
         }
         constructor = (CachedConstructor) chooseMethod("<init>", constructors, arguments);
         if (constructor != null) {
-            return constructor.cachedConstructor;
+            return constructor.getCachedConstructor();
         }
         return null;
     }
@@ -2404,10 +2407,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
     private static boolean packageLocal(CachedField mfp, CachedClass klass) {
         if ((mfp.getModifiers() & (Modifier.PRIVATE | Modifier.PUBLIC | Modifier.PROTECTED)) != 0 || klass == null)
             return false;
-        Package fieldPackage = mfp.field.getDeclaringClass().getPackage();
-        Package classPackage = klass.getTheClass().getPackage();
-        return (fieldPackage == null && classPackage == null) ||
-                fieldPackage != null && classPackage != null && fieldPackage.getName().equals(classPackage.getName());
+        return isDefaultVisibility(mfp.getModifiers()) && inSamePackage(mfp.getDeclaringClass(), klass.getTheClass());
     }
 
     private void applyStrayPropertyMethods(LinkedList<CachedClass> superClasses, Index classPropertyIndex, boolean isThis) {
diff --git a/src/main/groovy/transform/Internal.java b/src/main/groovy/transform/Internal.java
new file mode 100644
index 0000000000..a645f81c8c
--- /dev/null
+++ b/src/main/groovy/transform/Internal.java
@@ -0,0 +1,32 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.transform;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * The Internal annotation is used to mark members that are internal.
+ */
+@Target({ElementType.METHOD, ElementType.CONSTRUCTOR, ElementType.TYPE, ElementType.FIELD})
+@Retention(RetentionPolicy.RUNTIME)
+public @interface Internal {
+}
diff --git a/src/main/org/apache/groovy/util/Maps.java b/src/main/org/apache/groovy/util/Maps.java
new file mode 100644
index 0000000000..b560a4f7d9
--- /dev/null
+++ b/src/main/org/apache/groovy/util/Maps.java
@@ -0,0 +1,5820 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.apache.groovy.util;
+
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+/**
+ * Map utilities.
+ * @since 2.5.0
+ */
+public abstract class Maps {
+
+    public static <K, V> Map<K, V> of(K k1, V v1) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69, K k70, V v70) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+        map.put(k70, v70);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69, K k70, V v70, K k71, V v71) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+        map.put(k70, v70);
+        map.put(k71, v71);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69, K k70, V v70, K k71, V v71, K k72, V v72) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+        map.put(k70, v70);
+        map.put(k71, v71);
+        map.put(k72, v72);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69, K k70, V v70, K k71, V v71, K k72, V v72, K k73, V v73) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+        map.put(k70, v70);
+        map.put(k71, v71);
+        map.put(k72, v72);
+        map.put(k73, v73);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69, K k70, V v70, K k71, V v71, K k72, V v72, K k73, V v73, K k74, V v74) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+        map.put(k70, v70);
+        map.put(k71, v71);
+        map.put(k72, v72);
+        map.put(k73, v73);
+        map.put(k74, v74);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69, K k70, V v70, K k71, V v71, K k72, V v72, K k73, V v73, K k74, V v74, K k75, V v75) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+        map.put(k70, v70);
+        map.put(k71, v71);
+        map.put(k72, v72);
+        map.put(k73, v73);
+        map.put(k74, v74);
+        map.put(k75, v75);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69, K k70, V v70, K k71, V v71, K k72, V v72, K k73, V v73, K k74, V v74, K k75, V v75, K k76, V v76) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+        map.put(k70, v70);
+        map.put(k71, v71);
+        map.put(k72, v72);
+        map.put(k73, v73);
+        map.put(k74, v74);
+        map.put(k75, v75);
+        map.put(k76, v76);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69, K k70, V v70, K k71, V v71, K k72, V v72, K k73, V v73, K k74, V v74, K k75, V v75, K k76, V v76, K k77, V v77) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+        map.put(k70, v70);
+        map.put(k71, v71);
+        map.put(k72, v72);
+        map.put(k73, v73);
+        map.put(k74, v74);
+        map.put(k75, v75);
+        map.put(k76, v76);
+        map.put(k77, v77);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69, K k70, V v70, K k71, V v71, K k72, V v72, K k73, V v73, K k74, V v74, K k75, V v75, K k76, V v76, K k77, V v77, K k78, V v78) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+        map.put(k70, v70);
+        map.put(k71, v71);
+        map.put(k72, v72);
+        map.put(k73, v73);
+        map.put(k74, v74);
+        map.put(k75, v75);
+        map.put(k76, v76);
+        map.put(k77, v77);
+        map.put(k78, v78);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69, K k70, V v70, K k71, V v71, K k72, V v72, K k73, V v73, K k74, V v74, K k75, V v75, K k76, V v76, K k77, V v77, K k78, V v78, K k79, V v79) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+        map.put(k70, v70);
+        map.put(k71, v71);
+        map.put(k72, v72);
+        map.put(k73, v73);
+        map.put(k74, v74);
+        map.put(k75, v75);
+        map.put(k76, v76);
+        map.put(k77, v77);
+        map.put(k78, v78);
+        map.put(k79, v79);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69, K k70, V v70, K k71, V v71, K k72, V v72, K k73, V v73, K k74, V v74, K k75, V v75, K k76, V v76, K k77, V v77, K k78, V v78, K k79, V v79, K k80, V v80) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+        map.put(k70, v70);
+        map.put(k71, v71);
+        map.put(k72, v72);
+        map.put(k73, v73);
+        map.put(k74, v74);
+        map.put(k75, v75);
+        map.put(k76, v76);
+        map.put(k77, v77);
+        map.put(k78, v78);
+        map.put(k79, v79);
+        map.put(k80, v80);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69, K k70, V v70, K k71, V v71, K k72, V v72, K k73, V v73, K k74, V v74, K k75, V v75, K k76, V v76, K k77, V v77, K k78, V v78, K k79, V v79, K k80, V v80, K k81, V v81) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+        map.put(k70, v70);
+        map.put(k71, v71);
+        map.put(k72, v72);
+        map.put(k73, v73);
+        map.put(k74, v74);
+        map.put(k75, v75);
+        map.put(k76, v76);
+        map.put(k77, v77);
+        map.put(k78, v78);
+        map.put(k79, v79);
+        map.put(k80, v80);
+        map.put(k81, v81);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69, K k70, V v70, K k71, V v71, K k72, V v72, K k73, V v73, K k74, V v74, K k75, V v75, K k76, V v76, K k77, V v77, K k78, V v78, K k79, V v79, K k80, V v80, K k81, V v81, K k82, V v82) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+        map.put(k70, v70);
+        map.put(k71, v71);
+        map.put(k72, v72);
+        map.put(k73, v73);
+        map.put(k74, v74);
+        map.put(k75, v75);
+        map.put(k76, v76);
+        map.put(k77, v77);
+        map.put(k78, v78);
+        map.put(k79, v79);
+        map.put(k80, v80);
+        map.put(k81, v81);
+        map.put(k82, v82);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69, K k70, V v70, K k71, V v71, K k72, V v72, K k73, V v73, K k74, V v74, K k75, V v75, K k76, V v76, K k77, V v77, K k78, V v78, K k79, V v79, K k80, V v80, K k81, V v81, K k82, V v82, K k83, V v83) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+        map.put(k70, v70);
+        map.put(k71, v71);
+        map.put(k72, v72);
+        map.put(k73, v73);
+        map.put(k74, v74);
+        map.put(k75, v75);
+        map.put(k76, v76);
+        map.put(k77, v77);
+        map.put(k78, v78);
+        map.put(k79, v79);
+        map.put(k80, v80);
+        map.put(k81, v81);
+        map.put(k82, v82);
+        map.put(k83, v83);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69, K k70, V v70, K k71, V v71, K k72, V v72, K k73, V v73, K k74, V v74, K k75, V v75, K k76, V v76, K k77, V v77, K k78, V v78, K k79, V v79, K k80, V v80, K k81, V v81, K k82, V v82, K k83, V v83, K k84, V v84) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+        map.put(k70, v70);
+        map.put(k71, v71);
+        map.put(k72, v72);
+        map.put(k73, v73);
+        map.put(k74, v74);
+        map.put(k75, v75);
+        map.put(k76, v76);
+        map.put(k77, v77);
+        map.put(k78, v78);
+        map.put(k79, v79);
+        map.put(k80, v80);
+        map.put(k81, v81);
+        map.put(k82, v82);
+        map.put(k83, v83);
+        map.put(k84, v84);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69, K k70, V v70, K k71, V v71, K k72, V v72, K k73, V v73, K k74, V v74, K k75, V v75, K k76, V v76, K k77, V v77, K k78, V v78, K k79, V v79, K k80, V v80, K k81, V v81, K k82, V v82, K k83, V v83, K k84, V v84, K k85, V v85) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+        map.put(k70, v70);
+        map.put(k71, v71);
+        map.put(k72, v72);
+        map.put(k73, v73);
+        map.put(k74, v74);
+        map.put(k75, v75);
+        map.put(k76, v76);
+        map.put(k77, v77);
+        map.put(k78, v78);
+        map.put(k79, v79);
+        map.put(k80, v80);
+        map.put(k81, v81);
+        map.put(k82, v82);
+        map.put(k83, v83);
+        map.put(k84, v84);
+        map.put(k85, v85);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69, K k70, V v70, K k71, V v71, K k72, V v72, K k73, V v73, K k74, V v74, K k75, V v75, K k76, V v76, K k77, V v77, K k78, V v78, K k79, V v79, K k80, V v80, K k81, V v81, K k82, V v82, K k83, V v83, K k84, V v84, K k85, V v85, K k86, V v86) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+        map.put(k70, v70);
+        map.put(k71, v71);
+        map.put(k72, v72);
+        map.put(k73, v73);
+        map.put(k74, v74);
+        map.put(k75, v75);
+        map.put(k76, v76);
+        map.put(k77, v77);
+        map.put(k78, v78);
+        map.put(k79, v79);
+        map.put(k80, v80);
+        map.put(k81, v81);
+        map.put(k82, v82);
+        map.put(k83, v83);
+        map.put(k84, v84);
+        map.put(k85, v85);
+        map.put(k86, v86);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69, K k70, V v70, K k71, V v71, K k72, V v72, K k73, V v73, K k74, V v74, K k75, V v75, K k76, V v76, K k77, V v77, K k78, V v78, K k79, V v79, K k80, V v80, K k81, V v81, K k82, V v82, K k83, V v83, K k84, V v84, K k85, V v85, K k86, V v86, K k87, V v87) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+        map.put(k70, v70);
+        map.put(k71, v71);
+        map.put(k72, v72);
+        map.put(k73, v73);
+        map.put(k74, v74);
+        map.put(k75, v75);
+        map.put(k76, v76);
+        map.put(k77, v77);
+        map.put(k78, v78);
+        map.put(k79, v79);
+        map.put(k80, v80);
+        map.put(k81, v81);
+        map.put(k82, v82);
+        map.put(k83, v83);
+        map.put(k84, v84);
+        map.put(k85, v85);
+        map.put(k86, v86);
+        map.put(k87, v87);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69, K k70, V v70, K k71, V v71, K k72, V v72, K k73, V v73, K k74, V v74, K k75, V v75, K k76, V v76, K k77, V v77, K k78, V v78, K k79, V v79, K k80, V v80, K k81, V v81, K k82, V v82, K k83, V v83, K k84, V v84, K k85, V v85, K k86, V v86, K k87, V v87, K k88, V v88) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+        map.put(k70, v70);
+        map.put(k71, v71);
+        map.put(k72, v72);
+        map.put(k73, v73);
+        map.put(k74, v74);
+        map.put(k75, v75);
+        map.put(k76, v76);
+        map.put(k77, v77);
+        map.put(k78, v78);
+        map.put(k79, v79);
+        map.put(k80, v80);
+        map.put(k81, v81);
+        map.put(k82, v82);
+        map.put(k83, v83);
+        map.put(k84, v84);
+        map.put(k85, v85);
+        map.put(k86, v86);
+        map.put(k87, v87);
+        map.put(k88, v88);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69, K k70, V v70, K k71, V v71, K k72, V v72, K k73, V v73, K k74, V v74, K k75, V v75, K k76, V v76, K k77, V v77, K k78, V v78, K k79, V v79, K k80, V v80, K k81, V v81, K k82, V v82, K k83, V v83, K k84, V v84, K k85, V v85, K k86, V v86, K k87, V v87, K k88, V v88, K k89, V v89) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+        map.put(k70, v70);
+        map.put(k71, v71);
+        map.put(k72, v72);
+        map.put(k73, v73);
+        map.put(k74, v74);
+        map.put(k75, v75);
+        map.put(k76, v76);
+        map.put(k77, v77);
+        map.put(k78, v78);
+        map.put(k79, v79);
+        map.put(k80, v80);
+        map.put(k81, v81);
+        map.put(k82, v82);
+        map.put(k83, v83);
+        map.put(k84, v84);
+        map.put(k85, v85);
+        map.put(k86, v86);
+        map.put(k87, v87);
+        map.put(k88, v88);
+        map.put(k89, v89);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69, K k70, V v70, K k71, V v71, K k72, V v72, K k73, V v73, K k74, V v74, K k75, V v75, K k76, V v76, K k77, V v77, K k78, V v78, K k79, V v79, K k80, V v80, K k81, V v81, K k82, V v82, K k83, V v83, K k84, V v84, K k85, V v85, K k86, V v86, K k87, V v87, K k88, V v88, K k89, V v89, K k90, V v90) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+        map.put(k70, v70);
+        map.put(k71, v71);
+        map.put(k72, v72);
+        map.put(k73, v73);
+        map.put(k74, v74);
+        map.put(k75, v75);
+        map.put(k76, v76);
+        map.put(k77, v77);
+        map.put(k78, v78);
+        map.put(k79, v79);
+        map.put(k80, v80);
+        map.put(k81, v81);
+        map.put(k82, v82);
+        map.put(k83, v83);
+        map.put(k84, v84);
+        map.put(k85, v85);
+        map.put(k86, v86);
+        map.put(k87, v87);
+        map.put(k88, v88);
+        map.put(k89, v89);
+        map.put(k90, v90);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69, K k70, V v70, K k71, V v71, K k72, V v72, K k73, V v73, K k74, V v74, K k75, V v75, K k76, V v76, K k77, V v77, K k78, V v78, K k79, V v79, K k80, V v80, K k81, V v81, K k82, V v82, K k83, V v83, K k84, V v84, K k85, V v85, K k86, V v86, K k87, V v87, K k88, V v88, K k89, V v89, K k90, V v90, K k91, V v91) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+        map.put(k70, v70);
+        map.put(k71, v71);
+        map.put(k72, v72);
+        map.put(k73, v73);
+        map.put(k74, v74);
+        map.put(k75, v75);
+        map.put(k76, v76);
+        map.put(k77, v77);
+        map.put(k78, v78);
+        map.put(k79, v79);
+        map.put(k80, v80);
+        map.put(k81, v81);
+        map.put(k82, v82);
+        map.put(k83, v83);
+        map.put(k84, v84);
+        map.put(k85, v85);
+        map.put(k86, v86);
+        map.put(k87, v87);
+        map.put(k88, v88);
+        map.put(k89, v89);
+        map.put(k90, v90);
+        map.put(k91, v91);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69, K k70, V v70, K k71, V v71, K k72, V v72, K k73, V v73, K k74, V v74, K k75, V v75, K k76, V v76, K k77, V v77, K k78, V v78, K k79, V v79, K k80, V v80, K k81, V v81, K k82, V v82, K k83, V v83, K k84, V v84, K k85, V v85, K k86, V v86, K k87, V v87, K k88, V v88, K k89, V v89, K k90, V v90, K k91, V v91, K k92, V v92) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+        map.put(k70, v70);
+        map.put(k71, v71);
+        map.put(k72, v72);
+        map.put(k73, v73);
+        map.put(k74, v74);
+        map.put(k75, v75);
+        map.put(k76, v76);
+        map.put(k77, v77);
+        map.put(k78, v78);
+        map.put(k79, v79);
+        map.put(k80, v80);
+        map.put(k81, v81);
+        map.put(k82, v82);
+        map.put(k83, v83);
+        map.put(k84, v84);
+        map.put(k85, v85);
+        map.put(k86, v86);
+        map.put(k87, v87);
+        map.put(k88, v88);
+        map.put(k89, v89);
+        map.put(k90, v90);
+        map.put(k91, v91);
+        map.put(k92, v92);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69, K k70, V v70, K k71, V v71, K k72, V v72, K k73, V v73, K k74, V v74, K k75, V v75, K k76, V v76, K k77, V v77, K k78, V v78, K k79, V v79, K k80, V v80, K k81, V v81, K k82, V v82, K k83, V v83, K k84, V v84, K k85, V v85, K k86, V v86, K k87, V v87, K k88, V v88, K k89, V v89, K k90, V v90, K k91, V v91, K k92, V v92, K k93, V v93) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+        map.put(k70, v70);
+        map.put(k71, v71);
+        map.put(k72, v72);
+        map.put(k73, v73);
+        map.put(k74, v74);
+        map.put(k75, v75);
+        map.put(k76, v76);
+        map.put(k77, v77);
+        map.put(k78, v78);
+        map.put(k79, v79);
+        map.put(k80, v80);
+        map.put(k81, v81);
+        map.put(k82, v82);
+        map.put(k83, v83);
+        map.put(k84, v84);
+        map.put(k85, v85);
+        map.put(k86, v86);
+        map.put(k87, v87);
+        map.put(k88, v88);
+        map.put(k89, v89);
+        map.put(k90, v90);
+        map.put(k91, v91);
+        map.put(k92, v92);
+        map.put(k93, v93);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69, K k70, V v70, K k71, V v71, K k72, V v72, K k73, V v73, K k74, V v74, K k75, V v75, K k76, V v76, K k77, V v77, K k78, V v78, K k79, V v79, K k80, V v80, K k81, V v81, K k82, V v82, K k83, V v83, K k84, V v84, K k85, V v85, K k86, V v86, K k87, V v87, K k88, V v88, K k89, V v89, K k90, V v90, K k91, V v91, K k92, V v92, K k93, V v93, K k94, V v94) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+        map.put(k70, v70);
+        map.put(k71, v71);
+        map.put(k72, v72);
+        map.put(k73, v73);
+        map.put(k74, v74);
+        map.put(k75, v75);
+        map.put(k76, v76);
+        map.put(k77, v77);
+        map.put(k78, v78);
+        map.put(k79, v79);
+        map.put(k80, v80);
+        map.put(k81, v81);
+        map.put(k82, v82);
+        map.put(k83, v83);
+        map.put(k84, v84);
+        map.put(k85, v85);
+        map.put(k86, v86);
+        map.put(k87, v87);
+        map.put(k88, v88);
+        map.put(k89, v89);
+        map.put(k90, v90);
+        map.put(k91, v91);
+        map.put(k92, v92);
+        map.put(k93, v93);
+        map.put(k94, v94);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69, K k70, V v70, K k71, V v71, K k72, V v72, K k73, V v73, K k74, V v74, K k75, V v75, K k76, V v76, K k77, V v77, K k78, V v78, K k79, V v79, K k80, V v80, K k81, V v81, K k82, V v82, K k83, V v83, K k84, V v84, K k85, V v85, K k86, V v86, K k87, V v87, K k88, V v88, K k89, V v89, K k90, V v90, K k91, V v91, K k92, V v92, K k93, V v93, K k94, V v94, K k95, V v95) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+        map.put(k70, v70);
+        map.put(k71, v71);
+        map.put(k72, v72);
+        map.put(k73, v73);
+        map.put(k74, v74);
+        map.put(k75, v75);
+        map.put(k76, v76);
+        map.put(k77, v77);
+        map.put(k78, v78);
+        map.put(k79, v79);
+        map.put(k80, v80);
+        map.put(k81, v81);
+        map.put(k82, v82);
+        map.put(k83, v83);
+        map.put(k84, v84);
+        map.put(k85, v85);
+        map.put(k86, v86);
+        map.put(k87, v87);
+        map.put(k88, v88);
+        map.put(k89, v89);
+        map.put(k90, v90);
+        map.put(k91, v91);
+        map.put(k92, v92);
+        map.put(k93, v93);
+        map.put(k94, v94);
+        map.put(k95, v95);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69, K k70, V v70, K k71, V v71, K k72, V v72, K k73, V v73, K k74, V v74, K k75, V v75, K k76, V v76, K k77, V v77, K k78, V v78, K k79, V v79, K k80, V v80, K k81, V v81, K k82, V v82, K k83, V v83, K k84, V v84, K k85, V v85, K k86, V v86, K k87, V v87, K k88, V v88, K k89, V v89, K k90, V v90, K k91, V v91, K k92, V v92, K k93, V v93, K k94, V v94, K k95, V v95, K k96, V v96) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+        map.put(k70, v70);
+        map.put(k71, v71);
+        map.put(k72, v72);
+        map.put(k73, v73);
+        map.put(k74, v74);
+        map.put(k75, v75);
+        map.put(k76, v76);
+        map.put(k77, v77);
+        map.put(k78, v78);
+        map.put(k79, v79);
+        map.put(k80, v80);
+        map.put(k81, v81);
+        map.put(k82, v82);
+        map.put(k83, v83);
+        map.put(k84, v84);
+        map.put(k85, v85);
+        map.put(k86, v86);
+        map.put(k87, v87);
+        map.put(k88, v88);
+        map.put(k89, v89);
+        map.put(k90, v90);
+        map.put(k91, v91);
+        map.put(k92, v92);
+        map.put(k93, v93);
+        map.put(k94, v94);
+        map.put(k95, v95);
+        map.put(k96, v96);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69, K k70, V v70, K k71, V v71, K k72, V v72, K k73, V v73, K k74, V v74, K k75, V v75, K k76, V v76, K k77, V v77, K k78, V v78, K k79, V v79, K k80, V v80, K k81, V v81, K k82, V v82, K k83, V v83, K k84, V v84, K k85, V v85, K k86, V v86, K k87, V v87, K k88, V v88, K k89, V v89, K k90, V v90, K k91, V v91, K k92, V v92, K k93, V v93, K k94, V v94, K k95, V v95, K k96, V v96, K k97, V v97) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+        map.put(k70, v70);
+        map.put(k71, v71);
+        map.put(k72, v72);
+        map.put(k73, v73);
+        map.put(k74, v74);
+        map.put(k75, v75);
+        map.put(k76, v76);
+        map.put(k77, v77);
+        map.put(k78, v78);
+        map.put(k79, v79);
+        map.put(k80, v80);
+        map.put(k81, v81);
+        map.put(k82, v82);
+        map.put(k83, v83);
+        map.put(k84, v84);
+        map.put(k85, v85);
+        map.put(k86, v86);
+        map.put(k87, v87);
+        map.put(k88, v88);
+        map.put(k89, v89);
+        map.put(k90, v90);
+        map.put(k91, v91);
+        map.put(k92, v92);
+        map.put(k93, v93);
+        map.put(k94, v94);
+        map.put(k95, v95);
+        map.put(k96, v96);
+        map.put(k97, v97);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69, K k70, V v70, K k71, V v71, K k72, V v72, K k73, V v73, K k74, V v74, K k75, V v75, K k76, V v76, K k77, V v77, K k78, V v78, K k79, V v79, K k80, V v80, K k81, V v81, K k82, V v82, K k83, V v83, K k84, V v84, K k85, V v85, K k86, V v86, K k87, V v87, K k88, V v88, K k89, V v89, K k90, V v90, K k91, V v91, K k92, V v92, K k93, V v93, K k94, V v94, K k95, V v95, K k96, V v96, K k97, V v97, K k98, V v98) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+        map.put(k70, v70);
+        map.put(k71, v71);
+        map.put(k72, v72);
+        map.put(k73, v73);
+        map.put(k74, v74);
+        map.put(k75, v75);
+        map.put(k76, v76);
+        map.put(k77, v77);
+        map.put(k78, v78);
+        map.put(k79, v79);
+        map.put(k80, v80);
+        map.put(k81, v81);
+        map.put(k82, v82);
+        map.put(k83, v83);
+        map.put(k84, v84);
+        map.put(k85, v85);
+        map.put(k86, v86);
+        map.put(k87, v87);
+        map.put(k88, v88);
+        map.put(k89, v89);
+        map.put(k90, v90);
+        map.put(k91, v91);
+        map.put(k92, v92);
+        map.put(k93, v93);
+        map.put(k94, v94);
+        map.put(k95, v95);
+        map.put(k96, v96);
+        map.put(k97, v97);
+        map.put(k98, v98);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69, K k70, V v70, K k71, V v71, K k72, V v72, K k73, V v73, K k74, V v74, K k75, V v75, K k76, V v76, K k77, V v77, K k78, V v78, K k79, V v79, K k80, V v80, K k81, V v81, K k82, V v82, K k83, V v83, K k84, V v84, K k85, V v85, K k86, V v86, K k87, V v87, K k88, V v88, K k89, V v89, K k90, V v90, K k91, V v91, K k92, V v92, K k93, V v93, K k94, V v94, K k95, V v95, K k96, V v96, K k97, V v97, K k98, V v98, K k99, V v99) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+        map.put(k70, v70);
+        map.put(k71, v71);
+        map.put(k72, v72);
+        map.put(k73, v73);
+        map.put(k74, v74);
+        map.put(k75, v75);
+        map.put(k76, v76);
+        map.put(k77, v77);
+        map.put(k78, v78);
+        map.put(k79, v79);
+        map.put(k80, v80);
+        map.put(k81, v81);
+        map.put(k82, v82);
+        map.put(k83, v83);
+        map.put(k84, v84);
+        map.put(k85, v85);
+        map.put(k86, v86);
+        map.put(k87, v87);
+        map.put(k88, v88);
+        map.put(k89, v89);
+        map.put(k90, v90);
+        map.put(k91, v91);
+        map.put(k92, v92);
+        map.put(k93, v93);
+        map.put(k94, v94);
+        map.put(k95, v95);
+        map.put(k96, v96);
+        map.put(k97, v97);
+        map.put(k98, v98);
+        map.put(k99, v99);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10, K k11, V v11, K k12, V v12, K k13, V v13, K k14, V v14, K k15, V v15, K k16, V v16, K k17, V v17, K k18, V v18, K k19, V v19, K k20, V v20, K k21, V v21, K k22, V v22, K k23, V v23, K k24, V v24, K k25, V v25, K k26, V v26, K k27, V v27, K k28, V v28, K k29, V v29, K k30, V v30, K k31, V v31, K k32, V v32, K k33, V v33, K k34, V v34, K k35, V v35, K k36, V v36, K k37, V v37, K k38, V v38, K k39, V v39, K k40, V v40, K k41, V v41, K k42, V v42, K k43, V v43, K k44, V v44, K k45, V v45, K k46, V v46, K k47, V v47, K k48, V v48, K k49, V v49, K k50, V v50, K k51, V v51, K k52, V v52, K k53, V v53, K k54, V v54, K k55, V v55, K k56, V v56, K k57, V v57, K k58, V v58, K k59, V v59, K k60, V v60, K k61, V v61, K k62, V v62, K k63, V v63, K k64, V v64, K k65, V v65, K k66, V v66, K k67, V v67, K k68, V v68, K k69, V v69, K k70, V v70, K k71, V v71, K k72, V v72, K k73, V v73, K k74, V v74, K k75, V v75, K k76, V v76, K k77, V v77, K k78, V v78, K k79, V v79, K k80, V v80, K k81, V v81, K k82, V v82, K k83, V v83, K k84, V v84, K k85, V v85, K k86, V v86, K k87, V v87, K k88, V v88, K k89, V v89, K k90, V v90, K k91, V v91, K k92, V v92, K k93, V v93, K k94, V v94, K k95, V v95, K k96, V v96, K k97, V v97, K k98, V v98, K k99, V v99, K k100, V v100) {
+        Map<K, V> map = new LinkedHashMap<K, V>();
+
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        map.put(k6, v6);
+        map.put(k7, v7);
+        map.put(k8, v8);
+        map.put(k9, v9);
+        map.put(k10, v10);
+        map.put(k11, v11);
+        map.put(k12, v12);
+        map.put(k13, v13);
+        map.put(k14, v14);
+        map.put(k15, v15);
+        map.put(k16, v16);
+        map.put(k17, v17);
+        map.put(k18, v18);
+        map.put(k19, v19);
+        map.put(k20, v20);
+        map.put(k21, v21);
+        map.put(k22, v22);
+        map.put(k23, v23);
+        map.put(k24, v24);
+        map.put(k25, v25);
+        map.put(k26, v26);
+        map.put(k27, v27);
+        map.put(k28, v28);
+        map.put(k29, v29);
+        map.put(k30, v30);
+        map.put(k31, v31);
+        map.put(k32, v32);
+        map.put(k33, v33);
+        map.put(k34, v34);
+        map.put(k35, v35);
+        map.put(k36, v36);
+        map.put(k37, v37);
+        map.put(k38, v38);
+        map.put(k39, v39);
+        map.put(k40, v40);
+        map.put(k41, v41);
+        map.put(k42, v42);
+        map.put(k43, v43);
+        map.put(k44, v44);
+        map.put(k45, v45);
+        map.put(k46, v46);
+        map.put(k47, v47);
+        map.put(k48, v48);
+        map.put(k49, v49);
+        map.put(k50, v50);
+        map.put(k51, v51);
+        map.put(k52, v52);
+        map.put(k53, v53);
+        map.put(k54, v54);
+        map.put(k55, v55);
+        map.put(k56, v56);
+        map.put(k57, v57);
+        map.put(k58, v58);
+        map.put(k59, v59);
+        map.put(k60, v60);
+        map.put(k61, v61);
+        map.put(k62, v62);
+        map.put(k63, v63);
+        map.put(k64, v64);
+        map.put(k65, v65);
+        map.put(k66, v66);
+        map.put(k67, v67);
+        map.put(k68, v68);
+        map.put(k69, v69);
+        map.put(k70, v70);
+        map.put(k71, v71);
+        map.put(k72, v72);
+        map.put(k73, v73);
+        map.put(k74, v74);
+        map.put(k75, v75);
+        map.put(k76, v76);
+        map.put(k77, v77);
+        map.put(k78, v78);
+        map.put(k79, v79);
+        map.put(k80, v80);
+        map.put(k81, v81);
+        map.put(k82, v82);
+        map.put(k83, v83);
+        map.put(k84, v84);
+        map.put(k85, v85);
+        map.put(k86, v86);
+        map.put(k87, v87);
+        map.put(k88, v88);
+        map.put(k89, v89);
+        map.put(k90, v90);
+        map.put(k91, v91);
+        map.put(k92, v92);
+        map.put(k93, v93);
+        map.put(k94, v94);
+        map.put(k95, v95);
+        map.put(k96, v96);
+        map.put(k97, v97);
+        map.put(k98, v98);
+        map.put(k99, v99);
+        map.put(k100, v100);
+
+        return Collections.unmodifiableMap(map);
+    }
+
+    /**
+     * Returns the inverse view of this map, and duplicated key is not allowed
+     *
+     * @param map the map to inverse
+     * @param <K> key type
+     * @param <V> value type
+     * @return the inverse view of this map
+     */
+    public static <K, V> Map<V, K> inverse(Map<K, V> map) {
+        return inverse(map, false);
+    }
+
+    /**
+     * Returns the inverse view of this map
+     *
+     * @param map the map to inverse
+     * @param force whether to put anyway even if duplicated key exists
+     * @param <K> key type
+     * @param <V> value type
+     * @return the inverse view of this map
+     */
+    public static <K, V> Map<V, K> inverse(Map<K, V> map, boolean force) {
+        // Because we can not rely on 3rd party library(excluding antlr, asm), we have to implement our own utils such as the `inverse` method...
+        // Actually `BiMap` of Guava and `BidiMap` of commons-collections are both suitable for this scenario.
+
+        Map<V, K> resultMap = new LinkedHashMap<>();
+
+        for (Map.Entry<K, V> entry : map.entrySet()) {
+            V value = entry.getValue();
+
+            if (!force && resultMap.containsKey(value)) {
+                throw new IllegalArgumentException("duplicated key found: " + value);
+            }
+
+            resultMap.put(value, entry.getKey());
+        }
+
+        return Collections.<V, K>unmodifiableMap(resultMap);
+    }
+}
diff --git a/src/main/org/codehaus/groovy/ast/PackageNode.java b/src/main/org/codehaus/groovy/ast/PackageNode.java
index d4fb15a258..097c7f924a 100644
--- a/src/main/org/codehaus/groovy/ast/PackageNode.java
+++ b/src/main/org/codehaus/groovy/ast/PackageNode.java
@@ -1,46 +1,44 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-package org.codehaus.groovy.ast;
-
-/**
- * Represents a package in the AST.
- *
- * @author Paul King
- */
-public class PackageNode extends AnnotatedNode {
-    private String name;
-
-    public PackageNode(String name) {
-        this.name = name;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    /**
-     * @return the text display of this package definition
-     */
-    public String getText() {
-        return "package " + name;
-    }
-
-    public void visit(GroovyCodeVisitor visitor) {
-    }
-}
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.codehaus.groovy.ast;
+
+/**
+ * Represents a package in the AST.
+ */
+public class PackageNode extends AnnotatedNode {
+    private final String name;
+
+    public PackageNode(String name) {
+        this.name = name;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * @return the text display of this package definition
+     */
+    public String getText() {
+        return "package " + name;
+    }
+
+    public void visit(GroovyCodeVisitor visitor) {
+    }
+}
diff --git a/src/main/org/codehaus/groovy/ast/tools/GeneralUtils.java b/src/main/org/codehaus/groovy/ast/tools/GeneralUtils.java
index f6455e5abd..4c809099f7 100644
--- a/src/main/org/codehaus/groovy/ast/tools/GeneralUtils.java
+++ b/src/main/org/codehaus/groovy/ast/tools/GeneralUtils.java
@@ -24,6 +24,7 @@ import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.FieldNode;
 import org.codehaus.groovy.ast.MethodNode;
+import org.codehaus.groovy.ast.PackageNode;
 import org.codehaus.groovy.ast.Parameter;
 import org.codehaus.groovy.ast.PropertyNode;
 import org.codehaus.groovy.ast.Variable;
@@ -61,6 +62,7 @@ import org.codehaus.groovy.syntax.Token;
 import org.codehaus.groovy.syntax.Types;
 import org.codehaus.groovy.transform.AbstractASTTransformation;
 
+import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.LinkedHashSet;
@@ -466,6 +468,24 @@ public class GeneralUtils {
         return false;
     }
 
+    public static boolean inSamePackage(final ClassNode first, final ClassNode second) {
+        PackageNode firstPackage = first.getPackage();
+        PackageNode secondPackage = second.getPackage();
+        return ((firstPackage == null && secondPackage == null) ||
+                        firstPackage != null && secondPackage != null && firstPackage.getName().equals(secondPackage.getName()));
+    }
+
+    public static boolean inSamePackage(final Class first, final Class second) {
+        Package firstPackage = first.getPackage();
+        Package secondPackage = second.getPackage();
+        return ((firstPackage == null && secondPackage == null) ||
+                        firstPackage != null && secondPackage != null && firstPackage.getName().equals(secondPackage.getName()));
+    }
+
+    public static boolean isDefaultVisibility(final int modifiers) {
+        return (modifiers & (Modifier.PRIVATE | Modifier.PUBLIC | Modifier.PROTECTED)) == 0;
+    }
+
     public static BinaryExpression hasEqualFieldX(FieldNode fNode, Expression other) {
         return eqX(varX(fNode), propX(other, fNode.getName()));
     }
diff --git a/src/main/org/codehaus/groovy/classgen/asm/util/TypeUtil.java b/src/main/org/codehaus/groovy/classgen/asm/util/TypeUtil.java
new file mode 100644
index 0000000000..cae9bfa921
--- /dev/null
+++ b/src/main/org/codehaus/groovy/classgen/asm/util/TypeUtil.java
@@ -0,0 +1,216 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.codehaus.groovy.classgen.asm.util;
+
+import groovy.lang.Tuple2;
+import org.apache.groovy.util.Maps;
+import org.codehaus.groovy.ast.ClassNode;
+import org.objectweb.asm.Type;
+
+import java.util.Map;
+
+import static org.codehaus.groovy.ast.ClassHelper.VOID_TYPE;
+import static org.codehaus.groovy.ast.ClassHelper.boolean_TYPE;
+import static org.codehaus.groovy.ast.ClassHelper.byte_TYPE;
+import static org.codehaus.groovy.ast.ClassHelper.char_TYPE;
+import static org.codehaus.groovy.ast.ClassHelper.double_TYPE;
+import static org.codehaus.groovy.ast.ClassHelper.float_TYPE;
+import static org.codehaus.groovy.ast.ClassHelper.int_TYPE;
+import static org.codehaus.groovy.ast.ClassHelper.long_TYPE;
+import static org.codehaus.groovy.ast.ClassHelper.short_TYPE;
+import static org.objectweb.asm.Opcodes.ALOAD;
+import static org.objectweb.asm.Opcodes.ARETURN;
+import static org.objectweb.asm.Opcodes.DLOAD;
+import static org.objectweb.asm.Opcodes.DRETURN;
+import static org.objectweb.asm.Opcodes.FLOAD;
+import static org.objectweb.asm.Opcodes.FRETURN;
+import static org.objectweb.asm.Opcodes.ILOAD;
+import static org.objectweb.asm.Opcodes.IRETURN;
+import static org.objectweb.asm.Opcodes.LLOAD;
+import static org.objectweb.asm.Opcodes.LRETURN;
+
+/**
+ * A utility for getting information of types
+ *
+ * @since 2.5.0
+ */
+public abstract class TypeUtil {
+    public static Class autoboxType(Class type) {
+        final Class res = PRIMITIVE_TYPE_TO_WRAPPED_CLASS_MAP.get(type);
+        return res == null ? type : res;
+    }
+
+    public static int getLoadInsnByType(Type type) {
+        Integer insn = PRIMITIVE_TYPE_TO_LOAD_INSN_MAP.get(type);
+
+        if (null != insn) {
+            return insn;
+        }
+
+        return ALOAD;
+    }
+
+    public static int getReturnInsnByType(Type type) {
+        Integer insn = PRIMITIVE_TYPE_TO_RETURN_INSN_MAP.get(type);
+
+        if (null != insn) {
+            return insn;
+        }
+
+        return ARETURN;
+    }
+
+    public static String getWrappedClassDescriptor(Type type) {
+        String desc = PRIMITIVE_TYPE_TO_WRAPPED_CLASS_DESCRIPTOR_MAP.get(type);
+
+        if (null != desc) {
+            return desc;
+        }
+
+        throw new IllegalArgumentException("Unexpected type class [" + type + "]");
+    }
+
+    public static boolean isPrimitiveType(Type type) {
+        return PRIMITIVE_TYPE_TO_LOAD_INSN_MAP.containsKey(type);
+    }
+
+    public static boolean isPrimitiveType(String name) {
+        return NAME_TO_PRIMITIVE_TYPE_MAP.containsKey(name);
+    }
+
+    public static boolean isPrimitiveType(ClassNode type) {
+        return PRIMITIVE_TYPE_TO_DESCRIPTION_MAP.containsKey(type);
+    }
+
+    public static String getDescriptionByType(ClassNode type) {
+        String desc = PRIMITIVE_TYPE_TO_DESCRIPTION_MAP.get(type);
+
+        if (null == desc) { // reference type
+            if (!type.isArray()) {
+                return makeRefDescription(type.getName());
+            }
+
+            StringBuilder arrayDescription = new StringBuilder(32);
+            Tuple2<ClassNode, Integer> arrayInfo = extractArrayInfo(type);
+
+            for (int i = 0, dimension = arrayInfo.getSecond(); i < dimension; i++) {
+                arrayDescription.append("[");
+            }
+
+            ClassNode componentType = arrayInfo.getFirst();
+            return arrayDescription.append(getDescriptionByType(componentType)).toString();
+        }
+
+        return desc;
+    }
+
+    public static String getDescriptionByName(String name) {
+        ClassNode type = NAME_TO_PRIMITIVE_TYPE_MAP.get(name);
+
+        if (null == type) {
+            return makeRefDescription(name);
+        }
+
+        return getDescriptionByType(type);
+    }
+
+    private static String makeRefDescription(String name) {
+        return REF_DESCRIPTION + name.replace('.', '/') + ";";
+    }
+
+    private static Tuple2<ClassNode, Integer> extractArrayInfo(ClassNode type) {
+        int dimension = 0;
+
+        do {
+            dimension++;
+        } while ((type = type.getComponentType()).isArray());
+
+        return new Tuple2<ClassNode, Integer>(type, dimension);
+    }
+
+    private static final String REF_DESCRIPTION = "L";
+    private static final Map<ClassNode, String> PRIMITIVE_TYPE_TO_DESCRIPTION_MAP = Maps.of(
+            int_TYPE, "I",
+            VOID_TYPE,"V",
+            boolean_TYPE, "Z",
+            byte_TYPE, "B",
+            char_TYPE, "C",
+            short_TYPE, "S",
+            double_TYPE, "D",
+            float_TYPE, "F",
+            long_TYPE, "J"
+    );
+
+    private static final Map<String, ClassNode> NAME_TO_PRIMITIVE_TYPE_MAP = Maps.of(
+            "int", int_TYPE,
+            "void", VOID_TYPE,
+            "boolean", boolean_TYPE,
+            "byte", byte_TYPE,
+            "char", char_TYPE,
+            "short", short_TYPE,
+            "double", double_TYPE,
+            "float", float_TYPE,
+            "long", long_TYPE
+    );
+
+    private static final Map<Type, Integer> PRIMITIVE_TYPE_TO_LOAD_INSN_MAP = Maps.of(
+            Type.BOOLEAN_TYPE, ILOAD,
+            Type.BYTE_TYPE, ILOAD,
+            Type.CHAR_TYPE, ILOAD,
+            Type.DOUBLE_TYPE, DLOAD,
+            Type.FLOAT_TYPE, FLOAD,
+            Type.INT_TYPE, ILOAD,
+            Type.LONG_TYPE, LLOAD,
+            Type.SHORT_TYPE, ILOAD
+    );
+
+    private static final Map<Type, Integer> PRIMITIVE_TYPE_TO_RETURN_INSN_MAP = Maps.of(
+            Type.BOOLEAN_TYPE, IRETURN,
+            Type.BYTE_TYPE, IRETURN,
+            Type.CHAR_TYPE, IRETURN,
+            Type.DOUBLE_TYPE, DRETURN,
+            Type.FLOAT_TYPE, FRETURN,
+            Type.INT_TYPE, IRETURN,
+            Type.LONG_TYPE, LRETURN,
+            Type.SHORT_TYPE, IRETURN
+    );
+
+    private static final Map<Type, String> PRIMITIVE_TYPE_TO_WRAPPED_CLASS_DESCRIPTOR_MAP = Maps.of(
+            Type.BOOLEAN_TYPE, "java/lang/Boolean",
+            Type.BYTE_TYPE, "java/lang/Byte",
+            Type.CHAR_TYPE, "java/lang/Character",
+            Type.DOUBLE_TYPE, "java/lang/Double",
+            Type.FLOAT_TYPE, "java/lang/Float",
+            Type.INT_TYPE, "java/lang/Integer",
+            Type.LONG_TYPE, "java/lang/Long",
+            Type.SHORT_TYPE, "java/lang/Short"
+    );
+
+    private static final Map<Class<?>, Class<?>> PRIMITIVE_TYPE_TO_WRAPPED_CLASS_MAP = Maps.<Class<?>, Class<?>>of(
+        byte.class, Byte.class,
+        boolean.class, Boolean.class,
+        char.class, Character.class,
+        double.class, Double.class,
+        float.class, Float.class,
+        int.class, Integer.class,
+        long.class, Long.class,
+        short.class, Short.class
+    );
+}
diff --git a/src/main/org/codehaus/groovy/reflection/AccessPermissionChecker.java b/src/main/org/codehaus/groovy/reflection/AccessPermissionChecker.java
new file mode 100644
index 0000000000..ae297dfd09
--- /dev/null
+++ b/src/main/org/codehaus/groovy/reflection/AccessPermissionChecker.java
@@ -0,0 +1,100 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.codehaus.groovy.reflection;
+
+import groovy.lang.GroovyObject;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.lang.reflect.ReflectPermission;
+import java.security.AccessControlException;
+
+final class AccessPermissionChecker {
+
+    private static final ReflectPermission REFLECT_PERMISSION = new ReflectPermission("suppressAccessChecks");
+
+    private AccessPermissionChecker() {
+    }
+
+    private static void checkAccessPermission(Class<?> declaringClass, final int modifiers, boolean isAccessible) {
+        final SecurityManager securityManager = System.getSecurityManager();
+        if (securityManager != null && isAccessible) {
+            if (((modifiers & Modifier.PRIVATE) != 0
+                    || ((modifiers & (Modifier.PUBLIC | Modifier.PROTECTED)) == 0
+                    && packageCanNotBeAddedAnotherClass(declaringClass)))
+                    && !GroovyObject.class.isAssignableFrom(declaringClass)) {
+                securityManager.checkPermission(REFLECT_PERMISSION);
+            } else if ((modifiers & (Modifier.PROTECTED)) != 0 && declaringClass.equals(ClassLoader.class)) {
+                securityManager.checkCreateClassLoader();
+            }
+        }
+    }
+
+    private static boolean packageCanNotBeAddedAnotherClass(Class<?> declaringClass) {
+        return declaringClass.getName().startsWith("java.");
+    }
+
+    static void checkAccessPermission(Method method) {
+        try {
+            checkAccessPermission(method.getDeclaringClass(), method.getModifiers(), method.isAccessible());
+        } catch (AccessControlException e) {
+            throw createCacheAccessControlExceptionOf(method, e);
+        }
+    }
+
+    static void checkAccessPermission(Constructor constructor) {
+        try {
+            checkAccessPermission(constructor.getDeclaringClass(), constructor.getModifiers(), constructor.isAccessible());
+        } catch (AccessControlException e) {
+            throw createCacheAccessControlExceptionOf(constructor, e);
+        }
+    }
+
+    private static CacheAccessControlException createCacheAccessControlExceptionOf(Method method, AccessControlException e) {
+        return new CacheAccessControlException(
+                "Groovy object can not access method " + method.getName()
+                        + " cacheAccessControlExceptionOf class " + method.getDeclaringClass().getName()
+                        + " with modifiers \"" + Modifier.toString(method.getModifiers()) + "\"", e);
+    }
+
+    private static CacheAccessControlException createCacheAccessControlExceptionOf(Constructor constructor, AccessControlException e) {
+        return new CacheAccessControlException(
+                "Groovy object can not access constructor " + constructor.getName()
+                        + " cacheAccessControlExceptionOf class " + constructor.getDeclaringClass().getName()
+                        + " with modifiers \"" + Modifier.toString(constructor.getModifiers()) + "\"", e);
+    }
+
+    static void checkAccessPermission(Field field) {
+        try {
+            checkAccessPermission(field.getDeclaringClass(), field.getModifiers(), field.isAccessible());
+        } catch (AccessControlException e) {
+            throw createCacheAccessControlExceptionOf(field, e);
+        }
+    }
+
+    private static CacheAccessControlException createCacheAccessControlExceptionOf(Field field, AccessControlException e) {
+        return new CacheAccessControlException(
+                "Groovy object can not access field " + field.getName()
+                        + " cacheAccessControlExceptionOf class " + field.getDeclaringClass().getName()
+                        + " with modifiers \"" + Modifier.toString(field.getModifiers()) + "\"", e);
+    }
+
+}
diff --git a/src/main/org/codehaus/groovy/reflection/CacheAccessControlException.java b/src/main/org/codehaus/groovy/reflection/CacheAccessControlException.java
new file mode 100644
index 0000000000..8dfa960ec8
--- /dev/null
+++ b/src/main/org/codehaus/groovy/reflection/CacheAccessControlException.java
@@ -0,0 +1,29 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.codehaus.groovy.reflection;
+
+import groovy.lang.GroovyRuntimeException;
+
+public class CacheAccessControlException extends GroovyRuntimeException {
+    private static final long serialVersionUID = -5315107566539656474L;
+
+    public CacheAccessControlException(String message, Throwable cause) {
+        super(message, cause);
+    }
+}
diff --git a/src/main/org/codehaus/groovy/reflection/CachedClass.java b/src/main/org/codehaus/groovy/reflection/CachedClass.java
index 3a4918f53f..5127f22aeb 100644
--- a/src/main/org/codehaus/groovy/reflection/CachedClass.java
+++ b/src/main/org/codehaus/groovy/reflection/CachedClass.java
@@ -31,8 +31,6 @@ import org.codehaus.groovy.util.FastArray;
 import org.codehaus.groovy.util.LazyReference;
 import org.codehaus.groovy.util.ReferenceBundle;
 
-import java.lang.reflect.AccessibleObject;
-import java.lang.reflect.Array;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
@@ -49,9 +47,8 @@ import java.util.LinkedList;
 import java.util.List;
 import java.util.Set;
 
-/**
- * @author Alex.Tkachman
- */
+import static org.codehaus.groovy.reflection.ReflectionUtils.checkCanSetAccessible;
+
 public class CachedClass {
     private static final Method[] EMPTY_METHOD_ARRAY = new Method[0];
     private final Class cachedClass;
@@ -63,15 +60,17 @@ public class CachedClass {
         private static final long serialVersionUID = 5450437842165410025L;
 
         public CachedField[] initValue() {
-            final Field[] declaredFields = (Field[])
-               AccessController.doPrivileged(new PrivilegedAction<Field[]>() {
-                   public Field[] run() {
-                       Field[] df = getTheClass().getDeclaredFields();
-                       df = (Field[]) makeAccessible(df);
-                       return df;                                                   
-                   }
-               });
-            CachedField [] fields = new CachedField[declaredFields.length];
+            final Field[] declaredFields = AccessController.doPrivileged(new PrivilegedAction<Field[]>() {
+                public Field[] run() {
+                    Field[] df = getTheClass().getDeclaredFields();
+                    df = Arrays.stream(df)
+                            .filter(f -> checkCanSetAccessible(f, CachedClass.class))
+                            .toArray(Field[]::new);
+//                    df = (Field[]) ReflectionUtils.makeAccessible(df);
+                    return df;
+                }
+            });
+            CachedField[] fields = new CachedField[declaredFields.length];
             for (int i = 0; i != fields.length; ++i)
                 fields[i] = new CachedField(declaredFields[i]);
             return fields;
@@ -83,49 +82,36 @@ public class CachedClass {
 
         public CachedConstructor[] initValue() {
             final Constructor[] declaredConstructors = (Constructor[])
-               AccessController.doPrivileged(new PrivilegedAction/*<Constructor[]>*/() {
-                   public /*Constructor[]*/ Object run() {
-                       return getTheClass().getDeclaredConstructors();
+               AccessController.doPrivileged(new PrivilegedAction<Constructor[]>() {
+                   public Constructor[] run() {
+                       Constructor[] dc = getTheClass().getDeclaredConstructors();
+                       dc = Arrays.stream(dc)
+                               .filter(c -> checkCanSetAccessible(c, CachedClass.class))
+                               .toArray(Constructor[]::new);
+
+                       return dc;
                    }
                });
-            CachedConstructor [] constructors = new CachedConstructor[declaredConstructors.length];
+            CachedConstructor[] constructors = new CachedConstructor[declaredConstructors.length];
             for (int i = 0; i != constructors.length; ++i)
                 constructors[i] = new CachedConstructor(CachedClass.this, declaredConstructors[i]);
             return constructors;
         }
     };
 
-    // to be run in PrivilegedAction!
-    private static AccessibleObject[] makeAccessible(final AccessibleObject[] aoa) {
-        try {
-            AccessibleObject.setAccessible(aoa, true);
-            return aoa;
-        } catch (Throwable outer) {
-            // swallow for strict security managers, module systems, android or others,
-            // but try one-by-one to get the allowed ones at least
-            final ArrayList<AccessibleObject> ret = new ArrayList<AccessibleObject>(aoa.length);
-            for (final AccessibleObject ao : aoa) {
-                try {
-                    ao.setAccessible(true);
-                    ret.add(ao);
-                } catch (Throwable inner) {
-                    // swallow for strict security managers, module systems, android or others
-                }
-            }
-            return ret.toArray((AccessibleObject[]) Array.newInstance(aoa.getClass().getComponentType(), ret.size()));
-        }
-    }
-
     private final LazyReference<CachedMethod[]> methods = new LazyReference<CachedMethod[]>(softBundle) {
         private static final long serialVersionUID = 6347586066597418308L;
 
         public CachedMethod[] initValue() {
-            final Method[] declaredMethods = (Method[])
-               AccessController.doPrivileged(new PrivilegedAction/*<Method[]>*/() {
-                   public /*Method[]*/ Object run() {
+            final Method[] declaredMethods =
+               AccessController.doPrivileged(new PrivilegedAction<Method[]>() {
+                   public Method[] run() {
                        try {
                            Method[] dm = getTheClass().getDeclaredMethods();
-                           dm = (Method[]) makeAccessible(dm);
+                           dm = Arrays.stream(dm)
+                                   .filter(m -> checkCanSetAccessible(m, CachedClass.class))
+                                   .toArray(Method[]::new);
+//                           dm = (Method[]) ReflectionUtils.makeAccessible(dm);
                            return dm;
                        } catch (Throwable e) {
                            // Typically, Android can throw ClassNotFoundException
@@ -151,7 +137,7 @@ public class CachedClass {
                 else
                   methods.add(cachedMethod);
             }
-            CachedMethod [] resMethods = methods.toArray(new CachedMethod[methods.size()]);
+            CachedMethod[] resMethods = methods.toArray(CachedMethod.EMPTY_ARRAY);
             Arrays.sort(resMethods);
 
             final CachedClass superClass = getCachedSuperClass();
@@ -221,7 +207,7 @@ public class CachedClass {
 
     int hashCode;
 
-    public  CachedMethod [] mopMethods;
+    public  CachedMethod[] mopMethods;
     public static final CachedClass[] EMPTY_ARRAY = new CachedClass[0];
 
     private final LazyReference<Set<CachedClass>> declaredInterfaces = new LazyReference<Set<CachedClass>> (softBundle) {
diff --git a/src/main/org/codehaus/groovy/reflection/CachedConstructor.java b/src/main/org/codehaus/groovy/reflection/CachedConstructor.java
index 74d9b713a0..fc04281332 100644
--- a/src/main/org/codehaus/groovy/reflection/CachedConstructor.java
+++ b/src/main/org/codehaus/groovy/reflection/CachedConstructor.java
@@ -24,34 +24,19 @@ import org.codehaus.groovy.runtime.InvokerInvocationException;
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
+
+import static org.codehaus.groovy.reflection.ReflectionUtils.makeAccessibleInPrivilegedAction;
 
 /**
  * @author Alex.Tkachman
  */
 public class CachedConstructor extends ParameterTypes {
-    CachedClass clazz;
-
-    public final Constructor cachedConstructor;
+    private final CachedClass clazz;
+    private final Constructor cachedConstructor;
 
     public CachedConstructor(CachedClass clazz, final Constructor c) {
         this.cachedConstructor = c;
         this.clazz = clazz;
-        try {
-            AccessController.doPrivileged(new PrivilegedAction() {
-                public Object run() {
-                    c.setAccessible(true);
-                    return null;
-                }
-            });
-        } catch (SecurityException e) {
-            // IGNORE
-        } catch (RuntimeException re) {
-            // test for JDK9 JIGSAW
-            if (!"java.lang.reflect.InaccessibleObjectException".equals(re.getClass().getName())) throw re;
-            // else IGNORE
-        }
     }
 
     public CachedConstructor(Constructor c) {
@@ -78,6 +63,8 @@ public class CachedConstructor extends ParameterTypes {
     }
 
     public Object invoke(Object[] argumentArray) {
+        makeAccessibleIfNecessary();
+
         Constructor constr = cachedConstructor;
         try {
             return constr.newInstance(argumentArray);
@@ -113,4 +100,22 @@ public class CachedConstructor extends ParameterTypes {
     public CachedClass getCachedClass() {
         return clazz;
     }
+
+    public Class getDeclaringClass() {
+        return cachedConstructor.getDeclaringClass();
+    }
+
+    public Constructor getCachedConstructor() {
+        makeAccessibleIfNecessary();
+        AccessPermissionChecker.checkAccessPermission(cachedConstructor);
+        return cachedConstructor;
+    }
+
+    private boolean makeAccessibleDone = false;
+    private void makeAccessibleIfNecessary() {
+        if (!makeAccessibleDone) {
+            makeAccessibleInPrivilegedAction(cachedConstructor);
+            makeAccessibleDone = true;
+        }
+    }
 }
diff --git a/src/main/org/codehaus/groovy/reflection/CachedField.java b/src/main/org/codehaus/groovy/reflection/CachedField.java
index 543a373653..c2b5dd4c10 100644
--- a/src/main/org/codehaus/groovy/reflection/CachedField.java
+++ b/src/main/org/codehaus/groovy/reflection/CachedField.java
@@ -25,12 +25,14 @@ import org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation;
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
 
+import static org.codehaus.groovy.reflection.ReflectionUtils.makeAccessibleInPrivilegedAction;
+
 public class CachedField extends MetaProperty {
-    public final Field field;
+    private final Field cachedField;
 
     public CachedField(Field field) {
         super (field.getName(), field.getType());
-        this.field = field;
+        this.cachedField = field;
     }
 
     public boolean isStatic() {
@@ -42,7 +44,7 @@ public class CachedField extends MetaProperty {
     }
 
     public int getModifiers() {
-        return field.getModifiers();
+        return cachedField.getModifiers();
     }
 
     /**
@@ -50,8 +52,10 @@ public class CachedField extends MetaProperty {
      * @throws RuntimeException if the property could not be evaluated
      */
     public Object getProperty(final Object object) {
+        makeAccessibleIfNecessary();
+        AccessPermissionChecker.checkAccessPermission(cachedField);
         try {
-            return field.get(object);
+            return cachedField.get(object);
         } catch (IllegalAccessException e) {
             throw new GroovyRuntimeException("Cannot get the property '" + name + "'.", e);
         }
@@ -65,15 +69,35 @@ public class CachedField extends MetaProperty {
      * @throws RuntimeException if the property could not be set
      */
     public void setProperty(final Object object, Object newValue) {
-        final Object goalValue = DefaultTypeTransformation.castToType(newValue, field.getType());
+        makeAccessibleIfNecessary();
+        AccessPermissionChecker.checkAccessPermission(cachedField);
+        final Object goalValue = DefaultTypeTransformation.castToType(newValue, cachedField.getType());
 
         if (isFinal()) {
             throw new GroovyRuntimeException("Cannot set the property '" + name + "' because the backing field is final.");
         }
         try {
-            field.set(object, goalValue);
+            cachedField.set(object, goalValue);
         } catch (IllegalAccessException ex) {
             throw new GroovyRuntimeException("Cannot set the property '" + name + "'.", ex);
         }
     }
+
+    public Class getDeclaringClass() {
+        return cachedField.getDeclaringClass();
+    }
+
+    public Field getCachedField() {
+        makeAccessibleIfNecessary();
+        AccessPermissionChecker.checkAccessPermission(cachedField);
+        return cachedField;
+    }
+
+    private boolean makeAccessibleDone = false;
+    private void makeAccessibleIfNecessary() {
+        if (!makeAccessibleDone) {
+            makeAccessibleInPrivilegedAction(cachedField);
+            makeAccessibleDone = true;
+        }
+    }
 }
diff --git a/src/main/org/codehaus/groovy/reflection/CachedMethod.java b/src/main/org/codehaus/groovy/reflection/CachedMethod.java
index 0c8dac0489..b9e319c787 100644
--- a/src/main/org/codehaus/groovy/reflection/CachedMethod.java
+++ b/src/main/org/codehaus/groovy/reflection/CachedMethod.java
@@ -31,6 +31,7 @@ import org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite;
 import org.codehaus.groovy.runtime.metaclass.MethodHelper;
 
 import java.io.Serializable;
+import java.lang.annotation.Annotation;
 import java.lang.ref.SoftReference;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
@@ -38,16 +39,16 @@ import java.lang.reflect.Method;
 import java.util.Arrays;
 import java.util.Comparator;
 
-/**
- * @author Alex.Tkachman
- */
+import static org.codehaus.groovy.reflection.ReflectionUtils.makeAccessibleInPrivilegedAction;
+
 public class CachedMethod extends MetaMethod implements Comparable {
+    public static final CachedMethod[] EMPTY_ARRAY = new CachedMethod[0];
     public final CachedClass cachedClass;
 
     private final Method cachedMethod;
     private int hashCode;
 
-    private static MyComparator comparator = new MyComparator();
+    private static final MyComparator COMPARATOR = new MyComparator();
 
     private SoftReference<Constructor> pogoCallSiteConstructor, pojoCallSiteConstructor, staticCallSiteConstructor;
 
@@ -70,14 +71,14 @@ public class CachedMethod extends MetaMethod implements Comparable {
 //                return cachedMethod;
 //        }
 //        return null;
-        int i = Arrays.binarySearch(methods, method, comparator);
+        int i = Arrays.binarySearch(methods, method, COMPARATOR);
         if (i < 0)
           return null;
 
         return methods[i];
     }
 
-    protected Class[] getPT() {
+    public Class[] getPT() {
         return cachedMethod.getParameterTypes();
     }
 
@@ -94,11 +95,33 @@ public class CachedMethod extends MetaMethod implements Comparable {
     }
 
     public final Object invoke(Object object, Object[] arguments) {
+        /*
+        CachedMethod transformedCachedMethod =
+                (CachedMethod) CallSiteHelper.transformMetaMethod(
+                        InvokerHelper.getMetaClass(object.getClass()),
+                        this,
+                        this.getPT(),
+                        CachedMethod.class);
+
+        Method cachedMethod = transformedCachedMethod.cachedMethod;
+
+        if (transformedCachedMethod == this) {
+            makeAccessibleIfNecessary();
+        } else {
+            ReflectionUtils.trySetAccessible(cachedMethod);
+        }
+        */
+
+        makeAccessibleIfNecessary();
+
+        try {
+            AccessPermissionChecker.checkAccessPermission(cachedMethod);
+        } catch (CacheAccessControlException ex) {
+            throw new InvokerInvocationException(ex);
+        }
         try {
             return cachedMethod.invoke(object, arguments);
-        } catch (IllegalArgumentException e) {
-            throw new InvokerInvocationException(e);
-        } catch (IllegalAccessException e) {
+        } catch (IllegalArgumentException | IllegalAccessException e) {
             throw new InvokerInvocationException(e);
         } catch (InvocationTargetException e) {
             Throwable cause = e.getCause(); 
@@ -129,6 +152,9 @@ public class CachedMethod extends MetaMethod implements Comparable {
     }
 
     public final Method setAccessible() {
+        makeAccessibleIfNecessary();
+
+        AccessPermissionChecker.checkAccessPermission(cachedMethod);
 //        if (queuedToCompile.compareAndSet(false,true)) {
 //            if (isCompilable())
 //              CompileThread.addMethod(this);
@@ -330,9 +356,25 @@ public class CachedMethod extends MetaMethod implements Comparable {
         }
     }
 
+    public <T extends Annotation> T getAnnotation(Class<T> annotationClass) {
+        return cachedMethod.getAnnotation(annotationClass);
+    }
+
+    public boolean isSynthetic() {
+        return cachedMethod.isSynthetic();
+    }
+
     public Method getCachedMethod() {
+        makeAccessibleIfNecessary();
+        AccessPermissionChecker.checkAccessPermission(cachedMethod);
         return cachedMethod;
     }
 
+    private boolean makeAccessibleDone = false;
+    private void makeAccessibleIfNecessary() {
+        if (!makeAccessibleDone) {
+            makeAccessibleInPrivilegedAction(cachedMethod);
+            makeAccessibleDone = true;
+        }
+    }
 }
-
diff --git a/src/main/org/codehaus/groovy/reflection/ClassLoaderForClassArtifacts.java b/src/main/org/codehaus/groovy/reflection/ClassLoaderForClassArtifacts.java
index ba24a6d39c..f8f0dfa6f2 100644
--- a/src/main/org/codehaus/groovy/reflection/ClassLoaderForClassArtifacts.java
+++ b/src/main/org/codehaus/groovy/reflection/ClassLoaderForClassArtifacts.java
@@ -60,12 +60,16 @@ public class ClassLoaderForClassArtifacts extends ClassLoader {
     }
 
     public String createClassName(Method method) {
+        return createClassName(method.getName());
+    }
+
+    public String createClassName(String methodName) {
         final String name;
         final String clsName = klazz.get().getName();
         if (clsName.startsWith("java."))
-          name = clsName.replace('.','_') + "$" + method.getName();
+            name = clsName.replace('.','_') + "$" + methodName;
         else
-          name = clsName + "$" + method.getName();
+            name = clsName + "$" + methodName;
         int suffix = classNamesCounter.getAndIncrement();
         return suffix == -1? name : name + "$" + suffix;
     }
diff --git a/src/main/org/codehaus/groovy/reflection/MixinInMetaClass.java b/src/main/org/codehaus/groovy/reflection/MixinInMetaClass.java
index 2f58d5c529..1a592e685d 100644
--- a/src/main/org/codehaus/groovy/reflection/MixinInMetaClass.java
+++ b/src/main/org/codehaus/groovy/reflection/MixinInMetaClass.java
@@ -25,6 +25,7 @@ import groovy.lang.GroovySystem;
 import groovy.lang.MetaClass;
 import groovy.lang.MetaMethod;
 import groovy.lang.MetaProperty;
+import groovy.transform.Internal;
 import org.codehaus.groovy.runtime.HandleMetaClass;
 import org.codehaus.groovy.runtime.MetaClassHelper;
 import org.codehaus.groovy.runtime.metaclass.MixedInMetaClass;
@@ -134,7 +135,7 @@ public class MixinInMetaClass extends ManagedConcurrentMap {
                 if (!Modifier.isPublic(mod))
                     continue;
 
-                if (method instanceof CachedMethod && ((CachedMethod) method).getCachedMethod().isSynthetic())
+                if (method instanceof CachedMethod && ((CachedMethod) method).isSynthetic())
                     continue;
 
                 if (Modifier.isStatic(mod)) {
@@ -159,6 +160,10 @@ public class MixinInMetaClass extends ManagedConcurrentMap {
         }
     }
 
+    private static boolean hasAnnotation(CachedMethod method, Class<Internal> annotationClass) {
+        return method.getAnnotation(annotationClass) != null;
+    }
+
     private static void staticMethod(final MetaClass self, List<MetaMethod> arr, final CachedMethod method) {
         CachedClass[] paramTypes = method.getParameterTypes();
 
diff --git a/src/main/org/codehaus/groovy/reflection/ReflectionUtils.java b/src/main/org/codehaus/groovy/reflection/ReflectionUtils.java
index e621729823..03706d4611 100644
--- a/src/main/org/codehaus/groovy/reflection/ReflectionUtils.java
+++ b/src/main/org/codehaus/groovy/reflection/ReflectionUtils.java
@@ -18,9 +18,21 @@
  */
 package org.codehaus.groovy.reflection;
 
+import org.codehaus.groovy.classgen.asm.util.TypeUtil;
+import org.codehaus.groovy.vmplugin.VMPlugin;
+import org.codehaus.groovy.vmplugin.VMPluginFactory;
+
+import java.lang.reflect.AccessibleObject;
+import java.lang.reflect.Array;
+import java.lang.reflect.Method;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashSet;
+import java.util.List;
+import java.util.Optional;
 import java.util.Set;
 
 /**
@@ -29,9 +41,9 @@ import java.util.Set;
  * groovy MOP are excluded from the level counting.
  */
 public class ReflectionUtils {
-
     // these are packages in the call stack that are only part of the groovy MOP
     private static final Set<String> IGNORED_PACKAGES = new HashSet<String>();
+    private static final VMPlugin VM_PLUGIN = VMPluginFactory.getPlugin();
 
     static {
         //IGNORED_PACKAGES.add("java.lang.reflect");
@@ -41,6 +53,7 @@ public class ReflectionUtils {
         IGNORED_PACKAGES.add("org.codehaus.groovy.runtime.metaclass");
         IGNORED_PACKAGES.add("org.codehaus.groovy.runtime");
         IGNORED_PACKAGES.add("sun.reflect");
+        IGNORED_PACKAGES.add("java.security");
         IGNORED_PACKAGES.add("java.lang.invoke");
         IGNORED_PACKAGES.add("org.codehaus.groovy.vmplugin.v7");
     }
@@ -119,6 +132,85 @@ public class ReflectionUtils {
         }
     }
 
+    public static Optional<Method> getMethod(Class type, String name, Class<?>... parameterTypes) {
+        out:
+        for (Method m : type.getMethods()) {
+            if (!m.getName().equals(name)) {
+                continue;
+            }
+
+            Class<?>[] methodParameterTypes = m.getParameterTypes();
+            if (methodParameterTypes.length != parameterTypes.length) {
+                continue;
+            }
+
+            for (int i = 0, n = methodParameterTypes.length; i < n; i++) {
+                Class<?> parameterType = TypeUtil.autoboxType(parameterTypes[i]);
+                if (null == parameterType) {
+                    continue out;
+                }
+
+                Class<?> methodParameterType = TypeUtil.autoboxType(methodParameterTypes[i]);
+                if (!methodParameterType.isAssignableFrom(parameterType)) {
+                    continue out;
+                }
+            }
+
+            return Optional.of(m);
+        }
+
+        return Optional.empty();
+    }
+
+    public static boolean checkCanSetAccessible(AccessibleObject accessibleObject,
+                                         Class<?> caller) {
+        return VM_PLUGIN.checkCanSetAccessible(accessibleObject, caller);
+    }
+
+    public static boolean trySetAccessible(AccessibleObject ao) {
+        try {
+            return VM_PLUGIN.trySetAccessible(ao);
+        } catch (Throwable t) {
+            // swallow for strict security managers, module systems, android or others
+        }
+
+        return false;
+    }
+
+    public static Optional<AccessibleObject> makeAccessibleInPrivilegedAction(final AccessibleObject ao) {
+        return AccessController.doPrivileged(new PrivilegedAction<Optional<AccessibleObject>>() {
+            public Optional<AccessibleObject> run() {
+                return makeAccessible(ao);
+            }
+        });
+    }
+
+    // to be run in PrivilegedAction!
+    public static Optional<AccessibleObject> makeAccessible(final AccessibleObject ao) {
+        AccessibleObject[] result = makeAccessible(new AccessibleObject[] { ao });
+
+        return Optional.ofNullable(0 == result.length ? null : result[0]);
+    }
+
+    // to be run in PrivilegedAction!
+    public static AccessibleObject[] makeAccessible(final AccessibleObject[] aoa) {
+        try {
+            AccessibleObject.setAccessible(aoa, true);
+            return aoa;
+        } catch (Throwable outer) {
+            // swallow for strict security managers, module systems, android or others,
+            // but try one-by-one to get the allowed ones at least
+            final List<AccessibleObject> ret = new ArrayList<>(aoa.length);
+            for (final AccessibleObject ao : aoa) {
+                boolean accessible = trySetAccessible(ao);
+                if (accessible) {
+                    ret.add(ao);
+                }
+            }
+            return ret.toArray((AccessibleObject[]) Array.newInstance(aoa.getClass().getComponentType(), 0));
+        }
+    }
+
     private static boolean superClassShouldBeIgnored(Class sc) {
         return ((sc != null) && (sc.getPackage() != null) && "org.codehaus.groovy.runtime.callsite".equals(sc.getPackage().getName()));
     }
diff --git a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index e3f747426b..d49f83689a 100644
--- a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -59,6 +59,7 @@ import org.codehaus.groovy.classgen.Verifier;
 import org.codehaus.groovy.reflection.ClassInfo;
 import org.codehaus.groovy.reflection.MixinInMetaClass;
 import org.codehaus.groovy.reflection.ReflectionCache;
+import org.codehaus.groovy.reflection.ReflectionUtils;
 import org.codehaus.groovy.reflection.stdclasses.CachedSAMClass;
 import org.codehaus.groovy.runtime.callsite.BooleanClosureWrapper;
 import org.codehaus.groovy.runtime.callsite.BooleanReturningMethodInvoker;
@@ -386,9 +387,9 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
                     if (groovyObject && field.getName().equals("metaClass")) {
                         continue;
                     }
-                    AccessController.doPrivileged(new PrivilegedAction() {
+                    AccessController.doPrivileged(new PrivilegedAction<Object>() {
                         public Object run() {
-                            field.setAccessible(true);
+                            ReflectionUtils.trySetAccessible(field);
                             return null;
                         }
                     });
diff --git a/src/main/org/codehaus/groovy/runtime/callsite/CallSiteArray.java b/src/main/org/codehaus/groovy/runtime/callsite/CallSiteArray.java
index c2c2cf2572..acbb06fa24 100644
--- a/src/main/org/codehaus/groovy/runtime/callsite/CallSiteArray.java
+++ b/src/main/org/codehaus/groovy/runtime/callsite/CallSiteArray.java
@@ -29,10 +29,10 @@ import org.codehaus.groovy.runtime.InvokerHelper;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 
+
 public final class CallSiteArray {
     public final CallSite[] array;
-
-    public static final Object [] NOPARAM = new Object[0];
+    public static final Object[] NOPARAM = new Object[0];
     public final Class owner;
 
     public CallSiteArray(Class owner, String [] names) {
diff --git a/src/main/org/codehaus/groovy/runtime/callsite/CallSiteGenerator.java b/src/main/org/codehaus/groovy/runtime/callsite/CallSiteGenerator.java
index 8931d19599..1267cfe5b4 100644
--- a/src/main/org/codehaus/groovy/runtime/callsite/CallSiteGenerator.java
+++ b/src/main/org/codehaus/groovy/runtime/callsite/CallSiteGenerator.java
@@ -32,7 +32,6 @@ import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 
 import java.lang.reflect.Constructor;
-import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 
 public class CallSiteGenerator {
@@ -71,9 +70,8 @@ public class CallSiteGenerator {
             BytecodeHelper.doCast(mv, callClass);
             if (useInterface) invokeMethodCode = Opcodes.INVOKEINTERFACE;
         }
-        
-        Method method = cachedMethod.setAccessible();
-        Class<?>[] parameters = method.getParameterTypes();
+
+        Class<?>[] parameters = cachedMethod.getPT();
         int size = parameters.length;
         for (int i = 0; i < size; i++) {
             if (useArray) {
@@ -231,7 +229,7 @@ public class CallSiteGenerator {
 
         final CachedClass declClass = cachedMethod.getDeclaringClass();
         final CallSiteClassLoader callSiteLoader = declClass.getCallSiteLoader();
-        final String name = callSiteLoader.createClassName(cachedMethod.setAccessible());
+        final String name = callSiteLoader.createClassName(cachedMethod.getName());
 
         final byte[] bytes = genPogoMetaMethodSite(cachedMethod, cw, name);
         
@@ -243,7 +241,7 @@ public class CallSiteGenerator {
 
         final CachedClass declClass = cachedMethod.getDeclaringClass();
         final CallSiteClassLoader callSiteLoader = declClass.getCallSiteLoader();
-        final String name = callSiteLoader.createClassName(cachedMethod.setAccessible());
+        final String name = callSiteLoader.createClassName(cachedMethod.getName());
 
         final byte[] bytes = genPojoMetaMethodSite(cachedMethod, cw, name);
         
@@ -255,7 +253,7 @@ public class CallSiteGenerator {
 
         final CachedClass declClass = cachedMethod.getDeclaringClass();
         final CallSiteClassLoader callSiteLoader = declClass.getCallSiteLoader();
-        final String name = callSiteLoader.createClassName(cachedMethod.setAccessible());
+        final String name = callSiteLoader.createClassName(cachedMethod.getName());
 
         final byte[] bytes = genStaticMetaMethodSite(cachedMethod, cw, name);
         
diff --git a/src/main/org/codehaus/groovy/runtime/callsite/CallSiteHelper.java b/src/main/org/codehaus/groovy/runtime/callsite/CallSiteHelper.java
new file mode 100644
index 0000000000..016c5373d0
--- /dev/null
+++ b/src/main/org/codehaus/groovy/runtime/callsite/CallSiteHelper.java
@@ -0,0 +1,33 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.codehaus.groovy.runtime.callsite;
+
+import groovy.lang.MetaClass;
+import groovy.lang.MetaMethod;
+import org.codehaus.groovy.vmplugin.VMPlugin;
+import org.codehaus.groovy.vmplugin.VMPluginFactory;
+
+public class CallSiteHelper {
+    private static final VMPlugin VM_PLUGIN = VMPluginFactory.getPlugin();
+
+    public static MetaMethod transformMetaMethod(MetaClass metaClass, MetaMethod metaMethod, Class<?>[] params, Class<?> caller) {
+        return VM_PLUGIN.transformMetaMethod(metaClass, metaMethod, params, caller);
+    }
+
+}
diff --git a/src/main/org/codehaus/groovy/runtime/callsite/GetEffectivePogoFieldSite.java b/src/main/org/codehaus/groovy/runtime/callsite/GetEffectivePogoFieldSite.java
index e8d7816683..efa5fb5c26 100644
--- a/src/main/org/codehaus/groovy/runtime/callsite/GetEffectivePogoFieldSite.java
+++ b/src/main/org/codehaus/groovy/runtime/callsite/GetEffectivePogoFieldSite.java
@@ -33,7 +33,7 @@ public class GetEffectivePogoFieldSite extends AbstractCallSite {
     public GetEffectivePogoFieldSite(CallSite site, MetaClass metaClass, CachedField effective) {
         super(site);
         this.metaClass = metaClass;
-        this.effective = effective.field;
+        this.effective = effective.getCachedField();
     }
 
     public final Object callGetProperty (Object receiver) throws Throwable {
diff --git a/src/main/org/codehaus/groovy/runtime/callsite/GetEffectivePojoFieldSite.java b/src/main/org/codehaus/groovy/runtime/callsite/GetEffectivePojoFieldSite.java
index 68f7342e4c..f1c4d719f9 100644
--- a/src/main/org/codehaus/groovy/runtime/callsite/GetEffectivePojoFieldSite.java
+++ b/src/main/org/codehaus/groovy/runtime/callsite/GetEffectivePojoFieldSite.java
@@ -33,7 +33,7 @@ class GetEffectivePojoFieldSite extends AbstractCallSite {
     public GetEffectivePojoFieldSite(CallSite site, MetaClassImpl metaClass, CachedField effective) {
         super(site);
         this.metaClass = metaClass;
-        this.effective = effective.field;
+        this.effective = effective.getCachedField();
         version = metaClass.getVersion();
     }
 
diff --git a/src/main/org/codehaus/groovy/runtime/callsite/MetaMethodSite.java b/src/main/org/codehaus/groovy/runtime/callsite/MetaMethodSite.java
index dc151450e6..94fb39324a 100644
--- a/src/main/org/codehaus/groovy/runtime/callsite/MetaMethodSite.java
+++ b/src/main/org/codehaus/groovy/runtime/callsite/MetaMethodSite.java
@@ -28,7 +28,7 @@ import groovy.lang.MetaMethod;
  */
 public abstract class MetaMethodSite extends MetaClassSite {
     final MetaMethod metaMethod;
-    protected final Class [] params;
+    protected final Class[] params;
 
     public MetaMethodSite(CallSite site, MetaClass metaClass, MetaMethod metaMethod, Class[] params) {
         super(site, metaClass);
diff --git a/src/main/org/codehaus/groovy/runtime/callsite/PogoMetaMethodSite.java b/src/main/org/codehaus/groovy/runtime/callsite/PogoMetaMethodSite.java
index 243e62de31..0a69ab4172 100644
--- a/src/main/org/codehaus/groovy/runtime/callsite/PogoMetaMethodSite.java
+++ b/src/main/org/codehaus/groovy/runtime/callsite/PogoMetaMethodSite.java
@@ -160,6 +160,9 @@ public class PogoMetaMethodSite extends MetaMethodSite {
         public PogoCachedMethodSite(CallSite site, MetaClassImpl metaClass, CachedMethod metaMethod, Class[] params) {
             super(site, metaClass, metaMethod, params);
             reflect = metaMethod.setAccessible();
+
+//            super(site, metaClass, CallSiteHelper.transformMetaMethod(metaClass, metaMethod, params, site), params);
+//            reflect = ((CachedMethod) super.metaMethod).setAccessible();
         }
 
         public Object invoke(Object receiver, Object[] args) throws Throwable {
diff --git a/src/main/org/codehaus/groovy/runtime/callsite/PojoMetaMethodSite.java b/src/main/org/codehaus/groovy/runtime/callsite/PojoMetaMethodSite.java
index 7bbd903d00..d44b0a507f 100644
--- a/src/main/org/codehaus/groovy/runtime/callsite/PojoMetaMethodSite.java
+++ b/src/main/org/codehaus/groovy/runtime/callsite/PojoMetaMethodSite.java
@@ -181,8 +181,8 @@ public class PojoMetaMethodSite extends MetaMethodSite {
         final Method reflect;
 
         public PojoCachedMethodSite(CallSite site, MetaClassImpl metaClass, MetaMethod metaMethod, Class[] params) {
-            super(site, metaClass, metaMethod, params);
-            reflect = ((CachedMethod)metaMethod).setAccessible();
+            super(site, metaClass, CallSiteHelper.transformMetaMethod(metaClass, metaMethod, params, site.getArray().owner), params);
+            reflect = ((CachedMethod) super.metaMethod).setAccessible();
         }
 
         public Object invoke(Object receiver, Object[] args) throws Throwable {
diff --git a/src/main/org/codehaus/groovy/runtime/metaclass/MetaClassRegistryImpl.java b/src/main/org/codehaus/groovy/runtime/metaclass/MetaClassRegistryImpl.java
index 742060b2eb..97c0580637 100644
--- a/src/main/org/codehaus/groovy/runtime/metaclass/MetaClassRegistryImpl.java
+++ b/src/main/org/codehaus/groovy/runtime/metaclass/MetaClassRegistryImpl.java
@@ -234,7 +234,7 @@ public class MetaClassRegistryImpl implements MetaClassRegistry{
 
             for (CachedMethod method : methods) {
                 final int mod = method.getModifiers();
-                if (Modifier.isStatic(mod) && Modifier.isPublic(mod) && method.getCachedMethod().getAnnotation(Deprecated.class) == null) {
+                if (Modifier.isStatic(mod) && Modifier.isPublic(mod) && method.getAnnotation(Deprecated.class) == null) {
                     CachedClass[] paramTypes = method.getParameterTypes();
                     if (paramTypes.length > 0) {
                         List<MetaMethod> arr = map.get(paramTypes[0]);
diff --git a/src/main/org/codehaus/groovy/runtime/metaclass/MethodSelectionException.java b/src/main/org/codehaus/groovy/runtime/metaclass/MethodSelectionException.java
index 4f0cc4cb96..5e30927362 100644
--- a/src/main/org/codehaus/groovy/runtime/metaclass/MethodSelectionException.java
+++ b/src/main/org/codehaus/groovy/runtime/metaclass/MethodSelectionException.java
@@ -32,12 +32,11 @@ import java.lang.reflect.Modifier;
  * <p>
  * <b>Note:</b> This exception as for internal use only!
  * 
- * @author Jochen Theodorou
  * @since Groovy 1.1
  */
 public class MethodSelectionException extends GroovyRuntimeException {
 
-    private static final long serialVersionUID = 6260193948973669540L;
+    private static final long serialVersionUID = 8126246630023758333L;
     private final String methodName;
     private final FastArray methods;
     private final Class[] arguments;
@@ -92,12 +91,12 @@ public class MethodSelectionException extends GroovyRuntimeException {
                 appendClassNames(buffer,method.getNativeParameterTypes());
             }
             else {
-                CachedConstructor method = (CachedConstructor) methodOrConstructor;
-                buffer.append(Modifier.toString(method.cachedConstructor.getModifiers()));
-                buffer.append(" ").append(method.cachedConstructor.getDeclaringClass().getName());
+                CachedConstructor constructor = (CachedConstructor) methodOrConstructor;
+                buffer.append(Modifier.toString(constructor.getModifiers()));
+                buffer.append(" ").append(constructor.getDeclaringClass().getName());
                 buffer.append("#<init>");
-                appendClassNames(buffer,method.getNativeParameterTypes());
+                appendClassNames(buffer,constructor.getNativeParameterTypes());
             }
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/main/org/codehaus/groovy/tools/DgmConverter.java b/src/main/org/codehaus/groovy/tools/DgmConverter.java
index 0965c92ac4..93997a1058 100644
--- a/src/main/org/codehaus/groovy/tools/DgmConverter.java
+++ b/src/main/org/codehaus/groovy/tools/DgmConverter.java
@@ -58,7 +58,7 @@ public class DgmConverter implements Opcodes {
             if (!method.isStatic() || !method.isPublic())
                 continue;
 
-            if (method.getCachedMethod().getAnnotation(Deprecated.class) != null)
+            if (method.getAnnotation(Deprecated.class) != null)
                 continue;
 
             if (method.getParameterTypes().length == 0)
diff --git a/src/main/org/codehaus/groovy/vmplugin/VMPlugin.java b/src/main/org/codehaus/groovy/vmplugin/VMPlugin.java
index d89ec16ce8..0d72662e77 100644
--- a/src/main/org/codehaus/groovy/vmplugin/VMPlugin.java
+++ b/src/main/org/codehaus/groovy/vmplugin/VMPlugin.java
@@ -18,22 +18,24 @@
  */
 package org.codehaus.groovy.vmplugin;
 
+import groovy.lang.MetaClass;
+import groovy.lang.MetaMethod;
 import org.codehaus.groovy.ast.AnnotationNode;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.CompileUnit;
 
+import java.lang.reflect.AccessibleObject;
 import java.lang.reflect.Method;
 
 /**
  * Interface to access VM version based actions.
  * This interface is for internal use only!
- * 
- * @author Jochen Theodorou
  */
 public interface VMPlugin {
     void setAdditionalClassInformation(ClassNode c);
     Class[] getPluginDefaultGroovyMethods();
     Class[] getPluginStaticGroovyMethods();
+    void configureAnnotationNodeFromDefinition(AnnotationNode definition, AnnotationNode root);
     void configureAnnotation(AnnotationNode an);
     void configureClassNode(CompileUnit compileUnit, ClassNode classNode);
     void invalidateCallSites();
@@ -56,9 +58,39 @@ public interface VMPlugin {
     Object invokeHandle(Object handle, Object[] args) throws Throwable;
 
     /**
-     * Gives the version the plguin is made for
-     * @return 5 for jdk5, 6 for jdk6, 7 for jdk7 or higher
+     * Gives the version the plugin is made for
+     * @return 7 for jdk7, 8 for jdk8, 9 for jdk9 or higher
      */
     int getVersion();
 
+    /**
+     * Check whether invoking {@link AccessibleObject#setAccessible(boolean)} on the accessible object will be completed successfully
+     *
+     * @param accessibleObject the accessible object to check
+     * @param caller the caller to invoke {@code setAccessible}
+     * @return the check result
+     */
+    boolean checkCanSetAccessible(AccessibleObject accessibleObject, Class<?> caller);
+
+    /**
+     * Set the {@code accessible} flag for this reflected object to {@code true}
+     * if possible.
+     *
+     * @param ao the accessible object
+     * @return {@code true} if the {@code accessible} flag is set to {@code true};
+     *         {@code false} if access cannot be enabled.
+     * @throws SecurityException if the request is denied by the security manager
+     */
+    boolean trySetAccessible(AccessibleObject ao);
+
+    /**
+     * transform meta method
+     *
+     * @param metaClass meta class
+     * @param metaMethod the original meta method
+     * @param params parameter types
+     * @param caller caller type
+     * @return the transformed meta method
+     */
+    MetaMethod transformMetaMethod(MetaClass metaClass, MetaMethod metaMethod, Class<?>[] params, Class<?> caller);
 }
diff --git a/src/main/org/codehaus/groovy/vmplugin/v5/Java5.java b/src/main/org/codehaus/groovy/vmplugin/v5/Java5.java
index 86c34b22af..a79eef0a13 100644
--- a/src/main/org/codehaus/groovy/vmplugin/v5/Java5.java
+++ b/src/main/org/codehaus/groovy/vmplugin/v5/Java5.java
@@ -18,6 +18,8 @@
  */
 package org.codehaus.groovy.vmplugin.v5;
 
+import groovy.lang.MetaClass;
+import groovy.lang.MetaMethod;
 import org.codehaus.groovy.GroovyBugError;
 import org.codehaus.groovy.ast.AnnotatedNode;
 import org.codehaus.groovy.ast.AnnotationNode;
@@ -36,12 +38,14 @@ import org.codehaus.groovy.ast.expr.ListExpression;
 import org.codehaus.groovy.ast.expr.PropertyExpression;
 import org.codehaus.groovy.ast.stmt.ReturnStatement;
 import org.codehaus.groovy.vmplugin.VMPlugin;
+import org.codehaus.groovy.vmplugin.VMPluginFactory;
 
 import java.lang.annotation.Annotation;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
+import java.lang.reflect.AccessibleObject;
 import java.lang.reflect.Array;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
@@ -50,19 +54,21 @@ import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.MalformedParameterizedTypeException;
 import java.lang.reflect.Method;
 import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.ReflectPermission;
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
 import java.lang.reflect.WildcardType;
+import java.security.Permission;
 import java.util.List;
 
 /**
  * java 5 based functions
- *
- * @author Jochen Theodorou
  */
 public class Java5 implements VMPlugin {
-    private static Class[] EMPTY_CLASS_ARRAY = new Class[0];
+    private static final Class[] EMPTY_CLASS_ARRAY = new Class[0];
     private static final Class[] PLUGIN_DGM = {PluginDefaultGroovyMethods.class};
+    private static final Method[] EMPTY_METHOD_ARRAY = new Method[0];
+    private static final Annotation[] EMPTY_ANNOTATION_ARRAY = new Annotation[0];
 
     public void setAdditionalClassInformation(ClassNode cn) {
         setGenericsTypes(cn);
@@ -84,15 +90,16 @@ public class Java5 implements VMPlugin {
     }
 
     private GenericsType configureTypeVariableDefinition(TypeVariable tv) {
-        ClassNode base = configureTypeVariableReference(tv);
+        return configureTypeVariableDefinition(configureTypeVariableReference(tv.getName()), configureTypes(tv.getBounds()));
+    }
+
+    public static GenericsType configureTypeVariableDefinition(ClassNode base, ClassNode[] cBounds) {
         ClassNode redirect = base.redirect();
         base.setRedirect(null);
-        Type[] tBounds = tv.getBounds();
         GenericsType gt;
-        if (tBounds.length == 0) {
+        if (cBounds == null || cBounds.length == 0) {
             gt = new GenericsType(base);
         } else {
-            ClassNode[] cBounds = configureTypes(tBounds);
             gt = new GenericsType(base, cBounds, null);
             gt.setName(base.getName());
             gt.setPlaceholder(true);
@@ -118,7 +125,7 @@ public class Java5 implements VMPlugin {
         } else if (type instanceof GenericArrayType) {
             return configureGenericArray((GenericArrayType) type);
         } else if (type instanceof TypeVariable) {
-            return configureTypeVariableReference((TypeVariable) type);
+            return configureTypeVariableReference(((TypeVariable) type).getName());
         } else if (type instanceof Class) {
             return configureClass((Class) type);
         } else if (type==null) {
@@ -168,10 +175,10 @@ public class Java5 implements VMPlugin {
         return base;
     }
 
-    private ClassNode configureTypeVariableReference(TypeVariable tv) {
-        ClassNode cn = ClassHelper.makeWithoutCaching(tv.getName());
+    public static ClassNode configureTypeVariableReference(String name) {
+        ClassNode cn = ClassHelper.makeWithoutCaching(name);
         cn.setGenericsPlaceHolder(true);
-        ClassNode cn2 = ClassHelper.makeWithoutCaching(tv.getName());
+        ClassNode cn2 = ClassHelper.makeWithoutCaching(name);
         cn2.setGenericsPlaceHolder(true);
         GenericsType[] gts = new GenericsType[]{new GenericsType(cn2)};
         cn.setGenericsTypes(gts);
@@ -210,18 +217,22 @@ public class Java5 implements VMPlugin {
         }
     }
 
-    private void configureAnnotationFromDefinition(AnnotationNode definition, AnnotationNode root) {
+    @Deprecated
+    public void configureAnnotationFromDefinition(AnnotationNode definition, AnnotationNode root) {
+        VMPlugin plugin = VMPluginFactory.getPlugin();
+        plugin.configureAnnotationNodeFromDefinition(definition, root);
+    }
+
+    public void configureAnnotationNodeFromDefinition(AnnotationNode definition, AnnotationNode root) {
         ClassNode type = definition.getClassNode();
-        if (!type.isResolved()) return;
-        Class clazz = type.getTypeClass();
-        if (clazz == Retention.class) {
+        if ("java.lang.annotation.Retention".equals(type.getName())) {
             Expression exp = definition.getMember("value");
             if (!(exp instanceof PropertyExpression)) return;
             PropertyExpression pe = (PropertyExpression) exp;
             String name = pe.getPropertyAsString();
             RetentionPolicy policy = RetentionPolicy.valueOf(name);
             setRetentionPolicy(policy, root);
-        } else if (clazz == Target.class) {
+        } else if ("java.lang.annotation.Target".equals(type.getName())) {
             Expression exp = definition.getMember("value");
             if (!(exp instanceof ListExpression)) return;
             ListExpression le = (ListExpression) exp;
@@ -239,13 +250,12 @@ public class Java5 implements VMPlugin {
 
     public void configureAnnotation(AnnotationNode node) {
         ClassNode type = node.getClassNode();
+        VMPlugin plugin = VMPluginFactory.getPlugin();
         List<AnnotationNode> annotations = type.getAnnotations();
         for (AnnotationNode an : annotations) {
-            configureAnnotationFromDefinition(an, node);
-        }
-        if (!"java.lang.annotation.Retention".equals(node.getClassNode().getName())) {
-            configureAnnotationFromDefinition(node, node);
+            plugin.configureAnnotationNodeFromDefinition(an, node);
         }
+        plugin.configureAnnotationNodeFromDefinition(node, node);
     }
 
     private void configureAnnotation(AnnotationNode node, Annotation annotation) {
@@ -271,7 +281,7 @@ public class Java5 implements VMPlugin {
             try {
                 declaredMethods = type.getDeclaredMethods();
             } catch (SecurityException se) {
-                declaredMethods = new Method[0];
+                declaredMethods = EMPTY_METHOD_ARRAY;
             }
             for (Method declaredMethod : declaredMethods) {
                 try {
@@ -280,8 +290,7 @@ public class Java5 implements VMPlugin {
                     if (valueExpression == null)
                         continue;
                     node.setMember(declaredMethod.getName(), valueExpression);
-                } catch (IllegalAccessException e) {
-                } catch (InvocationTargetException e) {
+                } catch (IllegalAccessException | InvocationTargetException e) {
                 }
             }
         }
@@ -305,7 +314,7 @@ public class Java5 implements VMPlugin {
         return null;
     }
 
-    private void setRetentionPolicy(RetentionPolicy value, AnnotationNode node) {
+    private static void setRetentionPolicy(RetentionPolicy value, AnnotationNode node) {
         switch (value) {
             case RUNTIME:
                 node.setRuntimeRetention(true);
@@ -321,7 +330,7 @@ public class Java5 implements VMPlugin {
         }
     }
 
-    private int getElementCode(ElementType value) {
+    protected int getElementCode(ElementType value) {
         switch (value) {
             case TYPE:
                 return AnnotationNode.TYPE_TARGET;
@@ -339,13 +348,11 @@ public class Java5 implements VMPlugin {
                 return AnnotationNode.ANNOTATION_TARGET;
             case PACKAGE:
                 return AnnotationNode.PACKAGE_TARGET;
-            default:
-                if ("TYPE_USE".equals(value.name()) || "TYPE_PARAMETER".equals(value.name()) || "MODULE".equals(value.name())) {
-                    // return 0 value because we are binary or'ing this and want to ignore without failing
-                    // later version plugins will override and provide sensible values for jdk8+
-                    return 0;
-                }
-                throw new GroovyBugError("unsupported Target " + value);
+        }
+        if ("MODULE".equals(value.name())) {
+            return AnnotationNode.TYPE_TARGET;
+        } else {
+            throw new GroovyBugError("unsupported Target " + value);
         }
     }
 
@@ -370,7 +377,7 @@ public class Java5 implements VMPlugin {
             Method[] methods = clazz.getDeclaredMethods();
             for (Method m : methods) {
                 ClassNode ret = makeClassNode(compileUnit, m.getGenericReturnType(), m.getReturnType());
-                Parameter[] params = makeParameters(compileUnit, m.getGenericParameterTypes(), m.getParameterTypes(), m.getParameterAnnotations());
+                Parameter[] params = processParameters(compileUnit, m);
                 ClassNode[] exceptions = makeClassNodes(compileUnit, m.getGenericExceptionTypes(), m.getExceptionTypes());
                 MethodNode mn = new MethodNode(m.getName(), m.getModifiers(), ret, params, exceptions, null);
                 mn.setSynthetic(m.isSynthetic());
@@ -381,12 +388,15 @@ public class Java5 implements VMPlugin {
             }
             Constructor[] constructors = clazz.getDeclaredConstructors();
             for (Constructor ctor : constructors) {
-                Parameter[] params = makeParameters(
-                        compileUnit,
-                        ctor.getGenericParameterTypes(),
-                        ctor.getParameterTypes(),
-                        getConstructorParameterAnnotations(ctor)
-                );
+                Type[] types = ctor.getGenericParameterTypes();
+                Parameter[] params1 = Parameter.EMPTY_ARRAY;
+                if (types.length > 0) {
+                    params1 = new Parameter[types.length];
+                    for (int i = 0; i < params1.length; i++) {
+                        params1[i] = makeParameter(compileUnit, types[i], ctor.getParameterTypes()[i], getConstructorParameterAnnotations(ctor)[i], "param" + i);
+                    }
+                }
+                Parameter[] params = params1;
                 ClassNode[] exceptions = makeClassNodes(compileUnit, ctor.getGenericExceptionTypes(), ctor.getExceptionTypes());
                 classNode.addConstructor(ctor.getModifiers(), params, exceptions, null);
             }
@@ -407,6 +417,18 @@ public class Java5 implements VMPlugin {
         }
     }
 
+    protected Parameter[] processParameters(CompileUnit compileUnit, Method m) {
+        Type[] types = m.getGenericParameterTypes();
+        Parameter[] params = Parameter.EMPTY_ARRAY;
+        if (types.length > 0) {
+            params = new Parameter[types.length];
+            for (int i = 0; i < params.length; i++) {
+                params[i] = makeParameter(compileUnit, types[i], m.getParameterTypes()[i], m.getParameterAnnotations()[i], "param" + i);
+            }
+        }
+        return params;
+    }
+
     /**
      * Synthetic parameters such as those added for inner class constructors may
      * not be included in the parameter annotations array. This is the case when
@@ -444,7 +466,7 @@ public class Java5 implements VMPlugin {
             }
             Annotation[][] adjusted = new Annotation[parameterCount][];
             for (int i = 0; i < diff; i++) {
-                adjusted[i] = new Annotation[0];
+                adjusted[i] = EMPTY_ANNOTATION_ARRAY;
             }
             System.arraycopy(annotations, 0, adjusted, diff, annotations.length);
             return adjusted;
@@ -495,20 +517,9 @@ public class Java5 implements VMPlugin {
         return back.getPlainNodeReference();
     }
 
-    private Parameter[] makeParameters(CompileUnit cu, Type[] types, Class[] cls, Annotation[][] parameterAnnotations) {
-        Parameter[] params = Parameter.EMPTY_ARRAY;
-        if (types.length > 0) {
-            params = new Parameter[types.length];
-            for (int i = 0; i < params.length; i++) {
-                params[i] = makeParameter(cu, types[i], cls[i], parameterAnnotations[i], i);
-            }
-        }
-        return params;
-    }
-
-    private Parameter makeParameter(CompileUnit cu, Type type, Class cl, Annotation[] annotations, int idx) {
+    protected Parameter makeParameter(CompileUnit cu, Type type, Class cl, Annotation[] annotations, String name) {
         ClassNode cn = makeClassNode(cu, type, cl);
-        Parameter parameter = new Parameter(cn, "param" + idx);
+        Parameter parameter = new Parameter(cn, name);
         setAnnotationMetaData(annotations, parameter);
         return parameter;
     }
@@ -529,5 +540,55 @@ public class Java5 implements VMPlugin {
     public Object invokeHandle(Object handle, Object[] args) throws Throwable {
         throw new GroovyBugError("invokeHandle requires at least JDK 7");
     }
+
+    /**
+     * The following scenarios can not set accessible, i.e. the return value is false
+     * 1) SecurityException occurred
+     * 2) the accessible object is a Constructor object for the Class class
+     *
+     * @param accessibleObject the accessible object to check
+     * @param caller the caller to invoke {@code setAccessible}
+     * @return the check result
+     */
+    @Override
+    public boolean checkCanSetAccessible(AccessibleObject accessibleObject,
+                                  Class<?> caller) {
+        SecurityManager sm = System.getSecurityManager();
+        try {
+            if (sm != null) {
+                sm.checkPermission(ACCESS_PERMISSION);
+            }
+        } catch (SecurityException e) {
+            return false;
+        }
+
+        if (accessibleObject instanceof Constructor) {
+            Constructor c = (Constructor) accessibleObject;
+            if (c.getDeclaringClass() == Class.class) {
+                return false; // Cannot make a java.lang.Class constructor accessible
+            }
+        }
+
+        return true;
+    }
+
+    @Override
+    public boolean trySetAccessible(AccessibleObject ao) {
+        try {
+            ao.setAccessible(true);
+            return true;
+        } catch (SecurityException e) {
+            throw e;
+        } catch (Throwable t) {
+            return false;
+        }
+    }
+
+    @Override
+    public MetaMethod transformMetaMethod(MetaClass metaClass, MetaMethod metaMethod, Class<?>[] params, Class<?> caller) {
+        return metaMethod;
+    }
+
+    private static final Permission ACCESS_PERMISSION = new ReflectPermission("suppressAccessChecks");
 }
 
diff --git a/src/main/org/codehaus/groovy/vmplugin/v7/Java7.java b/src/main/org/codehaus/groovy/vmplugin/v7/Java7.java
index 93165b1d6e..dbcd111446 100644
--- a/src/main/org/codehaus/groovy/vmplugin/v7/Java7.java
+++ b/src/main/org/codehaus/groovy/vmplugin/v7/Java7.java
@@ -19,6 +19,7 @@
 package org.codehaus.groovy.vmplugin.v7;
 
 import org.codehaus.groovy.GroovyBugError;
+import org.codehaus.groovy.reflection.ReflectionUtils;
 import org.codehaus.groovy.vmplugin.v6.Java6;
 
 import java.lang.invoke.MethodHandle;
@@ -29,40 +30,44 @@ import java.security.AccessController;
 import java.security.PrivilegedAction;
 
 /**
- * Java 7 based functions. Currently just a stub but you can
- * add your own methods to your own version and place it on the classpath
- * ahead of this one.
+ * Java 7 based functions.
  *
- * @author Jochen Theodorou
+ * For crude customization, you can add your own methods to your own version and place it on the classpath ahead of this one.
  */
 public class Java7 extends Java6 {
-    private static final Constructor<MethodHandles.Lookup> LOOKUP_Constructor;
-    static {
-        Constructor<MethodHandles.Lookup> con = null;
-        try {
-            con = MethodHandles.Lookup.class.getDeclaredConstructor(Class.class, int.class);
-        } catch (NoSuchMethodException e) {
-            throw new GroovyBugError(e);
-        }
-        try {
-            if (!con.isAccessible()) {
-                final Constructor tmp = con;
-                AccessController.doPrivileged(new PrivilegedAction() {
-                    @Override
-                    public Object run() {
-                        tmp.setAccessible(true);
-                        return null;
-                    }
-                });
+    private static class LookupHolder {
+        private static final Constructor<MethodHandles.Lookup> LOOKUP_Constructor;
+        static {
+            Constructor<MethodHandles.Lookup> con = null;
+            try {
+                con = MethodHandles.Lookup.class.getDeclaredConstructor(Class.class, int.class);
+            } catch (NoSuchMethodException e) {
+                throw new GroovyBugError(e);
             }
-        } catch (SecurityException se) {
-            con = null;
-        } catch (RuntimeException re) {
-            // test for JDK9 JIGSAW
-            if (!"java.lang.reflect.InaccessibleObjectException".equals(re.getClass().getName())) throw re;
-            con = null;
+            try {
+                if (!con.isAccessible()) {
+                    final Constructor tmp = con;
+                    AccessController.doPrivileged(new PrivilegedAction<Object>() {
+                        @Override
+                        public Object run() {
+                            ReflectionUtils.trySetAccessible(tmp);
+                            return null;
+                        }
+                    });
+                }
+            } catch (SecurityException se) {
+                con = null;
+            } catch (RuntimeException re) {
+                // test for JDK9 JIGSAW
+                if (!"java.lang.reflect.InaccessibleObjectException".equals(re.getClass().getName())) throw re;
+                con = null;
+            }
+            LOOKUP_Constructor = con;
         }
-        LOOKUP_Constructor = con;
+    }
+
+    private static Constructor<MethodHandles.Lookup> getLookupConstructor() {
+        return LookupHolder.LOOKUP_Constructor;
     }
 
     @Override
@@ -77,22 +82,21 @@ public class Java7 extends Java6 {
 
     @Override
     public Object getInvokeSpecialHandle(final Method method, final Object receiver) {
-        if (LOOKUP_Constructor==null) {
+        if (getLookupConstructor() == null) {
             return super.getInvokeSpecialHandle(method, receiver);
         }
         if (!method.isAccessible()) {
-            AccessController.doPrivileged(new PrivilegedAction() {
+            AccessController.doPrivileged(new PrivilegedAction<Object>() {
                 @Override
                 public Object run() {
-                    method.setAccessible(true);
+                    ReflectionUtils.trySetAccessible(method);
                     return null;
                 }
             });
         }
         Class declaringClass = method.getDeclaringClass();
         try {
-            return LOOKUP_Constructor.
-                    newInstance(declaringClass, MethodHandles.Lookup.PRIVATE).
+            return getLookupConstructor().newInstance(declaringClass, -1).
                     unreflectSpecial(method, declaringClass).
                     bindTo(receiver);
         } catch (ReflectiveOperationException e) {
diff --git a/src/main/org/codehaus/groovy/vmplugin/v7/Selector.java b/src/main/org/codehaus/groovy/vmplugin/v7/Selector.java
index a8f9b464e9..c0e9ca37cc 100644
--- a/src/main/org/codehaus/groovy/vmplugin/v7/Selector.java
+++ b/src/main/org/codehaus/groovy/vmplugin/v7/Selector.java
@@ -325,7 +325,7 @@ public abstract class Selector {
                 insertName = true;
             } else if (res instanceof CachedField) {
                 CachedField cf = (CachedField) res;
-                Field f = cf.field;
+                Field f = cf.getCachedField();
                 try {
                     handle = LOOKUP.unreflectGetter(f);
                     if (Modifier.isStatic(f.getModifiers())) {
@@ -424,7 +424,7 @@ public abstract class Selector {
                 if (LOG_ENABLED) LOG.info("meta method is MetaConstructor instance");
                 MetaConstructor mc = (MetaConstructor) method;
                 isVargs = mc.isVargsMethod();
-                Constructor con = mc.getCachedConstrcutor().cachedConstructor;
+                Constructor con = mc.getCachedConstrcutor().getCachedConstructor();
                 try {
                     handle = LOOKUP.unreflectConstructor(con);
                     if (LOG_ENABLED) LOG.info("successfully unreflected constructor");
diff --git a/src/main/org/codehaus/groovy/vmplugin/v9/Java9.java b/src/main/org/codehaus/groovy/vmplugin/v9/Java9.java
new file mode 100644
index 0000000000..eb3f760c1f
--- /dev/null
+++ b/src/main/org/codehaus/groovy/vmplugin/v9/Java9.java
@@ -0,0 +1,253 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.codehaus.groovy.vmplugin.v9;
+
+import groovy.lang.MetaClass;
+import groovy.lang.MetaMethod;
+import org.codehaus.groovy.GroovyBugError;
+import org.codehaus.groovy.reflection.CachedClass;
+import org.codehaus.groovy.reflection.CachedMethod;
+import org.codehaus.groovy.reflection.ReflectionUtils;
+import org.codehaus.groovy.vmplugin.v5.Java5;
+import org.codehaus.groovy.vmplugin.v8.Java8;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.reflect.AccessibleObject;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Executable;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Member;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.Optional;
+
+/**
+ * Additional Java 9 based functions will be added here as needed.
+ */
+public class Java9 extends Java8 {
+
+    private static class LookupHolder {
+        private static final Method PRIVATE_LOOKUP;
+        private static final Constructor<MethodHandles.Lookup> LOOKUP_Constructor;
+        static {
+            Constructor<MethodHandles.Lookup> lookup = null;
+            Method privateLookup = null;
+            try { // java 9
+                privateLookup = MethodHandles.class.getMethod("privateLookupIn", Class.class, MethodHandles.Lookup.class);
+            } catch (final NoSuchMethodException | RuntimeException e) { // java 8 or fallback if anything else goes wrong
+                try {
+                    lookup = MethodHandles.Lookup.class.getDeclaredConstructor(Class.class, Integer.TYPE);
+                    if (!lookup.isAccessible()) {
+                        ReflectionUtils.trySetAccessible(lookup);
+                    }
+                } catch (final NoSuchMethodException ex) {
+                    throw new IllegalStateException("Incompatible JVM", e);
+                }
+            }
+            PRIVATE_LOOKUP = privateLookup;
+            LOOKUP_Constructor = lookup;
+        }
+    }
+
+    private static Constructor<MethodHandles.Lookup> getLookupConstructor() {
+        return LookupHolder.LOOKUP_Constructor;
+    }
+
+    private static Method getPrivateLookup() {
+        return LookupHolder.PRIVATE_LOOKUP;
+    }
+
+    public static MethodHandles.Lookup of(final Class<?> declaringClass) {
+        try {
+            if (getPrivateLookup() != null) {
+                return MethodHandles.Lookup.class.cast(getPrivateLookup().invoke(null, declaringClass, MethodHandles.lookup()));
+            }
+            return getLookupConstructor().newInstance(declaringClass, MethodHandles.Lookup.PRIVATE).in(declaringClass);
+        } catch (final IllegalAccessException | InstantiationException e) {
+            throw new IllegalArgumentException(e);
+        } catch (final InvocationTargetException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public int getVersion() {
+        return 9;
+    }
+
+    @Override
+    public Object getInvokeSpecialHandle(Method method, Object receiver) {
+        if (getLookupConstructor() != null) {
+            Class declaringClass = method.getDeclaringClass();
+            try {
+                return of(declaringClass).unreflectSpecial(method, receiver.getClass()).bindTo(receiver);
+            } catch (ReflectiveOperationException e) {
+                throw new GroovyBugError(e);
+            }
+        }
+        return super.getInvokeSpecialHandle(method, receiver);
+    }
+
+    /**
+     * This method may be used by a caller in class C to check whether to enable access to a member of declaring class D successfully
+     * if {@link Java5#checkCanSetAccessible(java.lang.reflect.AccessibleObject, java.lang.Class)} returns true and any of the following hold:
+     *
+     * 1) C and D are in the same module.
+     * 2) The member is public and D is public in a package that the module containing D exports to at least the module containing C.
+     * 3) The member is protected static, D is public in a package that the module containing D exports to at least the module containing C, and C is a subclass of D.
+     * 4) D is in a package that the module containing D opens to at least the module containing C. All packages in unnamed and open modules are open to all modules and so this method always succeeds when D is in an unnamed or open module.
+     *
+     * @param accessibleObject the accessible object to check
+     * @param caller the caller to invoke {@code setAccessible}
+     * @return the check result
+     */
+    public boolean checkCanSetAccessible(AccessibleObject accessibleObject,
+                                                Class<?> caller) {
+
+        if (!super.checkCanSetAccessible(accessibleObject, caller)) return false;
+
+        if (caller == MethodHandle.class) {
+            throw new IllegalCallerException();   // should not happen
+        }
+
+        if (!(accessibleObject instanceof Member)) {
+            throw new IllegalArgumentException("accessibleObject should be a member of type: " + accessibleObject);   // should not happen
+        }
+
+        Class<?> declaringClass = ((Member) accessibleObject).getDeclaringClass();
+
+        Module callerModule = caller.getModule();
+        Module declaringModule = declaringClass.getModule();
+
+        if (callerModule == declaringModule) return true;
+        if (callerModule == Object.class.getModule()) return true;
+        if (!declaringModule.isNamed()) return true;
+
+        int modifiers;
+        if (accessibleObject instanceof Executable) {
+            modifiers = ((Executable) accessibleObject).getModifiers();
+        } else {
+            modifiers = ((Field) accessibleObject).getModifiers();
+        }
+
+        return checkAccessible(caller, declaringClass, modifiers, true);
+    }
+
+
+    @Override
+    public boolean trySetAccessible(AccessibleObject ao) {
+        return ao.trySetAccessible();
+    }
+
+    @Override
+    public MetaMethod transformMetaMethod(MetaClass metaClass, MetaMethod metaMethod, Class<?>[] params, Class<?> caller) {
+        if (!(metaMethod instanceof CachedMethod)) {
+            return metaMethod;
+        }
+
+        CachedMethod cachedMethod = (CachedMethod) metaMethod;
+        CachedClass methodDeclaringClass = cachedMethod.getDeclaringClass();
+
+        if (null == methodDeclaringClass) {
+            return metaMethod;
+        }
+
+        Class<?> declaringClass = methodDeclaringClass.getTheClass();
+        Class theClass = metaClass.getTheClass();
+
+        if (declaringClass == theClass) {
+            return metaMethod;
+        }
+
+        int modifiers = cachedMethod.getModifiers();
+
+        // if caller can access the method,
+        // no need to transform the meta method
+        if (checkAccessible(caller, declaringClass, modifiers, false)) {
+            return metaMethod;
+        }
+
+        // if caller can not access the method,
+        // try to find the corresponding method in its derived class
+        if (declaringClass.isAssignableFrom(theClass)) {
+            Optional<Method> optionalMethod = ReflectionUtils.getMethod(theClass, metaMethod.getName(), params);
+            if (optionalMethod.isPresent()) {
+                return new CachedMethod(optionalMethod.get());
+            }
+        }
+
+        return metaMethod;
+    }
+
+    private static boolean checkAccessible(Class<?> caller, Class<?> declaringClass, int modifiers, boolean allowIllegalAccess) {
+        Module callerModule = caller.getModule();
+        Module declaringModule = declaringClass.getModule();
+        String pn = declaringClass.getPackageName();
+
+        boolean unnamedModuleAccessNamedModule = !callerModule.isNamed() && declaringModule.isNamed();
+        boolean illegalAccess = !allowIllegalAccess && unnamedModuleAccessNamedModule;
+
+        // class is public and package is exported to caller
+        boolean isClassPublic = Modifier.isPublic(declaringClass.getModifiers());
+        if (isClassPublic && declaringModule.isExported(pn, callerModule)) {
+            // member is public
+            if (Modifier.isPublic(modifiers)) {
+                if (illegalAccess) {
+                    return false;
+                }
+
+                return true;
+            }
+
+            // member is protected-static
+            if (Modifier.isProtected(modifiers)
+                    && Modifier.isStatic(modifiers)
+                    && isSubclassOf(caller, declaringClass)) {
+                if (illegalAccess) {
+                    return false;
+                }
+
+                return true;
+            }
+        }
+
+        // package is open to caller
+        if (declaringModule.isOpen(pn, callerModule)) {
+            if (illegalAccess) {
+                return false;
+            }
+
+            return true;
+        }
+
+        return false;
+    }
+
+    private static boolean isSubclassOf(Class<?> queryClass, Class<?> ofClass) {
+        while (queryClass != null) {
+            if (queryClass == ofClass) {
+                return true;
+            }
+            queryClass = queryClass.getSuperclass();
+        }
+        return false;
+    }
+}
diff --git a/src/test/groovy/bugs/Groovy8339Bug.groovy b/src/test/groovy/bugs/Groovy8339Bug.groovy
new file mode 100644
index 0000000000..5fa94f5339
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy8339Bug.groovy
@@ -0,0 +1,27 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.bugs
+
+// TODO add JVM option `--illegal-access=deny` when all warnings fixed
+class Groovy8339Bug extends GroovyTestCase {
+    void testCase2() {
+        StringBuilder sb = new StringBuilder()
+        sb.setLength(0)
+    }
+}
diff --git a/src/test/org/codehaus/groovy/reflection/SecurityTest.java b/src/test/org/codehaus/groovy/reflection/SecurityTest.java
new file mode 100644
index 0000000000..229865e91e
--- /dev/null
+++ b/src/test/org/codehaus/groovy/reflection/SecurityTest.java
@@ -0,0 +1,278 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.codehaus.groovy.reflection;
+
+import groovy.lang.GroovyObjectSupport;
+import groovy.util.GroovyTestCase;
+import org.codehaus.groovy.runtime.InvokerInvocationException;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.lang.reflect.ReflectPermission;
+import java.math.BigDecimal;
+import java.nio.ByteBuffer;
+import java.security.AccessControlException;
+import java.security.Permission;
+import java.security.Permissions;
+import java.security.ProtectionDomain;
+
+import static groovy.test.GroovyAssert.isAtLeastJdk;
+
+public class SecurityTest extends GroovyTestCase {
+
+    @SuppressWarnings("unused")
+    public class TestClass{
+        public String publicField;
+        protected String protectedField;
+        String packagePrivateField;
+        private String privateField;
+
+        private boolean methodCalled = false;
+
+        public void publicMethod() {
+            privateMethod();
+        }
+
+        private void privateMethod() {
+            methodCalled = true;
+        }
+
+        void packagePrivateMethod() {
+            privateMethod();
+        }
+
+        void protectedMethod() {
+            privateMethod();
+        }
+
+        public boolean isMethodCalled() {
+            return methodCalled;
+        }
+    }
+
+    @SuppressWarnings("unused")
+    public class TestGroovyClass extends GroovyObjectSupport{
+        private String privateField;
+        private boolean methodCalled = false;
+        private void privateMethod() {
+            methodCalled = true;
+        }
+        public boolean isMethodCalled() {
+            return methodCalled;
+        }
+    }
+    SecurityManager restrictiveSecurityManager;
+    CachedMethod cachedMethodUnderTest;
+    CachedField cachedFieldUnderTest;
+    Permissions forbidden;
+
+    public void setUp() {
+        forbidden = new Permissions();
+        forbidden.add(new ReflectPermission("suppressAccessChecks"));
+        restrictiveSecurityManager = new SecurityManager() {
+
+            @Override
+            public void checkPermission(Permission perm) {
+                if (forbidden.implies(perm))
+                    throw new AccessControlException(perm.getName());
+            }
+        };
+    }
+
+    public void tearDown(){
+        System.setSecurityManager(null);
+    }
+
+    private CachedMethod createCachedMethod(String name) throws Exception {
+        return createCachedMethod(TestClass.class, name);
+    }
+
+    private CachedMethod createCachedMethod(Class<?> cachedClass, String methodName, Class... parameters) throws NoSuchMethodException {
+        Method method = cachedClass.getDeclaredMethod(methodName, parameters);
+        method.setAccessible(true);
+        return new CachedMethod(null, method);
+    }
+
+    private boolean invokesCachedMethod() {
+        TestClass object = new TestClass();
+        cachedMethodUnderTest.invoke(object, new Object[]{});
+        return object.isMethodCalled();
+    }
+
+    private CachedField createCachedField(String name) throws Exception {
+        Field field = TestClass.class.getDeclaredField(name);
+        field.setAccessible(true);
+        return new CachedField(field);
+    }
+
+    public void testInvokesPublicMethodsWithoutChecks() throws Exception {
+        cachedMethodUnderTest = createCachedMethod("publicMethod");
+        System.setSecurityManager(restrictiveSecurityManager);
+        assertTrue(invokesCachedMethod());
+    }
+
+    public void testReturnsAccesiblePublicMethodsWithoutChecks() throws Exception {
+        cachedMethodUnderTest = createCachedMethod("publicMethod");
+        System.setSecurityManager(restrictiveSecurityManager);
+        assertEquals("publicMethod", cachedMethodUnderTest.setAccessible().getName());
+        assertEquals("publicMethod", cachedMethodUnderTest.getName());
+    }
+
+    public void testAccessesPublicFieldsWithoutChecks() throws Exception {
+        cachedFieldUnderTest = createCachedField("publicField");
+        System.setSecurityManager(restrictiveSecurityManager);
+        TestClass object = new TestClass();
+        cachedFieldUnderTest.setProperty(object, "value");
+        assertEquals("value", cachedFieldUnderTest.getProperty(object));
+    }
+
+    public void testInvokesPrivateMethodsWithoutSecurityManager() throws Exception{
+        cachedMethodUnderTest = createCachedMethod("privateMethod");
+        assertTrue(invokesCachedMethod());
+    }
+
+    public void testAccessesPrivateFieldsWithoutSecurityManager() throws Exception {
+        cachedFieldUnderTest = createCachedField("privateField");
+        System.setSecurityManager(null);
+        TestClass object = new TestClass();
+        cachedFieldUnderTest.setProperty(object, "value");
+        assertEquals("value", cachedFieldUnderTest.getProperty(object));
+    }
+
+    public void testReturnsAccesiblePrivateMethodsWithoutSecurityManager() throws Exception {
+        cachedMethodUnderTest = createCachedMethod("privateMethod");
+        System.setSecurityManager(null);
+        assertEquals("privateMethod", cachedMethodUnderTest.setAccessible().getName());
+        assertEquals("privateMethod", cachedMethodUnderTest.getName());
+    }
+
+    public void testChecksReflectPermissionForInvokeOnPrivateMethods() throws Exception {
+        cachedMethodUnderTest = createCachedMethod("privateMethod");
+        System.setSecurityManager(restrictiveSecurityManager);
+        try {
+            invokesCachedMethod();
+            fail();
+        }
+        catch (InvokerInvocationException e) {
+            assertEquals(CacheAccessControlException.class, e.getCause().getClass());
+        }
+    }
+
+    public void testChecksReflectPermissionForFieldAccessOnPrivateFields() throws Exception {
+        cachedFieldUnderTest = createCachedField("privateField");
+        System.setSecurityManager(restrictiveSecurityManager);
+        TestClass object = new TestClass();
+        try {
+            cachedFieldUnderTest.setProperty(object, "value");
+            fail();
+        }
+        catch (CacheAccessControlException e) {
+        }
+
+        try {
+            cachedFieldUnderTest.getProperty(object);
+            fail();
+        }
+        catch (CacheAccessControlException e) {
+        }
+    }
+
+    public void testChecksReflectPermissionForMethodAccessOnPrivateMethods() throws Exception {
+        cachedMethodUnderTest = createCachedMethod("privateMethod");
+        System.setSecurityManager(restrictiveSecurityManager);
+        try {
+            cachedMethodUnderTest.setAccessible();
+            fail();
+        }
+        catch (CacheAccessControlException e) {
+        }
+
+        try {
+            cachedMethodUnderTest.getCachedMethod();
+            fail();
+        }
+        catch (CacheAccessControlException e) {
+        }
+    }
+
+    public void testInvokesPackagePrivateMethodsWithoutChecksInNonRestrictedPackages() throws Exception {
+        cachedMethodUnderTest = createCachedMethod("packagePrivateMethod");
+        System.setSecurityManager(restrictiveSecurityManager);
+        assertTrue(invokesCachedMethod());
+    }
+
+    public void testChecksReflectPermissionForInvokeOnPackagePrivateMethodsInRestrictedJavaPackages() throws Exception {
+        // FIX_JDK9 remove this exemption for JDK9
+        if (isAtLeastJdk("9.0")) {
+            return;
+        }
+        cachedMethodUnderTest = createCachedMethod(ClassLoader.class, "getBootstrapClassPath", new Class[0]);
+        System.setSecurityManager(restrictiveSecurityManager);
+
+        try {
+            cachedMethodUnderTest.invoke(null, new Object[]{});
+            fail();
+        }
+        catch (InvokerInvocationException e) {
+            assertEquals(CacheAccessControlException.class, e.getCause().getClass());
+        }
+    }
+
+    public void testInvokesProtectedMethodsWithoutChecks() throws Exception {
+        cachedMethodUnderTest = createCachedMethod("protectedMethod");
+        System.setSecurityManager(restrictiveSecurityManager);
+        assertTrue(invokesCachedMethod());
+    }
+
+
+    public void testChecksCreateClassLoaderPermissionForClassLoaderProtectedMethodAccess() throws Exception {
+        cachedMethodUnderTest = createCachedMethod(ClassLoader.class, "defineClass", new Class[]{String.class, ByteBuffer.class, ProtectionDomain.class});
+        forbidden = new Permissions();
+        forbidden.add(new RuntimePermission("createClassLoader"));
+        System.setSecurityManager(restrictiveSecurityManager);
+
+        ClassLoader classLoader = getClass().getClassLoader();
+
+        try {
+            cachedMethodUnderTest.invoke(classLoader, new Object[]{null, null, null});
+            fail();
+        }
+        catch (InvokerInvocationException e) {
+            assertEquals(CacheAccessControlException.class, e.getCause().getClass());
+        }
+    }
+
+    public void testInvokesPrivateMethodsInGroovyObjectsWithoutChecks() throws Exception {
+        cachedMethodUnderTest = createCachedMethod(TestGroovyClass.class, "privateMethod");
+        TestGroovyClass object = new TestGroovyClass();
+        System.setSecurityManager(restrictiveSecurityManager);
+        cachedMethodUnderTest.invoke(object, new Object[]{});
+        assertTrue(object.isMethodCalled());
+    }
+
+    public void testAccessesPrivateFieldsInGroovyObjectsWithoutChecks() throws Exception {
+        Field field = TestGroovyClass.class.getDeclaredField("privateField");
+        field.setAccessible(true);
+        cachedFieldUnderTest = new CachedField(field);
+        TestGroovyClass object = new TestGroovyClass();
+        System.setSecurityManager(restrictiveSecurityManager);
+        cachedFieldUnderTest.setProperty(object, "value");
+        assertEquals("value", cachedFieldUnderTest.getProperty(object));
+    }
+
+}
diff --git a/subprojects/groovy-ant/src/main/java/groovy/util/AntBuilder.java b/subprojects/groovy-ant/src/main/java/groovy/util/AntBuilder.java
index 92961e4648..a4e04a79e0 100644
--- a/subprojects/groovy-ant/src/main/java/groovy/util/AntBuilder.java
+++ b/subprojects/groovy-ant/src/main/java/groovy/util/AntBuilder.java
@@ -35,6 +35,7 @@ import org.apache.tools.ant.dispatch.DispatchUtils;
 import org.apache.tools.ant.helper.AntXMLContext;
 import org.apache.tools.ant.helper.ProjectHelper2;
 import org.codehaus.groovy.ant.FileScanner;
+import org.codehaus.groovy.reflection.ReflectionUtils;
 import org.codehaus.groovy.runtime.DefaultGroovyMethodsSupport;
 import org.xml.sax.Attributes;
 import org.xml.sax.Locator;
@@ -325,7 +326,7 @@ public class AntBuilder extends BuilderSupport {
         try {
             // Have to call fireTestStared/fireTestFinished via reflection as they unfortunately have protected access in Project
             final Method fireTaskStarted = Project.class.getDeclaredMethod("fireTaskStarted", Task.class);
-            fireTaskStarted.setAccessible(true);
+            ReflectionUtils.trySetAccessible(fireTaskStarted);
             fireTaskStarted.invoke(project, task);
 
             Object realThing;
@@ -359,7 +360,7 @@ public class AntBuilder extends BuilderSupport {
         finally {
             try {
                 final Method fireTaskFinished = Project.class.getDeclaredMethod("fireTaskFinished", Task.class, Throwable.class);
-                fireTaskFinished.setAccessible(true);
+                ReflectionUtils.trySetAccessible(fireTaskFinished);
                 fireTaskFinished.invoke(project, task, reason);
             }
             catch (Exception e) {
diff --git a/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/Groovy.java b/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/Groovy.java
index aae992b8ba..48fd137328 100644
--- a/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/Groovy.java
+++ b/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/Groovy.java
@@ -35,6 +35,7 @@ import org.apache.tools.ant.util.FileUtils;
 import org.codehaus.groovy.control.CompilationFailedException;
 import org.codehaus.groovy.control.CompilerConfiguration;
 import org.codehaus.groovy.control.customizers.ImportCustomizer;
+import org.codehaus.groovy.reflection.ReflectionUtils;
 import org.codehaus.groovy.runtime.InvokerHelper;
 import org.codehaus.groovy.runtime.ResourceGroovyMethods;
 import org.codehaus.groovy.tools.ErrorReporter;
@@ -413,7 +414,7 @@ public class Groovy extends Java {
             try {
                 final Object propsHandler = project.getClass().getMethod("getPropsHandler").invoke(project);
                 final Field contextField = propsHandler.getClass().getDeclaredField("context");
-                contextField.setAccessible(true);
+                ReflectionUtils.trySetAccessible(contextField);
                 final Object context = contextField.get(propsHandler);
                 mavenPom = InvokerHelper.invokeMethod(context, "getProject", EMPTY_OBJECT_ARRAY);
             }
diff --git a/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/util/PackageHelperImpl.groovy b/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/util/PackageHelperImpl.groovy
index 73f9f7d32a..3b537343a3 100644
--- a/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/util/PackageHelperImpl.groovy
+++ b/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/util/PackageHelperImpl.groovy
@@ -163,12 +163,14 @@ def filterClassName(Path path) {
     }
 }
 
+class GroovyFileVisitor extends SimpleFileVisitor {}
+
 // walk each file and directory, possibly storing directories as packages, and files as classes
 Files.walkFileTree(fs.getPath('modules'),
         [preVisitDirectory: { dir, attrs -> filterPackageName(dir); FileVisitResult.CONTINUE },
          visitFile: { file, attrs -> filterClassName(file); FileVisitResult.CONTINUE}
         ]
-            as SimpleFileVisitor)
+            as GroovyFileVisitor)
 '''
 
         Set<String> jigsawPackages = (Set<String>) shell.getProperty('result')
diff --git a/subprojects/groovy-swing/src/main/java/org/codehaus/groovy/binding/ClosureTriggerBinding.java b/subprojects/groovy-swing/src/main/java/org/codehaus/groovy/binding/ClosureTriggerBinding.java
index 8a0fecb2ec..7a08f753d7 100644
--- a/subprojects/groovy-swing/src/main/java/org/codehaus/groovy/binding/ClosureTriggerBinding.java
+++ b/subprojects/groovy-swing/src/main/java/org/codehaus/groovy/binding/ClosureTriggerBinding.java
@@ -21,6 +21,7 @@ package org.codehaus.groovy.binding;
 import groovy.lang.Closure;
 import groovy.lang.GroovyObjectSupport;
 import groovy.lang.Reference;
+import org.codehaus.groovy.reflection.ReflectionUtils;
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
@@ -81,13 +82,13 @@ public class ClosureTriggerBinding implements TriggerBinding, SourceBinding {
                     }
                     try {
                         boolean acc = constructor.isAccessible();
-                        constructor.setAccessible(true);
+                        ReflectionUtils.trySetAccessible(constructor);
                         Closure localCopy = (Closure) constructor.newInstance(args);
                         if (!acc) { constructor.setAccessible(false); }
                         localCopy.setResolveStrategy(Closure.DELEGATE_ONLY);
                         for (Field f:closureClass.getDeclaredFields()) {
                             acc = f.isAccessible();
-                            f.setAccessible(true);
+                            ReflectionUtils.trySetAccessible(f);
                             if (f.getType() == Reference.class) {
                                 delegate.fields.put(f.getName(),
                                         (BindPathSnooper) ((Reference) f.get(localCopy)).get());
diff --git a/subprojects/groovy-swing/src/test/groovy/groovy/beans/BindableSwingTest.groovy b/subprojects/groovy-swing/src/test/groovy/groovy/beans/BindableSwingTest.groovy
index f17a37ba5c..39135b8f08 100644
--- a/subprojects/groovy-swing/src/test/groovy/groovy/beans/BindableSwingTest.groovy
+++ b/subprojects/groovy-swing/src/test/groovy/groovy/beans/BindableSwingTest.groovy
@@ -30,6 +30,17 @@ class BindableSwingTest extends GroovySwingTestCase {
 
                 class BindableTestBean6 extends javax.swing.JPanel {
                     @Bindable String testField
+                    
+                    /*
+                    // if the following stub added, the illegal access warnings can be fixed
+                    // java.awt.Component.firePropertyChange(java.lang.String,java.lang.Object,java.lang.Object)
+                    // should we add this kind of stubs automatically?
+                    void firePropertyChange(String propertyName,
+                                      Object oldValue, Object newValue) {
+                    
+                        super.firePropertyChange(propertyName, oldValue, newValue)                  
+                    }
+                    */
                 }
 
                 sb = new BindableTestBean6()
-- 
2.36.1

