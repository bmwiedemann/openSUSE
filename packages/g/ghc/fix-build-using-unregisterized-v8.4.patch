Description: Allow unregisterised ghc-8.4 to build newer GHC
 Commit 4075656e8bb introduced a regression stopping existing unregisteristed
 compilers from being able to compile newer versions of GHC. The problem is
 that the bootstrap compiler uses the newer `rts/storage/ClosureTypes.h` file
 where some defines have been renamed, resulting in the following error:
.
  error: ‘stg_MUT_ARR_PTRS_FROZEN0_info’ undeclared (first use in this function); did you mean ‘stg_MUT_ARR_PTRS_FROZEN_DIRTY_info’?
.
 For more information, see https://gitlab.haskell.org/ghc/ghc/issues/15913.
.
 This patch can be removed, once ghc-8.4 is no longer the bootstrap compiler.
Author: Ilias Tsitsimpis <iliastsi@debian.org>
Bug: https://gitlab.haskell.org/ghc/ghc/issues/15913
Bug-Debian: https://bugs.debian.org/932941

Index: b/includes/rts/storage/ClosureTypes.h
===================================================================
--- a/includes/rts/storage/ClosureTypes.h
+++ b/includes/rts/storage/ClosureTypes.h
@@ -82,5 +82,11 @@
 #define SMALL_MUT_ARR_PTRS_DIRTY      60
 #define SMALL_MUT_ARR_PTRS_FROZEN_DIRTY 61
 #define SMALL_MUT_ARR_PTRS_FROZEN_CLEAN 62
+#if __GLASGOW_HASKELL__ < 806
+#define SMALL_MUT_ARR_PTRS_FROZEN0 SMALL_MUT_ARR_PTRS_FROZEN_DIRTY
+#define SMALL_MUT_ARR_PTRS_FROZEN SMALL_MUT_ARR_PTRS_FROZEN_CLEAN
+#define MUT_ARR_PTRS_FROZEN0 MUT_ARR_PTRS_FROZEN_DIRTY
+#define MUT_ARR_PTRS_FROZEN MUT_ARR_PTRS_FROZEN_CLEAN
+#endif
 #define COMPACT_NFDATA                63
 #define N_CLOSURE_TYPES               64
Index: b/includes/stg/MiscClosures.h
===================================================================
--- a/includes/stg/MiscClosures.h
+++ b/includes/stg/MiscClosures.h
@@ -116,12 +116,22 @@ RTS_ENTRY(stg_ARR_WORDS);
 RTS_ENTRY(stg_MUT_ARR_WORDS);
 RTS_ENTRY(stg_MUT_ARR_PTRS_CLEAN);
 RTS_ENTRY(stg_MUT_ARR_PTRS_DIRTY);
+#if __GLASGOW_HASKELL__ < 806
+RTS_ENTRY(stg_MUT_ARR_PTRS_FROZEN);
+RTS_ENTRY(stg_MUT_ARR_PTRS_FROZEN0);
+#else
 RTS_ENTRY(stg_MUT_ARR_PTRS_FROZEN_CLEAN);
 RTS_ENTRY(stg_MUT_ARR_PTRS_FROZEN_DIRTY);
+#endif
 RTS_ENTRY(stg_SMALL_MUT_ARR_PTRS_CLEAN);
 RTS_ENTRY(stg_SMALL_MUT_ARR_PTRS_DIRTY);
+#if __GLASGOW_HASKELL__ < 806
+RTS_ENTRY(stg_SMALL_MUT_ARR_PTRS_FROZEN);
+RTS_ENTRY(stg_SMALL_MUT_ARR_PTRS_FROZEN0);
+#else
 RTS_ENTRY(stg_SMALL_MUT_ARR_PTRS_FROZEN_CLEAN);
 RTS_ENTRY(stg_SMALL_MUT_ARR_PTRS_FROZEN_DIRTY);
+#endif
 RTS_ENTRY(stg_MUT_VAR_CLEAN);
 RTS_ENTRY(stg_MUT_VAR_DIRTY);
 RTS_ENTRY(stg_END_TSO_QUEUE);
