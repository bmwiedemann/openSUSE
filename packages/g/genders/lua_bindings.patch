diff --git a/config/ac_lua_extensions.m4 b/config/ac_lua_extensions.m4
deleted file mode 100644
index 4dbfb7b..0000000
--- a/config/ac_lua_extensions.m4
+++ /dev/null
@@ -1,21 +0,0 @@
-
-AC_DEFUN([AC_LUA_EXTENSIONS],
-[
-  AC_MSG_CHECKING(for --with-lua-extensions)
-  AC_ARG_WITH(lua-extensions,
-     AC_HELP_STRING([--with-lua-extensions=], 
-                    [enable or disable lua extensions build]),
-     [ case "$withval" in
-     yes)
-         ac_with_lua_extensions=yes
-         ;;
-     no)
-         ac_with_lua_extensions=no
-         ;;
-     *)
-         ac_with_lua_extensions=yes
-         ;;
-     esac ]
-  )
-  AC_MSG_RESULT(${ac_with_lua_extensions=yes})
-])
diff --git a/config/x_ac_lua.m4 b/config/x_ac_lua.m4
deleted file mode 100644
index 2f5f587..0000000
--- a/config/x_ac_lua.m4
+++ /dev/null
@@ -1,60 +0,0 @@
-##*****************************************************************************
-#  AUTHOR:
-#    Mark Grondona <mgrondona@llnl.gov>
-#
-#  SYNOPSIS:
-#    AC_LUA
-#
-#  DESCRIPTION:
-#    Check for presence of lua libs and headers
-##*****************************************************************************
-
-
-AC_DEFUN([X_AC_LUA],
-[
-	x_ac_lua_pkg_name="lua"
-	#check for 5.3 then 5.2 then 5.1
-	PKG_CHECK_EXISTS([lua5.3], [x_ac_lua_pkg_name=lua5.3],
-		[PKG_CHECK_EXISTS([lua-5.3], [x_ac_lua_pkg_name=lua-5.3],
-		[PKG_CHECK_EXISTS([lua5.2], [x_ac_lua_pkg_name=lua5.2],
-		[PKG_CHECK_EXISTS([lua-5.2], [x_ac_lua_pkg_name=lua-5.2],
-		[PKG_CHECK_EXISTS([lua5.1], [x_ac_lua_pkg_name=lua5.1],
-		[PKG_CHECK_EXISTS([lua-5.1], [x_ac_lua_pkg_name=lua-5.1],
-	        [x_ac_lua_pkg_name="lua >= 5.1"])])])])])])
-	PKG_CHECK_MODULES([lua], ${x_ac_lua_pkg_name},
-                [x_ac_have_lua="yes"],
-                [x_ac_have_lua="no"])
-
-	if test "x$x_ac_have_lua" = "xyes"; then
-	  saved_CFLAGS="$CFLAGS"
-	  saved_LIBS="$LIBS"
-	  lua_CFLAGS="$lua_CFLAGS"
-	  CFLAGS="$CFLAGS $lua_CFLAGS"
-	  LIBS="$LIBS $lua_LIBS"
-	  AC_MSG_CHECKING([for whether we can link to liblua])
-	  AC_TRY_LINK(
-		[#include <lua.h>
-                 #include <lauxlib.h>
-		 #include <lualib.h>
-		],
-		[lua_State *L = luaL_newstate (); luaL_openlibs(L);
-		],
-		[], [x_ac_have_lua="no"])
-
-	  AC_MSG_RESULT([$x_ac_have_lua $x_ac_lua_pkg_name])
-	  if test "x$x_ac_have_lua" = "xno"; then
-	    AC_MSG_WARN([unable to link against lua libraries])
-	  else
-	    AC_DEFINE(HAVE_LUA, 1, [Define to 1 if we have the Lua library])
-	    # We can not define something here to determine version for systems
-	    # that use just liblua we will not know what version we are using.
-	    # Use LUA_VERSION_NUM as in lua.h it will always be right.
-	  fi
-	  CFLAGS="$saved_CFLAGS"
-	  LIBS="$saved_LIBS"
-	else
-	  AC_MSG_WARN([unable to locate lua package])
-	fi
-
-	AM_CONDITIONAL(HAVE_LUA, test "x$x_ac_have_lua" = "xyes")
-])
diff --git a/configure.ac b/configure.ac
index 5096c98..9f43805 100644
--- a/configure.ac
+++ b/configure.ac
@@ -68,7 +68,6 @@ PYTHONGENDERS_MINOR=2
 PYTHONGENDERS_VERSION=$PYTHONGENDERS_MAJOR.$PYTHONGENDERS_MINOR
 AC_SUBST([PYTHONGENDERS_VERSION])
 
-
 ##
 # Checks for programs.
 ##
@@ -87,7 +86,6 @@ AC_PATH_PROG([JAVAH], [javah])
 AC_PATH_PROG([JAVA], [java])
 AC_PATH_PROG([JAR], [jar])
 AC_PATH_PROG([JAVADOC], [javadoc])
-AC_PATH_PROG([JAVADOC], [lua])
 AC_DEBUG
 
 ##
@@ -210,21 +208,6 @@ AM_CONDITIONAL(WITH_CPLUSPLUS_EXTENSIONS, [test "$ac_with_cplusplus_extensions"
 AC_JAVA_EXTENSIONS
 AM_CONDITIONAL(WITH_JAVA_EXTENSIONS, [test "$ac_with_java_extensions" = "yes"])
 
-
-#
-# expand lua
-#
-AX_PROG_LUA
-AX_LUA_HEADERS
-AX_LUA_LIBS
-
-#
-# Check for lua
-#
-
-AC_LUA_EXTENSIONS
-AM_CONDITIONAL(WITH_LUA_EXTENSIONS, [test "$ac_with_lua_extensions" = "yes"])
-
 ##
 # Checks for typedefs, structures, and compiler characteristics.
 ##
@@ -265,7 +248,6 @@ AC_CONFIG_FILES( \
   src/extensions/perl/Genders/Makefile \
   src/extensions/perl/Genders/Genders.pm \
   src/extensions/python/Makefile \
-  src/extensions/lua/Makefile \
   src/extensions/python/genderssetup.py \
   src/extensions/java/Makefile \
   src/testsuite/Makefile \
diff --git a/src/extensions/Makefile.am b/src/extensions/Makefile.am
index e85f6c2..ec963c4 100644
--- a/src/extensions/Makefile.am
+++ b/src/extensions/Makefile.am
@@ -4,4 +4,4 @@
 ## Process this file with automake to produce Makefile.in.
 ##*****************************************************************************
 
-SUBDIRS = cplusplus java perl python lua
+SUBDIRS = cplusplus java perl python
diff --git a/src/extensions/lua/Makefile.am b/src/extensions/lua/Makefile.am
deleted file mode 100644
index 4512cee..0000000
--- a/src/extensions/lua/Makefile.am
+++ /dev/null
@@ -1,21 +0,0 @@
-# DESTDIR is usually set during make install time, not configure or
-# make time, so we work around it with the --with-extension-destdir
-# autoconf option.
-
-
-if WITH_LUA_EXTENSIONS
-
-luaexec_LTLIBRARIES = genders.la
-
-genders_la_SOURCES = genderslua.c
-
-genders_la_CFLAGS =  @LUA_INCLUDE@ -I../../libgenders/
-
-genders_la_LDFLAGS = -module -avoid-version
-
-genders_la_LIBADD = ../../libgenders/libgenders.la $(OTHER_FLAGS) @LUA_LIB@
-
-
-endif
-
-EXTRA_DIST = genderslua.c
diff --git a/src/extensions/lua/genderslua.c b/src/extensions/lua/genderslua.c
deleted file mode 100644
index f2364af..0000000
--- a/src/extensions/lua/genderslua.c
+++ /dev/null
@@ -1,322 +0,0 @@
-/*****************************************************************************
- *  Copyright (C) 2018 SUSE LLC
- *  Written by Christian Goll <cgoll@suse.com>
- *
- *  This file is part of Genders, a cluster configuration database.
- *  For details, see <http://www.llnl.gov/linux/genders/>.
- *
- *  Genders is free software; you can redistribute it and/or modify it under
- *  the terms of the GNU General Public License as published by the Free
- *  Software Foundation; either version 2 of the License, or (at your option)
- *  any later version.
- *
- *  Genders is distributed in the hope that it will be useful, but WITHOUT ANY
- *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
- *  details.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with Genders.  If not, see <http://www.gnu.org/licenses/>.
-\*****************************************************************************/
-#if HAVE_CONFIG_H
-#include "config.h"
-#endif /* HAVE_CONFIG_H */
-#include <stdlib.h>
-#include <string.h>
-#include <lua.h>
-#include <lauxlib.h>
-#include <lualib.h>
-#include <genders.h>
-
-typedef struct {
-	/* genders_t itself is a pointer */
-	genders_t handle;
-	char      *db_name;
- } lgenders_userdata_t;
-
-static int lgenders_new(lua_State *L) {
-	lgenders_userdata_t *dbh;
-	const char *db_name, *g_error;
-	/* check for argument vailidy */
-	db_name = luaL_checkstring(L,1); 
-	if (db_name == NULL)
-		luaL_error(L,"database name could not be empty");
-	/* Create the user data pushing it onto the stack. We also pre-initialize
-	 * the member of the userdata in case initialization fails in some way. If
-	 * that happens we want the userdata to be in a consistent state for __gc. 
-	 */
-	dbh = (lgenders_userdata_t *)lua_newuserdata(L, sizeof(*dbh));
-	dbh->handle = NULL;
-	dbh->db_name = NULL; 
-	/* Add the metatable to the stack. */
-	luaL_getmetatable(L, "LGenders");
-	/* Set the metatable on the userdata. */
-	lua_setmetatable(L, -2);
-	/* Create the handle */
-	dbh->handle =  genders_handle_create(); 
-	dbh->db_name = strdup(db_name);
-	if(genders_load_data(dbh->handle,dbh->db_name) != 0) {
-		g_error = strdup(genders_errormsg(dbh->handle));
-		luaL_error(L,g_error);
-	}
-	return 1;
-}
-static int lgenders_reload(lua_State *L) {
-	lgenders_userdata_t *dbh;
-	const char *db_name, *g_error;
-	dbh = (lgenders_userdata_t *)luaL_checkudata(L, 1, "LGenders");
-	/* check for argument vailidy */
-	db_name = luaL_checkstring(L,2); 
-	if (db_name == NULL)
-		db_name = strdup(dbh->db_name);
-	if (dbh->handle != NULL)
-		genders_handle_destroy(dbh->handle);
-	dbh->db_name = NULL; 
-	/* Create the handle */
-	dbh->handle =  genders_handle_create(); 
-	dbh->db_name = strdup(db_name);
-	if(genders_load_data(dbh->handle,dbh->db_name) != 0) {
-		g_error = strdup(genders_errormsg(dbh->handle));
-		luaL_error(L,g_error);
-	}
-	return 0;
-}
-static int lgenders_destroy(lua_State *L) {
-	lgenders_userdata_t *dbh;
-	dbh = (lgenders_userdata_t *)luaL_checkudata(L, 1, "LGenders");
-	/* pass return value to lus */
-	if (dbh->handle != NULL)
-		genders_handle_destroy(dbh->handle);
-
-	if (dbh->db_name != NULL)
-		free(dbh->db_name);
-	dbh->db_name = NULL;
-	return 0;
-}
-
-static int lgenders_getnumnodes(lua_State *L) {
-	lgenders_userdata_t *dbh;
-	dbh = (lgenders_userdata_t *)luaL_checkudata(L, 1, "LGenders");
-	lua_pushinteger(L,genders_getnumnodes(dbh->handle));
-	return 1;
-}
-
-static int lgenders_getnumattrs(lua_State *L) {
-	lgenders_userdata_t *dbh;
-	dbh = (lgenders_userdata_t *)luaL_checkudata(L, 1, "LGenders");
-	lua_pushinteger(L,genders_getnumattrs(dbh->handle));
-	return 1;
-}
-
-static int lgenders_getnodes(lua_State *L) {
-	char** nodelist;
-	const char *g_error, *attr, *val;
-	int size, nr_nodes, i, nr_args = 0;
-	lgenders_userdata_t *dbh;
-	dbh = (lgenders_userdata_t *)luaL_checkudata(L, 1, "LGenders");
-	/* create space for the genders stuff */
-	size = genders_nodelist_create(dbh->handle,&nodelist);
-	if(size == -1) {
-		g_error = strdup(genders_errormsg(dbh->handle));
-		luaL_error(L,g_error);
-	}
-	attr = NULL; val = NULL;
-	/* check for attr and val */
-	nr_args = lua_gettop(L);
-	if(nr_args > 1)
-		attr = luaL_checkstring(L,2); 
-	if(nr_args > 2)
-		val = luaL_checkstring(L,3); 
-	if(nr_args > 3)
-		luaL_error(L,"getnodes accepts none,one or two arguments");
-	nr_nodes = genders_getnodes(dbh->handle,nodelist,size,attr,val);
-	lua_newtable(L);
-	for(i = 0; i < nr_nodes; i++) {
-		lua_pushstring(L,nodelist[i]);
-		lua_rawseti(L,-2,i+1);
-	}
-	/* destroy list of nodes */
-	if(genders_nodelist_destroy(dbh->handle,nodelist) == -1) {
-		g_error = strdup(genders_errormsg(dbh->handle));
-		luaL_error(L,g_error);
-	}
-	return 1;
-}
-
-static int lgenders_query(lua_State *L) {
-	char** nodelist;
-	const char *g_error, *query;
-	int size, nr_nodes, i, nr_args = 0;
-	lgenders_userdata_t *dbh;
-	dbh = (lgenders_userdata_t *)luaL_checkudata(L, 1, "LGenders");
-	/* create space for the genders stuff */
-	size = genders_nodelist_create(dbh->handle,&nodelist);
-	if(size == -1) {
-		g_error = strdup(genders_errormsg(dbh->handle));
-		luaL_error(L,g_error);
-	}
-	nr_args = lua_gettop(L);
-	if(nr_args == 2)
-		query = luaL_checkstring(L,2); 
-	else
-		luaL_error(L,"query must be called with one argument");
-	nr_nodes = genders_query(dbh->handle,nodelist,size,query);
-	lua_newtable(L);
-	for(i = 0; i < nr_nodes; i++) {
-		lua_pushstring(L,nodelist[i]);
-		lua_rawseti(L,-2,i+1);
-	}
-	/* destroy list of nodes */
-	if(genders_nodelist_destroy(dbh->handle,nodelist) == -1) {
-		g_error = strdup(genders_errormsg(dbh->handle));
-		luaL_error(L,g_error);
-	}
-	return 1;
-}
-static int lgenders_getattr(lua_State *L) {
-	char **attr_list, **val_list;
-	const char *node, *g_error;
-	int ret_code, nr_args, size_attr, i = 0;
-	lgenders_userdata_t *dbh;
-	dbh = (lgenders_userdata_t *)luaL_checkudata(L, 1, "LGenders");
-	nr_args = lua_gettop(L);
-	if(nr_args == 2)
-		node = luaL_checkstring(L,2); 
-	else
-		luaL_error(L,"query must be called with one argument");
-	/* create space for the lists */
-	ret_code = genders_attrlist_create(dbh->handle,&attr_list);
-	if(ret_code == -1) {
-		g_error = strdup(genders_errormsg(dbh->handle));
-		luaL_error(L,g_error);
-	}
-	ret_code = genders_vallist_create(dbh->handle,&val_list);
-	if(ret_code == -1) {
-		g_error = strdup(genders_errormsg(dbh->handle));
-		luaL_error(L,g_error);
-	}
-	/* hopefully size (which is in ret_code) of attr_list and val_list are the same */
-	size_attr = genders_getattr(dbh->handle,attr_list,val_list,ret_code,node);
-	if(size_attr == -1) {
-		g_error = strdup(genders_errormsg(dbh->handle));
-		luaL_error(L,g_error);
-	}
-	lua_newtable(L);
-	for(i = 0; i < size_attr; i++) {
-		lua_pushstring(L, attr_list[i]);
-		lua_pushstring(L, val_list[i]);
-		lua_settable(L, -3);
-	}
-	/* destroy list of nodes */
-	if(genders_vallist_destroy(dbh->handle,val_list) == -1) {
-		g_error = strdup(genders_errormsg(dbh->handle));
-		luaL_error(L,g_error);
-	}
-	if(genders_attrlist_destroy(dbh->handle,attr_list) == -1) {
-		g_error = strdup(genders_errormsg(dbh->handle));
-		luaL_error(L,g_error);
-	}
-	return 1;
-}
-
-static int lgenders_isnode(lua_State *L) {
-	const char *node, *g_error;
-	int ret_code, nr_args;
-	lgenders_userdata_t *dbh;
-	dbh = (lgenders_userdata_t *)luaL_checkudata(L, 1, "LGenders");
-	nr_args = lua_gettop(L);
-	if(nr_args == 2)
-		node = luaL_checkstring(L,2); 
-	else
-		luaL_error(L,"isnode must be called with one argument");
-	ret_code = genders_isnode(dbh->handle,node);
-	if(ret_code == -1) {
-		g_error = strdup(genders_errormsg(dbh->handle));
-		luaL_error(L,g_error);
-	}
-	lua_pushboolean(L,ret_code);
-	return 1;
-}
-
-static int lgenders_isattr(lua_State *L) {
-	const char *attr, *g_error;
-	int ret_code, nr_args;
-	lgenders_userdata_t *dbh;
-	dbh = (lgenders_userdata_t *)luaL_checkudata(L, 1, "LGenders");
-	nr_args = lua_gettop(L);
-	if(nr_args == 2)
-		attr = luaL_checkstring(L,2); 
-	else
-		luaL_error(L,"isattr must be called with one argument");
-	ret_code = genders_isattr(dbh->handle,attr);
-	if(ret_code == -1) {
-		g_error = strdup(genders_errormsg(dbh->handle));
-		luaL_error(L,g_error);
-	}
-	lua_pushboolean(L,ret_code);
-	return 1;
-}
-
-static int lgenders_isattrval(lua_State *L) {
-	const char *attr, *val, *g_error;
-	int ret_code, nr_args;
-	lgenders_userdata_t *dbh;
-	dbh = (lgenders_userdata_t *)luaL_checkudata(L, 1, "LGenders");
-	nr_args = lua_gettop(L);
-	if(nr_args == 3) {
-		attr = luaL_checkstring(L,2); 
-		val = luaL_checkstring(L,3); 
-	}
-	else
-		luaL_error(L,"isattrval must be called with two arguments");
-	ret_code = genders_isattrval(dbh->handle,attr,val);
-	if(ret_code == -1) {
-		g_error = strdup(genders_errormsg(dbh->handle));
-		luaL_error(L,g_error);
-	}
-	lua_pushboolean(L,ret_code);
-	return 1;
-}
-
-static const struct luaL_Reg genders_methods[] = {
-	{"getnumattrs",lgenders_getnumattrs},
-	{"getnumnodes",lgenders_getnumnodes},
-	{"getnodes",lgenders_getnodes},
-	{"getattr",lgenders_getattr},
-	{"query",lgenders_query},
-	{"isnode",lgenders_isnode},
-	{"isattr",lgenders_isattr},
-	{"isattrval",lgenders_isattrval},
-	{"reload",lgenders_reload},
-	{"__gc",lgenders_destroy},
-	{NULL,NULL},
-};
-
-static const struct luaL_Reg genders_functions[] = {
-	{ "new", lgenders_new },
-	{ NULL,  NULL}
-};
-
-
-int luaopen_genders(lua_State *L) {
-	/* Create the metatable and put it on the stack. */
-	luaL_newmetatable(L, "LGenders");
-	/* Duplicate the metatable on the stack (We know have 2). */
-	lua_pushvalue(L, -1);
-	/* Pop the first metatable off the stack and assign it to __index
-	* of the second one. We set the metatable for the table to itself.
-	* This is equivalent to the following in lua:
-	* metatable = {}
-	* metatable.__index = metatable
-	*/
-	lua_setfield(L, -2, "__index");
-
-	/* Set the methods to the metatable that should be accessed via object:func */
-	luaL_setfuncs(L, genders_methods, 0);
-
-	/* Register the object.func functions into the table that is at the top of the
-	* stack. */
-	luaL_newlib(L, genders_functions);
-
-	return 1;
-}
