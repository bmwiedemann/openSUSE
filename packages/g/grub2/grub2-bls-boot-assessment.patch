Implement Automatic Boot Assessment for grub2-bls.

https://systemd.io/AUTOMATIC_BOOT_ASSESSMENT/

The entries are ordered first by the boot tries left, keeping
the one without available tries (e.g. <entry>+0-3.conf)
after the one without a boot counter or with a positive boot counter.

After removing the boot counter from the release string, keep the ordering
as it worked previously.

--- a/grub-core/commands/blsuki.c
+++ b/grub-core/commands/blsuki.c
@@ -255,6 +255,39 @@
   return ret;
 }
 
+static long
+tries_left (const char *filename)
+{
+  char *tries_left_str;
+  long ret = -1;
+  char *str = grub_strdup (filename);
+
+  if (str == NULL)
+    return -1;
+
+  /* Search for the start of the tries left, as per boot assessment */
+  tries_left_str = grub_strrchr (str, '+');
+
+  if (tries_left_str != NULL)
+    {
+      const char *end;
+      long tries;
+
+      ++tries_left_str;
+      tries = grub_strtol (tries_left_str, (const char **) &end, 10);
+
+      if (grub_errno == GRUB_ERR_NONE)
+	{
+	  if (*end == '-' || *end == '.')
+	    ret = tries;
+	}
+      else
+	grub_errno = GRUB_ERR_NONE;
+    }
+
+  grub_free (str);
+  return ret;
+}
 /*
  * Add a new grub_blsuki_entry_t struct to the entries list and sort it's
  * position on the list.
@@ -274,10 +307,19 @@
 
   FOR_BLSUKI_ENTRIES (e)
     {
+      long t1, t2;
+     
       rc = filevercmp (entry->filename, e->filename);
       if (rc == 0)
 	return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("duplicate file: `%s'"), entry->filename);
 
+      t1 = tries_left (entry->filename);
+      t2 = tries_left (e->filename);
+      if (t2 == 0 && t1 != 0)
+	rc = 1;
+      else if (t2 != 0 && t1 == 0)
+	rc = -1;
+
       if (rc > 0)
 	{
 	  grub_dprintf ("blsuki", "Add entry with id \"%s\"\n", entry->filename);
