Set the EFI variables LoaderEntries and LoaderEntrySelected to
follow systemd-boot implementation and make bootctl work.

--- a/grub-core/commands/efi/blsbumpcounter.c
+++ b/grub-core/commands/efi/blsbumpcounter.c
@@ -60,8 +60,14 @@
 
   /* Look for the start of the count
      If no '+' symbol has been found, the boot counting isn't enabled for the selected entry */
+  char* new_path = grub_xasprintf ("%s.conf", id);
+  grub_efi_set_variable_to_string("LoaderEntrySelected", &grub_efi_loader_guid, new_path,
+					      GRUB_EFI_VARIABLE_BOOTSERVICE_ACCESS |
+					      GRUB_EFI_VARIABLE_RUNTIME_ACCESS);
+  grub_free(new_path);
   if (grub_strrchr(id, '+') == NULL) {
     grub_dprintf("bls_bumpcounter", "boot counting is not in effect for id %s\n", id);
+
     return GRUB_ERR_NONE;
   }
 
@@ -183,7 +189,6 @@
       goto finish;
   }
 
-  char *new_path;
   if (tries == -1) {
     /* This is the first try, rename accordingly */
     new_path = grub_xasprintf ("%s+%d-1.conf", id, tries_left);
--- a/grub-core/commands/blsuki.c
+++ b/grub-core/commands/blsuki.c
@@ -45,6 +45,14 @@
 #define GRUB_BOOT_DEVICE ""
 #endif
 
+#ifdef GRUB_MACHINE_EFI
+#include <grub/efi/efi.h>
+#define GRUB_EFI_LOADER_GUID \
+        { 0x4a67b082, 0x0a4c, 0x41cf, { 0xb6, 0xc7, 0x44, 0x0b, 0x29, 0xbb, 0x8c, 0x4f } }
+
+static grub_guid_t grub_efi_loader_guid = GRUB_EFI_LOADER_GUID;
+#endif
+
 GRUB_MOD_LICENSE ("GPLv3+");
 
 #define GRUB_BLS_CONFIG_PATH "/loader/entries/"
@@ -1537,6 +1545,12 @@
   const char *def_entry = NULL;
   grub_blsuki_entry_t *entry = NULL;
   int idx = 0;
+#ifdef GRUB_MACHINE_EFI
+  grub_size_t size = 0, r_size;
+  grub_efi_char16_t *efi_entries = NULL;
+  grub_efi_char16_t *p = NULL;
+  char* tmp = NULL;
+#endif
 
   def_entry = grub_env_get ("default");
 
@@ -1558,11 +1572,58 @@
 	    uki_create_entry (entry);
 #endif
 	  entry->visible = true;
+#ifdef GRUB_MACHINE_EFI
+	  grub_size_t len = grub_strlen (entry->filename);
+
+	  if (len > BLS_EXT_LEN && grub_strcmp (entry->filename + len - BLS_EXT_LEN, ".conf") == 0)
+	    size += (len - BLS_EXT_LEN + 1);
+	  else
+	    size += (len + 1);
+#endif
 	}
 
       idx++;
     }
 
+#ifdef GRUB_MACHINE_EFI
+  efi_entries = grub_malloc (size * sizeof (grub_efi_char16_t));
+  if (efi_entries == NULL)
+    return grub_errno;
+
+  p = efi_entries;
+  r_size = size;
+  FOR_BLSUKI_ENTRIES (entry)
+    {
+      if (entry->visible)
+	{
+	  grub_size_t len = grub_strlen (entry->filename);
+
+	  if (len > BLS_EXT_LEN && grub_strcmp (entry->filename + len - BLS_EXT_LEN, ".conf") == 0)
+	    len -= BLS_EXT_LEN;
+
+	  if (r_size < (len + 1))
+	    {
+	      grub_dprintf ("blsuki", "LoaderEntries buffer too small\n");
+	      break;
+	    }
+
+	  r_size -= (len + 1);
+	  tmp = entry->filename;
+	  while (len)
+	    {
+	      *p++ = (grub_efi_char16_t) *tmp++;
+	      len--;
+	    }
+	  *p++ = (grub_efi_char16_t) '\0';
+	}
+    }
+  grub_efi_set_variable_with_attributes ("LoaderEntries", &grub_efi_loader_guid,
+					      efi_entries, (size - r_size) * sizeof (grub_efi_char16_t),
+					      GRUB_EFI_VARIABLE_BOOTSERVICE_ACCESS |
+					      GRUB_EFI_VARIABLE_RUNTIME_ACCESS);
+  grub_free (efi_entries);
+#endif
+
   return GRUB_ERR_NONE;
 }
 
