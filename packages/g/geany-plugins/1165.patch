From 108ef15553663e3db49343cbc4e4664c521cb96b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Enrico=20Tr=C3=B6ger?= <enrico.troeger@uvena.de>
Date: Sun, 20 Feb 2022 13:15:35 +0100
Subject: [PATCH] GitChangeBar: Support libgit2 1.4.x

libgit2 1.4.0 changed the public API of "git_buf" and renamed the
attribute "asize" to "reserved".
For details, see https://github.com/libgit2/libgit2/pull/6078/files.
---
 git-changebar/src/gcb-plugin.c | 347 +++++++++++++++++----------------
 1 file changed, 176 insertions(+), 171 deletions(-)

diff --git a/git-changebar/src/gcb-plugin.c b/git-changebar/src/gcb-plugin.c
index f8ce20cd6..a5b37a9b5 100644
--- a/git-changebar/src/gcb-plugin.c
+++ b/git-changebar/src/gcb-plugin.c
@@ -1,20 +1,20 @@
 /*
- *  
+ *
  *  Copyright (C) 2014  Colomban Wendling <ban@herbesfolles.org>
- *  
+ *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation, either version 3 of the License, or
  *  (at your option) any later version.
- *  
+ *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
- *  
+ *
  *  You should have received a copy of the GNU General Public License
  *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *  
+ *
  */
 
 #include "config.h"
@@ -49,6 +49,11 @@
 # define git_buf_dispose  git_buf_free
 # define git_error_last   giterr_last
 #endif
+#if ! defined (LIBGIT2_VER_MINOR) || (LIBGIT2_VER_MAJOR < 1) || ( (LIBGIT2_VER_MAJOR == 1) && (LIBGIT2_VER_MINOR < 4) )
+# define gcb_git_buf_reserved asize
+#else
+# define gcb_git_buf_reserved reserved
+#endif
 
 
 GeanyPlugin      *geany_plugin;
@@ -216,7 +221,7 @@ static int
 gcb_git_buf_grow (git_buf  *buf,
                   size_t    target_size)
 {
-  if (buf->asize == 0) {
+  if (buf->gcb_git_buf_reserved == 0) {
     if (target_size == 0) {
       target_size = buf->size;
     }
@@ -234,7 +239,7 @@ buf_zero (git_buf *buf)
   if (buf) {
     buf->ptr = NULL;
     buf->size = 0;
-    buf->asize = 0;
+    buf->gcb_git_buf_reserved = 0;
   }
 }
 
@@ -257,19 +262,19 @@ repo_get_file_blob_contents (git_repository  *repo,
 {
   git_reference  *head    = NULL;
   gboolean        success = FALSE;
-  
+
   if (git_repository_head (&head, repo) == 0) {
     git_commit *commit = NULL;
-    
+
     if (git_commit_lookup (&commit, repo, git_reference_target (head)) == 0) {
       git_tree *tree = NULL;
-      
+
       if (git_commit_tree (&tree, commit) == 0) {
         git_tree_entry *entry = NULL;
-        
+
         if (git_tree_entry_bypath (&entry, tree, relpath) == 0) {
           git_blob *blob;
-          
+
           if (git_blob_lookup (&blob, repo, git_tree_entry_id (entry)) == 0) {
             if (git_blob_filtered_content (contents, blob, relpath,
                                            check_for_binary_data) == 0 &&
@@ -286,7 +291,7 @@ repo_get_file_blob_contents (git_repository  *repo,
     }
     git_reference_free (head);
   }
-  
+
   return success;
 }
 
@@ -294,7 +299,7 @@ static void
 free_job (gpointer data)
 {
   AsyncBlobContentsJob *job = data;
-  
+
   /* unlikely, but if we still have the buffer, free it */
   if (job->buf.ptr) {
     git_buf_dispose (&job->buf);
@@ -307,16 +312,16 @@ static gboolean
 report_work_in_idle (gpointer data)
 {
   AsyncBlobContentsJob *job = data;
-  
+
   /* update cached blob */
   clear_cached_blob_contents ();
   G_blob_contents = job->buf;
   G_blob_contents_tag = job->buf.ptr ? job->tag : 0;
-  
+
   job->callback (job->path, job->buf.ptr ? &job->buf : NULL, job->user_data);
-  
+
   buf_zero (&job->buf);
-  
+
   return FALSE;
 }
 
@@ -331,7 +336,7 @@ monitor_repo_file (git_repository  *repo,
   GFileMonitor *monitor = NULL;
   gchar        *path    = g_build_filename (git_repository_path (repo),
                                             subpath, NULL);
-  
+
   file = g_file_new_for_path (path);
   monitor = g_file_monitor (file, 0, NULL, &err);
   if (err) {
@@ -342,7 +347,7 @@ monitor_repo_file (git_repository  *repo,
   }
   g_object_unref (file);
   g_free (path);
-  
+
   return monitor;
 }
 
@@ -354,14 +359,14 @@ monitor_head_ref (git_repository *repo,
 {
   git_reference  *head    = NULL;
   GFileMonitor   *monitor = NULL;
-  
+
   if (! git_repository_head_detached (repo) &&
       git_repository_head (&head, repo) == 0) {
     monitor = monitor_repo_file (repo, git_reference_name (head),
                                  changed_callback, user_data);
     git_reference_free (head);
   }
-  
+
   return monitor;
 }
 
@@ -377,14 +382,14 @@ path_dir_contains (const gchar *dir,
 #else
 # define NORM_PATH_CH(c) (c)
 #endif
-  
+
   g_return_val_if_fail (dir != NULL, NULL);
   g_return_val_if_fail (path != NULL, NULL);
-  
+
   while (*dir && NORM_PATH_CH (*dir) == NORM_PATH_CH (*path)) {
     dir++, path++;
   }
-  
+
   return *dir ? NULL : path;
 }
 
@@ -395,22 +400,22 @@ get_path_in_repository (git_repository *repo,
 {
   const gchar  *workdir   = git_repository_workdir (repo);
   const gchar  *rel_path  = path_dir_contains (workdir, sys_path);
-  
+
 #ifdef G_OS_WIN32
   if (rel_path) {
     /* we want an internal Git path, which uses UNIX format */
     gchar  *p;
     gchar  *repo_path = g_strdup (rel_path);
-    
+
     for (p = repo_path; *p; p++) {
       if (*p == '\\') {
         *p = '/';
       }
     }
-    
+
     return repo_path;
   }
-  
+
   return NULL;
 #else
   return g_strdup (rel_path);
@@ -425,10 +430,10 @@ worker_thread (gpointer data)
   GFileMonitor         *monitors[2] = { NULL, NULL };
   AsyncBlobContentsJob *job;
   guint                 i;
-  
+
   while ((job = g_async_queue_pop (queue)) != QUIT_THREAD_JOB) {
     const gchar *path = job->path;
-    
+
     if (repo && (job->force ||
                  ! path_dir_contains (path, git_repository_workdir (repo)))) {
       /* FIXME: this can fail with nested repositories */
@@ -460,24 +465,24 @@ worker_thread (gpointer data)
       }
       g_free(dirname);
     }
-    
+
     buf_zero (&job->buf);
     if (repo) {
       gchar *relpath = get_path_in_repository (repo, path);
-      
+
       if (relpath) {
         if (! repo_get_file_blob_contents (repo, relpath, &job->buf, 0)) {
           git_buf_dispose (&job->buf);
           buf_zero (&job->buf);
         }
-        
+
         g_free (relpath);
       }
     }
-    
+
     g_idle_add_full (G_PRIORITY_LOW, report_work_in_idle, job, free_job);
   }
-  
+
   for (i = 0; i < G_N_ELEMENTS (monitors); i++) {
     if (monitors[i]) {
       g_object_unref (monitors[i]);
@@ -487,7 +492,7 @@ worker_thread (gpointer data)
   if (repo) {
     git_repository_free (repo);
   }
-  
+
   return NULL;
 }
 
@@ -503,14 +508,14 @@ get_cached_blob_contents_async (const gchar          *path,
     callback (path, &G_blob_contents, user_data);
   } else {
     AsyncBlobContentsJob *job = g_slice_alloc (sizeof *job);
-    
+
     job->force      = force;
     job->tag        = tag;
     job->path       = g_strdup (path);
     job->callback   = callback;
     job->user_data  = user_data;
     buf_zero (&job->buf);
-    
+
     if (! G_thread) {
       G_queue = g_async_queue_new ();
 #if GLIB_CHECK_VERSION (2, 32, 0)
@@ -519,7 +524,7 @@ get_cached_blob_contents_async (const gchar          *path,
       G_thread = g_thread_create (worker_thread, G_queue, FALSE, NULL);
 #endif
     }
-    
+
     g_async_queue_push (G_queue, job);
   }
 }
@@ -529,19 +534,19 @@ allocate_marker (ScintillaObject *sci,
                  guint            marker)
 {
   g_return_val_if_fail (marker < MARKER_COUNT, -1);
-  
+
   if (G_markers[marker].num == -1) {
     gint i;
-    
+
     G_markers[marker].num = -2;
     /* markers 0-1 and 25-31 are reserved */
     for (i = 2; G_markers[marker].num < 0 && i < 25; i++) {
       gint sym = scintilla_send_message (sci, SCI_MARKERSYMBOLDEFINED, i, 0);
-      
+
       if (sym == SC_MARK_AVAILABLE ||
           sym == 0 /* unfortunately it's also SC_MARK_CIRCLE */) {
         guint j;
-        
+
         /* check if we already allocate it but not defined it yet */
         for (j = 0; j < MARKER_COUNT && G_markers[j].num != i; j++) {
           /* nothing */
@@ -552,7 +557,7 @@ allocate_marker (ScintillaObject *sci,
       }
     }
   }
-  
+
   return G_markers[marker].num;
 }
 
@@ -560,21 +565,21 @@ static gboolean
 allocate_resources (ScintillaObject *sci)
 {
   guint i;
-  
+
   if (g_object_get_qdata (G_OBJECT (sci), RESOURCES_ALLOCATED_QTAG)) {
     return TRUE;
   }
-  
+
   /* allocate all markers first so we have all or nothing */
   for (i = 0; i < MARKER_COUNT; i++) {
     if (allocate_marker (sci, i) < 0) {
       return FALSE;
     }
   }
-  
+
   for (i = 0; i < MARKER_COUNT; i++) {
     scintilla_send_message (sci, SCI_MARKERDEFINE,
-                            G_markers[i].num, G_markers[i].style);    
+                            G_markers[i].num, G_markers[i].style);
     scintilla_send_message (sci, SCI_MARKERSETBACK,
                             G_markers[i].num,
                             /* Scintilla uses BGR */
@@ -582,15 +587,15 @@ allocate_resources (ScintillaObject *sci)
                             ((G_markers[i].color & 0x00ff00)) |
                             ((G_markers[i].color & 0x0000ff) << 16));
   }
-  
+
   /* setup tooltips */
   gtk_widget_set_has_tooltip (GTK_WIDGET (sci), TRUE);
   g_signal_connect (sci, "query-tooltip",
                     G_CALLBACK (on_sci_query_tooltip), NULL);
-  
+
   g_object_set_qdata (G_OBJECT (sci), RESOURCES_ALLOCATED_QTAG,
                       sci /* anything non-NULL */);
-  
+
   return TRUE;
 }
 
@@ -599,7 +604,7 @@ release_resources (ScintillaObject *sci)
 {
   if (g_object_get_qdata (G_OBJECT (sci), RESOURCES_ALLOCATED_QTAG)) {
     guint j;
-    
+
     for (j = 0; j < MARKER_COUNT; j++) {
       if (G_markers[j].num >= 0) {
         scintilla_send_message (sci, SCI_MARKERDEFINE,
@@ -629,15 +634,15 @@ encoding_needs_conversion (const gchar *encoding)
  * @param from Source encoding
  * @param error Return location for errors, or @c NULL
  * @returns @c TRUE if @p buffer should be freed, or @c FALSE otherwise.
- * 
+ *
  * @warning This function has a very weird API, but it is practical for
  *          how it's used.
  * @note the only way to tell if the conversion succeeded when @p free_buffer
  *       is @c TRUE is to compare the output value of @buffer against the
  *       one it had as an input value.
- * 
+ *
  * Converts between encodings (using g_convert()) in-place.
- * 
+ *
  * The @p buffer is both an input and output parameter.  As an input
  * parameter, it is used as a constant buffer pointer and is never
  * modified nor freed.  As an output parameter, it is an allocated chunk
@@ -658,17 +663,17 @@ convert_encoding_inplace (gchar       **buffer,
   gsize   tmp_len;
   gchar  *tmp_buf = g_convert (*buffer, (gssize) *length, to, from,
                                NULL, &tmp_len, error);
-  
+
   if (tmp_buf) {
     if (free_buffer) {
       g_free (*buffer);
     }
-    
+
     *buffer = tmp_buf;
     *length = tmp_len;
     free_buffer = TRUE;
   }
-  
+
   return free_buffer;
 }
 
@@ -678,19 +683,19 @@ add_utf8_bom (gchar   **buffer,
               gboolean  free_buffer)
 {
   gchar *new_buf = g_malloc (*length + 3);
-  
+
   new_buf[0] = (gchar) 0xef;
   new_buf[1] = (gchar) 0xbb;
   new_buf[2] = (gchar) 0xbf;
   memcpy (&new_buf[3], *buffer, *length);
-  
+
   if (free_buffer) {
     g_free (*buffer);
   }
-  
+
   *buffer = new_buf;
   *length += 3;
-  
+
   return TRUE;
 }
 
@@ -706,10 +711,10 @@ diff_buf_to_doc (const git_buf   *old_buf,
   size_t            len;
   gboolean          free_buf = FALSE;
   int               ret;
-  
+
   buf = (gchar *) scintilla_send_message (sci, SCI_GETCHARACTERPOINTER, 0, 0);
   len = sci_get_length (sci);
-  
+
   /* add the BOM if needed */
   if (doc->has_bom) {
     /* UTF-8 BOM, converted below */
@@ -720,19 +725,19 @@ diff_buf_to_doc (const git_buf   *old_buf,
     free_buf = convert_encoding_inplace (&buf, &len, free_buf,
                                          doc->encoding, "UTF-8", NULL);
   }
-  
+
   /* no context lines, and no need to bother about binary checks */
   opts.context_lines = 0;
   opts.flags = GIT_DIFF_FORCE_TEXT;
-  
+
   ret = git_diff_buffers (old_buf->ptr, old_buf->size, NULL,
                           buf, len, NULL, &opts, NULL, NULL, hunk_cb, NULL,
                           payload);
-  
+
   if (free_buf) {
     g_free (buf);
   }
-  
+
   return ret;
 }
 
@@ -743,10 +748,10 @@ diff_hunk_cb (const git_diff_delta *delta,
 {
   ScintillaObject *sci = data;
   gint line;
-  
+
   if (hunk->new_lines > 0) {
     guint marker = hunk->old_lines > 0 ? MARKER_LINE_CHANGED : MARKER_LINE_ADDED;
-    
+
     for (line = hunk->new_start; line < hunk->new_start + hunk->new_lines; line++) {
       scintilla_send_message (sci, SCI_MARKERADD, line - 1, G_markers[marker].num);
     }
@@ -755,7 +760,7 @@ diff_hunk_cb (const git_diff_delta *delta,
     scintilla_send_message (sci, SCI_MARKERADD, line,
                             G_markers[MARKER_LINE_REMOVED].num);
   }
-  
+
   return 0;
 }
 
@@ -775,9 +780,9 @@ get_widget_for_buf_range (GeanyDocument *doc,
   gchar                  *buf       = contents->ptr;
   gsize                   buf_len   = contents->size;
   gboolean                free_buf  = FALSE;
-  
+
   gtk_widget_get_allocation (GTK_WIDGET (doc->editor->sci), &alloc);
-  
+
   highlighting_set_styles (sci, doc->file_type);
   if (iprefs->type == GEANY_INDENT_TYPE_BOTH) {
     scintilla_send_message (sci, SCI_SETTABWIDTH, iprefs->hard_tab_width, 0);
@@ -787,40 +792,40 @@ get_widget_for_buf_range (GeanyDocument *doc,
   scintilla_send_message (sci, SCI_SETINDENT, iprefs->width, 0);
   zoom = scintilla_send_message (doc->editor->sci, SCI_GETZOOM, 0, 0);
   scintilla_send_message (sci, SCI_SETZOOM, zoom, 0);
-  
+
   /* hide stuff we don't wanna see */
   scintilla_send_message (sci, SCI_SETHSCROLLBAR, 0, 0);
   scintilla_send_message (sci, SCI_SETVSCROLLBAR, 0, 0);
   for (i = 0; i < SC_MAX_MARGIN; i++) {
     scintilla_send_message (sci, SCI_SETMARGINWIDTHN, i, 0);
   }
-  
+
   /* convert the buffer to UTF-8 if necessary */
   if (encoding_needs_conversion (doc->encoding)) {
     free_buf = convert_encoding_inplace (&buf, &buf_len, free_buf,
                                          "UTF-8", doc->encoding, NULL);
   }
-  
+
   scintilla_send_message (sci, SCI_ADDTEXT, buf_len, (sptr_t) buf);
-  
+
   if (free_buf) {
     g_free (buf);
   }
-  
+
   /* we need to enable extra scroll after last line so that SETFIRSTVISIBLELINE
    * really places the line we want on top of the view, even if the line is
    * close to the end and wouldn't possibly end on top otherwise */
   scintilla_send_message (sci, SCI_SETENDATLASTLINE, 0, 0);
   scintilla_send_message (sci, SCI_SETFIRSTVISIBLELINE, line_start, 0);
-  
+
   /* compute the size of the area we want to see */
   for (i = line_start; i < line_start + n_lines; i++) {
     gint pos    = sci_get_line_end_position (sci, i);
     gint end_x  = scintilla_send_message (sci, SCI_POINTXFROMPOSITION, 0, pos);
-    
+
     height += scintilla_send_message (sci, SCI_TEXTHEIGHT, i, 0);
     width = MAX (width, end_x);
-    
+
     if (height > alloc.height) {
       break;
     }
@@ -831,7 +836,7 @@ get_widget_for_buf_range (GeanyDocument *doc,
   gtk_widget_set_size_request (GTK_WIDGET (sci),
                                MIN (width + 2, alloc.width),
                                MIN (height + 1, alloc.height));
-  
+
   return GTK_WIDGET (sci);
 }
 
@@ -847,11 +852,11 @@ tooltip_diff_hunk_cb (const git_diff_delta *delta,
                       void                 *data)
 {
   TooltipHunkData *thd = data;
-  
+
   if (thd->found) {
     return 1;
   }
-  
+
   if (hunk->old_lines > 0 &&
       (is_first_line_removed (thd->line, hunk->new_start, hunk->new_lines) ||
        (thd->line >= hunk->new_start &&
@@ -859,11 +864,11 @@ tooltip_diff_hunk_cb (const git_diff_delta *delta,
     GtkWidget *old = get_widget_for_buf_range (thd->doc, thd->buf,
                                                hunk->old_start - 1,
                                                hunk->old_lines);
-    
+
     gtk_tooltip_set_custom (thd->tooltip, old);
     thd->found = old != NULL;
   }
-  
+
   return thd->found;
 }
 
@@ -880,32 +885,32 @@ on_sci_query_tooltip (GtkWidget  *widget,
   ScintillaObject  *sci         = (ScintillaObject *) widget;
   GeanyDocument    *doc         = document_get_current ();
   gboolean          has_tooltip = FALSE;
-  
+
   /* for some reason the widget isn't the current one during tab switch, so
    * give up silently when we receive a query for a non-current widget */
   if (! doc || doc->editor->sci != sci) {
     return FALSE;
   }
-  
+
   min_x = scintilla_send_message (sci, SCI_GETMARGINWIDTHN, 0, 0);
   max_x = min_x + scintilla_send_message (sci, SCI_GETMARGINWIDTHN, 1, 0);
-  
+
   if (x >= min_x && x <= max_x &&
       G_blob_contents.ptr && G_blob_contents_tag == doc->id) {
     gint pos  = scintilla_send_message (sci, SCI_POSITIONFROMPOINT, x, y);
     gint line = sci_get_line_from_position (sci, pos);
     gint mask = scintilla_send_message (sci, SCI_MARKERGET, line, 0);
-    
+
     if (mask & ((1 << G_markers[MARKER_LINE_CHANGED].num) |
                 (1 << G_markers[MARKER_LINE_REMOVED].num))) {
       TooltipHunkData thd = TOOLTIP_HUNK_DATA_INIT (line + 1, doc,
                                                     &G_blob_contents, tooltip);
-      
+
       diff_buf_to_doc (&G_blob_contents, doc, tooltip_diff_hunk_cb, &thd);
       has_tooltip = thd.found;
     }
   }
-  
+
   return has_tooltip;
 }
 
@@ -915,23 +920,23 @@ update_diff (const gchar *path,
              gpointer     data)
 {
   GeanyDocument *doc = document_get_current ();
-  
+
   if (doc && doc->id == GPOINTER_TO_UINT (data)) {
     ScintillaObject  *sci = doc->editor->sci;
     gboolean    allocated = !! g_object_get_qdata (G_OBJECT (sci),
                                                    RESOURCES_ALLOCATED_QTAG);
-    
+
     if (allocated) {
       guint i;
-      
+
       /* clear previous markers */
       for (i = 0; i < MARKER_COUNT; i++) {
         scintilla_send_message (sci, SCI_MARKERDELETEALL, G_markers[i].num, 0);
       }
     }
-    
+
     gtk_widget_set_visible (G_undo_menu_item, contents != NULL);
-    
+
     if (contents && (allocated || allocate_resources (sci))) {
       diff_buf_to_doc (contents, doc, diff_hunk_cb, sci);
     } else if (! contents && allocated) {
@@ -949,14 +954,14 @@ do_update_diff_idle (guint    doc_id,
                      gboolean force)
 {
   GeanyDocument *doc = document_get_current ();
-  
+
   G_source_id = 0;
   /* make sure the document is still valid and current */
   if (doc && doc->id == doc_id) {
     get_cached_blob_contents_async (doc->real_path, doc_id, force, update_diff,
                                     GUINT_TO_POINTER (doc->id));
   }
-  
+
   return FALSE;
 }
 
@@ -978,10 +983,10 @@ update_diff_force_idle (gpointer id)
  * @param force Whether to force reloading the repository information.  This
  *              is used to e.g. force re-setting up monitors after a repository
  *              change.
- * 
+ *
  * Pushes a request for updating the diff.  Typically this should be called
  * after the user modified the buffer to keep the diff in sync.
- * 
+ *
  * Pass @c TRUE to @p force if the repository might have changed in a way that
  * requires reloading it.  Note that generally you don't need to do so when the
  * file might have changed in the repository (e.g. when the user checked out
@@ -993,9 +998,9 @@ update_diff_push (GeanyDocument  *doc,
                   gboolean        force)
 {
   g_return_if_fail (DOC_VALID (doc));
-  
+
   gtk_widget_hide (G_undo_menu_item);
-  
+
   if (G_source_id) {
     g_source_remove (G_source_id);
     G_source_id = 0;
@@ -1019,7 +1024,7 @@ on_editor_notify (GObject        *obj,
        nt->modificationType & (SC_MOD_INSERTTEXT | SC_MOD_DELETETEXT))) {
     update_diff_push (editor->document, FALSE);
   }
-  
+
   return FALSE;
 }
 
@@ -1037,7 +1042,7 @@ on_startup_complete (GObject *obj,
                      gpointer user_data)
 {
   GeanyDocument *doc = document_get_current ();
-  
+
   if (doc) {
     update_diff_push (doc, FALSE);
   }
@@ -1051,7 +1056,7 @@ on_git_repo_changed (GFileMonitor     *monitor,
                      gpointer          force)
 {
   GeanyDocument *doc = document_get_current ();
-  
+
   if (doc) {
     clear_cached_blob_contents ();
     update_diff_push (doc, GPOINTER_TO_INT (force));
@@ -1064,7 +1069,7 @@ goto_next_hunk_diff_hunk_cb (const git_diff_delta *delta,
                              void                 *udata)
 {
   GotoNextHunkData *data = udata;
-  
+
   switch (data->kb) {
     case KB_GOTO_NEXT_HUNK:
       if (data->next_line >= 0) {
@@ -1073,14 +1078,14 @@ goto_next_hunk_diff_hunk_cb (const git_diff_delta *delta,
         data->next_line = REMOVED_MARKER_POS (hunk->new_start);
       }
       break;
-    
+
     case KB_GOTO_PREV_HUNK:
       if (data->line > hunk->new_start - 1 + MAX (hunk->new_lines - 1, 0)) {
         data->next_line = REMOVED_MARKER_POS (hunk->new_start);
       }
       break;
   }
-  
+
   return 0;
 }
 
@@ -1091,17 +1096,17 @@ goto_next_hunk_cb (const gchar *path,
 {
   GotoNextHunkData *data  = udata;
   GeanyDocument    *doc   = document_get_current ();
-  
+
   if (doc && doc->id == data->doc_id && contents) {
     diff_buf_to_doc (contents, doc, goto_next_hunk_diff_hunk_cb, data);
-    
+
     if (data->next_line >= 0) {
       gint pos = sci_get_position_from_line (doc->editor->sci, data->next_line);
-      
+
       editor_goto_pos (doc->editor, pos, FALSE);
     }
   }
-  
+
   g_slice_free1 (sizeof *data, data);
 }
 
@@ -1109,15 +1114,15 @@ static void
 on_kb_goto_next_hunk (guint kb)
 {
   GeanyDocument *doc = document_get_current ();
-  
+
   if (doc) {
     GotoNextHunkData *data = g_slice_alloc (sizeof *data);
-  
+
     data->kb        = kb;
     data->doc_id    = doc->id;
     data->line      = sci_get_current_line (doc->editor->sci);
     data->next_line = -1;
-    
+
     get_cached_blob_contents_async (doc->real_path, doc->id, FALSE,
                                     goto_next_hunk_cb, data);
   }
@@ -1137,13 +1142,13 @@ insert_buf_range (GeanyDocument *doc,
   gint             old_pos_start;
   gint             old_pos_end;
   gchar           *old_range;
-  
+
   /* convert the buffer to UTF-8 if necessary */
   if (encoding_needs_conversion (doc->encoding)) {
     free_buf = convert_encoding_inplace (&old_buf, &old_buf_len, free_buf,
                                          "UTF-8", doc->encoding, NULL);
   }
-  
+
   scintilla_send_message (old_sci, SCI_ADDTEXT, old_buf_len, (sptr_t) old_buf);
 
   old_pos_start = sci_get_position_from_line (old_sci, old_start);
@@ -1153,7 +1158,7 @@ insert_buf_range (GeanyDocument *doc,
   sci_insert_text (doc->editor->sci, pos, old_range);
 
   g_free (old_range);
-  
+
   if (free_buf) {
     g_free (old_buf);
   }
@@ -1168,7 +1173,7 @@ undo_hunk_diff_hunk_cb (const git_diff_delta *delta,
                         void                 *udata)
 {
   UndoHunkData *data = udata;
-  
+
   if (is_first_line_removed (data->line, hunk->new_start, hunk->new_lines) ||
       (data->line >= hunk->new_start &&
        data->line < hunk->new_start + MAX (1, hunk->new_lines))) {
@@ -1179,7 +1184,7 @@ undo_hunk_diff_hunk_cb (const git_diff_delta *delta,
     data->found = TRUE;
     return 1;
   }
-  
+
   return 0;
 }
 
@@ -1190,7 +1195,7 @@ undo_hunk_cb (const gchar *path,
 {
   UndoHunkData  *data = udata;
   GeanyDocument *doc  = document_get_current ();
-  
+
   if (doc && doc->id == data->doc_id && contents) {
     diff_buf_to_doc (contents, doc, undo_hunk_diff_hunk_cb, data);
 
@@ -1225,7 +1230,7 @@ undo_hunk_cb (const gchar *path,
       sci_end_undo_action (sci);
     }
   }
-  
+
   g_slice_free1 (sizeof *data, data);
 }
 
@@ -1238,7 +1243,7 @@ undo_hunk (GeanyDocument *doc,
   data->doc_id = doc->id;
   data->line   = line + 1;
   data->found  = FALSE;
-  
+
   get_cached_blob_contents_async (doc->real_path, doc->id, FALSE,
                                   undo_hunk_cb, data);
 }
@@ -1247,7 +1252,7 @@ static void
 on_kb_undo_hunk (guint kb)
 {
   GeanyDocument *doc = document_get_current ();
-  
+
   if (doc) {
     undo_hunk (doc, sci_get_current_line (doc->editor->sci));
   }
@@ -1259,11 +1264,11 @@ on_undo_hunk_activate (GtkWidget *widget,
 {
   GeanyDocument  *doc     = document_get_current ();
   gpointer        doc_id  = g_object_get_qdata (G_OBJECT (widget), DOC_ID_QTAG);
-  
+
   if (doc && doc->id == GPOINTER_TO_UINT (doc_id) &&
       gtk_widget_get_sensitive (widget)) {
     gpointer line = g_object_get_qdata (G_OBJECT (widget), UNDO_LINE_QTAG);
-    
+
     undo_hunk (doc, GPOINTER_TO_INT (line));
   }
 }
@@ -1275,7 +1280,7 @@ check_undo_hunk_cb (const gchar *path,
 {
   UndoHunkData  *data = udata;
   GeanyDocument *doc  = document_get_current ();
-  
+
   if (doc && doc->id == data->doc_id && contents) {
     diff_buf_to_doc (contents, doc, undo_hunk_diff_hunk_cb, data);
     if (data->found) {
@@ -1286,7 +1291,7 @@ check_undo_hunk_cb (const gchar *path,
                           GUINT_TO_POINTER (data->doc_id));
     }
   }
-  
+
   g_slice_free1 (sizeof *data, data);
 }
 
@@ -1298,14 +1303,14 @@ on_update_editor_menu (GObject       *object,
                        gpointer       user_data)
 {
   gtk_widget_set_sensitive (G_undo_menu_item, FALSE);
-  
+
   if (doc) {
     UndoHunkData *data = g_slice_alloc (sizeof *data);
-  
+
     data->doc_id = doc->id;
     data->line   = sci_get_line_from_position (doc->editor->sci, pos) + 1;
     data->found  = FALSE;
-    
+
     get_cached_blob_contents_async (doc->real_path, doc->id, FALSE,
                                     check_undo_hunk_cb, data);
   }
@@ -1321,16 +1326,16 @@ read_setting_color (GKeyFile     *kf,
 {
   guint32  *color = value;
   gchar    *kfval = g_key_file_get_value (kf, group, key, NULL);
-  
+
   if (kfval) {
     const gchar  *nptr = kfval;
     gchar        *endptr;
     glong         val;
-    
+
     if (*nptr == '#') {
       nptr++;
     }
-    
+
     val = strtol (nptr, &endptr, 16);
     if (! *endptr && val >= 0 && val <= 0xffffff) {
       *color = (guint32) val;
@@ -1347,9 +1352,9 @@ write_setting_color (GKeyFile      *kf,
 {
   const guint32  *color     = value;
   gchar           kfval[8]  = {0};
-  
+
   g_return_if_fail (*color <= 0xffffff);
-  
+
   g_snprintf (kfval, sizeof kfval, "#%.6x", *color);
   g_key_file_set_value (kf, group, key, kfval);
 }
@@ -1361,7 +1366,7 @@ read_setting_boolean (GKeyFile     *kf,
                       gpointer      value)
 {
   gboolean *bool = value;
-  
+
   *bool = utils_get_setting_boolean (kf, group, key, *bool);
 }
 
@@ -1372,7 +1377,7 @@ write_setting_boolean (GKeyFile      *kf,
                        gconstpointer  value)
 {
   const gboolean *bool = value;
-  
+
   g_key_file_set_boolean (kf, group, key, *bool);
 }
 
@@ -1384,16 +1389,16 @@ read_keyfile (GKeyFile     *kf,
               GKeyFileFlags flags)
 {
   GError *error = NULL;
-  
+
   if (! g_key_file_load_from_file (kf, filename, flags, &error)) {
     if (error->domain != G_FILE_ERROR || error->code != G_FILE_ERROR_NOENT) {
       g_warning (_("Failed to load configuration file: %s"), error->message);
     }
     g_error_free (error);
-    
+
     return FALSE;
   }
-  
+
   return TRUE;
 }
 
@@ -1409,7 +1414,7 @@ write_keyfile (GKeyFile    *kf,
   gchar    *data;
   gsize     length;
   gboolean  success = FALSE;
-  
+
   data = g_key_file_to_data (kf, &length, NULL);
   if ((err = utils_mkdir (dirname, TRUE)) != 0) {
     g_warning (_("Failed to create configuration directory \"%s\": %s"),
@@ -1422,7 +1427,7 @@ write_keyfile (GKeyFile    *kf,
   }
   g_free (data);
   g_free (dirname);
-  
+
   return success;
 }
 
@@ -1438,10 +1443,10 @@ load_config (void)
 {
   gchar    *filename  = get_config_filename ();
   GKeyFile *kf        = g_key_file_new ();
-  
+
   if (read_keyfile (kf, filename, G_KEY_FILE_NONE)) {
     guint i;
-    
+
     for (i = 0; i < G_N_ELEMENTS (G_settings_desc); i++) {
       G_settings_desc[i].read (kf, G_settings_desc[i].group,
                                G_settings_desc[i].key,
@@ -1458,7 +1463,7 @@ save_config (void)
   gchar    *filename  = get_config_filename ();
   GKeyFile *kf        = g_key_file_new ();
   guint     i;
-  
+
   read_keyfile (kf, filename, G_KEY_FILE_KEEP_COMMENTS);
   for (i = 0; i < G_N_ELEMENTS (G_settings_desc); i++) {
     G_settings_desc[i].write (kf, G_settings_desc[i].group,
@@ -1466,7 +1471,7 @@ save_config (void)
                               G_settings_desc[i].value);
   }
   write_keyfile (kf, filename);
-  
+
   g_key_file_free (kf);
   g_free (filename);
 }
@@ -1477,27 +1482,27 @@ void
 plugin_init (GeanyData *data)
 {
   GeanyKeyGroup *kb_group;
-  
+
   buf_zero (&G_blob_contents);
   G_blob_contents_tag = 0;
   G_source_id         = 0;
   G_thread            = NULL;
   G_queue             = NULL;
-  
+
   if (git_libgit2_init () < 0) {
     const git_error *err = git_error_last ();
     g_warning ("Failed to initialize libgit2: %s", err ? err->message : "?");
     return;
   }
-  
+
   load_config ();
-  
+
   G_undo_menu_item = gtk_menu_item_new_with_label (_("Undo Git hunk"));
   g_signal_connect (G_undo_menu_item, "activate",
                     G_CALLBACK (on_undo_hunk_activate), NULL);
   gtk_container_add (GTK_CONTAINER (data->main_widgets->editor_menu),
                      G_undo_menu_item);
-  
+
   kb_group = plugin_set_key_group (geany_plugin, PLUGIN, KB_COUNT, NULL);
   keybindings_set_item (kb_group, KB_GOTO_PREV_HUNK, on_kb_goto_next_hunk, 0, 0,
                         "goto-prev-hunk", _("Go to the previous hunk"), NULL);
@@ -1506,7 +1511,7 @@ plugin_init (GeanyData *data)
   keybindings_set_item (kb_group, KB_UNDO_HUNK, on_kb_undo_hunk, 0, 0,
                         "undo-hunk", _("Undo hunk at the cursor position"),
                         G_undo_menu_item);
-  
+
   plugin_signal_connect (geany_plugin, NULL, "editor-notify", TRUE,
                          G_CALLBACK (on_editor_notify), NULL);
   plugin_signal_connect (geany_plugin, NULL, "update-editor-menu", TRUE,
@@ -1519,7 +1524,7 @@ plugin_init (GeanyData *data)
                          G_CALLBACK (on_document_activate), NULL);
   plugin_signal_connect (geany_plugin, NULL, "geany-startup-complete", TRUE,
                          G_CALLBACK (on_startup_complete), NULL);
-  
+
   if (main_is_realized ()) {
     /* update for the current document as we are loaded in the middle of a
      * session and so won't receive the :geany-startup-complete signal */
@@ -1531,9 +1536,9 @@ void
 plugin_cleanup (void)
 {
   guint i = 0;
-  
+
   gtk_widget_destroy (G_undo_menu_item);
-  
+
   if (G_source_id) {
     g_source_remove (G_source_id);
     G_source_id = 0;
@@ -1546,13 +1551,13 @@ plugin_cleanup (void)
     G_queue = NULL;
   }
   clear_cached_blob_contents ();
-  
+
   foreach_document (i) {
     release_resources (documents[i]->editor->sci);
   }
-  
+
   save_config ();
-  
+
   git_libgit2_shutdown ();
 }
 
@@ -1601,7 +1606,7 @@ on_plugin_configure_response (GtkDialog        *dialog,
       guint           i = 0;
       GdkColor        color;
       GeanyDocument  *doc = document_get_current ();
-      
+
       G_monitoring_enabled = gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (cw->monitoring_check));
       gtk_color_button_get_color (GTK_COLOR_BUTTON (cw->added_color_button),
                                   &color);
@@ -1612,7 +1617,7 @@ on_plugin_configure_response (GtkDialog        *dialog,
       gtk_color_button_get_color (GTK_COLOR_BUTTON (cw->removed_color_button),
                                   &color);
       G_markers[MARKER_LINE_REMOVED].color = color_to_int (&color);
-      
+
       /* update everything */
       foreach_document (i) {
         release_resources (documents[i]->editor->sci);
@@ -1634,7 +1639,7 @@ get_data_dir_path (const gchar *filename)
   prefix = g_win32_get_package_installation_directory_of_module (NULL);
 #elif defined(__APPLE__)
   if (g_getenv ("GEANY_PLUGINS_SHARE_PATH"))
-    return g_build_filename (g_getenv ("GEANY_PLUGINS_SHARE_PATH"), 
+    return g_build_filename (g_getenv ("GEANY_PLUGINS_SHARE_PATH"),
                              PLUGIN, filename, NULL);
 #endif
   path = g_build_filename (prefix ? prefix : "", PLUGINDATADIR, filename, NULL);
@@ -1649,7 +1654,7 @@ plugin_configure (GtkDialog *dialog)
   GtkWidget  *base    = NULL;
   GtkBuilder *builder = gtk_builder_new ();
   gchar      *path    = get_data_dir_path ("prefs.ui");
-  
+
   gtk_builder_set_translation_domain (builder, GETTEXT_PACKAGE);
   if (! gtk_builder_add_from_file (builder, path, &error)) {
     g_critical (_("Failed to load UI definition, please check your "
@@ -1669,11 +1674,11 @@ plugin_configure (GtkDialog *dialog)
       { "removed-color-button", &cw->removed_color_button },
     };
     guint i;
-    
+
     for (i = 0; i < G_N_ELEMENTS (map); i++) {
       *map[i].ptr = GTK_WIDGET (gtk_builder_get_object (builder, map[i].name));
     }
-    
+
     gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (cw->monitoring_check),
                                   G_monitoring_enabled);
     color_from_int (&color, G_markers[MARKER_LINE_ADDED].color);
@@ -1685,16 +1690,16 @@ plugin_configure (GtkDialog *dialog)
     color_from_int (&color, G_markers[MARKER_LINE_REMOVED].color);
     gtk_color_button_set_color (GTK_COLOR_BUTTON (cw->removed_color_button),
                                 &color);
-    
+
     base = g_object_ref_sink (cw->base);
-    
+
     g_signal_connect_data (dialog, "response",
                            G_CALLBACK (on_plugin_configure_response),
                            cw, (GClosureNotify) configure_widgets_free, 0);
   }
-  
+
   g_free (path);
   g_object_unref (builder);
-  
+
   return base;
 }
