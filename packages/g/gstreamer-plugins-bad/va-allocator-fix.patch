From 9bcacb5ba47ba0632a6cc1b50de4f2bbb0ee7319 Mon Sep 17 00:00:00 2001
From: Nicolas Dufresne <nicolas.dufresne@collabora.com>
Date: Wed, 8 Jun 2022 09:02:52 -0400
Subject: [PATCH 1/2] va: allocator: Fix translation of
 VADRMPRIMESurfaceDescriptor

VADRMPRIMESurfaceDescriptor structure describes the offsets from the
point of view of the specific handle (DMABuf). While GstVideoInfo
(and the meta) describes offsets from the point of the view of the
GstBuffer, an aggregate of all the GstMemory (1 per handle).

This changes combined with [Mesa Fix](https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/16813)
fixes decoding failure with AMD driver.

Fixes #1223

Part-of: <https://gitlab.freedesktop.org/gstreamer/gstreamer/-/merge_requests/2657>
---
 subprojects/gst-plugins-bad/sys/va/gstvaallocator.c | 12 +++++++++---
 1 file changed, 9 insertions(+), 3 deletions(-)

Index: gst-plugins-bad-1.20.3/sys/va/gstvaallocator.c
===================================================================
--- gst-plugins-bad-1.20.3.orig/sys/va/gstvaallocator.c
+++ gst-plugins-bad-1.20.3/sys/va/gstvaallocator.c
@@ -513,6 +513,7 @@ gst_va_dmabuf_allocator_setup_buffer_ful
   VASurfaceID surface;
   guint32 i, fourcc, rt_format, export_flags;
   GDestroyNotify buffer_destroy = NULL;
+  gsize object_offset[4];
 
   g_return_val_if_fail (GST_IS_VA_DMABUF_ALLOCATOR (allocator), FALSE);
 
@@ -588,11 +589,19 @@ gst_va_dmabuf_allocator_setup_buffer_ful
 
   for (i = 0; i < desc.num_objects; i++) {
     gint fd = desc.objects[i].fd;
-    gsize size = desc.objects[i].size > 0 ?
-        desc.objects[i].size : _get_fd_size (fd);
+    /* don't rely on prime descriptor reported size since gallium drivers report
+     * different values */
+    gsize size = _get_fd_size (fd);
     GstMemory *mem = gst_dmabuf_allocator_alloc (allocator, fd, size);
     guint64 *drm_mod = g_new (guint64, 1);
 
+    if (size != desc.objects[i].size) {
+      GST_WARNING_OBJECT (self, "driver bug: fd size (%" G_GSIZE_FORMAT
+          ") differs from object descriptor size (%" G_GUINT32_FORMAT ")",
+          size, desc.objects[i].size);
+    }
+
+    object_offset[i] = gst_buffer_get_size (buffer);
     gst_buffer_append_memory (buffer, mem);
     buf->mems[i] = mem;
 
@@ -615,18 +624,22 @@ gst_va_dmabuf_allocator_setup_buffer_ful
         drm_mod, g_free);
 
     if (G_UNLIKELY (info))
-      GST_VIDEO_INFO_SIZE (info) += size;
+      GST_VIDEO_INFO_PLANE_OFFSET (info, i) = GST_VIDEO_INFO_SIZE (info);
 
     GST_LOG_OBJECT (self, "buffer %p: new dmabuf %d / surface %#x [%dx%d] "
         "size %" G_GSIZE_FORMAT " drm mod %#lx", buffer, fd, surface,
         GST_VIDEO_INFO_WIDTH (&self->info), GST_VIDEO_INFO_HEIGHT (&self->info),
-        GST_VIDEO_INFO_SIZE (&self->info), *drm_mod);
+        size, *drm_mod);
   }
 
   if (G_UNLIKELY (info)) {
+    GST_VIDEO_INFO_SIZE (info) = gst_buffer_get_size (buffer);
+
     for (i = 0; i < desc.num_layers; i++) {
       g_assert (desc.layers[i].num_planes == 1);
-      GST_VIDEO_INFO_PLANE_OFFSET (info, i) = desc.layers[i].offset[0];
+      GST_VIDEO_INFO_PLANE_OFFSET (info, i) =
+          object_offset[desc.layers[i].object_index[0]] +
+          desc.layers[i].offset[0];
       GST_VIDEO_INFO_PLANE_STRIDE (info, i) = desc.layers[i].pitch[0];
     }
   } else {
