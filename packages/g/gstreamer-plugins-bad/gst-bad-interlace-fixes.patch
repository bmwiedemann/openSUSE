From 9fb5c5f466fb707931bf783d9518c661c53f334e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Sebastian=20Dr=C3=B6ge?= <sebastian@centricular.com>
Date: Tue, 3 Dec 2019 15:35:57 +0200
Subject: [PATCH] interlace: Increment phase_index before checking if we're at
 the end of the phase

Incrementing it afterwards will always have to phase_index >= 1 and we
will never be at the beginning (0) of the phase again, and thus never
reset timestamp tracking accordingly.

This was broken in bea13ef43b719aad96e28766cd4d23652a891a20 in 2010, and
causes interlace to run into integer overflows after 2^31 frames or
about 5 hours at 29.97fps. Due to usage of wrong types for the integers
this then causes negative numbers to be used in calculations and all
calculations spectacularly fail, leading to all following buffers to
have the timestamp of the first buffer minus one nanosecond.
---
 gst/interlace/gstinterlace.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/gst/interlace/gstinterlace.c b/gst/interlace/gstinterlace.c
index e0ff1aa4b..8121eec01 100644
--- a/gst/interlace/gstinterlace.c
+++ b/gst/interlace/gstinterlace.c
@@ -899,13 +899,13 @@ gst_interlace_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
     interlace->fields_since_timebase = 0;
   }
 
+  current_fields = format->n_fields[interlace->phase_index];
+  /* increment the phase index */
+  interlace->phase_index++;
   if (!format->n_fields[interlace->phase_index]) {
     interlace->phase_index = 0;
   }
 
-  current_fields = format->n_fields[interlace->phase_index];
-  /* increment the phase index */
-  interlace->phase_index++;
   GST_DEBUG ("incoming buffer assigned %d fields", current_fields);
 
   num_fields = interlace->stored_fields + current_fields;
-- 
2.24.1


From 39a67657d7153662ed08eab6cb8da6d4e621f055 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Sebastian=20Dr=C3=B6ge?= <sebastian@centricular.com>
Date: Tue, 3 Dec 2019 15:45:26 +0200
Subject: [PATCH] interlace: Store unsigned integers in unsigned integer types

And add some assertions to guard against overflows and out of bounds
reads.
---
 gst/interlace/gstinterlace.c | 16 ++++++++++------
 1 file changed, 10 insertions(+), 6 deletions(-)

diff --git a/gst/interlace/gstinterlace.c b/gst/interlace/gstinterlace.c
index 8121eec01..39bcab99d 100644
--- a/gst/interlace/gstinterlace.c
+++ b/gst/interlace/gstinterlace.c
@@ -98,11 +98,11 @@ struct _GstInterlace
   int src_fps_d;
 
   GstBuffer *stored_frame;
-  gint stored_fields;
-  gint phase_index;
-  int field_index;              /* index of the next field to push, 0=top 1=bottom */
+  guint stored_fields;
+  guint phase_index;
+  guint field_index;            /* index of the next field to push, 0=top 1=bottom */
   GstClockTime timebase;
-  int fields_since_timebase;
+  guint fields_since_timebase;
   guint pattern_offset;         /* initial offset into the pattern */
   gboolean passthrough;
 };
@@ -849,7 +849,7 @@ gst_interlace_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
   GstInterlace *interlace = GST_INTERLACE (parent);
   GstFlowReturn ret = GST_FLOW_OK;
   gint num_fields = 0;
-  int current_fields;
+  guint current_fields;
   const PulldownFormat *format;
   GstClockTime timestamp;
 
@@ -902,6 +902,7 @@ gst_interlace_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
   current_fields = format->n_fields[interlace->phase_index];
   /* increment the phase index */
   interlace->phase_index++;
+  g_assert (interlace->phase_index < G_N_ELEMENTS (format->n_fields));
   if (!format->n_fields[interlace->phase_index]) {
     interlace->phase_index = 0;
   }
@@ -911,7 +912,7 @@ gst_interlace_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
   num_fields = interlace->stored_fields + current_fields;
   while (num_fields >= 2) {
     GstBuffer *output_buffer;
-    int n_output_fields;
+    guint n_output_fields;
     gboolean interlaced = FALSE;
 
     GST_DEBUG ("have %d fields, %d current, %d stored",
@@ -948,6 +949,9 @@ gst_interlace_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
 
     gst_interlace_decorate_buffer (interlace, output_buffer, n_output_fields,
         interlaced);
+    /* Guard against overflows here. If this ever happens, resetting the phase
+     * above would never happen because of some bugs */
+    g_assert (interlace->fields_since_timebase <= G_MAXUINT - n_output_fields);
     interlace->fields_since_timebase += n_output_fields;
     interlace->field_index ^= (n_output_fields & 1);
 
-- 
2.24.1

