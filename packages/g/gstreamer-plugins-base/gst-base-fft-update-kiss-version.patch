From 46544d7c41fecab52d870f35f27a479acd6fd61e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Sebastian=20Dr=C3=B6ge?= <sebastian@centricular.com>
Date: Fri, 27 Dec 2019 11:34:26 +0200
Subject: [PATCH] fft: Update our kiss fft version

This fixes thread-safety issues and various other minor issues. Our
previous version was about 13 years old.

Fixes https://gitlab.freedesktop.org/gstreamer/gst-plugins-base/issues/715
---
 gst-libs/gst/fft/_kiss_fft_guts_f32.h | 99 ++++++++++++++++++++++-----
 gst-libs/gst/fft/_kiss_fft_guts_f64.h | 99 ++++++++++++++++++++++-----
 gst-libs/gst/fft/_kiss_fft_guts_s16.h | 76 +++++++++++++++-----
 gst-libs/gst/fft/_kiss_fft_guts_s32.h | 77 +++++++++++++++------
 gst-libs/gst/fft/kiss_fft_f32.c       | 84 +++++++----------------
 gst-libs/gst/fft/kiss_fft_f32.h       | 20 ++++--
 gst-libs/gst/fft/kiss_fft_f64.c       | 88 ++++++++----------------
 gst-libs/gst/fft/kiss_fft_f64.h       | 20 ++++--
 gst-libs/gst/fft/kiss_fft_s16.c       | 84 +++++++----------------
 gst-libs/gst/fft/kiss_fft_s16.h       | 30 ++++----
 gst-libs/gst/fft/kiss_fft_s32.c       | 84 +++++++----------------
 gst-libs/gst/fft/kiss_fft_s32.h       | 30 ++++----
 gst-libs/gst/fft/kiss_fftr_f32.c      | 43 ++++--------
 gst-libs/gst/fft/kiss_fftr_f32.h      | 14 +++-
 gst-libs/gst/fft/kiss_fftr_f64.c      | 44 ++++--------
 gst-libs/gst/fft/kiss_fftr_f64.h      | 14 +++-
 gst-libs/gst/fft/kiss_fftr_s16.c      | 44 ++++--------
 gst-libs/gst/fft/kiss_fftr_s16.h      | 14 +++-
 gst-libs/gst/fft/kiss_fftr_s32.c      | 44 ++++--------
 gst-libs/gst/fft/kiss_fftr_s32.h      | 14 +++-
 gst-libs/gst/fft/kiss_version         |  3 +-
 21 files changed, 544 insertions(+), 481 deletions(-)

diff --git a/gst-libs/gst/fft/_kiss_fft_guts_f32.h b/gst-libs/gst/fft/_kiss_fft_guts_f32.h
index 78d2e2e81..c0cf744f9 100644
--- a/gst-libs/gst/fft/_kiss_fft_guts_f32.h
+++ b/gst-libs/gst/fft/_kiss_fft_guts_f32.h
@@ -1,18 +1,12 @@
 /*
-Copyright (c) 2003-2004, Mark Borgerding
-
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
-    * Neither the author nor the names of any contributors may be used to endorse or promote products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ *  Copyright (c) 2003-2010, Mark Borgerding. All rights reserved.
+ *  This file is part of KISS FFT - https://github.com/mborgerding/kissfft
+ *
+ *  SPDX-License-Identifier: BSD-3-Clause
+ *  See COPYING file for more information.
+ */
 
-/* kiss_fft.h
+/* kiss_fft_f32.h
    defines kiss_fft_f32_scalar as either short or a float type
    and defines
    typedef struct { kiss_fft_f32_scalar r; kiss_fft_f32_scalar i; }kiss_fft_f32_cpx; */
@@ -55,15 +49,58 @@ struct kiss_fft_f32_state{
    C_SUBFROM( res , a)  : res -= a
    C_ADDTO( res , a)    : res += a
  * */
+#ifdef FIXED_POINT
+#include <stdint.h>
+#if (FIXED_POINT==32)
+# define FRACBITS 31
+# define SAMPPROD int64_t
+#define SAMP_MAX INT32_MAX
+#define SAMP_MIN INT32_MIN
+#else
+# define FRACBITS 15
+# define SAMPPROD int32_t
+#define SAMP_MAX INT16_MAX
+#define SAMP_MIN INT16_MIN
+#endif
+
+#if defined(CHECK_OVERFLOW)
+#  define CHECK_OVERFLOW_OP(a,op,b)  \
+	if ( (SAMPPROD)(a) op (SAMPPROD)(b) > SAMP_MAX || (SAMPPROD)(a) op (SAMPPROD)(b) < SAMP_MIN ) { \
+		g_critical("overflow @ " __FILE__ "(%d): (%d " #op" %d) = %ld",__LINE__,(a),(b),(SAMPPROD)(a) op (SAMPPROD)(b) );  }
+#endif
+
+
+#   define smul(a,b) ( (SAMPPROD)(a)*(b) )
+#   define sround( x )  (kiss_fft_f32_scalar)( ( (x) + (1<<(FRACBITS-1)) ) >> FRACBITS )
 
-#define S_MUL(a,b) ( (a)*(b) )
+#   define S_MUL(a,b) sround( smul(a,b) )
+
+#   define C_MUL(m,a,b) \
+      do{ (m).r = sround( smul((a).r,(b).r) - smul((a).i,(b).i) ); \
+          (m).i = sround( smul((a).r,(b).i) + smul((a).i,(b).r) ); }while(0)
+
+#   define DIVSCALAR(x,k) \
+	(x) = sround( smul(  x, SAMP_MAX/k ) )
+
+#   define C_FIXDIV(c,div) \
+	do {    DIVSCALAR( (c).r , div);  \
+		DIVSCALAR( (c).i  , div); }while (0)
+
+#   define C_MULBYSCALAR( c, s ) \
+    do{ (c).r =  sround( smul( (c).r , s ) ) ;\
+        (c).i =  sround( smul( (c).i , s ) ) ; }while(0)
+
+#else  /* not FIXED_POINT*/
+
+#   define S_MUL(a,b) ( (a)*(b) )
 #define C_MUL(m,a,b) \
     do{ (m).r = (a).r*(b).r - (a).i*(b).i;\
         (m).i = (a).r*(b).i + (a).i*(b).r; }while(0)
-#define C_FIXDIV(c,div) /* NOOP */
-#define C_MULBYSCALAR( c, s ) \
+#   define C_FIXDIV(c,div) /* NOOP */
+#   define C_MULBYSCALAR( c, s ) \
     do{ (c).r *= (s);\
         (c).i *= (s); }while(0)
+#endif
 
 #ifndef CHECK_OVERFLOW_OP
 #  define CHECK_OVERFLOW_OP(a,op,b) /* noop */
@@ -96,9 +133,19 @@ struct kiss_fft_f32_state{
     }while(0)
 
 
-#define KISS_FFT_F32_COS(phase) (kiss_fft_f32_scalar) cos(phase)
-#define KISS_FFT_F32_SIN(phase) (kiss_fft_f32_scalar) sin(phase)
-#define HALF_OF(x) ((x)*.5)
+#ifdef FIXED_POINT
+#  define KISS_FFT_F32_COS(phase)  floor(.5+SAMP_MAX * cos (phase))
+#  define KISS_FFT_F32_SIN(phase)  floor(.5+SAMP_MAX * sin (phase))
+#  define HALF_OF(x) ((x)>>1)
+#elif defined(USE_SIMD)
+#  define KISS_FFT_F32_COS(phase) _mm_set1_ps( cos(phase) )
+#  define KISS_FFT_F32_SIN(phase) _mm_set1_ps( sin(phase) )
+#  define HALF_OF(x) ((x)*_mm_set1_ps(.5))
+#else
+#  define KISS_FFT_F32_COS(phase) (kiss_fft_f32_scalar) cos(phase)
+#  define KISS_FFT_F32_SIN(phase) (kiss_fft_f32_scalar) sin(phase)
+#  define HALF_OF(x) ((x)*.5)
+#endif
 
 #define  kf_cexp(x,phase) \
 	do{ \
@@ -110,3 +157,17 @@ struct kiss_fft_f32_state{
 /* a debugging function */
 #define pcpx(c)\
     fprintf(stderr,"%g + %gi\n",(double)((c)->r),(double)((c)->i) )
+
+
+#ifdef KISS_FFT_F32_USE_ALLOCA
+// define this to allow use of alloca instead of malloc for temporary buffers
+// Temporary buffers are used in two case: 
+// 1. FFT sizes that have "bad" factors. i.e. not 2,3 and 5
+// 2. "in-place" FFTs.  Notice the quotes, since kissfft does not really do an in-place transform.
+#include <alloca.h>
+#define  KISS_FFT_F32_TMP_ALLOC(nbytes) alloca(nbytes)
+#define  KISS_FFT_F32_TMP_FREE(ptr) 
+#else
+#define  KISS_FFT_F32_TMP_ALLOC(nbytes) KISS_FFT_F32_MALLOC(nbytes)
+#define  KISS_FFT_F32_TMP_FREE(ptr) KISS_FFT_F32_FREE(ptr)
+#endif
diff --git a/gst-libs/gst/fft/_kiss_fft_guts_f64.h b/gst-libs/gst/fft/_kiss_fft_guts_f64.h
index 4202716d8..f1b00fb9f 100644
--- a/gst-libs/gst/fft/_kiss_fft_guts_f64.h
+++ b/gst-libs/gst/fft/_kiss_fft_guts_f64.h
@@ -1,18 +1,12 @@
 /*
-Copyright (c) 2003-2004, Mark Borgerding
-
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
-    * Neither the author nor the names of any contributors may be used to endorse or promote products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ *  Copyright (c) 2003-2010, Mark Borgerding. All rights reserved.
+ *  This file is part of KISS FFT - https://github.com/mborgerding/kissfft
+ *
+ *  SPDX-License-Identifier: BSD-3-Clause
+ *  See COPYING file for more information.
+ */
 
-/* kiss_fft.h
+/* kiss_fft_f64.h
    defines kiss_fft_f64_scalar as either short or a float type
    and defines
    typedef struct { kiss_fft_f64_scalar r; kiss_fft_f64_scalar i; }kiss_fft_f64_cpx; */
@@ -55,15 +49,58 @@ struct kiss_fft_f64_state{
    C_SUBFROM( res , a)  : res -= a
    C_ADDTO( res , a)    : res += a
  * */
+#ifdef FIXED_POINT
+#include <stdint.h>
+#if (FIXED_POINT==32)
+# define FRACBITS 31
+# define SAMPPROD int64_t
+#define SAMP_MAX INT32_MAX
+#define SAMP_MIN INT32_MIN
+#else
+# define FRACBITS 15
+# define SAMPPROD int32_t
+#define SAMP_MAX INT16_MAX
+#define SAMP_MIN INT16_MIN
+#endif
+
+#if defined(CHECK_OVERFLOW)
+#  define CHECK_OVERFLOW_OP(a,op,b)  \
+	if ( (SAMPPROD)(a) op (SAMPPROD)(b) > SAMP_MAX || (SAMPPROD)(a) op (SAMPPROD)(b) < SAMP_MIN ) { \
+		g_critical("overflow @ " __FILE__ "(%d): (%d " #op" %d) = %ld",__LINE__,(a),(b),(SAMPPROD)(a) op (SAMPPROD)(b) );  }
+#endif
+
+
+#   define smul(a,b) ( (SAMPPROD)(a)*(b) )
+#   define sround( x )  (kiss_fft_f64_scalar)( ( (x) + (1<<(FRACBITS-1)) ) >> FRACBITS )
 
-#define S_MUL(a,b) ( (a)*(b) )
+#   define S_MUL(a,b) sround( smul(a,b) )
+
+#   define C_MUL(m,a,b) \
+      do{ (m).r = sround( smul((a).r,(b).r) - smul((a).i,(b).i) ); \
+          (m).i = sround( smul((a).r,(b).i) + smul((a).i,(b).r) ); }while(0)
+
+#   define DIVSCALAR(x,k) \
+	(x) = sround( smul(  x, SAMP_MAX/k ) )
+
+#   define C_FIXDIV(c,div) \
+	do {    DIVSCALAR( (c).r , div);  \
+		DIVSCALAR( (c).i  , div); }while (0)
+
+#   define C_MULBYSCALAR( c, s ) \
+    do{ (c).r =  sround( smul( (c).r , s ) ) ;\
+        (c).i =  sround( smul( (c).i , s ) ) ; }while(0)
+
+#else  /* not FIXED_POINT*/
+
+#   define S_MUL(a,b) ( (a)*(b) )
 #define C_MUL(m,a,b) \
     do{ (m).r = (a).r*(b).r - (a).i*(b).i;\
         (m).i = (a).r*(b).i + (a).i*(b).r; }while(0)
-#define C_FIXDIV(c,div) /* NOOP */
-#define C_MULBYSCALAR( c, s ) \
+#   define C_FIXDIV(c,div) /* NOOP */
+#   define C_MULBYSCALAR( c, s ) \
     do{ (c).r *= (s);\
         (c).i *= (s); }while(0)
+#endif
 
 #ifndef CHECK_OVERFLOW_OP
 #  define CHECK_OVERFLOW_OP(a,op,b) /* noop */
@@ -96,9 +133,19 @@ struct kiss_fft_f64_state{
     }while(0)
 
 
-#define KISS_FFT_F64_COS(phase) (kiss_fft_f64_scalar) cos(phase)
-#define KISS_FFT_F64_SIN(phase) (kiss_fft_f64_scalar) sin(phase)
-#define HALF_OF(x) ((x)*.5)
+#ifdef FIXED_POINT
+#  define KISS_FFT_F64_COS(phase)  floor(.5+SAMP_MAX * cos (phase))
+#  define KISS_FFT_F64_SIN(phase)  floor(.5+SAMP_MAX * sin (phase))
+#  define HALF_OF(x) ((x)>>1)
+#elif defined(USE_SIMD)
+#  define KISS_FFT_F64_COS(phase) _mm_set1_ps( cos(phase) )
+#  define KISS_FFT_F64_SIN(phase) _mm_set1_ps( sin(phase) )
+#  define HALF_OF(x) ((x)*_mm_set1_ps(.5))
+#else
+#  define KISS_FFT_F64_COS(phase) (kiss_fft_f64_scalar) cos(phase)
+#  define KISS_FFT_F64_SIN(phase) (kiss_fft_f64_scalar) sin(phase)
+#  define HALF_OF(x) ((x)*.5)
+#endif
 
 #define  kf_cexp(x,phase) \
 	do{ \
@@ -110,3 +157,17 @@ struct kiss_fft_f64_state{
 /* a debugging function */
 #define pcpx(c)\
     fprintf(stderr,"%g + %gi\n",(double)((c)->r),(double)((c)->i) )
+
+
+#ifdef KISS_FFT_F64_USE_ALLOCA
+// define this to allow use of alloca instead of malloc for temporary buffers
+// Temporary buffers are used in two case: 
+// 1. FFT sizes that have "bad" factors. i.e. not 2,3 and 5
+// 2. "in-place" FFTs.  Notice the quotes, since kissfft does not really do an in-place transform.
+#include <alloca.h>
+#define  KISS_FFT_F64_TMP_ALLOC(nbytes) alloca(nbytes)
+#define  KISS_FFT_F64_TMP_FREE(ptr) 
+#else
+#define  KISS_FFT_F64_TMP_ALLOC(nbytes) KISS_FFT_F64_MALLOC(nbytes)
+#define  KISS_FFT_F64_TMP_FREE(ptr) KISS_FFT_F64_FREE(ptr)
+#endif
diff --git a/gst-libs/gst/fft/_kiss_fft_guts_s16.h b/gst-libs/gst/fft/_kiss_fft_guts_s16.h
index 2d8256e09..3fc4acff7 100644
--- a/gst-libs/gst/fft/_kiss_fft_guts_s16.h
+++ b/gst-libs/gst/fft/_kiss_fft_guts_s16.h
@@ -1,18 +1,12 @@
 /*
-Copyright (c) 2003-2004, Mark Borgerding
-
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
-    * Neither the author nor the names of any contributors may be used to endorse or promote products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ *  Copyright (c) 2003-2010, Mark Borgerding. All rights reserved.
+ *  This file is part of KISS FFT - https://github.com/mborgerding/kissfft
+ *
+ *  SPDX-License-Identifier: BSD-3-Clause
+ *  See COPYING file for more information.
+ */
 
-/* kiss_fft.h
+/* kiss_fft_s16.h
    defines kiss_fft_s16_scalar as either short or a float type
    and defines
    typedef struct { kiss_fft_s16_scalar r; kiss_fft_s16_scalar i; }kiss_fft_s16_cpx; */
@@ -55,16 +49,24 @@ struct kiss_fft_s16_state{
    C_SUBFROM( res , a)  : res -= a
    C_ADDTO( res , a)    : res += a
  * */
-#define FRACBITS 15
-#define SAMPPROD int32_t 
-#define SAMP_MAX 32767
-
-#define SAMP_MIN -SAMP_MAX
+#ifdef FIXED_POINT
+#include <stdint.h>
+#if (FIXED_POINT==32)
+# define FRACBITS 31
+# define SAMPPROD int64_t
+#define SAMP_MAX INT32_MAX
+#define SAMP_MIN INT32_MIN
+#else
+# define FRACBITS 15
+# define SAMPPROD int32_t
+#define SAMP_MAX INT16_MAX
+#define SAMP_MIN INT16_MIN
+#endif
 
 #if defined(CHECK_OVERFLOW)
 #  define CHECK_OVERFLOW_OP(a,op,b)  \
 	if ( (SAMPPROD)(a) op (SAMPPROD)(b) > SAMP_MAX || (SAMPPROD)(a) op (SAMPPROD)(b) < SAMP_MIN ) { \
-		fprintf(stderr,"WARNING:overflow @ " __FILE__ "(%d): (%d " #op" %d) = %ld\n",__LINE__,(a),(b),(SAMPPROD)(a) op (SAMPPROD)(b) );  }
+		g_critical("overflow @ " __FILE__ "(%d): (%d " #op" %d) = %ld",__LINE__,(a),(b),(SAMPPROD)(a) op (SAMPPROD)(b) );  }
 #endif
 
 
@@ -88,6 +90,18 @@ struct kiss_fft_s16_state{
     do{ (c).r =  sround( smul( (c).r , s ) ) ;\
         (c).i =  sround( smul( (c).i , s ) ) ; }while(0)
 
+#else  /* not FIXED_POINT*/
+
+#   define S_MUL(a,b) ( (a)*(b) )
+#define C_MUL(m,a,b) \
+    do{ (m).r = (a).r*(b).r - (a).i*(b).i;\
+        (m).i = (a).r*(b).i + (a).i*(b).r; }while(0)
+#   define C_FIXDIV(c,div) /* NOOP */
+#   define C_MULBYSCALAR( c, s ) \
+    do{ (c).r *= (s);\
+        (c).i *= (s); }while(0)
+#endif
+
 #ifndef CHECK_OVERFLOW_OP
 #  define CHECK_OVERFLOW_OP(a,op,b) /* noop */
 #endif
@@ -119,9 +133,19 @@ struct kiss_fft_s16_state{
     }while(0)
 
 
+#ifdef FIXED_POINT
 #  define KISS_FFT_S16_COS(phase)  floor(.5+SAMP_MAX * cos (phase))
 #  define KISS_FFT_S16_SIN(phase)  floor(.5+SAMP_MAX * sin (phase))
 #  define HALF_OF(x) ((x)>>1)
+#elif defined(USE_SIMD)
+#  define KISS_FFT_S16_COS(phase) _mm_set1_ps( cos(phase) )
+#  define KISS_FFT_S16_SIN(phase) _mm_set1_ps( sin(phase) )
+#  define HALF_OF(x) ((x)*_mm_set1_ps(.5))
+#else
+#  define KISS_FFT_S16_COS(phase) (kiss_fft_s16_scalar) cos(phase)
+#  define KISS_FFT_S16_SIN(phase) (kiss_fft_s16_scalar) sin(phase)
+#  define HALF_OF(x) ((x)*.5)
+#endif
 
 #define  kf_cexp(x,phase) \
 	do{ \
@@ -133,3 +157,17 @@ struct kiss_fft_s16_state{
 /* a debugging function */
 #define pcpx(c)\
     fprintf(stderr,"%g + %gi\n",(double)((c)->r),(double)((c)->i) )
+
+
+#ifdef KISS_FFT_S16_USE_ALLOCA
+// define this to allow use of alloca instead of malloc for temporary buffers
+// Temporary buffers are used in two case: 
+// 1. FFT sizes that have "bad" factors. i.e. not 2,3 and 5
+// 2. "in-place" FFTs.  Notice the quotes, since kissfft does not really do an in-place transform.
+#include <alloca.h>
+#define  KISS_FFT_S16_TMP_ALLOC(nbytes) alloca(nbytes)
+#define  KISS_FFT_S16_TMP_FREE(ptr) 
+#else
+#define  KISS_FFT_S16_TMP_ALLOC(nbytes) KISS_FFT_S16_MALLOC(nbytes)
+#define  KISS_FFT_S16_TMP_FREE(ptr) KISS_FFT_S16_FREE(ptr)
+#endif
diff --git a/gst-libs/gst/fft/_kiss_fft_guts_s32.h b/gst-libs/gst/fft/_kiss_fft_guts_s32.h
index f0ec9c0f4..3dccf9cf2 100644
--- a/gst-libs/gst/fft/_kiss_fft_guts_s32.h
+++ b/gst-libs/gst/fft/_kiss_fft_guts_s32.h
@@ -1,18 +1,12 @@
 /*
-Copyright (c) 2003-2004, Mark Borgerding
-
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
-    * Neither the author nor the names of any contributors may be used to endorse or promote products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ *  Copyright (c) 2003-2010, Mark Borgerding. All rights reserved.
+ *  This file is part of KISS FFT - https://github.com/mborgerding/kissfft
+ *
+ *  SPDX-License-Identifier: BSD-3-Clause
+ *  See COPYING file for more information.
+ */
 
-/* kiss_fft.h
+/* kiss_fft_s32.h
    defines kiss_fft_s32_scalar as either short or a float type
    and defines
    typedef struct { kiss_fft_s32_scalar r; kiss_fft_s32_scalar i; }kiss_fft_s32_cpx; */
@@ -55,17 +49,24 @@ struct kiss_fft_s32_state{
    C_SUBFROM( res , a)  : res -= a
    C_ADDTO( res , a)    : res += a
  * */
-
-#define FRACBITS 31
-#define SAMPPROD int64_t
-#define SAMP_MAX 2147483647
-
-#define SAMP_MIN -SAMP_MAX
+#ifdef FIXED_POINT
+#include <stdint.h>
+#if (FIXED_POINT==32)
+# define FRACBITS 31
+# define SAMPPROD int64_t
+#define SAMP_MAX INT32_MAX
+#define SAMP_MIN INT32_MIN
+#else
+# define FRACBITS 15
+# define SAMPPROD int32_t
+#define SAMP_MAX INT16_MAX
+#define SAMP_MIN INT16_MIN
+#endif
 
 #if defined(CHECK_OVERFLOW)
 #  define CHECK_OVERFLOW_OP(a,op,b)  \
 	if ( (SAMPPROD)(a) op (SAMPPROD)(b) > SAMP_MAX || (SAMPPROD)(a) op (SAMPPROD)(b) < SAMP_MIN ) { \
-		fprintf(stderr,"WARNING:overflow @ " __FILE__ "(%d): (%d " #op" %d) = %ld\n",__LINE__,(a),(b),(SAMPPROD)(a) op (SAMPPROD)(b) );  }
+		g_critical("overflow @ " __FILE__ "(%d): (%d " #op" %d) = %ld",__LINE__,(a),(b),(SAMPPROD)(a) op (SAMPPROD)(b) );  }
 #endif
 
 
@@ -89,6 +90,18 @@ struct kiss_fft_s32_state{
     do{ (c).r =  sround( smul( (c).r , s ) ) ;\
         (c).i =  sround( smul( (c).i , s ) ) ; }while(0)
 
+#else  /* not FIXED_POINT*/
+
+#   define S_MUL(a,b) ( (a)*(b) )
+#define C_MUL(m,a,b) \
+    do{ (m).r = (a).r*(b).r - (a).i*(b).i;\
+        (m).i = (a).r*(b).i + (a).i*(b).r; }while(0)
+#   define C_FIXDIV(c,div) /* NOOP */
+#   define C_MULBYSCALAR( c, s ) \
+    do{ (c).r *= (s);\
+        (c).i *= (s); }while(0)
+#endif
+
 #ifndef CHECK_OVERFLOW_OP
 #  define CHECK_OVERFLOW_OP(a,op,b) /* noop */
 #endif
@@ -120,9 +133,19 @@ struct kiss_fft_s32_state{
     }while(0)
 
 
+#ifdef FIXED_POINT
 #  define KISS_FFT_S32_COS(phase)  floor(.5+SAMP_MAX * cos (phase))
 #  define KISS_FFT_S32_SIN(phase)  floor(.5+SAMP_MAX * sin (phase))
 #  define HALF_OF(x) ((x)>>1)
+#elif defined(USE_SIMD)
+#  define KISS_FFT_S32_COS(phase) _mm_set1_ps( cos(phase) )
+#  define KISS_FFT_S32_SIN(phase) _mm_set1_ps( sin(phase) )
+#  define HALF_OF(x) ((x)*_mm_set1_ps(.5))
+#else
+#  define KISS_FFT_S32_COS(phase) (kiss_fft_s32_scalar) cos(phase)
+#  define KISS_FFT_S32_SIN(phase) (kiss_fft_s32_scalar) sin(phase)
+#  define HALF_OF(x) ((x)*.5)
+#endif
 
 #define  kf_cexp(x,phase) \
 	do{ \
@@ -134,3 +157,17 @@ struct kiss_fft_s32_state{
 /* a debugging function */
 #define pcpx(c)\
     fprintf(stderr,"%g + %gi\n",(double)((c)->r),(double)((c)->i) )
+
+
+#ifdef KISS_FFT_S32_USE_ALLOCA
+// define this to allow use of alloca instead of malloc for temporary buffers
+// Temporary buffers are used in two case: 
+// 1. FFT sizes that have "bad" factors. i.e. not 2,3 and 5
+// 2. "in-place" FFTs.  Notice the quotes, since kissfft does not really do an in-place transform.
+#include <alloca.h>
+#define  KISS_FFT_S32_TMP_ALLOC(nbytes) alloca(nbytes)
+#define  KISS_FFT_S32_TMP_FREE(ptr) 
+#else
+#define  KISS_FFT_S32_TMP_ALLOC(nbytes) KISS_FFT_S32_MALLOC(nbytes)
+#define  KISS_FFT_S32_TMP_FREE(ptr) KISS_FFT_S32_FREE(ptr)
+#endif
diff --git a/gst-libs/gst/fft/kiss_fft_f32.c b/gst-libs/gst/fft/kiss_fft_f32.c
index 45bdeb680..092713e13 100644
--- a/gst-libs/gst/fft/kiss_fft_f32.c
+++ b/gst-libs/gst/fft/kiss_fft_f32.c
@@ -1,40 +1,17 @@
 /*
-Copyright (c) 2003-2004, Mark Borgerding
-
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
-    * Neither the author nor the names of any contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+ *  Copyright (c) 2003-2010, Mark Borgerding. All rights reserved.
+ *  This file is part of KISS FFT - https://github.com/mborgerding/kissfft
+ *
+ *  SPDX-License-Identifier: BSD-3-Clause
+ *  See COPYING file for more information.
+ */
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
 
 #include "_kiss_fft_guts_f32.h"
 /* The guts header contains all the multiplication and addition macros that are defined for
  fixed or floating point complex numbers.  It also delares the kf_ internal functions.
  */
 
-static kiss_fft_f32_cpx *scratchbuf = NULL;
-static size_t nscratchbuf = 0;
-static kiss_fft_f32_cpx *tmpbuf = NULL;
-static size_t ntmpbuf = 0;
-
-#define CHECKBUF(buf,nbuf,n) \
-    do { \
-        if ( nbuf < (size_t)(n) ) {\
-            free(buf); \
-            buf = (kiss_fft_f32_cpx*)KISS_FFT_F32_MALLOC(sizeof(kiss_fft_f32_cpx)*(n)); \
-            nbuf = (size_t)(n); \
-        } \
-   }while(0)
-
-
 static void
 kf_bfly2 (kiss_fft_f32_cpx * Fout,
     const size_t fstride, const kiss_fft_f32_cfg st, int m)
@@ -42,7 +19,6 @@ kf_bfly2 (kiss_fft_f32_cpx * Fout,
   kiss_fft_f32_cpx *Fout2;
   kiss_fft_f32_cpx *tw1 = st->twiddles;
   kiss_fft_f32_cpx t;
-
   Fout2 = Fout + m;
   do {
     C_FIXDIV (*Fout, 2);
@@ -67,6 +43,7 @@ kf_bfly4 (kiss_fft_f32_cpx * Fout,
   const size_t m2 = 2 * m;
   const size_t m3 = 3 * m;
 
+
   tw3 = tw2 = tw1 = st->twiddles;
 
   do {
@@ -113,7 +90,6 @@ kf_bfly3 (kiss_fft_f32_cpx * Fout,
   kiss_fft_f32_cpx *tw1, *tw2;
   kiss_fft_f32_cpx scratch[5];
   kiss_fft_f32_cpx epi3;
-
   epi3 = st->twiddles[fstride * m];
 
   tw1 = tw2 = st->twiddles;
@@ -158,7 +134,6 @@ kf_bfly5 (kiss_fft_f32_cpx * Fout,
   kiss_fft_f32_cpx *twiddles = st->twiddles;
   kiss_fft_f32_cpx *tw;
   kiss_fft_f32_cpx ya, yb;
-
   ya = twiddles[fstride * m];
   yb = twiddles[fstride * 2 * m];
 
@@ -229,38 +204,40 @@ kf_bfly_generic (kiss_fft_f32_cpx * Fout,
   kiss_fft_f32_cpx t;
   int Norig = st->nfft;
 
-  CHECKBUF (scratchbuf, nscratchbuf, p);
+  kiss_fft_f32_cpx *scratch =
+      (kiss_fft_f32_cpx *) KISS_FFT_F32_TMP_ALLOC (sizeof (kiss_fft_f32_cpx) *
+      p);
 
   for (u = 0; u < m; ++u) {
     k = u;
     for (q1 = 0; q1 < p; ++q1) {
-      scratchbuf[q1] = Fout[k];
-      C_FIXDIV (scratchbuf[q1], p);
+      scratch[q1] = Fout[k];
+      C_FIXDIV (scratch[q1], p);
       k += m;
     }
 
     k = u;
     for (q1 = 0; q1 < p; ++q1) {
       int twidx = 0;
-
-      Fout[k] = scratchbuf[0];
+      Fout[k] = scratch[0];
       for (q = 1; q < p; ++q) {
         twidx += fstride * k;
         if (twidx >= Norig)
           twidx -= Norig;
-        C_MUL (t, scratchbuf[q], twiddles[twidx]);
+        C_MUL (t, scratch[q], twiddles[twidx]);
         C_ADDTO (Fout[k], t);
       }
       k += m;
     }
   }
+  KISS_FFT_F32_TMP_FREE (scratch);
 }
 
 static void
 kf_work (kiss_fft_f32_cpx * Fout,
     const kiss_fft_f32_cpx * f,
-    const size_t fstride,
-    int in_stride, int *factors, const kiss_fft_f32_cfg st)
+    const size_t fstride, int in_stride, int *factors,
+    const kiss_fft_f32_cfg st)
 {
   kiss_fft_f32_cpx *Fout_beg = Fout;
   const int p = *factors++;     /* the radix  */
@@ -270,7 +247,7 @@ kf_work (kiss_fft_f32_cpx * Fout,
 #ifdef _OPENMP
   // use openmp extensions at the 
   // top-level (not recursive)
-  if (fstride == 1) {
+  if (fstride == 1 && p <= 5 && m != 1) {
     int k;
 
     // execute the p different work units in different threads
@@ -348,7 +325,6 @@ kf_factor (int n, int *facbuf)
 {
   int p = 4;
   double floor_sqrt;
-
   floor_sqrt = floor (sqrt ((double) n));
 
   /*factor out powers of 4, powers of 2, then any remaining primes */
@@ -379,7 +355,7 @@ kf_factor (int n, int *facbuf)
  * User-callable function to allocate all necessary storage space for the fft.
  *
  * The return value is a contiguous block of memory, allocated with malloc.  As such,
- * It can be freed with free(), rather than a kiss_fft-specific function.
+ * It can be freed with free(), rather than a kiss_fft_f32-specific function.
  * */
 kiss_fft_f32_cfg
 kiss_fft_f32_alloc (int nfft, int inverse_fft, void *mem, size_t * lenmem)
@@ -397,7 +373,6 @@ kiss_fft_f32_alloc (int nfft, int inverse_fft, void *mem, size_t * lenmem)
   }
   if (st) {
     int i;
-
     st->nfft = nfft;
     st->inverse = inverse_fft;
 
@@ -405,7 +380,6 @@ kiss_fft_f32_alloc (int nfft, int inverse_fft, void *mem, size_t * lenmem)
       const double pi =
           3.141592653589793238462643383279502884197169399375105820974944;
       double phase = -2 * pi * i / nfft;
-
       if (st->inverse)
         phase *= -1;
       kf_cexp (st->twiddles + i, phase);
@@ -417,16 +391,19 @@ kiss_fft_f32_alloc (int nfft, int inverse_fft, void *mem, size_t * lenmem)
 }
 
 
-
-
 void
 kiss_fft_f32_stride (kiss_fft_f32_cfg st, const kiss_fft_f32_cpx * fin,
     kiss_fft_f32_cpx * fout, int in_stride)
 {
   if (fin == fout) {
-    CHECKBUF (tmpbuf, ntmpbuf, st->nfft);
+    //NOTE: this is not really an in-place FFT algorithm.
+    //It just performs an out-of-place FFT into a temp buffer
+    kiss_fft_f32_cpx *tmpbuf =
+        (kiss_fft_f32_cpx *) KISS_FFT_F32_TMP_ALLOC (sizeof (kiss_fft_f32_cpx) *
+        st->nfft);
     kf_work (tmpbuf, fin, 1, in_stride, st->factors, st);
     memcpy (fout, tmpbuf, sizeof (kiss_fft_f32_cpx) * st->nfft);
+    KISS_FFT_F32_TMP_FREE (tmpbuf);
   } else {
     kf_work (fout, fin, 1, in_stride, st->factors, st);
   }
@@ -440,18 +417,10 @@ kiss_fft_f32 (kiss_fft_f32_cfg cfg, const kiss_fft_f32_cpx * fin,
 }
 
 
-/* not really necessary to call, but if someone is doing in-place ffts, they may want to free the 
-   buffers from CHECKBUF
- */
 void
 kiss_fft_f32_cleanup (void)
 {
-  free (scratchbuf);
-  scratchbuf = NULL;
-  nscratchbuf = 0;
-  free (tmpbuf);
-  tmpbuf = NULL;
-  ntmpbuf = 0;
+  // nothing needed any more
 }
 
 int
@@ -459,7 +428,6 @@ kiss_fft_f32_next_fast_size (int n)
 {
   while (1) {
     int m = n;
-
     while ((m % 2) == 0)
       m /= 2;
     while ((m % 3) == 0)
diff --git a/gst-libs/gst/fft/kiss_fft_f32.h b/gst-libs/gst/fft/kiss_fft_f32.h
index 098b89da7..6e4a91e82 100644
--- a/gst-libs/gst/fft/kiss_fft_f32.h
+++ b/gst-libs/gst/fft/kiss_fft_f32.h
@@ -1,3 +1,11 @@
+/*
+ *  Copyright (c) 2003-2010, Mark Borgerding. All rights reserved.
+ *  This file is part of KISS FFT - https://github.com/mborgerding/kissfft
+ *
+ *  SPDX-License-Identifier: BSD-3-Clause
+ *  See COPYING file for more information.
+ */
+
 #ifndef KISS_FFT_F32_H
 #define KISS_FFT_F32_H
 
@@ -5,6 +13,7 @@
 #include <stdio.h>
 #include <math.h>
 #include <string.h>
+#include <stdint.h>
 #include <glib.h>
 
 #ifdef __cplusplus
@@ -20,11 +29,12 @@ extern "C" {
  -- a command-line utility to perform ffts
  -- a command-line utility to perform fast-convolution filtering
 
- Then see kfc.h kiss_fftr.h kiss_fftnd.h fftutil.c kiss_fastfir.c
+ Then see kfc.h kiss_fftr_f32.h kiss_fft_f32nd.h fftutil.c kiss_fastfir.c
   in the tools/ directory.
 */
 
 #define KISS_FFT_F32_MALLOC g_malloc
+#define KISS_FFT_F32_FREE g_free
 #define kiss_fft_f32_scalar float
 
 typedef struct {
@@ -60,7 +70,7 @@ typedef struct kiss_fft_f32_state* kiss_fft_f32_cfg;
 kiss_fft_f32_cfg kiss_fft_f32_alloc(int nfft,int inverse_fft,void * mem,size_t * lenmem); 
 
 /*
- * kiss_fft(cfg,in_out_buf)
+ * kiss_fft_f32(cfg,in_out_buf)
  *
  * Perform an FFT on a complex input buffer.
  * for a forward FFT,
@@ -78,7 +88,7 @@ void kiss_fft_f32_stride(kiss_fft_f32_cfg cfg,const kiss_fft_f32_cpx *fin,kiss_f
 
 /* If kiss_fft_f32_alloc allocated a buffer, it is one contiguous 
    buffer and can be simply free()d when no longer needed*/
-#define kiss_fft_f32_free g_free
+#define kiss_fft_f32_free KISS_FFT_F32_FREE
 
 /*
  Cleans up some memory that gets managed internally. Not necessary to call, but it might clean up 
@@ -93,8 +103,8 @@ void kiss_fft_f32_cleanup(void);
 int kiss_fft_f32_next_fast_size(int n);
 
 /* for real ffts, we need an even size */
-#define kiss_fftr_next_fast_size_real(n) \
-        (kiss_fft_next_fast_size( ((n)+1)>>1)<<1)
+#define kiss_fftr_f32_next_fast_size_real(n) \
+        (kiss_fft_f32_next_fast_size( ((n)+1)>>1)<<1)
 
 #ifdef __cplusplus
 } 
diff --git a/gst-libs/gst/fft/kiss_fft_f64.c b/gst-libs/gst/fft/kiss_fft_f64.c
index da42aab94..4b3fa00f5 100644
--- a/gst-libs/gst/fft/kiss_fft_f64.c
+++ b/gst-libs/gst/fft/kiss_fft_f64.c
@@ -1,40 +1,17 @@
 /*
-Copyright (c) 2003-2004, Mark Borgerding
-
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
-    * Neither the author nor the names of any contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+ *  Copyright (c) 2003-2010, Mark Borgerding. All rights reserved.
+ *  This file is part of KISS FFT - https://github.com/mborgerding/kissfft
+ *
+ *  SPDX-License-Identifier: BSD-3-Clause
+ *  See COPYING file for more information.
+ */
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
 
 #include "_kiss_fft_guts_f64.h"
 /* The guts header contains all the multiplication and addition macros that are defined for
  fixed or floating point complex numbers.  It also delares the kf_ internal functions.
  */
 
-static kiss_fft_f64_cpx *scratchbuf = NULL;
-static size_t nscratchbuf = 0;
-static kiss_fft_f64_cpx *tmpbuf = NULL;
-static size_t ntmpbuf = 0;
-
-#define CHECKBUF(buf,nbuf,n) \
-    do { \
-        if ( nbuf < (size_t)(n) ) {\
-            free(buf); \
-            buf = (kiss_fft_f64_cpx*)KISS_FFT_F64_MALLOC(sizeof(kiss_fft_f64_cpx)*(n)); \
-            nbuf = (size_t)(n); \
-        } \
-   }while(0)
-
-
 static void
 kf_bfly2 (kiss_fft_f64_cpx * Fout,
     const size_t fstride, const kiss_fft_f64_cfg st, int m)
@@ -42,7 +19,6 @@ kf_bfly2 (kiss_fft_f64_cpx * Fout,
   kiss_fft_f64_cpx *Fout2;
   kiss_fft_f64_cpx *tw1 = st->twiddles;
   kiss_fft_f64_cpx t;
-
   Fout2 = Fout + m;
   do {
     C_FIXDIV (*Fout, 2);
@@ -67,6 +43,7 @@ kf_bfly4 (kiss_fft_f64_cpx * Fout,
   const size_t m2 = 2 * m;
   const size_t m3 = 3 * m;
 
+
   tw3 = tw2 = tw1 = st->twiddles;
 
   do {
@@ -113,7 +90,6 @@ kf_bfly3 (kiss_fft_f64_cpx * Fout,
   kiss_fft_f64_cpx *tw1, *tw2;
   kiss_fft_f64_cpx scratch[5];
   kiss_fft_f64_cpx epi3;
-
   epi3 = st->twiddles[fstride * m];
 
   tw1 = tw2 = st->twiddles;
@@ -158,7 +134,6 @@ kf_bfly5 (kiss_fft_f64_cpx * Fout,
   kiss_fft_f64_cpx *twiddles = st->twiddles;
   kiss_fft_f64_cpx *tw;
   kiss_fft_f64_cpx ya, yb;
-
   ya = twiddles[fstride * m];
   yb = twiddles[fstride * 2 * m];
 
@@ -229,38 +204,40 @@ kf_bfly_generic (kiss_fft_f64_cpx * Fout,
   kiss_fft_f64_cpx t;
   int Norig = st->nfft;
 
-  CHECKBUF (scratchbuf, nscratchbuf, p);
+  kiss_fft_f64_cpx *scratch =
+      (kiss_fft_f64_cpx *) KISS_FFT_F64_TMP_ALLOC (sizeof (kiss_fft_f64_cpx) *
+      p);
 
   for (u = 0; u < m; ++u) {
     k = u;
     for (q1 = 0; q1 < p; ++q1) {
-      scratchbuf[q1] = Fout[k];
-      C_FIXDIV (scratchbuf[q1], p);
+      scratch[q1] = Fout[k];
+      C_FIXDIV (scratch[q1], p);
       k += m;
     }
 
     k = u;
     for (q1 = 0; q1 < p; ++q1) {
       int twidx = 0;
-
-      Fout[k] = scratchbuf[0];
+      Fout[k] = scratch[0];
       for (q = 1; q < p; ++q) {
         twidx += fstride * k;
         if (twidx >= Norig)
           twidx -= Norig;
-        C_MUL (t, scratchbuf[q], twiddles[twidx]);
+        C_MUL (t, scratch[q], twiddles[twidx]);
         C_ADDTO (Fout[k], t);
       }
       k += m;
     }
   }
+  KISS_FFT_F64_TMP_FREE (scratch);
 }
 
 static void
 kf_work (kiss_fft_f64_cpx * Fout,
     const kiss_fft_f64_cpx * f,
-    const size_t fstride,
-    int in_stride, int *factors, const kiss_fft_f64_cfg st)
+    const size_t fstride, int in_stride, int *factors,
+    const kiss_fft_f64_cfg st)
 {
   kiss_fft_f64_cpx *Fout_beg = Fout;
   const int p = *factors++;     /* the radix  */
@@ -270,7 +247,7 @@ kf_work (kiss_fft_f64_cpx * Fout,
 #ifdef _OPENMP
   // use openmp extensions at the 
   // top-level (not recursive)
-  if (fstride == 1) {
+  if (fstride == 1 && p <= 5 && m != 1) {
     int k;
 
     // execute the p different work units in different threads
@@ -348,7 +325,6 @@ kf_factor (int n, int *facbuf)
 {
   int p = 4;
   double floor_sqrt;
-
   floor_sqrt = floor (sqrt ((double) n));
 
   /*factor out powers of 4, powers of 2, then any remaining primes */
@@ -379,14 +355,12 @@ kf_factor (int n, int *facbuf)
  * User-callable function to allocate all necessary storage space for the fft.
  *
  * The return value is a contiguous block of memory, allocated with malloc.  As such,
- * It can be freed with free(), rather than a kiss_fft-specific function.
+ * It can be freed with free(), rather than a kiss_fft_f64-specific function.
  * */
 kiss_fft_f64_cfg
 kiss_fft_f64_alloc (int nfft, int inverse_fft, void *mem, size_t * lenmem)
 {
   kiss_fft_f64_cfg st = NULL;
-  const double pi =
-      3.141592653589793238462643383279502884197169399375105820974944;
   size_t memneeded = sizeof (struct kiss_fft_f64_state)
       + sizeof (kiss_fft_f64_cpx) * (nfft - 1); /* twiddle factors */
 
@@ -399,13 +373,13 @@ kiss_fft_f64_alloc (int nfft, int inverse_fft, void *mem, size_t * lenmem)
   }
   if (st) {
     int i;
-
     st->nfft = nfft;
     st->inverse = inverse_fft;
 
     for (i = 0; i < nfft; ++i) {
+      const double pi =
+          3.141592653589793238462643383279502884197169399375105820974944;
       double phase = -2 * pi * i / nfft;
-
       if (st->inverse)
         phase *= -1;
       kf_cexp (st->twiddles + i, phase);
@@ -417,16 +391,19 @@ kiss_fft_f64_alloc (int nfft, int inverse_fft, void *mem, size_t * lenmem)
 }
 
 
-
-
 void
 kiss_fft_f64_stride (kiss_fft_f64_cfg st, const kiss_fft_f64_cpx * fin,
     kiss_fft_f64_cpx * fout, int in_stride)
 {
   if (fin == fout) {
-    CHECKBUF (tmpbuf, ntmpbuf, st->nfft);
+    //NOTE: this is not really an in-place FFT algorithm.
+    //It just performs an out-of-place FFT into a temp buffer
+    kiss_fft_f64_cpx *tmpbuf =
+        (kiss_fft_f64_cpx *) KISS_FFT_F64_TMP_ALLOC (sizeof (kiss_fft_f64_cpx) *
+        st->nfft);
     kf_work (tmpbuf, fin, 1, in_stride, st->factors, st);
     memcpy (fout, tmpbuf, sizeof (kiss_fft_f64_cpx) * st->nfft);
+    KISS_FFT_F64_TMP_FREE (tmpbuf);
   } else {
     kf_work (fout, fin, 1, in_stride, st->factors, st);
   }
@@ -440,18 +417,10 @@ kiss_fft_f64 (kiss_fft_f64_cfg cfg, const kiss_fft_f64_cpx * fin,
 }
 
 
-/* not really necessary to call, but if someone is doing in-place ffts, they may want to free the 
-   buffers from CHECKBUF
- */
 void
 kiss_fft_f64_cleanup (void)
 {
-  free (scratchbuf);
-  scratchbuf = NULL;
-  nscratchbuf = 0;
-  free (tmpbuf);
-  tmpbuf = NULL;
-  ntmpbuf = 0;
+  // nothing needed any more
 }
 
 int
@@ -459,7 +428,6 @@ kiss_fft_f64_next_fast_size (int n)
 {
   while (1) {
     int m = n;
-
     while ((m % 2) == 0)
       m /= 2;
     while ((m % 3) == 0)
diff --git a/gst-libs/gst/fft/kiss_fft_f64.h b/gst-libs/gst/fft/kiss_fft_f64.h
index 90792bbda..edfbfd1d2 100644
--- a/gst-libs/gst/fft/kiss_fft_f64.h
+++ b/gst-libs/gst/fft/kiss_fft_f64.h
@@ -1,3 +1,11 @@
+/*
+ *  Copyright (c) 2003-2010, Mark Borgerding. All rights reserved.
+ *  This file is part of KISS FFT - https://github.com/mborgerding/kissfft
+ *
+ *  SPDX-License-Identifier: BSD-3-Clause
+ *  See COPYING file for more information.
+ */
+
 #ifndef KISS_FFT_F64_H
 #define KISS_FFT_F64_H
 
@@ -5,6 +13,7 @@
 #include <stdio.h>
 #include <math.h>
 #include <string.h>
+#include <stdint.h>
 #include <glib.h>
 
 #ifdef __cplusplus
@@ -20,11 +29,12 @@ extern "C" {
  -- a command-line utility to perform ffts
  -- a command-line utility to perform fast-convolution filtering
 
- Then see kfc.h kiss_fftr.h kiss_fftnd.h fftutil.c kiss_fastfir.c
+ Then see kfc.h kiss_fftr_f64.h kiss_fft_f64nd.h fftutil.c kiss_fastfir.c
   in the tools/ directory.
 */
 
 #define KISS_FFT_F64_MALLOC g_malloc
+#define KISS_FFT_F64_FREE g_free
 #define kiss_fft_f64_scalar double
 
 typedef struct {
@@ -60,7 +70,7 @@ typedef struct kiss_fft_f64_state* kiss_fft_f64_cfg;
 kiss_fft_f64_cfg kiss_fft_f64_alloc(int nfft,int inverse_fft,void * mem,size_t * lenmem); 
 
 /*
- * kiss_fft(cfg,in_out_buf)
+ * kiss_fft_f64(cfg,in_out_buf)
  *
  * Perform an FFT on a complex input buffer.
  * for a forward FFT,
@@ -78,7 +88,7 @@ void kiss_fft_f64_stride(kiss_fft_f64_cfg cfg,const kiss_fft_f64_cpx *fin,kiss_f
 
 /* If kiss_fft_f64_alloc allocated a buffer, it is one contiguous 
    buffer and can be simply free()d when no longer needed*/
-#define kiss_fft_f64_free g_free
+#define kiss_fft_f64_free KISS_FFT_F64_FREE
 
 /*
  Cleans up some memory that gets managed internally. Not necessary to call, but it might clean up 
@@ -93,8 +103,8 @@ void kiss_fft_f64_cleanup(void);
 int kiss_fft_f64_next_fast_size(int n);
 
 /* for real ffts, we need an even size */
-#define kiss_fftr_next_fast_size_real(n) \
-        (kiss_fft_next_fast_size( ((n)+1)>>1)<<1)
+#define kiss_fftr_f64_next_fast_size_real(n) \
+        (kiss_fft_f64_next_fast_size( ((n)+1)>>1)<<1)
 
 #ifdef __cplusplus
 } 
diff --git a/gst-libs/gst/fft/kiss_fft_s16.c b/gst-libs/gst/fft/kiss_fft_s16.c
index 7334141a0..a110bbd98 100644
--- a/gst-libs/gst/fft/kiss_fft_s16.c
+++ b/gst-libs/gst/fft/kiss_fft_s16.c
@@ -1,40 +1,17 @@
 /*
-Copyright (c) 2003-2004, Mark Borgerding
-
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
-    * Neither the author nor the names of any contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+ *  Copyright (c) 2003-2010, Mark Borgerding. All rights reserved.
+ *  This file is part of KISS FFT - https://github.com/mborgerding/kissfft
+ *
+ *  SPDX-License-Identifier: BSD-3-Clause
+ *  See COPYING file for more information.
+ */
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
 
 #include "_kiss_fft_guts_s16.h"
 /* The guts header contains all the multiplication and addition macros that are defined for
  fixed or floating point complex numbers.  It also delares the kf_ internal functions.
  */
 
-static kiss_fft_s16_cpx *scratchbuf = NULL;
-static size_t nscratchbuf = 0;
-static kiss_fft_s16_cpx *tmpbuf = NULL;
-static size_t ntmpbuf = 0;
-
-#define CHECKBUF(buf,nbuf,n) \
-    do { \
-        if ( nbuf < (size_t)(n) ) {\
-            free(buf); \
-            buf = (kiss_fft_s16_cpx*)KISS_FFT_S16_MALLOC(sizeof(kiss_fft_s16_cpx)*(n)); \
-            nbuf = (size_t)(n); \
-        } \
-   }while(0)
-
-
 static void
 kf_bfly2 (kiss_fft_s16_cpx * Fout,
     const size_t fstride, const kiss_fft_s16_cfg st, int m)
@@ -42,7 +19,6 @@ kf_bfly2 (kiss_fft_s16_cpx * Fout,
   kiss_fft_s16_cpx *Fout2;
   kiss_fft_s16_cpx *tw1 = st->twiddles;
   kiss_fft_s16_cpx t;
-
   Fout2 = Fout + m;
   do {
     C_FIXDIV (*Fout, 2);
@@ -67,6 +43,7 @@ kf_bfly4 (kiss_fft_s16_cpx * Fout,
   const size_t m2 = 2 * m;
   const size_t m3 = 3 * m;
 
+
   tw3 = tw2 = tw1 = st->twiddles;
 
   do {
@@ -113,7 +90,6 @@ kf_bfly3 (kiss_fft_s16_cpx * Fout,
   kiss_fft_s16_cpx *tw1, *tw2;
   kiss_fft_s16_cpx scratch[5];
   kiss_fft_s16_cpx epi3;
-
   epi3 = st->twiddles[fstride * m];
 
   tw1 = tw2 = st->twiddles;
@@ -158,7 +134,6 @@ kf_bfly5 (kiss_fft_s16_cpx * Fout,
   kiss_fft_s16_cpx *twiddles = st->twiddles;
   kiss_fft_s16_cpx *tw;
   kiss_fft_s16_cpx ya, yb;
-
   ya = twiddles[fstride * m];
   yb = twiddles[fstride * 2 * m];
 
@@ -229,38 +204,40 @@ kf_bfly_generic (kiss_fft_s16_cpx * Fout,
   kiss_fft_s16_cpx t;
   int Norig = st->nfft;
 
-  CHECKBUF (scratchbuf, nscratchbuf, p);
+  kiss_fft_s16_cpx *scratch =
+      (kiss_fft_s16_cpx *) KISS_FFT_S16_TMP_ALLOC (sizeof (kiss_fft_s16_cpx) *
+      p);
 
   for (u = 0; u < m; ++u) {
     k = u;
     for (q1 = 0; q1 < p; ++q1) {
-      scratchbuf[q1] = Fout[k];
-      C_FIXDIV (scratchbuf[q1], p);
+      scratch[q1] = Fout[k];
+      C_FIXDIV (scratch[q1], p);
       k += m;
     }
 
     k = u;
     for (q1 = 0; q1 < p; ++q1) {
       int twidx = 0;
-
-      Fout[k] = scratchbuf[0];
+      Fout[k] = scratch[0];
       for (q = 1; q < p; ++q) {
         twidx += fstride * k;
         if (twidx >= Norig)
           twidx -= Norig;
-        C_MUL (t, scratchbuf[q], twiddles[twidx]);
+        C_MUL (t, scratch[q], twiddles[twidx]);
         C_ADDTO (Fout[k], t);
       }
       k += m;
     }
   }
+  KISS_FFT_S16_TMP_FREE (scratch);
 }
 
 static void
 kf_work (kiss_fft_s16_cpx * Fout,
     const kiss_fft_s16_cpx * f,
-    const size_t fstride,
-    int in_stride, int *factors, const kiss_fft_s16_cfg st)
+    const size_t fstride, int in_stride, int *factors,
+    const kiss_fft_s16_cfg st)
 {
   kiss_fft_s16_cpx *Fout_beg = Fout;
   const int p = *factors++;     /* the radix  */
@@ -270,7 +247,7 @@ kf_work (kiss_fft_s16_cpx * Fout,
 #ifdef _OPENMP
   // use openmp extensions at the 
   // top-level (not recursive)
-  if (fstride == 1) {
+  if (fstride == 1 && p <= 5 && m != 1) {
     int k;
 
     // execute the p different work units in different threads
@@ -348,7 +325,6 @@ kf_factor (int n, int *facbuf)
 {
   int p = 4;
   double floor_sqrt;
-
   floor_sqrt = floor (sqrt ((double) n));
 
   /*factor out powers of 4, powers of 2, then any remaining primes */
@@ -379,7 +355,7 @@ kf_factor (int n, int *facbuf)
  * User-callable function to allocate all necessary storage space for the fft.
  *
  * The return value is a contiguous block of memory, allocated with malloc.  As such,
- * It can be freed with free(), rather than a kiss_fft-specific function.
+ * It can be freed with free(), rather than a kiss_fft_s16-specific function.
  * */
 kiss_fft_s16_cfg
 kiss_fft_s16_alloc (int nfft, int inverse_fft, void *mem, size_t * lenmem)
@@ -397,7 +373,6 @@ kiss_fft_s16_alloc (int nfft, int inverse_fft, void *mem, size_t * lenmem)
   }
   if (st) {
     int i;
-
     st->nfft = nfft;
     st->inverse = inverse_fft;
 
@@ -405,7 +380,6 @@ kiss_fft_s16_alloc (int nfft, int inverse_fft, void *mem, size_t * lenmem)
       const double pi =
           3.141592653589793238462643383279502884197169399375105820974944;
       double phase = -2 * pi * i / nfft;
-
       if (st->inverse)
         phase *= -1;
       kf_cexp (st->twiddles + i, phase);
@@ -417,16 +391,19 @@ kiss_fft_s16_alloc (int nfft, int inverse_fft, void *mem, size_t * lenmem)
 }
 
 
-
-
 void
 kiss_fft_s16_stride (kiss_fft_s16_cfg st, const kiss_fft_s16_cpx * fin,
     kiss_fft_s16_cpx * fout, int in_stride)
 {
   if (fin == fout) {
-    CHECKBUF (tmpbuf, ntmpbuf, st->nfft);
+    //NOTE: this is not really an in-place FFT algorithm.
+    //It just performs an out-of-place FFT into a temp buffer
+    kiss_fft_s16_cpx *tmpbuf =
+        (kiss_fft_s16_cpx *) KISS_FFT_S16_TMP_ALLOC (sizeof (kiss_fft_s16_cpx) *
+        st->nfft);
     kf_work (tmpbuf, fin, 1, in_stride, st->factors, st);
     memcpy (fout, tmpbuf, sizeof (kiss_fft_s16_cpx) * st->nfft);
+    KISS_FFT_S16_TMP_FREE (tmpbuf);
   } else {
     kf_work (fout, fin, 1, in_stride, st->factors, st);
   }
@@ -440,18 +417,10 @@ kiss_fft_s16 (kiss_fft_s16_cfg cfg, const kiss_fft_s16_cpx * fin,
 }
 
 
-/* not really necessary to call, but if someone is doing in-place ffts, they may want to free the 
-   buffers from CHECKBUF
- */
 void
 kiss_fft_s16_cleanup (void)
 {
-  free (scratchbuf);
-  scratchbuf = NULL;
-  nscratchbuf = 0;
-  free (tmpbuf);
-  tmpbuf = NULL;
-  ntmpbuf = 0;
+  // nothing needed any more
 }
 
 int
@@ -459,7 +428,6 @@ kiss_fft_s16_next_fast_size (int n)
 {
   while (1) {
     int m = n;
-
     while ((m % 2) == 0)
       m /= 2;
     while ((m % 3) == 0)
diff --git a/gst-libs/gst/fft/kiss_fft_s16.h b/gst-libs/gst/fft/kiss_fft_s16.h
index 7dd40a22b..ca6fc3a5d 100644
--- a/gst-libs/gst/fft/kiss_fft_s16.h
+++ b/gst-libs/gst/fft/kiss_fft_s16.h
@@ -1,18 +1,19 @@
+/*
+ *  Copyright (c) 2003-2010, Mark Borgerding. All rights reserved.
+ *  This file is part of KISS FFT - https://github.com/mborgerding/kissfft
+ *
+ *  SPDX-License-Identifier: BSD-3-Clause
+ *  See COPYING file for more information.
+ */
+
 #ifndef KISS_FFT_S16_H
 #define KISS_FFT_S16_H
 
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#ifdef HAVE_STDINT_H
-#include <stdint.h>
-#endif
-
 #include <stdlib.h>
 #include <stdio.h>
 #include <math.h>
 #include <string.h>
+#include <stdint.h>
 #include <glib.h>
 
 #ifdef __cplusplus
@@ -28,13 +29,14 @@ extern "C" {
  -- a command-line utility to perform ffts
  -- a command-line utility to perform fast-convolution filtering
 
- Then see kfc.h kiss_fftr.h kiss_fftnd.h fftutil.c kiss_fastfir.c
+ Then see kfc.h kiss_fftr_s16.h kiss_fft_s16nd.h fftutil.c kiss_fastfir.c
   in the tools/ directory.
 */
 
 #define KISS_FFT_S16_MALLOC g_malloc
-
+#define KISS_FFT_S16_FREE g_free
 #define kiss_fft_s16_scalar int16_t
+#define FIXED_POINT 16
 
 typedef struct {
     kiss_fft_s16_scalar r;
@@ -69,7 +71,7 @@ typedef struct kiss_fft_s16_state* kiss_fft_s16_cfg;
 kiss_fft_s16_cfg kiss_fft_s16_alloc(int nfft,int inverse_fft,void * mem,size_t * lenmem); 
 
 /*
- * kiss_fft(cfg,in_out_buf)
+ * kiss_fft_s16(cfg,in_out_buf)
  *
  * Perform an FFT on a complex input buffer.
  * for a forward FFT,
@@ -87,7 +89,7 @@ void kiss_fft_s16_stride(kiss_fft_s16_cfg cfg,const kiss_fft_s16_cpx *fin,kiss_f
 
 /* If kiss_fft_s16_alloc allocated a buffer, it is one contiguous 
    buffer and can be simply free()d when no longer needed*/
-#define kiss_fft_s16_free g_free
+#define kiss_fft_s16_free KISS_FFT_S16_FREE
 
 /*
  Cleans up some memory that gets managed internally. Not necessary to call, but it might clean up 
@@ -102,8 +104,8 @@ void kiss_fft_s16_cleanup(void);
 int kiss_fft_s16_next_fast_size(int n);
 
 /* for real ffts, we need an even size */
-#define kiss_fftr_next_fast_size_real(n) \
-        (kiss_fft_next_fast_size( ((n)+1)>>1)<<1)
+#define kiss_fftr_s16_next_fast_size_real(n) \
+        (kiss_fft_s16_next_fast_size( ((n)+1)>>1)<<1)
 
 #ifdef __cplusplus
 } 
diff --git a/gst-libs/gst/fft/kiss_fft_s32.c b/gst-libs/gst/fft/kiss_fft_s32.c
index ed8d69ee2..7e5a0e177 100644
--- a/gst-libs/gst/fft/kiss_fft_s32.c
+++ b/gst-libs/gst/fft/kiss_fft_s32.c
@@ -1,40 +1,17 @@
 /*
-Copyright (c) 2003-2004, Mark Borgerding
-
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
-    * Neither the author nor the names of any contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+ *  Copyright (c) 2003-2010, Mark Borgerding. All rights reserved.
+ *  This file is part of KISS FFT - https://github.com/mborgerding/kissfft
+ *
+ *  SPDX-License-Identifier: BSD-3-Clause
+ *  See COPYING file for more information.
+ */
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
 
 #include "_kiss_fft_guts_s32.h"
 /* The guts header contains all the multiplication and addition macros that are defined for
  fixed or floating point complex numbers.  It also delares the kf_ internal functions.
  */
 
-static kiss_fft_s32_cpx *scratchbuf = NULL;
-static size_t nscratchbuf = 0;
-static kiss_fft_s32_cpx *tmpbuf = NULL;
-static size_t ntmpbuf = 0;
-
-#define CHECKBUF(buf,nbuf,n) \
-    do { \
-        if ( nbuf < (size_t)(n) ) {\
-            free(buf); \
-            buf = (kiss_fft_s32_cpx*)KISS_FFT_S32_MALLOC(sizeof(kiss_fft_s32_cpx)*(n)); \
-            nbuf = (size_t)(n); \
-        } \
-   }while(0)
-
-
 static void
 kf_bfly2 (kiss_fft_s32_cpx * Fout,
     const size_t fstride, const kiss_fft_s32_cfg st, int m)
@@ -42,7 +19,6 @@ kf_bfly2 (kiss_fft_s32_cpx * Fout,
   kiss_fft_s32_cpx *Fout2;
   kiss_fft_s32_cpx *tw1 = st->twiddles;
   kiss_fft_s32_cpx t;
-
   Fout2 = Fout + m;
   do {
     C_FIXDIV (*Fout, 2);
@@ -67,6 +43,7 @@ kf_bfly4 (kiss_fft_s32_cpx * Fout,
   const size_t m2 = 2 * m;
   const size_t m3 = 3 * m;
 
+
   tw3 = tw2 = tw1 = st->twiddles;
 
   do {
@@ -113,7 +90,6 @@ kf_bfly3 (kiss_fft_s32_cpx * Fout,
   kiss_fft_s32_cpx *tw1, *tw2;
   kiss_fft_s32_cpx scratch[5];
   kiss_fft_s32_cpx epi3;
-
   epi3 = st->twiddles[fstride * m];
 
   tw1 = tw2 = st->twiddles;
@@ -158,7 +134,6 @@ kf_bfly5 (kiss_fft_s32_cpx * Fout,
   kiss_fft_s32_cpx *twiddles = st->twiddles;
   kiss_fft_s32_cpx *tw;
   kiss_fft_s32_cpx ya, yb;
-
   ya = twiddles[fstride * m];
   yb = twiddles[fstride * 2 * m];
 
@@ -229,38 +204,40 @@ kf_bfly_generic (kiss_fft_s32_cpx * Fout,
   kiss_fft_s32_cpx t;
   int Norig = st->nfft;
 
-  CHECKBUF (scratchbuf, nscratchbuf, p);
+  kiss_fft_s32_cpx *scratch =
+      (kiss_fft_s32_cpx *) KISS_FFT_S32_TMP_ALLOC (sizeof (kiss_fft_s32_cpx) *
+      p);
 
   for (u = 0; u < m; ++u) {
     k = u;
     for (q1 = 0; q1 < p; ++q1) {
-      scratchbuf[q1] = Fout[k];
-      C_FIXDIV (scratchbuf[q1], p);
+      scratch[q1] = Fout[k];
+      C_FIXDIV (scratch[q1], p);
       k += m;
     }
 
     k = u;
     for (q1 = 0; q1 < p; ++q1) {
       int twidx = 0;
-
-      Fout[k] = scratchbuf[0];
+      Fout[k] = scratch[0];
       for (q = 1; q < p; ++q) {
         twidx += fstride * k;
         if (twidx >= Norig)
           twidx -= Norig;
-        C_MUL (t, scratchbuf[q], twiddles[twidx]);
+        C_MUL (t, scratch[q], twiddles[twidx]);
         C_ADDTO (Fout[k], t);
       }
       k += m;
     }
   }
+  KISS_FFT_S32_TMP_FREE (scratch);
 }
 
 static void
 kf_work (kiss_fft_s32_cpx * Fout,
     const kiss_fft_s32_cpx * f,
-    const size_t fstride,
-    int in_stride, int *factors, const kiss_fft_s32_cfg st)
+    const size_t fstride, int in_stride, int *factors,
+    const kiss_fft_s32_cfg st)
 {
   kiss_fft_s32_cpx *Fout_beg = Fout;
   const int p = *factors++;     /* the radix  */
@@ -270,7 +247,7 @@ kf_work (kiss_fft_s32_cpx * Fout,
 #ifdef _OPENMP
   // use openmp extensions at the 
   // top-level (not recursive)
-  if (fstride == 1) {
+  if (fstride == 1 && p <= 5 && m != 1) {
     int k;
 
     // execute the p different work units in different threads
@@ -348,7 +325,6 @@ kf_factor (int n, int *facbuf)
 {
   int p = 4;
   double floor_sqrt;
-
   floor_sqrt = floor (sqrt ((double) n));
 
   /*factor out powers of 4, powers of 2, then any remaining primes */
@@ -379,7 +355,7 @@ kf_factor (int n, int *facbuf)
  * User-callable function to allocate all necessary storage space for the fft.
  *
  * The return value is a contiguous block of memory, allocated with malloc.  As such,
- * It can be freed with free(), rather than a kiss_fft-specific function.
+ * It can be freed with free(), rather than a kiss_fft_s32-specific function.
  * */
 kiss_fft_s32_cfg
 kiss_fft_s32_alloc (int nfft, int inverse_fft, void *mem, size_t * lenmem)
@@ -397,7 +373,6 @@ kiss_fft_s32_alloc (int nfft, int inverse_fft, void *mem, size_t * lenmem)
   }
   if (st) {
     int i;
-
     st->nfft = nfft;
     st->inverse = inverse_fft;
 
@@ -405,7 +380,6 @@ kiss_fft_s32_alloc (int nfft, int inverse_fft, void *mem, size_t * lenmem)
       const double pi =
           3.141592653589793238462643383279502884197169399375105820974944;
       double phase = -2 * pi * i / nfft;
-
       if (st->inverse)
         phase *= -1;
       kf_cexp (st->twiddles + i, phase);
@@ -417,16 +391,19 @@ kiss_fft_s32_alloc (int nfft, int inverse_fft, void *mem, size_t * lenmem)
 }
 
 
-
-
 void
 kiss_fft_s32_stride (kiss_fft_s32_cfg st, const kiss_fft_s32_cpx * fin,
     kiss_fft_s32_cpx * fout, int in_stride)
 {
   if (fin == fout) {
-    CHECKBUF (tmpbuf, ntmpbuf, st->nfft);
+    //NOTE: this is not really an in-place FFT algorithm.
+    //It just performs an out-of-place FFT into a temp buffer
+    kiss_fft_s32_cpx *tmpbuf =
+        (kiss_fft_s32_cpx *) KISS_FFT_S32_TMP_ALLOC (sizeof (kiss_fft_s32_cpx) *
+        st->nfft);
     kf_work (tmpbuf, fin, 1, in_stride, st->factors, st);
     memcpy (fout, tmpbuf, sizeof (kiss_fft_s32_cpx) * st->nfft);
+    KISS_FFT_S32_TMP_FREE (tmpbuf);
   } else {
     kf_work (fout, fin, 1, in_stride, st->factors, st);
   }
@@ -440,18 +417,10 @@ kiss_fft_s32 (kiss_fft_s32_cfg cfg, const kiss_fft_s32_cpx * fin,
 }
 
 
-/* not really necessary to call, but if someone is doing in-place ffts, they may want to free the 
-   buffers from CHECKBUF
- */
 void
 kiss_fft_s32_cleanup (void)
 {
-  free (scratchbuf);
-  scratchbuf = NULL;
-  nscratchbuf = 0;
-  free (tmpbuf);
-  tmpbuf = NULL;
-  ntmpbuf = 0;
+  // nothing needed any more
 }
 
 int
@@ -459,7 +428,6 @@ kiss_fft_s32_next_fast_size (int n)
 {
   while (1) {
     int m = n;
-
     while ((m % 2) == 0)
       m /= 2;
     while ((m % 3) == 0)
diff --git a/gst-libs/gst/fft/kiss_fft_s32.h b/gst-libs/gst/fft/kiss_fft_s32.h
index ad2f2b086..ff3e8d22a 100644
--- a/gst-libs/gst/fft/kiss_fft_s32.h
+++ b/gst-libs/gst/fft/kiss_fft_s32.h
@@ -1,18 +1,19 @@
+/*
+ *  Copyright (c) 2003-2010, Mark Borgerding. All rights reserved.
+ *  This file is part of KISS FFT - https://github.com/mborgerding/kissfft
+ *
+ *  SPDX-License-Identifier: BSD-3-Clause
+ *  See COPYING file for more information.
+ */
+
 #ifndef KISS_FFT_S32_H
 #define KISS_FFT_S32_H
 
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#ifdef HAVE_STDINT_H
-#include <stdint.h>
-#endif
-
 #include <stdlib.h>
 #include <stdio.h>
 #include <math.h>
 #include <string.h>
+#include <stdint.h>
 #include <glib.h>
 
 #ifdef __cplusplus
@@ -28,13 +29,14 @@ extern "C" {
  -- a command-line utility to perform ffts
  -- a command-line utility to perform fast-convolution filtering
 
- Then see kfc.h kiss_fftr.h kiss_fftnd.h fftutil.c kiss_fastfir.c
+ Then see kfc.h kiss_fftr_s32.h kiss_fft_s32nd.h fftutil.c kiss_fastfir.c
   in the tools/ directory.
 */
 
 #define KISS_FFT_S32_MALLOC g_malloc
-
+#define KISS_FFT_S32_FREE g_free
 #define kiss_fft_s32_scalar int32_t
+#define FIXED_POINT 32
 
 typedef struct {
     kiss_fft_s32_scalar r;
@@ -69,7 +71,7 @@ typedef struct kiss_fft_s32_state* kiss_fft_s32_cfg;
 kiss_fft_s32_cfg kiss_fft_s32_alloc(int nfft,int inverse_fft,void * mem,size_t * lenmem); 
 
 /*
- * kiss_fft(cfg,in_out_buf)
+ * kiss_fft_s32(cfg,in_out_buf)
  *
  * Perform an FFT on a complex input buffer.
  * for a forward FFT,
@@ -87,7 +89,7 @@ void kiss_fft_s32_stride(kiss_fft_s32_cfg cfg,const kiss_fft_s32_cpx *fin,kiss_f
 
 /* If kiss_fft_s32_alloc allocated a buffer, it is one contiguous 
    buffer and can be simply free()d when no longer needed*/
-#define kiss_fft_s32_free g_free
+#define kiss_fft_s32_free KISS_FFT_S32_FREE
 
 /*
  Cleans up some memory that gets managed internally. Not necessary to call, but it might clean up 
@@ -102,8 +104,8 @@ void kiss_fft_s32_cleanup(void);
 int kiss_fft_s32_next_fast_size(int n);
 
 /* for real ffts, we need an even size */
-#define kiss_fftr_next_fast_size_real(n) \
-        (kiss_fft_next_fast_size( ((n)+1)>>1)<<1)
+#define kiss_fftr_s32_next_fast_size_real(n) \
+        (kiss_fft_s32_next_fast_size( ((n)+1)>>1)<<1)
 
 #ifdef __cplusplus
 } 
diff --git a/gst-libs/gst/fft/kiss_fftr_f32.c b/gst-libs/gst/fft/kiss_fftr_f32.c
index 20998113d..6ef981cf2 100644
--- a/gst-libs/gst/fft/kiss_fftr_f32.c
+++ b/gst-libs/gst/fft/kiss_fftr_f32.c
@@ -1,19 +1,10 @@
 /*
-Copyright (c) 2003-2004, Mark Borgerding
-
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
-    * Neither the author nor the names of any contributors may be used to endorse or promote products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
+ *  Copyright (c) 2003-2004, Mark Borgerding. All rights reserved.
+ *  This file is part of KISS FFT - https://github.com/mborgerding/kissfft
+ *
+ *  SPDX-License-Identifier: BSD-3-Clause
+ *  See COPYING file for more information.
+ */
 
 #include "kiss_fftr_f32.h"
 #include "_kiss_fft_guts_f32.h"
@@ -24,7 +15,7 @@ struct kiss_fftr_f32_state
   kiss_fft_f32_cpx *tmpbuf;
   kiss_fft_f32_cpx *super_twiddles;
 #ifdef USE_SIMD
-  long pad;
+  void *pad;
 #endif
 };
 
@@ -33,17 +24,15 @@ kiss_fftr_f32_alloc (int nfft, int inverse_fft, void *mem, size_t * lenmem)
 {
   int i;
   kiss_fftr_f32_cfg st = NULL;
-  size_t subsize, memneeded;
+  size_t subsize = 0, memneeded;
 
-  if (nfft & 1) {
-    fprintf (stderr, "Real FFT optimization must be even.\n");
-    return NULL;
-  }
+  g_return_val_if_fail ((nfft & 1) == 0, NULL);
   nfft >>= 1;
 
   kiss_fft_f32_alloc (nfft, inverse_fft, NULL, &subsize);
-  memneeded = ALIGN_STRUCT (sizeof (struct kiss_fftr_f32_state))
-      + ALIGN_STRUCT (subsize) + sizeof (kiss_fft_f32_cpx) * (nfft * 3 / 2);
+  memneeded =
+      ALIGN_STRUCT (sizeof (struct kiss_fftr_f32_state)) +
+      ALIGN_STRUCT (subsize) + sizeof (kiss_fft_f32_cpx) * (nfft * 3 / 2);
 
   if (lenmem == NULL) {
     st = (kiss_fftr_f32_cfg) KISS_FFT_F32_MALLOC (memneeded);
@@ -64,7 +53,6 @@ kiss_fftr_f32_alloc (int nfft, int inverse_fft, void *mem, size_t * lenmem)
   for (i = 0; i < nfft / 2; ++i) {
     double phase =
         -3.14159265358979323846264338327 * ((double) (i + 1) / nfft + .5);
-
     if (inverse_fft)
       phase *= -1;
     kf_cexp (st->super_twiddles + i, phase);
@@ -80,8 +68,7 @@ kiss_fftr_f32 (kiss_fftr_f32_cfg st, const kiss_fft_f32_scalar * timedata,
   int k, ncfft;
   kiss_fft_f32_cpx fpnk, fpk, f1k, f2k, tw, tdc;
 
-  /* kiss fft usage error: improper alloc */
-  g_return_if_fail (st->substate->inverse == 0);
+  g_return_if_fail (!st->substate->inverse);
 
   ncfft = st->substate->nfft;
 
@@ -135,8 +122,7 @@ kiss_fftri_f32 (kiss_fftr_f32_cfg st, const kiss_fft_f32_cpx * freqdata,
   /* input buffer timedata is stored row-wise */
   int k, ncfft;
 
-  /* kiss fft usage error: improper alloc */
-  g_return_if_fail (st->substate->inverse != 0);
+  g_return_if_fail (st->substate->inverse);
 
   ncfft = st->substate->nfft;
 
@@ -146,7 +132,6 @@ kiss_fftri_f32 (kiss_fftr_f32_cfg st, const kiss_fft_f32_cpx * freqdata,
 
   for (k = 1; k <= ncfft / 2; ++k) {
     kiss_fft_f32_cpx fk, fnkc, fek, fok, tmp;
-
     fk = freqdata[k];
     fnkc.r = freqdata[ncfft - k].r;
     fnkc.i = -freqdata[ncfft - k].i;
diff --git a/gst-libs/gst/fft/kiss_fftr_f32.h b/gst-libs/gst/fft/kiss_fftr_f32.h
index 91f2085e5..da21245f5 100644
--- a/gst-libs/gst/fft/kiss_fftr_f32.h
+++ b/gst-libs/gst/fft/kiss_fftr_f32.h
@@ -1,5 +1,13 @@
-#ifndef KISS_FTR_F32_H
-#define KISS_FTR_F32_H
+/*
+ *  Copyright (c) 2003-2004, Mark Borgerding. All rights reserved.
+ *  This file is part of KISS FFT - https://github.com/mborgerding/kissfft
+ *
+ *  SPDX-License-Identifier: BSD-3-Clause
+ *  See COPYING file for more information.
+ */
+
+#ifndef KISS_FTR_H
+#define KISS_FTR_H
 
 #include "kiss_fft_f32.h"
 #ifdef __cplusplus
@@ -38,7 +46,7 @@ void kiss_fftri_f32(kiss_fftr_f32_cfg cfg,const kiss_fft_f32_cpx *freqdata,kiss_
  output timedata has nfft scalar points
 */
 
-#define kiss_fftr_f32_free free
+#define kiss_fftr_f32_free KISS_FFT_F32_FREE
 
 #ifdef __cplusplus
 }
diff --git a/gst-libs/gst/fft/kiss_fftr_f64.c b/gst-libs/gst/fft/kiss_fftr_f64.c
index 0a6c282b5..7ab406e4f 100644
--- a/gst-libs/gst/fft/kiss_fftr_f64.c
+++ b/gst-libs/gst/fft/kiss_fftr_f64.c
@@ -1,19 +1,10 @@
 /*
-Copyright (c) 2003-2004, Mark Borgerding
-
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
-    * Neither the author nor the names of any contributors may be used to endorse or promote products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
+ *  Copyright (c) 2003-2004, Mark Borgerding. All rights reserved.
+ *  This file is part of KISS FFT - https://github.com/mborgerding/kissfft
+ *
+ *  SPDX-License-Identifier: BSD-3-Clause
+ *  See COPYING file for more information.
+ */
 
 #include "kiss_fftr_f64.h"
 #include "_kiss_fft_guts_f64.h"
@@ -24,7 +15,7 @@ struct kiss_fftr_f64_state
   kiss_fft_f64_cpx *tmpbuf;
   kiss_fft_f64_cpx *super_twiddles;
 #ifdef USE_SIMD
-  long pad;
+  void *pad;
 #endif
 };
 
@@ -33,18 +24,15 @@ kiss_fftr_f64_alloc (int nfft, int inverse_fft, void *mem, size_t * lenmem)
 {
   int i;
   kiss_fftr_f64_cfg st = NULL;
-  size_t subsize, memneeded;
+  size_t subsize = 0, memneeded;
 
-  if (nfft & 1) {
-    fprintf (stderr, "Real FFT optimization must be even.\n");
-    return NULL;
-  }
+  g_return_val_if_fail ((nfft & 1) == 0, NULL);
   nfft >>= 1;
 
   kiss_fft_f64_alloc (nfft, inverse_fft, NULL, &subsize);
-  memneeded = ALIGN_STRUCT (sizeof (struct kiss_fftr_f64_state))
-      + ALIGN_STRUCT (subsize)
-      + sizeof (kiss_fft_f64_cpx) * (nfft * 3 / 2);
+  memneeded =
+      ALIGN_STRUCT (sizeof (struct kiss_fftr_f64_state)) +
+      ALIGN_STRUCT (subsize) + sizeof (kiss_fft_f64_cpx) * (nfft * 3 / 2);
 
   if (lenmem == NULL) {
     st = (kiss_fftr_f64_cfg) KISS_FFT_F64_MALLOC (memneeded);
@@ -65,7 +53,6 @@ kiss_fftr_f64_alloc (int nfft, int inverse_fft, void *mem, size_t * lenmem)
   for (i = 0; i < nfft / 2; ++i) {
     double phase =
         -3.14159265358979323846264338327 * ((double) (i + 1) / nfft + .5);
-
     if (inverse_fft)
       phase *= -1;
     kf_cexp (st->super_twiddles + i, phase);
@@ -81,8 +68,7 @@ kiss_fftr_f64 (kiss_fftr_f64_cfg st, const kiss_fft_f64_scalar * timedata,
   int k, ncfft;
   kiss_fft_f64_cpx fpnk, fpk, f1k, f2k, tw, tdc;
 
-  /* kiss fft usage error: improper alloc */
-  g_return_if_fail (st->substate->inverse == 0);
+  g_return_if_fail (!st->substate->inverse);
 
   ncfft = st->substate->nfft;
 
@@ -136,8 +122,7 @@ kiss_fftri_f64 (kiss_fftr_f64_cfg st, const kiss_fft_f64_cpx * freqdata,
   /* input buffer timedata is stored row-wise */
   int k, ncfft;
 
-  /* kiss fft usage error: improper alloc */
-  g_return_if_fail (st->substate->inverse != 0);
+  g_return_if_fail (st->substate->inverse);
 
   ncfft = st->substate->nfft;
 
@@ -147,7 +132,6 @@ kiss_fftri_f64 (kiss_fftr_f64_cfg st, const kiss_fft_f64_cpx * freqdata,
 
   for (k = 1; k <= ncfft / 2; ++k) {
     kiss_fft_f64_cpx fk, fnkc, fek, fok, tmp;
-
     fk = freqdata[k];
     fnkc.r = freqdata[ncfft - k].r;
     fnkc.i = -freqdata[ncfft - k].i;
diff --git a/gst-libs/gst/fft/kiss_fftr_f64.h b/gst-libs/gst/fft/kiss_fftr_f64.h
index 0b35cb6ad..5725030db 100644
--- a/gst-libs/gst/fft/kiss_fftr_f64.h
+++ b/gst-libs/gst/fft/kiss_fftr_f64.h
@@ -1,5 +1,13 @@
-#ifndef KISS_FTR_F64_H
-#define KISS_FTR_F64_H
+/*
+ *  Copyright (c) 2003-2004, Mark Borgerding. All rights reserved.
+ *  This file is part of KISS FFT - https://github.com/mborgerding/kissfft
+ *
+ *  SPDX-License-Identifier: BSD-3-Clause
+ *  See COPYING file for more information.
+ */
+
+#ifndef KISS_FTR_H
+#define KISS_FTR_H
 
 #include "kiss_fft_f64.h"
 #ifdef __cplusplus
@@ -38,7 +46,7 @@ void kiss_fftri_f64(kiss_fftr_f64_cfg cfg,const kiss_fft_f64_cpx *freqdata,kiss_
  output timedata has nfft scalar points
 */
 
-#define kiss_fftr_f64_free free
+#define kiss_fftr_f64_free KISS_FFT_F64_FREE
 
 #ifdef __cplusplus
 }
diff --git a/gst-libs/gst/fft/kiss_fftr_s16.c b/gst-libs/gst/fft/kiss_fftr_s16.c
index ba1b74353..00d1aa3b3 100644
--- a/gst-libs/gst/fft/kiss_fftr_s16.c
+++ b/gst-libs/gst/fft/kiss_fftr_s16.c
@@ -1,19 +1,10 @@
 /*
-Copyright (c) 2003-2004, Mark Borgerding
-
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
-    * Neither the author nor the names of any contributors may be used to endorse or promote products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
+ *  Copyright (c) 2003-2004, Mark Borgerding. All rights reserved.
+ *  This file is part of KISS FFT - https://github.com/mborgerding/kissfft
+ *
+ *  SPDX-License-Identifier: BSD-3-Clause
+ *  See COPYING file for more information.
+ */
 
 #include "kiss_fftr_s16.h"
 #include "_kiss_fft_guts_s16.h"
@@ -24,7 +15,7 @@ struct kiss_fftr_s16_state
   kiss_fft_s16_cpx *tmpbuf;
   kiss_fft_s16_cpx *super_twiddles;
 #ifdef USE_SIMD
-  long pad;
+  void *pad;
 #endif
 };
 
@@ -33,18 +24,15 @@ kiss_fftr_s16_alloc (int nfft, int inverse_fft, void *mem, size_t * lenmem)
 {
   int i;
   kiss_fftr_s16_cfg st = NULL;
-  size_t subsize, memneeded;
+  size_t subsize = 0, memneeded;
 
-  if (nfft & 1) {
-    fprintf (stderr, "Real FFT optimization must be even.\n");
-    return NULL;
-  }
+  g_return_val_if_fail ((nfft & 1) == 0, NULL);
   nfft >>= 1;
 
   kiss_fft_s16_alloc (nfft, inverse_fft, NULL, &subsize);
-  memneeded = ALIGN_STRUCT (sizeof (struct kiss_fftr_s16_state))
-      + ALIGN_STRUCT (subsize)
-      + sizeof (kiss_fft_s16_cpx) * (nfft * 3 / 2);
+  memneeded =
+      ALIGN_STRUCT (sizeof (struct kiss_fftr_s16_state)) +
+      ALIGN_STRUCT (subsize) + sizeof (kiss_fft_s16_cpx) * (nfft * 3 / 2);
 
   if (lenmem == NULL) {
     st = (kiss_fftr_s16_cfg) KISS_FFT_S16_MALLOC (memneeded);
@@ -65,7 +53,6 @@ kiss_fftr_s16_alloc (int nfft, int inverse_fft, void *mem, size_t * lenmem)
   for (i = 0; i < nfft / 2; ++i) {
     double phase =
         -3.14159265358979323846264338327 * ((double) (i + 1) / nfft + .5);
-
     if (inverse_fft)
       phase *= -1;
     kf_cexp (st->super_twiddles + i, phase);
@@ -81,8 +68,7 @@ kiss_fftr_s16 (kiss_fftr_s16_cfg st, const kiss_fft_s16_scalar * timedata,
   int k, ncfft;
   kiss_fft_s16_cpx fpnk, fpk, f1k, f2k, tw, tdc;
 
-  /* kiss fft usage error: improper alloc */
-  g_return_if_fail (st->substate->inverse == 0);
+  g_return_if_fail (!st->substate->inverse);
 
   ncfft = st->substate->nfft;
 
@@ -136,8 +122,7 @@ kiss_fftri_s16 (kiss_fftr_s16_cfg st, const kiss_fft_s16_cpx * freqdata,
   /* input buffer timedata is stored row-wise */
   int k, ncfft;
 
-  /* kiss fft usage error: improper alloc */
-  g_return_if_fail (st->substate->inverse != 0);
+  g_return_if_fail (st->substate->inverse);
 
   ncfft = st->substate->nfft;
 
@@ -147,7 +132,6 @@ kiss_fftri_s16 (kiss_fftr_s16_cfg st, const kiss_fft_s16_cpx * freqdata,
 
   for (k = 1; k <= ncfft / 2; ++k) {
     kiss_fft_s16_cpx fk, fnkc, fek, fok, tmp;
-
     fk = freqdata[k];
     fnkc.r = freqdata[ncfft - k].r;
     fnkc.i = -freqdata[ncfft - k].i;
diff --git a/gst-libs/gst/fft/kiss_fftr_s16.h b/gst-libs/gst/fft/kiss_fftr_s16.h
index 20bc9ef57..d3ee40376 100644
--- a/gst-libs/gst/fft/kiss_fftr_s16.h
+++ b/gst-libs/gst/fft/kiss_fftr_s16.h
@@ -1,5 +1,13 @@
-#ifndef KISS_FTR_S16_H
-#define KISS_FTR_S16_H
+/*
+ *  Copyright (c) 2003-2004, Mark Borgerding. All rights reserved.
+ *  This file is part of KISS FFT - https://github.com/mborgerding/kissfft
+ *
+ *  SPDX-License-Identifier: BSD-3-Clause
+ *  See COPYING file for more information.
+ */
+
+#ifndef KISS_FTR_H
+#define KISS_FTR_H
 
 #include "kiss_fft_s16.h"
 #ifdef __cplusplus
@@ -38,7 +46,7 @@ void kiss_fftri_s16(kiss_fftr_s16_cfg cfg,const kiss_fft_s16_cpx *freqdata,kiss_
  output timedata has nfft scalar points
 */
 
-#define kiss_fftr_s16_free free
+#define kiss_fftr_s16_free KISS_FFT_S16_FREE
 
 #ifdef __cplusplus
 }
diff --git a/gst-libs/gst/fft/kiss_fftr_s32.c b/gst-libs/gst/fft/kiss_fftr_s32.c
index 81e9393d3..f4c9fc7f1 100644
--- a/gst-libs/gst/fft/kiss_fftr_s32.c
+++ b/gst-libs/gst/fft/kiss_fftr_s32.c
@@ -1,19 +1,10 @@
 /*
-Copyright (c) 2003-2004, Mark Borgerding
-
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
-    * Neither the author nor the names of any contributors may be used to endorse or promote products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
+ *  Copyright (c) 2003-2004, Mark Borgerding. All rights reserved.
+ *  This file is part of KISS FFT - https://github.com/mborgerding/kissfft
+ *
+ *  SPDX-License-Identifier: BSD-3-Clause
+ *  See COPYING file for more information.
+ */
 
 #include "kiss_fftr_s32.h"
 #include "_kiss_fft_guts_s32.h"
@@ -24,7 +15,7 @@ struct kiss_fftr_s32_state
   kiss_fft_s32_cpx *tmpbuf;
   kiss_fft_s32_cpx *super_twiddles;
 #ifdef USE_SIMD
-  long pad;
+  void *pad;
 #endif
 };
 
@@ -33,18 +24,15 @@ kiss_fftr_s32_alloc (int nfft, int inverse_fft, void *mem, size_t * lenmem)
 {
   int i;
   kiss_fftr_s32_cfg st = NULL;
-  size_t subsize, memneeded;
+  size_t subsize = 0, memneeded;
 
-  if (nfft & 1) {
-    fprintf (stderr, "Real FFT optimization must be even.\n");
-    return NULL;
-  }
+  g_return_val_if_fail ((nfft & 1) == 0, NULL);
   nfft >>= 1;
 
   kiss_fft_s32_alloc (nfft, inverse_fft, NULL, &subsize);
-  memneeded = ALIGN_STRUCT (sizeof (struct kiss_fftr_s32_state))
-      + ALIGN_STRUCT (subsize)
-      + sizeof (kiss_fft_s32_cpx) * (nfft * 3 / 2);
+  memneeded =
+      ALIGN_STRUCT (sizeof (struct kiss_fftr_s32_state)) +
+      ALIGN_STRUCT (subsize) + sizeof (kiss_fft_s32_cpx) * (nfft * 3 / 2);
 
   if (lenmem == NULL) {
     st = (kiss_fftr_s32_cfg) KISS_FFT_S32_MALLOC (memneeded);
@@ -65,7 +53,6 @@ kiss_fftr_s32_alloc (int nfft, int inverse_fft, void *mem, size_t * lenmem)
   for (i = 0; i < nfft / 2; ++i) {
     double phase =
         -3.14159265358979323846264338327 * ((double) (i + 1) / nfft + .5);
-
     if (inverse_fft)
       phase *= -1;
     kf_cexp (st->super_twiddles + i, phase);
@@ -81,8 +68,7 @@ kiss_fftr_s32 (kiss_fftr_s32_cfg st, const kiss_fft_s32_scalar * timedata,
   int k, ncfft;
   kiss_fft_s32_cpx fpnk, fpk, f1k, f2k, tw, tdc;
 
-  /* kiss fft usage error: improper alloc */
-  g_return_if_fail (st->substate->inverse == 0);
+  g_return_if_fail (!st->substate->inverse);
 
   ncfft = st->substate->nfft;
 
@@ -136,8 +122,7 @@ kiss_fftri_s32 (kiss_fftr_s32_cfg st, const kiss_fft_s32_cpx * freqdata,
   /* input buffer timedata is stored row-wise */
   int k, ncfft;
 
-  /* kiss fft usage error: improper alloc */
-  g_return_if_fail (st->substate->inverse != 0);
+  g_return_if_fail (st->substate->inverse);
 
   ncfft = st->substate->nfft;
 
@@ -147,7 +132,6 @@ kiss_fftri_s32 (kiss_fftr_s32_cfg st, const kiss_fft_s32_cpx * freqdata,
 
   for (k = 1; k <= ncfft / 2; ++k) {
     kiss_fft_s32_cpx fk, fnkc, fek, fok, tmp;
-
     fk = freqdata[k];
     fnkc.r = freqdata[ncfft - k].r;
     fnkc.i = -freqdata[ncfft - k].i;
diff --git a/gst-libs/gst/fft/kiss_fftr_s32.h b/gst-libs/gst/fft/kiss_fftr_s32.h
index 8e8fecb13..723d5c9d0 100644
--- a/gst-libs/gst/fft/kiss_fftr_s32.h
+++ b/gst-libs/gst/fft/kiss_fftr_s32.h
@@ -1,5 +1,13 @@
-#ifndef KISS_FTR_S32_H
-#define KISS_FTR_S32_H
+/*
+ *  Copyright (c) 2003-2004, Mark Borgerding. All rights reserved.
+ *  This file is part of KISS FFT - https://github.com/mborgerding/kissfft
+ *
+ *  SPDX-License-Identifier: BSD-3-Clause
+ *  See COPYING file for more information.
+ */
+
+#ifndef KISS_FTR_H
+#define KISS_FTR_H
 
 #include "kiss_fft_s32.h"
 #ifdef __cplusplus
@@ -38,7 +46,7 @@ void kiss_fftri_s32(kiss_fftr_s32_cfg cfg,const kiss_fft_s32_cpx *freqdata,kiss_
  output timedata has nfft scalar points
 */
 
-#define kiss_fftr_s32_free free
+#define kiss_fftr_s32_free KISS_FFT_S32_FREE
 
 #ifdef __cplusplus
 }
diff --git a/gst-libs/gst/fft/kiss_version b/gst-libs/gst/fft/kiss_version
index c55188bb2..1053e7cf6 100644
--- a/gst-libs/gst/fft/kiss_version
+++ b/gst-libs/gst/fft/kiss_version
@@ -1,4 +1,5 @@
-Based on Kiss FFT version 1.2.6. http://kissfft.sourceforge.net
+Based on Kiss FFT version 1efe72041e00868c3c71eaf569343ee132a4fbb9
+https://github.com/mborgerding/kissfft
 
 Only changes are limitation to one data type for each version in
 kiss_fft.h and _kiss_fft_guts.h.
-- 
2.24.1

