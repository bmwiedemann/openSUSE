From b40f43e9fd3e523c0c4b50b0dcd8ca743cb6b9a7 Mon Sep 17 00:00:00 2001
From: Tom de Vries <tdevries@suse.de>
Date: Fri, 17 Feb 2023 15:33:18 +0100
Subject: [PATCH] [gdb/testsuite] Simplify gdb.arch/amd64-disp-step-avx.exp

On SLE-11, with glibc 2.11.3, I run into:
...
(gdb) PASS: gdb.arch/amd64-disp-step-avx.exp: vex3: \
  var128 has expected value after
continue^M
Continuing.^M
^M
Program received signal SIGSEGV, Segmentation fault.^M
0x0000000000400283 in _exit (status=0) at \
  ../sysdeps/unix/sysv/linux/_exit.c:33^M
33      ../sysdeps/unix/sysv/linux/_exit.c: No such file or directory.^M
(gdb) FAIL: gdb.arch/amd64-disp-step-avx.exp: \
  continue until exit at amd64-disp-step-avx
...

This is not related to gdb, we get the same result by just running the exec.

The problem is that the test-case:
- calls glibc's _exit, and
- uses -nostartfiles -static, putting the burden for any necessary
  initialization for calling glibc's _exit on the test-case itself.

So, when we get to the second insn in _exit:
...
000000000040acb0 <_exit>:
  40acb0:       48 63 d7                movslq %edi,%rdx
  40acb3:       64 4c 8b 14 25 00 00    mov    %fs:0x0,%r10
...
no glibc-related initialization is done, and we run into the segfault.

Adding this (borrowed from __libc_start_main) in _start in the .S file is
sufficient to fix it:
...
         .rept 200
         nop
+        call __pthread_initialize_minimal
         .endr
...
But that already doesn't compile with say glibc 2.31, and regardless I think
this sort of fix is too fragile.

We could of course fix this by simply not running to exit.  But ideally we'd
have an exec that doesn't segfault when you just run it.

Alternatively, we could hand-code an _exit syscall and bypass glibc
all together.  But I'd rather fix this in a way that simplifies the test-case.

Taking a step back, the -nostartfiles -static was added to address that the
xmm registers were not zero at main (which AFAICT is a valid thing to happen).

[ The change itself silently broke the test-case, needing further fixing by
commit 40310f30a51 ("gdb: make gdb.arch/amd64-disp-step-avx.exp actually test
displaced stepping"). ]

Instead, simplify things by reverting to the original situation:
- no -nostartfiles -static compilation flags,
- no _start in the .S file,
- use exit instead of _exit in the .S file,
and fix the original problem by setting the xmm registers to zero rather than
checking that they're zero.

Now that we're no longer forcing -static, add nopie to the flags to prevent
compilation failure with target board unix/-fPIE/-pie.

Tested on x86_64-linux.

PR testsuite/30132
Bug: https://sourceware.org/bugzilla/show_bug.cgi?id=30132
---
 gdb/testsuite/gdb.arch/amd64-disp-step-avx.S   | 12 ++----------
 gdb/testsuite/gdb.arch/amd64-disp-step-avx.exp | 14 ++++----------
 2 files changed, 6 insertions(+), 20 deletions(-)

diff --git a/gdb/testsuite/gdb.arch/amd64-disp-step-avx.S b/gdb/testsuite/gdb.arch/amd64-disp-step-avx.S
index 924deef224f..b39ee9f6567 100644
--- a/gdb/testsuite/gdb.arch/amd64-disp-step-avx.S
+++ b/gdb/testsuite/gdb.arch/amd64-disp-step-avx.S
@@ -19,15 +19,7 @@
    instructions.  */
 
 	.text
-
-	.global _start,main
-_start:
-	# The area at _start is used as the displaced stepping buffer.  Put
-	# more than enough nop instructions so that the instructions under test
-	# below don't conflict with it.
-	.rept 200
-	nop
-	.endr
+	.global main
 main:
         nop
 
@@ -66,7 +58,7 @@ ro_var:
 
 done:
 	mov $0,%rdi
-	call _exit
+	call exit
 	hlt
 
 /* RIP-relative data for VEX3 test above.  */
diff --git a/gdb/testsuite/gdb.arch/amd64-disp-step-avx.exp b/gdb/testsuite/gdb.arch/amd64-disp-step-avx.exp
index a64c85bc0e9..e6bdc3c242f 100644
--- a/gdb/testsuite/gdb.arch/amd64-disp-step-avx.exp
+++ b/gdb/testsuite/gdb.arch/amd64-disp-step-avx.exp
@@ -30,9 +30,7 @@ if { ![have_avx] } {
 
 standard_testfile .S
 
-set options [list debug \
-		 additional_flags=-static \
-		 additional_flags=-nostartfiles]
+set options [list debug nopie]
 if { [prepare_for_testing "failed to prepare" ${testfile} ${srcfile} $options] } {
     return -1
 }
@@ -111,14 +109,10 @@ proc disp_step_func { func } {
 
 # Test a VEX2-encoded RIP-relative instruction.
 with_test_prefix "vex2" {
-    # This test writes to the 'xmm0' register.  As the test is
-    # statically linked, we know that the XMM registers should all
-    # have the default value of 0 at this point in time.  We're about
-    # to run an AVX instruction that will modify $xmm0, but lets first
-    # confirm that all XMM registers are 0.
+    # Initialize all XMM registers to 0.
     for {set i 0 } { $i < 16 } { incr i } {
-	gdb_test "p /x \$xmm${i}.uint128" " = 0x0" \
-	    "xmm${i} has expected value before"
+	gdb_test_no_output "set \$xmm${i}.uint128 = 0" \
+	    "xmm${i} set to zero"
     }
 
     disp_step_func "test_rip_vex2"

base-commit: 8f25c476588b41f18ef7b026c81a6b415a809930
-- 
2.35.3

