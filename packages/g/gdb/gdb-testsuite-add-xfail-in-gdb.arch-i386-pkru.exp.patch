From 1b89c346a99d89a06d9694ca4d47d040d4eebd5a Mon Sep 17 00:00:00 2001
From: Tom de Vries <tdevries@suse.de>
Date: Tue, 3 Jan 2023 16:41:05 +0100
Subject: [PATCH 02/11] [gdb/testsuite] Add xfail in gdb.arch/i386-pkru.exp

On a x86_64-linux machine with pkru register, I run into:
...
(gdb) PASS: gdb.arch/i386-pkru.exp: set pkru value
info register pkru^M
pkru           0x12345678          305419896^M
(gdb) FAIL: gdb.arch/i386-pkru.exp: read value after setting value
...

This is a regression due to kernel commit e84ba47e313d ("x86/fpu: Hook up PKRU
onto ptrace()").  This is fixed by recent kernel commit 4a804c4f8356
("x86/fpu: Allow PKRU to be (once again) written by ptrace.").

The regression occurs for kernel versions v5.14-rc1 (the first tag containing
the regression) up to but excluding v6.2-rc1 (the first tag containing the fix).

Fix this by adding an xfail for the appropriate kernel versions.

Tested on x86_64-linux.

PR testsuite/29790
Bug: https://sourceware.org/bugzilla/show_bug.cgi?id=29790
---
 gdb/testsuite/gdb.arch/i386-pkru.exp | 45 +++++++++++++++++++++++---
 gdb/testsuite/lib/gdb-utils.exp      | 48 ++++++++++++++++++++++++++++
 2 files changed, 89 insertions(+), 4 deletions(-)

diff --git a/gdb/testsuite/gdb.arch/i386-pkru.exp b/gdb/testsuite/gdb.arch/i386-pkru.exp
index 7724a579631..5fe93db9b4b 100644
--- a/gdb/testsuite/gdb.arch/i386-pkru.exp
+++ b/gdb/testsuite/gdb.arch/i386-pkru.exp
@@ -58,6 +58,26 @@ if { !$supports_pkru } {
     return
 }
 
+# Linux kernel versions 5.14.0 to 6.1.x contain a regression related to writing
+# the PKRU using ptrace, see commit 4a804c4f8356 ("x86/fpu: Allow PKRU to be
+# (once again) written by ptrace.").
+set have_xfail 0
+if { [istarget *-*-linux*] } {
+    set res [remote_exec target "uname -r"]
+    set status [lindex $res 0]
+    set output [lindex $res 1]
+
+    set re ^($decimal)\\.($decimal)\\.($decimal)
+    if { $status == 0
+	 && [regexp $re $output dummy v1 v2 v3] == 1 } {
+	set v [list $v1 $v2 $v3]
+	set have_xfail \
+	    [expr \
+		 [version_compare [list 5 14 0] <= $v] \
+		 && [version_compare $v < [list 6 2 0]]]
+    }
+}
+
 # Test pkru register at startup
 gdb_test "print /x \$pkru" "= $default_pkru_re" "pkru register"
 
@@ -65,11 +85,28 @@ gdb_test "print /x \$pkru" "= $default_pkru_re" "pkru register"
 gdb_breakpoint [ gdb_get_line_number "break here 1" ]
 gdb_continue_to_breakpoint "break here 1" ".*break here 1.*"
 
-gdb_test "info register pkru" ".*pkru.*0x12345678.*" "read pkru register"
-gdb_test "print /x \$pkru = 0x44444444" "= 0x44444444" "set pkru value"
-gdb_test "info register pkru" ".*pkru.*0x44444444.*" "read value after setting value"
+set val1 0x12345678
+gdb_test "info register pkru" ".*pkru.*$val1.*" "read pkru register"
+
+set val2 0x44444444
+gdb_test "print /x \$pkru = $val2" "= $val2" "set pkru value"
+
+set xval $val2
+gdb_test_multiple "info register pkru" "read value after setting value" {
+    -re -wrap ".*pkru.*$val2.*" {
+	pass $gdb_test_name
+    }
+    -re -wrap ".*pkru.*$val1.*" {
+	if { $have_xfail } {
+	    xfail $gdb_test_name
+	} else {
+	    fail $gdb_test_name
+	}
+	set xval $val1
+    }
+}
 
 gdb_breakpoint [ gdb_get_line_number "break here 2" ]
 gdb_continue_to_breakpoint "break here 2" ".*break here 2.*"
 
-gdb_test "print /x rd_value" "= 0x44444444" "variable after reading pkru"
+gdb_test "print /x rd_value" "= $xval" "variable after reading pkru"
diff --git a/gdb/testsuite/lib/gdb-utils.exp b/gdb/testsuite/lib/gdb-utils.exp
index ffdfb75557c..294d0998632 100644
--- a/gdb/testsuite/lib/gdb-utils.exp
+++ b/gdb/testsuite/lib/gdb-utils.exp
@@ -72,3 +72,51 @@ proc style {str style} {
     }
     return "\033\\\[${style}m${str}\033\\\[m"
 }
+
+# Compare the version numbers in L1 to those in L2 using OP, and return
+# 1 if the comparison is true.
+
+proc version_compare { l1 op l2 } {
+    set len [llength $l1]
+    if { $len != [llength $l2] } {
+	error "l2 not the same length as l1"
+    }
+
+    switch -exact $op {
+	"=="    -
+	"<"     {}
+	"<="    { return [expr [version_compare $l1 < $l2] \
+			      || [version_compare $l1 == $l2]]}
+	default { error "unsupported op: $op" }
+    }
+
+    # Handle ops < and ==.
+    set idx 0
+    foreach v1 $l1 {
+	set v2 [lindex $l2 $idx]
+	incr idx
+	set last [expr $len == $idx]
+
+	set cmp [expr $v1 $op $v2]
+	if { $op == "==" } {
+	    if { $cmp } {
+		continue
+	    } else {
+		return 0
+	    }
+	} else {
+	    # $op == "<".
+	    if { $cmp } {
+		return 1
+	    } else {
+		if { !$last && $v1 == $v2 } {
+		    continue
+		}
+		return 0
+	    }
+	}
+    }
+
+    return 1
+}
+
-- 
2.35.3

