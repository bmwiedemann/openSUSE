From FEDORA_PATCHES Mon Sep 17 00:00:00 2001
From: Fedora GDB patches <invalid@email.com>
Date: Fri, 27 Oct 2017 21:07:50 +0200
Subject: gdb-6.3-test-pie-20050107.patch

;; VSYSCALL and PIE
;;=fedoratest

diff --git a/gdb/testsuite/gdb.pie/attach.c b/gdb/testsuite/gdb.pie/attach.c
new file mode 100644
--- /dev/null
+++ b/gdb/testsuite/gdb.pie/attach.c
@@ -0,0 +1,20 @@
+/* This program is intended to be started outside of gdb, and then
+   attached to by gdb.  Thus, it simply spins in a loop.  The loop
+   is exited when & if the variable 'should_exit' is non-zero.  (It
+   is initialized to zero in this program, so the loop will never
+   exit unless/until gdb sets the variable to non-zero.)
+   */
+#include <stdio.h>
+
+int  should_exit = 0;
+
+int main ()
+{
+  int  local_i = 0;
+
+  while (! should_exit)
+    {
+      local_i++;
+    }
+  return 0;
+}
diff --git a/gdb/testsuite/gdb.pie/attach.exp b/gdb/testsuite/gdb.pie/attach.exp
new file mode 100644
--- /dev/null
+++ b/gdb/testsuite/gdb.pie/attach.exp
@@ -0,0 +1,416 @@
+#   Copyright 1997, 1999, 2002 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+# On HP-UX 11.0, this test is causing a process running the program
+# "attach" to be left around spinning.  Until we figure out why, I am
+# commenting out the test to avoid polluting tiamat (our 11.0 nightly
+# test machine) with these processes. RT
+#
+# Setting the magic bit in the target app should work.  I added a
+# "kill", and also a test for the R3 register warning.  JB
+if { [istarget "hppa*-*-hpux*"] } {
+    return 0
+}
+
+# are we on a target board
+if [is_remote target] then {
+    return 0
+}
+
+set testfile "attach"
+set srcfile  ${testfile}.c
+set srcfile2 ${testfile}2.c
+set binfile  [standard_output_file ${testfile}]
+set binfile2 [standard_output_file ${testfile}2]
+set escapedbinfile  [string_to_regexp [standard_output_file ${testfile}]]
+set cleanupfile [standard_output_file ${testfile}.awk]
+
+#execute_anywhere "rm -f ${binfile} ${binfile2}"
+remote_exec build "rm -f ${binfile} ${binfile2}"
+# For debugging this test
+#
+#log_user 1
+
+# Clean out any old files from past runs.
+#
+remote_exec build "${cleanupfile}"
+
+# build the first test case
+#
+if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug "additional_flags= -fpie -pie"}] != "" } {
+     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
+}
+
+# Build the in-system-call test
+
+if  { [gdb_compile "${srcdir}/${subdir}/${srcfile2}" "${binfile2}" executable {debug "additional_flags= -fpie -pie"}] != "" } {
+     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
+}
+
+if [get_compiler_info ${binfile}] {
+    return -1
+}
+
+proc do_attach_tests {} {
+   global gdb_prompt
+   global binfile
+   global escapedbinfile
+   global srcfile
+   global testfile
+   global subdir
+   global timeout
+
+   # Start the program running and then wait for a bit, to be sure
+   # that it can be attached to.
+   #
+   set testpid [eval exec $binfile &]
+   exec sleep 2
+
+   # Verify that we cannot attach to nonsense.
+   #
+   send_gdb "attach abc\n"
+   gdb_expect {
+      -re ".*Illegal process-id: abc.*$gdb_prompt $"\
+                      {pass "attach to nonsense is prohibited"}
+      -re "Attaching to.*, process .*couldn't open /proc file.*$gdb_prompt $"\
+                      {
+                        # Response expected from /proc-based systems.
+                        pass "attach to nonsense is prohibited" 
+                      }
+      -re "Attaching to.*$gdb_prompt $"\
+                      {fail "attach to nonsense is prohibited (bogus pid allowed)"}
+      -re "$gdb_prompt $" {fail "attach to nonsense is prohibited"}
+      timeout         {fail "(timeout) attach to nonsense is prohibited"}
+   }
+
+   # Verify that we cannot attach to what appears to be a valid
+   # process ID, but is a process that doesn't exist.  Traditionally,
+   # most systems didn't have a process with ID 0, so we take that as
+   # the default.  However, there are a few exceptions.
+   #
+   set boguspid 0
+   if { [istarget "*-*-*bsd*"] } {
+       # In FreeBSD 5.0, PID 0 is used for "swapper".  Use -1 instead
+       # (which should have the desired effect on any version of
+       # FreeBSD, and probably other *BSD's too).
+       set boguspid -1
+   }
+   send_gdb "attach $boguspid\n"
+   gdb_expect {
+       -re "Attaching to.*, process $boguspid.*No such process.*$gdb_prompt $"\
+	       {
+	   # Response expected on ptrace-based systems (i.e. HP-UX 10.20).
+	   pass "attach to nonexistent process is prohibited"
+       }
+       -re "Attaching to.*, process $boguspid failed.*Hint.*$gdb_prompt $"\
+	       {
+	   # Response expected on ttrace-based systems (i.e. HP-UX 11.0).
+	   pass "attach to nonexistent process is prohibited"
+       }
+       -re "Attaching to.*, process $boguspid.*denied.*$gdb_prompt $"\
+	       {pass "attach to nonexistent process is prohibited"}
+       -re "Attaching to.*, process $boguspid.*not permitted.*$gdb_prompt $"\
+	       {pass "attach to nonexistent process is prohibited"}
+       -re "Attaching to.*, process .*couldn't open /proc file.*$gdb_prompt $"\
+	       {
+	   # Response expected from /proc-based systems.
+	   pass "attach to nonexistent process is prohibited"
+       }
+       -re "$gdb_prompt $" {fail "attach to nonexistent process is prohibited"}
+       timeout {
+	   fail "(timeout) attach to nonexistent process is prohibited"
+       }
+   }
+
+   # Verify that we can attach to the process by first giving its
+   # executable name via the file command, and using attach with
+   # the process ID.
+   #
+   # (Actually, the test system appears to do this automatically
+   # for us.  So, we must also be prepared to be asked if we want
+   # to discard an existing set of symbols.)
+   #
+   send_gdb "file $binfile\n"
+   gdb_expect {
+      -re "Load new symbol table from.*y or n.*$" {
+         send_gdb "y\n"
+         gdb_expect {
+            -re "Reading symbols from $escapedbinfile\.\.\.*done.*$gdb_prompt $"\
+                            {pass "(re)set file, before attach1"}
+            -re "$gdb_prompt $" {fail "(re)set file, before attach1"}
+            timeout         {fail "(timeout) (re)set file, before attach1"}
+         }
+      }
+      -re "Reading symbols from $escapedbinfile\.\.\.*done.*$gdb_prompt $"\
+                      {pass "set file, before attach1"}
+      -re "$gdb_prompt $" {fail "set file, before attach1"}
+      timeout         {fail "(timeout) set file, before attach1"}
+   }
+
+   send_gdb "attach $testpid\n"
+   gdb_expect {
+      -re "Attaching to program.*`?$escapedbinfile'?, process $testpid.*main.*at .*$srcfile:.*$gdb_prompt $"\
+                      {pass "attach1, after setting file"}
+      -re "$gdb_prompt $" {fail "attach1, after setting file"}
+      timeout         {fail "(timeout) attach1, after setting file"}
+   }
+
+   # Verify that we can "see" the variable "should_exit" in the
+   # program, and that it is zero.
+   #
+   send_gdb "print should_exit\n"
+   gdb_expect {
+      -re ".* = 0.*$gdb_prompt $"\
+                      {pass "after attach1, print should_exit"}
+      -re "$gdb_prompt $" {fail "after attach1, print should_exit"}
+      timeout         {fail "(timeout) after attach1, print should_exit"}
+   }
+
+   # Detach the process.
+   #
+   send_gdb "detach\n"
+   gdb_expect {
+      -re "Detaching from program: .*$escapedbinfile.*$gdb_prompt $"\
+                      {pass "attach1 detach"}
+      -re "$gdb_prompt $" {fail "attach1 detach"}
+      timeout         {fail "(timeout) attach1 detach"}
+   }
+
+   # Wait a bit for gdb to finish detaching
+   #
+   exec sleep 5
+
+   # Purge the symbols from gdb's brain.  (We want to be certain
+   # the next attach, which won't be preceded by a "file" command,
+   # is really getting the executable file without our help.)
+   #
+   set old_timeout $timeout
+   set timeout 15 
+   send_gdb "file\n"
+   gdb_expect {
+      -re ".*gdb internal error.*$" { 
+          fail "Internal error, prob. Memory corruption" 
+      }
+      -re "No executable file now.*Discard symbol table.*y or n.*$" {
+         send_gdb "y\n"
+         gdb_expect {
+            -re "No symbol file now.*$gdb_prompt $"\
+                            {pass "attach1, purging symbols after detach"}
+            -re "$gdb_prompt $" {fail "attach1, purging symbols after detach"}
+            timeout         {fail "(timeout) attach1, purging symbols after detach"}
+         }
+      }
+      -re "$gdb_prompt $" {fail "attach1, purging file after detach"}
+      timeout         {
+          fail "(timeout) attach1, purging file after detach"
+      }
+   }
+   set timeout $old_timeout
+
+   # Verify that we can attach to the process just by giving the
+   # process ID.
+   #
+   send_gdb "attach $testpid\n"
+   gdb_expect {
+      -re "Attaching to process $testpid.*Reading symbols from $escapedbinfile.*main.*at .*$gdb_prompt $"\
+                      {pass "attach2"}
+      -re "$gdb_prompt $" {fail "attach2"}
+      timeout         {fail "(timeout) attach2"}
+   }
+
+   # Verify that we can modify the variable "should_exit" in the
+   # program.
+   #
+   send_gdb "set should_exit=1\n"
+   gdb_expect {
+      -re "$gdb_prompt $" {pass "after attach2, set should_exit"}
+      timeout         {fail "(timeout) after attach2, set should_exit"}
+   }
+
+   # Verify that the modification really happened.
+   #
+   send_gdb "tbreak 19\n"
+   gdb_expect {
+      -re "reakpoint .*at.*$srcfile, line 19.*$gdb_prompt $"\
+                      {pass "after attach2, set tbreak postloop"}
+      -re "$gdb_prompt $" {fail "after attach2, set tbreak postloop"}
+      timeout         {fail "(timeout) after attach2, set tbreak postloop"}
+   }
+   send_gdb "continue\n"
+   gdb_expect {
+      -re "main.*at.*$srcfile:19.*$gdb_prompt $"\
+                      {pass "after attach2, reach tbreak postloop"}
+      -re "$gdb_prompt $" {fail "after attach2, reach tbreak postloop"}
+      timeout         {fail "(timeout) after attach2, reach tbreak postloop"}
+   }
+
+   # Allow the test process to exit, to cleanup after ourselves.
+   #
+   gdb_test "continue" {\[Inferior .* exited normally\]} "after attach2, exit"
+
+   # Make sure we don't leave a process around to confuse
+   # the next test run (and prevent the compile by keeping
+   # the text file busy), in case the "set should_exit" didn't
+   # work.
+   #
+   remote_exec build "kill -9 ${testpid}"
+   # Start the program running and then wait for a bit, to be sure
+   # that it can be attached to.
+   #
+   set testpid [eval exec $binfile &]
+   exec sleep 2
+
+   # Verify that we can attach to the process, and find its a.out
+   # when we're cd'd to some directory that doesn't contain the
+   # a.out.  (We use the source path set by the "dir" command.)
+   #
+   send_gdb "dir [file dirname [standard_output_file ${testfile}]]\n"
+   gdb_expect {
+      -re ".*Source directories searched: .*$gdb_prompt $"\
+                      {pass "set source path"}
+      -re "$gdb_prompt $" {fail "set source path"}
+      timeout         {fail "(timeout) set source path"}
+   }
+
+   send_gdb "cd /tmp\n"
+   gdb_expect {
+      -re ".*Working directory /tmp.*$gdb_prompt $"\
+                      {pass "cd away from process' a.out"}
+      -re "$gdb_prompt $" {fail "cd away from process' a.out"}
+      timeout         {fail "(timeout) cd away from process' a.out"}
+   }
+
+   # Explicitly flush out any knowledge of the previous attachment.
+   send_gdb "symbol\n"
+   gdb_expect {
+      -re ".*Discard symbol table from.*y or n. $"\
+                      {send_gdb "y\n"
+                       gdb_expect {
+                          -re ".*No symbol file now.*$gdb_prompt $"\
+                                          {pass "before attach3, flush symbols"}
+                          -re "$gdb_prompt $" {fail "before attach3, flush symbols"}
+                          timeout         {fail "(timeout) before attach3, flush symbols"}
+                       }
+                      }
+      -re ".*No symbol file now.*$gdb_prompt $"\
+                      {pass "before attach3, flush symbols"}
+      -re "$gdb_prompt $" {fail "before attach3, flush symbols"}
+      timeout         {fail "(timeout) before attach3, flush symbols"}
+   }
+   send_gdb "exec\n"
+   gdb_expect {
+      -re ".*No executable file now.*$gdb_prompt $"\
+                      {pass "before attach3, flush exec"}
+      -re "$gdb_prompt $" {fail "before attach3, flush exec"}
+      timeout         {fail "(timeout) before attach3, flush exec"}
+   }
+
+   send_gdb "attach $testpid\n"
+   gdb_expect {
+      -re "Attaching to process $testpid.*Reading symbols from $escapedbinfile.*main.*at .*$gdb_prompt $"\
+                      {pass "attach when process' a.out not in cwd"}
+      -re "$gdb_prompt $" {fail "attach when process' a.out not in cwd"}
+      timeout         {fail "(timeout) attach when process' a.out not in cwd"}
+   }
+
+   send_gdb "kill\n"
+   gdb_expect {
+      -re ".*Kill the program being debugged.*y or n. $"\
+                      {send_gdb "y\n"
+                       gdb_expect {
+                          -re "$gdb_prompt $" {pass "after attach3, exit"}
+                          timeout {fail "(timeout) after attach3, exit"}
+                       }
+                      }
+      -re "$gdb_prompt $" {fail "after attach3, exit"}
+      timeout         {fail "(timeout) after attach3, exit"}
+   }
+
+   # Another "don't leave a process around"
+   remote_exec build "kill -9 ${testpid}"
+}
+
+proc do_call_attach_tests {} {
+   global gdb_prompt
+   global binfile2
+
+   # Start the program running and then wait for a bit, to be sure
+   # that it can be attached to.
+   #
+   set testpid [eval exec $binfile2 &]
+   exec sleep 2
+
+   # Attach
+   #
+   gdb_test "file $binfile2" ".*" "force switch to gdb64, if necessary"
+   send_gdb "attach $testpid\n"
+   gdb_expect {
+      -re ".*warning: reading register.*I.*O error.*$gdb_prompt $" {
+         fail "attach call, read register 3 error"
+     }
+     -re "Attaching to.*process $testpid.*$gdb_prompt $" {
+         # libc is relocated, not relocated, therefore not printed.
+         pass "attach call"
+     }
+      -re "$gdb_prompt $" {fail "attach call"}
+      timeout         {fail "(timeout) attach call"}
+   }
+
+   # See if other registers are problems
+   #
+   send_gdb "i r r3\n"
+   gdb_expect {
+       -re ".*warning: reading register.*$gdb_prompt $" {
+           pass "CHFts23490: known bug"
+       }
+       -re ".*r3.*$gdb_prompt $" {
+           pass "Bug fixed, Yayyy!"
+       }
+       timeout { fail "timeout on info reg" }
+   }
+
+   # Get rid of the process
+   #
+   gdb_test "p should_exit = 1" ".*"
+   gdb_test "c" {\[Inferior .* exited normally\]}
+   
+   # Be paranoid
+   #
+    remote_exec build "kill -9 ${testpid}"
+
+}
+
+
+# Start with a fresh gdb
+#
+gdb_exit
+gdb_start
+gdb_reinitialize_dir $srcdir/$subdir
+gdb_load ${binfile}
+
+# This is a test of gdb's ability to attach to a running process.
+#
+do_attach_tests
+
+# Test attaching when the target is inside a system call
+#
+gdb_exit
+gdb_start
+
+gdb_reinitialize_dir $srcdir/$subdir
+do_call_attach_tests
+
+return 0
diff --git a/gdb/testsuite/gdb.pie/attach2.c b/gdb/testsuite/gdb.pie/attach2.c
new file mode 100644
--- /dev/null
+++ b/gdb/testsuite/gdb.pie/attach2.c
@@ -0,0 +1,24 @@
+/* This program is intended to be started outside of gdb, and then
+   attached to by gdb.  Thus, it simply spins in a loop.  The loop
+   is exited when & if the variable 'should_exit' is non-zero.  (It
+   is initialized to zero in this program, so the loop will never
+   exit unless/until gdb sets the variable to non-zero.)
+   */
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+int  should_exit = 0;
+
+int main ()
+{
+  int  local_i = 0;
+
+  sleep( 10 ); /* System call causes register fetch to fail */
+               /* This is a known HPUX "feature"            */
+  while (! should_exit)
+    {
+      local_i++;
+    }
+  return (0);
+}
diff --git a/gdb/testsuite/gdb.pie/break.c b/gdb/testsuite/gdb.pie/break.c
new file mode 100644
--- /dev/null
+++ b/gdb/testsuite/gdb.pie/break.c
@@ -0,0 +1,146 @@
+/* This testcase is part of GDB, the GNU debugger.
+
+   Copyright 1992, 1993, 1994, 1995, 1999, 2002, 2003 Free Software
+   Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+ 
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+   Please email any bugs, comments, and/or additions to this file to:
+   bug-gdb@prep.ai.mit.edu  */
+
+#ifdef vxworks
+
+#  include <stdio.h>
+
+/* VxWorks does not supply atoi.  */
+static int
+atoi (z)
+     char *z;
+{
+  int i = 0;
+
+  while (*z >= '0' && *z <= '9')
+    i = i * 10 + (*z++ - '0');
+  return i;
+}
+
+/* I don't know of any way to pass an array to VxWorks.  This function
+   can be called directly from gdb.  */
+
+vxmain (arg)
+char *arg;
+{
+  char *argv[2];
+
+  argv[0] = "";
+  argv[1] = arg;
+  main (2, argv, (char **) 0);
+}
+
+#else /* ! vxworks */
+#  include <stdio.h>
+#  include <stdlib.h>
+#endif /* ! vxworks */
+
+#ifdef PROTOTYPES
+extern int marker1 (void);
+extern int marker2 (int a);
+extern void marker3 (char *a, char *b);
+extern void marker4 (long d);
+#else
+extern int marker1 ();
+extern int marker2 ();
+extern void marker3 ();
+extern void marker4 ();
+#endif
+
+/*
+ *	This simple classical example of recursion is useful for
+ *	testing stack backtraces and such.
+ */
+
+#ifdef PROTOTYPES
+int factorial(int);
+
+int
+main (int argc, char **argv, char **envp)
+#else
+int
+main (argc, argv, envp)
+int argc;
+char *argv[], **envp;
+#endif
+{
+#ifdef usestubs
+    set_debug_traps();  /* set breakpoint 5 here */
+    breakpoint();
+#endif
+    if (argc == 12345) {  /* an unlikely value < 2^16, in case uninited */ /* set breakpoint 6 here */
+	fprintf (stderr, "usage:  factorial <number>\n");
+	return 1;
+    }
+    printf ("%d\n", factorial (atoi ("6")));  /* set breakpoint 1 here */
+    /* set breakpoint 12 here */
+    marker1 ();  /* set breakpoint 11 here */
+    marker2 (43); /* set breakpoint 20 here */
+    marker3 ("stack", "trace"); /* set breakpoint 21 here */
+    marker4 (177601976L);
+    argc = (argc == 12345); /* This is silly, but we can step off of it */ /* set breakpoint 2 here */
+    return argc;  /* set breakpoint 10 here */
+}
+
+#ifdef PROTOTYPES
+int factorial (int value)
+#else
+int factorial (value)
+int value;
+#endif
+{
+  if (value > 1) {  /* set breakpoint 7 here */
+	value *= factorial (value - 1);
+    }
+    return (value); /* set breakpoint 19 here */
+}
+
+#ifdef PROTOTYPES
+int multi_line_if_conditional (int a, int b, int c)
+#else
+int multi_line_if_conditional (a, b, c)
+  int a, b, c;
+#endif
+{
+  if (a    /* set breakpoint 3 here */
+      && b
+      && c)
+    return 0;
+  else
+    return 1;
+}
+
+#ifdef PROTOTYPES
+int multi_line_while_conditional (int a, int b, int c)
+#else
+int multi_line_while_conditional (a, b, c)
+  int a, b, c;
+#endif
+{
+  while (a /* set breakpoint 4 here */
+      && b
+      && c)
+    {
+      a--, b--, c--;
+    }
+  return 0;
+}
diff --git a/gdb/testsuite/gdb.pie/break.exp b/gdb/testsuite/gdb.pie/break.exp
new file mode 100644
--- /dev/null
+++ b/gdb/testsuite/gdb.pie/break.exp
@@ -0,0 +1,954 @@
+#   Copyright 1988, 1990, 1991, 1992, 1994, 1995, 1996, 1997, 1998, 1999,
+#   2000, 2002, 2003, 2004
+#   Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gdb@prep.ai.mit.edu
+
+# This file was written by Rob Savoye. (rob@cygnus.com)
+
+# Test the same stuff but with PIE executables
+
+set testfile "break"
+set srcfile ${testfile}.c
+set srcfile1 ${testfile}1.c
+set binfile [standard_output_file ${testfile}]
+
+if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}0.o" object {debug "additional_flags=-w -fpie -pie"}] != "" } {
+     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
+}
+
+if  { [gdb_compile "${srcdir}/${subdir}/${srcfile1}" "${binfile}1.o" object {debug "additional_flags=-w -fpie -pie"}] != "" } {
+     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
+}
+
+if  { [gdb_compile "${binfile}0.o ${binfile}1.o" "${binfile}" executable {debug "additional_flags=-w -fpie -pie"}] != "" } {
+     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
+}
+
+if [get_compiler_info ${binfile}] {
+    return -1
+}
+
+gdb_exit
+gdb_start
+gdb_reinitialize_dir $srcdir/$subdir
+gdb_load ${binfile}
+
+if [target_info exists gdb_stub] {
+    gdb_step_for_stub;
+}
+#
+# test simple breakpoint setting commands
+#
+
+# Test deleting all breakpoints when there are none installed,
+# GDB should not prompt for confirmation.
+# Note that gdb-init.exp provides a "delete_breakpoints" proc
+# for general use elsewhere.
+
+send_gdb "delete breakpoints\n"
+gdb_expect {
+     -re "Delete all breakpoints.*$" {
+	    send_gdb "y\n"
+	    gdb_expect {
+		-re "$gdb_prompt $" {
+		    fail "Delete all breakpoints when none (unexpected prompt)"
+		}
+		timeout	{ fail "Delete all breakpoints when none (timeout after unexpected prompt)" }
+	    }
+	}
+     -re ".*$gdb_prompt $"       { pass "Delete all breakpoints when none" }
+    timeout	            { fail "Delete all breakpoints when none (timeout)" }
+}
+
+#
+# test break at function
+#
+gdb_test "break main" \
+    "Breakpoint.*at.* file .*$srcfile, line.*" \
+    "breakpoint function"
+
+#
+# test break at quoted function
+#
+gdb_test "break \"marker2\"" \
+    "Breakpoint.*at.* file .*$srcfile1, line.*" \
+    "breakpoint quoted function"
+
+#
+# test break at function in file
+#
+gdb_test "break $srcfile:factorial" \
+    "Breakpoint.*at.* file .*$srcfile, line.*" \
+    "breakpoint function in file"
+
+set bp_location1 [gdb_get_line_number "set breakpoint 1 here"]
+
+#
+# test break at line number
+#
+# Note that the default source file is the last one whose source text
+# was printed.  For native debugging, before we've executed the
+# program, this is the file containing main, but for remote debugging,
+# it's wherever the processor was stopped when we connected to the
+# board.  So, to be sure, we do a list command.
+#
+gdb_test "list main" \
+    ".*main \\(argc, argv, envp\\).*" \
+    "use `list' to establish default source file"
+gdb_test "break $bp_location1" \
+    "Breakpoint.*at.* file .*$srcfile, line $bp_location1\\." \
+    "breakpoint line number"
+
+#
+# test duplicate breakpoint
+#
+gdb_test "break $bp_location1" \
+    "Note: breakpoint \[0-9\]+ also set at pc.*Breakpoint \[0-9\]+ at.* file .*$srcfile, line $bp_location1\\." \
+    "breakpoint duplicate"
+
+set bp_location2 [gdb_get_line_number "set breakpoint 2 here"]
+
+#
+# test break at line number in file
+#
+gdb_test "break $srcfile:$bp_location2" \
+    "Breakpoint.*at.* file .*$srcfile, line $bp_location2\\." \
+    "breakpoint line number in file"
+
+set bp_location3 [gdb_get_line_number "set breakpoint 3 here"]
+set bp_location4 [gdb_get_line_number "set breakpoint 4 here"]
+
+#
+# Test putting a break at the start of a multi-line if conditional.
+# Verify the breakpoint was put at the start of the conditional.
+#
+gdb_test "break multi_line_if_conditional" \
+    "Breakpoint.*at.* file .*$srcfile, line $bp_location3\\." \
+    "breakpoint at start of multi line if conditional"
+
+gdb_test "break multi_line_while_conditional" \
+    "Breakpoint.*at.* file .*$srcfile, line $bp_location4\\." \
+    "breakpoint at start of multi line while conditional"
+
+set bp_location5 [gdb_get_line_number "set breakpoint 5 here"]
+set bp_location6 [gdb_get_line_number "set breakpoint 6 here"]
+
+#
+# check to see what breakpoints are set
+#
+if [target_info exists gdb_stub] {
+    set main_line $bp_location5
+} else {
+    set main_line $bp_location6
+}
+
+set proto ""
+
+set bp_location7 [gdb_get_line_number "set breakpoint 7 here"]
+set bp_location8 [gdb_get_line_number "set breakpoint 8 here" $srcfile1]
+set bp_location9 [gdb_get_line_number "set breakpoint 9 here" $srcfile1]
+
+# Test a pending breakpoint in PIE executable does not crash later GDB.
+gdb_breakpoint "non_existent_function" allow-pending
+
+gdb_test "info break" \
+    "Num\[ \]+Type\[ \]+Disp Enb Address\[ \]+What.*
+\[0-9\]+\[\t \]+breakpoint     keep y.* in main at .*$srcfile:$main_line.*
+\[0-9\]+\[\t \]+breakpoint     keep y.* in marker2 at .*$srcfile1:($bp_location8|$bp_location9).*
+\[0-9\]+\[\t \]+breakpoint     keep y.* in factorial$proto at .*$srcfile:$bp_location7.*
+\[0-9\]+\[\t \]+breakpoint     keep y.* in main at .*$srcfile:$bp_location1.*
+\[0-9\]+\[\t \]+breakpoint     keep y.* in main at .*$srcfile:$bp_location1.*
+\[0-9\]+\[\t \]+breakpoint     keep y.* in main at .*$srcfile:$bp_location2.*
+\[0-9\]+\[\t \]+breakpoint     keep y.* in multi_line_if_conditional at .*$srcfile:$bp_location3.*
+\[0-9\]+\[\t \]+breakpoint     keep y.* in multi_line_while_conditional at .*$srcfile:$bp_location4.*
+\[0-9\]+\[\t \]+breakpoint     keep y.* <PENDING> *non_existent_function" \
+    "breakpoint info"
+
+# FIXME: The rest of this test doesn't work with anything that can't
+# handle arguments.
+# Huh? There doesn't *appear* to be anything that passes arguments
+# below.
+if [istarget "mips-idt-*"] then {
+    return
+}
+
+#
+# run until the breakpoint at main is hit. For non-stubs-using targets.
+#
+if ![target_info exists use_gdb_stub] {
+  if [istarget "*-*-vxworks*"] then {
+    send_gdb "run vxmain \"2\"\n"
+    set timeout 120
+    verbose "Timeout is now $timeout seconds" 2
+  } else {
+	send_gdb "run\n"
+  }
+  gdb_expect {
+    -re "The program .* has been started already.*y or n. $" {
+	send_gdb "y\n"
+	exp_continue
+    }
+    -re "Starting program.*Breakpoint \[0-9\]+,.*main .*argc.*argv.* at .*$srcfile:$bp_location6.*$bp_location6\[\t \]+if .argc.* \{.*$gdb_prompt $"\
+	                    { pass "run until function breakpoint" }
+    -re ".*$gdb_prompt $"       { fail "run until function breakpoint" }
+    timeout	            { fail "run until function breakpoint (timeout)" }
+  }
+} else {
+    if ![target_info exists gdb_stub] {
+	gdb_test continue ".*Continuing\\..*Breakpoint \[0-9\]+, main \\(argc=.*, argv=.*, envp=.*\\) at .*$srcfile:$bp_location6.*$bp_location6\[\t \]+if .argc.*\{.*" "stub continue"
+    }
+}
+
+#
+# run until the breakpoint at a line number
+#
+gdb_test continue "Continuing\\..*Breakpoint \[0-9\]+, main \\(argc=.*, argv=.*, envp=.*\\) at .*$srcfile:$bp_location1.*$bp_location1\[\t \]+printf.*factorial.*" \
+			"run until breakpoint set at a line number"
+
+#
+# Run until the breakpoint set in a function in a file
+#
+for {set i 6} {$i >= 1} {incr i -1} {
+	gdb_test continue "Continuing\\..*Breakpoint \[0-9\]+, factorial \\(value=$i\\) at .*$srcfile:$bp_location7.*$bp_location7\[\t \]+.*if .value > 1. \{.*" \
+			"run until file:function($i) breakpoint"
+}
+
+#
+# Run until the breakpoint set at a quoted function
+#
+gdb_test continue "Continuing\\..*Breakpoint \[0-9\]+, (0x\[0-9a-f\]+ in )?marker2 \\(a=43\\) at .*$srcfile1:($bp_location8|$bp_location9).*" \
+		"run until quoted breakpoint"
+#
+# run until the file:function breakpoint at a line number in a file
+#
+gdb_test continue "Continuing\\..*Breakpoint \[0-9\]+, main \\(argc=.*, argv=.*, envp=.*\\) at .*$srcfile:$bp_location2.*$bp_location2\[\t \]+argc = \\(argc == 12345\\);.*" \
+		"run until file:linenum breakpoint"
+
+# Test break at offset +1
+set bp_location10 [gdb_get_line_number "set breakpoint 10 here"]
+
+gdb_test "break +1" \
+    "Breakpoint.*at.* file .*$srcfile, line $bp_location10\\." \
+    "breakpoint offset +1"
+
+# Check to see if breakpoint is hit when stepped onto
+
+gdb_test "step" \
+    ".*Breakpoint \[0-9\]+, main \\(argc=.*, argv=.*, envp=.*\\) at .*$srcfile:$bp_location10.*$bp_location10\[\t \]+return argc;.*breakpoint 10 here.*" \
+    "step onto breakpoint"
+
+#
+# delete all breakpoints so we can start over, course this can be a test too
+#
+delete_breakpoints
+
+#
+# test temporary breakpoint at function
+#
+
+gdb_test "tbreak main" "reakpoint.*at.* file .*$srcfile, line.*" "Temporary breakpoint function"
+
+#
+# test break at function in file
+#
+
+gdb_test "tbreak $srcfile:factorial" "reakpoint.*at.* file .*$srcfile, line.*" \
+	"Temporary breakpoint function in file"
+
+#
+# test break at line number
+#
+send_gdb "tbreak $bp_location1\n"
+gdb_expect {
+    -re "reakpoint.*at.* file .*$srcfile, line $bp_location1.*$gdb_prompt $" { pass "Temporary breakpoint line number #1" }
+	-re ".*$gdb_prompt $"   { pass "Temporary breakpoint line number #1" }
+	timeout	    { fail "breakpoint line number #1 (timeout)" }
+}
+
+gdb_test "tbreak $bp_location6" "reakpoint.*at.* file .*$srcfile, line $bp_location6.*" "Temporary breakpoint line number #2"
+
+#
+# test break at line number in file
+#
+send_gdb "tbreak $srcfile:$bp_location2\n"
+gdb_expect {
+    -re "reakpoint.*at.* file .*$srcfile, line $bp_location2.*$gdb_prompt $" { pass "Temporary breakpoint line number in file #1" }
+	-re ".*$gdb_prompt $"   { pass "Temporary breakpoint line number in file #1" }
+	timeout	    { fail "Temporary breakpoint line number in file #1 (timeout)" }
+}
+
+set bp_location11 [gdb_get_line_number "set breakpoint 11 here"]
+gdb_test  "tbreak $srcfile:$bp_location11" "reakpoint.*at.* file .*$srcfile, line $bp_location11.*" "Temporary breakpoint line number in file #2"
+
+#
+# check to see what breakpoints are set (temporary this time)
+#
+gdb_test "info break" "Num.*Type.*Disp Enb Address.*What.*\[\r\n\]
+\[0-9\]+\[\t \]+breakpoint     del.*y.*in main at .*$srcfile:$main_line.*\[\r\n\]
+\[0-9\]+\[\t \]+breakpoint     del.*y.*in factorial$proto at .*$srcfile:$bp_location7.*\[\r\n\]
+\[0-9\]+\[\t \]+breakpoint     del.*y.*in main at .*$srcfile:$bp_location1.*\[\r\n\]
+\[0-9\]+\[\t \]+breakpoint     del.*y.*in main at .*$srcfile:$bp_location6.*\[\r\n\]
+\[0-9\]+\[\t \]+breakpoint     del.*y.*in main at .*$srcfile:$bp_location2.*\[\r\n\]
+\[0-9\]+\[\t \]+breakpoint     del.*y.*in main at .*$srcfile:$bp_location11.*" \
+    "Temporary breakpoint info"
+
+
+#***********
+
+# Verify that catchpoints for fork, vfork and exec don't trigger
+# inappropriately.  (There are no calls to those system functions
+# in this test program.)
+#
+if ![runto_main] then { fail "break tests suppressed" }
+
+send_gdb "catch\n"
+gdb_expect {
+  -re "Catch requires an event name.*$gdb_prompt $"\
+          {pass "catch requires an event name"}
+  -re "$gdb_prompt $"\
+          {fail "catch requires an event name"}
+  timeout {fail "(timeout) catch requires an event name"}
+}
+
+
+set name "set catch fork, never expected to trigger"
+send_gdb "catch fork\n"
+gdb_expect {
+  -re "Catchpoint \[0-9\]* .fork..*$gdb_prompt $"
+          {pass $name}
+  -re "Catch of fork not yet implemented.*$gdb_prompt $"
+	  {pass $name}
+  -re "$gdb_prompt $"
+          {fail $name}
+  timeout {fail "(timeout) $name"}
+}
+
+
+set name "set catch vfork, never expected to trigger"
+send_gdb "catch vfork\n"
+
+# If we are on HP-UX 10.20, we expect an error message to be
+# printed if we type "catch vfork" at the gdb gdb_prompt.  This is
+# because on HP-UX 10.20, we cannot catch vfork events.
+
+if [istarget "hppa*-hp-hpux10.20"] then {
+    gdb_expect {
+	-re "Catch of vfork events not supported on HP-UX 10.20..*$gdb_prompt $"
+		{pass $name}
+	-re "$gdb_prompt $"
+		{fail $name}
+	timeout {fail "(timeout) $name"}
+    }
+} else {
+    gdb_expect {
+	-re "Catchpoint \[0-9\]* .vfork..*$gdb_prompt $"
+		{pass $name}
+	-re "Catch of vfork not yet implemented.*$gdb_prompt $"
+		{pass $name}
+	-re "$gdb_prompt $"
+		{fail $name}
+	timeout {fail "(timeout) $name"}
+    }
+}
+
+set name "set catch exec, never expected to trigger"
+send_gdb "catch exec\n"
+gdb_expect {
+  -re "Catchpoint \[0-9\]* .exec..*$gdb_prompt $"
+          {pass $name}
+  -re "Catch of exec not yet implemented.*$gdb_prompt $"
+	  {pass $name}
+  -re "$gdb_prompt $" {fail $name}
+  timeout {fail "(timeout) $name"}
+}
+
+# Verify that GDB responds gracefully when asked to set a breakpoint
+# on a nonexistent source line.
+#
+gdb_test_no_output "set breakpoint pending off"
+gdb_test "break 999" \
+    "No line 999 in the current file." \
+    "break on non-existent source line"
+
+# Run to the desired default location. If not positioned here, the
+# tests below don't work.
+#
+gdb_test "until $bp_location1" "main .* at .*:$bp_location1.*" "until bp_location1"
+
+
+# Verify that GDB allows one to just say "break", which is treated
+# as the "default" breakpoint.  Note that GDB gets cute when printing
+# the informational message about other breakpoints at the same
+# location.  We'll hit that bird with this stone too.
+#
+send_gdb "break\n"
+gdb_expect {
+  -re "Breakpoint \[0-9\]*.*$gdb_prompt $"\
+          {pass "break on default location, 1st time"}
+  -re "$gdb_prompt $"\
+          {fail "break on default location, 1st time"}
+  timeout {fail "(timeout) break on default location, 1st time"}
+}
+
+send_gdb "break\n"
+gdb_expect {
+  -re "Note: breakpoint \[0-9\]* also set at .*Breakpoint \[0-9\]*.*$gdb_prompt $"\
+          {pass "break on default location, 2nd time"}
+  -re "$gdb_prompt $"\
+          {fail "break on default location, 2nd time"}
+  timeout {fail "(timeout) break on default location, 2nd time"}
+}
+
+send_gdb "break\n"
+gdb_expect {
+  -re "Note: breakpoints \[0-9\]* and \[0-9\]* also set at .*Breakpoint \[0-9\]*.*$gdb_prompt $"\
+          {pass "break on default location, 3rd time"}
+  -re "$gdb_prompt $"\
+          {fail "break on default location, 3rd time"}
+  timeout {fail "(timeout) break on default location, 3rd time"}
+}
+
+send_gdb "break\n"
+gdb_expect {
+  -re "Note: breakpoints \[0-9\]*, \[0-9\]* and \[0-9\]* also set at .*Breakpoint \[0-9\]*.*$gdb_prompt $"\
+          {pass "break on default location, 4th time"}
+  -re "$gdb_prompt $"\
+          {fail "break on default location, 4th time"}
+  timeout {fail "(timeout) break on default location, 4th time"}
+}
+
+# Verify that a "silent" breakpoint can be set, and that GDB is indeed
+# "silent" about its triggering.
+#
+if ![runto_main] then { fail "break tests suppressed" }
+
+send_gdb "break $bp_location1\n"
+gdb_expect {
+  -re "Breakpoint (\[0-9\]*) at .*, line $bp_location1.*$gdb_prompt $"\
+          {pass "set to-be-silent break bp_location1"}
+  -re "$gdb_prompt $"\
+          {fail "set to-be-silent break bp_location1"}
+  timeout {fail "(timeout) set to-be-silent break bp_location1"}
+}
+
+send_gdb "commands $expect_out(1,string)\n"
+send_gdb "silent\n"
+send_gdb "end\n"
+gdb_expect {
+  -re ".*$gdb_prompt $"\
+          {pass "set silent break bp_location1"}
+  timeout {fail "(timeout) set silent break bp_location1"}
+}
+
+send_gdb "info break $expect_out(1,string)\n"
+gdb_expect {
+  -re "\[0-9\]*\[ \t\]*breakpoint.*:$bp_location1\r\n\[ \t\]*silent.*$gdb_prompt $"\
+          {pass "info silent break bp_location1"}
+  -re "$gdb_prompt $"\
+          {fail "info silent break bp_location1"}
+  timeout {fail "(timeout) info silent break bp_location1"}
+}
+send_gdb "continue\n"
+gdb_expect {
+  -re "Continuing.\r\n$gdb_prompt $"\
+          {pass "hit silent break bp_location1"}
+  -re "$gdb_prompt $"\
+          {fail "hit silent break bp_location1"}
+  timeout {fail "(timeout) hit silent break bp_location1"}
+}
+send_gdb "bt\n"
+gdb_expect {
+  -re "#0  main .* at .*:$bp_location1.*$gdb_prompt $"\
+          {pass "stopped for silent break bp_location1"}
+  -re "$gdb_prompt $"\
+          {fail "stopped for silent break bp_location1"}
+  timeout {fail "(timeout) stopped for silent break bp_location1"}
+}
+
+# Verify that GDB can at least parse a breakpoint with the
+# "thread" keyword.  (We won't attempt to test here that a
+# thread-specific breakpoint really triggers appropriately.
+# The gdb.threads subdirectory contains tests for that.)
+#
+set bp_location12 [gdb_get_line_number "set breakpoint 12 here"]
+send_gdb "break $bp_location12 thread 999\n"
+gdb_expect {
+  -re "Unknown thread 999.*$gdb_prompt $"\
+          {pass "thread-specific breakpoint on non-existent thread disallowed"}
+  -re "$gdb_prompt $"\
+          {fail "thread-specific breakpoint on non-existent thread disallowed"}
+  timeout {fail "(timeout) thread-specific breakpoint on non-existent thread disallowed"}
+}
+
+gdb_test "break $bp_location12 thread foo" \
+    "Invalid thread ID: foo" \
+    "thread-specific breakpoint on bogus thread ID disallowed"
+
+# Verify that GDB responds gracefully to a breakpoint command with
+# trailing garbage.
+#
+send_gdb "break $bp_location12 foo\n"
+gdb_expect {
+  -re "malformed linespec error: unexpected string, \"foo\"\r\n$gdb_prompt $"\
+          {pass "breakpoint with trailing garbage disallowed"}
+  -re "$gdb_prompt $"\
+          {fail "breakpoint with trailing garbage disallowed"}
+  timeout {fail "(timeout) breakpoint with trailing garbage disallowed"}
+}
+
+# Verify that GDB responds gracefully to a "clear" command that has
+# no matching breakpoint.  (First, get us off the current source line,
+# which we know has a breakpoint.)
+#
+send_gdb "next\n"
+gdb_expect {
+  -re ".*$gdb_prompt $"\
+          {pass "step over breakpoint"}
+  timeout {fail "(timeout) step over breakpoint"}
+}
+send_gdb "clear 81\n"
+gdb_expect {
+  -re "No breakpoint at 81..*$gdb_prompt $"\
+          {pass "clear line has no breakpoint disallowed"}
+  -re "$gdb_prompt $"\
+          {fail "clear line has no breakpoint disallowed"}
+  timeout {fail "(timeout) clear line has no breakpoint disallowed"}
+}
+send_gdb "clear\n"
+gdb_expect {
+  -re "No breakpoint at this line..*$gdb_prompt $"\
+          {pass "clear current line has no breakpoint disallowed"}
+  -re "$gdb_prompt $"\
+          {fail "clear current line has no breakpoint disallowed"}
+  timeout {fail "(timeout) clear current line has no breakpoint disallowed"}
+}
+
+# Verify that we can set and clear multiple breakpoints.
+#
+# We don't test that it deletes the correct breakpoints.  We do at
+# least test that it deletes more than one breakpoint.
+#
+gdb_test "break marker3" "Breakpoint.*at.*" "break marker3 #1"
+gdb_test "break marker3" "Breakpoint.*at.*" "break marker3 #2"
+gdb_test "clear marker3" {Deleted breakpoints [0-9]+ [0-9]+.*}
+
+# Verify that a breakpoint can be set via a convenience variable.
+#
+send_gdb "set \$foo=$bp_location11\n"
+gdb_expect {
+  -re "$gdb_prompt $"\
+          {pass "set convenience variable \$foo to bp_location11"}
+  timeout {fail "(timeout) set convenience variable \$foo to bp_location11"}
+}
+send_gdb "break \$foo\n"
+gdb_expect {
+  -re "Breakpoint (\[0-9\]*) at .*, line $bp_location11.*$gdb_prompt $"\
+          {pass "set breakpoint via convenience variable"}
+  -re "$gdb_prompt $"\
+          {fail "set breakpoint via convenience variable"}
+  timeout {fail "(timeout) set breakpoint via convenience variable"}
+}
+
+# Verify that GDB responds gracefully to an attempt to set a
+# breakpoint via a convenience variable whose type is not integer.
+#
+send_gdb "set \$foo=81.5\n"
+gdb_expect {
+  -re "$gdb_prompt $"\
+          {pass "set convenience variable \$foo to 81.5"}
+  timeout {fail "(timeout) set convenience variable \$foo to 81.5"}
+}
+send_gdb "break \$foo\n"
+gdb_expect {
+  -re "Convenience variables used in line specs must have integer values..*$gdb_prompt $"\
+          {pass "set breakpoint via non-integer convenience variable disallowed"}
+  -re "$gdb_prompt $"\
+          {fail "set breakpoint via non-integer convenience variable disallowed"}
+  timeout {fail "(timeout) set breakpoint via non-integer convenience variable disallowed"}
+}
+
+# Verify that we can set and trigger a breakpoint in a user-called function.
+#
+send_gdb "break marker2\n"
+gdb_expect {
+    -re "Breakpoint (\[0-9\]*) at .*, line ($bp_location8|$bp_location9).*$gdb_prompt $"\
+          {pass "set breakpoint on to-be-called function"}
+  -re "$gdb_prompt $"\
+          {fail "set breakpoint on to-be-called function"}
+  timeout {fail "(timeout) set breakpoint on to-be-called function"}
+}
+send_gdb "print marker2(99)\n"
+gdb_expect {
+  -re "The program being debugged stopped while in a function called from GDB.\r\nEvaluation of the expression containing the function\r\n.marker2$proto. will be abandoned.\r\nWhen the function is done executing, GDB will silently stop.\r\n$gdb_prompt $"\
+          {pass "hit breakpoint on called function"}
+  -re "$gdb_prompt $"\
+          {fail "hit breakpoint on called function"}
+  timeout {fail "(timeout) hit breakpoint on called function"}
+}
+
+# As long as we're stopped (breakpointed) in a called function,
+# verify that we can successfully backtrace & such from here.
+#
+# In this and the following test, the _sr4export check apparently is needed
+# for hppa*-*-hpux.
+#
+send_gdb "bt\n"
+gdb_expect {
+    -re "#0\[ \t\]*($hex in )?marker2.*:($bp_location8|$bp_location9)\r\n#1.*_sr4export.*$gdb_prompt $"\
+            {pass "backtrace while in called function"}
+    -re "#0\[ \t\]*($hex in )?marker2.*:($bp_location8|$bp_location9)\r\n#1.*function called from gdb.*$gdb_prompt $"\
+	    {pass "backtrace while in called function"}
+    -re "$gdb_prompt $"\
+            {fail "backtrace while in called function"}
+    timeout {fail "(timeout) backtrace while in called function"}
+}
+
+# Return from the called function.  For remote targets, it's important to do
+# this before runto_main, which otherwise may silently stop on the dummy
+# breakpoint inserted by GDB at the program's entry point.
+#
+send_gdb "finish\n"
+gdb_expect {
+    -re "Run till exit from .*marker2.* at .*($bp_location8|$bp_location9)\r\n.* in _sr4export.*$gdb_prompt $"\
+            {pass "finish from called function"}
+    -re "Run till exit from .*marker2.* at .*($bp_location8|$bp_location9)\r\n.*function called from gdb.*$gdb_prompt $"\
+            {pass "finish from called function"}
+    -re "Run till exit from .*marker2.* at .*($bp_location8|$bp_location9)\r\n.*Value returned.*$gdb_prompt $"\
+            {pass "finish from called function"}
+    -re "$gdb_prompt $"\
+            {fail "finish from called function"}
+    timeout {fail "(timeout) finish from called function"}
+}
+
+# Verify that GDB responds gracefully to a "finish" command with
+# arguments.
+#
+if ![runto_main] then { fail "break tests suppressed" }
+
+send_gdb "finish 123\n"
+gdb_expect {
+  -re "The \"finish\" command does not take any arguments.\r\n$gdb_prompt $"\
+          {pass "finish with arguments disallowed"}
+  -re "$gdb_prompt $"\
+          {fail "finish with arguments disallowed"}
+  timeout {fail "(timeout) finish with arguments disallowed"}
+}
+
+# Verify that GDB responds gracefully to a request to "finish" from
+# the outermost frame.  On a stub that never exits, this will just
+# run to the stubs routine, so we don't get this error...  Thus the 
+# second condition.
+#
+
+send_gdb "finish\n"
+gdb_expect {
+  -re "\"finish\" not meaningful in the outermost frame.\r\n$gdb_prompt $"\
+          {pass "finish from outermost frame disallowed"}
+  -re "Run till exit from.*\r\n$gdb_prompt $" {
+     pass "finish from outermost frame disallowed"
+  }
+  -re "$gdb_prompt $"\
+          {fail "finish from outermost frame disallowed"}
+  timeout {fail "(timeout) finish from outermost frame disallowed"}
+}
+
+# Verify that we can explicitly ask GDB to stop on all shared library
+# events, and that it does so.
+#
+if [istarget "hppa*-*-hpux*"] then {
+  if ![runto_main] then { fail "break tests suppressed" }
+
+  send_gdb "set stop-on-solib-events 1\n"
+  gdb_expect {
+    -re "$gdb_prompt $"\
+            {pass "set stop-on-solib-events"}
+    timeout {fail "(timeout) set stop-on-solib-events"}
+  }
+
+  send_gdb "run\n"
+  gdb_expect {
+    -re ".*Start it from the beginning.*y or n. $"\
+            {send_gdb "y\n"
+             gdb_expect {
+               -re ".*Stopped due to shared library event.*$gdb_prompt $"\
+                       {pass "triggered stop-on-solib-events"}
+               -re "$gdb_prompt $"\
+                       {fail "triggered stop-on-solib-events"}
+               timeout {fail "(timeout) triggered stop-on-solib-events"}
+             }
+            }
+    -re "$gdb_prompt $"\
+            {fail "rerun for stop-on-solib-events"}
+    timeout {fail "(timeout) rerun for stop-on-solib-events"}
+  }
+
+  send_gdb "set stop-on-solib-events 0\n"
+  gdb_expect {
+    -re "$gdb_prompt $"\
+            {pass "reset stop-on-solib-events"}
+    timeout {fail "(timeout) reset stop-on-solib-events"}
+  }
+}
+
+# Hardware breakpoints are unsupported on HP-UX.  Verify that GDB
+# gracefully responds to requests to create them.
+#
+if [istarget "hppa*-*-hpux*"] then {
+  if ![runto_main] then { fail "break tests suppressed" }
+
+  send_gdb "hbreak\n"
+  gdb_expect {
+    -re "No hardware breakpoint support in the target.*$gdb_prompt $"\
+            {pass "hw breaks disallowed"}
+    -re "$gdb_prompt $"\
+            {fail "hw breaks disallowed"}
+    timeout {fail "(timeout) hw breaks disallowed"}
+  }
+
+  send_gdb "thbreak\n"
+  gdb_expect {
+    -re "No hardware breakpoint support in the target.*$gdb_prompt $"\
+            {pass "temporary hw breaks disallowed"}
+    -re "$gdb_prompt $"\
+            {fail "temporary hw breaks disallowed"}
+    timeout {fail "(timeout) temporary hw breaks disallowed"}
+  }
+}
+
+#********
+
+
+#
+# Test "next" over recursive function call.
+#
+
+proc test_next_with_recursion {} { 
+    global gdb_prompt
+    global decimal
+    global binfile
+
+    if [target_info exists use_gdb_stub] {
+	# Reload the program.
+	delete_breakpoints
+	gdb_load ${binfile};
+    } else {
+	# FIXME: should be using runto
+	gdb_test "kill" "" "kill program" "Kill the program being debugged.*y or n. $" "y"
+
+	delete_breakpoints
+    }
+
+    gdb_test "break factorial" "Breakpoint $decimal at .*" "break at factorial"
+
+    # Run until we call factorial with 6
+
+    if [istarget "*-*-vxworks*"] then {
+	send_gdb "run vxmain \"6\"\n"
+    } else {
+	gdb_run_cmd
+    }
+    gdb_expect {
+	-re "Break.* factorial .value=6. .*$gdb_prompt $" {}
+	-re ".*$gdb_prompt $" {
+	    fail "run to factorial(6)";
+	    gdb_suppress_tests;
+	}
+	timeout { fail "run to factorial(6) (timeout)" ; gdb_suppress_tests }
+    }
+
+    # Continue until we call factorial recursively with 5.
+
+    if [gdb_test "continue" \
+	"Continuing.*Break.* factorial .value=5. .*" \
+	"continue to factorial(5)"] then { gdb_suppress_tests }
+
+    # Do a backtrace just to confirm how many levels deep we are.
+
+    if [gdb_test "backtrace" \
+	"#0\[ \t\]+ factorial .value=5..*" \
+	"backtrace from factorial(5)"] then { gdb_suppress_tests }
+
+    # Now a "next" should position us at the recursive call, which
+    # we will be performing with 4.
+
+    if [gdb_test "next" \
+	".* factorial .value - 1.;.*" \
+	"next to recursive call"] then { gdb_suppress_tests }
+
+    # Disable the breakpoint at the entry to factorial by deleting them all.
+    # The "next" should run until we return to the next line from this
+    # recursive call to factorial with 4.
+    # Buggy versions of gdb will stop instead at the innermost frame on
+    # the line where we are trying to "next" to.
+
+    delete_breakpoints
+
+    if [istarget "mips*tx39-*"] {
+	set timeout 60
+    }
+    # We used to set timeout here for all other targets as well.  This
+    # is almost certainly wrong.  The proper timeout depends on the
+    # target system in use, and how we communicate with it, so there
+    # is no single value appropriate for all targets.  The timeout
+    # should be established by the Dejagnu config file(s) for the
+    # board, and respected by the test suite.
+    #
+    # For example, if I'm running GDB over an SSH tunnel talking to a
+    # portmaster in California talking to an ancient 68k board running
+    # a crummy ROM monitor (a situation I can only wish were
+    # hypothetical), then I need a large timeout.  But that's not the
+    # kind of knowledge that belongs in this file.
+
+    gdb_test next "\[0-9\]*\[\t \]+return \\(value\\);.*" \
+	    "next over recursive call"
+
+    # OK, we should be back in the same stack frame we started from.
+    # Do a backtrace just to confirm.
+
+    set result [gdb_test "backtrace" \
+	    "#0\[ \t\]+ factorial .value=120.*\r\n#1\[ \t\]+ \[0-9a-fx\]+ in factorial .value=6..*" \
+	    "backtrace from factorial(5.1)"]
+    if { $result != 0 } { gdb_suppress_tests }
+
+    if [target_info exists gdb,noresults] { gdb_suppress_tests }
+  gdb_continue_to_end "recursive next test"
+   gdb_stop_suppressing_tests;
+}
+
+test_next_with_recursion
+
+
+#********
+
+# build a new file with optimization enabled so that we can try breakpoints
+# on targets with optimized prologues
+
+set binfileo2 [standard_output_file ${testfile}o2]
+
+if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}O0.o" object {debug "additional_flags=-w -O2 -fpie -pie"}] != "" } {
+     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
+}
+
+if  { [gdb_compile "${srcdir}/${subdir}/${srcfile1}" "${binfile}O1.o" object {debug "additional_flags=-w -O2 -fpie -pie"}] != "" } {
+     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
+}
+
+if  { [gdb_compile "${binfile}O0.o ${binfile}O1.o" "${binfileo2}" executable {debug "additional_flags=-w -fpie -pie"}] != "" } {
+     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
+}
+
+if [get_compiler_info ${binfileo2}] {
+    return -1
+}
+
+gdb_exit
+gdb_start
+gdb_reinitialize_dir $srcdir/$subdir
+gdb_load ${binfileo2}
+
+if [target_info exists gdb_stub] {
+    gdb_step_for_stub;
+}
+
+#
+# test break at function
+#
+gdb_test "break main" \
+    "Breakpoint.*at.* file .*$srcfile, line.*" \
+    "breakpoint function, optimized file"
+
+#
+# test break at function
+#
+gdb_test "break marker4" \
+    "Breakpoint.*at.* file .*$srcfile1, line.*" \
+    "breakpoint small function, optimized file"
+
+#
+# run until the breakpoint at main is hit. For non-stubs-using targets.
+#
+if ![target_info exists use_gdb_stub] {
+  if [istarget "*-*-vxworks*"] then {
+    send_gdb "run vxmain \"2\"\n"
+    set timeout 120
+    verbose "Timeout is now $timeout seconds" 2
+  } else {
+	send_gdb "run\n"
+  }
+  gdb_expect {
+    -re "The program .* has been started already.*y or n. $" {
+	send_gdb "y\n"
+	exp_continue
+    }
+    -re "Starting program.*Breakpoint \[0-9\]+,.*main .*argc.*argv.* at .*$srcfile:$bp_location6.*$bp_location6\[\t \]+if .argc.* \{.*$gdb_prompt $"\
+	                    { pass "run until function breakpoint, optimized file" }
+    -re "Starting program.*Breakpoint \[0-9\]+,.*main .*argc.*argv.* at .*$gdb_prompt $"\
+	                    { pass "run until function breakpoint, optimized file (code motion)" }
+    -re ".*$gdb_prompt $"       { fail "run until function breakpoint, optimized file" }
+    timeout	            { fail "run until function breakpoint, optimized file (timeout)" }
+  }
+} else {
+    if ![target_info exists gdb_stub] {
+	gdb_test continue ".*Continuing\\..*Breakpoint \[0-9\]+, main \\(argc=.*, argv=.*, envp=.*\\) at .*$srcfile:$bp_location6.*$bp_location6\[\t \]+if .argc.*\{.*" "stub continue, optimized file"
+    }
+}
+
+#
+# run until the breakpoint at a small function
+#
+
+#
+# Add a second pass pattern.  The behavior differs here between stabs
+# and dwarf for one-line functions.  Stabs preserves two line symbols
+# (one before the prologue and one after) with the same line number, 
+# but dwarf regards these as duplicates and discards one of them.
+# Therefore the address after the prologue (where the breakpoint is)
+# has no exactly matching line symbol, and GDB reports the breakpoint
+# as if it were in the middle of a line rather than at the beginning.
+
+set bp_location13 [gdb_get_line_number "set breakpoint 13 here" $srcfile1]
+set bp_location14 [gdb_get_line_number "set breakpoint 14 here" $srcfile1]
+send_gdb "continue\n"
+gdb_expect {
+    -re "Breakpoint $decimal, marker4 \\(d=177601976\\) at .*$srcfile1:$bp_location13\[\r\n\]+$bp_location13\[\t \]+void marker4.*" {
+	pass "run until breakpoint set at small function, optimized file"
+    }
+    -re "Breakpoint $decimal, $hex in marker4 \\(d=177601976\\) at .*$srcfile1:$bp_location13\[\r\n\]+$bp_location13\[\t \]+void marker4.*" {
+	pass "run until breakpoint set at small function, optimized file"
+    }
+    -re "Breakpoint $decimal, marker4 \\(d=177601976\\) at .*$srcfile1:$bp_location14\[\r\n\]+$bp_location14\[\t \]+void marker4.*" {
+        # marker4() is defined at line 46 when compiled with -DPROTOTYPES
+	pass "run until breakpoint set at small function, optimized file (line bp_location14)"
+    }
+    -re ".*$gdb_prompt " {
+	fail "run until breakpoint set at small function, optimized file"
+    }
+    timeout {
+	fail "run until breakpoint set at small function, optimized file (timeout)"
+    }
+}
+
+
+# Reset the default arguments for VxWorks
+if [istarget "*-*-vxworks*"] {
+    set timeout 10
+    verbose "Timeout is now $timeout seconds" 2
+    send_gdb "set args main\n"
+    gdb_expect -re ".*$gdb_prompt $" {}
+}
diff --git a/gdb/testsuite/gdb.pie/break1.c b/gdb/testsuite/gdb.pie/break1.c
new file mode 100644
--- /dev/null
+++ b/gdb/testsuite/gdb.pie/break1.c
@@ -0,0 +1,44 @@
+/* This testcase is part of GDB, the GNU debugger.
+
+   Copyright 1992, 1993, 1994, 1995, 1999, 2002, 2003 Free Software
+   Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+ 
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+   Please email any bugs, comments, and/or additions to this file to:
+   bug-gdb@prep.ai.mit.edu  */
+
+/* The code for this file was extracted from the gdb testsuite
+   testcase "break.c". */
+
+/* The following functions do nothing useful.  They are included
+   simply as places to try setting breakpoints at.  They are
+   explicitly "one-line functions" to verify that this case works
+   (some versions of gcc have or have had problems with this).
+  
+   These functions are in a separate source file to prevent an
+   optimizing compiler from inlining them and optimizing them away. */
+
+#ifdef PROTOTYPES
+int marker1 (void) { return (0); }	/* set breakpoint 15 here */
+int marker2 (int a) { return (1); }	/* set breakpoint 8 here */
+void marker3 (char *a, char *b) {}	/* set breakpoint 17 here */
+void marker4 (long d) {}		/* set breakpoint 14 here */
+#else
+int marker1 () { return (0); }		/* set breakpoint 16 here */
+int marker2 (a) int a; { return (1); }	/* set breakpoint 9 here */
+void marker3 (a, b) char *a, *b; {}	/* set breakpoint 18 here */
+void marker4 (d) long d; {}		/* set breakpoint 13 here */
+#endif
diff --git a/gdb/testsuite/gdb.pie/corefile.exp b/gdb/testsuite/gdb.pie/corefile.exp
new file mode 100644
--- /dev/null
+++ b/gdb/testsuite/gdb.pie/corefile.exp
@@ -0,0 +1,233 @@
+# Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
+# Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
+
+# This file was written by Fred Fish. (fnf@cygnus.com)
+
+# are we on a target board
+if ![isnative] then {
+    return
+}
+
+set testfile "coremaker"
+set srcfile ${testfile}.c
+set binfile [standard_output_file ${testfile}]
+if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug "additional_flags=-fpie -pie"}] != "" } {
+     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
+}
+
+# Create and source the file that provides information about the compiler
+# used to compile the test case.
+if [get_compiler_info ${binfile}] {
+    return -1;
+}
+
+# Create a core file named "corefile" rather than just "core", to
+# avoid problems with sys admin types that like to regularly prune all
+# files named "core" from the system.
+#
+# Arbitrarily try setting the core size limit to "unlimited" since
+# this does not hurt on systems where the command does not work and
+# allows us to generate a core on systems where it does.
+#
+# Some systems append "core" to the name of the program; others append
+# the name of the program to "core"; still others (like Linux, as of
+# May 2003) create cores named "core.PID".  In the latter case, we
+# could have many core files lying around, and it may be difficult to
+# tell which one is ours, so let's run the program in a subdirectory.
+set found 0
+set coredir [standard_output_file coredir.[getpid]]
+file mkdir $coredir
+catch "system \"(cd ${coredir}; ulimit -c unlimited; ${binfile}; true) >/dev/null 2>&1\""
+#      remote_exec host "${binfile}"
+foreach i "${coredir}/core ${coredir}/core.coremaker.c ${binfile}.core" {
+    if [remote_file build exists $i] {
+	remote_exec build "mv $i [standard_output_file corefile]"
+	set found 1
+    }
+}
+# Check for "core.PID".
+if { $found == 0 } {
+    set names [glob -nocomplain -directory $coredir core.*]
+    if {[llength $names] == 1} {
+        set corefile [file join $coredir [lindex $names 0]]
+        remote_exec build "mv $corefile [standard_output_file corefile]"
+        set found 1
+    }
+}
+if { $found == 0 } {
+    # The braindamaged HPUX shell quits after the ulimit -c above
+    # without executing ${binfile}.  So we try again without the
+    # ulimit here if we didn't find a core file above.
+    # Oh, I should mention that any "braindamaged" non-Unix system has
+    # the same problem. I like the cd bit too, it's really neat'n stuff.
+    catch "system \"(cd [file dirname [standard_output_file ${binfile}]]; ${binfile}; true) >/dev/null 2>&1\""
+    foreach i "[standard_output_file core] [standard_output_file core.coremaker.c] ${binfile}.core" {
+	if [remote_file build exists $i] {
+	    remote_exec build "mv $i [standard_output_file corefile]"
+	    set found 1
+	}
+    }
+}
+
+# Try to clean up after ourselves. 
+remote_file build delete [file join $coredir coremmap.data]
+remote_exec build "rmdir $coredir"
+    
+if { $found == 0  } {
+    warning "can't generate a core file - core tests suppressed - check ulimit -c"
+    return 0
+}
+
+#
+# Test that we can simply startup with a "-core=corefile" command line arg
+# and recognize that the core file is a valid, usable core file.
+# To do this, we must shutdown the currently running gdb and restart
+# with the -core args.  We can't use gdb_start because it looks for
+# the first gdb prompt, and the message we are looking for occurs
+# before the first prompt.  Also, we can't include GDBFLAGS because
+# if it is empty, this confuses gdb with an empty argument that it
+# grumbles about (said grumbling currently being ignored in gdb_start).
+# **FIXME**
+#
+# Another problem is that on some systems (solaris for example), there
+# is apparently a limit on the length of a fully specified path to 
+# the coremaker executable, at about 80 chars.  For this case, consider
+# it a pass, but note that the program name is bad.
+
+gdb_exit
+if $verbose>1 then {
+    send_user "Spawning $GDB -nw $GDBFLAGS -core=[standard_output_file corefile]\n"
+}
+
+set oldtimeout $timeout
+set timeout [expr "$timeout + 60"]
+verbose "Timeout is now $timeout seconds" 2
+eval "spawn $GDB -nw $GDBFLAGS -core=[standard_output_file corefile]"
+expect {
+    -re "Couldn't find .* registers in core file.*$gdb_prompt $" {
+        fail "args: -core=corefile (couldn't find regs)"
+    }
+    -re "Core was generated by .*coremaker.*\r\n\#0  .*\(\).*\r\n$gdb_prompt $" {
+	pass "args: -core=corefile"
+    }
+    -re "Core was generated by .*\r\n\#0  .*\(\).*\r\n$gdb_prompt $" {
+	pass "args: -core=corefile (with bad program name)"
+    }
+    -re ".*registers from core file: File in wrong format.* $" {
+	fail "args: -core=corefile (could not read registers from core file)"
+    }
+    -re ".*$gdb_prompt $"	{ fail "args: -core=corefile" }
+    timeout 		{ fail "(timeout) starting with -core" }
+}
+
+
+#
+# Test that startup with both an executable file and -core argument.
+# See previous comments above, they are still applicable.
+#
+
+close;
+
+if $verbose>1 then {
+    send_user "Spawning $GDB -nw $GDBFLAGS $binfile -core=[standard_output_file corefile]\n"
+}
+
+
+eval "spawn $GDB -nw $GDBFLAGS $binfile -core=[standard_output_file corefile]";
+expect {
+    -re "Core was generated by .*coremaker.*\r\n\#0  .*\(\).*\r\n$gdb_prompt $" {
+	pass "args: execfile -core=corefile"
+    }
+    -re "Core was generated by .*\r\n\#0  .*\(\).*\r\n$gdb_prompt $"	 {
+	pass "args: execfile -core=corefile (with bad program name)"
+    }
+    -re ".*registers from core file: File in wrong format.* $" {
+	fail "args: execfile -core=corefile (could not read registers from core file)"
+    }
+    -re ".*$gdb_prompt $"	{ fail "args: execfile -core=corefile" }
+    timeout 		{ fail "(timeout) starting with -core" }
+}
+set timeout $oldtimeout
+verbose "Timeout is now $timeout seconds" 2
+
+close;
+
+# Now restart normally.
+
+gdb_start
+gdb_reinitialize_dir $srcdir/$subdir
+gdb_load ${binfile}
+
+# Test basic corefile recognition via core-file command.
+
+send_gdb "core-file [standard_output_file corefile]\n"
+gdb_expect {
+    -re ".* program is being debugged already.*y or n. $" {
+	# gdb_load may connect us to a gdbserver.
+	send_gdb "y\n"
+	exp_continue;
+    }
+    -re "Core was generated by .*coremaker.*\r\n\#0  .*\(\).*\r\n$gdb_prompt $" {
+	pass "core-file command"
+    }
+    -re "Core was generated by .*\r\n\#0  .*\(\).*\r\n$gdb_prompt $" {
+	pass "core-file command (with bad program name)"
+    }
+    -re ".*registers from core file: File in wrong format.* $" {
+	fail "core-file command (could not read registers from core file)"
+    }
+    -re ".*$gdb_prompt $"	{ fail "core-file command" }
+    timeout 		{ fail "(timeout) core-file command" }
+}
+
+# Test correct mapping of corefile sections by printing some variables.
+
+gdb_test "print coremaker_data" "\\\$$decimal = 202"
+gdb_test "print coremaker_bss" "\\\$$decimal = 10"
+gdb_test "print coremaker_ro" "\\\$$decimal = 201"
+
+gdb_test "print func2::coremaker_local" "\\\$$decimal = \\{0, 1, 2, 3, 4\\}"
+
+# Somehow we better test the ability to read the registers out of the core
+# file correctly.  I don't think the other tests do this.
+
+gdb_test "bt" "abort.*func2.*func1.*main.*" "backtrace in corefile.exp"
+gdb_test "up" "#\[0-9\]* *\[0-9xa-fH'\]* in .* \\(.*\\).*" "up in corefile.exp"
+
+# Test ability to read mmap'd data
+
+gdb_test "x/8bd buf1" ".*:.*0.*1.*2.*3.*4.*5.*6.*7" "accessing original mmap data in core file"
+setup_xfail "*-*-sunos*" "*-*-ultrix*" "*-*-aix*"
+set test "accessing mmapped data in core file"
+gdb_test_multiple "x/8bd buf2" "$test" {
+    -re ".*:.*0.*1.*2.*3.*4.*5.*6.*7.*$gdb_prompt $" {
+	pass "$test"
+    }
+    -re "0x\[f\]*:.*Cannot access memory at address 0x\[f\]*.*$gdb_prompt $" {
+	fail "$test (mapping failed at runtime)"
+    }
+    -re "0x.*:.*Cannot access memory at address 0x.*$gdb_prompt $" {
+	fail "$test (mapping address not found in core file)"
+    }
+}
+
+# test reinit_frame_cache
+
+gdb_load ${binfile}
+gdb_test "up" "#\[0-9\]* *\[0-9xa-fH'\]* in .* \\(.*\\).*" "up in corefile.exp (reinit)"
+
+gdb_test "core" "No core file now."
diff --git a/gdb/testsuite/gdb.pie/coremaker.c b/gdb/testsuite/gdb.pie/coremaker.c
new file mode 100644
--- /dev/null
+++ b/gdb/testsuite/gdb.pie/coremaker.c
@@ -0,0 +1,142 @@
+/* Copyright 1992, 1993, 1994, 1995, 1996, 1999
+   Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or (at
+   your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* Simple little program that just generates a core dump from inside some
+   nested function calls. */
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#ifndef __STDC__
+#define	const	/**/
+#endif
+
+#define MAPSIZE (8 * 1024)
+
+/* Don't make these automatic vars or we will have to walk back up the
+   stack to access them. */
+
+char *buf1;
+char *buf2;
+
+int coremaker_data = 1;	/* In Data section */
+int coremaker_bss;	/* In BSS section */
+
+const int coremaker_ro = 201;	/* In Read-Only Data section */
+
+/* Note that if the mapping fails for any reason, we set buf2
+   to -1 and the testsuite notices this and reports it as
+   a failure due to a mapping error.  This way we don't have
+   to test for specific errors when running the core maker. */
+
+void
+mmapdata ()
+{
+  int j, fd;
+
+  /* Allocate and initialize a buffer that will be used to write
+     the file that is later mapped in. */
+
+  buf1 = (char *) malloc (MAPSIZE);
+  for (j = 0; j < MAPSIZE; ++j)
+    {
+      buf1[j] = j;
+    }
+
+  /* Write the file to map in */
+
+  fd = open ("coremmap.data", O_CREAT | O_RDWR, 0666);
+  if (fd == -1)
+    {
+      perror ("coremmap.data open failed");
+      buf2 = (char *) -1;
+      return;
+    }
+  write (fd, buf1, MAPSIZE);
+
+  /* Now map the file into our address space as buf2 */
+
+  buf2 = (char *) mmap (0, MAPSIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);
+  if (buf2 == (char *) -1)
+    {
+      perror ("mmap failed");
+      return;
+    }
+
+  /* Verify that the original data and the mapped data are identical.
+     If not, we'd rather fail now than when trying to access the mapped
+     data from the core file. */
+
+  for (j = 0; j < MAPSIZE; ++j)
+    {
+      if (buf1[j] != buf2[j])
+	{
+	  fprintf (stderr, "mapped data is incorrect");
+	  buf2 = (char *) -1;
+	  return;
+	}
+    }
+}
+
+void
+func2 ()
+{
+  int coremaker_local[5];
+  int i;
+
+#ifdef SA_FULLDUMP
+  /* Force a corefile that includes the data section for AIX.  */
+  {
+    struct sigaction sa;
+
+    sigaction (SIGABRT, (struct sigaction *)0, &sa);
+    sa.sa_flags |= SA_FULLDUMP;
+    sigaction (SIGABRT, &sa, (struct sigaction *)0);
+  }
+#endif
+
+  /* Make sure that coremaker_local doesn't get optimized away. */
+  for (i = 0; i < 5; i++)
+    coremaker_local[i] = i;
+  coremaker_bss = 0;
+  for (i = 0; i < 5; i++)
+    coremaker_bss += coremaker_local[i];
+  coremaker_data = coremaker_ro + 1;
+  abort ();
+}
+
+void
+func1 ()
+{
+  func2 ();
+}
+
+int main ()
+{
+  mmapdata ();
+  func1 ();
+  return 0;
+}
+
