[gdb/testsuite] Support recording of getrandom

Add missing support for recording of linux syscall getrandom.

Tested on x86_64-linux with native and target board unix/-m32.

---
 gdb/aarch64-linux-tdep.c                |  2 ++
 gdb/amd64-linux-tdep.c                  |  3 ++
 gdb/amd64-linux-tdep.h                  |  3 +-
 gdb/arm-linux-tdep.c                    |  1 +
 gdb/linux-record.c                      |  6 ++++
 gdb/linux-record.h                      |  1 +
 gdb/ppc-linux-tdep.c                    |  2 ++
 gdb/s390-linux-tdep.c                   |  2 ++
 gdb/testsuite/gdb.reverse/getrandom.c   | 41 ++++++++++++++++++++++++
 gdb/testsuite/gdb.reverse/getrandom.exp | 56 +++++++++++++++++++++++++++++++++
 10 files changed, 116 insertions(+), 1 deletion(-)

diff --git a/gdb/aarch64-linux-tdep.c b/gdb/aarch64-linux-tdep.c
index cb132d5a540..437fd083fa7 100644
--- a/gdb/aarch64-linux-tdep.c
+++ b/gdb/aarch64-linux-tdep.c
@@ -1137,6 +1137,7 @@ enum aarch64_syscall {
   aarch64_sys_finit_module = 273,
   aarch64_sys_sched_setattr = 274,
   aarch64_sys_sched_getattr = 275,
+  aarch64_sys_getrandom = 278
 };
 
 /* aarch64_canonicalize_syscall maps syscall ids from the native AArch64
@@ -1419,6 +1420,7 @@ aarch64_canonicalize_syscall (enum aarch64_syscall syscall_number)
       UNSUPPORTED_SYSCALL_MAP (finit_module);
       UNSUPPORTED_SYSCALL_MAP (sched_setattr);
       UNSUPPORTED_SYSCALL_MAP (sched_getattr);
+      SYSCALL_MAP (getrandom);
   default:
     return gdb_sys_no_syscall;
   }
diff --git a/gdb/amd64-linux-tdep.c b/gdb/amd64-linux-tdep.c
index 9788711d296..02f87ddac32 100644
--- a/gdb/amd64-linux-tdep.c
+++ b/gdb/amd64-linux-tdep.c
@@ -463,6 +463,9 @@ amd64_canonicalize_syscall (enum amd64_syscall syscall_number)
   case amd64_sys_pipe2:
     return gdb_sys_pipe2;
 
+  case amd64_sys_getrandom:
+    return gdb_sys_getrandom;
+
   case amd64_sys_select:
   case amd64_x32_sys_select:
     return gdb_sys_select;
diff --git a/gdb/amd64-linux-tdep.h b/gdb/amd64-linux-tdep.h
index 184b0c86f07..ef111f4ac2a 100644
--- a/gdb/amd64-linux-tdep.h
+++ b/gdb/amd64-linux-tdep.h
@@ -320,7 +320,8 @@ enum amd64_syscall {
   amd64_sys_sync_file_range = 277,
   amd64_sys_vmsplice = 278,
   amd64_sys_move_pages = 279,
-  amd64_sys_pipe2 = 293
+  amd64_sys_pipe2 = 293,
+  amd64_sys_getrandom = 318
 };
 
 /* Enum that defines the syscall identifiers for x32 linux.
diff --git a/gdb/arm-linux-tdep.c b/gdb/arm-linux-tdep.c
index 6aac016afb9..be9f203bd8e 100644
--- a/gdb/arm-linux-tdep.c
+++ b/gdb/arm-linux-tdep.c
@@ -1610,6 +1610,7 @@ arm_canonicalize_syscall (int syscall)
     case 378: return gdb_sys_kcmp;
     case 379: return gdb_sys_finit_module;
       */
+    case 384: return gdb_sys_getrandom;
     case 983041: /* ARM_breakpoint */ return gdb_sys_no_syscall;
     case 983042: /* ARM_cacheflush */ return gdb_sys_no_syscall;
     case 983043: /* ARM_usr26 */ return gdb_sys_no_syscall;
diff --git a/gdb/linux-record.c b/gdb/linux-record.c
index 0af1ef2a9e0..ffc6337d18a 100644
--- a/gdb/linux-record.c
+++ b/gdb/linux-record.c
@@ -356,6 +356,12 @@ record_linux_system_call (enum gdb_syscall syscall,
 	return -1;
       break;
 
+    case gdb_sys_getrandom:
+      regcache_raw_read_unsigned (regcache, tdep->arg2, &tmpulongest);
+      if (record_mem_at_reg (regcache, tdep->arg1, tmpulongest))
+	return -1;
+      break;
+
     case gdb_sys_times:
       if (record_mem_at_reg (regcache, tdep->arg1, tdep->size_tms))
 	return -1;
diff --git a/gdb/linux-record.h b/gdb/linux-record.h
index 219c67f888d..c70d75b0d6e 100644
--- a/gdb/linux-record.h
+++ b/gdb/linux-record.h
@@ -510,6 +510,7 @@ enum gdb_syscall {
   gdb_sys_dup3 = 330,
   gdb_sys_pipe2 = 331,
   gdb_sys_inotify_init1 = 332,
+  gdb_sys_getrandom = 355,
   gdb_sys_statx = 383,
   gdb_sys_socket = 500,
   gdb_sys_connect = 501,
diff --git a/gdb/ppc-linux-tdep.c b/gdb/ppc-linux-tdep.c
index 0b165fe2ca3..cb215f9cc51 100644
--- a/gdb/ppc-linux-tdep.c
+++ b/gdb/ppc-linux-tdep.c
@@ -1406,6 +1406,8 @@ ppc_canonicalize_syscall (int syscall, int wordsize)
     result = gdb_sys_recvfrom;
   else if (syscall == 342)
     result = gdb_sys_recvmsg;
+  else if (syscall == 359)
+    result = gdb_sys_getrandom;
 
   return (enum gdb_syscall) result;
 }
diff --git a/gdb/s390-linux-tdep.c b/gdb/s390-linux-tdep.c
index 56cc147a391..d4ae9275e36 100644
--- a/gdb/s390-linux-tdep.c
+++ b/gdb/s390-linux-tdep.c
@@ -787,6 +787,8 @@ s390_canonicalize_syscall (int syscall, enum s390_abi_kind abi)
 	/* ioprio_set .. epoll_pwait */
 	else if (syscall >= 282 && syscall <= 312)
 	  ret = syscall + 7;
+	else if (syscall == 349)
+	  ret = gdb_sys_getrandom;
 	else
 	  ret = gdb_sys_no_syscall;
 
diff --git a/gdb/testsuite/gdb.reverse/getrandom.c b/gdb/testsuite/gdb.reverse/getrandom.c
new file mode 100644
index 00000000000..162de6ed81b
--- /dev/null
+++ b/gdb/testsuite/gdb.reverse/getrandom.c
@@ -0,0 +1,41 @@
+/* This testcase is part of GDB, the GNU debugger.
+
+   Copyright 2022 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include <sys/random.h>
+
+void
+marker1 (void)
+{
+}
+
+void
+marker2 (void)
+{
+}
+
+unsigned char buf[6];
+
+int
+main (void)
+{
+  buf[0] = 0xff;
+  buf[5] = 0xff;
+  marker1 ();
+  volatile ssize_t r = getrandom (&buf[1], 4, 0);
+  marker2 ();
+  return 0;
+}
diff --git a/gdb/testsuite/gdb.reverse/getrandom.exp b/gdb/testsuite/gdb.reverse/getrandom.exp
new file mode 100644
index 00000000000..b1c7d9dad80
--- /dev/null
+++ b/gdb/testsuite/gdb.reverse/getrandom.exp
@@ -0,0 +1,56 @@
+# Copyright 2022 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+# This file is part of the gdb testsuite.
+
+#
+# This test tests getrandom syscall for reverse execution.
+#
+
+if ![supports_reverse] {
+    return
+}
+
+standard_testfile
+
+if { [prepare_for_testing "failed to prepare" $testfile $srcfile] } {
+    return -1
+}
+
+runto_main
+
+if [supports_process_record] {
+    # Activate process record/replay
+    gdb_test_no_output "record" "turn on process record"
+}
+
+gdb_test "break marker2" \
+    "Breakpoint $decimal at $hex: file .*$srcfile, line $decimal.*" \
+    "set breakpoint at marker2"
+
+gdb_continue_to_breakpoint "marker2" ".*$srcfile:.*"
+
+gdb_test "break marker1" \
+    "Breakpoint $decimal at $hex: file .*$srcfile, line $decimal.*" \
+    "set breakpoint at marker1"
+
+gdb_test "reverse-continue" ".*$srcfile:$decimal.*" "reverse to marker1"
+
+gdb_test "print (unsigned)buf\[0\]" ".* = 255" "check buf\[0\]"
+gdb_test "print (unsigned)buf\[1\]" ".* = 0" "check buf\[1\]"
+gdb_test "print (unsigned)buf\[2\]" ".* = 0" "check buf\[2\]"
+gdb_test "print (unsigned)buf\[3\]" ".* = 0" "check buf\[3\]"
+gdb_test "print (unsigned)buf\[4\]" ".* = 0" "check buf\[4\]"
+gdb_test "print (unsigned)buf\[5\]" ".* = 255" "check buf\[5\]"
