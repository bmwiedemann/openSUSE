From 3f0c512dc37dbede372a018732d315726a56d10e Mon Sep 17 00:00:00 2001
From: Tom de Vries <tdevries@suse.de>
Date: Wed, 1 Nov 2023 08:07:15 +0100
Subject: [PATCH] [gdb/tdep] Fix nr array elements in ppc64_aggregate_candidate

On AlmaLinux 9.2 powerpc64le I run into:
...
(gdb) PASS: gdb.ada/array_return.exp: continuing to Create_Small_Float_Vector
finish^M
Run till exit from #0  pck.create_small_float_vector () at pck.adb:30^M
0x00000000100022d4 in p () at p.adb:25^M
25         Vector := Create_Small_Float_Vector;^M
Value returned is $3 = (2.80259693e-45, 2.80259693e-45)^M
(gdb) FAIL: gdb.ada/array_return.exp: value printed by finish of Create_Small_Float_Vector
...
while this is expected:
...
Value returned is $3 = (4.25, 4.25)^M
...

The problem is here in ppc64_aggregate_candidate:
...
		  if (!get_array_bounds (type, &low_bound, &high_bound))
		    return -1;
		  count *= high_bound - low_bound
...

The array type (containing 2 elements) is:
...
   type Small_Float_Vector is array (1 .. 2) of Float;
...
so we have:
...
(gdb) p	low_bound
$1 = 1
(gdb) p	high_bound
$2 = 2
...
but we calculate the number of elements in the array using
"high_bound - low_bound", which is 1.

Consequently, gdb fails to correctly classify the type as a ELFv2 homogeneous
aggregate.

Fix this by calculating the number of elements in the array by using
"high_bound - low_bound + 1" instead.

Furthermore, high_bound can (in general, though perhaps not here) be also be
smaller than low_bound, so to be safe take that into account as well:
...
	  LONGEST nr_array_elements = (low_bound > high_bound
				       ? 0
				       : (high_bound - low_bound + 1));
	  count *= nr_array_elements;
...

Tested on powerpc64le-linux.

PR tdep/31015
Bug: https://sourceware.org/bugzilla/show_bug.cgi?id=31015
---
 gdb/ppc-sysv-tdep.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/gdb/ppc-sysv-tdep.c b/gdb/ppc-sysv-tdep.c
index 9cea63307e6..dc89201eed2 100644
--- a/gdb/ppc-sysv-tdep.c
+++ b/gdb/ppc-sysv-tdep.c
@@ -1126,7 +1126,11 @@ ppc64_aggregate_candidate (struct type *type,
 
 	  if (!get_array_bounds (type, &low_bound, &high_bound))
 	    return -1;
-	  count *= high_bound - low_bound;
+
+	  LONGEST nr_array_elements = (low_bound > high_bound
+				       ? 0
+				       : (high_bound - low_bound + 1));
+	  count *= nr_array_elements;
 
 	  /* There must be no padding.  */
 	  if (count == 0)

base-commit: b1136560e772dd4c74f1fbb41f6ba840b92fb9d6
-- 
2.35.3

