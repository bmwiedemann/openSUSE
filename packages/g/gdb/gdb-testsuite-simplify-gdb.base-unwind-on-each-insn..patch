From 525bc63f2afc749f967f98730623de3a6895a5e9 Mon Sep 17 00:00:00 2001
From: Tom de Vries <tdevries@suse.de>
Date: Mon, 23 Jan 2023 10:32:45 +0100
Subject: [PATCH 2/4] [gdb/testsuite] Simplify gdb.base/unwind-on-each-insn.exp

In test-case gdb.base/unwind-on-each-insn.exp, we try to determine the last
disassembled insn in function foo.

This in it self is fragile, as demonstrated by commit 91836f41e20 ("Powerpc
fix for gdb.base/unwind-on-each-insn.exp").

The use of the last disassembled insn in the test-case is to stop stepping in
foo once reaching it.

However, the intent is to stop stepping just before returning to main.

There is no guarantee that the last disassembled insn:
- is actually executed
- is executed just before returning to main
- is executed only once.

Fix this by simplying the test-case to continue stepping till stepping out of
foo.

Tested on x86_64-linux.
---
 .../gdb.base/unwind-on-each-insn.exp          | 62 ++++---------------
 1 file changed, 11 insertions(+), 51 deletions(-)

diff --git a/gdb/testsuite/gdb.base/unwind-on-each-insn.exp b/gdb/testsuite/gdb.base/unwind-on-each-insn.exp
index c8748d5ae14..5e822effaf1 100644
--- a/gdb/testsuite/gdb.base/unwind-on-each-insn.exp
+++ b/gdb/testsuite/gdb.base/unwind-on-each-insn.exp
@@ -73,51 +73,6 @@ set main_fid [get_fid]
 gdb_breakpoint "*foo"
 gdb_continue_to_breakpoint "enter foo"
 
-# Figure out the range of addresses covered by this function.
-set last_addr_in_foo ""
-
-# The disassembly of foo on PowerPC looks like:
-#     Dump of assembler code for function foo:
-#  => 0x00000000100006dc <+0>:     std     r31,-8(r1)
-#     0x00000000100006e0 <+4>:     stdu    r1,-48(r1)
-#     0x00000000100006e4 <+8>:     mr      r31,r1
-#     0x00000000100006e8 <+12>:    nop
-#     0x00000000100006ec <+16>:    addi    r1,r31,48
-#     0x00000000100006f0 <+20>:    ld      r31,-8(r1)
-#     0x00000000100006f4 <+24>:    blr
-#     0x00000000100006f8 <+28>:    .long 0x0
-#     0x00000000100006fc <+32>:    .long 0x0
-#     0x0000000010000700 <+36>:    .long 0x1000180
-#     End of assembler dump.
-#
-# The last instruction in function foo is blr.  Need to ignore the .long
-# entries following the blr instruction.
-
-gdb_test_multiple "disassemble foo" "" {
-    -re "^disassemble foo\r\n" {
-	exp_continue
-    }
-
-    -re "^Dump of assembler code for function foo:\r\n" {
-	exp_continue
-    }
-
-    -re "^...($hex) \[<>+0-9:\s\t\]*\.long\[\s\t\]*\[^\r\n\]*\r\n" {
-	exp_continue
-    }
-
-    -re "^...($hex) \[^\r\n\]+\r\n" {
-	set last_addr_in_foo $expect_out(1,string)
-	exp_continue
-    }
-
-    -wrap -re "^End of assembler dump\\." {
-	gdb_assert { ![string equal $last_addr_in_foo ""] } \
-	    "found some addresses in foo"
-	pass $gdb_test_name
-    }
-}
-
 # Record the current stack-pointer, and the frame base address.
 lassign [get_sp_and_fba "in foo"] foo_sp foo_fba
 set foo_fid [get_fid]
@@ -158,11 +113,6 @@ for { set i_count 1 } { true } { incr i_count } {
 	# Move back to the inner most frame.
 	gdb_test "frame 0" ".*"
 
-	set pc [get_hexadecimal_valueof "\$pc" "*UNKNOWN*"]
-	if { $pc == $last_addr_in_foo } {
-	    break
-	}
-
 	if { $i_count > 100 } {
 	    # We expect a handful of instructions, if we reach 100,
 	    # something is going wrong.  Avoid an infinite loop.
@@ -170,6 +120,16 @@ for { set i_count 1 } { true } { incr i_count } {
 	    break
 	}
 
-	gdb_test "stepi" ".*"
+	set in_foo 0
+	gdb_test_multiple "stepi" "" {
+	    -re -wrap "$hex in foo \\(\\)" {
+		set in_foo 1
+	    }
+	    -re -wrap "" {}
+	}
+
+	if { ! $in_foo } {
+	    break
+	}
     }
 }
-- 
2.35.3

