From e13b5af2c0bc0cdf1b2d66f184fff4ba019b28ec Mon Sep 17 00:00:00 2001
From: Tom de Vries <tdevries@suse.de>
Date: Wed, 4 Sep 2024 10:07:19 +0200
Subject: [PATCH 12/46] [gdb/testsuite] Fix gdb.dwarf2/dw2-lines.exp on
 arm-linux

With test-case gdb.dwarf2/dw2-lines.exp on arm-linux, I run into:
...
(gdb) break bar_label^M
Breakpoint 2 at 0x4004f6: file dw2-lines.c, line 29.^M
(gdb) continue^M
Continuing.^M
^M
Breakpoint 2, bar () at dw2-lines.c:29^M
29        foo (2);^M
(gdb) PASS: $exp: cv=2: cdw=32: lv=2: ldw=32: continue to breakpoint: foo \(1\)
...

The pass is incorrect because the continue lands at line 29 with "foo (2)"
instead of line line 27 with "foo (1)".

A minimal version is:
...
$ gdb -q -batch dw2-lines.cv-2-cdw-32-lv-2-ldw-32 -ex "b bar_label"
Breakpoint 1 at 0x4f6: file dw2-lines.c, line 29.
...
where:
...
000004ec <bar>:
 4ec:	b580      	push	{r7, lr}
 4ee:	af00      	add	r7, sp, #0

000004f0 <bar_label>:
 4f0:	2001      	movs	r0, #1
 4f2:	f7ff fff1 	bl	4d8 <foo>

000004f6 <bar_label_2>:
 4f6:	2002      	movs	r0, #2
 4f8:	f7ff ffee 	bl	4d8 <foo>
...

So, how does this happen?  In short:
- skip_prologue_sal calls arm_skip_prologue with pc == 0x4ec,
- thumb_analyze_prologue returns 0x4f2
  (overshooting by 1 insn, PR tdep/31981), and
- skip_prologue_sal decides that we're mid-line, and updates to 0x4f6.

However, this is a test-case about .debug_line info, so why didn't arm_skip_prologue
use the line info to skip the prologue?

The answer is that the line info starts at bar_label, not at bar.

Fixing that allows us to work around PR tdep/31981.

Likewise in gdb.dwarf2/dw2-line-number-zero.exp.

Instead, add a new test-case gdb.arch/skip-prologue.exp that is dedicated to
checking quality of architecture-specific prologue analysis, without being
written in an architecture-specific way.

If fails on arm-linux for both marm and mthumb:
...
FAIL: gdb.arch/skip-prologue.exp: f2: $bp_addr == $prologue_end_addr (skipped too much)
FAIL: gdb.arch/skip-prologue.exp: f4: $bp_addr == $prologue_end_addr (skipped too much)
...
and passes for:
- x86_64-linux for {m64,m32}x{-fno-PIE/-no-pie,-fPIE/-pie}
- aarch64-linux.

Tested on arm-linux.
---
 gdb/testsuite/gdb.arch/skip-prologue.c        | 54 +++++++++++++
 gdb/testsuite/gdb.arch/skip-prologue.exp      | 76 +++++++++++++++++++
 .../gdb.dwarf2/dw2-line-number-zero.exp       |  8 ++
 gdb/testsuite/gdb.dwarf2/dw2-lines.c          |  2 +-
 gdb/testsuite/gdb.dwarf2/dw2-lines.exp        |  4 +
 5 files changed, 143 insertions(+), 1 deletion(-)
 create mode 100644 gdb/testsuite/gdb.arch/skip-prologue.c
 create mode 100644 gdb/testsuite/gdb.arch/skip-prologue.exp

diff --git a/gdb/testsuite/gdb.arch/skip-prologue.c b/gdb/testsuite/gdb.arch/skip-prologue.c
new file mode 100644
index 00000000000..08ceacb6aa8
--- /dev/null
+++ b/gdb/testsuite/gdb.arch/skip-prologue.c
@@ -0,0 +1,54 @@
+/* Copyright 2024 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+void
+f1 (void)
+{
+  asm ("f1_prologue_end: .globl f1_prologue_end");
+}
+
+int
+f2 (int a)
+{
+  asm ("f2_prologue_end: .globl f2_prologue_end");
+  return a;
+}
+
+void
+f3 (void)
+{
+  asm ("f3_prologue_end: .globl f3_prologue_end");
+  f1 ();
+}
+
+int
+f4 (int a)
+{
+  asm ("f4_prologue_end: .globl f4_prologue_end");
+  return f2 (a);
+}
+
+int
+main (void)
+{
+  f1 ();
+  f2 (0);
+  f3 ();
+  f4 (0);
+
+  return 0;
+}
diff --git a/gdb/testsuite/gdb.arch/skip-prologue.exp b/gdb/testsuite/gdb.arch/skip-prologue.exp
new file mode 100644
index 00000000000..89d2225151a
--- /dev/null
+++ b/gdb/testsuite/gdb.arch/skip-prologue.exp
@@ -0,0 +1,76 @@
+# Copyright 2024 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+# Test-case that checks architecture-specific prologue analyzers.
+
+standard_testfile
+
+if { [prepare_for_testing "failed to prepare"  $testfile $srcfile \
+	  {nodebug}] } {
+    return -1
+}
+
+proc do_test { f } {
+    set bp_addr ""
+    gdb_test_multiple "break $f" "" {
+	-re -wrap "Breakpoint $::decimal at ($::hex)" {
+	    set bp_addr $expect_out(1,string)
+	    pass $gdb_test_name
+	}
+    }
+
+    if { $bp_addr == "" } {
+	return
+    }
+
+    set prologue_end_addr ""
+    gdb_test_multiple "p /x &${f}_prologue_end" "" {
+	-re -wrap " = ($::hex)" {
+	    set prologue_end_addr $expect_out(1,string)
+	    pass $gdb_test_name
+	}
+    }
+
+    if { $prologue_end_addr == "" } {
+	return
+    }
+
+    set test {$bp_addr == $prologue_end_addr}
+    if { [expr $test] } {
+	pass $test
+    } elseif { $bp_addr < $prologue_end_addr } {
+	# We'll allow this.  For instance, amd64 has a prologue
+	# analyzer that doesn't skip the 3rd instruction here, which saves an
+	# argument register to stack:
+	#
+	#   00000000004004ae <f2>:
+	#   4004ae:       55                      push   %rbp
+	#   4004af:       48 89 e5                mov    %rsp,%rbp
+	#   4004b2:       89 7d fc                mov    %edi,-0x4(%rbp)
+	#   00000000004004b5 <f2_prologue_end>:
+	#
+	pass "$test (skipped less than possible)"
+    } elseif { $bp_addr > $prologue_end_addr } {
+	fail "$test (skipped too much)"
+    } else {
+	fail "$test"
+    }
+}
+
+foreach f { f1 f2 f3 f4 } {
+    with_test_prefix $f {
+	do_test $f
+    }
+}
diff --git a/gdb/testsuite/gdb.dwarf2/dw2-line-number-zero.exp b/gdb/testsuite/gdb.dwarf2/dw2-line-number-zero.exp
index c510de42037..9124aff1dad 100644
--- a/gdb/testsuite/gdb.dwarf2/dw2-line-number-zero.exp
+++ b/gdb/testsuite/gdb.dwarf2/dw2-line-number-zero.exp
@@ -56,6 +56,10 @@ Dwarf::assemble $asm_file {
 	file_name "$srcfile" 1
 
 	program {
+	    DW_LNE_set_address $bar1_start
+	    line 25
+	    DW_LNS_copy
+
 	    DW_LNE_set_address bar1_label
 	    line 27
 	    DW_LNS_copy
@@ -76,6 +80,10 @@ Dwarf::assemble $asm_file {
 	    DW_LNE_end_sequence
 
 
+	    DW_LNE_set_address $bar2_start
+	    line 39
+	    DW_LNS_copy
+
 	    DW_LNE_set_address bar2_label
 	    line 41
 	    DW_LNS_copy
diff --git a/gdb/testsuite/gdb.dwarf2/dw2-lines.c b/gdb/testsuite/gdb.dwarf2/dw2-lines.c
index 67c98fecf02..221d7b95bc3 100644
--- a/gdb/testsuite/gdb.dwarf2/dw2-lines.c
+++ b/gdb/testsuite/gdb.dwarf2/dw2-lines.c
@@ -22,7 +22,7 @@ foo (int x)
 
 void
 bar (void)
-{
+{ /* bar: */
   asm ("bar_label: .globl bar_label");
   foo (1);
   asm ("bar_label_2: .globl bar_label_2");
diff --git a/gdb/testsuite/gdb.dwarf2/dw2-lines.exp b/gdb/testsuite/gdb.dwarf2/dw2-lines.exp
index af5b6b71768..fd5b83edc5b 100644
--- a/gdb/testsuite/gdb.dwarf2/dw2-lines.exp
+++ b/gdb/testsuite/gdb.dwarf2/dw2-lines.exp
@@ -88,6 +88,10 @@ proc test_1 { _cv _cdw64 _lv _ldw64 {_string_form ""}} {
 		# to set the current file explicitly.
 		DW_LNS_set_file $diridx
 
+		DW_LNE_set_address $bar_start
+		line [line_for bar]
+		DW_LNS_copy
+
 		DW_LNE_set_address bar_label
 		line [line_for bar_label]
 		DW_LNS_copy
-- 
2.43.0

