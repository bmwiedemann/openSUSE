From 439271c6fc28387ea7b6fb6e8bb07963e8b3fd7d Mon Sep 17 00:00:00 2001
From: Tom de Vries <tdevries@suse.de>
Date: Sun, 24 Sep 2023 11:41:39 +0200
Subject: [PATCH 06/11] [gdb/symtab] Keep track of processed DIEs in shard

For optimizations in two following patches, we keep track in each shard which
DIEs have been processed.

Tested on x86_64-linux.
---
 gdb/dwarf2/cooked-index.c |  1 +
 gdb/dwarf2/cooked-index.h | 15 +++++++++++++++
 gdb/dwarf2/read.c         | 24 ++++++++++++++++++++++++
 3 files changed, 40 insertions(+)

diff --git a/gdb/dwarf2/cooked-index.c b/gdb/dwarf2/cooked-index.c
index 4a0ccc78c5d..cef57a96384 100644
--- a/gdb/dwarf2/cooked-index.c
+++ b/gdb/dwarf2/cooked-index.c
@@ -541,6 +541,7 @@ cooked_index_vector::handle_deferred_entries ()
     {
       shard->m_die_range_map.reset (nullptr);
       shard->m_deferred_entries.reset (nullptr);
+      shard->m_die_range_map_valid.reset (nullptr);
     }
 }
 
diff --git a/gdb/dwarf2/cooked-index.h b/gdb/dwarf2/cooked-index.h
index a06d99532ed..9d836379666 100644
--- a/gdb/dwarf2/cooked-index.h
+++ b/gdb/dwarf2/cooked-index.h
@@ -312,6 +312,7 @@ class cooked_index
   {
     m_die_range_map.reset (new parent_map);
     m_deferred_entries.reset (new std::vector<deferred_entry>);
+    m_die_range_map_valid.reset (new addrmap_mutable);
   }
 
   /* Create a new cooked_index_entry and register it with this object.
@@ -403,6 +404,18 @@ class cooked_index
   const cooked_index_entry *resolve_deferred_entry
     (const deferred_entry &entry, const cooked_index_entry *parent_entry);
 
+  /* Mark parents in range [START, END] as valid .  */
+  void set_parent_valid (CORE_ADDR start, CORE_ADDR end)
+  {
+    m_die_range_map_valid->set_empty (start, end, (void *) 1);
+  }
+
+  /* Return true if find_parents can be relied upon.  */
+  bool parent_valid (CORE_ADDR addr)
+  {
+    return m_die_range_map_valid->find (addr) != nullptr;
+  }
+
 private:
 
   /* Return the entry that is believed to represent the program's
@@ -466,6 +479,8 @@ class cooked_index
      understand this.  */
   std::unique_ptr<parent_map> m_die_range_map;
 
+  std::unique_ptr<addrmap> m_die_range_map_valid;
+
   /* The generated DWARF can sometimes have the declaration for a
      method in a class (or perhaps namespace) scope, with the
      definition appearing outside this scope... just one of the many
diff --git a/gdb/dwarf2/read.c b/gdb/dwarf2/read.c
index 41fa8affcd0..ba21b6a14c9 100644
--- a/gdb/dwarf2/read.c
+++ b/gdb/dwarf2/read.c
@@ -6697,6 +6697,12 @@ class cooked_index_storage
     m_index->defer_entry (de);
   }
 
+  /* Mark parents in range [START, END] as valid .  */
+  void set_parent_valid (CORE_ADDR start, CORE_ADDR end)
+  {
+    m_index->set_parent_valid (start, end);
+  }
+
 private:
 
   /* Hash function for a cutu_reader.  */
@@ -6840,6 +6846,11 @@ class cooked_indexer
   {
     m_index_storage->defer_entry (de);
   }
+
+  void set_parent_valid (CORE_ADDR start, CORE_ADDR end)
+  {
+    m_index_storage->set_parent_valid (start, end);
+  }
 };
 
 /* Subroutine of dwarf2_build_psymtabs_hard to simplify it.
@@ -18512,6 +18523,11 @@ cooked_indexer::index_dies (cutu_reader *reader,
 			     + to_underlying (reader->cu->header.sect_off)
 			     + reader->cu->header.get_length ());
 
+  const CORE_ADDR start_cu
+    = parent_map::form_addr (sect_offset (info_ptr - reader->buffer),
+			     reader->cu->per_cu->is_dwz,
+			     reader->cu->per_cu->is_debug_types);
+
   while (info_ptr < end_ptr)
     {
       sect_offset this_die = (sect_offset) (info_ptr - reader->buffer);
@@ -18662,6 +18678,14 @@ cooked_indexer::index_dies (cutu_reader *reader,
 	}
     }
 
+  {
+    CORE_ADDR end_prev_die
+      = parent_map::form_addr (sect_offset (info_ptr - reader->buffer - 1),
+			       reader->cu->per_cu->is_dwz,
+			       reader->cu->per_cu->is_debug_types);
+    set_parent_valid (start_cu, end_prev_die);
+  }
+
   return info_ptr;
 }
 
-- 
2.35.3

