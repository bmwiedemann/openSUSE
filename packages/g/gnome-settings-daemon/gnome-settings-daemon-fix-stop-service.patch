From afc8df459f6603799a50f221e77dfdf4df1d6d56 Mon Sep 17 00:00:00 2001
From: Joan Torres <joan.torres@suse.com>
Date: Wed, 11 Dec 2024 15:29:17 +0100
Subject: [PATCH 1/2] sharing: Stop assigned services properly on manager stop

Assigned services are started when sharing status is not offline.
But they were being stopped only when sharing status is available.
To fix this, stop assigned services when sharing status is not offline.

This doesn't affect configurable services which weren't already started.
---
 plugins/sharing/gsd-sharing-manager.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/plugins/sharing/gsd-sharing-manager.c b/plugins/sharing/gsd-sharing-manager.c
index 8b818c4e..c20b42e6 100644
--- a/plugins/sharing/gsd-sharing-manager.c
+++ b/plugins/sharing/gsd-sharing-manager.c
@@ -951,7 +951,7 @@ gsd_sharing_manager_stop (GsdSharingManager *manager)
 
         cancel_pending_wait_tasks (manager);
 
-        if (manager->sharing_status == GSD_SHARING_STATUS_AVAILABLE &&
+        if (manager->sharing_status != GSD_SHARING_STATUS_OFFLINE &&
             manager->connection != NULL) {
                 manager->sharing_status = GSD_SHARING_STATUS_OFFLINE;
                 gsd_sharing_manager_sync_services (manager);
-- 
2.47.1


From 9d92d287218733c5754c853c0a298874eb704754 Mon Sep 17 00:00:00 2001
From: Joan Torres <joan.torres@suse.com>
Date: Wed, 11 Dec 2024 13:22:56 +0100
Subject: [PATCH 2/2] common: Stop manager before stopping main loop

When the sharing manager is stopped, some async calls are done to stop
some services. If the main loop is stopped before, those calls are not
handled properly and the services are left orphaned.

Stop the manager first and wait a few seconds before stopping the
main loop to allow the async calls to finish successfully.

This fixes an issue where the gnome-remote-desktop-handover.service was
not stopped on logout. Making the session on a new login, use the same old
handover daemon which is still listening to the old handover iface with
the old session id.
---
 plugins/common/daemon-skeleton.h | 26 +++++++++++++++++++-------
 1 file changed, 19 insertions(+), 7 deletions(-)

diff --git a/plugins/common/daemon-skeleton.h b/plugins/common/daemon-skeleton.h
index 40b7f149..8fb12422 100644
--- a/plugins/common/daemon-skeleton.h
+++ b/plugins/common/daemon-skeleton.h
@@ -30,6 +30,7 @@
 
 #define GNOME_SESSION_DBUS_NAME                     "org.gnome.SessionManager"
 #define GNOME_SESSION_CLIENT_PRIVATE_DBUS_INTERFACE "org.gnome.SessionManager.ClientPrivate"
+#define WAIT_BEFORE_STOPPING_LOOP 3
 
 static MANAGER *manager = NULL;
 static int timeout = -1;
@@ -53,10 +54,24 @@ respond_to_end_session (GDBusProxy *proxy)
                            -1, NULL, NULL, NULL);
 }
 
+static gboolean
+stop_loop (gpointer user_data)
+{
+        GMainLoop *loop = user_data;
+
+        if (g_main_loop_is_running (loop))
+                g_main_loop_quit (loop);
+
+        return G_SOURCE_REMOVE;
+}
+
 static void
 do_stop (GMainLoop *loop)
 {
-        g_main_loop_quit (loop);
+        if (manager)
+                STOP (manager);
+
+        g_timeout_add_seconds (WAIT_BEFORE_STOPPING_LOOP, stop_loop, loop);
 }
 
 static void
@@ -149,8 +164,7 @@ handle_sigterm (gpointer user_data)
 
   g_debug ("Got SIGTERM; shutting down ...");
 
-  if (g_main_loop_is_running (main_loop))
-    g_main_loop_quit (main_loop);
+  do_stop (main_loop);
 
   return G_SOURCE_REMOVE;
 }
@@ -229,8 +243,8 @@ main (int argc, char **argv)
 
 	if (timeout > 0) {
 		guint id;
-		id = g_timeout_add_seconds (timeout, (GSourceFunc) g_main_loop_quit, loop);
-		g_source_set_name_by_id (id, "[gnome-settings-daemon] g_main_loop_quit");
+		id = g_timeout_add_seconds (timeout, (GSourceFunc) do_stop, loop);
+		g_source_set_name_by_id (id, "[gnome-settings-daemon] do_stop");
 	}
 
         install_signal_handler (loop);
@@ -255,8 +269,6 @@ main (int argc, char **argv)
 
         g_main_loop_run (loop);
 
-        STOP (manager);
-
         g_object_unref (manager);
         g_bus_unown_name (name_own_id);
 
-- 
2.47.1

