From 2e8296620bc22f97c34f876ab62902e7c3d89601 Mon Sep 17 00:00:00 2001
From: Seungha Yang <seungha.yang@navercorp.com>
Date: Thu, 24 Oct 2019 00:25:28 +0900
Subject: [PATCH] avviddec: Enforce allocate new AVFrame per input frame

... if ffmpeg would reuse the allocated AVBuffer. Reused AVFrame by
the ffmpeg seems to break our decoding flow since the reused AVFrame
holds the initial opaque data (GstVideoCodecFrame in this case), so
we couldn't trace the our in/out frames.
To enforce get_buffer() call per output frame, hold another reference
to the AVBuffer in order to mark the AVBuffer as not writable.

Fixes: https://gitlab.freedesktop.org/gstreamer/gst-libav/issues/62
---
 ext/libav/gstavviddec.c | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/ext/libav/gstavviddec.c b/ext/libav/gstavviddec.c
index 374bd9e..58979d8 100644
--- a/ext/libav/gstavviddec.c
+++ b/ext/libav/gstavviddec.c
@@ -730,6 +730,12 @@ gst_ffmpegviddec_can_direct_render (GstFFMpegVidDec * ffmpegdec)
       AV_CODEC_CAP_DR1);
 }
 
+static void
+gst_ffmpegviddec_avbuffer_unref (AVBufferRef * avbuffer)
+{
+  av_buffer_unref (&avbuffer);
+}
+
 /* called when ffmpeg wants us to allocate a buffer to write the decoded frame
  * into. We try to give it memory from our pool */
 static int
@@ -823,6 +829,16 @@ gst_ffmpegviddec_get_buffer2 (AVCodecContext * context, AVFrame * picture,
   }
 
   picture->buf[0] = av_buffer_create (NULL, 0, dummy_free_buffer, dframe, 0);
+  if ((flags & AV_GET_BUFFER_FLAG_REF) == AV_GET_BUFFER_FLAG_REF) {
+    /* decoder might reuse this AVFrame and it would result to no more
+     * get_buffer() call if the AVFrame's AVBuffer is writable
+     * (meaning that the refcount of AVBuffer == 1).
+     * To enforce get_buffer() for the every output frame, hold another ref here
+     */
+    gst_video_codec_frame_set_user_data (frame,
+        av_buffer_ref (picture->buf[0]),
+        (GDestroyNotify) gst_ffmpegviddec_avbuffer_unref);
+  }
 
   GST_LOG_OBJECT (ffmpegdec, "returned frame %p", dframe->buffer);
 
-- 
2.22.0


From 20d73cbfeb51d9d9349a35156a15018fb7770d8e Mon Sep 17 00:00:00 2001
From: Seungha Yang <seungha.yang@navercorp.com>
Date: Tue, 29 Oct 2019 11:43:05 +0900
Subject: [PATCH] avviddec: Fix huge leak caused by circular reference

AVBufferRef -> GstFFMpegVideoDecVideoFrame -> GstVideoCodecFrame -> AVBufferRef

Instead of holding additional ref there, set read-only which would not be
reused by ff_reget_buffer()

Fixes: https://gitlab.freedesktop.org/gstreamer/gst-libav/issues/63
---
 ext/libav/gstavviddec.c | 16 +++++-----------
 1 file changed, 5 insertions(+), 11 deletions(-)

diff --git a/ext/libav/gstavviddec.c b/ext/libav/gstavviddec.c
index 58979d8..b0f55f2 100644
--- a/ext/libav/gstavviddec.c
+++ b/ext/libav/gstavviddec.c
@@ -730,12 +730,6 @@ gst_ffmpegviddec_can_direct_render (GstFFMpegVidDec * ffmpegdec)
       AV_CODEC_CAP_DR1);
 }
 
-static void
-gst_ffmpegviddec_avbuffer_unref (AVBufferRef * avbuffer)
-{
-  av_buffer_unref (&avbuffer);
-}
-
 /* called when ffmpeg wants us to allocate a buffer to write the decoded frame
  * into. We try to give it memory from our pool */
 static int
@@ -747,6 +741,7 @@ gst_ffmpegviddec_get_buffer2 (AVCodecContext * context, AVFrame * picture,
   GstFFMpegVidDec *ffmpegdec;
   guint c;
   GstFlowReturn ret;
+  int create_buffer_flags = 0;
 
   ffmpegdec = (GstFFMpegVidDec *) context->opaque;
 
@@ -828,17 +823,16 @@ gst_ffmpegviddec_get_buffer2 (AVCodecContext * context, AVFrame * picture,
         picture->data[c]);
   }
 
-  picture->buf[0] = av_buffer_create (NULL, 0, dummy_free_buffer, dframe, 0);
   if ((flags & AV_GET_BUFFER_FLAG_REF) == AV_GET_BUFFER_FLAG_REF) {
     /* decoder might reuse this AVFrame and it would result to no more
      * get_buffer() call if the AVFrame's AVBuffer is writable
      * (meaning that the refcount of AVBuffer == 1).
-     * To enforce get_buffer() for the every output frame, hold another ref here
+     * To enforce get_buffer() for the every output frame, set read-only flag here
      */
-    gst_video_codec_frame_set_user_data (frame,
-        av_buffer_ref (picture->buf[0]),
-        (GDestroyNotify) gst_ffmpegviddec_avbuffer_unref);
+    create_buffer_flags = AV_BUFFER_FLAG_READONLY;
   }
+  picture->buf[0] = av_buffer_create (NULL,
+      0, dummy_free_buffer, dframe, create_buffer_flags);
 
   GST_LOG_OBJECT (ffmpegdec, "returned frame %p", dframe->buffer);
 
-- 
2.22.0

