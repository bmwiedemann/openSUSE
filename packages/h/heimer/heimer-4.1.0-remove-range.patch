From 5b39a2eb67678931c713d536c6875fe59ea89fc6 Mon Sep 17 00:00:00 2001
From: Jussi Lind <jussi.lind@iki.fi>
Date: Thu, 30 Mar 2023 21:02:49 +0300
Subject: [PATCH] Revert "Prefer range-v3 algorithms"

This reverts commit a8691678eae615c5ecff9a3112fe37a557c4a936.
---
 src/core/graph.cpp | 47 +++++++++++++++++++++++++---------------------
 1 file changed, 26 insertions(+), 21 deletions(-)

diff --git a/src/core/graph.cpp b/src/core/graph.cpp
index de604b8..475e9e6 100644
--- a/src/core/graph.cpp
+++ b/src/core/graph.cpp
@@ -19,8 +19,6 @@
 
 #include "simple_logger.hpp"
 
-#include <range/v3/view.hpp>
-
 #include <algorithm>
 #include <cassert>
 #include <cmath>
@@ -29,8 +27,6 @@
 
 namespace Core {
 
-namespace rv = ranges::views;
-
 namespace {
 int64_t getKey(int c0, int c1)
 {
@@ -135,25 +131,31 @@ EdgeS Graph::getEdge(int index0, int index1) const
 
 Graph::EdgeVector Graph::getEdges() const
 {
-    return m_edges
-      | rv::transform([](auto && edge) { return std::get<EdgeS>(edge); })
-      | ranges::to_vector;
+    EdgeVector edges(m_edges.size());
+    std::transform(std::begin(m_edges), std::end(m_edges), std::begin(edges), [](auto && edge) { return edge.second; });
+    return edges;
 }
 
 Graph::EdgeVector Graph::getEdgesFromNode(NodeS node) const
 {
-    return m_edges
-      | rv::filter([&](auto && edge) { return std::get<EdgeS>(edge)->sourceNode().index() == node->index(); })
-      | rv::transform([](auto && edge) { return std::get<EdgeS>(edge); })
-      | ranges::to_vector;
+    EdgeVector edges;
+    for (auto && edge : m_edges) {
+        if (edge.second->sourceNode().index() == node->index()) {
+            edges.push_back(edge.second);
+        }
+    }
+    return edges;
 }
 
 Graph::EdgeVector Graph::getEdgesToNode(NodeS node) const
 {
-    return m_edges
-      | rv::filter([&](auto && edge) { return std::get<EdgeS>(edge)->targetNode().index() == node->index(); })
-      | rv::transform([](auto && edge) { return std::get<EdgeS>(edge); })
-      | ranges::to_vector;
+    Graph::EdgeVector edges;
+    for (auto && edge : m_edges) {
+        if (edge.second->targetNode().index() == node->index()) {
+            edges.push_back(edge.second);
+        }
+    }
+    return edges;
 }
 
 NodeS Graph::getNode(int index) const
@@ -166,18 +168,21 @@ NodeS Graph::getNode(int index) const
 
 Graph::NodeVector Graph::getNodes() const
 {
-    return m_nodes
-      | rv::transform([](auto && node) { return std::get<NodeS>(node); })
-      | ranges::to_vector;
+    NodeVector nodes(m_nodes.size());
+    std::transform(std::begin(m_nodes), std::end(m_nodes), std::begin(nodes), [](auto && node) { return node.second; });
+    return nodes;
 }
 
 Graph::NodeVector Graph::getNodesConnectedToNode(NodeS node) const
 {
+    NodeVector result;
     const auto edgesToNode = getEdgesToNode(node);
+    std::transform(std::begin(edgesToNode), std::end(edgesToNode), std::back_inserter(result), [this](auto && edge) { return getNode(edge->sourceNode().index()); });
+
     const auto edgesFromNode = getEdgesFromNode(node);
-    const auto a = edgesToNode | rv::transform([this](auto && edge) { return getNode(edge->sourceNode().index()); });
-    const auto b = edgesFromNode | rv::transform([this](auto && edge) { return getNode(edge->targetNode().index()); });
-    return rv::concat(a, b) | ranges::to_vector;
+    std::transform(std::begin(edgesFromNode), std::end(edgesFromNode), std::back_inserter(result), [this](auto && edge) { return getNode(edge->targetNode().index()); });
+
+    return result;
 }
 
 Graph::~Graph()
From d6b60cb5878bc2f49ba3aaad846e626ab0ba2ef6 Mon Sep 17 00:00:00 2001
From: Jussi Lind <jussi.lind@iki.fi>
Date: Thu, 30 Mar 2023 21:06:13 +0300
Subject: [PATCH] Revert "Add range-v3 lib"

This reverts commit e40dabbce4bc4c3ba350530651b85039c265a7c6.
---
 src/CMakeLists.txt                            |    4 -
 src/contrib/range-v3-0.11.0/BUCK              |   42 -
 src/contrib/range-v3-0.11.0/BUILD.bazel       |   42 -
 src/contrib/range-v3-0.11.0/CMakeLists.txt    |  178 -
 src/contrib/range-v3-0.11.0/CREDITS.md        |   48 -
 src/contrib/range-v3-0.11.0/LICENSE.txt       |  151 -
 src/contrib/range-v3-0.11.0/README.md         |  120 -
 src/contrib/range-v3-0.11.0/TODO.md           |   26 -
 src/contrib/range-v3-0.11.0/Version.cmake     |    7 -
 src/contrib/range-v3-0.11.0/WORKSPACE         |    0
 .../cmake/GoogleBenchmark.cmake.in            |   19 -
 .../range-v3-0.11.0/cmake/GoogleTest.cmake.in |   19 -
 .../range-v3-0.11.0/cmake/TestHeaders.cmake   |  128 -
 .../cmake/aligned_new_probe.cpp               |    6 -
 .../cmake/concepts_test_code.cpp              |   19 -
 .../range-v3-0.11.0/cmake/coro_test_code.cpp  |   46 -
 .../range-v3-0.11.0/cmake/gbenchmark.cmake    |   26 -
 src/contrib/range-v3-0.11.0/cmake/gtest.cmake |   32 -
 .../cmake/range-v3-config.cmake               |   21 -
 .../cmake/ranges_diagnostics.cmake            |   46 -
 .../range-v3-0.11.0/cmake/ranges_env.cmake    |   96 -
 .../range-v3-0.11.0/cmake/ranges_flags.cmake  |  298 --
 .../cmake/ranges_options.cmake                |   56 -
 src/contrib/range-v3-0.11.0/cmake/readme.md   |    5 -
 src/contrib/range-v3-0.11.0/conanfile.py      |   35 -
 .../range-v3-0.11.0/doc/CMakeLists.txt        |   88 -
 src/contrib/range-v3-0.11.0/doc/Doxyfile.in   |  174 -
 .../range-v3-0.11.0/doc/clean-gh-pages.cmake  |    4 -
 src/contrib/range-v3-0.11.0/doc/examples.md   |   62 -
 .../range-v3-0.11.0/doc/ignore_errors.sh      |    3 -
 src/contrib/range-v3-0.11.0/doc/index.md      |  954 ----
 src/contrib/range-v3-0.11.0/doc/layout.xml    |  225 -
 .../range-v3-0.11.0/doc/preprocess.sh.in      |    3 -
 .../range-v3-0.11.0/doc/release_notes.md      |  442 --
 src/contrib/range-v3-0.11.0/doc/std/D4128.md  | 2031 ---------
 .../range-v3-0.11.0/doc/std/header.html       |   24 -
 .../doc/std/pandoc-template.html              |   67 -
 src/contrib/range-v3-0.11.0/doc/std/show.cmd  |    1 -
 .../range-v3-0.11.0/doc/unpreprocess.pl       |   19 -
 src/contrib/range-v3-0.11.0/example/BUCK      |  155 -
 .../range-v3-0.11.0/example/CMakeLists.txt    |   37 -
 .../example/accumulate_ints.cpp               |   37 -
 .../example/any_all_none_of.cpp               |   44 -
 .../range-v3-0.11.0/example/calendar.cpp      |  373 --
 .../example/comprehension_conversion.cpp      |   35 -
 .../example/comprehensions.cpp                |  124 -
 src/contrib/range-v3-0.11.0/example/count.cpp |   40 -
 .../range-v3-0.11.0/example/count_if.cpp      |   39 -
 .../example/filter_transform.cpp              |   34 -
 src/contrib/range-v3-0.11.0/example/find.cpp  |  118 -
 .../example/for_each_assoc.cpp                |   58 -
 .../example/for_each_sequence.cpp             |   59 -
 src/contrib/range-v3-0.11.0/example/hello.cpp |   29 -
 .../range-v3-0.11.0/example/is_sorted.cpp     |   35 -
 .../range-v3-0.11.0/example/sort_unique.cpp   |   34 -
 .../include/concepts/compare.hpp              |   65 -
 .../include/concepts/concepts.hpp             | 1130 -----
 .../range-v3-0.11.0/include/concepts/swap.hpp |  340 --
 .../include/concepts/type_traits.hpp          |  379 --
 .../range-v3-0.11.0/include/meta/meta.hpp     | 3965 -----------------
 .../range-v3-0.11.0/include/meta/meta_fwd.hpp |  359 --
 .../range-v3-0.11.0/include/module.modulemap  |   61 -
 .../include/range/v3/action.hpp               |   42 -
 .../include/range/v3/action/action.hpp        |  248 --
 .../range/v3/action/adjacent_remove_if.hpp    |   70 -
 .../include/range/v3/action/concepts.hpp      |  169 -
 .../include/range/v3/action/drop.hpp          |   67 -
 .../include/range/v3/action/drop_while.hpp    |   66 -
 .../include/range/v3/action/erase.hpp         |   82 -
 .../include/range/v3/action/insert.hpp        |  320 --
 .../include/range/v3/action/join.hpp          |   69 -
 .../include/range/v3/action/push_back.hpp     |  150 -
 .../include/range/v3/action/push_front.hpp    |  150 -
 .../include/range/v3/action/remove.hpp        |   76 -
 .../include/range/v3/action/remove_if.hpp     |   72 -
 .../include/range/v3/action/reverse.hpp       |   56 -
 .../include/range/v3/action/shuffle.hpp       |   86 -
 .../include/range/v3/action/slice.hpp         |  164 -
 .../include/range/v3/action/sort.hpp          |   66 -
 .../include/range/v3/action/split.hpp         |  109 -
 .../include/range/v3/action/split_when.hpp    |   92 -
 .../include/range/v3/action/stable_sort.hpp   |   66 -
 .../include/range/v3/action/stride.hpp        |   81 -
 .../include/range/v3/action/take.hpp          |   66 -
 .../include/range/v3/action/take_while.hpp    |   66 -
 .../include/range/v3/action/transform.hpp     |   67 -
 .../include/range/v3/action/unique.hpp        |   70 -
 .../range/v3/action/unstable_remove_if.hpp    |   75 -
 .../include/range/v3/algorithm.hpp            |  105 -
 .../range/v3/algorithm/adjacent_find.hpp      |   77 -
 .../range/v3/algorithm/adjacent_remove_if.hpp |   94 -
 .../include/range/v3/algorithm/all_of.hpp     |   71 -
 .../include/range/v3/algorithm/any_of.hpp     |   72 -
 .../range/v3/algorithm/aux_/equal_range_n.hpp |   92 -
 .../range/v3/algorithm/aux_/lower_bound_n.hpp |   83 -
 .../range/v3/algorithm/aux_/merge_n.hpp       |  116 -
 .../v3/algorithm/aux_/merge_n_with_buffer.hpp |   75 -
 .../v3/algorithm/aux_/partition_point_n.hpp   |   66 -
 .../v3/algorithm/aux_/sort_n_with_buffer.hpp  |   74 -
 .../range/v3/algorithm/aux_/upper_bound_n.hpp |   88 -
 .../range/v3/algorithm/binary_search.hpp      |   83 -
 .../include/range/v3/algorithm/contains.hpp   |   62 -
 .../include/range/v3/algorithm/copy.hpp       |   91 -
 .../range/v3/algorithm/copy_backward.hpp      |   76 -
 .../include/range/v3/algorithm/copy_if.hpp    |   90 -
 .../include/range/v3/algorithm/copy_n.hpp     |   70 -
 .../include/range/v3/algorithm/count.hpp      |   74 -
 .../include/range/v3/algorithm/count_if.hpp   |   73 -
 .../include/range/v3/algorithm/ends_with.hpp  |  102 -
 .../include/range/v3/algorithm/equal.hpp      |  179 -
 .../range/v3/algorithm/equal_range.hpp        |  132 -
 .../include/range/v3/algorithm/fill.hpp       |   64 -
 .../include/range/v3/algorithm/fill_n.hpp     |   60 -
 .../include/range/v3/algorithm/find.hpp       |   80 -
 .../include/range/v3/algorithm/find_end.hpp   |  242 -
 .../range/v3/algorithm/find_first_of.hpp      |  105 -
 .../include/range/v3/algorithm/find_if.hpp    |   81 -
 .../range/v3/algorithm/find_if_not.hpp        |   82 -
 .../include/range/v3/algorithm/for_each.hpp   |   80 -
 .../include/range/v3/algorithm/for_each_n.hpp |   79 -
 .../include/range/v3/algorithm/generate.hpp   |   75 -
 .../include/range/v3/algorithm/generate_n.hpp |   68 -
 .../range/v3/algorithm/heap_algorithm.hpp     |  440 --
 .../range/v3/algorithm/inplace_merge.hpp      |  307 --
 .../range/v3/algorithm/is_partitioned.hpp     |   82 -
 .../include/range/v3/algorithm/is_sorted.hpp  |   79 -
 .../range/v3/algorithm/is_sorted_until.hpp    |   91 -
 .../v3/algorithm/lexicographical_compare.hpp  |  101 -
 .../range/v3/algorithm/lower_bound.hpp        |   80 -
 .../include/range/v3/algorithm/max.hpp        |   93 -
 .../range/v3/algorithm/max_element.hpp        |   74 -
 .../include/range/v3/algorithm/merge.hpp      |  138 -
 .../include/range/v3/algorithm/min.hpp        |   93 -
 .../range/v3/algorithm/min_element.hpp        |   74 -
 .../include/range/v3/algorithm/minmax.hpp     |  133 -
 .../range/v3/algorithm/minmax_element.hpp     |  114 -
 .../include/range/v3/algorithm/mismatch.hpp   |  178 -
 .../include/range/v3/algorithm/move.hpp       |   90 -
 .../range/v3/algorithm/move_backward.hpp      |   77 -
 .../include/range/v3/algorithm/none_of.hpp    |   72 -
 .../range/v3/algorithm/nth_element.hpp        |  335 --
 .../range/v3/algorithm/partial_sort.hpp       |   89 -
 .../range/v3/algorithm/partial_sort_copy.hpp  |  125 -
 .../include/range/v3/algorithm/partition.hpp  |  139 -
 .../range/v3/algorithm/partition_copy.hpp     |  111 -
 .../range/v3/algorithm/partition_point.hpp    |  110 -
 .../range/v3/algorithm/permutation.hpp        |  369 --
 .../include/range/v3/algorithm/remove.hpp     |   84 -
 .../range/v3/algorithm/remove_copy.hpp        |   88 -
 .../range/v3/algorithm/remove_copy_if.hpp     |   88 -
 .../include/range/v3/algorithm/remove_if.hpp  |   83 -
 .../include/range/v3/algorithm/replace.hpp    |   76 -
 .../range/v3/algorithm/replace_copy.hpp       |  104 -
 .../range/v3/algorithm/replace_copy_if.hpp    |   97 -
 .../include/range/v3/algorithm/replace_if.hpp |   77 -
 .../range/v3/algorithm/result_types.hpp       |  169 -
 .../include/range/v3/algorithm/reverse.hpp    |   93 -
 .../range/v3/algorithm/reverse_copy.hpp       |   77 -
 .../include/range/v3/algorithm/rotate.hpp     |  236 -
 .../range/v3/algorithm/rotate_copy.hpp        |   78 -
 .../include/range/v3/algorithm/sample.hpp     |  254 --
 .../include/range/v3/algorithm/search.hpp     |  231 -
 .../include/range/v3/algorithm/search_n.hpp   |  199 -
 .../range/v3/algorithm/set_algorithm.hpp      |  454 --
 .../include/range/v3/algorithm/shuffle.hpp    |   92 -
 .../include/range/v3/algorithm/sort.hpp       |  234 -
 .../range/v3/algorithm/stable_partition.hpp   |  333 --
 .../range/v3/algorithm/stable_sort.hpp        |  238 -
 .../range/v3/algorithm/starts_with.hpp        |  102 -
 .../range/v3/algorithm/swap_ranges.hpp        |   99 -
 .../include/range/v3/algorithm/tagspec.hpp    |   52 -
 .../include/range/v3/algorithm/transform.hpp  |  226 -
 .../include/range/v3/algorithm/unique.hpp     |   88 -
 .../range/v3/algorithm/unique_copy.hpp        |  180 -
 .../range/v3/algorithm/unstable_remove_if.hpp |   88 -
 .../range/v3/algorithm/upper_bound.hpp        |   78 -
 .../range-v3-0.11.0/include/range/v3/all.hpp  |   27 -
 .../range-v3-0.11.0/include/range/v3/at.hpp   |   23 -
 .../range-v3-0.11.0/include/range/v3/back.hpp |   22 -
 .../include/range/v3/begin_end.hpp            |   22 -
 .../include/range/v3/compare.hpp              |   45 -
 .../range-v3-0.11.0/include/range/v3/core.hpp |   33 -
 .../range-v3-0.11.0/include/range/v3/data.hpp |   22 -
 .../include/range/v3/detail/adl_get.hpp       |  146 -
 .../include/range/v3/detail/config.hpp        |  755 ----
 .../include/range/v3/detail/epilogue.hpp      |   21 -
 .../include/range/v3/detail/prologue.hpp      |   37 -
 .../include/range/v3/detail/range_access.hpp  |  375 --
 .../range/v3/detail/satisfy_boost_range.hpp   |   87 -
 .../include/range/v3/detail/variant.hpp       |  907 ----
 .../range/v3/detail/with_braced_init_args.hpp |   83 -
 .../include/range/v3/distance.hpp             |   24 -
 .../include/range/v3/empty.hpp                |   22 -
 .../v3/experimental/utility/generator.hpp     |  369 --
 .../range/v3/experimental/view/shared.hpp     |  135 -
 .../include/range/v3/front.hpp                |   22 -
 .../include/range/v3/functional.hpp           |   32 -
 .../range/v3/functional/arithmetic.hpp        |  112 -
 .../include/range/v3/functional/bind.hpp      |  127 -
 .../include/range/v3/functional/bind_back.hpp |  192 -
 .../range/v3/functional/comparisons.hpp       |  133 -
 .../include/range/v3/functional/compose.hpp   |  104 -
 .../include/range/v3/functional/concepts.hpp  |   90 -
 .../include/range/v3/functional/identity.hpp  |   48 -
 .../include/range/v3/functional/indirect.hpp  |  100 -
 .../include/range/v3/functional/invoke.hpp    |  245 -
 .../include/range/v3/functional/not_fn.hpp    |  103 -
 .../include/range/v3/functional/on.hpp        |   74 -
 .../include/range/v3/functional/overload.hpp  |  181 -
 .../include/range/v3/functional/pipeable.hpp  |  131 -
 .../range/v3/functional/reference_wrapper.hpp |  187 -
 .../include/range/v3/getlines.hpp             |   22 -
 .../include/range/v3/index.hpp                |   23 -
 .../include/range/v3/istream_range.hpp        |   22 -
 .../include/range/v3/iterator.hpp             |   32 -
 .../include/range/v3/iterator/access.hpp      |  304 --
 .../range/v3/iterator/basic_iterator.hpp      | 1081 -----
 .../range/v3/iterator/common_iterator.hpp     |  483 --
 .../include/range/v3/iterator/concepts.hpp    |  873 ----
 .../range/v3/iterator/counted_iterator.hpp    |  498 ---
 .../range/v3/iterator/default_sentinel.hpp    |   41 -
 .../include/range/v3/iterator/diffmax_t.hpp   |  483 --
 .../range/v3/iterator/insert_iterators.hpp    |  219 -
 .../range/v3/iterator/move_iterators.hpp      |  489 --
 .../include/range/v3/iterator/operations.hpp  |  674 ---
 .../range/v3/iterator/reverse_iterator.hpp    |  157 -
 .../range/v3/iterator/stream_iterators.hpp    |  227 -
 .../include/range/v3/iterator/traits.hpp      |  178 -
 .../v3/iterator/unreachable_sentinel.hpp      |   74 -
 .../include/range/v3/iterator_range.hpp       |  392 --
 .../include/range/v3/numeric.hpp              |   20 -
 .../include/range/v3/numeric/accumulate.hpp   |   69 -
 .../range/v3/numeric/adjacent_difference.hpp  |  156 -
 .../range/v3/numeric/inner_product.hpp        |  160 -
 .../include/range/v3/numeric/iota.hpp         |   57 -
 .../include/range/v3/numeric/partial_sum.hpp  |  174 -
 .../include/range/v3/range.hpp                |   25 -
 .../include/range/v3/range/access.hpp         |  724 ---
 .../include/range/v3/range/concepts.hpp       |  306 --
 .../include/range/v3/range/conversion.hpp     |  530 ---
 .../include/range/v3/range/dangling.hpp       |   96 -
 .../include/range/v3/range/operations.hpp     |  128 -
 .../include/range/v3/range/primitives.hpp     |  335 --
 .../include/range/v3/range/traits.hpp         |  142 -
 .../include/range/v3/range_access.hpp         |   23 -
 .../include/range/v3/range_concepts.hpp       |   22 -
 .../include/range/v3/range_for.hpp            |   50 -
 .../include/range/v3/range_fwd.hpp            |  931 ----
 .../include/range/v3/range_traits.hpp         |   22 -
 .../range-v3-0.11.0/include/range/v3/size.hpp |   22 -
 .../range-v3-0.11.0/include/range/v3/span.hpp |   22 -
 .../include/range/v3/to_container.hpp         |   22 -
 .../include/range/v3/utility.hpp              |   37 -
 .../include/range/v3/utility/addressof.hpp    |   80 -
 .../include/range/v3/utility/any.hpp          |  236 -
 .../range/v3/utility/associated_types.hpp     |   23 -
 .../range/v3/utility/basic_iterator.hpp       |   23 -
 .../include/range/v3/utility/box.hpp          |  380 --
 .../range/v3/utility/common_iterator.hpp      |   23 -
 .../include/range/v3/utility/common_tuple.hpp |  827 ----
 .../include/range/v3/utility/common_type.hpp  |  175 -
 .../range/v3/utility/compressed_pair.hpp      |  232 -
 .../include/range/v3/utility/concepts.hpp     |   27 -
 .../include/range/v3/utility/copy.hpp         |   62 -
 .../range/v3/utility/counted_iterator.hpp     |   22 -
 .../include/range/v3/utility/dangling.hpp     |   22 -
 .../include/range/v3/utility/functional.hpp   |   42 -
 .../include/range/v3/utility/get.hpp          |   73 -
 .../include/range/v3/utility/in_place.hpp     |   33 -
 .../include/range/v3/utility/infinity.hpp     |   75 -
 .../include/range/v3/utility/invoke.hpp       |   23 -
 .../include/range/v3/utility/iterator.hpp     |   31 -
 .../range/v3/utility/iterator_concepts.hpp    |   23 -
 .../range/v3/utility/iterator_traits.hpp      |   22 -
 .../include/range/v3/utility/memory.hpp       |  262 --
 .../include/range/v3/utility/move.hpp         |   65 -
 .../include/range/v3/utility/nullptr_v.hpp    |   40 -
 .../include/range/v3/utility/optional.hpp     |  992 -----
 .../range/v3/utility/polymorphic_cast.hpp     |   46 -
 .../include/range/v3/utility/random.hpp       |  498 ---
 .../include/range/v3/utility/scope_exit.hpp   |   97 -
 .../include/range/v3/utility/semiregular.hpp  |   24 -
 .../range/v3/utility/semiregular_box.hpp      |  344 --
 .../include/range/v3/utility/static_const.hpp |   32 -
 .../include/range/v3/utility/swap.hpp         |   55 -
 .../include/range/v3/utility/tagged_pair.hpp  |  236 -
 .../include/range/v3/utility/tagged_tuple.hpp |   45 -
 .../range/v3/utility/tuple_algorithm.hpp      |  196 -
 .../include/range/v3/utility/unreachable.hpp  |   22 -
 .../include/range/v3/utility/variant.hpp      |  142 -
 .../include/range/v3/version.hpp              |   24 -
 .../range-v3-0.11.0/include/range/v3/view.hpp |   89 -
 .../include/range/v3/view/adaptor.hpp         |  587 ---
 .../include/range/v3/view/addressof.hpp       |   66 -
 .../include/range/v3/view/adjacent_filter.hpp |  191 -
 .../range/v3/view/adjacent_remove_if.hpp      |  191 -
 .../include/range/v3/view/all.hpp             |  128 -
 .../include/range/v3/view/any_view.hpp        |  696 ---
 .../include/range/v3/view/bounded.hpp         |   22 -
 .../include/range/v3/view/c_str.hpp           |   96 -
 .../include/range/v3/view/cache1.hpp          |  208 -
 .../range/v3/view/cartesian_product.hpp       |  504 ---
 .../include/range/v3/view/chunk.hpp           |  477 --
 .../include/range/v3/view/common.hpp          |  244 -
 .../include/range/v3/view/concat.hpp          |  473 --
 .../include/range/v3/view/const.hpp           |  148 -
 .../include/range/v3/view/counted.hpp         |  131 -
 .../include/range/v3/view/cycle.hpp           |  251 --
 .../include/range/v3/view/delimit.hpp         |  135 -
 .../include/range/v3/view/drop.hpp            |  211 -
 .../include/range/v3/view/drop_exactly.hpp    |  192 -
 .../include/range/v3/view/drop_last.hpp       |  383 --
 .../include/range/v3/view/drop_while.hpp      |  170 -
 .../include/range/v3/view/empty.hpp           |   86 -
 .../include/range/v3/view/enumerate.hpp       |  118 -
 .../include/range/v3/view/exclusive_scan.hpp  |  200 -
 .../include/range/v3/view/facade.hpp          |  141 -
 .../include/range/v3/view/filter.hpp          |  144 -
 .../include/range/v3/view/for_each.hpp        |  143 -
 .../include/range/v3/view/generate.hpp        |  121 -
 .../include/range/v3/view/generate_n.hpp      |  128 -
 .../include/range/v3/view/getlines.hpp        |  112 -
 .../include/range/v3/view/group_by.hpp        |  206 -
 .../include/range/v3/view/indices.hpp         |   84 -
 .../include/range/v3/view/indirect.hpp        |  163 -
 .../include/range/v3/view/interface.hpp       |  551 ---
 .../include/range/v3/view/intersperse.hpp     |  268 --
 .../include/range/v3/view/iota.hpp            |  580 ---
 .../include/range/v3/view/istream.hpp         |  124 -
 .../include/range/v3/view/join.hpp            |  658 ---
 .../range/v3/view/linear_distribute.hpp       |  119 -
 .../include/range/v3/view/map.hpp             |  151 -
 .../include/range/v3/view/move.hpp            |  141 -
 .../include/range/v3/view/partial_sum.hpp     |  235 -
 .../include/range/v3/view/ref.hpp             |  129 -
 .../include/range/v3/view/remove.hpp          |  113 -
 .../include/range/v3/view/remove_if.hpp       |  216 -
 .../include/range/v3/view/repeat.hpp          |  124 -
 .../include/range/v3/view/repeat_n.hpp        |  132 -
 .../include/range/v3/view/replace.hpp         |  144 -
 .../include/range/v3/view/replace_if.hpp      |  162 -
 .../include/range/v3/view/reverse.hpp         |  191 -
 .../include/range/v3/view/sample.hpp          |  271 --
 .../include/range/v3/view/set_algorithm.hpp   |  907 ----
 .../include/range/v3/view/single.hpp          |  144 -
 .../include/range/v3/view/slice.hpp           |  354 --
 .../include/range/v3/view/sliding.hpp         |  415 --
 .../include/range/v3/view/span.hpp            |  430 --
 .../include/range/v3/view/split.hpp           |  716 ---
 .../include/range/v3/view/split_when.hpp      |  236 -
 .../include/range/v3/view/stride.hpp          |  350 --
 .../include/range/v3/view/subrange.hpp        |  487 --
 .../include/range/v3/view/tail.hpp            |  151 -
 .../include/range/v3/view/take.hpp            |  334 --
 .../include/range/v3/view/take_exactly.hpp    |  207 -
 .../include/range/v3/view/take_last.hpp       |   68 -
 .../include/range/v3/view/take_while.hpp      |  218 -
 .../include/range/v3/view/tokenize.hpp        |  213 -
 .../include/range/v3/view/transform.hpp       |  592 ---
 .../include/range/v3/view/trim.hpp            |  165 -
 .../include/range/v3/view/unbounded.hpp       |   75 -
 .../include/range/v3/view/unique.hpp          |   74 -
 .../include/range/v3/view/view.hpp            |  285 --
 .../include/range/v3/view/zip.hpp             |  199 -
 .../include/range/v3/view/zip_with.hpp        |  460 --
 .../include/range/v3/view_adaptor.hpp         |   21 -
 .../include/range/v3/view_facade.hpp          |   21 -
 .../include/range/v3/view_interface.hpp       |   21 -
 .../include/std/detail/associated_types.hpp   |  304 --
 .../range-v3-0.11.0/include/std/iterator      |  278 --
 src/contrib/range-v3-0.11.0/install_libcxx.sh |  103 -
 .../range-v3-0.11.0/perf/CMakeLists.txt       |   10 -
 .../perf/counted_insertion_sort.cpp           |  187 -
 .../range-v3-0.11.0/perf/range_conversion.cpp |  101 -
 .../range-v3-0.11.0/perf/sort_patterns.cpp    |  256 --
 .../range-v3-0.11.0/test/CMakeLists.txt       |   21 -
 .../test/action/CMakeLists.txt                |   24 -
 .../test/action/adjacent_remove_if.cpp        |   34 -
 .../test/action/cont_concepts.cpp             |   43 -
 .../range-v3-0.11.0/test/action/drop.cpp      |   39 -
 .../test/action/drop_while.cpp                |   41 -
 .../range-v3-0.11.0/test/action/insert.cpp    |   90 -
 .../range-v3-0.11.0/test/action/join.cpp      |   34 -
 .../range-v3-0.11.0/test/action/push_back.cpp |  100 -
 .../test/action/push_front.cpp                |  100 -
 .../range-v3-0.11.0/test/action/remove.cpp    |   68 -
 .../range-v3-0.11.0/test/action/remove_if.cpp |   32 -
 .../range-v3-0.11.0/test/action/reverse.cpp   |   35 -
 .../range-v3-0.11.0/test/action/shuffle.cpp   |   70 -
 .../range-v3-0.11.0/test/action/slice.cpp     |   71 -
 .../range-v3-0.11.0/test/action/sort.cpp      |   69 -
 .../range-v3-0.11.0/test/action/split.cpp     |  139 -
 .../test/action/stable_sort.cpp               |   88 -
 .../range-v3-0.11.0/test/action/stride.cpp    |   47 -
 .../range-v3-0.11.0/test/action/take.cpp      |   43 -
 .../test/action/take_while.cpp                |   44 -
 .../range-v3-0.11.0/test/action/transform.cpp |   35 -
 .../range-v3-0.11.0/test/action/unique.cpp    |   44 -
 .../test/action/unstable_remove_if.cpp        |  222 -
 .../test/algorithm/CMakeLists.txt             |  113 -
 .../test/algorithm/adjacent_find.cpp          |   30 -
 .../test/algorithm/adjacent_remove_if.cpp     |  197 -
 .../range-v3-0.11.0/test/algorithm/all_of.cpp |   62 -
 .../range-v3-0.11.0/test/algorithm/any_of.cpp |   63 -
 .../test/algorithm/binary_search.cpp          |   54 -
 .../test/algorithm/contains.cpp               |   39 -
 .../range-v3-0.11.0/test/algorithm/copy.cpp   |   95 -
 .../test/algorithm/copy_backward.cpp          |   74 -
 .../range-v3-0.11.0/test/algorithm/count.cpp  |   61 -
 .../test/algorithm/count_if.cpp               |   78 -
 .../test/algorithm/ends_with.cpp              |  111 -
 .../range-v3-0.11.0/test/algorithm/equal.cpp  |  295 --
 .../test/algorithm/equal_range.cpp            |  120 -
 .../range-v3-0.11.0/test/algorithm/fill.cpp   |  100 -
 .../range-v3-0.11.0/test/algorithm/find.cpp   |   91 -
 .../test/algorithm/find_end.cpp               |  296 --
 .../test/algorithm/find_first_of.cpp          |  221 -
 .../test/algorithm/find_if.cpp                |   98 -
 .../test/algorithm/for_each.cpp               |   51 -
 .../test/algorithm/for_each_n.cpp             |   54 -
 .../test/algorithm/generate.cpp               |   98 -
 .../test/algorithm/generate_n.cpp             |   79 -
 .../test/algorithm/includes.cpp               |  153 -
 .../test/algorithm/inplace_merge.cpp          |  142 -
 .../test/algorithm/is_heap.hpp                | 1063 -----
 .../test/algorithm/is_heap1.cpp               |   14 -
 .../test/algorithm/is_heap2.cpp               |   14 -
 .../test/algorithm/is_heap3.cpp               |   14 -
 .../test/algorithm/is_heap4.cpp               |   14 -
 .../test/algorithm/is_heap_until.hpp          | 1070 -----
 .../test/algorithm/is_heap_until1.cpp         |   14 -
 .../test/algorithm/is_heap_until2.cpp         |   14 -
 .../test/algorithm/is_heap_until3.cpp         |   14 -
 .../test/algorithm/is_heap_until4.cpp         |   14 -
 .../test/algorithm/is_partitioned.cpp         |  128 -
 .../test/algorithm/is_permutation.cpp         |  854 ----
 .../test/algorithm/is_sorted.cpp              |  409 --
 .../test/algorithm/is_sorted_until.cpp        |  452 --
 .../algorithm/lexicographical_compare.cpp     |  176 -
 .../test/algorithm/lower_bound.cpp            |   83 -
 .../test/algorithm/make_heap.cpp              |  212 -
 .../range-v3-0.11.0/test/algorithm/max.cpp    |  142 -
 .../test/algorithm/max_element.cpp            |  165 -
 .../range-v3-0.11.0/test/algorithm/merge.cpp  |   92 -
 .../range-v3-0.11.0/test/algorithm/min.cpp    |  141 -
 .../test/algorithm/min_element.cpp            |  165 -
 .../range-v3-0.11.0/test/algorithm/minmax.cpp |  171 -
 .../test/algorithm/minmax_element.cpp         |  241 -
 .../test/algorithm/mismatch.cpp               |  139 -
 .../range-v3-0.11.0/test/algorithm/move.cpp   |  241 -
 .../test/algorithm/move_backward.cpp          |  148 -
 .../test/algorithm/next_permutation.cpp       |  217 -
 .../test/algorithm/none_of.cpp                |   63 -
 .../test/algorithm/nth_element.cpp            |  103 -
 .../test/algorithm/partial_sort.cpp           |  183 -
 .../test/algorithm/partial_sort_copy.cpp      |  177 -
 .../test/algorithm/partition.cpp              |  223 -
 .../test/algorithm/partition_copy.cpp         |  165 -
 .../test/algorithm/partition_point.cpp        |  229 -
 .../test/algorithm/pop_heap.cpp               |  270 --
 .../test/algorithm/prev_permutation.cpp       |  217 -
 .../test/algorithm/push_heap.cpp              |  154 -
 .../range-v3-0.11.0/test/algorithm/remove.cpp |  185 -
 .../test/algorithm/remove_copy.cpp            |  188 -
 .../test/algorithm/remove_copy_if.cpp         |  187 -
 .../test/algorithm/remove_if.cpp              |  206 -
 .../test/algorithm/replace.cpp                |  123 -
 .../test/algorithm/replace_copy.cpp           |  123 -
 .../test/algorithm/replace_copy_if.cpp        |  126 -
 .../test/algorithm/replace_if.cpp             |  126 -
 .../test/algorithm/reverse.cpp                |  111 -
 .../test/algorithm/reverse_copy.cpp           |  162 -
 .../range-v3-0.11.0/test/algorithm/rotate.cpp |  303 --
 .../test/algorithm/rotate_copy.cpp            |  337 --
 .../range-v3-0.11.0/test/algorithm/sample.cpp |  281 --
 .../range-v3-0.11.0/test/algorithm/search.cpp |  237 -
 .../test/algorithm/search_n.cpp               |  249 --
 .../test/algorithm/set_difference.hpp         |  343 --
 .../test/algorithm/set_difference1.cpp        |   14 -
 .../test/algorithm/set_difference2.cpp        |   14 -
 .../test/algorithm/set_difference3.cpp        |   14 -
 .../test/algorithm/set_difference4.cpp        |   14 -
 .../test/algorithm/set_difference5.cpp        |   14 -
 .../test/algorithm/set_difference6.cpp        |   14 -
 .../test/algorithm/set_intersection.hpp       |  267 --
 .../test/algorithm/set_intersection1.cpp      |   14 -
 .../test/algorithm/set_intersection2.cpp      |   14 -
 .../test/algorithm/set_intersection3.cpp      |   14 -
 .../test/algorithm/set_intersection4.cpp      |   14 -
 .../test/algorithm/set_intersection5.cpp      |   14 -
 .../test/algorithm/set_intersection6.cpp      |   14 -
 .../algorithm/set_symmetric_difference.hpp    |  350 --
 .../algorithm/set_symmetric_difference1.cpp   |   14 -
 .../algorithm/set_symmetric_difference2.cpp   |   14 -
 .../algorithm/set_symmetric_difference3.cpp   |   14 -
 .../algorithm/set_symmetric_difference4.cpp   |   14 -
 .../algorithm/set_symmetric_difference5.cpp   |   14 -
 .../algorithm/set_symmetric_difference6.cpp   |   14 -
 .../test/algorithm/set_union.hpp              |  306 --
 .../test/algorithm/set_union1.cpp             |   14 -
 .../test/algorithm/set_union2.cpp             |   14 -
 .../test/algorithm/set_union3.cpp             |   14 -
 .../test/algorithm/set_union4.cpp             |   14 -
 .../test/algorithm/set_union5.cpp             |   14 -
 .../test/algorithm/set_union6.cpp             |   14 -
 .../test/algorithm/shuffle.cpp                |   95 -
 .../range-v3-0.11.0/test/algorithm/sort.cpp   |  338 --
 .../test/algorithm/sort_heap.cpp              |  204 -
 .../test/algorithm/sort_n_with_buffer.cpp     |   49 -
 .../test/algorithm/stable_partition.cpp       |  464 --
 .../test/algorithm/stable_sort.cpp            |  260 --
 .../test/algorithm/starts_with.cpp            |  124 -
 .../test/algorithm/swap_ranges.cpp            |  247 -
 .../test/algorithm/transform.cpp              |  430 --
 .../range-v3-0.11.0/test/algorithm/unique.cpp |  180 -
 .../test/algorithm/unique_copy.cpp            |  325 --
 .../test/algorithm/upper_bound.cpp            |  100 -
 src/contrib/range-v3-0.11.0/test/array.hpp    |  301 --
 src/contrib/range-v3-0.11.0/test/bug1322.cpp  |   19 -
 src/contrib/range-v3-0.11.0/test/bug1335.cpp  |   14 -
 src/contrib/range-v3-0.11.0/test/bug474.cpp   |   32 -
 src/contrib/range-v3-0.11.0/test/bug566.cpp   |   36 -
 src/contrib/range-v3-0.11.0/test/config.cpp   |   19 -
 .../range-v3-0.11.0/test/constexpr_core.cpp   |  300 --
 .../range-v3-0.11.0/test/debug_view.hpp       |  182 -
 .../test/experimental/CMakeLists.txt          |    4 -
 .../test/experimental/utility/CMakeLists.txt  |    5 -
 .../test/experimental/utility/generator.cpp   |  292 --
 .../test/experimental/view/CMakeLists.txt     |    3 -
 .../test/experimental/view/shared.cpp         |  144 -
 .../test/functional/CMakeLists.txt            |    3 -
 .../test/functional/bind_back.cpp             |   36 -
 .../test/iterator/CMakeLists.txt              |    7 -
 .../test/iterator/basic_iterator.cpp          |  601 ---
 .../test/iterator/common_iterator.cpp         |  155 -
 .../test/iterator/diffmax_t.cpp               |   72 -
 .../test/iterator/iterator.cpp                |  445 --
 .../test/iterator/reverse_iterator.cpp        |  480 --
 .../range-v3-0.11.0/test/multiple1.cpp        |   15 -
 .../range-v3-0.11.0/test/multiple2.cpp        |   20 -
 .../test/numeric/CMakeLists.txt               |    7 -
 .../test/numeric/accumulate.cpp               |   75 -
 .../test/numeric/adjacent_difference.cpp      |  179 -
 .../test/numeric/inner_product.cpp            |  191 -
 .../range-v3-0.11.0/test/numeric/iota.cpp     |   64 -
 .../test/numeric/partial_sum.cpp              |  198 -
 .../range-v3-0.11.0/test/range/CMakeLists.txt |    6 -
 .../range-v3-0.11.0/test/range/access.cpp     |  316 --
 .../range-v3-0.11.0/test/range/conversion.cpp |  217 -
 .../range-v3-0.11.0/test/range/index.cpp      |  132 -
 .../range-v3-0.11.0/test/range/operations.cpp |  121 -
 .../range-v3-0.11.0/test/simple_test.hpp      |  171 -
 .../range-v3-0.11.0/test/test_iterators.hpp   |  447 --
 .../range-v3-0.11.0/test/test_utils.hpp       |  338 --
 .../test/utility/CMakeLists.txt               |   12 -
 .../range-v3-0.11.0/test/utility/box.cpp      |   41 -
 .../test/utility/common_type.cpp              |  149 -
 .../range-v3-0.11.0/test/utility/compare.cpp  |   41 -
 .../range-v3-0.11.0/test/utility/concepts.cpp |  340 --
 .../test/utility/functional.cpp               |  253 --
 .../range-v3-0.11.0/test/utility/meta.cpp     |  434 --
 .../test/utility/scope_exit.cpp               |   85 -
 .../test/utility/semiregular_box.cpp          |   33 -
 .../range-v3-0.11.0/test/utility/swap.cpp     |  113 -
 .../range-v3-0.11.0/test/utility/variant.cpp  |  200 -
 .../range-v3-0.11.0/test/view/CMakeLists.txt  |   69 -
 .../range-v3-0.11.0/test/view/adaptor.cpp     |  172 -
 .../range-v3-0.11.0/test/view/addressof.cpp   |  129 -
 .../test/view/adjacent_remove_if.cpp          |  117 -
 src/contrib/range-v3-0.11.0/test/view/all.cpp |   54 -
 .../range-v3-0.11.0/test/view/any_view.cpp    |  227 -
 .../range-v3-0.11.0/test/view/cache1.cpp      |  151 -
 .../test/view/cartesian_product.cpp           |  354 --
 .../range-v3-0.11.0/test/view/chunk.cpp       |  236 -
 .../range-v3-0.11.0/test/view/common.cpp      |  125 -
 .../range-v3-0.11.0/test/view/concat.cpp      |  106 -
 .../range-v3-0.11.0/test/view/const.cpp       |   99 -
 .../range-v3-0.11.0/test/view/conversion.cpp  |   99 -
 .../range-v3-0.11.0/test/view/counted.cpp     |   75 -
 .../range-v3-0.11.0/test/view/cycle.cpp       |  347 --
 .../range-v3-0.11.0/test/view/delimit.cpp     |   53 -
 .../range-v3-0.11.0/test/view/drop.cpp        |  159 -
 .../test/view/drop_exactly.cpp                |  103 -
 .../range-v3-0.11.0/test/view/drop_last.cpp   |  207 -
 .../range-v3-0.11.0/test/view/drop_while.cpp  |   93 -
 .../range-v3-0.11.0/test/view/enumerate.cpp   |  104 -
 .../test/view/exclusive_scan.cpp              |   57 -
 .../range-v3-0.11.0/test/view/facade.cpp      |  109 -
 .../range-v3-0.11.0/test/view/generate.cpp    |  102 -
 .../range-v3-0.11.0/test/view/generate_n.cpp  |  110 -
 .../range-v3-0.11.0/test/view/getlines.cpp    |   39 -
 .../range-v3-0.11.0/test/view/group_by.cpp    |  157 -
 .../range-v3-0.11.0/test/view/indirect.cpp    |   78 -
 .../range-v3-0.11.0/test/view/intersperse.cpp |  166 -
 .../range-v3-0.11.0/test/view/iota.cpp        |  228 -
 .../range-v3-0.11.0/test/view/istream.cpp     |   25 -
 .../test/view/iterator_range.cpp              |   75 -
 .../range-v3-0.11.0/test/view/join.cpp        |  276 --
 .../range-v3-0.11.0/test/view/keys_value.cpp  |   79 -
 .../test/view/linear_distribute.cpp           |   91 -
 .../range-v3-0.11.0/test/view/move.cpp        |   63 -
 .../range-v3-0.11.0/test/view/partial_sum.cpp |   72 -
 .../test/view/partial_sum_depr.cpp            |   25 -
 .../range-v3-0.11.0/test/view/remove.cpp      |   56 -
 .../range-v3-0.11.0/test/view/remove_if.cpp   |  184 -
 .../range-v3-0.11.0/test/view/repeat.cpp      |   30 -
 .../range-v3-0.11.0/test/view/replace.cpp     |  101 -
 .../range-v3-0.11.0/test/view/replace_if.cpp  |  116 -
 .../range-v3-0.11.0/test/view/reverse.cpp     |  156 -
 .../range-v3-0.11.0/test/view/sample.cpp      |   42 -
 .../test/view/set_difference.cpp              |  269 --
 .../test/view/set_intersection.cpp            |  228 -
 .../test/view/set_symmetric_difference.cpp    |  324 --
 .../range-v3-0.11.0/test/view/set_union.cpp   |  315 --
 .../range-v3-0.11.0/test/view/slice.cpp       |  138 -
 .../range-v3-0.11.0/test/view/sliding.cpp     |  224 -
 .../range-v3-0.11.0/test/view/span.cpp        | 1099 -----
 .../range-v3-0.11.0/test/view/split.cpp       |  425 --
 .../range-v3-0.11.0/test/view/stride.cpp      |  193 -
 .../range-v3-0.11.0/test/view/subrange.cpp    |  207 -
 .../range-v3-0.11.0/test/view/tail.cpp        |   72 -
 .../range-v3-0.11.0/test/view/take.cpp        |  154 -
 .../test/view/take_exactly.cpp                |   86 -
 .../range-v3-0.11.0/test/view/take_last.cpp   |   35 -
 .../range-v3-0.11.0/test/view/take_while.cpp  |   90 -
 .../range-v3-0.11.0/test/view/tokenize.cpp    |   39 -
 .../range-v3-0.11.0/test/view/transform.cpp   |  226 -
 .../range-v3-0.11.0/test/view/trim.cpp        |   97 -
 .../range-v3-0.11.0/test/view/unique.cpp      |  155 -
 .../range-v3-0.11.0/test/view/view.cpp        |   49 -
 src/contrib/range-v3-0.11.0/test/view/zip.cpp |  304 --
 .../test_package/CMakeLists.txt               |   23 -
 .../range-v3-0.11.0/test_package/conanfile.py |   33 -
 .../range-v3-0.11.0/test_package/example.cpp  |   43 -
 src/contrib/range-v3-0.11.0/version.hpp.in    |   24 -
 635 files changed, 105191 deletions(-)
 delete mode 100644 src/contrib/range-v3-0.11.0/BUCK
 delete mode 100644 src/contrib/range-v3-0.11.0/BUILD.bazel
 delete mode 100644 src/contrib/range-v3-0.11.0/CMakeLists.txt
 delete mode 100644 src/contrib/range-v3-0.11.0/CREDITS.md
 delete mode 100644 src/contrib/range-v3-0.11.0/LICENSE.txt
 delete mode 100644 src/contrib/range-v3-0.11.0/README.md
 delete mode 100644 src/contrib/range-v3-0.11.0/TODO.md
 delete mode 100644 src/contrib/range-v3-0.11.0/Version.cmake
 delete mode 100644 src/contrib/range-v3-0.11.0/WORKSPACE
 delete mode 100644 src/contrib/range-v3-0.11.0/cmake/GoogleBenchmark.cmake.in
 delete mode 100644 src/contrib/range-v3-0.11.0/cmake/GoogleTest.cmake.in
 delete mode 100644 src/contrib/range-v3-0.11.0/cmake/TestHeaders.cmake
 delete mode 100644 src/contrib/range-v3-0.11.0/cmake/aligned_new_probe.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/cmake/concepts_test_code.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/cmake/coro_test_code.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/cmake/gbenchmark.cmake
 delete mode 100644 src/contrib/range-v3-0.11.0/cmake/gtest.cmake
 delete mode 100644 src/contrib/range-v3-0.11.0/cmake/range-v3-config.cmake
 delete mode 100644 src/contrib/range-v3-0.11.0/cmake/ranges_diagnostics.cmake
 delete mode 100644 src/contrib/range-v3-0.11.0/cmake/ranges_env.cmake
 delete mode 100644 src/contrib/range-v3-0.11.0/cmake/ranges_flags.cmake
 delete mode 100644 src/contrib/range-v3-0.11.0/cmake/ranges_options.cmake
 delete mode 100644 src/contrib/range-v3-0.11.0/cmake/readme.md
 delete mode 100644 src/contrib/range-v3-0.11.0/conanfile.py
 delete mode 100644 src/contrib/range-v3-0.11.0/doc/CMakeLists.txt
 delete mode 100644 src/contrib/range-v3-0.11.0/doc/Doxyfile.in
 delete mode 100644 src/contrib/range-v3-0.11.0/doc/clean-gh-pages.cmake
 delete mode 100644 src/contrib/range-v3-0.11.0/doc/examples.md
 delete mode 100755 src/contrib/range-v3-0.11.0/doc/ignore_errors.sh
 delete mode 100644 src/contrib/range-v3-0.11.0/doc/index.md
 delete mode 100644 src/contrib/range-v3-0.11.0/doc/layout.xml
 delete mode 100755 src/contrib/range-v3-0.11.0/doc/preprocess.sh.in
 delete mode 100644 src/contrib/range-v3-0.11.0/doc/release_notes.md
 delete mode 100644 src/contrib/range-v3-0.11.0/doc/std/D4128.md
 delete mode 100644 src/contrib/range-v3-0.11.0/doc/std/header.html
 delete mode 100644 src/contrib/range-v3-0.11.0/doc/std/pandoc-template.html
 delete mode 100644 src/contrib/range-v3-0.11.0/doc/std/show.cmd
 delete mode 100755 src/contrib/range-v3-0.11.0/doc/unpreprocess.pl
 delete mode 100644 src/contrib/range-v3-0.11.0/example/BUCK
 delete mode 100644 src/contrib/range-v3-0.11.0/example/CMakeLists.txt
 delete mode 100644 src/contrib/range-v3-0.11.0/example/accumulate_ints.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/example/any_all_none_of.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/example/calendar.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/example/comprehension_conversion.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/example/comprehensions.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/example/count.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/example/count_if.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/example/filter_transform.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/example/find.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/example/for_each_assoc.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/example/for_each_sequence.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/example/hello.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/example/is_sorted.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/example/sort_unique.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/concepts/compare.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/concepts/concepts.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/concepts/swap.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/concepts/type_traits.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/meta/meta.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/meta/meta_fwd.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/module.modulemap
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/action.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/action/action.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/action/adjacent_remove_if.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/action/concepts.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/action/drop.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/action/drop_while.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/action/erase.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/action/insert.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/action/join.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/action/push_back.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/action/push_front.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/action/remove.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/action/remove_if.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/action/reverse.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/action/shuffle.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/action/slice.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/action/sort.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/action/split.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/action/split_when.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/action/stable_sort.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/action/stride.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/action/take.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/action/take_while.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/action/transform.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/action/unique.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/action/unstable_remove_if.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/adjacent_find.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/adjacent_remove_if.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/all_of.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/any_of.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/aux_/equal_range_n.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/aux_/lower_bound_n.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/aux_/merge_n.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/aux_/merge_n_with_buffer.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/aux_/partition_point_n.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/aux_/sort_n_with_buffer.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/aux_/upper_bound_n.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/binary_search.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/contains.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/copy.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/copy_backward.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/copy_if.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/copy_n.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/count.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/count_if.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/ends_with.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/equal.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/equal_range.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/fill.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/fill_n.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/find.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/find_end.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/find_first_of.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/find_if.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/find_if_not.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/for_each.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/for_each_n.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/generate.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/generate_n.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/heap_algorithm.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/inplace_merge.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/is_partitioned.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/is_sorted.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/is_sorted_until.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/lexicographical_compare.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/lower_bound.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/max.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/max_element.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/merge.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/min.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/min_element.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/minmax.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/minmax_element.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/mismatch.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/move.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/move_backward.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/none_of.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/nth_element.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/partial_sort.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/partial_sort_copy.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/partition.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/partition_copy.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/partition_point.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/permutation.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/remove.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/remove_copy.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/remove_copy_if.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/remove_if.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/replace.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/replace_copy.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/replace_copy_if.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/replace_if.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/result_types.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/reverse.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/reverse_copy.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/rotate.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/rotate_copy.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/sample.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/search.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/search_n.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/set_algorithm.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/shuffle.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/sort.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/stable_partition.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/stable_sort.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/starts_with.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/swap_ranges.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/tagspec.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/transform.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/unique.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/unique_copy.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/unstable_remove_if.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/algorithm/upper_bound.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/all.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/at.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/back.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/begin_end.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/compare.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/core.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/data.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/detail/adl_get.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/detail/config.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/detail/epilogue.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/detail/prologue.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/detail/range_access.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/detail/satisfy_boost_range.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/detail/variant.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/detail/with_braced_init_args.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/distance.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/empty.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/experimental/utility/generator.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/experimental/view/shared.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/front.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/functional.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/functional/arithmetic.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/functional/bind.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/functional/bind_back.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/functional/comparisons.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/functional/compose.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/functional/concepts.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/functional/identity.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/functional/indirect.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/functional/invoke.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/functional/not_fn.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/functional/on.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/functional/overload.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/functional/pipeable.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/functional/reference_wrapper.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/getlines.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/index.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/istream_range.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/iterator.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/iterator/access.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/iterator/basic_iterator.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/iterator/common_iterator.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/iterator/concepts.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/iterator/counted_iterator.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/iterator/default_sentinel.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/iterator/diffmax_t.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/iterator/insert_iterators.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/iterator/move_iterators.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/iterator/operations.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/iterator/reverse_iterator.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/iterator/stream_iterators.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/iterator/traits.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/iterator/unreachable_sentinel.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/iterator_range.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/numeric.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/numeric/accumulate.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/numeric/adjacent_difference.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/numeric/inner_product.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/numeric/iota.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/numeric/partial_sum.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/range.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/range/access.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/range/concepts.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/range/conversion.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/range/dangling.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/range/operations.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/range/primitives.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/range/traits.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/range_access.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/range_concepts.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/range_for.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/range_fwd.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/range_traits.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/size.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/span.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/to_container.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/addressof.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/any.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/associated_types.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/basic_iterator.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/box.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/common_iterator.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/common_tuple.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/common_type.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/compressed_pair.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/concepts.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/copy.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/counted_iterator.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/dangling.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/functional.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/get.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/in_place.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/infinity.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/invoke.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/iterator.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/iterator_concepts.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/iterator_traits.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/memory.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/move.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/nullptr_v.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/optional.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/polymorphic_cast.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/random.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/scope_exit.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/semiregular.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/semiregular_box.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/static_const.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/swap.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/tagged_pair.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/tagged_tuple.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/tuple_algorithm.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/unreachable.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/utility/variant.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/version.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/adaptor.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/addressof.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/adjacent_filter.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/adjacent_remove_if.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/all.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/any_view.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/bounded.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/c_str.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/cache1.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/cartesian_product.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/chunk.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/common.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/concat.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/const.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/counted.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/cycle.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/delimit.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/drop.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/drop_exactly.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/drop_last.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/drop_while.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/empty.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/enumerate.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/exclusive_scan.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/facade.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/filter.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/for_each.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/generate.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/generate_n.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/getlines.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/group_by.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/indices.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/indirect.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/interface.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/intersperse.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/iota.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/istream.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/join.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/linear_distribute.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/map.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/move.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/partial_sum.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/ref.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/remove.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/remove_if.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/repeat.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/repeat_n.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/replace.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/replace_if.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/reverse.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/sample.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/set_algorithm.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/single.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/slice.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/sliding.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/span.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/split.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/split_when.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/stride.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/subrange.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/tail.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/take.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/take_exactly.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/take_last.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/take_while.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/tokenize.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/transform.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/trim.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/unbounded.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/unique.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/view.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/zip.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view/zip_with.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view_adaptor.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view_facade.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/range/v3/view_interface.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/std/detail/associated_types.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/include/std/iterator
 delete mode 100755 src/contrib/range-v3-0.11.0/install_libcxx.sh
 delete mode 100644 src/contrib/range-v3-0.11.0/perf/CMakeLists.txt
 delete mode 100644 src/contrib/range-v3-0.11.0/perf/counted_insertion_sort.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/perf/range_conversion.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/perf/sort_patterns.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/CMakeLists.txt
 delete mode 100644 src/contrib/range-v3-0.11.0/test/action/CMakeLists.txt
 delete mode 100644 src/contrib/range-v3-0.11.0/test/action/adjacent_remove_if.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/action/cont_concepts.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/action/drop.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/action/drop_while.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/action/insert.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/action/join.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/action/push_back.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/action/push_front.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/action/remove.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/action/remove_if.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/action/reverse.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/action/shuffle.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/action/slice.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/action/sort.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/action/split.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/action/stable_sort.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/action/stride.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/action/take.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/action/take_while.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/action/transform.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/action/unique.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/action/unstable_remove_if.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/CMakeLists.txt
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/adjacent_find.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/adjacent_remove_if.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/all_of.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/any_of.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/binary_search.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/contains.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/copy.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/copy_backward.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/count.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/count_if.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/ends_with.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/equal.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/equal_range.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/fill.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/find.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/find_end.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/find_first_of.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/find_if.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/for_each.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/for_each_n.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/generate.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/generate_n.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/includes.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/inplace_merge.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/is_heap.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/is_heap1.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/is_heap2.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/is_heap3.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/is_heap4.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/is_heap_until.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/is_heap_until1.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/is_heap_until2.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/is_heap_until3.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/is_heap_until4.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/is_partitioned.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/is_permutation.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/is_sorted.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/is_sorted_until.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/lexicographical_compare.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/lower_bound.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/make_heap.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/max.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/max_element.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/merge.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/min.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/min_element.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/minmax.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/minmax_element.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/mismatch.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/move.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/move_backward.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/next_permutation.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/none_of.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/nth_element.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/partial_sort.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/partial_sort_copy.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/partition.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/partition_copy.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/partition_point.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/pop_heap.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/prev_permutation.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/push_heap.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/remove.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/remove_copy.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/remove_copy_if.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/remove_if.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/replace.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/replace_copy.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/replace_copy_if.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/replace_if.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/reverse.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/reverse_copy.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/rotate.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/rotate_copy.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/sample.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/search.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/search_n.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/set_difference.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/set_difference1.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/set_difference2.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/set_difference3.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/set_difference4.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/set_difference5.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/set_difference6.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/set_intersection.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/set_intersection1.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/set_intersection2.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/set_intersection3.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/set_intersection4.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/set_intersection5.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/set_intersection6.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/set_symmetric_difference.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/set_symmetric_difference1.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/set_symmetric_difference2.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/set_symmetric_difference3.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/set_symmetric_difference4.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/set_symmetric_difference5.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/set_symmetric_difference6.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/set_union.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/set_union1.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/set_union2.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/set_union3.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/set_union4.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/set_union5.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/set_union6.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/shuffle.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/sort.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/sort_heap.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/sort_n_with_buffer.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/stable_partition.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/stable_sort.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/starts_with.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/swap_ranges.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/transform.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/unique.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/unique_copy.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/algorithm/upper_bound.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/array.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/bug1322.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/bug1335.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/bug474.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/bug566.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/config.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/constexpr_core.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/debug_view.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/experimental/CMakeLists.txt
 delete mode 100644 src/contrib/range-v3-0.11.0/test/experimental/utility/CMakeLists.txt
 delete mode 100644 src/contrib/range-v3-0.11.0/test/experimental/utility/generator.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/experimental/view/CMakeLists.txt
 delete mode 100644 src/contrib/range-v3-0.11.0/test/experimental/view/shared.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/functional/CMakeLists.txt
 delete mode 100644 src/contrib/range-v3-0.11.0/test/functional/bind_back.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/iterator/CMakeLists.txt
 delete mode 100644 src/contrib/range-v3-0.11.0/test/iterator/basic_iterator.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/iterator/common_iterator.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/iterator/diffmax_t.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/iterator/iterator.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/iterator/reverse_iterator.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/multiple1.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/multiple2.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/numeric/CMakeLists.txt
 delete mode 100644 src/contrib/range-v3-0.11.0/test/numeric/accumulate.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/numeric/adjacent_difference.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/numeric/inner_product.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/numeric/iota.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/numeric/partial_sum.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/range/CMakeLists.txt
 delete mode 100644 src/contrib/range-v3-0.11.0/test/range/access.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/range/conversion.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/range/index.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/range/operations.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/simple_test.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/test_iterators.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/test_utils.hpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/utility/CMakeLists.txt
 delete mode 100644 src/contrib/range-v3-0.11.0/test/utility/box.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/utility/common_type.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/utility/compare.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/utility/concepts.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/utility/functional.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/utility/meta.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/utility/scope_exit.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/utility/semiregular_box.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/utility/swap.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/utility/variant.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/CMakeLists.txt
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/adaptor.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/addressof.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/adjacent_remove_if.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/all.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/any_view.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/cache1.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/cartesian_product.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/chunk.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/common.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/concat.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/const.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/conversion.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/counted.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/cycle.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/delimit.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/drop.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/drop_exactly.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/drop_last.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/drop_while.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/enumerate.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/exclusive_scan.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/facade.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/generate.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/generate_n.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/getlines.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/group_by.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/indirect.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/intersperse.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/iota.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/istream.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/iterator_range.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/join.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/keys_value.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/linear_distribute.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/move.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/partial_sum.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/partial_sum_depr.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/remove.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/remove_if.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/repeat.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/replace.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/replace_if.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/reverse.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/sample.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/set_difference.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/set_intersection.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/set_symmetric_difference.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/set_union.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/slice.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/sliding.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/span.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/split.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/stride.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/subrange.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/tail.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/take.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/take_exactly.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/take_last.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/take_while.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/tokenize.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/transform.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/trim.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/unique.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/view.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test/view/zip.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/test_package/CMakeLists.txt
 delete mode 100644 src/contrib/range-v3-0.11.0/test_package/conanfile.py
 delete mode 100644 src/contrib/range-v3-0.11.0/test_package/example.cpp
 delete mode 100644 src/contrib/range-v3-0.11.0/version.hpp.in

diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 0999aa97..a0be26ea 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -4,10 +4,6 @@ include_directories(contrib/SimpleLogger/src)
 add_subdirectory(contrib/Argengine EXCLUDE_FROM_ALL)
 include_directories(contrib/Argengine/src)
 
-# This lib can be removed once we can upgrade to C++20
-add_subdirectory(contrib/range-v3-0.11.0 EXCLUDE_FROM_ALL)
-include_directories(contrib/range-v3-0.11.0/include)
-
 # Translation files in src/translations (without .ts)
 set(TS heimer_de heimer_en heimer_es heimer_fi heimer_fr heimer_it heimer_nl heimer_zh)
 set(TS_FILES)
diff --git a/src/contrib/range-v3-0.11.0/BUCK b/src/contrib/range-v3-0.11.0/BUCK
deleted file mode 100644
index 4b726ddb..00000000
--- a/src/contrib/range-v3-0.11.0/BUCK
+++ /dev/null
@@ -1,42 +0,0 @@
-prebuilt_cxx_library(
-  name = 'concepts',
-  header_namespace = 'concepts',
-  header_only = True,
-  exported_headers = subdir_glob([
-    ('include/concepts', '**/*.hpp'),
-  ]),
-  licenses = [
-    'LICENSE.txt',
-  ],
-)
-
-prebuilt_cxx_library(
-  name = 'meta',
-  header_namespace = 'meta',
-  header_only = True,
-  exported_headers = subdir_glob([
-    ('include/meta', '**/*.hpp'),
-  ]),
-  licenses = [
-    'LICENSE.txt',
-  ],
-)
-
-prebuilt_cxx_library(
-  name = 'range-v3',
-  header_namespace = 'range/v3',
-  header_only = True,
-  exported_headers = subdir_glob([
-    ('include/range/v3', '**/*.hpp'),
-  ]),
-  licenses = [
-    'LICENSE.txt',
-  ],
-  visibility = [
-    'PUBLIC'
-  ],
-  deps = [
-    ':concepts',
-    ':meta',
-  ],
-)
diff --git a/src/contrib/range-v3-0.11.0/BUILD.bazel b/src/contrib/range-v3-0.11.0/BUILD.bazel
deleted file mode 100644
index 9b1a8a47..00000000
--- a/src/contrib/range-v3-0.11.0/BUILD.bazel
+++ /dev/null
@@ -1,42 +0,0 @@
-cc_library(
-  name = 'concepts',
-  hdrs = glob([
-    'include/concepts/**/*.hpp',
-  ]),
-  includes = [
-    "include",
-  ],
-)
-
-cc_library(
-  name = 'meta',
-  hdrs = glob([
-    'include/meta/**/*.hpp',
-  ]),
-  includes = [
-    "include",
-  ],
-)
-
-cc_library(
-  name = 'std',
-  hdrs = glob([
-    'include/std/**/*.hpp',
-  ]),
-  includes = [
-    "include",
-  ],
-)
-
-cc_library(
-  name = 'range-v3',
-  hdrs = glob([
-    'include/range/v3/**/*.hpp',
-  ]),
-  visibility = ["//visibility:public"],
-  deps = [
-    ':concepts',
-    ':meta',
-    ':std',
-  ],
-)
diff --git a/src/contrib/range-v3-0.11.0/CMakeLists.txt b/src/contrib/range-v3-0.11.0/CMakeLists.txt
deleted file mode 100644
index ceda468e..00000000
--- a/src/contrib/range-v3-0.11.0/CMakeLists.txt
+++ /dev/null
@@ -1,178 +0,0 @@
-# Copyright Eric Niebler 2014
-# Copyright Gonzalo Brito Gadeschi 2014, 2017
-# Copyright Louis Dionne 2015
-# Copyright Casey Carter 2016
-# Distributed under the Boost Software License, Version 1.0.
-# (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-
-cmake_minimum_required(VERSION 3.6)
-get_directory_property(is_subproject PARENT_DIRECTORY)
-
-if(NOT is_subproject)
-    set(is_standalone YES)
-else()
-    set(is_standalone NO)
-endif()
-
-project(Range-v3 CXX)
-
-list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
-set(CMAKE_EXPORT_COMPILE_COMMANDS ON) # Export compilation data-base
-set_property(GLOBAL PROPERTY USE_FOLDERS ON)
-
-add_library(range-v3-meta INTERFACE)
-add_library(range-v3::meta ALIAS range-v3-meta)
-target_include_directories(range-v3-meta INTERFACE $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include/>)
-target_include_directories(range-v3-meta SYSTEM INTERFACE $<INSTALL_INTERFACE:$<INSTALL_PREFIX>/include>)
-target_compile_options(range-v3-meta INTERFACE $<$<CXX_COMPILER_ID:MSVC>:/permissive->)
-
-add_library(range-v3-concepts INTERFACE)
-add_library(range-v3::concepts ALIAS range-v3-concepts)
-target_include_directories(range-v3-concepts INTERFACE $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include/>)
-target_include_directories(range-v3-concepts SYSTEM INTERFACE $<INSTALL_INTERFACE:$<INSTALL_PREFIX>/include>)
-target_compile_options(range-v3-concepts INTERFACE $<$<CXX_COMPILER_ID:MSVC>:/permissive->)
-target_link_libraries(range-v3-concepts INTERFACE range-v3::meta)
-
-add_library(range-v3 INTERFACE)
-add_library(range-v3::range-v3 ALIAS range-v3)
-target_include_directories(range-v3 INTERFACE $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include/>)
-target_include_directories(range-v3 SYSTEM INTERFACE $<INSTALL_INTERFACE:$<INSTALL_PREFIX>/include>)
-target_compile_options(range-v3 INTERFACE $<$<CXX_COMPILER_ID:MSVC>:/permissive->)
-target_link_libraries(range-v3 INTERFACE range-v3::concepts range-v3::meta)
-
-function(rv3_add_test TESTNAME EXENAME FIRSTSOURCE)
-  add_executable(${EXENAME} ${FIRSTSOURCE} ${ARGN})
-  target_link_libraries(${EXENAME} range-v3)
-  add_test(${TESTNAME} ${EXENAME})
-endfunction(rv3_add_test)
-
-include(ranges_options)
-include(ranges_env)
-include(ranges_flags)
-
-if(RANGE_V3_DOCS)
-  add_subdirectory(doc)
-endif()
-
-if(RANGE_V3_TESTS)
-  include(CTest)
-  add_subdirectory(test)
-endif()
-
-if(RANGE_V3_EXAMPLES)
-  add_subdirectory(example)
-endif()
-
-if(RANGE_V3_PERF)
-  include(gtest)
-  include(gbenchmark)
-  add_subdirectory(perf)
-endif()
-
-# Add header files as sources to fix MSVS 2017 not finding source during debugging
-file(GLOB_RECURSE RANGE_V3_PUBLIC_HEADERS_ABSOLUTE
-                  "${CMAKE_CURRENT_SOURCE_DIR}/include/*.hpp")
-add_custom_target(headers SOURCES ${RANGE_V3_PUBLIC_HEADERS_ABSOLUTE})
-set_target_properties(headers PROPERTIES FOLDER "header")
-
-# Test all headers
-if(RANGE_V3_HEADER_CHECKS)
-  include(TestHeaders)
-
-  file(GLOB_RECURSE RANGE_V3_PUBLIC_HEADERS
-                    RELATIVE "${CMAKE_CURRENT_SOURCE_DIR}/include"
-                    "${CMAKE_CURRENT_SOURCE_DIR}/include/*.hpp")
-  # These headers are not meant to be included directly:
-  list(REMOVE_ITEM RANGE_V3_PUBLIC_HEADERS std/detail/associated_types.hpp)
-  list(REMOVE_ITEM RANGE_V3_PUBLIC_HEADERS range/v3/detail/epilogue.hpp)
-  # Deprecated headers
-  if(CMAKE_CXX_COMPILER_ID STREQUAL GNU)
-    foreach(header ${RANGE_V3_PUBLIC_HEADERS})
-      file(STRINGS "${CMAKE_CURRENT_SOURCE_DIR}/include/${header}" is_deprecated
-           LIMIT_COUNT 1
-           REGEX ".*RANGES_DEPRECATED_HEADER.*")
-      if(is_deprecated)
-        list(APPEND RANGE_V3_DEPRECATED_PUBLIC_HEADERS "${header}")
-      endif()
-    endforeach()
-  endif()
-
-  add_header_test(test.range.v3.headers
-    EXCLUDE ${RANGE_V3_DEPRECATED_PUBLIC_HEADERS}
-    HEADERS ${RANGE_V3_PUBLIC_HEADERS})
-  target_link_libraries(test.range.v3.headers PRIVATE range-v3)
-endif()
-
-# Grab the range-v3 version numbers:
-include(${CMAKE_CURRENT_SOURCE_DIR}/Version.cmake)
-set(RANGE_V3_VERSION ${RANGE_V3_MAJOR}.${RANGE_V3_MINOR}.${RANGE_V3_PATCHLEVEL})
-
-# Try to build a new version.hpp
-configure_file(version.hpp.in include/range/v3/version.hpp @ONLY)
-file(STRINGS ${CMAKE_CURRENT_BINARY_DIR}/include/range/v3/version.hpp RANGE_V3_OLD_VERSION_HPP)
-file(STRINGS ${CMAKE_CURRENT_SOURCE_DIR}/include/range/v3/version.hpp RANGE_V3_NEW_VERSION_HPP)
-
-# If the new version.hpp is materially different from the one in the source
-# directory, update it, commit, and tag.
-if(NOT RANGE_V3_NEW_VERSION_HPP STREQUAL RANGE_V3_OLD_VERSION_HPP)
-  # Check that doc/release_notes.md and Version.cmake are the only changed file:
-  execute_process(
-    COMMAND ${GIT_EXECUTABLE} -C "${CMAKE_CURRENT_SOURCE_DIR}" status --porcelain -uno
-    OUTPUT_VARIABLE RANGE_V3_GIT_STATUS
-    OUTPUT_STRIP_TRAILING_WHITESPACE
-  )
-  string(REPLACE "\n" ";"  RANGE_V3_GIT_STATUS ${RANGE_V3_GIT_STATUS})
-  if (NOT "x${RANGE_V3_GIT_STATUS}" STREQUAL "x M Version.cmake; M doc/release_notes.md")
-    message(FATAL_ERROR "Cannot update version.hpp: range-v3 source directory has a dirty status")
-  endif()
-  file(
-    COPY ${CMAKE_CURRENT_BINARY_DIR}/include/range/v3/version.hpp
-    DESTINATION ${CMAKE_CURRENT_SOURCE_DIR}/include/range/v3
-  )
-  execute_process(
-    COMMAND ${GIT_EXECUTABLE} -C "${CMAKE_CURRENT_SOURCE_DIR}" add -u
-  )
-  execute_process(
-    COMMAND ${GIT_EXECUTABLE} -C "${CMAKE_CURRENT_SOURCE_DIR}" commit -m "${RANGE_V3_VERSION}"
-  )
-  execute_process(
-    COMMAND ${GIT_EXECUTABLE} -C "${CMAKE_CURRENT_SOURCE_DIR}" tag -f -a "${RANGE_V3_VERSION}" -m "${RANGE_V3_VERSION}"
-  )
-  find_program(CONAN_EXECUTABLE NAMES conan conan.exe)
-  if (NOT "x${CONAN_EXECUTABLE}" STREQUAL "xCONAN_EXECUTABLE-NOTFOUND")
-    message(STATUS "Exporting conanfile for new version")
-    execute_process(
-      COMMAND ${CONAN_EXECUTABLE} create . range-v3/${RANGE_V3_VERSION}@ericniebler/stable
-      WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}"
-    )
-  endif()
-  message(STATUS "Version updated to ${RANGE_V3_VERSION}. Don't forget to:")
-  message(STATUS "  git push origin <feature-branch>")
-  message(STATUS "and (after that is merged to master) then:")
-  message(STATUS "  conan create ${CMAKE_CURRENT_SOURCE_DIR} range-v3/${RANGE_V3_VERSION}@ericniebler/stable")
-  message(STATUS "  conan upload --all range-v3/${RANGE_V3_VERSION}@ericniebler/stable")
-endif()
-
-include(CMakePackageConfigHelpers)
-
-# write_basic_package_version_file(...) gained ARCH_INDEPENDENT in CMake 3.14.
-# For CMake 3.6, this workaround makes the version file ARCH_INDEPENDENT
-# by making CMAKE_SIZEOF_VOID_P empty.
-set(OLD_CMAKE_SIZEOF_VOID_P ${CMAKE_SIZEOF_VOID_P})
-set(CMAKE_SIZEOF_VOID_P "")
-write_basic_package_version_file(
-  ${CMAKE_CURRENT_BINARY_DIR}/range-v3-config-version.cmake
-  VERSION ${RANGE_V3_VERSION}
-  COMPATIBILITY ExactVersion
-)
-set(CMAKE_SIZEOF_VOID_P ${OLD_CMAKE_SIZEOF_VOID_P})
-
-install(TARGETS range-v3-concepts range-v3-meta range-v3 EXPORT range-v3-targets DESTINATION lib)
-install(EXPORT range-v3-targets FILE range-v3-targets.cmake DESTINATION lib/cmake/range-v3)
-install(FILES
-  ${CMAKE_CURRENT_BINARY_DIR}/range-v3-config-version.cmake
-  cmake/range-v3-config.cmake
-  DESTINATION lib/cmake/range-v3)
-install(DIRECTORY include/ DESTINATION include FILES_MATCHING PATTERN "*")
-
-export(EXPORT range-v3-targets FILE range-v3-config.cmake)
diff --git a/src/contrib/range-v3-0.11.0/CREDITS.md b/src/contrib/range-v3-0.11.0/CREDITS.md
deleted file mode 100644
index 46bd9798..00000000
--- a/src/contrib/range-v3-0.11.0/CREDITS.md
+++ /dev/null
@@ -1,48 +0,0 @@
-Acknowledgements
-----------------
-
-In range-v3, I have integrated many ideas that come from other people. I would be remiss to not mention them. Many others helped either directly or indirectly in a variety of ways. In no particular order...
-
-| Contributor                 | Contribution |
-|-----------------------------|------|
-| Jeremy Siek                 | Container algorithms (in Boost pre-history), Boost.Iterators |
-| Thorston Ottoson            | Boost.Range v1 |
-| Neil Groves                 | Boost.Range v2 |
-| David Abrahams, Thomas Witt | Boost.Iterators, Sentinels |
-| Sean Parent                 | ASL, Projections, View / Range distinction, much Generic Program wisdom besides |
-| Dietmar Khl                | Array Traits, Property Map |
-| Andrew Sutton               | C++ Concepts "Lite", Origin Libraries, Palo Alto Report |
-| Doug Gregor                 | C++0x Concepts |
-| Casey Carter                | Co-author and Editor, Ranges TS; major code contributions |
-| Gonzalo Brito Gadeschi      | Many ideas, bug reports, and code contributions |
-| Alexander Stepanov          | STL, Generic Programming, Iterators, Elements of Programming, etc. |
-| Bjarne Stroustrup           | A tireless effort to add proper support for Generic Programming to C++, early support for my Ranges proposal |
-| Herb Sutter                 | Early support for my Ranges proposal |
-| The Standard C++ Foundation | A generous grant supporting my Ranges work |
-
-An Abreviated History
---------------------
-
-**Range v1**
-
-I came to Boost in the early 2000's. By that time, Boost already had a Range library (Thorston Ottoson's). At this time, Boost.Range was little more that the `begin` and `end` free functions, and range-based overloads of the STL algorithms that dispatched to the iterator-based overloads in namespace `std`.
-
-Boost also already had the Iterators library by David Abrahams and Jeremy Siek. This library had iterator adaptors like `filter_iterator` and `transform_iterator`.
-
-**Range v2**
-
-It seemed natural to me that the Range library and the adaptors from the Iterators library should be combined. I wrote the `filter` and `transform` range adaptors, commandeered the pipe operator (`|`) from bash for chaining, and put a rough library together called Range_ex in the Boost File Vault (which would later become the Boost Sandbox). I saw problems with my design and never finished it.
-
-A few years later, Neil Groves picked up some of the ideas in my Range\_ex, polished them a great deal, published his own Range\_ex library, and submitted it to Boost. It became Boost.Range v2. At the time of writing (March, 2017), it is the version still shipping with Boost.
-
-**Range v3**
-
-In 2013, I published a blog post called ["Out Parameters, Move Semantics, and Stateful Algorithms"](http://ericniebler.com/2013/10/13/out-parameters-vs-move-semantics/) that turned my mind to ranges once again. Following that, it became clear to me that the Boost.Range library, designed for C++98, needed a facelift for the post-C++11 world. I began what I believed at the time would be a quick hack to bring Boost.Range into the modern world. I called it "Range v3", thinking it would become the third major version of the Boost.Range library. Subsequent posts detailed the evolution of my thinking as range-v3 took shape.
-
-**Standardization**
-
-Around this time, some big thinkers in the C++ community were working to resurrect the effort to add Concepts to C++. They published a paper ([N3351](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3351.pdf)) that would become known as the **"Palo Alto Report"** which detailed the necessary and sufficient language and library support for a concept-checked version of the Standard Template Library. The authors of the paper included Alexander Stepanov, Bjarne Stroustrup, Sean Parent, Andrew Sutton, and more. Andrew Sutton began working in earnest to realize the core language changes, an effort that became known as "Concepts Lite". (It is now the Concepts TS.)
-
-I decided early on that Concepts Lite, or something like it, would become part of Standard C++. Recognizing that C++ would need a concept-ified Standard Library to go with the language feature, I began evolving range-v3 in that direction, eventually submitting ["Ranges for the Standard Library, Revision 1"](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4128.html) to the C++ Standardization Committee, together with Andrew Sutton and Sean Parent. The Committee approved the direction in late 2014, and so it goes...
-
-Today (2017-03), we are very close to a final Ranges TS and are on target to integrate into Standard C++ in 2020, with *much* more to come. Stay tuned.
diff --git a/src/contrib/range-v3-0.11.0/LICENSE.txt b/src/contrib/range-v3-0.11.0/LICENSE.txt
deleted file mode 100644
index 698193e9..00000000
--- a/src/contrib/range-v3-0.11.0/LICENSE.txt
+++ /dev/null
@@ -1,151 +0,0 @@
-========================================================
-Boost Software License - Version 1.0 - August 17th, 2003
-========================================================
-
-Permission is hereby granted, free of charge, to any person or organization
-obtaining a copy of the software and accompanying documentation covered by
-this license (the "Software") to use, reproduce, display, distribute,
-execute, and transmit the Software, and to prepare derivative works of the
-Software, and to permit third-parties to whom the Software is furnished to
-do so, all subject to the following:
-
-The copyright notices in the Software and this entire statement, including
-the above license grant, this restriction and the following disclaimer,
-must be included in all copies of the Software, in whole or in part, and
-all derivative works of the Software, unless such copies or derivative
-works are solely in the form of machine-executable object code generated by
-a source language processor.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
-SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
-FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
-ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.
-
-==============================================================================
-libc++ License
-==============================================================================
-
-The libc++ library is dual licensed under both the University of Illinois
-"BSD-Like" license and the MIT license.  As a user of this code you may choose
-to use it under either license.  As a contributor, you agree to allow your code
-to be used under both.
-
-Full text of the relevant licenses is included below.
-
-==============================================================================
-
-University of Illinois/NCSA
-Open Source License
-
-Copyright (c) 2009-2014 by the contributors listed in CREDITS.TXT
-http://llvm.org/svn/llvm-project/libcxx/trunk/CREDITS.TXT
-
-All rights reserved.
-
-Developed by:
-
-    LLVM Team
-
-    University of Illinois at Urbana-Champaign
-
-    http://llvm.org
-
-Permission is hereby granted, free of charge, to any person obtaining a copy of
-this software and associated documentation files (the "Software"), to deal with
-the Software without restriction, including without limitation the rights to
-use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
-of the Software, and to permit persons to whom the Software is furnished to do
-so, subject to the following conditions:
-
-    * Redistributions of source code must retain the above copyright notice,
-      this list of conditions and the following disclaimers.
-
-    * Redistributions in binary form must reproduce the above copyright notice,
-      this list of conditions and the following disclaimers in the
-      documentation and/or other materials provided with the distribution.
-
-    * Neither the names of the LLVM Team, University of Illinois at
-      Urbana-Champaign, nor the names of its contributors may be used to
-      endorse or promote products derived from this Software without specific
-      prior written permission.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
-CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
-SOFTWARE.
-
-==============================================================================
-
-Copyright (c) 2009-2014 by the contributors listed in CREDITS.TXT
-  http://llvm.org/svn/llvm-project/libcxx/trunk/CREDITS.TXT
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-THE SOFTWARE.
-
-==============================================================================
-Stepanov and McJones, "Elements of Programming" license
-==============================================================================
-
-// Copyright (c) 2009 Alexander Stepanov and Paul McJones
-//
-// Permission to use, copy, modify, distribute and sell this software
-// and its documentation for any purpose is hereby granted without
-// fee, provided that the above copyright notice appear in all copies
-// and that both that copyright notice and this permission notice
-// appear in supporting documentation. The authors make no
-// representations about the suitability of this software for any
-// purpose. It is provided "as is" without express or implied
-// warranty.
-//
-// Algorithms from
-// Elements of Programming
-// by Alexander Stepanov and Paul McJones
-// Addison-Wesley Professional, 2009
-
-==============================================================================
-SGI C++ Standard Template Library license
-==============================================================================
-
-// Copyright (c) 1994
-// Hewlett-Packard Company
-//
-// Permission to use, copy, modify, distribute and sell this software
-// and its documentation for any purpose is hereby granted without fee,
-// provided that the above copyright notice appear in all copies and
-// that both that copyright notice and this permission notice appear
-// in supporting documentation.  Hewlett-Packard Company makes no
-// representations about the suitability of this software for any
-// purpose.  It is provided "as is" without express or implied warranty.
-//
-// Copyright (c) 1996
-// Silicon Graphics Computer Systems, Inc.
-//
-// Permission to use, copy, modify, distribute and sell this software
-// and its documentation for any purpose is hereby granted without fee,
-// provided that the above copyright notice appear in all copies and
-// that both that copyright notice and this permission notice appear
-// in supporting documentation.  Silicon Graphics makes no
-// representations about the suitability of this software for any
-// purpose.  It is provided "as is" without express or implied warranty.
-//
diff --git a/src/contrib/range-v3-0.11.0/README.md b/src/contrib/range-v3-0.11.0/README.md
deleted file mode 100644
index d2201f08..00000000
--- a/src/contrib/range-v3-0.11.0/README.md
+++ /dev/null
@@ -1,120 +0,0 @@
-range-v3
-========
-
-Range library for C++14/17/20. This code was the basis of [a formal proposal](https://ericniebler.github.io/std/wg21/D4128.html) to add range support to the C++ standard library. That proposal evolved through a Technical Specification, and finally into [P0896R4 "The One Ranges Proposal"](https://wg21.link/p0896r4) which was merged into the C++20 working drafts in November 2018.
-
-About:
-------
-
-Ranges are an extension of the Standard Template Library that makes its iterators and algorithms more powerful by making them _composable_. Unlike other range-like solutions which seek to do away with iterators, in range-v3 ranges are an abstration layer _on top_ of iterators.
-
-Range-v3 is built on three pillars: Views, Actions, and Algorithms. The algorithms are the same as those with which you are already familiar in the STL, except that in range-v3 all the algorithms have overloads that take ranges in addition to the overloads that take iterators. Views are composable adaptations of ranges where the adaptation happens lazily as the view is iterated. And an action is an eager application of an algorithm to a container that mutates the container in-place and returns it for further processing.
-
-Views and actions use the pipe syntax (e.g., `rng | adapt1 | adapt2 | ...`) so your code is terse and readable from left to right.
-
-Documentation:
---------------
-
-Check out the (woefully incomplete) documentation [here](https://ericniebler.github.io/range-v3/).
-
-Other resources (mind the dates, the library probably has changed since then):
-
-- Usage:
-  - Talk: [CppCon 2015: Eric Niebler "Ranges for the Standard Library"](https://www.youtube.com/watch?v=mFUXNMfaciE), 2015.
-  - [A slice of Python in C++](http://ericniebler.com/2014/12/07/a-slice-of-python-in-c/), 07.12.2014.
-  - Actions (back then called [Container Algorithms](http://ericniebler.com/2014/11/23/container-algorithms/)), 23.11.2014.
-  - [Range comprehensions](http://ericniebler.com/2014/04/27/range-comprehensions/), 27.04.2014.
-  - [Input iterators vs input ranges](http://ericniebler.com/2013/11/07/input-iterators-vs-input-ranges/), 07.11.2013.
-
-- Design / Implementation:
-  - Rationale behind range-v3: [N4128: Ranges for the standard library Revision 1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4128.html), 2014.
-  - Ranges TS: [N4560: C++ Extensions for Ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4560.pdf), 2015.
-  - Implementation of customization points in range-v3:
-    - [N4381: Suggested Design for Customization Points](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4381.html), 2015.
-    - [P0386: Inline variables](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0386r0.pdf), 2016.
-    - [Customization Point Design in C++11 and Beyond](http://ericniebler.com/2014/10/21/customization-point-design-in-c11-and-beyond/), 2014.
-  - Proxy iterators in range-v3:
-    - [D0022: Proxy Iterators for the Ranges Extensions](https://ericniebler.github.io/std/wg21/D0022.html).
-    - [To Be or Not to Be (an Iterator)](http://ericniebler.com/2015/01/28/to-be-or-not-to-be-an-iterator/), 2015.
-    - [Iterators++: Part1](http://ericniebler.com/2015/02/03/iterators-plus-plus-part-1/), 2015.
-    - [Iterators++: Part2](http://ericniebler.com/2015/02/13/iterators-plus-plus-part-2/), 2015.
-    - [Iterators++: Part3](http://ericniebler.com/2015/03/03/iterators-plus-plus-part-3/), 2015.
-  - Metaprogramming utilities:
-    - See the [meta documentation](https://ericniebler.github.io/meta/index.html), the library has changed significantly since the [2014 blog post](http://ericniebler.com/2014/11/13/tiny-metaprogramming-library/).
-  - Concept emulation layer: [Concept checking in C++11](http://ericniebler.com/2013/11/23/concept-checking-in-c11/), 2013.
-  - [C++Now 2014: Eric Niebler "C++11 Library Design"](https://www.youtube.com/watch?v=zgOF4NrQllo), 2014.
-
-License:
---------
-
-Most of the source code in this project are mine, and those are under the Boost Software License. Parts are taken from Alex Stepanov's Elements of Programming, Howard Hinnant's libc++, and from the SGI STL. Please see the attached LICENSE file and the CREDITS file for the licensing and acknowledgments.
-
-Supported Compilers
--------------------
-
-The code is known to work on the following compilers:
-
-- clang 5.0 (or later)
-- GCC 6.5 (or later)
-- Clang/LLVM 6 (or later) on Windows (older versions may work - we haven't tested.)
-- Visual Studio 2019 (or later) on Windows, with some caveats due to range-v3's strict conformance requirements:
-  - range-v3 needs `/permissive-` and either `/std:c++latest` or `/std:c++17`
-
-**Development Status:** This code is fairly stable, well-tested, and suitable for casual use, although currently lacking documentation. _In general_, no promise is made about support or long-term stability. This code *will* evolve without regard to backwards compatibility.
-
-A notable exception is anything found within the `ranges::cpp20` namespace. Those components will change rarely or (preferably) never at all.
-
-**Build status**
-- on GitHub Actions: [![GitHub Actions Status](https://github.com/ericniebler/range-v3/workflows/range-v3%20CI/badge.svg?branch=master)](https://github.com/ericniebler/range-v3/actions)
-
-Building range-v3 - Using vcpkg
--------------------------------
-
-You can download and install range-v3 using the [vcpkg](https://github.com/Microsoft/vcpkg) dependency manager:
-
-    git clone https://github.com/Microsoft/vcpkg.git
-    cd vcpkg
-    ./bootstrap-vcpkg.sh
-    ./vcpkg integrate install
-    ./vcpkg install range-v3
-
-The range-v3 port in vcpkg is kept up to date by Microsoft team members and community contributors. If the version is out of date, please [create an issue or pull request](https://github.com/Microsoft/vcpkg) on the vcpkg repository.
-
-Building range-v3 - Using Conan
--------------------------------
-
-You can download and install range-v3 using the [Conan](https://github.com/conan-io/conan) dependency manager.
-
-Setup your CMakeLists.txt (see [Conan documentation](https://docs.conan.io/en/latest/integrations/build_system.html) on how to use MSBuild, Meson and others):
-```
-project(myproject CXX)
-
-add_executable(${PROJECT_NAME} main.cpp)
-
-include(${CMAKE_BINARY_DIR}/conanbuildinfo.cmake) # Include Conan-generated file
-conan_basic_setup(TARGETS) # Introduce Conan-generated targets
-
-target_link_libraries(${PROJECT_NAME} CONAN_PKG::range-v3)
-```
-Create `conanfile.txt` in your source dir:
-```
-[requires]
-range-v3/0.10.0
-
-[generators]
-cmake
-```
-Install and run `conan`, then build your project as always:
-```
-pip install conan
-mkdir build
-cd build
-conan install ../ --build=missing
-cmake ../
-cmake --build .
-```
-
-Say Thanks!
------------
-
-I do this work because I love it and because I love C++ and want it to be as excellent as I know it can be. If you like my work and are looking for a way to say thank you, you can leave a supportive comment on [my blog](http://ericniebler.com). Or you could leave me some kudos on my Open Hub range-v3 contribution page. Just click the **Give Kudos** button [here](https://www.openhub.net/p/range-v3/contributors/3053743222308608).
diff --git a/src/contrib/range-v3-0.11.0/TODO.md b/src/contrib/range-v3-0.11.0/TODO.md
deleted file mode 100644
index 55a44ed4..00000000
--- a/src/contrib/range-v3-0.11.0/TODO.md
+++ /dev/null
@@ -1,26 +0,0 @@
-* Add contiguous iterator utilities. How about `is_contiguous_iterator` and `as_contiguous_range`:
-
-    ```
-    CPP_template(typename I, typename S)(
-        requires RandomAccessIterator<I> &&
-            SizedSentinel<S, I> &&
-            is_contiguous_iterator<I>())
-    subrange<std::add_pointer_t<iter_reference_t<I>>>
-    as_contiguous_range(I begin, S end)
-    {
-        if(begin == end)
-            return {nullptr, nullptr};
-        else
-            return {addressof(*begin), addressof(*begin) + (end - begin)};
-    }
-    ```
-* Longer-term goals:
-  - Make `inplace_merge` work with forward iterators
-  - Make the sorting algorithms work with forward iterators
-
-* Maybe iterators are not necessarily countable. Is there a relation between
-  the ability to be able to subtract two iterators to find the distance, and
-  with the existence of a DistanceType associated type? Think of:
-  - counted iterators (subtractable regardless of traversal category)
-  - repeat_view iterators (*not* subtractable but could be random access otherwise)
-  - infinite ranges (only countable with an infinite precision integer which we lack)
diff --git a/src/contrib/range-v3-0.11.0/Version.cmake b/src/contrib/range-v3-0.11.0/Version.cmake
deleted file mode 100644
index 6cb76af0..00000000
--- a/src/contrib/range-v3-0.11.0/Version.cmake
+++ /dev/null
@@ -1,7 +0,0 @@
-# To update the range-v3 version, from a working directory that is clean except for an
-# updated doc/release_notes.md file, update the version numbers below. This makefile will
-# generate a new version.hpp, *AMEND THE MOST RECENT COMMIT*, and git-tag the commit.
-
-set(RANGE_V3_MAJOR 0)
-set(RANGE_V3_MINOR 11)
-set(RANGE_V3_PATCHLEVEL 0)
diff --git a/src/contrib/range-v3-0.11.0/WORKSPACE b/src/contrib/range-v3-0.11.0/WORKSPACE
deleted file mode 100644
index e69de29b..00000000
diff --git a/src/contrib/range-v3-0.11.0/cmake/GoogleBenchmark.cmake.in b/src/contrib/range-v3-0.11.0/cmake/GoogleBenchmark.cmake.in
deleted file mode 100644
index 3fcf1b5c..00000000
--- a/src/contrib/range-v3-0.11.0/cmake/GoogleBenchmark.cmake.in
+++ /dev/null
@@ -1,19 +0,0 @@
-# Copyright Eric Niebler 2019
-# Distributed under the Boost Software License, Version 1.0.
-# (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-
-cmake_minimum_required(VERSION 2.8.2)
-
-project(google-benchmark-download NONE)
-
-include(ExternalProject)
-ExternalProject_Add(google-benchmark
-  GIT_REPOSITORY    https://github.com/google/benchmark.git
-  GIT_TAG           master
-  SOURCE_DIR        "${CMAKE_CURRENT_BINARY_DIR}/google-benchmark-src"
-  BINARY_DIR        "${CMAKE_CURRENT_BINARY_DIR}/google-benchmark-build"
-  CONFIGURE_COMMAND ""
-  BUILD_COMMAND     ""
-  INSTALL_COMMAND   ""
-  TEST_COMMAND      ""
-)
diff --git a/src/contrib/range-v3-0.11.0/cmake/GoogleTest.cmake.in b/src/contrib/range-v3-0.11.0/cmake/GoogleTest.cmake.in
deleted file mode 100644
index 0d33f9d8..00000000
--- a/src/contrib/range-v3-0.11.0/cmake/GoogleTest.cmake.in
+++ /dev/null
@@ -1,19 +0,0 @@
-# Copyright Eric Niebler 2019
-# Distributed under the Boost Software License, Version 1.0.
-# (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-
-cmake_minimum_required(VERSION 2.8.2)
-
-project(google-test-download NONE)
-
-include(ExternalProject)
-ExternalProject_Add(google-test
-  GIT_REPOSITORY    https://github.com/google/googletest.git
-  GIT_TAG           master
-  SOURCE_DIR        "${CMAKE_CURRENT_BINARY_DIR}/google-test-src"
-  BINARY_DIR        "${CMAKE_CURRENT_BINARY_DIR}/google-test-build"
-  CONFIGURE_COMMAND ""
-  BUILD_COMMAND     ""
-  INSTALL_COMMAND   ""
-  TEST_COMMAND      ""
-)
diff --git a/src/contrib/range-v3-0.11.0/cmake/TestHeaders.cmake b/src/contrib/range-v3-0.11.0/cmake/TestHeaders.cmake
deleted file mode 100644
index 663c9f4e..00000000
--- a/src/contrib/range-v3-0.11.0/cmake/TestHeaders.cmake
+++ /dev/null
@@ -1,128 +0,0 @@
-# Copyright Louis Dionne 2013-2017
-# Distributed under the Boost Software License, Version 1.0.
-# (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-#
-#
-# This CMake module provides a function generating a unit test to make sure
-# that every public header can be included on its own.
-#
-# When a C++ library or application has many header files, it can happen that
-# a header does not include all the other headers it depends on. When this is
-# the case, it can happen that including that header file on its own will
-# break the compilation. This CMake module generates a dummy executable
-# comprised of many .cpp files, each of which includes a header file that
-# is part of the public API. In other words, the executable is comprised
-# of .cpp files of the form:
-#
-#   #include <the/public/header.hpp>
-#
-# and then exactly one `main` function. If this succeeds to compile, it means
-# that the header can be included on its own, which is what clients expect.
-# Otherwise, you have a problem. Since writing these dumb unit tests by hand
-# is tedious and repetitive, you can use this CMake module to automate this
-# task.
-
-#   add_header_test(<target> [EXCLUDE_FROM_ALL] [EXCLUDE excludes...] HEADERS headers...)
-#
-# Generates header-inclusion unit tests for all the specified headers.
-#
-# This function creates a target which builds a dummy executable including
-# each specified header file individually. If this target builds successfully,
-# it means that all the specified header files can be included individually.
-#
-# Parameters
-# ----------
-# <target>:
-#   The name of the target to generate.
-#
-# HEADERS headers:
-#   A list of header files to generate the inclusion tests for. All headers
-#   in this list must be represented as relative paths from the root of the
-#   include directory added to the compiler's header search path. In other
-#   words, it should be possible to include all headers in this list as
-#
-#       #include <${header}>
-#
-#   For example, for a library with the following structure:
-#
-#       project/
-#           doc/
-#           test/
-#           ...
-#           include/
-#               boost/
-#                   hana.hpp
-#                   hana/
-#                       transform.hpp
-#                       tuple.hpp
-#                       pair.hpp
-#                       ...
-#
-#   When building the unit tests for that library, we'll add `-I project/include'
-#   to the compiler's arguments. The list of public headers should therefore contain
-#
-#       boost/hana.hpp
-#       boost/hana/transform.hpp
-#       boost/hana/tuple.hpp
-#       boost/hana/pair.hpp
-#       ...
-#
-#   Usually, all the 'public' header files of a library should be tested for
-#   standalone inclusion. A header is considered 'public' if a client should
-#   be able to include that header on its own.
-#
-# [EXCLUDE excludes]:
-#   An optional list of headers or regexes for which no unit test should be
-#   generated. Basically, any header in the list specified by the `HEADERS`
-#   argument that matches anything in `EXCLUDE` will be skipped.
-#
-# [EXCLUDE_FROM_ALL]:
-#   If provided, the generated target is excluded from the 'all' target.
-#
-function(add_header_test target)
-    cmake_parse_arguments(ARGS "EXCLUDE_FROM_ALL"             # options
-                               ""                             # 1 value args
-                               "HEADERS;EXCLUDE"              # multivalued args
-                               ${ARGN})
-    if (NOT ARGS_HEADERS)
-        message(FATAL_ERROR "The `HEADERS` argument must be provided.")
-    endif()
-
-    if (ARGS_EXCLUDE_FROM_ALL)
-        set(ARGS_EXCLUDE_FROM_ALL "EXCLUDE_FROM_ALL")
-    else()
-        set(ARGS_EXCLUDE_FROM_ALL "")
-    endif()
-
-    foreach(header ${ARGS_HEADERS})
-        set(skip FALSE)
-        foreach(exclude ${ARGS_EXCLUDE})
-            if (${header} MATCHES ${exclude})
-                set(skip TRUE)
-                break()
-            endif()
-        endforeach()
-        if (skip)
-            continue()
-        endif()
-
-        get_filename_component(filename "${header}" NAME_WE)
-        get_filename_component(directory "${header}" DIRECTORY)
-
-        set(source "${CMAKE_CURRENT_BINARY_DIR}/headers/${directory}/${filename}.cpp")
-        if (NOT EXISTS "${source}")
-            file(WRITE "${source}" "#include <${header}>")
-        endif()
-        list(APPEND sources "${source}")
-    endforeach()
-
-    set(standalone_main "${CMAKE_CURRENT_BINARY_DIR}/headers/_standalone_main.cpp")
-    if (NOT EXISTS "${standalone_main}")
-        file(WRITE "${standalone_main}" "int main() { }")
-    endif()
-    add_executable(${target}
-        ${ARGS_EXCLUDE_FROM_ALL}
-        ${sources}
-        "${CMAKE_CURRENT_BINARY_DIR}/headers/_standalone_main.cpp"
-    )
-endfunction()
diff --git a/src/contrib/range-v3-0.11.0/cmake/aligned_new_probe.cpp b/src/contrib/range-v3-0.11.0/cmake/aligned_new_probe.cpp
deleted file mode 100644
index 148a3178..00000000
--- a/src/contrib/range-v3-0.11.0/cmake/aligned_new_probe.cpp
+++ /dev/null
@@ -1,6 +0,0 @@
-#include <new>
-
-int main() {
-    struct alignas(__STDCPP_DEFAULT_NEW_ALIGNMENT__ * 4) S {};
-    (void) ::operator new(sizeof(S), static_cast<std::align_val_t>(alignof(S)));
-}
diff --git a/src/contrib/range-v3-0.11.0/cmake/concepts_test_code.cpp b/src/contrib/range-v3-0.11.0/cmake/concepts_test_code.cpp
deleted file mode 100644
index 42aaa982..00000000
--- a/src/contrib/range-v3-0.11.0/cmake/concepts_test_code.cpp
+++ /dev/null
@@ -1,19 +0,0 @@
-template<class>
-concept bool True = true;
-
-template<class T>
-constexpr bool test(T)
-{
-    return false;
-}
-
-template<True T>
-constexpr bool test(T)
-{
-    return true;
-}
-
-int main()
-{
-    static_assert(::test(42), "");
-}
diff --git a/src/contrib/range-v3-0.11.0/cmake/coro_test_code.cpp b/src/contrib/range-v3-0.11.0/cmake/coro_test_code.cpp
deleted file mode 100644
index b2216cfe..00000000
--- a/src/contrib/range-v3-0.11.0/cmake/coro_test_code.cpp
+++ /dev/null
@@ -1,46 +0,0 @@
-#if defined(__cpp_coroutines) && defined(__has_include)
-#if __has_include(<coroutine>)
-#include <coroutine>
-namespace std_coro = std;
-#elif __has_include(<experimental/coroutine>)
-#include <experimental/coroutine>
-namespace std_coro = std::experimental;
-#else
-#error Either the compiler or the library lacks support for coroutines
-#endif
-#else
-#error Either the compiler or the library lacks support for coroutines
-#endif
-
-struct present
-{
-    struct promise_type
-    {
-        int result;
-
-        present get_return_object() { return {*this}; }
-        std_coro::suspend_never initial_suspend() { return {}; }
-        std_coro::suspend_never final_suspend() { return {}; }
-        void return_value(int i) { result = i; }
-        void unhandled_exception() {}
-    };
-
-    promise_type& promise;
-
-    bool await_ready() const { return true; }
-    void await_suspend(std_coro::coroutine_handle<>) const {}
-    int await_resume() const { return promise.result; }
-};
-
-present f(int n)
-{
-    if (n < 2)
-        co_return 1;
-    else
-        co_return n * co_await f(n - 1);
-}
-
-int main()
-{
-    return f(5).promise.result != 120;
-}
diff --git a/src/contrib/range-v3-0.11.0/cmake/gbenchmark.cmake b/src/contrib/range-v3-0.11.0/cmake/gbenchmark.cmake
deleted file mode 100644
index 81789ca8..00000000
--- a/src/contrib/range-v3-0.11.0/cmake/gbenchmark.cmake
+++ /dev/null
@@ -1,26 +0,0 @@
-# Download and unpack googletest at configure time
-configure_file(
-    cmake/GoogleBenchmark.cmake.in
-    google-benchmark-download/CMakeLists.txt)
-
-execute_process(COMMAND ${CMAKE_COMMAND} -G "${CMAKE_GENERATOR}" .
-  RESULT_VARIABLE result
-  WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/google-benchmark-download)
-
-if(result)
-  message(FATAL_ERROR "CMake step for google-benchmark failed: ${result}")
-endif()
-
-execute_process(COMMAND ${CMAKE_COMMAND} --build .
-  RESULT_VARIABLE result
-  WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/google-benchmark-download)
-
-if(result)
-  message(FATAL_ERROR "Build step for google-benchmark failed: ${result}")
-endif()
-
-# Add google-benchmark directly to our build. This defines
-# the benchmark and benchmark_main targets.
-add_subdirectory(${CMAKE_CURRENT_BINARY_DIR}/google-benchmark-src
-                 ${CMAKE_CURRENT_BINARY_DIR}/google-benchmark-build
-                 EXCLUDE_FROM_ALL)
diff --git a/src/contrib/range-v3-0.11.0/cmake/gtest.cmake b/src/contrib/range-v3-0.11.0/cmake/gtest.cmake
deleted file mode 100644
index a989aec9..00000000
--- a/src/contrib/range-v3-0.11.0/cmake/gtest.cmake
+++ /dev/null
@@ -1,32 +0,0 @@
-# Copyright 2019 Eric Niebler
-# Distributed under the Boost Software License, Version 1.0.
-# (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-
-# Download and unpack googletest at configure time
-configure_file(cmake/GoogleTest.cmake.in google-test-download/CMakeLists.txt)
-
-execute_process(COMMAND ${CMAKE_COMMAND} -G "${CMAKE_GENERATOR}" .
-  RESULT_VARIABLE result
-  WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/google-test-download )
-
-if(result)
-  message(FATAL_ERROR "CMake step for google-test failed: ${result}")
-endif()
-
-execute_process(COMMAND ${CMAKE_COMMAND} --build .
-  RESULT_VARIABLE result
-  WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/google-test-download )
-
-if(result)
-  message(FATAL_ERROR "Build step for google-test failed: ${result}")
-endif()
-
-# Prevent overriding the parent project's compiler/linker
-# settings on Windows
-set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)
-
-# Add google-test directly to our build. This defines
-# the gtest and gtest_main targets.
-add_subdirectory(${CMAKE_CURRENT_BINARY_DIR}/google-test-src
-                 ${CMAKE_CURRENT_BINARY_DIR}/google-test-build
-                 EXCLUDE_FROM_ALL)
diff --git a/src/contrib/range-v3-0.11.0/cmake/range-v3-config.cmake b/src/contrib/range-v3-0.11.0/cmake/range-v3-config.cmake
deleted file mode 100644
index 33c774d2..00000000
--- a/src/contrib/range-v3-0.11.0/cmake/range-v3-config.cmake
+++ /dev/null
@@ -1,21 +0,0 @@
-include("${CMAKE_CURRENT_LIST_DIR}/range-v3-targets.cmake")
-
-if (TARGET range-v3::meta)
-  return()
-endif()
-
-add_library(range-v3::meta INTERFACE IMPORTED)
-add_library(range-v3::concepts INTERFACE IMPORTED)
-add_library(range-v3::range-v3 INTERFACE IMPORTED)
-
-# workaround for target_link_libraries on lower cmake versions (< 3.11)
-# see https://cmake.org/cmake/help/latest/release/3.11.html#commands
-if(CMAKE_VERSION VERSION_LESS 3.11)
-set_target_properties(range-v3::meta PROPERTIES INTERFACE_LINK_LIBRARIES "range-v3-meta")
-set_target_properties(range-v3::concepts PROPERTIES INTERFACE_LINK_LIBRARIES "range-v3-concepts")
-set_target_properties(range-v3::range-v3 PROPERTIES INTERFACE_LINK_LIBRARIES "range-v3")
-else()
-target_link_libraries(range-v3::meta INTERFACE range-v3-meta)
-target_link_libraries(range-v3::concepts INTERFACE range-v3-concepts)
-target_link_libraries(range-v3::range-v3 INTERFACE range-v3)
-endif()
diff --git a/src/contrib/range-v3-0.11.0/cmake/ranges_diagnostics.cmake b/src/contrib/range-v3-0.11.0/cmake/ranges_diagnostics.cmake
deleted file mode 100644
index 6a85bfeb..00000000
--- a/src/contrib/range-v3-0.11.0/cmake/ranges_diagnostics.cmake
+++ /dev/null
@@ -1,46 +0,0 @@
-# Copyright Louis Dionne 2015
-# Copyright Gonzalo Brito Gadeschi 2015
-# Distributed under the Boost Software License, Version 1.0.
-# (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-#
-# Setup compiler flags (more can be set on a per-target basis or in
-# subdirectories)
-
-# Enable all warnings:
-ranges_append_flag(RANGES_HAS_WEVERYTHING -Weverything)
-ranges_append_flag(RANGES_HAS_PEDANTIC -pedantic)
-ranges_append_flag(RANGES_HAS_PEDANTIC_ERRORS -pedantic-errors)
-
-# Selectively disable those warnings that are not worth it:
-ranges_append_flag(RANGES_HAS_WNO_CXX98_COMPAT -Wno-c++98-compat)
-ranges_append_flag(RANGES_HAS_WNO_CXX98_COMPAT_PEDANTIC -Wno-c++98-compat-pedantic)
-ranges_append_flag(RANGES_HAS_WNO_WEAK_VTABLES -Wno-weak-vtables)
-ranges_append_flag(RANGES_HAS_WNO_PADDED -Wno-padded)
-ranges_append_flag(RANGES_HAS_WNO_MISSING_VARIABLE_DECLARATIONS -Wno-missing-variable-declarations)
-ranges_append_flag(RANGES_HAS_WNO_DOCUMENTATION -Wno-documentation)
-ranges_append_flag(RANGES_HAS_WNO_DOCUMENTATION_UNKNOWN_COMMAND -Wno-documentation-unknown-command)
-ranges_append_flag(RANGES_HAS_WNO_OLD_STYLE_CAST -Wno-old-style-cast)
-
-if (RANGES_ENV_MACOSX)
-  ranges_append_flag(RANGES_HAS_WNO_GLOBAL_CONSTRUCTORS -Wno-global-constructors)
-  ranges_append_flag(RANGES_HAS_WNO_EXIT_TIME_DESTRUCTORS -Wno-exit-time-destructors)
-endif()
-
-if (RANGES_CXX_COMPILER_CLANG OR RANGES_CXX_COMPILER_CLANGCL)
-  ranges_append_flag(RANGES_HAS_WNO_MISSING_PROTOTYPES -Wno-missing-prototypes)
-endif()
-
-if (RANGES_CXX_COMPILER_GCC)
-  if (CMAKE_CXX_COMPILER_VERSION VERSION_LESS "6.0")
-    ranges_append_flag(RANGES_HAS_WNO_STRICT_OVERFLOW -Wno-strict-overflow)
-    if (CMAKE_CXX_COMPILER_VERSION VERSION_LESS "5.0")
-      ranges_append_flag(RANGES_HAS_WNO_MISSING_FIELD_INITIALIZERS -Wno-missing-field-initializers)
-    endif()
-  elseif ((CMAKE_CXX_COMPILER_VERSION VERSION_GREATER "7.0") OR (CMAKE_CXX_COMPILER_VERSION VERSION_EQUAL "7.0"))
-    ranges_append_flag(RANGES_HAS_WNO_NOEXCEPT_TYPE -Wno-noexcept-type)
-  endif()
-endif()
-
-if (RANGES_VERBOSE_BUILD)
-  message(STATUS "[range-v3]: test C++ flags: ${CMAKE_CXX_FLAGS}")
-endif()
diff --git a/src/contrib/range-v3-0.11.0/cmake/ranges_env.cmake b/src/contrib/range-v3-0.11.0/cmake/ranges_env.cmake
deleted file mode 100644
index 6d808ca5..00000000
--- a/src/contrib/range-v3-0.11.0/cmake/ranges_env.cmake
+++ /dev/null
@@ -1,96 +0,0 @@
-# Copyright Gonzalo Brito Gadeschi 2015
-# Distributed under the Boost Software License, Version 1.0.
-# (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-#
-# Detects the C++ compiler, system, build-type, etc.
-include(CheckCXXCompilerFlag)
-
-if("x${CMAKE_CXX_COMPILER_ID}" MATCHES "x.*Clang")
-  if("x${CMAKE_CXX_SIMULATE_ID}" STREQUAL "xMSVC")
-    set (RANGES_CXX_COMPILER_CLANGCL TRUE)
-    if (RANGES_VERBOSE_BUILD)
-      message(STATUS "[range-v3]: compiler is clang-cl.")
-    endif()
-  else()
-    set (RANGES_CXX_COMPILER_CLANG TRUE)
-    if (RANGES_VERBOSE_BUILD)
-      message(STATUS "[range-v3]: compiler is clang.")
-    endif()
-  endif()
-elseif(CMAKE_COMPILER_IS_GNUCXX)
-  set (RANGES_CXX_COMPILER_GCC TRUE)
-  if (RANGES_VERBOSE_BUILD)
-    message(STATUS "[range-v3]: compiler is gcc.")
-  endif()
-elseif("x${CMAKE_CXX_COMPILER_ID}" STREQUAL "xMSVC")
-  set (RANGES_CXX_COMPILER_MSVC TRUE)
-  if (RANGES_VERBOSE_BUILD)
-    message(STATUS "[range-v3]: compiler is msvc.")
-  endif()
-else()
-  message(WARNING "[range-v3 warning]: unknown compiler ${CMAKE_CXX_COMPILER_ID} !")
-endif()
-
-if(CMAKE_SYSTEM_NAME MATCHES "Darwin")
-  set (RANGES_ENV_MACOSX TRUE)
-  if (RANGES_VERBOSE_BUILD)
-    message(STATUS "[range-v3]: system is MacOSX.")
-  endif()
-elseif(CMAKE_SYSTEM_NAME MATCHES "Linux")
-  set (RANGES_ENV_LINUX TRUE)
-  if (RANGES_VERBOSE_BUILD)
-    message(STATUS "[range-v3]: system is Linux.")
-  endif()
-elseif(CMAKE_SYSTEM_NAME MATCHES "Windows")
-  set (RANGES_ENV_WINDOWS TRUE)
-  if (RANGES_VERBOSE_BUILD)
-    message(STATUS "[range-v3]: system is Windows.")
-  endif()
-else()
-  message(WARNING "[range-v3 warning]: unknown system ${CMAKE_SYSTEM_NAME} !")
-endif()
-
-if(RANGES_CXX_STD MATCHES "^[0-9]+$")
-  if(RANGES_CXX_COMPILER_MSVC AND RANGES_CXX_STD LESS 17)
-    # MSVC is currently supported only in 17+ mode
-    set(RANGES_CXX_STD 17)
-  elseif(RANGES_CXX_STD LESS 14)
-    set(RANGES_CXX_STD 14)
-  endif()
-endif()
-
-# Build type
-set(RANGES_DEBUG_BUILD FALSE)
-set(RANGES_RELEASE_BUILD FALSE)
-
-if (CMAKE_BUILD_TYPE STREQUAL "Debug")
-  set(RANGES_DEBUG_BUILD TRUE)
-  if (RANGES_VERBOSE_BUILD)
-    message(STATUS "[range-v3]: build type is debug.")
-  endif()
-elseif(CMAKE_BUILD_TYPE STREQUAL "Release")
-  set(RANGES_RELEASE_BUILD TRUE)
-  if (RANGES_VERBOSE_BUILD)
-    message(STATUS "[range-v3]: build type is release.")
-  endif()
-else()
-  message(WARNING "[range-v3 warning]: unknown build type, defaults to release!")
-  set(CMAKE_BUILD_TYPE "Release")
-  set(RANGES_RELEASE_BUILD TRUE)
-endif()
-
-# Find Valgrind
-find_program(MEMORYCHECK_COMMAND valgrind)
-if(MEMORYCHECK_COMMAND)
-  set(MEMORYCHECK_COMMAND_OPTIONS "--trace-children=yes --leak-check=full")
-  if (RANGES_VERBOSE_BUILD)
-    message(STATUS "[range-v3]: valgrind found at path: ${MEMORYCHECK_COMMAND}")
-  endif()
-else()
-  if (RANGES_VERBOSE_BUILD)
-    message(WARNING "[range-v3 warning]: valgrind not found!")
-  endif()
-endif()
-
-find_package(Doxygen)
-find_package(Git)
diff --git a/src/contrib/range-v3-0.11.0/cmake/ranges_flags.cmake b/src/contrib/range-v3-0.11.0/cmake/ranges_flags.cmake
deleted file mode 100644
index e3a20aac..00000000
--- a/src/contrib/range-v3-0.11.0/cmake/ranges_flags.cmake
+++ /dev/null
@@ -1,298 +0,0 @@
-# Copyright Louis Dionne 2015
-# Copyright Gonzalo Brito Gadeschi 2015
-# Distributed under the Boost Software License, Version 1.0.
-# (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-#
-# Setup compiler flags (more can be set on a per-target basis or in
-# subdirectories)
-
-# Compilation flags
-include(CheckCXXCompilerFlag)
-macro(ranges_append_flag testname flag)
-  # As -Wno-* flags do not lead to build failure when there are no other
-  # diagnostics, we check positive option to determine their applicability.
-  # Of course, we set the original flag that is requested in the parameters.
-  string(REGEX REPLACE "^-Wno-" "-W" alt ${flag})
-  check_cxx_compiler_flag(${alt} ${testname})
-  if (${testname})
-    add_compile_options(${flag})
-  endif()
-endmacro()
-
-function(cxx_standard_normalize cxx_standard return_value)
-  if("x${cxx_standard}" STREQUAL "x1y")
-    set( ${return_value} "14" PARENT_SCOPE )
-  elseif("x${cxx_standard}" STREQUAL "x1z")
-    set( ${return_value} "17" PARENT_SCOPE )
-  elseif("x${cxx_standard}" STREQUAL "xlatest" OR "x${cxx_standard}" STREQUAL "x2a")
-    set( ${return_value} "20" PARENT_SCOPE )
-  else()
-    set( ${return_value} "${cxx_standard}" PARENT_SCOPE )
-  endif()
-endfunction()
-
-function(cxx_standard_denormalize cxx_standard return_value)
-  if("x${cxx_standard}" STREQUAL "x17")
-    if (RANGES_CXX_COMPILER_CLANGCL OR RANGES_CXX_COMPILER_MSVC)
-      set( ${return_value} 17 PARENT_SCOPE )
-    else()
-      set( ${return_value} 1z PARENT_SCOPE )
-    endif()
-  elseif("x${cxx_standard}" STREQUAL "x20")
-    if (RANGES_CXX_COMPILER_CLANGCL OR RANGES_CXX_COMPILER_MSVC)
-      set( ${return_value} latest PARENT_SCOPE )
-    else()
-      set( ${return_value} 2a PARENT_SCOPE )
-    endif()
-  else()
-    set( ${return_value} ${cxx_standard} PARENT_SCOPE )
-  endif()
-endfunction()
-
-if(CMAKE_CXX_STANDARD)
-  if(NOT "x${RANGES_CXX_STD}" STREQUAL "xdefault")
-    # Normalize RANGES_CXX_STD
-    cxx_standard_normalize( ${RANGES_CXX_STD} ranges_cxx_std )
-    if(NOT "x${ranges_cxx_std}" STREQUAL "x${CMAKE_CXX_STANDARD}")
-      message(FATAL_ERROR "[range-v3]: Cannot specify both CMAKE_CXX_STANDARD and RANGES_CXX_STD, or they must match.")
-    endif()
-  else()
-    cxx_standard_denormalize(${CMAKE_CXX_STANDARD} RANGES_CXX_STD)
-  endif()
-elseif("x${RANGES_CXX_STD}" STREQUAL "xdefault")
-  if (RANGES_CXX_COMPILER_CLANGCL OR RANGES_CXX_COMPILER_MSVC)
-    set(RANGES_CXX_STD 17)
-  else()
-    set(RANGES_CXX_STD 14)
-  endif()
-endif()
-
-# All compilation flags
-# Language flag: version of the C++ standard to use
-message(STATUS "[range-v3]: C++ std=${RANGES_CXX_STD}")
-if (RANGES_CXX_COMPILER_CLANGCL OR RANGES_CXX_COMPILER_MSVC)
-  ranges_append_flag(RANGES_HAS_CXXSTDCOLON "/std:c++${RANGES_CXX_STD}")
-  set(RANGES_STD_FLAG "/std:c++${RANGES_CXX_STD}")
-  if (RANGES_CXX_COMPILER_CLANGCL)
-    # The MSVC STL before VS 2019v16.6 with Clang 10 requires -fms-compatibility in C++17 mode, and
-    # doesn't support C++20 mode at all. Let's drop this flag until AppVeyor updates to VS2016v16.6.
-    # ranges_append_flag(RANGES_HAS_FNO_MS_COMPATIBIILITY "-fno-ms-compatibility")
-    ranges_append_flag(RANGES_HAS_FNO_DELAYED_TEMPLATE_PARSING "-fno-delayed-template-parsing")
-  endif()
-  # Enable "normal" warnings and make them errors:
-  ranges_append_flag(RANGES_HAS_W3 /W3)
-  ranges_append_flag(RANGES_HAS_WX /WX)
-else()
-  ranges_append_flag(RANGES_HAS_CXXSTD "-std=c++${RANGES_CXX_STD}")
-  set(RANGES_STD_FLAG "-std=c++${RANGES_CXX_STD}")
-  # Enable "normal" warnings and make them errors:
-  ranges_append_flag(RANGES_HAS_WALL -Wall)
-  ranges_append_flag(RANGES_HAS_WEXTRA -Wextra)
-  ranges_append_flag(RANGES_HAS_WERROR -Werror)
-endif()
-
-if (RANGES_ENV_LINUX AND RANGES_CXX_COMPILER_CLANG)
-  # On linux libc++ re-exports the system math headers. The ones from libstdc++
-  # use the GCC __extern_always_inline intrinsic which is not supported by clang
-  # versions 3.6, 3.7, 3.8, 3.9, 4.0, and current trunk 5.0 (as of 2017.04.13).
-  #
-  # This works around it by replacing __extern_always_inline with inline using a
-  # macro:
-  ranges_append_flag(RANGES_HAS_D__EXTERN_ALWAYS_INLINE -D__extern_always_inline=inline)
-endif()
-
-# Deep integration support
-if (RANGES_DEEP_STL_INTEGRATION)
-  if (RANGES_CXX_COMPILER_MSVC)
-    add_compile_options(/I "${PROJECT_SOURCE_DIR}/include/std")
-    add_compile_options(/I "${PROJECT_SOURCE_DIR}/include")
-  else()
-    add_compile_options(-isystem "${PROJECT_SOURCE_DIR}/include/std")
-    add_compile_options(-I "${PROJECT_SOURCE_DIR}/include")
-  endif()
-  add_compile_options(-DRANGES_DEEP_STL_INTEGRATION=1)
-endif()
-
-# Template diagnostic flags
-ranges_append_flag(RANGES_HAS_FDIAGNOSTIC_SHOW_TEMPLATE_TREE -fdiagnostics-show-template-tree)
-ranges_append_flag(RANGES_HAS_FTEMPLATE_BACKTRACE_LIMIT "-ftemplate-backtrace-limit=0")
-ranges_append_flag(RANGES_HAS_FMACRO_BACKTRACE_LIMIT "-fmacro-backtrace-limit=1")
-
-# Clang modules support
-if (RANGES_MODULES)
-  ranges_append_flag(RANGES_HAS_MODULES -fmodules)
-  ranges_append_flag(RANGES_HAS_MODULE_MAP_FILE "-fmodule-map-file=${PROJECT_SOURCE_DIR}/include/module.modulemap")
-  ranges_append_flag(RANGES_HAS_MODULE_CACHE_PATH "-fmodules-cache-path=${PROJECT_BINARY_DIR}/module.cache")
-  if (RANGES_LIBCXX_MODULE)
-    ranges_append_flag(RANGES_HAS_LIBCXX_MODULE_MAP_FILE "-fmodule-map-file=${RANGES_LIBCXX_MODULE}")
-  endif()
-  if (RANGES_ENV_MACOSX)
-    ranges_append_flag(RANGES_HAS_NO_IMPLICIT_MODULE_MAPS -fno-implicit-module-maps)
-  endif()
-  if (RANGES_DEBUG_BUILD)
-    ranges_append_flag(RANGES_HAS_GMODULES -gmodules)
-  endif()
-endif()
-
-# Sanitizer support: detect incompatible sanitizer combinations
-if (RANGES_ASAN AND RANGES_MSAN)
-  message(FATAL_ERROR "[range-v3 error]: AddressSanitizer and MemorySanitizer are both enabled at the same time!")
-endif()
-
-if (RANGES_MSAN AND RANGES_ENV_MACOSX)
-  message(FATAL_ERROR "[range-v3 error]: MemorySanitizer is not supported on MacOSX!")
-endif()
-
-# AddressSanitizer support
-if (RANGES_ASAN)
-  # This policy enables passing the linker flags to the linker when trying to
-  # test the features, which is required to successfully link ASan binaries
-  cmake_policy(SET CMP0056 NEW)
-  set (ASAN_FLAGS "")
-  if (RANGES_ENV_MACOSX) # LeakSanitizer not supported on MacOSX
-    set (ASAN_FLAGS "-fsanitize=address,signed-integer-overflow,shift,integer-divide-by-zero,implicit-signed-integer-truncation,implicit-integer-sign-change,undefined,nullability")
-  else()
-    if (RANGES_CXX_COMPILER_CLANG AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS "4.0")
-      set (ASAN_FLAGS "-fsanitize=address")
-    else()
-      set (ASAN_FLAGS "-fsanitize=address,signed-integer-overflow,shift,integer-divide-by-zero,implicit-signed-integer-truncation,implicit-integer-sign-change,leak,nullability")
-    endif()
-  endif()
-  ranges_append_flag(RANGES_HAS_ASAN "${ASAN_FLAGS}")
-  if (RANGES_HAS_ASAN) #ASAN flags must be passed to the linker:
-    set(CMAKE_EXE_LINKER_FLAGS  "${CMAKE_EXE_LINKER_FLAGS} ${ASAN_FLAGS}")
-  endif()
-  ranges_append_flag(RANGES_HAS_SANITIZE_NO_RECOVER "-fno-sanitize-recover=all")
-  ranges_append_flag(RANGES_HAS_NO_OMIT_FRAME_POINTER -fno-omit-frame-pointer)
-endif()
-
-# MemorySanitizer support
-if (RANGES_MSAN)
-  # This policy enables passing the linker flags to the linker when trying to
-  # compile the examples, which is required to successfully link MSan binaries
-  cmake_policy(SET CMP0056 NEW)
-  ranges_append_flag(RANGES_HAS_MSAN "-fsanitize=memory")
-  ranges_append_flag(RANGES_HAS_MSAN_TRACK_ORIGINS -fsanitize-memory-track-origins)
-  ranges_append_flag(RANGES_HAS_SANITIZE_RECOVER_ALL "-fno-sanitize-recover=all")
-  ranges_append_flag(RANGES_HAS_NO_OMIT_FRAME_POINTER -fno-omit-frame-pointer)
-endif()
-
-# Build types:
-if (RANGES_DEBUG_BUILD AND RANGES_RELEASE_BUILD)
-  message(FATAL_ERROR "[range-v3 error] Cannot simultaneously generate debug and release builds!")
-endif()
-
-if (RANGES_DEBUG_BUILD)
-  ranges_append_flag(RANGES_HAS_NO_INLINE -fno-inline)
-  ranges_append_flag(RANGES_HAS_STACK_PROTECTOR_ALL -fstack-protector-all)
-  ranges_append_flag(RANGES_HAS_G3 -g3)
-  # Clang can generate debug info tuned for LLDB or GDB
-  if (RANGES_CXX_COMPILER_CLANG)
-    if (RANGES_ENV_MACOSX)
-      ranges_append_flag(RANGES_HAS_GLLDB -glldb)
-    elseif(RANGES_ENV_LINUX)
-      ranges_append_flag(RANGES_HAS_GGDB -ggdb)
-    endif()
-  endif()
-endif()
-
-if (RANGES_RELEASE_BUILD)
-  if (NOT RANGES_ASSERTIONS)
-    ranges_append_flag(RANGES_HAS_DNDEBUG -DNDEBUG)
-  endif()
-  if (NOT RANGES_ASAN AND NOT RANGES_MSAN)
-    # The quality of ASan and MSan error messages suffers if we disable the
-    # frame pointer, so leave it enabled when compiling with either of them:
-    ranges_append_flag(RANGES_HAS_OMIT_FRAME_POINTER -fomit-frame-pointer)
-  endif()
-
-  ranges_append_flag(RANGES_HAS_OFAST -Ofast)
-  if (NOT RANGES_HAS_OFAST)
-    ranges_append_flag(RANGES_HAS_O2 -O2)
-  endif()
-  ranges_append_flag(RANGES_HAS_STRICT_ALIASING -fstrict-aliasing)
-  ranges_append_flag(RANGES_HAS_STRICT_VTABLE_POINTERS -fstrict-vtable-pointers)
-  ranges_append_flag(RANGES_HAS_FAST_MATH -ffast-math)
-  ranges_append_flag(RANGES_HAS_VECTORIZE -fvectorize)
-
-  if (NOT RANGES_ENV_MACOSX)
-    # Sized deallocation is not available in MacOSX:
-    ranges_append_flag(RANGES_HAS_SIZED_DEALLOCATION -fsized-deallocation)
-  endif()
-
-  if (RANGES_LLVM_POLLY)
-    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -mllvm -polly -mllvm -polly-vectorizer=stripmine")
-  endif()
-
-  if (RANGES_CXX_COMPILER_CLANG AND (NOT (RANGES_INLINE_THRESHOLD EQUAL -1)))
-    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -mllvm -inline-threshold=${RANGES_INLINE_THRESHOLD}")
-  endif()
-endif()
-
-if (RANGES_NATIVE)
-  ranges_append_flag(RANGES_HAS_MARCH_NATIVE "-march=native")
-  ranges_append_flag(RANGES_HAS_MTUNE_NATIVE "-mtune=native")
-endif()
-
-include(CheckCXXSourceCompiles)
-
-set(CMAKE_REQUIRED_FLAGS ${RANGES_STD_FLAG})
-# Probe for library and compiler support for aligned new
-file(READ "${CMAKE_CURRENT_SOURCE_DIR}/cmake/aligned_new_probe.cpp" RANGE_V3_PROBE_CODE)
-check_cxx_source_compiles("${RANGE_V3_PROBE_CODE}" RANGE_V3_ALIGNED_NEW_PROBE)
-unset(RANGE_V3_PROBE_CODE)
-unset(CMAKE_REQUIRED_FLAGS)
-if (NOT RANGE_V3_ALIGNED_NEW_PROBE)
-  add_compile_options("-DRANGES_CXX_ALIGNED_NEW=0")
-endif()
-
-# Probe for coroutine TS support
-file(READ "${CMAKE_CURRENT_SOURCE_DIR}/cmake/coro_test_code.cpp" RANGE_V3_PROBE_CODE)
-if(RANGES_CXX_COMPILER_MSVC)
-  set(CMAKE_REQUIRED_FLAGS "/await")
-  check_cxx_source_compiles("${RANGE_V3_PROBE_CODE}" RANGES_HAS_AWAIT)
-  if(RANGES_HAS_AWAIT)
-    set(RANGE_V3_COROUTINE_FLAGS "/await")
-  endif()
-elseif(RANGES_CXX_COMPILER_CLANG)
-  set(CMAKE_REQUIRED_FLAGS "-fcoroutines-ts ${RANGES_STD_FLAG}")
-  check_cxx_source_compiles("${RANGE_V3_PROBE_CODE}" RANGES_HAS_FCOROUTINES_TS)
-  if(RANGES_HAS_FCOROUTINES_TS)
-    set(RANGE_V3_COROUTINE_FLAGS "-fcoroutines-ts")
-  endif()
-endif()
-unset(CMAKE_REQUIRED_FLAGS)
-unset(RANGE_V3_PROBE_CODE)
-if (RANGE_V3_COROUTINE_FLAGS)
-  add_compile_options(${RANGE_V3_COROUTINE_FLAGS})
-endif()
-
-# Test for concepts support
-file(READ "${CMAKE_CURRENT_SOURCE_DIR}/cmake/concepts_test_code.cpp" RANGE_V3_PROBE_CODE)
-if(RANGES_CXX_COMPILER_GCC OR RANGES_CXX_COMPILER_CLANG)
-  set(CMAKE_REQUIRED_FLAGS "-fconcepts ${RANGES_STD_FLAG}")
-  check_cxx_source_compiles("${RANGE_V3_PROBE_CODE}" RANGE_V3_HAS_FCONCEPTS)
-  if(RANGE_V3_HAS_FCONCEPTS)
-    set(RANGE_V3_CONCEPTS_FLAGS "-fconcepts")
-  endif()
-endif()
-unset(CMAKE_REQUIRED_FLAGS)
-unset(RANGE_V3_PROBE_CODE)
-if (RANGE_V3_CONCEPTS_FLAGS AND RANGES_PREFER_REAL_CONCEPTS)
-  add_compile_options(${RANGE_V3_CONCEPTS_FLAGS})
-endif()
-
-if (RANGES_VERBOSE_BUILD)
-  message(STATUS "[range-v3]: C++ flags: ${CMAKE_CXX_FLAGS}")
-  message(STATUS "[range-v3]: C++ debug flags: ${CMAKE_CXX_FLAGS_DEBUG}")
-  message(STATUS "[range-v3]: C++ Release Flags: ${CMAKE_CXX_FLAGS_RELEASE}")
-  message(STATUS "[range-v3]: C++ Compile Flags: ${CMAKE_CXX_COMPILE_FLAGS}")
-  message(STATUS "[range-v3]: Compile options: ${COMPILE_OPTIONS_}")
-  message(STATUS "[range-v3]: C Flags: ${CMAKE_C_FLAGS}")
-  message(STATUS "[range-v3]: C Compile Flags: ${CMAKE_C_COMPILE_FLAGS}")
-  message(STATUS "[range-v3]: EXE Linker flags: ${CMAKE_EXE_LINKER_FLAGS}")
-  message(STATUS "[range-v3]: C++ Linker flags: ${CMAKE_CXX_LINK_FLAGS}")
-  message(STATUS "[range-v3]: MODULE Linker flags: ${CMAKE_MODULE_LINKER_FLAGS}")
-  get_directory_property(CMakeCompDirDefs COMPILE_DEFINITIONS)
-  message(STATUS "[range-v3]: Compile Definitions: ${CmakeCompDirDefs}")
-endif()
diff --git a/src/contrib/range-v3-0.11.0/cmake/ranges_options.cmake b/src/contrib/range-v3-0.11.0/cmake/ranges_options.cmake
deleted file mode 100644
index 4ec39c7f..00000000
--- a/src/contrib/range-v3-0.11.0/cmake/ranges_options.cmake
+++ /dev/null
@@ -1,56 +0,0 @@
-# Copyright Gonzalo Brito Gadeschi 2015
-# Distributed under the Boost Software License, Version 1.0.
-# (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-#
-# CMake options
-
-include(CMakeDependentOption)
-
-set(RANGES_CXX_STD default CACHE STRING "C++ standard version.")
-option(RANGES_BUILD_CALENDAR_EXAMPLE "Builds the calendar example." ON)
-option(RANGES_ASAN "Run the tests using AddressSanitizer." OFF)
-option(RANGES_MSAN "Run the tests using MemorySanitizer." OFF)
-option(RANGES_ASSERTIONS "Enable assertions." ON)
-option(RANGES_DEBUG_INFO "Include debug information in the binaries." ON)
-option(RANGES_MODULES "Enables use of Clang modules (experimental)." OFF)
-option(RANGES_NATIVE "Enables -march/-mtune=native." ON)
-option(RANGES_VERBOSE_BUILD "Enables debug output from CMake." OFF)
-option(RANGES_LLVM_POLLY "Enables LLVM Polly." OFF)
-option(RANGES_PREFER_REAL_CONCEPTS
-  "Use real concepts instead of emulation if the compiler supports it"
-  ON)
-option(RANGES_DEEP_STL_INTEGRATION
-  "Hijacks the primary std::iterator_traits template to emulate the C++20 std::ranges:: behavior."
-  OFF)
-option(RANGE_V3_HEADER_CHECKS
-  "Build the Range-v3 header checks and integrate with ctest"
-  OFF)
-set(RANGES_INLINE_THRESHOLD -1 CACHE STRING "Force a specific inlining threshold.")
-
-# Enable verbose configure when passing -Wdev to CMake
-if (DEFINED CMAKE_SUPPRESS_DEVELOPER_WARNINGS AND
-    NOT CMAKE_SUPPRESS_DEVELOPER_WARNINGS)
-  set(RANGES_VERBOSE_BUILD ON)
-endif()
-
-if (RANGES_VERBOSE_BUILD)
-  message(STATUS "[range-v3]: verbose build enabled.")
-endif()
-
-CMAKE_DEPENDENT_OPTION(RANGE_V3_TESTS
-  "Build the Range-v3 tests and integrate with ctest"
-  ON "${is_standalone}" OFF)
-
-CMAKE_DEPENDENT_OPTION(RANGE_V3_EXAMPLES
-  "Build the Range-v3 examples and integrate with ctest"
-  ON "${is_standalone}" OFF)
-
-option(RANGE_V3_PERF
-  "Build the Range-v3 performance benchmarks"
-  OFF)
-
-CMAKE_DEPENDENT_OPTION(RANGE_V3_DOCS
-  "Build the Range-v3 documentation"
-  ON "${is_standalone}" OFF)
-
-mark_as_advanced(RANGE_V3_PERF)
diff --git a/src/contrib/range-v3-0.11.0/cmake/readme.md b/src/contrib/range-v3-0.11.0/cmake/readme.md
deleted file mode 100644
index 76c74487..00000000
--- a/src/contrib/range-v3-0.11.0/cmake/readme.md
+++ /dev/null
@@ -1,5 +0,0 @@
-# CMake files overview:
-
-- `ranges_options.cmake`: All options to configure the library.
-- `ranges_env.cmake`: Detects the environment: operating system, compiler, build-type, ...
-- `ranges_flags.cmake`: Sets up all compiler flags.
diff --git a/src/contrib/range-v3-0.11.0/conanfile.py b/src/contrib/range-v3-0.11.0/conanfile.py
deleted file mode 100644
index d49d7da6..00000000
--- a/src/contrib/range-v3-0.11.0/conanfile.py
+++ /dev/null
@@ -1,35 +0,0 @@
-# Range v3 library
-#
-#  Copyright Luis Martinez de Bartolome Izquierdo 2016
-#
-#  Use, modification and distribution is subject to the
-#  Boost Software License, Version 1.0. (See accompanying
-#  file LICENSE_1_0.txt or copy at
-#  http://www.boost.org/LICENSE_1_0.txt)
-#
-# Project home: https://github.com/ericniebler/range-v3
-#
-
-from conans import ConanFile, CMake
-
-class Rangev3Conan(ConanFile):
-    name = "range-v3"
-    version = "0.10.0"
-    license = "Boost Software License - Version 1.0 - August 17th, 2003"
-    url = "https://github.com/ericniebler/range-v3"
-    description = """Experimental range library for C++11/14/17"""
-    # No settings/options are necessary, this is header only
-    exports_sources = "include*", "LICENSE.txt", "CMakeLists.txt", "cmake/*", "Version.cmake", "version.hpp.in"
-    no_copy_source = True
-
-    def package(self):
-        cmake = CMake(self)
-        cmake.definitions["RANGE_V3_TESTS"] = "OFF"
-        cmake.definitions["RANGE_V3_EXAMPLES"] = "OFF"
-        cmake.definitions["RANGE_V3_PERF"] = "OFF"
-        cmake.definitions["RANGE_V3_DOCS"] = "OFF"
-        cmake.definitions["RANGE_V3_HEADER_CHECKS"] = "OFF"
-        cmake.configure()
-        cmake.install()
-
-        self.copy("LICENSE.txt", dst="licenses", ignore_case=True, keep_path=False)
diff --git a/src/contrib/range-v3-0.11.0/doc/CMakeLists.txt b/src/contrib/range-v3-0.11.0/doc/CMakeLists.txt
deleted file mode 100644
index 68f94a7d..00000000
--- a/src/contrib/range-v3-0.11.0/doc/CMakeLists.txt
+++ /dev/null
@@ -1,88 +0,0 @@
-#=============================================================================
-# Setup the documentation
-#=============================================================================
-if (NOT DOXYGEN_FOUND)
-    message(STATUS
-    "Doxygen not found; the 'doc' and 'gh-pages.{clean,copy,update}' targets "
-    "will be unavailable.")
-    return()
-endif()
-
-set(CMAKE_FOLDER "doc")
-
-configure_file(Doxyfile.in Doxyfile @ONLY)
-configure_file(preprocess.sh.in preprocess.sh @ONLY)
-add_custom_target(doc.check
-    COMMAND ${DOXYGEN_EXECUTABLE} Doxyfile
-    COMMENT "Running Doxygen to validate the documentation"
-    VERBATIM
-)
-set_target_properties(doc.check
-    PROPERTIES FOLDER ${CMAKE_FOLDER}
-)
-
-# if (NOT TARGET benchmarks)
-#     message(STATUS
-#         "The 'benchmarks' target is not available; the 'doc' and "
-#         "'gh-pages.{clean,copy,update}' targets will be unavailable. "
-#         "The 'doc.check' target can still be used to generate the "
-#         "documentation to check for errors/warnings.")
-#     return()
-# endif()
-
-add_custom_target(doc
-    COMMAND ${DOXYGEN_EXECUTABLE} Doxyfile
-    COMMENT "Generating API documentation with Doxygen"
-#     DEPENDS benchmarks
-    VERBATIM
-)
-set_target_properties(doc
-    PROPERTIES FOLDER ${CMAKE_FOLDER}
-)
-
-if (NOT GIT_FOUND)
-    message(STATUS
-    "Git was not found; the 'gh-pages.{clean,copy,update}' targets "
-    "will be unavailable.")
-    return()
-endif()
-
-add_custom_target(gh-pages.clean
-    COMMAND ${CMAKE_COMMAND} -P ${CMAKE_CURRENT_LIST_DIR}/clean-gh-pages.cmake
-    COMMAND ${CMAKE_COMMAND} -E remove_directory search
-    WORKING_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}/gh-pages
-    COMMENT "Cleaning up doc/gh-pages"
-    VERBATIM
-)
-set_target_properties(gh-pages.clean
-    PROPERTIES FOLDER ${CMAKE_FOLDER}
-)
-
-add_custom_target(gh-pages.copy
-    COMMAND ${CMAKE_COMMAND} -E copy_directory ${CMAKE_CURRENT_BINARY_DIR}/html ${CMAKE_CURRENT_LIST_DIR}/gh-pages
-    WORKING_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}/gh-pages
-    COMMENT "Copying the documentation from ${CMAKE_CURRENT_BINARY_DIR}/html to doc/gh-pages"
-    DEPENDS doc gh-pages.clean
-    VERBATIM
-)
-set_target_properties(gh-pages.copy
-    PROPERTIES FOLDER ${CMAKE_FOLDER}
-)
-
-execute_process(
-    COMMAND ${GIT_EXECUTABLE} -C ${CMAKE_SOURCE_DIR} rev-parse --short HEAD
-    OUTPUT_VARIABLE RANGE_V3_GIT_SHORT_SHA
-    OUTPUT_STRIP_TRAILING_WHITESPACE
-)
-
-add_custom_target(gh-pages.update
-    COMMAND ${GIT_EXECUTABLE} add --all .
-    COMMAND ${GIT_EXECUTABLE} commit -m "Update to ${RANGE_V3_GIT_SHORT_SHA}"
-    WORKING_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}/gh-pages
-    COMMENT "Updating the gh-pages branch with freshly built documentation"
-    DEPENDS gh-pages.copy
-    VERBATIM
-)
-set_target_properties(gh-pages.update
-    PROPERTIES FOLDER ${CMAKE_FOLDER}
-)
diff --git a/src/contrib/range-v3-0.11.0/doc/Doxyfile.in b/src/contrib/range-v3-0.11.0/doc/Doxyfile.in
deleted file mode 100644
index cdd446b3..00000000
--- a/src/contrib/range-v3-0.11.0/doc/Doxyfile.in
+++ /dev/null
@@ -1,174 +0,0 @@
-PROJECT_NAME            = "Range-v3"
-PROJECT_BRIEF           = "Range algorithms, views, and actions for the Standard Library"
-PROJECT_LOGO            =
-PROJECT_NUMBER          =
-
-STRIP_FROM_PATH         = @Range-v3_SOURCE_DIR@/include @Range-v3_SOURCE_DIR@/doc
-BUILTIN_STL_SUPPORT     = YES
-STRIP_FROM_INC_PATH     = @Range-v3_SOURCE_DIR@/include
-ALIASES                 =
-ENABLED_SECTIONS        =
-
-
-# Resources
-OUTPUT_DIRECTORY        =
-INPUT                   = @Range-v3_SOURCE_DIR@/include \
-                          @Range-v3_SOURCE_DIR@/doc/index.md \
-                          @Range-v3_SOURCE_DIR@/doc/examples.md \
-                          @Range-v3_SOURCE_DIR@/doc/release_notes.md
-FILE_PATTERNS           = *.hpp *.md
-RECURSIVE               = YES
-EXCLUDE                 = @Range-v3_SOURCE_DIR@/include/range/v3/detail \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/algorithm/aux_ \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/algorithm/tagspec.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/at.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/back.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/begin_end.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/data.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/distance.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/empty.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/front.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/getlines.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/index.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/istream_range.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/iterator_range.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/range_access.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/range_concepts.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/range_traits.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/size.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/span.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/to_container.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/to_container.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/utility/associated_types.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/utility/basic_iterator.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/utility/common_iterator.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/utility/concepts.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/utility/counted_iterator.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/utility/dangling.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/utility/functional.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/utility/infinity.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/utility/invoke.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/utility/iterator_concepts.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/utility/iterator_traits.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/utility/iterator.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/utility/nullptr_v.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/utility/semiregular.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/utility/tagged_pair.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/utility/tagged_tuple.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/utility/unreachable.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/utility/view_adaptor.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/view_adaptor.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/view_facade.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/view_interface.hpp \
-                          @Range-v3_SOURCE_DIR@/include/range/v3/view/bounded.hpp
-EXAMPLE_PATH            = @Range-v3_SOURCE_DIR@/example \
-                          @Range-v3_SOURCE_DIR@/test
-EXAMPLE_RECURSIVE       = YES
-IMAGE_PATH              = @Range-v3_BINARY_DIR@/image
-FILTER_PATTERNS         = *.hpp="\"@Range-v3_BINARY_DIR@/doc/preprocess.sh\""
-WARN_IF_UNDOCUMENTED    = NO
-
-SHOW_GROUPED_MEMB_INC   = YES
-BRIEF_MEMBER_DESC       = YES
-REPEAT_BRIEF            = YES
-ALWAYS_DETAILED_SEC     = NO
-INLINE_INHERITED_MEMB   = NO
-JAVADOC_AUTOBRIEF       = YES
-QT_AUTOBRIEF            = YES
-MULTILINE_CPP_IS_BRIEF  = YES
-INHERIT_DOCS            = NO
-SEPARATE_MEMBER_PAGES   = NO
-DISTRIBUTE_GROUP_DOC    = NO
-SUBGROUPING             = NO
-INLINE_GROUPED_CLASSES  = NO
-INLINE_SIMPLE_STRUCTS   = NO
-
-# Generated formats
-GENERATE_HTML           = YES
-GENERATE_LATEX          = NO
-
-GENERATE_TODOLIST       = YES
-GENERATE_TESTLIST       = YES
-GENERATE_BUGLIST        = YES
-GENERATE_DEPRECATEDLIST = YES
-SHOW_USED_FILES         = NO
-SHOW_FILES              = YES
-SHOW_NAMESPACES         = YES
-LAYOUT_FILE             = @Range-v3_SOURCE_DIR@/doc/layout.xml
-
-
-CLASS_DIAGRAMS          = YES
-HAVE_DOT                = NO
-
-HIDE_UNDOC_RELATIONS    = NO
-HIDE_UNDOC_MEMBERS      = NO
-HIDE_UNDOC_CLASSES      = NO
-HIDE_FRIEND_COMPOUNDS   = NO
-HIDE_IN_BODY_DOCS       = NO
-INTERNAL_DOCS           = NO
-HIDE_SCOPE_NAMES        = NO
-SHOW_INCLUDE_FILES      = NO
-FORCE_LOCAL_INCLUDES    = NO
-INLINE_INFO             = NO
-SORT_MEMBER_DOCS        = YES
-SORT_BRIEF_DOCS         = YES
-SORT_MEMBERS_CTORS_1ST  = NO
-SORT_GROUP_NAMES        = NO
-SORT_BY_SCOPE_NAME      = YES
-
-
-ALPHABETICAL_INDEX      = NO
-COLS_IN_ALPHA_INDEX     = 1
-
-# Preprocessing
-ENABLE_PREPROCESSING    = YES
-MACRO_EXPANSION         = YES
-EXPAND_ONLY_PREDEF      = NO
-SEARCH_INCLUDES         = YES
-INCLUDE_PATH            = @Range-v3_SOURCE_DIR@/include
-INCLUDE_FILE_PATTERNS   =
-PREDEFINED              = RANGES_DOXYGEN_INVOKED=1 \
-                          META_DOXYGEN_INVOKED=1 \
-                          CPP_DOXYGEN_INVOKED=1 \
-                          "RANGES_INLINE_VARIABLE(T,N)=inline constexpr T N{};"
-SKIP_FUNCTION_MACROS    = NO
-
-# Source browsing
-SOURCE_BROWSER          = NO
-INLINE_SOURCES          = NO
-STRIP_CODE_COMMENTS     = YES
-REFERENCED_BY_RELATION  = YES
-REFERENCES_RELATION     = YES
-REFERENCES_LINK_SOURCE  = YES
-USE_HTAGS               = NO
-VERBATIM_HEADERS        = NO
-# CLANG_ASSISTED_PARSING  = NO
-# CLANG_OPTIONS           =
-
-# HTML output
-HTML_OUTPUT             = html
-HTML_FILE_EXTENSION     = .html
-HTML_HEADER             =
-HTML_FOOTER             =
-HTML_EXTRA_STYLESHEET   =
-HTML_EXTRA_FILES        =
-HTML_COLORSTYLE_HUE     = 75  # 0 - 359
-HTML_COLORSTYLE_SAT     = 100 # 0 - 255
-HTML_COLORSTYLE_GAMMA   = 80
-HTML_TIMESTAMP          = NO
-HTML_DYNAMIC_SECTIONS   = YES
-HTML_INDEX_NUM_ENTRIES  = 0 # Fully expand trees in the Indexes by default
-DISABLE_INDEX           = YES
-GENERATE_TREEVIEW       = YES
-TREEVIEW_WIDTH          = 270
-EXT_LINKS_IN_WINDOW     = NO
-FORMULA_FONTSIZE        = 10
-FORMULA_TRANSPARENT     = YES
-SEARCHENGINE            = YES
-
-# Mathjax (HTML only)
-USE_MATHJAX             = NO
-MATHJAX_FORMAT          = HTML-CSS
-MATHJAX_RELPATH         = http://cdn.mathjax.org/mathjax/latest
-MATHJAX_EXTENSIONS      =
-MATHJAX_CODEFILE        =
diff --git a/src/contrib/range-v3-0.11.0/doc/clean-gh-pages.cmake b/src/contrib/range-v3-0.11.0/doc/clean-gh-pages.cmake
deleted file mode 100644
index 8fb22f48..00000000
--- a/src/contrib/range-v3-0.11.0/doc/clean-gh-pages.cmake
+++ /dev/null
@@ -1,4 +0,0 @@
-FILE(GLOB gh_files "*.html" "*.js" "*.css" "*.png")
-IF( gh_files )
-    execute_process( COMMAND ${CMAKE_COMMAND} -E remove ${gh_files} )
-ENDIF()
diff --git a/src/contrib/range-v3-0.11.0/doc/examples.md b/src/contrib/range-v3-0.11.0/doc/examples.md
deleted file mode 100644
index 29ba0547..00000000
--- a/src/contrib/range-v3-0.11.0/doc/examples.md
+++ /dev/null
@@ -1,62 +0,0 @@
-Examples
-========
-
-\section example-algorithms Examples: Algorithms
-
-\subsection example-hello Hello, Ranges!
-
-\snippet hello.cpp hello
-
-\subsection example-any-all-none any_of, all_of, none_of
-
-\snippet any_all_none_of.cpp any_all_none_of
-
-\subsection example-count count
-
-\snippet count.cpp count
-
-\subsection example-count_if count_if
-
-\snippet count_if.cpp count_if
-
-\subsection example-find find, find_if, find_if_not on sequence containers
-
-\snippet find.cpp find
-
-\subsection example-for_each-seq for_each on sequence containers
-
-\snippet for_each_sequence.cpp for_each_sequence
-
-\subsection example-for_each-assoc for_each on associative containers
-
-\snippet for_each_assoc.cpp for_each_assoc
-
-\subsection example-is_sorted is_sorted
-
-\snippet is_sorted.cpp is_sorted
-
-\section example-views Examples: Views
-
-\subsection example-filter-transform Filter and transform
-
-\snippet filter_transform.cpp filter_transform
-
-\subsection example-accumulate-ints Generate ints and accumulate
-
-\snippet accumulate_ints.cpp accumulate_ints
-
-\subsection example-comprehension-conversion Convert a range comprehension to a vector
-
-\snippet comprehension_conversion.cpp comprehension_conversion
-
-\section example-actions Examples: Actions
-
-\subsection example-sort-unique Remove non-unique elements from a container
-
-\snippet sort_unique.cpp sort_unique
-
-\section example-gestalt Examples: Putting it all together
-
-\subsection example-calendar Calendar
-
-\snippet calendar.cpp calendar
diff --git a/src/contrib/range-v3-0.11.0/doc/ignore_errors.sh b/src/contrib/range-v3-0.11.0/doc/ignore_errors.sh
deleted file mode 100755
index a9441917..00000000
--- a/src/contrib/range-v3-0.11.0/doc/ignore_errors.sh
+++ /dev/null
@@ -1,3 +0,0 @@
-#!/bin/bash
-$* 2>/dev/null
-exit 0
diff --git a/src/contrib/range-v3-0.11.0/doc/index.md b/src/contrib/range-v3-0.11.0/doc/index.md
deleted file mode 100644
index dbc94edb..00000000
--- a/src/contrib/range-v3-0.11.0/doc/index.md
+++ /dev/null
@@ -1,954 +0,0 @@
-User Manual       {#mainpage}
-===========
-
-\tableofcontents
-
-\section tutorial-preface Preface
-
---------------------------------------------
-Range library for C++14/17/20. This code is the basis of [the range support in C++20](http://eel.is/c++draft/#ranges).
-
-**Development Status:**
-
-This code is fairly stable, well-tested, and suitable for casual use, although
-currently lacking documentation. No promise is made about support or long-term
-stability. This code *will* evolve without regard to backwards compatibility.
-
-A notable exception is anything found within the `ranges::cpp20` namespace.
-Those components will change rarely or (preferably) never at all.
-
-\subsection tutorial-installation Installation
-
---------------------------------------------
-This library is header-only. You can get the source code from the
-[range-v3 repository](https://github.com/ericniebler/range-v3) on github. To
-compile with Range-v3, just `#include` the individual headers you want.
-
-This distribution actually contains three separate header-only libraries:
-
-* <strong><tt>include/concepts/...</tt></strong> contains the Concepts Portability Preprocessor, or
-  CPP, which is a set of macros for defining and using concept checks,
-  regardless of whether your compiler happens to support the C++20 concepts
-  language feature or not.
-* <strong><tt>include/meta/...</tt></strong> contains the Meta Library, which is a set of
-  meta-programming utilities for processing types and lists of types at compile
-  time.
-* <strong><tt>include/range/...</tt></strong> contains the Range-v3 library, as described below.
-
-The Range-v3 library is physically structured in directories by feature group:
-
-* <strong><tt>include/range/v3/actions/...</tt></strong> contains _actions_, or composable
-  components that operate eagerly on containers and return the mutated container
-  for further actions.
-* <strong><tt>include/range/v3/algorithms/...</tt></strong> contains all the STL _algorithms_ with
-  overloads that accept ranges, in addition to the familiar overloads that take iterators.
-* <strong><tt>include/range/v3/functional/...</tt></strong> contains many generally useful
-  components that would be familiar to functional programmers.
-* <strong><tt>include/range/v3/iterator/...</tt></strong> contains the definitions of many useful
-  iterators and iterator-related concepts and utilities.
-* <strong><tt>include/range/v3/numeric/...</tt></strong> contains numeric algorithms corresponding
-  to those found in the standard `<numeric>` header.
-* <strong><tt>include/range/v3/range/...</tt></strong> contains range-related utilities, such as
-  `begin`, `end`, and `size`, range traits and concepts, and conversions to
-  containers.
-* <strong><tt>include/range/v3/utility/...</tt></strong> contains a miscellaneous assortment of
-  reusable code.
-* <strong><tt>include/range/v3/view/...</tt></strong> contains _views_, or composable
-  components that operate lazily on ranges and that themselves return ranges
-  that can be operated upon with additional view adaptors.
-
-\subsection tutorial-license License
-
---------------------------------------------
-Most of the source code in this project are mine, and those are under the Boost
-Software License. Parts are taken from Alex Stepanov's Elements of Programming,
-Howard Hinnant's libc++, and from the SGI STL. Please see the attached LICENSE
-file and the CREDITS file for the licensing and acknowledgements.
-
-\subsection tutorial-compilers Supported Compilers
-
---------------------------------------------------------------------------------
-The code is known to work on the following compilers:
-
-- clang 5.0
-- GCC 6.5
-- Clang/LLVM 6 (or later) on Windows
-- MSVC VS2019, with `/permissive-` and either `/std:c++latest` or `/std:c++17`
-
-\section tutorial-quick-start Quick Start
-
---------------------------------------------------------------------------------
-Range-v3 is a generic library that augments the existing standard library with
-facilities for working with *ranges*. A range can be loosely thought of a pair
-of iterators, although they need not be implemented that way. Bundling begin/end
-iterators into a single object brings several benefits: convenience,
-composability, and correctness.
-
-**Convenience**
-
-It's more convenient to pass a single range object to an algorithm than separate
-begin/end iterators. Compare:
-
-~~~~~~~{.cpp}
-    std::vector<int> v{/*...*/};
-    std::sort( v.begin(), v.end() );
-~~~~~~~
-
-with
-
-~~~~~~~{.cpp}
-    std::vector<int> v{/*...*/};
-    ranges::sort( v );
-~~~~~~~
-
-Range-v3 contains full implementations of all the standard algorithms with
-range-based overloads for convenience.
-
-**Composability**
-
-Having a single range object permits *pipelines* of operations. In a pipeline, a
-range is lazily adapted or eagerly mutated in some way, with the result
-immediately available for further adaptation or mutation. Lazy adaption is
-handled by *views*, and eager mutation is handled by *actions*.
-
-For instance, the below uses _views_ to filter a container using a predicate
-and transform the resulting range with a function. Note that the underlying
-data is `const` and is not mutated by the views.
-
-~~~~~~~{.cpp}
-    std::vector<int> const vi{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
-    using namespace ranges;
-    auto rng = vi | views::remove_if([](int i){ return i % 2 == 1; })
-                  | views::transform([](int i){ return std::to_string(i); });
-    // rng == {"2","4","6","8","10"};
-~~~~~~~
-
-In the code above, `rng` simply stores a reference to the underlying data and
-the filter and transformation functions. No work is done until `rng` is
-iterated.
-
-In contrast, _actions_ do their work eagerly, but they also compose. Consider
-the code below, which reads some data into a vector, sorts it, and makes it
-unique.
-
-~~~~~~~{.cpp}
-    extern std::vector<int> read_data();
-    using namespace ranges;
-    std::vector<int> vi = read_data() | actions::sort | actions::unique;
-~~~~~~~
-
-Unlike views, with actions each step in the pipeline (`actions::sort` and
-`actions::unique`) accepts a container _by value_, mutates it in place, and
-returns it.
-
-**Correctness**
-
-Whether you are using views or actions, you are operating on data in a pure
-functional, declarative style. You rarely need to trouble yourself with
-iterators, although they are there under the covers should you need them.
-
-By operating declaratively and functionally instead of imperatively, we reduce
-the need for overt state manipulation and branches and loops. This brings down
-the number of states your program can be in, which brings down your bug counts.
-
-In short, if you can find a way to express your solution as a composition of
-functional transformations on your data, you can make your code _correct by
-construction_.
-
-\subsection tutorial-views Views
-
---------------------------------------------------------------------------------
-As described above, the big advantage of ranges over iterators is their
-composability. They permit a functional style of programming where data is
-manipulated by passing it through a series of combinators. In addition, the
-combinators can be *lazy*, only doing work when the answer is requested, and
-*purely functional*, without mutating the original data. This makes it easier to
-reason about your code.
-
-A _view_ is a lightweight wrapper that presents a view of an underlying sequence
-of elements in some custom way without mutating or copying it. Views are cheap
-to create and copy and have non-owning reference semantics. Below are some
-examples that use views:
-
-Filter a container using a predicate and transform it.
-
-~~~~~~~{.cpp}
-    std::vector<int> const vi{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
-    using namespace ranges;
-    auto rng = vi | views::remove_if([](int i){return i % 2 == 1;})
-                  | views::transform([](int i){return std::to_string(i);});
-    // rng == {"2","4","6","8","10"};
-~~~~~~~
-
-Generate an infinite list of integers starting at 1, square them, take the first
-10, and sum them:
-
-~~~~~~~{.cpp}
-    using namespace ranges;
-    int sum = accumulate(views::ints(1)
-                       | views::transform([](int i){return i*i;})
-                       | views::take(10), 0);
-~~~~~~~
-
-Generate a sequence on the fly with a range comprehension and initialize a
-vector with it:
-
-~~~~~~~{.cpp}
-    using namespace ranges;
-    auto vi =
-        views::for_each(views::ints(1, 10), [](int i) {
-            return yield_from(views::repeat_n(i, i));
-        })
-      | to<std::vector>();
-    // vi == {1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,...}
-~~~~~~~
-
-### View const-ness
-
-Logically, a view is a factory for iterators, but in practice a view is often
-implemented as a state machine, with the state stored within the view object
-itself (to keep iterators small) and mutated as the view is iterated. Because
-the view contains mutable state, many views lack a `const`-qualified
-`begin()`/`end()`. When `const` versions of `begin()`/`end()` are provided, they
-are truly `const`; that is, thread-safe.
-
-Since views present the same interface as containers, the temptation is to think
-they behave like containers with regard to `const`-ness. This is not the case.
-Their behavior with regards to `const`-ness is similar to iterators and
-pointers.
-
-The `const`-ness of a view is not related to the `const`-ness of the underlying
-data. A non-`const` view may refer to elements that are themselves `const`, and
-_vice versa_. This is analogous to pointers; an `int* const` is a `const`
-pointer to a mutable `int`, and a `int const*` is a non-`const` pointer to a
-`const` `int`.
-
-Use non-`const` views whenever possible. If you need thread-safety, work with
-view copies in threads; don't share.
-
-### View validity
-
-Any operation on the underlying range that invalidates its iterators or
-sentinels will also invalidate any view that refers to any part of that range.
-Additionally, some views (_e.g._, `views::filter`), are invalidated when the
-underlying elements of the range are mutated. It is best to recreate a view
-after any operation that may have mutated the underlying range.
-
-### List of range views
-
-Below is a list of the lazy range combinators, or views, that Range-v3
-provides, and a blurb about how each is intended to be used.
-
-<DL>
-<DT>\link ranges::views::addressof_fn `views::addressof`\endlink</DT>
-  <DD>Given a source range of lvalue references, return a new view that is the result of taking `std::addressof` of each.</DD>
-<DT>\link ranges::views::adjacent_filter_fn `views::adjacent_filter`\endlink</DT>
-  <DD>For each pair of adjacent elements in a source range, evaluate the specified binary predicate. If the predicate evaluates to false, the second element of the pair is removed from the result range; otherwise, it is included. The first element in the source range is always included. (For instance, `adjacent_filter` with `std::not_equal_to` filters out all the non-unique elements.)</DD>
-<DT>\link ranges::views::adjacent_remove_if_fn `views::adjacent_remove_if`\endlink</DT>
-  <DD>For each pair of adjacent elements in a source range, evaluate the specified binary predicate. If the predicate evaluates to true, the first element of the pair is removed from the result range; otherwise, it is included. The last element in the source range is always included.</DD>
-<DT>\link ranges::views::all_fn `views::all`\endlink</DT>
-  <DD>Return a range containing all the elements in the source. Useful for converting containers to ranges.</DD>
-<DT>\link ranges::any_view `any_view<T>(rng)`\endlink</DT>
-  <DD>Type-erased range of elements with value type `T`; can store _any_ range with this value type.</DD>
-<DT>\link ranges::views::c_str_fn `views::c_str`\endlink</DT>
-  <DD>View a `\0`-terminated C string (e.g. from a `const char*`) as a range.</DD>
-<DT>\link ranges::views::cache1_fn `views::cache1`\endlink</DT>
-  <DD>Caches the most recent element within the view so that dereferencing the view's iterator multiple times doesn't incur any recomputation. This can be useful in adaptor pipelines that include combinations of `view::filter` and `view::transform`, for instance. `views::cache1` is always single-pass.</DD>
-<DT>\link ranges::views::cartesian_product_fn `views::cartesian_product`\endlink</DT>
-  <DD>Enumerates the n-ary cartesian product of `n` ranges, i.e., generates all `n`-tuples `(e1, e2, ... , en)` where `e1` is an element of the first range, `e2` is an element of the second range, etc.</DD>
-<DT>\link ranges::views::chunk_fn `views::chunk`\endlink</DT>
-  <DD>Given a source range and an integer *N*, produce a range of contiguous ranges where each inner range has *N* contiguous elements. The final range may have fewer than *N* elements.</DD>
-<DT>\link ranges::views::common_fn `views::common`\endlink</DT>
-  <DD>Convert the source range to a *common* range, where the type of the `end` is the same as the `begin`. Useful for calling algorithms in the `std::` namespace.</DD>
-<DT>\link ranges::views::concat_fn `views::concat`\endlink</DT>
-  <DD>Given *N* source ranges, produce a result range that is the concatenation of all of them.</DD>
-<DT>\link ranges::views::const_fn `views::const_`\endlink</DT>
-  <DD>Present a `const` view of a source range.</DD>
-<DT>\link ranges::views::counted_fn `views::counted`\endlink</DT>
-  <DD>Given an iterator `it` and a count `n`, create a range that starts at `it` and includes the next `n` elements.</DD>
-<DT>\link ranges::views::cycle_fn `views::cycle`\endlink</DT>
-  <DD>Returns an infinite range that endlessly repeats the source range.</DD>
-<DT>\link ranges::views::delimit_fn `views::delimit`\endlink</DT>
-  <DD>Given a source range and a value, return a new range that ends either at the end of the source or at the first occurrence of the value, whichever comes first. Alternatively, `views::delimit` can be called with an iterator and a value, in which case it returns a range that starts at the specified position and ends at the first occurrence of the value.</DD>
-<DT>\link ranges::views::drop_fn `views::drop`\endlink</DT>
-  <DD>Given a source range and an integral count, return a range consisting of all but the first *count* elements from the source range, or an empty range if it has fewer elements.</DD>
-<DT>\link ranges::views::drop_last_fn `views::drop_last`\endlink</DT>
-  <DD>Given a source range and an integral count, return a range consisting of all but the last *count* elements from the source range, or an empty range if it has fewer elements.</DD>
-<DT>\link ranges::views::drop_exactly_fn `views::drop_exactly`\endlink</DT>
-  <DD>Given a source range and an integral count, return a range consisting of all but the first *count* elements from the source range. The source range must have at least that many elements.</DD>
-<DT>\link ranges::views::drop_while_fn `views::drop_while`\endlink</DT>
-  <DD>Remove elements from the front of a range that satisfy a unary predicate.</DD>
-<DT>\link ranges::views::empty() `views::empty`\endlink</DT>
-  <DD>Create an empty range with a given value type.</DD>
-<DT>\link ranges::views::enumerate() `views::enumerate`\endlink</DT>
-  <DD>Pair each element of a range with its index.</DD>
-<DT>\link ranges::views::filter_fn `views::filter`\endlink</DT>
-  <DD>Given a source range and a unary predicate, filter the elements that satisfy the predicate. (For users of Boost.Range, this is like the `filter` adaptor.)</DD>
-<DT>\link ranges::views::for_each_fn `views::for_each`\endlink</DT>
-  <DD>Lazily applies an unary function to each element in the source range that returns another range (possibly empty), flattening the result.</DD>
-<DT>\link ranges::views::generate_fn `views::generate`\endlink</DT>
-  <DD>Given a nullary function, return an infinite range whose elements are generated with the function.</DD>
-<DT>\link ranges::views::generate_n_fn `views::generate_n`\endlink</DT>
-  <DD>Given a nullary function and a count, return a range that generates the requested number of elements by calling the function.</DD>
-<DT>\link ranges::views::group_by_fn `views::group_by`\endlink</DT>
-  <DD>Given a source range and a binary predicate, return a range of ranges where each range contains contiguous elements from the source range such that the following condition holds: for each element in the range apart from the first, when that element and the first element are passed to the binary predicate, the result is true. In essence, `views::group_by` *groups* contiguous elements together with a binary predicate.</DD>
-<DT>\link ranges::views::indirect_fn `views::indirect`\endlink</DT>
-  <DD>Given a source range of readable values (e.g. pointers or iterators), return a new view that is the result of dereferencing each.</DD>
-<DT>\link ranges::views::intersperse_fn `views::intersperse`\endlink</DT>
-  <DD>Given a source range and a value, return a new range where the value is inserted between contiguous elements from the source.</DD>
-<DT>\link ranges::views::ints_fn `views::ints`\endlink</DT>
-  <DD>Generate a range of monotonically increasing `int`s. When used without arguments, it generates the quasi-infinite range [0,1,2,3...]. It can also be called with a lower bound, or with a lower and upper bound (exclusive). An inclusive version is provided by `closed_ints`.</DD>
-<DT>\link ranges::views::iota_fn `views::iota`\endlink</DT>
-  <DD>A generalization of `views::ints` that generates a sequence of monotonically increasing values of any incrementable type. When specified with a single argument, the result is an infinite range beginning at the specified value. With two arguments, the values are assumed to denote a half-open range.</DD>
-<DT>\link ranges::views::join_fn `views::join`\endlink</DT>
-  <DD>Given a range of ranges, join them into a flattened sequence of elements. Optionally, you can specify a value or a range to be inserted between each source range.</DD>
-<DT>\link ranges::views::keys_fn `views::keys`\endlink</DT>
-  <DD>Given a range of `pair`s (like a `std::map`), return a new range consisting of just the first element of the `pair`.</DD>
-<DT>\link ranges::views::linear_distribute_fn `views::linear_distribute`\endlink</DT>
-  <DD>Distributes `n` values linearly in the closed interval `[from, to]` (the end points are always included). If `from == to`, returns `n`-times `to`, and if `n == 1` it returns `to`.</DD>
-<DT>\link ranges::views::move_fn `views::move`\endlink</DT>
-  <DD>Given a source range, return a new range where each element has been has been cast to an rvalue reference.</DD>
-<DT>\link ranges::views::partial_sum_fn `views::partial_sum`\endlink</DT>
-  <DD>Given a range and a binary function, return a new range where the *N*<SUP>th</SUP> element is the result of applying the function to the *N*<SUP>th</SUP> element from the source range and the (N-1)th element from the result range.</DD>
-<DT>\link ranges::views::remove_fn `views::remove`\endlink</DT>
-  <DD>Given a source range and a value, filter out those elements that do not equal value.</DD>
-<DT>\link ranges::views::remove_if_fn `views::remove_if`\endlink</DT>
-  <DD>Given a source range and a unary predicate, filter out those elements that do not satisfy the predicate. (For users of Boost.Range, this is like the `filter` adaptor with the predicate negated.)</DD>
-<DT>\link ranges::views::repeat_fn `views::repeat`\endlink</DT>
-  <DD>Given a value, create a range that is that value repeated infinitely.</DD>
-<DT>\link ranges::views::repeat_n_fn `views::repeat_n`\endlink</DT>
-  <DD>Given a value and a count, create a range that is that value repeated *count* number of times.</DD>
-<DT>\link ranges::views::replace_fn `views::replace`\endlink</DT>
-  <DD>Given a source range, a source value and a target value, create a new range where all elements equal to the source value are replaced with the target value.</DD>
-<DT>\link ranges::views::replace_if_fn `views::replace_if`\endlink</DT>
-  <DD>Given a source range, a unary predicate and a target value, create a new range where all elements that satisfy the predicate are replaced with the target value.</DD>
-<DT>\link ranges::views::reverse_fn `views::reverse`\endlink</DT>
-  <DD>Create a new range that traverses the source range in reverse order.</DD>
-<DT>\link ranges::views::sample_fn `views::sample`\endlink</DT>
-  <DD>Returns a random sample of a range of length `size(range)`.</DD>
-<DT>\link ranges::views::single_fn `views::single`\endlink</DT>
-  <DD>Given a value, create a range with exactly one element.</DD>
-<DT>\link ranges::views::slice_fn `views::slice`\endlink</DT>
-  <DD>Give a source range a lower bound (inclusive) and an upper bound (exclusive), create a new range that begins and ends at the specified offsets. Both the begin and the end can be integers relative to the front, or relative to the end with "`end-2`" syntax.</DD>
-<DT>\link ranges::views::sliding_fn `views::sliding`\endlink</DT>
-  <DD>Given a range and a count `n`, place a window over the first `n` elements of the underlying range. Return the contents of that window as the first element of the adapted range, then slide the window forward one element at a time until hitting the end of the underlying range.</DD>
-<DT>\link ranges::views::split_fn `views::split`\endlink</DT>
-  <DD>Given a source range and a delimiter specifier, split the source range into a range of ranges using the delimiter specifier to find the boundaries. The delimiter specifier can be an element or a range of elements. The elements matching the delimiter are excluded from the resulting range of ranges.</DD>
-<DT>\link ranges::views::split_when_fn `views::split_when`\endlink</DT>
-  <DD>Given a source range and a delimiter specifier, split the source range into a range of ranges using the delimiter specifier to find the boundaries. The delimiter specifier can be a predicate or a function. The predicate should take a single argument of the range's reference type and return `true` if and only if the element is part of a delimiter. The function should accept an iterator and sentinel indicating the current position and end of the source range and return `std::make_pair(true, iterator_past_the_delimiter)` if the current position is a boundary; otherwise `std::make_pair(false, ignored_iterator_value)`. The elements matching the delimiter are excluded from the resulting range of ranges.</DD>
-<DT>\link ranges::views::stride_fn `views::stride`\endlink</DT>
-  <DD>Given a source range and an integral stride value, return a range consisting of every *N*<SUP>th</SUP> element, starting with the first.</DD>
-<DT>\link ranges::views::tail_fn `views::tail`\endlink</DT>
-  <DD>Given a source range, return a new range without the first element. The range must have at least one element.</DD>
-<DT>\link ranges::views::take_fn `views::take`\endlink</DT>
-  <DD>Given a source range and an integral count, return a range consisting of the first *count* elements from the source range, or the complete range if it has fewer elements. (The result of `views::take` is not a `sized_range`.)</DD>
-<DT>\link ranges::views::take_exactly_fn `views::take_exactly`\endlink</DT>
-  <DD>Given a source range and an integral count, return a range consisting of the first *count* elements from the source range. The source range must have at least that many elements. (The result of `views::take_exactly` is a `sized_range`.)</DD>
-<DT>\link ranges::views::take_last_fn `views::take_last`\endlink</DT>
-  <DD>Given a source range and an integral count, return a range consisting of the last *count* elements from the source range. The source range must be a `sized_range`. If the source range does not have at least *count* elements, the full range is returned.</DD>
-<DT>\link ranges::views::take_while_fn `views::take_while`\endlink</DT>
-  <DD>Given a source range and a unary predicate, return a new range consisting of the  elements from the front that satisfy the predicate.</DD>
-<DT>\link ranges::views::tokenize_fn `views::tokenize`\endlink</DT>
-  <DD>Given a source range and optionally a submatch specifier and a `std::regex_constants::match_flag_type`, return a `std::regex_token_iterator` to step through the regex submatches of the source range. The submatch specifier may be either a plain `int`, a `std::vector<int>`, or a `std::initializer_list<int>`.</DD>
-<DT>\link ranges::views::transform_fn `views::transform`\endlink</DT>
-  <DD>Given a source range and a unary function, return a new range where each result element is the result of applying the unary function to a source element.</DD>
-<DT>\link ranges::views::trim_fn `views::trim`\endlink</DT>
-  <DD>Given a source bidirectional range and a unary predicate, return a new range without the front and back elements that satisfy the predicate.</DD>
-<DT>\link ranges::views::unbounded_fn `views::unbounded`\endlink</DT>
-  <DD>Given an iterator, return an infinite range that begins at that position.</DD>
-<DT>\link ranges::views::unique_fn `views::unique`\endlink</DT>
-  <DD>Given a range, return a new range where all consecutive elements that compare equal save the first have been filtered out.</DD>
-<DT>\link ranges::views::values_fn `views::values`\endlink</DT>
-  <DD>Given a range of `pair`s (like a `std::map`), return a new range consisting of just the second element of the `pair`.</DD>
-<DT>\link ranges::views::zip_fn `views::zip`\endlink</DT>
-  <DD>Given *N* ranges, return a new range where *M*<SUP>th</SUP> element is the result of calling `make_tuple` on the *M*<SUP>th</SUP> elements of all *N* ranges.</DD>
-<DT>\link ranges::views::zip_with_fn `views::zip_with`\endlink</DT>
-  <DD>Given *N* ranges and a *N*-ary function, return a new range where *M*<SUP>th</SUP> element is the result of calling the function on the *M*<SUP>th</SUP> elements of all *N* ranges.</DD>
-</DL>
-
-\subsection tutorial-actions Actions
-
---------------------------------------------------------------
-When you want to mutate a container in-place, or forward it through a chain of
-mutating operations, you can use actions. The following examples should make it
-clear.
-
-Read data into a vector, sort it, and make it unique.
-
-~~~~~~~{.cpp}
-    extern std::vector<int> read_data();
-    using namespace ranges;
-    std::vector<int> vi = read_data() | actions::sort | actions::unique;
-~~~~~~~
-
-Do the same to a `vector` that already contains some data:
-
-~~~~~~~{.cpp}
-    vi = std::move(vi) | actions::sort | actions::unique;
-~~~~~~~
-
-Mutate the container in-place:
-
-~~~~~~~{.cpp}
-    vi |= actions::sort | actions::unique;
-~~~~~~~
-
-Same as above, but with function-call syntax instead of pipe syntax:
-
-~~~~~~~{.cpp}
-    actions::unique(actions::sort(vi));
-~~~~~~~
-
-### List of range actions
-
-Below is a list of the eager range combinators, or actions, that Range-v3
-provides, and a blurb about how each is intended to be used.
-
-<DL>
-<DT>\link ranges::actions::drop_fn `actions::drop`\endlink</DT>
-  <DD>Removes the first `N` elements of the source range.</DD>
-<DT>\link ranges::actions::drop_while_fn `actions::drop_while`\endlink</DT>
-  <DD>Removes the first elements of the source range that satisfy the unary predicate.</DD>
-<DT>`actions::erase`</DT>
-  <DD>Removes all elements in the sub-range of the source (range version) or all elements after position.</DD>
-<DT>`actions::insert`</DT>
-  <DD>Inserts all elements of the range into the source at position.</DD>
-<DT>\link ranges::actions::join_fn `actions::join`\endlink</DT>
-  <DD>Flattens a range of ranges.</DD>
-<DT> `actions::push_back`</DT>
-  <DD>Appends elements to the tail of the source.</DD>
-<DT>`actions::push_front`</DT>
-  <DD>Appends elements before the head of the source.</DD>
-<DT>\link ranges::actions::remove_if_fn `actions::remove_if`\endlink</DT>
-  <DD>Removes all elements from the source that satisfy the predicate.</DD>
-<DT>\link ranges::actions::remove_fn `actions::remove`\endlink</DT>
-  <DD>Removes all elements from the source that are equal to value.</DD>
-<DT>\link ranges::actions::reverse_fn `actions::reverse`\endlink</DT>
-  <DD>Reverses all the elements in the container.</DD>
-<DT>\link ranges::actions::shuffle_fn `actions::shuffle`\endlink</DT>
-  <DD>Shuffles the source range.</DD>
-<DT>\link ranges::actions::slice_fn `actions::slice`\endlink</DT>
-  <DD>Removes all elements from the source that are not part of the sub-range.</DD>
-<DT>\link ranges::actions::sort_fn `actions::sort`\endlink</DT>
-  <DD>Sorts the source range (unstable).</DD>
-<DT>\link ranges::actions::split_fn `actions::split`\endlink</DT>
-  <DD>Split a range into a sequence of subranges using a delimiter (a value, a sequence of values, a predicate, or a binary function returning a `pair<bool, N>`).</DD>
-<DT>\link ranges::actions::stable_sort_fn `actions::stable_sort`\endlink</DT>
-  <DD>Sorts the source range (stable).</DD>
-<DT>\link ranges::actions::stride_fn `actions::stride`\endlink</DT>
-  <DD>Removes all elements whose position does not match the stride.</DD>
-<DT>\link ranges::actions::take_fn `actions::take`\endlink</DT>
-  <DD>Keeps the first `N`-th elements of the range, removes the rest.</DD>
-<DT>\link ranges::actions::take_while_fn `actions::take_while`\endlink</DT>
-  <DD>Keeps the first elements that satisfy the predicate, removes the rest.</DD>
-<DT>\link ranges::actions::transform_fn `actions::transform`\endlink</DT>
-  <DD>Replaces elements of the source with the result of the unary function.</DD>
-<DT>\link ranges::actions::unique_fn `actions::unique`\endlink</DT>
-  <DD>Removes adjacent elements of the source that compare equal. If the source is sorted, removes all duplicate elements.</DD>
-<DT>\link ranges::actions::unstable_remove_if_fn `actions::unstable_remove_if`\endlink</DT>
-  <DD>Much faster (each element remove has constant time complexity), unordered version of `remove_if`. Requires bidirectional container.</DD>
-</DL>
-
-
-\subsection tutorial-utilities Utilities
-
-----------------------------------------------
-Below we cover some utilities that range-v3 provides for creating your own
-view adaptors and iterators.
-
-#### Create Custom Views with view_facade
-
-Range-v3 provides a utility for easily creating your own range types, called
-\link ranges::view_facade `ranges::view_facade`\endlink. The code below uses
-`view_facade` to create a range that traverses a null-terminated string:
-
-~~~~~~~{.cpp}
-    #include <range/v3/view/facade.hpp>
-
-    // A range that iterates over all the characters in a
-    // null-terminated string.
-    class c_string_range
-      : public ranges::view_facade<c_string_range>
-    {
-        friend ranges::range_access;
-        char const * sz_ = "";
-        char const & read() const { return *sz_; }
-        bool equal(ranges::default_sentinel_t) const { return *sz_ == '\0'; }
-        void next() { ++sz_; }
-    public:
-        c_string_range() = default;
-        explicit c_string_range(char const *sz) : sz_(sz)
-        {
-            assert(sz != nullptr);
-        }
-    };
-~~~~~~~
-
-The `view_facade` class generates an iterator and begin/end member functions
-from the minimal interface provided by `c_string_range`. This is an example of a
-very simple range for which it is not necessary to separate the range itself
-from the thing that iterates the range. Future examples will show examples of
-more sophisticated ranges.
-
-With `c_string_range`, you can now use algorithms to operate on null-terminated
-strings, as below:
-
-~~~~~~~{.cpp}
-    #include <iostream>
-
-    int main()
-    {
-        c_string_range r("hello world");
-        // Iterate over all the characters and print them out
-        ranges::for_each(r, [](char ch){
-            std::cout << ch << ' ';
-        });
-        // prints: h e l l o   w o r l d
-    }
-~~~~~~~
-
-#### Create Custom Views with view_adaptor
-
-Often, a new range type is most easily expressed by adapting an existing range
-type. That's the case for many of the range views provided by the Range-v3
-library; for example, the `views::remove_if` and `views::transform` views. These
-are rich types with many moving parts, but thanks to a helper class called
-\link ranges::view_adaptor `ranges::view_adaptor`\endlink, they aren't hard
-to write.
-
-Below in roughly 2 dozen lines of code is the `transform` view, which takes one
-range and transforms all the elements with a unary function.
-
-~~~~~~~{.cpp}
-    #include <range/v3/view/adaptor.hpp>
-    #include <range/v3/utility/semiregular_box.hpp>
-
-    // A class that adapts an existing range with a function
-    template<class Rng, class Fun>
-    class transform_view
-      : public ranges::view_adaptor<transform_view<Rng, Fun>, Rng>
-    {
-        friend ranges::range_access;
-        ranges::semiregular_box_t<Fun> fun_; // Make Fun model semiregular if it doesn't
-        class adaptor : public ranges::adaptor_base
-        {
-            ranges::semiregular_box_t<Fun> fun_;
-        public:
-            adaptor() = default;
-            adaptor(ranges::semiregular_box_t<Fun> const &fun) : fun_(fun) {}
-            // Here is where we apply Fun to the elements:
-            auto read(ranges::iterator_t<Rng> it) const -> decltype(fun_(*it))
-            {
-                return fun_(*it);
-            }
-        };
-        adaptor begin_adaptor() const { return {fun_}; }
-        adaptor end_adaptor() const { return {fun_}; }
-    public:
-        transform_view() = default;
-        transform_view(Rng && rng, Fun fun)
-          : transform_view::view_adaptor{std::forward<Rng>(rng)}
-          , fun_(std::move(fun))
-        {}
-    };
-
-    template<class Rng, class Fun>
-    transform_view<Rng, Fun> transform(Rng && rng, Fun fun)
-    {
-        return {std::forward<Rng>(rng), std::move(fun)};
-    }
-~~~~~~~
-
-Range transformation is achieved by defining a nested `adaptor` class that
-handles the transformation, and then defining `begin_adaptor` and `end_adaptor`
-members that return adaptors for the begin iterator and the end sentinel,
-respectively. The `adaptor` class has a `read` member that performs the
-transformation. It is passed an iterator to the current element. Other members
-are available for customization: `equal`, `next`, `prev`, `advance`, and
-`distance_to`; but the transform adaptor accepts the defaults defined in
-\link ranges::adaptor_base `ranges::adaptor_base`\endlink.
-
-With `transform_view`, we can print out the first 20 squares:
-
-~~~~~~~{.cpp}
-    int main()
-    {
-        auto squares = ::transform(views::ints(1), [](int i){return i*i;});
-        for(int i : squares | views::take(20))
-            std::cout << i << ' ';
-        std::cout << '\n';
-        // prints 1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 324 361 400
-    }
-~~~~~~~
-
-The `transform_view` defined above is an input range when it is wrapping an
-input range, a forward range when it's wrapping a forward range, etc. That happens
-because of smart defaults defined in the `adaptor_base` class that frees you
-from having to deal with a host of niggly detail when implementing iterators.
-
-*(Note: the above `transform_view` always stores a copy of the function in the
-sentinel. That is only necessary if the underlying range's sentinel type models
-bidirectional_iterator. That's a finer point that you shouldn't worry about right
-now.)*
-
-##### view_adaptor in details
-
-Each `view_adaptor` contains `base()` member in view and iterator.
-`base()` - allow to access "adapted" range/iterator:
-
-~~~~~~~{.cpp}
-    std::vector<int> vec;
-    auto list = vec | views::transfom([](int i){ return i+1; });
-
-    assert( vec.begin() == list.begin().base() );
-    assert( vec.begin() == list.base().begin() );
-~~~~~~~
-
-Like `basic_iterator`'s `cursor`, `view_adaptor`'s `adaptor` can contain mixin class too,
-to inject things into the public interface of the iterator:
-
-~~~~~~~{.cpp}
-    class adaptor : public ranges::adaptor_base
-    {
-        template<class BaseMixin>
-        struct mixin : BaseMixin
-        {
-              // everything inside this class will be accessible from iterator
-              using BaseMixin::BaseMixin;
-
-              auto& base_value() const
-              {
-                  return *this->base();
-              }
-
-              int get_i() const
-              {
-                  return this->get().i;
-              }
-        };
-
-        int i = 100;
-    };
-~~~~~~~
-
-From within mixin you can call:
-
-* `get()` - to access adaptor internals
-* `base()` - to access adaptable iterator
-
-Iterator/sentinel adaptor may "override" the following members:
-
-~~~~~~~{.cpp}
-    class adaptor : public ranges::adaptor_base
-    {
-        // !For begin_adaptor only!
-        template<typename Rng>
-        constexpr auto begin(Rng &rng)
-        {
-            return ranges::begin(rng.base());
-        }
-
-        // !For end_adaptor only!
-        template<typename Rng>
-        constexpr auto end(Rng &rng)
-        {
-            return ranges::end(rng.base());
-        }
-
-        template<typename I>
-        bool equal(I const &this_iter, I const &that_iter) const
-        {
-            return this_iter == that_iter;
-        }
-        // or
-        template<typename I>
-        bool equal(I const &this_iter, I const &that_iter, adaptor const &that_adapt) const
-        {
-            return
-              *this.some_value == that_adapt.some_value
-              && this_iter == that_iter;
-        }
-
-        // !For end_adaptor only!
-        // Same as equal, but compare iterator with sentinel.
-        // Not used, if iterator same as sentinel, and both have the same adaptor.
-        template<typename I, typename S>
-        constexpr bool empty(I const &it, S const &end) const
-        {
-            return it == end;
-        }
-        // or
-        template<typename I, typename S, typename SA>
-        constexpr bool empty(I const &it, S const &end, SA const &end_adapt) const
-        {
-            return
-              *this.some_value == end_adapt.some_value
-              && it == end;
-        }
-
-        template<typename I>
-        reference_t<I> read(I const &it)
-        {
-            return *it;
-        }
-
-        template<typename I>
-        void next(I &it)
-        {
-            ++it;
-        }
-
-        // !For bidirectional iterator only!
-        template<typename I>
-        void prev(I &it)
-        {
-            --it;
-        }
-
-        // !For random access iterator only!
-        template<typename I>
-        void advance(I &it, difference_type_t<I> n)
-        {
-            it += n;
-        }
-
-        // !For "sized" iterators only!
-        template<typename I>
-        difference_type_t<I> distance_to(I const &this_iter, I const &that_iter)
-        {
-            return that_iter - this_iter;
-        }
-        // or
-        template<typename I>
-        difference_type_t<I> distance_to
-            (I const &this_iter, I const &that_iter, adaptor const &that_adapt)
-        {
-            return that_iter - this_iter;
-        }
-    }
-~~~~~~~
-
-As you can see, some "overrides" have effect only for `begin_adaptor` or
-`end_adaptor`. In order to use full potential of adaptor, you need to have
-separate adaptors for begin and end:
-
-~~~~~~~{.cpp}
-    struct adaptor : adaptor_base
-    {
-        int n = 0;
-
-        void next(iterator_t<Rng>& it)
-        {
-            ++n;
-            ++it;
-        }
-    };
-
-    struct sentinel_adaptor : adaptor_base
-    {
-        int stop_at;
-        bool empty(const iterator_t<Rng>&, const adaptor& ia, const sentinel_t<Rng>& s) const
-        {
-            return ia.n == stop_at;
-        }
-    };
-
-    adaptor begin_adaptor() const { return {}; }
-    sentinel_adaptor end_adaptor() const { return {100}; }
-~~~~~~~
-
-Sometimes, you can use the same adaptor for both `begin_adaptor` and `end_adaptor`:
-
-~~~~~~~{.cpp}
-    struct adaptor : adaptor_base
-    {
-        int n = 0;
-        void next(iterator_t<Rng>& it)
-        {
-            ++n;
-            ++it;
-        }
-
-        // pay attention, we use equal, not empty. empty() will never trigger.
-        template<typename I>
-        bool equal(I const &this_iter, I const &that_iter, adaptor const &that_adapt) const
-        {
-            return *this.n == that_adapt.n;
-        }
-    };
-
-    adaptor begin_adaptor() const { return {}; }
-    adaptor end_adaptor()   const { return {100}; }
-~~~~~~~
-
-Note that all the data you store in the adaptor will become part of the iterator.
-
-If you will not "override" `begin_adaptor()` or/and `end_adaptor()` in your view_adaptor, default ones will be used.
-
-#### Create Custom Iterators with basic_iterator
-
-Here is an example of Range-v3 compatible random access proxy iterator.
-The iterator returns a key/value pair, like the `zip` view.
-
-~~~~~~~{.cpp}
-    #include <range/v3/iterator/basic_iterator.hpp>
-    #include <range/v3/utility/common_tuple.hpp>
-
-    using KeyIter   = typename std::vector<Key>::iterator;
-    using ValueIter = typename std::vector<Value>::iterator;
-
-    struct cursor
-    {
-        // basic_iterator derives from "mixin", if present, so it can be used
-        // to inject things into the public interface of the iterator
-        struct mixin;
-
-        // This is for dereference operator.
-        using value_type = std::pair<Key, Value>;
-        ranges::common_pair<Key&, Value&> read() const
-        {
-            return { *key_iterator, *value_iterator };
-        }
-
-        bool equal(const cursor& other) const
-        {
-            return key_iterator == other.key_iterator;
-        }
-
-        void next()
-        {
-            ++key_iterator;
-            ++value_iterator;
-        }
-
-        // prev optional. Required for Bidirectional iterator
-        void prev()
-        {
-            --key_iterator;
-            --value_iterator;
-        }
-
-        // advance and distance_to are optional. Required for random access iterator
-        void advance(std::ptrdiff_t n)
-        {
-            key_iterator   += n;
-            value_iterator += n;
-        }
-        std::ptrdiff_t distance_to(const cursor& other) const
-        {
-            return other.key_iterator - this->key_iterator;
-        }
-
-        cursor() = default;
-        cursor(KeyIter key_iterator, ValueIter value_iterator)
-          : key_iterator(key_iterator)
-          , value_iterator(value_iterator)
-        {}
-
-        KeyIter   key_iterator;
-        ValueIter value_iterator;
-    };
-
-    struct cursor::mixin : ranges::basic_mixin<cursor>
-    {
-        using ranges::basic_mixin<cursor>::basic_mixin;
-
-        // It is necessary to expose constructor in this way
-        mixin(KeyIter key_iterator, ValueIter value_iterator)
-          : mixin{ cursor(key_iterator, value_iterator) }
-        {}
-
-        KeyIter key_iterator()
-        {
-            return this->get().key_iterator;
-        }
-        ValueIter value_iterator()
-        {
-            return this->get().value_iterator;
-        }
-    };
-
-    using iterator = ranges::basic_iterator<cursor>;
-
-    void test()
-    {
-        std::vector<Key>   keys   = {1};
-        std::vector<Value> values = {10};
-
-        iterator iter(keys.begin(), values.begin());
-        ranges::common_pair<Key&, Value&> pair = *iter;
-        Key&   key   = pair.first;
-        Value& value = pair.second;
-
-        assert(&key   == &keys[0]);
-        assert(&value == &values[0]);
-
-        auto key_iter = iter.key_iterator();
-        assert(key_iter == keys.begin());
-    }
-~~~~~~~
-
-`read()` returns references. But the default for `value_type`, which is
-`decay_t<decltype(read())>`, is `common_pair<Key&, Value&>`. That is not correct
-in our case. It should be `pair<Key, Value>`, so we explicitly specify
-`value_type`.
-
-`ranges::common_pair` has conversions:
-
-> `ranges::common_pair<Key&, Value&>` &harr; `ranges::common_pair<Key, Value>`.
-
-All `ranges::common_pair`s converts to their `std::pair` equivalents, also.
-
-For more information, see [http://wg21.link/P0186#basic-iterators-iterators.basic](http://wg21.link/P0186#basic-iterators-iterators.basic)
-
-\subsection tutorial-concepts Concept Checking
-
---------------------------------------------------------------------------------
-The Range-v3 library makes heavy use of concepts to constrain functions, control
-overloading, and check type constraints at compile-time. It achieves this with
-the help of a Concepts emulation layer that works on any standard-conforming
-C++14 compiler. The library provides many useful concepts, both for the core
-language and for iterators and ranges. You can use the concepts framework to
-constrain your own code.
-
-For instance, if you would like to write a function that takes an
-iterator/sentinel pair, you can write it like this:
-
-~~~~~~~{.cpp}
-    CPP_template(class Iter, class Sent, class Comp = /*...some_default..*/)
-        (requires sentinel_for<Sent, Iter>)
-    void my_algorithm(Iter first, Sent last, Comp comp = Comp{})
-    {
-        // ...
-    }
-~~~~~~~
-
-You can then add an overload that take a Range:
-
-~~~~~~~{.cpp}
-    CPP_template(class Rng, class Comp = /*...some_default..*/)
-        (requires range<Rng>)
-    void my_algorithm(Rng && rng, Comp comp = Comp{})
-    {
-        return my_algorithm(ranges::begin(rng), ranges::end(rng));
-    }
-~~~~~~~
-
-With the type constraints expressed with the `CPP_template` macro, these
-two overloads are guaranteed to not be ambiguous. When compiling with C++20
-concepts support, this uses real concept checks. On legacy compilers, it falls
-back to using `std::enable_if`.
-
-\subsection tutorial-future Range-v3 and the Future
-
---------------------------------------------------------------------------------
-Range-v3 formed the basis for the
-[Technical Specification on Ranges](https://www.iso.org/standard/70910.html),
-which has since been merged into the working draft of C++20.
-
-In addition, a subset of range-v3's views are also a part of the C++20 working
-draft, with more slated for eventual inclusion in future versions of C++.
-
-The actions, as well as various utilities, have not yet been reviewed by the
-Committee, although the basic direction has already passed an initial review.
-
diff --git a/src/contrib/range-v3-0.11.0/doc/layout.xml b/src/contrib/range-v3-0.11.0/doc/layout.xml
deleted file mode 100644
index 304bf831..00000000
--- a/src/contrib/range-v3-0.11.0/doc/layout.xml
+++ /dev/null
@@ -1,225 +0,0 @@
-<doxygenlayout version="1.0">
-  <!-- Generated by doxygen 1.8.7 -->
-  <!-- Navigation index tabs for HTML output -->
-  <navindex>
-    <tab type="mainpage" visible="yes" title=""/>
-    <tab type="pages" visible="yes" title="" intro=""/>
-    <tab type="modules" visible="yes"
-                        title="Reference"
-                        intro="
-The reference documentation is split into logical modules, as documented in
-the user manual."/>
-
-    <tab type="usergroup" visible="yes" title="Indexes">
-      <tab type="classmembers" visible="yes"
-                               title="Methods"
-                               intro="
-This is an index of all the methods with links to the
-corresponding documentation."/>
-
-      <tab type="classlist" visible="yes"
-                            title="Classes"
-                            intro="
-This is an index of all the classes in the library with links to the
-corresponding documentation."/>
-
-      <tab type="filelist" visible="yes"
-                           title="Files"
-                           intro=""/>
-
-    </tab>
-
-    <!-- We don't use what's below -->
-    <tab type="namespaces" visible="no" title="">
-      <tab type="namespacelist" visible="no" title="" intro=""/>
-      <tab type="namespacemembers" visible="no" title="" intro=""/>
-    </tab>
-
-    <tab type="examples" visible="no" title="" intro=""/>
-
-    <tab type="classes" visible="no" title="">
-      <tab type="classindex" visible="$ALPHABETICAL_INDEX" title=""/>
-      <tab type="hierarchy" visible="no" title="" intro=""/>
-    </tab>
-
-    <tab type="files" visible="no" title="Files">
-      <tab type="globals" visible="no" title="Globals" intro=""/>
-    </tab>
-  </navindex>
-
-  <!-- Layout definition for a class page -->
-  <class>
-    <briefdescription visible="no"/>
-    <detaileddescription title="Description"/>
-
-    <includes visible="$SHOW_INCLUDE_FILES"/>
-    <inheritancegraph visible="$CLASS_GRAPH"/>
-    <collaborationgraph visible="$COLLABORATION_GRAPH"/>
-    <memberdecl>
-      <related title="Synopsis of methods" subtitle=" "/>
-      <nestedclasses visible="yes" title="Instances and minimal complete definitions"/>
-      <friends title=""/>
-      <membergroups visible="yes"/>
-
-      <!-- We don't use what's below -->
-      <publictypes title=""/>
-      <services title=""/>
-      <interfaces title=""/>
-      <publicslots title=""/>
-      <signals title=""/>
-      <publicmethods title=""/>
-      <publicstaticmethods title=""/>
-      <publicattributes title=""/>
-      <publicstaticattributes title=""/>
-      <protectedtypes title=""/>
-      <protectedslots title=""/>
-      <protectedmethods title=""/>
-      <protectedstaticmethods title=""/>
-      <protectedattributes title=""/>
-      <protectedstaticattributes title=""/>
-      <packagetypes title=""/>
-      <packagemethods title=""/>
-      <packagestaticmethods title=""/>
-      <packageattributes title=""/>
-      <packagestaticattributes title=""/>
-      <properties title=""/>
-      <events title=""/>
-      <privatetypes title=""/>
-      <privateslots title=""/>
-      <privatemethods title=""/>
-      <privatestaticmethods title=""/>
-      <privateattributes title=""/>
-      <privatestaticattributes title=""/>
-    </memberdecl>
-    <memberdef>
-      <related title="Methods"/>
-      <functions title=""/>
-      <variables title=""/>
-      <inlineclasses title=""/>
-      <typedefs title=""/>
-      <enums title=""/>
-
-      <!-- This is not for C++ -->
-      <services title=""/>
-      <interfaces title=""/>
-      <constructors title=""/>
-      <properties title=""/>
-      <events title=""/>
-    </memberdef>
-    <allmemberslink visible="yes"/>
-    <usedfiles visible="$SHOW_USED_FILES"/>
-    <authorsection visible="yes"/>
-  </class>
-
-  <!-- Layout definition for a namespace page -->
-  <namespace>
-    <briefdescription visible="yes"/>
-    <memberdecl>
-      <nestednamespaces visible="yes" title=""/>
-      <constantgroups visible="yes" title=""/>
-      <classes visible="yes" title=""/>
-      <typedefs title=""/>
-      <enums title=""/>
-      <functions title=""/>
-      <variables title=""/>
-      <membergroups visible="yes"/>
-    </memberdecl>
-    <detaileddescription title=""/>
-    <memberdef>
-      <inlineclasses title=""/>
-      <typedefs title=""/>
-      <enums title=""/>
-      <functions title=""/>
-      <variables title=""/>
-    </memberdef>
-    <authorsection visible="yes"/>
-  </namespace>
-
-  <!-- Layout definition for a file page -->
-  <file>
-    <briefdescription visible="yes"/>
-    <includes visible="$SHOW_INCLUDE_FILES"/>
-    <includegraph visible="$INCLUDE_GRAPH"/>
-    <includedbygraph visible="$INCLUDED_BY_GRAPH"/>
-    <sourcelink visible="yes"/>
-    <memberdecl>
-      <classes visible="yes" title=""/>
-      <namespaces visible="yes" title=""/>
-      <constantgroups visible="yes" title=""/>
-      <defines title=""/>
-      <typedefs title=""/>
-      <enums title=""/>
-      <functions title=""/>
-      <variables title=""/>
-      <membergroups visible="yes"/>
-    </memberdecl>
-    <detaileddescription title=""/>
-    <memberdef>
-      <inlineclasses title=""/>
-      <defines title=""/>
-      <typedefs title=""/>
-      <enums title=""/>
-      <functions title=""/>
-      <variables title=""/>
-    </memberdef>
-    <authorsection/>
-  </file>
-
-  <!-- Layout definition for a group page -->
-  <group>
-    <briefdescription visible="no"/>
-    <detaileddescription title="Description"/>
-
-    <groupgraph visible="$GROUP_GRAPHS"/>
-    <memberdecl>
-      <nestedgroups visible="yes" title=""/>
-      <dirs visible="yes" title=""/>
-      <files visible="yes" title=""/>
-      <namespaces visible="yes" title=""/>
-      <classes visible="yes" title=""/>
-      <defines title=""/>
-      <typedefs title=""/>
-      <enums title=""/>
-      <enumvalues title=""/>
-      <functions title=""/>
-      <variables title=""/>
-      <signals title=""/>
-      <publicslots title=""/>
-      <protectedslots title=""/>
-      <privateslots title=""/>
-      <events title=""/>
-      <properties title=""/>
-      <friends title=""/>
-      <membergroups visible="yes"/>
-    </memberdecl>
-    <memberdef>
-      <pagedocs/>
-      <inlineclasses title=""/>
-      <defines title=""/>
-      <typedefs title=""/>
-      <enums title=""/>
-      <enumvalues title=""/>
-      <functions title=""/>
-      <variables title=""/>
-      <signals title=""/>
-      <publicslots title=""/>
-      <protectedslots title=""/>
-      <privateslots title=""/>
-      <events title=""/>
-      <properties title=""/>
-      <friends title=""/>
-    </memberdef>
-    <authorsection visible="yes"/>
-  </group>
-
-  <!-- Layout definition for a directory page -->
-  <directory>
-    <briefdescription visible="yes"/>
-    <directorygraph visible="yes"/>
-    <memberdecl>
-      <dirs visible="yes"/>
-      <files visible="yes"/>
-    </memberdecl>
-    <detaileddescription title=""/>
-  </directory>
-</doxygenlayout>
diff --git a/src/contrib/range-v3-0.11.0/doc/preprocess.sh.in b/src/contrib/range-v3-0.11.0/doc/preprocess.sh.in
deleted file mode 100755
index a365b511..00000000
--- a/src/contrib/range-v3-0.11.0/doc/preprocess.sh.in
+++ /dev/null
@@ -1,3 +0,0 @@
-#!/bin/bash
-@Range-v3_SOURCE_DIR@/doc/ignore_errors.sh @CMAKE_CXX_COMPILER@ -x c++ -std=c++2a -DRANGES_DOXYGEN_INVOKED=1 -DMETA_DOXYGEN_INVOKED=1 -DCPP_DOXYGEN_INVOKED=1 -I @Range-v3_SOURCE_DIR@/include -E -CC $1 | @Range-v3_SOURCE_DIR@/doc/unpreprocess.pl
-exit 0
diff --git a/src/contrib/range-v3-0.11.0/doc/release_notes.md b/src/contrib/range-v3-0.11.0/doc/release_notes.md
deleted file mode 100644
index 54e8b5e2..00000000
--- a/src/contrib/range-v3-0.11.0/doc/release_notes.md
+++ /dev/null
@@ -1,442 +0,0 @@
-Release Notes           {#release_notes}
-=============
-
-\section v0-11-0 Version 0.11.0 "Thanks, ISO"
-
-_Released:_ August 6, 2020
-
-> **IMPORTANT:** This release removes the heuristic that tries to guess whether a range type
-is a "view" (lightweight, non-owning range), in accordance with the C++20. **This is a
-potentially source-breaking change.** Code that previously used an rvalue range as the
-start of a pipeline could stop compiling if the range library is not explicitly told that
-that range type is a view. To override the new default, please specialize the
-`ranges::enable_view<R>` Boolean variable template.
-
-> **IMPORTANT:** This release removes the implicit conversion from views to containers.
-To construct a container from an arbitrary range, you must now explicitly use
-`ranges::to`. For example, the following code no longer works:
->
-> ```c++
-> std::vector<int> is = ranges::views::ints(0, 10); // ERROR: no conversion
-> ```
->
-> Instead, please write this as:
->
-> ```c++
-> auto is = ranges::views::ints(0, 10) | ranges::to<std::vector>; // OK
-> ```
->
-> `ranges::to` lives in header `<range/v3/range/conversion.hpp>`
-
-> **IMPORTANT:** This release drops support for llvm-3.9.
-
-Changes:
-* **NEW:** A new concepts portability layer that short-circuits atomic constraints
-  in `requires` clauses for better compile times when emulating concepts.
-* **NEW:** Restored support for MSVC in `/std:c++17` mode, and for MSVC's default preprocessor.
-* Remove the implicit conversion from views to containers.
-* Rename the following entities to be consistent with C++20's `std::ranges` support:
-  * `safe_range<R>` -> `borrowed_range<R>`
-  * `enable_safe_range<R>` -> `enable_borrowed_range<R>`
-  * `safe_iterator_t<R>` -> `borrowed_iterator_t<R>`
-  * `safe_subrange_t<R>` -> `borrowed_subrange_t<R>`
-  * `readable_traits<I>` -> `indirectly_readable_traits<I>`
-  * `readable<I>` -> `indirectly_readable<I>`
-  * `writable<I>` -> `indirectly_writable<I>`
-* Added the following to the `ranges::cpp20` namespace:
-  * Algorithm `for_each_n`
-  * Algorithm `sample`
-  * Class `view_base`
-  * Alias `views::all_t`
-* Type `__int128` is recognized as "integer-like".
-* Adds concepts `three_way_comparable[_with]` when `<=>` is supported.
-* Adds concepts `partially_ordered[_with]`.
-* Better conformance with C++20's use of the _`boolean-testable`_ concept.
-* Support C++20 coroutines.
-* Honor CMake's `CMAKE_CXX_STANDARD` variable.
-* A fix for the cardinality of `views::zip[_with]` (#1486).
-* Add `view_interface::data()` member function.
-* Add necessary specializations for `std::basic_common_reference` and
-  `std::common_type`.
-* Numerous workarounds for MSVC.
-* Various CMake fixes and improvements.
-* `drop_while_view` is not a `sized_range`.
-* Added support for Wind River Systems.
-* Bug fixes to `views::group_by` (#1393).
-* `common_[reference|type]` of `common_[tuple|pair]` now yields a `common_[tuple|pair]`
-  instead of a `std::[tuple|pair]` (#1422).
-* Avoid UB when currying an lvalue in some views and actions (#1320).
-
-**Credits:** I would like to thank the following people who contributed to this release
-(in no particular order): Christopher Di Bella, @marehr, Casey Carter, Dvir Yitzchaki,
-Justin Riddell, Johel Ernesto Guerrero Pea, Barry Revzin, Kamlesh Kumar, and Vincas
-Dargis.
-
-\section v0-10-0 Version 0.10.0 "To Err is Human"
-
-_Released:_ Dec 6, 2019.
-
-**IMPORTANT:** Before upgrading, please note that several older compiler versions
-and build configurations are no longer supported! In particular, MSVC now needs
-`/std:c++latest`.
-
-**ALSO:** When taking a dependency on the `range-v3`, `meta`, or `concepts`
-libraries via CMake, please now use the namespace qualified target names:
-  - `range-v3::range-v3`
-  - `range-v3::meta`
-  - `range-v3::concepts`
-
-Changes:
-* **NEW:** Rewritten concepts portability layer with simpler macros for better
-  diagnostics.
-* **NEW:** The `views::cache1` view caches the most recent value in the
-  range. This can help avoid reevaluation of transformations in complex view
-  pipelines.
-* **NEW:** `ranges::contains` algorithm.
-* **NEW:** `enable_safe_range` trait for opting in to the _forwarding-range_
-  concept. Theseare ranges whose iterators remain valid even after the
-  range itself has been destroyed; _e.g._, `std::string_view` and
-  `ranges::subrange`.
-* The `readable` concept has changed such that types that are not _indirectly_
-  readable with `operator*` (_e.g., `std::optional`) no longer satisfy that
-  concept.
-* Using `views::join` to join a range of xvalue ranges works again.
-* The following range access primitives no longer accept temporary containers
-  (_i.e._, they refuse to return references known to be dangling):
-  - `range::front`
-  - `range::back`
-  - `range::at`
-  - `range::index`
-* `views::concat` with a single argument now simply returns its argument.
-* `ranges::ostream_iterator<T>` now coerces arguments to `T` before inserting
-  them into the wrapped ostream.
-* Smaller iterators for `views::transform` and `views::take_while`.
-* `actions::split` and `actions::split_when` now support partial application and
-  pipelining ([\#1085](https://github.com/ericniebler/range-v3/issues/1085)).
-* `views::group_by` and its iterator both get a `.base()` member to access the
-  underlying range and iterator, respectively.
-* Improved diagnostics with clang.
-* Assorted bug fixes and compiler work-arounds:
-  [\#284](https://github.com/ericniebler/range-v3/issues/284),
-  [\#491](https://github.com/ericniebler/range-v3/issues/491),
-  [\#499](https://github.com/ericniebler/range-v3/issues/499),
-  [\#871](https://github.com/ericniebler/range-v3/issues/871),
-  [\#1022](https://github.com/ericniebler/range-v3/issues/1022),
-  [\#1043](https://github.com/ericniebler/range-v3/issues/1043),
-  [\#1081](https://github.com/ericniebler/range-v3/issues/1081),
-  [\#1085](https://github.com/ericniebler/range-v3/issues/1085),
-  [\#1101](https://github.com/ericniebler/range-v3/issues/1101),
-  [\#1116](https://github.com/ericniebler/range-v3/issues/1116),
-  [\#1296](https://github.com/ericniebler/range-v3/issues/1296),
-  [\#1305](https://github.com/ericniebler/range-v3/issues/1305), and
-  [\#1335](https://github.com/ericniebler/range-v3/issues/1335).
-
-Many thanks to GitHub users @CaseyCarter, @morinmorin, @h-2, @MichaelWJung,
-@johelegp, @marehr, @alkino, @xuning97, @BRevzin, and @mpusz for their
-contributions.
-
-\section v0-9-1 Version 0.9.1
-
-_Released:_ Sept 1, 2019.
-
-gcc-9.x portability fixes.
-
-\section v0-9-0 Version 0.9.0 "Std::ranger Things"
-
-_Released:_ Aug 26, 2019.
-
-Bring many interfaces into sync with the C++20 draft.
-
-* **NEW:** An improved concepts portability layer with macros that use C++20
-  concepts when the compiler supports them.
-* **NEW:** An improved directory structure that keeps disjoint parts of the
-  library -- iterators, ranges, algorithms, actions, views, functional
-  programming support, and general utilities -- physically separate.
-* **NEW:** A `RANGES_DEEP_STL_INTEGRATION` configuration option that makes your
-  STL implementation default to structural conformance to infer iterator
-  category, as in C++20. Applies to libc++, libstdc++, and MSVC's Standard
-  Library.
-* **NEW:** A `ranges::cpp20` namespace that contains all the functionality of
-  C++20's `std::ranges` namespace.
-* All concept names have been given standard_case (renamed from PascalCase) and
-  have been harmonized with the C++20 draft.
-* The following range access customization points no longer accept rvalue ranges
-  by default:
-  - `ranges::begin`
-  - `ranges::end`
-  - `ranges::rbegin`
-  - `ranges::rend`
-  - `ranges::cbegin`
-  - `ranges::cend`
-  - `ranges::crbegin`
-  - `ranges::crend`
-  - `ranges::data`
-  - `ranges::cdata`
-* Iterators may specify an `iterator_concept` type alias in addition to
-  `iterator_category` -- either as a nested type or as a member of a
-  `std::iterator_traits` specialization -- to denote conformance to the C++20
-  iterator concepts as distinct from the C++98 iterator requirements.
-  (See [P1037 "Deep Integration of the Ranges TS"](http://wg21.link/p1037)
-  for more information.)
-* The `ranges::value_type` trait has been renamed to `readable_traits`.
-* The `ranges::difference_type` trait has been renamed to `incrementable_traits`.
-* The `ranges::iterator_category` trait has been deprecated. Specialize
-  `std::iterator_traits` to non-intrusively specify an iterator's category
-  and (optionally) concept.
-* Rename the `ranges::view` namespace to `ranges::views` and `ranges::action` to
-  `ranges::actions` (with deprecated namespace aliases for migration).
-* Rename `view::bounded` to `views::common`.
-* Rename `unreachable` to `unreachable_sentinel_t`.
-* Change `dangling` from a class template that wraps an iterator to a class that
-  acts as a placeholder for an iterator that would otherwise dangle.
-* Implement C++20's `subrange` as a view that wraps an iterator/sentinel pair;
-  deprecate `iterator_range`.
-* Deprecate implicit conversion from view types to containers; rename
-  `ranges::to_` to `ranges::to` and extend it to support converting a
-  range-of-ranges to a container-of-containers.
-* Deprecate the `ranges::v3` inline versioning namespace.
-* The following views have had minor changes to bring them into conformance with
-  the C++20 working draft:
-  - `join_view`
-  - `single_view`
-  - `empty_view`
-  - `split_view`
-  - `reverse_view`
-  - `all_view`
-  - `take_view`
-  - `iota_view`
-  <p/>`iota_view<std::[u]intmax_t>`, in particular, is given a user-defined
-  `difference_type` that avoids integer overflow.
-* New names for the iterator and range type aliases:
-  | Old Name                      | New Name                    |
-  |-------------------------------|-----------------------------|
-  | `value_type_t`                | `iter_value_t`              |
-  | `reference_t`                 | `iter_reference_t`          |
-  | `difference_type_t`           | `iter_difference_t`         |
-  | `size_type_t`                 | _deprecated_                |
-  | `rvalue_reference_t`          | `iter_rvalue_reference_t`   |
-  | `range_value_type_t`          | `range_value_t`             |
-  | `range_difference_type_t`     | `range_difference_t`        |
-  | `range_size_type_t`           | `range_size_t`              |
-
-\section v0-5-0 Version 0.5.0
-
-_Released:_ Apr 30, 2019.
-
-* **NEW:** MSVC support, from @CaseyCarter :tada: (See the docs for the list of supported compilers.)
-* **NEW:** `view::enumerate`, from @MikeGitb
-* **NEW:** `view::addressof`, from @tower120
-* **NEW:** `unstable_remove_if` algorithm and action, from @tower120
-* **NEW:** `adjacent_remove_if` algorithm and action, from @cjdb
-* **NEW:** `ostream_joiner`, from @sv1990
-* `view::drop_while` and `view::take_while` get projection support, from @mrpi
-* `view::filter` and `view::remove_if` get projection support, from @mrpi
-* `view::unique` accepts optional comparison operator, from @tete17
-* `action::slice` supports sliding from the end, from @tete17
-* Support coroutines on MSVC, from @CaseyCarter
-* Faster `view::generate_n`, from GitHub user @tower120
-* Improved aligned new detection for libc++ on iOS, from @mtak-
-* Various CMake improvements, from @johelegp
-* `view_adaptor` supports `basic_iterator`-style mixins, from @tower120
-* Fix `ranges::advance` for random-access iterators for `n==0`, from @tower120
-* Bugs fixed: [#755](https://github.com/ericniebler/range-v3/issues/755), [#759](https://github.com/ericniebler/range-v3/issues/759), [#942](https://github.com/ericniebler/range-v3/issues/942), [#946](https://github.com/ericniebler/range-v3/issues/946), [#952](https://github.com/ericniebler/range-v3/issues/952), [#975](https://github.com/ericniebler/range-v3/issues/975), [#978](https://github.com/ericniebler/range-v3/issues/978), [#986](https://github.com/ericniebler/range-v3/issues/986), [#996](https://github.com/ericniebler/range-v3/issues/996), [#1041](https://github.com/ericniebler/range-v3/issues/1041), [#1047](https://github.com/ericniebler/range-v3/issues/1047), [#1088](https://github.com/ericniebler/range-v3/issues/1088), [#1094](https://github.com/ericniebler/range-v3/issues/1094), [#1107](https://github.com/ericniebler/range-v3/issues/1107), [#1129](https://github.com/ericniebler/range-v3/issues/1129)
-
-\section v0-4-0 Version 0.4.0
-
-_Released:_ Oct 18, 2018.
-
-- Minor interface-breaking changes:
-  * `single_view` returns by `const &` (see [#817](https://github.com/ericniebler/range-v3/issues/817)).
-  * `reverse_view` of a non-Sized, non-Bounded RandomAccess range (eg., a null-terminated string) no longer satisfies SizedRange.
-  * The `generate` and `generate_n` views now return the generated values by xvalue reference (`T &&`) to the value cached within the view (see [#905](https://github.com/ericniebler/range-v3/issues/905)).
-  * Views no longer prefer returning constant iterators when they can; some views have different constant and mutable iterators.
-- Enhancements:
-  * Views can successfully adapt other views that have different constant and mutable iterators.
-  * The `single` and `empty` views are much closer to the versions as specified in [P0896](http://wg21.link/P0896).
-- Bug fixes:
-  * "single_view should not copy the value" [#817](https://github.com/ericniebler/range-v3/issues/817).
-  * "Calling back() on strided range does not return the correct last value in range" [#901](https://github.com/ericniebler/range-v3/issues/901).
-  * "generate(foo) | take(n) calls foo n+1 times" [#819](https://github.com/ericniebler/range-v3/issues/819).
-  * "generate seems broken with move-only return types" [#905](https://github.com/ericniebler/range-v3/issues/905).
-  * "Unexpected behavior in generate with return by reference" [#807](https://github.com/ericniebler/range-v3/issues/807).
-  * "Inconsistent behaviour of ranges::distance with ranges::view::zip using infinite views." [#783](https://github.com/ericniebler/range-v3/issues/783).
-  * "Infinite loop when using ranges::view::cycle with an infinite range" [#780](https://github.com/ericniebler/range-v3/issues/780).
-  * "Composing ranges::view::cycle with ranges::view::slice" [#778](https://github.com/ericniebler/range-v3/issues/778).
-  * "cartesian_product view, now with moar bugs." [#919](https://github.com/ericniebler/range-v3/issues/919).
-
-
-\section v0-3-7 Version 0.3.7
-
-_Released:_ Sept 19, 2018.
-
-- Improved support for clang-cl (thanks to @CaseyCarter).
-- Fix for `any_view<T, category::sized | category::input>` (see #869).
-- Fix `iter_move` of a `ranges::reverse_iterator` (see #888).
-- Fix `move_sentinel` comparisons (see #889).
-- Avoid ambiguity created by `boost::advance` and `std::advance` (see #893).
-
-\section v0-3-6 Version 0.3.6
-
-_Released:_ May 15, 2018.
-
-- NEW: `view::exclusive_scan` (thanks to GitHub user @mitsutaka-takeda).
-- All views get non-`const` overloads of `.empty()` and `.size()` (see [ericniebler/stl2\#793](https://github.com/ericniebler/stl2/issues/793)).
-- Upgrade Conan support for conan 1.0.
-- `subspan` interface tweaks.
-- Fix bug in `view::split` (see [this stackoverflow question](https://stackoverflow.com/questions/49015671)).
-- Fix bug in `view::stride` (see [ericniebler/stl2\#805](https://github.com/ericniebler/stl2/issues/805)).
-- Fix `const`-correctness problem in `view::chunk` (see [this stackoverflow question](https://stackoverflow.com/questions/49210190)).
-- Replace uses of `ranges::result_of` with `ranges::invoke_result`.
-- Fix potentialbuffer overrun of `view::drop` over RandomAccessRanges.
-- Lots of `view::cartesian_product` fixes (see [ericniebler/stl2\#820](https://github.com/ericniebler/stl2/issues/820), [ericniebler/stl2\#823](https://github.com/ericniebler/stl2/issues/823)).
-- Work around gcc-8 regression regarding `volatile` `std::initializer_list`s (see [ericniebler/stl2\#826](https://github.com/ericniebler/stl2/issues/826)).
-- Fix `const`-correctness problem of `view::take`.
-
-\section v0-3-5 Version 0.3.5
-
-_Released:_ February 17, 2018.
-
-- Rvalues may satisfy `Writable` (see [ericniebler/stl2\#387](https://github.com/ericniebler/stl2/issues/387)).
-- `view_interface` gets a bounds-checking `at` method.
-- `chunk_view` works on Input ranges.
-- Fix bug in `group_by_view`.
-- Improved concept checks for `partial_sum` numeric algorithm.
-- Define `ContiguousIterator` concept and `contiguous_iterator_tag` iterator
-  category tag.
-- Sundry `span` fixes.
-- `action::insert` avoids interfering with `vector`'s exponentional growth
-  strategy.
-- Add an experimental `shared` view for views that need container-like scratch
-  space to do their work.
-- Faster, simpler `reverse_view`.
-- Rework `ranges::reference_wrapper` to avoid [LWG\#2993](https://wg21.link/lwg2993).
-- Reworked `any_view`, the type-erased view wrapper.
-- `equal` algorithm is `constexpr` in C++14.
-- `stride_view` no longer needs an `atomic` data member.
-- `const`-correct `drop_view`.
-- `adjacent_filter_view` supports bidirectional iteration.
-- Massive `view_adaptor` cleanup to remove the need for a `mutable` data
-  member holding the adapted view.
-- Fix `counting_iterator` post-increment bug.
-- `tail_view` of an empty range is an empty range, not undefined behavior.
-- Various portability fixes for gcc and clang trunk.
-
-\section v0-3-0 Version 0.3.0
-
-_Released:_ June 30, 2017.
-
-- Input views may now be move-only (from @CaseyCarter)
-- Input `any_view`s are now *much* more efficient (from @CaseyCarter)
-- Better support for systems lacking a working `<thread>` header (from @CaseyCarter)
-
-\section v0-2-6 Version 0.2.6
-
-_Released:_ June 21, 2017.
-
-- Experimental coroutines with `ranges::experimental::generator` (from @CaseyCarter)
-- `ranges::optional` now behaves like `std::optional` (from @CaseyCarter)
-- Extensive bug fixes with Input ranges (from @CaseyCarter)
-
-\section v0-2-5 Version 0.2.5
-
-_Released:_ May 16, 2017.
-
-- `view::chunk` works on Input ranges (from @CaseyCarter)
-- `for_each_n` algorithm (from @khlebnikov)
-- Portability fixes for MinGW, clang-3.6 and -3.7, and gcc-7; and cmake 3.0
-
-\section v0-2-4 Version 0.2.4
-
-_Released:_ April 12, 2017.
-
-Fix the following bug:
-- `action::stable_sort` of `vector` broken on Clang 3.8.1 since ~last Xmas (ericniebler/range-v3#632).
-
-\section v0-2-3 Version 0.2.3
-
-_Released:_ April 4, 2017.
-
-Fix the following bug:
-- iterators that return move-only types by value do not satisfy Readable (ericniebler/stl2#399).
-
-\section v0-2-2 Version 0.2.2
-
-_Released:_ March 30, 2017.
-
-New in this release:
-- `view::linear_distribute(from,to,n)` - A view of `n` elements between `from` and `to`, distributed evenly.
-- `view::indices(n)` - A view of the indices `[0,1,2...n-1]`.
-- `view::closed_indices(n)` - A view of the indices `[0,1,2...n]`.
-
-This release deprecates `view::ints(n)` as confusing to new users.
-
-\section v0-2-1 Version 0.2.1
-
-_Released:_ March 22, 2017.
-
-New in this release:
-- `view::cartesian_product`
-- `action::reverse`
-
-\section v0-2-0 Version 0.2.0
-
-_Released:_ March 13, 2017.
-
-Bring many interfaces into sync with the Ranges TS.
-- Many interfaces are simply renamed. The following table shows the old names
-  and the new. (All names are in the `ranges::v3` namespace.)
-  | Old Name                      | New Name                  |
-  |-------------------------------|---------------------------|
-  | `indirect_swap`               | `iter_swap`               |
-  | `indirect_move`               | `iter_move`               |
-  | `iterator_value_t`            | `value_type_t`            |
-  | `iterator_reference_t`        | `reference_t`             |
-  | `iterator_difference_t`       | `difference_type_t`       |
-  | `iterator_size_t`             | `size_type_t`             |
-  | `iterator_rvalue_reference_t` | `rvalue_reference_t`      |
-  | `iterator_common_reference_t` | `iter_common_reference_t` |
-  | `range_value_t`               | `range_value_type_t`      |
-  | `range_difference_t`          | `range_difference_type_t` |
-  | `range_size_t`                | `range_size_type_t`       |
-  | `range_iterator_t`            | `iterator_t`              |
-  | `range_sentinel_t`            | `sentinel_t`              |
-- `common_iterator` now requires that its two types (`Iterator` and `Sentinel`)
-  are different. Use `common_iterator_t<I, S>` to get the old behavior (i.e., if the two types are the same, it is an alias for `I`; otherwise, it is
-  `common_iterator<I, S>`).
-- The following iterator adaptors now work with iterators that return proxies
-  from their postfix increment operator (i.e., `operator++(int)`):
-  * `common_iterator`
-  * `counted_iterator`
-- The following customization points are now implemented per the Ranges TS
-  spec and will no longer find the associated unconstrained overload in
-  namespace `std::`:
-  * `ranges::begin`
-  * `ranges::end`
-  * `ranges::size`
-  * `ranges::swap`
-  * `ranges::iter_swap`
-
-  (In practice, this has very little effect but it may effect overloading in
-  rare situations.)
-- `ranges::is_swappable` now only takes one template parameter. The new
-  `ranges::is_swappable_with<T, U>` tests whether `T` and `U` are swappable.
-  `ranges::is_swappable<T>` is equivalent to `ranges::is_swappable_with<T &, T &>`.
-- The following object concepts have changed to conform with the Ranges TS
-  specification, and approved changes (see [P0547](http://wg21.link/p0547)):
-  * `Destructible`
-  * `Constructible`
-  * `DefaultConstructible`
-  * `MoveConstructible`
-  * `MoveConstructible`
-  * `Movable`
-  * `Assignable`
-- The `View` concept is no longer satisfied by reference types.
-- The syntax for defining a concept has changed slightly. See [iterator/concepts.hpp](https://github.com/ericniebler/range-v3/blob/master/include/range/v3/iterator/concepts.hpp) for examples.
-
-\section v0-1-1 Version 0.1.1
-
-- Small tweak to `Writable` concept to fix #537.
-
-\section v0-1-0 Version 0.1.0
-
-- March 8, 2017, Begin semantic versioning
diff --git a/src/contrib/range-v3-0.11.0/doc/std/D4128.md b/src/contrib/range-v3-0.11.0/doc/std/D4128.md
deleted file mode 100644
index f3ca4568..00000000
--- a/src/contrib/range-v3-0.11.0/doc/std/D4128.md
+++ /dev/null
@@ -1,2031 +0,0 @@
----
-pagetitle: Ranges for the Standard Library, Revision 1
-title: Ranges for the Standard Library, Revision 1
-...
-
-Introduction
-=====
-
-This paper outlines what support for ranges in the C++ standard library might look like. Rather than presenting a final design, this paper proposes a set of concepts and guidelines for using them to implement range-based versions of the standard algorithms. It draws inspiration from the [Boost.Range][2][@boostrange] library, the range algorithms in [Adobe Source Libraries][3][@asl], *Elements of Programming* by Stepanov and McJones (2009) [@stepanov09], and from [N3351 "A Concept Design for the STL"][8] by Stroustrup and Sutton (2012) [@n3351]. In addition to presenting the concepts and guidelines, this paper discusses the rationale behind each, weighing different design options.
-
-The decision to defer any discussion about specific wording was taken in recognition of the fact that any range design is likely to undergo significant revision by the committee. The paper is intended merely as a starting point for discussion and as a basis for future work.
-
-This paper assumes the availability of Concepts Lite; however, everything suggested here has been implemented in C++11, where Concepts Lite has been simulated with the help of generalized SFINAE for expressions.
-
-Motivation and Scope
-=====
-
-A *range* is an object that refers to a sequence of elements, conceptually similar to a pair of iterators. One prime motivation for ranges is to give users a simpler syntax for calling algorithms. Rather than this:
-
-    std::vector<int> v { /*...*/ };
-    std::sort( v.begin(), v.end() );
-
-Ranges would give us a pithier syntax:
-
-    std::sort( v );
-
-Allowing algorithms to take a single range object instead of separate begin and end iterators brings other benefits besides convenience. In particular:
-
-  * It eliminates the possibility of mismatched iterators.
-  * It opens the door to *range adaptors* which lazily transform or filter their underlying sequence in interesting ways.
-
-Range adaptors are far more compelling than iterator adaptors due to the fact that only a single object, the range object, needs to be adapted; hence, adaptors can be easily chained to create lazy computational pipelines, as in the code below which sums the first 10 squares:
-
-    int total = accumulate(view::iota(1) |
-                           view::transform([](int x){return x*x;}) |
-                           view::take(10), 0);
-
-The standard defines the term "range" in [iterator.requirements.general]:
-
-> [...] in general, a range `[i,j)` refers to the elements in the data structure starting with the element pointed to by `i` and up to but not including the element pointed to by `j`. Range `[i,j)` is valid if and only if `j` is reachable from `i`.
-
-From the perspective of the standard library, a range *is* a pair of iterators. But there are other interesting ways to denote a range of elements:
-
-* An iterator and a count of elements
-* An iterator and a (possibly stateful) predicate that indicates when the range is exhausted.
-
-One of these three range types can be used to denote all other range types, like an iterator and a sentinel value (e.g. a null-terminated string), or a range that spans disjoint ranges. Ideally, we would like our Range abstraction to be general enough to accommodate the three different kinds of ranges since that would increase the applicability of the algorithms.
-
-## Impact on the Standard
-
-Although this paper does not offer specific wording for any additions to the standard, we imagine that proper support for ranges in C++ would involve changes to the following parts of the standard:
-
-- New library-wide concepts related to ranges.
-- New iterator algorithms for efficiently dealing with the new abstractions.
-- Changes to existing algorithms to constrain the templates with concepts.
-- Additional overloads of existing algorithms that accept ranges instead of pairs of iterators.
-- Changes to the containers to allow containers to be constructed and assigned from ranges, and to allow range-based insert operations.
-- A new library section for range adaptors, which are views of existing data that have been transformed or filtered and that compose with other views.
-- General utilities for the construction of custom range adaptors.
-- A minor change to the specification of the range-based `for` to make it more efficient and general.
-
-Future papers will make specific recommendations for all of the above, modulo any feedback on the design presented here.
-
-Proposed Design
-=====
-
-The design space for ranges is surprisingly large. At one end of the spectrum lies [Boost.Range][2][@boostrange] and [Adobe's ASL][3][@asl] in which ranges are a thin abstraction on top of iterators, which remain the primitives that glue together data structures and algorithms. At the other end of the spectrum we find the [D Standard Library's std.range module][4][@drange], in which ranges and operations on them are the primitives themselves.
-
-This proposal picks a single point in this design space, and here we present the decisions that led to the selection of that point, along with guidelines to be applied to the standard library and the rationale for each choice.
-
-## Design Goals
-
-We feel that a well-designed range abstraction would:
-
-* Allow algorithms to operate on the three kinds of ranges with low or no abstraction penalty and a minimum of syntactic noise,
-* Allow range-based algorithms to share implementation with iterator-based algorithms,
-* Make it easy for users to reason about the complexity and expense of range operations (e.g. How many passes over the data are made? Are the elements copied? etc.),
-* Protect the user from lifetime issues,
-* Make it straightforward for users to make their types model one of the range concepts.
-
-It is helpful at this point to reflect on the success of C++11's range-based `for` loop. It succeeds because most of the types over which one would want to iterate already define iterators and `begin`/`end` members. Cleanly and efficiently interoperating with and reusing the existing abstractions of the STL is critical to the success of any range extensions.
-
-## High-Level Design
-
-At the highest level, this paper proposes the addition of two related range concepts: Iterable and Range. An *Iterable* type is one for which we can call `begin()` and `end()` to yield an iterator/sentinel pair. (Sentinels are described below.) The Iterable concept says nothing about the type's constructibility or assignability. Range-based standard algorithms are constrained using the Iterable concept. Consider:
-
-    int buf[5000];
-    // Fill buf
-    std::sort( buf );
-
-`buf` denotes a random access range of elements, so we should be able to sort it; but native arrays are neither copyable nor assignable, so these operations should not be required by whatever range-like concept is used to constrain `sort`. The above line of code is equivalent to:
-
-    using std::begin;
-    using std::end;
-    std::sort( begin( buf ), end( buf ) );
-
-For an Iterable object `o`, the concept requires the following:
-
-    auto b = begin( o ); // b models Iterator
-    auto e = end( o );   // e models Regular
-    bool f = (b == e);   // b and e model EqualityComparable
-
-Algorithms will typically be implemented to take iterator/sentinel pairs, rather than the iterator/iterator pairs as they do now. A typical algorithm might look like:
-
-    template<Iterator I, Regular S, /*...*/>
-        requires EqualityComparable<I, S>
-    I some_algo(I first, S last, /*...*/)
-    {
-        for(; first != last; ++first)
-            /*...*/
-        return first;
-    }
-
-    template<Iterable R, /*...*/>
-    IteratorOf<R> some_algo( R & r, /*...*/ )
-    {
-        return some_algo( begin(r), end(r), /*...*/ );
-    }
-
-The *Range* concept is modeled by lightweight objects that denote a range of elements they do not own. A pair of iterators can be a model of Range, whereas a `vector` is not. Range, as opposed to Iterable, requires copyability and assignability. Copying and assignment are required to execute in constant time; that is, the cost of these operations is not proportional to the number of elements in the Range.
-
-The Range concept refines the Iterable concept by additionally requiring following valid expressions for an object `o` of type `O`:
-
-    // Constructible:
-    auto o1 = o;
-    auto o2 = std::move(o);
-    O o3; // default-constructed, singular
-    // Assignable:
-    o2 = o1;
-    o2 = std::move(o1);
-    // Destructible
-    o.~O();
-
-The Range concept exists to give the range adaptors consistent and predictable semantics, and memory and performance characteristics. Since adaptors allow the composition of range objects, those objects must be efficiently copyable (or at least movable). The result of adapting a Range is a Range. The result of adapting a container is also a Range; the container -- or any Iterable that is not already a Range -- is first converted to a Range automatically by taking the container's `begin` and `end`.
-
-The precise definitions of the suggested concepts are given in [Section 4](#concept-definitions), along with other supporting concepts that have proven useful while porting the algorithms.
-
-The use of sentinels instead of iterators as an Iterable's bound is best understood by seeing how the three different kinds of ranges can be made to model the Iterable concept. Below is a sketch of how `begin` and `end` might work for each kind.
-
-- **Pair of iterators**: An end iterator is a perfectly acceptable sentinel. Existing code that uses iterator pairs to call STL algorithms will continue working with no changes.
-- **Iterator and predicate**: `begin(rng)` can return a normal iterator, `first`. `end(rng)` can return a sentinel `last` such that `first == last` returns the result of calling `last.predicate_(*first)`. See [Appendix 1](#appendix-1-sentinels-and-code-generation) for a discussion about the code generation benefits of letting the sentinel have a different type than the iterator.
-- **Iterator and count**: `begin(rng)` can return an iterator `first` that bundles the underlying iterator with the count to the end. Incrementing the iterator decrements the count. `end(rng)` can return an empty sentinel `last` such that `first == last` returns the result of `first.count_ == 0`. See [Appendix 4](#appendix-4-on-counted-ranges-and-efficiency) for a discussion of the performance implications of this design.
-
-## Design Decisions, Guidelines, and Rationale
-
-Below we present the decisions that led to the chosen high-level design, along with guidelines to be applied to the standard library and the rationale for each choice.
-
-### Iterator Operations are Primitive
-
-The most fundamental decision facing the designer of a generic library like the STL is: what are the *basis operations*? Basis operations are the primitive operations upon which all other desired operations can be efficiently built. In the STL, those operations are the operations on iterators, and they are clustered into the familiar iterator concept hierarchy. Two iterators are required to denote a range. Can these two positions be bundled together into a single range object and -- more ambitiously -- can operations on ranges be made the basis, obviating the need for iterators entirely?
-
-Below we describe two libraries that use range operations as the basis, and describe why they are not a good fit for the C++ Standard Library.
-
-#### D's Ranges
-
-In the C++ Standard Library, iterators fill several roles:
-
-* Two of them denote a sequence of elements.
-* One of them denotes a position within a range.
-* They allow access to an element at the current position.
-* They allow access to subsequent (and sometimes prior) positions in the sequence.
-
-The [D Standard Library][4][@drange] takes a different approach. In D, ranges and the operations on them form the basis operations of the standard algorithms. D-style ranges fill the following roles:
-
-* They denote a sequence of elements.
-* They allow access to the front of the range, and sometimes to the back or the N-th.
-* They allow the removal of elements from the front of the range, and sometimes from the back.
-
-Would C++ benefit from a similar design? The argument typically given in favor of D's ranges is that they lead to simpler code, both for the algorithms that operate on ranges as well as for users who wish to create custom range types. Code that manipulates positions directly can be harder to reason about and thus more bug-prone, and implementing custom iterators is famously complicated.
-
-D-style ranges can only ever shrink, and they have no notion of position within sequence. If one were to try to implement C++'s iterators on top of D's ranges, one would immediately run into trouble implementing ForwardIterator's `operator==`. As D's ranges do not represent position, there would be no way to test two ranges to see if their heads referred to the same element. (The `front` member function that returns the front of a D range is not required to return a reference, nor would that be sufficient to implement a hypothetical `hasSameFront` function; a repeating range might return the same element multiple times, leading to false positives.) Additionally, there would be trouble implementing BidirectionalIterator's `operator--` or RandomAccessIterator's `operator+=` as that might require a range to grow, and D ranges can't grow.
-
-On the other hand, two C++ iterators can easily be used to implement a D-style range; thus, every range-based design can be implemented in terms of iterators. Since iterators can implement D ranges, but D ranges cannot be used to implement iterators, we conclude that iterators form a more powerful and foundational basis.
-
-D avoids the limits of its ranges by carefully designing the algorithms such that the missing functionality is never needed. This can sometimes require some creativity, and leads to some awkward productions. A good example is the `find` family of algorithms. Since `find` cannot return the position of the found element, it must instead return a range. But which range to return? The D Standard Library has as many `find` algorithms as there are answers to this question ([`find`](http://dlang.org/phobos/std_algorithm.html#find), [`findSkip`](http://dlang.org/phobos/std_algorithm.html#.findSkip), [`findSplit`](http://dlang.org/phobos/std_algorithm.html#.findSplit), [`findSplitBefore`](http://dlang.org/phobos/std_algorithm.html#.findSplitBefore), [`findSplitAfter`](http://dlang.org/phobos/std_algorithm.html#.findSplitAfter)). All these algorithms find an element in a range; they only differ in the information they return. In contrast, C++ has just one `find` algorithm; it returns a position, and the user is free to construct any desired range from that.
-
-[Appendix 3](#appendix-3-d-ranges-and-algorithmic-complexity) contains an example of an algorithm that cannot be implemented with the same algorithmic complexity using D-style ranges. Any algorithm that needs to freely move an iterator forward and backward between two bounds will suffer from the same fundamental problem. Just writing the signature of an algorithm like `rotate`, which takes as an argument a position in a sequence, is challenging without a way to specify a position.
-
-Since C++ iterators cannot be implemented on top of D's ranges, iterators have to stay both for the increased expressive power and for backwards compatibility. To additionally provide D-style ranges -- essentially offering an incompatible set of basis operations -- would create a schism within the standard library between range-based and iterator-based algorithms, which couldn't share code. We, the authors, consider such a schism unacceptable.
-
-#### Position-Based Ranges
-
-If a range-first design that abandons "position" as a representable entity is undesirable for C++, perhaps adding position back in yields a satisfactory design. That is the approach taken by [James Touton's range library][5][@bekennrange], where ranges -- together with a new Position concept -- are the primitives. A Position, as its name suggests, represents a position in a range. Unlike an iterator, a position cannot be used to access the element at that position without the range into which it refers, nor can the position be advanced without the range.
-
-This design has the following advantages:
-
-* In making position a representable entity, it avoids the sometimes awkward constructions of D's range library.
-* In requiring the range in order to dereference the position, it avoids all dangling iterator issues.
-* In requiring the range in order to change the position, it makes range-checking trivial. This is a boon not just for debuggability, but also for the design of certain range adaptors like filter and stride whose iterators need to know the end of the range so as not to walk past it.
-* It permits a clean separation of element traversal and access, much like the suggested [cursor/property map abstraction][11][@n1873].
-
-It is possible to implement iterators on top of a position-based range by bundling a position with a pointer to a range into an iterator. However that results in iterators that may be fatter than necessary.
-
-A more workable approach would be to reimplement all the algorithms in terms of the position-based range primitives, and have the iterator-based overloads (that are retained for backwards-compatibility) forward to the range-based versions. In such a scheme, two iterators can be turned into a position-based range by wrapping them in a single range object and using the iterators themselves as the "positions".
-
-Although workable in principle, in practice it means there will be two ways of representing a range: an object with `begin()` and `end()` members that return iterators, and one with `begin_pos()` and `end_pos()` members that return positions; and every function that accepts ranges will need to account for that. It would mean that everybody would need to learn a new way to write algorithms. And it would mean that sometimes algorithms would return iterators and sometimes they would return positions, and that users would need to learn a new way to access the elements of a range.
-
-As appealing as the design is, it is too disruptive a change for the Standard Library.
-
-#### Basis-Operations: Summary
-
-In short, it just doesn't seem worth the trouble to change basis-operation horses in midstream. Iterators have a proven track record as a solid basis for the algorithms, and the C++ community has a heavy investment in the abstraction. The most heavily used and vetted C++ range libraries, Boost.Range and ASL Ranges, are built on top of iterators and have shown that it works in practice. This proposal follows suit.
-
-### Ranges Cannot Own Elements
-
-As described above, a Container is not a Range; it is, however, an Iterable. Distinguishing between the two makes it possible to be explicit about where copyability is required, and with what performance characteristics.
-
-The algorithms discussed in this proposal don't require any distinction between Ranges and Containers since they never copy or assign the ranges passed to them; they only request the `begin` and `end` iterators. The distinction between Iterables and Ranges only becomes important when defining adaptor chains. What does code like the following mean?
-
-    auto rng = v | view::reverse;
-
-This creates a view of `v` that iterates in reverse order. Now: is `rng` copyable, and if so, how expensive is the copy operation? If `v` is a `vector`, can `rng` safely outlive `v`? How about if `v` is just a pair of iterators? What happens when a user does `*rng.begin() = 42`? Is `v` mutated? How do the answers change if we replaced `v` with an rvalue expression? If a copy of `rng` is made, and an element is mutated through the copy, does the original `rng` object "see" the change?
-
-By specifying that Ranges do *not* own their elements, and further specifying that range adaptors operate on and produce Ranges (not Containers), we are able to answer these questions in a clear and consistent way. The result of a chain of range adaptors is always a lightweight object that is cheap to copy and assign (O(1) as opposed to O(N)), and that refers to elements whose lifetime is managed by some other object. Mutating an element through the resulting Range object mutates the underlying sequence. Copies of the resulting range are aliases to the same elements, and mutations to the elements are visible through all the aliased ranges.
-
-If `v` is a Range in the above line of code, it is copied into the adaptor. If it is a `vector`, the `vector` is first used to construct a Range by taking the `begin` and `end` of the Container. This happens automatically.
-
-The downside of this design is that it is sometimes desirable to do this:
-
-    // Try to adapt an rvalue container
-    auto rng = vector<int>{1,2,3,4} | view::reverse; // OK?
-
-Adaptors operate on and yield Ranges; other Iterables (i.e., containers) are used to construct Ranges by first taking their begin and end. The code above is unsafe because `rng` will be left holding invalid iterators into a container that no longer exists. Our solution is to disallow the above code. *It is illegal to adapt an rvalue non-Range.* (Adapting rvalue Ranges, however, is perfectly acceptable; indeed necessary if adaptor pipelines are to work.) See [Appendix 6](#on-distinguishing-ranges-from-non-range-iterables) for the mechanics of how we distinguish between Iterables and Ranges.
-
-The alternative is for the rvalue container to be moved (or copied) into the adapted range and held by value. The resulting object would therefore no longer model Range; it would model Iterable. The authors feel that this weakening of the requirements on the return type makes it difficult to reason about the semantics and algorithmic complexity of range adaptors. The recommendation is to first declare the container and then create the adaptor separately.
-
-### Ranges Are Semiregular
-
-We've already decided that Ranges (not Iterables) are copyable and assignable. They are, in the terminology of EoP[@stepanov09] and [N3351][8][@n3351], Semiregular types. It follows that copies are independent, even though the copies are both aliases of the same underlying elements. The ranges are independent in the same way that a copy of a pointer or an iterator is independent from the original. Likewise, iterators from two ranges that are copies of each other are also independent. When the source range goes out of scope, it does not invalidate an iterator into the destination range.
-
-Semiregular also requires DefaultConstructible in [N3351][8]. We follow suit and require all Ranges to be DefaultConstructible. Although this complicates the implementation of some range types, it has proven useful in practice, so we have kept this requirement.
-
-It is tempting to make Ranges Regular by requiring that they be EqualityComparable. A Range type would satisfy this additional requirement by testing whether two Ranges refer to the same elements in a sequence. (Note that it would be an error for `operator==` to test corresponding elements in two Ranges for equality, in the same way that it would be an error for `operator==` invoked on two pointers to compare the pointed-to elements. The state of a Range is not influenced by the content of its elements; a Range is defined only by the identity of the elements it references.) Although such a requirement is appealing in theory, it has problems:
-
-* It might conflict with users' expectations of what `rng1 == rng2` means. (See string_view for an example of a Range-like class that implements `operator==` in terms of the values of its elements, rather than identity.)
-* It is impossible to implement with those semantics in O(1) for some range types; for example, a filter range that stores a predicate. Functors and lambdas are generally not EqualityComparable.
-
-Another option is to allow Ranges to trivially model EqualityComparable by narrowly defining the domain over which the operation is valid. Iterators may only be compared if they refer into the same range. We can extend the reasoning to Ranges, which are logically little more than pairs of iterators. Taking this tack, we could allow a Range type to define its `operator==` as:
-
-    rng1.begin() == rng2.begin() && rng1.end() == rng2.end()
-
-The assumption being that the operation is invalid if `rng1` and `rng2` refer to different elements. Although principled (for some set of principles), such a definition is almost certain to lead users into undefined behavior-land.
-
-As a result of the above, we have decided that the Range concept should not require EqualityComparable. Ranges are Semiregular, not Regular.
-
-If a user would like to check to see if two ranges have elements that compare equal, we suggest the `equal` algorithm:
-
-    if(std::equal(rng1, rng2))
-        // ...
-
-### Range Iterators Cannot Outlive Their Ranges
-
-Containers own their elements, so it is clear that the container must outlive the iterators it generates. But is the same true for a Range if it does not own its elements? For a trivial range consisting of two iterators, it's clearly not true; the iterators *may* outlive the range.
-
-It turns out that if we require that all range's iterators be permitted to outlive the range, a great many interesting range types become significantly more expensive at runtime. A good case study is the filter view.
-
-A filter view takes a range and a predicate, and presents a view of the sequence that skips the elements for which the predicate is false. (The filter view can be thought of as a lazy equivalent of the `copy_if` algorithm.) The existence of the `boost::filter_iterator` shows that such an iterator *can* be made such that it doesn't depend on a range, but at a cost. The `filter_iterator` stores:
-
- 1. An iterator that indicates the current position in the underlying sequence.
- 2. An iterator that indicates the end of the underlying sequence (needed by the increment operators to avoid falling off the end while searching for an element that satisfies the predicate).
- 3. The predicate.
-
-In today's STL, the begin and end iterators must have the same type, and they are both needed to call an algorithm. Thus, the information in (2) and (3) is duplicated. Also, the predicate may be expensive to copy, given the ease with which capture-by-value lambdas and `std::function`s can be created. When such iterators are composed with other kinds of views (e.g., a transformed, filtered view), the bloat compounds exponentially (see [Index-Based Ranges][10][@n3782]).
-
-By relaxing the constraint that a range's begin and end must have the same type, we can avoid the duplication, but the begin iterator still must hold everything, which is potentially expensive.
-
-If we could rely on the range object outliving the iterator, we can make the filter iterators smaller and lighter. The range object can hold the predicate and the underlying range's begin/end iterators. The filter view's iterator only needs to hold the current position and a pointer back to the range object.
-
-The same logic applies to the transform view, which applies a transformation function to elements on the fly. If the iterators are required to be valid beyond the lifetime of the transform range, then the transformation function must be cached inside each iterator. This could make the iterators expensive to copy. An implementor might instead want the freedom to put the transformation function in the range object.
-
-A final example is `istream_iterator<T>`. Every `istream_iterator<T>` holds a single cached `T` object inside it. If `T` is an expensive-to-copy type like `std::string`, then copying `istream_iterator`s is potentially causing dynamic allocations. The STL assumes iterators are cheap to copy and copies them freely. A better design would see the cached `string` object move into an `istream_range` object whose iterators merely stored pointers back to the range. This would make the iterators smaller and cheaper to copy, but they would become invalid once the range was destroyed. This tradeoff is probably worth it.
-
-### An Iterable's End May Have a Different Type Than Its Begin
-
-In today's STL, `c.begin()` must have the same type as `c.end()`. This is because the only kind of range the STL supports is a pair of iterators. However, we've given examples of other kinds of ranges we would like to support, such as an iterator and a predicate, and an iterator and a count. These kinds of ranges can already be supported by shoe-horning them into the pair-of-iterators mold, but at a cost (see [Appendix 1](#appendix-1-sentinels-and-code-generation)). Loosening the constraints of the type of Iterable's end makes it possible to accommodate these other kinds of ranges with lower overhead.
-
-Allowing "end-ness" to be encoded in the type system also eliminates the need to mock-up dummy end iterators like `std::istream_iterator` and `std::regex_iterator`, the logic of which is tricky to get right. What's more, it improves code generation for these kinds of ranges. With the use of dummy end iterators, information which is known at compile-time -- namely, that an iterator represents the end -- must be encoded into runtime information in the iterator itself. This robs the compiler of the information it needs to eliminate branches from the core loops of many algorithms. See [Appendix 1](#appendix-1-sentinels-and-code-generation) for an example of how sentinels can positively affect code generation.
-
-When considering this choice for the range concept, it's helpful to think about how it would affect the algorithms. Consider `std::for_each`, which currently has this signature:
-
-    template<class InputIterator, class Function>
-    Function for_each(InputIterator first, InputIterator last, Function f)
-    {
-        for(; first != last; ++first)
-            f(*first);
-        return f;
-    }
-
-With sentinels, `for_each` might look like this:
-
-    template<InputIterator I, Regular S, Function<ValueType<I>> F>
-        requires EqualityComparable<I, S>
-    F for_each(I first, S last, F f)
-    {
-        for(; first != last; ++first)
-            f(*first);
-        return f;
-    }
-
-None of the code in the algorithm had to change. No calling code would have to change either; this is a strictly backwards-compatible change. You might think that this opens a new category of programming errors where developers inadvertently pass mismatched iterator/sentinel pairs. However, this algorithm signature is constrained with concept checks that ensures that `I` and `S` satisfied the cross-type EqualityComparable concept (see [N3351][8][@n3351]). See [Appendix 2](#appendix-2-sentinels-iterators-and-the-cross-type-equalitycomparable-concept) for further discussion about iterator/sentinel cross-type EqualityComparability constraint.
-
-To see the benefit of this design, imagine a sentinel type `null_sentinel`:
-
-    // For determining whether an iterator refers to a null value:
-    struct null_sentinel
-    {
-        template<Iterator I>
-        friend bool operator==(I i, null_sentinel) { return 0 == *i; }
-        // ... and friends
-    };
-
-    template<Iterator I>
-    struct common_type<I, null_sentinel>
-       ... see Appendix 2 ...
-
-Now we can use `std::for_each` on null-terminated strings without needing to know the length of the string:
-
-    std::for_each(argv[1], null_sentinel(), f);
-
-Of course, all the algorithms would have overloads that also accept range arguments, so this can be further simplified to:
-
-    std::for_each(null_terminated(argv[1]), f);
-
-where `null_terminated(InputIterator)` returns a range `r` such that the `std::end(r)` is a `null_sentinel`.
-
-#### Sentinels and Early Algorithm Termination
-
-One excuse sometimes given for not using the standard algorithm is that they don't give the users a way to break out of them early. The use of sentinels makes that possible. Consider a sentinel constructed from both an end iterator and a predicate. Such a sentinel would compare equal to an iterator *either* when the iterator equals the end iterator *or* when the predicate evaluates to true. Using such a sentinel has the effect of terminating an algorithm early. For instance:
-
-    // Process work items in a queue, allowing for a user interrupt
-    std::queue<Work> q;
-    std::function<void(Work const &)> user_interrupt = /*...*/;
-    std::for_each( q | view::until(user_interrupt), f );
-
-In the above, `view::until` is a range modifier that adds `user_interrupt` as an extra termination condition.
-
-### Algorithm Return Types are Changed to Accommodate Sentinels
-
-Notice that in the due course of evaluating `std::for_each` with `null_sentinel` above, the position of the null terminator is found. This is potentially useful information that can easily be returned to the user. It is, in fact, a far more interesting and useful result that the `Function` that `for_each` currently returns. So a better signature for `for_each` should look like this:
-
-    // Returns an InputIterator i such that (i == last) is true:
-    template<InputIterator I, Regular S, Function<ValueType<I>> F>
-        requires EqualityComparable<I, S>
-    I for_each(I first, S last, F f);
-
-In similar fashion, most algorithm get new return types when they are generalized to support sentinels. This is a source-breaking change in many cases. In some cases, like `for_each`, the change is unlikely to be very disruptive. In other cases it may be more so. Merely accepting the breakage is clearly not acceptable. We can imagine three ways to mitigate the problem:
-
-1. Only change the return type when the types of the iterator and the sentinel differ. This leads to a slightly more complicated interface that may confuse users. It also greatly complicates generic code, which would need metaprogramming logic just to use the result of calling some algorithms. For this reason, this possibility is not explored here.
-
-2. Make the new return type of the algorithms implicitly convertible to the old return type. Consider `copy`, which currently returns the ending position of the output iterator. When changed to accommodate sentinels, the return type would be changed to something like `pair<I, O>`; that is, a pair of the input and output iterators. Instead of returning a `pair`, we could return a kind of pair that is implicitly convertible to its second argument. This avoids breakage in some, but not all, scenarios. This subterfuge is unlikely to go completely unnoticed.
-
-3. Deliver the new standard library in a separate namespace that users must opt into. In that case, no code is broken until the user explicitly ports their code. The user would have to accommodate the changed return types then. An automated upgrade tool similar to [clang modernize][16][@clangmodernize] can greatly help here.
-
-We, the authors, prefer (3). Our expectation is that the addition of concepts will occasion a rewrite of the STL to properly concept-ify it. The experience with C++0x Concepts taught us that baking concepts into the STL in a purely backward-compatible way is hard and leads to an unsatisfactory design with a proliferation of meaningless, purely syntactic concepts. The spirit of [N3351][8][@n3351] is to conceptify the STL in a meaningful way, even at the expense of minor breakage. Although the issue has not yet been discussed, one likely solution would be to deliver a new STL in a separate namespace. Once that happens, it opens the door for other minor breaking changes, provided the benefits are deemed worthy.
-
-### Orthogonality of Traversal and Access Is Not Surfaced in the Iterator Concepts
-
-The current iterator concept hierarchy ties together the traversal and access properties of iterators. For instance, no forward iterator may return an rvalue proxy when it is dereferenced; the ForwardIterator concept requires that unary `operator*` return an lvalue. There is no room in the hierarchy for, say, a random-access iterator that returns proxies.
-
-This problem is not new to ranges; however, it has serious consequences for lazy ranges that apply transformations to elements on the fly. If the transformation function does not return an lvalue, the range's iterator can model no concept stronger than InputIterator, even if the resulting iterator could in theory allow random access. The result in practice is that most range adaptors today have the unfortunate effect of degrading the underlying range's category to Input, thereby limiting the number of algorithms it can be passed to -- often for no good reason.
-
-Prior work has been done by [Abrahams et. al.][9][@new-iter-concepts] to separate the traversal and access properties of iterators in a way that is backwards compatible. When formalizing the iterator concepts for a range library, should new iterator concepts be used, or should we hew to the old, simpler concept hierarchy with its known limitations?
-
-A close reading of the iterator concepts proposed by [N3351][8][@n3351] shows that the problematic requirement on ForwardIterator's reference type has been dropped. That is, if the concepts proposed by Stroustrup, Sutton, et. al., are adopted, there will be nothing wrong with, say, a random-access iterator with a proxy for a reference type. The problems described above go away without any need for further complication of the iterator refinement hierarchy. It's unclear at this time if that was the authors' intent, and if so what impact it has on the standard algorithms. This area requires more research.
-
-It is noted here that this proposal adopts the [N3351][8][@n3351] iterator concepts as-is.
-
-### Additional Overloads of the Algorithms
-
-As should be obvious, this range proposal recommends adding additional overloads of the existing algorithms to allow them to work directly on Iterables. This is done in accordance with the following suggested guidelines:
-
-- Any algorithm that currently operates on a range denoted by two iterators gets an overload where the two iterator arguments are replaced with a single Iterable argument. (NOTE: This does *not* include the counted algorithms like `copy_n` that take an iterator and a count instead of two iterators.)
-- All overloads of an algorithm, whether they take Iterables or separate iterator/sentinel arguments, are *semantically identical*. All overloads have the same return type. All evaluate eagerly. The intention is that the Iterable-based overloads delegate to the iterator-based ones and have the same semantics and algorithmic complexity.
-- As described above, algorithms that necessarily process their entire input sequence return the iterator position at the end in addition to whatever else they return. The purpose is to return potentially useful information that is computed as a side-effect of the normal execution of the algorithm. Exceptions to this design guideline are made when one of the following is true:
-    * The algorithm might in some cases not consume the entire input sequence. (The point of this exception is to avoid forcing the algorithm to compute something that is not necessary for successful completion. For example, `find`.)
-    * When the sole purpose of the algorithm is specifically to compute a single value; hence, changing the return type will necessarily break code using the C++11 version. Examples include `is_sorted` and `accumulate`.
-- "Three-legged" iterator-based algorithms (i.e. algorithms that operate on two ranges, the second of which is specified by only a single iterator and is assumed to be long enough) now have 4 versions:
-    1. The old three-legged iterator version,
-    2. A four-legged version that uses the sentinel of the second sequence as an additional termination condition,
-    3. A version that takes an Iterable and an Iterator (which dispatches to the three-legged iterator-based version),
-       and
-    4. A version that takes two Iterables (which dispatches to the four-legged iterator-based version).
-
-  Note: Purely as an implementation consideration, overloads (3) and (4) above must be coded to avoid ambiguity when a native array is passed as the second parameter (where either an Iterable or an Iterator may appear). Arrays are Iterables, but if (3) is naively coded to take an Iterator by value, a native array would also match, since native arrays decay into pointers.
-- If an algorithm returns an iterator into an Iterable argument, the Iterable must be an lvalue. This is to avoid
-  returning an iterator that is immediately made invalid. Conversely, if no iterator into an Iterable argument is
-  returned, then the Iterable should be taken by forwarding reference (aka ["universal reference"][13][@universal-references]).
-- Algorithms that do not mutate their input sequence must also work when braced initializer lists [dcl.init] are used in place of Iterables. This can require additional `initializer_list` overloads since a type cannot be deduced from a *braced-init-list* used as an argument.
-
-### Range-based for Loop is Changed to Accommodate Sentinels
-
-The current range-based `for` loop assumes that a range's end has the same type as its begin. This restriction can be relaxed to allow range-based `for` to operate on Iterables.
-
-The range-based for loop is currently specified as:
-
-    {
-        auto && __range = range-init;
-        for ( auto __begin = begin-expr,
-                   __end = end-expr;
-              __begin != __end;
-              ++__begin ) {
-            for-range-declaration = *__begin;
-            statement
-        }
-    }
-
-To accommodate Iterables, the change is as simple as:
-
-    {
-        auto && __range = range-init;
-        auto __begin = begin-expr;
-        auto __end = end-expr;
-        for ( ; __begin != __end; ++__begin ) {
-            for-range-declaration = *__begin;
-            statement
-        }
-    }
-
-This is the only core language change required to fully support Iterables.
-
-### Allow Mutable-Only Iterables
-
-If a cv-unqualified type `T` models Iterable, then the type `T const` need not. This permits ranges that maintain mutable internal state such as an `istream_range`.
-
-Consider the performance short-comings of `istream_iterator<string>`. The iterator reads a string from an `istream` and must store it internally so it can be returned from `operator*`. This means that copying an `istream_iterator<string>` probably incurs a dynamic allocation. Copying iterators is not supposed to be expensive.
-
-An alternative range-based design would be to define an `istream_range` class template:
-
-    template<class T>
-    class istream_range {
-       T value_;
-       istream * postr_;
-    public:
-        class iterator {
-            istream_range * prng_;
-        public:
-            /*...*/
-        };
-        iterator begin() {/*...*/}
-        iterator end() {/*...*/}
-    };
-
-In this design, the cached value lives in the range object, not in the iterator. The iterator merely stores a pointer back to the range. As the iterator is advanced, values are read from the stream and stored in the cache. Since the range object is mutated as it is iterated, it would be a lie to provide const overloads of `begin()` and `end()`.
-
-The need for a range that is mutated in the course of iteration also came up in the design of a `view::flatten` adaptor that takes a range of ranges, and turns it into a single range. This adapted range also must mutate an internal cache. The adaptor is used to make Ranges monads, and is used in the implementation of [Range Comprehensions][12][@range-comprehensions], which are akin to Python's and Haskell's List Comprehensions. (That discussion is beyond the scope of this document.)
-
-### Range Adaptors are Lazy Algorithms
-
-Consider the example given at the start of paper:
-
-    int total = accumulate(view::iota(1) |
-                           view::transform([](int x){return x*x;}) |
-                           view::take(10), 0);
-
-The semantics of the adaptors (the things in the `view::` namespace) are such that computations are only done on demand, when the resulting adapted range is iterated. In this case, the range pipeline expression does no work aside from setting up a computation. Only as `accumulate` executes is the sequence of integers generated and transformed.
-
-All adaptors have these lazy semantics. This gives users the ability to reason about the algorithmic complexity of their programs. If an underlying range is transformed and filtered and then passed to an algorithm, users can be certain that the sequence will be traversed exactly once.
-
-### All Algorithms Accept Sentinels Even If They Need An End Iterator
-
-Some algorithms like `reverse` really need an end iterator to do their job. One option would be to require users to pass an actual end iterator instead of a non-iterator sentinel. The other option is to accept a sentinel and do an O(N) probe for the end first. We opted for the latter option. No such algorithms have complexity better than O(N), so such a probe doesn't affect the overall algorithmic complexity of the algorithm. And it saves the user the hassle of having to find the end herself before calling the algorithm. In short, it should be possible to `reverse` a null-terminated string *without* needing to call `strlen` first.
-
-### There Is No Function Signature To Express Does-Not-Mutate-The-Range-Elements
-
-Raw pointers have an advantage over iterators with regard to the const-correctness of function interfaces; namely, that you can use `const` to guarantee that the function will not mutate the pointed-to data. Consider:
-
-    // This will not mutate the data
-    template<typename T>
-    void some_function(const T * data, std::size_t count);
-
-When we move to iterators, we lose that expressiveness:
-
-    // Will this mutate the data?
-    template<typename Iter>
-    void some_function(Iter first, Iter last);
-
-Since the suggested range design is built on top of iterators, it inherits this limitation. Consider what happens when we change to a range-based API with a simple `range` type like that proposed by [N3350][21][@n3350]:
-
-    // Accepts a const Range object, but mutates its elements
-    template<Iterable Rng>
-    void some_function(Rng const & rng) {
-        ++*rng.begin(); // Deeply questionable behavior
-    }
-
-    template<typename I>
-    struct range : pair<I, I> {
-        using pair<I, I>::pair;
-        I begin() const { return this->first; }
-        I end() const { return this->second; }
-    };
-
-    int main() {
-        int arr[] = {1,2,3,4};
-        range<int*> rng{ arr, arr + 3 };
-        some_function(rng); // arr is now {2,2,3,4}
-    }
-
-Keep in mind that the Iterable concept describes types like `vector` where a top-level const *does* affect the mutability of the iterable's elements, as well as simple pair-of-iterator style ranges like `range` above, where the top-level constness does *not* affect the elements' mutability. Concepts Lite doesn't help, either. Although it's not hard to write a concept that only matches immutable iterables and use it to constrain an algorithm, it doesn't solve the problem. See below:
-
-    template<Iterable Rng>
-    concept ConstIterable =
-        is_const<remove_reference_t<
-            decltype(*begin(declval<Rng &>()))
-        >>::value;
-
-    // This is over-constrained:
-    template<ConstIterable Rng>
-    void non_mutating_algorithm(Rng const & rng);
-
-    int rgi[] = {1,2,3,4};
-    range<int *> rng{rgi, rgi+4}; // a pair of mutable iterators
-    non_mutating_algorithm(rng); // <== ERROR rng is not a ConstIterable
-
-The trouble is that the type `Rng` is deduced as `range<int *>` which doesn't satisfy the requirements of the ConstIterable concept. The const in the function signature doesn't help because it doesn't change the const-ness of the iterator's reference type. Even if `rng` is const, `rng.begin()` returns an `int*`. There is no way to write the function signature such that template type deduction works *and* const-ness is applied deeply to the range's elements. That's because such a transformation would necessarily involve a change to the range's type, and type deduction makes no allowance for arbitrary type transformations during the deduction process.
-
-#### But it works for `array_view`. Why?
-
-[N3851](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3851.pdf) proposes an `array_view` class for the second Library Fundamentals TS. That type allows users to independently specify the mutability of the elements and of the view with the `const` keyword. From N3851:
-
-> A view can be created over an arbitrary *value_type*, as long as there exists a conversion from the pointer to the underlying collection object type to the pointer to the *value_type*. This allows to distinguish two levels of constness, analogously to the pointer semantics -- the constness of the view and the constness of the data over which the view is defined -- see Table 2. Interfaces of both the *array_view* and the *strided_array_view* allow for implicit conversions from non-const-qualified views to const-qualified views.
-
-With this scheme, you presumably would be able to pass any Container (defined in N3851 to be arrays and class types with `size` and `data` member functions) to an algorithm as follows:
-
-    void some_algorithm( array_view<const int, 1> const & arr );
-
-    vector<int> vi {1,2,3,4};
-    array_view<int, 1> arr { vi }
-    some_algorithm( arr ); // OK!
-
-In this case, the signature of the algorithm, together with the constructors of `array_view` and the implicit conversion of `int*` to `const int*`, conspire to make `some_function` guarantee deep-constness.
-
-If it can work for `array_view`, why can it not work in general for all Iterables? In other words, is there no range design in which users can put `const` somewhere in their function signatures to make their algorithms deeply const? The answer, sadly, is no. Even a trivial change to the above signature shows how fragile the `array_view` design is, and why it cannot be generalized to all range types:
-
-    template<typename T>
-    void some_algorithm( array_view<const T, 1> const & arr );
-
-    vector<int> rgi{1,2,3,4};
-    array_view<int, 1> arr { vi }
-    some_algorithm( arr ); // ERROR!
-
-The compiler cannot figure out what type to pick for `T` during type deduction, and there's no way for the author of `array_view` to give the compiler that guidance.
-
-When generalized to arbitrary Iterables and Ranges, the problem is further compounded. There is no place to put a second, "deep" `const` in a signature like below:
-
-    template<Iterable Rng>
-    void some_algorithm( Rng const & rng );
-
-And even if there were, the problem would be the same as for `array_view`: template type deduction would fail.
-
-#### Constraints and contracts
-
-There is no clever way around the problem in today's language, or even with Concepts Lite. This is an artifact of the style of generic programming used in C++: stating constraints on template arguments is significantly different than adding `const`-ness to a concrete type or template specialization.
-
-A template's constraints define part of that template's contract, and this contract applies not only to the user of that template, but also its implementer. In the earlier example, `some_function` requires its template arguments to satisfy the requirements of the Iterable concept. Under that contract, the implementation should use only the expressions allowed by the concept on objects whose types are constrained by the concept. In other words, those requirements define a set of expressions and types that are *admissible* within the template.
-
-Recall the `some_function` define above:
-
-    // Accepts a const Range object, but mutates its elements
-    template<Iterable Rng>
-    void some_function(Rng const & rng) {
-        ++*rng.begin(); // Deeply questionable behavior
-    }
-
-The expression `++*rng.begin()` invokes not one, but two operations not admitted by the requirements of the Iterable concept:
-
-- `rng.begin()` (which should be `using std::begin; begin(rng)`), and
-- `++x` where `x` is the object returned by `*begin(rng)`.
-
-While this program is syntactically well-formed, and instantiation may even succeed, its behavior would be undefined under the terms of its contract. In other words, the implementation does not conform to its constraints. This is not fundamentally different than using a `const_cast` to modify the value of a `const`-qualified function argument: it might work, but the modification invokes undefined behavior.
-
-*Every* proposed range design will have the same problem. The lack of a library solution to this problem should not hold up a proposal. A  work-around is for users to test each algorithm with an archetypal non-mutable iterator, as has been done with the [Boost Concept Check Library][1][@boostconceptcheck]. The standard library could make this task simpler by providing debug archetypal iterators for testing purposes.
-
-### Singular Ranges Are Not Empty
-
-Ranges are default-constructible. The question is, what can be done with a such a range? Given a Range type `R` and an object `r` defined as follows:
-
-    R r;                            // "singular" range
-    assert( begin(r) == end(r) );   // Is this OK?
-
-Default-constructed standard containers are empty. Can we expect the same is true for ranges? No, we cannot. The intention is that a simple pair of iterators may qualify as a valid range. The section [iterator.requirements.general]/5 explains what can be done with singular iterators, and comparing them for equality is not listed as one of the valid operations. Therefore, singular ranges are not "empty". In terms of EoP, they are partially formed objects that must be assigned to before they can be used [8].
-
-A particular model of the Range concept may choose to provide this guarantee, but it is not required by the Range concept itself and, as such, should not be relied upon.
-
-Concept Definitions
-=====
-
-The following concepts are proposed to constrain the standard library. The iterator concepts mentioned here are identical to those specified in [N3351][8][@n3351] except where specified.
-
-## Iterator Concepts
-
-The range concepts presented below build on the following iterator concepts. These are largely as found in [N3351][8][@n3351], with the addition of WeakIterator, Iterator, WeakOutputIterator and OutputIterator. The entire hierarchy is presented here for completeness. An important, new concept is:
-
-    concept WeakIterator<typename I> =
-        WeaklyIncrementable<I> && Copyable<I> &&
-        requires(I i) {
-            { *i } -> auto&&;
-        };
-
-A WeakIterator is a WeaklyIncrementable type that is both copyable and dereferencable, in addition to being pre-incrementable. The only requirement on the result of dereferencing the iterator is that its type can be deduced from `auto&&`. Effectively, the result of dereferencing shall not be `void`. The WeakIterator concept allows iterator adaptors to provide a dereferencing operator for both InputIterators and OutputIterators.
-
-This concept is refined  by the addition of either Readable or Writable, which allow reading from and writing to a dereferenced iterator, respectively. The Iterator and WeakIterator also obviate the need for separate InputRange and OutputRange concepts (as we see later).
-
-    concept Iterator<typename I> =
-        WeakIterator<I> && EqualityComparable<I>;
-
-    concept WeakOutputIterator<typename I, typename T> =
-        WeakIterator<I> && Writable<I, T>;
-
-    concept OutputIterator<typename I, typename T> =
-        WeakOutputIterator<I> && EqualityComparable<I>;
-
-N3351 does not define WeakOutputIterator or OutputIterator, preferring instead to define all the algorithms in terms of WeaklyIncrementable and (separately) Writable. We see no disadvantage to rolling these two into the familiar (Weak)OutputIterator concept as a convenience; it saves typing.
-
-The WeakInputIterator concept defines requirements for a type whose referred to values can be read (from the requirement for Readable) and which be both pre- and post-incremented. However, WeakInputIterators are not required to be compared for equality. There are a number of algorithms whose input ranges are defined by the equality of comparison of another input range (e.g., `std::mismatch` and `std::equal`).
-
-    concept WeakInputIterator<WeakIterator I> =
-        Readable<I> &&
-        requires(I i) {
-            typename IteratorCategory<I>;
-            { i++ } -> Readable;
-            requires Derived<IteratorCategory<I>, weak_input_iterator_tag>;
-        };
-
-An InputItreator is a WeakInputIterator that can be compared for equality comparison. This concept defines the basic requirements for a very large number of the algorithm in the standard library.
-
-    concept InputIterator<typename I> =
-        WeakInputIterator<I> &&
-        EqualityComparable<I> &&
-        Derived<IteratorCategory<I>, input_iterator_tag>;
-
-The ForwardIterator concept refines the InputIterator concept, but the refinement is *semantic*. It guarantees the "multipass" property: it allows multiple iterations of a range of elements. This is something that cannot be done with, say, an `istream_iterator`. The current element is consumed when the iterator is incremented.
-
-    concept ForwardIterator<typename I> =
-        InputIterator<I> &&
-        Incrementable<I> &&
-        Derived<IteratorCategory<I>, forward_iterator_tag>;
-
-The BidirectionalIterator concept refines the ForwardIterator concept, and allows both incrementing and decrementing.
-
-    concept BidirectionalIterator<typename I> =
-        ForwardIterator<I> &&
-        Derived<IteratorCategory<I>, bidirectional_iterator_tag> &&
-        requires decrement (I i, I j) {
-            { i } -> I&;
-            { i } -> I;
-        };
-
-The RandomAccess concept refines the BidirectionalIterator concept and provides support for constant-time advancement using `+=`, `+`, and `-=`, and the computation of distance in constant time using `-`. Random access iterators also support array notation via subscripting.
-
-    concept RandomAccessIterator<typename I> =
-        BidirectionalIterator<I> &&
-        TotallyOrdered<I> &&
-        Derived<IteratorCategory<I>, random_access_iterator_tag> &&
-        SignedIntegral<DistanceType<I>> &&
-        SizedIteratorRange<I, I> && // see below
-        requires advance (I i, I j, DifferenceType<I> n) {
-            { i += n } -> I&;
-            { i + n } -> I;
-            { n + i } -> I;
-            { i = n } -> I&;
-            { i  n } -> I;
-            { i[n] } -> ValueType<I>;
-        };
-
-## Iterator Range Concepts
-
-The IteratorRange concept defines a pair of types (an Iterator and a Sentinel), that can be compared for equality. This concept is the key that allows iterator ranges to be defined by pairs of types that are not the same.
-
-    concept IteratorRange<typename I, typename S> =
-        Iterator<I> &&
-        Regular<S> &&
-        EqualityComparable<I, S>;
-
-The SizedIteratorRange allows the use of the `-` operator to compute the distance between to an Iterator and a Sentinel.
-
-    concept SizedIteratorRange<typename I, typename S> =
-        IteratorRange<I, S> &&
-        requires difference (I i, S j) {
-            typename Distance_type<I>;
-            { i - i } -> Distance_type<I>;
-            { j - j } -> Distance_type<I>;
-            { i - j } -> Distance_type<I>;
-            { j - i } -> Distance_type<I>;
-            requires SignedIntegral<DifferenceType>;
-        };
-
-## Iterable Concepts
-
-This proposal introduces a new concept for describing the requirements on algorithms that require access to the `begin` and `end` of a Range or Container.
-
-    concept Iterable<typename T> =
-        requires(T t) {
-            typename IteratorType<T>;
-            typename SentinelType<T>;
-            { begin(t) } -> IteratorType<T>;
-            { end(t) } -> SentinelType<T>;
-            requires IteratorRange<IteratorType, SentinelType>;
-        }
-
-The Iterable concept requires two associated operations: `begin`, and `end`. Note that the return types of these operations are not required to be the same. The names of those return types are `IteratorType<T>` and `SentinelType<T>`, respectively. Furthermore, that pair of types must satisfy the requirements of the IteratorRange concept defined in the previous section.
-
-Iterable types have no other requirements. Most algorithms requiring this concept simply forward to an Iterator-based algorithm by calling `begin` and `end`.
-
-The Range concept refines the Iterable concept and defines a view on a range of elements that it does not own.
-
-    concept Range<typename T> =
-        Iterable<T> && Semiregular<T> && is_range<T>::value;
-
-A possible implementation of the `is_range` predicate is shown below.
-
-    // For exposition only:
-    struct range_base
-    {};
-
-    concept ContainerLike<Iterable T> =
-        !Same<decltype(*begin(declval<T &>())),
-              decltype(*begin(declval<T const &>()))>;
-
-    // For exposition only:
-    template<typename T>
-    struct is_range_impl_
-      : std::integral_constant<
-            bool,
-            Iterable<T> && (!ContainerLike<T> || Derived<T, range_base>)
-        >
-    {};
-
-    // Specialize this if the default is wrong.
-    template<typename T, typename Enable = void>
-    struct is_range
-      : conditional<
-            is_same<T, remove_const_t<remove_reference_t<T>>>::value,
-            is_range_impl_<T>,
-            is_range<remove_const_t<remove_reference_t<T>>>
-        >::type
-    {};
-
-
-Note that the "multipass" property--the property that guarantees that you can iterate the same range twice, accessing the same objects in each pass--is guaranteed by the `forward_iterator_tag` class. That is, any iterator having whose iterator category is derived from that tag class is required to be a multipass iterator.
-
-
-## Sized Iterable Concepts
-
-The `SizedIterable` concept exists for the same reasons as `SizedIteratorRange`. There are some iterables that, though they are not random-access, know their size in O(1). A prime example is `std::list`. Another example is a counted view (i.e., a range specified by an iterator and a count). Some algorithms can select a better implementation when the size of the range is known, even if the iterators don't allow random access. (One example is a `search` algorithm that knows to stop searching when there is no longer room in the input sequence for the pattern to match.)
-
-    // For exposition only:
-    concept SizedIterableLike<Iterable R> =
-        requires(R r) {
-            typename SizeType<R>;
-            { size(r) } -> SizeType<R>; // ADL customization point
-            requires Integral<SizeType>;
-        }
-
-    concept SizedIterable<SizedIterableLike R> =
-        is_sized_iterable<R>::value;
-
-Like [N4017][20][@n4017], we propose `size(r)` as a customization point for accessing the size of an Iterable. A SizedIterable requires that `size(r)` returns the same value as `distance(begin(r), end(r))` (module a possible change in the signed-ness of the Integral type). As in N4017, we suggest `size` overloads in `std::` for arrays and for class types with a `size()` member.
-
-In recognition of the fact that nominal conformance to a concept is insufficiently fine-grained, the SizedIterable concept is defined in terms of a `is_sized_iterable` trait. This is to give users explicit control in the case of accidental conformance with the syntactic requirements of the concept. A possible default implementation of the `is_sized_iterable` trait is shown below.
-
-    // For exposition only:
-    template<typename R>
-    struct is_sized_iterable_impl_
-      : std::integral_constant<
-            bool,
-            SizedIterableLike<R>
-        >
-    {};
-
-    // Specialize this if the default is wrong.
-    template<typename R>
-    struct is_sized_iterable
-      : conditional<
-            is_same<R, remove_const_t<remove_reference_t<R>>>::value,
-            is_sized_iterable_impl_<R>,
-            is_sized_iterable<remove_const_t<remove_reference_t<R>>>
-        >::type
-    {};
-
-Technical Specifications
-=====
-
-This section is intentionally left blank.
-
-Future Directions
-=====
-
-More work is necessary to get ranges into the standard. Subsequent proposals will recommend specific components for standardization as described in [Impact on the Standard](#impact-on-the-standard). In addition, below are some additional areas that are currently open for research.
-
-- Range extensions to things like regex. Make it work with null-terminated strings, e.g..
-- Discuss the pros and cons of tying this work with work on a concept-ified standard library (aka Concepts Lite TS2).
-- Discuss the pros and cons of making this (and the concept-ified standard library) *strictly* backwards compatible, versus delivering the new, conceptified and range-ified standard library in a separate, versioned namespace (and what such a solution should look like).
-- Discuss how an extension to the Concepts Lite proposal, implicit conversion to concept, bears on the Iterable/Range concepts and the way the algorithms are constrained. Also discuss how it can give a syntax to express "this function does not mutate the range elements."
-- Assess the impact of allowing ForwardIterators to return proxies.
-- Consider integrating ContiguousIterator from [N4132][18][@n4132]
-
-Acknowledgements
-=====
-
-I would like to give special thanks to Sean Parent for his advice and feedback on early designs of the range library on which this proposal is based, in addition to his work on the [Adobe Source Libraries][3][@asl] from which this proposal has borrowed liberally.
-
-Also deserving of special thanks is Andrew Sutton. His work on Concepts Lite and on the formulations of the algorithms as specified in [N3351][8][@n3351] has proven invaluable, and he has generously donated his time and expertise to expound on the ideas there and improve the quality of this proposal.
-
-Chandler Carruth has also helped more than he probably knows. I am indebted to him for his support and perspective.
-
-I would be remiss if I didn't acknowledge the foundational work of all the people whose ideas and sweat have gone into various range libraries and proposals in the past. They are too many to list, but I certainly benefited from the work of Dave Abrahams, Dietmar Khl, Neil Groves, Thorsten Ottosen, Arno Schoedl, Daniel Walker, and Jeremy Seik. Neil Groves also submitted a particularly extensive review of this document.
-
-Of course none of this work would be possible without Alex Stepanov's giant leap forward with the STL, or without Bjarne Stroustrup who gave Alex the instrument he needed to most clearly realize his vision.
-
-References
-=====
-
----
-references:
-- id: boostconceptcheck
-  title: Boost Concept Check Library
-  URL: 'http://boost.org/libs/concept_check'
-  type: webpage
-  accessed:
-    year: 2014
-    month: 10
-    day: 8
-- id: boostrange
-  title: Boost.Range Library
-  URL: 'http://boost.org/libs/range'
-  type: webpage
-  accessed:
-    year: 2014
-    month: 10
-    day: 8
-- id: asl
-  title: Adobe Source Libraries
-  URL: 'http://stlab.adobe.com'
-  type: webpage
-  accessed:
-    year: 2014
-    month: 10
-    day: 8
-- id: drange
-  title: D Phobos std.range
-  URL: 'http://dlang.org/phobos/std_range.html'
-  type: webpage
-  accessed:
-    year: 2014
-    month: 10
-    day: 8
-- id: bekennrange
-  title: Position-Based Ranges
-  URL: 'https://github.com/Bekenn/range'
-  type: webpage
-  accessed:
-    year: 2014
-    month: 10
-    day: 8
-- id: stepanov09
-  title: Elements of Programming
-  type: book
-  author:
-  - family: Stepanov
-    given: Alexander
-  - family: McJones
-    given: Paul
-  edition: 1
-  isbn: 032163537X, 9780321635372
-  issued:
-    year: 2009
-  publisher: Addison-Wesley Professional
-- id: n3351
-  title: 'N3351: A Concept Design for the STL'
-  type: article
-  author:
-  - family: Stroustrup
-    given: Bjarne
-  - family: Sutton
-    given: Andrew
-  issued:
-    year: 2012
-    month: 1
-  URL: 'http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3351.pdf'
-- id: n1873
-  title: 'N1873: The Cursor/Property Map Abstraction'
-  type: article
-  author:
-  - family: Dietmar
-    given: Khl
-  - family: Abrahams
-    given: David
-  issued:
-    year: 2005
-    month: 8
-    day: 26
-  URL: 'http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1873.html'
-- id: n3782
-  title: 'N3782: Index-Based Ranges'
-  type: article
-  author:
-  - family: Schdl
-    given: Arno
-  - family: Fracassi
-    given: Fabio
-  issued:
-    year: 2013
-    month: 9
-    day: 24
-  URL: 'http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3782.pdf'
-- id: clangmodernize
-  title: Clang Modernize
-  URL: 'http://clang.llvm.org/extra/clang-modernize.html'
-  type: webpage
-  accessed:
-    year: 2014
-    month: 10
-    day: 8
-- id: new-iter-concepts
-  title: New Iterator Concepts
-  URL: 'http://www.boost.org/libs/iterator/doc/new-iter-concepts.html'
-  type: webpage
-  accessed:
-    year: 2014
-    month: 10
-    day: 8
-- id: universal-references
-  title: Universal References in C++11
-  URL: 'http://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers'
-  type: webpage
-  accessed:
-    year: 2014
-    month: 10
-    day: 8
-- id: range-comprehensions
-  title: Range Comprehensions
-  URL: 'http://ericniebler.com/2014/04/27/range-comprehensions/'
-  type: webpage
-  accessed:
-    year: 2014
-    month: 10
-    day: 8
-- id: n4132
-  title: 'N4132: Contiguous Iterators'
-  type: article
-  author:
-  - family: Maurer
-    given: Jens
-  issued:
-    year: 2014
-    month: 9
-    day: 10
-  accessed:
-    year: 2014
-    month: 10
-    day: 8
-  URL: 'https://isocpp.org/files/papers/n4132.html'
-- id: ntcts-iterator
-  title: NTCTS Iterator
-  URL: 'https://github.com/Beman/ntcts_iterator'
-  type: webpage
-  accessed:
-    year: 2014
-    month: 10
-    day: 8
-- id: range-v3
-  title: Range v3
-  URL: 'http://www.github.com/ericniebler/range-v3'
-  type: webpage
-  accessed:
-    year: 2014
-    month: 10
-    day: 8
-- id: llvm-sroa
-  title: 'Debug info: Support fragmented variables'
-  URL: 'http://reviews.llvm.org/D2680'
-  type: webpage
-  accessed:
-    year: 2014
-    month: 10
-    day: 8
-- id: libcxx
-  title: 'libc++ C++ Standard Library'
-  URL: 'http://libcxx.llvm.org/'
-  type: webpage
-  accessed:
-    year: 2014
-    month: 10
-    day: 8
-- id: austern98
-  title: 'Segmented Iterators and Hierarchical Algorithms'
-  URL: 'http://dl.acm.org/citation.cfm?id=647373.724070'
-  author:
-  - family: Austern
-    given: Matthew
-  type: paper-conference
-  container-title: Selected Papers from the International Seminar on Generic Programming
-  page: 80-90
-  issued:
-    year: 2000
-- id: cpp-seasoning
-  title: 'C++ Seasoning'
-  author:
-  - family: Parent
-    given: Sean
-  type: speech
-  URL: 'https://github.com/sean-parent/sean-parent.github.com/wiki/presentations/2013-09-11-cpp-seasoning/cpp-seasoning.pdf'
-  container-title: 'GoingNative 2013'
-  issued:
-    year: 2013
-    month: 9
-    day: 11
-- id: muchnick97
-  title: 'Advanced Compiler Design Implementation'
-  author:
-  - family: Muchnick
-    given: Steven
-  publisher: 'Morgan Kaufmann'
-  issued:
-    year: 1997
-  isbn: '1558603204, 9781558603202'
-- id: n4017
-  title: 'N4017: Non-member size() and more'
-  type: article
-  author:
-  - family: Marcangelo
-    given: Riccardo
-  issued:
-    year: 2014
-    month: 5
-    day: 22
-  accessed:
-    year: 2014
-    month: 10
-    day: 10
-  URL: 'http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4017.htm'
-- id: n3350
-  title: 'N3350: A minimal std::range<Iter>'
-  type: article
-  author:
-  - family: Yasskin
-    given: Jeffrey
-  issued:
-    year: 2012
-    month: 1
-    day: 16
-  accessed:
-    year: 2014
-    month: 10
-    day: 10
-    URL: 'http://www.open-std.org/Jtc1/sc22/wg21/docs/papers/2012/n3350.html'
-...
-
-[1]: http://boost.org/libs/concept_check "Boost Concept Check Library"
-[2]: http://www.boost.org/libs/range "Boost.Range"
-[3]: http://stlab.adobe.com/ "Adobe Source Libraries"
-[4]: http://dlang.org/phobos/std_range.html "D Phobos std.range"
-[5]: https://github.com/Bekenn/range "Position-Based Ranges"
-[6]: https://github.com/sean-parent/sean-parent.github.com/wiki/presentations/2013-09-11-cpp-seasoning/cpp-seasoning.pdf "C++ Seasoning, Sean Parent"
-[7]: http://www.github.com/ericniebler/range-v3 "Range v3"
-[8]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3351.pdf "A Concept Design for the STL"
-[9]: http://www.boost.org/libs/iterator/doc/new-iter-concepts.html "New Iterator Concepts"
-[10]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3782.pdf "Indexed-Based Ranges"
-[11]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1873.html "The Cursor/Property Map Abstraction"
-[12]: http://ericniebler.com/2014/04/27/range-comprehensions/ "Range Comprehensions"
-[13]: http://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers "Universal References in C++11"
-[14]: http://lafstern.org/matt/segmented.pdf "Segmented Iterators and Hierarchical Algorithms"
-[15]: http://reviews.llvm.org/D2680 "Debug info: Support fragmented variables."
-[16]: http://clang.llvm.org/extra/clang-modernize.html "Clang Modernize"
-[17]: http://libcxx.llvm.org/ "libc++ C++ Standard Library"
-[18]: https://isocpp.org/files/papers/n4132.html "Contiguous Iterators"
-[19]: https://github.com/Beman/ntcts_iterator "ntcts_iterator"
-[20]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4017.htm "Non-member size() and more"
-[21]: http://www.open-std.org/Jtc1/sc22/wg21/docs/papers/2012/n3350.html "A minimal std::range<Iter>"
-
-Appendix 1: Sentinels and Code Generation
-=====
-
-In this appendix we explore the effect of sentinels on code generation. I'll show that allowing the type of the end iterator to differ from the begin can have a positive effect on the performance of algorithms. First, I'll note that nothing that can be done with sentinels cannot also be done with appropriately designed end iterators. Here, for instance, is the code for an iterator that can be used to adapt a null-terminated string to the STL. It is implemented with the help of the Boost.Iterators library:
-
-    #include <cassert>
-    #include <iostream>
-    #include <boost/iterator/iterator_facade.hpp>
-
-    struct c_string_range
-    {
-    private:
-        char const *str_;
-    public:
-        using const_iterator = struct iterator
-          : boost::iterator_facade<
-                iterator
-              , char const
-              , std::forward_iterator_tag
-            >
-        {
-        private:
-            friend class boost::iterator_core_access;
-            friend struct c_string_range;
-            char const * str_;
-            iterator(char const * str)
-              : str_(str)
-            {}
-            bool equal(iterator that) const
-            {
-                return str_
-                    ? (that.str_ == str_ ||
-                         (!that.str_ && !*str_))
-                    : (!that.str_ || !*that.str_);
-            }
-            void increment()
-            {
-                assert(str_ && *str_);
-                ++str_;
-            }
-            char const& dereference() const
-            {
-                assert(str_ && *str_);
-                return *str_;
-            }
-        public:
-            iterator()
-              : str_(nullptr)
-            {}
-        };
-        c_string_range(char const * str)
-          : str_(str)
-        {
-            assert(str_);
-        }
-        iterator begin() const
-        {
-            return iterator{str_};
-        }
-        iterator end() const
-        {
-            return iterator{};
-        }
-        explicit operator bool() const
-        {
-            return !!*str_;
-        }
-    };
-
-    int c_strlen(char const *sz)
-    {
-        int i = 0;
-        for(; *sz; ++sz)
-            ++i;
-        return i;
-    }
-
-    int range_strlen(
-        c_string_range::iterator begin,
-        c_string_range::iterator end)
-    {
-        int i = 0;
-        for(; begin != end; ++begin)
-            ++i;
-        return i;
-    }
-
-The code traverses the sequence of characters without first computing its end. It does it by creating a dummy end iterator such that any time a real iterator is compared to it, it checks to see if the real iterator points to the null terminator. All the comparison logic is in the `c_string_range::iterator::equal` member function.
-
-The functions `c_strlen` and `range_strlen` implement equivalent procedures for computing the length of a string, the first using raw pointers and a check for the null terminator, the second using `c_string_range`'s STL iterators. The resulting optimized assembly code (clang 3.4 -O3 -DNDEBUG) generated for the two functions highlights the lost optimization opportunities.
-
-<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="607">
-<tr><td><pre><code>c_strlen</code></pre></td><td><pre><code>range_strlen</code></pre></td></tr>
-<tr><td valign="top"><pre><code>    pushl   %ebp
-    movl    %esp, %ebp
-    movl    8(%ebp), %ecx
-    xorl    %eax, %eax
-    cmpb    $0, (%ecx)
-    je      LBB1_3
-    xorl    %eax, %eax
-    .align  16, 0x90
-LBB1_2:
-    cmpb    $0, 1(%ecx,%eax)
-    leal    1(%eax), %eax
-    jne     LBB1_2
-LBB1_3:
-    popl    %ebp
-    ret</code></pre></td><td><pre><code>    pushl   %ebp
-    movl    %esp, %ebp
-    pushl   %esi
-    leal    8(%ebp), %ecx
-    movl    12(%ebp), %esi
-    xorl    %eax, %eax
-    testl   %esi, %esi
-    movl    8(%ebp), %edx
-    jne     LBB2_4
-    jmp     LBB2_1
-    .align  16, 0x90
-LBB2_8:
-    incl    %eax
-    incl    %edx
-    movl    %edx, (%ecx)
-LBB2_4:
-    testl   %edx, %edx
-    jne     LBB2_5
-    cmpb    $0, (%esi)
-    jne     LBB2_8
-    jmp     LBB2_6
-    .align  16, 0x90
-LBB2_5:
-    cmpl    %edx, %esi
-    jne     LBB2_8
-    jmp     LBB2_6
-    .align  16, 0x90
-LBB2_3:
-    leal    1(%edx,%eax), %esi
-    incl    %eax
-    movl    %esi, (%ecx)
-LBB2_1:
-    movl    %edx, %esi
-    addl    %eax, %esi
-    je      LBB2_6
-    cmpb    $0, (%esi)
-    jne     LBB2_3
-LBB2_6:
-    popl    %esi
-    popl    %ebp
-    ret</code></pre></td></tr>
-</table>
-
-Code like `c_string_range` exists in the wild; for instance, see [Beman Dawes' `ntcts_iterator`][19][@ntcts-iterator]. But more typically, when users want to use an STL algorithm on a C-style string, they call `strlen` to find the end first (this is what the standard regex algorithms do when passed C-style strings). That traverses the string an extra time needlessly. Also, such a trick is not possible for input sequences like those traversed by `std::istream_iterator` that consume their input.
-
-Rather than mocking up a dummy end iterator with a computationally expensive equality comparison operation, we can use a sentinel type that encodes end-ness in its type. Below is an example from the [Range-v3 library][7][@range-v3], which uses a `range_facade` class template to generate iterators and sentinels from a simple range-like interface:
-
-    using namespace ranges;
-    struct c_string_iterable
-      : range_facade<c_string_iterable>
-    {
-    private:
-        friend range_access;
-        char const *sz_;
-        char const & current() const { return *sz_; }
-        void next() { ++sz_; }
-        bool done() const { return *sz_ == 0; }
-        bool equal(c_string_iterable const &that) const
-        { return sz_ == that.sz_; }
-    public:
-        c_string_iterable() = default;
-        c_string_iterable(char const *sz)
-            : sz_(sz) {}
-    };
-
-    // Iterable-based
-    int iterable_strlen(
-        range_iterator_t<c_string_iterable> begin,
-        range_sentinel_t<c_string_iterable> end)
-    {
-        int i = 0;
-        for(; begin != end; ++begin)
-            ++i;
-        return i;
-    }
-
-The assembly generated for `iterable_strlen` is nearly identical to that for the hand-coded `c_strlen`:
-
-<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="607">
-<tr><td><pre><code>c_strlen</code></pre></td><td><pre><code>iterable_strlen</code></pre></td></tr>
-<tr><td valign="top"><pre><code>    pushl   %ebp
-    movl    %esp, %ebp
-    movl    8(%ebp), %ecx
-    xorl    %eax, %eax
-    cmpb    $0, (%ecx)
-    je      LBB1_3
-    xorl    %eax, %eax
-    .align  16, 0x90
-LBB1_2:
-    cmpb    $0, 1(%ecx,%eax)
-    leal    1(%eax), %eax
-    jne     LBB1_2
-
-
-LBB1_3:
-    popl    %ebp
-    ret</code></pre></td><td><pre><code>    pushl   %ebp
-    movl    %esp, %ebp
-    movl    8(%ebp), %ecx
-    xorl    %eax, %eax
-    cmpb    $0, (%ecx)
-    je      LBB1_4
-    leal    8(%ebp), %edx
-    .align  16, 0x90
-LBB1_2:
-    cmpb    $0, 1(%ecx,%eax)
-    leal    1(%eax), %eax
-    jne     LBB1_2
-    addl    %eax, %ecx
-    movl    %ecx, (%edx)
-LBB1_4:
-    popl    %ebp
-    ret</code></pre></td></tr>
-</table>
-
-The generated code for `iterable_strlen` is better than for `range_strlen` because the sentinel has a different type than the iterator, so that the expression `begin != end` can be optimized into `*begin == 0`. In `range_strlen`, `begin == end` is comparing two objects of the same type, and since either `begin` or `end` could be a sentinel -- or both, or neither -- the compiler can't elide the extra checks without extra information from the surrounding calling context, which isn't always available; hence, the worse code gen.
-
-In addition to the performance impact, the complexity of implementing a correct `operator==` for an iterator with a dummy sentinel can present problems. Chandler Carruth reports that such comparison operators have been a rich source of bugs for Google.
-
-Appendix 2: Sentinels, Iterators, and the Cross-Type EqualityComparable Concept
-=====
-
-This appendix describes the theoretical justification for sentinels from the perspective of the STL concepts as set out in [N3351][8][@n3351]. In that paper, the foundational concept EqualityComparable is described in depth, not only its syntactic constraints but also its semantic axioms. It is not enough that the syntax `a == b` compiles. It has to be a meaningful comparison. Here I explain why I believe it is meaningful to compare an iterator with a sentinel of a different type for equality.
-
-In the expression `x == y`, where `x` and `y` have different types, the EqualityComparable concept requires that the types of both `x` and `y` must themselves be EqualityComparable, and there must be a common type to which they can both be converted, and that type must also be EqualityComparable. Think of comparing a `char` with a `short`. It works because both `char` and `short` are EqualityComparable, and because they can both be converted to an `int` which is also EqualityComparable.
-
-Iterators are comparable, and sentinels are trivially comparable (they always compare equal). The tricky part is the common type requirement. Logically, every iterator/sentinel pair has a common type that can be constructed as follows: assume the existence of a new iterator type `I` that is a tagged union that contains *either* an iterator *or* a sentinel. When an iterator is compared to a sentinel, it behaves semantically as if both the iterator and the sentinel were first converted to two objects of type `I`  call them `lhs` and `rhs`  and then compared according to the following truth table:
-
-LHS IS SENTINEL ? | RHS IS SENTINEL ? | LHS == RHS ?
------------------ | ----------------- | ------------
-`true`            | `true`            | `true`<sup>[\[*\]](#sentinel-equality "Sentinel Equality")</sup>
-`true`            | `false`           | `done(rhs.iter)`
-`false`           | `true`            | `done(lhs.iter)`
-`false`           | `false`           | `lhs.iter == rhs.iter`
-
-In [Appendix 1](#appendix-1-sentinels-and-code-generation), there is an implementation of `c_string_range` whose iterator's `operator==` is a procedure for evaluating this truth table. Thats no coincidence; that was a special case of this more general construction.
-
-In summary, for every iterator/sentinel pair, we can construct a common iterator type that implements an equivalent procedure for computing equality. The existence of this common type is what allows iterator/sentinel pairs to satisfy the EqualityComparable requirement.
-
-As a final note, the Range v3 library has a general implementation of this common iterator type as a parametrized type, and appropriate specializations of `std::common_type` that allow the constrained algorithms to type-check correctly. It works well in practice, both for the purpose of type-checking the algorithms and for adapting ranges with iterator/sentinel pairs to old code that expects the begin and end of a range to have the same type.
-
-## Sentinel Equality
-
-The first line of table above shows that sentinels always compare equal -- regardless of their state. This can seem unintuitive in some situations. For instance:
-
-    auto s = "Hello World!?";
-    // Hypothetical range-like facilities for exposition only:
-    auto r1 = make_range( &s[0], equal_to('!') );
-    auto r2 = make_range( &s[0], equal_to('?') );
-    // 'end()' returns each 'equal_to' sentinel object:
-    assert(r1.end() == r2.end() && "really?");
-
-In the above example, it's clear that `r1.end()` and `r2.end()` are referring to different elements, and that's reflected in their having different state. So shouldn't sentinel equality be a stateful comparison?
-
-It's incorrect to think of sentinels as objects whose position is determined by their value. Thinking that way leads to logical inconsistencies. It's not hard to define sentinels that -- if you consider their state during comparison -- compare equal when they represent a different position, and not equal when they represent the same position. Consider:
-
-    auto s = "hello! world!";
-    auto r1 = make_range( &s[0], equal_to('!') );
-    auto r2 = make_range( &s[7], equal_to('!') );
-
-    assert(r1.end() == r2.end() && "really?");
-
-In the above code, although the sentinels have the same type and the same state, they refer to different elements.
-
-Also imagine a counted iterator that stores an underlying iterator and a count that starts at zero. It's paired with a sentinel that contains an ending count:
-
-    auto s = "hello";
-    // Hypothetical range-like facilities for exposition only:
-    auto r1 = make_range( counting(&s[0]), end_count(5) );
-    auto r2 = make_range( counting(&s[1]), end_count(4) );
-
-    assert(r1.end() != r2.end() && "really?");
-
-The end sentinels have the same type and different state, but they refer to the same element.
-
-The question then is: What does it *mean* to compare sentinels for equality? The meaning has to be taken from the context in which the operation appears. In that context -- the algorithms -- the sentinel is one of two positions denoting a range.
-
-Iterator comparison is a position comparison. A sentinel, when it's paired with an iterator as in the algorithms, denotes a unique position. Since iterators must be valid sentinels, comparing sentinels should also be a position comparison. In this context, sentinels always represent the same position -- the end -- even though that position is not yet know. Hence, sentinels compare equal always, without any need to consider state. Anything else yields results that are inconsistent with the use of iterators to denote the end of a range.
-
-What about the examples above where sentinel comparison seems to give nonsensical results? In those examples, we are expecting sentinels to have meaning outside of their valid domain -- when they are considered in isolation of their paired iterator. It is the paired iterator that give the sentinel its "unique-position-ness", so we shouldn't expect an operation that compares position to make sense on an object that is not capable of representing a position by itself.
-
-Appendix 3: D Ranges and Algorithmic Complexity
-=====
-
-As currently defined, D's ranges make it difficult to implement algorithms over bidirectional sequences that take a position in the middle as an argument. A good example is a hypothetical `is_word_boundary` algorithm. In C++ with iterators, it might look like this:
-
-    template< BidirectionalIterator I >
-    bool is_word_boundary( I begin, I middle, I end )
-    {
-        bool is_word_prev = middle == begin ? false : isword(*prev(middle));
-        bool is_word_this = middle == end ? false : isword(*middle);
-        return is_word_prev != is_word_this;
-    }
-
-Users might call this in a loop to find the first word boundary in a range of characters as follows:
-
-    auto i = myrange.begin();
-    for( ; i != myrange.end(); ++i )
-        if( is_word_boundary( myrange.begin(), i, myrange.end() ) )
-            break;
-
-The question is how such an API should be designed in D, since D doesn't have iterators. In a private email exchange, Andrei Alexandrescu, the designer of D's range library, described this potential implementation (the detailed implementation is ours):
-
-    bool is_word_boundary(Range1, Range2)( Range1 front, Range2 back )
-        if (isBidirectionalRange!Range1 && isInputRange!Range2 )
-    {
-        bool is_word_prev = front.empty ? false : isword(front.back);
-        bool is_word_this = back.empty ? false : isword(back.front);
-        return is_word_prev != is_word_this;
-    }
-
-    range r = myrange;
-    size_t n = 0;
-    for(range r = myrange; !r.empty; r.popFront(), ++n)
-         if( is_word_boundary( takeExactly(myrange, n), r) )
-            break;
-
-This example uses D's `takeExactly` range adaptor. `takeExactly` is like Haskell's `take` function which creates a list from another list by taking the first `n` elements, but `takeExactly` requires that the input range has at least `n` elements begin with.
-
-The trouble with the above implementation is that `takeExactly` demotes Bidirectional ranges to Forward ranges. For example, taking the first *N* elements of a linked list cannot give access to the final element in O(1). So the `for` loop is trying to pass a Forward range to an algorithm that clearly requires a Bidirectional range. The only fix is to loosen the requirements of `Range1` to be Forward. To do that, the implementation of `is_word_boundary` needs to change so that, when it is passed a Forward range, it walks to the end of the `front` range and tests the last character. Obviously, that's an O(N) operation.
-
-In other words, by converting the `is_word_boundary` from iterators to D-style ranges, the algorithm goes from O(1) to O(N). From this we draw the following conclusion: D's choice of algorithmic *basis operations* is inherently less efficient than C++'s.
-
-Appendix 4: On Counted Ranges and Efficiency
-=====
-
-The three types of ranges that we would like the Iterable concept to be able to efficiently model are:
-
-1. Two iterators
-2. An iterator and a predicate
-3. An iterator and a count
-
-The Iterator/Sentinel abstraction is what makes it possible for the algorithms to handle these three cases with uniform syntax. However, the third option presents challenges when trying to make some algorithms optimally efficient.
-
-Counted ranges, formed by specifying a position and a count of elements, have iterators -- as all Iterables do. The iterators of a counted range must know the range's extent and how close they are to reaching it. Therefore, the counted range's iterators must store both an iterator into the underlying sequence and a count -- either a count to the end or a count from the front. Here is one potential design:
-
-    class counted_sentinel
-    {};
-
-    template<WeakIterator I>
-    class counted_iterator
-    {
-        I it_;
-        DistanceType<I> n_; // distance to end
-    public:
-        // ... constructors...
-        using iterator_category =
-            typename iterator_traits<I>::iterator_category;
-        decltype(auto) operator*() const
-        {
-            return *it_;
-        }
-        counted_iterator & operator++()
-        {
-            ++it_;
-            --n_;
-            return *this;
-        }
-        friend bool operator==(counted_iterator const & it,
-                               counted_sentinel)
-        {
-            return it.n_ == 0;
-        }
-        // ... other operators...
-    };
-
-    template<WeakIterator I>
-    class counted_range
-    {
-        I begin_;
-        DistanceType<I> count_;
-    public:
-        // ... constructors ...
-        counted_iterator<I> begin() const
-        {
-            return {begin_, count_};
-        }
-        counted_sentinel end() const
-        {
-            return {};
-        }
-    };
-
-    template<WeakIterator I>
-    struct common_type<counted_iterator<I>, counted_sentinel>
-        // ... see Appendix 2 ...
-
-There are some noteworthy things about the code above. First, `counted_iterator` bundles an iterator and a count. Right off, we see that copying counted iterators is going to be more expensive, and iterators are copied frequently. A mitigating factor is that the sentinel is empty. Passing a `counted_iterator` and a `counted_sentinel` to an algorithm copies as much data as passing an iterator and a count. When passed separately, the compiler probably has an easier time fitting them in registers, but some modern compilers are capable passing the members of a struct in registers. This compiler optimization is sometimes called Scalar Replacement of Aggregates (see Muchnick 1997, ch. 12.2 [@muchnick97]) and is known to be implemented in gcc and LLVM (see [this recent LLVM commit][15][@llvm-sroa] for example).
-
-Also, incrementing a counted iterator is expensive: it involves incrementing the underlying iterator and decrementing the internal count. To see why this is potentially expensive, consider the trivial case of passing a `counted_iterator<list<int>::iterator>` to `advance`. That counted iterator type is bidirectional, and `advance` must increment it *n* times:
-
-    template<BidirectionalIterator I>
-    void advance(I & i, DistanceType<I> n)
-    {
-        if(n >= 0)
-            for(; n != 0; --n)
-                ++i;
-        else
-            for(; n != 0; ++n)
-                --i;
-    }
-
-Notice that for each `++i` or `--i` here, *two* increments or decrements are happening when `I` is a `counted_iterator`. This is sub-optimal. A better implementation for `counted_iterator` is:
-
-    template<BidirectionalIterator I>
-    void advance(counted_iterator<I> & i, DistanceType<I> n)
-    {
-        i.n_ -= n;
-        advance(i.it_, n);
-    }
-
-This has a noticeable effect on the generated code. As it turns out, `advance` is one of the relatively few places in the standard library where special handling of `counted_iterator` is advantageous. Let's examine some algorithms to see why that's the case.
-
-## Single-Pass Algorithms with Counted Iterators
-
-First, let's look at a simple algorithm like `for_each` that makes exactly one pass through its input sequence:
-
-    template<InputIterator I, Regular S, Function<ValueType<I>> F>
-        requires EqualityComparable<I, S>
-    I for_each(I first, S last, F f)
-    {
-        for(; first != last; ++first)
-            f(*first);
-        return first;
-    }
-
-When passed counted iterators, at each iteration of the loop, we do an increment, a decrement (for the underlying iterator and the count), and a comparison. Let's compare this against a hypothetical `for_each_n` algorithm that takes the underlying iterator and the count separately. It might look like this:
-
-    template<InputIterator I, Function<ValueType<I>> F>
-    I for_each_n(I first, DifferenceType<I> n, F f)
-    {
-        for(; n != 0; ++first, --n)
-            f(*first);
-        return first;
-    }
-
-For the hypothetical `for_each_n`, at each loop iteration, we do an increment, a decrement, and a comparison. That's exactly as many operations as `for_each` does when passed counted iterators. So a separate `for_each_n` algorithm is probably unnecessary if we have sentinels and `counted_iterator`s. This is true for any algorithm that makes only one pass through the input range. That turns out to be a lot of algorithms.
-
-## Multi-Pass Algorithms with Counted Iterators
-
-There are other algorithms that make more than one pass over the input sequence. Most of those, however, use `advance` when they need to move iterators by more than one hop. Once we have specialized `advance` for `counted_iterator`, those algorithms that use `advance` get faster without any extra work.
-
-Consider `partition_point`. Here is one example implementation, taken from [libc++][17][@libcxx] and ported to Concepts Lite and sentinels:
-
-    template<ForwardIterator I, Regular S, Predicate<ValueType<I>> P>
-        requires EqualityComparable<I, S>
-    I partition_point(I first, S last, P pred)
-    {
-        DifferenceType<I> len = distance(first, last);
-        while (len != 0)
-        {
-            DifferenceType<I> l2 = len / 2;
-            I m = first;
-            advance(m, l2);
-            if (pred(*m))
-            {
-                first = ++m;
-                len -= l2 + 1;
-            }
-            else
-                len = l2;
-        }
-        return first;
-    }
-
-Imagine that `I` is a forward `counted_iterator` and `S` is a `counted_sentinel`. If the library does not specialize `advance`, this is certainly inefficient. Every time `advance` is called, needless work is being done. Compare it to a hypothetical `partition_point_n`:
-
-    template<ForwardIterator I, Predicate<ValueType<I>> P>
-    I partition_point_n(I first, DifferenceType<I> len, P pred)
-    {
-        while (len != 0)
-        {
-            DifferenceType<I> l2 = len / 2;
-            I m = first;
-            advance(m, l2);
-            if (pred(*m))
-            {
-                first = ++m;
-                len -= l2 + 1;
-            }
-            else
-                len = l2;
-        }
-        return first;
-    }
-
-The first thing we notice is that `partition_point_n` doesn't need to call `distance`! The more subtle thing to note is that calling `partition_point_n` with a raw iterator and a count saves about O(N) integer decrements over the equivalent call to `partition_point` with `counted_iterator`s ... unless, of course, we have specialized the `advance` algorithm as shown above. Once we have, we trade the O(N) integer decrements for O(log N) integer subtractions. That's a big improvement.
-
-But what about the O(N) call to `distance`? Actually, that's easy, and it's the reason why the SizedIteratorRange concept exists. `counted_iterator` stores the distance to the end. So the distance between a `counted_iterator` and a `counted_sentinel` (or between two `counted_iterators`) is known in O(1) *regardless of the iterator's category*. The SizedIteratorRange concept tests whether an iterator `I` and a sentinel `S` can be subtracted to get the distance. This concept is modeled by random-access iterators by their nature, but also by counted iterators and their sentinels. The `distance` algorithm is specialized for SizedIteratorRange, so it is O(1) for counted iterators.
-
-With these changes, we see that `partition_point` with counted iterators is very nearly as efficient as a hypothetical `partition_point_n` would be, and we had to make no special accommodations. Why can't we make `partition_point` *exactly* as efficient as `partition_point_n`? When `partition_point` is called with a counted iterator, it also *returns* a counted iterator. Counted iterators contain two datums: the position and distance to the end. But when `partition_point_n` returns just the position, it is actually computing and returning less information. Sometimes users don't need the extra information. But sometimes, after calling `partition_point_n`, the user might want to pass the resulting iterator to another algorithm. If *that* algorithm calls `distance` (like `partition_point` and other algorithms do), then it will be O(N). With counted iterators, however, it's O(1). So in the case of `partition_point`, counted iterators cause the algorithm to do O(log N) extra work, but it sometimes saves O(N) work later.
-
-To see an example, imagine a trivial `insertion_sort` algorithm:
-
-    template<ForwardIterator I, Regular S>
-        requires EqualityComparable<I, S> && Sortable<I> // from N3351
-    void insertion_sort(I begin, S end)
-    {
-        for(auto it = begin; it != end; ++it)
-        {
-            auto insertion = upper_bound(begin, it, *it);
-            rotate(insertion, it, next(it));
-        }
-    }
-
-Imagine that `I` is a `counted_iterator`. The first thing `upper_bound` does is call `distance`. Making `distance` O(1) for `counted_iterator`s saves N calls of an O(N) algorithm. To get comparable performance for an equivalent procedure in today's STL, users would have to write a separate `insertion_sort_n` algorithm that dispatches to an `upper_bound_n` algorithm -- that they would also need to write themselves.
-
-## Counted Algorithms with Counted Iterators
-
-We've seen that regular algorithms with counted iterators can be made nearly as efficient as dedicated counted algorithms, and that sometimes we are more than compensated for the small performance loss. All is not roses, however. There are a number of *counted algorithms* in the standard (the algorithms whose names end with `_n`). Consider `copy_n`:
-
-    template<WeakInputIterator I, WeakOutputIterator<ValueType<I>> O>
-    pair<I, O> copy_n(I in, DifferenceType<I> n, O out)
-    {
-        for(; n != 0; ++in, ++out, --n)
-            *out = *in;
-        return {in, out};
-    }
-
-(We've changed the return type of `copy_n` so as not to lose information.) If `I` is a counted iterator, then for every `++in`, an increment and a decrement are happening, and in this case the extra decrement is totally unnecessary. For *any* counted (i.e., `_n`) algorithm, something special needs to be done to keep the performance from degrading when passed counted iterators.
-
-The algorithm author has two options here, and neither of them is ideal.
-
-**Option 1: Overload the algorithm**
-
-The following is an optimized version of `copy_n` for counted iterators:
-
-    template<WeakInputIterator I, WeakOutputIterator<ValueType<I>> O>
-    pair<I, O> copy_n(counted_iterator<I> in, DifferenceType<I> n, O out)
-    {
-        for(auto m = in.n_ - n; in.n_ != m; ++in.i_, --in.n_, ++out)
-            *out = *in;
-        return {in, out};
-    }
-
-Obviously, creating an overload for counted iterators is unsatisfying.
-
-**Option 2: Separate the iterator from the count**
-
-This option shows how a library implementer can write just one version of `copy_n` that is automatically optimized for counted iterators. First, we need to provide two utility functions for unpacking and repacking counted iterators:
-
-    template<WeakIterator I>
-    I uncounted(I i)
-    {
-        return i;
-    }
-
-    template<WeakIterator I>
-    I uncounted(counted_iterator<I> i)
-    {
-        return i.it_;
-    }
-
-    template<WeakIterator I>
-    I recounted(I const &, I i, DifferenceType<I>)
-    {
-        return i;
-    }
-
-    template<WeakIterator I>
-    counted_iterator<I> recounted(counted_iterator<I> const &j, I i, DifferenceType<I> n)
-    {
-        return {i, j.n_ - n};
-    }
-
-With the help of `uncounted` and `recounted`, we can write an optimized `copy_n` just once:
-
-    template<WeakInputIterator I, WeakOutputIterator<ValueType<I>> O>
-    pair<I, O> copy_n(I in_, DifferenceType<I> n_, O out)
-    {
-        auto in = uncounted(in_);
-        for(auto n = n_; n != 0; ++in, --n, ++out)
-            *out = *in;
-        return {recounted(in_, in, n_), out};
-    }
-
-This version works optimally for both counted and non-counted iterators. It is not a thing of beauty, however. It's slightly annoying to have to do the `uncounted`/`recounted` dance, but it's mostly needed only in the counted algorithms.
-
-As a final note, the overload of `advance` for counted iterators can be eliminated with the help of `uncounted` and `recounted`. After all, `advance` is a counted algorithm.
-
-## Benchmark: Insertion Sort
-
-To test how expensive counted ranges and counted iterators are, we wrote a benchmark. The benchmark program pits counted ranges against a dedicated `_n` algorithm for [Insertion Sort](http://en.wikipedia.org/wiki/Insertion_sort).
-
-The program is listed below:
-
-    #include <chrono>
-    #include <iostream>
-    #include <range/v3/range.hpp>
-
-    class timer
-    {
-    private:
-        std::chrono::high_resolution_clock::time_point start_;
-    public:
-        timer()
-        {
-            reset();
-        }
-        void reset()
-        {
-            start_ = std::chrono::high_resolution_clock::now();
-        }
-        std::chrono::milliseconds elapsed() const
-        {
-            return std::chrono::duration_cast<std::chrono::milliseconds>(
-                std::chrono::high_resolution_clock::now() - start_);
-        }
-        friend std::ostream &operator<<(std::ostream &sout, timer const &t)
-        {
-            return sout << t.elapsed().count() << "ms";
-        }
-    };
-
-    template<typename It>
-    struct forward_iterator
-    {
-        It it_;
-
-        template<typename U>
-        friend struct forward_iterator;
-    public:
-        typedef          std::forward_iterator_tag                 iterator_category;
-        typedef typename std::iterator_traits<It>::value_type      value_type;
-        typedef typename std::iterator_traits<It>::difference_type difference_type;
-        typedef It                                                 pointer;
-        typedef typename std::iterator_traits<It>::reference       reference;
-
-        forward_iterator() : it_() {}
-        explicit forward_iterator(It it) : it_(it) {}
-
-        reference operator*() const {return *it_;}
-        pointer operator->() const {return it_;}
-
-        forward_iterator& operator++() {++it_; return *this;}
-        forward_iterator operator++(int)
-            {forward_iterator tmp(*this); ++(*this); return tmp;}
-
-        friend bool operator==(const forward_iterator& x, const forward_iterator& y)
-            {return x.it_ == y.it_;}
-        friend bool operator!=(const forward_iterator& x, const forward_iterator& y)
-            {return !(x == y);}
-    };
-
-    template<typename I, typename V2>
-    I upper_bound_n(I begin, typename std::iterator_traits<I>::difference_type d, V2 const &val)
-    {
-        while(0 != d)
-        {
-            auto half = d / 2;
-            auto middle = std::next(begin, half);
-            if(val < *middle)
-                d = half;
-            else
-            {
-                begin = ++middle;
-                d -= half + 1;
-            }
-        }
-        return begin;
-    }
-
-    template<typename I>
-    void insertion_sort_n(I begin, typename std::iterator_traits<I>::difference_type n)
-    {
-        auto m = 0;
-        for(auto it = begin; m != n; ++it, ++m)
-        {
-            auto insertion = upper_bound_n(begin, m, *it);
-            ranges::rotate(insertion, it, std::next(it));
-        }
-    }
-
-    template<typename I, typename S>
-    void insertion_sort(I begin, S end)
-    {
-        for(auto it = begin; it != end; ++it)
-        {
-            auto insertion = ranges::upper_bound(begin, it, *it);
-            ranges::rotate(insertion, it, std::next(it));
-        }
-    }
-
-    template<typename Rng>
-    void insertion_sort(Rng && rng)
-    {
-        ::insertion_sort(std::begin(rng), std::end(rng));
-    }
-
-    std::unique_ptr<int[]> data(int i)
-    {
-        std::unique_ptr<int[]> a(new int[i]);
-        auto rng = ranges::view::counted(a.get(), i);
-        ranges::iota(rng, 0);
-        return a;
-    }
-
-    void shuffle(int *a, int i)
-    {
-        auto rng = ranges::view::counted(a, i);
-        ranges::random_shuffle(rng);
-    }
-
-    constexpr int cloops = 3;
-
-    template<typename I>
-    void benchmark_n(int i)
-    {
-        auto a = data(i);
-        long ms = 0;
-        for(int j = 0; j < cloops; ++j)
-        {
-            ::shuffle(a.get(), i);
-            timer t;
-            insertion_sort_n(I{a.get()}, i);
-            ms += t.elapsed().count();
-        }
-        std::cout << (int)((double)ms/cloops) << std::endl;
-    }
-
-    template<typename I>
-    void benchmark_counted(int i)
-    {
-        auto a = data(i);
-        long ms = 0;
-        for(int j = 0; j < cloops; ++j)
-        {
-            ::shuffle(a.get(), i);
-            timer t;
-            insertion_sort(ranges::view::counted(I{a.get()}, i));
-            ms += t.elapsed().count();
-        }
-        std::cout << (int)((double)ms/cloops) << std::endl;
-    }
-
-    int main(int argc, char *argv[])
-    {
-        if(argc < 2)
-            return -1;
-
-        int i = std::atoi(argv[1]);
-        std::cout << "insertion_sort_n (random-access) : ";
-        benchmark_n<int*>(i);
-        std::cout << "insertion_sort   (random-access) : ";
-        benchmark_counted<int*>(i);
-        std::cout << "\n";
-        std::cout << "insertion_sort_n (forward)       : ";
-        benchmark_n<forward_iterator<int*>>(i);
-        std::cout << "insertion_sort   (forward)       : ";
-        benchmark_counted<forward_iterator<int*>>(i);
-    }
-
-The program implements both `insertion_sort_n`, a dedicated counted algorithm, and `insertion_sort`, a general algorithm that accepts any Iterable, to which we pass a counted range. The latter is implemented in terms of the general-purpose `upper_bound` as provided by the Range v3 library, whereas the former requires a dedicated `upper_bound_n` algorithm, which is also provided.
-
-The test is run both with raw pointers (hence, random-access) and with an iterator wrapper that only models ForwardIterator. Each test is run three times, and the resulting times are averaged. The test was compiled with `g++` version 4.9.0 with `-O3 -std=gnu++11 -DNDEBUG` and run on a Linux machine. The results are reported below, for N == 30,000:
-
-&nbsp;        | `insertion_sort_n` | `insertion_sort`
---------------|--------------------|-----------------
-random-access | 2.692 s            | 2.703 s
-forward       | 23.853 s           | 23.817 s
-
-The performance difference, if there is any, is lost in the noise. At least in this case, with this compiler, on this hardware, there is no performance justification for a dedicated `_n` algorithm.
-
-**Summary**
-
-In short, counted iterators are not a *perfect* abstraction. There is some precedent here. The iterators for `deque`, and for any segmented data structure, are known to be inefficient (see [Segmented Iterators and Hierarchical Algorithms][14], Austern 1998[@austern98]). The fix for that problem, new iterator abstractions and separate hierarchical algorithm implementations, is invasive and is not attempted in any STL implementation we are aware of. In comparison, the extra complications that come with counted iterators seem quite small. For segmented iterators, the upside was the simplicity and uniformity of the Iterator abstraction. In the case of counted ranges and iterators, the upside is the simplicity and uniformity of the Iterable concept. Algorithms need only one form, not separate bounded, counted, and sentinel forms. Our benchmark gives us reasonable assurance that we aren't sacrificing performance for the sake of a unifying abstraction.
-
-Appendix 5: Drive-By Improvements to the Standard Algorithms
-=====
-
-As we are making changes to the standard algorithms, not all of which are strictly source compatible, here are some other drive-by changes that we might consider making. The changes suggested below have nothing to do with ranges *per se*, but they increase the power and uniformity of the STL and they have proven useful in the Adobe Source Library, so we might consider taking all these changes in one go.
-
-## Higher-Order Algorithms Should Take Invokables Instead of Functions
-
-Some algorithms like `for_each` are higher-order; they take functions as parameters. In [N3351][8][@n3351], they are constrained with the `Function` concept which, among other things, requires that its parameters can be used to form a valid callable expression `f(a)`.
-
-However, consider a class `S` with a member function `Do`, like:
-
-    class S {
-    public:
-        void Do() const;
-    };
-
-If we have a `vector` of `S` objects and we want to `Do` all of them, this is what we need to do:
-
-    for_each( v, [](auto & s) { s.Do(); });
-
-or, more concisely with a `bind` expression:
-
-    for_each( v, bind(&S::Do, _1) );
-
-Note that `bind` is specified in terms of a hypothetical INVOKE utility in [func.require]. Wouldn't it be more convenient if all the algorithms were required to merely take INVOKE-able things -- that is, things that can be passed to `bind` -- as arguments, instead of Functions? Then we can express the above call to `for_each` more concisely as:
-
-    for_each( v, &S::Do );
-
-We can define an `invokable` utility function as:
-
-    template<typename R, typename T>
-    auto invokable(R T::* p) const -> decltype(std::mem_fn(p))
-    {
-        return std::mem_fn(p);
-    }
-
-    template<typename T, typename U = decay_t<T>>
-    auto invokable(T && t) const -> enable_if_t<!is_member_pointer<U>::value, T>
-    {
-        return std::forward<T>(t);
-    }
-
-    template<typename F>
-    using invokable_t = decltype(invokable(std::declval<F>()));
-
-We can define an Invokable concept as:
-
-    concept Invokable<Semiregular F, typename... As> =
-        Function<invokable_t<F>, As...> &&
-        requires (F f, As... as) {
-            InvokableResultOf<F, As...>;
-            InvokableResultOf<F, As...> == invokable(f)(as...);
-        };
-
-The Invokable concept can be used to constrain algorithms instead of the Function concept. The algorithms would need to apply `invokable` to each Invokable argument before invoking it.
-
-This is pure extension and would break no code.
-
-## Algorithms Should Take Invokable Projections
-
-The [Adobe Source Libraries (ASL)][3][@asl] pioneered the use of "projections" to make the algorithms more powerful and expressive by increasing interface symmetry. Sean Parent gives a motivating example in his ["C++ Seasoning" talk][6][@cpp-seasoning], on slide 38. With today's STL, when using `sort` and `lower_bound` together with user-defined predicates, the predicate must sometimes differ. Consider:
-
-    std::sort(a, [](const employee& x, const employee& y)
-                 { return x.last < y.last; });
-    auto p = std::lower_bound(a, "Parent", [](const employee& x, const string& y)
-                                           { return x.last < y; });
-
-Notice the different predicates used in the invocations of `sort` and `lower_bound`. Since the predicates are different, there is a chance they might get out of sync leading to subtle bugs.
-
-By introducing the use of projections, this code is simplified to:
-
-    std::sort(a, std::less<>(), &employee::last);
-    auto p = std::lower_bound(a, "Parent", std::less<>(), &employee::last);
-
-Every element in the input sequence is first passed through the projection `&employee::last`. As a result, the simple comparison predicate `std::less<>` can be used in both places.
-
-No effort was made in ASL to use projections consistently. This proposal bakes them in everywhere it makes sense. Here are the guidelines to be applied to the standard algorithms:
-
-- Wherever appropriate, algorithms should optionally take INVOKE-able *projections* that are applied to each element in the input sequence(s). This, in effect, allows users to trivially transform each input sequence for the sake of that single algorithm invocation.
-- Algorithms that take two input sequences should (optionally) take two projections.
-- For algorithms that optionally accept functions/predicates (e.g. `transform`, `sort`), projection arguments follow functions/predicates. There are no algorithm overloads that allow the user to specify the projection without also specifying a predicate, even if the default would suffice. This is to reduce the number of overloads and also to avoid any potential for ambiguity.
-
-An open design question is whether all algorithms should take projections, or only the higher-order algorithms. In our current design, all algorithms take projections. This makes it trivial to, say, copy all the keys of a map by using the standard `copy` algorithm with `&pair<const key,value>::first` as the projection.
-
-### Projections versus Range Transform View
-
-In a sense, the use of a projection parameter to an algorithm is similar to applying a transform view directly to a range. For example, calling `std::find` with a projection is similar to applying a transform to a range and calling without the projection:
-
-    auto it = std::find( a, 42, &employee::age );
-
-    auto a2 = a | view::transform( &employee::age );
-    auto it2 = std::find( a2, 42 );
-
-Aside from the extra verbosity of the view-based solution, there are two meaningful differences: (1) The type of the resulting iterator is different; `*it` refers to an `employee` whereas `*it2` refers to an `int`. And (2) if the transform function returns an rvalue, then the transformed view cannot model a forward sequence due to the current requirements on the ForwardIterator concept. The result of applying a transform view is an Input range unless the transform function returns an lvalue. The projection-based interface suffers no such degradation of the iterator category. (Note: if the concepts in [N3351][8][@n3351] are adopted, this argument is no longer valid.) For those reasons, range transform adapters are not a replacement for projection arguments to algorithms.
-
-See [Algorithm Implementation with Projections](#algorithm-implementation-with-projections) for a discussion of how projections affect the implementation.
-
-The addition of projection arguments to the algorithms is pure extension.
-
-Appendix 6: Implementation Notes
-=====
-
-## On Distinguishing Ranges from Non-Range Iterables
-
-The design of the range library depends on the ability to tell apart Ranges from Iterables. Ranges are lightweight objects that refer to elements they do not own. As a result, they can guarantee O(1) copyability and assignability. Iterables, on the other hand, may or may not own their elements, and so cannot guarantee anything about the algorithmic complexity of their copy and assign operations. Indeed, an Iterable may not be copyable at all: it may be a native array or a `vector` of move-only types.
-
-But how to tell Ranges apart from Iterables? After all, whether an Iterable owns its elements or not is largely a semantic difference with no purely syntactic way to differentiate. Well, that's almost true...
-
-It turns out that there is a reasonably good heuristic we can use to tell Iterables and Ranges apart. Imagine that we have some Iterable type `T` that is either a container like `list`, `vector`, or a native array; or else it's a Range like `pair<int*,int*>`. Then we can imagine taking iterators to `T` and `const T`, dereferencing them, and comparing the resulting reference types. The following table gives the results we might expect to find.
-
-Expression                      |  Container            |   Range
---------------------------------|-----------------------|-----------------------
-`*begin(declval<T&>())`         | `value_type &`        | `[const] value_type &`
-`*begin(declval<const T&>())`   | `const value_type &`  | `[const] value_type &`
-
-Notice how containers and ranges differ in the way a top-level cv-qualifier affects the reference type. Since a range is a proxy to elements stored elsewhere, a top-level `const` qualification on the *range* object typically has no effect at all on its iterator's reference type. But that's not true for a container that owns its elements.
-
-We can use this to build an `is_range` traits that gives a pretty good guess whether an Iterable type is a range or not. This trait can be used to define the Range concept. Obviously since it's a trait, users are free to specialize it if the trait guesses wrong.
-
-Some people want their range types to behave like containers with respect to the handling of top-level `const`; that is, they would like their ranges to be designed such that if the range object is `const`, the range's elements cannot be mutated through it. There is nothing about the Range concepts that precludes that design, but it does require the developer of such a range to specialize the `is_range` trait. If anything, the default behavior of the trait can be seen as gentle encouragement to handle top-level `const` in a way that is consistent with ranges' nature as a lightweight proxy.
-
-As an added convenience, we can provide a class, `range_base`, from which users can create a derived type as another way of opting in to "range-ness". The `is_range` trait can test for derivation from `range_base` as an extra test. This would save users the trouble of opening the `std` namespace to specialize the `is_range` trait on the rare occasions that that is necessary.
-
-The `is_range` trait will also need to be specialized for immutable containers, for which both the mutable and const iterators have the same reference type. A good example is `std::set`.
-
-If the `is_range` trait erroneously reports `false` for a type that is actually a range, then the library errs on the side of caution and will prevent the user from using rvalues of that type in range adaptor pipelines. If, on the other hand, the `is_range` trait gets the answer wrong for a type that is actually a container, the container ends up being copied or moved into range adaptors. This is a performance bug, and it may give surprising results at runtime if the original container doesn't get mutated when the user thinks it should. It's not a memory error, though.
-
-## Algorithm Implementation with Projections
-
-Rather than requiring additional overloads, the addition of projection arguments has very little cost to library implementers. The use of function template default parameters obviates the need for overloads. For instance, `find` can be defined as:
-
-    template<InputIterator I, Regular S, typename V, Invokable<ValueType<I>> Proj = identity>
-        requires EqualityComparable<I, S> &&
-                 EqualityComparable<V, InvokableResultOf<Proj, ValueType<I>>>
-    I find(I first, S last, V const & val, Proj proj = Proj{})
-    {
-        /* ... */
-    }
-
-## Algorithms That Need An End Iterator
-
-Some algorithms need to know the real physical end of the input sequence so that the sequence can be traversed backwards, like `reverse`. In those cases, it's helpful to have an algorithm `advance_to` that takes an iterator and a sentinel and returns a real end iterator. `advance_to` looks like this:
-
-
-    template<Iterator I, Regular S>
-        requires IteratorRange<I, S>
-    I advance_to( I i, S s )
-    {
-        while(i != s)
-            ++i;
-        return i;
-    }
-
-    template<Iterator I, Regular S>
-        requires SizedIteratorRange<I, S>
-    I advance_to( I i, S s )
-    {
-        advance( i, s - i );
-        return i;
-    }
-
-    template<Iterator I>
-    I advance_to( I, I s )
-    {
-        return s;
-    }
-
-When the sentinel is actually an iterator, we already know where the end is so we can just return it. Notice how we handle SizedIteratorRanges specially and dispatch to `advance` with a count. [Appendix 4](#appendix-4-on-counted-ranges-and-efficiency) shows how `advance` is optimized for counted iterators. By dispatching to `advance` when we can, we make `advance_to` faster for counted iterators, too.
-
-With `advance_to` we can implement `reverse` generically as:
-
-    template<BidirectionalIterator I, Regular S>
-        requires EqualityComparable<I, S> && Permutable<I>
-    I reverse( I first, S last_ )
-    {
-        I last = advance_to( first, last_ ), end = last;
-        while( first != last )
-        {
-            if( first == --last )
-                break;
-            iter_swap( first, last );
-            ++first;
-        }
-        return end;
-    }
-
-Since this algorithm necessarily computes the end of the sequence if it isn't known already, we return it.
diff --git a/src/contrib/range-v3-0.11.0/doc/std/header.html b/src/contrib/range-v3-0.11.0/doc/std/header.html
deleted file mode 100644
index 9412972f..00000000
--- a/src/contrib/range-v3-0.11.0/doc/std/header.html
+++ /dev/null
@@ -1,24 +0,0 @@
-<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="607">
-  <tr>
-    <td width="172" align="left" valign="top">Document number:</td>
-    <td width="435">
-      <span style="background-color: #FFFF00">D4128</span>=yy-nnnn
-    </td>
-  </tr>
-  <tr>
-    <td width="172" align="left" valign="top">Date:</td>
-    <td width="435">2014-10-10</td>
-  </tr>
-  <tr>
-    <td width="172" align="left" valign="top">Project:</td>
-    <td width="435">Programming Language C++, Library Working Group</td>
-  </tr>
-  <tr>
-    <td width="172" align="left" valign="top">Reply-to:</td>
-    <td width="435">
-      Eric Niebler &lt;<a href="mailto:eniebler@boost.org">eniebler@boost.org</a>&gt;,<br/>
-      Sean Parent &lt;<a href="mailto:sparent@adobe.com">sparent@adobe.com</a>&gt;,<br/>
-      Andrew Sutton &lt;<a href="mailto:andrew.n.sutton@gmail.com">andrew.n.sutton@gmail.com</a>&gt;
-    </td>
-  </tr>
-</table>
diff --git a/src/contrib/range-v3-0.11.0/doc/std/pandoc-template.html b/src/contrib/range-v3-0.11.0/doc/std/pandoc-template.html
deleted file mode 100644
index 5a36b3b6..00000000
--- a/src/contrib/range-v3-0.11.0/doc/std/pandoc-template.html
+++ /dev/null
@@ -1,67 +0,0 @@
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml"$if(lang)$ lang="$lang$" xml:lang="$lang$"$endif$>
-<head>
-  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
-  <meta http-equiv="Content-Style-Type" content="text/css" />
-  <meta name="generator" content="pandoc" />
-$for(author-meta)$
-  <meta name="author" content="$author-meta$" />
-$endfor$
-$if(date-meta)$
-  <meta name="date" content="$date-meta$" />
-$endif$
-  <title>$if(title-prefix)$$title-prefix$ - $endif$$pagetitle$</title>
-  <style type="text/css">code{white-space: pre;}</style>
-$if(quotes)$
-  <style type="text/css">q { quotes: "" "" "" ""; }</style>
-$endif$
-$if(highlighting-css)$
-  <style type="text/css">
-$highlighting-css$
-  </style>
-$endif$
-$for(css)$
-  <link rel="stylesheet" href="$css$" $if(html5)$$else$type="text/css" $endif$/>
-$endfor$
-$if(math)$
-  $math$
-$endif$
-$for(header-includes)$
-  $header-includes$
-$endfor$
-</head>
-<body>
-$for(include-before)$
-$include-before$
-$endfor$
-$if(title)$
-<div id="$idprefix$header">
-<h1 class="title">$title$</h1>
-$if(subtitle)$
-<h1 class="subtitle">$subtitle$</h1>
-$endif$
-$for(author)$
-<h2 class="author">$author$</h2>
-$endfor$
-$if(date)$
-<h3 class="date">$date$</h3>
-$endif$
-</div>
-$endif$
-<blockquote>
-  <p>A beginning is the time for taking the most delicate care that the balances are correct.</p>
-  <p>
-     Frank Herbert, <em>Dune</em>
-  </p>
-</blockquote>
-$if(toc)$
-<div id="$idprefix$TOC">
-$toc$
-</div>
-$endif$
-$body$
-$for(include-after)$
-$include-after$
-$endfor$
-</body>
-</html>
diff --git a/src/contrib/range-v3-0.11.0/doc/std/show.cmd b/src/contrib/range-v3-0.11.0/doc/std/show.cmd
deleted file mode 100644
index 521532e6..00000000
--- a/src/contrib/range-v3-0.11.0/doc/std/show.cmd
+++ /dev/null
@@ -1 +0,0 @@
-pandoc -f markdown_github+yaml_metadata_block+citations -t html -o D4128.html --filter pandoc-citeproc --csl=acm-sig-proceedings.csl --number-sections --toc -s -S --template=pandoc-template --include-before-body=header.html D4128.md
diff --git a/src/contrib/range-v3-0.11.0/doc/unpreprocess.pl b/src/contrib/range-v3-0.11.0/doc/unpreprocess.pl
deleted file mode 100755
index befe3d4b..00000000
--- a/src/contrib/range-v3-0.11.0/doc/unpreprocess.pl
+++ /dev/null
@@ -1,19 +0,0 @@
-#!/usr/bin/perl
-
-use strict;
-
-my $file = "";
-my $first = 1;
-my $emit = 0;
-
-while(<>) {
-    if ($first) {
-        $_ =~ m/^#\s*\d+\s+"(.*)"/;
-        $file = $1;
-        $first = 0;
-    } elsif ($_ =~ m/^#\s*\d+\s+"(.*)"/) {
-        $emit = ($1 eq $file);
-    } elsif ($emit) {
-        print $_;
-    }
-}
diff --git a/src/contrib/range-v3-0.11.0/example/BUCK b/src/contrib/range-v3-0.11.0/example/BUCK
deleted file mode 100644
index 8c9d9f8c..00000000
--- a/src/contrib/range-v3-0.11.0/example/BUCK
+++ /dev/null
@@ -1,155 +0,0 @@
-cxx_binary(
-  name = 'comprehensions',
-  srcs = [
-    'comprehensions.cpp',
-  ],
-  deps = [
-    '//:range-v3',
-  ],
-  compiler_flags = [
-    '-std=c++14',
-  ],
-)
-
-cxx_binary(
-  name = 'count_if',
-  srcs = [
-    'count_if.cpp',
-  ],
-  deps = [
-    '//:range-v3',
-  ],
-  compiler_flags = [
-    '-std=c++14',
-  ],
-)
-
-cxx_binary(
-  name = 'count',
-  srcs = [
-    'count.cpp',
-  ],
-  deps = [
-    '//:range-v3',
-  ],
-  compiler_flags = [
-    '-std=c++14',
-  ],
-)
-
-cxx_binary(
-  name = 'find',
-  srcs = [
-    'find.cpp',
-  ],
-  deps = [
-    '//:range-v3',
-  ],
-  compiler_flags = [
-    '-std=c++14',
-  ],
-)
-
-cxx_binary(
-  name = 'for_each_assoc',
-  srcs = [
-    'for_each_assoc.cpp',
-  ],
-  deps = [
-    '//:range-v3',
-  ],
-  compiler_flags = [
-    '-std=c++14',
-  ],
-)
-
-cxx_binary(
-  name = 'for_each_sequence',
-  srcs = [
-    'for_each_sequence.cpp',
-  ],
-  deps = [
-    '//:range-v3',
-  ],
-  compiler_flags = [
-    '-std=c++14',
-  ],
-)
-
-cxx_binary(
-  name = 'hello',
-  srcs = [
-    'hello.cpp',
-  ],
-  deps = [
-    '//:range-v3',
-  ],
-  compiler_flags = [
-    '-std=c++14',
-  ],
-)
-
-cxx_binary(
-  name = 'is_sorted',
-  srcs = [
-    'is_sorted.cpp',
-  ],
-  deps = [
-    '//:range-v3',
-  ],
-  compiler_flags = [
-    '-std=c++14',
-  ],
-)
-
-cxx_binary(
-  name = 'filter_transform',
-  srcs = [
-    'filter_transform.cpp',
-  ],
-  deps = [
-    '//:range-v3',
-  ],
-  compiler_flags = [
-    '-std=c++14',
-  ],
-)
-
-cxx_binary(
-  name = 'accumulate_ints',
-  srcs = [
-    'accumulate_ints.cpp',
-  ],
-  deps = [
-    '//:range-v3',
-  ],
-  compiler_flags = [
-    '-std=c++14',
-  ],
-)
-
-cxx_binary(
-  name = 'comprehension_conversion',
-  srcs = [
-    'comprehension_conversion.cpp',
-  ],
-  deps = [
-    '//:range-v3',
-  ],
-  compiler_flags = [
-    '-std=c++14',
-  ],
-)
-
-cxx_binary(
-  name = 'sort_unique',
-  srcs = [
-    'sort_unique.cpp',
-  ],
-  deps = [
-    '//:range-v3',
-  ],
-  compiler_flags = [
-    '-std=c++14',
-  ],
-)
diff --git a/src/contrib/range-v3-0.11.0/example/CMakeLists.txt b/src/contrib/range-v3-0.11.0/example/CMakeLists.txt
deleted file mode 100644
index f36e814c..00000000
--- a/src/contrib/range-v3-0.11.0/example/CMakeLists.txt
+++ /dev/null
@@ -1,37 +0,0 @@
-set(CMAKE_FOLDER "example")
-
-# examples use a less draconian set of compiler warnings
-ranges_append_flag(RANGES_HAS_WNO_MISSING_BRACES -Wno-missing-braces)
-ranges_append_flag(RANGES_HAS_WNO_SHORTEN_64_TO_32 -Wno-shorten-64-to-32)
-ranges_append_flag(RANGES_HAS_WNO_GLOBAL_CONSTRUCTORS -Wno-global-constructors)
-
-rv3_add_test(example.comprehensions comprehensions comprehensions.cpp)
-rv3_add_test(example.hello hello hello.cpp)
-rv3_add_test(example.count count count.cpp)
-rv3_add_test(example.count_if count_if count_if.cpp)
-rv3_add_test(example.any_all_none_of any_all_none_of any_all_none_of.cpp)
-rv3_add_test(example.for_each_sequence for_each_sequence for_each_sequence.cpp)
-rv3_add_test(example.for_each_assoc for_each_assoc for_each_assoc.cpp)
-rv3_add_test(example.is_sorted is_sorted is_sorted.cpp)
-rv3_add_test(example.find find find.cpp)
-rv3_add_test(example.filter_transform filter_transform filter_transform.cpp)
-rv3_add_test(example.accumulate_ints accumulate_ints accumulate_ints.cpp)
-rv3_add_test(example.comprehension_conversion comprehension_conversion comprehension_conversion.cpp)
-rv3_add_test(example.sort_unique sort_unique sort_unique.cpp)
-
-# Guarded with a variable because the calendar example causes gcc to puke.
-if(RANGES_BUILD_CALENDAR_EXAMPLE)
-    set(Boost_USE_STATIC_LIBS        ON)
-    set(Boost_USE_MULTITHREADED     OFF)
-    set(Boost_USE_STATIC_RUNTIME    OFF)
-    find_package(Boost 1.59.0 COMPONENTS date_time program_options)
-
-    if (Boost_FOUND)
-        add_executable(calendar calendar.cpp)
-        target_include_directories(calendar SYSTEM PRIVATE ${Boost_INCLUDE_DIRS})
-        target_link_libraries(calendar PRIVATE range-v3 Boost::date_time Boost::program_options)
-        message(STATUS "boost: ${Boost_LIBRARY_DIRS}")
-        target_compile_definitions(calendar PRIVATE BOOST_NO_AUTO_PTR)
-        target_compile_options(calendar PRIVATE -std=gnu++14)
-    endif()
-endif()
diff --git a/src/contrib/range-v3-0.11.0/example/accumulate_ints.cpp b/src/contrib/range-v3-0.11.0/example/accumulate_ints.cpp
deleted file mode 100644
index 65769239..00000000
--- a/src/contrib/range-v3-0.11.0/example/accumulate_ints.cpp
+++ /dev/null
@@ -1,37 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2019
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-///[accumulate_ints]
-// Sums the first ten squares and prints them, using views::ints to generate
-// and infinite range of integers, views::transform to square them, views::take
-// to drop all but the first 10, and accumulate to sum them.
-
-#include <iostream>
-#include <vector>
-
-#include <range/v3/numeric/accumulate.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/take.hpp>
-#include <range/v3/view/transform.hpp>
-using std::cout;
-
-int main()
-{
-    using namespace ranges;
-    int sum = accumulate(views::ints(1, unreachable) | views::transform([](int i) {
-                             return i * i;
-                         }) | views::take(10),
-                         0);
-    // prints: 385
-    cout << sum << '\n';
-}
-///[accumulate_ints]
diff --git a/src/contrib/range-v3-0.11.0/example/any_all_none_of.cpp b/src/contrib/range-v3-0.11.0/example/any_all_none_of.cpp
deleted file mode 100644
index edf5be57..00000000
--- a/src/contrib/range-v3-0.11.0/example/any_all_none_of.cpp
+++ /dev/null
@@ -1,44 +0,0 @@
-// Range v3 library
-//
-//  Copyright Jeff Garland 2017
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-//[any_all_none_of]]
-// Demonstrates any_of, all_of, none_of
-// output
-// vector: [6,2,3,4,5,6]
-// vector any_of is_six: true
-// vector all_of is_six: false
-// vector none_of is_six: false
-
-#include <range/v3/algorithm/all_of.hpp>
-#include <range/v3/algorithm/any_of.hpp>
-#include <range/v3/algorithm/for_each.hpp>
-#include <range/v3/algorithm/none_of.hpp>
-#include <range/v3/view/all.hpp>
-
-#include <iostream>
-#include <vector>
-using std::cout;
-
-auto is_six = [](int i) { return i == 6; };
-
-int
-main()
-{
-    std::vector<int> v{6, 2, 3, 4, 5, 6};
-    cout << std::boolalpha;
-    cout << "vector: " << ranges::views::all(v) << '\n';
-
-    cout << "vector any_of is_six: " << ranges::any_of(v, is_six) << '\n';
-    cout << "vector all_of is_six: " << ranges::all_of(v, is_six) << '\n';
-    cout << "vector none_of is_six: " << ranges::none_of(v, is_six) << '\n';
-}
-//[any_all_none_of]]
diff --git a/src/contrib/range-v3-0.11.0/example/calendar.cpp b/src/contrib/range-v3-0.11.0/example/calendar.cpp
deleted file mode 100644
index 02021ffd..00000000
--- a/src/contrib/range-v3-0.11.0/example/calendar.cpp
+++ /dev/null
@@ -1,373 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#include <range/v3/detail/config.hpp>
-
-#if RANGES_CXX_RETURN_TYPE_DEDUCTION >= RANGES_CXX_RETURN_TYPE_DEDUCTION_14 && \
-    RANGES_CXX_GENERIC_LAMBDAS >= RANGES_CXX_GENERIC_LAMBDAS_14
-
-///[calendar]
-
-// Usage:
-//     calendar 2015
-//
-// Output:
-/*
-        January              February                March
-              1  2  3   1  2  3  4  5  6  7   1  2  3  4  5  6  7
-  4  5  6  7  8  9 10   8  9 10 11 12 13 14   8  9 10 11 12 13 14
- 11 12 13 14 15 16 17  15 16 17 18 19 20 21  15 16 17 18 19 20 21
- 18 19 20 21 22 23 24  22 23 24 25 26 27 28  22 23 24 25 26 27 28
- 25 26 27 28 29 30 31                        29 30 31
-
-         April                  May                  June
-           1  2  3  4                  1  2      1  2  3  4  5  6
-  5  6  7  8  9 10 11   3  4  5  6  7  8  9   7  8  9 10 11 12 13
- 12 13 14 15 16 17 18  10 11 12 13 14 15 16  14 15 16 17 18 19 20
- 19 20 21 22 23 24 25  17 18 19 20 21 22 23  21 22 23 24 25 26 27
- 26 27 28 29 30        24 25 26 27 28 29 30  28 29 30
-                       31
-         July                 August               September
-           1  2  3  4                     1         1  2  3  4  5
-  5  6  7  8  9 10 11   2  3  4  5  6  7  8   6  7  8  9 10 11 12
- 12 13 14 15 16 17 18   9 10 11 12 13 14 15  13 14 15 16 17 18 19
- 19 20 21 22 23 24 25  16 17 18 19 20 21 22  20 21 22 23 24 25 26
- 26 27 28 29 30 31     23 24 25 26 27 28 29  27 28 29 30
-                       30 31
-        October              November              December
-              1  2  3   1  2  3  4  5  6  7         1  2  3  4  5
-  4  5  6  7  8  9 10   8  9 10 11 12 13 14   6  7  8  9 10 11 12
- 11 12 13 14 15 16 17  15 16 17 18 19 20 21  13 14 15 16 17 18 19
- 18 19 20 21 22 23 24  22 23 24 25 26 27 28  20 21 22 23 24 25 26
- 25 26 27 28 29 30 31  29 30                 27 28 29 30 31
-// */
-
-// Credits:
-//   Thanks to H. S. Teoh for the article that served as the
-//     inspiration for this example:
-//     <http://wiki.dlang.org/Component_programming_with_ranges>
-//   Thanks to github's Arzar for bringing date::week_number
-//     to my attention.
-
-#include <boost/date_time/gregorian/gregorian.hpp>
-#include <boost/format.hpp>
-#include <boost/lexical_cast.hpp>
-#include <boost/program_options.hpp>
-#include <algorithm>
-#include <cstddef>
-#include <functional>
-#include <iostream>
-#include <range/v3/action/join.hpp>
-#include <range/v3/algorithm/copy.hpp>
-#include <range/v3/algorithm/for_each.hpp>
-#include <range/v3/algorithm/mismatch.hpp>
-#include <range/v3/core.hpp>
-#include <range/v3/iterator/stream_iterators.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/chunk.hpp>
-#include <range/v3/view/concat.hpp>
-#include <range/v3/view/group_by.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/join.hpp>
-#include <range/v3/view/repeat_n.hpp>
-#include <range/v3/view/single.hpp>
-#include <range/v3/view/take.hpp>
-#include <range/v3/view/transform.hpp>
-#include <stdexcept>
-#include <string>
-#include <utility>
-#include <vector>
-
-namespace po = boost::program_options;
-namespace greg = boost::gregorian;
-using date = greg::date;
-using day = greg::date_duration;
-using namespace ranges;
-
-namespace boost
-{
-    namespace gregorian
-    {
-        date &operator++(date &d)
-        {
-            return d = d + day(1);
-        }
-        date operator++(date &d, int)
-        {
-            return ++d - day(1);
-        }
-    }
-}
-namespace ranges
-{
-    template<>
-    struct incrementable_traits<date>
-    {
-        using difference_type = date::duration_type::duration_rep::int_type;
-    };
-}
-CPP_assert(incrementable<date>);
-
-auto
-dates(unsigned short start, unsigned short stop)
-{
-    return views::iota(date{start, greg::Jan, 1}, date{stop, greg::Jan, 1});
-}
-
-auto
-dates_from(unsigned short year)
-{
-    return views::iota(date{year, greg::Jan, 1});
-}
-
-auto
-by_month()
-{
-    return views::group_by(
-        [](date a, date b) { return a.month() == b.month(); });
-}
-
-auto
-by_week()
-{
-    return views::group_by([](date a, date b) {
-        // ++a because week_number is Mon-Sun and we want Sun-Sat
-        return (++a).week_number() == (++b).week_number();
-    });
-}
-
-std::string
-format_day(date d)
-{
-    return boost::str(boost::format("%|3|") % d.day());
-}
-
-// In:  range<range<date>>: month grouped by weeks.
-// Out: range<std::string>: month with formatted weeks.
-auto
-format_weeks()
-{
-    return views::transform([](/*range<date>*/ auto week) {
-        return boost::str(boost::format("%1%%2%%|22t|") %
-                          std::string(front(week).day_of_week() * 3u, ' ') %
-                          (week | views::transform(format_day) | actions::join));
-    });
-}
-
-// Return a formatted string with the title of the month
-// corresponding to a date.
-std::string
-month_title(date d)
-{
-    return boost::str(boost::format("%|=22|") % d.month().as_long_string());
-}
-
-// In:  range<range<date>>: year of months of days
-// Out: range<range<std::string>>: year of months of formatted wks
-auto
-layout_months()
-{
-    return views::transform([](/*range<date>*/ auto month) {
-        auto week_count =
-            static_cast<std::ptrdiff_t>(distance(month | by_week()));
-        return views::concat(
-            views::single(month_title(front(month))),
-            month | by_week() | format_weeks(),
-            views::repeat_n(std::string(22, ' '), 6 - week_count));
-    });
-}
-
-// Flattens a range of ranges by iterating the inner
-// ranges in round-robin fashion.
-template<class Rngs>
-class interleave_view : public view_facade<interleave_view<Rngs>>
-{
-    friend range_access;
-    std::vector<range_value_t<Rngs>> rngs_;
-    struct cursor;
-    cursor begin_cursor()
-    {
-        return {0, &rngs_, views::transform(rngs_, ranges::begin) | to<std::vector>};
-    }
-
-public:
-    interleave_view() = default;
-    explicit interleave_view(Rngs rngs)
-      : rngs_(std::move(rngs) | to<std::vector>)
-    {}
-};
-
-template<class Rngs>
-struct interleave_view<Rngs>::cursor
-{
-    std::size_t n_;
-    std::vector<range_value_t<Rngs>> *rngs_;
-    std::vector<iterator_t<range_value_t<Rngs>>> its_;
-    decltype(auto) read() const
-    {
-        return *its_[n_];
-    }
-    void next()
-    {
-        if(0 == ((++n_) %= its_.size()))
-            for_each(its_, [](auto &it) { ++it; });
-    }
-    bool equal(default_sentinel_t) const
-    {
-        if(n_ != 0)
-            return false;
-        auto ends = *rngs_ | views::transform(ranges::end);
-        return its_.end() != std::mismatch(
-            its_.begin(), its_.end(), ends.begin(), std::not_equal_to<>{}).first;
-    }
-    CPP_member
-    auto equal(cursor const& that) const -> CPP_ret(bool)(
-        requires forward_range<range_value_t<Rngs>>)
-    {
-        return n_ == that.n_ && its_ == that.its_;
-    }
-};
-
-// In:  range<range<T>>
-// Out: range<T>, flattened by walking the ranges
-//                round-robin fashion.
-auto
-interleave()
-{
-    return make_view_closure([](auto &&rngs) {
-        using Rngs = decltype(rngs);
-        return interleave_view<views::all_t<Rngs>>(
-            views::all(std::forward<Rngs>(rngs)));
-    });
-}
-
-// In:  range<range<T>>
-// Out: range<range<T>>, transposing the rows and columns.
-auto
-transpose()
-{
-    return make_view_closure([](auto &&rngs) {
-        using Rngs = decltype(rngs);
-        CPP_assert(forward_range<Rngs>);
-        return std::forward<Rngs>(rngs)
-            | interleave()
-            | views::chunk(static_cast<std::size_t>(distance(rngs)));
-    });
-}
-
-// In:  range<range<range<string>>>
-// Out: range<range<range<string>>>, transposing months.
-auto
-transpose_months()
-{
-    return views::transform(
-        [](/*range<range<string>>*/ auto rng) { return rng | transpose(); });
-}
-
-// In:  range<range<string>>
-// Out: range<string>, joining the strings of the inner ranges
-auto
-join_months()
-{
-    return views::transform(
-        [](/*range<string>*/ auto rng) { return actions::join(rng); });
-}
-
-// In:  range<date>
-// Out: range<string>, lines of formatted output
-auto
-format_calendar(std::size_t months_per_line)
-{
-    return
-        // Group the dates by month:
-        by_month()
-        // Format the month into a range of strings:
-      | layout_months()
-        // Group the months that belong side-by-side:
-      | views::chunk(months_per_line)
-        // Transpose the rows and columns of the size-by-side months:
-      | transpose_months()
-        // Ungroup the side-by-side months:
-      | views::join
-        // Join the strings of the transposed months:
-      | join_months();
-}
-
-int
-main(int argc, char *argv[]) try
-{
-    // Declare the supported options.
-    po::options_description desc("Allowed options");
-    desc.add_options()("help", "produce help message")(
-        "start", po::value<unsigned short>(), "Year to start")(
-        "stop", po::value<std::string>(), "Year to stop")(
-        "per-line",
-        po::value<std::size_t>()->default_value(3u),
-        "Nbr of months per line");
-
-    po::positional_options_description p;
-    p.add("start", 1).add("stop", 1);
-
-    po::variables_map vm;
-    po::store(
-        po::command_line_parser(argc, argv).options(desc).positional(p).run(),
-        vm);
-    po::notify(vm);
-
-    if(vm.count("help") || 1 != vm.count("start"))
-    {
-        std::cerr << desc << '\n';
-        return 1;
-    }
-
-    auto const start = vm["start"].as<unsigned short>();
-    auto const stop = 0 == vm.count("stop")
-                          ? (unsigned short)(start + 1)
-                          : vm["stop"].as<std::string>() == "never"
-                                ? (unsigned short)-1
-                                : boost::lexical_cast<unsigned short>(
-                                      vm["stop"].as<std::string>());
-    auto const months_per_line = vm["per-line"].as<std::size_t>();
-
-    if(stop != (unsigned short)-1 && stop <= start)
-    {
-        std::cerr << "ERROR: The stop year must be larger than the start"
-                  << '\n';
-        return 1;
-    }
-
-    if((unsigned short)-1 != stop)
-    {
-        copy(dates(start, stop) | format_calendar(months_per_line),
-             ostream_iterator<>(std::cout, "\n"));
-    }
-    else
-    {
-        copy(dates_from(start) | format_calendar(months_per_line),
-             ostream_iterator<>(std::cout, "\n"));
-    }
-}
-catch(std::exception &e)
-{
-    std::cerr << "ERROR: Unhandled exception\n";
-    std::cerr << "  what(): " << e.what();
-    return 1;
-}
-///[calendar]
-
-#else
-#pragma message( \
-    "calendar requires C++14 return type deduction and generic lambdas")
-int
-main()
-{}
-#endif
diff --git a/src/contrib/range-v3-0.11.0/example/comprehension_conversion.cpp b/src/contrib/range-v3-0.11.0/example/comprehension_conversion.cpp
deleted file mode 100644
index 8b327ae4..00000000
--- a/src/contrib/range-v3-0.11.0/example/comprehension_conversion.cpp
+++ /dev/null
@@ -1,35 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2019
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-///[comprehension_conversion]
-// Use a range comprehension (views::for_each) to construct a custom range, and
-// then convert it to a std::vector.
-
-#include <iostream>
-#include <vector>
-
-#include <range/v3/range/conversion.hpp>
-#include <range/v3/view/for_each.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/repeat_n.hpp>
-using std::cout;
-
-int main()
-{
-    using namespace ranges;
-    auto vi = views::for_each(views::ints(1, 6),
-                              [](int i) { return yield_from(views::repeat_n(i, i)); }) |
-              to<std::vector>();
-    // prints: [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5]
-    cout << views::all(vi) << '\n';
-}
-///[comprehension_conversion]
diff --git a/src/contrib/range-v3-0.11.0/example/comprehensions.cpp b/src/contrib/range-v3-0.11.0/example/comprehensions.cpp
deleted file mode 100644
index 8bdea0e7..00000000
--- a/src/contrib/range-v3-0.11.0/example/comprehensions.cpp
+++ /dev/null
@@ -1,124 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#include <chrono>
-#include <iostream>
-#include <range/v3/all.hpp>
-
-using namespace ranges;
-
-int
-main()
-{
-    // Define an infinite range containing all the Pythagorean triples:
-    auto triples = views::for_each(views::iota(1), [](int z) {
-        return views::for_each(views::iota(1, z + 1), [=](int x) {
-            return views::for_each(views::iota(x, z + 1), [=](int y) {
-                return yield_if(x * x + y * y == z * z,
-                                std::make_tuple(x, y, z));
-            });
-        });
-    });
-
-    //// This alternate syntax also works:
-    // auto triples = iota(1)      >>= [] (int z) { return
-    //                iota(1, z+1) >>= [=](int x) { return
-    //                iota(x, z+1) >>= [=](int y) { return
-    //    yield_if(x*x + y*y == z*z,
-    //        std::make_tuple(x, y, z)); };}; };
-
-    // Display the first 100 triples
-    RANGES_FOR(auto triple, triples | views::take(100))
-    {
-        std::cout << '(' << std::get<0>(triple) << ',' << std::get<1>(triple)
-                  << ',' << std::get<2>(triple) << ')' << '\n';
-    }
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////////////
-//  Benchmark Code
-////////////////////////////////////////////////////////////////////////////////////////////////////
-
-class timer
-{
-private:
-    std::chrono::high_resolution_clock::time_point start_;
-
-public:
-    timer()
-    {
-        reset();
-    }
-    void reset()
-    {
-        start_ = std::chrono::high_resolution_clock::now();
-    }
-    std::chrono::milliseconds elapsed() const
-    {
-        return std::chrono::duration_cast<std::chrono::milliseconds>(
-            std::chrono::high_resolution_clock::now() - start_);
-    }
-    friend std::ostream &operator<<(std::ostream &sout, timer const &t)
-    {
-        return sout << t.elapsed().count() << "ms";
-    }
-};
-
-void
-benchmark()
-{
-    // Define an infinite range containing all the Pythagorean triples:
-    auto triples = views::for_each(views::iota(1), [](int z) {
-        return views::for_each(views::iota(1, z + 1), [=](int x) {
-            return views::for_each(views::iota(x, z + 1), [=](int y) {
-                return yield_if(x * x + y * y == z * z,
-                                std::make_tuple(x, y, z));
-            });
-        });
-    });
-
-    static constexpr int max_triples = 3000;
-
-    timer t;
-    int result = 0;
-    RANGES_FOR(auto triple, triples | views::take(max_triples))
-    {
-        int i, j, k;
-        std::tie(i, j, k) = triple;
-        result += (i + j + k);
-    }
-    std::cout << t << '\n';
-    std::cout << result << '\n';
-
-    result = 0;
-    int found = 0;
-    t.reset();
-    for(int z = 1;; ++z)
-    {
-        for(int x = 1; x <= z; ++x)
-        {
-            for(int y = x; y <= z; ++y)
-            {
-                if(x * x + y * y == z * z)
-                {
-                    result += (x + y + z);
-                    ++found;
-                    if(found == max_triples)
-                        goto done;
-                }
-            }
-        }
-    }
-done:
-    std::cout << t << '\n';
-    std::cout << result << '\n';
-}
diff --git a/src/contrib/range-v3-0.11.0/example/count.cpp b/src/contrib/range-v3-0.11.0/example/count.cpp
deleted file mode 100644
index ffc17d87..00000000
--- a/src/contrib/range-v3-0.11.0/example/count.cpp
+++ /dev/null
@@ -1,40 +0,0 @@
-// Range v3 library
-//
-//  Copyright Jeff Garland 2017
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-///[count]
-// This example demonstrates counting the number of
-// elements that match a given value.
-// output...
-// vector:   2
-// array:    2
-
-#include <iostream>
-#include <range/v3/algorithm/count.hpp> // specific includes
-#include <vector>
-using std::cout;
-
-int
-main()
-{
-    std::vector<int> v{6, 2, 3, 4, 5, 6};
-    // note the count return is a numeric type
-    // like int or long -- auto below make sure
-    // it matches the implementation
-    auto c = ranges::count(v, 6);
-    cout << "vector:   " << c << '\n';
-
-    std::array<int, 6> a{6, 2, 3, 4, 5, 6};
-    c = ranges::count(a, 6);
-    cout << "array:    " << c << '\n';
-}
-
-///[count]
diff --git a/src/contrib/range-v3-0.11.0/example/count_if.cpp b/src/contrib/range-v3-0.11.0/example/count_if.cpp
deleted file mode 100644
index 0a9e3ebe..00000000
--- a/src/contrib/range-v3-0.11.0/example/count_if.cpp
+++ /dev/null
@@ -1,39 +0,0 @@
-
-// Range v3 library
-//
-//  Copyright Jeff Garland 2017
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-///[count_if]
-// This example counts element of a range that match a supplied predicate.
-// output
-// vector:   2
-// array:    2
-
-#include <array>
-#include <iostream>
-#include <range/v3/algorithm/count_if.hpp> // specific includes
-#include <vector>
-using std::cout;
-
-auto is_six = [](int i) -> bool { return i == 6; };
-
-int
-main()
-{
-    std::vector<int> v{6, 2, 3, 4, 5, 6};
-    auto c = ranges::count_if(v, is_six);
-    cout << "vector:   " << c << '\n'; // 2
-
-    std::array<int, 6> a{6, 2, 3, 4, 5, 6};
-    c = ranges::count_if(a, is_six);
-    cout << "array:    " << c << '\n'; // 2
-}
-///[count_if]
diff --git a/src/contrib/range-v3-0.11.0/example/filter_transform.cpp b/src/contrib/range-v3-0.11.0/example/filter_transform.cpp
deleted file mode 100644
index f8783a62..00000000
--- a/src/contrib/range-v3-0.11.0/example/filter_transform.cpp
+++ /dev/null
@@ -1,34 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2019
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-///[filter_transform]
-// This example demonstrates filtering and transforming a range on the
-// fly with view adaptors.
-
-#include <iostream>
-#include <string>
-#include <vector>
-
-#include <range/v3/view/filter.hpp>
-#include <range/v3/view/transform.hpp>
-using std::cout;
-
-int main()
-{
-    std::vector<int> const vi{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
-    using namespace ranges;
-    auto rng = vi | views::filter([](int i) { return i % 2 == 0; }) |
-               views::transform([](int i) { return std::to_string(i); });
-    // prints: [2,4,6,8,10]
-    cout << rng << '\n';
-}
-///[filter_transform]
diff --git a/src/contrib/range-v3-0.11.0/example/find.cpp b/src/contrib/range-v3-0.11.0/example/find.cpp
deleted file mode 100644
index 060f5ef2..00000000
--- a/src/contrib/range-v3-0.11.0/example/find.cpp
+++ /dev/null
@@ -1,118 +0,0 @@
-// Range v3 library
-//
-//  Copyright Jeff Garland 2017
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-///[find]
-// vector:   *i: 6
-// didn't find 10
-// *i: 6
-// *i: 2
-// *i after ++ (2 expected): 2
-// array:    *i: 6
-// list:     *i: 6
-// fwd_list: *i: 4
-// deque:    *i: 6
-
-#include <array>
-#include <deque>
-#include <forward_list>
-#include <iostream>
-#include <list>
-#include <range/v3/all.hpp>
-#include <vector>
-using std::cout;
-
-auto is_six = [](int i) -> bool { return i == 6; };
-
-int
-main()
-{
-    cout << "vector:   ";
-
-    std::vector<int> v{6, 2, 6, 4, 6, 1};
-    {
-        auto i = ranges::find(v, 6); // 1 2 3 4 5 6
-        cout << "*i: " << *i << '\n';
-    }
-    {
-        auto i = ranges::find(v, 10); // 1 2 3 4 5 6
-        if(i == ranges::end(v))
-        {
-            cout << "didn't find 10\n";
-        }
-    }
-    {
-        auto i = ranges::find_if(v, is_six);
-        if(i != ranges::end(v))
-        {
-            cout << "*i: " << *i << '\n';
-        }
-    }
-    {
-        auto i = ranges::find_if_not(v, is_six);
-        if(i != ranges::end(v))
-        {
-            cout << "*i: " << *i << '\n';
-        }
-    }
-    {
-        auto i = ranges::find(v, 6);
-        i++;
-        if(i != ranges::end(v))
-        {
-            cout << "*i after ++ (2 expected): " << *i;
-        }
-    }
-
-    cout << "\narray:    ";
-
-    std::array<int, 6> a{6, 2, 3, 4, 5, 1};
-    {
-        auto i = ranges::find(a, 6);
-        if(i != ranges::end(a))
-        {
-            cout << "*i: " << *i;
-        }
-    }
-    cout << "\nlist:     ";
-
-    std::list<int> li{6, 2, 3, 4, 5, 1};
-    {
-        auto i = ranges::find(li, 6);
-        if(i != ranges::end(li))
-        {
-            cout << "*i: " << *i;
-        }
-    }
-
-    cout << "\nfwd_list: ";
-
-    std::forward_list<int> fl{6, 2, 3, 4, 5, 1};
-    {
-        auto i = ranges::find(fl, 4);
-        if(i != ranges::end(fl))
-        {
-            cout << "*i: " << *i;
-        }
-    }
-    cout << "\ndeque:    ";
-
-    std::deque<int> d{6, 2, 3, 4, 5, 1};
-    {
-        auto i = ranges::find(d, 6);
-        if(i != ranges::end(d))
-        {
-            cout << "*i: " << *i;
-        }
-    }
-    cout << '\n';
-}
-///[find]
diff --git a/src/contrib/range-v3-0.11.0/example/for_each_assoc.cpp b/src/contrib/range-v3-0.11.0/example/for_each_assoc.cpp
deleted file mode 100644
index 3c1dfbbc..00000000
--- a/src/contrib/range-v3-0.11.0/example/for_each_assoc.cpp
+++ /dev/null
@@ -1,58 +0,0 @@
-
-// Range v3 library
-//
-//  Copyright Jeff Garland 2017
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-///[for_each_assoc]
-// for_each with associative containers
-// output
-// set:           1 2 3 4 5 6
-// map:           one:1 three:3 two:2
-// unordered_map: three:3 one:1 two:2
-// unordered_set: 6 5 4 3 2 1
-
-#include <iostream>
-#include <map>
-#include <range/v3/algorithm/for_each.hpp>
-#include <set>
-#include <string>
-#include <unordered_map>
-#include <unordered_set>
-using std::cout;
-using std::string;
-
-auto print = [](int i) { cout << i << ' '; };
-// must take a pair for map types
-auto printm = [](std::pair<string, int> p) {
-    cout << p.first << ":" << p.second << ' ';
-};
-
-int
-main()
-{
-    cout << "set:           ";
-    std::set<int> si{1, 2, 3, 4, 5, 6};
-    ranges::for_each(si, print);
-
-    cout << "\nmap:           ";
-    std::map<string, int> msi{{"one", 1}, {"two", 2}, {"three", 3}};
-    ranges::for_each(msi, printm);
-
-    cout << "\nunordered map: ";
-    std::unordered_map<string, int> umsi{{"one", 1}, {"two", 2}, {"three", 3}};
-    ranges::for_each(umsi, printm);
-
-    cout << "\nunordered set: ";
-    std::unordered_set<int> usi{1, 2, 3, 4, 5, 6};
-    ranges::for_each(usi, print);
-    cout << '\n';
-}
-///[for_each_assoc]
diff --git a/src/contrib/range-v3-0.11.0/example/for_each_sequence.cpp b/src/contrib/range-v3-0.11.0/example/for_each_sequence.cpp
deleted file mode 100644
index 99c94f48..00000000
--- a/src/contrib/range-v3-0.11.0/example/for_each_sequence.cpp
+++ /dev/null
@@ -1,59 +0,0 @@
-// Range v3 library
-//
-//  Copyright Jeff Garland 2017
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-///[for_each_sequence]
-// Use the for_each to print from various containers
-// output
-// vector:   1 2 3 4 5 6
-// array:    1 2 3 4 5 6
-// list:     1 2 3 4 5 6
-// fwd_list: 1 2 3 4 5 6
-// deque:    1 2 3 4 5 6
-
-#include <array>
-#include <deque>
-#include <forward_list>
-#include <iostream>
-#include <list>
-#include <queue>
-#include <range/v3/algorithm/for_each.hpp> // specific includes
-#include <stack>
-#include <vector>
-using std::cout;
-
-auto print = [](int i) { cout << i << ' '; };
-
-int
-main()
-{
-    cout << "vector:   ";
-    std::vector<int> v{1, 2, 3, 4, 5, 6};
-    ranges::for_each(v, print); // 1 2 3 4 5 6
-
-    cout << "\narray:    ";
-    std::array<int, 6> a{1, 2, 3, 4, 5, 6};
-    ranges::for_each(a, print);
-
-    cout << "\nlist:     ";
-    std::list<int> ll{1, 2, 3, 4, 5, 6};
-    ranges::for_each(ll, print);
-
-    cout << "\nfwd_list: ";
-    std::forward_list<int> fl{1, 2, 3, 4, 5, 6};
-    ranges::for_each(fl, print);
-
-    cout << "\ndeque:    ";
-    std::deque<int> d{1, 2, 3, 4, 5, 6};
-    ranges::for_each(d, print);
-    cout << '\n';
-}
-///[for_each_sequence]
diff --git a/src/contrib/range-v3-0.11.0/example/hello.cpp b/src/contrib/range-v3-0.11.0/example/hello.cpp
deleted file mode 100644
index 2f551ab6..00000000
--- a/src/contrib/range-v3-0.11.0/example/hello.cpp
+++ /dev/null
@@ -1,29 +0,0 @@
-
-// Range v3 library
-//
-//  Copyright Jeff Garland 2017
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-///[hello]
-#include <iostream>
-#include <range/v3/all.hpp> // get everything
-#include <string>
-using std::cout;
-
-int
-main()
-{
-    std::string s{"hello"};
-
-    // output: h e l l o
-    ranges::for_each(s, [](char c) { cout << c << ' '; });
-    cout << '\n';
-}
-///[hello]
diff --git a/src/contrib/range-v3-0.11.0/example/is_sorted.cpp b/src/contrib/range-v3-0.11.0/example/is_sorted.cpp
deleted file mode 100644
index d479d4bf..00000000
--- a/src/contrib/range-v3-0.11.0/example/is_sorted.cpp
+++ /dev/null
@@ -1,35 +0,0 @@
-// Range v3 library
-//
-//  Copyright Jeff Garland 2017
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-///[is_sorted]
-// Check if a container is sorted
-// output
-// vector:   true
-// array:    false
-
-#include <array>
-#include <iostream>
-#include <range/v3/algorithm/is_sorted.hpp> // specific includes
-#include <vector>
-using std::cout;
-
-int
-main()
-{
-    cout << std::boolalpha;
-    std::vector<int> v{1, 2, 3, 4, 5, 6};
-    cout << "vector:   " << ranges::is_sorted(v) << '\n';
-
-    std::array<int, 6> a{6, 2, 3, 4, 5, 6};
-    cout << "array:    " << ranges::is_sorted(a) << '\n';
-}
-///[is_sorted]
diff --git a/src/contrib/range-v3-0.11.0/example/sort_unique.cpp b/src/contrib/range-v3-0.11.0/example/sort_unique.cpp
deleted file mode 100644
index 4c924d9e..00000000
--- a/src/contrib/range-v3-0.11.0/example/sort_unique.cpp
+++ /dev/null
@@ -1,34 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2019
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-///[sort_unique]
-// Remove all non-unique elements from a container.
-
-#include <iostream>
-#include <vector>
-
-#include <range/v3/action/sort.hpp>
-#include <range/v3/action/unique.hpp>
-#include <range/v3/view/all.hpp>
-using std::cout;
-
-int main()
-{
-    std::vector<int> vi{9, 4, 5, 2, 9, 1, 0, 2, 6, 7, 4, 5, 6, 5, 9, 2, 7,
-                        1, 4, 5, 3, 8, 5, 0, 2, 9, 3, 7, 5, 7, 5, 5, 6, 1,
-                        4, 3, 1, 8, 4, 0, 7, 8, 8, 2, 6, 5, 3, 4, 5};
-    using namespace ranges;
-    vi |= actions::sort | actions::unique;
-    // prints: [0,1,2,3,4,5,6,7,8,9]
-    cout << views::all(vi) << '\n';
-}
-///[sort_unique]
diff --git a/src/contrib/range-v3-0.11.0/include/concepts/compare.hpp b/src/contrib/range-v3-0.11.0/include/concepts/compare.hpp
deleted file mode 100644
index 4b0beb8d..00000000
--- a/src/contrib/range-v3-0.11.0/include/concepts/compare.hpp
+++ /dev/null
@@ -1,65 +0,0 @@
-/// \file
-//  CPP, the Concepts PreProcessor library
-//
-//  Copyright Eric Niebler 2018-present
-//  Copyright (c) 2020-present, Google LLC.
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// This source code is licensed under the MIT license found in the
-// LICENSE file in the root directory of this source tree.
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef CPP_COMPARE_HPP
-#define CPP_COMPARE_HPP
-
-#if __cplusplus > 201703L && defined(__cpp_impl_three_way_comparison) && __has_include(<compare>)
-
-#include <compare>
-#include <concepts/concepts.hpp>
-#include <range/v3/compare.hpp>
-
-// clang-format off
-
-namespace concepts
-{
-    // Note: concepts in this file can use C++20 concepts, since operator<=> isn't available in
-    // compilers that don't support core concepts.
-    namespace detail
-    {
-        template<typename T, typename Cat>
-        concept compares_as = same_as<ranges::common_comparison_category_t<T, Cat>, Cat>;
-    } // namespace detail
-
-    inline namespace defs
-    {
-        template<typename T, typename Cat = std::partial_ordering>
-        concept three_way_comparable =
-            detail::weakly_equality_comparable_with_<T, T> &&
-            detail::partially_ordered_with_<T ,T> &&
-            requires(detail::as_cref_t<T>& a, detail::as_cref_t<T>& b) {
-                { a <=> b } -> detail::compares_as<Cat>;
-            };
-
-        template<typename T, typename U, typename Cat = std::partial_ordering>
-        concept three_way_comparable_with =
-            three_way_comparable<T, Cat> &&
-            three_way_comparable<U, Cat> &&
-            common_reference_with<detail::as_cref_t<T>&, detail::as_cref_t<U>&> &&
-            three_way_comparable<common_reference_t<detail::as_cref_t<T>&, detail::as_cref_t<U>&>> &&
-            detail::partially_ordered_with_<T, U> &&
-            requires(detail::as_cref_t<T>& t, detail::as_cref_t<U>& u) {
-                { t <=> u } -> detail::compares_as<Cat>;
-                { u <=> t } -> detail::compares_as<Cat>;
-            };
-    } // inline namespace defs
-} // namespace concepts
-
-// clang-format on
-
-#endif // __cplusplus
-#endif // CPP_COMPARE_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/concepts/concepts.hpp b/src/contrib/range-v3-0.11.0/include/concepts/concepts.hpp
deleted file mode 100644
index 43c1a6d8..00000000
--- a/src/contrib/range-v3-0.11.0/include/concepts/concepts.hpp
+++ /dev/null
@@ -1,1130 +0,0 @@
-/// \file
-//  CPP, the Concepts PreProcessor library
-//
-//  Copyright Eric Niebler 2018-present
-//  Copyright (c) 2018-present, Facebook, Inc.
-//  Copyright (c) 2020-present, Google LLC.
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// This source code is licensed under the MIT license found in the
-// LICENSE file in the root directory of this source tree.
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef CPP_CONCEPTS_HPP
-#define CPP_CONCEPTS_HPP
-
-// clang-format off
-
-#include <initializer_list>
-#include <utility>
-#include <type_traits>
-#include <concepts/swap.hpp>
-#include <concepts/type_traits.hpp>
-
-// Disable buggy clang compatibility warning about "requires" and "concept" being
-// C++20 keywords.
-// https://bugs.llvm.org/show_bug.cgi?id=43708
-#if defined(__clang__) && __cplusplus <= 201703L
-#define CPP_PP_IGNORE_CXX2A_COMPAT_BEGIN                                                \
-    CPP_DIAGNOSTIC_PUSH                                                                 \
-    CPP_DIAGNOSTIC_IGNORE_CPP2A_COMPAT
-
-#define CPP_PP_IGNORE_CXX2A_COMPAT_END                                                  \
-    CPP_DIAGNOSTIC_POP
-
-#else
-#define CPP_PP_IGNORE_CXX2A_COMPAT_BEGIN
-#define CPP_PP_IGNORE_CXX2A_COMPAT_END
-#endif
-
-#if defined(_MSC_VER) && !defined(__clang__)
-#define CPP_WORKAROUND_MSVC_779763 // FATAL_UNREACHABLE calling constexpr function via template parameter
-#define CPP_WORKAROUND_MSVC_784772 // Failure to invoke *explicit* bool conversion in a constant expression
-#endif
-
-#if !defined(CPP_CXX_CONCEPTS)
-#ifdef CPP_DOXYGEN_INVOKED
-#define CPP_CXX_CONCEPTS 201800L
-#elif defined(__cpp_concepts) && __cpp_concepts > 0
-// gcc-6 concepts are too buggy to use
-#if !defined(__GNUC__) || defined(__clang__) || __GNUC__ >= 7
-#define CPP_CXX_CONCEPTS __cpp_concepts
-#else
-#define CPP_CXX_CONCEPTS 0L
-#endif
-#else
-#define CPP_CXX_CONCEPTS 0L
-#endif
-#endif
-
-#define CPP_PP_CAT_(X, ...)  X ## __VA_ARGS__
-#define CPP_PP_CAT(X, ...)   CPP_PP_CAT_(X, __VA_ARGS__)
-
-#define CPP_PP_EVAL_(X, ARGS) X ARGS
-#define CPP_PP_EVAL(X, ...) CPP_PP_EVAL_(X, (__VA_ARGS__))
-
-#define CPP_PP_EVAL2_(X, ARGS) X ARGS
-#define CPP_PP_EVAL2(X, ...) CPP_PP_EVAL2_(X, (__VA_ARGS__))
-
-#define CPP_PP_EXPAND(...) __VA_ARGS__
-#define CPP_PP_EAT(...)
-
-#define CPP_PP_FIRST(LIST) CPP_PP_FIRST_ LIST
-#define CPP_PP_FIRST_(...) __VA_ARGS__ CPP_PP_EAT
-
-#define CPP_PP_SECOND(LIST) CPP_PP_SECOND_ LIST
-#define CPP_PP_SECOND_(...) CPP_PP_EXPAND
-
-#define CPP_PP_CHECK(...) CPP_PP_EXPAND(CPP_PP_CHECK_N(__VA_ARGS__, 0,))
-#define CPP_PP_CHECK_N(x, n, ...) n
-#define CPP_PP_PROBE(x) x, 1,
-#define CPP_PP_PROBE_N(x, n) x, n,
-
-#define CPP_PP_IS_PAREN(x) CPP_PP_CHECK(CPP_PP_IS_PAREN_PROBE x)
-#define CPP_PP_IS_PAREN_PROBE(...) CPP_PP_PROBE(~)
-
-// CPP_CXX_VA_OPT
-#ifndef CPP_CXX_VA_OPT
-#if __cplusplus > 201703L
-#define CPP_CXX_VA_OPT_(...) CPP_PP_CHECK(__VA_OPT__(,) 1)
-#define CPP_CXX_VA_OPT CPP_CXX_VA_OPT_(~)
-#else
-#define CPP_CXX_VA_OPT 0
-#endif
-#endif // CPP_CXX_VA_OPT
-
-// The final CPP_PP_EXPAND here is to avoid
-// https://stackoverflow.com/questions/5134523/msvc-doesnt-expand-va-args-correctly
-#define CPP_PP_COUNT(...)                                                       \
-    CPP_PP_EXPAND(CPP_PP_COUNT_(__VA_ARGS__,                                    \
-        50, 49, 48, 47, 46, 45, 44, 43, 42, 41,                                 \
-        40, 39, 38, 37, 36, 35, 34, 33, 32, 31,                                 \
-        30, 29, 28, 27, 26, 25, 24, 23, 22, 21,                                 \
-        20, 19, 18, 17, 16, 15, 14, 13, 12, 11,                                 \
-        10, 9, 8, 7, 6, 5, 4, 3, 2, 1,))
-
-#define CPP_PP_COUNT_(                                                          \
-    _01, _02, _03, _04, _05, _06, _07, _08, _09, _10,                           \
-    _11, _12, _13, _14, _15, _16, _17, _18, _19, _20,                           \
-    _21, _22, _23, _24, _25, _26, _27, _28, _29, _30,                           \
-    _31, _32, _33, _34, _35, _36, _37, _38, _39, _40,                           \
-    _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, N, ...)                   \
-    N
-
-#define CPP_PP_IIF(BIT) CPP_PP_CAT_(CPP_PP_IIF_, BIT)
-#define CPP_PP_IIF_0(TRUE, ...) __VA_ARGS__
-#define CPP_PP_IIF_1(TRUE, ...) TRUE
-
-#define CPP_PP_LPAREN (
-#define CPP_PP_RPAREN )
-
-#define CPP_PP_NOT(BIT) CPP_PP_CAT_(CPP_PP_NOT_, BIT)
-#define CPP_PP_NOT_0 1
-#define CPP_PP_NOT_1 0
-
-#define CPP_PP_EMPTY()
-#define CPP_PP_COMMA() ,
-#define CPP_PP_LBRACE() {
-#define CPP_PP_RBRACE() }
-#define CPP_PP_COMMA_IIF(X)                                                     \
-    CPP_PP_IIF(X)(CPP_PP_EMPTY, CPP_PP_COMMA)()
-
-#define CPP_PP_FOR_EACH(M, ...)                                                 \
-    CPP_PP_FOR_EACH_N(CPP_PP_COUNT(__VA_ARGS__), M, __VA_ARGS__)
-#define CPP_PP_FOR_EACH_N(N, M, ...)                                            \
-    CPP_PP_CAT(CPP_PP_FOR_EACH_, N)(M, __VA_ARGS__)
-#define CPP_PP_FOR_EACH_1(M, _1)                                                \
-    M(_1)
-#define CPP_PP_FOR_EACH_2(M, _1, _2)                                            \
-    M(_1), M(_2)
-#define CPP_PP_FOR_EACH_3(M, _1, _2, _3)                                        \
-    M(_1), M(_2), M(_3)
-#define CPP_PP_FOR_EACH_4(M, _1, _2, _3, _4)                                    \
-    M(_1), M(_2), M(_3), M(_4)
-#define CPP_PP_FOR_EACH_5(M, _1, _2, _3, _4, _5)                                \
-    M(_1), M(_2), M(_3), M(_4), M(_5)
-#define CPP_PP_FOR_EACH_6(M, _1, _2, _3, _4, _5, _6)                            \
-    M(_1), M(_2), M(_3), M(_4), M(_5), M(_6)
-#define CPP_PP_FOR_EACH_7(M, _1, _2, _3, _4, _5, _6, _7)                        \
-    M(_1), M(_2), M(_3), M(_4), M(_5), M(_6), M(_7)
-#define CPP_PP_FOR_EACH_8(M, _1, _2, _3, _4, _5, _6, _7, _8)                    \
-    M(_1), M(_2), M(_3), M(_4), M(_5), M(_6), M(_7), M(_8)
-
-#define CPP_PP_PROBE_EMPTY_PROBE_CPP_PP_PROBE_EMPTY                             \
-    CPP_PP_PROBE(~)
-
-#define CPP_PP_PROBE_EMPTY()
-#define CPP_PP_IS_NOT_EMPTY(...)                                                \
-    CPP_PP_EVAL(                                                                \
-        CPP_PP_CHECK,                                                           \
-        CPP_PP_CAT(                                                             \
-            CPP_PP_PROBE_EMPTY_PROBE_,                                          \
-            CPP_PP_PROBE_EMPTY __VA_ARGS__ ()))
-
-#if defined(_MSC_VER) && !defined(__clang__) && (__cplusplus <= 201703L)
-#define CPP_BOOL(...) ::meta::bool_<__VA_ARGS__>::value
-#define CPP_TRUE_FN                                                             \
-    !::concepts::detail::instance_<                                             \
-        decltype(CPP_true_fn(::concepts::detail::xNil{}))>
-
-#define CPP_NOT(...) (!CPP_BOOL(__VA_ARGS__))
-#else
-#define CPP_BOOL(...) __VA_ARGS__
-#define CPP_TRUE_FN CPP_true_fn(::concepts::detail::xNil{})
-#define CPP_NOT(...) (!(__VA_ARGS__))
-#endif
-
-#define CPP_assert(...)                                                         \
-    static_assert(static_cast<bool>(__VA_ARGS__),                               \
-        "Concept assertion failed : " #__VA_ARGS__)
-
-#define CPP_assert_msg static_assert
-
-#if CPP_CXX_CONCEPTS || defined(CPP_DOXYGEN_INVOKED)
-#define CPP_concept META_CONCEPT
-#define CPP_and &&
-
-#else
-#define CPP_concept CPP_INLINE_VAR constexpr bool
-#define CPP_and CPP_and_sfinae
-
-#endif
-
-////////////////////////////////////////////////////////////////////////////////
-// CPP_template
-// Usage:
-//   CPP_template(typename A, typename B)
-//     (requires Concept1<A> CPP_and Concept2<B>)
-//   void foo(A a, B b)
-//   {}
-#if CPP_CXX_CONCEPTS
-#define CPP_template(...) template<__VA_ARGS__ CPP_TEMPLATE_AUX_
-#define CPP_template_def CPP_template
-#define CPP_member
-#define CPP_ctor(TYPE) TYPE CPP_CTOR_IMPL_1_
-
-#if defined(CPP_DOXYGEN_INVOKED) && CPP_DOXYGEN_INVOKED
-/// INTERNAL ONLY
-#define CPP_CTOR_IMPL_1_(...) (__VA_ARGS__) CPP_CTOR_IMPL_2_
-#define CPP_CTOR_IMPL_2_(...) __VA_ARGS__ `
-#else
-/// INTERNAL ONLY
-#define CPP_CTOR_IMPL_1_(...) (__VA_ARGS__) CPP_PP_EXPAND
-#endif
-
-/// INTERNAL ONLY
-#define CPP_TEMPLATE_AUX_(...)                                                  \
-    > CPP_PP_CAT(                                                               \
-        CPP_TEMPLATE_AUX_,                                                      \
-        CPP_TEMPLATE_AUX_WHICH_(__VA_ARGS__,))(__VA_ARGS__)
-
-/// INTERNAL ONLY
-#define CPP_TEMPLATE_AUX_WHICH_(FIRST, ...)                                     \
-    CPP_PP_EVAL(                                                                \
-        CPP_PP_CHECK,                                                           \
-        CPP_PP_CAT(CPP_TEMPLATE_PROBE_CONCEPT_, FIRST))
-
-/// INTERNAL ONLY
-#define CPP_TEMPLATE_PROBE_CONCEPT_concept                                      \
-    CPP_PP_PROBE(~)
-
-#if defined(CPP_DOXYGEN_INVOKED) && CPP_DOXYGEN_INVOKED
-// A template with a requires clause. Turn the requires clause into
-// a Doxygen precondition block.
-/// INTERNAL ONLY
-#define CPP_TEMPLATE_AUX_0(...) __VA_ARGS__`
-#define requires requires `
-
-#else
-// A template with a requires clause
-/// INTERNAL ONLY
-#define CPP_TEMPLATE_AUX_0(...) __VA_ARGS__
-#endif
-
-// A concept definition
-/// INTERNAL ONLY
-#define CPP_TEMPLATE_AUX_1(DECL, ...)                                           \
-    CPP_concept CPP_CONCEPT_NAME_(DECL) = __VA_ARGS__
-
-#define CPP_concept_ref(NAME, ...)                                              \
-    CPP_PP_CAT(NAME, _concept_)<__VA_ARGS__>
-
-#else // ^^^^ with concepts / without concepts vvvv
-
-#define CPP_template CPP_template_sfinae
-#define CPP_template_def CPP_template_def_sfinae
-#define CPP_member CPP_member_sfinae
-#define CPP_ctor CPP_ctor_sfinae
-#define CPP_concept_ref(NAME, ...)                                              \
-    (1u == sizeof(CPP_PP_CAT(NAME, _concept_)(                                  \
-        (::concepts::detail::tag<__VA_ARGS__>*)nullptr)))
-
-/// INTERNAL ONLY
-#define CPP_TEMPLATE_AUX_ CPP_TEMPLATE_SFINAE_AUX_
-
-#endif
-
-#define CPP_template_sfinae(...)                                                \
-    CPP_PP_IGNORE_CXX2A_COMPAT_BEGIN                                            \
-    template<__VA_ARGS__ CPP_TEMPLATE_SFINAE_AUX_
-
-/// INTERNAL ONLY
-#define CPP_TEMPLATE_SFINAE_PROBE_CONCEPT_concept                               \
-    CPP_PP_PROBE(~)
-
-/// INTERNAL ONLY
-#define CPP_TEMPLATE_SFINAE_AUX_WHICH_(FIRST, ...)                              \
-    CPP_PP_EVAL(                                                                \
-        CPP_PP_CHECK,                                                           \
-        CPP_PP_CAT(CPP_TEMPLATE_SFINAE_PROBE_CONCEPT_, FIRST))
-
-/// INTERNAL ONLY
-#define CPP_TEMPLATE_SFINAE_AUX_(...)                                           \
-    CPP_PP_CAT(                                                                 \
-        CPP_TEMPLATE_SFINAE_AUX_,                                               \
-        CPP_TEMPLATE_SFINAE_AUX_WHICH_(__VA_ARGS__,))(__VA_ARGS__)
-
-// A template with a requires clause
-/// INTERNAL ONLY
-#define CPP_TEMPLATE_SFINAE_AUX_0(...) ,                                        \
-    bool CPP_true = true,                                                       \
-    std::enable_if_t<                                                           \
-        CPP_PP_CAT(CPP_TEMPLATE_SFINAE_AUX_3_, __VA_ARGS__) &&                  \
-        CPP_BOOL(CPP_true),                                                     \
-        int> = 0>                                                               \
-    CPP_PP_IGNORE_CXX2A_COMPAT_END
-
-// A concept definition
-/// INTERNAL ONLY
-#define CPP_TEMPLATE_SFINAE_AUX_1(DECL, ...) ,                                  \
-        bool CPP_true = true,                                                   \
-        std::enable_if_t<__VA_ARGS__ && CPP_BOOL(CPP_true), int> = 0>           \
-    auto CPP_CONCEPT_NAME_(DECL)(                                               \
-        ::concepts::detail::tag<CPP_CONCEPT_PARAMS_(DECL)>*)                    \
-        -> char(&)[1];                                                          \
-    auto CPP_CONCEPT_NAME_(DECL)(...) -> char(&)[2]                             \
-    CPP_PP_IGNORE_CXX2A_COMPAT_END
-
-/// INTERNAL ONLY
-#define CPP_CONCEPT_NAME_(DECL)                                                 \
-    CPP_PP_EVAL(                                                                \
-        CPP_PP_CAT,                                                             \
-        CPP_PP_EVAL(CPP_PP_FIRST, CPP_EAT_CONCEPT_(DECL)), _concept_)
-
-/// INTERNAL ONLY
-#define CPP_CONCEPT_PARAMS_(DECL)                                               \
-    CPP_PP_EVAL(CPP_PP_SECOND, CPP_EAT_CONCEPT_(DECL))
-
-/// INTERNAL ONLY
-#define CPP_EAT_CONCEPT_(DECL)                                                  \
-    CPP_PP_CAT(CPP_EAT_CONCEPT_, DECL)
-
-/// INTERNAL ONLY
-#define CPP_EAT_CONCEPT_concept
-
-#define CPP_and_sfinae                                                          \
-    && CPP_BOOL(CPP_true), int> = 0, std::enable_if_t<
-
-#define CPP_template_def_sfinae(...)                                            \
-    template<__VA_ARGS__ CPP_TEMPLATE_DEF_SFINAE_AUX_
-
-/// INTERNAL ONLY
-#define CPP_TEMPLATE_DEF_SFINAE_AUX_(...) ,                                     \
-    bool CPP_true,                                                              \
-    std::enable_if_t<                                                           \
-        CPP_PP_CAT(CPP_TEMPLATE_SFINAE_AUX_3_, __VA_ARGS__) &&                  \
-        CPP_BOOL(CPP_true),                                                     \
-        int>>
-
-#define CPP_and_sfinae_def                                                      \
-    && CPP_BOOL(CPP_true), int>, std::enable_if_t<
-
-/// INTERNAL ONLY
-#define CPP_TEMPLATE_SFINAE_AUX_3_requires
-
-#define CPP_member_sfinae                                                       \
-    CPP_broken_friend_member
-
-#define CPP_ctor_sfinae(TYPE)                                                   \
-    CPP_PP_IGNORE_CXX2A_COMPAT_BEGIN                                            \
-    TYPE CPP_CTOR_SFINAE_IMPL_1_
-
-/// INTERNAL ONLY
-#define CPP_CTOR_SFINAE_IMPL_1_(...)                                            \
-    (__VA_ARGS__                                                                \
-        CPP_PP_COMMA_IIF(                                                       \
-            CPP_PP_NOT(CPP_PP_IS_NOT_EMPTY(__VA_ARGS__)))                       \
-    CPP_CTOR_SFINAE_REQUIRES
-
-/// INTERNAL ONLY
-#define CPP_CTOR_SFINAE_PROBE_NOEXCEPT_noexcept                                 \
-    CPP_PP_PROBE(~)
-
-/// INTERNAL ONLY
-#define CPP_CTOR_SFINAE_MAKE_PROBE(FIRST,...)                                   \
-    CPP_PP_CAT(CPP_CTOR_SFINAE_PROBE_NOEXCEPT_, FIRST)
-
-/// INTERNAL ONLY
-#define CPP_CTOR_SFINAE_REQUIRES(...)                                           \
-    CPP_PP_CAT(                                                                 \
-        CPP_CTOR_SFINAE_REQUIRES_,                                              \
-        CPP_PP_EVAL(                                                            \
-            CPP_PP_CHECK,                                                       \
-            CPP_CTOR_SFINAE_MAKE_PROBE(__VA_ARGS__,)))(__VA_ARGS__)
-
-// No noexcept-clause:
-/// INTERNAL ONLY
-#define CPP_CTOR_SFINAE_REQUIRES_0(...)                                         \
-    std::enable_if_t<                                                           \
-        CPP_PP_CAT(CPP_TEMPLATE_SFINAE_AUX_3_, __VA_ARGS__) && CPP_TRUE_FN,     \
-        ::concepts::detail::Nil                                                 \
-    > = {})                                                                     \
-    CPP_PP_IGNORE_CXX2A_COMPAT_END
-
-// Yes noexcept-clause:
-/// INTERNAL ONLY
-#define CPP_CTOR_SFINAE_REQUIRES_1(...)                                         \
-    std::enable_if_t<                                                           \
-        CPP_PP_EVAL(CPP_PP_CAT,                                                 \
-            CPP_TEMPLATE_SFINAE_AUX_3_,                                         \
-            CPP_PP_CAT(CPP_CTOR_SFINAE_EAT_NOEXCEPT_, __VA_ARGS__)) && CPP_TRUE_FN,\
-        ::concepts::detail::Nil                                                 \
-    > = {})                                                                     \
-    CPP_PP_EXPAND(CPP_PP_CAT(CPP_CTOR_SFINAE_SHOW_NOEXCEPT_, __VA_ARGS__)))
-
-/// INTERNAL ONLY
-#define CPP_CTOR_SFINAE_EAT_NOEXCEPT_noexcept(...)
-
-/// INTERNAL ONLY
-#define CPP_CTOR_SFINAE_SHOW_NOEXCEPT_noexcept(...)                             \
-    noexcept(__VA_ARGS__)                                                       \
-    CPP_PP_IGNORE_CXX2A_COMPAT_END                                              \
-    CPP_PP_EAT CPP_PP_LPAREN
-
-#ifdef CPP_DOXYGEN_INVOKED
-#define CPP_broken_friend_ret(...)                                              \
-    __VA_ARGS__ CPP_PP_EXPAND
-
-#else // ^^^ CPP_DOXYGEN_INVOKED / not CPP_DOXYGEN_INVOKED vvv
-#define CPP_broken_friend_ret(...)                                              \
-    ::concepts::return_t<                                                       \
-        __VA_ARGS__,                                                            \
-        std::enable_if_t<CPP_BROKEN_FRIEND_RETURN_TYPE_AUX_
-
-/// INTERNAL ONLY
-#define CPP_BROKEN_FRIEND_RETURN_TYPE_AUX_(...)                                 \
-    CPP_BROKEN_FRIEND_RETURN_TYPE_AUX_3_(CPP_PP_CAT(                            \
-        CPP_TEMPLATE_AUX_2_, __VA_ARGS__))
-
-/// INTERNAL ONLY
-#define CPP_TEMPLATE_AUX_2_requires
-
-/// INTERNAL ONLY
-#define CPP_BROKEN_FRIEND_RETURN_TYPE_AUX_3_(...)                               \
-    __VA_ARGS__ && CPP_TRUE_FN>>
-
-#ifdef CPP_WORKAROUND_MSVC_779763
-#define CPP_broken_friend_member                                                \
-    template<::concepts::detail::CPP_true_t const &CPP_true_fn =                \
-        ::concepts::detail::CPP_true_fn_>
-
-#else // ^^^ workaround / no workaround vvv
-#define CPP_broken_friend_member                                                \
-    template<bool (&CPP_true_fn)(::concepts::detail::xNil) =                    \
-        ::concepts::detail::CPP_true_fn>
-
-#endif // CPP_WORKAROUND_MSVC_779763
-#endif
-
-#if CPP_CXX_CONCEPTS
-#define CPP_requires(NAME, REQS)                                                \
-CPP_concept CPP_PP_CAT(NAME, _requires_) =                                      \
-    CPP_PP_CAT(CPP_REQUIRES_, REQS)
-
-#define CPP_requires_ref(NAME, ...)                                             \
-    CPP_PP_CAT(NAME, _requires_)<__VA_ARGS__>
-
-/// INTERNAL ONLY
-#define CPP_REQUIRES_requires(...)                                              \
-    requires(__VA_ARGS__) CPP_REQUIRES_AUX_
-
-/// INTERNAL ONLY
-#define CPP_REQUIRES_AUX_(...)                                                  \
-    { __VA_ARGS__; }
-
-#else
-#define CPP_requires(NAME, REQS)                                                \
-    auto CPP_PP_CAT(NAME, _requires_test_)                                      \
-    CPP_REQUIRES_AUX_(NAME, CPP_REQUIRES_ ## REQS)
-
-#define CPP_requires_ref(NAME, ...)                                             \
-    (1u == sizeof(CPP_PP_CAT(NAME, _requires_)(                                 \
-        (::concepts::detail::tag<__VA_ARGS__>*)nullptr)))
-
-/// INTERNAL ONLY
-#define CPP_REQUIRES_requires(...)                                              \
-    (__VA_ARGS__) -> decltype CPP_REQUIRES_RETURN_
-
-/// INTERNAL ONLY
-#define CPP_REQUIRES_RETURN_(...) (__VA_ARGS__, void()) {}
-
-/// INTERNAL ONLY
-#define CPP_REQUIRES_AUX_(NAME, ...)                                            \
-    __VA_ARGS__                                                                 \
-    template<typename... As>                                                    \
-    auto CPP_PP_CAT(NAME, _requires_)(                                          \
-        ::concepts::detail::tag<As...> *,                                       \
-        decltype(&CPP_PP_CAT(NAME, _requires_test_)<As...>) = nullptr)          \
-        -> char(&)[1];                                                          \
-    auto CPP_PP_CAT(NAME, _requires_)(...) -> char(&)[2]
-
-#endif
-
-#if CPP_CXX_CONCEPTS
-
-#if defined(CPP_DOXYGEN_INVOKED) && CPP_DOXYGEN_INVOKED
-#define CPP_ret(...)                                                            \
-    __VA_ARGS__ CPP_RET_AUX_
-#define CPP_RET_AUX_(...) __VA_ARGS__ `
-#else
-#define CPP_ret(...)                                                            \
-    __VA_ARGS__ CPP_PP_EXPAND
-#endif
-
-#else
-#define CPP_ret                                                                 \
-    CPP_broken_friend_ret
-
-#endif
-
-////////////////////////////////////////////////////////////////////////////////
-// CPP_fun
-#if CPP_CXX_CONCEPTS
-
-#if defined(CPP_DOXYGEN_INVOKED) && CPP_DOXYGEN_INVOKED
-/// INTERNAL ONLY
-#define CPP_FUN_IMPL_1_(...)                                                    \
-    (__VA_ARGS__)                                                               \
-    CPP_FUN_IMPL_2_
-#define CPP_FUN_IMPL_2_(...)                                                    \
-    __VA_ARGS__ `
-#else
-/// INTERNAL ONLY
-#define CPP_FUN_IMPL_1_(...)                                                    \
-    (__VA_ARGS__)                                                               \
-    CPP_PP_EXPAND
-#endif
-
-#define CPP_fun(X) X CPP_FUN_IMPL_1_
-#else
-/// INTERNAL ONLY
-#define CPP_FUN_IMPL_1_(...)                                                    \
-    (__VA_ARGS__                                                                \
-        CPP_PP_COMMA_IIF(                                                       \
-            CPP_PP_NOT(CPP_PP_IS_NOT_EMPTY(__VA_ARGS__)))                       \
-    CPP_FUN_IMPL_REQUIRES
-
-/// INTERNAL ONLY
-#define CPP_FUN_IMPL_REQUIRES(...)                                              \
-    CPP_PP_EVAL2_(                                                              \
-        CPP_FUN_IMPL_SELECT_CONST_,                                             \
-        (__VA_ARGS__,)                                                          \
-    )(__VA_ARGS__)
-
-/// INTERNAL ONLY
-#define CPP_FUN_IMPL_SELECT_CONST_(MAYBE_CONST, ...)                            \
-    CPP_PP_CAT(CPP_FUN_IMPL_SELECT_CONST_,                                      \
-        CPP_PP_EVAL(CPP_PP_CHECK, CPP_PP_CAT(                                   \
-            CPP_PP_PROBE_CONST_PROBE_, MAYBE_CONST)))
-
-/// INTERNAL ONLY
-#define CPP_PP_PROBE_CONST_PROBE_const CPP_PP_PROBE(~)
-
-/// INTERNAL ONLY
-#define CPP_FUN_IMPL_SELECT_CONST_1(...)                                        \
-    CPP_PP_EVAL(                                                                \
-        CPP_FUN_IMPL_SELECT_CONST_NOEXCEPT_,                                    \
-        CPP_PP_CAT(CPP_FUN_IMPL_EAT_CONST_, __VA_ARGS__),)(                     \
-        CPP_PP_CAT(CPP_FUN_IMPL_EAT_CONST_, __VA_ARGS__))
-
-/// INTERNAL ONLY
-#define CPP_FUN_IMPL_SELECT_CONST_NOEXCEPT_(MAYBE_NOEXCEPT, ...)                \
-    CPP_PP_CAT(CPP_FUN_IMPL_SELECT_CONST_NOEXCEPT_,                             \
-        CPP_PP_EVAL2(CPP_PP_CHECK, CPP_PP_CAT(                                  \
-            CPP_PP_PROBE_NOEXCEPT_PROBE_, MAYBE_NOEXCEPT)))
-
-/// INTERNAL ONLY
-#define CPP_PP_PROBE_NOEXCEPT_PROBE_noexcept CPP_PP_PROBE(~)
-
-/// INTERNAL ONLY
-#define CPP_FUN_IMPL_SELECT_CONST_NOEXCEPT_0(...)                               \
-    std::enable_if_t<                                                           \
-        CPP_PP_EVAL(                                                            \
-            CPP_PP_CAT,                                                         \
-            CPP_FUN_IMPL_EAT_REQUIRES_,                                         \
-            __VA_ARGS__) && CPP_TRUE_FN,                                           \
-        ::concepts::detail::Nil                                                 \
-    > = {}) const                                                               \
-    CPP_PP_IGNORE_CXX2A_COMPAT_END
-
-/// INTERNAL ONLY
-#define CPP_FUN_IMPL_SELECT_CONST_NOEXCEPT_1(...)                               \
-    std::enable_if_t<                                                           \
-        CPP_PP_EVAL(                                                            \
-            CPP_PP_CAT,                                                         \
-            CPP_FUN_IMPL_EAT_REQUIRES_,                                         \
-            CPP_PP_CAT(CPP_FUN_IMPL_EAT_NOEXCEPT_, __VA_ARGS__)) && CPP_TRUE_FN,   \
-        ::concepts::detail::Nil                                                 \
-    > = {}) const                                                               \
-    CPP_PP_EXPAND(CPP_PP_CAT(CPP_FUN_IMPL_SHOW_NOEXCEPT_, __VA_ARGS__)))
-
-/// INTERNAL ONLY
-#define CPP_FUN_IMPL_EAT_NOEXCEPT_noexcept(...)
-
-/// INTERNAL ONLY
-#define CPP_FUN_IMPL_SHOW_NOEXCEPT_noexcept(...)                                \
-    noexcept(__VA_ARGS__) CPP_PP_IGNORE_CXX2A_COMPAT_END                        \
-    CPP_PP_EAT CPP_PP_LPAREN
-
-/// INTERNAL ONLY
-#define CPP_FUN_IMPL_SELECT_CONST_0(...)                                        \
-    CPP_PP_EVAL_(                                                               \
-        CPP_FUN_IMPL_SELECT_NONCONST_NOEXCEPT_,                                 \
-        (__VA_ARGS__,)                                                          \
-    )(__VA_ARGS__)
-
-/// INTERNAL ONLY
-#define CPP_FUN_IMPL_SELECT_NONCONST_NOEXCEPT_(MAYBE_NOEXCEPT, ...)             \
-    CPP_PP_CAT(CPP_FUN_IMPL_SELECT_NONCONST_NOEXCEPT_,                          \
-          CPP_PP_EVAL2(CPP_PP_CHECK, CPP_PP_CAT(                                \
-            CPP_PP_PROBE_NOEXCEPT_PROBE_, MAYBE_NOEXCEPT)))
-
-/// INTERNAL ONLY
-#define CPP_FUN_IMPL_SELECT_NONCONST_NOEXCEPT_0(...)                            \
-    std::enable_if_t<                                                           \
-        CPP_PP_CAT(CPP_FUN_IMPL_EAT_REQUIRES_, __VA_ARGS__) && CPP_TRUE_FN,        \
-        ::concepts::detail::Nil                                                 \
-    > = {})                                                                     \
-    CPP_PP_IGNORE_CXX2A_COMPAT_END
-
-/// INTERNAL ONLY
-#define CPP_FUN_IMPL_SELECT_NONCONST_NOEXCEPT_1(...)                            \
-    std::enable_if_t<                                                           \
-        CPP_PP_EVAL(                                                            \
-            CPP_PP_CAT,                                                         \
-            CPP_FUN_IMPL_EAT_REQUIRES_,                                         \
-            CPP_PP_CAT(CPP_FUN_IMPL_EAT_NOEXCEPT_, __VA_ARGS__)                 \
-        ) && CPP_TRUE_FN,                                                          \
-        ::concepts::detail::Nil                                                 \
-    > = {})                                                                     \
-    CPP_PP_EXPAND(CPP_PP_CAT(CPP_FUN_IMPL_SHOW_NOEXCEPT_, __VA_ARGS__)))
-
-/// INTERNAL ONLY
-#define CPP_FUN_IMPL_EAT_CONST_const
-
-/// INTERNAL ONLY
-#define CPP_FUN_IMPL_EAT_REQUIRES_requires
-
-////////////////////////////////////////////////////////////////////////////////
-// CPP_fun
-// Usage:
-//   template <typename A, typename B>
-//   void CPP_fun(foo)(A a, B b)([const]opt [noexcept(true)]opt
-//       requires Concept1<A> && Concept2<B>)
-//   {}
-//
-// Note: This macro cannot be used when the last function argument is a
-//       parameter pack.
-#define CPP_fun(X) CPP_PP_IGNORE_CXX2A_COMPAT_BEGIN X CPP_FUN_IMPL_1_
-#endif
-
-////////////////////////////////////////////////////////////////////////////////
-// CPP_auto_fun
-// Usage:
-//   template <typename A, typename B>
-//   auto CPP_auto_fun(foo)(A a, B b)([const]opt [noexcept(cond)]opt)opt
-//   (
-//       return a + b
-//   )
-#define CPP_auto_fun(X) X CPP_AUTO_FUN_IMPL_
-
-/// INTERNAL ONLY
-#define CPP_AUTO_FUN_IMPL_(...) (__VA_ARGS__) CPP_AUTO_FUN_RETURNS_
-
-/// INTERNAL ONLY
-#define CPP_AUTO_FUN_RETURNS_(...)                                              \
-    CPP_PP_EVAL2_(                                                              \
-        CPP_AUTO_FUN_SELECT_RETURNS_,                                           \
-        (__VA_ARGS__,)                                                          \
-    )(__VA_ARGS__)
-
-/// INTERNAL ONLY
-#define CPP_AUTO_FUN_SELECT_RETURNS_(MAYBE_CONST, ...)                          \
-    CPP_PP_CAT(CPP_AUTO_FUN_RETURNS_CONST_,                                     \
-        CPP_PP_EVAL(CPP_PP_CHECK, CPP_PP_CAT(                                   \
-            CPP_PP_PROBE_CONST_MUTABLE_PROBE_, MAYBE_CONST)))
-
-/// INTERNAL ONLY
-#define CPP_PP_PROBE_CONST_MUTABLE_PROBE_const CPP_PP_PROBE_N(~, 1)
-
-/// INTERNAL ONLY
-#define CPP_PP_PROBE_CONST_MUTABLE_PROBE_mutable CPP_PP_PROBE_N(~, 2)
-
-/// INTERNAL ONLY
-#define CPP_PP_EAT_MUTABLE_mutable
-
-/// INTERNAL ONLY
-#define CPP_AUTO_FUN_RETURNS_CONST_2(...)                                       \
-    CPP_PP_CAT(CPP_PP_EAT_MUTABLE_, __VA_ARGS__) CPP_AUTO_FUN_RETURNS_CONST_0
-
-/// INTERNAL ONLY
-#define CPP_AUTO_FUN_RETURNS_CONST_1(...)                                       \
-    __VA_ARGS__ CPP_AUTO_FUN_RETURNS_CONST_0
-
-/// INTERNAL ONLY
-#define CPP_AUTO_FUN_RETURNS_CONST_0(...)                                       \
-    CPP_PP_EVAL(CPP_AUTO_FUN_DECLTYPE_NOEXCEPT_,                                \
-        CPP_PP_CAT(CPP_AUTO_FUN_RETURNS_, __VA_ARGS__))
-
-/// INTERNAL ONLY
-#define CPP_AUTO_FUN_RETURNS_return
-
-#ifdef __cpp_guaranteed_copy_elision
-/// INTERNAL ONLY
-#define CPP_AUTO_FUN_DECLTYPE_NOEXCEPT_(...)                                    \
-    noexcept(noexcept(__VA_ARGS__)) -> decltype(__VA_ARGS__)                    \
-    { return (__VA_ARGS__); }
-
-#else
-/// INTERNAL ONLY
-#define CPP_AUTO_FUN_DECLTYPE_NOEXCEPT_(...)                                    \
-    noexcept(noexcept(decltype(__VA_ARGS__)(__VA_ARGS__))) ->                   \
-    decltype(__VA_ARGS__)                                                       \
-    { return (__VA_ARGS__); }
-
-#endif
-
-namespace concepts
-{
-    template<bool B>
-    using bool_ = std::integral_constant<bool, B>;
-
-#if defined(__cpp_fold_expressions) && __cpp_fold_expressions >= 201603
-    template<bool...Bs>
-    CPP_INLINE_VAR constexpr bool and_v = (Bs &&...);
-
-    template<bool...Bs>
-    CPP_INLINE_VAR constexpr bool or_v = (Bs ||...);
-#else
-    namespace detail
-    {
-        template<bool...>
-        struct bools;
-    } // namespace detail
-
-    template<bool...Bs>
-    CPP_INLINE_VAR constexpr bool and_v =
-        META_IS_SAME(detail::bools<Bs..., true>, detail::bools<true, Bs...>);
-
-    template<bool...Bs>
-    CPP_INLINE_VAR constexpr bool or_v =
-        !META_IS_SAME(detail::bools<Bs..., false>, detail::bools<false, Bs...>);
-#endif
-
-    template<typename>
-    struct return_t_
-    {
-        template<typename T>
-        using invoke = T;
-    };
-
-    template<typename T, typename EnableIf>
-    using return_t = meta::invoke<return_t_<EnableIf>, T>;
-
-    namespace detail
-    {
-        struct ignore
-        {
-            template<class... Args>
-            constexpr ignore(Args&&...) noexcept {}
-        };
-
-        template<class>
-        constexpr bool true_()
-        {
-            return true;
-        }
-
-        template<typename...>
-        struct tag;
-
-        template<typename T>
-        CPP_INLINE_VAR constexpr T instance_ = T{};
-
-        template<typename>
-        constexpr bool requires_()
-        {
-            return true;
-        }
-
-        struct Nil
-        {};
-
-#ifdef CPP_WORKAROUND_MSVC_779763
-        enum class xNil {};
-
-        struct CPP_true_t
-        {
-            constexpr bool operator()(Nil) const noexcept
-            {
-                return true;
-            }
-            constexpr bool operator()(xNil) const noexcept
-            {
-                return true;
-            }
-        };
-
-        CPP_INLINE_VAR constexpr CPP_true_t CPP_true_fn_ {};
-
-        constexpr bool CPP_true_fn(xNil)
-        {
-            return true;
-        }
-#else
-        using xNil = Nil;
-#endif
-
-        constexpr bool CPP_true_fn(Nil)
-        {
-            return true;
-        }
-    } // namespace detail
-
-#if defined(__clang__) || defined(_MSC_VER)
-    template<bool B>
-    std::enable_if_t<B> requires_()
-    {}
-#else
-    template<bool B>
-    CPP_INLINE_VAR constexpr std::enable_if_t<B, int> requires_ = 0;
-#endif
-
-    inline namespace defs
-    {
-        ////////////////////////////////////////////////////////////////////////
-        // Utility concepts
-        ////////////////////////////////////////////////////////////////////////
-
-        template<bool B>
-        CPP_concept is_true = B;
-
-        template<typename... Args>
-        CPP_concept type = true;
-
-        template<class T, template<typename...> class Trait, typename... Args>
-        CPP_concept satisfies =
-            static_cast<bool>(Trait<T, Args...>::type::value);
-
-        ////////////////////////////////////////////////////////////////////////
-        // Core language concepts
-        ////////////////////////////////////////////////////////////////////////
-
-        template<typename A, typename B>
-        CPP_concept same_as =
-            META_IS_SAME(A, B) && META_IS_SAME(B, A);
-
-        /// \cond
-        template<typename A, typename B>
-        CPP_concept not_same_as_ =
-            (!same_as<remove_cvref_t<A>, remove_cvref_t<B>>);
-
-        // Workaround bug in the Standard Library:
-        // From cannot be an incomplete class type despite that
-        // is_convertible<X, Y> should be equivalent to is_convertible<X&&, Y>
-        // in such a case.
-        template<typename From, typename To>
-        CPP_concept implicitly_convertible_to =
-            std::is_convertible<std::add_rvalue_reference_t<From>, To>::value;
-
-        template<typename From, typename To>
-        CPP_requires(explicitly_convertible_to_,
-            requires(From(*from)()) //
-            (
-                static_cast<To>(from())
-            ));
-        template<typename From, typename To>
-        CPP_concept explicitly_convertible_to =
-            CPP_requires_ref(concepts::explicitly_convertible_to_, From, To);
-        /// \endcond
-
-        template<typename From, typename To>
-        CPP_concept convertible_to =
-            implicitly_convertible_to<From, To> &&
-            explicitly_convertible_to<From, To>;
-
-        CPP_template(typename T, typename U)(
-        concept (derived_from_)(T, U),
-            convertible_to<T const volatile *, U const volatile *>
-        );
-        template<typename T, typename U>
-        CPP_concept derived_from =
-            META_IS_BASE_OF(U, T) &&
-            CPP_concept_ref(concepts::derived_from_, T, U);
-
-        CPP_template(typename T, typename U)(
-        concept (common_reference_with_)(T, U),
-            same_as<common_reference_t<T, U>, common_reference_t<U, T>> CPP_and
-            convertible_to<T, common_reference_t<T, U>> CPP_and
-            convertible_to<U, common_reference_t<T, U>>
-        );
-        template<typename T, typename U>
-        CPP_concept common_reference_with =
-            CPP_concept_ref(concepts::common_reference_with_, T, U);
-
-        CPP_template(typename T, typename U)(
-        concept (common_with_)(T, U),
-            same_as<common_type_t<T, U>, common_type_t<U, T>> CPP_and
-            convertible_to<T, common_type_t<T, U>> CPP_and
-            convertible_to<U, common_type_t<T, U>> CPP_and
-            common_reference_with<
-                std::add_lvalue_reference_t<T const>,
-                std::add_lvalue_reference_t<U const>> CPP_and
-            common_reference_with<
-                std::add_lvalue_reference_t<common_type_t<T, U>>,
-                common_reference_t<
-                    std::add_lvalue_reference_t<T const>,
-                    std::add_lvalue_reference_t<U const>>>
-        );
-        template<typename T, typename U>
-        CPP_concept common_with =
-            CPP_concept_ref(concepts::common_with_, T, U);
-
-        template<typename T>
-        CPP_concept integral =
-            std::is_integral<T>::value;
-
-        template<typename T>
-        CPP_concept signed_integral =
-            integral<T> &&
-            std::is_signed<T>::value;
-
-        template<typename T>
-        CPP_concept unsigned_integral =
-            integral<T> &&
-            !signed_integral<T>;
-
-        template<typename T, typename U>
-        CPP_requires(assignable_from_,
-            requires(T t, U && u) //
-            (
-                t = (U &&) u,
-                requires_<same_as<T, decltype(t = (U &&) u)>>
-            ));
-        template<typename T, typename U>
-        CPP_concept assignable_from =
-            std::is_lvalue_reference<T>::value &&
-            common_reference_with<detail::as_cref_t<T>, detail::as_cref_t<U>> &&
-            CPP_requires_ref(defs::assignable_from_, T, U);
-
-        template<typename T>
-        CPP_requires(swappable_,
-            requires(T & t, T & u) //
-            (
-                concepts::swap(t, u)
-            ));
-        template<typename T>
-        CPP_concept swappable =
-            CPP_requires_ref(defs::swappable_, T);
-
-        template<typename T, typename U>
-        CPP_requires(swappable_with_,
-            requires(T && t, U && u) //
-            (
-                concepts::swap((T &&) t, (T &&) t),
-                concepts::swap((U &&) u, (U &&) u),
-                concepts::swap((U &&) u, (T &&) t),
-                concepts::swap((T &&) t, (U &&) u)
-            ));
-        template<typename T, typename U>
-        CPP_concept swappable_with =
-            common_reference_with<detail::as_cref_t<T>, detail::as_cref_t<U>> &&
-            CPP_requires_ref(defs::swappable_with_, T, U);
-
-    }  // inline namespace defs
-
-    namespace detail
-    {
-        template<typename T>
-        CPP_concept boolean_testable_impl_ = convertible_to<T, bool>;
-
-        template<typename T>
-        CPP_requires(boolean_testable_frag_,
-            requires(T && t) //
-            (
-                !(T&&) t,
-                concepts::requires_<boolean_testable_impl_<decltype(!(T&&) t)>>
-            ));
-
-        template<typename T>
-        CPP_concept boolean_testable_ =
-            CPP_requires_ref(boolean_testable_frag_, T) &&
-            boolean_testable_impl_<T>;
-
-        CPP_DIAGNOSTIC_PUSH
-        CPP_DIAGNOSTIC_IGNORE_FLOAT_EQUAL
-
-        template<typename T, typename U>
-        CPP_requires(weakly_equality_comparable_with_frag_,
-            requires(detail::as_cref_t<T> t, detail::as_cref_t<U> u) //
-            (
-                concepts::requires_<boolean_testable_<decltype(t == u)>>,
-                concepts::requires_<boolean_testable_<decltype(t != u)>>,
-                concepts::requires_<boolean_testable_<decltype(u == t)>>,
-                concepts::requires_<boolean_testable_<decltype(u != t)>>
-            ));
-        template<typename T, typename U>
-        CPP_concept weakly_equality_comparable_with_ =
-            CPP_requires_ref(weakly_equality_comparable_with_frag_, T, U);
-
-        template<typename T, typename U>
-        CPP_requires(partially_ordered_with_frag_,
-            requires(detail::as_cref_t<T>& t, detail::as_cref_t<U>& u) //
-            (
-                concepts::requires_<boolean_testable_<decltype(t < u)>>,
-                concepts::requires_<boolean_testable_<decltype(t > u)>>,
-                concepts::requires_<boolean_testable_<decltype(t <= u)>>,
-                concepts::requires_<boolean_testable_<decltype(t >= u)>>,
-                concepts::requires_<boolean_testable_<decltype(u < t)>>,
-                concepts::requires_<boolean_testable_<decltype(u > t)>>,
-                concepts::requires_<boolean_testable_<decltype(u <= t)>>,
-                concepts::requires_<boolean_testable_<decltype(u >= t)>>
-            ));
-        template<typename T, typename U>
-        CPP_concept partially_ordered_with_ =
-            CPP_requires_ref(partially_ordered_with_frag_, T, U);
-
-        CPP_DIAGNOSTIC_POP
-    } // namespace detail
-
-    inline namespace defs
-    {
-        ////////////////////////////////////////////////////////////////////////
-        // Comparison concepts
-        ////////////////////////////////////////////////////////////////////////
-
-        template<typename T>
-        CPP_concept equality_comparable =
-            detail::weakly_equality_comparable_with_<T, T>;
-
-        CPP_template(typename T, typename U)(
-        concept (equality_comparable_with_)(T, U),
-            equality_comparable<
-                common_reference_t<detail::as_cref_t<T>, detail::as_cref_t<U>>>
-        );
-        template<typename T, typename U>
-        CPP_concept equality_comparable_with =
-            equality_comparable<T> &&
-            equality_comparable<U> &&
-            detail::weakly_equality_comparable_with_<T, U> &&
-            common_reference_with<detail::as_cref_t<T>, detail::as_cref_t<U>> &&
-            CPP_concept_ref(concepts::equality_comparable_with_, T, U);
-
-        template<typename T>
-        CPP_concept totally_ordered =
-            equality_comparable<T> &&
-            detail::partially_ordered_with_<T, T>;
-
-        CPP_template(typename T, typename U)(
-        concept (totally_ordered_with_)(T, U),
-            totally_ordered<
-                common_reference_t<
-                    detail::as_cref_t<T>,
-                    detail::as_cref_t<U>>> CPP_and
-            detail::partially_ordered_with_<T, U>);
-
-        template<typename T, typename U>
-        CPP_concept totally_ordered_with =
-            totally_ordered<T> &&
-            totally_ordered<U> &&
-            equality_comparable_with<T, U> &&
-            CPP_concept_ref(concepts::totally_ordered_with_, T, U);
-
-        ////////////////////////////////////////////////////////////////////////
-        // Object concepts
-        ////////////////////////////////////////////////////////////////////////
-
-        template<typename T>
-        CPP_concept destructible =
-            std::is_nothrow_destructible<T>::value;
-
-        template<typename T, typename... Args>
-        CPP_concept constructible_from =
-            destructible<T> &&
-            META_IS_CONSTRUCTIBLE(T, Args...);
-
-        template<typename T>
-        CPP_concept default_constructible =
-            constructible_from<T>;
-
-        template<typename T>
-        CPP_concept move_constructible =
-            constructible_from<T, T> &&
-            convertible_to<T, T>;
-
-        CPP_template(typename T)(
-        concept (copy_constructible_)(T),
-            constructible_from<T, T &> &&
-            constructible_from<T, T const &> &&
-            constructible_from<T, T const> &&
-            convertible_to<T &, T> &&
-            convertible_to<T const &, T> &&
-            convertible_to<T const, T>);
-        template<typename T>
-        CPP_concept copy_constructible =
-            move_constructible<T> &&
-            CPP_concept_ref(concepts::copy_constructible_, T);
-
-        CPP_template(typename T)(
-        concept (move_assignable_)(T),
-            assignable_from<T &, T>
-        );
-        template<typename T>
-        CPP_concept movable =
-            std::is_object<T>::value &&
-            move_constructible<T> &&
-            CPP_concept_ref(concepts::move_assignable_, T) &&
-            swappable<T>;
-
-        CPP_template(typename T)(
-        concept (copy_assignable_)(T),
-            assignable_from<T &, T const &>
-        );
-        template<typename T>
-        CPP_concept copyable =
-            copy_constructible<T> &&
-            movable<T> &&
-            CPP_concept_ref(concepts::copy_assignable_, T);
-
-        template<typename T>
-        CPP_concept semiregular =
-            copyable<T> &&
-            default_constructible<T>;
-            // Axiom: copies are independent. See Fundamentals of Generic
-            // Programming http://www.stepanovpapers.com/DeSt98.pdf
-
-        template<typename T>
-        CPP_concept regular =
-            semiregular<T> &&
-            equality_comparable<T>;
-
-    } // inline namespace defs
-} // namespace concepts
-
-#endif // RANGES_V3_UTILITY_CONCEPTS_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/concepts/swap.hpp b/src/contrib/range-v3-0.11.0/include/concepts/swap.hpp
deleted file mode 100644
index dd708641..00000000
--- a/src/contrib/range-v3-0.11.0/include/concepts/swap.hpp
+++ /dev/null
@@ -1,340 +0,0 @@
-/// \file
-// Concepts library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#ifndef CPP_SWAP_HPP
-#define CPP_SWAP_HPP
-
-#include <tuple>
-#include <utility>
-#include <type_traits>
-#include <meta/meta.hpp>
-
-// Note: constexpr implies inline, to retain the same visibility
-// C++14 constexpr functions are inline in C++11
-#if (defined(__cpp_constexpr) && __cpp_constexpr >= 201304L) ||\
-    (!defined(__cpp_constexpr) && __cplusplus >= 201402L)
-#define CPP_CXX14_CONSTEXPR constexpr
-#else
-#define CPP_CXX14_CONSTEXPR inline
-#endif
-
-#ifndef CPP_CXX_INLINE_VARIABLES
-#ifdef __cpp_inline_variables // TODO: fix this if SD-6 picks another name
-#define CPP_CXX_INLINE_VARIABLES __cpp_inline_variables
-// TODO: remove once clang defines __cpp_inline_variables (or equivalent)
-#elif defined(__clang__) && \
-    (__clang_major__ > 3 || __clang_major__ == 3 && __clang_minor__ == 9) && \
-    __cplusplus > 201402L
-#define CPP_CXX_INLINE_VARIABLES 201606L
-#else
-#define CPP_CXX_INLINE_VARIABLES __cplusplus
-#endif  // __cpp_inline_variables
-#endif  // CPP_CXX_INLINE_VARIABLES
-
-#if defined(_MSC_VER) && !defined(__clang__)
-#if _MSC_VER < 1926
-#define CPP_WORKAROUND_MSVC_895622 // Error when phase 1 name binding finds only deleted function
-#endif // _MSC_VER < 1926
-#endif // MSVC
-
-#if CPP_CXX_INLINE_VARIABLES < 201606L
-#define CPP_INLINE_VAR
-#define CPP_INLINE_VARIABLE(type, name)                                         \
-    inline namespace                                                            \
-    {                                                                           \
-        constexpr auto &name = ::concepts::detail::static_const<type>::value;   \
-    }                                                                           \
-    /**/
-#else  // CPP_CXX_INLINE_VARIABLES >= 201606L
-#define CPP_INLINE_VAR inline
-#define CPP_INLINE_VARIABLE(type, name)                                         \
-    inline constexpr type name{};                                               \
-    /**/
-#endif // CPP_CXX_INLINE_VARIABLES
-
-#if CPP_CXX_INLINE_VARIABLES < 201606L
-#define CPP_DEFINE_CPO(type, name)                                              \
-    inline namespace                                                            \
-    {                                                                           \
-        constexpr auto &name = ::concepts::detail::static_const<type>::value;   \
-    }                                                                           \
-    /**/
-#else  // CPP_CXX_INLINE_VARIABLES >= 201606L
-#define CPP_DEFINE_CPO(type, name)                                              \
-    inline namespace _                                                          \
-    {                                                                           \
-        inline constexpr type name{};                                           \
-    }                                                                           \
-    /**/
-#endif // CPP_CXX_INLINE_VARIABLES
-
-#if defined(_MSC_VER) && !defined(__clang__)
-#define CPP_DIAGNOSTIC_PUSH __pragma(warning(push))
-#define CPP_DIAGNOSTIC_POP __pragma(warning(pop))
-#define CPP_DIAGNOSTIC_IGNORE_INIT_LIST_LIFETIME
-#define CPP_DIAGNOSTIC_IGNORE_FLOAT_EQUAL
-#define CPP_DIAGNOSTIC_IGNORE_CPP2A_COMPAT
-#else // ^^^ defined(_MSC_VER) ^^^ / vvv !defined(_MSC_VER) vvv
-#if defined(__GNUC__) || defined(__clang__)
-#define CPP_PRAGMA(X) _Pragma(#X)
-#define CPP_DIAGNOSTIC_PUSH CPP_PRAGMA(GCC diagnostic push)
-#define CPP_DIAGNOSTIC_POP CPP_PRAGMA(GCC diagnostic pop)
-#define CPP_DIAGNOSTIC_IGNORE_PRAGMAS \
-    CPP_PRAGMA(GCC diagnostic ignored "-Wpragmas")
-#define CPP_DIAGNOSTIC_IGNORE(X) \
-    CPP_DIAGNOSTIC_IGNORE_PRAGMAS \
-    CPP_PRAGMA(GCC diagnostic ignored "-Wunknown-pragmas") \
-    CPP_PRAGMA(GCC diagnostic ignored X)
-#define CPP_DIAGNOSTIC_IGNORE_INIT_LIST_LIFETIME \
-    CPP_DIAGNOSTIC_IGNORE("-Wunknown-warning-option") \
-    CPP_DIAGNOSTIC_IGNORE("-Winit-list-lifetime")
-#define CPP_DIAGNOSTIC_IGNORE_FLOAT_EQUAL CPP_DIAGNOSTIC_IGNORE("-Wfloat-equal")
-#define CPP_DIAGNOSTIC_IGNORE_CPP2A_COMPAT CPP_DIAGNOSTIC_IGNORE("-Wc++2a-compat")
-#else
-#define CPP_DIAGNOSTIC_PUSH
-#define CPP_DIAGNOSTIC_POP
-#define CPP_DIAGNOSTIC_IGNORE_INIT_LIST_LIFETIME
-#define CPP_DIAGNOSTIC_IGNORE_FLOAT_EQUAL
-#define CPP_DIAGNOSTIC_IGNORE_CPP2A_COMPAT
-#endif
-#endif // MSVC/Generic configuration switch
-
-namespace concepts
-{
-    /// \cond
-    namespace detail
-    {
-        template<typename T>
-        CPP_INLINE_VAR constexpr bool is_movable_v =
-            std::is_object<T>::value &&
-            std::is_move_constructible<T>::value &&
-            std::is_move_assignable<T>::value;
-
-        template<typename T>
-        struct static_const
-        {
-            static constexpr T const value {};
-        };
-        template<typename T>
-        constexpr T const static_const<T>::value;
-    }
-    /// \endcond
-
-    template<typename T>
-    struct is_swappable;
-
-    template<typename T>
-    struct is_nothrow_swappable;
-
-    template<typename T, typename U>
-    struct is_swappable_with;
-
-    template<typename T, typename U>
-    struct is_nothrow_swappable_with;
-
-    template<typename T, typename U = T>
-    CPP_CXX14_CONSTEXPR
-    meta::if_c<
-        std::is_move_constructible<T>::value &&
-        std::is_assignable<T &, U>::value, T>
-    exchange(T &t, U &&u)
-        noexcept(
-            std::is_nothrow_move_constructible<T>::value &&
-            std::is_nothrow_assignable<T &, U>::value)
-    {
-        T tmp((T &&) t);
-        t = (U &&) u;
-        CPP_DIAGNOSTIC_IGNORE_INIT_LIST_LIFETIME
-        return tmp;
-    }
-
-    /// \cond
-    namespace adl_swap_detail
-    {
-        struct nope
-        {};
-
-        // Intentionally create an ambiguity with std::swap, which is
-        // (possibly) unconstrained.
-        template<typename T>
-        nope swap(T &, T &) = delete;
-
-        template<typename T, std::size_t N>
-        nope swap(T (&)[N], T (&)[N]) = delete;
-
-#ifdef CPP_WORKAROUND_MSVC_895622
-        nope swap();
-#endif
-
-        template<typename T, typename U>
-        decltype(swap(std::declval<T>(), std::declval<U>())) try_adl_swap_(int);
-
-        template<typename T, typename U>
-        nope try_adl_swap_(long);
-
-        template<typename T, typename U = T>
-        CPP_INLINE_VAR constexpr bool is_adl_swappable_v =
-            !META_IS_SAME(decltype(adl_swap_detail::try_adl_swap_<T, U>(42)), nope);
-
-        struct swap_fn
-        {
-            // Dispatch to user-defined swap found via ADL:
-            template<typename T, typename U>
-            CPP_CXX14_CONSTEXPR
-            meta::if_c<is_adl_swappable_v<T, U>>
-            operator()(T &&t, U &&u) const
-            noexcept(noexcept(swap((T &&) t, (U &&) u)))
-            {
-                swap((T &&) t, (U &&) u);
-            }
-
-            // For intrinsically swappable (i.e., movable) types for which
-            // a swap overload cannot be found via ADL, swap by moving.
-            template<typename T>
-            CPP_CXX14_CONSTEXPR
-            meta::if_c<
-                !is_adl_swappable_v<T &> &&
-                detail::is_movable_v<T>>
-            operator()(T &a, T &b) const
-            noexcept(noexcept(b = concepts::exchange(a, (T &&) b)))
-            {
-                b = concepts::exchange(a, (T &&) b);
-            }
-
-            // For arrays of intrinsically swappable (i.e., movable) types
-            // for which a swap overload cannot be found via ADL, swap array
-            // elements by moving.
-            template<typename T, typename U, std::size_t N>
-            CPP_CXX14_CONSTEXPR
-            meta::if_c<
-                !is_adl_swappable_v<T (&)[N], U (&)[N]> &&
-                is_swappable_with<T &, U &>::value>
-            operator()(T (&t)[N], U (&u)[N]) const
-                noexcept(is_nothrow_swappable_with<T &, U &>::value)
-            {
-                for(std::size_t i = 0; i < N; ++i)
-                    (*this)(t[i], u[i]);
-            }
-
-            // For rvalue pairs and tuples of swappable types, swap the
-            // members. This permits code like:
-            //   ranges::swap(std::tie(a,b,c), std::tie(d,e,f));
-            template<typename F0, typename S0, typename F1, typename S1>
-            CPP_CXX14_CONSTEXPR
-            meta::if_c<is_swappable_with<F0, F1>::value && is_swappable_with<S0, S1>::value>
-            operator()(std::pair<F0, S0> &&left, std::pair<F1, S1> &&right) const
-                noexcept(
-                    is_nothrow_swappable_with<F0, F1>::value &&
-                    is_nothrow_swappable_with<S0, S1>::value)
-            {
-                swap_fn()(static_cast<std::pair<F0, S0> &&>(left).first,
-                            static_cast<std::pair<F1, S1> &&>(right).first);
-                swap_fn()(static_cast<std::pair<F0, S0> &&>(left).second,
-                            static_cast<std::pair<F1, S1> &&>(right).second);
-            }
-
-            template<typename ...Ts, typename ...Us>
-            CPP_CXX14_CONSTEXPR
-            meta::if_c<meta::and_c<is_swappable_with<Ts, Us>::value...>::value>
-            operator()(std::tuple<Ts...> &&left, std::tuple<Us...> &&right) const
-                noexcept(meta::and_c<is_nothrow_swappable_with<Ts, Us>::value...>::value)
-            {
-                swap_fn::impl(
-                    static_cast<std::tuple<Ts...> &&>(left),
-                    static_cast<std::tuple<Us...> &&>(right),
-                    meta::make_index_sequence<sizeof...(Ts)>{});
-            }
-
-        private:
-            template<typename... Ts>
-            static constexpr int ignore_unused(Ts &&...)
-            {
-                return 0;
-            }
-            template<typename T, typename U, std::size_t ...Is>
-            CPP_CXX14_CONSTEXPR
-            static void impl(T &&left, U &&right, meta::index_sequence<Is...>)
-            {
-                (void) swap_fn::ignore_unused(
-                    (swap_fn()(std::get<Is>(static_cast<T &&>(left)),
-                                std::get<Is>(static_cast<U &&>(right))), 42)...);
-            }
-        };
-
-        template<typename T, typename U, typename = void>
-        struct is_swappable_with_
-            : std::false_type
-        {};
-
-        template<typename T, typename U>
-        struct is_swappable_with_<T, U, meta::void_<
-            decltype(swap_fn()(std::declval<T>(), std::declval<U>())),
-            decltype(swap_fn()(std::declval<U>(), std::declval<T>()))>>
-            : std::true_type
-        {};
-
-        template<typename T, typename U>
-        struct is_nothrow_swappable_with_
-            : meta::bool_<noexcept(swap_fn()(std::declval<T>(), std::declval<U>())) &&
-                        noexcept(swap_fn()(std::declval<U>(), std::declval<T>()))>
-        {};
-
-        // Q: Should std::reference_wrapper be considered a proxy wrt swapping rvalues?
-        // A: No. Its operator= is currently defined to reseat the references, so
-        //    std::swap(ra, rb) already means something when ra and rb are (lvalue)
-        //    reference_wrappers. That reseats the reference wrappers but leaves the
-        //    referents unmodified. Treating rvalue reference_wrappers differently would
-        //    be confusing.
-
-        // Q: Then why is it OK to "re"-define swap for pairs and tuples of references?
-        // A: Because as defined above, swapping an rvalue tuple of references has the same
-        //    semantics as swapping an lvalue tuple of references. Rather than reseat the
-        //    references, assignment happens *through* the references.
-
-        // Q: But I have an iterator whose operator* returns an rvalue
-        //    std::reference_wrapper<T>. How do I make it model indirectly_swappable?
-        // A: With an overload of iter_swap.
-    }
-    /// \endcond
-
-    /// \ingroup group-utility
-    template<typename T, typename U>
-    struct is_swappable_with
-        : adl_swap_detail::is_swappable_with_<T, U>
-    {};
-
-    /// \ingroup group-utility
-    template<typename T, typename U>
-    struct is_nothrow_swappable_with
-        : meta::and_<
-            is_swappable_with<T, U>,
-            adl_swap_detail::is_nothrow_swappable_with_<T, U>>
-    {};
-
-    /// \ingroup group-utility
-    template<typename T>
-    struct is_swappable
-        : is_swappable_with<T &, T &>
-    {};
-
-    /// \ingroup group-utility
-    template<typename T>
-    struct is_nothrow_swappable
-        : is_nothrow_swappable_with<T &, T &>
-    {};
-
-    /// \ingroup group-utility
-    /// \relates adl_swap_detail::swap_fn
-    CPP_DEFINE_CPO(adl_swap_detail::swap_fn, swap)
-}
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/concepts/type_traits.hpp b/src/contrib/range-v3-0.11.0/include/concepts/type_traits.hpp
deleted file mode 100644
index f8ee95c9..00000000
--- a/src/contrib/range-v3-0.11.0/include/concepts/type_traits.hpp
+++ /dev/null
@@ -1,379 +0,0 @@
-/// \file
-// Concepts library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#ifndef CPP_TYPE_TRAITS_HPP
-#define CPP_TYPE_TRAITS_HPP
-
-#include <tuple>
-#include <utility>
-#include <type_traits>
-#include <meta/meta.hpp>
-
-namespace concepts
-{
-    template<typename T>
-    using remove_cvref_t =
-        typename std::remove_cv<
-            typename std::remove_reference<T>::type>::type;
-
-    /// \cond
-    namespace detail
-    {
-        template<typename From, typename To>
-        using is_convertible = std::is_convertible<meta::_t<std::add_rvalue_reference<From>>, To>;
-
-        template<bool>
-        struct if_else_
-        {
-            template<typename, typename U>
-            using invoke = U;
-        };
-        template<>
-        struct if_else_<true>
-        {
-            template<typename T, typename>
-            using invoke = T;
-        };
-        template<bool B, typename T, typename U>
-        using if_else_t = meta::invoke<if_else_<B>, T, U>;
-
-        template<bool>
-        struct if_
-        {};
-        template<>
-        struct if_<true>
-        {
-            template<typename T>
-            using invoke = T;
-        };
-        template<bool B, typename T = void>
-        using if_t = meta::invoke<if_<B>, T>;
-
-        template<typename From, typename To>
-        struct _copy_cv_
-        {
-            using type = To;
-        };
-        template<typename From, typename To>
-        struct _copy_cv_<From const, To>
-        {
-            using type = To const;
-        };
-        template<typename From, typename To>
-        struct _copy_cv_<From volatile, To>
-        {
-            using type = To volatile;
-        };
-        template<typename From, typename To>
-        struct _copy_cv_<From const volatile, To>
-        {
-            using type = To const volatile;
-        };
-        template<typename From, typename To>
-        using _copy_cv = meta::_t<_copy_cv_<From, To>>;
-
-        ////////////////////////////////////////////////////////////////////////////////////////
-        template<typename T, typename U, typename = void>
-        struct _builtin_common;
-
-        template<typename T, typename U>
-        using _builtin_common_t = meta::_t<_builtin_common<T, U>>;
-
-        template<typename T, typename U>
-        using _cond_res = decltype(true ? std::declval<T>() : std::declval<U>());
-
-        template<typename T, typename U, typename R = _builtin_common_t<T &, U &>>
-        using _rref_res =
-            if_else_t<std::is_reference<R>::value, meta::_t<std::remove_reference<R>> &&, R>;
-
-        template<typename T, typename U>
-        using _lref_res = _cond_res<_copy_cv<T, U> &, _copy_cv<U, T> &>;
-
-        template<typename T>
-        struct as_cref_
-        {
-            using type = T const &;
-        };
-        template<typename T>
-        struct as_cref_<T &>
-        {
-            using type = T const &;
-        };
-        template<typename T>
-        struct as_cref_<T &&>
-        {
-            using type = T const &;
-        };
-        template<>
-        struct as_cref_<void>
-        {
-            using type = void;
-        };
-        template<>
-        struct as_cref_<void const>
-        {
-            using type = void const;
-        };
-
-        template<typename T>
-        using as_cref_t = typename as_cref_<T>::type;
-
-        template<typename T>
-        using decay_t = typename std::decay<T>::type;
-
-    #if !defined(__GNUC__) || defined(__clang__)
-        template<typename T, typename U, typename = void>
-        struct _builtin_common_3
-        {};
-        template<typename T, typename U>
-        struct _builtin_common_3<T, U, meta::void_<_cond_res<as_cref_t<T>, as_cref_t<U>>>>
-            : std::decay<_cond_res<as_cref_t<T>, as_cref_t<U>>>
-        {};
-        template<typename T, typename U, typename = void>
-        struct _builtin_common_2
-            : _builtin_common_3<T, U>
-        {};
-        template<typename T, typename U>
-        struct _builtin_common_2<T, U, meta::void_<_cond_res<T, U>>>
-            : std::decay<_cond_res<T, U>>
-        {};
-        template<typename T, typename U, typename /* = void */>
-        struct _builtin_common
-            : _builtin_common_2<T, U>
-        {};
-        template<typename T, typename U>
-        struct _builtin_common<T &&, U &&, if_t<
-            is_convertible<T &&, _rref_res<T, U>>::value &&
-            is_convertible<U &&, _rref_res<T, U>>::value>>
-        {
-            using type = _rref_res<T, U>;
-        };
-        template<typename T, typename U>
-        struct _builtin_common<T &, U &>
-            : meta::defer<_lref_res, T, U>
-        {};
-        template<typename T, typename U>
-        struct _builtin_common<T &, U &&, if_t<
-            is_convertible<U &&, _builtin_common_t<T &, U const &>>::value>>
-            : _builtin_common<T &, U const &>
-        {};
-        template<typename T, typename U>
-        struct _builtin_common<T &&, U &>
-            : _builtin_common<U &, T &&>
-        {};
-    #else
-        template<typename T, typename U, typename = void>
-        struct _builtin_common_3
-        {};
-        template<typename T, typename U>
-        struct _builtin_common_3<T, U, meta::void_<_cond_res<as_cref_t<T>, as_cref_t<U>>>>
-            : std::decay<_cond_res<as_cref_t<T>, as_cref_t<U>>>
-        {};
-        template<typename T, typename U, typename = void>
-        struct _builtin_common_2
-            : _builtin_common_3<T, U>
-        {};
-        template<typename T, typename U>
-        struct _builtin_common_2<T, U, meta::void_<_cond_res<T, U>>>
-            : std::decay<_cond_res<T, U>>
-        {};
-        template<typename T, typename U, typename /* = void */>
-        struct _builtin_common
-            : _builtin_common_2<T, U>
-        {};
-        template<typename T, typename U, typename = void>
-        struct _builtin_common_rr
-            : _builtin_common_2<T &&, U &&>
-        {};
-        template<typename T, typename U>
-        struct _builtin_common_rr<T, U, if_t<
-            is_convertible<T &&, _rref_res<T, U>>::value &&
-            is_convertible<U &&, _rref_res<T, U>>::value>>
-        {
-            using type = _rref_res<T, U>;
-        };
-        template<typename T, typename U>
-        struct _builtin_common<T &&, U &&>
-            : _builtin_common_rr<T, U>
-        {};
-        template<typename T, typename U>
-        struct _builtin_common<T &, U &>
-            : meta::defer<_lref_res, T, U>
-        {};
-        template<typename T, typename U, typename = void>
-        struct _builtin_common_lr
-            : _builtin_common_2<T &, T &&>
-        {};
-        template<typename T, typename U>
-        struct _builtin_common_lr<T, U, if_t<
-            is_convertible<U &&, _builtin_common_t<T &, U const &>>::value>>
-            : _builtin_common<T &, U const &>
-        {};
-        template<typename T, typename U>
-        struct _builtin_common<T &, U &&>
-            : _builtin_common_lr<T, U>
-        {};
-        template<typename T, typename U>
-        struct _builtin_common<T &&, U &>
-            : _builtin_common<U &, T &&>
-        {};
-    #endif
-    }
-    /// \endcond
-
-    /// \addtogroup group-utility Utility
-    /// @{
-    ///
-
-    /// Users should specialize this to hook the \c common_with concept
-    /// until \c std gets a SFINAE-friendly \c std::common_type and there's
-    /// some sane way to deal with cv and ref qualifiers.
-    template<typename ...Ts>
-    struct common_type
-    {};
-
-    template<typename T>
-    struct common_type<T>
-        : std::decay<T>
-    {};
-
-    template<typename T, typename U>
-    struct common_type<T, U>
-        : detail::if_else_t<
-            (META_IS_SAME(detail::decay_t<T>, T) &&
-                META_IS_SAME(detail::decay_t<U>, U) ),
-            meta::defer<detail::_builtin_common_t, T, U>,
-            common_type<detail::decay_t<T>, detail::decay_t<U>>>
-    {};
-
-    template<typename... Ts>
-    using common_type_t = typename common_type<Ts...>::type;
-
-    template<typename T, typename U, typename... Vs>
-    struct common_type<T, U, Vs...>
-        : meta::lazy::fold<meta::list<U, Vs...>, T, meta::quote<common_type_t>>
-    {};
-
-    /// @}
-
-    /// \addtogroup group-utility Utility
-    /// @{
-    ///
-
-    /// Users can specialize this to hook the \c common_reference_with concept.
-    /// \sa `common_reference`
-    template<
-        typename T,
-        typename U,
-        template<typename> class TQual,
-        template<typename> class UQual>
-    struct basic_common_reference
-    {};
-
-    /// \cond
-    namespace detail
-    {
-        using _rref =
-            meta::quote_trait<std::add_rvalue_reference>;
-        using _lref =
-            meta::quote_trait<std::add_lvalue_reference>;
-
-        template<typename>
-        struct _xref
-        {
-            template<typename T>
-            using invoke = T;
-        };
-        template<typename T>
-        struct _xref<T &&>
-        {
-            template<typename U>
-            using invoke =
-                meta::_t<std::add_rvalue_reference<meta::invoke<_xref<T>, U>>>;
-        };
-        template<typename T>
-        struct _xref<T &>
-        {
-            template<typename U>
-            using invoke =
-                meta::_t<std::add_lvalue_reference<meta::invoke<_xref<T>, U>>>;
-        };
-        template<typename T>
-        struct _xref<T const>
-        {
-            template<typename U>
-            using invoke = U const;
-        };
-        template<typename T>
-        struct _xref<T volatile>
-        {
-            template<typename U>
-            using invoke = U volatile;
-        };
-        template<typename T>
-        struct _xref<T const volatile>
-        {
-            template<typename U>
-            using invoke = U const volatile;
-        };
-
-        template<typename T, typename U>
-        using _basic_common_reference =
-            basic_common_reference<
-                remove_cvref_t<T>,
-                remove_cvref_t<U>,
-                _xref<T>::template invoke,
-                _xref<U>::template invoke>;
-
-        template<typename T, typename U, typename = void>
-        struct _common_reference2
-            : if_else_t<
-                meta::is_trait<_basic_common_reference<T, U>>::value,
-                _basic_common_reference<T, U>,
-                common_type<T, U>>
-        {};
-
-        template<typename T, typename U>
-        struct _common_reference2<T, U, if_t<std::is_reference<_builtin_common_t<T, U>>::value>>
-            : _builtin_common<T, U>
-        {};
-    }
-    /// \endcond
-
-    /// Users can specialize this to hook the \c common_reference_with concept.
-    /// \sa `basic_common_reference`
-    template<typename ...Ts>
-    struct common_reference
-    {};
-
-    template<typename T>
-    struct common_reference<T>
-    {
-        using type = T;
-    };
-
-    template<typename T, typename U>
-    struct common_reference<T, U>
-        : detail::_common_reference2<T, U>
-    {};
-
-    template<typename... Ts>
-    using common_reference_t = typename common_reference<Ts...>::type;
-
-    template<typename T, typename U, typename... Vs>
-    struct common_reference<T, U, Vs...>
-        : meta::lazy::fold<meta::list<U, Vs...>, T, meta::quote<common_reference_t>>
-    {};
-    /// @}
-} // namespace concepts
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/meta/meta.hpp b/src/contrib/range-v3-0.11.0/include/meta/meta.hpp
deleted file mode 100644
index 4590d593..00000000
--- a/src/contrib/range-v3-0.11.0/include/meta/meta.hpp
+++ /dev/null
@@ -1,3965 +0,0 @@
-/// \file meta.hpp Tiny meta-programming library.
-//
-// Meta library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/meta
-//
-
-#ifndef META_HPP
-#define META_HPP
-
-#include <cstddef>
-#include <initializer_list>
-#include <meta/meta_fwd.hpp>
-#include <type_traits>
-#include <utility>
-
-#ifdef __clang__
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wunknown-pragmas"
-#pragma GCC diagnostic ignored "-Wpragmas"
-#pragma GCC diagnostic ignored "-Wdocumentation-deprecated-sync"
-#pragma GCC diagnostic ignored "-Wmissing-variable-declarations"
-#endif
-
-/// \defgroup meta Meta
-///
-/// A tiny metaprogramming library
-
-/// \defgroup trait Trait
-/// Trait invocation/composition.
-/// \ingroup meta
-
-/// \defgroup invocation Invocation
-/// Trait invocation
-/// \ingroup trait
-
-/// \defgroup composition Composition
-/// Trait composition
-/// \ingroup trait
-
-/// \defgroup logical Logical
-/// Logical operations
-/// \ingroup meta
-
-/// \defgroup algorithm Algorithms
-/// Algorithms.
-/// \ingroup meta
-
-/// \defgroup query Query/Search
-/// Query and search algorithms
-/// \ingroup algorithm
-
-/// \defgroup transformation Transformation
-/// Transformation algorithms
-/// \ingroup algorithm
-
-/// \defgroup runtime Runtime
-/// Runtime algorithms
-/// \ingroup algorithm
-
-/// \defgroup datatype Datatype
-/// Datatypes.
-/// \ingroup meta
-
-/// \defgroup list list_like
-/// \ingroup datatype
-
-/// \defgroup integral Integer sequence
-/// Equivalent to C++14's `std::integer_sequence`
-/// \ingroup datatype
-
-/// \defgroup extension Extension
-/// Extend meta with your own datatypes.
-/// \ingroup datatype
-
-/// \defgroup math Math
-/// Integral constant arithmetic.
-/// \ingroup meta
-
-/// \defgroup lazy_trait lazy
-/// \ingroup trait
-
-/// \defgroup lazy_invocation lazy
-/// \ingroup invocation
-
-/// \defgroup lazy_composition lazy
-/// \ingroup composition
-
-/// \defgroup lazy_logical lazy
-/// \ingroup logical
-
-/// \defgroup lazy_query lazy
-/// \ingroup query
-
-/// \defgroup lazy_transformation lazy
-/// \ingroup transformation
-
-/// \defgroup lazy_list lazy
-/// \ingroup list
-
-/// \defgroup lazy_datatype lazy
-/// \ingroup datatype
-
-/// \defgroup lazy_math lazy
-/// \ingroup math
-
-/// Tiny metaprogramming library
-namespace meta
-{
-    namespace detail
-    {
-        /// Returns a \p T nullptr
-        template <typename T>
-        constexpr T *_nullptr_v()
-        {
-            return nullptr;
-        }
-
-#if META_CXX_VARIABLE_TEMPLATES
-        template <typename T>
-        META_INLINE_VAR constexpr T *nullptr_v = nullptr;
-#endif
-    } // namespace detail
-
-    /// An empty type.
-    /// \ingroup datatype
-    struct nil_
-    {
-    };
-
-    /// Type alias for \p T::type.
-    /// \ingroup invocation
-    template <META_TYPE_CONSTRAINT(trait) T>
-    using _t = typename T::type;
-
-#if META_CXX_VARIABLE_TEMPLATES || defined(META_DOXYGEN_INVOKED)
-    /// Variable alias for \c T::type::value
-    /// \note Requires C++14 or greater.
-    /// \ingroup invocation
-    template <META_TYPE_CONSTRAINT(integral) T>
-    constexpr typename T::type::value_type _v = T::type::value;
-#endif
-
-    /// Lazy versions of meta actions
-    namespace lazy
-    {
-        /// \sa `meta::_t`
-        /// \ingroup lazy_invocation
-        template <typename T>
-        using _t = defer<_t, T>;
-    } // namespace lazy
-
-    /// An integral constant wrapper for \c std::size_t.
-    /// \ingroup integral
-    template <std::size_t N>
-    using size_t = std::integral_constant<std::size_t, N>;
-
-    /// An integral constant wrapper for \c bool.
-    /// \ingroup integral
-    template <bool B>
-    using bool_ = std::integral_constant<bool, B>;
-
-    /// An integral constant wrapper for \c int.
-    /// \ingroup integral
-    template <int I>
-    using int_ = std::integral_constant<int, I>;
-
-    /// An integral constant wrapper for \c char.
-    /// \ingroup integral
-    template <char Ch>
-    using char_ = std::integral_constant<char, Ch>;
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // Math operations
-    /// An integral constant wrapper around the result of incrementing the wrapped integer \c
-    /// T::type::value.
-    template <META_TYPE_CONSTRAINT(integral) T>
-    using inc = std::integral_constant<decltype(T::type::value + 1), T::type::value + 1>;
-
-    /// An integral constant wrapper around the result of decrementing the wrapped integer \c
-    /// T::type::value.
-    template <META_TYPE_CONSTRAINT(integral) T>
-    using dec = std::integral_constant<decltype(T::type::value - 1), T::type::value - 1>;
-
-    /// An integral constant wrapper around the result of adding the two wrapped integers
-    /// \c T::type::value and \c U::type::value.
-    /// \ingroup math
-    template <META_TYPE_CONSTRAINT(integral) T, META_TYPE_CONSTRAINT(integral) U>
-    using plus = std::integral_constant<decltype(T::type::value + U::type::value),
-                                        T::type::value + U::type::value>;
-
-    /// An integral constant wrapper around the result of subtracting the two wrapped integers
-    /// \c T::type::value and \c U::type::value.
-    /// \ingroup math
-    template <META_TYPE_CONSTRAINT(integral) T, META_TYPE_CONSTRAINT(integral) U>
-    using minus = std::integral_constant<decltype(T::type::value - U::type::value),
-                                            T::type::value - U::type::value>;
-
-    /// An integral constant wrapper around the result of multiplying the two wrapped integers
-    /// \c T::type::value and \c U::type::value.
-    /// \ingroup math
-    template <META_TYPE_CONSTRAINT(integral) T, META_TYPE_CONSTRAINT(integral) U>
-    using multiplies = std::integral_constant<decltype(T::type::value * U::type::value),
-                                                T::type::value * U::type::value>;
-
-    /// An integral constant wrapper around the result of dividing the two wrapped integers \c
-    /// T::type::value and \c U::type::value.
-    /// \ingroup math
-    template <META_TYPE_CONSTRAINT(integral) T, META_TYPE_CONSTRAINT(integral) U>
-    using divides = std::integral_constant<decltype(T::type::value / U::type::value),
-                                            T::type::value / U::type::value>;
-
-    /// An integral constant wrapper around the result of negating the wrapped integer
-    /// \c T::type::value.
-    /// \ingroup math
-    template <META_TYPE_CONSTRAINT(integral) T>
-    using negate = std::integral_constant<decltype(-T::type::value), -T::type::value>;
-
-    /// An integral constant wrapper around the remainder of dividing the two wrapped integers
-    /// \c T::type::value and \c U::type::value.
-    /// \ingroup math
-    template <META_TYPE_CONSTRAINT(integral) T, META_TYPE_CONSTRAINT(integral) U>
-    using modulus = std::integral_constant<decltype(T::type::value % U::type::value),
-                                            T::type::value % U::type::value>;
-
-    /// A Boolean integral constant wrapper around the result of comparing \c T::type::value and
-    /// \c U::type::value for equality.
-    /// \ingroup math
-    template <META_TYPE_CONSTRAINT(integral) T, META_TYPE_CONSTRAINT(integral) U>
-    using equal_to = bool_<T::type::value == U::type::value>;
-
-    /// A Boolean integral constant wrapper around the result of comparing \c T::type::value and
-    /// \c U::type::value for inequality.
-    /// \ingroup math
-    template <META_TYPE_CONSTRAINT(integral) T, META_TYPE_CONSTRAINT(integral) U>
-    using not_equal_to = bool_<T::type::value != U::type::value>;
-
-    /// A Boolean integral constant wrapper around \c true if \c T::type::value is greater than
-    /// \c U::type::value; \c false, otherwise.
-    /// \ingroup math
-    template <META_TYPE_CONSTRAINT(integral) T, META_TYPE_CONSTRAINT(integral) U>
-    using greater = bool_<(T::type::value > U::type::value)>;
-
-    /// A Boolean integral constant wrapper around \c true if \c T::type::value is less than \c
-    /// U::type::value; \c false, otherwise.
-    /// \ingroup math
-    template <META_TYPE_CONSTRAINT(integral) T, META_TYPE_CONSTRAINT(integral) U>
-    using less = bool_<(T::type::value < U::type::value)>;
-
-    /// A Boolean integral constant wrapper around \c true if \c T::type::value is greater than
-    /// or equal to \c U::type::value; \c false, otherwise.
-    /// \ingroup math
-    template <META_TYPE_CONSTRAINT(integral) T, META_TYPE_CONSTRAINT(integral) U>
-    using greater_equal = bool_<(T::type::value >= U::type::value)>;
-
-    /// A Boolean integral constant wrapper around \c true if \c T::type::value is less than or
-    /// equal to \c U::type::value; \c false, otherwise.
-    /// \ingroup math
-    template <META_TYPE_CONSTRAINT(integral) T, META_TYPE_CONSTRAINT(integral) U>
-    using less_equal = bool_<(T::type::value <= U::type::value)>;
-
-    /// An integral constant wrapper around the result of bitwise-and'ing the two wrapped
-    /// integers \c T::type::value and \c U::type::value.
-    /// \ingroup math
-    template <META_TYPE_CONSTRAINT(integral) T, META_TYPE_CONSTRAINT(integral) U>
-    using bit_and = std::integral_constant<decltype(T::type::value & U::type::value),
-                                            T::type::value & U::type::value>;
-
-    /// An integral constant wrapper around the result of bitwise-or'ing the two wrapped
-    /// integers \c T::type::value and \c U::type::value.
-    /// \ingroup math
-    template <META_TYPE_CONSTRAINT(integral) T, META_TYPE_CONSTRAINT(integral) U>
-    using bit_or = std::integral_constant<decltype(T::type::value | U::type::value),
-                                            T::type::value | U::type::value>;
-
-    /// An integral constant wrapper around the result of bitwise-exclusive-or'ing the two
-    /// wrapped integers \c T::type::value and \c U::type::value.
-    /// \ingroup math
-    template <META_TYPE_CONSTRAINT(integral) T, META_TYPE_CONSTRAINT(integral) U>
-    using bit_xor = std::integral_constant<decltype(T::type::value ^ U::type::value),
-                                            T::type::value ^ U::type::value>;
-
-    /// An integral constant wrapper around the result of bitwise-complementing the wrapped
-    /// integer \c T::type::value.
-    /// \ingroup math
-    template <META_TYPE_CONSTRAINT(integral) T>
-    using bit_not = std::integral_constant<decltype(~T::type::value), ~T::type::value>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::int'
-        /// \ingroup lazy_math
-        template <typename T>
-        using inc = defer<inc, T>;
-
-        /// \sa 'meta::dec'
-        /// \ingroup lazy_math
-        template <typename T>
-        using dec = defer<dec, T>;
-
-        /// \sa 'meta::plus'
-        /// \ingroup lazy_math
-        template <typename T, typename U>
-        using plus = defer<plus, T, U>;
-
-        /// \sa 'meta::minus'
-        /// \ingroup lazy_math
-        template <typename T, typename U>
-        using minus = defer<minus, T, U>;
-
-        /// \sa 'meta::multiplies'
-        /// \ingroup lazy_math
-        template <typename T, typename U>
-        using multiplies = defer<multiplies, T, U>;
-
-        /// \sa 'meta::divides'
-        /// \ingroup lazy_math
-        template <typename T, typename U>
-        using divides = defer<divides, T, U>;
-
-        /// \sa 'meta::negate'
-        /// \ingroup lazy_math
-        template <typename T>
-        using negate = defer<negate, T>;
-
-        /// \sa 'meta::modulus'
-        /// \ingroup lazy_math
-        template <typename T, typename U>
-        using modulus = defer<modulus, T, U>;
-
-        /// \sa 'meta::equal_to'
-        /// \ingroup lazy_math
-        template <typename T, typename U>
-        using equal_to = defer<equal_to, T, U>;
-
-        /// \sa 'meta::not_equal_t'
-        /// \ingroup lazy_math
-        template <typename T, typename U>
-        using not_equal_to = defer<not_equal_to, T, U>;
-
-        /// \sa 'meta::greater'
-        /// \ingroup lazy_math
-        template <typename T, typename U>
-        using greater = defer<greater, T, U>;
-
-        /// \sa 'meta::less'
-        /// \ingroup lazy_math
-        template <typename T, typename U>
-        using less = defer<less, T, U>;
-
-        /// \sa 'meta::greater_equal'
-        /// \ingroup lazy_math
-        template <typename T, typename U>
-        using greater_equal = defer<greater_equal, T, U>;
-
-        /// \sa 'meta::less_equal'
-        /// \ingroup lazy_math
-        template <typename T, typename U>
-        using less_equal = defer<less_equal, T, U>;
-
-        /// \sa 'meta::bit_and'
-        /// \ingroup lazy_math
-        template <typename T, typename U>
-        using bit_and = defer<bit_and, T, U>;
-
-        /// \sa 'meta::bit_or'
-        /// \ingroup lazy_math
-        template <typename T, typename U>
-        using bit_or = defer<bit_or, T, U>;
-
-        /// \sa 'meta::bit_xor'
-        /// \ingroup lazy_math
-        template <typename T, typename U>
-        using bit_xor = defer<bit_xor, T, U>;
-
-        /// \sa 'meta::bit_not'
-        /// \ingroup lazy_math
-        template <typename T>
-        using bit_not = defer<bit_not, T>;
-    } // namespace lazy
-
-    /// \cond
-    namespace detail
-    {
-        enum class indices_strategy_
-        {
-            done,
-            repeat,
-            recurse
-        };
-
-        constexpr indices_strategy_ strategy_(std::size_t cur, std::size_t end)
-        {
-            return cur >= end ? indices_strategy_::done
-                              : cur * 2 <= end ? indices_strategy_::repeat
-                                               : indices_strategy_::recurse;
-        }
-
-        template <typename T>
-        constexpr std::size_t range_distance_(T begin, T end)
-        {
-            return begin <= end ? static_cast<std::size_t>(end - begin)
-                                : throw "The start of the integer_sequence must not be "
-                                        "greater than the end";
-        }
-
-        template <std::size_t End, typename State, indices_strategy_ Status_>
-        struct make_indices_
-        {
-            using type = State;
-        };
-
-        template <typename T, T, typename>
-        struct coerce_indices_
-        {
-        };
-    } // namespace detail
-    /// \endcond
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // integer_sequence
-#if !META_CXX_INTEGER_SEQUENCE
-    /// A container for a sequence of compile-time integer constants.
-    /// \ingroup integral
-    template <typename T, T... Is>
-    struct integer_sequence
-    {
-        using value_type = T;
-        /// \return `sizeof...(Is)`
-        static constexpr std::size_t size() noexcept { return sizeof...(Is); }
-    };
-#endif
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // index_sequence
-    /// A container for a sequence of compile-time integer constants of type
-    /// \c std::size_t
-    /// \ingroup integral
-    template <std::size_t... Is>
-    using index_sequence = integer_sequence<std::size_t, Is...>;
-
-#if META_HAS_MAKE_INTEGER_SEQ && !defined(META_DOXYGEN_INVOKED)
-    // Implement make_integer_sequence and make_index_sequence with the
-    // __make_integer_seq builtin on compilers that provide it. (Redirect
-    // through decltype to workaround suspected clang bug.)
-    /// \cond
-    namespace detail
-    {
-        template <typename T, T N>
-        __make_integer_seq<integer_sequence, T, N> make_integer_sequence_();
-    }
-    /// \endcond
-
-    template <typename T, T N>
-    using make_integer_sequence = decltype(detail::make_integer_sequence_<T, N>());
-
-    template <std::size_t N>
-    using make_index_sequence = make_integer_sequence<std::size_t, N>;
-#else
-    /// Generate \c index_sequence containing integer constants [0,1,2,...,N-1].
-    /// \par Complexity
-    /// \f$ O(log(N)) \f$.
-    /// \ingroup integral
-    template <std::size_t N>
-    using make_index_sequence =
-        _t<detail::make_indices_<N, index_sequence<0>, detail::strategy_(1, N)>>;
-
-    /// Generate \c integer_sequence containing integer constants [0,1,2,...,N-1].
-    /// \par Complexity
-    /// \f$ O(log(N)) \f$.
-    /// \ingroup integral
-    template <typename T, T N>
-    using make_integer_sequence =
-        _t<detail::coerce_indices_<T, 0, make_index_sequence<static_cast<std::size_t>(N)>>>;
-#endif
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // integer_range
-    /// Makes the integer sequence <tt>[From, To)</tt>.
-    /// \par Complexity
-    /// \f$ O(log(To - From)) \f$.
-    /// \ingroup integral
-    template <typename T, T From, T To>
-    using integer_range =
-        _t<detail::coerce_indices_<T, From,
-                                    make_index_sequence<detail::range_distance_(From, To)>>>;
-
-    /// \cond
-    namespace detail
-    {
-        template <typename, typename>
-        struct concat_indices_
-        {
-        };
-
-        template <std::size_t... Is, std::size_t... Js>
-        struct concat_indices_<index_sequence<Is...>, index_sequence<Js...>>
-        {
-            using type = index_sequence<Is..., (Js + sizeof...(Is))...>;
-        };
-
-        template <>
-        struct make_indices_<0u, index_sequence<0>, indices_strategy_::done>
-        {
-            using type = index_sequence<>;
-        };
-
-        template <std::size_t End, std::size_t... Values>
-        struct make_indices_<End, index_sequence<Values...>, indices_strategy_::repeat>
-          : make_indices_<End, index_sequence<Values..., (Values + sizeof...(Values))...>,
-                          detail::strategy_(sizeof...(Values) * 2, End)>
-        {
-        };
-
-        template <std::size_t End, std::size_t... Values>
-        struct make_indices_<End, index_sequence<Values...>, indices_strategy_::recurse>
-          : concat_indices_<index_sequence<Values...>,
-                            make_index_sequence<End - sizeof...(Values)>>
-        {
-        };
-
-        template <typename T, T Offset, std::size_t... Values>
-        struct coerce_indices_<T, Offset, index_sequence<Values...>>
-        {
-            using type =
-                integer_sequence<T, static_cast<T>(static_cast<T>(Values) + Offset)...>;
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// Evaluate the invocable \p Fn with the arguments \p Args.
-    /// \ingroup invocation
-    template <META_TYPE_CONSTRAINT(invocable) Fn, typename... Args>
-    using invoke = typename Fn::template invoke<Args...>;
-
-    /// Lazy versions of meta actions
-    namespace lazy
-    {
-        /// \sa `meta::invoke`
-        /// \ingroup lazy_invocation
-        template <typename Fn, typename... Args>
-        using invoke = defer<invoke, Fn, Args...>;
-    } // namespace lazy
-
-    /// A trait that always returns its argument \p T. It is also an invocable
-    /// that always returns \p T.
-    /// \ingroup trait
-    /// \ingroup invocation
-    template <typename T>
-    struct id
-    {
-#if defined(META_WORKAROUND_CWG_1558) && !defined(META_DOXYGEN_INVOKED)
-        // Redirect through decltype for compilers that have not
-        // yet implemented CWG 1558:
-        static id impl(void *);
-
-        template <typename... Ts>
-        using invoke = _t<decltype(id::impl(static_cast<list<Ts...> *>(nullptr)))>;
-#else
-        template <typename...>
-        using invoke = T;
-#endif
-
-        using type = T;
-    };
-
-    /// An alias for type \p T. Useful in non-deduced contexts.
-    /// \ingroup trait
-    template <typename T>
-    using id_t = _t<id<T>>;
-
-    namespace lazy
-    {
-        /// \sa `meta::id`
-        /// \ingroup lazy_trait
-        /// \ingroup lazy_invocation
-        template <typename T>
-        using id = defer<id, T>;
-    } // namespace lazy
-
-    /// An alias for `void`.
-    /// \ingroup trait
-#if defined(META_WORKAROUND_CWG_1558) && !defined(META_DOXYGEN_INVOKED)
-    // Redirect through decltype for compilers that have not
-    // yet implemented CWG 1558:
-    template <typename... Ts>
-    using void_ = invoke<id<void>, Ts...>;
-#else
-    template <typename...>
-    using void_ = void;
-#endif
-
-#if META_CXX_VARIABLE_TEMPLATES
-#ifdef META_CONCEPT
-    /// `true` if `T::type` exists and names a type; `false` otherwise.
-    /// \ingroup trait
-    template <typename T>
-    META_INLINE_VAR constexpr bool is_trait_v = trait<T>;
-
-    /// `true` if `T::invoke` exists and names a class template; `false` otherwise.
-    /// \ingroup trait
-    template <typename T>
-    META_INLINE_VAR constexpr bool is_callable_v = invocable<T>;
-#else   // ^^^ Concepts / No concepts vvv
-    /// \cond
-    namespace detail
-    {
-        template <typename, typename = void>
-        META_INLINE_VAR constexpr bool is_trait_ = false;
-
-        template <typename T>
-        META_INLINE_VAR constexpr bool is_trait_<T, void_<typename T::type>> = true;
-
-        template <typename, typename = void>
-        META_INLINE_VAR constexpr bool is_callable_ = false;
-
-        template <typename T>
-        META_INLINE_VAR constexpr bool is_callable_<T, void_<quote<T::template invoke>>> = true;
-    } // namespace detail
-    /// \endcond
-
-    /// `true` if `T::type` exists and names a type; `false` otherwise.
-    /// \ingroup trait
-    template <typename T>
-    META_INLINE_VAR constexpr bool is_trait_v = detail::is_trait_<T>;
-
-    /// `true` if `T::invoke` exists and names a class template; `false` otherwise.
-    /// \ingroup trait
-    template <typename T>
-    META_INLINE_VAR constexpr bool is_callable_v = detail::is_callable_<T>;
-#endif  // Concepts vs. variable templates
-
-    /// An alias for `std::true_type` if `T::type` exists and names a type; otherwise, it's an
-    /// alias for `std::false_type`.
-    /// \ingroup trait
-    template <typename T>
-    using is_trait = bool_<is_trait_v<T>>;
-
-    /// An alias for `std::true_type` if `T::invoke` exists and names a class template;
-    /// otherwise, it's an alias for `std::false_type`.
-    /// \ingroup trait
-    template <typename T>
-    using is_callable = bool_<is_callable_v<T>>;
-#else   // ^^^ META_CXX_VARIABLE_TEMPLATES / !META_CXX_VARIABLE_TEMPLATES vvv
-    /// \cond
-    namespace detail
-    {
-        template <typename, typename = void>
-        struct is_trait_
-        {
-            using type = std::false_type;
-        };
-
-        template <typename T>
-        struct is_trait_<T, void_<typename T::type>>
-        {
-            using type = std::true_type;
-        };
-
-        template <typename, typename = void>
-        struct is_callable_
-        {
-            using type = std::false_type;
-        };
-
-        template <typename T>
-        struct is_callable_<T, void_<quote<T::template invoke>>>
-        {
-            using type = std::true_type;
-        };
-    } // namespace detail
-    /// \endcond
-
-    template <typename T>
-    using is_trait = _t<detail::is_trait_<T>>;
-
-    /// An alias for `std::true_type` if `T::invoke` exists and names a class
-    /// template or alias template; otherwise, it's an alias for
-    /// `std::false_type`.
-    /// \ingroup trait
-    template <typename T>
-    using is_callable = _t<detail::is_callable_<T>>;
-#endif
-
-    /// \cond
-    namespace detail
-    {
-#ifdef META_CONCEPT
-        template <template <typename...> class, typename...>
-        struct defer_
-        {
-        };
-
-        template <template <typename...> class C, typename... Ts>
-        requires valid<C, Ts...> struct defer_<C, Ts...>
-        {
-            using type = C<Ts...>;
-        };
-
-        template <typename T, template <T...> class, T...>
-        struct defer_i_
-        {
-        };
-
-        template <typename T, template <T...> class C, T... Is>
-        requires valid_i<T, C, Is...> struct defer_i_<T, C, Is...>
-        {
-            using type = C<Is...>;
-        };
-#elif defined(META_WORKAROUND_MSVC_703656) // ^^^ Concepts / MSVC workaround vvv
-        template <typename, template <typename...> class, typename...>
-        struct _defer_
-        {
-        };
-
-        template <template <typename...> class C, typename... Ts>
-        struct _defer_<void_<C<Ts...>>, C, Ts...>
-        {
-            using type = C<Ts...>;
-        };
-
-        template <template <typename...> class C, typename... Ts>
-        using defer_ = _defer_<void, C, Ts...>;
-
-        template <typename, typename T, template <T...> class, T...>
-        struct _defer_i_
-        {
-        };
-
-        template <typename T, template <T...> class C, T... Is>
-        struct _defer_i_<void_<C<Is...>>, T, C, Is...>
-        {
-            using type = C<Is...>;
-        };
-
-        template <typename T, template <T...> class C, T... Is>
-        using defer_i_ = _defer_i_<void, T, C, Is...>;
-#else                             // ^^^ workaround ^^^ / vvv no workaround vvv
-        template <template <typename...> class C, typename... Ts,
-                    template <typename...> class D = C>
-        id<D<Ts...>> try_defer_(int);
-        template <template <typename...> class C, typename... Ts>
-        nil_ try_defer_(long);
-
-        template <template <typename...> class C, typename... Ts>
-        using defer_ = decltype(detail::try_defer_<C, Ts...>(0));
-
-        template <typename T, template <T...> class C, T... Is, template <T...> class D = C>
-        id<D<Is...>> try_defer_i_(int);
-        template <typename T, template <T...> class C, T... Is>
-        nil_ try_defer_i_(long);
-
-        template <typename T, template <T...> class C, T... Is>
-        using defer_i_ = decltype(detail::try_defer_i_<T, C, Is...>(0));
-#endif                            // Concepts vs. MSVC vs. Other
-
-        template <typename T>
-        using _t_t = _t<_t<T>>;
-    } // namespace detail
-    /// \endcond
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // defer
-    /// A wrapper that defers the instantiation of a template \p C with type parameters \p Ts in
-    /// a \c lambda or \c let expression.
-    ///
-    /// In the code below, the lambda would ideally be written as
-    /// `lambda<_a,_b,push_back<_a,_b>>`, however this fails since `push_back` expects its first
-    /// argument to be a list, not a placeholder. Instead, we express it using \c defer as
-    /// follows:
-    ///
-    /// \code
-    /// template <typename L>
-    /// using reverse = reverse_fold<L, list<>, lambda<_a, _b, defer<push_back, _a, _b>>>;
-    /// \endcode
-    ///
-    /// \ingroup invocation
-    template <template <typename...> class C, typename... Ts>
-    struct defer : detail::defer_<C, Ts...>
-    {
-    };
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // defer_i
-    /// A wrapper that defers the instantiation of a template \p C with integral constant
-    /// parameters \p Is in a \c lambda or \c let expression.
-    /// \sa `defer`
-    /// \ingroup invocation
-    template <typename T, template <T...> class C, T... Is>
-    struct defer_i : detail::defer_i_<T, C, Is...>
-    {
-    };
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // defer_trait
-    /// A wrapper that defers the instantiation of a trait \p C with type parameters \p Ts in a
-    /// \c lambda or \c let expression.
-    /// \sa `defer`
-    /// \ingroup invocation
-    template <template <typename...> class C, typename... Ts>
-    using defer_trait = defer<detail::_t_t, detail::defer_<C, Ts...>>;
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // defer_trait_i
-    /// A wrapper that defers the instantiation of a trait \p C with integral constant
-    /// parameters \p Is in a \c lambda or \c let expression.
-    /// \sa `defer_i`
-    /// \ingroup invocation
-    template <typename T, template <T...> class C, T... Is>
-    using defer_trait_i = defer<detail::_t_t, detail::defer_i_<T, C, Is...>>;
-
-    /// An alias that computes the size of the type \p T.
-    /// \par Complexity
-    /// \f$ O(1) \f$.
-    /// \ingroup trait
-    template <typename T>
-    using sizeof_ = meta::size_t<sizeof(T)>;
-
-    /// An alias that computes the alignment required for any instance of the type \p T.
-    /// \par Complexity
-    /// \f$ O(1) \f$.
-    /// \ingroup trait
-    template <typename T>
-    using alignof_ = meta::size_t<alignof(T)>;
-
-    namespace lazy
-    {
-        /// \sa `meta::sizeof_`
-        /// \ingroup lazy_trait
-        template <typename T>
-        using sizeof_ = defer<sizeof_, T>;
-
-        /// \sa `meta::alignof_`
-        /// \ingroup lazy_trait
-        template <typename T>
-        using alignof_ = defer<alignof_, T>;
-    } // namespace lazy
-
-#if META_CXX_VARIABLE_TEMPLATES
-    /// is
-    /// Test whether a type \p T is an instantiation of class
-    /// template \p C.
-    /// \ingroup trait
-    template <typename T, template <typename...> class C>
-    using is = bool_<is_v<T, C>>;
-#else
-    /// is
-    /// \cond
-    namespace detail
-    {
-        template <typename, template <typename...> class>
-        struct is_ : std::false_type
-        {
-        };
-
-        template <typename... Ts, template <typename...> class C>
-        struct is_<C<Ts...>, C> : std::true_type
-        {
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// Test whether a type \c T is an instantiation of class
-    /// template \c C.
-    /// \ingroup trait
-    template <typename T, template <typename...> class C>
-    using is = _t<detail::is_<T, C>>;
-#endif
-
-    /// Compose the Invocables \p Fns in the parameter pack \p Ts.
-    /// \ingroup composition
-    template <META_TYPE_CONSTRAINT(invocable)... Fns>
-    struct compose_
-    {
-    };
-
-    template <META_TYPE_CONSTRAINT(invocable) Fn0>
-    struct compose_<Fn0>
-    {
-        template <typename... Ts>
-        using invoke = invoke<Fn0, Ts...>;
-    };
-
-    template <META_TYPE_CONSTRAINT(invocable) Fn0, META_TYPE_CONSTRAINT(invocable)... Fns>
-    struct compose_<Fn0, Fns...>
-    {
-        template <typename... Ts>
-        using invoke = invoke<Fn0, invoke<compose_<Fns...>, Ts...>>;
-    };
-
-    template <typename... Fns>
-    using compose = compose_<Fns...>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::compose'
-        /// \ingroup lazy_composition
-        template <typename... Fns>
-        using compose = defer<compose, Fns...>;
-    } // namespace lazy
-
-    /// Turn a template \p C into an invocable.
-    /// \ingroup composition
-    template <template <typename...> class C>
-    struct quote
-    {
-        // Indirection through defer here needed to avoid Core issue 1430
-        // https://wg21.link/cwg1430
-        template <typename... Ts>
-        using invoke = _t<defer<C, Ts...>>;
-    };
-
-    /// Turn a template \p C taking literals of type \p T into a
-    /// invocable.
-    /// \ingroup composition
-    template <typename T, template <T...> class C>
-    struct quote_i
-    {
-        // Indirection through defer_i here needed to avoid Core issue 1430
-        // https://wg21.link/cwg1430
-        template <META_TYPE_CONSTRAINT(integral)... Ts>
-        using invoke = _t<defer_i<T, C, Ts::type::value...>>;
-    };
-
-#if defined(__GNUC__) && !defined(__clang__) && __GNUC__ == 4 && __GNUC_MINOR__ <= 8 && \
-!defined(META_DOXYGEN_INVOKED)
-    template <template <typename...> class C>
-    struct quote_trait
-    {
-        template <typename... Ts>
-        using invoke = _t<invoke<quote<C>, Ts...>>;
-    };
-
-    template <typename T, template <T...> class C>
-    struct quote_trait_i
-    {
-        template <typename... Ts>
-        using invoke = _t<invoke<quote_i<T, C>, Ts...>>;
-    };
-#else
-    // clang-format off
-    /// Turn a trait template \p C into an invocable.
-    /// \code
-    /// static_assert(std::is_same_v<invoke<quote_trait<std::add_const>, int>, int const>, "");
-    /// \endcode
-    /// \ingroup composition
-    template <template <typename...> class C>
-    using quote_trait = compose<quote<_t>, quote<C>>;
-
-    /// Turn a trait template \p C taking literals of type \p T into an invocable.
-    /// \ingroup composition
-    template <typename T, template <T...> class C>
-    using quote_trait_i = compose<quote<_t>, quote_i<T, C>>;
-    // clang-format on
-#endif
-
-    /// An invocable that partially applies the invocable
-    /// \p Fn by binding the arguments \p Ts to the \e front of \p Fn.
-    /// \ingroup composition
-    template <META_TYPE_CONSTRAINT(invocable) Fn, typename... Ts>
-    struct bind_front
-    {
-        template <typename... Us>
-        using invoke = invoke<Fn, Ts..., Us...>;
-    };
-
-    /// An invocable that partially applies the invocable \p Fn by binding the
-    /// arguments \p Us to the \e back of \p Fn.
-    /// \ingroup composition
-    template <META_TYPE_CONSTRAINT(invocable) Fn, typename... Us>
-    struct bind_back
-    {
-        template <typename... Ts>
-        using invoke = invoke<Fn, Ts..., Us...>;
-    };
-
-    namespace lazy
-    {
-        /// \sa 'meta::bind_front'
-        /// \ingroup lazy_composition
-        template <typename Fn, typename... Ts>
-        using bind_front = defer<bind_front, Fn, Ts...>;
-
-        /// \sa 'meta::bind_back'
-        /// \ingroup lazy_composition
-        template <typename Fn, typename... Ts>
-        using bind_back = defer<bind_back, Fn, Ts...>;
-    } // namespace lazy
-
-    /// Extend meta with your own datatypes.
-    namespace extension
-    {
-        /// A trait that unpacks the types in the type list \p L into the invocable
-        /// \p Fn.
-        /// \ingroup extension
-        template <META_TYPE_CONSTRAINT(invocable) Fn, typename L>
-        struct apply
-        {
-        };
-
-        template <META_TYPE_CONSTRAINT(invocable) Fn, typename Ret, typename... Args>
-        struct apply<Fn, Ret(Args...)> : lazy::invoke<Fn, Ret, Args...>
-        {
-        };
-
-        template <META_TYPE_CONSTRAINT(invocable) Fn, template <typename...> class T,
-                    typename... Ts>
-        struct apply<Fn, T<Ts...>> : lazy::invoke<Fn, Ts...>
-        {
-        };
-
-        template <META_TYPE_CONSTRAINT(invocable) Fn, typename T, T... Is>
-        struct apply<Fn, integer_sequence<T, Is...>>
-          : lazy::invoke<Fn, std::integral_constant<T, Is>...>
-        {
-        };
-    } // namespace extension
-
-    /// Applies the invocable \p Fn using the types in the type list \p L as
-    /// arguments.
-    /// \ingroup invocation
-    template <META_TYPE_CONSTRAINT(invocable) Fn, typename L>
-    using apply = _t<extension::apply<Fn, L>>;
-
-    namespace lazy
-    {
-        template <typename Fn, typename L>
-        using apply = defer<apply, Fn, L>;
-    }
-
-    /// An invocable that takes a bunch of arguments, bundles them into a type
-    /// list, and then calls the invocable \p Fn with the type list \p Q.
-    /// \ingroup composition
-    template <META_TYPE_CONSTRAINT(invocable) Fn,
-                META_TYPE_CONSTRAINT(invocable) Q = quote<list>>
-    using curry = compose<Fn, Q>;
-
-    /// An invocable that takes a type list, unpacks the types, and then
-    /// calls the invocable \p Fn with the types.
-    /// \ingroup composition
-    template <META_TYPE_CONSTRAINT(invocable) Fn>
-    using uncurry = bind_front<quote<apply>, Fn>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::curry'
-        /// \ingroup lazy_composition
-        template <typename Fn, typename Q = quote<list>>
-        using curry = defer<curry, Fn, Q>;
-
-        /// \sa 'meta::uncurry'
-        /// \ingroup lazy_composition
-        template <typename Fn>
-        using uncurry = defer<uncurry, Fn>;
-    } // namespace lazy
-
-    /// An invocable that reverses the order of the first two arguments.
-    /// \ingroup composition
-    template <META_TYPE_CONSTRAINT(invocable) Fn>
-    struct flip
-    {
-    private:
-        template <typename... Ts>
-        struct impl
-        {
-        };
-        template <typename A, typename B, typename... Ts>
-        struct impl<A, B, Ts...> : lazy::invoke<Fn, B, A, Ts...>
-        {
-        };
-
-    public:
-        template <typename... Ts>
-        using invoke = _t<impl<Ts...>>;
-    };
-
-    namespace lazy
-    {
-        /// \sa 'meta::flip'
-        /// \ingroup lazy_composition
-        template <typename Fn>
-        using flip = defer<flip, Fn>;
-    } // namespace lazy
-
-    /// \cond
-    namespace detail
-    {
-        template <typename...>
-        struct on_
-        {
-        };
-        template <typename Fn, typename... Gs>
-        struct on_<Fn, Gs...>
-        {
-            template <typename... Ts>
-            using invoke = invoke<Fn, invoke<compose<Gs...>, Ts>...>;
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// Use as `on<Fn, Gs...>`. Creates an invocable that applies invocable \c Fn to the
-    /// result of applying invocable `compose<Gs...>` to all the arguments.
-    /// \ingroup composition
-    template <META_TYPE_CONSTRAINT(invocable)... Fns>
-    using on_ = detail::on_<Fns...>;
-
-    template <typename... Fns>
-    using on = on_<Fns...>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::on'
-        /// \ingroup lazy_composition
-        template <typename Fn, typename G>
-        using on = defer<on, Fn, G>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // conditional_t
-    /// \cond
-    namespace detail
-    {
-        template <bool>
-        struct _cond
-        {
-            template <typename Then, typename Else>
-            using invoke = Then;
-        };
-        template <>
-        struct _cond<false>
-        {
-            template <typename Then, typename Else>
-            using invoke = Else;
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// Select one type or another depending on a compile-time Boolean.
-    /// \ingroup logical
-    template <bool If, typename Then, typename Else = void>
-    using conditional_t = typename detail::_cond<If>::template invoke<Then, Else>;
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // if_
-    /// \cond
-    namespace detail
-    {
-#ifdef META_CONCEPT
-        template <typename...>
-        struct _if_
-        {
-        };
-
-        template <integral If>
-        struct _if_<If> : std::enable_if<_v<If>>
-        {
-        };
-
-        template <integral If, typename Then>
-        struct _if_<If, Then> : std::enable_if<_v<If>, Then>
-        {
-        };
-
-        template <integral If, typename Then, typename Else>
-        struct _if_<If, Then, Else> : std::conditional<_v<If>, Then, Else>
-        {
-        };
-#elif defined(__clang__)
-        // Clang is faster with this implementation
-        template <typename, typename = bool>
-        struct _if_
-        {
-        };
-
-        template <typename If>
-        struct _if_<list<If>, decltype(bool(If::type::value))> : std::enable_if<If::type::value>
-        {
-        };
-
-        template <typename If, typename Then>
-        struct _if_<list<If, Then>, decltype(bool(If::type::value))>
-          : std::enable_if<If::type::value, Then>
-        {
-        };
-
-        template <typename If, typename Then, typename Else>
-        struct _if_<list<If, Then, Else>, decltype(bool(If::type::value))>
-          : std::conditional<If::type::value, Then, Else>
-        {
-        };
-#else
-        // GCC seems to prefer this implementation
-        template <typename, typename = std::true_type>
-        struct _if_
-        {
-        };
-
-        template <typename If>
-        struct _if_<list<If>, bool_<If::type::value>>
-        {
-            using type = void;
-        };
-
-        template <typename If, typename Then>
-        struct _if_<list<If, Then>, bool_<If::type::value>>
-        {
-            using type = Then;
-        };
-
-        template <typename If, typename Then, typename Else>
-        struct _if_<list<If, Then, Else>, bool_<If::type::value>>
-        {
-            using type = Then;
-        };
-
-        template <typename If, typename Then, typename Else>
-        struct _if_<list<If, Then, Else>, bool_<!If::type::value>>
-        {
-            using type = Else;
-        };
-#endif
-    } // namespace detail
-        /// \endcond
-
-    /// Select one type or another depending on a compile-time Boolean.
-    /// \ingroup logical
-#ifdef META_CONCEPT
-    template <typename... Args>
-    using if_ = _t<detail::_if_<Args...>>;
-
-    /// Select one type or another depending on a compile-time Boolean.
-    /// \ingroup logical
-    template <bool If, typename... Args>
-    using if_c = _t<detail::_if_<bool_<If>, Args...>>;
-#else
-    template <typename... Args>
-    using if_ = _t<detail::_if_<list<Args...>>>;
-
-    template <bool If, typename... Args>
-    using if_c = _t<detail::_if_<list<bool_<If>, Args...>>>;
-#endif
-
-    namespace lazy
-    {
-        /// \sa 'meta::if_'
-        /// \ingroup lazy_logical
-        template <typename... Args>
-        using if_ = defer<if_, Args...>;
-
-        /// \sa 'meta::if_c'
-        /// \ingroup lazy_logical
-        template <bool If, typename... Args>
-        using if_c = if_<bool_<If>, Args...>;
-    } // namespace lazy
-
-    /// \cond
-    namespace detail
-    {
-#ifdef META_CONCEPT
-        template <typename...>
-        struct _and_
-        {
-        };
-
-        template <>
-        struct _and_<> : std::true_type
-        {
-        };
-
-        template <integral B, typename... Bs>
-        requires (bool(B::type::value)) struct _and_<B, Bs...> : _and_<Bs...>
-        {
-        };
-
-        template <integral B, typename... Bs>
-        requires (!bool(B::type::value)) struct _and_<B, Bs...> : std::false_type
-        {
-        };
-
-        template <typename...>
-        struct _or_
-        {
-        };
-
-        template <>
-        struct _or_<> : std::false_type
-        {
-        };
-
-        template <integral B, typename... Bs>
-        requires (bool(B::type::value)) struct _or_<B, Bs...> : std::true_type
-        {
-        };
-
-        template <integral B, typename... Bs>
-        requires (!bool(B::type::value)) struct _or_<B, Bs...> : _or_<Bs...>
-        {
-        };
-#else
-        template <bool>
-        struct _and_
-        {
-            template <typename...>
-            using invoke = std::true_type;
-        };
-
-        template <>
-        struct _and_<false>
-        {
-            template <typename B, typename... Bs>
-            using invoke = invoke<
-                if_c<!B::type::value, id<std::false_type>, _and_<0 == sizeof...(Bs)>>,
-                Bs...>;
-        };
-
-        template <bool>
-        struct _or_
-        {
-            template <typename = void>
-            using invoke = std::false_type;
-        };
-
-        template <>
-        struct _or_<false>
-        {
-            template <typename B, typename... Bs>
-            using invoke = invoke<
-                if_c<B::type::value, id<std::true_type>, _or_<0 == sizeof...(Bs)>>,
-                Bs...>;
-        };
-#endif
-    } // namespace detail
-    /// \endcond
-
-    /// Logically negate the Boolean parameter
-    /// \ingroup logical
-    template <bool B>
-    using not_c = bool_<!B>;
-
-    /// Logically negate the integral constant-wrapped Boolean parameter.
-    /// \ingroup logical
-    template <META_TYPE_CONSTRAINT(integral) B>
-    using not_ = not_c<B::type::value>;
-
-#if META_CXX_FOLD_EXPRESSIONS && !defined(META_WORKAROUND_GCC_UNKNOWN1)
-    template <bool... Bs>
-    META_INLINE_VAR constexpr bool and_v = (true && ... && Bs);
-
-    /// Logically AND together all the Boolean parameters
-    /// \ingroup logical
-    template <bool... Bs>
-#if defined(META_WORKAROUND_MSVC_756112) || defined(META_WORKAROUND_GCC_86356)
-    using and_c = bool_<and_v<Bs...>>;
-#else
-    using and_c = bool_<(true && ... && Bs)>;
-#endif
-#else
-#if defined(META_WORKAROUND_GCC_66405)
-    template <bool... Bs>
-    using and_c = meta::bool_<
-        META_IS_SAME(integer_sequence<bool, true, Bs...>,
-                     integer_sequence<bool, Bs..., true>)>;
-#else
-    template <bool... Bs>
-    struct and_c
-      : meta::bool_<
-            META_IS_SAME(integer_sequence<bool, Bs...>,
-                         integer_sequence<bool, (Bs || true)...>)>
-    {};
-#endif
-#if META_CXX_VARIABLE_TEMPLATES
-    template <bool... Bs>
-    META_INLINE_VAR constexpr bool and_v =
-        META_IS_SAME(integer_sequence<bool, Bs...>,
-                     integer_sequence<bool, (Bs || true)...>);
-#endif
-#endif
-
-    /// Logically AND together all the integral constant-wrapped Boolean
-    /// parameters, \e without short-circuiting.
-    /// \ingroup logical
-    template <META_TYPE_CONSTRAINT(integral)... Bs>
-    using strict_and_ = and_c<Bs::type::value...>;
-
-    template <typename... Bs>
-    using strict_and = strict_and_<Bs...>;
-
-    /// Logically AND together all the integral constant-wrapped Boolean
-    /// parameters, \e with short-circuiting.
-    /// \ingroup logical
-    template <typename... Bs>
-#ifdef META_CONCEPT
-    using and_ = _t<detail::_and_<Bs...>>;
-#else
-    // Make a trip through defer<> to avoid CWG1430
-    // https://wg21.link/cwg1430
-    using and_ = _t<defer<detail::_and_<0 == sizeof...(Bs)>::template invoke, Bs...>>;
-#endif
-
-    /// Logically OR together all the Boolean parameters
-    /// \ingroup logical
-#if META_CXX_FOLD_EXPRESSIONS && !defined(META_WORKAROUND_GCC_UNKNOWN1)
-    template <bool... Bs>
-    META_INLINE_VAR constexpr bool or_v = (false || ... || Bs);
-
-    template <bool... Bs>
-#if defined(META_WORKAROUND_MSVC_756112) || defined(META_WORKAROUND_GCC_86356)
-    using or_c = bool_<or_v<Bs...>>;
-#else
-    using or_c = bool_<(false || ... || Bs)>;
-#endif
-#else
-    template <bool... Bs>
-    struct or_c
-      : meta::bool_<
-            !META_IS_SAME(integer_sequence<bool, Bs...>,
-                          integer_sequence<bool, (Bs && false)...>)>
-    {};
-#if META_CXX_VARIABLE_TEMPLATES
-    template <bool... Bs>
-    META_INLINE_VAR constexpr bool or_v =
-        !META_IS_SAME(integer_sequence<bool, Bs...>,
-                      integer_sequence<bool, (Bs && false)...>);
-#endif
-#endif
-
-    /// Logically OR together all the integral constant-wrapped Boolean
-    /// parameters, \e without short-circuiting.
-    /// \ingroup logical
-    template <META_TYPE_CONSTRAINT(integral)... Bs>
-    using strict_or_ = or_c<Bs::type::value...>;
-
-    template <typename... Bs>
-    using strict_or = strict_or_<Bs...>;
-
-    /// Logically OR together all the integral constant-wrapped Boolean
-    /// parameters, \e with short-circuiting.
-    /// \ingroup logical
-    template <typename... Bs>
-#ifdef META_CONCEPT
-    using or_ = _t<detail::_or_<Bs...>>;
-#else
-    // Make a trip through defer<> to avoid CWG1430
-    // https://wg21.link/cwg1430
-    using or_ = _t<defer<detail::_or_<0 == sizeof...(Bs)>::template invoke, Bs...>>;
-#endif
-
-    namespace lazy
-    {
-        /// \sa 'meta::and_'
-        /// \ingroup lazy_logical
-        template <typename... Bs>
-        using and_ = defer<and_, Bs...>;
-
-        /// \sa 'meta::or_'
-        /// \ingroup lazy_logical
-        template <typename... Bs>
-        using or_ = defer<or_, Bs...>;
-
-        /// \sa 'meta::not_'
-        /// \ingroup lazy_logical
-        template <typename B>
-        using not_ = defer<not_, B>;
-
-        /// \sa 'meta::strict_and'
-        /// \ingroup lazy_logical
-        template <typename... Bs>
-        using strict_and = defer<strict_and, Bs...>;
-
-        /// \sa 'meta::strict_or'
-        /// \ingroup lazy_logical
-        template <typename... Bs>
-        using strict_or = defer<strict_or, Bs...>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // fold
-    /// \cond
-    namespace detail
-    {
-        template <typename, typename, typename>
-        struct fold_
-        {
-        };
-
-        template <typename Fn, typename T0, typename T1, typename T2, typename T3, typename T4,
-                    typename T5, typename T6, typename T7, typename T8, typename T9>
-        struct compose10_
-        {
-            template <typename X, typename Y>
-            using F = invoke<Fn, X, Y>;
-
-            template <typename S>
-            using invoke =
-                F<F<F<F<F<F<F<F<F<F<_t<S>, T0>, T1>, T2>, T3>, T4>, T5>, T6>, T7>, T8>, T9>;
-        };
-
-#ifdef META_CONCEPT
-        template <typename Fn>
-        struct compose_
-        {
-            template <typename X, typename Y>
-            using F = invoke<Fn, X, Y>;
-
-            template <typename T0, typename T1, typename T2, typename T3, typename T4,
-                        typename T5, typename T6, typename T7, typename T8, typename T9,
-                        typename State>
-            using invoke =
-                F<F<F<F<F<F<F<F<F<F<State, T0>, T1>, T2>, T3>, T4>, T5>, T6>, T7>, T8>, T9>;
-        };
-
-        template <typename State, typename Fn>
-        struct fold_<list<>, State, Fn>
-        {
-            using type = State;
-        };
-
-        template <typename Head, typename... Tail, typename State, typename Fn>
-        requires valid<invoke, Fn, State, Head>
-        struct fold_<list<Head, Tail...>, State, Fn>
-          : fold_<list<Tail...>, invoke<Fn, State, Head>, Fn>
-        {
-        };
-
-        template <typename T0, typename T1, typename T2, typename T3, typename T4, typename T5,
-                    typename T6, typename T7, typename T8, typename T9, typename... Tail,
-                    typename State, typename Fn>
-        requires valid<invoke, compose_<Fn>, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, State>
-        struct fold_<list<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, Tail...>, State, Fn>
-          : fold_<list<Tail...>,
-                  invoke<compose_<Fn>, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, State>, Fn>
-        {
-        };
-#else   // ^^^ Concepts / no Concepts vvv
-        template <typename Fn, typename T0>
-        struct compose1_
-        {
-            template <typename X>
-            using invoke = invoke<Fn, _t<X>, T0>;
-        };
-
-        template <typename State, typename Fn>
-        struct fold_<list<>, State, Fn> : State
-        {
-        };
-
-        template <typename Head, typename... Tail, typename State, typename Fn>
-        struct fold_<list<Head, Tail...>, State, Fn>
-          : fold_<list<Tail...>, lazy::invoke<compose1_<Fn, Head>, State>, Fn>
-        {
-        };
-
-        template <typename T0, typename T1, typename T2, typename T3, typename T4, typename T5,
-                    typename T6, typename T7, typename T8, typename T9, typename... Tail,
-                    typename State, typename Fn>
-        struct fold_<list<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, Tail...>, State, Fn>
-          : fold_<list<Tail...>,
-                  lazy::invoke<compose10_<Fn, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>, State>, Fn>
-        {
-        };
-#endif  // META_CONCEPT
-    } // namespace detail
-    /// \endcond
-
-    /// Return a new \c meta::list constructed by doing a left fold of the list \p L using
-    /// binary invocable \p Fn and initial state \p State. That is, the \c State_N for
-    /// the list element \c A_N is computed by `Fn(State_N-1, A_N) -> State_N`.
-    /// \par Complexity
-    /// \f$ O(N) \f$.
-    /// \ingroup transformation
-    template <META_TYPE_CONSTRAINT(list_like) L, typename State, META_TYPE_CONSTRAINT(invocable) Fn>
-#ifdef META_CONCEPT
-    using fold = _t<detail::fold_<L, State, Fn>>;
-#else
-    using fold = _t<detail::fold_<L, id<State>, Fn>>;
-#endif
-
-    /// An alias for `meta::fold`.
-    /// \par Complexity
-    /// \f$ O(N) \f$.
-    /// \ingroup transformation
-    template <META_TYPE_CONSTRAINT(list_like) L, typename State, META_TYPE_CONSTRAINT(invocable) Fn>
-    using accumulate = fold<L, State, Fn>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::foldl'
-        /// \ingroup lazy_transformation
-        template <typename L, typename State, typename Fn>
-        using fold = defer<fold, L, State, Fn>;
-
-        /// \sa 'meta::accumulate'
-        /// \ingroup lazy_transformation
-        template <typename L, typename State, typename Fn>
-        using accumulate = defer<accumulate, L, State, Fn>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // reverse_fold
-    /// \cond
-    namespace detail
-    {
-        template <typename, typename, typename>
-        struct reverse_fold_
-        {
-        };
-
-        template <typename State, typename Fn>
-        struct reverse_fold_<list<>, State, Fn>
-        {
-            using type = State;
-        };
-
-#ifdef META_CONCEPT
-        template <typename Head, typename... L, typename State, typename Fn>
-        requires trait<reverse_fold_<list<L...>, State, Fn>> struct reverse_fold_<
-            list<Head, L...>, State, Fn>
-          : lazy::invoke<Fn, _t<reverse_fold_<list<L...>, State, Fn>>, Head>
-        {
-        };
-#else
-        template <typename Head, typename... Tail, typename State, typename Fn>
-        struct reverse_fold_<list<Head, Tail...>, State, Fn>
-          : lazy::invoke<compose1_<Fn, Head>, reverse_fold_<list<Tail...>, State, Fn>>
-        {
-        };
-#endif
-
-        template <typename T0, typename T1, typename T2, typename T3, typename T4, typename T5,
-                    typename T6, typename T7, typename T8, typename T9, typename... Tail,
-                    typename State, typename Fn>
-        struct reverse_fold_<list<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, Tail...>, State, Fn>
-          : lazy::invoke<compose10_<Fn, T9, T8, T7, T6, T5, T4, T3, T2, T1, T0>,
-                            reverse_fold_<list<Tail...>, State, Fn>>
-        {
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// Return a new \c meta::list constructed by doing a right fold of the list \p L using
-    /// binary invocable \p Fn and initial state \p State. That is, the \c State_N for the list
-    /// element \c A_N is computed by `Fn(A_N, State_N+1) -> State_N`.
-    /// \par Complexity
-    /// \f$ O(N) \f$.
-    /// \ingroup transformation
-    template <META_TYPE_CONSTRAINT(list_like) L, typename State, META_TYPE_CONSTRAINT(invocable) Fn>
-    using reverse_fold = _t<detail::reverse_fold_<L, State, Fn>>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::foldr'
-        /// \ingroup lazy_transformation
-        template <typename L, typename State, typename Fn>
-        using reverse_fold = defer<reverse_fold, L, State, Fn>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // npos
-    /// A special value used to indicate no matches. It equals the maximum
-    /// value representable by std::size_t.
-    /// \ingroup list
-    using npos = meta::size_t<std::size_t(-1)>;
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // list
-    /// A list of types.
-    /// \ingroup list
-    template <typename... Ts>
-    struct list
-    {
-        using type = list;
-        /// \return `sizeof...(Ts)`
-        static constexpr std::size_t size() noexcept { return sizeof...(Ts); }
-    };
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // size
-    /// An integral constant wrapper that is the size of the \c meta::list
-    /// \p L.
-    /// \ingroup list
-    template <META_TYPE_CONSTRAINT(list_like) L>
-    using size = meta::size_t<L::size()>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::size'
-        /// \ingroup lazy_list
-        template <typename L>
-        using size = defer<size, L>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // concat
-    /// \cond
-    namespace detail
-    {
-        template <typename... Lists>
-        struct concat_
-        {
-        };
-
-        template <>
-        struct concat_<>
-        {
-            using type = list<>;
-        };
-
-        template <typename... L1>
-        struct concat_<list<L1...>>
-        {
-            using type = list<L1...>;
-        };
-
-        template <typename... L1, typename... L2>
-        struct concat_<list<L1...>, list<L2...>>
-        {
-            using type = list<L1..., L2...>;
-        };
-
-        template <typename... L1, typename... L2, typename... L3>
-        struct concat_<list<L1...>, list<L2...>, list<L3...>>
-        {
-            using type = list<L1..., L2..., L3...>;
-        };
-
-        template <typename... L1, typename... L2, typename... L3, typename... Rest>
-        struct concat_<list<L1...>, list<L2...>, list<L3...>, Rest...>
-          : concat_<list<L1..., L2..., L3...>, Rest...>
-        {
-        };
-
-        template <typename... L1, typename... L2, typename... L3, typename... L4,
-                    typename... L5, typename... L6, typename... L7, typename... L8,
-                    typename... L9, typename... L10, typename... Rest>
-        struct concat_<list<L1...>, list<L2...>, list<L3...>, list<L4...>, list<L5...>,
-                        list<L6...>, list<L7...>, list<L8...>, list<L9...>, list<L10...>,
-                        Rest...>
-          : concat_<list<L1..., L2..., L3..., L4..., L5..., L6..., L7..., L8..., L9..., L10...>,
-                    Rest...>
-        {
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// Concatenates several lists into a single list.
-    /// \pre The parameters must all be instantiations of \c meta::list.
-    /// \par Complexity
-    /// \f$ O(L) \f$ where \f$ L \f$ is the number of lists in the list of lists.
-    /// \ingroup transformation
-    template <META_TYPE_CONSTRAINT(list_like)... Ls>
-    using concat_ = _t<detail::concat_<Ls...>>;
-
-    template <typename... Lists>
-    using concat = concat_<Lists...>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::concat'
-        /// \ingroup lazy_transformation
-        template <typename... Lists>
-        using concat = defer<concat, Lists...>;
-    } // namespace lazy
-
-    /// Joins a list of lists into a single list.
-    /// \pre The parameter must be an instantiation of \c meta::list\<T...\>
-    /// where each \c T is itself an instantiation of \c meta::list.
-    /// \par Complexity
-    /// \f$ O(L) \f$ where \f$ L \f$ is the number of lists in the list of
-    /// lists.
-    /// \ingroup transformation
-    template <META_TYPE_CONSTRAINT(list_like) ListOfLists>
-    using join = apply<quote<concat>, ListOfLists>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::join'
-        /// \ingroup lazy_transformation
-        template <typename ListOfLists>
-        using join = defer<join, ListOfLists>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // transform
-    /// \cond
-    namespace detail
-    {
-#ifdef META_CONCEPT
-        template <typename... Args>
-        struct transform_
-        {
-        };
-
-        template <typename... Ts, invocable Fn>
-        requires and_v<valid<invoke, Fn, Ts>...>
-        struct transform_<list<Ts...>, Fn>
-        {
-            using type = list<invoke<Fn, Ts>...>;
-        };
-
-        template <typename... Ts, typename... Us, invocable Fn>
-        requires and_v<valid<invoke, Fn, Ts, Us>...>
-        struct transform_<list<Ts...>, list<Us...>, Fn>
-        {
-            using type = list<invoke<Fn, Ts, Us>...>;
-        };
-#else
-        template <typename, typename = void>
-        struct transform_
-        {
-        };
-
-        template <typename... Ts, typename Fn>
-        struct transform_<list<list<Ts...>, Fn>, void_<invoke<Fn, Ts>...>>
-        {
-            using type = list<invoke<Fn, Ts>...>;
-        };
-
-        template <typename... Ts0, typename... Ts1, typename Fn>
-        struct transform_<list<list<Ts0...>, list<Ts1...>, Fn>,
-                            void_<invoke<Fn, Ts0, Ts1>...>>
-        {
-            using type = list<invoke<Fn, Ts0, Ts1>...>;
-        };
-#endif
-    } // namespace detail
-        /// \endcond
-
-    /// Return a new \c meta::list constructed by transforming all the
-    /// elements in \p L with the unary invocable \p Fn. \c transform can
-    /// also be called with two lists of the same length and a binary
-    /// invocable, in which case it returns a new list constructed with the
-    /// results of calling \c Fn with each element in the lists, pairwise.
-    /// \par Complexity
-    /// \f$ O(N) \f$.
-    /// \ingroup transformation
-#ifdef META_CONCEPT
-    template <typename... Args>
-    using transform = _t<detail::transform_<Args...>>;
-#else
-    template <typename... Args>
-    using transform = _t<detail::transform_<list<Args...>>>;
-#endif
-
-    namespace lazy
-    {
-        /// \sa 'meta::transform'
-        /// \ingroup lazy_transformation
-        template <typename... Args>
-        using transform = defer<transform, Args...>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // repeat_n
-    /// \cond
-    namespace detail
-    {
-        template <typename T, std::size_t>
-        using first_ = T;
-
-        template <typename T, typename Ints>
-        struct repeat_n_c_
-        {
-        };
-
-        template <typename T, std::size_t... Is>
-        struct repeat_n_c_<T, index_sequence<Is...>>
-        {
-            using type = list<first_<T, Is>...>;
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// Generate `list<T,T,T...T>` of size \p N arguments.
-    /// \par Complexity
-    /// \f$ O(log N) \f$.
-    /// \ingroup list
-    template <std::size_t N, typename T = void>
-    using repeat_n_c = _t<detail::repeat_n_c_<T, make_index_sequence<N>>>;
-
-    /// Generate `list<T,T,T...T>` of size \p N arguments.
-    /// \par Complexity
-    /// \f$ O(log N) \f$.
-    /// \ingroup list
-    template <META_TYPE_CONSTRAINT(integral) N, typename T = void>
-    using repeat_n = repeat_n_c<N::type::value, T>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::repeat_n'
-        /// \ingroup lazy_list
-        template <typename N, typename T = void>
-        using repeat_n = defer<repeat_n, N, T>;
-
-        /// \sa 'meta::repeat_n_c'
-        /// \ingroup lazy_list
-        template <std::size_t N, typename T = void>
-        using repeat_n_c = defer<repeat_n, meta::size_t<N>, T>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // at
-    /// \cond
-    namespace detail
-    {
-#if META_HAS_TYPE_PACK_ELEMENT && !defined(META_DOXYGEN_INVOKED)
-        template <typename L, std::size_t N, typename = void>
-        struct at_
-        {
-        };
-
-        template <typename... Ts, std::size_t N>
-        struct at_<list<Ts...>, N, void_<__type_pack_element<N, Ts...>>>
-        {
-            using type = __type_pack_element<N, Ts...>;
-        };
-#else
-        template <typename VoidPtrs>
-        struct at_impl_;
-
-        template <typename... VoidPtrs>
-        struct at_impl_<list<VoidPtrs...>>
-        {
-            static nil_ eval(...);
-
-            template <typename T, typename... Us>
-            static T eval(VoidPtrs..., T *, Us *...);
-        };
-
-        template <typename L, std::size_t N>
-        struct at_
-        {
-        };
-
-        template <typename... Ts, std::size_t N>
-        struct at_<list<Ts...>, N>
-          : decltype(at_impl_<repeat_n_c<N, void *>>::eval(static_cast<id<Ts> *>(nullptr)...))
-        {
-        };
-#endif    // META_HAS_TYPE_PACK_ELEMENT
-    } // namespace detail
-    /// \endcond
-
-    /// Return the \p N th element in the \c meta::list \p L.
-    /// \par Complexity
-    /// Amortized \f$ O(1) \f$.
-    /// \ingroup list
-    template <META_TYPE_CONSTRAINT(list_like) L, std::size_t N>
-    using at_c = _t<detail::at_<L, N>>;
-
-    /// Return the \p N th element in the \c meta::list \p L.
-    /// \par Complexity
-    /// Amortized \f$ O(1) \f$.
-    /// \ingroup list
-    template <META_TYPE_CONSTRAINT(list_like) L, META_TYPE_CONSTRAINT(integral) N>
-    using at = at_c<L, N::type::value>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::at'
-        /// \ingroup lazy_list
-        template <typename L, typename N>
-        using at = defer<at, L, N>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // drop
-    /// \cond
-    namespace detail
-    {
-        ///////////////////////////////////////////////////////////////////////////////////////
-        /// drop_impl_
-        template <typename VoidPtrs>
-        struct drop_impl_
-        {
-            static nil_ eval(...);
-        };
-
-        template <typename... VoidPtrs>
-        struct drop_impl_<list<VoidPtrs...>>
-        {
-            static nil_ eval(...);
-
-            template <typename... Ts>
-            static id<list<Ts...>> eval(VoidPtrs..., id<Ts> *...);
-        };
-
-        template <>
-        struct drop_impl_<list<>>
-        {
-            template <typename... Ts>
-            static id<list<Ts...>> eval(id<Ts> *...);
-        };
-
-        template <typename L, std::size_t N>
-        struct drop_
-        {
-        };
-
-        template <typename... Ts, std::size_t N>
-        struct drop_<list<Ts...>, N>
-#if META_CXX_VARIABLE_TEMPLATES
-          : decltype(drop_impl_<repeat_n_c<N, void *>>::eval(detail::nullptr_v<id<Ts>>...))
-#else
-          : decltype(drop_impl_<repeat_n_c<N, void *>>::eval(detail::_nullptr_v<id<Ts>>()...))
-#endif
-        {
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// Return a new \c meta::list by removing the first \p N elements from \p L.
-    /// \par Complexity
-    /// \f$ O(1) \f$.
-    /// \ingroup transformation
-    template <META_TYPE_CONSTRAINT(list_like) L, std::size_t N>
-    using drop_c = _t<detail::drop_<L, N>>;
-
-    /// Return a new \c meta::list by removing the first \p N elements from \p L.
-    /// \par Complexity
-    /// \f$ O(1) \f$.
-    /// \ingroup transformation
-    template <META_TYPE_CONSTRAINT(list_like) L, META_TYPE_CONSTRAINT(integral) N>
-    using drop = drop_c<L, N::type::value>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::drop'
-        /// \ingroup lazy_transformation
-        template <typename L, typename N>
-        using drop = defer<drop, L, N>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // front
-    /// \cond
-    namespace detail
-    {
-        template <typename L>
-        struct front_
-        {
-        };
-
-        template <typename Head, typename... Tail>
-        struct front_<list<Head, Tail...>>
-        {
-            using type = Head;
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// Return the first element in \c meta::list \p L.
-    /// \par Complexity
-    /// \f$ O(1) \f$.
-    /// \ingroup list
-    template <META_TYPE_CONSTRAINT(list_like) L>
-    using front = _t<detail::front_<L>>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::front'
-        /// \ingroup lazy_list
-        template <typename L>
-        using front = defer<front, L>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // back
-    /// \cond
-    namespace detail
-    {
-        template <typename L>
-        struct back_
-        {
-        };
-
-        template <typename Head, typename... Tail>
-        struct back_<list<Head, Tail...>>
-        {
-            using type = at_c<list<Head, Tail...>, sizeof...(Tail)>;
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// Return the last element in \c meta::list \p L.
-    /// \par Complexity
-    /// Amortized \f$ O(1) \f$.
-    /// \ingroup list
-    template <META_TYPE_CONSTRAINT(list_like) L>
-    using back = _t<detail::back_<L>>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::back'
-        /// \ingroup lazy_list
-        template <typename L>
-        using back = defer<back, L>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // push_front
-    /// Return a new \c meta::list by adding the element \c T to the front of \p L.
-    /// \par Complexity
-    /// \f$ O(1) \f$.
-    /// \ingroup transformation
-    template <META_TYPE_CONSTRAINT(list_like) L, typename... Ts>
-    using push_front = apply<bind_front<quote<list>, Ts...>, L>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::push_front'
-        /// \ingroup lazy_transformation
-        template <typename... Ts>
-        using push_front = defer<push_front, Ts...>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // pop_front
-    /// \cond
-    namespace detail
-    {
-        template <typename L>
-        struct pop_front_
-        {
-        };
-
-        template <typename Head, typename... L>
-        struct pop_front_<list<Head, L...>>
-        {
-            using type = list<L...>;
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// Return a new \c meta::list by removing the first element from the
-    /// front of \p L.
-    /// \par Complexity
-    /// \f$ O(1) \f$.
-    /// \ingroup transformation
-    template <META_TYPE_CONSTRAINT(list_like) L>
-    using pop_front = _t<detail::pop_front_<L>>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::pop_front'
-        /// \ingroup lazy_transformation
-        template <typename L>
-        using pop_front = defer<pop_front, L>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // push_back
-    /// Return a new \c meta::list by adding the element \c T to the back of \p L.
-    /// \par Complexity
-    /// \f$ O(1) \f$.
-    /// \note \c pop_back not provided because it cannot be made to meet the
-    /// complexity guarantees one would expect.
-    /// \ingroup transformation
-    template <META_TYPE_CONSTRAINT(list_like) L, typename... Ts>
-    using push_back = apply<bind_back<quote<list>, Ts...>, L>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::push_back'
-        /// \ingroup lazy_transformation
-        template <typename... Ts>
-        using push_back = defer<push_back, Ts...>;
-    } // namespace lazy
-
-    /// \cond
-    namespace detail
-    {
-        template <typename T, typename U>
-        using min_ = if_<less<U, T>, U, T>;
-
-        template <typename T, typename U>
-        using max_ = if_<less<U, T>, T, U>;
-    } // namespace detail
-    /// \endcond
-
-    /// An integral constant wrapper around the minimum of `Ts::type::value...`
-    /// \ingroup math
-    template <META_TYPE_CONSTRAINT(integral)... Ts>
-    using min_ = fold<pop_front<list<Ts...>>, front<list<Ts...>>, quote<detail::min_>>;
-
-    template <typename... Ts>
-    using min = min_<Ts...>;
-
-    /// An integral constant wrapper around the maximum of `Ts::type::value...`
-    /// \ingroup math
-    template <META_TYPE_CONSTRAINT(integral)... Ts>
-    using max_ = fold<pop_front<list<Ts...>>, front<list<Ts...>>, quote<detail::max_>>;
-
-    template <typename... Ts>
-    using max = max_<Ts...>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::min'
-        /// \ingroup lazy_math
-        template <typename... Ts>
-        using min = defer<min, Ts...>;
-
-        /// \sa 'meta::max'
-        /// \ingroup lazy_math
-        template <typename... Ts>
-        using max = defer<max, Ts...>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // empty
-    /// An Boolean integral constant wrapper around \c true if \p L is an
-    /// empty type list; \c false, otherwise.
-    /// \par Complexity
-    /// \f$ O(1) \f$.
-    /// \ingroup list
-    template <META_TYPE_CONSTRAINT(list_like) L>
-    using empty = bool_<0 == size<L>::type::value>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::empty'
-        /// \ingroup lazy_list
-        template <typename L>
-        using empty = defer<empty, L>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // pair
-    /// A list with exactly two elements
-    /// \ingroup list
-    template <typename F, typename S>
-    using pair = list<F, S>;
-
-    /// Retrieve the first element of the \c pair \p Pair
-    /// \ingroup list
-    template <typename Pair>
-    using first = front<Pair>;
-
-    /// Retrieve the first element of the \c pair \p Pair
-    /// \ingroup list
-    template <typename Pair>
-    using second = front<pop_front<Pair>>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::first'
-        /// \ingroup lazy_list
-        template <typename Pair>
-        using first = defer<first, Pair>;
-
-        /// \sa 'meta::second'
-        /// \ingroup lazy_list
-        template <typename Pair>
-        using second = defer<second, Pair>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // find_index
-    /// \cond
-    namespace detail
-    {
-        // With thanks to Peter Dimov:
-        constexpr std::size_t find_index_i_(bool const *const first, bool const *const last,
-                                            std::size_t N = 0)
-        {
-            return first == last ? npos::value
-                                 : *first ? N : find_index_i_(first + 1, last, N + 1);
-        }
-
-        template <typename L, typename T>
-        struct find_index_
-        {
-        };
-
-        template <typename V>
-        struct find_index_<list<>, V>
-        {
-            using type = npos;
-        };
-
-        template <typename... T, typename V>
-        struct find_index_<list<T...>, V>
-        {
-#ifdef META_WORKAROUND_LLVM_28385
-            static constexpr bool s_v[sizeof...(T)] = {META_IS_SAME(T, V)...};
-#else
-            static constexpr bool s_v[] = {META_IS_SAME(T, V)...};
-#endif
-            using type = size_t<find_index_i_(s_v, s_v + sizeof...(T))>;
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// Finds the index of the first occurrence of the type \p T within the list \p L.
-    /// Returns `#meta::npos` if the type \p T was not found.
-    /// \par Complexity
-    /// \f$ O(N) \f$.
-    /// \ingroup query
-    /// \sa `meta::npos`
-    template <META_TYPE_CONSTRAINT(list_like) L, typename T>
-    using find_index = _t<detail::find_index_<L, T>>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::find_index'
-        /// \ingroup lazy_query
-        template <typename L, typename T>
-        using find_index = defer<find_index, L, T>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // reverse_find_index
-    /// \cond
-    namespace detail
-    {
-        // With thanks to Peter Dimov:
-        constexpr std::size_t reverse_find_index_i_(bool const *const first,
-                                                    bool const *const last, std::size_t N)
-        {
-            return first == last
-                ? npos::value
-                : *(last - 1) ? N - 1 : reverse_find_index_i_(first, last - 1, N - 1);
-        }
-
-        template <typename L, typename T>
-        struct reverse_find_index_
-        {
-        };
-
-        template <typename V>
-        struct reverse_find_index_<list<>, V>
-        {
-            using type = npos;
-        };
-
-        template <typename... T, typename V>
-        struct reverse_find_index_<list<T...>, V>
-        {
-#ifdef META_WORKAROUND_LLVM_28385
-            static constexpr bool s_v[sizeof...(T)] = {META_IS_SAME(T, V)...};
-#else
-            static constexpr bool s_v[] = {META_IS_SAME(T, V)...};
-#endif
-            using type = size_t<reverse_find_index_i_(s_v, s_v + sizeof...(T), sizeof...(T))>;
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// Finds the index of the last occurrence of the type \p T within the
-    /// list \p L. Returns `#meta::npos` if the type \p T was not found.
-    /// \par Complexity
-    /// \f$ O(N) \f$.
-    /// \ingroup query
-    /// \sa `#meta::npos`
-    template <META_TYPE_CONSTRAINT(list_like) L, typename T>
-    using reverse_find_index = _t<detail::reverse_find_index_<L, T>>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::reverse_find_index'
-        /// \ingroup lazy_query
-        template <typename L, typename T>
-        using reverse_find_index = defer<reverse_find_index, L, T>;
-    } // namespace lazy
-
-    ////////////////////////////////////////////////////////////////////////////////////
-    // find
-    /// Return the tail of the list \p L starting at the first occurrence of
-    /// \p T, if any such element exists; the empty list, otherwise.
-    /// \par Complexity
-    /// \f$ O(N) \f$.
-    /// \ingroup query
-    template <META_TYPE_CONSTRAINT(list_like) L, typename T>
-    using find = drop<L, min<find_index<L, T>, size<L>>>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::find'
-        /// \ingroup lazy_query
-        template <typename L, typename T>
-        using find = defer<find, L, T>;
-    } // namespace lazy
-
-    ////////////////////////////////////////////////////////////////////////////////////
-    // reverse_find
-    /// \cond
-    namespace detail
-    {
-        template <typename L, typename T, typename State = list<>>
-        struct reverse_find_
-        {
-        };
-
-        template <typename T, typename State>
-        struct reverse_find_<list<>, T, State>
-        {
-            using type = State;
-        };
-
-        template <typename Head, typename... L, typename T, typename State>
-        struct reverse_find_<list<Head, L...>, T, State> : reverse_find_<list<L...>, T, State>
-        {
-        };
-
-        template <typename... L, typename T, typename State>
-        struct reverse_find_<list<T, L...>, T, State>
-          : reverse_find_<list<L...>, T, list<T, L...>>
-        {
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// Return the tail of the list \p L starting at the last occurrence of \p T, if any such
-    /// element exists; the empty list, otherwise.
-    /// \par Complexity
-    /// \f$ O(N) \f$.
-    /// \ingroup query
-    template <META_TYPE_CONSTRAINT(list_like) L, typename T>
-    using reverse_find = drop<L, min<reverse_find_index<L, T>, size<L>>>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::rfind'
-        /// \ingroup lazy_query
-        template <typename L, typename T>
-        using reverse_find = defer<reverse_find, L, T>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // find_if
-    /// \cond
-    namespace detail
-    {
-#ifdef META_CONCEPT
-        template <typename L, typename Fn>
-        struct find_if_
-        {
-        };
-
-        template <typename Fn>
-        struct find_if_<list<>, Fn>
-        {
-            using type = list<>;
-        };
-
-        template <typename Head, typename... L, typename Fn>
-        requires integral<invoke<Fn, Head>>
-        struct find_if_<list<Head, L...>, Fn>
-          : if_<invoke<Fn, Head>, id<list<Head, L...>>, find_if_<list<L...>, Fn>>
-        {
-        };
-#else
-        constexpr bool const *find_if_i_(bool const *const begin, bool const *const end)
-        {
-            return begin == end || *begin ? begin : find_if_i_(begin + 1, end);
-        }
-
-        template <typename L, typename Fn, typename = void>
-        struct find_if_
-        {
-        };
-
-        template <typename Fn>
-        struct find_if_<list<>, Fn>
-        {
-            using type = list<>;
-        };
-
-        template <typename... L, typename Fn>
-        struct find_if_<list<L...>, Fn,
-                        void_<integer_sequence<bool, bool(invoke<Fn, L>::type::value)...>>>
-        {
-#ifdef META_WORKAROUND_LLVM_28385
-            static constexpr bool s_v[sizeof...(L)] = {invoke<Fn, L>::type::value...};
-#else
-            static constexpr bool s_v[] = {invoke<Fn, L>::type::value...};
-#endif
-            using type =
-                drop_c<list<L...>, detail::find_if_i_(s_v, s_v + sizeof...(L)) - s_v>;
-        };
-#endif
-    } // namespace detail
-    /// \endcond
-
-    /// Return the tail of the list \p L starting at the first element `A`
-    /// such that `invoke<Fn, A>::%value` is \c true, if any such element
-    /// exists; the empty list, otherwise.
-    /// \par Complexity
-    /// \f$ O(N) \f$.
-    /// \ingroup query
-    template <META_TYPE_CONSTRAINT(list_like) L, META_TYPE_CONSTRAINT(invocable) Fn>
-    using find_if = _t<detail::find_if_<L, Fn>>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::find_if'
-        /// \ingroup lazy_query
-        template <typename L, typename Fn>
-        using find_if = defer<find_if, L, Fn>;
-    } // namespace lazy
-
-    ////////////////////////////////////////////////////////////////////////////////////
-    // reverse_find_if
-    /// \cond
-    namespace detail
-    {
-#ifdef META_CONCEPT
-        template <typename L, typename Fn, typename State = list<>>
-        struct reverse_find_if_
-        {
-        };
-
-        template <typename Fn, typename State>
-        struct reverse_find_if_<list<>, Fn, State>
-        {
-            using type = State;
-        };
-
-        template <typename Head, typename... L, typename Fn, typename State>
-        requires integral<invoke<Fn, Head>>
-        struct reverse_find_if_<list<Head, L...>, Fn, State>
-          : reverse_find_if_<list<L...>, Fn, if_<invoke<Fn, Head>, list<Head, L...>, State>>
-        {
-        };
-#else
-        constexpr bool const *reverse_find_if_i_(bool const *const begin, bool const *const pos,
-                                                    bool const *const end)
-        {
-            return begin == pos
-                ? end
-                : *(pos - 1) ? pos - 1 : reverse_find_if_i_(begin, pos - 1, end);
-        }
-
-        template <typename L, typename Fn, typename = void>
-        struct reverse_find_if_
-        {
-        };
-
-        template <typename Fn>
-        struct reverse_find_if_<list<>, Fn>
-        {
-            using type = list<>;
-        };
-
-        template <typename... L, typename Fn>
-        struct reverse_find_if_<
-            list<L...>, Fn,
-            void_<integer_sequence<bool, bool(invoke<Fn, L>::type::value)...>>>
-        {
-#ifdef META_WORKAROUND_LLVM_28385
-            static constexpr bool s_v[sizeof...(L)] = {invoke<Fn, L>::type::value...};
-#else
-            static constexpr bool s_v[] = {invoke<Fn, L>::type::value...};
-#endif
-            using type =
-                drop_c<list<L...>, detail::reverse_find_if_i_(s_v, s_v + sizeof...(L),
-                                                                    s_v + sizeof...(L)) -
-                                            s_v>;
-        };
-#endif
-    } // namespace detail
-    /// \endcond
-
-    /// Return the tail of the list \p L starting at the last element `A`
-    /// such that `invoke<Fn, A>::%value` is \c true, if any such element
-    /// exists; the empty list, otherwise.
-    /// \par Complexity
-    /// \f$ O(N) \f$.
-    /// \ingroup query
-    template <META_TYPE_CONSTRAINT(list_like) L, META_TYPE_CONSTRAINT(invocable) Fn>
-    using reverse_find_if = _t<detail::reverse_find_if_<L, Fn>>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::rfind_if'
-        /// \ingroup lazy_query
-        template <typename L, typename Fn>
-        using reverse_find_if = defer<reverse_find_if, L, Fn>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // replace
-    /// \cond
-    namespace detail
-    {
-        template <typename L, typename T, typename U>
-        struct replace_
-        {
-        };
-
-        template <typename... L, typename T, typename U>
-        struct replace_<list<L...>, T, U>
-        {
-            using type = list<if_c<META_IS_SAME(T, L), U, L>...>;
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// Return a new \c meta::list where all instances of type \p T have
-    /// been replaced with \p U.
-    /// \par Complexity
-    /// \f$ O(N) \f$.
-    /// \ingroup transformation
-    template <META_TYPE_CONSTRAINT(list_like) L, typename T, typename U>
-    using replace = _t<detail::replace_<L, T, U>>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::replace'
-        /// \ingroup lazy_transformation
-        template <typename L, typename T, typename U>
-        using replace = defer<replace, T, U>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // replace_if
-    /// \cond
-    namespace detail
-    {
-#ifdef META_CONCEPT
-        template <typename L, typename C, typename U>
-        struct replace_if_
-        {
-        };
-
-        template <typename... L, typename C, typename U>
-        requires and_v<integral<invoke<C, L>>...>
-        struct replace_if_<list<L...>, C, U>
-        {
-            using type = list<if_<invoke<C, L>, U, L>...>;
-        };
-#else
-        template <typename L, typename C, typename U, typename = void>
-        struct replace_if_
-        {
-        };
-
-        template <typename... L, typename C, typename U>
-        struct replace_if_<list<L...>, C, U,
-                            void_<integer_sequence<bool, bool(invoke<C, L>::type::value)...>>>
-        {
-            using type = list<if_<invoke<C, L>, U, L>...>;
-        };
-#endif
-    } // namespace detail
-    /// \endcond
-
-    /// Return a new \c meta::list where all elements \c A of the list \p L
-    /// for which `invoke<C,A>::%value` is \c true have been replaced with
-    /// \p U.
-    /// \par Complexity
-    /// \f$ O(N) \f$.
-    /// \ingroup transformation
-    template <META_TYPE_CONSTRAINT(list_like) L, typename C, typename U>
-    using replace_if = _t<detail::replace_if_<L, C, U>>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::replace_if'
-        /// \ingroup lazy_transformation
-        template <typename L, typename C, typename U>
-        using replace_if = defer<replace_if, C, U>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////
-    // count
-    namespace detail
-    {
-        template <typename, typename>
-        struct count_
-        {
-        };
-
-#if (defined(META_CONCEPT) || META_CXX_VARIABLE_TEMPLATES) && META_CXX_FOLD_EXPRESSIONS
-        template <typename... Ts, typename T>
-        struct count_<list<Ts...>, T>
-        {
-            using type = meta::size_t<((std::size_t)META_IS_SAME(T, Ts) + ...)>;
-        };
-#else
-        constexpr std::size_t count_i_(bool const *const begin, bool const *const end,
-                                       std::size_t n)
-        {
-            return begin == end ? n : detail::count_i_(begin + 1, end, n + *begin);
-        }
-
-        template <typename T>
-        struct count_<list<>, T>
-        {
-            using type = meta::size_t<0>;
-        };
-
-        template <typename... L, typename T>
-        struct count_<list<L...>, T>
-        {
-#ifdef META_WORKAROUND_LLVM_28385
-            static constexpr bool s_v[sizeof...(L)] = {META_IS_SAME(T, L)...};
-#else
-            static constexpr bool s_v[] = {META_IS_SAME(T, L)...};
-#endif
-            using type = meta::size_t<detail::count_i_(s_v, s_v + sizeof...(L), 0u)>;
-        };
-#endif
-    } // namespace detail
-
-    /// Count the number of times a type \p T appears in the list \p L.
-    /// \par Complexity
-    /// \f$ O(N) \f$.
-    /// \ingroup query
-    template <META_TYPE_CONSTRAINT(list_like) L, typename T>
-    using count = _t<detail::count_<L, T>>;
-
-    namespace lazy
-    {
-        /// \sa `meta::count`
-        /// \ingroup lazy_query
-        template <typename L, typename T>
-        using count = defer<count, L, T>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////
-    // count_if
-    namespace detail
-    {
-#if defined(META_CONCEPT) && META_CXX_FOLD_EXPRESSIONS
-        template <typename, typename>
-        struct count_if_
-        {
-        };
-
-        template <typename... Ts, typename Fn>
-        requires (integral<invoke<Fn, Ts>> && ...)
-        struct count_if_<list<Ts...>, Fn>
-        {
-            using type = meta::size_t<((std::size_t)(bool)_v<invoke<Fn, Ts>> + ...)>;
-        };
-#else
-        template <typename L, typename Fn, typename = void>
-        struct count_if_
-        {
-        };
-
-        template <typename Fn>
-        struct count_if_<list<>, Fn>
-        {
-            using type = meta::size_t<0>;
-        };
-
-        template <typename... L, typename Fn>
-        struct count_if_<list<L...>, Fn,
-                            void_<integer_sequence<bool, bool(invoke<Fn, L>::type::value)...>>>
-        {
-#if META_CXX_FOLD_EXPRESSIONS
-            using type = meta::size_t<((std::size_t)(bool)invoke<Fn, L>::type::value + ...)>;
-#else
-#ifdef META_WORKAROUND_LLVM_28385
-            static constexpr bool s_v[sizeof...(L)] = {invoke<Fn, L>::type::value...};
-#else
-            static constexpr bool s_v[] = {invoke<Fn, L>::type::value...};
-#endif
-            using type = meta::size_t<detail::count_i_(s_v, s_v + sizeof...(L), 0u)>;
-#endif  // META_CXX_FOLD_EXPRESSIONS
-        };
-#endif  // META_CONCEPT
-    } // namespace detail
-
-    /// Count the number of times the predicate \p Fn evaluates to true for all the elements in
-    /// the list \p L.
-    /// \par Complexity
-    /// \f$ O(N) \f$.
-    /// \ingroup query
-    template <META_TYPE_CONSTRAINT(list_like) L, META_TYPE_CONSTRAINT(invocable) Fn>
-    using count_if = _t<detail::count_if_<L, Fn>>;
-
-    namespace lazy
-    {
-        /// \sa `meta::count_if`
-        /// \ingroup lazy_query
-        template <typename L, typename Fn>
-        using count_if = defer<count_if, L, Fn>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // filter
-    /// \cond
-    namespace detail
-    {
-        template <typename Pred>
-        struct filter_
-        {
-            template <typename A>
-            using invoke = if_c<invoke<Pred, A>::type::value, list<A>, list<>>;
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// Returns a new meta::list where only those elements of \p L that satisfy the
-    /// Callable \p Pred such that `invoke<Pred,A>::%value` is \c true are present.
-    /// That is, those elements that don't satisfy the \p Pred are "removed".
-    /// \par Complexity
-    /// \f$ O(N) \f$.
-    /// \ingroup transformation
-    template <typename L, typename Pred>
-    using filter = join<transform<L, detail::filter_<Pred>>>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::filter'
-        /// \ingroup lazy_transformation
-        template <typename L, typename Fn>
-        using filter = defer<filter, L, Fn>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // static_const
-    ///\cond
-    namespace detail
-    {
-        template <typename T>
-        struct static_const
-        {
-            static constexpr T value{};
-        };
-
-        // Avoid potential ODR violations with global objects:
-        template <typename T>
-        constexpr T static_const<T>::value;
-    } // namespace detail
-
-    ///\endcond
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // for_each
-    /// \cond
-    namespace detail
-    {
-        struct for_each_fn
-        {
-            template <class Fn, class... Args>
-            constexpr auto operator()(list<Args...>, Fn f) const -> Fn
-            {
-                return (void)std::initializer_list<int>{((void)f(Args{}), 0)...}, f;
-            }
-        };
-    } // namespace detail
-    /// \endcond
-
-#if META_CXX_INLINE_VARIABLES
-    /// `for_each(L, Fn)` calls the \p Fn for each
-    /// argument in the \p L.
-    /// \ingroup runtime
-    inline constexpr detail::for_each_fn for_each{};
-#else
-    ///\cond
-    namespace
-    {
-        /// \endcond
-
-        /// `for_each(List, UnaryFunction)` calls the \p UnaryFunction for each
-        /// argument in the \p List.
-        /// \ingroup runtime
-        constexpr auto &&for_each = detail::static_const<detail::for_each_fn>::value;
-
-        /// \cond
-    }
-    /// \endcond
-#endif
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // transpose
-    /// Given a list of lists of types \p ListOfLists, transpose the elements from the lists.
-    /// \par Complexity
-    /// \f$ O(N \times M) \f$, where \f$ N \f$ is the size of the outer list, and
-    /// \f$ M \f$ is the size of the inner lists.
-    /// \ingroup transformation
-    template <META_TYPE_CONSTRAINT(list_like) ListOfLists>
-    using transpose = fold<ListOfLists, repeat_n<size<front<ListOfLists>>, list<>>,
-                            bind_back<quote<transform>, quote<push_back>>>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::transpose'
-        /// \ingroup lazy_transformation
-        template <typename ListOfLists>
-        using transpose = defer<transpose, ListOfLists>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // zip_with
-    /// Given a list of lists of types \p ListOfLists and an invocable \p Fn, construct a new
-    /// list by calling \p Fn with the elements from the lists pairwise.
-    /// \par Complexity
-    /// \f$ O(N \times M) \f$, where \f$ N \f$ is the size of the outer list, and
-    /// \f$ M \f$ is the size of the inner lists.
-    /// \ingroup transformation
-    template <META_TYPE_CONSTRAINT(invocable) Fn, META_TYPE_CONSTRAINT(list_like) ListOfLists>
-    using zip_with = transform<transpose<ListOfLists>, uncurry<Fn>>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::zip_with'
-        /// \ingroup lazy_transformation
-        template <typename Fn, typename ListOfLists>
-        using zip_with = defer<zip_with, Fn, ListOfLists>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // zip
-    /// Given a list of lists of types \p ListOfLists, construct a new list by grouping the
-    /// elements from the lists pairwise into `meta::list`s.
-    /// \par Complexity
-    /// \f$ O(N \times M) \f$, where \f$ N \f$ is the size of the outer list, and \f$ M \f$
-    /// is the size of the inner lists.
-    /// \ingroup transformation
-    template <META_TYPE_CONSTRAINT(list_like) ListOfLists>
-    using zip = transpose<ListOfLists>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::zip'
-        /// \ingroup lazy_transformation
-        template <typename ListOfLists>
-        using zip = defer<zip, ListOfLists>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // as_list
-    /// \cond
-    namespace detail
-    {
-        template <typename T>
-        using uncvref_t = _t<std::remove_cv<_t<std::remove_reference<T>>>>;
-
-        // Indirection here needed to avoid Core issue 1430
-        // https://wg21.link/cwg1430
-        template <typename Sequence>
-        struct as_list_ : lazy::invoke<uncurry<quote<list>>, Sequence>
-        {
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// Turn a type into an instance of \c meta::list in a way determined by
-    /// \c meta::apply.
-    /// \ingroup list
-    template <typename Sequence>
-    using as_list = _t<detail::as_list_<detail::uncvref_t<Sequence>>>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::as_list'
-        /// \ingroup lazy_list
-        template <typename Sequence>
-        using as_list = defer<as_list, Sequence>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // reverse
-    /// \cond
-    namespace detail
-    {
-        template <typename L, typename State = list<>>
-        struct reverse_ : lazy::fold<L, State, quote<push_front>>
-        {
-        };
-
-        template <typename T0, typename T1, typename T2, typename T3, typename T4, typename T5,
-                    typename T6, typename T7, typename T8, typename T9, typename... Ts,
-                    typename... Us>
-        struct reverse_<list<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, Ts...>, list<Us...>>
-          : reverse_<list<Ts...>, list<T9, T8, T7, T6, T5, T4, T3, T2, T1, T0, Us...>>
-        {
-        };
-    }
-    /// \endcond
-
-    /// Return a new \c meta::list by reversing the elements in the list \p L.
-    /// \par Complexity
-    /// \f$ O(N) \f$.
-    /// \ingroup transformation
-    template <META_TYPE_CONSTRAINT(list_like) L>
-    using reverse = _t<detail::reverse_<L>>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::reverse'
-        /// \ingroup lazy_transformation
-        template <typename L>
-        using reverse = defer<reverse, L>;
-    } // namespace lazy
-
-    /// Logically negate the result of invocable \p Fn.
-    /// \ingroup trait
-    template <META_TYPE_CONSTRAINT(invocable) Fn>
-    using not_fn = compose<quote<not_>, Fn>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::not_fn'
-        /// \ingroup lazy_trait
-        template <typename Fn>
-        using not_fn = defer<not_fn, Fn>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // all_of
-    /// A Boolean integral constant wrapper around \c true if `invoke<Fn, A>::%value` is \c true
-    /// for all elements \c A in \c meta::list \p L; \c false, otherwise.
-    /// \par Complexity
-    /// \f$ O(N) \f$.
-    /// \ingroup query
-    template <META_TYPE_CONSTRAINT(list_like) L, META_TYPE_CONSTRAINT(invocable) Fn>
-    using all_of = empty<find_if<L, not_fn<Fn>>>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::all_of'
-        /// \ingroup lazy_query
-        template <typename L, typename Fn>
-        using all_of = defer<all_of, L, Fn>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // any_of
-    /// A Boolean integral constant wrapper around \c true if `invoke<Fn, A>::%value` is
-    /// \c true for any element \c A in \c meta::list \p L; \c false, otherwise.
-    /// \par Complexity
-    /// \f$ O(N) \f$.
-    /// \ingroup query
-    template <META_TYPE_CONSTRAINT(list_like) L, META_TYPE_CONSTRAINT(invocable) Fn>
-    using any_of = not_<empty<find_if<L, Fn>>>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::any_of'
-        /// \ingroup lazy_query
-        template <typename L, typename Fn>
-        using any_of = defer<any_of, L, Fn>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // none_of
-    /// A Boolean integral constant wrapper around \c true if `invoke<Fn, A>::%value` is
-    /// \c false for all elements \c A in \c meta::list \p L; \c false, otherwise.
-    /// \par Complexity
-    /// \f$ O(N) \f$.
-    /// \ingroup query
-    template <META_TYPE_CONSTRAINT(list_like) L, META_TYPE_CONSTRAINT(invocable) Fn>
-    using none_of = empty<find_if<L, Fn>>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::none_of'
-        /// \ingroup lazy_query
-        template <typename L, META_TYPE_CONSTRAINT(invocable) Fn>
-        using none_of = defer<none_of, L, Fn>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // in
-    /// A Boolean integral constant wrapper around \c true if there is at least one occurrence
-    /// of \p T in \p L.
-    /// \par Complexity
-    /// \f$ O(N) \f$.
-    /// \ingroup query
-    template <META_TYPE_CONSTRAINT(list_like) L, typename T>
-    using in = not_<empty<find<L, T>>>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::in'
-        /// \ingroup lazy_query
-        template <typename L, typename T>
-        using in = defer<in, L, T>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // inherit
-    /// \cond
-    namespace detail
-    {
-        template <typename L>
-        struct inherit_
-        {
-        };
-
-        template <typename... L>
-        struct inherit_<list<L...>> : L...
-        {
-            using type = inherit_;
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// A type that inherits from all the types in the list
-    /// \pre The types in the list must be unique
-    /// \pre All the types in the list must be non-final class types
-    /// \ingroup datatype
-    template <META_TYPE_CONSTRAINT(list_like) L>
-    using inherit = meta::_t<detail::inherit_<L>>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::inherit'
-        /// \ingroup lazy_datatype
-        template <typename L>
-        using inherit = defer<inherit, L>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // unique
-    /// \cond
-    namespace detail
-    {
-        template <typename Set, typename T>
-        struct in_
-        {
-        };
-
-        template <typename... Set, typename T>
-        struct in_<list<Set...>, T> : bool_<META_IS_BASE_OF(id<T>, inherit<list<id<Set>...>>)>
-        {
-        };
-
-        template <typename Set, typename T>
-        struct insert_back_
-        {
-        };
-
-        template <typename... Set, typename T>
-        struct insert_back_<list<Set...>, T>
-        {
-            using type = if_<in_<list<Set...>, T>, list<Set...>, list<Set..., T>>;
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// Return a new \c meta::list where all duplicate elements have been removed.
-    /// \par Complexity
-    /// \f$ O(N^2) \f$.
-    /// \ingroup transformation
-    template <META_TYPE_CONSTRAINT(list_like) L>
-    using unique = fold<L, list<>, quote_trait<detail::insert_back_>>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::unique'
-        /// \ingroup lazy_transformation
-        template <typename L>
-        using unique = defer<unique, L>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // partition
-    /// \cond
-    namespace detail
-    {
-        template <typename Fn>
-        struct partition_
-        {
-#ifdef META_CONCEPT
-            template <typename, typename>
-#else
-            template <typename, typename, typename = void>
-#endif
-            struct impl
-            {
-            };
-            template <typename... Yes, typename... No, typename A>
-#ifdef META_CONCEPT
-            requires integral<invoke<Fn, A>>
-            struct impl<pair<list<Yes...>, list<No...>>, A>
-#else
-            struct impl<pair<list<Yes...>, list<No...>>, A,
-                        void_<bool_<invoke<Fn, A>::type::value>>>
-#endif
-            {
-                using type = if_<invoke<Fn, A>, pair<list<Yes..., A>, list<No...>>,
-                                    pair<list<Yes...>, list<No..., A>>>;
-            };
-
-            template <typename State, typename A>
-            using invoke = _t<impl<State, A>>;
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// Returns a pair of lists, where the elements of \p L that satisfy the
-    /// invocable \p Fn such that `invoke<Fn,A>::%value` is \c true are present in the
-    /// first list and the rest are in the second.
-    /// \par Complexity
-    /// \f$ O(N) \f$.
-    /// \ingroup transformation
-    template <META_TYPE_CONSTRAINT(list_like) L, META_TYPE_CONSTRAINT(invocable) Fn>
-    using partition = fold<L, pair<list<>, list<>>, detail::partition_<Fn>>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::partition'
-        /// \ingroup lazy_transformation
-        template <typename L, typename Fn>
-        using partition = defer<partition, L, Fn>;
-    } // namespace lazy
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // sort
-    /// \cond
-    namespace detail
-    {
-        template <META_TYPE_CONSTRAINT(invocable) Fn, typename A, typename B, typename... Ts>
-        using part_ = partition<list<B, Ts...>, bind_back<Fn, A>>;
-#ifdef META_CONCEPT
-        template <list_like L, invocable Fn>
-#else
-        template <typename, typename, typename = void>
-#endif
-        struct sort_
-        {
-        };
-        template <typename Fn>
-        struct sort_<list<>, Fn>
-        {
-            using type = list<>;
-        };
-
-        template <typename A, typename Fn>
-        struct sort_<list<A>, Fn>
-        {
-            using type = list<A>;
-        };
-
-        template <typename A, typename B, typename... Ts, typename Fn>
-#ifdef META_CONCEPT
-        requires trait<sort_<first<part_<Fn, A, B, Ts...>>, Fn>> &&
-            trait<sort_<second<part_<Fn, A, B, Ts...>>, Fn>>
-        struct sort_<list<A, B, Ts...>, Fn>
-#else
-        struct sort_<
-            list<A, B, Ts...>, Fn,
-            void_<_t<sort_<first<part_<Fn, A, B, Ts...>>, Fn>>>>
-#endif
-        {
-            using P = part_<Fn, A, B, Ts...>;
-            using type = concat<_t<sort_<first<P>, Fn>>, list<A>, _t<sort_<second<P>, Fn>>>;
-        };
-    } // namespace detail
-    /// \endcond
-
-    // clang-format off
-    /// Return a new \c meta::list that is sorted according to invocable predicate \p Fn.
-    /// \par Complexity
-    /// Expected: \f$ O(N log N) \f$
-    /// Worst case: \f$ O(N^2) \f$.
-    /// \code
-    /// using L0 = list<char[5], char[3], char[2], char[6], char[1], char[5], char[10]>;
-    /// using L1 = meta::sort<L0, lambda<_a, _b, lazy::less<lazy::sizeof_<_a>, lazy::sizeof_<_b>>>>;
-    /// static_assert(std::is_same_v<L1, list<char[1], char[2], char[3], char[5], char[5], char[6], char[10]>>, "");
-    /// \endcode
-    /// \ingroup transformation
-    // clang-format on
-    template <META_TYPE_CONSTRAINT(list_like) L, META_TYPE_CONSTRAINT(invocable) Fn>
-    using sort = _t<detail::sort_<L, Fn>>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::sort'
-        /// \ingroup lazy_transformation
-        template <typename L, typename Fn>
-        using sort = defer<sort, L, Fn>;
-    } // namespace lazy
-
-    ////////////////////////////////////////////////////////////////////////////
-    // lambda_
-    /// \cond
-    namespace detail
-    {
-        template <typename T, int = 0>
-        struct protect_;
-
-        template <typename, int = 0>
-        struct vararg_;
-
-        template <typename T, int = 0>
-        struct is_valid_;
-
-        // Returns which branch to evaluate
-        template <typename If, typename... Ts>
-#ifdef META_CONCEPT
-        using lazy_if_ = lazy::_t<defer<_if_, If, protect_<Ts>...>>;
-#else
-        using lazy_if_ = lazy::_t<defer<_if_, list<If, protect_<Ts>...>>>;
-#endif
-
-        template <typename A, typename T, typename Fn, typename Ts>
-        struct subst1_
-        {
-            using type = list<list<T>>;
-        };
-        template <typename T, typename Fn, typename Ts>
-        struct subst1_<Fn, T, Fn, Ts>
-        {
-            using type = list<>;
-        };
-        template <typename A, typename T, typename Fn, typename Ts>
-        struct subst1_<vararg_<A>, T, Fn, Ts>
-        {
-            using type = list<Ts>;
-        };
-
-        template <typename As, typename Ts>
-        using substitutions_ = push_back<
-            join<transform<
-                concat<As, repeat_n_c<size<Ts>{} + 2 - size<As>{}, back<As>>>,
-                concat<Ts, repeat_n_c<2, back<As>>>,
-                bind_back<quote_trait<subst1_>, back<As>, drop_c<Ts, size<As>{} - 2>>>>,
-            list<back<As>>>;
-
-#if 0//def META_CONCEPT
-        template <list_like As, list_like Ts>
-        requires (_v<size<Ts>> + 2 >= _v<size<As>>)
-        using substitutions = substitutions_<As, Ts>;
-#else // ^^^ concepts / no concepts vvv
-        template <typename As, typename Ts>
-        using substitutions =
-#ifdef META_WORKAROUND_MSVC_702792
-            invoke<if_c<(size<Ts>::value + 2 >= size<As>::value), quote<substitutions_>>, As,
-                    Ts>;
-#else // ^^^ workaround ^^^ / vvv no workaround vvv
-            invoke<if_c<(size<Ts>{} + 2 >= size<As>{}), quote<substitutions_>>, As, Ts>;
-#endif // META_WORKAROUND_MSVC_702792
-#endif // META_CONCEPT
-
-        template <typename T>
-        struct is_vararg_ : std::false_type
-        {
-        };
-        template <typename T>
-        struct is_vararg_<vararg_<T>> : std::true_type
-        {
-        };
-
-        template <META_TYPE_CONSTRAINT(list_like) Tags>
-        using is_variadic_ = is_vararg_<at<push_front<Tags, void>, dec<size<Tags>>>>;
-
-        template <META_TYPE_CONSTRAINT(list_like) Tags, bool IsVariadic = is_variadic_<Tags>::value>
-        struct lambda_;
-
-        // Non-variadic lambda implementation
-        template <typename... As>
-        struct lambda_<list<As...>, false>
-        {
-        private:
-            static constexpr std::size_t arity = sizeof...(As) - 1;
-            using Tags = list<As...>; // Includes the lambda body as the last arg!
-            using Fn = back<Tags>;
-            template <typename T, META_TYPE_CONSTRAINT(list_like) Args>
-            struct impl;
-            template <typename T, META_TYPE_CONSTRAINT(list_like) Args>
-            using lazy_impl_ = lazy::_t<defer<impl, T, protect_<Args>>>;
-#if 0//def META_CONCEPT
-            template <typename, list_like>
-#else
-            template <typename, typename, typename = void>
-#endif
-            struct subst_
-            {
-            };
-            template <template <typename...> class C, typename... Ts, typename Args>
-#if 0//def META_CONCEPT
-            requires valid<C, _t<impl<Ts, Args>>...> struct subst_<defer<C, Ts...>, Args>
-#else
-            struct subst_<defer<C, Ts...>, Args, void_<C<_t<impl<Ts, Args>>...>>>
-#endif
-            {
-                using type = C<_t<impl<Ts, Args>>...>;
-            };
-            template <typename T, template <T...> class C, T... Is, typename Args>
-#if 0//def META_CONCEPT
-            requires valid_i<T, C, Is...> struct subst_<defer_i<T, C, Is...>, Args>
-#else
-            struct subst_<defer_i<T, C, Is...>, Args, void_<C<Is...>>>
-#endif
-            {
-                using type = C<Is...>;
-            };
-            template <typename T, META_TYPE_CONSTRAINT(list_like) Args>
-            struct impl : if_c<(reverse_find_index<Tags, T>() != npos()),
-                                lazy::at<Args, reverse_find_index<Tags, T>>, id<T>>
-            {
-            };
-            template <typename T, typename Args>
-            struct impl<protect_<T>, Args>
-            {
-                using type = T;
-            };
-            template <typename T, typename Args>
-            struct impl<is_valid_<T>, Args>
-            {
-                using type = is_trait<impl<T, Args>>;
-            };
-            template <typename If, typename... Ts, typename Args>
-            struct impl<defer<if_, If, Ts...>, Args> // Short-circuit if_
-              : impl<lazy_impl_<lazy_if_<If, Ts...>, Args>, Args>
-            {
-            };
-            template <typename B, typename... Bs, typename Args>
-            struct impl<defer<and_, B, Bs...>, Args> // Short-circuit and_
-              : impl<lazy_impl_<lazy_if_<B, lazy::and_<Bs...>, protect_<std::false_type>>, Args>,
-                     Args>
-            {
-            };
-            template <typename B, typename... Bs, typename Args>
-            struct impl<defer<or_, B, Bs...>, Args> // Short-circuit or_
-              : impl<lazy_impl_<lazy_if_<B, protect_<std::true_type>, lazy::or_<Bs...>>, Args>,
-                     Args>
-            {
-            };
-            template <template <typename...> class C, typename... Ts, typename Args>
-            struct impl<defer<C, Ts...>, Args> : subst_<defer<C, Ts...>, Args>
-            {
-            };
-            template <typename T, template <T...> class C, T... Is, typename Args>
-            struct impl<defer_i<T, C, Is...>, Args> : subst_<defer_i<T, C, Is...>, Args>
-            {
-            };
-            template <template <typename...> class C, typename... Ts, typename Args>
-            struct impl<C<Ts...>, Args> : subst_<defer<C, Ts...>, Args>
-            {
-            };
-            template <typename... Ts, typename Args>
-            struct impl<lambda_<list<Ts...>, false>, Args>
-            {
-                using type = compose<uncurry<lambda_<list<As..., Ts...>, false>>,
-                                        curry<bind_front<quote<concat>, Args>>>;
-            };
-            template <typename... Bs, typename Args>
-            struct impl<lambda_<list<Bs...>, true>, Args>
-            {
-                using type = compose<typename lambda_<list<As..., Bs...>, true>::thunk,
-                                        bind_front<quote<concat>, transform<Args, quote<list>>>,
-                                        curry<bind_front<quote<substitutions>, list<Bs...>>>>;
-            };
-
-        public:
-            template <typename... Ts>
-#ifdef META_CONCEPT
-                requires (sizeof...(Ts) == arity) using invoke = _t<impl<Fn, list<Ts..., Fn>>>;
-#else
-            using invoke = _t<if_c<sizeof...(Ts) == arity, impl<Fn, list<Ts..., Fn>>>>;
-#endif
-        };
-
-        // Lambda with variadic placeholder (broken out due to less efficient compile-time
-        // resource usage)
-        template <typename... As>
-        struct lambda_<list<As...>, true>
-        {
-        private:
-            template <META_TYPE_CONSTRAINT(list_like) T, bool IsVar>
-            friend struct lambda_;
-            using Tags = list<As...>; // Includes the lambda body as the last arg!
-            template <typename T, META_TYPE_CONSTRAINT(list_like) Args>
-            struct impl;
-            template <META_TYPE_CONSTRAINT(list_like) Args>
-            using eval_impl_ = bind_back<quote_trait<impl>, Args>;
-            template <typename T, META_TYPE_CONSTRAINT(list_like) Args>
-            using lazy_impl_ = lazy::_t<defer<impl, T, protect_<Args>>>;
-            template <template <typename...> class C, META_TYPE_CONSTRAINT(list_like) Args,
-                        META_TYPE_CONSTRAINT(list_like) Ts>
-            using try_subst_ = apply<quote<C>, join<transform<Ts, eval_impl_<Args>>>>;
-#if 0//def META_CONCEPT
-            template <typename, list_like>
-#else
-            template <typename, typename, typename = void>
-#endif
-            struct subst_
-            {
-            };
-            template <template <typename...> class C, typename... Ts, typename Args>
-#if 0//def META_CONCEPT
-            requires is_true<try_subst_<C, Args, list<Ts...>>> struct subst_<defer<C, Ts...>, Args>
-#else
-            struct subst_<defer<C, Ts...>, Args, void_<try_subst_<C, Args, list<Ts...>>>>
-#endif
-            {
-                using type = list<try_subst_<C, Args, list<Ts...>>>;
-            };
-            template <typename T, template <T...> class C, T... Is, typename Args>
-#if 0//def META_CONCEPT
-            requires valid_i<T, C, Is...> struct subst_<defer_i<T, C, Is...>, Args>
-#else
-            struct subst_<defer_i<T, C, Is...>, Args, void_<C<Is...>>>
-#endif
-            {
-                using type = list<C<Is...>>;
-            };
-            template <typename T, META_TYPE_CONSTRAINT(list_like) Args>
-            struct impl : if_c<(reverse_find_index<Tags, T>() != npos()),
-                                lazy::at<Args, reverse_find_index<Tags, T>>, id<list<T>>>
-            {
-            };
-            template <typename T, typename Args>
-            struct impl<protect_<T>, Args>
-            {
-                using type = list<T>;
-            };
-            template <typename T, typename Args>
-            struct impl<is_valid_<T>, Args>
-            {
-                using type = list<is_trait<impl<T, Args>>>;
-            };
-            template <typename If, typename... Ts, typename Args>
-            struct impl<defer<if_, If, Ts...>, Args> // Short-circuit if_
-              : impl<lazy_impl_<lazy_if_<If, Ts...>, Args>, Args>
-            {
-            };
-            template <typename B, typename... Bs, typename Args>
-            struct impl<defer<and_, B, Bs...>, Args> // Short-circuit and_
-              : impl<lazy_impl_<lazy_if_<B, lazy::and_<Bs...>, protect_<std::false_type>>, Args>,
-                     Args>
-            {
-            };
-            template <typename B, typename... Bs, typename Args>
-            struct impl<defer<or_, B, Bs...>, Args> // Short-circuit or_
-              : impl<lazy_impl_<lazy_if_<B, protect_<std::true_type>, lazy::or_<Bs...>>, Args>,
-                     Args>
-            {
-            };
-            template <template <typename...> class C, typename... Ts, typename Args>
-            struct impl<defer<C, Ts...>, Args> : subst_<defer<C, Ts...>, Args>
-            {
-            };
-            template <typename T, template <T...> class C, T... Is, typename Args>
-            struct impl<defer_i<T, C, Is...>, Args> : subst_<defer_i<T, C, Is...>, Args>
-            {
-            };
-            template <template <typename...> class C, typename... Ts, typename Args>
-            struct impl<C<Ts...>, Args> : subst_<defer<C, Ts...>, Args>
-            {
-            };
-            template <typename... Bs, bool IsVar, typename Args>
-            struct impl<lambda_<list<Bs...>, IsVar>, Args>
-            {
-                using type =
-                    list<compose<typename lambda_<list<As..., Bs...>, true>::thunk,
-                                    bind_front<quote<concat>, Args>,
-                                    curry<bind_front<quote<substitutions>, list<Bs...>>>>>;
-            };
-            struct thunk
-            {
-                template <typename S, typename R = _t<impl<back<Tags>, S>>>
-#ifdef META_CONCEPT
-                    requires (_v<size<R>> == 1) using invoke = front<R>;
-#else
-                using invoke = if_c<size<R>{} == 1, front<R>>;
-#endif
-            };
-
-        public:
-            template <typename... Ts>
-            using invoke = invoke<thunk, substitutions<Tags, list<Ts...>>>;
-        };
-    } // namespace detail
-    /// \endcond
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // lambda
-    /// For creating anonymous Invocables.
-    /// \code
-    /// using L = lambda<_a, _b, std::pair<_b, std::pair<_a, _a>>>;
-    /// using P = invoke<L, int, short>;
-    /// static_assert(std::is_same_v<P, std::pair<short, std::pair<int, int>>>, "");
-    /// \endcode
-    /// \ingroup trait
-    template <typename... Ts>
-#ifdef META_CONCEPT
-        requires (sizeof...(Ts) > 0) using lambda = detail::lambda_<list<Ts...>>;
-#else
-    using lambda = if_c<(sizeof...(Ts) > 0), detail::lambda_<list<Ts...>>>;
-#endif
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // is_valid
-    /// For testing whether a deferred computation will succeed in a \c let or a \c lambda.
-    /// \ingroup trait
-    template <typename T>
-    using is_valid = detail::is_valid_<T>;
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // vararg
-    /// For defining variadic placeholders.
-    template <typename T>
-    using vararg = detail::vararg_<T>;
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // protect
-    /// For preventing the evaluation of a nested `defer`ed computation in a \c let or
-    /// \c lambda expression.
-    template <typename T>
-    using protect = detail::protect_<T>;
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // var
-    /// For use when defining local variables in \c meta::let expressions
-    /// \sa `meta::let`
-    template <typename Tag, typename Value>
-    struct var;
-
-    /// \cond
-    namespace detail
-    {
-        template <typename...>
-        struct let_
-        {
-        };
-        template <typename Fn>
-        struct let_<Fn>
-        {
-            using type = lazy::invoke<lambda<Fn>>;
-        };
-        template <typename Tag, typename Value, typename... Rest>
-        struct let_<var<Tag, Value>, Rest...>
-        {
-            using type = lazy::invoke<lambda<Tag, _t<let_<Rest...>>>, Value>;
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// A lexically scoped expression with local variables.
-    ///
-    /// \code
-    /// template <typename T, typename L>
-    /// using find_index_ = let<
-    ///     var<_a, L>,
-    ///     var<_b, lazy::find<_a, T>>,
-    ///     lazy::if_<
-    ///         std::is_same<_b, list<>>,
-    ///         meta::npos,
-    ///         lazy::minus<lazy::size<_a>, lazy::size<_b>>>>;
-    /// static_assert(find_index_<int, list<short, int, float>>{} == 1, "");
-    /// static_assert(find_index_<double, list<short, int, float>>{} == meta::npos{}, "");
-    /// \endcode
-    /// \ingroup trait
-    template <typename... As>
-    using let = _t<_t<detail::let_<As...>>>;
-
-    namespace lazy
-    {
-        /// \sa `meta::let`
-        /// \ingroup lazy_trait
-        template <typename... As>
-        using let = defer<let, As...>;
-    } // namespace lazy
-
-    // Some argument placeholders for use in \c lambda expressions.
-    /// \ingroup trait
-    inline namespace placeholders
-    {
-        // regular placeholders:
-        struct _a;
-        struct _b;
-        struct _c;
-        struct _d;
-        struct _e;
-        struct _f;
-        struct _g;
-        struct _h;
-        struct _i;
-
-        // variadic placeholders:
-        using _args = vararg<void>;
-        using _args_a = vararg<_a>;
-        using _args_b = vararg<_b>;
-        using _args_c = vararg<_c>;
-    } // namespace placeholders
-
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // cartesian_product
-    /// \cond
-    namespace detail
-    {
-        template <typename M2, typename M>
-        struct cartesian_product_fn
-        {
-            template <typename X>
-            struct lambda0
-            {
-                template <typename Xs>
-                using lambda1 = list<push_front<Xs, X>>;
-                using type = join<transform<M2, quote<lambda1>>>;
-            };
-            using type = join<transform<M, quote_trait<lambda0>>>;
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// Given a list of lists \p ListOfLists, return a new list of lists that is the Cartesian
-    /// Product. Like the `sequence` function from the Haskell Prelude.
-    /// \par Complexity
-    /// \f$ O(N \times M) \f$, where \f$ N \f$ is the size of the outer list, and
-    /// \f$ M \f$ is the size of the inner lists.
-    /// \ingroup transformation
-    template <META_TYPE_CONSTRAINT(list_like) ListOfLists>
-    using cartesian_product =
-        reverse_fold<ListOfLists, list<list<>>, quote_trait<detail::cartesian_product_fn>>;
-
-    namespace lazy
-    {
-        /// \sa 'meta::cartesian_product'
-        /// \ingroup lazy_transformation
-        template <typename ListOfLists>
-        using cartesian_product = defer<cartesian_product, ListOfLists>;
-    } // namespace lazy
-
-    /// \cond
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // add_const_if
-    namespace detail
-    {
-        template <bool>
-        struct add_const_if
-        {
-            template <typename T>
-            using invoke = T const;
-        };
-        template <>
-        struct add_const_if<false>
-        {
-            template <typename T>
-            using invoke = T;
-        };
-    } // namespace detail
-    template <bool If>
-    using add_const_if_c = detail::add_const_if<If>;
-    template <META_TYPE_CONSTRAINT(integral) If>
-    using add_const_if = add_const_if_c<If::type::value>;
-    /// \endcond
-
-    /// \cond
-    ///////////////////////////////////////////////////////////////////////////////////////////
-    // const_if
-    template <bool If, typename T>
-    using const_if_c = typename add_const_if_c<If>::template invoke<T>;
-    template <typename If, typename T>
-    using const_if = typename add_const_if<If>::template invoke<T>;
-    /// \endcond
-
-    /// \cond
-    namespace detail
-    {
-        template <typename State, typename Ch>
-        using atoi_ = if_c<(Ch::value >= '0' && Ch::value <= '9'),
-                            std::integral_constant<typename State::value_type,
-                                                    State::value * 10 + (Ch::value - '0')>>;
-    }
-    /// \endcond
-
-    inline namespace literals
-    {
-        /// A user-defined literal that generates objects of type \c meta::size_t.
-        /// \ingroup integral
-        template <char... Chs>
-        constexpr fold<list<char_<Chs>...>, meta::size_t<0>, quote<detail::atoi_>>
-            operator"" _z()
-        {
-            return {};
-        }
-    } // namespace literals
-} // namespace meta
-
-/// \cond
-// Non-portable forward declarations of standard containers
-#ifndef META_NO_STD_FORWARD_DECLARATIONS
-#if defined(__apple_build_version__) || (defined(__clang__) && __clang_major__ < 6)
-META_BEGIN_NAMESPACE_STD
-META_BEGIN_NAMESPACE_VERSION
-template <class>
-class META_TEMPLATE_VIS allocator;
-template <class, class>
-struct META_TEMPLATE_VIS pair;
-template <class>
-struct META_TEMPLATE_VIS hash;
-template <class>
-struct META_TEMPLATE_VIS less;
-template <class>
-struct META_TEMPLATE_VIS equal_to;
-template <class>
-struct META_TEMPLATE_VIS char_traits;
-#if defined(_GLIBCXX_USE_CXX11_ABI) && _GLIBCXX_USE_CXX11_ABI
-inline namespace __cxx11 {
-#endif
-template <class, class, class>
-class META_TEMPLATE_VIS basic_string;
-#if defined(_GLIBCXX_USE_CXX11_ABI) && _GLIBCXX_USE_CXX11_ABI
-}
-#endif
-META_END_NAMESPACE_VERSION
-META_BEGIN_NAMESPACE_CONTAINER
-#if defined(__GLIBCXX__)
-inline namespace __cxx11 {
-#endif
-template <class, class>
-class META_TEMPLATE_VIS list;
-#if defined(__GLIBCXX__)
-}
-#endif
-template <class, class>
-class META_TEMPLATE_VIS forward_list;
-template <class, class>
-class META_TEMPLATE_VIS vector;
-template <class, class>
-class META_TEMPLATE_VIS deque;
-template <class, class, class, class>
-class META_TEMPLATE_VIS map;
-template <class, class, class, class>
-class META_TEMPLATE_VIS multimap;
-template <class, class, class>
-class META_TEMPLATE_VIS set;
-template <class, class, class>
-class META_TEMPLATE_VIS multiset;
-template <class, class, class, class, class>
-class META_TEMPLATE_VIS unordered_map;
-template <class, class, class, class, class>
-class META_TEMPLATE_VIS unordered_multimap;
-template <class, class, class, class>
-class META_TEMPLATE_VIS unordered_set;
-template <class, class, class, class>
-class META_TEMPLATE_VIS unordered_multiset;
-template <class, class>
-class META_TEMPLATE_VIS queue;
-template <class, class, class>
-class META_TEMPLATE_VIS priority_queue;
-template <class, class>
-class META_TEMPLATE_VIS stack;
-META_END_NAMESPACE_CONTAINER
-META_END_NAMESPACE_STD
-
-namespace meta
-{
-    namespace detail
-    {
-        template <typename T, typename A = std::allocator<T>>
-        using std_list = std::list<T, A>;
-        template <typename T, typename A = std::allocator<T>>
-        using std_forward_list = std::forward_list<T, A>;
-        template <typename T, typename A = std::allocator<T>>
-        using std_vector = std::vector<T, A>;
-        template <typename T, typename A = std::allocator<T>>
-        using std_deque = std::deque<T, A>;
-        template <typename T, typename C = std::char_traits<T>, typename A = std::allocator<T>>
-        using std_basic_string = std::basic_string<T, C, A>;
-        template <typename K, typename V, typename C = std::less<K>,
-                    typename A = std::allocator<std::pair<K const, V>>>
-        using std_map = std::map<K, V, C, A>;
-        template <typename K, typename V, typename C = std::less<K>,
-                    typename A = std::allocator<std::pair<K const, V>>>
-        using std_multimap = std::multimap<K, V, C, A>;
-        template <typename K, typename C = std::less<K>, typename A = std::allocator<K>>
-        using std_set = std::set<K, C, A>;
-        template <typename K, typename C = std::less<K>, typename A = std::allocator<K>>
-        using std_multiset = std::multiset<K, C, A>;
-        template <typename K, typename V, typename H = std::hash<K>,
-                    typename C = std::equal_to<K>,
-                    typename A = std::allocator<std::pair<K const, V>>>
-        using std_unordered_map = std::unordered_map<K, V, H, C, A>;
-        template <typename K, typename V, typename H = std::hash<K>,
-                    typename C = std::equal_to<K>,
-                    typename A = std::allocator<std::pair<K const, V>>>
-        using std_unordered_multimap = std::unordered_multimap<K, V, H, C, A>;
-        template <typename K, typename H = std::hash<K>, typename C = std::equal_to<K>,
-                    typename A = std::allocator<K>>
-        using std_unordered_set = std::unordered_set<K, H, C, A>;
-        template <typename K, typename H = std::hash<K>, typename C = std::equal_to<K>,
-                    typename A = std::allocator<K>>
-        using std_unordered_multiset = std::unordered_multiset<K, H, C, A>;
-        template <typename T, typename C = std_deque<T>>
-        using std_queue = std::queue<T, C>;
-        template <typename T, typename C = std_vector<T>,
-                    class D = std::less<typename C::value_type>>
-        using std_priority_queue = std::priority_queue<T, C, D>;
-        template <typename T, typename C = std_deque<T>>
-        using std_stack = std::stack<T, C>;
-    } // namespace detail
-
-    template <>
-    struct quote<::std::list> : quote<detail::std_list>
-    {
-    };
-    template <>
-    struct quote<::std::deque> : quote<detail::std_deque>
-    {
-    };
-    template <>
-    struct quote<::std::forward_list> : quote<detail::std_forward_list>
-    {
-    };
-    template <>
-    struct quote<::std::vector> : quote<detail::std_vector>
-    {
-    };
-    template <>
-    struct quote<::std::basic_string> : quote<detail::std_basic_string>
-    {
-    };
-    template <>
-    struct quote<::std::map> : quote<detail::std_map>
-    {
-    };
-    template <>
-    struct quote<::std::multimap> : quote<detail::std_multimap>
-    {
-    };
-    template <>
-    struct quote<::std::set> : quote<detail::std_set>
-    {
-    };
-    template <>
-    struct quote<::std::multiset> : quote<detail::std_multiset>
-    {
-    };
-    template <>
-    struct quote<::std::unordered_map> : quote<detail::std_unordered_map>
-    {
-    };
-    template <>
-    struct quote<::std::unordered_multimap> : quote<detail::std_unordered_multimap>
-    {
-    };
-    template <>
-    struct quote<::std::unordered_set> : quote<detail::std_unordered_set>
-    {
-    };
-    template <>
-    struct quote<::std::unordered_multiset> : quote<detail::std_unordered_multiset>
-    {
-    };
-    template <>
-    struct quote<::std::queue> : quote<detail::std_queue>
-    {
-    };
-    template <>
-    struct quote<::std::priority_queue> : quote<detail::std_priority_queue>
-    {
-    };
-    template <>
-    struct quote<::std::stack> : quote<detail::std_stack>
-    {
-    };
-} // namespace meta
-
-#endif
-#endif
-/// \endcond
-
-#ifdef __clang__
-#pragma GCC diagnostic pop
-#endif
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/meta/meta_fwd.hpp b/src/contrib/range-v3-0.11.0/include/meta/meta_fwd.hpp
deleted file mode 100644
index f374db07..00000000
--- a/src/contrib/range-v3-0.11.0/include/meta/meta_fwd.hpp
+++ /dev/null
@@ -1,359 +0,0 @@
-/// \file meta_fwd.hpp Forward declarations
-//
-// Meta library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/meta
-//
-
-#ifndef META_FWD_HPP
-#define META_FWD_HPP
-
-#include <type_traits>
-#include <utility>
-
-#ifdef __clang__
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wmissing-variable-declarations"
-#endif
-
-#define META_CXX_STD_14 201402L
-#define META_CXX_STD_17 201703L
-
-#if defined(_MSVC_LANG) && _MSVC_LANG > __cplusplus // Older clangs define _MSVC_LANG < __cplusplus
-#define META_CXX_VER _MSVC_LANG
-#else
-#define META_CXX_VER __cplusplus
-#endif
-
-#if defined(__apple_build_version__) || defined(__clang__)
-#if defined(__apple_build_version__) || (defined(__clang__) && __clang_major__ < 6)
-#define META_WORKAROUND_LLVM_28385 // https://llvm.org/bugs/show_bug.cgi?id=28385
-#endif
-
-#elif defined(_MSC_VER)
-#define META_HAS_MAKE_INTEGER_SEQ 1
-#if _MSC_VER < 1920
-#define META_WORKAROUND_MSVC_702792 // Bogus C4018 comparing constant expressions with dependent type
-#define META_WORKAROUND_MSVC_703656 // ICE with pack expansion inside decltype in alias template
-#endif
-
-#if _MSC_VER < 1921
-#define META_WORKAROUND_MSVC_756112 // fold expression + alias templates in template argument
-#endif
-
-#elif defined(__GNUC__)
-#define META_WORKAROUND_GCC_86356 // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86356
-#if __GNUC__ < 8
-#define META_WORKAROUND_GCC_UNKNOWN1 // Older GCCs don't like fold + debug + -march=native
-#endif
-#if __GNUC__ == 5 && __GNUC_MINOR__ == 1
-#define META_WORKAROUND_GCC_66405 // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66405
-#endif
-#if __GNUC__ < 5
-#define META_WORKAROUND_CWG_1558 // https://wg21.link/cwg1558
-#endif
-#endif
-
-#ifndef META_CXX_VARIABLE_TEMPLATES
-#ifdef __cpp_variable_templates
-#define META_CXX_VARIABLE_TEMPLATES __cpp_variable_templates
-#else
-#define META_CXX_VARIABLE_TEMPLATES (META_CXX_VER >= META_CXX_STD_14)
-#endif
-#endif
-
-#ifndef META_CXX_INLINE_VARIABLES
-#ifdef __cpp_inline_variables
-#define META_CXX_INLINE_VARIABLES __cpp_inline_variables
-#else
-#define META_CXX_INLINE_VARIABLES (META_CXX_VER >= META_CXX_STD_17)
-#endif
-#endif
-
-#ifndef META_INLINE_VAR
-#if META_CXX_INLINE_VARIABLES
-#define META_INLINE_VAR inline
-#else
-#define META_INLINE_VAR
-#endif
-#endif
-
-#ifndef META_CXX_INTEGER_SEQUENCE
-#ifdef __cpp_lib_integer_sequence
-#define META_CXX_INTEGER_SEQUENCE __cpp_lib_integer_sequence
-#else
-#define META_CXX_INTEGER_SEQUENCE (META_CXX_VER >= META_CXX_STD_14)
-#endif
-#endif
-
-#ifndef META_HAS_MAKE_INTEGER_SEQ
-#ifdef __has_builtin
-#if __has_builtin(__make_integer_seq)
-#define META_HAS_MAKE_INTEGER_SEQ 1
-#endif
-#endif
-#endif
-#ifndef META_HAS_MAKE_INTEGER_SEQ
-#define META_HAS_MAKE_INTEGER_SEQ 0
-#endif
-
-#ifndef META_HAS_TYPE_PACK_ELEMENT
-#ifdef __has_builtin
-#if __has_builtin(__type_pack_element)
-#define META_HAS_TYPE_PACK_ELEMENT 1
-#endif
-#endif
-#endif
-#ifndef META_HAS_TYPE_PACK_ELEMENT
-#define META_HAS_TYPE_PACK_ELEMENT 0
-#endif
-
-#if !defined(META_DEPRECATED) && !defined(META_DISABLE_DEPRECATED_WARNINGS)
-#if defined(__cpp_attribute_deprecated) || META_CXX_VER >= META_CXX_STD_14
-#define META_DEPRECATED(...) [[deprecated(__VA_ARGS__)]]
-#elif defined(__clang__) || defined(__GNUC__)
-#define META_DEPRECATED(...) __attribute__((deprecated(__VA_ARGS__)))
-#endif
-#endif
-#ifndef META_DEPRECATED
-#define META_DEPRECATED(...)
-#endif
-
-#ifndef META_CXX_FOLD_EXPRESSIONS
-#ifdef __cpp_fold_expressions
-#define META_CXX_FOLD_EXPRESSIONS __cpp_fold_expressions
-#else
-#define META_CXX_FOLD_EXPRESSIONS (META_CXX_VER >= META_CXX_STD_17)
-#endif
-#endif
-
-#if META_CXX_FOLD_EXPRESSIONS
-#if !META_CXX_VARIABLE_TEMPLATES
-#error Fold expressions, but no variable templates?
-#endif
-#endif
-
-#if (defined(__cpp_concepts) && __cpp_concepts > 0) || defined(META_DOXYGEN_INVOKED)
-#if !META_CXX_VARIABLE_TEMPLATES
-#error Concepts, but no variable templates?
-#endif
-#if __cpp_concepts <= 201507L && !defined(META_DOXYGEN_INVOKED)
-#define META_CONCEPT concept bool
-// TS concepts subsumption barrier for atomic expressions
-#define META_CONCEPT_BARRIER(...) ::meta::detail::barrier<__VA_ARGS__>
-#else
-#define META_CONCEPT concept
-#define META_CONCEPT_BARRIER(...) __VA_ARGS__
-#endif
-#define META_TYPE_CONSTRAINT(...) __VA_ARGS__
-#else
-#define META_TYPE_CONSTRAINT(...) typename
-#endif
-
-#if (defined(__cpp_lib_type_trait_variable_templates) && \
-    __cpp_lib_type_trait_variable_templates > 0)
-#define META_CXX_TRAIT_VARIABLE_TEMPLATES 1
-#else
-#define META_CXX_TRAIT_VARIABLE_TEMPLATES 0
-#endif
-
-#if defined(__clang__)
-#define META_IS_SAME(...) __is_same(__VA_ARGS__)
-#elif defined(__GNUC__) && __GNUC__ >= 6
-#define META_IS_SAME(...) __is_same_as(__VA_ARGS__)
-#elif META_CXX_TRAIT_VARIABLE_TEMPLATES
-#define META_IS_SAME(...) std::is_same_v<__VA_ARGS__>
-#else
-#define META_IS_SAME(...) std::is_same<__VA_ARGS__>::value
-#endif
-
-#if defined(__GNUC__) || defined(_MSC_VER)
-#define META_IS_BASE_OF(...) __is_base_of(__VA_ARGS__)
-#elif META_CXX_TRAIT_VARIABLE_TEMPLATES
-#define META_IS_BASE_OF(...) std::is_base_of_v<__VA_ARGS__>
-#else
-#define META_IS_BASE_OF(...) std::is_base_of<__VA_ARGS__>::value
-#endif
-
-#if defined(__clang__) || defined(_MSC_VER) || \
-    (defined(__GNUC__) && __GNUC__ >= 8)
-#define META_IS_CONSTRUCTIBLE(...) __is_constructible(__VA_ARGS__)
-#elif META_CXX_TRAIT_VARIABLE_TEMPLATES
-#define META_IS_CONSTRUCTIBLE(...) std::is_constructible_v<__VA_ARGS__>
-#else
-#define META_IS_CONSTRUCTIBLE(...) std::is_constructible<__VA_ARGS__>::value
-#endif
-
-/// \cond
-// Non-portable forward declarations of standard containers
-#ifdef _LIBCPP_VERSION
-#define META_BEGIN_NAMESPACE_STD _LIBCPP_BEGIN_NAMESPACE_STD
-#define META_END_NAMESPACE_STD _LIBCPP_END_NAMESPACE_STD
-#elif defined(_MSVC_STL_VERSION)
-#define META_BEGIN_NAMESPACE_STD _STD_BEGIN
-#define META_END_NAMESPACE_STD _STD_END
-#else
-#define META_BEGIN_NAMESPACE_STD namespace std {
-#define META_END_NAMESPACE_STD }
-#endif
-
-#if defined(__GLIBCXX__)
-#define META_BEGIN_NAMESPACE_VERSION _GLIBCXX_BEGIN_NAMESPACE_VERSION
-#define META_END_NAMESPACE_VERSION _GLIBCXX_END_NAMESPACE_VERSION
-#define META_BEGIN_NAMESPACE_CONTAINER _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
-#define META_END_NAMESPACE_CONTAINER _GLIBCXX_END_NAMESPACE_CONTAINER
-#else
-#define META_BEGIN_NAMESPACE_VERSION
-#define META_END_NAMESPACE_VERSION
-#define META_BEGIN_NAMESPACE_CONTAINER
-#define META_END_NAMESPACE_CONTAINER
-#endif
-
-#if defined(_LIBCPP_VERSION) && _LIBCPP_VERSION >= 4000
-#define META_TEMPLATE_VIS _LIBCPP_TEMPLATE_VIS
-#elif defined(_LIBCPP_VERSION)
-#define META_TEMPLATE_VIS _LIBCPP_TYPE_VIS_ONLY
-#else
-#define META_TEMPLATE_VIS
-#endif
-/// \endcond
-
-namespace meta
-{
-#if META_CXX_INTEGER_SEQUENCE
-    using std::integer_sequence;
-#else
-    template <typename T, T...>
-    struct integer_sequence;
-#endif
-
-    template <typename... Ts>
-    struct list;
-
-    template <typename T>
-    struct id;
-
-    template <template <typename...> class>
-    struct quote;
-
-    template <typename T, template <T...> class F>
-    struct quote_i;
-
-    template <template <typename...> class C, typename... Ts>
-    struct defer;
-
-    template <typename T, template <T...> class C, T... Is>
-    struct defer_i;
-
-#if META_CXX_VARIABLE_TEMPLATES || defined(META_DOXYGEN_INVOKED)
-    /// is_v
-    /// Test whether a type \p T is an instantiation of class
-    /// template \p C.
-    /// \ingroup trait
-    template <typename, template <typename...> class>
-    META_INLINE_VAR constexpr bool is_v = false;
-    template <typename... Ts, template <typename...> class C>
-    META_INLINE_VAR constexpr bool is_v<C<Ts...>, C> = true;
-#endif
-
-#ifdef META_CONCEPT
-    namespace detail
-    {
-        template <bool B>
-        META_INLINE_VAR constexpr bool barrier = B;
-
-        template <class T, T> struct require_constant; // not defined
-    }
-
-    template <typename...>
-    META_CONCEPT is_true = META_CONCEPT_BARRIER(true);
-
-    template <typename T, typename U>
-    META_CONCEPT same_as =
-        META_CONCEPT_BARRIER(META_IS_SAME(T, U));
-
-    template <template <typename...> class C, typename... Ts>
-    META_CONCEPT valid = requires
-    {
-        typename C<Ts...>;
-    };
-
-    template <typename T, template <T...> class C, T... Is>
-    META_CONCEPT valid_i = requires
-    {
-        typename C<Is...>;
-    };
-
-    template <typename T>
-    META_CONCEPT trait = requires
-    {
-        typename T::type;
-    };
-
-    template <typename T>
-    META_CONCEPT invocable = requires
-    {
-        typename quote<T::template invoke>;
-    };
-
-    template <typename T>
-    META_CONCEPT list_like = is_v<T, list>;
-
-    // clang-format off
-    template <typename T>
-    META_CONCEPT integral = requires
-    {
-        typename T::type;
-        typename T::value_type;
-        typename T::type::value_type;
-    }
-    && same_as<typename T::value_type, typename T::type::value_type>
-#if META_CXX_TRAIT_VARIABLE_TEMPLATES
-    && std::is_integral_v<typename T::value_type>
-#else
-    && std::is_integral<typename T::value_type>::value
-#endif
-
-    && requires
-    {
-        // { T::value } -> same_as<const typename T::value_type&>;
-        T::value;
-        requires same_as<decltype(T::value), const typename T::value_type>;
-        typename detail::require_constant<decltype(T::value), T::value>;
-
-        // { T::type::value } -> same_as<const typename T::value_type&>;
-        T::type::value;
-        requires same_as<decltype(T::type::value), const typename T::value_type>;
-        typename detail::require_constant<decltype(T::type::value), T::type::value>;
-        requires T::value == T::type::value;
-
-        // { T{}() } -> same_as<typename T::value_type>;
-        T{}();
-        requires same_as<decltype(T{}()), typename T::value_type>;
-        typename detail::require_constant<decltype(T{}()), T{}()>;
-        requires T{}() == T::value;
-
-        // { T{} } -> typename T::value_type;
-    };
-    // clang-format on
-#endif // META_CONCEPT
-
-    namespace extension
-    {
-        template <META_TYPE_CONSTRAINT(invocable) F, typename L>
-        struct apply;
-    }
-} // namespace meta
-
-#ifdef __clang__
-#pragma GCC diagnostic pop
-#endif
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/module.modulemap b/src/contrib/range-v3-0.11.0/include/module.modulemap
deleted file mode 100644
index 8bdf46db..00000000
--- a/src/contrib/range-v3-0.11.0/include/module.modulemap
+++ /dev/null
@@ -1,61 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Gonzalo Brito Gadeschi 2017.
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-module concepts {
-    umbrella "concepts"
-    export *
-}
-module meta {
-    umbrella "meta"
-    export *
-}
-module range_v3 {
-    umbrella "range"
-    export *
-    exclude header "range/v3/algorithm/tagspec.hpp"
-    exclude header "range/v3/at.hpp"
-    exclude header "range/v3/back.hpp"
-    exclude header "range/v3/begin_end.hpp"
-    exclude header "range/v3/data.hpp"
-    exclude header "range/v3/distance.hpp"
-    exclude header "range/v3/empty.hpp"
-    exclude header "range/v3/front.hpp"
-    exclude header "range/v3/getlines.hpp"
-    exclude header "range/v3/index.hpp"
-    exclude header "range/v3/istream_range.hpp"
-    exclude header "range/v3/iterator_range.hpp"
-    exclude header "range/v3/range_access.hpp"
-    exclude header "range/v3/range_concepts.hpp"
-    exclude header "range/v3/range_traits.hpp"
-    exclude header "range/v3/size.hpp"
-    exclude header "range/v3/span.hpp"
-    exclude header "range/v3/to_container.hpp"
-    exclude header "range/v3/utility/associated_types.hpp"
-    exclude header "range/v3/utility/basic_iterator.hpp"
-    exclude header "range/v3/utility/common_iterator.hpp"
-    exclude header "range/v3/utility/concepts.hpp"
-    exclude header "range/v3/utility/counted_iterator.hpp"
-    exclude header "range/v3/utility/dangling.hpp"
-    exclude header "range/v3/utility/functional.hpp"
-    exclude header "range/v3/utility/infinity.hpp"
-    exclude header "range/v3/utility/invoke.hpp"
-    exclude header "range/v3/utility/iterator_concepts.hpp"
-    exclude header "range/v3/utility/iterator_traits.hpp"
-    exclude header "range/v3/utility/iterator.hpp"
-    exclude header "range/v3/utility/nullptr_v.hpp"
-    exclude header "range/v3/utility/unreachable.hpp"
-    exclude header "range/v3/view_adaptor.hpp"
-    exclude header "range/v3/view_facade.hpp"
-    exclude header "range/v3/view_interface.hpp"
-    exclude header "range/v3/view/bounded.hpp"
-}
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/action.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/action.hpp
deleted file mode 100644
index 6f2befd5..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/action.hpp
+++ /dev/null
@@ -1,42 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ACTION_HPP
-#define RANGES_V3_ACTION_HPP
-
-#include <range/v3/action/action.hpp>
-#include <range/v3/action/adjacent_remove_if.hpp>
-#include <range/v3/action/concepts.hpp>
-#include <range/v3/action/drop.hpp>
-#include <range/v3/action/drop_while.hpp>
-#include <range/v3/action/erase.hpp>
-#include <range/v3/action/insert.hpp>
-#include <range/v3/action/join.hpp>
-#include <range/v3/action/push_back.hpp>
-#include <range/v3/action/push_front.hpp>
-#include <range/v3/action/remove_if.hpp>
-#include <range/v3/action/reverse.hpp>
-#include <range/v3/action/shuffle.hpp>
-#include <range/v3/action/slice.hpp>
-#include <range/v3/action/sort.hpp>
-#include <range/v3/action/split.hpp>
-#include <range/v3/action/split_when.hpp>
-#include <range/v3/action/stable_sort.hpp>
-#include <range/v3/action/stride.hpp>
-#include <range/v3/action/take.hpp>
-#include <range/v3/action/take_while.hpp>
-#include <range/v3/action/transform.hpp>
-#include <range/v3/action/unique.hpp>
-#include <range/v3/action/unstable_remove_if.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/action/action.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/action/action.hpp
deleted file mode 100644
index 3d6ee242..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/action/action.hpp
+++ /dev/null
@@ -1,248 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_CONTAINER_ACTION_HPP
-#define RANGES_V3_CONTAINER_ACTION_HPP
-
-#include <type_traits>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/action/concepts.hpp>
-#include <range/v3/functional/compose.hpp>
-#include <range/v3/functional/concepts.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/functional/reference_wrapper.hpp>
-#include <range/v3/functional/pipeable.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/utility/move.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-actions
-    /// @{
-    struct make_action_closure_fn
-    {
-        template<typename Fun>
-        constexpr actions::action_closure<Fun> operator()(Fun fun) const
-        {
-            return actions::action_closure<Fun>{static_cast<Fun &&>(fun)};
-        }
-    };
-
-    /// \sa make_action_closure_fn
-    RANGES_INLINE_VARIABLE(make_action_closure_fn, make_action_closure)
-
-    /// \cond
-    namespace detail
-    {
-        struct action_closure_base_
-        {};
-    }
-    /// \endcond
-
-    template(typename ActionFn, typename Rng)(
-    concept (invocable_action_closure_)(ActionFn, Rng),
-        !derived_from<invoke_result_t<ActionFn, Rng>, detail::action_closure_base_>
-    );
-    template<typename ActionFn, typename Rng>
-    CPP_concept invocable_action_closure =
-        invocable<ActionFn, Rng> &&
-        CPP_concept_ref(ranges::invocable_action_closure_, ActionFn, Rng);
-
-    namespace actions
-    {
-        struct RANGES_STRUCT_WITH_ADL_BARRIER(action_closure_base)
-          : detail::action_closure_base_
-        {
-            // clang-format off
-            // Piping requires things are passed by value.
-            template(typename Rng, typename ActionFn)(
-                /// \pre
-                requires (!std::is_lvalue_reference<Rng>::value) AND
-                range<Rng> AND invocable_action_closure<ActionFn, Rng &>)
-            friend constexpr auto
-            operator|(Rng && rng, action_closure<ActionFn> act)
-            {
-                return aux::move(static_cast<ActionFn &&>(act)(rng));
-            }
-
-#ifndef RANGES_WORKAROUND_CLANG_43400
-            template<typename Rng, typename ActionFn>   // ******************************
-            friend constexpr auto                       // ******************************
-            operator|(Rng &,                            // ********* READ THIS **********
-                      action_closure<ActionFn> const &) // ****** IF YOUR COMPILE *******
-                -> CPP_broken_friend_ret(Rng)(          // ******** BREAKS HERE *********
-                    requires range<Rng>) = delete;      // ******************************
-            // **************************************************************************
-            // *    When piping a range into an action, the range must be moved in.     *
-            // **************************************************************************
-#endif // RANGES_WORKAROUND_CLANG_43400
-
-            template<typename ActionFn, typename Pipeable>
-            friend constexpr auto operator|(action_closure<ActionFn> act, Pipeable pipe)
-                -> CPP_broken_friend_ret(action_closure<composed<Pipeable, ActionFn>>)(
-                    /// \pre
-                    requires (is_pipeable_v<Pipeable>))
-            {
-                return make_action_closure(compose(static_cast<Pipeable &&>(pipe),
-                                                   static_cast<ActionFn &&>(act)));
-            }
-
-            template<typename Rng, typename ActionFn>
-            friend constexpr auto operator|=(Rng & rng, action_closure<ActionFn> act) //
-                -> CPP_broken_friend_ret(Rng &)(
-                    /// \pre
-                    requires range<Rng> && invocable<ActionFn, Rng &>)
-            {
-                static_cast<ActionFn &&>(act)(rng);
-                return rng;
-            }
-            // clang-format on
-        };
-
-#ifdef RANGES_WORKAROUND_CLANG_43400
-        // clang-format off
-        namespace RANGES_ADL_BARRIER_FOR(action_closure_base)
-        {
-            template(typename Rng, typename ActionFn)(  // *******************************
-                requires range<Rng>)                    // *******************************
-            constexpr Rng                               // ********** READ THIS **********
-            operator|(Rng &,                            // ******* IF YOUR COMPILE *******
-                      action_closure<ActionFn> const &) // ********* BREAKS HERE *********
-                = delete;                               // *******************************
-            // ***************************************************************************
-            // *    When piping a range into an action, the range must be moved in.      *
-            // ***************************************************************************
-        } // namespace RANGES_ADL_BARRIER_FOR(action_closure_base)
-        // clang-format on
-#endif    // RANGES_WORKAROUND_CLANG_43400
-
-        template<typename ActionFn>
-        struct RANGES_EMPTY_BASES action_closure
-          : action_closure_base
-          , ActionFn
-        {
-            action_closure() = default;
-
-            constexpr explicit action_closure(ActionFn fn)
-              : ActionFn(static_cast<ActionFn &&>(fn))
-            {}
-        };
-
-        /// \cond
-        /// DEPRECATED STUFF
-        struct action_access_
-        {
-            template<typename Action>
-            struct impl
-            {
-                // clang-format off
-                template<typename... Ts, typename A = Action>
-                static constexpr auto CPP_auto_fun(bind)(Ts &&... ts)
-                (
-                    return A::bind(static_cast<Ts &&>(ts)...)
-                )
-                // clang-format on
-            };
-        };
-
-        using action_access RANGES_DEPRECATED(
-            "action_access and actions::action<> are deprecated. Please "
-            "replace action<> with action_closure<> and discontinue use of "
-            "action_access.") = action_access_;
-
-        template<typename>
-        struct old_action_;
-
-        struct make_action_fn_
-        {
-            template<typename Fun>
-            constexpr old_action_<Fun> operator()(Fun fun) const
-            {
-                return old_action_<Fun>{static_cast<Fun &&>(fun)};
-            }
-        };
-        using make_action_fn RANGES_DEPRECATED(
-            "make_action_fn is deprecated. Please use "
-            "make_action_closure instead.") = make_action_fn_;
-
-        namespace
-        {
-            RANGES_DEPRECATED(
-                "make_action and actions::action<> has been deprecated. Please switch to "
-                "make_action_closure and action::action_closure.")
-            RANGES_INLINE_VAR constexpr auto & make_action =
-                static_const<make_action_fn_>::value;
-        } // namespace
-
-        template<typename Action>
-        struct old_action_ : pipeable_base
-        {
-        private:
-            Action act_;
-            friend pipeable_access;
-
-        public:
-            old_action_() = default;
-
-            constexpr explicit old_action_(Action a) noexcept(
-                std::is_nothrow_move_constructible<Action>::value)
-              : act_(detail::move(a))
-            {}
-
-            // Calling directly requires things are passed by reference.
-            template(typename Rng, typename... Rest)(
-                /// \pre
-                requires range<Rng> AND invocable<Action const &, Rng &, Rest...>)
-            invoke_result_t<Action const &, Rng &, Rest...> //
-            operator()(Rng & rng, Rest &&... rest) const
-            {
-                return invoke(act_, rng, static_cast<Rest &&>(rest)...);
-            }
-
-            // Currying overload.
-            // clang-format off
-            template(typename... Rest, typename A = Action)(
-                /// \pre
-                requires (sizeof...(Rest) != 0))
-            auto CPP_auto_fun(operator())(Rest &&... rest)(const)
-            (
-                return make_action_fn_{}(
-                    action_access_::impl<A>::bind(act_,
-                                                  static_cast<Rest &&>(rest)...))
-            )
-            // clang-format on
-        };
-
-        template<typename Action>
-        using action RANGES_DEPRECATED(
-            "The actions::action<> template is deprecated. Please switch to "
-            "action_closure") = old_action_<Action>;
-        /// \endcond
-    } // namespace actions
-
-    template<typename ActionFn>
-    RANGES_INLINE_VAR constexpr bool is_pipeable_v<actions::action_closure<ActionFn>> =
-        true;
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/action/adjacent_remove_if.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/action/adjacent_remove_if.hpp
deleted file mode 100644
index bcd7e158..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/action/adjacent_remove_if.hpp
+++ /dev/null
@@ -1,70 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler
-//  Copyright Christopher Di Bella
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ACTION_ADJACENT_REMOVE_IF_HPP
-#define RANGES_V3_ACTION_ADJACENT_REMOVE_IF_HPP
-
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/action/action.hpp>
-#include <range/v3/action/erase.hpp>
-#include <range/v3/algorithm/adjacent_remove_if.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-actions
-    /// @{
-    namespace actions
-    {
-        struct adjacent_remove_if_fn
-        {
-            template(typename Pred, typename Proj = identity)(
-                /// \pre
-                requires (!range<Pred>))
-            constexpr auto operator()(Pred pred, Proj proj = {}) const
-            {
-                return make_action_closure(
-                    bind_back(adjacent_remove_if_fn{}, std::move(pred), std::move(proj)));
-            }
-
-            template(typename Rng, typename Pred, typename Proj = identity)(
-                /// \pre
-                requires forward_range<Rng> AND
-                    erasable_range<Rng, iterator_t<Rng>, sentinel_t<Rng>> AND
-                    indirect_relation<Pred, projected<iterator_t<Rng>, Proj>> AND
-                    permutable<iterator_t<Rng>>)
-            Rng operator()(Rng && rng, Pred pred, Proj proj = {}) const
-            {
-                auto i = adjacent_remove_if(rng, std::move(pred), std::move(proj));
-                erase(rng, std::move(i), end(rng));
-                return static_cast<Rng &&>(rng);
-            }
-        };
-
-        /// \relates actions::adjacent_remove_if_fn
-        RANGES_INLINE_VARIABLE(adjacent_remove_if_fn, adjacent_remove_if)
-    } // namespace actions
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif // RANGES_V3_ACTION_ADJACENT_REMOVE_IF_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/action/concepts.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/action/concepts.hpp
deleted file mode 100644
index 3db31672..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/action/concepts.hpp
+++ /dev/null
@@ -1,169 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ACTION_CONCEPTS_HPP
-#define RANGES_V3_ACTION_CONCEPTS_HPP
-
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        template<typename T>
-        struct movable_input_iterator
-        {
-            using iterator_category = std::input_iterator_tag;
-            using value_type = T;
-            using difference_type = std::ptrdiff_t;
-            using pointer = T *;
-            using reference = T &&;
-
-            movable_input_iterator() = default;
-            movable_input_iterator & operator++();
-            movable_input_iterator operator++(int);
-            bool operator==(movable_input_iterator const &) const;
-            bool operator!=(movable_input_iterator const &) const;
-            T && operator*() const;
-        };
-    } // namespace detail
-      /// \endcond
-
-    /// \addtogroup group-range
-    /// @{
-
-    // std::array is a semi_container, native arrays are not.
-    // clang-format off
-    template<typename T>
-    CPP_concept semi_container =
-        forward_range<T> && default_constructible<uncvref_t<T>> &&
-        movable<uncvref_t<T>> &&
-        !view_<T>;
-
-    // std::vector is a container, std::array is not
-    template(typename T)(
-    concept (container_)(T),
-        constructible_from<
-            uncvref_t<T>,
-            detail::movable_input_iterator<range_value_t<T>>,
-            detail::movable_input_iterator<range_value_t<T>>>
-    );
-
-    template<typename T>
-    CPP_concept container =
-        semi_container<T> &&
-        CPP_concept_ref(ranges::container_, T);
-
-    template<typename C>
-    CPP_requires(reservable_,
-        requires(C & c, C const & cc) //
-        (
-            c.reserve(ranges::size(c)),
-            cc.capacity(),
-            cc.max_size(),
-            concepts::requires_<same_as<decltype(cc.capacity()),
-                                        decltype(ranges::size(c))>>,
-            concepts::requires_<same_as<decltype(cc.max_size()),
-                                        decltype(ranges::size(c))>>
-        ));
-
-    template<typename C>
-    CPP_concept reservable =
-        container<C> && sized_range<C> && CPP_requires_ref(ranges::reservable_, C);
-
-    template<typename C, typename I>
-    CPP_requires(reservable_with_assign_,
-        requires(C & c, I i) //
-        (
-            c.assign(i, i)
-        ));
-    template<typename C, typename I>
-    CPP_concept reservable_with_assign =
-        reservable<C> && //
-        input_iterator<I> && //
-        CPP_requires_ref(ranges::reservable_with_assign_, C, I);
-
-    template<typename C>
-    CPP_concept random_access_reservable =
-        reservable<C> && random_access_range<C>;
-    // clang-format on
-
-    /// \cond
-    namespace detail
-    {
-        template(typename T)(
-            /// \pre
-            requires container<T>)
-        std::true_type is_lvalue_container_like(T &) noexcept
-        {
-            return {};
-        }
-
-        template(typename T)(
-            /// \pre
-            requires container<T>)
-        meta::not_<std::is_rvalue_reference<T>> //
-        is_lvalue_container_like(reference_wrapper<T>) noexcept
-        {
-            return {};
-        }
-
-        template(typename T)(
-            /// \pre
-            requires container<T>)
-        std::true_type is_lvalue_container_like(std::reference_wrapper<T>) noexcept
-        {
-            return {};
-        }
-
-        template(typename T)(
-            /// \pre
-            requires container<T>)
-        std::true_type is_lvalue_container_like(ref_view<T>) noexcept
-        {
-            return {};
-        }
-
-        template<typename T>
-        using is_lvalue_container_like_t =
-            decltype(detail::is_lvalue_container_like(std::declval<T>()));
-
-    } // namespace detail
-      /// \endcond
-
-    // clang-format off
-    template(typename T)(
-    concept (lvalue_container_like_)(T),
-        implicitly_convertible_to<detail::is_lvalue_container_like_t<T>, std::true_type>
-    );
-    template<typename T>
-    CPP_concept lvalue_container_like =
-        forward_range<T> &&
-        CPP_concept_ref(ranges::lvalue_container_like_, T);
-    // clang-format on
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/action/drop.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/action/drop.hpp
deleted file mode 100644
index 3090dc56..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/action/drop.hpp
+++ /dev/null
@@ -1,67 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ACTION_DROP_HPP
-#define RANGES_V3_ACTION_DROP_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/action/action.hpp>
-#include <range/v3/action/erase.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-actions
-    /// @{
-    namespace actions
-    {
-        struct drop_fn
-        {
-            template(typename Int)(
-                /// \pre
-                requires detail::integer_like_<Int>)
-            constexpr auto operator()(Int n) const
-            {
-                RANGES_EXPECT(n >= Int(0));
-                return make_action_closure(bind_back(drop_fn{}, n));
-            }
-
-            template(typename Rng)(
-                /// \pre
-                requires forward_range<Rng> AND
-                    erasable_range<Rng &, iterator_t<Rng>, iterator_t<Rng>>)
-            Rng operator()(Rng && rng, range_difference_t<Rng> n) const
-            {
-                RANGES_EXPECT(n >= 0);
-                ranges::actions::erase(
-                    rng, begin(rng), ranges::next(begin(rng), n, end(rng)));
-                return static_cast<Rng &&>(rng);
-            }
-        };
-
-        /// \relates actions::drop_fn
-        RANGES_INLINE_VARIABLE(drop_fn, drop)
-    } // namespace actions
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/action/drop_while.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/action/drop_while.hpp
deleted file mode 100644
index 4b8b7da5..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/action/drop_while.hpp
+++ /dev/null
@@ -1,66 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ACTION_DROP_WHILE_HPP
-#define RANGES_V3_ACTION_DROP_WHILE_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/action/action.hpp>
-#include <range/v3/action/erase.hpp>
-#include <range/v3/algorithm/find_if_not.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-actions
-    /// @{
-    namespace actions
-    {
-        struct drop_while_fn
-        {
-            template(typename Fun)(
-                /// \pre
-                requires (!range<Fun>))
-            constexpr auto operator()(Fun fun) const
-            {
-                return make_action_closure(bind_back(drop_while_fn{}, std::move(fun)));
-            }
-
-            template(typename Rng, typename Fun)(
-                /// \pre
-                requires forward_range<Rng> AND
-                    indirect_unary_predicate<Fun, iterator_t<Rng>> AND
-                        erasable_range<Rng &, iterator_t<Rng>, iterator_t<Rng>>)
-            Rng operator()(Rng && rng, Fun fun) const
-            {
-                ranges::actions::erase(
-                    rng, begin(rng), find_if_not(begin(rng), end(rng), std::move(fun)));
-                return static_cast<Rng &&>(rng);
-            }
-        };
-
-        /// \relates actions::drop_while_fn
-        RANGES_INLINE_VARIABLE(drop_while_fn, drop_while)
-    } // namespace actions
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/action/erase.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/action/erase.hpp
deleted file mode 100644
index 4b431f01..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/action/erase.hpp
+++ /dev/null
@@ -1,82 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ACTION_ERASE_HPP
-#define RANGES_V3_ACTION_ERASE_HPP
-
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/action/insert.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace adl_erase_detail
-    {
-        template(typename Cont, typename I, typename S)(
-            /// \pre
-            requires lvalue_container_like<Cont> AND forward_iterator<I> AND
-                sentinel_for<S, I>)
-        auto erase(Cont && cont, I first, S last)                            //
-            -> decltype(unwrap_reference(cont).erase(first, last))
-        {
-            return unwrap_reference(cont).erase(first, last);
-        }
-
-        struct erase_fn
-        {
-            template(typename Rng, typename I, typename S)(
-                /// \pre
-                requires range<Rng> AND forward_iterator<I> AND sentinel_for<S, I>)
-            auto operator()(Rng && rng, I first, S last) const
-                -> decltype(erase((Rng &&) rng, first, last))
-            {
-                return erase(static_cast<Rng &&>(rng), first, last);
-            }
-        };
-    } // namespace adl_erase_detail
-    /// \endcond
-
-    /// \ingroup group-actions
-    RANGES_INLINE_VARIABLE(adl_erase_detail::erase_fn, erase)
-
-    namespace actions
-    {
-        using ranges::erase;
-    }
-
-    /// \addtogroup group-range
-    /// @{
-    // clang-format off
-    template<typename Rng, typename I, typename S>
-    CPP_requires(erasable_range_,
-        requires(Rng && rng, I first, S last)
-        (
-            ranges::erase((Rng &&) rng, first, last)
-        )
-    );
-    template<typename Rng, typename I, typename S>
-    CPP_concept erasable_range =
-        range<Rng> && CPP_requires_ref(ranges::erasable_range_, Rng, I, S);
-    // clang-format on
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/action/insert.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/action/insert.hpp
deleted file mode 100644
index 98c25cbb..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/action/insert.hpp
+++ /dev/null
@@ -1,320 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ACTION_INSERT_HPP
-#define RANGES_V3_ACTION_INSERT_HPP
-
-#include <initializer_list>
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/action/concepts.hpp>
-#include <range/v3/algorithm/max.hpp>
-#include <range/v3/iterator/common_iterator.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace adl_insert_detail
-    {
-        template<typename Cont, typename... Args>
-        using insert_result_t = decltype(
-            unwrap_reference(std::declval<Cont>()).insert(std::declval<Args>()...));
-
-        template(typename Cont, typename T)(
-            /// \pre
-            requires lvalue_container_like<Cont> AND
-            (!range<T> && constructible_from<range_value_t<Cont>, T>)) //
-        insert_result_t<Cont &, T> insert(Cont && cont, T && t)
-        {
-            return unwrap_reference(cont).insert(static_cast<T &&>(t));
-        }
-
-        template(typename Cont, typename I, typename S)(
-            /// \pre
-            requires lvalue_container_like<Cont> AND sentinel_for<S, I> AND (!range<S>))
-        insert_result_t<Cont &, detail::cpp17_iterator_t<I, S>,
-                                detail::cpp17_iterator_t<I, S>>
-        insert(Cont && cont, I i, S j)
-        {
-            return unwrap_reference(cont).insert(detail::cpp17_iterator_t<I, S>{i},
-                                                 detail::cpp17_iterator_t<I, S>{j});
-        }
-
-        template(typename Cont, typename Rng)(
-            /// \pre
-            requires lvalue_container_like<Cont> AND range<Rng>)
-        insert_result_t<Cont &, detail::range_cpp17_iterator_t<Rng>,
-                                detail::range_cpp17_iterator_t<Rng>>
-        insert(Cont && cont, Rng && rng)
-        {
-            return unwrap_reference(cont).insert(
-                detail::range_cpp17_iterator_t<Rng>{ranges::begin(rng)},
-                detail::range_cpp17_iterator_t<Rng>{ranges::end(rng)});
-        }
-
-        template(typename Cont, typename I, typename T)(
-            /// \pre
-            requires lvalue_container_like<Cont> AND input_iterator<I> AND
-            (!range<T> && constructible_from<range_value_t<Cont>, T>)) //
-        insert_result_t<Cont &, I, T> insert(Cont && cont, I p, T && t)
-        {
-            return unwrap_reference(cont).insert(p, static_cast<T &&>(t));
-        }
-
-        template(typename Cont, typename I, typename N, typename T)(
-            /// \pre
-            requires lvalue_container_like<Cont> AND input_iterator<I> AND
-                integral<N> AND constructible_from<range_value_t<Cont>, T>)
-        insert_result_t<Cont &, I, N, T> insert(Cont && cont, I p, N n, T && t)
-        {
-            return unwrap_reference(cont).insert(p, n, static_cast<T &&>(t));
-        }
-
-        /// \cond
-        namespace detail
-        {
-            using ranges::detail::cpp17_iterator_t;
-            using ranges::detail::range_cpp17_iterator_t;
-
-            template(typename Cont, typename P)(
-                /// \pre
-                requires container<Cont> AND input_iterator<P> AND
-                        random_access_reservable<Cont>)
-            iterator_t<Cont> insert_reserve_helper(
-                Cont & cont, P const p, range_size_t<Cont> const delta)
-            {
-                auto const old_size = ranges::size(cont);
-                auto const max_size = cont.max_size();
-                RANGES_EXPECT(delta <= max_size - old_size);
-                auto const new_size = old_size + delta;
-                auto const old_capacity = cont.capacity();
-                auto const index = p - ranges::begin(cont);
-                if(old_capacity < new_size)
-                {
-                    auto const new_capacity =
-                        (old_capacity <= max_size / 3 * 2)
-                            ? ranges::max(old_capacity + old_capacity / 2, new_size)
-                            : max_size;
-                    cont.reserve(new_capacity);
-                }
-                return ranges::begin(cont) + index;
-            }
-
-            template(typename Cont, typename P, typename I, typename S)(
-                /// \pre
-                requires sentinel_for<S, I> AND (!range<S>)) //
-            auto insert_impl(Cont && cont, P p, I i, S j, std::false_type)
-                -> decltype(unwrap_reference(cont).insert(
-                    p, cpp17_iterator_t<I, S>{i}, cpp17_iterator_t<I, S>{j}))
-            {
-                using C = cpp17_iterator_t<I, S>;
-                return unwrap_reference(cont).insert(p, C{i}, C{j});
-            }
-
-            template(typename Cont, typename P, typename I, typename S)(
-                /// \pre
-                requires sized_sentinel_for<S, I> AND random_access_reservable<Cont> AND
-                    (!range<S>)) //
-            auto insert_impl(Cont && cont_, P p, I i, S j, std::true_type)
-                -> decltype(unwrap_reference(cont_).insert(
-                    ranges::begin(unwrap_reference(cont_)), cpp17_iterator_t<I, S>{i},
-                    cpp17_iterator_t<I, S>{j}))
-            {
-                using C = cpp17_iterator_t<I, S>;
-                auto && cont = unwrap_reference(cont_);
-                auto const delta = static_cast<range_size_t<Cont>>(j - i);
-                auto pos = insert_reserve_helper(cont, std::move(p), delta);
-                return cont.insert(pos, C{std::move(i)}, C{std::move(j)});
-            }
-
-            template(typename Cont, typename I, typename Rng)(
-                /// \pre
-                requires range<Rng>)
-            auto insert_impl(Cont && cont, I p, Rng && rng, std::false_type)
-                -> decltype(unwrap_reference(cont).insert(
-                    p, range_cpp17_iterator_t<Rng>{ranges::begin(rng)},
-                    range_cpp17_iterator_t<Rng>{ranges::end(rng)}))
-            {
-                using C = range_cpp17_iterator_t<Rng>;
-                return unwrap_reference(cont).insert(
-                    p, C{ranges::begin(rng)}, C{ranges::end(rng)});
-            }
-
-            template(typename Cont, typename I, typename Rng)(
-                /// \pre
-                requires random_access_reservable<Cont> AND sized_range<Rng>)
-            auto insert_impl(Cont && cont_, I p, Rng && rng, std::true_type)
-                -> decltype(unwrap_reference(cont_).insert(
-                    begin(unwrap_reference(cont_)),
-                    range_cpp17_iterator_t<Rng>{ranges::begin(rng)},
-                    range_cpp17_iterator_t<Rng>{ranges::end(rng)}))
-            {
-                using C = range_cpp17_iterator_t<Rng>;
-                auto && cont = unwrap_reference(cont_);
-                auto const delta = static_cast<range_size_t<Cont>>(ranges::size(rng));
-                auto pos = insert_reserve_helper(cont, std::move(p), delta);
-                return cont.insert(pos, C{ranges::begin(rng)}, C{ranges::end(rng)});
-            }
-        } // namespace detail
-        /// \endcond
-
-        template(typename Cont, typename P, typename I, typename S)(
-            /// \pre
-            requires lvalue_container_like<Cont> AND input_iterator<P> AND
-                sentinel_for<S, I> AND
-            (!range<S>)) //
-        auto insert(Cont && cont, P p, I i, S j) //
-            -> decltype(detail::insert_impl(
-                static_cast<Cont &&>(cont),
-                static_cast<P &&>(p),
-                static_cast<I &&>(i),
-                static_cast<S &&>(j),
-                meta::bool_<random_access_reservable<Cont> && //
-                            sized_sentinel_for<S, I>>{}))
-        {
-            return detail::insert_impl(static_cast<Cont &&>(cont),
-                                       static_cast<P &&>(p),
-                                       static_cast<I &&>(i),
-                                       static_cast<S &&>(j),
-                                       meta::bool_<random_access_reservable<Cont> &&
-                                                   sized_sentinel_for<S, I>>{});
-        }
-
-        template(typename Cont, typename I, typename Rng)(
-            /// \pre
-            requires lvalue_container_like<Cont> AND input_iterator<I> AND range<Rng>)
-        auto insert(Cont && cont, I p, Rng && rng)
-            -> decltype(detail::insert_impl(
-                static_cast<Cont &&>(cont), std::move(p), static_cast<Rng &&>(rng),
-                meta::bool_<random_access_reservable<Cont> && sized_range<Rng>>{}))
-        {
-            return detail::insert_impl(static_cast<Cont &&>(cont),
-                                       std::move(p),
-                                       static_cast<Rng &&>(rng),
-                                       meta::bool_<random_access_reservable<Cont> &&
-                                                   sized_range<Rng>>{});
-        }
-
-        struct insert_fn
-        {
-            template<typename Rng, typename... Args>
-            using insert_result_t =
-                decltype(insert(std::declval<Rng>(), std::declval<Args>()...));
-
-            template(typename Rng, typename T)(
-                /// \pre
-                requires range<Rng> AND
-                    (!range<T>) AND constructible_from<range_value_t<Rng>, T>)
-            insert_result_t<Rng, T> operator()(Rng && rng, T && t) const
-            {
-                return insert(static_cast<Rng &&>(rng), static_cast<T &&>(t));
-            }
-
-            template(typename Rng, typename Rng2)(
-                /// \pre
-                requires range<Rng> AND range<Rng2>)
-            insert_result_t<Rng, Rng2> operator()(Rng && rng, Rng2 && rng2) const
-            {
-                static_assert(!is_infinite<Rng>::value,
-                              "Attempting to insert an infinite range into a container");
-                return insert(static_cast<Rng &&>(rng), static_cast<Rng2 &&>(rng2));
-            }
-
-            template(typename Rng, typename T)(
-                /// \pre
-                requires range<Rng>)
-            insert_result_t<Rng, std::initializer_list<T> &> //
-            operator()(Rng && rng, std::initializer_list<T> rng2) const
-            {
-                return insert(static_cast<Rng &&>(rng), rng2);
-            }
-
-            template(typename Rng, typename I, typename S)(
-                /// \pre
-                requires range<Rng> AND sentinel_for<S, I> AND (!range<S>)) //
-            insert_result_t<Rng, I, S> operator()(Rng && rng, I i, S j) const
-            {
-                return insert(static_cast<Rng &&>(rng), std::move(i), std::move(j));
-            }
-
-            template(typename Rng, typename I, typename T)(
-                /// \pre
-                requires range<Rng> AND input_iterator<I> AND
-                    (!range<T>) AND constructible_from<range_value_t<Rng>, T>)
-            insert_result_t<Rng, I, T> operator()(Rng && rng, I p, T && t) const
-            {
-                return insert(
-                    static_cast<Rng &&>(rng), std::move(p), static_cast<T &&>(t));
-            }
-
-            template(typename Rng, typename I, typename Rng2)(
-                /// \pre
-                requires range<Rng> AND input_iterator<I> AND range<Rng2>)
-            insert_result_t<Rng, I, Rng2> operator()(Rng && rng, I p, Rng2 && rng2) const
-            {
-                static_assert(!is_infinite<Rng>::value,
-                              "Attempting to insert an infinite range into a container");
-                return insert(
-                    static_cast<Rng &&>(rng), std::move(p), static_cast<Rng2 &&>(rng2));
-            }
-
-            template(typename Rng, typename I, typename T)(
-                /// \pre
-                requires range<Rng> AND input_iterator<I>)
-            insert_result_t<Rng, I, std::initializer_list<T> &> //
-            operator()(Rng && rng, I p, std::initializer_list<T> rng2) const
-            {
-                return insert(static_cast<Rng &&>(rng), std::move(p), rng2);
-            }
-
-            template(typename Rng, typename I, typename N, typename T)(
-                /// \pre
-                requires range<Rng> AND input_iterator<I> AND integral<N> AND
-                    (!range<T>) AND constructible_from<range_value_t<Rng>, T>)
-            insert_result_t<Rng, I, N, T> operator()(Rng && rng, I p, N n, T && t) const
-            {
-                return insert(
-                    static_cast<Rng &&>(rng), std::move(p), n, static_cast<T &&>(t));
-            }
-
-            template(typename Rng, typename P, typename I, typename S)(
-                /// \pre
-                requires range<Rng> AND input_iterator<P> AND sentinel_for<S, I> AND
-                (!range<S>)) //
-            insert_result_t<Rng, P, I, S> operator()(Rng && rng, P p, I i, S j) const
-            {
-                return insert(
-                    static_cast<Rng &&>(rng), std::move(p), std::move(i), std::move(j));
-            }
-        };
-    } // namespace adl_insert_detail
-    /// \endcond
-
-    /// \ingroup group-actions
-    RANGES_INLINE_VARIABLE(adl_insert_detail::insert_fn, insert)
-
-    namespace actions
-    {
-        using ranges::insert;
-    }
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/action/join.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/action/join.hpp
deleted file mode 100644
index e49f6ae3..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/action/join.hpp
+++ /dev/null
@@ -1,69 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ACTION_JOIN_HPP
-#define RANGES_V3_ACTION_JOIN_HPP
-
-#include <vector>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/action/action.hpp>
-#include <range/v3/action/concepts.hpp>
-#include <range/v3/action/push_back.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-actions
-    /// @{
-    namespace actions
-    {
-        template<typename Rng>
-        using join_action_value_t_ =
-            meta::if_c<(bool)ranges::container<range_value_t<Rng>>, //
-                       range_value_t<Rng>,                          //
-                       std::vector<range_value_t<range_value_t<Rng>>>>;
-
-        struct join_fn
-        {
-            template(typename Rng)(
-                /// \pre
-                requires input_range<Rng> AND input_range<range_value_t<Rng>> AND
-                    semiregular<join_action_value_t_<Rng>>)
-            join_action_value_t_<Rng> operator()(Rng && rng) const
-            {
-                join_action_value_t_<Rng> ret;
-                auto last = ranges::end(rng);
-                for(auto it = begin(rng); it != last; ++it)
-                    push_back(ret, *it);
-                return ret;
-            }
-        };
-
-        /// \relates actions::join_fn
-        /// \sa action_closure
-        RANGES_INLINE_VARIABLE(action_closure<join_fn>, join)
-    } // namespace actions
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/action/push_back.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/action/push_back.hpp
deleted file mode 100644
index 7d7ad7b9..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/action/push_back.hpp
+++ /dev/null
@@ -1,150 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ACTION_PUSH_BACK_HPP
-#define RANGES_V3_ACTION_PUSH_BACK_HPP
-
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/action/action.hpp>
-#include <range/v3/action/insert.hpp>
-#include <range/v3/detail/with_braced_init_args.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-actions
-    /// @{
-
-    /// \cond
-    namespace adl_push_back_detail
-    {
-        /// \endcond
-        template<typename Cont, typename T>
-        using push_back_t = decltype(static_cast<void>(
-            unwrap_reference(std::declval<Cont &>()).push_back(std::declval<T>())));
-
-        template<typename Cont, typename Rng>
-        using insert_t = decltype(static_cast<void>(
-            ranges::insert(std::declval<Cont &>(), std::declval<sentinel_t<Cont>>(),
-                           std::declval<Rng>())));
-
-        template(typename Cont, typename T)(
-            /// \pre
-            requires lvalue_container_like<Cont> AND
-                (!range<T>) AND constructible_from<range_value_t<Cont>, T>)
-        push_back_t<Cont, T> push_back(Cont && cont, T && t)
-        {
-            unwrap_reference(cont).push_back(static_cast<T &&>(t));
-        }
-
-        template(typename Cont, typename Rng)(
-            /// \pre
-            requires lvalue_container_like<Cont> AND range<Rng>)
-        insert_t<Cont, Rng> push_back(Cont && cont, Rng && rng)
-        {
-            ranges::insert(cont, end(cont), static_cast<Rng &&>(rng));
-        }
-
-        /// \cond
-        // clang-format off
-        template<typename Rng, typename T>
-        CPP_requires(can_push_back_frag_,
-            requires(Rng && rng, T && t) //
-            (
-                push_back(rng, (T &&) t)
-            ));
-        template<typename Rng, typename T>
-        CPP_concept can_push_back_ =
-            CPP_requires_ref(adl_push_back_detail::can_push_back_frag_, Rng, T);
-        // clang-format on
-        /// \endcond
-
-        struct push_back_fn
-        {
-            template<typename T>
-            constexpr auto operator()(T && val) const
-            {
-                return make_action_closure(
-                    bind_back(push_back_fn{}, static_cast<T &&>(val)));
-            }
-
-            template(typename T)(
-                /// \pre
-                requires range<T &>)
-            constexpr auto operator()(T & t) const
-            {
-                return make_action_closure(
-                    bind_back(push_back_fn{}, detail::reference_wrapper_<T>(t)));
-            }
-
-            template<typename T>
-            constexpr auto operator()(std::initializer_list<T> val) const
-            {
-                return make_action_closure(bind_back(push_back_fn{}, val));
-            }
-
-            template(typename Rng, typename T)(
-                /// \pre
-                requires input_range<Rng> AND can_push_back_<Rng, T> AND
-                (range<T> || constructible_from<range_value_t<Rng>, T>)) //
-            Rng operator()(Rng && rng, T && t) const //
-            {
-                push_back(rng, static_cast<T &&>(t));
-                return static_cast<Rng &&>(rng);
-            }
-
-            template(typename Rng, typename T)(
-                /// \pre
-                requires input_range<Rng> AND
-                        can_push_back_<Rng, std::initializer_list<T>> AND
-                            constructible_from<range_value_t<Rng>, T const &>)
-            Rng operator()(Rng && rng, std::initializer_list<T> t) const //
-            {
-                push_back(rng, t);
-                return static_cast<Rng &&>(rng);
-            }
-
-            /// \cond
-            template<typename Rng, typename T>
-            invoke_result_t<push_back_fn, Rng, T &> //
-            operator()(Rng && rng, detail::reference_wrapper_<T> r) const
-            {
-                return (*this)(static_cast<Rng &&>(rng), r.get());
-            }
-            /// \endcond
-        };
-        /// \cond
-    } // namespace adl_push_back_detail
-    /// \endcond
-
-    namespace actions
-    {
-        RANGES_INLINE_VARIABLE(adl_push_back_detail::push_back_fn, push_back)
-    } // namespace actions
-
-    using actions::push_back;
-
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/action/push_front.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/action/push_front.hpp
deleted file mode 100644
index de25f092..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/action/push_front.hpp
+++ /dev/null
@@ -1,150 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ACTION_PUSH_FRONT_HPP
-#define RANGES_V3_ACTION_PUSH_FRONT_HPP
-
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/action/action.hpp>
-#include <range/v3/action/insert.hpp>
-#include <range/v3/detail/with_braced_init_args.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-actions
-    /// @{
-
-    /// \cond
-    namespace adl_push_front_detail
-    {
-        /// \endcond
-        template<typename Cont, typename T>
-        using push_front_t = decltype(static_cast<void>(
-            unwrap_reference(std::declval<Cont &>()).push_front(std::declval<T>())));
-
-        template<typename Cont, typename Rng>
-        using insert_t = decltype(static_cast<void>(
-            ranges::insert(std::declval<Cont &>(), std::declval<iterator_t<Cont>>(),
-                           std::declval<Rng>())));
-
-        template(typename Cont, typename T)(
-            /// \pre
-            requires lvalue_container_like<Cont> AND
-                (!range<T>) AND constructible_from<range_value_t<Cont>, T>)
-        push_front_t<Cont, T> push_front(Cont && cont, T && t)
-        {
-            unwrap_reference(cont).push_front(static_cast<T &&>(t));
-        }
-
-        template(typename Cont, typename Rng)(
-            /// \pre
-            requires lvalue_container_like<Cont> AND range<Rng>)
-        insert_t<Cont, Rng> push_front(Cont && cont, Rng && rng)
-        {
-            ranges::insert(cont, begin(cont), static_cast<Rng &&>(rng));
-        }
-
-        /// \cond
-        // clang-format off
-        template<typename Rng, typename T>
-        CPP_requires(can_push_front_frag_,
-            requires(Rng && rng, T && t) //
-            (
-                push_front(rng, (T &&) t)
-            ));
-        template<typename Rng, typename T>
-        CPP_concept can_push_front_ =
-            CPP_requires_ref(adl_push_front_detail::can_push_front_frag_, Rng, T);
-        // clang-format on
-        /// \endcond
-
-        struct push_front_fn
-        {
-            template<typename T>
-            constexpr auto operator()(T && val) const
-            {
-                return make_action_closure(
-                    bind_back(push_front_fn{}, static_cast<T &&>(val)));
-            }
-
-            template<typename T>
-            constexpr auto operator()(std::initializer_list<T> val) const
-            {
-                return make_action_closure(bind_back(push_front_fn{}, val));
-            }
-
-            template(typename T)(
-                /// \pre
-                requires range<T &>)
-            constexpr auto operator()(T & t) const
-            {
-                return make_action_closure(
-                    bind_back(push_front_fn{}, detail::reference_wrapper_<T>(t)));
-            }
-
-            template(typename Rng, typename T)(
-                /// \pre
-                requires input_range<Rng> AND can_push_front_<Rng, T> AND
-                    (range<T> || constructible_from<range_value_t<Rng>, T>)) //
-            Rng operator()(Rng && rng, T && t) const //
-            {
-                push_front(rng, static_cast<T &&>(t));
-                return static_cast<Rng &&>(rng);
-            }
-
-            template(typename Rng, typename T)(
-                /// \pre
-                requires input_range<Rng> AND
-                    can_push_front_<Rng, std::initializer_list<T>> AND
-                    constructible_from<range_value_t<Rng>, T const &>)
-            Rng operator()(Rng && rng, std::initializer_list<T> t) const //
-            {
-                push_front(rng, t);
-                return static_cast<Rng &&>(rng);
-            }
-
-            /// \cond
-            template<typename Rng, typename T>
-            invoke_result_t<push_front_fn, Rng, T &> //
-            operator()(Rng && rng, detail::reference_wrapper_<T> r) const
-            {
-                return (*this)(static_cast<Rng &&>(rng), r.get());
-            }
-            /// \endcond
-        };
-    /// \cond
-    } // namespace adl_push_front_detail
-    /// \endcond
-
-    namespace actions
-    {
-        RANGES_INLINE_VARIABLE(adl_push_front_detail::push_front_fn, push_front)
-    } // namespace actions
-
-    using actions::push_front;
-
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/action/remove.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/action/remove.hpp
deleted file mode 100644
index b2038dcf..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/action/remove.hpp
+++ /dev/null
@@ -1,76 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Andrey Diduh 2019
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ACTION_REMOVE_HPP
-#define RANGES_V3_ACTION_REMOVE_HPP
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/action/action.hpp>
-#include <range/v3/action/erase.hpp>
-#include <range/v3/algorithm/remove.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-actions
-    /// @{
-    namespace actions
-    {
-        struct remove_fn
-        {
-            template(typename V, typename P)(
-                /// \pre
-                requires (!range<V>))
-            constexpr auto operator()(V && value, P proj) const
-            {
-                return make_action_closure(
-                    bind_back(remove_fn{}, static_cast<V &&>(value), std::move(proj)));
-            }
-
-            template<typename V>
-            constexpr auto operator()(V && value) const
-            {
-                return make_action_closure(
-                    bind_back(remove_fn{}, static_cast<V &&>(value), identity{}));
-            }
-
-            template(typename Rng, typename V, typename P = identity)(
-                /// \pre
-                requires forward_range<Rng> AND permutable<iterator_t<Rng>> AND
-                        erasable_range<Rng, iterator_t<Rng>, sentinel_t<Rng>> AND
-                            indirect_relation<equal_to, projected<iterator_t<Rng>, P>,
-                                              V const *>)
-            Rng operator()(Rng && rng, V const & value, P proj = {}) const
-            {
-                auto it = ranges::remove(rng, value, std::move(proj));
-                ranges::erase(rng, it, ranges::end(rng));
-                return static_cast<Rng &&>(rng);
-            }
-        };
-
-        /// \relates actions::remove_fn
-        RANGES_INLINE_VARIABLE(remove_fn, remove)
-    } // namespace actions
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/action/remove_if.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/action/remove_if.hpp
deleted file mode 100644
index 3149501e..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/action/remove_if.hpp
+++ /dev/null
@@ -1,72 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ACTION_REMOVE_IF_HPP
-#define RANGES_V3_ACTION_REMOVE_IF_HPP
-
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/action/action.hpp>
-#include <range/v3/action/erase.hpp>
-#include <range/v3/algorithm/remove_if.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    // TODO Look at all the special cases handled by erase_if in Library Fundamentals 2
-
-    /// \addtogroup group-actions
-    /// @{
-    namespace actions
-    {
-        struct remove_if_fn
-        {
-            template(typename C, typename P = identity)(
-                /// \pre
-                requires (!range<C>))
-            constexpr auto operator()(C pred, P proj = P{}) const
-            {
-                return make_action_closure(
-                    bind_back(remove_if_fn{}, std::move(pred), std::move(proj)));
-            }
-
-            template(typename Rng, typename C, typename P = identity)(
-                /// \pre
-                requires forward_range<Rng> AND
-                    erasable_range<Rng &, iterator_t<Rng>, iterator_t<Rng>> AND
-                        permutable<iterator_t<Rng>> AND
-                            indirect_unary_predicate<C, projected<iterator_t<Rng>, P>>)
-            Rng operator()(Rng && rng, C pred, P proj = P{}) const
-            {
-                auto it = ranges::remove_if(rng, std::move(pred), std::move(proj));
-                ranges::erase(rng, it, ranges::end(rng));
-                return static_cast<Rng &&>(rng);
-            }
-        };
-
-        /// \relates actions::remove_if_fn
-        RANGES_INLINE_VARIABLE(remove_if_fn, remove_if)
-    } // namespace actions
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/action/reverse.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/action/reverse.hpp
deleted file mode 100644
index 6c392699..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/action/reverse.hpp
+++ /dev/null
@@ -1,56 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//  Copyright Gonzalo Brito Gadeschi 2017
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ACTION_REVERSE_HPP
-#define RANGES_V3_ACTION_REVERSE_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/action/action.hpp>
-#include <range/v3/algorithm/reverse.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-actions
-    /// @{
-    namespace actions
-    {
-        /// Reversed the source range in-place.
-        struct reverse_fn
-        {
-            template(typename Rng)(
-                /// \pre
-                requires bidirectional_range<Rng> AND permutable<iterator_t<Rng>>)
-            Rng operator()(Rng && rng) const
-            {
-                ranges::reverse(rng);
-                return static_cast<Rng &&>(rng);
-            }
-        };
-
-        /// \relates actions::reverse_fn
-        /// \sa action_closure
-        RANGES_INLINE_VARIABLE(action_closure<reverse_fn>, reverse)
-    } // namespace actions
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/action/shuffle.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/action/shuffle.hpp
deleted file mode 100644
index 9c542380..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/action/shuffle.hpp
+++ /dev/null
@@ -1,86 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Filip Matzner 2015
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ACTION_SHUFFLE_HPP
-#define RANGES_V3_ACTION_SHUFFLE_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/action/action.hpp>
-#include <range/v3/algorithm/shuffle.hpp>
-#include <range/v3/functional/bind.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-actions
-    /// @{
-    namespace actions
-    {
-        struct shuffle_fn
-        {
-            template(typename Gen)(
-                /// \pre
-                requires uniform_random_bit_generator<Gen>)
-            constexpr auto operator()(Gen & gen) const
-            {
-                return make_action_closure(
-                    bind_back(shuffle_fn{}, detail::reference_wrapper_<Gen>(gen)));
-            }
-
-            template(typename Gen)(
-                /// \pre
-                requires uniform_random_bit_generator<Gen>)
-            constexpr auto operator()(Gen && gen) const
-            {
-                return make_action_closure(
-                    bind_back(shuffle_fn{}, static_cast<Gen &&>(gen)));
-            }
-
-            template(typename Rng, typename Gen)(
-                /// \pre
-                requires random_access_range<Rng> AND permutable<iterator_t<Rng>> AND
-                    uniform_random_bit_generator<std::remove_reference_t<Gen>> AND
-                    convertible_to<invoke_result_t<Gen &>, range_difference_t<Rng>>)
-            Rng operator()(Rng && rng, Gen && gen) const
-            {
-                ranges::shuffle(rng, static_cast<Gen &&>(gen));
-                return static_cast<Rng &&>(rng);
-            }
-
-            /// \cond
-            template<typename Rng, typename T>
-            invoke_result_t<shuffle_fn, Rng, T &> //
-            operator()(Rng && rng, detail::reference_wrapper_<T> r) const
-            {
-                return (*this)(static_cast<Rng &&>(rng), r.get());
-            }
-            /// \endcond
-        };
-
-        /// \relates actions::shuffle_fn
-        /// \sa `action_closure`
-        RANGES_INLINE_VARIABLE(shuffle_fn, shuffle)
-    } // namespace actions
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/action/slice.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/action/slice.hpp
deleted file mode 100644
index fb6b990c..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/action/slice.hpp
+++ /dev/null
@@ -1,164 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ACTION_SLICE_HPP
-#define RANGES_V3_ACTION_SLICE_HPP
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/action/action.hpp>
-#include <range/v3/action/erase.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/interface.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-actions
-    /// @{
-    namespace actions
-    {
-        struct slice_fn
-        {
-        private:
-            template<typename D>
-            using diff_t = range_difference_t<D>;
-
-        public:
-            // Overloads for the pipe syntax: rng | actions::slice(from, to)
-            template(typename D)(
-                /// \pre
-                requires integral<D>)
-            constexpr auto operator()(D from, D to) const
-            {
-                return make_action_closure(bind_back(slice_fn{}, from, to));
-            }
-            template(typename D)(
-                /// \pre
-                requires integral<D>)
-            constexpr auto operator()(D from, detail::from_end_<D> to) const
-            {
-                return make_action_closure(bind_back(slice_fn{}, from, to));
-            }
-            template(typename D)(
-                /// \pre
-                requires integral<D>)
-            constexpr auto operator()(detail::from_end_<D> from, detail::from_end_<D> to)
-                const
-            {
-                return make_action_closure(bind_back(slice_fn{}, from, to));
-            }
-            template(typename D)(
-                /// \pre
-                requires integral<D>)
-            constexpr auto operator()(D from, end_fn const & to) const
-            {
-                return make_action_closure(bind_back(slice_fn{}, from, to));
-            }
-            template(typename D)(
-                /// \pre
-                requires integral<D>)
-            constexpr auto operator()(detail::from_end_<D> from, end_fn const & to) const
-            {
-                return make_action_closure(bind_back(slice_fn{}, from, to));
-            }
-
-            template(typename Rng, typename I = iterator_t<Rng>)(
-                /// \pre
-                requires forward_range<Rng> AND erasable_range<Rng &, I, I>)
-            Rng operator()(Rng && rng, diff_t<Rng> from, diff_t<Rng> to) const
-            {
-                RANGES_EXPECT(0 <= from && 0 <= to && from <= to);
-                RANGES_EXPECT(!sized_range<Rng> || to <= distance(rng));
-                ranges::actions::erase(rng, begin(rng), next(begin(rng), from));
-                ranges::actions::erase(rng, next(begin(rng), to - from), end(rng));
-                return static_cast<Rng &&>(rng);
-            }
-
-            template(typename Rng, typename I = iterator_t<Rng>)(
-                /// \pre
-                requires bidirectional_range<Rng> AND erasable_range<Rng &, I, I>)
-            Rng operator()(Rng && rng,
-                           diff_t<Rng> from,
-                           detail::from_end_<diff_t<Rng>> to) const
-            {
-                RANGES_EXPECT(0 <= from && to.dist_ <= 0);
-                RANGES_EXPECT(!sized_range<Rng> || from - to.dist_ <= distance(rng));
-                ranges::actions::erase(rng, begin(rng), next(begin(rng), from));
-                if(to.dist_ != 0)
-                {
-                    auto const last = next(begin(rng), end(rng));
-                    ranges::actions::erase(rng, prev(last, -to.dist_), last);
-                }
-                return static_cast<Rng &&>(rng);
-            }
-
-            template(typename Rng, typename I = iterator_t<Rng>)(
-                /// \pre
-                requires bidirectional_range<Rng> AND erasable_range<Rng &, I, I>)
-            Rng operator()(Rng && rng,
-                           detail::from_end_<diff_t<Rng>> from,
-                           detail::from_end_<diff_t<Rng>> to) const
-            {
-                RANGES_EXPECT(from.dist_ <= 0 && to.dist_ <= 0 && from.dist_ <= to.dist_);
-                RANGES_EXPECT(!sized_range<Rng> || 0 <= distance(rng) + from.dist_);
-                auto last = next(begin(rng), end(rng));
-                ranges::actions::erase(rng, prev(last, -to.dist_), last);
-                last = next(begin(rng), end(rng));
-                ranges::actions::erase(
-                    rng, begin(rng), prev(last, to.dist_ - from.dist_));
-                return static_cast<Rng &&>(rng);
-            }
-
-            template(typename Rng, typename I = iterator_t<Rng>)(
-                /// \pre
-                requires forward_range<Rng> AND erasable_range<Rng &, I, I>)
-            Rng operator()(Rng && rng, diff_t<Rng> from, end_fn const &) const
-            {
-                RANGES_EXPECT(0 <= from);
-                RANGES_EXPECT(!sized_range<Rng> || from <= distance(rng));
-                ranges::actions::erase(rng, begin(rng), next(begin(rng), from));
-                return static_cast<Rng &&>(rng);
-            }
-
-            template(typename Rng, typename I = iterator_t<Rng>)(
-                /// \pre
-                requires bidirectional_range<Rng> AND erasable_range<Rng &, I, I>)
-            Rng operator()(Rng && rng,
-                           detail::from_end_<diff_t<Rng>> from,
-                           end_fn const &) const
-            {
-                RANGES_EXPECT(from.dist_ <= 0);
-                RANGES_EXPECT(!sized_range<Rng> || 0 <= distance(rng) + from.dist_);
-                auto const last = next(begin(rng), end(rng));
-                ranges::actions::erase(rng, begin(rng), prev(last, -from.dist_));
-                return static_cast<Rng &&>(rng);
-            }
-        };
-
-        /// \relates actions::slice_fn
-        RANGES_INLINE_VARIABLE(slice_fn, slice)
-    } // namespace actions
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/action/sort.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/action/sort.hpp
deleted file mode 100644
index 86d771c6..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/action/sort.hpp
+++ /dev/null
@@ -1,66 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ACTION_SORT_HPP
-#define RANGES_V3_ACTION_SORT_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/action/action.hpp>
-#include <range/v3/algorithm/sort.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-actions
-    /// @{
-    namespace actions
-    {
-        struct sort_fn
-        {
-            template(typename C, typename P = identity)(
-                /// \pre
-                requires (!range<C>))
-            constexpr auto operator()(C pred, P proj = {}) const
-            {
-                return make_action_closure(
-                    bind_back(sort_fn{}, std::move(pred), std::move(proj)));
-            }
-
-            template(typename Rng, typename C = less, typename P = identity)(
-                /// \pre
-                requires forward_range<Rng> AND sortable<iterator_t<Rng>, C, P>)
-            Rng operator()(Rng && rng, C pred = {}, P proj = {}) const
-            {
-                ranges::sort(rng, std::move(pred), std::move(proj));
-                return static_cast<Rng &&>(rng);
-            }
-        };
-
-        /// \relates actions::sort_fn
-        /// \sa action_closure
-        RANGES_INLINE_VARIABLE(action_closure<sort_fn>, sort)
-    } // namespace actions
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/action/split.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/action/split.hpp
deleted file mode 100644
index 0f7f5649..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/action/split.hpp
+++ /dev/null
@@ -1,109 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ACTION_SPLIT_HPP
-#define RANGES_V3_ACTION_SPLIT_HPP
-
-#include <vector>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/action/action.hpp>
-#include <range/v3/action/concepts.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/conversion.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/split.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-actions
-    /// @{
-    namespace actions
-    {
-        struct split_fn
-        {
-            template<typename Rng>
-            using split_value_t =
-                meta::if_c<(bool)ranges::container<Rng>, //
-                           uncvref_t<Rng>, std::vector<range_value_t<Rng>>>;
-
-            template(typename T)(
-                /// \pre
-                requires range<T &>)
-            constexpr auto operator()(T & t) const
-            {
-                return make_action_closure(
-                    bind_back(split_fn{}, detail::reference_wrapper_<T>(t)));
-            }
-
-            template<typename T>
-            constexpr auto operator()(T && t) const
-            {
-                return make_action_closure(bind_back(split_fn{}, static_cast<T &&>(t)));
-            }
-
-            // BUGBUG something is not right with the actions. It should be possible
-            // to move a container into a split and have elements moved into the result.
-            template(typename Rng)(
-                /// \pre
-                requires input_range<Rng> AND indirectly_comparable<
-                        iterator_t<Rng>, range_value_t<Rng> const *, ranges::equal_to>)
-            std::vector<split_value_t<Rng>> //
-            operator()(Rng && rng, range_value_t<Rng> val) const
-            {
-                return views::split(rng, std::move(val)) |
-                       to<std::vector<split_value_t<Rng>>>();
-            }
-
-            template(typename Rng, typename Pattern)(
-                /// \pre
-                requires input_range<Rng> AND viewable_range<Pattern> AND
-                    forward_range<Pattern> AND
-                    indirectly_comparable<
-                        iterator_t<Rng>,
-                        iterator_t<Pattern>,
-                        ranges::equal_to> AND
-                    (forward_range<Rng> || detail::tiny_range<Pattern>)) //
-            std::vector<split_value_t<Rng>> operator()(Rng && rng, Pattern && pattern)
-                const
-            {
-                return views::split(rng, static_cast<Pattern &&>(pattern)) |
-                       to<std::vector<split_value_t<Rng>>>();
-            }
-
-            /// \cond
-            template<typename Rng, typename T>
-            invoke_result_t<split_fn, Rng, T &> //
-            operator()(Rng && rng, detail::reference_wrapper_<T> r) const
-            {
-                return (*this)(static_cast<Rng &&>(rng), r.get());
-            }
-            /// \endcond
-        };
-
-        /// \relates actions::split_fn
-        RANGES_INLINE_VARIABLE(split_fn, split)
-    } // namespace actions
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/action/split_when.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/action/split_when.hpp
deleted file mode 100644
index 4bc8d7eb..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/action/split_when.hpp
+++ /dev/null
@@ -1,92 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ACTION_SPLIT_WHEN_HPP
-#define RANGES_V3_ACTION_SPLIT_WHEN_HPP
-
-#include <vector>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/action/action.hpp>
-#include <range/v3/action/concepts.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/conversion.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/split_when.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-actions
-    /// @{
-    namespace actions
-    {
-        struct split_when_fn
-        {
-            template<typename Rng>
-            using split_value_t =
-                meta::if_c<(bool)ranges::container<Rng>, //
-                           uncvref_t<Rng>, std::vector<range_value_t<Rng>>>;
-
-            template<typename Fun>
-            constexpr auto operator()(Fun fun) const
-            {
-                return make_action_closure(
-                    bind_back(split_when_fn{}, static_cast<Fun &&>(fun)));
-            }
-
-            // BUGBUG something is not right with the actions. It should be possible
-            // to move a container into a split and have elements moved into the result.
-            template(typename Rng, typename Fun)(
-                /// \pre
-                requires forward_range<Rng> AND
-                        invocable<Fun &, iterator_t<Rng>, sentinel_t<Rng>> AND
-                            invocable<Fun &, iterator_t<Rng>, iterator_t<Rng>> AND
-                                copy_constructible<Fun> AND
-                                    convertible_to<invoke_result_t<Fun &, iterator_t<Rng>,
-                                                                   sentinel_t<Rng>>,
-                                                   std::pair<bool, iterator_t<Rng>>>)
-            std::vector<split_value_t<Rng>> operator()(Rng && rng, Fun fun) const
-            {
-                return views::split_when(rng, std::move(fun)) |
-                       to<std::vector<split_value_t<Rng>>>();
-            }
-
-            template(typename Rng, typename Fun)(
-                /// \pre
-                requires forward_range<Rng> AND
-                        predicate<Fun const &, range_reference_t<Rng>> AND
-                            copy_constructible<Fun>)
-            std::vector<split_value_t<Rng>> operator()(Rng && rng, Fun fun) const
-            {
-                return views::split_when(rng, std::move(fun)) |
-                       to<std::vector<split_value_t<Rng>>>();
-            }
-        };
-
-        /// \relates actions::split_when_fn
-        RANGES_INLINE_VARIABLE(split_when_fn, split_when)
-    } // namespace actions
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/action/stable_sort.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/action/stable_sort.hpp
deleted file mode 100644
index 9542c442..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/action/stable_sort.hpp
+++ /dev/null
@@ -1,66 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ACTION_STABLE_SORT_HPP
-#define RANGES_V3_ACTION_STABLE_SORT_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/action/action.hpp>
-#include <range/v3/algorithm/stable_sort.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-actions
-    /// @{
-    namespace actions
-    {
-        struct stable_sort_fn
-        {
-            template(typename C, typename P = identity)(
-                /// \pre
-                requires (!range<C>))
-            constexpr auto operator()(C pred, P proj = P{}) const
-            {
-                return make_action_closure(
-                    bind_back(stable_sort_fn{}, std::move(pred), std::move(proj)));
-            }
-
-            template(typename Rng, typename C = less, typename P = identity)(
-                /// \pre
-                requires forward_range<Rng> AND sortable<iterator_t<Rng>, C, P>)
-            Rng operator()(Rng && rng, C pred = C{}, P proj = P{}) const
-            {
-                ranges::stable_sort(rng, std::move(pred), std::move(proj));
-                return static_cast<Rng &&>(rng);
-            }
-        };
-
-        /// \relates actions::stable_sort_fn
-        /// \sa action_closure
-        RANGES_INLINE_VARIABLE(action_closure<stable_sort_fn>, stable_sort)
-    } // namespace actions
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/action/stride.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/action/stride.hpp
deleted file mode 100644
index 3a32e775..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/action/stride.hpp
+++ /dev/null
@@ -1,81 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ACTION_STRIDE_HPP
-#define RANGES_V3_ACTION_STRIDE_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/action/action.hpp>
-#include <range/v3/action/erase.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-actions
-    /// @{
-    namespace actions
-    {
-        struct stride_fn
-        {
-            template(typename D)(
-                /// \pre
-                requires detail::integer_like_<D>)
-            constexpr auto operator()(D step) const
-            {
-                return make_action_closure(bind_back(stride_fn{}, step));
-            }
-
-            template(typename Rng, typename D = range_difference_t<Rng>)(
-                /// \pre
-                requires forward_range<Rng> AND
-                    erasable_range<Rng &, iterator_t<Rng>, sentinel_t<Rng>> AND
-                    permutable<iterator_t<Rng>>)
-            Rng operator()(Rng && rng, range_difference_t<Rng> const step) const
-            {
-                using I = iterator_t<Rng>;
-                using S = sentinel_t<Rng>;
-                RANGES_EXPECT(0 < step);
-                if(1 < step)
-                {
-                    I first = ranges::begin(rng);
-                    S const last = ranges::end(rng);
-                    if(first != last)
-                    {
-                        for(I i = ranges::next(++first, step - 1, last); i != last;
-                            advance(i, step, last), ++first)
-                        {
-                            *first = iter_move(i);
-                        }
-                    }
-                    ranges::actions::erase(rng, first, last);
-                }
-                return static_cast<Rng &&>(rng);
-            }
-        };
-
-        /// \relates actions::stride_fn
-        RANGES_INLINE_VARIABLE(stride_fn, stride)
-    } // namespace actions
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/action/take.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/action/take.hpp
deleted file mode 100644
index d17c56fe..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/action/take.hpp
+++ /dev/null
@@ -1,66 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ACTION_TAKE_HPP
-#define RANGES_V3_ACTION_TAKE_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/action/action.hpp>
-#include <range/v3/action/erase.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-actions
-    /// @{
-    namespace actions
-    {
-        struct take_fn
-        {
-            template(typename Int)(
-                /// \pre
-                requires detail::integer_like_<Int>)
-            constexpr auto operator()(Int n) const
-            {
-                return make_action_closure(bind_back(take_fn{}, n));
-            }
-
-            template(typename Rng)(
-                /// \pre
-                requires forward_range<Rng> AND
-                    erasable_range<Rng &, iterator_t<Rng>, sentinel_t<Rng>>)
-            Rng operator()(Rng && rng, range_difference_t<Rng> n) const
-            {
-                RANGES_EXPECT(n >= 0);
-                ranges::actions::erase(
-                    rng, ranges::next(begin(rng), n, end(rng)), end(rng));
-                return static_cast<Rng &&>(rng);
-            }
-        };
-
-        /// \relates actions::take_fn
-        RANGES_INLINE_VARIABLE(take_fn, take)
-    } // namespace actions
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/action/take_while.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/action/take_while.hpp
deleted file mode 100644
index 280a12b3..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/action/take_while.hpp
+++ /dev/null
@@ -1,66 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ACTION_TAKE_WHILE_HPP
-#define RANGES_V3_ACTION_TAKE_WHILE_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/action/action.hpp>
-#include <range/v3/action/erase.hpp>
-#include <range/v3/algorithm/find_if_not.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-actions
-    /// @{
-    namespace actions
-    {
-        struct take_while_fn
-        {
-            template(typename Fun)(
-                /// \pre
-                requires (!range<Fun>))
-            constexpr auto operator()(Fun fun) const
-            {
-                return make_action_closure(bind_back(take_while_fn{}, std::move(fun)));
-            }
-
-            template(typename Rng, typename Fun)(
-                /// \pre
-                requires forward_range<Rng> AND
-                    erasable_range<Rng &, iterator_t<Rng>, sentinel_t<Rng>> AND
-                    indirect_unary_predicate<Fun, iterator_t<Rng>>)
-            Rng operator()(Rng && rng, Fun fun) const
-            {
-                ranges::actions::erase(
-                    rng, find_if_not(begin(rng), end(rng), std::move(fun)), end(rng));
-                return static_cast<Rng &&>(rng);
-            }
-        };
-
-        /// \relates actions::take_while_fn
-        RANGES_INLINE_VARIABLE(take_while_fn, take_while)
-    } // namespace actions
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/action/transform.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/action/transform.hpp
deleted file mode 100644
index 0cfc5fb3..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/action/transform.hpp
+++ /dev/null
@@ -1,67 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ACTION_TRANSFORM_HPP
-#define RANGES_V3_ACTION_TRANSFORM_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/action/action.hpp>
-#include <range/v3/algorithm/transform.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-actions
-    /// @{
-    namespace actions
-    {
-        struct transform_fn
-        {
-            template(typename F, typename P = identity)(
-                /// \pre
-                requires (!range<F>))
-            constexpr auto operator()(F fun, P proj = P{}) const
-            {
-                return make_action_closure(
-                    bind_back(transform_fn{}, std::move(fun), std::move(proj)));
-            }
-
-            template(typename Rng, typename F, typename P = identity)(
-                /// \pre
-                requires input_range<Rng> AND copy_constructible<F> AND
-                    indirectly_writable<
-                        iterator_t<Rng>,
-                        indirect_result_t<F &, projected<iterator_t<Rng>, P>>>)
-            Rng operator()(Rng && rng, F fun, P proj = P{}) const
-            {
-                ranges::transform(rng, begin(rng), std::move(fun), std::move(proj));
-                return static_cast<Rng &&>(rng);
-            }
-        };
-
-        /// \relates actions::transform_fn
-        RANGES_INLINE_VARIABLE(transform_fn, transform)
-    } // namespace actions
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/action/unique.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/action/unique.hpp
deleted file mode 100644
index 66c0cfb1..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/action/unique.hpp
+++ /dev/null
@@ -1,70 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ACTION_UNIQUE_HPP
-#define RANGES_V3_ACTION_UNIQUE_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/action/action.hpp>
-#include <range/v3/action/erase.hpp>
-#include <range/v3/algorithm/unique.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-actions
-    /// @{
-    namespace actions
-    {
-        struct unique_fn
-        {
-            template(typename C, typename P = identity)(
-                /// \pre
-                requires (!range<C>))
-            constexpr auto operator()(C pred, P proj = P{}) const
-            {
-                return make_action_closure(
-                    bind_back(unique_fn{}, std::move(pred), std::move(proj)));
-            }
-
-            template(typename Rng, typename C = equal_to, typename P = identity)(
-                /// \pre
-                requires forward_range<Rng> AND
-                    erasable_range<Rng &, iterator_t<Rng>, sentinel_t<Rng>> AND
-                    sortable<iterator_t<Rng>, C, P>)
-            Rng operator()(Rng && rng, C pred = C{}, P proj = P{}) const
-            {
-                auto it = ranges::unique(rng, std::move(pred), std::move(proj));
-                ranges::erase(rng, it, end(rng));
-                return static_cast<Rng &&>(rng);
-            }
-        };
-
-        /// \relates detail::unique_fn
-        /// \sa action_closure
-        RANGES_INLINE_VARIABLE(action_closure<unique_fn>, unique)
-    } // namespace actions
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/action/unstable_remove_if.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/action/unstable_remove_if.hpp
deleted file mode 100644
index a663ef63..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/action/unstable_remove_if.hpp
+++ /dev/null
@@ -1,75 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Andrey Diduh 2019
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ACTION_UNSTABLE_REMOVE_IF_HPP
-#define RANGES_V3_ACTION_UNSTABLE_REMOVE_IF_HPP
-
-#include <utility>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/action/action.hpp>
-#include <range/v3/action/erase.hpp>
-#include <range/v3/algorithm/unstable_remove_if.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-actions
-    /// @{
-    namespace actions
-    {
-        struct unstable_remove_if_fn
-        {
-            template(typename C, typename P = identity)(
-                /// \pre
-                requires (!range<C>))
-            constexpr auto operator()(C pred, P proj = P{}) const
-            {
-                return make_action_closure(
-                    bind_back(unstable_remove_if_fn{}, std::move(pred), std::move(proj)));
-            }
-
-            template(typename Rng, typename C, typename P = identity)(
-                /// \pre
-                requires bidirectional_range<Rng> AND common_range<Rng> AND
-                    permutable<iterator_t<Rng>> AND
-                    indirect_unary_predicate<C, projected<iterator_t<Rng>, P>> AND
-                    erasable_range<Rng, iterator_t<Rng>, iterator_t<Rng>>)
-            Rng operator()(Rng && rng, C pred, P proj = P{}) const
-            {
-                auto it = ranges::unstable_remove_if(ranges::begin(rng),
-                                                     ranges::end(rng),
-                                                     std::move(pred),
-                                                     std::move(proj));
-                ranges::erase(rng, it, ranges::end(rng));
-                return static_cast<Rng &&>(rng);
-            }
-        };
-
-        /// \sa `actions::unstable_remove_if_fn`
-        RANGES_INLINE_VARIABLE(unstable_remove_if_fn, unstable_remove_if)
-    } // namespace actions
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif // RANGES_V3_ACTION_UNSTABLE_REMOVE_IF_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm.hpp
deleted file mode 100644
index 7700ae52..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm.hpp
+++ /dev/null
@@ -1,105 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ALGORITHM_HPP
-#define RANGES_V3_ALGORITHM_HPP
-
-#include <range/v3/algorithm/adjacent_find.hpp>
-#include <range/v3/algorithm/adjacent_remove_if.hpp>
-#include <range/v3/algorithm/all_of.hpp>
-#include <range/v3/algorithm/any_of.hpp>
-#include <range/v3/algorithm/binary_search.hpp>
-#include <range/v3/algorithm/contains.hpp>
-#include <range/v3/algorithm/copy.hpp>
-#include <range/v3/algorithm/copy_backward.hpp>
-#include <range/v3/algorithm/copy_if.hpp>
-#include <range/v3/algorithm/copy_n.hpp>
-#include <range/v3/algorithm/count.hpp>
-#include <range/v3/algorithm/count_if.hpp>
-#include <range/v3/algorithm/ends_with.hpp>
-#include <range/v3/algorithm/equal.hpp>
-#include <range/v3/algorithm/equal_range.hpp>
-#include <range/v3/algorithm/fill.hpp>
-#include <range/v3/algorithm/fill_n.hpp>
-#include <range/v3/algorithm/find.hpp>
-#include <range/v3/algorithm/find_end.hpp>
-#include <range/v3/algorithm/find_first_of.hpp>
-#include <range/v3/algorithm/find_if.hpp>
-#include <range/v3/algorithm/find_if_not.hpp>
-#include <range/v3/algorithm/for_each.hpp>
-#include <range/v3/algorithm/for_each_n.hpp>
-#include <range/v3/algorithm/generate.hpp>
-#include <range/v3/algorithm/generate_n.hpp>
-#include <range/v3/algorithm/heap_algorithm.hpp>
-#include <range/v3/algorithm/inplace_merge.hpp>
-#include <range/v3/algorithm/is_partitioned.hpp>
-#include <range/v3/algorithm/is_sorted.hpp>
-#include <range/v3/algorithm/is_sorted_until.hpp>
-#include <range/v3/algorithm/lexicographical_compare.hpp>
-#include <range/v3/algorithm/lower_bound.hpp>
-#include <range/v3/algorithm/max.hpp>
-#include <range/v3/algorithm/max_element.hpp>
-#include <range/v3/algorithm/merge.hpp>
-#include <range/v3/algorithm/min.hpp>
-#include <range/v3/algorithm/min_element.hpp>
-#include <range/v3/algorithm/minmax.hpp>
-#include <range/v3/algorithm/minmax_element.hpp>
-#include <range/v3/algorithm/mismatch.hpp>
-#include <range/v3/algorithm/move.hpp>
-#include <range/v3/algorithm/move_backward.hpp>
-#include <range/v3/algorithm/none_of.hpp>
-#include <range/v3/algorithm/nth_element.hpp>
-#include <range/v3/algorithm/partial_sort.hpp>
-#include <range/v3/algorithm/partial_sort_copy.hpp>
-#include <range/v3/algorithm/partition.hpp>
-#include <range/v3/algorithm/partition_copy.hpp>
-#include <range/v3/algorithm/partition_point.hpp>
-#include <range/v3/algorithm/permutation.hpp>
-#include <range/v3/algorithm/remove.hpp>
-#include <range/v3/algorithm/remove_copy.hpp>
-#include <range/v3/algorithm/remove_copy_if.hpp>
-#include <range/v3/algorithm/remove_if.hpp>
-#include <range/v3/algorithm/replace.hpp>
-#include <range/v3/algorithm/replace_copy.hpp>
-#include <range/v3/algorithm/replace_copy_if.hpp>
-#include <range/v3/algorithm/replace_if.hpp>
-#include <range/v3/algorithm/reverse.hpp>
-#include <range/v3/algorithm/reverse_copy.hpp>
-#include <range/v3/algorithm/rotate.hpp>
-#include <range/v3/algorithm/rotate_copy.hpp>
-#include <range/v3/algorithm/sample.hpp>
-#include <range/v3/algorithm/search.hpp>
-#include <range/v3/algorithm/search_n.hpp>
-#include <range/v3/algorithm/set_algorithm.hpp>
-#include <range/v3/algorithm/shuffle.hpp>
-#include <range/v3/algorithm/sort.hpp>
-#include <range/v3/algorithm/stable_partition.hpp>
-#include <range/v3/algorithm/stable_sort.hpp>
-#include <range/v3/algorithm/starts_with.hpp>
-#include <range/v3/algorithm/swap_ranges.hpp>
-#include <range/v3/algorithm/transform.hpp>
-#include <range/v3/algorithm/unique.hpp>
-#include <range/v3/algorithm/unique_copy.hpp>
-#include <range/v3/algorithm/unstable_remove_if.hpp>
-#include <range/v3/algorithm/upper_bound.hpp>
-#include <range/v3/detail/config.hpp>
-
-// BUGBUG
-#include <range/v3/algorithm/aux_/equal_range_n.hpp>
-#include <range/v3/algorithm/aux_/lower_bound_n.hpp>
-#include <range/v3/algorithm/aux_/merge_n.hpp>
-#include <range/v3/algorithm/aux_/merge_n_with_buffer.hpp>
-#include <range/v3/algorithm/aux_/sort_n_with_buffer.hpp>
-#include <range/v3/algorithm/aux_/upper_bound_n.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/adjacent_find.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/adjacent_find.hpp
deleted file mode 100644
index b4ba14e2..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/adjacent_find.hpp
+++ /dev/null
@@ -1,77 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_ADJACENT_FIND_HPP
-#define RANGES_V3_ALGORITHM_ADJACENT_FIND_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(adjacent_find)
-        /// \brief function template \c adjacent_find
-        ///
-        /// range-based version of the \c adjacent_find std algorithm
-        ///
-        /// \pre `Rng` is a model of the `range` concept
-        /// \pre `C` is a model of the `BinaryPredicate` concept
-        template(typename I, typename S, typename C = equal_to, typename P = identity)(
-            /// \pre
-            requires forward_iterator<I> AND sentinel_for<S, I> AND
-            indirect_relation<C, projected<I, P>>)
-        I RANGES_FUNC(adjacent_find)(I first, S last, C pred = C{}, P proj = P{})
-        {
-            if(first == last)
-                return first;
-            auto inext = first;
-            for(; ++inext != last; first = inext)
-                if(invoke(pred, invoke(proj, *first), invoke(proj, *inext)))
-                    return first;
-            return inext;
-        }
-
-        /// \overload
-        template(typename Rng, typename C = equal_to, typename P = identity)(
-            /// \pre
-            requires forward_range<Rng> AND
-            indirect_relation<C, projected<iterator_t<Rng>, P>>)
-        borrowed_iterator_t<Rng> //
-        RANGES_FUNC(adjacent_find)(Rng && rng, C pred = C{}, P proj = P{}) //
-        {
-            return (*this)(begin(rng), end(rng), std::move(pred), std::move(proj));
-        }
-    RANGES_FUNC_END(adjacent_find)
-
-    namespace cpp20
-    {
-        using ranges::adjacent_find;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif // RANGE_ALGORITHM_ADJACENT_FIND_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/adjacent_remove_if.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/adjacent_remove_if.hpp
deleted file mode 100644
index ec6c1f8d..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/adjacent_remove_if.hpp
+++ /dev/null
@@ -1,94 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler
-//  Copyright Christopher Di Bella
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_ADJACENT_REMOVE_IF_HPP
-#define RANGES_V3_ALGORITHM_ADJACENT_REMOVE_IF_HPP
-
-#include <functional>
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/adjacent_find.hpp>
-#include <range/v3/algorithm/move.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/move.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(adjacent_remove_if)
-        /// \brief function \c adjacent_remove_if
-        ///
-        /// range-based version of the \c adjacent_remove_if algorithm
-        ///
-        /// \pre `Rng` is a model of the `forward_range` concept.
-        /// \pre `Pred` is a model of the `BinaryPredicate` concept.
-        template(typename I, typename S, typename Pred, typename Proj = identity)(
-            /// \pre
-            requires permutable<I> AND sentinel_for<S, I> AND
-                indirect_relation<Pred, projected<I, Proj>>)
-        I RANGES_FUNC(adjacent_remove_if)(I first, S last, Pred pred = {}, Proj proj = {})
-        {
-            first = adjacent_find(std::move(first), last, std::ref(pred), std::ref(proj));
-            if(first == last)
-                return first;
-
-            auto i = first;
-            for(auto j = ++i; ++j != last; ++i)
-            {
-                if(!invoke(pred, invoke(proj, *i), invoke(proj, *j)))
-                {
-                    *first = iter_move(i);
-                    ++first;
-                }
-            }
-
-            *first = iter_move(i);
-            ++first;
-            return first;
-        }
-
-        /// \overload
-        template(typename Rng, typename Pred, typename Proj = identity)(
-            /// \pre
-            requires forward_range<Rng> AND
-            indirect_relation<Pred, projected<iterator_t<Rng>, Proj>> AND
-            permutable<iterator_t<Rng>>)
-        borrowed_iterator_t<Rng>
-        RANGES_FUNC(adjacent_remove_if)(Rng && rng, Pred pred, Proj proj = {}) //
-        {
-            return (*this)(begin(rng), end(rng), std::move(pred), std::move(proj));
-        }
-    RANGES_FUNC_END(adjacent_remove_if)
-
-    namespace cpp20
-    {
-        using ranges::adjacent_remove_if;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif // RANGES_V3_ALGORITHM_ADJACENT_REMOVE_IF_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/all_of.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/all_of.hpp
deleted file mode 100644
index d6780896..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/all_of.hpp
+++ /dev/null
@@ -1,71 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Andrew Sutton 2014
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_ALL_OF_HPP
-#define RANGES_V3_ALGORITHM_ALL_OF_HPP
-
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(all_of)
-
-        /// \brief function template \c all_of
-        template(typename I, typename S, typename F, typename P = identity)(
-            /// \pre
-            requires input_iterator<I> AND sentinel_for<S, I> AND
-            indirect_unary_predicate<F, projected<I, P>>)
-        bool RANGES_FUNC(all_of)(I first, S last, F pred, P proj = P{}) //
-        {
-            for(; first != last; ++first)
-                if(!invoke(pred, invoke(proj, *first)))
-                    break;
-            return first == last;
-        }
-
-        /// \overload
-        template(typename Rng, typename F, typename P = identity)(
-            /// \pre
-            requires input_range<Rng> AND
-            indirect_unary_predicate<F, projected<iterator_t<Rng>, P>>)
-        bool RANGES_FUNC(all_of)(Rng && rng, F pred, P proj = P{}) //
-        {
-            return (*this)(begin(rng), end(rng), std::move(pred), std::move(proj));
-        }
-
-    RANGES_FUNC_END(all_of)
-
-    namespace cpp20
-    {
-        using ranges::all_of;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/any_of.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/any_of.hpp
deleted file mode 100644
index 324e815b..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/any_of.hpp
+++ /dev/null
@@ -1,72 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Andrew Sutton 2014
-//  Copyright Gonzalo Brito Gadeschi 2014
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_ANY_OF_HPP
-#define RANGES_V3_ALGORITHM_ANY_OF_HPP
-
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(any_of)
-
-        /// \brief function template \c any_of
-        template(typename I, typename S, typename F, typename P = identity)(
-            /// \pre
-            requires input_iterator<I> AND sentinel_for<S, I> AND
-            indirect_unary_predicate<F, projected<I, P>>)
-        bool RANGES_FUNC(any_of)(I first, S last, F pred, P proj = P{}) //
-        {
-            for(; first != last; ++first)
-                if(invoke(pred, invoke(proj, *first)))
-                    return true;
-            return false;
-        }
-
-        /// \overload
-        template(typename Rng, typename F, typename P = identity)(
-            /// \pre
-            requires input_range<Rng> AND
-            indirect_unary_predicate<F, projected<iterator_t<Rng>, P>>)
-        bool RANGES_FUNC(any_of)(Rng && rng, F pred, P proj = P{}) //
-        {
-            return (*this)(begin(rng), end(rng), std::move(pred), std::move(proj));
-        }
-
-    RANGES_FUNC_END(any_of)
-
-    namespace cpp20
-    {
-        using ranges::any_of;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/aux_/equal_range_n.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/aux_/equal_range_n.hpp
deleted file mode 100644
index 9ffc797f..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/aux_/equal_range_n.hpp
+++ /dev/null
@@ -1,92 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_AUX_EQUAL_RANGE_N_HPP
-#define RANGES_V3_ALGORITHM_AUX_EQUAL_RANGE_N_HPP
-
-#include <functional>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/aux_/lower_bound_n.hpp>
-#include <range/v3/algorithm/aux_/upper_bound_n.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/subrange.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    namespace aux
-    {
-        struct equal_range_n_fn
-        {
-            template(typename I, typename V, typename R = less, typename P = identity)(
-                /// \pre
-                requires forward_iterator<I> AND
-                    indirect_strict_weak_order<R, V const *, projected<I, P>>)
-            subrange<I> operator()(I first,
-                                   iter_difference_t<I> dist,
-                                   V const & val,
-                                   R pred = R{},
-                                   P proj = P{}) const
-            {
-                if(0 < dist)
-                {
-                    do
-                    {
-                        auto half = dist / 2;
-                        auto middle = ranges::next(first, half);
-                        auto && v = *middle;
-                        auto && pv = invoke(proj, (decltype(v) &&)v);
-                        if(invoke(pred, pv, val))
-                        {
-                            first = std::move(++middle);
-                            dist -= half + 1;
-                        }
-                        else if(invoke(pred, val, pv))
-                        {
-                            dist = half;
-                        }
-                        else
-                        {
-                            return {lower_bound_n(std::move(first),
-                                                  half,
-                                                  val,
-                                                  std::ref(pred),
-                                                  std::ref(proj)),
-                                    upper_bound_n(ranges::next(middle),
-                                                  dist - (half + 1),
-                                                  val,
-                                                  std::ref(pred),
-                                                  std::ref(proj))};
-                        }
-                    } while(0 != dist);
-                }
-                return {first, first};
-            }
-        };
-
-        RANGES_INLINE_VARIABLE(equal_range_n_fn, equal_range_n)
-    } // namespace aux
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/aux_/lower_bound_n.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/aux_/lower_bound_n.hpp
deleted file mode 100644
index 16c6f161..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/aux_/lower_bound_n.hpp
+++ /dev/null
@@ -1,83 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_AUX_LOWER_BOUND_N_HPP
-#define RANGES_V3_ALGORITHM_AUX_LOWER_BOUND_N_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/aux_/partition_point_n.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        // [&](auto&& i){ return invoke(pred, i, val); }
-        template<typename Pred, typename Val>
-        struct lower_bound_predicate
-        {
-            Pred & pred_;
-            Val & val_;
-
-            template<typename T>
-            bool operator()(T && t) const
-            {
-                return invoke(pred_, static_cast<T &&>(t), val_);
-            }
-        };
-
-        template<typename Pred, typename Val>
-        lower_bound_predicate<Pred, Val> make_lower_bound_predicate(Pred & pred,
-                                                                    Val & val)
-        {
-            return {pred, val};
-        }
-    } // namespace detail
-    /// \endcond
-
-    namespace aux
-    {
-        struct lower_bound_n_fn
-        {
-            template(typename I, typename V, typename C = less, typename P = identity)(
-                /// \pre
-                requires forward_iterator<I> AND
-                    indirect_strict_weak_order<C, V const *, projected<I, P>>)
-            I operator()(I first,
-                         iter_difference_t<I> d,
-                         V const & val,
-                         C pred = C{},
-                         P proj = P{}) const
-            {
-                return partition_point_n(std::move(first),
-                                         d,
-                                         detail::make_lower_bound_predicate(pred, val),
-                                         std::move(proj));
-            }
-        };
-
-        RANGES_INLINE_VARIABLE(lower_bound_n_fn, lower_bound_n)
-    } // namespace aux
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/aux_/merge_n.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/aux_/merge_n.hpp
deleted file mode 100644
index cb943495..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/aux_/merge_n.hpp
+++ /dev/null
@@ -1,116 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-// Copyright (c) 2009 Alexander Stepanov and Paul McJones
-//
-// Permission to use, copy, modify, distribute and sell this software
-// and its documentation for any purpose is hereby granted without
-// fee, provided that the above copyright notice appear in all copies
-// and that both that copyright notice and this permission notice
-// appear in supporting documentation. The authors make no
-// representations about the suitability of this software for any
-// purpose. It is provided "as is" without express or implied
-// warranty.
-//
-// Algorithms from
-// Elements of Programming
-// by Alexander Stepanov and Paul McJones
-// Addison-Wesley Professional, 2009
-#ifndef RANGES_V3_ALGORITHM_AUX_MERGE_N_HPP
-#define RANGES_V3_ALGORITHM_AUX_MERGE_N_HPP
-
-#include <tuple>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/copy_n.hpp>
-#include <range/v3/algorithm/result_types.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    namespace aux
-    {
-        template<typename I0, typename I1, typename O>
-        using merge_n_result = detail::in1_in2_out_result<I0, I1, O>;
-
-        struct merge_n_fn
-        {
-            template(typename I0, typename I1, typename O, typename C = less,
-                     typename P0 = identity, typename P1 = identity)(
-                /// \pre
-                requires mergeable<I0, I1, O, C, P0, P1>)
-            merge_n_result<I0, I1, O> operator()(I0 begin0,
-                                                 iter_difference_t<I0> n0,
-                                                 I1 begin1,
-                                                 iter_difference_t<I1> n1,
-                                                 O out,
-                                                 C r = C{},
-                                                 P0 p0 = P0{},
-                                                 P1 p1 = P1{}) const
-            {
-                using T = merge_n_result<I0, I1, O>;
-                auto n0orig = n0;
-                auto n1orig = n1;
-                auto b0 = uncounted(begin0);
-                auto b1 = uncounted(begin1);
-                while(true)
-                {
-                    if(0 == n0)
-                    {
-                        auto res = copy_n(b1, n1, out);
-                        begin0 = recounted(begin0, b0, n0orig);
-                        begin1 = recounted(begin1, res.in, n1orig);
-                        return T{begin0, begin1, res.out};
-                    }
-                    if(0 == n1)
-                    {
-                        auto res = copy_n(b0, n0, out);
-                        begin0 = recounted(begin0, res.in, n0orig);
-                        begin1 = recounted(begin1, b1, n1orig);
-                        return T{begin0, begin1, res.out};
-                    }
-                    if(invoke(r, invoke(p1, *b1), invoke(p0, *b0)))
-                    {
-                        *out = *b1;
-                        ++b1;
-                        ++out;
-                        --n1;
-                    }
-                    else
-                    {
-                        *out = *b0;
-                        ++b0;
-                        ++out;
-                        --n0;
-                    }
-                }
-            }
-        };
-
-        RANGES_INLINE_VARIABLE(merge_n_fn, merge_n)
-    } // namespace aux
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/aux_/merge_n_with_buffer.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/aux_/merge_n_with_buffer.hpp
deleted file mode 100644
index a68d0cd4..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/aux_/merge_n_with_buffer.hpp
+++ /dev/null
@@ -1,75 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-// Copyright (c) 2009 Alexander Stepanov and Paul McJones
-//
-// Permission to use, copy, modify, distribute and sell this software
-// and its documentation for any purpose is hereby granted without
-// fee, provided that the above copyright notice appear in all copies
-// and that both that copyright notice and this permission notice
-// appear in supporting documentation. The authors make no
-// representations about the suitability of this software for any
-// purpose. It is provided "as is" without express or implied
-// warranty.
-//
-// Algorithms from
-// Elements of Programming
-// by Alexander Stepanov and Paul McJones
-// Addison-Wesley Professional, 2009
-#ifndef RANGES_V3_ALGORITHM_AUX_MERGE_N_WITH_BUFFER_HPP
-#define RANGES_V3_ALGORITHM_AUX_MERGE_N_WITH_BUFFER_HPP
-
-#include <tuple>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/aux_/merge_n.hpp>
-#include <range/v3/algorithm/copy_n.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    namespace aux
-    {
-        struct merge_n_with_buffer_fn
-        {
-            template(typename I, typename B, typename C = less, typename P = identity)(
-                /// \pre
-                requires same_as<iter_common_reference_t<I>,
-                                     iter_common_reference_t<B>> AND
-                        indirectly_copyable<I, B> AND mergeable<B, I, I, C, P, P>)
-            I operator()(I begin0,
-                         iter_difference_t<I> n0,
-                         I begin1,
-                         iter_difference_t<I> n1,
-                         B buff,
-                         C r = C{},
-                         P p = P{}) const
-            {
-                copy_n(begin0, n0, buff);
-                return merge_n(buff, n0, begin1, n1, begin0, r, p, p).out;
-            }
-        };
-
-        RANGES_INLINE_VARIABLE(merge_n_with_buffer_fn, merge_n_with_buffer)
-    } // namespace aux
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/aux_/partition_point_n.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/aux_/partition_point_n.hpp
deleted file mode 100644
index 231a63ed..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/aux_/partition_point_n.hpp
+++ /dev/null
@@ -1,66 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_AUX_PARTITION_POINT_N_HPP
-#define RANGES_V3_ALGORITHM_AUX_PARTITION_POINT_N_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    namespace aux
-    {
-        struct partition_point_n_fn
-        {
-            template(typename I, typename C, typename P = identity)(
-                /// \pre
-                requires forward_iterator<I> AND
-                        indirect_unary_predicate<C, projected<I, P>>)
-            I operator()(I first,
-                         iter_difference_t<I> d,
-                         C pred,
-                         P proj = P{}) const //
-            {
-                if(0 < d)
-                {
-                    do
-                    {
-                        auto half = d / 2;
-                        auto middle = next(uncounted(first), half);
-                        if(invoke(pred, invoke(proj, *middle)))
-                        {
-                            first = recounted(first, std::move(++middle), half + 1);
-                            d -= half + 1;
-                        }
-                        else
-                            d = half;
-                    } while(0 != d);
-                }
-                return first;
-            }
-        };
-
-        RANGES_INLINE_VARIABLE(partition_point_n_fn, partition_point_n)
-    } // namespace aux
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/aux_/sort_n_with_buffer.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/aux_/sort_n_with_buffer.hpp
deleted file mode 100644
index 13585704..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/aux_/sort_n_with_buffer.hpp
+++ /dev/null
@@ -1,74 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-// Copyright (c) 2009 Alexander Stepanov and Paul McJones
-//
-// Permission to use, copy, modify, distribute and sell this software
-// and its documentation for any purpose is hereby granted without
-// fee, provided that the above copyright notice appear in all copies
-// and that both that copyright notice and this permission notice
-// appear in supporting documentation. The authors make no
-// representations about the suitability of this software for any
-// purpose. It is provided "as is" without express or implied
-// warranty.
-//
-// Algorithms from
-// Elements of Programming
-// by Alexander Stepanov and Paul McJones
-// Addison-Wesley Professional, 2009
-#ifndef RANGES_V3_ALGORITHM_AUX_SORT_N_WITH_BUFFER_HPP
-#define RANGES_V3_ALGORITHM_AUX_SORT_N_WITH_BUFFER_HPP
-
-#include <tuple>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/aux_/merge_n_with_buffer.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    namespace aux
-    {
-        struct sort_n_with_buffer_fn
-        {
-            template(typename I, typename B, typename C = less, typename P = identity)(
-                /// \pre
-                requires same_as<iter_common_reference_t<I>,
-                                 iter_common_reference_t<B>> AND
-                    indirectly_copyable<I, B> AND mergeable<B, I, I, C, P, P>)
-            I operator()(I first, iter_difference_t<I> n, B buff, C r = C{}, P p = P{})
-                const
-            {
-                auto half = n / 2;
-                if(0 == half)
-                    return next(first, n);
-                I m = (*this)(first, half, buff, r, p);
-                (*this)(m, n - half, buff, r, p);
-                return merge_n_with_buffer(first, half, m, n - half, buff, r, p);
-            }
-        };
-
-        RANGES_INLINE_VARIABLE(sort_n_with_buffer_fn, sort_n_with_buffer)
-    } // namespace aux
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/aux_/upper_bound_n.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/aux_/upper_bound_n.hpp
deleted file mode 100644
index e4a5a9c3..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/aux_/upper_bound_n.hpp
+++ /dev/null
@@ -1,88 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_AUX_UPPER_BOUND_N_HPP
-#define RANGES_V3_ALGORITHM_AUX_UPPER_BOUND_N_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/aux_/partition_point_n.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        // [&](auto&& i){ return !invoke(pred, val, i); }
-        template<typename Pred, typename Val>
-        struct upper_bound_predicate
-        {
-            Pred * pred_;
-            Val * val_;
-
-            template<typename T>
-            bool operator()(T && t) const
-            {
-                return !invoke(*pred_, *val_, static_cast<T &&>(t));
-            }
-        };
-
-        template<typename Pred, typename Val>
-        upper_bound_predicate<Pred, Val> make_upper_bound_predicate(Pred & pred,
-                                                                    Val & val)
-        {
-            return {&pred, &val};
-        }
-    } // namespace detail
-    /// \endcond
-
-    namespace aux
-    {
-        struct upper_bound_n_fn
-        {
-            /// \brief template function upper_bound
-            ///
-            /// range-based version of the `upper_bound` std algorithm
-            ///
-            /// \pre `Rng` is a model of the `range` concept
-            template(typename I, typename V, typename C = less, typename P = identity)(
-                /// \pre
-                requires forward_iterator<I> AND
-                    indirect_strict_weak_order<C, V const *, projected<I, P>>)
-            I operator()(I first,
-                         iter_difference_t<I> d,
-                         V const & val,
-                         C pred = C{},
-                         P proj = P{}) const
-            {
-                return partition_point_n(std::move(first),
-                                         d,
-                                         detail::make_upper_bound_predicate(pred, val),
-                                         std::move(proj));
-            }
-        };
-
-        RANGES_INLINE_VARIABLE(upper_bound_n_fn, upper_bound_n)
-    } // namespace aux
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/binary_search.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/binary_search.hpp
deleted file mode 100644
index baf670c5..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/binary_search.hpp
+++ /dev/null
@@ -1,83 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_BINARY_SEARCH_HPP
-#define RANGES_V3_ALGORITHM_BINARY_SEARCH_HPP
-
-#include <functional>
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/lower_bound.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(binary_search)
-        /// \brief function template \c binary_search
-        ///
-        /// range-based version of the \c binary_search std algorithm
-        ///
-        /// \pre `Rng` is a model of the `range` concept
-        template(typename I,
-                 typename S,
-                 typename V,
-                 typename C = less,
-                 typename P = identity)(
-            /// \pre
-            requires forward_iterator<I> AND sentinel_for<S, I> AND
-                indirect_strict_weak_order<C, V const *, projected<I, P>>)
-        bool RANGES_FUNC(binary_search)(
-            I first, S last, V const & val, C pred = C{}, P proj = P{})
-        {
-            first =
-                lower_bound(std::move(first), last, val, std::ref(pred), std::ref(proj));
-            return first != last && !invoke(pred, val, invoke(proj, *first));
-        }
-
-        /// \overload
-        template(typename Rng, typename V, typename C = less, typename P = identity)(
-            /// \pre
-            requires forward_range<Rng> AND
-                indirect_strict_weak_order<C, V const *, projected<iterator_t<Rng>, P>>)
-        bool RANGES_FUNC(binary_search)(
-            Rng && rng, V const & val, C pred = C{}, P proj = P{}) //
-        {
-            static_assert(!is_infinite<Rng>::value,
-                          "Trying to binary search an infinite range");
-            return (*this)(begin(rng), end(rng), val, std::move(pred), std::move(proj));
-        }
-    RANGES_FUNC_END(binary_search)
-
-    namespace cpp20
-    {
-        using ranges::binary_search;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/contains.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/contains.hpp
deleted file mode 100644
index bf93cf8f..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/contains.hpp
+++ /dev/null
@@ -1,62 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Johel Guerrero 2019
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_CONTAINS_HPP
-#define RANGES_V3_ALGORITHM_CONTAINS_HPP
-
-#include <utility>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/algorithm/find.hpp>
-#include <range/v3/detail/config.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(contains)
-
-        /// \brief function template \c contains
-        template(typename I, typename S, typename T, typename P = identity)(
-            /// \pre
-            requires input_iterator<I> AND sentinel_for<S, I> AND
-            indirect_relation<equal_to, projected<I, P>, const T *>)
-        constexpr bool RANGES_FUNC(contains)(I first, S last, const T & val, P proj = {})
-        {
-            return find(std::move(first), last, val, std::move(proj)) != last;
-        }
-
-        /// \overload
-        template(typename Rng, typename T, typename P = identity)(
-            /// \pre
-            requires input_range<Rng> AND
-            indirect_relation<equal_to, projected<iterator_t<Rng>, P>, const T *>)
-        constexpr bool RANGES_FUNC(contains)(Rng && rng, const T & val, P proj = {})
-        {
-            return (*this)(begin(rng), end(rng), val, std::move(proj));
-        }
-
-    RANGES_FUNC_END(contains)
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif // RANGES_V3_ALGORITHM_CONTAINS_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/copy.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/copy.hpp
deleted file mode 100644
index 401f68ff..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/copy.hpp
+++ /dev/null
@@ -1,91 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_COPY_HPP
-#define RANGES_V3_ALGORITHM_COPY_HPP
-
-#include <functional>
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/result_types.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/copy.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    template<typename I, typename O>
-    using copy_result = detail::in_out_result<I, O>;
-
-    RANGES_HIDDEN_DETAIL(namespace _copy CPP_PP_LBRACE())
-    RANGES_FUNC_BEGIN(copy)
-
-        /// \brief function template \c copy
-        template(typename I, typename S, typename O)(
-            /// \pre
-            requires input_iterator<I> AND sentinel_for<S, I> AND
-            weakly_incrementable<O> AND indirectly_copyable<I, O>)
-        constexpr copy_result<I, O> RANGES_FUNC(copy)(I first, S last, O out) //
-        {
-            for(; first != last; ++first, ++out)
-                *out = *first;
-            return {first, out};
-        }
-
-        /// \overload
-        template(typename Rng, typename O)(
-            /// \pre
-            requires input_range<Rng> AND weakly_incrementable<O> AND
-            indirectly_copyable<iterator_t<Rng>, O>)
-        constexpr copy_result<borrowed_iterator_t<Rng>, O> //
-        RANGES_FUNC(copy)(Rng && rng, O out)  //
-        {
-            return (*this)(begin(rng), end(rng), std::move(out));
-        }
-
-    RANGES_FUNC_END(copy)
-    RANGES_HIDDEN_DETAIL(CPP_PP_RBRACE())
-
-#ifndef RANGES_DOXYGEN_INVOKED
-    struct copy_fn
-      : aux::copy_fn
-      , _copy::copy_fn
-    {
-        using aux::copy_fn::operator();
-        using _copy::copy_fn::operator();
-    };
-    RANGES_INLINE_VARIABLE(copy_fn, copy)
-#endif
-
-    namespace cpp20
-    {
-        using ranges::copy_result;
-        using ranges::RANGES_HIDDEN_DETAIL(_copy::) copy;
-    } // namespace cpp20
-
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/copy_backward.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/copy_backward.hpp
deleted file mode 100644
index b0f57e78..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/copy_backward.hpp
+++ /dev/null
@@ -1,76 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_COPY_BACKWARD_HPP
-#define RANGES_V3_ALGORITHM_COPY_BACKWARD_HPP
-
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/result_types.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    template<typename I, typename O>
-    using copy_backward_result = detail::in_out_result<I, O>;
-
-    RANGES_FUNC_BEGIN(copy_backward)
-
-        /// \brief function template \c copy_backward
-        template(typename I, typename S, typename O)(
-            /// \pre
-            requires bidirectional_iterator<I> AND sentinel_for<S, I> AND
-            bidirectional_iterator<O> AND indirectly_copyable<I, O>)
-        copy_backward_result<I, O> RANGES_FUNC(copy_backward)(I first, S end_, O out)
-        {
-            I i = ranges::next(first, end_), last = i;
-            while(first != i)
-                *--out = *--i;
-            return {last, out};
-        }
-
-        /// \overload
-        template(typename Rng, typename O)(
-            /// \pre
-            requires bidirectional_range<Rng> AND bidirectional_iterator<O> AND
-            indirectly_copyable<iterator_t<Rng>, O>)
-        copy_backward_result<borrowed_iterator_t<Rng>, O> //
-        RANGES_FUNC(copy_backward)(Rng && rng, O out)
-        {
-            return (*this)(begin(rng), end(rng), std::move(out));
-        }
-    RANGES_FUNC_END(copy_backward)
-
-    namespace cpp20
-    {
-        using ranges::copy_backward;
-        using ranges::copy_backward_result;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/copy_if.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/copy_if.hpp
deleted file mode 100644
index 6f974cc5..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/copy_if.hpp
+++ /dev/null
@@ -1,90 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_COPY_IF_HPP
-#define RANGES_V3_ALGORITHM_COPY_IF_HPP
-
-#include <functional>
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/result_types.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    template<typename I, typename O>
-    using copy_if_result = detail::in_out_result<I, O>;
-
-    RANGES_FUNC_BEGIN(copy_if)
-
-        /// \brief function template \c copy_if
-        template(typename I, typename S, typename O, typename F, typename P = identity)(
-            /// \pre
-            requires input_iterator<I> AND sentinel_for<S, I> AND
-                weakly_incrementable<O> AND
-                indirect_unary_predicate<F, projected<I, P>> AND
-                indirectly_copyable<I, O>)
-        copy_if_result<I, O> //
-        RANGES_FUNC(copy_if)(I first, S last, O out, F pred, P proj = P{}) //
-        {
-            for(; first != last; ++first)
-            {
-                auto && x = *first;
-                if(invoke(pred, invoke(proj, x)))
-                {
-                    *out = (decltype(x) &&)x;
-                    ++out;
-                }
-            }
-            return {first, out};
-        }
-
-        /// \overload
-        template(typename Rng, typename O, typename F, typename P = identity)(
-            /// \pre
-            requires input_range<Rng> AND weakly_incrementable<O> AND
-            indirect_unary_predicate<F, projected<iterator_t<Rng>, P>> AND
-            indirectly_copyable<iterator_t<Rng>, O>)
-        copy_if_result<borrowed_iterator_t<Rng>, O> //
-        RANGES_FUNC(copy_if)(Rng && rng, O out, F pred, P proj = P{})
-        {
-            return (*this)(
-                begin(rng), end(rng), std::move(out), std::move(pred), std::move(proj));
-        }
-
-    RANGES_FUNC_END(copy_if)
-
-    namespace cpp20
-    {
-        using ranges::copy_if;
-        using ranges::copy_if_result;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/copy_n.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/copy_n.hpp
deleted file mode 100644
index 8a9d9ce2..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/copy_n.hpp
+++ /dev/null
@@ -1,70 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_COPY_N_HPP
-#define RANGES_V3_ALGORITHM_COPY_N_HPP
-
-#include <functional>
-#include <tuple>
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/result_types.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    template<typename I, typename O>
-    using copy_n_result = detail::in_out_result<I, O>;
-
-    RANGES_FUNC_BEGIN(copy_n)
-
-        /// \brief function template \c copy_n
-        template(typename I, typename O, typename P = identity)(
-            /// \pre
-            requires input_iterator<I> AND weakly_incrementable<O> AND
-            indirectly_copyable<I, O>)
-        copy_n_result<I, O> RANGES_FUNC(copy_n)(I first, iter_difference_t<I> n, O out)
-        {
-            RANGES_EXPECT(0 <= n);
-            auto norig = n;
-            auto b = uncounted(first);
-            for(; n != 0; ++b, ++out, --n)
-                *out = *b;
-            return {recounted(first, b, norig), out};
-        }
-
-    RANGES_FUNC_END(copy_n)
-
-    namespace cpp20
-    {
-        using ranges::copy_n;
-        using ranges::copy_n_result;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/count.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/count.hpp
deleted file mode 100644
index a0993b71..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/count.hpp
+++ /dev/null
@@ -1,74 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_COUNT_HPP
-#define RANGES_V3_ALGORITHM_COUNT_HPP
-
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(count)
-
-        /// \brief function template \c count
-        template(typename I, typename S, typename V, typename P = identity)(
-            /// \pre
-            requires input_iterator<I> AND sentinel_for<S, I> AND
-            indirect_relation<equal_to, projected<I, P>, V const *>)
-        iter_difference_t<I> //
-        RANGES_FUNC(count)(I first, S last, V const & val, P proj = P{})
-        {
-            iter_difference_t<I> n = 0;
-            for(; first != last; ++first)
-                if(invoke(proj, *first) == val)
-                    ++n;
-            return n;
-        }
-
-        /// \overload
-        template(typename Rng, typename V, typename P = identity)(
-            /// \pre
-            requires input_range<Rng> AND
-            indirect_relation<equal_to, projected<iterator_t<Rng>, P>, V const *>)
-        iter_difference_t<iterator_t<Rng>> //
-        RANGES_FUNC(count)(Rng && rng, V const & val, P proj = P{})
-        {
-            return (*this)(begin(rng), end(rng), val, std::move(proj));
-        }
-
-    RANGES_FUNC_END(count)
-
-    namespace cpp20
-    {
-        using ranges::count;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/count_if.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/count_if.hpp
deleted file mode 100644
index c9003d4e..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/count_if.hpp
+++ /dev/null
@@ -1,73 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_COUNT_IF_HPP
-#define RANGES_V3_ALGORITHM_COUNT_IF_HPP
-
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(count_if)
-
-        /// \brief function template \c count_if
-        template(typename I, typename S, typename R, typename P = identity)(
-            /// \pre
-            requires input_iterator<I> AND sentinel_for<S, I> AND
-            indirect_unary_predicate<R, projected<I, P>>)
-        iter_difference_t<I> RANGES_FUNC(count_if)(I first, S last, R pred, P proj = P{})
-        {
-            iter_difference_t<I> n = 0;
-            for(; first != last; ++first)
-                if(invoke(pred, invoke(proj, *first)))
-                    ++n;
-            return n;
-        }
-
-        /// \overload
-        template(typename Rng, typename R, typename P = identity)(
-            /// \pre
-            requires input_range<Rng> AND
-            indirect_unary_predicate<R, projected<iterator_t<Rng>, P>>)
-        iter_difference_t<iterator_t<Rng>> //
-        RANGES_FUNC(count_if)(Rng && rng, R pred, P proj = P{})
-        {
-            return (*this)(begin(rng), end(rng), std::move(pred), std::move(proj));
-        }
-
-    RANGES_FUNC_END(count_if)
-
-    namespace cpp20
-    {
-        using ranges::count_if;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/ends_with.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/ends_with.hpp
deleted file mode 100644
index 6361fbca..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/ends_with.hpp
+++ /dev/null
@@ -1,102 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Johel Guerrero 2019
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_ENDS_WITH_HPP
-#define RANGES_V3_ALGORITHM_ENDS_WITH_HPP
-
-#include <utility>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/algorithm/equal.hpp>
-#include <range/v3/detail/config.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(ends_with)
-
-        /// \brief function template \c ends_with
-        template(typename I0,
-                 typename S0,
-                 typename I1,
-                 typename S1,
-                 typename C = equal_to,
-                 typename P0 = identity,
-                 typename P1 = identity)(
-            /// \pre
-            requires ((forward_iterator<I0> && sentinel_for<S0, I0>) ||
-                      (input_iterator<I0> && sized_sentinel_for<S0, I0>)) AND
-                ((forward_iterator<I1> && sentinel_for<S1, I1>) ||
-                 (input_iterator<I1> && sized_sentinel_for<S1, I1>)) AND
-                indirectly_comparable<I0, I1, C, P0, P1>)
-        constexpr bool RANGES_FUNC(ends_with)(I0 begin0,
-                                              S0 end0,
-                                              I1 begin1,
-                                              S1 end1,
-                                              C pred = C{},
-                                              P0 proj0 = P0{},
-                                              P1 proj1 = P1{}) //
-        {
-            const auto drop = distance(begin0, end0) - distance(begin1, end1);
-            if(drop < 0)
-                return false;
-            return equal(next(std::move(begin0), drop),
-                         std::move(end0),
-                         std::move(begin1),
-                         std::move(end1),
-                         std::move(pred),
-                         std::move(proj0),
-                         std::move(proj1));
-        }
-
-        /// \overload
-        template(typename Rng0,
-                 typename Rng1,
-                 typename C = equal_to,
-                 typename P0 = identity,
-                 typename P1 = identity)(
-            /// \pre
-            requires (forward_range<Rng0> || (input_range<Rng0> && sized_range<Rng0>)) AND
-                (forward_range<Rng1> || (input_range<Rng1> && sized_range<Rng1>)) AND
-                indirectly_comparable<iterator_t<Rng0>, iterator_t<Rng1>, C, P0, P1>)
-        constexpr bool RANGES_FUNC(ends_with)(
-            Rng0 && rng0, Rng1 && rng1, C pred = C{}, P0 proj0 = P0{}, P1 proj1 = P1{}) //
-        {
-            const auto drop = distance(rng0) - distance(rng1);
-            if(drop < 0)
-                return false;
-            return equal(next(begin(rng0), drop),
-                         end(rng0),
-                         begin(rng1),
-                         end(rng1),
-                         std::move(pred),
-                         std::move(proj0),
-                         std::move(proj1));
-        }
-
-    RANGES_FUNC_END(ends_with)
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/equal.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/equal.hpp
deleted file mode 100644
index d3a9f0af..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/equal.hpp
+++ /dev/null
@@ -1,179 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_EQUAL_HPP
-#define RANGES_V3_ALGORITHM_EQUAL_HPP
-
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-
-    /// \cond
-    namespace detail
-    {
-        template<typename I0, typename S0, typename I1, typename S1, typename C,
-                 typename P0, typename P1>
-        constexpr bool equal_nocheck(I0 begin0, S0 end0, I1 begin1, S1 end1, C pred,
-                                     P0 proj0, P1 proj1)
-        {
-            for(; begin0 != end0 && begin1 != end1; ++begin0, ++begin1)
-                if(!invoke(pred, invoke(proj0, *begin0), invoke(proj1, *begin1)))
-                    return false;
-            return begin0 == end0 && begin1 == end1;
-        }
-    } // namespace detail
-    /// \endcond
-
-    RANGES_FUNC_BEGIN(equal)
-
-        /// \brief function template \c equal
-        template(typename I0,
-                     typename S0,
-                     typename I1,
-                     typename C = equal_to,
-                     typename P0 = identity,
-                     typename P1 = identity)(
-            /// \pre
-            requires input_iterator<I0> AND sentinel_for<S0, I0> AND
-                input_iterator<I1> AND indirectly_comparable<I0, I1, C, P0, P1>)
-        RANGES_DEPRECATED(
-            "Use the variant of ranges::equal that takes an upper bound for "
-            "both sequences")
-        constexpr bool RANGES_FUNC(equal)(I0 begin0,
-                                          S0 end0,
-                                          I1 begin1,
-                                          C pred = C{},
-                                          P0 proj0 = P0{},
-                                          P1 proj1 = P1{}) //
-        {
-            for(; begin0 != end0; ++begin0, ++begin1)
-                if(!invoke(pred, invoke(proj0, *begin0), invoke(proj1, *begin1)))
-                    return false;
-            return true;
-        }
-
-        /// \overload
-        template(typename I0,
-                 typename S0,
-                 typename I1,
-                 typename S1,
-                 typename C = equal_to,
-                 typename P0 = identity,
-                 typename P1 = identity)(
-            /// \pre
-            requires input_iterator<I0> AND sentinel_for<S0, I0> AND
-                input_iterator<I1> AND sentinel_for<S1, I1> AND
-                indirectly_comparable<I0, I1, C, P0, P1>)
-        constexpr bool RANGES_FUNC(equal)(I0 begin0,
-                                          S0 end0,
-                                          I1 begin1,
-                                          S1 end1,
-                                          C pred = C{},
-                                          P0 proj0 = P0{},
-                                          P1 proj1 = P1{}) //
-        {
-            if(RANGES_CONSTEXPR_IF(sized_sentinel_for<S0, I0> &&
-                                   sized_sentinel_for<S1, I1>))
-                if(distance(begin0, end0) != distance(begin1, end1))
-                    return false;
-            return detail::equal_nocheck(std::move(begin0),
-                                         std::move(end0),
-                                         std::move(begin1),
-                                         std::move(end1),
-                                         std::move(pred),
-                                         std::move(proj0),
-                                         std::move(proj1));
-        }
-
-        /// \overload
-        template(typename Rng0,
-                     typename I1Ref,
-                     typename C = equal_to,
-                     typename P0 = identity,
-                     typename P1 = identity)(
-            /// \pre
-            requires input_range<Rng0> AND input_iterator<uncvref_t<I1Ref>> AND
-                indirectly_comparable<iterator_t<Rng0>, uncvref_t<I1Ref>, C, P0, P1>)
-        RANGES_DEPRECATED(
-            "Use the variant of ranges::equal that takes an upper bound for "
-            "both sequences")
-        constexpr bool RANGES_FUNC(equal)(Rng0 && rng0,
-                                          I1Ref && begin1,
-                                          C pred = C{},
-                                          P0 proj0 = P0{},
-                                          P1 proj1 = P1{}) //
-        {
-            RANGES_DIAGNOSTIC_PUSH
-            RANGES_DIAGNOSTIC_IGNORE_DEPRECATED_DECLARATIONS
-            return (*this)(begin(rng0),
-                           end(rng0),
-                           (I1Ref &&) begin1,
-                           std::move(pred),
-                           std::move(proj0),
-                           std::move(proj1));
-            RANGES_DIAGNOSTIC_POP
-        }
-
-        /// \overload
-        template(typename Rng0,
-                     typename Rng1,
-                     typename C = equal_to,
-                     typename P0 = identity,
-                     typename P1 = identity)(
-            /// \pre
-            requires input_range<Rng0> AND input_range<Rng1> AND
-                indirectly_comparable<iterator_t<Rng0>, iterator_t<Rng1>, C, P0, P1>)
-        constexpr bool RANGES_FUNC(equal)(
-            Rng0 && rng0, Rng1 && rng1, C pred = C{}, P0 proj0 = P0{}, P1 proj1 = P1{}) //
-        {
-            if(RANGES_CONSTEXPR_IF(sized_range<Rng0> && sized_range<Rng1>))
-                if(distance(rng0) != distance(rng1))
-                    return false;
-            return detail::equal_nocheck(begin(rng0),
-                                         end(rng0),
-                                         begin(rng1),
-                                         end(rng1),
-                                         std::move(pred),
-                                         std::move(proj0),
-                                         std::move(proj1));
-        }
-
-    RANGES_FUNC_END(equal)
-
-    namespace cpp20
-    {
-        using ranges::equal;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/equal_range.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/equal_range.hpp
deleted file mode 100644
index f8e0ea64..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/equal_range.hpp
+++ /dev/null
@@ -1,132 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_EQUAL_RANGE_HPP
-#define RANGES_V3_ALGORITHM_EQUAL_RANGE_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/aux_/equal_range_n.hpp>
-#include <range/v3/algorithm/aux_/lower_bound_n.hpp>
-#include <range/v3/algorithm/upper_bound.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/subrange.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(equal_range)
-
-        /// \brief function template \c equal_range
-        template(typename I,
-                 typename S,
-                 typename V,
-                 typename C = less,
-                 typename P = identity)(
-            /// \pre
-            requires forward_iterator<I> AND sentinel_for<S, I> AND
-                indirect_strict_weak_order<C, V const *, projected<I, P>>)
-        subrange<I> RANGES_FUNC(equal_range)(
-            I first, S last, V const & val, C pred = C{}, P proj = P{})
-        {
-            if(RANGES_CONSTEXPR_IF(sized_sentinel_for<S, I>))
-            {
-                auto const len = distance(first, last);
-                return aux::equal_range_n(
-                    std::move(first), len, val, std::move(pred), std::move(proj));
-            }
-
-            // Probe exponentially for either end-of-range, an iterator that
-            // is past the equal range (i.e., denotes an element greater
-            // than val), or is in the equal range (denotes an element equal
-            // to val).
-            auto dist = iter_difference_t<I>{1};
-            while(true)
-            {
-                auto mid = first;
-                auto d = advance(mid, dist, last);
-                if(d || mid == last)
-                {
-                    // at the end of the input range
-                    dist -= d;
-                    return aux::equal_range_n(
-                        std::move(first), dist, val, std::ref(pred), std::ref(proj));
-                }
-                // if val < *mid, mid is after the target range.
-                auto && v = *mid;
-                auto && pv = invoke(proj, (decltype(v) &&)v);
-                if(invoke(pred, val, pv))
-                {
-                    return aux::equal_range_n(
-                        std::move(first), dist, val, std::ref(pred), std::ref(proj));
-                }
-                else if(!invoke(pred, pv, val))
-                {
-                    // *mid == val: the lower bound is <= mid, and the upper bound is >
-                    // mid.
-                    return {
-                        aux::lower_bound_n(
-                            std::move(first), dist, val, std::ref(pred), std::ref(proj)),
-                        upper_bound(std::move(mid),
-                                    std::move(last),
-                                    val,
-                                    std::ref(pred),
-                                    std::ref(proj))};
-                }
-                // *mid < val, mid is before the target range.
-                first = std::move(mid);
-                ++first;
-                dist *= 2;
-            }
-        }
-
-        /// \overload
-        template(typename Rng, typename V, typename C = less, typename P = identity)(
-            /// \pre
-            requires forward_range<Rng> AND
-                indirect_strict_weak_order<C, V const *, projected<iterator_t<Rng>, P>>)
-        borrowed_subrange_t<Rng> //
-        RANGES_FUNC(equal_range)(Rng && rng, V const & val, C pred = C{}, P proj = P{}) //
-        {
-            if(RANGES_CONSTEXPR_IF(sized_range<Rng>))
-            {
-                auto const len = distance(rng);
-                return aux::equal_range_n(
-                    begin(rng), len, val, std::move(pred), std::move(proj));
-            }
-
-            return (*this)(begin(rng), end(rng), val, std::move(pred), std::move(proj));
-        }
-
-    RANGES_FUNC_END(equal_range)
-
-    namespace cpp20
-    {
-        using ranges::equal_range;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/fill.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/fill.hpp
deleted file mode 100644
index 1a6cc470..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/fill.hpp
+++ /dev/null
@@ -1,64 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_FILL_HPP
-#define RANGES_V3_ALGORITHM_FILL_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(fill)
-
-        /// \brief function template \c fill
-        template(typename O, typename S, typename V)(
-            /// \pre
-            requires output_iterator<O, V const &> AND sentinel_for<S, O>)
-        O RANGES_FUNC(fill)(O first, S last, V const & val) //
-        {
-            for(; first != last; ++first)
-                *first = val;
-            return first;
-        }
-
-        /// \overload
-        template(typename Rng, typename V)(
-            /// \pre
-            requires output_range<Rng, V const &>)
-        borrowed_iterator_t<Rng> RANGES_FUNC(fill)(Rng && rng, V const & val)
-        {
-            return (*this)(begin(rng), end(rng), val);
-        }
-
-    RANGES_FUNC_END(fill)
-
-    namespace cpp20
-    {
-        using ranges::fill;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/fill_n.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/fill_n.hpp
deleted file mode 100644
index dda3609d..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/fill_n.hpp
+++ /dev/null
@@ -1,60 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_FILL_N_HPP
-#define RANGES_V3_ALGORITHM_FILL_N_HPP
-
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(fill_n)
-
-        /// \brief function template \c equal
-        template(typename O, typename V)(
-            /// \pre
-            requires output_iterator<O, V const &>)
-        O RANGES_FUNC(fill_n)(O first, iter_difference_t<O> n, V const & val)
-        {
-            RANGES_EXPECT(n >= 0);
-            auto norig = n;
-            auto b = uncounted(first);
-            for(; n != 0; ++b, --n)
-                *b = val;
-            return recounted(first, b, norig);
-        }
-
-    RANGES_FUNC_END(fill_n)
-
-    namespace cpp20
-    {
-        using ranges::fill_n;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/find.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/find.hpp
deleted file mode 100644
index 2c20b4d3..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/find.hpp
+++ /dev/null
@@ -1,80 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_FIND_HPP
-#define RANGES_V3_ALGORITHM_FIND_HPP
-
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(find)
-        /// \brief template function \c find
-        ///
-        /// range-based version of the \c find std algorithm
-        ///
-        /// \pre `Rng` is a model of the `range` concept
-        /// \pre `I` is a model of the `input_iterator` concept
-        /// \pre `S` is a model of the `sentinel_for<I>` concept
-        /// \pre `P` is a model of the `invocable<iter_common_reference_t<I>>` concept
-        /// \pre The ResultType of `P` is equality_comparable with V
-        template(typename I, typename S, typename V, typename P = identity)(
-            /// \pre
-            requires input_iterator<I> AND sentinel_for<S, I> AND
-            indirect_relation<equal_to, projected<I, P>, V const *>)
-        constexpr I RANGES_FUNC(find)(I first, S last, V const & val, P proj = P{})
-        {
-            for(; first != last; ++first)
-                if(invoke(proj, *first) == val)
-                    break;
-            return first;
-        }
-
-        /// \overload
-        template(typename Rng, typename V, typename P = identity)(
-            /// \pre
-            requires input_range<Rng> AND
-            indirect_relation<equal_to, projected<iterator_t<Rng>, P>, V const *>)
-        constexpr borrowed_iterator_t<Rng> //
-        RANGES_FUNC(find)(Rng && rng, V const & val, P proj = P{})
-        {
-            return (*this)(begin(rng), end(rng), val, std::move(proj));
-        }
-
-    RANGES_FUNC_END(find)
-
-    namespace cpp20
-    {
-        using ranges::find;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/find_end.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/find_end.hpp
deleted file mode 100644
index 89ef3139..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/find_end.hpp
+++ /dev/null
@@ -1,242 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_FIND_END_HPP
-#define RANGES_V3_ALGORITHM_FIND_END_HPP
-
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/subrange.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        template(typename I, typename S)(
-            /// \pre
-            requires input_iterator<I> AND sentinel_for<S, I>)
-        I next_to_if(I i, S s, std::true_type)
-        {
-            return ranges::next(i, s);
-        }
-
-        template(typename I, typename S)(
-            /// \pre
-            requires input_iterator<I> AND sentinel_for<S, I>)
-        S next_to_if(I, S s, std::false_type)
-        {
-            return s;
-        }
-
-        template(bool B, typename I, typename S)(
-            /// \pre
-            requires input_iterator<I> AND sentinel_for<S, I>)
-        meta::if_c<B, I, S> next_to_if(I i, S s)
-        {
-            return detail::next_to_if(std::move(i), std::move(s), meta::bool_<B>{});
-        }
-
-        template<typename I1, typename S1, typename I2, typename S2, typename R,
-                 typename P>
-        subrange<I1> find_end_impl(I1 begin1, S1 end1, I2 begin2, S2 end2, R pred, P proj,
-                                   std::forward_iterator_tag, std::forward_iterator_tag)
-        {
-            bool found = false;
-            I1 res_begin, res_end;
-            if(begin2 == end2)
-            {
-                auto e1 = ranges::next(begin1, end1);
-                return {e1, e1};
-            }
-            while(true)
-            {
-                while(true)
-                {
-                    if(begin1 == end1)
-                        return {(found ? res_begin : begin1), (found ? res_end : begin1)};
-                    if(invoke(pred, invoke(proj, *begin1), *begin2))
-                        break;
-                    ++begin1;
-                }
-                auto tmp1 = begin1;
-                auto tmp2 = begin2;
-                while(true)
-                {
-                    if(++tmp2 == end2)
-                    {
-                        res_begin = begin1++;
-                        res_end = ++tmp1;
-                        found = true;
-                        break;
-                    }
-                    if(++tmp1 == end1)
-                        return {(found ? res_begin : tmp1), (found ? res_end : tmp1)};
-                    if(!invoke(pred, invoke(proj, *tmp1), *tmp2))
-                    {
-                        ++begin1;
-                        break;
-                    }
-                }
-            }
-        }
-
-        template<typename I1, typename I2, typename R, typename P>
-        subrange<I1> find_end_impl(I1 begin1, I1 end1, I2 begin2, I2 end2, R pred, P proj,
-                                   std::bidirectional_iterator_tag,
-                                   std::bidirectional_iterator_tag)
-        {
-            // modeled after search algorithm (in reverse)
-            if(begin2 == end2)
-                return {end1, end1}; // Everything matches an empty sequence
-            I1 l1 = end1;
-            I2 l2 = end2;
-            --l2;
-            while(true)
-            {
-                // Find end element in sequence 1 that matches *(end2-1), with a mininum
-                // of loop checks
-                do
-                    // return {end1,end1} if no element matches *begin2
-                    if(begin1 == l1)
-                        return {end1, end1};
-                while(!invoke(pred, invoke(proj, *--l1), *l2));
-                // *l1 matches *l2, now match elements before here
-                I1 m1 = l1;
-                I2 m2 = l2;
-                do
-                    // If pattern exhausted, {m1,++l1} is the answer
-                    // (works for 1 element pattern)
-                    if(m2 == begin2)
-                        return {m1, ++l1};
-                    // Otherwise if source exhausted, pattern not found
-                    else if(m1 == begin1)
-                        return {end1, end1};
-                // if there is a mismatch, restart with a new l1
-                // else there is a match, check next elements
-                while(invoke(pred, invoke(proj, *--m1), *--m2));
-            }
-        }
-
-        template<typename I1, typename I2, typename R, typename P>
-        subrange<I1> find_end_impl(I1 begin1, I1 end1, I2 begin2, I2 end2, R pred, P proj,
-                                   std::random_access_iterator_tag,
-                                   std::random_access_iterator_tag)
-        {
-            // Take advantage of knowing source and pattern lengths.  Stop short when
-            // source is smaller than pattern
-            auto len2 = end2 - begin2;
-            if(len2 == 0)
-                return {end1, end1};
-            auto len1 = end1 - begin1;
-            if(len1 < len2)
-                return {end1, end1};
-            I1 const start =
-                begin1 + (len2 - 1); // End of pattern match can't go before here
-            I1 l1 = end1;
-            I2 l2 = end2;
-            --l2;
-            while(true)
-            {
-                do
-                    if(start == l1)
-                        return {end1, end1};
-                while(!invoke(pred, invoke(proj, *--l1), *l2));
-                I1 m1 = l1;
-                I2 m2 = l2;
-                do
-                    if(m2 == begin2)
-                        return {m1, ++l1};
-                // no need to check range on m1 because s guarantees we have enough source
-                while(invoke(pred, invoke(proj, *--m1), *--m2));
-            }
-        }
-    } // namespace detail
-    /// \endcond
-
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(find_end)
-
-        /// \brief function template \c find_end
-        template(typename I1,
-                 typename S1,
-                 typename I2,
-                 typename S2,
-                 typename R = equal_to,
-                 typename P = identity)(
-            /// \pre
-            requires forward_iterator<I1> AND sentinel_for<S1, I1> AND
-                forward_iterator<I2> AND sentinel_for<S2, I2> AND
-                indirect_relation<R, projected<I1, P>, I2>)
-        subrange<I1> RANGES_FUNC(find_end)(
-            I1 begin1, S1 end1, I2 begin2, S2 end2, R pred = R{}, P proj = P{}) //
-        {
-            constexpr bool Bidi =
-                bidirectional_iterator<I1> && bidirectional_iterator<I2>;
-            return detail::find_end_impl(begin1,
-                                         detail::next_to_if<Bidi>(begin1, end1),
-                                         begin2,
-                                         detail::next_to_if<Bidi>(begin2, end2),
-                                         std::move(pred),
-                                         std::move(proj),
-                                         iterator_tag_of<I1>(),
-                                         iterator_tag_of<I2>());
-        }
-
-        /// \overload
-        template(typename Rng1,
-                 typename Rng2,
-                 typename R = equal_to,
-                 typename P = identity)(
-            /// \pre
-            requires forward_range<Rng1> AND forward_range<Rng2> AND
-                indirect_relation<R, projected<iterator_t<Rng1>, P>, iterator_t<Rng2>>)
-        borrowed_subrange_t<Rng1> RANGES_FUNC(find_end)(
-            Rng1 && rng1, Rng2 && rng2, R pred = R{}, P proj = P{}) //
-        {
-            return (*this)(begin(rng1),
-                           end(rng1),
-                           begin(rng2),
-                           end(rng2),
-                           std::move(pred),
-                           std::move(proj));
-        }
-
-    RANGES_FUNC_END(find_end)
-
-    namespace cpp20
-    {
-        using ranges::find_end;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/find_first_of.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/find_first_of.hpp
deleted file mode 100644
index 846e302f..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/find_first_of.hpp
+++ /dev/null
@@ -1,105 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_FIND_FIRST_OF_HPP
-#define RANGES_V3_ALGORITHM_FIND_FIRST_OF_HPP
-
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(find_first_of)
-        // Rationale: return I0 instead of pair<I0,I1> because find_first_of need
-        // not actually compute the end of [I1,S0); therefore, it is not necessarily
-        // losing information. E.g., if begin0 == end0, we can return begin0 immediately.
-        // If we returned pair<I0,I1>, we would need to do an O(N) scan to find the
-        // end position.
-
-        /// \brief function template \c find_first_of
-        template(typename I0,
-                 typename S0,
-                 typename I1,
-                 typename S1,
-                 typename R = equal_to,
-                 typename P0 = identity,
-                 typename P1 = identity)(
-            /// \pre
-            requires input_iterator<I0> AND sentinel_for<S0, I0> AND
-                forward_iterator<I1> AND sentinel_for<S1, I1> AND
-                indirect_relation<R, projected<I0, P0>, projected<I1, P1>>)
-        constexpr I0 RANGES_FUNC(find_first_of)(I0 begin0,
-                                                S0 end0,
-                                                I1 begin1,
-                                                S1 end1,
-                                                R pred = R{},
-                                                P0 proj0 = P0{},
-                                                P1 proj1 = P1{}) //
-        {
-            for(; begin0 != end0; ++begin0)
-                for(auto tmp = begin1; tmp != end1; ++tmp)
-                    if(invoke(pred, invoke(proj0, *begin0), invoke(proj1, *tmp)))
-                        return begin0;
-            return begin0;
-        }
-
-        /// \overload
-        template(typename Rng0,
-                     typename Rng1,
-                     typename R = equal_to,
-                     typename P0 = identity,
-                     typename P1 = identity)(
-            /// \pre
-            requires input_range<Rng0> AND forward_range<Rng1> AND
-                indirect_relation<R,
-                                  projected<iterator_t<Rng0>, P0>,
-                                  projected<iterator_t<Rng1>, P1>>)
-        constexpr borrowed_iterator_t<Rng0> RANGES_FUNC(find_first_of)(
-            Rng0 && rng0, Rng1 && rng1, R pred = R{}, P0 proj0 = P0{}, P1 proj1 = P1{}) //
-        {
-            return (*this)(begin(rng0),
-                           end(rng0),
-                           begin(rng1),
-                           end(rng1),
-                           std::move(pred),
-                           std::move(proj0),
-                           std::move(proj1));
-        }
-
-    RANGES_FUNC_END(find_first_of)
-
-    namespace cpp20
-    {
-        using ranges::find_first_of;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/find_if.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/find_if.hpp
deleted file mode 100644
index 05fae718..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/find_if.hpp
+++ /dev/null
@@ -1,81 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_FIND_IF_HPP
-#define RANGES_V3_ALGORITHM_FIND_IF_HPP
-
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(find_if)
-        /// \brief template function \c find
-        ///
-        /// range-based version of the \c find std algorithm
-        ///
-        /// \pre `Rng` is a model of the `range` concept
-        /// \pre `I` is a model of the `input_iterator` concept
-        /// \pre `S` is a model of the `sentinel_for<I>` concept
-        /// \pre `P` is a model of the `invocable<V>` concept, where `V` is the
-        ///      value type of I.
-        /// \pre `F` models `predicate<X>`, where `X` is the result type
-        ///      of `invocable<P, V>`
-        template(typename I, typename S, typename F, typename P = identity)(
-            /// \pre
-            requires input_iterator<I> AND sentinel_for<S, I> AND
-            indirect_unary_predicate<F, projected<I, P>>)
-        I RANGES_FUNC(find_if)(I first, S last, F pred, P proj = P{})
-        {
-            for(; first != last; ++first)
-                if(invoke(pred, invoke(proj, *first)))
-                    break;
-            return first;
-        }
-
-        /// \overload
-        template(typename Rng, typename F, typename P = identity)(
-            /// \pre
-            requires input_range<Rng> AND
-            indirect_unary_predicate<F, projected<iterator_t<Rng>, P>>)
-        borrowed_iterator_t<Rng> RANGES_FUNC(find_if)(Rng && rng, F pred, P proj = P{})
-        {
-            return (*this)(begin(rng), end(rng), std::move(pred), std::move(proj));
-        }
-
-    RANGES_FUNC_END(find_if)
-
-    namespace cpp20
-    {
-        using ranges::find_if;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/find_if_not.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/find_if_not.hpp
deleted file mode 100644
index 39008237..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/find_if_not.hpp
+++ /dev/null
@@ -1,82 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_FIND_IF_NOT_HPP
-#define RANGES_V3_ALGORITHM_FIND_IF_NOT_HPP
-
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(find_if_not)
-        /// \brief template function \c find_if_not
-        ///
-        /// range-based version of the \c find_if_not std algorithm
-        ///
-        /// \pre `Rng` is a model of the `range` concept
-        /// \pre `I` is a model of the `input_iterator` concept
-        /// \pre `S` is a model of the `sentinel_for<I>` concept
-        /// \pre `P` is a model of the `invocable<V>` concept, where `V` is the
-        ///      value type of I.
-        /// \pre `F` models `predicate<X>`, where `X` is the result type
-        ///      of `invocable<P, V>`
-        template(typename I, typename S, typename F, typename P = identity)(
-            /// \pre
-            requires input_iterator<I> AND sentinel_for<S, I> AND
-            indirect_unary_predicate<F, projected<I, P>>)
-        I RANGES_FUNC(find_if_not)(I first, S last, F pred, P proj = P{})
-        {
-            for(; first != last; ++first)
-                if(!invoke(pred, invoke(proj, *first)))
-                    break;
-            return first;
-        }
-
-        /// \overload
-        template(typename Rng, typename F, typename P = identity)(
-            /// \pre
-            requires input_range<Rng> AND
-            indirect_unary_predicate<F, projected<iterator_t<Rng>, P>>)
-        borrowed_iterator_t<Rng> //
-        RANGES_FUNC(find_if_not)(Rng && rng, F pred, P proj = P{})
-        {
-            return (*this)(begin(rng), end(rng), std::move(pred), std::move(proj));
-        }
-
-    RANGES_FUNC_END(find_if_not)
-
-    namespace cpp20
-    {
-        using ranges::find_if_not;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/for_each.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/for_each.hpp
deleted file mode 100644
index 64cbbf8f..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/for_each.hpp
+++ /dev/null
@@ -1,80 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_FOR_EACH_HPP
-#define RANGES_V3_ALGORITHM_FOR_EACH_HPP
-
-#include <functional>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/result_types.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/functional/reference_wrapper.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    template<typename I, typename F>
-    using for_each_result = detail::in_fun_result<I, F>;
-
-    RANGES_FUNC_BEGIN(for_each)
-
-        /// \brief function template \c for_each
-        template(typename I, typename S, typename F, typename P = identity)(
-            /// \pre
-            requires input_iterator<I> AND sentinel_for<S, I> AND
-            indirectly_unary_invocable<F, projected<I, P>>)
-        for_each_result<I, F> RANGES_FUNC(for_each)(I first, S last, F fun, P proj = P{})
-        {
-            for(; first != last; ++first)
-            {
-                invoke(fun, invoke(proj, *first));
-            }
-            return {detail::move(first), detail::move(fun)};
-        }
-
-        /// \overload
-        template(typename Rng, typename F, typename P = identity)(
-            /// \pre
-            requires input_range<Rng> AND
-            indirectly_unary_invocable<F, projected<iterator_t<Rng>, P>>)
-        for_each_result<borrowed_iterator_t<Rng>, F> //
-        RANGES_FUNC(for_each)(Rng && rng, F fun, P proj = P{})
-        {
-            return {(*this)(begin(rng), end(rng), ref(fun), detail::move(proj)).in,
-                    detail::move(fun)};
-        }
-
-    RANGES_FUNC_END(for_each)
-
-    namespace cpp20
-    {
-        using ranges::for_each;
-        using ranges::for_each_result;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/for_each_n.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/for_each_n.hpp
deleted file mode 100644
index 9f9cb898..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/for_each_n.hpp
+++ /dev/null
@@ -1,79 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Rostislav Khlebnikov 2017
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_FOR_EACH_N_HPP
-#define RANGES_V3_ALGORITHM_FOR_EACH_N_HPP
-
-#include <functional>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/result_types.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(for_each_n)
-
-        /// \brief function template \c for_each_n
-        template(typename I, typename F, typename P = identity)(
-            /// \pre
-            requires input_iterator<I> AND
-                indirectly_unary_invocable<F, projected<I, P>>)
-        I RANGES_FUNC(for_each_n)(I first, iter_difference_t<I> n, F fun, P proj = P{})
-        {
-            RANGES_EXPECT(0 <= n);
-            auto norig = n;
-            auto b = uncounted(first);
-            for(; 0 < n; ++b, --n)
-                invoke(fun, invoke(proj, *b));
-            return recounted(first, b, norig);
-        }
-
-        /// \overload
-        template(typename Rng, typename F, typename P = identity)(
-            /// \pre
-            requires input_range<Rng> AND
-                indirectly_unary_invocable<F, projected<iterator_t<Rng>, P>>)
-        borrowed_iterator_t<Rng> RANGES_FUNC(for_each_n)(
-            Rng && rng, range_difference_t<Rng> n, F fun, P proj = P{})
-        {
-            if(sized_range<Rng>)
-                RANGES_EXPECT(n <= distance(rng));
-
-            return (*this)(begin(rng), n, detail::move(fun), detail::move(proj));
-        }
-
-    RANGES_FUNC_END(for_each_n)
-
-    namespace cpp20
-    {
-        using ranges::for_each_n;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/generate.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/generate.hpp
deleted file mode 100644
index b1607823..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/generate.hpp
+++ /dev/null
@@ -1,75 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_GENERATE_HPP
-#define RANGES_V3_ALGORITHM_GENERATE_HPP
-
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/result_types.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/functional/reference_wrapper.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    template<typename O, typename F>
-    using generate_result = detail::out_fun_result<O, F>;
-
-    RANGES_FUNC_BEGIN(generate)
-
-        /// \brief function template \c generate_n
-        template(typename O, typename S, typename F)(
-            /// \pre
-            requires invocable<F &> AND output_iterator<O, invoke_result_t<F &>> AND
-            sentinel_for<S, O>)
-        generate_result<O, F> RANGES_FUNC(generate)(O first, S last, F fun) //
-        {
-            for(; first != last; ++first)
-                *first = invoke(fun);
-            return {detail::move(first), detail::move(fun)};
-        }
-
-        /// \overload
-        template(typename Rng, typename F)(
-            /// \pre
-            requires invocable<F &> AND output_range<Rng, invoke_result_t<F &>>)
-        generate_result<borrowed_iterator_t<Rng>, F> //
-        RANGES_FUNC(generate)(Rng && rng, F fun)
-        {
-            return {(*this)(begin(rng), end(rng), ref(fun)).out, detail::move(fun)};
-        }
-
-    RANGES_FUNC_END(generate)
-
-    namespace cpp20
-    {
-        using ranges::generate;
-        using ranges::generate_result;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/generate_n.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/generate_n.hpp
deleted file mode 100644
index ef94bade..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/generate_n.hpp
+++ /dev/null
@@ -1,68 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_GENERATE_N_HPP
-#define RANGES_V3_ALGORITHM_GENERATE_N_HPP
-
-#include <tuple>
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/result_types.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    template<typename O, typename F>
-    using generate_n_result = detail::out_fun_result<O, F>;
-
-    RANGES_FUNC_BEGIN(generate_n)
-
-        /// \brief function template \c generate_n
-        template(typename O, typename F)(
-            /// \pre
-            requires invocable<F &> AND output_iterator<O, invoke_result_t<F &>>)
-        generate_n_result<O, F> //
-        RANGES_FUNC(generate_n)(O first, iter_difference_t<O> n, F fun)
-        {
-            RANGES_EXPECT(n >= 0);
-            auto norig = n;
-            auto b = uncounted(first);
-            for(; 0 != n; ++b, --n)
-                *b = invoke(fun);
-            return {recounted(first, b, norig), detail::move(fun)};
-        }
-
-    RANGES_FUNC_END(generate_n)
-
-    namespace cpp20
-    {
-        using ranges::generate_n;
-        using ranges::generate_n_result;
-    } // namespace cpp20
-    // @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/heap_algorithm.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/heap_algorithm.hpp
deleted file mode 100644
index 7030ba41..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/heap_algorithm.hpp
+++ /dev/null
@@ -1,440 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-#ifndef RANGES_V3_ALGORITHM_HEAP_ALGORITHM_HPP
-#define RANGES_V3_ALGORITHM_HEAP_ALGORITHM_HPP
-
-#include <functional>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        struct is_heap_until_n_fn
-        {
-            template(typename I, typename C = less, typename P = identity)(
-                /// \pre
-                requires random_access_iterator<I> AND
-                    indirect_strict_weak_order<C, projected<I, P>>)
-            I operator()(I const begin_, iter_difference_t<I> const n_, C pred = C{},
-                            P proj = P{}) const
-            {
-                RANGES_EXPECT(0 <= n_);
-                iter_difference_t<I> p = 0, c = 1;
-                I pp = begin_;
-                while(c < n_)
-                {
-                    I cp = begin_ + c;
-                    if(invoke(pred, invoke(proj, *pp), invoke(proj, *cp)))
-                        return cp;
-                    ++c;
-                    ++cp;
-                    if(c == n_ || invoke(pred, invoke(proj, *pp), invoke(proj, *cp)))
-                        return cp;
-                    ++p;
-                    ++pp;
-                    c = 2 * p + 1;
-                }
-                return begin_ + n_;
-            }
-        };
-
-        RANGES_INLINE_VARIABLE(is_heap_until_n_fn, is_heap_until_n)
-
-        struct is_heap_n_fn
-        {
-            template(typename I, typename C = less, typename P = identity)(
-                /// \pre
-                requires random_access_iterator<I> AND
-                    indirect_strict_weak_order<C, projected<I, P>>)
-            bool operator()(I first, iter_difference_t<I> n, C pred = C{},
-                            P proj = P{}) const
-            {
-                return is_heap_until_n(first, n, std::move(pred), std::move(proj)) ==
-                       first + n;
-            }
-        };
-
-        RANGES_INLINE_VARIABLE(is_heap_n_fn, is_heap_n)
-    } // namespace detail
-    /// \endcond
-
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(is_heap_until)
-
-        /// \brief function template \c is_heap_until
-        template(typename I, typename S, typename C = less, typename P = identity)(
-            /// \pre
-            requires random_access_iterator<I> AND sentinel_for<S, I> AND
-            indirect_strict_weak_order<C, projected<I, P>>)
-        I RANGES_FUNC(is_heap_until)(I first, S last, C pred = C{}, P proj = P{})
-        {
-            return detail::is_heap_until_n(std::move(first),
-                                           distance(first, last),
-                                           std::move(pred),
-                                           std::move(proj));
-        }
-
-        /// \overload
-        template(typename Rng, typename C = less, typename P = identity)(
-            /// \pre
-            requires random_access_range<Rng> AND
-            indirect_strict_weak_order<C, projected<iterator_t<Rng>, P>>)
-        borrowed_iterator_t<Rng> //
-        RANGES_FUNC(is_heap_until)(Rng && rng, C pred = C{}, P proj = P{})
-        {
-            return detail::is_heap_until_n(
-                begin(rng), distance(rng), std::move(pred), std::move(proj));
-        }
-
-    RANGES_FUNC_END(is_heap_until)
-
-    namespace cpp20
-    {
-        using ranges::is_heap_until;
-    }
-
-    RANGES_FUNC_BEGIN(is_heap)
-
-        /// \brief function template \c is_heap
-        template(typename I, typename S, typename C = less, typename P = identity)(
-            /// \pre
-            requires random_access_iterator<I> AND sentinel_for<S, I> AND
-            indirect_strict_weak_order<C, projected<I, P>>)
-        bool RANGES_FUNC(is_heap)(I first, S last, C pred = C{}, P proj = P{}) //
-        {
-            return detail::is_heap_n(std::move(first),
-                                     distance(first, last),
-                                     std::move(pred),
-                                     std::move(proj));
-        }
-
-        /// \overload
-        template(typename Rng, typename C = less, typename P = identity)(
-            /// \pre
-            requires random_access_range<Rng> AND
-            indirect_strict_weak_order<C, projected<iterator_t<Rng>, P>>)
-        bool RANGES_FUNC(is_heap)(Rng && rng, C pred = C{}, P proj = P{}) //
-        {
-            return detail::is_heap_n(
-                begin(rng), distance(rng), std::move(pred), std::move(proj));
-        }
-
-    RANGES_FUNC_END(is_heap)
-
-    namespace cpp20
-    {
-        using ranges::is_heap;
-    }
-    /// @}
-
-    /// \cond
-    namespace detail
-    {
-        struct sift_up_n_fn
-        {
-            template<typename I, typename C = less, typename P = identity>
-            void operator()(I first, iter_difference_t<I> len, C pred = C{},
-                            P proj = P{}) const
-            {
-                if(len > 1)
-                {
-                    I last = first + len;
-                    len = (len - 2) / 2;
-                    I i = first + len;
-                    if(invoke(pred, invoke(proj, *i), invoke(proj, *--last)))
-                    {
-                        iter_value_t<I> v = iter_move(last);
-                        do
-                        {
-                            *last = iter_move(i);
-                            last = i;
-                            if(len == 0)
-                                break;
-                            len = (len - 1) / 2;
-                            i = first + len;
-                        } while(invoke(pred, invoke(proj, *i), invoke(proj, v)));
-                        *last = std::move(v);
-                    }
-                }
-            }
-        };
-
-        RANGES_INLINE_VARIABLE(sift_up_n_fn, sift_up_n)
-
-        struct sift_down_n_fn
-        {
-            template<typename I, typename C = less, typename P = identity>
-            void operator()(I first, iter_difference_t<I> len, I start, C pred = C{},
-                            P proj = P{}) const
-            {
-                // left-child of start is at 2 * start + 1
-                // right-child of start is at 2 * start + 2
-                auto child = start - first;
-
-                if(len < 2 || (len - 2) / 2 < child)
-                    return;
-
-                child = 2 * child + 1;
-                I child_i = first + child;
-
-                if((child + 1) < len &&
-                   invoke(pred, invoke(proj, *child_i), invoke(proj, *(child_i + 1))))
-                {
-                    // right-child exists and is greater than left-child
-                    ++child_i;
-                    ++child;
-                }
-
-                // check if we are in heap-order
-                if(invoke(pred, invoke(proj, *child_i), invoke(proj, *start)))
-                    // we are, start is larger than it's largest child
-                    return;
-
-                iter_value_t<I> top = iter_move(start);
-                do
-                {
-                    // we are not in heap-order, swap the parent with it's largest child
-                    *start = iter_move(child_i);
-                    start = child_i;
-
-                    if((len - 2) / 2 < child)
-                        break;
-
-                    // recompute the child based off of the updated parent
-                    child = 2 * child + 1;
-                    child_i = first + child;
-
-                    if((child + 1) < len &&
-                       invoke(pred, invoke(proj, *child_i), invoke(proj, *(child_i + 1))))
-                    {
-                        // right-child exists and is greater than left-child
-                        ++child_i;
-                        ++child;
-                    }
-
-                    // check if we are in heap-order
-                } while(!invoke(pred, invoke(proj, *child_i), invoke(proj, top)));
-                *start = std::move(top);
-            }
-        };
-
-        RANGES_INLINE_VARIABLE(sift_down_n_fn, sift_down_n)
-    } // namespace detail
-    /// \endcond
-
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(push_heap)
-
-        /// \brief function template \c push_heap
-        template(typename I, typename S, typename C = less, typename P = identity)(
-            /// \pre
-            requires random_access_iterator<I> AND sentinel_for<S, I> AND
-            sortable<I, C, P>)
-        I RANGES_FUNC(push_heap)(I first, S last, C pred = C{}, P proj = P{})
-        {
-            auto n = distance(first, last);
-            detail::sift_up_n(first, n, std::move(pred), std::move(proj));
-            return first + n;
-        }
-
-        /// \overload
-        template(typename Rng, typename C = less, typename P = identity)(
-            /// \pre
-            requires random_access_range<Rng> AND sortable<iterator_t<Rng>, C, P>)
-        borrowed_iterator_t<Rng> //
-        RANGES_FUNC(push_heap)(Rng && rng, C pred = C{}, P proj = P{}) //
-        {
-            iterator_t<Rng> first = ranges::begin(rng);
-            auto n = distance(rng);
-            detail::sift_up_n(first, n, std::move(pred), std::move(proj));
-            return first + n;
-        }
-
-    RANGES_FUNC_END(push_heap)
-
-    namespace cpp20
-    {
-        using ranges::push_heap;
-    }
-    /// @}
-
-    /// \cond
-    namespace detail
-    {
-        struct pop_heap_n_fn
-        {
-            template(typename I, typename C = less, typename P = identity)(
-                /// \pre
-                requires random_access_iterator<I> AND sortable<I, C, P>)
-            void operator()(I first, iter_difference_t<I> len, C pred = C{},
-                            P proj = P{}) const
-            {
-                if(len > 1)
-                {
-                    ranges::iter_swap(first, first + (len - 1));
-                    detail::sift_down_n(
-                        first, len - 1, first, std::move(pred), std::move(proj));
-                }
-            }
-        };
-
-        RANGES_INLINE_VARIABLE(pop_heap_n_fn, pop_heap_n)
-    } // namespace detail
-    /// \endcond
-
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(pop_heap)
-
-        /// \brief function template \c pop_heap
-        template(typename I, typename S, typename C = less, typename P = identity)(
-            /// \pre
-            requires random_access_iterator<I> AND sentinel_for<S, I> AND
-            sortable<I, C, P>)
-        I RANGES_FUNC(pop_heap)(I first, S last, C pred = C{}, P proj = P{})
-        {
-            auto n = distance(first, last);
-            detail::pop_heap_n(first, n, std::move(pred), std::move(proj));
-            return first + n;
-        }
-
-        /// \overload
-        template(typename Rng, typename C = less, typename P = identity)(
-            /// \pre
-            requires random_access_range<Rng> AND sortable<iterator_t<Rng>, C, P>)
-        borrowed_iterator_t<Rng> //
-        RANGES_FUNC(pop_heap)(Rng && rng, C pred = C{}, P proj = P{})
-        {
-            iterator_t<Rng> first = ranges::begin(rng);
-            auto n = distance(rng);
-            detail::pop_heap_n(first, n, std::move(pred), std::move(proj));
-            return first + n;
-        }
-
-    RANGES_FUNC_END(pop_heap)
-
-    namespace cpp20
-    {
-        using ranges::pop_heap;
-    }
-
-    RANGES_FUNC_BEGIN(make_heap)
-
-        /// \brief function template \c make_heap
-        template(typename I, typename S, typename C = less, typename P = identity)(
-            /// \pre
-            requires random_access_iterator<I> AND sentinel_for<S, I> AND
-            sortable<I, C, P>)
-        I RANGES_FUNC(make_heap)(I first, S last, C pred = C{}, P proj = P{})
-        {
-            iter_difference_t<I> const n = distance(first, last);
-            if(n > 1)
-                // start from the first parent, there is no need to consider children
-                for(auto start = (n - 2) / 2; start >= 0; --start)
-                    detail::sift_down_n(
-                        first, n, first + start, std::ref(pred), std::ref(proj));
-            return first + n;
-        }
-
-        /// \overload
-        template(typename Rng, typename C = less, typename P = identity)(
-            /// \pre
-            requires random_access_range<Rng> AND sortable<iterator_t<Rng>, C, P>)
-        borrowed_iterator_t<Rng> //
-        RANGES_FUNC(make_heap)(Rng && rng, C pred = C{}, P proj = P{})
-        {
-            iterator_t<Rng> first = ranges::begin(rng);
-            auto const n = distance(rng);
-            if(n > 1)
-                // start from the first parent, there is no need to consider children
-                for(auto start = (n - 2) / 2; start >= 0; --start)
-                    detail::sift_down_n(
-                        first, n, first + start, std::ref(pred), std::ref(proj));
-            return first + n;
-        }
-
-    RANGES_FUNC_END(make_heap)
-
-    namespace cpp20
-    {
-        using ranges::make_heap;
-    }
-
-    RANGES_FUNC_BEGIN(sort_heap)
-
-        template(typename I, typename S, typename C = less, typename P = identity)(
-            /// \pre
-            requires random_access_iterator<I> AND sentinel_for<S, I> AND
-            sortable<I, C, P>)
-        I RANGES_FUNC(sort_heap)(I first, S last, C pred = C{}, P proj = P{})
-        {
-            iter_difference_t<I> const n = distance(first, last);
-            for(auto i = n; i > 1; --i)
-                detail::pop_heap_n(first, i, std::ref(pred), std::ref(proj));
-            return first + n;
-        }
-
-        template(typename Rng, typename C = less, typename P = identity)(
-            /// \pre
-            requires random_access_range<Rng &> AND sortable<iterator_t<Rng>, C, P>)
-        borrowed_iterator_t<Rng> //
-        RANGES_FUNC(sort_heap)(Rng && rng, C pred = C{}, P proj = P{})
-        {
-            iterator_t<Rng> first = ranges::begin(rng);
-            auto const n = distance(rng);
-            for(auto i = n; i > 1; --i)
-                detail::pop_heap_n(first, i, std::ref(pred), std::ref(proj));
-            return first + n;
-        }
-
-    RANGES_FUNC_END(sort_heap)
-
-    namespace cpp20
-    {
-        using ranges::sort_heap;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/inplace_merge.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/inplace_merge.hpp
deleted file mode 100644
index 336a868c..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/inplace_merge.hpp
+++ /dev/null
@@ -1,307 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-#ifndef RANGES_V3_ALGORITHM_INPLACE_MERGE_HPP
-#define RANGES_V3_ALGORITHM_INPLACE_MERGE_HPP
-
-#include <functional>
-#include <memory>
-#include <new>
-#include <type_traits>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/lower_bound.hpp>
-#include <range/v3/algorithm/merge.hpp>
-#include <range/v3/algorithm/min.hpp>
-#include <range/v3/algorithm/move.hpp>
-#include <range/v3/algorithm/rotate.hpp>
-#include <range/v3/algorithm/upper_bound.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/functional/not_fn.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/move_iterators.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/reverse_iterator.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/memory.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/utility/swap.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        struct merge_adaptive_fn
-        {
-        private:
-            template<typename I, typename C, typename P>
-            static void impl(I first, I middle, I last, iter_difference_t<I> len1,
-                             iter_difference_t<I> len2, iter_value_t<I> * const buf,
-                             C & pred, P & proj)
-            {
-                auto tmpbuf = make_raw_buffer(buf);
-                if(len1 <= len2)
-                {
-                    auto p = ranges::move(first, middle, tmpbuf.begin()).out;
-                    merge(make_move_iterator(buf),
-                          make_move_iterator(p.base().base()),
-                          make_move_iterator(std::move(middle)),
-                          make_move_iterator(std::move(last)),
-                          std::move(first),
-                          std::ref(pred),
-                          std::ref(proj),
-                          std::ref(proj));
-                }
-                else
-                {
-                    auto p = ranges::move(middle, last, tmpbuf.begin()).out;
-                    using RBi = ranges::reverse_iterator<I>;
-                    using Rv = ranges::reverse_iterator<iter_value_t<I> *>;
-                    merge(make_move_iterator(RBi{std::move(middle)}),
-                          make_move_iterator(RBi{std::move(first)}),
-                          make_move_iterator(Rv{p.base().base()}),
-                          make_move_iterator(Rv{buf}),
-                          RBi{std::move(last)},
-                          not_fn(std::ref(pred)),
-                          std::ref(proj),
-                          std::ref(proj));
-                }
-            }
-
-        public:
-            template(typename I, typename C = less, typename P = identity)(
-                /// \pre
-                requires bidirectional_iterator<I> AND sortable<I, C, P>)
-            void operator()(I first, I middle, I last, iter_difference_t<I> len1,
-                            iter_difference_t<I> len2, iter_value_t<I> * buf,
-                            std::ptrdiff_t buf_size, C pred = C{}, P proj = P{}) const
-            {
-                using D = iter_difference_t<I>;
-                while(true)
-                {
-                    // if middle == last, we're done
-                    if(len2 == 0)
-                        return;
-                    // shrink [first, middle) as much as possible (with no moves),
-                    // returning if it shrinks to 0
-                    for(; true; ++first, --len1)
-                    {
-                        if(len1 == 0)
-                            return;
-                        if(invoke(pred, invoke(proj, *middle), invoke(proj, *first)))
-                            break;
-                    }
-                    if(len1 <= buf_size || len2 <= buf_size)
-                    {
-                        merge_adaptive_fn::impl(std::move(first),
-                                                std::move(middle),
-                                                std::move(last),
-                                                len1,
-                                                len2,
-                                                buf,
-                                                pred,
-                                                proj);
-                        return;
-                    }
-                    // first < middle < end
-                    // *first > *middle
-                    // partition [first, m1) [m1, middle) [middle, m2) [m2, last) such
-                    // that
-                    //     all elements in:
-                    //         [first, m1)  <= [middle, m2)
-                    //         [middle, m2) <  [m1, middle)
-                    //         [m1, middle) <= [m2, last)
-                    //     and m1 or m2 is in the middle of its range
-                    I m1;    // "median" of [first, middle)
-                    I m2;    // "median" of [middle, last)
-                    D len11; // distance(first, m1)
-                    D len21; // distance(middle, m2)
-                    // binary search smaller range
-                    if(len1 < len2)
-                    { // len >= 1, len2 >= 2
-                        len21 = len2 / 2;
-                        m2 = next(middle, len21);
-                        m1 = upper_bound(first,
-                                         middle,
-                                         invoke(proj, *m2),
-                                         std::ref(pred),
-                                         std::ref(proj));
-                        len11 = distance(first, m1);
-                    }
-                    else
-                    {
-                        if(len1 == 1)
-                        { // len1 >= len2 && len2 > 0, therefore len2 == 1
-                            // It is known *first > *middle
-                            ranges::iter_swap(first, middle);
-                            return;
-                        }
-                        // len1 >= 2, len2 >= 1
-                        len11 = len1 / 2;
-                        m1 = next(first, len11);
-                        m2 = lower_bound(middle,
-                                         last,
-                                         invoke(proj, *m1),
-                                         std::ref(pred),
-                                         std::ref(proj));
-                        len21 = distance(middle, m2);
-                    }
-                    D len12 = len1 - len11; // distance(m1, middle)
-                    D len22 = len2 - len21; // distance(m2, last)
-                    // [first, m1) [m1, middle) [middle, m2) [m2, last)
-                    // swap middle two partitions
-                    middle = rotate(m1, std::move(middle), m2).begin();
-                    // len12 and len21 now have swapped meanings
-                    // merge smaller range with recursive call and larger with tail
-                    // recursion elimination
-                    if(len11 + len21 < len12 + len22)
-                    {
-                        (*this)(std::move(first),
-                                std::move(m1),
-                                middle,
-                                len11,
-                                len21,
-                                buf,
-                                buf_size,
-                                std::ref(pred),
-                                std::ref(proj));
-                        first = std::move(middle);
-                        middle = std::move(m2);
-                        len1 = len12;
-                        len2 = len22;
-                    }
-                    else
-                    {
-                        (*this)(middle,
-                                std::move(m2),
-                                std::move(last),
-                                len12,
-                                len22,
-                                buf,
-                                buf_size,
-                                std::ref(pred),
-                                std::ref(proj));
-                        last = std::move(middle);
-                        middle = std::move(m1);
-                        len1 = len11;
-                        len2 = len21;
-                    }
-                }
-            }
-        };
-
-        RANGES_INLINE_VARIABLE(merge_adaptive_fn, merge_adaptive)
-
-        struct inplace_merge_no_buffer_fn
-        {
-            template(typename I, typename C = less, typename P = identity)(
-                /// \pre
-                requires bidirectional_iterator<I> AND sortable<I, C, P>)
-            void operator()(I first, I middle, I last, iter_difference_t<I> len1,
-                            iter_difference_t<I> len2, C pred = C{}, P proj = P{}) const
-            {
-                merge_adaptive(std::move(first),
-                               std::move(middle),
-                               std::move(last),
-                               len1,
-                               len2,
-                               static_cast<iter_value_t<I> *>(nullptr),
-                               0,
-                               std::move(pred),
-                               std::move(proj));
-            }
-        };
-
-        RANGES_INLINE_VARIABLE(inplace_merge_no_buffer_fn, inplace_merge_no_buffer)
-    } // namespace detail
-    /// \endcond
-
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(inplace_merge)
-
-        // TODO reimplement to only need forward iterators
-
-        /// \brief function template \c inplace_merge
-        template(typename I, typename S, typename C = less, typename P = identity)(
-            /// \pre
-            requires bidirectional_iterator<I> AND sortable<I, C, P>)
-        I RANGES_FUNC(inplace_merge)(
-            I first, I middle, S last, C pred = C{}, P proj = P{})
-        {
-            using value_type = iter_value_t<I>;
-            auto len1 = distance(first, middle);
-            auto len2_and_end = enumerate(middle, last);
-            auto buf_size = ranges::min(len1, len2_and_end.first);
-            std::pair<value_type *, std::ptrdiff_t> buf{nullptr, 0};
-            std::unique_ptr<value_type, detail::return_temporary_buffer> h;
-            if(detail::is_trivially_copy_assignable_v<value_type> && 8 < buf_size)
-            {
-                buf = detail::get_temporary_buffer<value_type>(buf_size);
-                h.reset(buf.first);
-            }
-            detail::merge_adaptive(std::move(first),
-                                   std::move(middle),
-                                   len2_and_end.second,
-                                   len1,
-                                   len2_and_end.first,
-                                   buf.first,
-                                   buf.second,
-                                   std::move(pred),
-                                   std::move(proj));
-            return len2_and_end.second;
-        }
-
-        /// \overload
-        template(typename Rng, typename C = less, typename P = identity)(
-            /// \pre
-            requires bidirectional_range<Rng> AND sortable<iterator_t<Rng>, C, P>)
-        borrowed_iterator_t<Rng> RANGES_FUNC(inplace_merge)(
-            Rng && rng, iterator_t<Rng> middle, C pred = C{}, P proj = P{})
-        {
-            return (*this)(begin(rng),
-                           std::move(middle),
-                           end(rng),
-                           std::move(pred),
-                           std::move(proj));
-        }
-
-    RANGES_FUNC_END(inplace_merge)
-
-    namespace cpp20
-    {
-        using ranges::inplace_merge;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/is_partitioned.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/is_partitioned.hpp
deleted file mode 100644
index 1c1a34d1..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/is_partitioned.hpp
+++ /dev/null
@@ -1,82 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//===-------------------------- algorithm ---------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-#ifndef RANGES_V3_ALGORITHM_IS_PARTITIONED_HPP
-#define RANGES_V3_ALGORITHM_IS_PARTITIONED_HPP
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(is_partitioned)
-
-        /// \brief function template \c is_partitioned
-        template(typename I, typename S, typename C, typename P = identity)(
-            /// \pre
-            requires input_iterator<I> AND sentinel_for<S, I> AND
-            indirect_unary_predicate<C, projected<I, P>>)
-        bool RANGES_FUNC(is_partitioned)(I first, S last, C pred, P proj = P{}) //
-        {
-            for(; first != last; ++first)
-                if(!invoke(pred, invoke(proj, *first)))
-                    break;
-            for(; first != last; ++first)
-                if(invoke(pred, invoke(proj, *first)))
-                    return false;
-            return true;
-        }
-
-        /// \overload
-        template(typename Rng, typename C, typename P = identity)(
-            /// \pre
-            requires input_range<Rng> AND
-            indirect_unary_predicate<C, projected<iterator_t<Rng>, P>>)
-        bool RANGES_FUNC(is_partitioned)(Rng && rng, C pred, P proj = P{}) //
-        {
-            return (*this)(begin(rng), end(rng), std::move(pred), std::move(proj));
-        }
-
-    RANGES_FUNC_END(is_partitioned)
-
-    namespace cpp20
-    {
-        using ranges::is_partitioned;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/is_sorted.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/is_sorted.hpp
deleted file mode 100644
index c3e01555..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/is_sorted.hpp
+++ /dev/null
@@ -1,79 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//  Copyright Gonzalo Brito Gadeschi 2014
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-// Implementation based on the code in libc++
-//   http://http://libcxx.llvm.org/
-#ifndef RANGES_V3_ALGORITHM_IS_SORTED_HPP
-#define RANGES_V3_ALGORITHM_IS_SORTED_HPP
-
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/is_sorted_until.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(is_sorted)
-        /// \brief template function \c is_sorted
-        ///
-        /// range-based version of the \c is_sorted std algorithm
-        ///
-        /// Works on forward_ranges
-        ///
-        /// \pre `Rng` is a model of the `forward_range` concept
-        /// \pre `I` is a model of the `forward_iterator` concept
-        /// \pre `S` and `I` model the `sentinel_for<S, I>` concept
-        /// \pre `R` and `projected<I, P>` model the `indirect_strict_weak_order<R,
-        /// projected<I, P>>` concept
-        ///
-        template(typename I, typename S, typename R = less, typename P = identity)(
-            /// \pre
-            requires forward_iterator<I> AND sentinel_for<S, I> AND
-            indirect_strict_weak_order<R, projected<I, P>>)
-        bool RANGES_FUNC(is_sorted)(I first, S last, R rel = R{}, P proj = P{})
-        {
-            return is_sorted_until(
-                       std::move(first), last, std::move(rel), std::move(proj)) == last;
-        }
-
-        /// \overload
-        template(typename Rng, typename R = less, typename P = identity)(
-            /// \pre
-            requires forward_range<Rng> AND
-            indirect_strict_weak_order<R, projected<iterator_t<Rng>, P>>)
-        bool RANGES_FUNC(is_sorted)(Rng && rng, R rel = R{}, P proj = P{}) //
-        {
-            return (*this)(begin(rng), end(rng), std::move(rel), std::move(proj));
-        }
-
-    RANGES_FUNC_END(is_sorted)
-
-    namespace cpp20
-    {
-        using ranges::is_sorted;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/is_sorted_until.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/is_sorted_until.hpp
deleted file mode 100644
index 590cae0d..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/is_sorted_until.hpp
+++ /dev/null
@@ -1,91 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//  Copyright Gonzalo Brito Gadeschi 2014
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-// Implementation based on the code in libc++
-//   http://http://libcxx.llvm.org/
-#ifndef RANGES_V3_ALGORITHM_IS_SORTED_UNTIL_HPP
-#define RANGES_V3_ALGORITHM_IS_SORTED_UNTIL_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(is_sorted_until)
-        /// \brief template function \c is_sorted_until
-        ///
-        /// range-based version of the \c is_sorted_until std algorithm
-        ///
-        /// Works on forward_ranges
-        ///
-        /// \pre `Rng` is a model of the `forward_range` concept
-        /// \pre `I` is a model of the `forward_iterator` concept
-        /// \pre `S` and `I` model the `sentinel_for<S, I>` concept
-        /// \pre `R` and `projected<I, P>` model the `indirect_strict_weak_order<R,
-        /// projected<I, P>>` concept
-        ///
-        template(typename I, typename S, typename R = less, typename P = identity)(
-            /// \pre
-            requires forward_iterator<I> AND sentinel_for<S, I> AND
-            indirect_strict_weak_order<R, projected<I, P>>)
-        I RANGES_FUNC(is_sorted_until)(I first, S last, R pred = R{}, P proj = P{})
-        {
-            auto i = first;
-            if(first != last)
-            {
-                while(++i != last)
-                {
-                    if(invoke(pred, invoke(proj, *i), invoke(proj, *first)))
-                        return i;
-                    first = i;
-                }
-            }
-            return i;
-        }
-
-        /// \overload
-        template(typename Rng, typename R = less, typename P = identity)(
-            /// \pre
-            requires forward_range<Rng> AND
-            indirect_strict_weak_order<R, projected<iterator_t<Rng>, P>>)
-        borrowed_iterator_t<Rng> //
-        RANGES_FUNC(is_sorted_until)(Rng && rng, R pred = R{}, P proj = P{})
-        {
-            return (*this)(begin(rng), end(rng), std::move(pred), std::move(proj));
-        }
-
-    RANGES_FUNC_END(is_sorted_until)
-
-    namespace cpp20
-    {
-        using ranges::is_sorted_until;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/lexicographical_compare.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/lexicographical_compare.hpp
deleted file mode 100644
index c0432f93..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/lexicographical_compare.hpp
+++ /dev/null
@@ -1,101 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_LEXICOGRAPHICAL_COMPARE_HPP
-#define RANGES_V3_ALGORITHM_LEXICOGRAPHICAL_COMPARE_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(lexicographical_compare)
-
-        /// \brief function template \c lexicographical_compare
-        template(typename I0,
-                 typename S0,
-                 typename I1,
-                 typename S1,
-                 typename C = less,
-                 typename P0 = identity,
-                 typename P1 = identity)(
-            /// \pre
-            requires input_iterator<I0> AND sentinel_for<S0, I0> AND
-                input_iterator<I1> AND sentinel_for<S1, I1> AND
-                indirect_strict_weak_order<C, projected<I0, P0>, projected<I1, P1>>)
-        bool RANGES_FUNC(lexicographical_compare)(I0 begin0,
-                                                  S0 end0,
-                                                  I1 begin1,
-                                                  S1 end1,
-                                                  C pred = C{},
-                                                  P0 proj0 = P0{},
-                                                  P1 proj1 = P1{})
-        {
-            for(; begin1 != end1; ++begin0, ++begin1)
-            {
-                if(begin0 == end0 ||
-                   invoke(pred, invoke(proj0, *begin0), invoke(proj1, *begin1)))
-                    return true;
-                if(invoke(pred, invoke(proj1, *begin1), invoke(proj0, *begin0)))
-                    return false;
-            }
-            return false;
-        }
-
-        /// \overload
-        template(typename Rng0,
-                 typename Rng1,
-                 typename C = less,
-                 typename P0 = identity,
-                 typename P1 = identity)(
-            /// \pre
-            requires input_range<Rng0> AND input_range<Rng1> AND
-                indirect_strict_weak_order<C,
-                                           projected<iterator_t<Rng0>, P0>,
-                                           projected<iterator_t<Rng1>, P1>>)
-        bool RANGES_FUNC(lexicographical_compare)(
-            Rng0 && rng0, Rng1 && rng1, C pred = C{}, P0 proj0 = P0{}, P1 proj1 = P1{}) //
-        {
-            return (*this)(begin(rng0),
-                           end(rng0),
-                           begin(rng1),
-                           end(rng1),
-                           std::move(pred),
-                           std::move(proj0),
-                           std::move(proj1));
-        }
-
-    RANGES_FUNC_END(lexicographical_compare)
-
-    namespace cpp20
-    {
-        using ranges::lexicographical_compare;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/lower_bound.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/lower_bound.hpp
deleted file mode 100644
index f740908a..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/lower_bound.hpp
+++ /dev/null
@@ -1,80 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_LOWER_BOUND_HPP
-#define RANGES_V3_ALGORITHM_LOWER_BOUND_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/aux_/lower_bound_n.hpp>
-#include <range/v3/algorithm/partition_point.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(lower_bound)
-
-        /// \brief function template \c lower_bound
-        template(typename I,
-                 typename S,
-                 typename V,
-                 typename C = less,
-                 typename P = identity)(
-            /// \pre
-            requires forward_iterator<I> AND sentinel_for<S, I> AND
-                indirect_strict_weak_order<C, V const *, projected<I, P>>)
-        I RANGES_FUNC(lower_bound)(
-            I first, S last, V const & val, C pred = C{}, P proj = P{})
-        {
-            return partition_point(std::move(first),
-                                   std::move(last),
-                                   detail::make_lower_bound_predicate(pred, val),
-                                   std::move(proj));
-        }
-
-        /// \overload
-        template(typename Rng, typename V, typename C = less, typename P = identity)(
-            /// \pre
-            requires forward_range<Rng> AND
-                indirect_strict_weak_order<C, V const *, projected<iterator_t<Rng>, P>>)
-        borrowed_iterator_t<Rng> //
-        RANGES_FUNC(lower_bound)(Rng && rng, V const & val, C pred = C{}, P proj = P{})
-        {
-            return partition_point(
-                rng, detail::make_lower_bound_predicate(pred, val), std::move(proj));
-        }
-
-    RANGES_FUNC_END(lower_bound)
-
-    namespace cpp20
-    {
-        using ranges::lower_bound;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/max.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/max.hpp
deleted file mode 100644
index da642788..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/max.hpp
+++ /dev/null
@@ -1,93 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Casey Carter 2015
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_MAX_HPP
-#define RANGES_V3_ALGORITHM_MAX_HPP
-
-#include <initializer_list>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(max)
-
-        /// \brief function template \c max
-        template(typename T, typename C = less, typename P = identity)(
-            /// \pre
-            requires indirect_strict_weak_order<C, projected<T const *, P>>)
-        constexpr T const & RANGES_FUNC(max)(
-            T const & a, T const & b, C pred = C{}, P proj = P{}) //
-        {
-            return invoke(pred, invoke(proj, b), invoke(proj, a)) ? a : b;
-        }
-
-        /// \overload
-        template(typename Rng, typename C = less, typename P = identity)(
-            /// \pre
-            requires input_range<Rng> AND
-            indirect_strict_weak_order<C, projected<iterator_t<Rng>, P>> AND
-            indirectly_copyable_storable<iterator_t<Rng>, range_value_t<Rng> *>)
-        constexpr range_value_t<Rng> //
-        RANGES_FUNC(max)(Rng && rng, C pred = C{}, P proj = P{}) //
-        {
-            auto first = ranges::begin(rng);
-            auto last = ranges::end(rng);
-            RANGES_EXPECT(first != last);
-            range_value_t<Rng> result = *first;
-            while(++first != last)
-            {
-                auto && tmp = *first;
-                if(invoke(pred, invoke(proj, result), invoke(proj, tmp)))
-                    result = (decltype(tmp) &&)tmp;
-            }
-            return result;
-        }
-
-        /// \overload
-        template(typename T, typename C = less, typename P = identity)(
-            /// \pre
-            requires copyable<T> AND
-                indirect_strict_weak_order<C, projected<T const *, P>>)
-        constexpr T RANGES_FUNC(max)(
-            std::initializer_list<T> const && rng, C pred = C{}, P proj = P{}) //
-        {
-            return (*this)(rng, std::move(pred), std::move(proj));
-        }
-
-    RANGES_FUNC_END(max)
-
-    namespace cpp20
-    {
-        using ranges::max;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/max_element.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/max_element.hpp
deleted file mode 100644
index 3b4f7557..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/max_element.hpp
+++ /dev/null
@@ -1,74 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_MAX_ELEMENT_HPP
-#define RANGES_V3_ALGORITHM_MAX_ELEMENT_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(max_element)
-
-        /// \brief function template \c max_element
-        template(typename I, typename S, typename C = less, typename P = identity)(
-            /// \pre
-            requires forward_iterator<I> AND sentinel_for<S, I> AND
-            indirect_strict_weak_order<C, projected<I, P>>)
-        I RANGES_FUNC(max_element)(I first, S last, C pred = C{}, P proj = P{})
-        {
-            if(first != last)
-                for(auto tmp = next(first); tmp != last; ++tmp)
-                    if(invoke(pred, invoke(proj, *first), invoke(proj, *tmp)))
-                        first = tmp;
-            return first;
-        }
-
-        /// \overload
-        template(typename Rng, typename C = less, typename P = identity)(
-            /// \pre
-            requires forward_range<Rng> AND
-            indirect_strict_weak_order<C, projected<iterator_t<Rng>, P>>)
-        borrowed_iterator_t<Rng> //
-        RANGES_FUNC(max_element)(Rng && rng, C pred = C{}, P proj = P{})
-        {
-            return (*this)(begin(rng), end(rng), std::move(pred), std::move(proj));
-        }
-
-    RANGES_FUNC_END(max_element)
-
-    namespace cpp20
-    {
-        using ranges::max_element;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/merge.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/merge.hpp
deleted file mode 100644
index da5ee243..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/merge.hpp
+++ /dev/null
@@ -1,138 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-// Copyright (c) 2009 Alexander Stepanov and Paul McJones
-//
-// Permission to use, copy, modify, distribute and sell this software
-// and its documentation for any purpose is hereby granted without
-// fee, provided that the above copyright notice appear in all copies
-// and that both that copyright notice and this permission notice
-// appear in supporting documentation. The authors make no
-// representations about the suitability of this software for any
-// purpose. It is provided "as is" without express or implied
-// warranty.
-//
-// Algorithms from
-// Elements of Programming
-// by Alexander Stepanov and Paul McJones
-// Addison-Wesley Professional, 2009
-
-#ifndef RANGES_V3_ALGORITHM_MERGE_HPP
-#define RANGES_V3_ALGORITHM_MERGE_HPP
-
-#include <tuple>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/copy.hpp>
-#include <range/v3/algorithm/result_types.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    template<typename I0, typename I1, typename O>
-    using merge_result = detail::in1_in2_out_result<I0, I1, O>;
-
-    RANGES_FUNC_BEGIN(merge)
-
-        /// \brief function template \c merge
-        template(typename I0,
-                 typename S0,
-                 typename I1,
-                 typename S1,
-                 typename O,
-                 typename C = less,
-                 typename P0 = identity,
-                 typename P1 = identity)(
-            /// \pre
-            requires sentinel_for<S0, I0> AND sentinel_for<S1, I1> AND
-                mergeable<I0, I1, O, C, P0, P1>)
-        merge_result<I0, I1, O> RANGES_FUNC(merge)(I0 begin0,
-                                                   S0 end0,
-                                                   I1 begin1,
-                                                   S1 end1,
-                                                   O out,
-                                                   C pred = C{},
-                                                   P0 proj0 = P0{},
-                                                   P1 proj1 = P1{}) //
-        {
-            for(; begin0 != end0 && begin1 != end1; ++out)
-            {
-                if(invoke(pred, invoke(proj1, *begin1), invoke(proj0, *begin0)))
-                {
-                    *out = *begin1;
-                    ++begin1;
-                }
-                else
-                {
-                    *out = *begin0;
-                    ++begin0;
-                }
-            }
-            auto t0 = ranges::copy(begin0, end0, out);
-            auto t1 = ranges::copy(begin1, end1, t0.out);
-            return {t0.in, t1.in, t1.out};
-        }
-
-        /// \overload
-        template(typename Rng0,
-                 typename Rng1,
-                 typename O,
-                 typename C = less,
-                 typename P0 = identity,
-                 typename P1 = identity)(
-            /// \pre
-            requires range<Rng0> AND range<Rng1> AND
-                mergeable<iterator_t<Rng0>, iterator_t<Rng1>, O, C, P0, P1>)
-        merge_result<borrowed_iterator_t<Rng0>, borrowed_iterator_t<Rng1>, O>
-        RANGES_FUNC(merge)(Rng0 && rng0,
-                           Rng1 && rng1,
-                           O out,
-                           C pred = C{},
-                           P0 proj0 = P0{},
-                           P1 proj1 = P1{})
-        {
-            return (*this)(begin(rng0),
-                           end(rng0),
-                           begin(rng1),
-                           end(rng1),
-                           std::move(out),
-                           std::move(pred),
-                           std::move(proj0),
-                           std::move(proj1));
-        }
-
-    RANGES_FUNC_END(merge)
-
-    namespace cpp20
-    {
-        using ranges::merge;
-        using ranges::merge_result;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/min.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/min.hpp
deleted file mode 100644
index 2fba9f02..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/min.hpp
+++ /dev/null
@@ -1,93 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Casey Carter 2015
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_MIN_HPP
-#define RANGES_V3_ALGORITHM_MIN_HPP
-
-#include <initializer_list>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(min)
-
-        /// \brief function template \c min
-        template(typename T, typename C = less, typename P = identity)(
-            /// \pre
-            requires indirect_strict_weak_order<C, projected<T const *, P>>)
-        constexpr T const & RANGES_FUNC(min)(
-            T const & a, T const & b, C pred = C{}, P proj = P{}) //
-        {
-            return invoke(pred, invoke(proj, b), invoke(proj, a)) ? b : a;
-        }
-
-        /// \overload
-        template(typename Rng, typename C = less, typename P = identity)(
-            /// \pre
-            requires input_range<Rng> AND
-            indirect_strict_weak_order<C, projected<iterator_t<Rng>, P>> AND
-            indirectly_copyable_storable<iterator_t<Rng>, range_value_t<Rng> *>)
-        constexpr range_value_t<Rng> //
-        RANGES_FUNC(min)(Rng && rng, C pred = C{}, P proj = P{}) //
-        {
-            auto first = ranges::begin(rng);
-            auto last = ranges::end(rng);
-            RANGES_EXPECT(first != last);
-            range_value_t<Rng> result = *first;
-            while(++first != last)
-            {
-                auto && tmp = *first;
-                if(invoke(pred, invoke(proj, tmp), invoke(proj, result)))
-                    result = (decltype(tmp) &&)tmp;
-            }
-            return result;
-        }
-
-        /// \overload
-        template(typename T, typename C = less, typename P = identity)(
-            /// \pre
-            requires copyable<T> AND
-                indirect_strict_weak_order<C, projected<T const *, P>>)
-        constexpr T RANGES_FUNC(min)(
-            std::initializer_list<T> const && rng, C pred = C{}, P proj = P{}) //
-        {
-            return (*this)(rng, std::move(pred), std::move(proj));
-        }
-
-    RANGES_FUNC_END(min)
-
-    namespace cpp20
-    {
-        using ranges::min;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/min_element.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/min_element.hpp
deleted file mode 100644
index ad0d5fa9..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/min_element.hpp
+++ /dev/null
@@ -1,74 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_MIN_ELEMENT_HPP
-#define RANGES_V3_ALGORITHM_MIN_ELEMENT_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(min_element)
-
-        /// \brief function template \c min_element
-        template(typename I, typename S, typename C = less, typename P = identity)(
-            /// \pre
-            requires forward_iterator<I> AND sentinel_for<S, I> AND
-            indirect_strict_weak_order<C, projected<I, P>>)
-        I RANGES_FUNC(min_element)(I first, S last, C pred = C{}, P proj = P{})
-        {
-            if(first != last)
-                for(auto tmp = next(first); tmp != last; ++tmp)
-                    if(invoke(pred, invoke(proj, *tmp), invoke(proj, *first)))
-                        first = tmp;
-            return first;
-        }
-
-        /// \overload
-        template(typename Rng, typename C = less, typename P = identity)(
-            /// \pre
-            requires forward_range<Rng> AND
-            indirect_strict_weak_order<C, projected<iterator_t<Rng>, P>>)
-        borrowed_iterator_t<Rng> //
-        RANGES_FUNC(min_element)(Rng && rng, C pred = C{}, P proj = P{}) //
-        {
-            return (*this)(begin(rng), end(rng), std::move(pred), std::move(proj));
-        }
-
-    RANGES_FUNC_END(min_element)
-
-    namespace cpp20
-    {
-        using ranges::min_element;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/minmax.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/minmax.hpp
deleted file mode 100644
index 05306e4e..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/minmax.hpp
+++ /dev/null
@@ -1,133 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Casey Carter 2015
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_MINMAX_HPP
-#define RANGES_V3_ALGORITHM_MINMAX_HPP
-
-#include <initializer_list>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/result_types.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    template<typename T>
-    using minmax_result = detail::min_max_result<T, T>;
-
-    RANGES_FUNC_BEGIN(minmax)
-
-        /// \brief function template \c minmax
-        template(typename T, typename C = less, typename P = identity)(
-            /// \pre
-            requires indirect_strict_weak_order<C, projected<T const *, P>>)
-        constexpr minmax_result<T const &> RANGES_FUNC(minmax)(
-            T const & a, T const & b, C pred = C{}, P proj = P{}) //
-        {
-            using R = minmax_result<T const &>;
-            return invoke(pred, invoke(proj, b), invoke(proj, a)) ? R{b, a} : R{a, b};
-        }
-
-        /// \overload
-        template(typename Rng, typename C = less, typename P = identity)(
-            /// \pre
-            requires input_range<Rng> AND
-            indirect_strict_weak_order<C, projected<iterator_t<Rng>, P>> AND
-            indirectly_copyable_storable<iterator_t<Rng>, range_value_t<Rng> *>)
-        constexpr minmax_result<range_value_t<Rng>> //
-        RANGES_FUNC(minmax)(Rng && rng, C pred = C{}, P proj = P{}) //
-        {
-            using R = minmax_result<range_value_t<Rng>>;
-            auto first = ranges::begin(rng);
-            auto last = ranges::end(rng);
-            RANGES_EXPECT(first != last);
-            auto result = R{*first, *first};
-            if(++first != last)
-            {
-                {
-                    auto && tmp = *first;
-                    if(invoke(pred, invoke(proj, tmp), invoke(proj, result.min)))
-                        result.min = (decltype(tmp) &&)tmp;
-                    else
-                        result.max = (decltype(tmp) &&)tmp;
-                }
-                while(++first != last)
-                {
-                    range_value_t<Rng> tmp1 = *first;
-                    if(++first == last)
-                    {
-                        if(invoke(pred, invoke(proj, tmp1), invoke(proj, result.min)))
-                            result.min = std::move(tmp1);
-                        else if(!invoke(
-                                    pred, invoke(proj, tmp1), invoke(proj, result.max)))
-                            result.max = std::move(tmp1);
-                        break;
-                    }
-
-                    auto && tmp2 = *first;
-                    if(invoke(pred, invoke(proj, tmp2), invoke(proj, tmp1)))
-                    {
-                        if(invoke(pred, invoke(proj, tmp2), invoke(proj, result.min)))
-                            result.min = (decltype(tmp2) &&)tmp2;
-                        if(!invoke(pred, invoke(proj, tmp1), invoke(proj, result.max)))
-                            result.max = std::move(tmp1);
-                    }
-                    else
-                    {
-                        if(invoke(pred, invoke(proj, tmp1), invoke(proj, result.min)))
-                            result.min = std::move(tmp1);
-                        if(!invoke(pred, invoke(proj, tmp2), invoke(proj, result.max)))
-                            result.max = (decltype(tmp2) &&)tmp2;
-                    }
-                }
-            }
-            return result;
-        }
-
-        /// \overload
-        template(typename T, typename C = less, typename P = identity)(
-            /// \pre
-            requires copyable<T> AND
-                indirect_strict_weak_order<C, projected<T const *, P>>)
-        constexpr minmax_result<T> RANGES_FUNC(minmax)(
-            std::initializer_list<T> const && rng, C pred = C{}, P proj = P{}) //
-        {
-            return (*this)(rng, std::move(pred), std::move(proj));
-        }
-
-    RANGES_FUNC_END(minmax)
-
-    namespace cpp20
-    {
-        using ranges::minmax;
-        using ranges::minmax_result;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/minmax_element.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/minmax_element.hpp
deleted file mode 100644
index 58f955e9..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/minmax_element.hpp
+++ /dev/null
@@ -1,114 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-// Implementation based on the code in libc++
-//   http://http://libcxx.llvm.org/
-
-#ifndef RANGES_V3_ALGORITHM_MINMAX_ELEMENT_HPP
-#define RANGES_V3_ALGORITHM_MINMAX_ELEMENT_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/result_types.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    template<typename I>
-    using minmax_element_result = detail::min_max_result<I, I>;
-
-    RANGES_FUNC_BEGIN(minmax_element)
-
-        /// \brief function template \c minmax_element
-        template(typename I, typename S, typename C = less, typename P = identity)(
-            /// \pre
-            requires forward_iterator<I> AND sentinel_for<S, I> AND
-            indirect_strict_weak_order<C, projected<I, P>>)
-        minmax_element_result<I> //
-        RANGES_FUNC(minmax_element)(I first, S last, C pred = C{}, P proj = P{}) //
-        {
-            minmax_element_result<I> result{first, first};
-            if(first == last || ++first == last)
-                return result;
-            if(invoke(pred, invoke(proj, *first), invoke(proj, *result.min)))
-                result.min = first;
-            else
-                result.max = first;
-            while(++first != last)
-            {
-                I tmp = first;
-                if(++first == last)
-                {
-                    if(invoke(pred, invoke(proj, *tmp), invoke(proj, *result.min)))
-                        result.min = tmp;
-                    else if(!invoke(pred, invoke(proj, *tmp), invoke(proj, *result.max)))
-                        result.max = tmp;
-                    break;
-                }
-                else
-                {
-                    if(invoke(pred, invoke(proj, *first), invoke(proj, *tmp)))
-                    {
-                        if(invoke(pred, invoke(proj, *first), invoke(proj, *result.min)))
-                            result.min = first;
-                        if(!invoke(pred, invoke(proj, *tmp), invoke(proj, *result.max)))
-                            result.max = tmp;
-                    }
-                    else
-                    {
-                        if(invoke(pred, invoke(proj, *tmp), invoke(proj, *result.min)))
-                            result.min = tmp;
-                        if(!invoke(pred, invoke(proj, *first), invoke(proj, *result.max)))
-                            result.max = first;
-                    }
-                }
-            }
-            return result;
-        }
-
-        /// \overload
-        template(typename Rng, typename C = less, typename P = identity)(
-            /// \pre
-            requires forward_range<Rng> AND
-            indirect_strict_weak_order<C, projected<iterator_t<Rng>, P>>)
-        minmax_element_result<borrowed_iterator_t<Rng>> //
-        RANGES_FUNC(minmax_element)(Rng && rng, C pred = C{}, P proj = P{}) //
-        {
-            return (*this)(begin(rng), end(rng), std::move(pred), std::move(proj));
-        }
-
-    RANGES_FUNC_END(minmax_element)
-
-    namespace cpp20
-    {
-        using ranges::minmax_element;
-        using ranges::minmax_element_result;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/mismatch.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/mismatch.hpp
deleted file mode 100644
index 4d6785c9..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/mismatch.hpp
+++ /dev/null
@@ -1,178 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_MISMATCH_HPP
-#define RANGES_V3_ALGORITHM_MISMATCH_HPP
-
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/result_types.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    template<typename I1, typename I2>
-    using mismatch_result = detail::in1_in2_result<I1, I2>;
-
-    RANGES_FUNC_BEGIN(mismatch)
-
-        /// \brief function template \c mismatch
-        template(typename I1,
-                     typename S1,
-                     typename I2,
-                     typename C = equal_to,
-                     typename P1 = identity,
-                     typename P2 = identity)(
-            /// \pre
-            requires input_iterator<I1> AND sentinel_for<S1, I1> AND
-                input_iterator<I2> AND
-                indirect_relation<C, projected<I1, P1>, projected<I2, P2>>)
-        RANGES_DEPRECATED(
-            "Use the variant of ranges::mismatch that takes an upper bound for "
-            "both sequences")
-        mismatch_result<I1, I2> RANGES_FUNC(mismatch)(I1 begin1,
-                                                      S1 end1,
-                                                      I2 begin2,
-                                                      C pred = C{},
-                                                      P1 proj1 = P1{},
-                                                      P2 proj2 = P2{}) //
-        {
-            for(; begin1 != end1; ++begin1, ++begin2)
-                if(!invoke(pred, invoke(proj1, *begin1), invoke(proj2, *begin2)))
-                    break;
-            return {begin1, begin2};
-        }
-
-        /// \overload
-        template(typename I1,
-                     typename S1,
-                     typename I2,
-                     typename S2,
-                     typename C = equal_to,
-                     typename P1 = identity,
-                     typename P2 = identity)(
-            /// \pre
-            requires input_iterator<I1> AND sentinel_for<S1, I1> AND
-                input_iterator<I2> AND sentinel_for<S2, I2> AND
-                indirect_relation<C, projected<I1, P1>, projected<I2, P2>>)
-        mismatch_result<I1, I2> RANGES_FUNC(mismatch)(I1 begin1,
-                                                      S1 end1,
-                                                      I2 begin2,
-                                                      S2 end2,
-                                                      C pred = C{},
-                                                      P1 proj1 = P1{},
-                                                      P2 proj2 = P2{}) //
-        {
-            for(; begin1 != end1 && begin2 != end2; ++begin1, ++begin2)
-                if(!invoke(pred, invoke(proj1, *begin1), invoke(proj2, *begin2)))
-                    break;
-            return {begin1, begin2};
-        }
-
-        /// \overload
-        template(typename Rng1,
-                     typename I2Ref,
-                     typename C = equal_to,
-                     typename P1 = identity,
-                     typename P2 = identity)( //s
-            requires input_range<Rng1> AND input_iterator<uncvref_t<I2Ref>> AND
-                indirect_relation<C,
-                                  projected<iterator_t<Rng1>, P1>,
-                                  projected<uncvref_t<I2Ref>, P2>>)
-        RANGES_DEPRECATED(
-            "Use the variant of ranges::mismatch that takes an upper bound for "
-            "both sequences")
-        mismatch_result<borrowed_iterator_t<Rng1>, uncvref_t<I2Ref>>
-        RANGES_FUNC(mismatch)(Rng1 && rng1,
-                              I2Ref && begin2,
-                              C pred = C{}, // see below [*]
-                              P1 proj1 = P1{},
-                              P2 proj2 = P2{}) //
-        {
-            RANGES_DIAGNOSTIC_PUSH
-            RANGES_DIAGNOSTIC_IGNORE_DEPRECATED_DECLARATIONS
-            return (*this)(begin(rng1),
-                           end(rng1),
-                           static_cast<uncvref_t<I2Ref> &&>(begin2),
-                           std::move(pred),
-                           std::move(proj1),
-                           std::move(proj2));
-            RANGES_DIAGNOSTIC_POP
-        }
-
-        /// \overload
-        template(typename Rng1,
-                     typename Rng2,
-                     typename C = equal_to,
-                     typename P1 = identity,
-                     typename P2 = identity)(
-            /// \pre
-            requires input_range<Rng1> AND input_range<Rng2> AND
-                indirect_relation<C,
-                                  projected<iterator_t<Rng1>, P1>,
-                                  projected<iterator_t<Rng2>, P2>>)
-        mismatch_result<borrowed_iterator_t<Rng1>, borrowed_iterator_t<Rng2>> //
-        RANGES_FUNC(mismatch)(Rng1 && rng1,
-                              Rng2 && rng2,
-                              C pred = C{},
-                              P1 proj1 = P1{},
-                              P2 proj2 = P2{}) //
-        {
-            return (*this)(begin(rng1),
-                           end(rng1),
-                           begin(rng2),
-                           end(rng2),
-                           std::move(pred),
-                           std::move(proj1),
-                           std::move(proj2));
-        }
-
-    RANGES_FUNC_END(mismatch)
-
-    namespace cpp20
-    {
-        using ranges::mismatch;
-        using ranges::mismatch_result;
-    } // namespace cpp20
-
-    // [*] In this case, the 'begin2' iterator is taken by universal reference. Why? So
-    // that we can properly distinguish this case:
-    //   int x[] = {1,2,3,4};
-    //   int y[] = {1,2,3,4};
-    //   mismatch(x, y);
-    // Had 'begin2' been taken by value as is customary, this call could match as either
-    // two ranges, or a range and an iterator, where the iterator is the array, decayed
-    // to a pointer. Yuk!
-
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/move.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/move.hpp
deleted file mode 100644
index 97e06f9e..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/move.hpp
+++ /dev/null
@@ -1,90 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_MOVE_HPP
-#define RANGES_V3_ALGORITHM_MOVE_HPP
-
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/result_types.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/move.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    template<typename I, typename O>
-    using move_result = detail::in_out_result<I, O>;
-
-    RANGES_HIDDEN_DETAIL(namespace _move CPP_PP_LBRACE())
-    RANGES_FUNC_BEGIN(move)
-
-        /// \brief function template \c move
-        template(typename I, typename S, typename O)(
-            /// \pre
-            requires input_iterator<I> AND sentinel_for<S, I> AND
-            weakly_incrementable<O> AND indirectly_movable<I, O>)
-        move_result<I, O> RANGES_FUNC(move)(I first, S last, O out) //
-        {
-            for(; first != last; ++first, ++out)
-                *out = iter_move(first);
-            return {first, out};
-        }
-
-        /// \overload
-        template(typename Rng, typename O)(
-            /// \pre
-            requires input_range<Rng> AND weakly_incrementable<O> AND
-            indirectly_movable<iterator_t<Rng>, O>)
-        move_result<borrowed_iterator_t<Rng>, O> //
-        RANGES_FUNC(move)(Rng && rng, O out)            //
-        {
-            return (*this)(begin(rng), end(rng), std::move(out));
-        }
-
-    RANGES_FUNC_END(move)
-    RANGES_HIDDEN_DETAIL(CPP_PP_RBRACE())
-
-#ifndef RANGES_DOXYGEN_INVOKED
-    struct RANGES_EMPTY_BASES move_fn
-      : aux::move_fn
-      , _move::move_fn
-    {
-        using aux::move_fn::operator();
-        using _move::move_fn::operator();
-    };
-
-    RANGES_INLINE_VARIABLE(move_fn, move)
-#endif
-
-    namespace cpp20
-    {
-        using ranges::move_result;
-        using ranges::RANGES_HIDDEN_DETAIL(_move::) move;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/move_backward.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/move_backward.hpp
deleted file mode 100644
index 04c610bd..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/move_backward.hpp
+++ /dev/null
@@ -1,77 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_MOVE_BACKWARD_HPP
-#define RANGES_V3_ALGORITHM_MOVE_BACKWARD_HPP
-
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/result_types.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    template<typename I, typename O>
-    using move_backward_result = detail::in_out_result<I, O>;
-
-    RANGES_FUNC_BEGIN(move_backward)
-
-        /// \brief function template \c move_backward
-        template(typename I, typename S, typename O)(
-            /// \pre
-            requires bidirectional_iterator<I> AND sentinel_for<S, I> AND
-            bidirectional_iterator<O> AND indirectly_movable<I, O>)
-        move_backward_result<I, O> RANGES_FUNC(move_backward)(I first, S end_, O out) //
-        {
-            I i = ranges::next(first, end_), last = i;
-            while(first != i)
-                *--out = iter_move(--i);
-            return {last, out};
-        }
-
-        /// \overload
-        template(typename Rng, typename O)(
-            /// \pre
-            requires bidirectional_range<Rng> AND bidirectional_iterator<O> AND
-            indirectly_movable<iterator_t<Rng>, O>)
-        move_backward_result<borrowed_iterator_t<Rng>, O> //
-        RANGES_FUNC(move_backward)(Rng && rng, O out)            //
-        {
-            return (*this)(begin(rng), end(rng), std::move(out));
-        }
-
-    RANGES_FUNC_END(move_backward)
-
-    namespace cpp20
-    {
-        using ranges::move_backward;
-        using ranges::move_backward_result;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/none_of.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/none_of.hpp
deleted file mode 100644
index ff433c63..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/none_of.hpp
+++ /dev/null
@@ -1,72 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Andrew Sutton 2014
-//  Copyright Gonzalo Brito Gadeschi 2014
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_NONE_OF_HPP
-#define RANGES_V3_ALGORITHM_NONE_OF_HPP
-
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(none_of)
-
-        /// \brief function template \c none_of
-        template(typename I, typename S, typename F, typename P = identity)(
-            /// \pre
-            requires input_iterator<I> AND sentinel_for<S, I> AND
-            indirect_unary_predicate<F, projected<I, P>>)
-        bool RANGES_FUNC(none_of)(I first, S last, F pred, P proj = P{}) //
-        {
-            for(; first != last; ++first)
-                if(invoke(pred, invoke(proj, *first)))
-                    return false;
-            return true;
-        }
-
-        /// \overload
-        template(typename Rng, typename F, typename P = identity)(
-            /// \pre
-            requires input_range<Rng> AND
-            indirect_unary_predicate<F, projected<iterator_t<Rng>, P>>)
-        bool RANGES_FUNC(none_of)(Rng && rng, F pred, P proj = P{}) //
-        {
-            return (*this)(begin(rng), end(rng), std::move(pred), std::move(proj));
-        }
-
-    RANGES_FUNC_END(none_of)
-
-    namespace cpp20
-    {
-        using ranges::none_of;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/nth_element.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/nth_element.hpp
deleted file mode 100644
index f70f8f30..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/nth_element.hpp
+++ /dev/null
@@ -1,335 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef RANGES_V3_ALGORITHM_NTH_ELEMENT_HPP
-#define RANGES_V3_ALGORITHM_NTH_ELEMENT_HPP
-
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/min_element.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/utility/swap.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        // stable, 2-3 compares, 0-2 swaps
-
-        template(typename I, typename C, typename P)(
-            /// \pre
-            requires forward_iterator<I> AND indirect_relation<C, projected<I, P>>)
-        unsigned sort3(I x, I y, I z, C & pred, P & proj)
-        {
-            unsigned r = 0;
-            if(!invoke(pred, invoke(proj, *y), invoke(proj, *x))) // if x <= y
-            {
-                if(!invoke(pred, invoke(proj, *z), invoke(proj, *y))) // if y <= z
-                    return r;                                         // x <= y && y <= z
-                                                                      // x <= y && y > z
-                ranges::iter_swap(y, z);                              // x <= z && y < z
-                r = 1;
-                if(invoke(pred, invoke(proj, *y), invoke(proj, *x))) // if x > y
-                {
-                    ranges::iter_swap(x, y); // x < y && y <= z
-                    r = 2;
-                }
-                return r; // x <= y && y < z
-            }
-            if(invoke(pred, invoke(proj, *z), invoke(proj, *y))) // x > y, if y > z
-            {
-                ranges::iter_swap(x, z); // x < y && y < z
-                r = 1;
-                return r;
-            }
-            ranges::iter_swap(x, y);                             // x > y && y <= z
-            r = 1;                                               // x < y && x <= z
-            if(invoke(pred, invoke(proj, *z), invoke(proj, *y))) // if y > z
-            {
-                ranges::iter_swap(y, z); // x <= y && y < z
-                r = 2;
-            }
-            return r;
-        } // x <= y && y <= z
-
-        template(typename I, typename C, typename P)(
-            /// \pre
-            requires bidirectional_iterator<I> AND indirect_relation<C, projected<I, P>>)
-        void selection_sort(I first, I last, C & pred, P & proj)
-        {
-            RANGES_EXPECT(first != last);
-            for(I lm1 = ranges::prev(last); first != lm1; ++first)
-            {
-                I i = ranges::min_element(first, last, std::ref(pred), std::ref(proj));
-                if(i != first)
-                    ranges::iter_swap(first, i);
-            }
-        }
-    } // namespace detail
-    /// \endcond
-
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(nth_element)
-
-        /// \brief function template \c nth_element
-        template(typename I, typename S, typename C = less, typename P = identity)(
-            /// \pre
-            requires random_access_iterator<I> AND sortable<I, C, P>)
-        I RANGES_FUNC(nth_element)(
-            I first, I nth, S end_, C pred = C{}, P proj = P{}) //
-        {
-            I last = ranges::next(nth, end_), end_orig = last;
-            // C is known to be a reference type
-            using difference_type = iter_difference_t<I>;
-            difference_type const limit = 7;
-            while(true)
-            {
-            restart:
-                if(nth == last)
-                    return end_orig;
-                difference_type len = last - first;
-                switch(len)
-                {
-                case 0:
-                case 1:
-                    return end_orig;
-                case 2:
-                    if(invoke(pred, invoke(proj, *--last), invoke(proj, *first)))
-                        ranges::iter_swap(first, last);
-                    return end_orig;
-                case 3:
-                {
-                    I m = first;
-                    detail::sort3(first, ++m, --last, pred, proj);
-                    return end_orig;
-                }
-                }
-                if(len <= limit)
-                {
-                    detail::selection_sort(first, last, pred, proj);
-                    return end_orig;
-                }
-                // len > limit >= 3
-                I m = first + len / 2;
-                I lm1 = last;
-                unsigned n_swaps = detail::sort3(first, m, --lm1, pred, proj);
-                // *m is median
-                // partition [first, m) < *m and *m <= [m, last)
-                //(this inhibits tossing elements equivalent to m around unnecessarily)
-                I i = first;
-                I j = lm1;
-                // j points beyond range to be tested, *lm1 is known to be <= *m
-                // The search going up is known to be guarded but the search coming down
-                // isn't. Prime the downward search with a guard.
-                if(!invoke(pred, invoke(proj, *i), invoke(proj, *m))) // if *first == *m
-                {
-                    // *first == *m, *first doesn't go in first part
-                    // manually guard downward moving j against i
-                    while(true)
-                    {
-                        if(i == --j)
-                        {
-                            // *first == *m, *m <= all other elements
-                            // Parition instead into [first, i) == *first and *first < [i,
-                            // last)
-                            ++i; // first + 1
-                            j = last;
-                            if(!invoke(
-                                   pred,
-                                   invoke(proj, *first),
-                                   invoke(
-                                       proj,
-                                       *--j))) // we need a guard if *first == *(last-1)
-                            {
-                                while(true)
-                                {
-                                    if(i == j)
-                                        return end_orig; // [first, last) all equivalent
-                                                         // elements
-                                    if(invoke(
-                                           pred, invoke(proj, *first), invoke(proj, *i)))
-                                    {
-                                        ranges::iter_swap(i, j);
-                                        ++n_swaps;
-                                        ++i;
-                                        break;
-                                    }
-                                    ++i;
-                                }
-                            }
-                            // [first, i) == *first and *first < [j, last) and j == last -
-                            // 1
-                            if(i == j)
-                                return end_orig;
-                            while(true)
-                            {
-                                while(
-                                    !invoke(pred, invoke(proj, *first), invoke(proj, *i)))
-                                    ++i;
-                                while(invoke(
-                                    pred, invoke(proj, *first), invoke(proj, *--j)))
-                                    ;
-                                if(i >= j)
-                                    break;
-                                ranges::iter_swap(i, j);
-                                ++n_swaps;
-                                ++i;
-                            }
-                            // [first, i) == *first and *first < [i, last)
-                            // The first part is sorted,
-                            if(nth < i)
-                                return end_orig;
-                            // nth_element the second part
-                            // nth_element<C>(i, nth, last, pred);
-                            first = i;
-                            goto restart;
-                        }
-                        if(invoke(pred, invoke(proj, *j), invoke(proj, *m)))
-                        {
-                            ranges::iter_swap(i, j);
-                            ++n_swaps;
-                            break; // found guard for downward moving j, now use unguarded
-                                   // partition
-                        }
-                    }
-                }
-                ++i;
-                // j points beyond range to be tested, *lm1 is known to be <= *m
-                // if not yet partitioned...
-                if(i < j)
-                {
-                    // known that *(i - 1) < *m
-                    while(true)
-                    {
-                        // m still guards upward moving i
-                        while(invoke(pred, invoke(proj, *i), invoke(proj, *m)))
-                            ++i;
-                        // It is now known that a guard exists for downward moving j
-                        while(!invoke(pred, invoke(proj, *--j), invoke(proj, *m)))
-                            ;
-                        if(i >= j)
-                            break;
-                        ranges::iter_swap(i, j);
-                        ++n_swaps;
-                        // It is known that m != j
-                        // If m just moved, follow it
-                        if(m == i)
-                            m = j;
-                        ++i;
-                    }
-                }
-                // [first, i) < *m and *m <= [i, last)
-                if(i != m && invoke(pred, invoke(proj, *m), invoke(proj, *i)))
-                {
-                    ranges::iter_swap(i, m);
-                    ++n_swaps;
-                }
-                // [first, i) < *i and *i <= [i+1, last)
-                if(nth == i)
-                    return end_orig;
-                if(n_swaps == 0)
-                {
-                    // We were given a perfectly partitioned sequence.  Coincidence?
-                    if(nth < i)
-                    {
-                        // Check for [first, i) already sorted
-                        j = m = first;
-                        while(++j != i)
-                        {
-                            if(invoke(pred, invoke(proj, *j), invoke(proj, *m)))
-                                // not yet sorted, so sort
-                                goto not_sorted;
-                            m = j;
-                        }
-                        // [first, i) sorted
-                        return end_orig;
-                    }
-                    else
-                    {
-                        // Check for [i, last) already sorted
-                        j = m = i;
-                        while(++j != last)
-                        {
-                            if(invoke(pred, invoke(proj, *j), invoke(proj, *m)))
-                                // not yet sorted, so sort
-                                goto not_sorted;
-                            m = j;
-                        }
-                        // [i, last) sorted
-                        return end_orig;
-                    }
-                }
-            not_sorted:
-                // nth_element on range containing nth
-                if(nth < i)
-                {
-                    // nth_element<C>(first, nth, i, pred);
-                    last = i;
-                }
-                else
-                {
-                    // nth_element<C>(i+1, nth, last, pred);
-                    first = ++i;
-                }
-            }
-            return end_orig;
-        }
-
-        /// \overload
-        template(typename Rng, typename C = less, typename P = identity)(
-            /// \pre
-            requires random_access_range<Rng> AND sortable<iterator_t<Rng>, C, P>)
-        borrowed_iterator_t<Rng> RANGES_FUNC(nth_element)(
-            Rng && rng, iterator_t<Rng> nth, C pred = C{}, P proj = P{}) //
-        {
-            return (*this)(
-                begin(rng), std::move(nth), end(rng), std::move(pred), std::move(proj));
-        }
-
-    RANGES_FUNC_END(nth_element)
-
-    namespace cpp20
-    {
-        using ranges::nth_element;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/partial_sort.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/partial_sort.hpp
deleted file mode 100644
index c5a829ca..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/partial_sort.hpp
+++ /dev/null
@@ -1,89 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_PARTIAL_SORT_HPP
-#define RANGES_V3_ALGORITHM_PARTIAL_SORT_HPP
-
-#include <functional>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/heap_algorithm.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(partial_sort)
-
-        /// \brief function template \c partial_sort
-        template(typename I, typename S, typename C = less, typename P = identity)(
-            /// \pre
-            requires sortable<I, C, P> AND random_access_iterator<I> AND
-                sentinel_for<S, I>)
-        I RANGES_FUNC(partial_sort)(
-            I first, I middle, S last, C pred = C{}, P proj = P{}) //
-        {
-            make_heap(first, middle, std::ref(pred), std::ref(proj));
-            auto const len = middle - first;
-            I i = middle;
-            for(; i != last; ++i)
-            {
-                if(invoke(pred, invoke(proj, *i), invoke(proj, *first)))
-                {
-                    iter_swap(i, first);
-                    detail::sift_down_n(
-                        first, len, first, std::ref(pred), std::ref(proj));
-                }
-            }
-            sort_heap(first, middle, std::ref(pred), std::ref(proj));
-            return i;
-        }
-
-        /// \overload
-        template(typename Rng, typename C = less, typename P = identity)(
-            /// \pre
-            requires sortable<iterator_t<Rng>, C, P> AND random_access_range<Rng>)
-        borrowed_iterator_t<Rng> RANGES_FUNC(partial_sort)(
-            Rng && rng, iterator_t<Rng> middle, C pred = C{}, P proj = P{}) //
-        {
-            return (*this)(begin(rng),
-                           std::move(middle),
-                           end(rng),
-                           std::move(pred),
-                           std::move(proj));
-        }
-
-    RANGES_FUNC_END(partial_sort)
-
-    namespace cpp20
-    {
-        using ranges::partial_sort;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/partial_sort_copy.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/partial_sort_copy.hpp
deleted file mode 100644
index db96ad31..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/partial_sort_copy.hpp
+++ /dev/null
@@ -1,125 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_PARTIAL_SORT_COPY_HPP
-#define RANGES_V3_ALGORITHM_PARTIAL_SORT_COPY_HPP
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/heap_algorithm.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(partial_sort_copy)
-
-        /// \brief function template \c partial_sort_copy
-        template(typename I,
-                 typename SI,
-                 typename O,
-                 typename SO,
-                 typename C = less,
-                 typename PI = identity,
-                 typename PO = identity)(
-            /// \pre
-            requires input_iterator<I> AND sentinel_for<SI, I> AND
-                random_access_iterator<O> AND sentinel_for<SO, O> AND
-                indirectly_copyable<I, O> AND sortable<O, C, PO> AND
-                indirect_strict_weak_order<C, projected<I, PI>, projected<O, PO>>)
-        O RANGES_FUNC(partial_sort_copy)(I first,
-                                         SI last,
-                                         O out_begin,
-                                         SO out_end,
-                                         C pred = C{},
-                                         PI in_proj = PI{},
-                                         PO out_proj = PO{}) //
-        {
-            O r = out_begin;
-            if(r != out_end)
-            {
-                for(; first != last && r != out_end; ++first, ++r)
-                    *r = *first;
-                make_heap(out_begin, r, std::ref(pred), std::ref(out_proj));
-                auto len = r - out_begin;
-                for(; first != last; ++first)
-                {
-                    auto && x = *first;
-                    if(invoke(pred, invoke(in_proj, x), invoke(out_proj, *out_begin)))
-                    {
-                        *out_begin = (decltype(x) &&)x;
-                        detail::sift_down_n(out_begin,
-                                            len,
-                                            out_begin,
-                                            std::ref(pred),
-                                            std::ref(out_proj));
-                    }
-                }
-                sort_heap(out_begin, r, std::ref(pred), std::ref(out_proj));
-            }
-            return r;
-        }
-
-        /// \overload
-        template(typename InRng,
-                 typename OutRng,
-                 typename C = less,
-                 typename PI = identity,
-                 typename PO = identity)(
-            /// \pre
-            requires input_range<InRng> AND random_access_range<OutRng> AND
-                indirectly_copyable<iterator_t<InRng>, iterator_t<OutRng>> AND
-                sortable<iterator_t<OutRng>, C, PO> AND
-                indirect_strict_weak_order<C,
-                                           projected<iterator_t<InRng>, PI>,
-                                           projected<iterator_t<OutRng>, PO>>)
-        borrowed_iterator_t<OutRng> RANGES_FUNC(partial_sort_copy)(InRng && in_rng,
-                                                                   OutRng && out_rng,
-                                                                   C pred = C{},
-                                                                   PI in_proj = PI{},
-                                                                   PO out_proj = PO{}) //
-        {
-            return (*this)(begin(in_rng),
-                           end(in_rng),
-                           begin(out_rng),
-                           end(out_rng),
-                           std::move(pred),
-                           std::move(in_proj),
-                           std::move(out_proj));
-        }
-
-    RANGES_FUNC_END(partial_sort_copy)
-
-    namespace cpp20
-    {
-        using ranges::partial_sort_copy;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/partition.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/partition.hpp
deleted file mode 100644
index 61fc9f87..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/partition.hpp
+++ /dev/null
@@ -1,139 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//===-------------------------- algorithm ---------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-#ifndef RANGES_V3_ALGORITHM_PARTITION_HPP
-#define RANGES_V3_ALGORITHM_PARTITION_HPP
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/utility/swap.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-
-    /// \cond
-    namespace detail
-    {
-        template<typename I, typename S, typename C, typename P>
-        I partition_impl(I first, S last, C pred, P proj, std::forward_iterator_tag)
-        {
-            while(true)
-            {
-                if(first == last)
-                    return first;
-                if(!invoke(pred, invoke(proj, *first)))
-                    break;
-                ++first;
-            }
-            for(I p = first; ++p != last;)
-            {
-                if(invoke(pred, invoke(proj, *p)))
-                {
-                    ranges::iter_swap(first, p);
-                    ++first;
-                }
-            }
-            return first;
-        }
-
-        template<typename I, typename S, typename C, typename P>
-        I partition_impl(I first, S end_, C pred, P proj, std::bidirectional_iterator_tag)
-        {
-            I last = ranges::next(first, end_);
-            while(true)
-            {
-                while(true)
-                {
-                    if(first == last)
-                        return first;
-                    if(!invoke(pred, invoke(proj, *first)))
-                        break;
-                    ++first;
-                }
-                do
-                {
-                    if(first == --last)
-                        return first;
-                } while(!invoke(pred, invoke(proj, *last)));
-                ranges::iter_swap(first, last);
-                ++first;
-            }
-        }
-    } // namespace detail
-    /// \endcond
-
-    RANGES_FUNC_BEGIN(partition)
-
-        /// \brief function template \c partition
-        template(typename I, typename S, typename C, typename P = identity)(
-            /// \pre
-            requires permutable<I> AND sentinel_for<S, I> AND
-            indirect_unary_predicate<C, projected<I, P>>)
-        I RANGES_FUNC(partition)(I first, S last, C pred, P proj = P{})
-        {
-            return detail::partition_impl(std::move(first),
-                                          std::move(last),
-                                          std::move(pred),
-                                          std::move(proj),
-                                          iterator_tag_of<I>());
-        }
-
-        /// \overload
-        template(typename Rng, typename C, typename P = identity)(
-            /// \pre
-            requires forward_range<Rng> AND permutable<iterator_t<Rng>> AND
-            indirect_unary_predicate<C, projected<iterator_t<Rng>, P>>)
-        borrowed_iterator_t<Rng> RANGES_FUNC(partition)(Rng && rng, C pred, P proj = P{})
-        {
-            return detail::partition_impl(begin(rng),
-                                          end(rng),
-                                          std::move(pred),
-                                          std::move(proj),
-                                          iterator_tag_of<iterator_t<Rng>>());
-        }
-
-    RANGES_FUNC_END(partition)
-
-    namespace cpp20
-    {
-        using ranges::partition;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/partition_copy.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/partition_copy.hpp
deleted file mode 100644
index 00f3306c..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/partition_copy.hpp
+++ /dev/null
@@ -1,111 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_PARTITION_COPY_HPP
-#define RANGES_V3_ALGORITHM_PARTITION_COPY_HPP
-
-#include <tuple>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/result_types.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    template<typename I, typename O0, typename O1>
-    using partition_copy_result = detail::in_out1_out2_result<I, O0, O1>;
-
-    RANGES_FUNC_BEGIN(partition_copy)
-
-        /// \brief function template \c partition_copy
-        template(typename I,
-                 typename S,
-                 typename O0,
-                 typename O1,
-                 typename C,
-                 typename P = identity)(
-            /// \pre
-            requires input_iterator<I> AND sentinel_for<S, I> AND
-                weakly_incrementable<O0> AND weakly_incrementable<O1> AND
-                indirectly_copyable<I, O0> AND indirectly_copyable<I, O1> AND
-                indirect_unary_predicate<C, projected<I, P>>)
-        partition_copy_result<I, O0, O1> RANGES_FUNC(partition_copy)(
-            I first, S last, O0 o0, O1 o1, C pred, P proj = P{})
-        {
-            for(; first != last; ++first)
-            {
-                auto && x = *first;
-                if(invoke(pred, invoke(proj, x)))
-                {
-                    *o0 = (decltype(x) &&)x;
-                    ++o0;
-                }
-                else
-                {
-                    *o1 = (decltype(x) &&)x;
-                    ++o1;
-                }
-            }
-            return {first, o0, o1};
-        }
-
-        /// \overload
-        template(typename Rng,
-                 typename O0,
-                 typename O1,
-                 typename C,
-                 typename P = identity)(
-            /// \pre
-            requires input_range<Rng> AND weakly_incrementable<O0> AND
-                weakly_incrementable<O1> AND indirectly_copyable<iterator_t<Rng>, O0> AND
-                indirectly_copyable<iterator_t<Rng>, O1> AND
-                indirect_unary_predicate<C, projected<iterator_t<Rng>, P>>)
-        partition_copy_result<borrowed_iterator_t<Rng>, O0, O1> //
-        RANGES_FUNC(partition_copy)(Rng && rng, O0 o0, O1 o1, C pred, P proj = P{})
-        {
-            return (*this)(begin(rng),
-                           end(rng),
-                           std::move(o0),
-                           std::move(o1),
-                           std::move(pred),
-                           std::move(proj));
-        }
-
-    RANGES_FUNC_END(partition_copy)
-
-    namespace cpp20
-    {
-        using ranges::partition_copy;
-        using ranges::partition_copy_result;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/partition_point.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/partition_point.hpp
deleted file mode 100644
index b987fa9c..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/partition_point.hpp
+++ /dev/null
@@ -1,110 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//===-------------------------- algorithm ---------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-#ifndef RANGES_V3_ALGORITHM_PARTITION_POINT_HPP
-#define RANGES_V3_ALGORITHM_PARTITION_POINT_HPP
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/aux_/partition_point_n.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-
-    RANGES_FUNC_BEGIN(partition_point)
-
-        /// \brief function template \c partition_point
-        template(typename I, typename S, typename C, typename P = identity)(
-            /// \pre
-            requires forward_iterator<I> AND sentinel_for<S, I> AND
-            indirect_unary_predicate<C, projected<I, P>>)
-        I RANGES_FUNC(partition_point)(I first, S last, C pred, P proj = P{})
-        {
-            if(RANGES_CONSTEXPR_IF(sized_sentinel_for<S, I>))
-            {
-                auto len = distance(first, std::move(last));
-                return aux::partition_point_n(
-                    std::move(first), len, std::move(pred), std::move(proj));
-            }
-
-            // Probe exponentially for either last-of-range or an iterator
-            // that is past the partition point (i.e., does not satisfy pred).
-            auto len = iter_difference_t<I>{1};
-            while(true)
-            {
-                auto mid = first;
-                auto d = advance(mid, len, last);
-                if(mid == last || !invoke(pred, invoke(proj, *mid)))
-                {
-                    len -= d;
-                    return aux::partition_point_n(
-                        std::move(first), len, std::ref(pred), std::ref(proj));
-                }
-                first = std::move(mid);
-                len *= 2;
-            }
-        }
-
-        /// \overload
-        template(typename Rng, typename C, typename P = identity)(
-            /// \pre
-            requires forward_range<Rng> AND
-            indirect_unary_predicate<C, projected<iterator_t<Rng>, P>>)
-        borrowed_iterator_t<Rng> //
-        RANGES_FUNC(partition_point)(Rng && rng, C pred, P proj = P{}) //
-        {
-            if(RANGES_CONSTEXPR_IF(sized_range<Rng>))
-            {
-                auto len = distance(rng);
-                return aux::partition_point_n(
-                    begin(rng), len, std::move(pred), std::move(proj));
-            }
-            return (*this)(begin(rng), end(rng), std::move(pred), std::move(proj));
-        }
-
-    RANGES_FUNC_END(partition_point)
-
-    namespace cpp20
-    {
-        using ranges::partition_point;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/permutation.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/permutation.hpp
deleted file mode 100644
index 88e0c1eb..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/permutation.hpp
+++ /dev/null
@@ -1,369 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//===-------------------------- algorithm ---------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-#ifndef RANGES_V3_ALGORITHM_PERMUTATION_HPP
-#define RANGES_V3_ALGORITHM_PERMUTATION_HPP
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/reverse.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/utility/swap.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-
-    /// \cond
-    namespace detail
-    {
-        template<typename I1, typename S1, typename I2, typename S2, typename C,
-                 typename P1, typename P2>
-        bool is_permutation_impl(I1 begin1, S1 end1, I2 begin2, S2 end2, C pred, P1 proj1,
-                                 P2 proj2)
-        {
-            // shorten sequences as much as possible by lopping off any equal parts
-            for(; begin1 != end1 && begin2 != end2; ++begin1, ++begin2)
-                if(!invoke(pred, invoke(proj1, *begin1), invoke(proj2, *begin2)))
-                    goto not_done;
-            return begin1 == end1 && begin2 == end2;
-        not_done:
-            // begin1 != end1 && begin2 != end2 && *begin1 != *begin2
-            auto l1 = distance(begin1, end1);
-            auto l2 = distance(begin2, end2);
-            if(l1 != l2)
-                return false;
-
-            // For each element in [f1, l1) see if there are the same number of
-            //    equal elements in [f2, l2)
-            for(I1 i = begin1; i != end1; ++i)
-            {
-                // Have we already counted the number of *i in [f1, l1)?
-                for(I1 j = begin1; j != i; ++j)
-                    if(invoke(pred, invoke(proj1, *j), invoke(proj1, *i)))
-                        goto next_iter;
-                {
-                    // Count number of *i in [f2, l2)
-                    iter_difference_t<I2> c2 = 0;
-                    for(I2 j = begin2; j != end2; ++j)
-                        if(invoke(pred, invoke(proj1, *i), invoke(proj2, *j)))
-                            ++c2;
-                    if(c2 == 0)
-                        return false;
-                    // Count number of *i in [i, l1) (we can start with 1)
-                    iter_difference_t<I1> c1 = 1;
-                    for(I1 j = next(i); j != end1; ++j)
-                        if(invoke(pred, invoke(proj1, *i), invoke(proj1, *j)))
-                            ++c1;
-                    if(c1 != c2)
-                        return false;
-                }
-            next_iter:;
-            }
-            return true;
-        }
-    } // namespace detail
-    /// \endcond
-
-    RANGES_FUNC_BEGIN(is_permutation)
-
-        /// \brief function template \c is_permutation
-        template(typename I1,
-                 typename S1,
-                 typename I2,
-                 typename C = equal_to,
-                 typename P1 = identity,
-                 typename P2 = identity)(
-            /// \pre
-            requires forward_iterator<I1> AND sentinel_for<S1, I1> AND
-                forward_iterator<I2> AND indirectly_comparable<I1, I2, C, P1, P2>)
-        RANGES_DEPRECATED(
-            "Use the variant of ranges::is_permutation that takes an upper bound "
-            "for both sequences")
-        bool RANGES_FUNC(is_permutation)(I1 begin1,
-                                         S1 end1,
-                                         I2 begin2,
-                                         C pred = C{},
-                                         P1 proj1 = P1{},
-                                         P2 proj2 = P2{}) //
-        {
-            // shorten sequences as much as possible by lopping off any equal parts
-            for(; begin1 != end1; ++begin1, ++begin2)
-                if(!invoke(pred, invoke(proj1, *begin1), invoke(proj2, *begin2)))
-                    goto not_done;
-            return true;
-        not_done:
-            // begin1 != end1 && *begin1 != *begin2
-            auto l1 = distance(begin1, end1);
-            if(l1 == 1)
-                return false;
-            I2 end2 = next(begin2, l1);
-            // For each element in [f1, l1) see if there are the same number of
-            //    equal elements in [f2, l2)
-            for(I1 i = begin1; i != end1; ++i)
-            {
-                // Have we already counted the number of *i in [f1, l1)?
-                for(I1 j = begin1; j != i; ++j)
-                    if(invoke(pred, invoke(proj1, *j), invoke(proj1, *i)))
-                        goto next_iter;
-                {
-                    // Count number of *i in [f2, l2)
-                    iter_difference_t<I2> c2 = 0;
-                    for(I2 j = begin2; j != end2; ++j)
-                        if(invoke(pred, invoke(proj1, *i), invoke(proj2, *j)))
-                            ++c2;
-                    if(c2 == 0)
-                        return false;
-                    // Count number of *i in [i, l1) (we can start with 1)
-                    iter_difference_t<I1> c1 = 1;
-                    for(I1 j = next(i); j != end1; ++j)
-                        if(invoke(pred, invoke(proj1, *i), invoke(proj1, *j)))
-                            ++c1;
-                    if(c1 != c2)
-                        return false;
-                }
-            next_iter:;
-            }
-            return true;
-        }
-
-        /// \overload
-        template(typename I1,
-                 typename S1,
-                 typename I2,
-                 typename S2,
-                 typename C = equal_to,
-                 typename P1 = identity,
-                 typename P2 = identity)(
-            /// \pre
-            requires forward_iterator<I1> AND sentinel_for<S1, I1> AND
-                forward_iterator<I2> AND sentinel_for<S2, I2> AND
-                indirectly_comparable<I1, I2, C, P1, P2>)
-        bool RANGES_FUNC(is_permutation)(I1 begin1,
-                                         S1 end1,
-                                         I2 begin2,
-                                         S2 end2,
-                                         C pred = C{},
-                                         P1 proj1 = P1{},
-                                         P2 proj2 = P2{}) //
-        {
-            if(RANGES_CONSTEXPR_IF(sized_sentinel_for<S1, I1> &&
-                                   sized_sentinel_for<S2, I2>))
-            {
-                RANGES_DIAGNOSTIC_PUSH
-                RANGES_DIAGNOSTIC_IGNORE_DEPRECATED_DECLARATIONS
-                return distance(begin1, end1) == distance(begin2, end2) &&
-                       (*this)(std::move(begin1),
-                               std::move(end1),
-                               std::move(begin2),
-                               std::move(pred),
-                               std::move(proj1),
-                               std::move(proj2));
-                RANGES_DIAGNOSTIC_POP
-            }
-            return detail::is_permutation_impl(std::move(begin1),
-                                               std::move(end1),
-                                               std::move(begin2),
-                                               std::move(end2),
-                                               std::move(pred),
-                                               std::move(proj1),
-                                               std::move(proj2));
-        }
-
-        /// \overload
-        template(typename Rng1,
-                     typename I2Ref,
-                     typename C = equal_to,
-                     typename P1 = identity,
-                     typename P2 = identity)(
-            /// \pre
-            requires forward_range<Rng1> AND forward_iterator<uncvref_t<I2Ref>> AND
-                indirectly_comparable<iterator_t<Rng1>, uncvref_t<I2Ref>, C, P1, P2>)
-        RANGES_DEPRECATED(
-            "Use the variant of ranges::is_permutation that takes an upper bound "
-            "for both sequences")
-        bool RANGES_FUNC(is_permutation)(Rng1 && rng1,
-                                         I2Ref && begin2,
-                                         C pred = C{},
-                                         P1 proj1 = P1{},
-                                         P2 proj2 = P2{}) //
-        {
-            RANGES_DIAGNOSTIC_PUSH
-            RANGES_DIAGNOSTIC_IGNORE_DEPRECATED_DECLARATIONS
-            return (*this)(begin(rng1),
-                           end(rng1),
-                           (I2Ref &&) begin2,
-                           std::move(pred),
-                           std::move(proj1),
-                           std::move(proj2));
-            RANGES_DIAGNOSTIC_POP
-        }
-
-        /// \overload
-        template(typename Rng1,
-                     typename Rng2,
-                     typename C = equal_to,
-                     typename P1 = identity,
-                     typename P2 = identity)(
-            /// \pre
-            requires forward_range<Rng1> AND forward_range<Rng2> AND
-                indirectly_comparable<iterator_t<Rng1>, iterator_t<Rng2>, C, P1, P2>)
-        bool RANGES_FUNC(is_permutation)(
-            Rng1 && rng1, Rng2 && rng2, C pred = C{}, P1 proj1 = P1{}, P2 proj2 = P2{}) //
-        {
-            if(RANGES_CONSTEXPR_IF(sized_range<Rng1> && sized_range<Rng2>))
-            {
-                RANGES_DIAGNOSTIC_PUSH
-                RANGES_DIAGNOSTIC_IGNORE_DEPRECATED_DECLARATIONS
-                return distance(rng1) == distance(rng2) && (*this)(begin(rng1),
-                                                                   end(rng1),
-                                                                   begin(rng2),
-                                                                   std::move(pred),
-                                                                   std::move(proj1),
-                                                                   std::move(proj2));
-                RANGES_DIAGNOSTIC_POP
-            }
-            return detail::is_permutation_impl(begin(rng1),
-                                               end(rng1),
-                                               begin(rng2),
-                                               end(rng2),
-                                               std::move(pred),
-                                               std::move(proj1),
-                                               std::move(proj2));
-        }
-
-    RANGES_FUNC_END(is_permutation)
-
-    RANGES_FUNC_BEGIN(next_permutation)
-
-        /// \brief function template \c next_permutation
-        template(typename I, typename S, typename C = less, typename P = identity)(
-            /// \pre
-            requires bidirectional_iterator<I> AND sentinel_for<S, I> AND
-                sortable<I, C, P>)
-        bool RANGES_FUNC(next_permutation)(I first, S end_, C pred = C{}, P proj = P{}) //
-        {
-            if(first == end_)
-                return false;
-            I last = ranges::next(first, end_), i = last;
-            if(first == --i)
-                return false;
-            while(true)
-            {
-                I ip1 = i;
-                if(invoke(pred, invoke(proj, *--i), invoke(proj, *ip1)))
-                {
-                    I j = last;
-                    while(!invoke(pred, invoke(proj, *i), invoke(proj, *--j)))
-                        ;
-                    ranges::iter_swap(i, j);
-                    ranges::reverse(ip1, last);
-                    return true;
-                }
-                if(i == first)
-                {
-                    ranges::reverse(first, last);
-                    return false;
-                }
-            }
-        }
-
-        /// \overload
-        template(typename Rng, typename C = less, typename P = identity)(
-            /// \pre
-            requires bidirectional_range<Rng> AND sortable<iterator_t<Rng>, C, P>)
-        bool RANGES_FUNC(next_permutation)(Rng && rng, C pred = C{}, P proj = P{}) //
-        {
-            return (*this)(begin(rng), end(rng), std::move(pred), std::move(proj));
-        }
-
-    RANGES_FUNC_END(next_permutation)
-
-    RANGES_FUNC_BEGIN(prev_permutation)
-
-        /// \brief function template \c prev_permutation
-        template(typename I, typename S, typename C = less, typename P = identity)(
-            /// \pre
-            requires bidirectional_iterator<I> AND sentinel_for<S, I> AND
-                sortable<I, C, P>)
-        bool RANGES_FUNC(prev_permutation)(I first, S end_, C pred = C{}, P proj = P{}) //
-        {
-            if(first == end_)
-                return false;
-            I last = ranges::next(first, end_), i = last;
-            if(first == --i)
-                return false;
-            while(true)
-            {
-                I ip1 = i;
-                if(invoke(pred, invoke(proj, *ip1), invoke(proj, *--i)))
-                {
-                    I j = last;
-                    while(!invoke(pred, invoke(proj, *--j), invoke(proj, *i)))
-                        ;
-                    ranges::iter_swap(i, j);
-                    ranges::reverse(ip1, last);
-                    return true;
-                }
-                if(i == first)
-                {
-                    ranges::reverse(first, last);
-                    return false;
-                }
-            }
-        }
-
-        /// \overload
-        template(typename Rng, typename C = less, typename P = identity)(
-            /// \pre
-            requires bidirectional_range<Rng> AND sortable<iterator_t<Rng>, C, P>)
-        bool RANGES_FUNC(prev_permutation)(Rng && rng, C pred = C{}, P proj = P{}) //
-        {
-            return (*this)(begin(rng), end(rng), std::move(pred), std::move(proj));
-        }
-
-    RANGES_FUNC_END(prev_permutation)
-
-    namespace cpp20
-    {
-        using ranges::is_permutation;
-        using ranges::next_permutation;
-        using ranges::prev_permutation;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/remove.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/remove.hpp
deleted file mode 100644
index 7cad286b..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/remove.hpp
+++ /dev/null
@@ -1,84 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_REMOVE_HPP
-#define RANGES_V3_ALGORITHM_REMOVE_HPP
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/find.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(remove)
-
-        /// \brief function template \c remove
-        template(typename I, typename S, typename T, typename P = identity)(
-            /// \pre
-            requires permutable<I> AND sentinel_for<S, I> AND
-            indirect_relation<equal_to, projected<I, P>, T const *>)
-        I RANGES_FUNC(remove)(I first, S last, T const & val, P proj = P{})
-        {
-            first = find(std::move(first), last, val, std::ref(proj));
-            if(first != last)
-            {
-                for(I i = next(first); i != last; ++i)
-                {
-                    if(!(invoke(proj, *i) == val))
-                    {
-                        *first = iter_move(i);
-                        ++first;
-                    }
-                }
-            }
-            return first;
-        }
-
-        /// \overload
-        template(typename Rng, typename T, typename P = identity)(
-            /// \pre
-            requires forward_range<Rng> AND permutable<iterator_t<Rng>> AND
-            indirect_relation<equal_to, projected<iterator_t<Rng>, P>, T const *>)
-        borrowed_iterator_t<Rng> //
-        RANGES_FUNC(remove)(Rng && rng, T const & val, P proj = P{})
-        {
-            return (*this)(begin(rng), end(rng), val, std::move(proj));
-        }
-
-    RANGES_FUNC_END(remove)
-
-    namespace cpp20
-    {
-        using ranges::remove;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/remove_copy.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/remove_copy.hpp
deleted file mode 100644
index ad76b8c3..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/remove_copy.hpp
+++ /dev/null
@@ -1,88 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_REMOVE_COPY_HPP
-#define RANGES_V3_ALGORITHM_REMOVE_COPY_HPP
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/result_types.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    template<typename I, typename O>
-    using remove_copy_result = detail::in_out_result<I, O>;
-
-    RANGES_FUNC_BEGIN(remove_copy)
-
-        /// \brief function template \c remove_copy
-        template(typename I, typename S, typename O, typename T, typename P = identity)(
-            /// \pre
-            requires input_iterator<I> AND sentinel_for<S, I> AND
-                weakly_incrementable<O> AND
-                indirect_relation<equal_to, projected<I, P>, T const *> AND
-                indirectly_copyable<I, O>)
-        remove_copy_result<I, O> RANGES_FUNC(remove_copy)(
-            I first, S last, O out, T const & val, P proj = P{}) //
-        {
-            for(; first != last; ++first)
-            {
-                auto && x = *first;
-                if(!(invoke(proj, x) == val))
-                {
-                    *out = (decltype(x) &&)x;
-                    ++out;
-                }
-            }
-            return {first, out};
-        }
-
-        /// \overload
-        template(typename Rng, typename O, typename T, typename P = identity)(
-            /// \pre
-            requires input_range<Rng> AND weakly_incrementable<O> AND
-            indirect_relation<equal_to, projected<iterator_t<Rng>, P>, T const *> AND
-            indirectly_copyable<iterator_t<Rng>, O>)
-        remove_copy_result<borrowed_iterator_t<Rng>, O> //
-        RANGES_FUNC(remove_copy)(Rng && rng, O out, T const & val, P proj = P{}) //
-        {
-            return (*this)(begin(rng), end(rng), std::move(out), val, std::move(proj));
-        }
-
-    RANGES_FUNC_END(remove_copy)
-
-    namespace cpp20
-    {
-        using ranges::remove_copy;
-        using ranges::remove_copy_result;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/remove_copy_if.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/remove_copy_if.hpp
deleted file mode 100644
index 3e5b1574..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/remove_copy_if.hpp
+++ /dev/null
@@ -1,88 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_REMOVE_COPY_IF_HPP
-#define RANGES_V3_ALGORITHM_REMOVE_COPY_IF_HPP
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/result_types.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    template<typename I, typename O>
-    using remove_copy_if_result = detail::in_out_result<I, O>;
-
-    RANGES_FUNC_BEGIN(remove_copy_if)
-
-        /// \brief function template \c remove_copy_if
-        template(typename I, typename S, typename O, typename C, typename P = identity)(
-            /// \pre
-            requires input_iterator<I> AND sentinel_for<S, I> AND
-            weakly_incrementable<O> AND indirect_unary_predicate<C, projected<I, P>> AND
-            indirectly_copyable<I, O>)
-        remove_copy_if_result<I, O> //
-        RANGES_FUNC(remove_copy_if)(I first, S last, O out, C pred, P proj = P{}) //
-        {
-            for(; first != last; ++first)
-            {
-                auto && x = *first;
-                if(!(invoke(pred, invoke(proj, x))))
-                {
-                    *out = (decltype(x) &&)x;
-                    ++out;
-                }
-            }
-            return {first, out};
-        }
-
-        /// \overload
-        template(typename Rng, typename O, typename C, typename P = identity)(
-            /// \pre
-            requires input_range<Rng> AND weakly_incrementable<O> AND
-            indirect_unary_predicate<C, projected<iterator_t<Rng>, P>> AND
-            indirectly_copyable<iterator_t<Rng>, O>)
-        remove_copy_if_result<borrowed_iterator_t<Rng>, O> //
-        RANGES_FUNC(remove_copy_if)(Rng && rng, O out, C pred, P proj = P{}) //
-        {
-            return (*this)(
-                begin(rng), end(rng), std::move(out), std::move(pred), std::move(proj));
-        }
-
-    RANGES_FUNC_END(remove_copy_if)
-
-    namespace cpp20
-    {
-        using ranges::remove_copy_if;
-        using ranges::remove_copy_if_result;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/remove_if.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/remove_if.hpp
deleted file mode 100644
index 77682f13..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/remove_if.hpp
+++ /dev/null
@@ -1,83 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_REMOVE_IF_HPP
-#define RANGES_V3_ALGORITHM_REMOVE_IF_HPP
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/find_if.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(remove_if)
-
-        /// \brief function template \c remove_if
-        template(typename I, typename S, typename C, typename P = identity)(
-            /// \pre
-            requires permutable<I> AND sentinel_for<S, I> AND
-            indirect_unary_predicate<C, projected<I, P>>)
-        I RANGES_FUNC(remove_if)(I first, S last, C pred, P proj = P{})
-        {
-            first = find_if(std::move(first), last, std::ref(pred), std::ref(proj));
-            if(first != last)
-            {
-                for(I i = next(first); i != last; ++i)
-                {
-                    if(!(invoke(pred, invoke(proj, *i))))
-                    {
-                        *first = iter_move(i);
-                        ++first;
-                    }
-                }
-            }
-            return first;
-        }
-
-        /// \overload
-        template(typename Rng, typename C, typename P = identity)(
-            /// \pre
-            requires forward_range<Rng> AND permutable<iterator_t<Rng>> AND
-            indirect_unary_predicate<C, projected<iterator_t<Rng>, P>>)
-        borrowed_iterator_t<Rng> RANGES_FUNC(remove_if)(Rng && rng, C pred, P proj = P{})
-        {
-            return (*this)(begin(rng), end(rng), std::move(pred), std::move(proj));
-        }
-
-    RANGES_FUNC_END(remove_if)
-
-    namespace cpp20
-    {
-        using ranges::remove_if;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/replace.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/replace.hpp
deleted file mode 100644
index a206de6c..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/replace.hpp
+++ /dev/null
@@ -1,76 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_REPLACE_HPP
-#define RANGES_V3_ALGORITHM_REPLACE_HPP
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(replace)
-
-        /// \brief function template \c replace
-        template(typename I, typename S, typename T1, typename T2, typename P = identity)(
-            /// \pre
-            requires input_iterator<I> AND sentinel_for<S, I> AND
-                indirectly_writable<I, T2 const &> AND
-                indirect_relation<equal_to, projected<I, P>, T1 const *>)
-        I RANGES_FUNC(replace)(
-            I first, S last, T1 const & old_value, T2 const & new_value, P proj = {}) //
-        {
-            for(; first != last; ++first)
-                if(invoke(proj, *first) == old_value)
-                    *first = new_value;
-            return first;
-        }
-
-        /// \overload
-        template(typename Rng, typename T1, typename T2, typename P = identity)(
-            /// \pre
-            requires input_range<Rng> AND
-                indirectly_writable<iterator_t<Rng>, T2 const &> AND
-                indirect_relation<equal_to, projected<iterator_t<Rng>, P>, T1 const *>)
-        borrowed_iterator_t<Rng> RANGES_FUNC(replace)(
-            Rng && rng, T1 const & old_value, T2 const & new_value, P proj = {}) //
-        {
-            return (*this)(begin(rng), end(rng), old_value, new_value, std::move(proj));
-        }
-
-    RANGES_FUNC_END(replace)
-
-    namespace cpp20
-    {
-        using ranges::replace;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/replace_copy.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/replace_copy.hpp
deleted file mode 100644
index d4709b39..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/replace_copy.hpp
+++ /dev/null
@@ -1,104 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_REPLACE_COPY_HPP
-#define RANGES_V3_ALGORITHM_REPLACE_COPY_HPP
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/result_types.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    template<typename I, typename O>
-    using replace_copy_result = detail::in_out_result<I, O>;
-
-    RANGES_FUNC_BEGIN(replace_copy)
-
-        /// \brief function template \c replace_copy
-        template(typename I,
-                 typename S,
-                 typename O,
-                 typename T1,
-                 typename T2,
-                 typename P = identity)(
-            /// \pre
-            requires input_iterator<I> AND sentinel_for<S, I> AND
-                output_iterator<O, T2 const &> AND indirectly_copyable<I, O> AND
-                indirect_relation<equal_to, projected<I, P>, T1 const *>)
-        replace_copy_result<I, O> RANGES_FUNC(replace_copy)(I first,
-                                                            S last,
-                                                            O out,
-                                                            T1 const & old_value,
-                                                            T2 const & new_value,
-                                                            P proj = {}) //
-        {
-            for(; first != last; ++first, ++out)
-            {
-                auto && x = *first;
-                if(invoke(proj, x) == old_value)
-                    *out = new_value;
-                else
-                    *out = (decltype(x) &&)x;
-            }
-            return {first, out};
-        }
-
-        /// \overload
-        template(typename Rng,
-                 typename O,
-                 typename T1,
-                 typename T2,
-                 typename P = identity)(
-            /// \pre
-            requires input_range<Rng> AND output_iterator<O, T2 const &> AND
-                indirectly_copyable<iterator_t<Rng>, O> AND
-                indirect_relation<equal_to, projected<iterator_t<Rng>, P>, T1 const *>)
-        replace_copy_result<borrowed_iterator_t<Rng>, O> RANGES_FUNC(replace_copy)(
-            Rng && rng, O out, T1 const & old_value, T2 const & new_value, P proj = {}) //
-        {
-            return (*this)(begin(rng),
-                           end(rng),
-                           std::move(out),
-                           old_value,
-                           new_value,
-                           std::move(proj));
-        }
-
-    RANGES_FUNC_END(replace_copy)
-
-    namespace cpp20
-    {
-        using ranges::replace_copy;
-        using ranges::replace_copy_result;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/replace_copy_if.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/replace_copy_if.hpp
deleted file mode 100644
index 080b51dc..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/replace_copy_if.hpp
+++ /dev/null
@@ -1,97 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_REPLACE_COPY_IF_HPP
-#define RANGES_V3_ALGORITHM_REPLACE_COPY_IF_HPP
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/result_types.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    template<typename I, typename O>
-    using replace_copy_if_result = detail::in_out_result<I, O>;
-
-    RANGES_FUNC_BEGIN(replace_copy_if)
-
-        /// \brief function template \c replace_copy_if
-        template(typename I,
-                 typename S,
-                 typename O,
-                 typename C,
-                 typename T,
-                 typename P = identity)(
-            /// \pre
-            requires input_iterator<I> AND sentinel_for<S, I> AND
-                output_iterator<O, T const &> AND
-                indirect_unary_predicate<C, projected<I, P>> AND
-                indirectly_copyable<I, O>)
-        replace_copy_if_result<I, O> RANGES_FUNC(replace_copy_if)(
-            I first, S last, O out, C pred, T const & new_value, P proj = {}) //
-        {
-            for(; first != last; ++first, ++out)
-            {
-                auto && x = *first;
-                if(invoke(pred, invoke(proj, x)))
-                    *out = new_value;
-                else
-                    *out = (decltype(x) &&)x;
-            }
-            return {first, out};
-        }
-
-        /// \overload
-        template(typename Rng, typename O, typename C, typename T, typename P = identity)(
-            /// \pre
-            requires input_range<Rng> AND output_iterator<O, T const &> AND
-                indirect_unary_predicate<C, projected<iterator_t<Rng>, P>> AND
-                indirectly_copyable<iterator_t<Rng>, O>)
-        replace_copy_if_result<borrowed_iterator_t<Rng>, O> RANGES_FUNC(replace_copy_if)(
-            Rng && rng, O out, C pred, T const & new_value, P proj = {}) //
-        {
-            return (*this)(begin(rng),
-                           end(rng),
-                           std::move(out),
-                           std::move(pred),
-                           new_value,
-                           std::move(proj));
-        }
-
-    RANGES_FUNC_END(replace_copy_if)
-
-    namespace cpp20
-    {
-        using ranges::replace_copy_if;
-        using ranges::replace_copy_if_result;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/replace_if.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/replace_if.hpp
deleted file mode 100644
index c820c8ac..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/replace_if.hpp
+++ /dev/null
@@ -1,77 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_REPLACE_IF_HPP
-#define RANGES_V3_ALGORITHM_REPLACE_IF_HPP
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(replace_if)
-
-        /// \brief function template \c replace_if
-        template(typename I, typename S, typename C, typename T, typename P = identity)(
-            /// \pre
-            requires input_iterator<I> AND sentinel_for<S, I> AND
-                indirect_unary_predicate<C, projected<I, P>> AND
-                indirectly_writable<I, T const &>)
-        I RANGES_FUNC(replace_if)(
-            I first, S last, C pred, T const & new_value, P proj = P{}) //
-        {
-            for(; first != last; ++first)
-                if(invoke(pred, invoke(proj, *first)))
-                    *first = new_value;
-            return first;
-        }
-
-        /// \overload
-        template(typename Rng, typename C, typename T, typename P = identity)(
-            /// \pre
-            requires input_range<Rng> AND
-                indirect_unary_predicate<C, projected<iterator_t<Rng>, P>> AND
-                indirectly_writable<iterator_t<Rng>, T const &>)
-        borrowed_iterator_t<Rng> RANGES_FUNC(replace_if)(
-            Rng && rng, C pred, T const & new_value, P proj = P{}) //
-        {
-            return (*this)(
-                begin(rng), end(rng), std::move(pred), new_value, std::move(proj));
-        }
-
-    RANGES_FUNC_END(replace_if)
-
-    namespace cpp20
-    {
-        using ranges::replace_if;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/result_types.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/result_types.hpp
deleted file mode 100644
index 92651443..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/result_types.hpp
+++ /dev/null
@@ -1,169 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#ifndef RANGES_V3_ALGORITHM_RESULT_TYPES_HPP
-#define RANGES_V3_ALGORITHM_RESULT_TYPES_HPP
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        // Extensions: the dangling story actually works, and result structs
-        // are conditionally equality_comparable
-#define RANGES_ALGO_RESULT_AUX_2(C, T1, M1, T2, M2)                                   \
-    template(typename X, typename Y)(                                                 \
-        requires convertible_to<T1 const &, X> AND convertible_to<T2 const &, Y>)     \
-    operator C<X, Y>() const &                                                        \
-    {                                                                                 \
-        return {M1, M2};                                                              \
-    }                                                                                 \
-    template(typename X, typename Y)(                                                 \
-        requires convertible_to<T1, X> AND convertible_to<T2, Y>)                     \
-    operator C<X, Y>() &&                                                             \
-    {                                                                                 \
-        return {static_cast<T1 &&>(M1), static_cast<T2 &&>(M2)};                      \
-    }                                                                                 \
-    CPP_broken_friend_member                                                          \
-    friend constexpr auto operator==(C<T1, T2> const & x, C<T1, T2> const & y)        \
-        -> CPP_broken_friend_ret(bool)(                                               \
-            requires equality_comparable<T1> && equality_comparable<T2>)              \
-    {                                                                                 \
-        return x.M1 == y.M1 && x.M2 == y.M2;                                          \
-    }                                                                                 \
-    CPP_broken_friend_member                                                          \
-    friend constexpr auto operator!=(C<T1, T2> const & x, C<T1, T2> const & y)        \
-        -> CPP_broken_friend_ret(bool)(                                               \
-            requires equality_comparable<T1> && equality_comparable<T2>)              \
-    {                                                                                 \
-        return !(x == y);                                                             \
-    }                                                                                 \
-    /**/
-
-#define RANGES_ALGO_RESULT_AUX_3(C, T1, M1, T2, M2, T3, M3)                              \
-    template(typename X, typename Y, typename Z)(                                        \
-        requires convertible_to<T1 const &, X> AND convertible_to<T2 const &, Y> AND     \
-            convertible_to<T3 const &, Z>)                                               \
-    operator C<X, Y, Z>() const &                                                        \
-    {                                                                                    \
-        return {M1, M2, M3};                                                             \
-    }                                                                                    \
-    template(typename X, typename Y, typename Z)(                                        \
-        requires convertible_to<T1, X> AND convertible_to<T2, Y> AND                     \
-            convertible_to<T3, Z>)                                                       \
-    operator C<X, Y, Z>() &&                                                             \
-    {                                                                                    \
-        return {static_cast<T1 &&>(M1), static_cast<T2 &&>(M2), static_cast<T3 &&>(M3)}; \
-    }                                                                                    \
-    CPP_broken_friend_member                                                             \
-    friend constexpr auto operator==(C<T1, T2, T3> const & x, C<T1, T2, T3> const & y)   \
-        -> CPP_broken_friend_ret(bool)(                                                  \
-            requires equality_comparable<T1> && equality_comparable<T2> &&               \
-                equality_comparable<T3>)                                                 \
-    {                                                                                    \
-        return x.M1 == y.M1 && x.M2 == y.M2 && x.M3 == y.M3;                             \
-    }                                                                                    \
-    CPP_broken_friend_member                                                             \
-    friend constexpr auto operator!=(C<T1, T2, T3> const & x, C<T1, T2, T3> const & y)   \
-        -> CPP_broken_friend_ret(bool)(                                                  \
-            requires equality_comparable<T1> && equality_comparable<T2> &&               \
-                equality_comparable<T3>)                                                 \
-    {                                                                                    \
-        return !(x == y);                                                                \
-    }                                                                                    \
-    /**/
-
-        template<typename I, typename O>
-        struct in_out_result
-        {
-            I in;
-            O out;
-
-            RANGES_ALGO_RESULT_AUX_2(in_out_result, I, in, O, out)
-        };
-
-        template<typename I1, typename O>
-        struct in1_out_result
-        {
-            I1 in1;
-            O out;
-
-            RANGES_ALGO_RESULT_AUX_2(in1_out_result, I1, in1, O, out)
-        };
-
-        template<typename I1, typename I2>
-        struct in1_in2_result
-        {
-            I1 in1;
-            I2 in2;
-
-            RANGES_ALGO_RESULT_AUX_2(in1_in2_result, I1, in1, I2, in2)
-        };
-
-        template<typename I, typename Fun>
-        struct in_fun_result
-        {
-            I in;
-            Fun fun;
-
-            RANGES_ALGO_RESULT_AUX_2(in_fun_result, I, in, Fun, fun)
-        };
-
-        template<typename O, typename Fun>
-        struct out_fun_result
-        {
-            O out;
-            Fun fun;
-
-            RANGES_ALGO_RESULT_AUX_2(out_fun_result, O, out, Fun, fun)
-        };
-
-        template<typename T, typename U>
-        struct min_max_result
-        {
-            T min;
-            U max;
-
-            RANGES_ALGO_RESULT_AUX_2(min_max_result, T, min, U, max)
-        };
-
-        template<typename I1, typename I2, typename O>
-        struct in1_in2_out_result
-        {
-            I1 in1;
-            I2 in2;
-            O out;
-
-            RANGES_ALGO_RESULT_AUX_3(in1_in2_out_result, I1, in1, I2, in2, O, out)
-        };
-
-        template<typename I, typename O1, typename O2>
-        struct in_out1_out2_result
-        {
-            I in;
-            O1 out1;
-            O2 out2;
-
-            RANGES_ALGO_RESULT_AUX_3(in_out1_out2_result, I, in, O1, out1, O2, out2)
-        };
-    } // namespace detail
-    /// \endcond
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/reverse.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/reverse.hpp
deleted file mode 100644
index 8443be5c..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/reverse.hpp
+++ /dev/null
@@ -1,93 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_REVERSE_HPP
-#define RANGES_V3_ALGORITHM_REVERSE_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/utility/swap.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-
-    /// \cond
-    namespace detail
-    {
-        template<typename I>
-        void reverse_impl(I first, I last, std::bidirectional_iterator_tag)
-        {
-            while(first != last)
-            {
-                if(first == --last)
-                    break;
-                ranges::iter_swap(first, last);
-                ++first;
-            }
-        }
-
-        template<typename I>
-        void reverse_impl(I first, I last, std::random_access_iterator_tag)
-        {
-            if(first != last)
-                for(; first < --last; ++first)
-                    ranges::iter_swap(first, last);
-        }
-    } // namespace detail
-    /// \endcond
-
-    RANGES_FUNC_BEGIN(reverse)
-
-        /// \brief function template \c reverse
-        template(typename I, typename S)(
-            /// \pre
-            requires bidirectional_iterator<I> AND sentinel_for<S, I> AND permutable<I>)
-        I RANGES_FUNC(reverse)(I first, S end_)
-        {
-            I last = ranges::next(first, end_);
-            detail::reverse_impl(first, last, iterator_tag_of<I>{});
-            return last;
-        }
-
-        /// \overload
-        template(typename Rng, typename I = iterator_t<Rng>)(
-            /// \pre
-            requires bidirectional_range<Rng> AND permutable<I>)
-        borrowed_iterator_t<Rng> RANGES_FUNC(reverse)(Rng && rng) //
-        {
-            return (*this)(begin(rng), end(rng));
-        }
-
-    RANGES_FUNC_END(reverse)
-
-    namespace cpp20
-    {
-        using ranges::reverse;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/reverse_copy.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/reverse_copy.hpp
deleted file mode 100644
index 89cd82fe..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/reverse_copy.hpp
+++ /dev/null
@@ -1,77 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_REVERSE_COPY_HPP
-#define RANGES_V3_ALGORITHM_REVERSE_COPY_HPP
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/result_types.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    template<typename I, typename O>
-    using reverse_copy_result = detail::in_out_result<I, O>;
-
-    RANGES_FUNC_BEGIN(reverse_copy)
-
-        /// \brief function template \c reverse_copy
-        template(typename I, typename S, typename O)(
-            /// \pre
-            requires bidirectional_iterator<I> AND sentinel_for<S, I> AND
-            weakly_incrementable<O> AND indirectly_copyable<I, O>)
-        reverse_copy_result<I, O> RANGES_FUNC(reverse_copy)(I first, S end_, O out) //
-        {
-            I last = ranges::next(first, end_), res = last;
-            for(; first != last; ++out)
-                *out = *--last;
-            return {res, out};
-        }
-
-        /// \overload
-        template(typename Rng, typename O)(
-            /// \pre
-            requires bidirectional_range<Rng> AND weakly_incrementable<O> AND
-            indirectly_copyable<iterator_t<Rng>, O>)
-        reverse_copy_result<borrowed_iterator_t<Rng>, O> //
-        RANGES_FUNC(reverse_copy)(Rng && rng, O out)            //
-        {
-            return (*this)(begin(rng), end(rng), std::move(out));
-        }
-
-    RANGES_FUNC_END(reverse_copy)
-
-    namespace cpp20
-    {
-        using ranges::reverse_copy;
-        using ranges::reverse_copy_result;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/rotate.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/rotate.hpp
deleted file mode 100644
index 5a0b6976..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/rotate.hpp
+++ /dev/null
@@ -1,236 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-#ifndef RANGES_V3_ALGORITHM_ROTATE_HPP
-#define RANGES_V3_ALGORITHM_ROTATE_HPP
-
-#include <type_traits>
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/move.hpp>
-#include <range/v3/algorithm/move_backward.hpp>
-#include <range/v3/algorithm/swap_ranges.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/move.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/utility/swap.hpp>
-#include <range/v3/view/subrange.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    /// \cond
-    namespace detail
-    {
-        template<typename I> // Forward
-        subrange<I> rotate_left(I first, I last)
-        {
-            iter_value_t<I> tmp = iter_move(first);
-            I lm1 = ranges::move(next(first), last, first).out;
-            *lm1 = std::move(tmp);
-            return {lm1, last};
-        }
-
-        template<typename I> // Bidirectional
-        subrange<I> rotate_right(I first, I last)
-        {
-            I lm1 = prev(last);
-            iter_value_t<I> tmp = iter_move(lm1);
-            I fp1 = move_backward(first, lm1, last).out;
-            *first = std::move(tmp);
-            return {fp1, last};
-        }
-
-        template<typename I, typename S> // Forward
-        subrange<I> rotate_forward(I first, I middle, S last)
-        {
-            I i = middle;
-            while(true)
-            {
-                ranges::iter_swap(first, i);
-                ++first;
-                if(++i == last)
-                    break;
-                if(first == middle)
-                    middle = i;
-            }
-            I r = first;
-            if(first != middle)
-            {
-                I j = middle;
-                while(true)
-                {
-                    ranges::iter_swap(first, j);
-                    ++first;
-                    if(++j == last)
-                    {
-                        if(first == middle)
-                            break;
-                        j = middle;
-                    }
-                    else if(first == middle)
-                        middle = j;
-                }
-            }
-            return {r, i};
-        }
-
-        template<typename D>
-        D gcd(D x, D y)
-        {
-            do
-            {
-                D t = x % y;
-                x = y;
-                y = t;
-            } while(y);
-            return x;
-        }
-
-        template<typename I> // Random
-        subrange<I> rotate_gcd(I first, I middle, I last)
-        {
-            auto const m1 = middle - first;
-            auto const m2 = last - middle;
-            if(m1 == m2)
-            {
-                swap_ranges(first, middle, middle);
-                return {middle, last};
-            }
-            auto const g = detail::gcd(m1, m2);
-            for(I p = first + g; p != first;)
-            {
-                iter_value_t<I> t = iter_move(--p);
-                I p1 = p;
-                I p2 = p1 + m1;
-                do
-                {
-                    *p1 = iter_move(p2);
-                    p1 = p2;
-                    auto const d = last - p2;
-                    if(m1 < d)
-                        p2 += m1;
-                    else
-                        p2 = first + (m1 - d);
-                } while(p2 != p);
-                *p1 = std::move(t);
-            }
-            return {first + m2, last};
-        }
-
-        template<typename I, typename S>
-        subrange<I> rotate_(I first, I middle, S last, std::forward_iterator_tag)
-        {
-            return detail::rotate_forward(first, middle, last);
-        }
-
-        template<typename I>
-        subrange<I> rotate_(I first, I middle, I last, std::forward_iterator_tag)
-        {
-            using value_type = iter_value_t<I>;
-            if(detail::is_trivially_move_assignable_v<value_type>)
-            {
-                if(next(first) == middle)
-                    return detail::rotate_left(first, last);
-            }
-            return detail::rotate_forward(first, middle, last);
-        }
-
-        template<typename I>
-        subrange<I> rotate_(I first, I middle, I last, std::bidirectional_iterator_tag)
-        {
-            using value_type = iter_value_t<I>;
-            if(detail::is_trivially_move_assignable_v<value_type>)
-            {
-                if(next(first) == middle)
-                    return detail::rotate_left(first, last);
-                if(next(middle) == last)
-                    return detail::rotate_right(first, last);
-            }
-            return detail::rotate_forward(first, middle, last);
-        }
-
-        template<typename I>
-        subrange<I> rotate_(I first, I middle, I last, std::random_access_iterator_tag)
-        {
-            using value_type = iter_value_t<I>;
-            if(detail::is_trivially_move_assignable_v<value_type>)
-            {
-                if(next(first) == middle)
-                    return detail::rotate_left(first, last);
-                if(next(middle) == last)
-                    return detail::rotate_right(first, last);
-                return detail::rotate_gcd(first, middle, last);
-            }
-            return detail::rotate_forward(first, middle, last);
-        }
-    } // namespace detail
-    /// \endcond
-
-    RANGES_FUNC_BEGIN(rotate)
-
-        /// \brief function template \c rotate
-        template(typename I, typename S)(
-            /// \pre
-            requires permutable<I> AND sentinel_for<S, I>)
-        subrange<I> RANGES_FUNC(rotate)(I first, I middle, S last) //
-        {
-            if(first == middle)
-            {
-                first = ranges::next(std::move(first), last);
-                return {first, first};
-            }
-            if(middle == last)
-            {
-                return {first, middle};
-            }
-            return detail::rotate_(first, middle, last, iterator_tag_of<I>{});
-        }
-
-        /// \overload
-        template(typename Rng, typename I = iterator_t<Rng>)(
-            /// \pre
-            requires range<Rng> AND permutable<I>)
-        borrowed_subrange_t<Rng> RANGES_FUNC(rotate)(Rng && rng, I middle) //
-        {
-            return (*this)(begin(rng), std::move(middle), end(rng));
-        }
-
-    RANGES_FUNC_END(rotate)
-
-    namespace cpp20
-    {
-        using ranges::rotate;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/rotate_copy.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/rotate_copy.hpp
deleted file mode 100644
index 16817b30..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/rotate_copy.hpp
+++ /dev/null
@@ -1,78 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_ROTATE_COPY_HPP
-#define RANGES_V3_ALGORITHM_ROTATE_COPY_HPP
-
-#include <functional>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/copy.hpp>
-#include <range/v3/algorithm/result_types.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    template<typename I, typename O>
-    using rotate_copy_result = detail::in_out_result<I, O>;
-
-    RANGES_FUNC_BEGIN(rotate_copy)
-
-        /// \brief function template \c rotate_copy
-        template(typename I, typename S, typename O, typename P = identity)(
-            /// \pre
-            requires forward_iterator<I> AND sentinel_for<S, I> AND
-            weakly_incrementable<O> AND indirectly_copyable<I, O>)
-        rotate_copy_result<I, O> //
-        RANGES_FUNC(rotate_copy)(I first, I middle, S last, O out) //
-        {
-            auto res = ranges::copy(middle, std::move(last), std::move(out));
-            return {std::move(res.in),
-                    ranges::copy(std::move(first), middle, std::move(res.out)).out};
-        }
-
-        /// \overload
-        template(typename Rng, typename O, typename P = identity)(
-            /// \pre
-            requires range<Rng> AND weakly_incrementable<O> AND
-            indirectly_copyable<iterator_t<Rng>, O>)
-        rotate_copy_result<borrowed_iterator_t<Rng>, O> //
-        RANGES_FUNC(rotate_copy)(Rng && rng, iterator_t<Rng> middle, O out) //
-        {
-            return (*this)(begin(rng), std::move(middle), end(rng), std::move(out));
-        }
-
-    RANGES_FUNC_END(rotate_copy)
-
-    namespace cpp20
-    {
-        using ranges::rotate_copy;
-        using ranges::rotate_copy_result;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/sample.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/sample.hpp
deleted file mode 100644
index 0fd67019..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/sample.hpp
+++ /dev/null
@@ -1,254 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_SAMPLE_HPP
-#define RANGES_V3_ALGORITHM_SAMPLE_HPP
-
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/copy_n.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/random.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    template<typename I, typename O>
-    using sample_result = detail::in_out_result<I, O>;
-
-    /// \cond
-    namespace detail
-    {
-        template<typename I, typename S, typename O, typename Gen>
-        sample_result<I, O> sample_sized_impl(I first,
-                                              S last,
-                                              iter_difference_t<I> pop_size,
-                                              O out,
-                                              iter_difference_t<O> sample_size,
-                                              Gen && gen)
-        {
-            if(pop_size > 0 && sample_size > 0)
-            {
-                std::uniform_int_distribution<iter_difference_t<I>> dist;
-                using param_t = typename decltype(dist)::param_type;
-                for(; first != last; ++first)
-                {
-                    if(sample_size >= pop_size)
-                        return copy_n(std::move(first), pop_size, std::move(out));
-
-                    if(dist(gen, param_t{0, --pop_size}) < sample_size)
-                    {
-                        *out = *first;
-                        ++out;
-                        if(--sample_size == 0)
-                            break;
-                    }
-                }
-            }
-
-            return {std::move(first), std::move(out)};
-        }
-    } // namespace detail
-    /// \endcond
-
-    RANGES_FUNC_BEGIN(sample)
-
-        /// \brief function template \c sample
-        template(typename I,
-                 typename S,
-                 typename O,
-                 typename Gen = detail::default_random_engine &)(
-            /// \pre
-            requires input_iterator<I> AND sentinel_for<S, I> AND
-                weakly_incrementable<O> AND indirectly_copyable<I, O> AND
-                uniform_random_bit_generator<std::remove_reference_t<Gen>> AND
-                (random_access_iterator<O> || forward_iterator<I> ||
-                 sized_sentinel_for<S, I>))
-        sample_result<I, O> RANGES_FUNC(sample)(I first,
-                                                S last,
-                                                O out,
-                                                iter_difference_t<O> const n,
-                                                Gen && gen = detail::get_random_engine())
-        {
-            if(RANGES_CONSTEXPR_IF(forward_iterator<I> || sized_sentinel_for<S, I>)) //
-            {
-                auto const k = distance(first, last);
-                return detail::sample_sized_impl(std::move(first),
-                                                 std::move(last),
-                                                 k,
-                                                 std::move(out),
-                                                 n,
-                                                 static_cast<Gen &&>(gen));
-            }
-            else
-            {
-                // out is random-access here; calls to advance(out,n) and
-                // next(out,n) are O(1).
-                if(n > 0)
-                {
-                    for(iter_difference_t<O> i = 0; i < n; (void)++i, ++first)
-                    {
-                        if(first == last)
-                        {
-                            advance(out, i);
-                            goto done;
-                        }
-                        *next(out, i) = *first;
-                    }
-
-                    std::uniform_int_distribution<iter_difference_t<O>> dist;
-                    using param_t = typename decltype(dist)::param_type;
-                    for(auto pop_size = n; first != last; (void)++first, ++pop_size)
-                    {
-                        auto const i = dist(gen, param_t{0, pop_size});
-                        if(i < n)
-                            *next(out, i) = *first;
-                    }
-
-                    advance(out, n);
-                }
-            done:
-                return {std::move(first), std::move(out)};
-            }
-        }
-
-        /// \overload
-        template(typename I,
-                 typename S,
-                 typename ORng,
-                 typename Gen = detail::default_random_engine &)(
-            /// \pre
-            requires input_iterator<I> AND sentinel_for<S, I> AND
-                weakly_incrementable<iterator_t<ORng>> AND
-                indirectly_copyable<I, iterator_t<ORng>> AND
-                uniform_random_bit_generator<std::remove_reference_t<Gen>> AND
-                (forward_range<ORng> || sized_range<ORng>) AND
-                (random_access_iterator<iterator_t<ORng>> || forward_iterator<I> ||
-                    sized_sentinel_for<S, I>))
-        sample_result<I, borrowed_iterator_t<ORng>> RANGES_FUNC(sample)(
-            I first,
-            S last,
-            ORng && out,
-            Gen && gen = detail::get_random_engine()) //
-        {
-            if(RANGES_CONSTEXPR_IF(forward_iterator<I> || sized_sentinel_for<S, I>)) //
-            {
-                auto k = distance(first, last);
-                return detail::sample_sized_impl(std::move(first),
-                                                 std::move(last),
-                                                 k,
-                                                 begin(out),
-                                                 distance(out),
-                                                 static_cast<Gen &&>(gen));
-            }
-            else
-            {
-                return (*this)(std::move(first),
-                               std::move(last),
-                               begin(out),
-                               distance(out),
-                               static_cast<Gen &&>(gen));
-            }
-        }
-
-        /// \overload
-        template(typename Rng,
-                 typename O,
-                 typename Gen = detail::default_random_engine &)(
-            /// \pre
-            requires input_range<Rng> AND weakly_incrementable<O> AND
-                indirectly_copyable<iterator_t<Rng>, O> AND
-                uniform_random_bit_generator<std::remove_reference_t<Gen>> AND
-                (random_access_iterator<O> || forward_range<Rng> || sized_range<Rng>))
-        sample_result<borrowed_iterator_t<Rng>, O> RANGES_FUNC(sample)(
-            Rng && rng,
-            O out,
-            iter_difference_t<O> const n,
-            Gen && gen = detail::get_random_engine()) //
-        {
-            if(RANGES_CONSTEXPR_IF(forward_range<Rng> || sized_range<Rng>)) //
-            {
-                return detail::sample_sized_impl(begin(rng),
-                                                 end(rng),
-                                                 distance(rng),
-                                                 std::move(out),
-                                                 n,
-                                                 static_cast<Gen &&>(gen));
-            }
-            else
-            {
-                return (*this)(
-                    begin(rng), end(rng), std::move(out), n, static_cast<Gen &&>(gen));
-            }
-        }
-
-        /// \overload
-        template(typename IRng,
-                 typename ORng,
-                 typename Gen = detail::default_random_engine &)(
-            /// \pre
-            requires input_range<IRng> AND range<ORng> AND
-                indirectly_copyable<iterator_t<IRng>, iterator_t<ORng>> AND
-                uniform_random_bit_generator<std::remove_reference_t<Gen>> AND
-                (random_access_iterator<iterator_t<ORng>> || forward_range<IRng> ||
-                    sized_range<IRng>) AND
-                (forward_range<ORng> || sized_range<ORng>))
-        sample_result<borrowed_iterator_t<IRng>, borrowed_iterator_t<ORng>> //
-        RANGES_FUNC(sample)(IRng && rng,
-                            ORng && out,
-                            Gen && gen = detail::get_random_engine())
-        {
-            if(RANGES_CONSTEXPR_IF(forward_range<IRng> || sized_range<IRng>)) //
-            {
-                return detail::sample_sized_impl(begin(rng),
-                                                 end(rng),
-                                                 distance(rng),
-                                                 begin(out),
-                                                 distance(out),
-                                                 static_cast<Gen &&>(gen));
-            }
-            else
-            {
-                return (*this)(begin(rng),
-                               end(rng),
-                               begin(out),
-                               distance(out),
-                               static_cast<Gen &&>(gen));
-            }
-        }
-
-    RANGES_FUNC_END(sample)
-
-    namespace cpp20
-    {
-        using ranges::sample_result;
-        using ranges::sample;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/search.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/search.hpp
deleted file mode 100644
index 62fdcaa7..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/search.hpp
+++ /dev/null
@@ -1,231 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-#ifndef RANGES_V3_ALGORITHM_SEARCH_HPP
-#define RANGES_V3_ALGORITHM_SEARCH_HPP
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/subrange.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-
-    /// \cond
-    namespace detail
-    {
-        template<typename I1, typename S1, typename D1, typename I2, typename S2,
-                 typename D2, typename C, typename P1, typename P2>
-        subrange<I1> search_sized_impl(I1 const begin1_, S1 end1, D1 const d1_, I2 begin2,
-                                       S2 end2, D2 d2, C & pred, P1 & proj1, P2 & proj2)
-        {
-            D1 d1 = d1_;
-            auto begin1 = uncounted(begin1_);
-            while(true)
-            {
-                // Find first element in sequence 1 that matches *begin2, with a mininum
-                // of loop checks
-                while(true)
-                {
-                    if(d1 < d2) // return the last if we've run out of room
-                    {
-                        auto e =
-                            ranges::next(recounted(begin1_, std::move(begin1), d1_ - d1),
-                                         std::move(end1));
-                        return {e, e};
-                    }
-                    if(invoke(pred, invoke(proj1, *begin1), invoke(proj2, *begin2)))
-                        break;
-                    ++begin1;
-                    --d1;
-                }
-                // *begin1 matches *begin2, now match elements after here
-                auto m1 = begin1;
-                I2 m2 = begin2;
-                while(true)
-                {
-                    if(++m2 == end2) // If pattern exhausted, begin1 is the answer (works
-                                     // for 1 element pattern)
-                    {
-                        return {recounted(begin1_, std::move(begin1), d1_ - d1),
-                                recounted(begin1_, std::move(++m1), d1_ - d1)};
-                    }
-                    ++m1; // No need to check, we know we have room to match successfully
-                    if(!invoke(
-                           pred,
-                           invoke(proj1, *m1),
-                           invoke(
-                               proj2,
-                               *m2))) // if there is a mismatch, restart with a new begin1
-                    {
-                        ++begin1;
-                        --d1;
-                        break;
-                    } // else there is a match, check next elements
-                }
-            }
-        }
-
-        template<typename I1, typename S1, typename I2, typename S2, typename C,
-                 typename P1, typename P2>
-        subrange<I1> search_impl(I1 begin1, S1 end1, I2 begin2, S2 end2, C & pred,
-                                 P1 & proj1, P2 & proj2)
-        {
-            while(true)
-            {
-                // Find first element in sequence 1 that matches *begin2, with a mininum
-                // of loop checks
-                while(true)
-                {
-                    if(begin1 == end1) // return end1 if no element matches *begin2
-                        return {begin1, begin1};
-                    if(invoke(pred, invoke(proj1, *begin1), invoke(proj2, *begin2)))
-                        break;
-                    ++begin1;
-                }
-                // *begin1 matches *begin2, now match elements after here
-                I1 m1 = begin1;
-                I2 m2 = begin2;
-                while(true)
-                {
-                    if(++m2 == end2) // If pattern exhausted, begin1 is the answer (works
-                                     // for 1 element pattern)
-                        return {begin1, ++m1};
-                    if(++m1 == end1) // Otherwise if source exhausted, pattern not found
-                        return {m1, m1};
-                    if(!invoke(
-                           pred,
-                           invoke(proj1, *m1),
-                           invoke(
-                               proj2,
-                               *m2))) // if there is a mismatch, restart with a new begin1
-                    {
-                        ++begin1;
-                        break;
-                    } // else there is a match, check next elements
-                }
-            }
-        }
-    } // namespace detail
-    /// \endcond
-
-    RANGES_FUNC_BEGIN(search)
-
-        /// \brief function template \c search
-        template(typename I1,
-                 typename S1,
-                 typename I2,
-                 typename S2,
-                 typename C = equal_to,
-                 typename P1 = identity,
-                 typename P2 = identity)(
-            /// \pre
-            requires forward_iterator<I1> AND sentinel_for<S1, I1> AND
-                forward_iterator<I2> AND sentinel_for<S2, I2> AND
-                indirectly_comparable<I1, I2, C, P1, P2>)
-        subrange<I1> RANGES_FUNC(search)(I1 begin1,
-                                         S1 end1,
-                                         I2 begin2,
-                                         S2 end2,
-                                         C pred = C{},
-                                         P1 proj1 = P1{},
-                                         P2 proj2 = P2{}) //
-        {
-            if(begin2 == end2)
-                return {begin1, begin1};
-            if(RANGES_CONSTEXPR_IF(sized_sentinel_for<S1, I1> &&
-                                   sized_sentinel_for<S2, I2>))
-                return detail::search_sized_impl(std::move(begin1),
-                                                 std::move(end1),
-                                                 distance(begin1, end1),
-                                                 std::move(begin2),
-                                                 std::move(end2),
-                                                 distance(begin2, end2),
-                                                 pred,
-                                                 proj1,
-                                                 proj2);
-            else
-                return detail::search_impl(std::move(begin1),
-                                           std::move(end1),
-                                           std::move(begin2),
-                                           std::move(end2),
-                                           pred,
-                                           proj1,
-                                           proj2);
-        }
-
-        /// \overload
-        template(typename Rng1,
-                 typename Rng2,
-                 typename C = equal_to,
-                 typename P1 = identity,
-                 typename P2 = identity)(
-            /// \pre
-            requires forward_range<Rng1> AND forward_range<Rng2> AND
-                indirectly_comparable<iterator_t<Rng1>, iterator_t<Rng2>, C, P1, P2>)
-        borrowed_subrange_t<Rng1> RANGES_FUNC(search)(
-            Rng1 && rng1, Rng2 && rng2, C pred = C{}, P1 proj1 = P1{}, P2 proj2 = P2{}) //
-        {
-            if(empty(rng2))
-                return subrange<iterator_t<Rng1>>{begin(rng1), begin(rng1)};
-            if(RANGES_CONSTEXPR_IF(sized_range<Rng1> && sized_range<Rng2>))
-                return detail::search_sized_impl(begin(rng1),
-                                                 end(rng1),
-                                                 distance(rng1),
-                                                 begin(rng2),
-                                                 end(rng2),
-                                                 distance(rng2),
-                                                 pred,
-                                                 proj1,
-                                                 proj2);
-            else
-                return detail::search_impl(
-                    begin(rng1), end(rng1), begin(rng2), end(rng2), pred, proj1, proj2);
-        }
-
-    RANGES_FUNC_END(search)
-
-    namespace cpp20
-    {
-        using ranges::search;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/search_n.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/search_n.hpp
deleted file mode 100644
index c87eaaea..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/search_n.hpp
+++ /dev/null
@@ -1,199 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-#ifndef RANGES_V3_ALGORITHM_SEARCH_N_HPP
-#define RANGES_V3_ALGORITHM_SEARCH_N_HPP
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/subrange.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-
-    /// \cond
-    namespace detail
-    {
-        template<typename I, typename S, typename D, typename V, typename C, typename P>
-        subrange<I> search_n_sized_impl(I const begin_, S last, D const d_, D cnt,
-                                        V const & val, C & pred, P & proj)
-        {
-            D d = d_; // always the distance from first to end
-            auto first = uncounted(begin_);
-            while(true)
-            {
-                // Find first element in sequence 1 that matches val, with a mininum of
-                // loop checks
-                while(true)
-                {
-                    if(d < cnt) // return the last if we've run out of room
-                    {
-                        auto e = ranges::next(recounted(begin_, std::move(first), d_ - d),
-                                              std::move(last));
-                        return {e, e};
-                    }
-                    if(invoke(pred, invoke(proj, *first), val))
-                        break;
-                    ++first;
-                    --d;
-                }
-                // *first matches val, now match elements after here
-                auto m = first;
-                D c = 0;
-                while(true)
-                {
-                    if(++c == cnt) // If pattern exhausted, first is the answer (works
-                                   // for 1 element pattern)
-                        return {recounted(begin_, std::move(first), d_ - d),
-                                recounted(begin_, std::move(++m), d_ - d)};
-                    ++m; // No need to check, we know we have room to match successfully
-                    if(!invoke(pred,
-                               invoke(proj, *m),
-                               val)) // if there is a mismatch, restart with a new begin
-                    {
-                        first = next(std::move(m));
-                        d -= (c + 1);
-                        break;
-                    } // else there is a match, check next elements
-                }
-            }
-        }
-
-        template<typename I, typename S, typename D, typename V, typename C, typename P>
-        subrange<I> search_n_impl(I first, S last, D cnt, V const & val, C & pred,
-                                  P & proj)
-        {
-            while(true)
-            {
-                // Find first element in sequence 1 that matches val, with a mininum of
-                // loop checks
-                while(true)
-                {
-                    if(first == last) // return last if no element matches val
-                        return {first, first};
-                    if(invoke(pred, invoke(proj, *first), val))
-                        break;
-                    ++first;
-                }
-                // *first matches val, now match elements after here
-                I m = first;
-                D c = 0;
-                while(true)
-                {
-                    if(++c == cnt) // If pattern exhausted, first is the answer (works
-                                   // for 1 element pattern)
-                        return {first, ++m};
-                    if(++m == last) // Otherwise if source exhausted, pattern not found
-                        return {m, m};
-                    if(!invoke(pred,
-                               invoke(proj, *m),
-                               val)) // if there is a mismatch, restart with a new begin
-                    {
-                        first = next(std::move(m));
-                        break;
-                    } // else there is a match, check next elements
-                }
-            }
-        }
-    } // namespace detail
-    /// \endcond
-
-    RANGES_FUNC_BEGIN(search_n)
-
-        /// \brief function template \c search_n
-        template(typename I,
-                 typename S,
-                 typename V,
-                 typename C = equal_to,
-                 typename P = identity)(
-            /// \pre
-            requires forward_iterator<I> AND sentinel_for<S, I> AND
-                indirectly_comparable<I, V const *, C, P>)
-        subrange<I> RANGES_FUNC(search_n)(I first,
-                                          S last,
-                                          iter_difference_t<I> cnt,
-                                          V const & val,
-                                          C pred = C{},
-                                          P proj = P{}) //
-        {
-            if(cnt <= 0)
-                return {first, first};
-            if(RANGES_CONSTEXPR_IF(sized_sentinel_for<S, I>))
-                return detail::search_n_sized_impl(std::move(first),
-                                                   std::move(last),
-                                                   distance(first, last),
-                                                   cnt,
-                                                   val,
-                                                   pred,
-                                                   proj);
-            else
-                return detail::search_n_impl(
-                    std::move(first), std::move(last), cnt, val, pred, proj);
-        }
-
-        /// \overload
-        template(typename Rng, typename V, typename C = equal_to, typename P = identity)(
-            /// \pre
-            requires forward_range<Rng> AND
-                indirectly_comparable<iterator_t<Rng>, V const *, C, P>)
-        borrowed_subrange_t<Rng> RANGES_FUNC(search_n)(Rng && rng,
-                                                   iter_difference_t<iterator_t<Rng>> cnt,
-                                                   V const & val,
-                                                   C pred = C{},
-                                                   P proj = P{}) //
-        {
-            if(cnt <= 0)
-                return subrange<iterator_t<Rng>>{begin(rng), begin(rng)};
-            if(RANGES_CONSTEXPR_IF(sized_range<Rng>))
-                return detail::search_n_sized_impl(
-                    begin(rng), end(rng), distance(rng), cnt, val, pred, proj);
-            else
-                return detail::search_n_impl(begin(rng), end(rng), cnt, val, pred, proj);
-        }
-
-    RANGES_FUNC_END(search_n)
-
-    namespace cpp20
-    {
-        using ranges::search_n;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/set_algorithm.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/set_algorithm.hpp
deleted file mode 100644
index 0d0406e1..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/set_algorithm.hpp
+++ /dev/null
@@ -1,454 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-#ifndef RANGES_V3_ALGORITHM_SET_ALGORITHM_HPP
-#define RANGES_V3_ALGORITHM_SET_ALGORITHM_HPP
-
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/copy.hpp>
-#include <range/v3/algorithm/result_types.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(includes)
-
-        /// \brief function template \c includes
-        template(typename I1,
-                 typename S1,
-                 typename I2,
-                 typename S2,
-                 typename C = less,
-                 typename P1 = identity,
-                 typename P2 = identity)(
-            /// \pre
-            requires input_iterator<I1> AND sentinel_for<S1, I1> AND
-                input_iterator<I2> AND sentinel_for<S2, I2> AND
-                indirect_strict_weak_order<C, projected<I1, P1>, projected<I2, P2>>)
-        bool RANGES_FUNC(includes)(I1 begin1,
-                                   S1 end1,
-                                   I2 begin2,
-                                   S2 end2,
-                                   C pred = C{},
-                                   P1 proj1 = P1{},
-                                   P2 proj2 = P2{}) //
-        {
-            for(; begin2 != end2; ++begin1)
-            {
-                if(begin1 == end1 ||
-                   invoke(pred, invoke(proj2, *begin2), invoke(proj1, *begin1)))
-                    return false;
-                if(!invoke(pred, invoke(proj1, *begin1), invoke(proj2, *begin2)))
-                    ++begin2;
-            }
-            return true;
-        }
-
-        /// \overload
-        template(typename Rng1,
-                 typename Rng2,
-                 typename C = less,
-                 typename P1 = identity,
-                 typename P2 = identity)(
-            /// \pre
-            requires input_range<Rng1> AND input_range<Rng2> AND
-                indirect_strict_weak_order<C,
-                                           projected<iterator_t<Rng1>, P1>,
-                                           projected<iterator_t<Rng2>, P2>>)
-        bool RANGES_FUNC(includes)(
-            Rng1 && rng1, Rng2 && rng2, C pred = C{}, P1 proj1 = P1{}, P2 proj2 = P2{}) //
-        {
-            return (*this)(begin(rng1),
-                           end(rng1),
-                           begin(rng2),
-                           end(rng2),
-                           std::move(pred),
-                           std::move(proj1),
-                           std::move(proj2));
-        }
-
-    RANGES_FUNC_END(includes)
-
-    namespace cpp20
-    {
-        using ranges::includes;
-    }
-
-    template<typename I1, typename I2, typename O>
-    using set_union_result = detail::in1_in2_out_result<I1, I2, O>;
-
-    RANGES_FUNC_BEGIN(set_union)
-
-        /// \brief function template \c set_union
-        template(typename I1,
-                 typename S1,
-                 typename I2,
-                 typename S2,
-                 typename O,
-                 typename C = less,
-                 typename P1 = identity,
-                 typename P2 = identity)(
-            /// \pre
-            requires sentinel_for<S1, I1> AND sentinel_for<S2, I2> AND
-                mergeable<I1, I2, O, C, P1, P2>)
-        set_union_result<I1, I2, O> RANGES_FUNC(set_union)(I1 begin1,
-                                                           S1 end1,
-                                                           I2 begin2,
-                                                           S2 end2,
-                                                           O out,
-                                                           C pred = C{},
-                                                           P1 proj1 = P1{},
-                                                           P2 proj2 = P2{}) //
-        {
-            for(; begin1 != end1; ++out)
-            {
-                if(begin2 == end2)
-                {
-                    auto tmp = ranges::copy(begin1, end1, out);
-                    return {tmp.in, begin2, tmp.out};
-                }
-                if(invoke(pred, invoke(proj2, *begin2), invoke(proj1, *begin1)))
-                {
-                    *out = *begin2;
-                    ++begin2;
-                }
-                else
-                {
-                    *out = *begin1;
-                    if(!invoke(pred, invoke(proj1, *begin1), invoke(proj2, *begin2)))
-                        ++begin2;
-                    ++begin1;
-                }
-            }
-            auto tmp = ranges::copy(begin2, end2, out);
-            return {begin1, tmp.in, tmp.out};
-        }
-
-        /// \overload
-        template(typename Rng1,
-                 typename Rng2,
-                 typename O,
-                 typename C = less,
-                 typename P1 = identity,
-                 typename P2 = identity)(
-            /// \pre
-            requires range<Rng1> AND range<Rng2> AND
-                mergeable<iterator_t<Rng1>, iterator_t<Rng2>, O, C, P1, P2>)
-        set_union_result<borrowed_iterator_t<Rng1>, borrowed_iterator_t<Rng2>, O> //
-        RANGES_FUNC(set_union)(Rng1 && rng1,
-                               Rng2 && rng2,
-                               O out,
-                               C pred = C{},
-                               P1 proj1 = P1{},
-                               P2 proj2 = P2{}) //
-        {
-            return (*this)(begin(rng1),
-                           end(rng1),
-                           begin(rng2),
-                           end(rng2),
-                           std::move(out),
-                           std::move(pred),
-                           std::move(proj1),
-                           std::move(proj2));
-        }
-
-    RANGES_FUNC_END(set_union)
-
-    namespace cpp20
-    {
-        using ranges::set_union;
-        using ranges::set_union_result;
-    } // namespace cpp20
-
-    RANGES_FUNC_BEGIN(set_intersection)
-
-        /// \brief function template \c set_intersection
-        template(typename I1,
-                 typename S1,
-                 typename I2,
-                 typename S2,
-                 typename O,
-                 typename C = less,
-                 typename P1 = identity,
-                 typename P2 = identity)(
-            /// \pre
-            requires sentinel_for<S1, I1> AND sentinel_for<S2, I2> AND
-                mergeable<I1, I2, O, C, P1, P2>)
-        O RANGES_FUNC(set_intersection)(I1 begin1,
-                                        S1 end1,
-                                        I2 begin2,
-                                        S2 end2,
-                                        O out,
-                                        C pred = C{},
-                                        P1 proj1 = P1{},
-                                        P2 proj2 = P2{}) //
-        {
-            while(begin1 != end1 && begin2 != end2)
-            {
-                if(invoke(pred, invoke(proj1, *begin1), invoke(proj2, *begin2)))
-                    ++begin1;
-                else
-                {
-                    if(!invoke(pred, invoke(proj2, *begin2), invoke(proj1, *begin1)))
-                    {
-                        *out = *begin1;
-                        ++out;
-                        ++begin1;
-                    }
-                    ++begin2;
-                }
-            }
-            return out;
-        }
-
-        /// \overload
-        template(typename Rng1,
-                 typename Rng2,
-                 typename O,
-                 typename C = less,
-                 typename P1 = identity,
-                 typename P2 = identity)(
-            /// \pre
-            requires range<Rng1> AND range<Rng2> AND
-                mergeable<iterator_t<Rng1>, iterator_t<Rng2>, O, C, P1, P2>)
-        O RANGES_FUNC(set_intersection)(Rng1 && rng1,
-                                        Rng2 && rng2,
-                                        O out,
-                                        C pred = C{},
-                                        P1 proj1 = P1{},
-                                        P2 proj2 = P2{}) //
-        {
-            return (*this)(begin(rng1),
-                           end(rng1),
-                           begin(rng2),
-                           end(rng2),
-                           std::move(out),
-                           std::move(pred),
-                           std::move(proj1),
-                           std::move(proj2));
-        }
-
-    RANGES_FUNC_END(set_intersection)
-
-    namespace cpp20
-    {
-        using ranges::set_intersection;
-    }
-
-    template<typename I, typename O>
-    using set_difference_result = detail::in1_out_result<I, O>;
-
-    RANGES_FUNC_BEGIN(set_difference)
-
-        /// \brief function template \c set_difference
-        template(typename I1,
-                 typename S1,
-                 typename I2,
-                 typename S2,
-                 typename O,
-                 typename C = less,
-                 typename P1 = identity,
-                 typename P2 = identity)(
-            /// \pre
-            requires sentinel_for<S1, I1> AND sentinel_for<S2, I2> AND
-                mergeable<I1, I2, O, C, P1, P2>)
-        set_difference_result<I1, O> RANGES_FUNC(set_difference)(I1 begin1,
-                                                                 S1 end1,
-                                                                 I2 begin2,
-                                                                 S2 end2,
-                                                                 O out,
-                                                                 C pred = C{},
-                                                                 P1 proj1 = P1{},
-                                                                 P2 proj2 = P2{}) //
-        {
-            while(begin1 != end1)
-            {
-                if(begin2 == end2)
-                {
-                    auto tmp = ranges::copy(begin1, end1, out);
-                    return {tmp.in, tmp.out};
-                }
-                if(invoke(pred, invoke(proj1, *begin1), invoke(proj2, *begin2)))
-                {
-                    *out = *begin1;
-                    ++out;
-                    ++begin1;
-                }
-                else
-                {
-                    if(!invoke(pred, invoke(proj2, *begin2), invoke(proj1, *begin1)))
-                        ++begin1;
-                    ++begin2;
-                }
-            }
-            return {begin1, out};
-        }
-
-        /// \overload
-        template(typename Rng1,
-                 typename Rng2,
-                 typename O,
-                 typename C = less,
-                 typename P1 = identity,
-                 typename P2 = identity)(
-            /// \pre
-            requires range<Rng1> AND range<Rng2> AND
-                mergeable<iterator_t<Rng1>, iterator_t<Rng2>, O, C, P1, P2>)
-        set_difference_result<borrowed_iterator_t<Rng1>, O> //
-        RANGES_FUNC(set_difference)(Rng1 && rng1,
-                                    Rng2 && rng2,
-                                    O out,
-                                    C pred = C{},
-                                    P1 proj1 = P1{},
-                                    P2 proj2 = P2{}) //
-        {
-            return (*this)(begin(rng1),
-                           end(rng1),
-                           begin(rng2),
-                           end(rng2),
-                           std::move(out),
-                           std::move(pred),
-                           std::move(proj1),
-                           std::move(proj2));
-        }
-
-    RANGES_FUNC_END(set_difference)
-
-    namespace cpp20
-    {
-        using ranges::set_difference;
-        using ranges::set_difference_result;
-    } // namespace cpp20
-
-    template<typename I1, typename I2, typename O>
-    using set_symmetric_difference_result = detail::in1_in2_out_result<I1, I2, O>;
-
-    RANGES_FUNC_BEGIN(set_symmetric_difference)
-
-        /// \brief function template \c set_symmetric_difference
-        template(typename I1,
-                 typename S1,
-                 typename I2,
-                 typename S2,
-                 typename O,
-                 typename C = less,
-                 typename P1 = identity,
-                 typename P2 = identity)(
-            /// \pre
-            requires sentinel_for<S1, I1> AND sentinel_for<S2, I2> AND
-                mergeable<I1, I2, O, C, P1, P2>)
-        set_symmetric_difference_result<I1, I2, O> //
-        RANGES_FUNC(set_symmetric_difference)(I1 begin1,
-                                              S1 end1,
-                                              I2 begin2,
-                                              S2 end2,
-                                              O out,
-                                              C pred = C{},
-                                              P1 proj1 = P1{},
-                                              P2 proj2 = P2{}) //
-        {
-            while(begin1 != end1)
-            {
-                if(begin2 == end2)
-                {
-                    auto tmp = ranges::copy(begin1, end1, out);
-                    return {tmp.in, begin2, tmp.out};
-                }
-                if(invoke(pred, invoke(proj1, *begin1), invoke(proj2, *begin2)))
-                {
-                    *out = *begin1;
-                    ++out;
-                    ++begin1;
-                }
-                else
-                {
-                    if(invoke(pred, invoke(proj2, *begin2), invoke(proj1, *begin1)))
-                    {
-                        *out = *begin2;
-                        ++out;
-                    }
-                    else
-                        ++begin1;
-                    ++begin2;
-                }
-            }
-            auto tmp = ranges::copy(begin2, end2, out);
-            return {begin1, tmp.in, tmp.out};
-        }
-
-        /// \overload
-        template(typename Rng1,
-                 typename Rng2,
-                 typename O,
-                 typename C = less,
-                 typename P1 = identity,
-                 typename P2 = identity)(
-            /// \pre
-            requires range<Rng1> AND range<Rng2> AND
-                mergeable<iterator_t<Rng1>, iterator_t<Rng2>, O, C, P1, P2>)
-        set_symmetric_difference_result<borrowed_iterator_t<Rng1>,
-                                        borrowed_iterator_t<Rng2>,
-                                        O>
-        RANGES_FUNC(set_symmetric_difference)(Rng1 && rng1,
-                                              Rng2 && rng2,
-                                              O out,
-                                              C pred = C{},
-                                              P1 proj1 = P1{},
-                                              P2 proj2 = P2{}) //
-        {
-            return (*this)(begin(rng1),
-                           end(rng1),
-                           begin(rng2),
-                           end(rng2),
-                           std::move(out),
-                           std::move(pred),
-                           std::move(proj1),
-                           std::move(proj2));
-        }
-
-    RANGES_FUNC_END(set_symmetric_difference)
-
-    namespace cpp20
-    {
-        using ranges::set_symmetric_difference;
-        using ranges::set_symmetric_difference_result;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/shuffle.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/shuffle.hpp
deleted file mode 100644
index 1e944d9c..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/shuffle.hpp
+++ /dev/null
@@ -1,92 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_SHUFFLE_HPP
-#define RANGES_V3_ALGORITHM_SHUFFLE_HPP
-
-#include <cstdint>
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/random.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/utility/swap.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(shuffle)
-
-        /// \brief function template \c shuffle
-        template(typename I, typename S, typename Gen = detail::default_random_engine &)(
-            /// \pre
-            requires random_access_iterator<I> AND sentinel_for<S, I> AND
-                permutable<I> AND
-                uniform_random_bit_generator<std::remove_reference_t<Gen>> AND
-                convertible_to<invoke_result_t<Gen &>, iter_difference_t<I>>)
-        I RANGES_FUNC(shuffle)(I const first,
-                               S const last,
-                               Gen && gen = detail::get_random_engine()) //
-        {
-            auto mid = first;
-            if(mid == last)
-                return mid;
-            using D1 = iter_difference_t<I>;
-            using D2 =
-                meta::conditional_t<std::is_integral<D1>::value, D1, std::ptrdiff_t>;
-            std::uniform_int_distribution<D2> uid{};
-            using param_t = typename decltype(uid)::param_type;
-            while(++mid != last)
-            {
-                RANGES_ENSURE(mid - first <= PTRDIFF_MAX);
-                if(auto const i = uid(gen, param_t{0, D2(mid - first)}))
-                    ranges::iter_swap(mid - i, mid);
-            }
-            return mid;
-        }
-
-        /// \overload
-        template(typename Rng, typename Gen = detail::default_random_engine &)(
-            /// \pre
-            requires random_access_range<Rng> AND permutable<iterator_t<Rng>> AND
-                uniform_random_bit_generator<std::remove_reference_t<Gen>> AND
-                convertible_to<invoke_result_t<Gen &>,
-                               iter_difference_t<iterator_t<Rng>>>)
-        borrowed_iterator_t<Rng> //
-        RANGES_FUNC(shuffle)(Rng && rng, Gen && rand = detail::get_random_engine()) //
-        {
-            return (*this)(begin(rng), end(rng), static_cast<Gen &&>(rand));
-        }
-
-    RANGES_FUNC_END(shuffle)
-
-    namespace cpp20
-    {
-        using ranges::shuffle;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/sort.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/sort.hpp
deleted file mode 100644
index 9255d2db..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/sort.hpp
+++ /dev/null
@@ -1,234 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright (c) 1994
-//  Hewlett-Packard Company
-//
-//  Permission to use, copy, modify, distribute and sell this software
-//  and its documentation for any purpose is hereby granted without fee,
-//  provided that the above copyright notice appear in all copies and
-//  that both that copyright notice and this permission notice appear
-//  in supporting documentation.  Hewlett-Packard Company makes no
-//  representations about the suitability of this software for any
-//  purpose.  It is provided "as is" without express or implied warranty.
-//
-//  Copyright (c) 1996
-//  Silicon Graphics Computer Systems, Inc.
-//
-//  Permission to use, copy, modify, distribute and sell this software
-//  and its documentation for any purpose is hereby granted without fee,
-//  provided that the above copyright notice appear in all copies and
-//  that both that copyright notice and this permission notice appear
-//  in supporting documentation.  Silicon Graphics makes no
-//  representations about the suitability of this software for any
-//  purpose.  It is provided "as is" without express or implied warranty.
-//
-
-#ifndef RANGES_V3_ALGORITHM_SORT_HPP
-#define RANGES_V3_ALGORITHM_SORT_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/heap_algorithm.hpp>
-#include <range/v3/algorithm/move_backward.hpp>
-#include <range/v3/algorithm/partial_sort.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        template<typename I, typename C, typename P>
-        inline I unguarded_partition(I first, I last, C & pred, P & proj)
-        {
-            I mid = first + (last - first) / 2, penultimate = ranges::prev(last);
-            auto &&x = *first, &&y = *mid, &&z = *penultimate;
-            auto &&a = invoke(proj, (decltype(x) &&)x),
-                 &&b = invoke(proj, (decltype(y) &&)y),
-                 &&c = invoke(proj, (decltype(z) &&)z);
-
-            // Find the median:
-            I pivot_pnt =
-                invoke(pred, a, b)
-                    ? (invoke(pred, b, c) ? mid
-                                          : (invoke(pred, a, c) ? penultimate : first))
-                    : (invoke(pred, a, c) ? first
-                                          : (invoke(pred, b, c) ? penultimate : mid));
-
-            // Do the partition:
-            while(true)
-            {
-                auto && v = *pivot_pnt;
-                auto && pivot = invoke(proj, (decltype(v) &&)v);
-                while(invoke(pred, invoke(proj, *first), pivot))
-                    ++first;
-                --last;
-                while(invoke(pred, pivot, invoke(proj, *last)))
-                    --last;
-                if(!(first < last))
-                    return first;
-                ranges::iter_swap(first, last);
-                pivot_pnt =
-                    pivot_pnt == first ? last : (pivot_pnt == last ? first : pivot_pnt);
-                ++first;
-            }
-        }
-
-        template<typename I, typename C, typename P>
-        inline void unguarded_linear_insert(I last, iter_value_t<I> val, C & pred,
-                                            P & proj)
-        {
-            I next = prev(last);
-            while(invoke(pred, invoke(proj, val), invoke(proj, *next)))
-            {
-                *last = iter_move(next);
-                last = next;
-                --next;
-            }
-            *last = std::move(val);
-        }
-
-        template<typename I, typename C, typename P>
-        inline void linear_insert(I first, I last, C & pred, P & proj)
-        {
-            iter_value_t<I> val = iter_move(last);
-            if(invoke(pred, invoke(proj, val), invoke(proj, *first)))
-            {
-                move_backward(first, last, last + 1);
-                *first = std::move(val);
-            }
-            else
-                detail::unguarded_linear_insert(last, std::move(val), pred, proj);
-        }
-
-        template<typename I, typename C, typename P>
-        inline void insertion_sort(I first, I last, C & pred, P & proj)
-        {
-            if(first == last)
-                return;
-            for(I i = next(first); i != last; ++i)
-                detail::linear_insert(first, i, pred, proj);
-        }
-
-        template<typename I, typename C, typename P>
-        inline void unguarded_insertion_sort(I first, I last, C & pred, P & proj)
-        {
-            for(I i = first; i != last; ++i)
-                detail::unguarded_linear_insert(i, iter_move(i), pred, proj);
-        }
-
-        constexpr int introsort_threshold()
-        {
-            return 16;
-        }
-
-        template<typename I, typename C, typename P>
-        inline void final_insertion_sort(I first, I last, C & pred, P & proj)
-        {
-            if(last - first > detail::introsort_threshold())
-            {
-                detail::insertion_sort(
-                    first, first + detail::introsort_threshold(), pred, proj);
-                detail::unguarded_insertion_sort(
-                    first + detail::introsort_threshold(), last, pred, proj);
-            }
-            else
-                detail::insertion_sort(first, last, pred, proj);
-        }
-
-        template<typename Size>
-        inline Size log2(Size n)
-        {
-            Size k = 0;
-            for(; n != 1; n >>= 1)
-                ++k;
-            return k;
-        }
-
-        template<typename I, typename Size, typename C, typename P>
-        inline void introsort_loop(I first, I last, Size depth_limit, C & pred, P & proj)
-        {
-            while(last - first > detail::introsort_threshold())
-            {
-                if(depth_limit == 0)
-                    return partial_sort(
-                               first, last, last, std::ref(pred), std::ref(proj)),
-                           void();
-                I cut = detail::unguarded_partition(first, last, pred, proj);
-                detail::introsort_loop(cut, last, --depth_limit, pred, proj);
-                last = cut;
-            }
-        }
-    } // namespace detail
-    /// \endcond
-
-    /// \addtogroup group-algorithms
-    /// @{
-
-    // Introsort: Quicksort to a certain depth, then Heapsort. Insertion
-    // sort below a certain threshold.
-    // TODO Forward iterators, like EoP?
-
-    RANGES_FUNC_BEGIN(sort)
-
-        /// \brief function template \c sort
-        template(typename I, typename S, typename C = less, typename P = identity)(
-            /// \pre
-            requires sortable<I, C, P> AND random_access_iterator<I> AND
-                sentinel_for<S, I>)
-        I RANGES_FUNC(sort)(I first, S end_, C pred = C{}, P proj = P{})
-        {
-            I last = ranges::next(first, std::move(end_));
-            if(first != last)
-            {
-                detail::introsort_loop(
-                    first, last, detail::log2(last - first) * 2, pred, proj);
-                detail::final_insertion_sort(first, last, pred, proj);
-            }
-            return last;
-        }
-
-        /// \overload
-        template(typename Rng, typename C = less, typename P = identity)(
-            /// \pre
-            requires sortable<iterator_t<Rng>, C, P> AND random_access_range<Rng>)
-        borrowed_iterator_t<Rng> //
-        RANGES_FUNC(sort)(Rng && rng, C pred = C{}, P proj = P{}) //
-        {
-            return (*this)(begin(rng), end(rng), std::move(pred), std::move(proj));
-        }
-
-    RANGES_FUNC_END(sort)
-
-    namespace cpp20
-    {
-        using ranges::sort;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/stable_partition.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/stable_partition.hpp
deleted file mode 100644
index d816caca..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/stable_partition.hpp
+++ /dev/null
@@ -1,333 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//===-------------------------- algorithm ---------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-#ifndef RANGES_V3_ALGORITHM_STABLE_PARTITION_HPP
-#define RANGES_V3_ALGORITHM_STABLE_PARTITION_HPP
-
-#include <functional>
-#include <memory>
-#include <type_traits>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/move.hpp>
-#include <range/v3/algorithm/partition_copy.hpp>
-#include <range/v3/algorithm/rotate.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/move_iterators.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/memory.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/utility/swap.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-
-    /// \cond
-    namespace detail
-    {
-        template<typename I, typename C, typename P, typename D, typename Pair>
-        I stable_partition_impl(I first, I last, C pred, P proj, D len, Pair const p,
-                                std::forward_iterator_tag fi)
-        {
-            // *first is known to be false
-            // len >= 1
-            if(len == 1)
-                return first;
-            if(len == 2)
-            {
-                I tmp = first;
-                if(invoke(pred, invoke(proj, *++tmp)))
-                {
-                    ranges::iter_swap(first, tmp);
-                    return tmp;
-                }
-                return first;
-            }
-            if(len <= p.second)
-            { // The buffer is big enough to use
-                // Move the falses into the temporary buffer, and the trues to the front
-                // of the line Update first to always point to the last of the trues
-                auto tmpbuf = make_raw_buffer(p.first);
-                auto buf = tmpbuf.begin();
-                *buf = iter_move(first);
-                ++buf;
-                auto res = partition_copy(make_move_iterator(next(first)),
-                                          make_move_sentinel(last),
-                                          first,
-                                          buf,
-                                          std::ref(pred),
-                                          std::ref(proj));
-                // All trues now at start of range, all falses in buffer
-                // Move falses back into range, but don't mess up first which points to
-                // first false
-                ranges::move(p.first, res.out2.base().base(), res.out1);
-                // h destructs moved-from values out of the temp buffer, but doesn't
-                // deallocate buffer
-                return res.out1;
-            }
-            // Else not enough buffer, do in place
-            // len >= 3
-            D half = len / 2; // half >= 2
-            I middle = next(first, half);
-            // recurse on [first, middle), *first know to be false
-            // F?????????????????
-            // f       m         l
-            I begin_false =
-                detail::stable_partition_impl(first, middle, pred, proj, half, p, fi);
-            // TTTFFFFF??????????
-            // f  ff   m         l
-            // recurse on [middle, last], except increase middle until *(middle) is false,
-            // *last know to be true
-            I m1 = middle;
-            D len_half = len - half;
-            while(invoke(pred, invoke(proj, *m1)))
-            {
-                if(++m1 == last)
-                    return ranges::rotate(begin_false, middle, last).begin();
-                --len_half;
-            }
-            // TTTFFFFFTTTF??????
-            // f  ff   m  m1     l
-            I end_false =
-                detail::stable_partition_impl(m1, last, pred, proj, len_half, p, fi);
-            // TTTFFFFFTTTTTFFFFF
-            // f  ff   m    sf   l
-            return ranges::rotate(begin_false, middle, end_false).begin();
-            // TTTTTTTTFFFFFFFFFF
-            //         |
-        }
-
-        template<typename I, typename S, typename C, typename P>
-        I stable_partition_impl(I first, S last, C pred, P proj,
-                                std::forward_iterator_tag fi)
-        {
-            using difference_type = iter_difference_t<I>;
-            difference_type const alloc_limit = 3; // might want to make this a function
-                                                   // of trivial assignment.
-            // Either prove all true and return first or point to first false
-            while(true)
-            {
-                if(first == last)
-                    return first;
-                if(!invoke(pred, invoke(proj, *first)))
-                    break;
-                ++first;
-            }
-            // We now have a reduced range [first, last)
-            // *first is known to be false
-            using value_type = iter_value_t<I>;
-            auto len_end = enumerate(first, last);
-            auto p = len_end.first >= alloc_limit
-                         ? detail::get_temporary_buffer<value_type>(len_end.first)
-                         : detail::value_init{};
-            std::unique_ptr<value_type, detail::return_temporary_buffer> const h{p.first};
-            return detail::stable_partition_impl(
-                first, len_end.second, pred, proj, len_end.first, p, fi);
-        }
-
-        template<typename I, typename C, typename P, typename D, typename Pair>
-        I stable_partition_impl(I first, I last, C pred, P proj, D len, Pair p,
-                                std::bidirectional_iterator_tag bi)
-        {
-            // *first is known to be false
-            // *last is known to be true
-            // len >= 2
-            if(len == 2)
-            {
-                ranges::iter_swap(first, last);
-                return last;
-            }
-            if(len == 3)
-            {
-                I tmp = first;
-                if(invoke(pred, invoke(proj, *++tmp)))
-                {
-                    ranges::iter_swap(first, tmp);
-                    ranges::iter_swap(tmp, last);
-                    return last;
-                }
-                ranges::iter_swap(tmp, last);
-                ranges::iter_swap(first, tmp);
-                return tmp;
-            }
-            if(len <= p.second)
-            { // The buffer is big enough to use
-                // Move the falses into the temporary buffer, and the trues to the front
-                // of the line Update first to always point to the last of the trues
-                auto tmpbuf = ranges::make_raw_buffer(p.first);
-                auto buf = tmpbuf.begin();
-                *buf = iter_move(first);
-                ++buf;
-                auto res = partition_copy(make_move_iterator(next(first)),
-                                          make_move_sentinel(last),
-                                          first,
-                                          buf,
-                                          std::ref(pred),
-                                          std::ref(proj));
-                first = res.out1;
-                // move *last, known to be true
-                *first = iter_move(res.in);
-                ++first;
-                // All trues now at start of range, all falses in buffer
-                // Move falses back into range, but don't mess up first which points to
-                // first false
-                ranges::move(p.first, res.out2.base().base(), first);
-                // h destructs moved-from values out of the temp buffer, but doesn't
-                // deallocate buffer
-                return first;
-            }
-            // Else not enough buffer, do in place
-            // len >= 4
-            I middle = first;
-            D half = len / 2; // half >= 2
-            advance(middle, half);
-            // recurse on [first, middle-1], except reduce middle-1 until *(middle-1) is
-            // true, *first know to be false F????????????????T f       m        l
-            I m1 = middle;
-            I begin_false = first;
-            D len_half = half;
-            while(!invoke(pred, invoke(proj, *--m1)))
-            {
-                if(m1 == first)
-                    goto first_half_done;
-                --len_half;
-            }
-            // F???TFFF?????????T
-            // f   m1  m        l
-            begin_false =
-                detail::stable_partition_impl(first, m1, pred, proj, len_half, p, bi);
-        first_half_done:
-            // TTTFFFFF?????????T
-            // f  ff   m        l
-            // recurse on [middle, last], except increase middle until *(middle) is false,
-            // *last know to be true
-            m1 = middle;
-            len_half = len - half;
-            while(invoke(pred, invoke(proj, *m1)))
-            {
-                if(++m1 == last)
-                    return ranges::rotate(begin_false, middle, ++last).begin();
-                --len_half;
-            }
-            // TTTFFFFFTTTF?????T
-            // f  ff   m  m1    l
-            I end_false =
-                detail::stable_partition_impl(m1, last, pred, proj, len_half, p, bi);
-            // TTTFFFFFTTTTTFFFFF
-            // f  ff   m    sf  l
-            return ranges::rotate(begin_false, middle, end_false).begin();
-            // TTTTTTTTFFFFFFFFFF
-            //         |
-        }
-
-        template<typename I, typename S, typename C, typename P>
-        I stable_partition_impl(I first, S end_, C pred, P proj,
-                                std::bidirectional_iterator_tag bi)
-        {
-            using difference_type = iter_difference_t<I>;
-            using value_type = iter_value_t<I>;
-            difference_type const alloc_limit =
-                4; // might want to make this a function of trivial assignment
-            // Either prove all true and return first or point to first false
-            while(true)
-            {
-                if(first == end_)
-                    return first;
-                if(!invoke(pred, invoke(proj, *first)))
-                    break;
-                ++first;
-            }
-            // first points to first false, everything prior to first is already set.
-            // Either prove [first, last) is all false and return first, or point last to
-            // last true
-            I last = ranges::next(first, end_);
-            do
-            {
-                if(first == --last)
-                    return first;
-            } while(!invoke(pred, invoke(proj, *last)));
-            // We now have a reduced range [first, last]
-            // *first is known to be false
-            // *last is known to be true
-            // len >= 2
-            auto len = distance(first, last) + 1;
-            auto p = len >= alloc_limit ? detail::get_temporary_buffer<value_type>(len)
-                                        : detail::value_init{};
-            std::unique_ptr<value_type, detail::return_temporary_buffer> const h{p.first};
-            return detail::stable_partition_impl(first, last, pred, proj, len, p, bi);
-        }
-    } // namespace detail
-    /// \endcond
-
-    RANGES_FUNC_BEGIN(stable_partition)
-
-        /// \brief function template \c stable_partition
-        template(typename I, typename S, typename C, typename P = identity)(
-            /// \pre
-            requires bidirectional_iterator<I> AND sentinel_for<S, I> AND
-            indirect_unary_predicate<C, projected<I, P>> AND permutable<I>)
-        I RANGES_FUNC(stable_partition)(I first, S last, C pred, P proj = P{})
-        {
-            return detail::stable_partition_impl(std::move(first),
-                                                 std::move(last),
-                                                 std::ref(pred),
-                                                 std::ref(proj),
-                                                 iterator_tag_of<I>());
-        }
-
-        // BUGBUG Can this be optimized if Rng has O1 size?
-        /// \overload
-        template(typename Rng, typename C, typename P = identity)(
-            /// \pre
-            requires bidirectional_range<Rng> AND
-            indirect_unary_predicate<C, projected<iterator_t<Rng>, P>> AND
-            permutable<iterator_t<Rng>>)
-        borrowed_iterator_t<Rng> //
-        RANGES_FUNC(stable_partition)(Rng && rng, C pred, P proj = P{}) //
-        {
-            return (*this)(begin(rng), end(rng), std::move(pred), std::move(proj));
-        }
-
-    RANGES_FUNC_END(stable_partition)
-
-    namespace cpp20
-    {
-        using ranges::stable_partition;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/stable_sort.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/stable_sort.hpp
deleted file mode 100644
index 6de064ea..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/stable_sort.hpp
+++ /dev/null
@@ -1,238 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright (c) 1994
-//  Hewlett-Packard Company
-//
-//  Permission to use, copy, modify, distribute and sell this software
-//  and its documentation for any purpose is hereby granted without fee,
-//  provided that the above copyright notice appear in all copies and
-//  that both that copyright notice and this permission notice appear
-//  in supporting documentation.  Hewlett-Packard Company makes no
-//  representations about the suitability of this software for any
-//  purpose.  It is provided "as is" without express or implied warranty.
-//
-//  Copyright (c) 1996
-//  Silicon Graphics Computer Systems, Inc.
-//
-//  Permission to use, copy, modify, distribute and sell this software
-//  and its documentation for any purpose is hereby granted without fee,
-//  provided that the above copyright notice appear in all copies and
-//  that both that copyright notice and this permission notice appear
-//  in supporting documentation.  Silicon Graphics makes no
-//  representations about the suitability of this software for any
-//  purpose.  It is provided "as is" without express or implied warranty.
-//
-
-#ifndef RANGES_V3_ALGORITHM_STABLE_SORT_HPP
-#define RANGES_V3_ALGORITHM_STABLE_SORT_HPP
-
-#include <functional>
-#include <iterator>
-#include <memory>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/inplace_merge.hpp>
-#include <range/v3/algorithm/merge.hpp>
-#include <range/v3/algorithm/min.hpp>
-#include <range/v3/algorithm/sort.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/move_iterators.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/memory.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-
-    /// \cond
-    namespace detail
-    {
-        template<typename I, typename C, typename P>
-        void inplace_stable_sort(I first, I last, C & pred, P & proj)
-        {
-            if(last - first < 15)
-                return detail::insertion_sort(first, last, pred, proj), void();
-            I middle = first + (last - first) / 2;
-            detail::inplace_stable_sort(first, middle, pred, proj);
-            detail::inplace_stable_sort(middle, last, pred, proj);
-            detail::inplace_merge_no_buffer(first,
-                                            middle,
-                                            last,
-                                            middle - first,
-                                            last - middle,
-                                            std::ref(pred),
-                                            std::ref(proj));
-        }
-
-        template<typename I1, typename I2, typename D, typename C, typename P>
-        void merge_sort_loop(I1 first, I1 last, I2 result, D step_size, C & pred,
-                             P & proj)
-        {
-            D two_step = 2 * step_size;
-            while(last - first >= two_step)
-            {
-                result = merge(make_move_iterator(first),
-                               make_move_iterator(first + step_size),
-                               make_move_iterator(first + step_size),
-                               make_move_iterator(first + two_step),
-                               result,
-                               std::ref(pred),
-                               std::ref(proj),
-                               std::ref(proj))
-                             .out;
-                first += two_step;
-            }
-            step_size = ranges::min(D(last - first), step_size);
-            merge(make_move_iterator(first),
-                  make_move_iterator(first + step_size),
-                  make_move_iterator(first + step_size),
-                  make_move_iterator(last),
-                  result,
-                  std::ref(pred),
-                  std::ref(proj),
-                  std::ref(proj));
-        }
-
-        constexpr int merge_sort_chunk_size()
-        {
-            return 7;
-        }
-
-        template<typename I, typename D, typename C, typename P>
-        void chunk_insertion_sort(I first, I last, D chunk_size, C & pred, P & proj)
-        {
-            while(last - first >= chunk_size)
-            {
-                detail::insertion_sort(first, first + chunk_size, pred, proj);
-                first += chunk_size;
-            }
-            detail::insertion_sort(first, last, pred, proj);
-        }
-
-        // buffer points to raw memory, we create objects, and then restore the buffer to
-        // raw memory by destroying the objects on return.
-        template<typename I, typename V, typename C, typename P>
-        void merge_sort_with_buffer(I first, I last, V * buffer, C & pred, P & proj)
-        {
-            iter_difference_t<I> len = last - first,
-                                 step_size = detail::merge_sort_chunk_size();
-            detail::chunk_insertion_sort(first, last, step_size, pred, proj);
-            if(step_size >= len)
-                return;
-            // The first call to merge_sort_loop moves into raw storage. Construct
-            // on-demand and keep track of how many objects we need to destroy.
-            V * buffer_end = buffer + static_cast<std::ptrdiff_t>(len);
-            auto tmpbuf = make_raw_buffer(buffer);
-            detail::merge_sort_loop(first, last, tmpbuf.begin(), step_size, pred, proj);
-            step_size *= 2;
-        loop:
-            detail::merge_sort_loop(
-                buffer, buffer_end, first, (std::ptrdiff_t)step_size, pred, proj);
-            step_size *= 2;
-            if(step_size >= len)
-                return;
-            detail::merge_sort_loop(first, last, buffer, step_size, pred, proj);
-            step_size *= 2;
-            goto loop;
-        }
-
-        // buffer points to raw memory
-        template<typename I, typename V, typename C, typename P>
-        void stable_sort_adaptive(I first, I last, V * buffer, std::ptrdiff_t buffer_size,
-                                  C & pred, P & proj)
-        {
-            iter_difference_t<I> len = (last - first + 1) / 2;
-            I middle = first + len;
-            if(len > buffer_size)
-            {
-                detail::stable_sort_adaptive(
-                    first, middle, buffer, buffer_size, pred, proj);
-                detail::stable_sort_adaptive(
-                    middle, last, buffer, buffer_size, pred, proj);
-            }
-            else
-            {
-                detail::merge_sort_with_buffer(first, middle, buffer, pred, proj);
-                detail::merge_sort_with_buffer(middle, last, buffer, pred, proj);
-            }
-            detail::merge_adaptive(first,
-                                   middle,
-                                   last,
-                                   middle - first,
-                                   last - middle,
-                                   buffer,
-                                   buffer_size,
-                                   std::ref(pred),
-                                   std::ref(proj));
-        }
-    } // namespace detail
-    /// \endcond
-
-    RANGES_FUNC_BEGIN(stable_sort)
-
-        /// \brief function template \c stable_sort
-        template(typename I, typename S, typename C = less, typename P = identity)(
-            /// \pre
-            requires sortable<I, C, P> AND random_access_iterator<I> AND
-            sentinel_for<S, I>)
-        I RANGES_FUNC(stable_sort)(I first, S end_, C pred = C{}, P proj = P{})
-        {
-            I last = ranges::next(first, end_);
-            using D = iter_difference_t<I>;
-            using V = iter_value_t<I>;
-            D len = last - first;
-            auto buf =
-                len > 256 ? detail::get_temporary_buffer<V>(len) : detail::value_init{};
-            std::unique_ptr<V, detail::return_temporary_buffer> h{buf.first};
-            if(buf.first == nullptr)
-                detail::inplace_stable_sort(first, last, pred, proj);
-            else
-                detail::stable_sort_adaptive(
-                    first, last, buf.first, buf.second, pred, proj);
-            return last;
-        }
-
-        /// \overload
-        template(typename Rng, typename C = less, typename P = identity)(
-            /// \pre
-            requires sortable<iterator_t<Rng>, C, P> AND random_access_range<Rng>)
-        borrowed_iterator_t<Rng> //
-        RANGES_FUNC(stable_sort)(Rng && rng, C pred = C{}, P proj = P{}) //
-        {
-            return (*this)(begin(rng), end(rng), std::move(pred), std::move(proj));
-        }
-
-    RANGES_FUNC_END(stable_sort)
-
-    namespace cpp20
-    {
-        using ranges::stable_sort;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/starts_with.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/starts_with.hpp
deleted file mode 100644
index 2fa6af64..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/starts_with.hpp
+++ /dev/null
@@ -1,102 +0,0 @@
-// Range v3 library
-//
-//  Copyright 2019 Christopher Di Bella
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-#ifndef RANGES_V3_ALGORITHM_STARTS_WITH_HPP
-#define RANGES_V3_ALGORITHM_STARTS_WITH_HPP
-
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/equal.hpp>
-#include <range/v3/algorithm/mismatch.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-
-    // template<typename I1, typename I2>
-    // struct starts_with_result : detail::in1_in2_result<I1, I2>
-    // {
-    //     bool result;
-    // };
-
-    RANGES_FUNC_BEGIN(starts_with)
-
-        /// \brief function template \c starts_with
-        template(typename I1,
-                 typename S1,
-                 typename I2,
-                 typename S2,
-                 typename Comp = equal_to,
-                 typename Proj1 = identity,
-                 typename Proj2 = identity)(
-            /// \pre
-            requires input_iterator<I1> AND sentinel_for<S1, I1> AND
-                input_iterator<I2> AND sentinel_for<S2, I2> AND
-                indirectly_comparable<I1, I2, Comp, Proj1, Proj2>)
-        constexpr bool RANGES_FUNC(starts_with)(I1 first1,
-                                                S1 last1,
-                                                I2 first2,
-                                                S2 last2,
-                                                Comp comp = {},
-                                                Proj1 proj1 = {},
-                                                Proj2 proj2 = {}) //
-        {
-            return mismatch(std::move(first1),
-                            std::move(last1),
-                            std::move(first2),
-                            last2,
-                            std::move(comp),
-                            std::move(proj1),
-                            std::move(proj2))
-                       .in2 == last2;
-        }
-
-        /// \overload
-        template(typename R1,
-                 typename R2,
-                 typename Comp = equal_to,
-                 typename Proj1 = identity,
-                 typename Proj2 = identity)(
-            /// \pre
-            requires input_range<R1> AND input_range<R2> AND
-                indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Comp, Proj1, Proj2>)
-        constexpr bool RANGES_FUNC(starts_with)(
-            R1 && r1, R2 && r2, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) //
-        {
-            return (*this)( //
-                begin(r1),
-                end(r1),
-                begin(r2),
-                end(r2),
-                std::move(comp),
-                std::move(proj1),
-                std::move(proj2));
-        }
-
-    RANGES_FUNC_END(starts_with)
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif // RANGES_V3_ALGORITHM_STARTS_WITH_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/swap_ranges.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/swap_ranges.hpp
deleted file mode 100644
index 13c6b4c2..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/swap_ranges.hpp
+++ /dev/null
@@ -1,99 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_SWAP_RANGES_HPP
-#define RANGES_V3_ALGORITHM_SWAP_RANGES_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/result_types.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    template<typename I1, typename I2>
-    using swap_ranges_result = detail::in1_in2_result<I1, I2>;
-
-    RANGES_FUNC_BEGIN(swap_ranges)
-
-        /// \brief function template \c swap_ranges
-        template(typename I1, typename S1, typename I2)(
-            /// \pre
-            requires input_iterator<I1> AND sentinel_for<S1, I1> AND
-            input_iterator<I2> AND indirectly_swappable<I1, I2>)
-        swap_ranges_result<I1, I2> //
-        RANGES_FUNC(swap_ranges)(I1 begin1, S1 end1, I2 begin2) //
-        {
-            for(; begin1 != end1; ++begin1, ++begin2)
-                ranges::iter_swap(begin1, begin2);
-            return {begin1, begin2};
-        }
-
-        /// \overload
-        template(typename I1, typename S1, typename I2, typename S2)(
-            /// \pre
-            requires input_iterator<I1> AND sentinel_for<S1, I1> AND
-                input_iterator<I2> AND sentinel_for<S2, I2> AND
-                indirectly_swappable<I1, I2>)
-        swap_ranges_result<I1, I2> RANGES_FUNC(swap_ranges)(I1 begin1,
-                                                            S1 end1,
-                                                            I2 begin2,
-                                                            S2 end2) //
-        {
-            for(; begin1 != end1 && begin2 != end2; ++begin1, ++begin2)
-                ranges::iter_swap(begin1, begin2);
-            return {begin1, begin2};
-        }
-
-        template(typename Rng1, typename I2_)(
-            /// \pre
-            requires input_range<Rng1> AND input_iterator<uncvref_t<I2_>> AND
-            indirectly_swappable<iterator_t<Rng1>, uncvref_t<I2_>>)
-        swap_ranges_result<iterator_t<Rng1>, uncvref_t<I2_>> //
-        RANGES_FUNC(swap_ranges)(Rng1 && rng1, I2_ && begin2) //
-        {
-            return (*this)(begin(rng1), end(rng1), (I2_ &&) begin2);
-        }
-
-        template(typename Rng1, typename Rng2)(
-            /// \pre
-            requires input_range<Rng1> AND input_range<Rng2> AND
-                indirectly_swappable<iterator_t<Rng1>, iterator_t<Rng2>>)
-        swap_ranges_result<borrowed_iterator_t<Rng1>, borrowed_iterator_t<Rng2>> //
-        RANGES_FUNC(swap_ranges)(Rng1 && rng1, Rng2 && rng2) //
-        {
-            return (*this)(begin(rng1), end(rng1), begin(rng2), end(rng2));
-        }
-
-    RANGES_FUNC_END(swap_ranges)
-
-    namespace cpp20
-    {
-        using ranges::swap_ranges;
-        using ranges::swap_ranges_result;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/tagspec.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/tagspec.hpp
deleted file mode 100644
index 203671fa..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/tagspec.hpp
+++ /dev/null
@@ -1,52 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#ifndef RANGES_V3_ALGORITHM_TAGSPEC_HPP
-#define RANGES_V3_ALGORITHM_TAGSPEC_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/utility/tagged_pair.hpp>
-
-RANGES_DEPRECATED_HEADER(
-    "This file is deprecated. Please discontinue using the tag types defined here and "
-    "define your own.")
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    RANGES_DEFINE_TAG_SPECIFIER(in)
-    RANGES_DEFINE_TAG_SPECIFIER(in1)
-    RANGES_DEFINE_TAG_SPECIFIER(in2)
-    RANGES_DEFINE_TAG_SPECIFIER(out)
-    RANGES_DEFINE_TAG_SPECIFIER(out1)
-    RANGES_DEFINE_TAG_SPECIFIER(out2)
-    RANGES_DEFINE_TAG_SPECIFIER(fun)
-    RANGES_DEFINE_TAG_SPECIFIER(min)
-    RANGES_DEFINE_TAG_SPECIFIER(max)
-    RANGES_DEFINE_TAG_SPECIFIER(begin)
-    RANGES_DEFINE_TAG_SPECIFIER(end)
-
-    RANGES_DEFINE_TAG_SPECIFIER(current)
-    RANGES_DEFINE_TAG_SPECIFIER(engine)
-    RANGES_DEFINE_TAG_SPECIFIER(range)
-    RANGES_DEFINE_TAG_SPECIFIER(size)
-
-    RANGES_DEFINE_TAG_SPECIFIER(first)
-    RANGES_DEFINE_TAG_SPECIFIER(second)
-    /// \endcond
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/transform.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/transform.hpp
deleted file mode 100644
index 7e16fa75..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/transform.hpp
+++ /dev/null
@@ -1,226 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_TRANSFORM_HPP
-#define RANGES_V3_ALGORITHM_TRANSFORM_HPP
-
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/result_types.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/iterator/unreachable_sentinel.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    template<typename I, typename O>
-    using unary_transform_result = detail::in_out_result<I, O>;
-
-    template<typename I1, typename I2, typename O>
-    using binary_transform_result = detail::in1_in2_out_result<I1, I2, O>;
-
-    RANGES_FUNC_BEGIN(transform)
-
-        // Single-range variant
-        /// \brief function template \c transform
-        template(typename I, typename S, typename O, typename F, typename P = identity)(
-            /// \pre
-            requires input_iterator<I> AND sentinel_for<S, I> AND
-            weakly_incrementable<O> AND copy_constructible<F> AND
-            indirectly_writable<O, indirect_result_t<F &, projected<I, P>>>)
-        unary_transform_result<I, O> //
-        RANGES_FUNC(transform)(I first, S last, O out, F fun, P proj = P{}) //
-        {
-            for(; first != last; ++first, ++out)
-                *out = invoke(fun, invoke(proj, *first));
-            return {first, out};
-        }
-
-        /// \overload
-        template(typename Rng, typename O, typename F, typename P = identity)(
-            /// \pre
-            requires input_range<Rng> AND weakly_incrementable<O> AND
-            copy_constructible<F> AND
-            indirectly_writable<O, indirect_result_t<F &, projected<iterator_t<Rng>, P>>>)
-        unary_transform_result<borrowed_iterator_t<Rng>, O> //
-        RANGES_FUNC(transform)(Rng && rng, O out, F fun, P proj = P{}) //
-        {
-            return (*this)(
-                begin(rng), end(rng), std::move(out), std::move(fun), std::move(proj));
-        }
-
-        // Double-range variant, 4-iterator version
-        /// \overload
-        template(typename I0,
-                 typename S0,
-                 typename I1,
-                 typename S1,
-                 typename O,
-                 typename F,
-                 typename P0 = identity,
-                 typename P1 = identity)(
-            /// \pre
-            requires input_iterator<I0> AND sentinel_for<S0, I0> AND
-                input_iterator<I1> AND sentinel_for<S1, I1> AND
-                weakly_incrementable<O> AND copy_constructible<F> AND
-                indirectly_writable<
-                    O,
-                    indirect_result_t<F &, projected<I0, P0>, projected<I1, P1>>>)
-        binary_transform_result<I0, I1, O> //
-        RANGES_FUNC(transform)(I0 begin0,
-                               S0 end0,
-                               I1 begin1,
-                               S1 end1,
-                               O out,
-                               F fun,
-                               P0 proj0 = P0{},
-                               P1 proj1 = P1{}) //
-        {
-            for(; begin0 != end0 && begin1 != end1; ++begin0, ++begin1, ++out)
-                *out = invoke(fun, invoke(proj0, *begin0), invoke(proj1, *begin1));
-            return {begin0, begin1, out};
-        }
-
-        /// \overload
-        template(typename Rng0,
-                 typename Rng1,
-                 typename O,
-                 typename F,
-                 typename P0 = identity,
-                 typename P1 = identity)(
-            /// \pre
-            requires input_range<Rng0> AND input_range<Rng1> AND
-                weakly_incrementable<O> AND copy_constructible<F> AND
-                indirectly_writable<
-                    O,
-                    indirect_result_t<F &,
-                                      projected<iterator_t<Rng0>, P0>,
-                                      projected<iterator_t<Rng1>, P1>>>)
-        binary_transform_result<borrowed_iterator_t<Rng0>,
-                                borrowed_iterator_t<Rng1>,
-                                O> //
-        RANGES_FUNC(transform)(
-            Rng0 && rng0, Rng1 && rng1, O out, F fun, P0 proj0 = P0{}, P1 proj1 = P1{}) //
-        {
-            return (*this)(begin(rng0),
-                           end(rng0),
-                           begin(rng1),
-                           end(rng1),
-                           std::move(out),
-                           std::move(fun),
-                           std::move(proj0),
-                           std::move(proj1));
-        }
-
-        // Double-range variant, 3-iterator version
-        /// \overload
-        template(typename I0,
-                     typename S0,
-                     typename I1,
-                     typename O,
-                     typename F,
-                     typename P0 = identity,
-                     typename P1 = identity)(
-            /// \pre
-            requires input_iterator<I0> AND sentinel_for<S0, I0> AND
-                input_iterator<I1> AND weakly_incrementable<O> AND
-                copy_constructible<F> AND
-                indirectly_writable<
-                    O,
-                    indirect_result_t<F &, projected<I0, P0>, projected<I1, P1>>>)
-        RANGES_DEPRECATED(
-            "Use the variant of ranges::transform that takes an upper bound "
-            "for both input ranges")
-        binary_transform_result<I0, I1, O> //
-        RANGES_FUNC(transform)(I0 begin0,
-                               S0 end0,
-                               I1 begin1,
-                               O out,
-                               F fun,
-                               P0 proj0 = P0{},
-                               P1 proj1 = P1{})
-        {
-            return (*this)(std::move(begin0),
-                           std::move(end0),
-                           std::move(begin1),
-                           unreachable,
-                           std::move(out),
-                           std::move(fun),
-                           std::move(proj0),
-                           std::move(proj1));
-        }
-
-        /// \overload
-        template(typename Rng0,
-                 typename I1Ref,
-                 typename O,
-                 typename F,
-                 typename P0 = identity,
-                 typename P1 = identity)(
-            /// \pre
-            requires input_range<Rng0> AND input_iterator<uncvref_t<I1Ref>> AND
-                weakly_incrementable<O> AND copy_constructible<F> AND
-                indirectly_writable<
-                    O,
-                    indirect_result_t<F &,
-                                      projected<iterator_t<Rng0>, P0>,
-                                      projected<uncvref_t<I1Ref>, P1>>>)
-        RANGES_DEPRECATED(
-            "Use the variant of ranges::transform that takes an upper bound "
-            "for both input ranges")
-        binary_transform_result<borrowed_iterator_t<Rng0>, uncvref_t<I1Ref>, O> //
-        RANGES_FUNC(transform)(Rng0 && rng0,
-                               I1Ref && begin1,
-                               O out,
-                               F fun,
-                               P0 proj0 = P0{},
-                               P1 proj1 = P1{}) //
-        {
-            return (*this)(begin(rng0),
-                           end(rng0),
-                           static_cast<I1Ref &&>(begin1),
-                           unreachable,
-                           std::move(out),
-                           std::move(fun),
-                           std::move(proj0),
-                           std::move(proj1));
-        }
-
-    RANGES_FUNC_END(transform)
-
-    namespace cpp20
-    {
-        using ranges::binary_transform_result;
-        using ranges::transform;
-        using ranges::unary_transform_result;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/unique.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/unique.hpp
deleted file mode 100644
index aa7e032d..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/unique.hpp
+++ /dev/null
@@ -1,88 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//  Copyright Gonzalo Brito Gadeschi 2014
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-// Implementation based on the code in libc++
-//   http://http://libcxx.llvm.org/
-
-#ifndef RANGES_V3_ALGORITHM_UNIQUE_HPP
-#define RANGES_V3_ALGORITHM_UNIQUE_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/adjacent_find.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(unique)
-
-        /// \brief template function \c unique
-        ///
-        /// range-based version of the \c unique std algorithm
-        ///
-        /// \pre `Rng` is a model of the `forward_range` concept
-        /// \pre `I` is a model of the `forward_iterator` concept
-        /// \pre `S` is a model of the `sentinel_for` concept
-        /// \pre `C` is a model of the `relation` concept
-        ///
-        template(typename I, typename S, typename C = equal_to, typename P = identity)(
-            /// \pre
-            requires sortable<I, C, P> AND sentinel_for<S, I>)
-        I RANGES_FUNC(unique)(I first, S last, C pred = C{}, P proj = P{})
-        {
-            first = adjacent_find(std::move(first), last, std::ref(pred), std::ref(proj));
-
-            if(first != last)
-            {
-                for(I i = next(first); ++i != last;)
-                    if(!invoke(pred, invoke(proj, *first), invoke(proj, *i)))
-                        *++first = iter_move(i);
-                ++first;
-            }
-            return first;
-        }
-
-        /// \overload
-        template(typename Rng, typename C = equal_to, typename P = identity)(
-            /// \pre
-            requires sortable<iterator_t<Rng>, C, P> AND range<Rng>)
-        borrowed_iterator_t<Rng> //
-        RANGES_FUNC(unique)(Rng && rng, C pred = C{}, P proj = P{}) //
-        {
-            return (*this)(begin(rng), end(rng), std::move(pred), std::move(proj));
-        }
-
-    RANGES_FUNC_END(unique)
-
-    namespace cpp20
-    {
-        using ranges::unique;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/unique_copy.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/unique_copy.hpp
deleted file mode 100644
index 361b90bc..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/unique_copy.hpp
+++ /dev/null
@@ -1,180 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_UNIQUE_COPY_HPP
-#define RANGES_V3_ALGORITHM_UNIQUE_COPY_HPP
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/result_types.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-
-    template<typename I, typename O>
-    using unique_copy_result = detail::in_out_result<I, O>;
-
-    /// \cond
-    namespace detail
-    {
-        template<typename I, typename S, typename O, typename C, typename P>
-        unique_copy_result<I, O> unique_copy_impl(I first, S last, O out, C pred, P proj,
-                                                  std::input_iterator_tag,
-                                                  std::false_type)
-        {
-            if(first != last)
-            {
-                // Must save a copy into a local because we will need this value
-                // even after we advance the input iterator.
-                iter_value_t<I> value =
-                    *first; // This is guaranteed by indirectly_copyable
-                *out = value;
-                ++out;
-                while(++first != last)
-                {
-                    auto && x = *first;
-                    if(!invoke(pred, invoke(proj, value), invoke(proj, x)))
-                    {
-                        value = (decltype(x) &&)x;
-                        *out = value;
-                        ++out;
-                    }
-                }
-            }
-            return {first, out};
-        }
-
-        template<typename I, typename S, typename O, typename C, typename P>
-        unique_copy_result<I, O> unique_copy_impl(I first, S last, O out, C pred, P proj,
-                                                  std::forward_iterator_tag,
-                                                  std::false_type)
-        {
-            if(first != last)
-            {
-                I tmp = first;
-                *out = *tmp;
-                ++out;
-                while(++first != last)
-                {
-                    auto && x = *first;
-                    if(!invoke(pred, invoke(proj, *tmp), invoke(proj, x)))
-                    {
-                        *out = (decltype(x) &&)x;
-                        ++out;
-                        tmp = first;
-                    }
-                }
-            }
-            return {first, out};
-        }
-
-        template<typename I, typename S, typename O, typename C, typename P>
-        unique_copy_result<I, O> unique_copy_impl(I first, S last, O out, C pred, P proj,
-                                                  std::input_iterator_tag, std::true_type)
-        {
-            if(first != last)
-            {
-                *out = *first;
-                while(++first != last)
-                {
-                    auto && x = *first;
-                    if(!invoke(pred, invoke(proj, *out), invoke(proj, x)))
-                        *++out = (decltype(x) &&)x;
-                }
-                ++out;
-            }
-            return {first, out};
-        }
-    } // namespace detail
-    /// \endcond
-
-    RANGES_FUNC_BEGIN(unique_copy)
-
-        /// \brief template function unique_copy
-        ///
-        /// range-based version of the `unique_copy` std algorithm
-        ///
-        /// \pre `Rng` is a model of the `input_range` concept
-        /// \pre `O` is a model of the `weakly_incrementable` concept
-        /// \pre `C` is a model of the `relation` concept
-        template(typename I,
-                 typename S,
-                 typename O,
-                 typename C = equal_to,
-                 typename P = identity)(
-            /// \pre
-            requires input_iterator<I> AND sentinel_for<S, I> AND
-                indirect_relation<C, projected<I, P>> AND weakly_incrementable<O> AND
-                indirectly_copyable<I, O> AND
-                (forward_iterator<I> || forward_iterator<O> ||
-                 indirectly_copyable_storable<I, O>)) //
-        unique_copy_result<I, O> RANGES_FUNC(unique_copy)(
-            I first, S last, O out, C pred = C{}, P proj = P{}) //
-        {
-            return detail::unique_copy_impl(std::move(first),
-                                            std::move(last),
-                                            std::move(out),
-                                            std::move(pred),
-                                            std::move(proj),
-                                            iterator_tag_of<I>(),
-                                            meta::bool_<forward_iterator<O>>{});
-        }
-
-        /// \overload
-        template(typename Rng, typename O, typename C = equal_to, typename P = identity)(
-            /// \pre
-            requires input_range<Rng> AND
-                indirect_relation<C, projected<iterator_t<Rng>, P>> AND
-                weakly_incrementable<O> AND indirectly_copyable<iterator_t<Rng>, O> AND
-                (forward_iterator<iterator_t<Rng>> || forward_iterator<O> ||
-                 indirectly_copyable_storable<iterator_t<Rng>, O>)) //
-        unique_copy_result<borrowed_iterator_t<Rng>, O> //
-        RANGES_FUNC(unique_copy)(Rng && rng, O out, C pred = C{}, P proj = P{}) //
-        {
-            return detail::unique_copy_impl(begin(rng),
-                                            end(rng),
-                                            std::move(out),
-                                            std::move(pred),
-                                            std::move(proj),
-                                            iterator_tag_of<iterator_t<Rng>>(),
-                                            meta::bool_<forward_iterator<O>>{});
-        }
-
-    RANGES_FUNC_END(unique_copy)
-
-    namespace cpp20
-    {
-        using ranges::unique_copy;
-        using ranges::unique_copy_result;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/unstable_remove_if.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/unstable_remove_if.hpp
deleted file mode 100644
index e07cdd48..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/unstable_remove_if.hpp
+++ /dev/null
@@ -1,88 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Andrey Diduh 2019
-//  Copyright Casey Carter 2019
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_UNSTABLE_REMOVE_IF_HPP
-#define RANGES_V3_ALGORITHM_UNSTABLE_REMOVE_IF_HPP
-
-#include <functional>
-#include <utility>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/find_if.hpp>
-#include <range/v3/algorithm/find_if_not.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/reverse_iterator.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/utility/move.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-
-    /// unstable_remove have O(1) complexity for each element remove, unlike remove O(n)
-    /// [for worst case]. Each erased element overwritten (moved in) with last one.
-    /// unstable_remove_if does not preserve relative element order.
-    RANGES_FUNC_BEGIN(unstable_remove_if)
-
-        /// \brief function template \c unstable_remove_if
-        template(typename I, typename C, typename P = identity)(
-            /// \pre
-            requires bidirectional_iterator<I> AND permutable<I> AND
-            indirect_unary_predicate<C, projected<I, P>>)
-        I RANGES_FUNC(unstable_remove_if)(I first, I last, C pred, P proj = {})
-        {
-            while(true)
-            {
-                first = find_if(std::move(first), last, std::ref(pred), std::ref(proj));
-                last = find_if_not(make_reverse_iterator(std::move(last)),
-                                   make_reverse_iterator(first),
-                                   std::ref(pred),
-                                   std::ref(proj))
-                           .base();
-                if(first == last)
-                    return first;
-                *first = iter_move(--last);
-
-                // discussion here: https://github.com/ericniebler/range-v3/issues/988
-                ++first;
-            }
-        }
-
-        /// \overload
-        template(typename Rng, typename C, typename P = identity)(
-            /// \pre
-            requires bidirectional_range<Rng> AND common_range<Rng> AND
-            permutable<iterator_t<Rng>> AND
-            indirect_unary_predicate<C, projected<iterator_t<Rng>, P>>)
-        borrowed_iterator_t<Rng> //
-        RANGES_FUNC(unstable_remove_if)(Rng && rng, C pred, P proj = P{}) //
-        {
-            return (*this)(begin(rng), end(rng), std::move(pred), std::move(proj));
-        }
-
-    RANGES_FUNC_END(unstable_remove_if)
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif // RANGES_V3_ALGORITHM_UNSTABLE_REMOVE_IF_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/upper_bound.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/upper_bound.hpp
deleted file mode 100644
index da644a3c..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/algorithm/upper_bound.hpp
+++ /dev/null
@@ -1,78 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ALGORITHM_UPPER_BOUND_HPP
-#define RANGES_V3_ALGORITHM_UPPER_BOUND_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/aux_/upper_bound_n.hpp>
-#include <range/v3/algorithm/partition_point.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-algorithms
-    /// @{
-    RANGES_FUNC_BEGIN(upper_bound)
-
-        /// \brief function template \c upper_bound
-        template(typename I,
-                 typename S,
-                 typename V,
-                 typename C = less,
-                 typename P = identity)(
-            /// \pre
-            requires forward_iterator<I> AND sentinel_for<S, I> AND
-                indirect_strict_weak_order<C, V const *, projected<I, P>>)
-        I RANGES_FUNC(upper_bound)(
-            I first, S last, V const & val, C pred = C{}, P proj = P{}) //
-        {
-            return partition_point(std::move(first),
-                                   std::move(last),
-                                   detail::make_upper_bound_predicate(pred, val),
-                                   std::move(proj));
-        }
-
-        /// \overload
-        template(typename Rng, typename V, typename C = less, typename P = identity)(
-            /// \pre
-            requires forward_range<Rng> AND
-                indirect_strict_weak_order<C, V const *, projected<iterator_t<Rng>, P>>)
-        borrowed_iterator_t<Rng> RANGES_FUNC(upper_bound)(
-            Rng && rng, V const & val, C pred = C{}, P proj = P{}) //
-        {
-            return partition_point(
-                rng, detail::make_upper_bound_predicate(pred, val), std::move(proj));
-        }
-
-    RANGES_FUNC_END(upper_bound)
-
-    namespace cpp20
-    {
-        using ranges::upper_bound;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/all.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/all.hpp
deleted file mode 100644
index 71ed69b5..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/all.hpp
+++ /dev/null
@@ -1,27 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013,2014.
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ALL_HPP
-#define RANGES_V3_ALL_HPP
-
-#include <range/v3/action.hpp>
-#include <range/v3/algorithm.hpp>
-#include <range/v3/core.hpp>
-#include <range/v3/functional.hpp>
-#include <range/v3/iterator.hpp>
-#include <range/v3/numeric.hpp>
-#include <range/v3/range.hpp>
-#include <range/v3/utility.hpp>
-#include <range/v3/view.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/at.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/at.hpp
deleted file mode 100644
index 8979ce0c..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/at.hpp
+++ /dev/null
@@ -1,23 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Gonzalo Brito Gadeschi 2017
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_AT_HPP
-#define RANGES_V3_AT_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated. Please #include <range/v3/range/operations.hpp> instead.")
-
-#include <range/v3/range/operations.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/back.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/back.hpp
deleted file mode 100644
index 74300e03..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/back.hpp
+++ /dev/null
@@ -1,22 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_BACK_HPP
-#define RANGES_V3_BACK_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated. Please #include <range/v3/range/operations.hpp> instead.")
-
-#include <range/v3/range/operations.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/begin_end.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/begin_end.hpp
deleted file mode 100644
index f872a8f7..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/begin_end.hpp
+++ /dev/null
@@ -1,22 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_BEGIN_END_HPP
-#define RANGES_V3_BEGIN_END_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated. Please #include <range/v3/range/access.hpp> instead.")
-
-#include <range/v3/range/access.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/compare.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/compare.hpp
deleted file mode 100644
index cbf5dc87..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/compare.hpp
+++ /dev/null
@@ -1,45 +0,0 @@
-/// \file
-//  CPP, the Concepts PreProcessor library
-//
-//  Copyright Eric Niebler 2018-present
-//  Copyright (c) 2020-present, Google LLC.
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// This source code is licensed under the MIT license found in the
-// LICENSE file in the root directory of this source tree.
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_COMPARE_HPP
-#define RANGES_V3_COMPARE_HPP
-
-#if __cplusplus > 201703L && defined(__cpp_impl_three_way_comparison) && __has_include(<compare>)
-
-#include <compare>
-#include <type_traits>
-
-namespace ranges
-{
-   template<typename... Ts>
-   struct common_comparison_category
-   {
-       using type = void;
-   };
-
-    template<typename... Ts>
-    requires ((std::is_same_v<Ts, std::partial_ordering> ||
-               std::is_same_v<Ts, std::weak_ordering> ||
-               std::is_same_v<Ts, std::strong_ordering>) && ...)
-    struct common_comparison_category<Ts...> : std::common_type<Ts...>
-    {};
-
-    template<typename... Ts>
-    using common_comparison_category_t = typename common_comparison_category<Ts...>::type;
-} // namespace ranges
-
-#endif // __cplusplus
-#endif // RANGES_V3_COMPARE_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/core.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/core.hpp
deleted file mode 100644
index 0485bbbb..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/core.hpp
+++ /dev/null
@@ -1,33 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_CORE_HPP
-#define RANGES_V3_CORE_HPP
-
-#include <range/v3/iterator/common_iterator.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/conversion.hpp>
-#include <range/v3/range/operations.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/range_for.hpp>
-#include <range/v3/view/adaptor.hpp>
-#include <range/v3/view/facade.hpp>
-#include <range/v3/view/getlines.hpp>
-#include <range/v3/view/interface.hpp>
-#include <range/v3/view/istream.hpp>
-#include <range/v3/view/subrange.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/data.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/data.hpp
deleted file mode 100644
index b62a29a4..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/data.hpp
+++ /dev/null
@@ -1,22 +0,0 @@
-// Range v3 library
-//
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_DATA_HPP
-#define RANGES_V3_DATA_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated. Please #include <range/v3/range/primitives.hpp> instead.")
-
-#include <range/v3/range/primitives.hpp>
-
-#endif // RANGES_V3_DATA_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/detail/adl_get.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/detail/adl_get.hpp
deleted file mode 100644
index c1d99530..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/detail/adl_get.hpp
+++ /dev/null
@@ -1,146 +0,0 @@
-// Range v3 library
-//
-//  Copyright Casey Carter 2018
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#ifndef RANGES_V3_DETAIL_ADL_GET_HPP
-#define RANGES_V3_DETAIL_ADL_GET_HPP
-
-#include <cstddef>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        namespace _adl_get_
-        {
-            template<typename>
-            void get();
-
-            template<std::size_t I, typename TupleLike>
-            constexpr auto adl_get(TupleLike && t) noexcept
-                -> decltype(get<I>(static_cast<TupleLike &&>(t)))
-            {
-                return get<I>(static_cast<TupleLike &&>(t));
-            }
-            template<typename T, typename TupleLike>
-            constexpr auto adl_get(TupleLike && t) noexcept
-                -> decltype(get<T>(static_cast<TupleLike &&>(t)))
-            {
-                return get<T>(static_cast<TupleLike &&>(t));
-            }
-        } // namespace _adl_get_
-        using _adl_get_::adl_get;
-    } // namespace detail
-
-    namespace _tuple_wrapper_
-    {
-        template<typename TupleLike>
-        struct forward_tuple_interface : TupleLike
-        {
-            forward_tuple_interface() = default;
-            using TupleLike::TupleLike;
-#if !defined(__clang__) || __clang_major__ > 3
-            CPP_member
-            constexpr CPP_ctor(forward_tuple_interface)(TupleLike && base)(    //
-                noexcept(std::is_nothrow_move_constructible<TupleLike>::value) //
-                requires move_constructible<TupleLike>)
-              : TupleLike(static_cast<TupleLike &&>(base))
-            {}
-            CPP_member
-            constexpr CPP_ctor(forward_tuple_interface)(TupleLike const & base)( //
-                noexcept(std::is_nothrow_copy_constructible<TupleLike>::value)   //
-                requires copy_constructible<TupleLike>)
-              : TupleLike(base)
-            {}
-#else
-            // Clang 3.x have a problem with inheriting constructors
-            // that causes the declarations in the preceeding PP block to get
-            // instantiated too early.
-            template(typename B = TupleLike)(
-                /// \pre
-                requires move_constructible<B>)
-                constexpr forward_tuple_interface(TupleLike && base) noexcept(
-                    std::is_nothrow_move_constructible<TupleLike>::value)
-              : TupleLike(static_cast<TupleLike &&>(base))
-            {}
-            template(typename B = TupleLike)(
-                /// \pre
-                requires copy_constructible<B>)
-                constexpr forward_tuple_interface(TupleLike const & base) noexcept(
-                    std::is_nothrow_copy_constructible<TupleLike>::value)
-              : TupleLike(base)
-            {}
-#endif
-
-            // clang-format off
-            template<std::size_t I, typename U = TupleLike>
-            friend constexpr auto CPP_auto_fun(get)(
-                forward_tuple_interface<TupleLike> &wb)
-            (
-                return detail::adl_get<I>(static_cast<U &>(wb))
-            )
-            template<std::size_t I, typename U = TupleLike>
-            friend constexpr auto CPP_auto_fun(get)(
-                forward_tuple_interface<TupleLike> const &wb)
-            (
-                return detail::adl_get<I>(static_cast<U const &>(wb))
-            )
-            template<std::size_t I, typename U = TupleLike>
-            friend constexpr auto CPP_auto_fun(get)(
-                forward_tuple_interface<TupleLike> &&wb)
-            (
-                return detail::adl_get<I>(static_cast<U &&>(wb))
-            )
-            template<std::size_t I, typename U = TupleLike>
-            friend constexpr auto CPP_auto_fun(get)(
-                forward_tuple_interface<TupleLike> const &&wb)
-            (
-                return detail::adl_get<I>(static_cast<U const &&>(wb))
-            )
-            template<typename T, typename U = TupleLike>
-            friend constexpr auto CPP_auto_fun(get)(
-                forward_tuple_interface<TupleLike> &wb)
-            (
-                return detail::adl_get<T>(static_cast<U &>(wb))
-            )
-            template<typename T, typename U = TupleLike>
-            friend constexpr auto CPP_auto_fun(get)(
-                forward_tuple_interface<TupleLike> const &wb)
-            (
-                return detail::adl_get<T>(static_cast<U const &>(wb))
-            )
-            template<typename T, typename U = TupleLike>
-            friend constexpr auto CPP_auto_fun(get)(
-                forward_tuple_interface<TupleLike> &&wb)
-            (
-                return detail::adl_get<T>(static_cast<U &&>(wb))
-            )
-            template<typename T, typename U = TupleLike>
-            friend constexpr auto CPP_auto_fun(get)(
-                forward_tuple_interface<TupleLike> const &&wb)
-            (
-                return detail::adl_get<T>(static_cast<U const &&>(wb))
-            )
-            // clang-format on
-        };
-    } // namespace _tuple_wrapper_
-    /// \endcond
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif // RANGES_V3_DETAIL_ADL_GET_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/detail/config.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/detail/config.hpp
deleted file mode 100644
index c503f173..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/detail/config.hpp
+++ /dev/null
@@ -1,755 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_DETAIL_CONFIG_HPP
-#define RANGES_V3_DETAIL_CONFIG_HPP
-
-// Grab some version information.
-#ifndef __has_include
-#include <iosfwd>
-#elif __has_include(<version>)
-#include <version>
-#else
-#include <iosfwd>
-#endif
-
-#if(defined(NDEBUG) && !defined(RANGES_ENSURE_MSG)) || \
-    (!defined(NDEBUG) && !defined(RANGES_ASSERT) &&    \
-     ((defined(__GNUC__) && !defined(__clang__) &&     \
-       (__GNUC__ < 5 || defined(__MINGW32__))) ||      \
-      defined(_MSVC_STL_VERSION)))
-#include <cstdio>
-#include <cstdlib>
-
-namespace ranges
-{
-    namespace detail
-    {
-        template<typename = void>
-        [[noreturn]] void assert_failure(char const * file, int line, char const * msg)
-        {
-            std::fprintf(stderr, "%s(%d): %s\n", file, line, msg);
-            std::abort();
-        }
-    } // namespace detail
-} // namespace ranges
-
-#endif
-
-#ifndef RANGES_ASSERT
-// Always use our hand-rolled assert implementation on older GCCs, which do
-// not allow assert to be used in a constant expression, and on MSVC whose
-// assert is not marked [[noreturn]].
-#if !defined(NDEBUG) && ((defined(__GNUC__) && !defined(__clang__) && \
-                          (__GNUC__ < 5 || defined(__MINGW32__))) ||  \
-                         defined(_MSVC_STL_VERSION))
-#define RANGES_ASSERT(...)                                    \
-    static_cast<void>((__VA_ARGS__)                           \
-                          ? void(0)                           \
-                          : ::ranges::detail::assert_failure( \
-                                __FILE__, __LINE__, "assertion failed: " #__VA_ARGS__))
-#else
-#include <cassert>
-#define RANGES_ASSERT assert
-#endif
-#endif
-
-#include <meta/meta_fwd.hpp>
-
-#ifndef RANGES_ASSUME
-#if defined(__clang__) || defined(__GNUC__)
-#define RANGES_ASSUME(COND) static_cast<void>((COND) ? void(0) : __builtin_unreachable())
-#elif defined(_MSC_VER)
-#define RANGES_ASSUME(COND) static_cast<void>(__assume(COND))
-#else
-#define RANGES_ASSUME(COND) static_cast<void>(COND)
-#endif
-#endif // RANGES_ASSUME
-
-#ifndef RANGES_EXPECT
-#ifdef NDEBUG
-#define RANGES_EXPECT(COND) RANGES_ASSUME(COND)
-#else // NDEBUG
-#define RANGES_EXPECT(COND) RANGES_ASSERT(COND)
-#endif // NDEBUG
-#endif // RANGES_EXPECT
-
-#ifndef RANGES_ENSURE_MSG
-#if defined(NDEBUG)
-#define RANGES_ENSURE_MSG(COND, MSG)                             \
-    static_cast<void>((COND) ? void(0)                           \
-                             : ::ranges::detail::assert_failure( \
-                                   __FILE__, __LINE__, "ensure failed: " MSG))
-#else
-#define RANGES_ENSURE_MSG(COND, MSG) RANGES_ASSERT((COND) && MSG)
-#endif
-#endif
-
-#ifndef RANGES_ENSURE
-#define RANGES_ENSURE(...) RANGES_ENSURE_MSG((__VA_ARGS__), #__VA_ARGS__)
-#endif
-
-#define RANGES_DECLTYPE_AUTO_RETURN(...) \
-    ->decltype(__VA_ARGS__)              \
-    {                                    \
-        return (__VA_ARGS__);            \
-    }                                    \
-    /**/
-
-#define RANGES_DECLTYPE_AUTO_RETURN_NOEXCEPT(...)                                 \
-    noexcept(noexcept(decltype(__VA_ARGS__)(__VA_ARGS__)))->decltype(__VA_ARGS__) \
-    {                                                                             \
-        return (__VA_ARGS__);                                                     \
-    }                                                                             \
-    /**/
-
-#define RANGES_AUTO_RETURN_NOEXCEPT(...)                   \
-    noexcept(noexcept(decltype(__VA_ARGS__)(__VA_ARGS__))) \
-    {                                                      \
-        return (__VA_ARGS__);                              \
-    }                                                      \
-    /**/
-
-#define RANGES_DECLTYPE_NOEXCEPT(...) \
-    noexcept(noexcept(decltype(__VA_ARGS__)(__VA_ARGS__)))->decltype(__VA_ARGS__) /**/
-
-// Non-portable forward declarations of standard containers
-#define RANGES_BEGIN_NAMESPACE_STD META_BEGIN_NAMESPACE_STD
-#define RANGES_END_NAMESPACE_STD META_END_NAMESPACE_STD
-#define RANGES_BEGIN_NAMESPACE_VERSION META_BEGIN_NAMESPACE_VERSION
-#define RANGES_END_NAMESPACE_VERSION META_END_NAMESPACE_VERSION
-#define RANGES_BEGIN_NAMESPACE_CONTAINER META_BEGIN_NAMESPACE_CONTAINER
-#define RANGES_END_NAMESPACE_CONTAINER META_END_NAMESPACE_CONTAINER
-
-// Database of feature versions
-#define RANGES_CXX_STATIC_ASSERT_11 200410L
-#define RANGES_CXX_STATIC_ASSERT_14 RANGES_CXX_STATIC_ASSERT_11
-#define RANGES_CXX_STATIC_ASSERT_17 201411L
-#define RANGES_CXX_VARIABLE_TEMPLATES_11 0L
-#define RANGES_CXX_VARIABLE_TEMPLATES_14 201304L
-#define RANGES_CXX_VARIABLE_TEMPLATES_17 RANGES_CXX_VARIABLE_TEMPLATES_14
-#define RANGES_CXX_ATTRIBUTE_DEPRECATED_11 0L
-#define RANGES_CXX_ATTRIBUTE_DEPRECATED_14 201309L
-#define RANGES_CXX_ATTRIBUTE_DEPRECATED_17 RANGES_CXX_ATTRIBUTE_DEPRECATED_14
-#define RANGES_CXX_CONSTEXPR_11 200704L
-#define RANGES_CXX_CONSTEXPR_14 201304L
-#define RANGES_CXX_CONSTEXPR_17 201603L
-#define RANGES_CXX_CONSTEXPR_LAMBDAS 201603L
-#define RANGES_CXX_RANGE_BASED_FOR_11 200907L
-#define RANGES_CXX_RANGE_BASED_FOR_14 RANGES_CXX_RANGE_BASED_FOR_11
-#define RANGES_CXX_RANGE_BASED_FOR_17 201603L
-#define RANGES_CXX_LIB_IS_FINAL_11 0L
-#define RANGES_CXX_LIB_IS_FINAL_14 201402L
-#define RANGES_CXX_LIB_IS_FINAL_17 RANGES_CXX_LIB_IS_FINAL_14
-#define RANGES_CXX_RETURN_TYPE_DEDUCTION_11 0L
-#define RANGES_CXX_RETURN_TYPE_DEDUCTION_14 201304L
-#define RANGES_CXX_RETURN_TYPE_DEDUCTION_17 RANGES_CXX_RETURN_TYPE_DEDUCTION_14
-#define RANGES_CXX_GENERIC_LAMBDAS_11 0L
-#define RANGES_CXX_GENERIC_LAMBDAS_14 201304L
-#define RANGES_CXX_GENERIC_LAMBDAS_17 RANGES_CXX_GENERIC_LAMBDAS_14
-#define RANGES_CXX_STD_11 201103L
-#define RANGES_CXX_STD_14 201402L
-#define RANGES_CXX_STD_17 201703L
-#define RANGES_CXX_THREAD_LOCAL_PRE_STANDARD \
-    200000L // Arbitrary number between 0 and C++11
-#define RANGES_CXX_THREAD_LOCAL_11 RANGES_CXX_STD_11
-#define RANGES_CXX_THREAD_LOCAL_14 RANGES_CXX_THREAD_LOCAL_11
-#define RANGES_CXX_THREAD_LOCAL_17 RANGES_CXX_THREAD_LOCAL_14
-#define RANGES_CXX_INLINE_VARIABLES_11 0L
-#define RANGES_CXX_INLINE_VARIABLES_14 0L
-#define RANGES_CXX_INLINE_VARIABLES_17 201606L
-#define RANGES_CXX_COROUTINES_11 0L
-#define RANGES_CXX_COROUTINES_14 0L
-#define RANGES_CXX_COROUTINES_17 0L
-#define RANGES_CXX_COROUTINES_TS1 201703L
-#define RANGES_CXX_DEDUCTION_GUIDES_11 0L
-#define RANGES_CXX_DEDUCTION_GUIDES_14 0L
-#define RANGES_CXX_DEDUCTION_GUIDES_17 201606L
-#define RANGES_CXX_IF_CONSTEXPR_11 0L
-#define RANGES_CXX_IF_CONSTEXPR_14 0L
-#define RANGES_CXX_IF_CONSTEXPR_17 201606L
-#define RANGES_CXX_ALIGNED_NEW_11 0L
-#define RANGES_CXX_ALIGNED_NEW_14 0L
-#define RANGES_CXX_ALIGNED_NEW_17 201606L
-
-// Implementation-specific diagnostic control
-#if defined(_MSC_VER) && !defined(__clang__)
-#define RANGES_DIAGNOSTIC_PUSH __pragma(warning(push))
-#define RANGES_DIAGNOSTIC_POP __pragma(warning(pop))
-#define RANGES_DIAGNOSTIC_IGNORE_PRAGMAS __pragma(warning(disable : 4068))
-#define RANGES_DIAGNOSTIC_IGNORE(X) \
-    RANGES_DIAGNOSTIC_IGNORE_PRAGMAS __pragma(warning(disable : X))
-#define RANGES_DIAGNOSTIC_IGNORE_SHADOWING RANGES_DIAGNOSTIC_IGNORE(4456)
-#define RANGES_DIAGNOSTIC_IGNORE_INDENTATION
-#define RANGES_DIAGNOSTIC_IGNORE_UNDEFINED_INTERNAL
-#define RANGES_DIAGNOSTIC_IGNORE_MISMATCHED_TAGS RANGES_DIAGNOSTIC_IGNORE(4099)
-#define RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS
-#define RANGES_DIAGNOSTIC_IGNORE_SIGN_CONVERSION
-#define RANGES_DIAGNOSTIC_IGNORE_UNNEEDED_INTERNAL
-#define RANGES_DIAGNOSTIC_IGNORE_UNNEEDED_MEMBER
-#define RANGES_DIAGNOSTIC_IGNORE_ZERO_LENGTH_ARRAY
-#define RANGES_DIAGNOSTIC_IGNORE_CXX17_COMPAT
-#define RANGES_DIAGNOSTIC_IGNORE_CXX2A_COMPAT
-#define RANGES_DIAGNOSTIC_IGNORE_FLOAT_EQUAL
-#define RANGES_DIAGNOSTIC_IGNORE_MISSING_BRACES
-#define RANGES_DIAGNOSTIC_IGNORE_UNDEFINED_FUNC_TEMPLATE
-#define RANGES_DIAGNOSTIC_IGNORE_INCONSISTENT_OVERRIDE
-#define RANGES_DIAGNOSTIC_IGNORE_RANGE_LOOP_ANALYSIS
-#define RANGES_DIAGNOSTIC_IGNORE_DEPRECATED_DECLARATIONS RANGES_DIAGNOSTIC_IGNORE(4996)
-#define RANGES_DIAGNOSTIC_IGNORE_DEPRECATED_THIS_CAPTURE
-#define RANGES_DIAGNOSTIC_IGNORE_INIT_LIST_LIFETIME
-// Ignores both "divide by zero" and "mod by zero":
-#define RANGES_DIAGNOSTIC_IGNORE_DIVIDE_BY_ZERO RANGES_DIAGNOSTIC_IGNORE(4723 4724)
-#define RANGES_DIAGNOSTIC_IGNORE_UNSIGNED_MATH RANGES_DIAGNOSTIC_IGNORE(4146)
-#define RANGES_DIAGNOSTIC_IGNORE_TRUNCATION RANGES_DIAGNOSTIC_IGNORE(4244)
-#define RANGES_DIAGNOSTIC_IGNORE_MULTIPLE_ASSIGNMENT_OPERATORS \
-    RANGES_DIAGNOSTIC_IGNORE(4522)
-#define RANGES_DIAGNOSTIC_IGNORE_VOID_PTR_DEREFERENCE
-#define RANGES_DIAGNOSTIC_KEYWORD_MACRO
-
-#define RANGES_CXX_VER _MSVC_LANG
-
-#if _MSC_VER < 1920 || _MSVC_LANG < 201703L
-#error range-v3 requires Visual Studio 2019 with the /std:c++17 (or /std:c++latest) and /permissive- options.
-#endif
-
-#if _MSC_VER < 1927
-#define RANGES_WORKAROUND_MSVC_895622 // Error when phase 1 name binding finds only
-                                      // deleted function
-
-#if _MSC_VER < 1925
-#define RANGES_WORKAROUND_MSVC_779708 // ADL for operands of function type [No workaround]
-
-#if _MSC_VER < 1923
-#define RANGES_WORKAROUND_MSVC_573728 // rvalues of array types bind to lvalue references
-                                      // [no workaround]
-#define RANGES_WORKAROUND_MSVC_934330 // Deduction guide not correctly preferred to copy
-                                      // deduction candidate [No workaround]
-
-#if _MSC_VER < 1922
-#define RANGES_WORKAROUND_MSVC_756601 // constexpr friend non-template erroneously
-                                      // rejected with C3615
-#define RANGES_WORKAROUND_MSVC_793042 // T[0] sometimes accepted as a valid type in SFINAE
-                                      // context
-
-#if _MSC_VER < 1921
-#define RANGES_WORKAROUND_MSVC_785522 // SFINAE failure for error in immediate context
-#define RANGES_WORKAROUND_MSVC_786376 // Assertion casting anonymous union member in
-                                      // trailing-return-type
-#define RANGES_WORKAROUND_MSVC_787074 // Over-eager substitution of dependent type in
-                                      // non-instantiated nested class template
-#define RANGES_WORKAROUND_MSVC_790554 // Assert for return type that uses dependent
-                                      // default non-type template argument
-#endif                                // _MSC_VER < 1921
-#endif                                // _MSC_VER < 1922
-#endif                                // _MSC_VER < 1923
-#endif                                // _MSC_VER < 1925
-#endif                                // _MSC_VER < 1926
-
-#if 1 // Fixed in 1920, but more bugs hiding behind workaround
-#define RANGES_WORKAROUND_MSVC_701385 // Yet another alias expansion error
-#endif
-
-#define RANGES_WORKAROUND_MSVC_249830 // constexpr and arguments that aren't subject to
-                                      // lvalue-to-rvalue conversion
-#define RANGES_WORKAROUND_MSVC_677925 // Bogus C2676 "binary '++': '_Ty' does not define
-                                      // this operator"
-#define RANGES_WORKAROUND_MSVC_683388 // decltype(*i) is incorrectly an rvalue reference
-                                      // for pointer-to-array i
-#define RANGES_WORKAROUND_MSVC_688606 // SFINAE failing to account for access control
-                                      // during specialization matching
-#define RANGES_WORKAROUND_MSVC_786312 // Yet another mixed-pack-expansion failure
-#define RANGES_WORKAROUND_MSVC_792338 // Failure to match specialization enabled via call
-                                      // to constexpr function
-#define RANGES_WORKAROUND_MSVC_835948 // Silent bad codegen destroying sized_generator [No
-                                      // workaround]
-#define RANGES_WORKAROUND_MSVC_934264 // Explicitly-defaulted inherited default
-                                      // constructor is not correctly implicitly constexpr
-#if _MSVC_LANG <= 201703L
-#define RANGES_WORKAROUND_MSVC_OLD_LAMBDA
-#endif
-
-#elif defined(__GNUC__) || defined(__clang__)
-#define RANGES_PRAGMA(X) _Pragma(#X)
-#define RANGES_DIAGNOSTIC_PUSH RANGES_PRAGMA(GCC diagnostic push)
-#define RANGES_DIAGNOSTIC_POP RANGES_PRAGMA(GCC diagnostic pop)
-#define RANGES_DIAGNOSTIC_IGNORE_PRAGMAS RANGES_PRAGMA(GCC diagnostic ignored "-Wpragmas")
-#define RANGES_DIAGNOSTIC_IGNORE(X)                                  \
-    RANGES_DIAGNOSTIC_IGNORE_PRAGMAS                                 \
-    RANGES_PRAGMA(GCC diagnostic ignored "-Wunknown-pragmas")        \
-    RANGES_PRAGMA(GCC diagnostic ignored "-Wunknown-warning-option") \
-    RANGES_PRAGMA(GCC diagnostic ignored X)
-#define RANGES_DIAGNOSTIC_IGNORE_SHADOWING RANGES_DIAGNOSTIC_IGNORE("-Wshadow")
-#define RANGES_DIAGNOSTIC_IGNORE_INDENTATION \
-    RANGES_DIAGNOSTIC_IGNORE("-Wmisleading-indentation")
-#define RANGES_DIAGNOSTIC_IGNORE_UNDEFINED_INTERNAL \
-    RANGES_DIAGNOSTIC_IGNORE("-Wundefined-internal")
-#define RANGES_DIAGNOSTIC_IGNORE_MISMATCHED_TAGS \
-    RANGES_DIAGNOSTIC_IGNORE("-Wmismatched-tags")
-#define RANGES_DIAGNOSTIC_IGNORE_SIGN_CONVERSION \
-    RANGES_DIAGNOSTIC_IGNORE("-Wsign-conversion")
-#define RANGES_DIAGNOSTIC_IGNORE_FLOAT_EQUAL RANGES_DIAGNOSTIC_IGNORE("-Wfloat-equal")
-#define RANGES_DIAGNOSTIC_IGNORE_MISSING_BRACES \
-    RANGES_DIAGNOSTIC_IGNORE("-Wmissing-braces")
-#define RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS \
-    RANGES_DIAGNOSTIC_IGNORE("-Wglobal-constructors")
-#define RANGES_DIAGNOSTIC_IGNORE_UNNEEDED_INTERNAL \
-    RANGES_DIAGNOSTIC_IGNORE("-Wunneeded-internal-declaration")
-#define RANGES_DIAGNOSTIC_IGNORE_UNNEEDED_MEMBER \
-    RANGES_DIAGNOSTIC_IGNORE("-Wunneeded-member-function")
-#define RANGES_DIAGNOSTIC_IGNORE_ZERO_LENGTH_ARRAY \
-    RANGES_DIAGNOSTIC_IGNORE("-Wzero-length-array")
-#define RANGES_DIAGNOSTIC_IGNORE_CXX17_COMPAT RANGES_DIAGNOSTIC_IGNORE("-Wc++1z-compat")
-#define RANGES_DIAGNOSTIC_IGNORE_CXX2A_COMPAT RANGES_DIAGNOSTIC_IGNORE("-Wc++2a-compat")
-#define RANGES_DIAGNOSTIC_IGNORE_UNDEFINED_FUNC_TEMPLATE \
-    RANGES_DIAGNOSTIC_IGNORE("-Wundefined-func-template")
-#define RANGES_DIAGNOSTIC_IGNORE_INCONSISTENT_OVERRIDE \
-    RANGES_DIAGNOSTIC_IGNORE("-Winconsistent-missing-override")
-#define RANGES_DIAGNOSTIC_IGNORE_RANGE_LOOP_ANALYSIS \
-    RANGES_DIAGNOSTIC_IGNORE("-Wrange-loop-analysis")
-#define RANGES_DIAGNOSTIC_IGNORE_DEPRECATED_DECLARATIONS \
-    RANGES_DIAGNOSTIC_IGNORE("-Wdeprecated-declarations")
-#define RANGES_DIAGNOSTIC_IGNORE_DEPRECATED_THIS_CAPTURE \
-    RANGES_DIAGNOSTIC_IGNORE("-Wdeprecated-this-capture")
-#define RANGES_DIAGNOSTIC_IGNORE_INIT_LIST_LIFETIME \
-    RANGES_DIAGNOSTIC_IGNORE("-Winit-list-lifetime")
-#define RANGES_DIAGNOSTIC_IGNORE_DIVIDE_BY_ZERO
-#define RANGES_DIAGNOSTIC_IGNORE_UNSIGNED_MATH
-#define RANGES_DIAGNOSTIC_IGNORE_TRUNCATION
-#define RANGES_DIAGNOSTIC_IGNORE_MULTIPLE_ASSIGNMENT_OPERATORS
-#define RANGES_DIAGNOSTIC_IGNORE_VOID_PTR_DEREFERENCE \
-    RANGES_DIAGNOSTIC_IGNORE("-Wvoid-ptr-dereference")
-#define RANGES_DIAGNOSTIC_KEYWORD_MACRO RANGES_DIAGNOSTIC_IGNORE("-Wkeyword-macro")
-
-#define RANGES_WORKAROUND_CWG_1554
-#ifdef __clang__
-#if __clang_major__ < 4
-#define RANGES_WORKAROUND_CLANG_23135 // constexpr leads to premature instantiation on
-                                      // clang-3.x
-#endif
-#define RANGES_WORKAROUND_CLANG_43400 // template friend is redefinition of itself
-#else                                 // __GNUC__
-#if __GNUC__ < 6
-#define RANGES_WORKAROUND_GCC_UNFILED0 /* Workaround old GCC name lookup bug */
-#endif
-#if __GNUC__ == 7 || __GNUC__ == 8
-#define RANGES_WORKAROUND_GCC_91525 /* Workaround strange GCC ICE */
-#endif
-#if __GNUC__ >= 9
-#if __GNUC__ == 9 && __GNUC_MINOR__ < 3 && __cplusplus == RANGES_CXX_STD_17
-#define RANGES_WORKAROUND_GCC_91923 // Failure-to-SFINAE with class type NTTP in C++17
-#endif
-#endif
-#endif
-
-#else
-#define RANGES_DIAGNOSTIC_PUSH
-#define RANGES_DIAGNOSTIC_POP
-#define RANGES_DIAGNOSTIC_IGNORE_PRAGMAS
-#define RANGES_DIAGNOSTIC_IGNORE_SHADOWING
-#define RANGES_DIAGNOSTIC_IGNORE_INDENTATION
-#define RANGES_DIAGNOSTIC_IGNORE_UNDEFINED_INTERNAL
-#define RANGES_DIAGNOSTIC_IGNORE_MISMATCHED_TAGS
-#define RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS
-#define RANGES_DIAGNOSTIC_IGNORE_SIGN_CONVERSION
-#define RANGES_DIAGNOSTIC_IGNORE_UNNEEDED_INTERNAL
-#define RANGES_DIAGNOSTIC_IGNORE_UNNEEDED_MEMBER
-#define RANGES_DIAGNOSTIC_IGNORE_ZERO_LENGTH_ARRAY
-#define RANGES_DIAGNOSTIC_IGNORE_CXX17_COMPAT
-#define RANGES_DIAGNOSTIC_IGNORE_CXX2A_COMPAT
-#define RANGES_DIAGNOSTIC_IGNORE_FLOAT_EQUAL
-#define RANGES_DIAGNOSTIC_IGNORE_MISSING_BRACES
-#define RANGES_DIAGNOSTIC_IGNORE_UNDEFINED_FUNC_TEMPLATE
-#define RANGES_DIAGNOSTIC_IGNORE_INCONSISTENT_OVERRIDE
-#define RANGES_DIAGNOSTIC_IGNORE_DEPRECATED_DECLARATIONS
-#define RANGES_DIAGNOSTIC_IGNORE_DEPRECATED_THIS_CAPTURE
-#define RANGES_DIAGNOSTIC_IGNORE_INIT_LIST_LIFETIME
-#define RANGES_DIAGNOSTIC_IGNORE_DIVIDE_BY_ZERO
-#define RANGES_DIAGNOSTIC_IGNORE_UNSIGNED_MATH
-#define RANGES_DIAGNOSTIC_IGNORE_TRUNCATION
-#define RANGES_DIAGNOSTIC_IGNORE_MULTIPLE_ASSIGNMENT_OPERATORS
-#define RANGES_DIAGNOSTIC_IGNORE_VOID_PTR_DEREFERENCE
-#define RANGES_DIAGNOSTIC_KEYWORD_MACRO
-#endif
-
-// Configuration via feature-test macros, with fallback to __cplusplus
-#ifndef RANGES_CXX_VER
-#define RANGES_CXX_VER __cplusplus
-#endif
-
-#define RANGES_CXX_FEATURE_CONCAT2(y, z) RANGES_CXX_##y##_##z
-#define RANGES_CXX_FEATURE_CONCAT(y, z) RANGES_CXX_FEATURE_CONCAT2(y, z)
-
-#if RANGES_CXX_VER >= RANGES_CXX_STD_17
-#define RANGES_CXX_STD RANGES_CXX_STD_17
-#define RANGES_CXX_FEATURE(x) RANGES_CXX_FEATURE_CONCAT(x, 17)
-#elif RANGES_CXX_VER >= RANGES_CXX_STD_14
-#define RANGES_CXX_STD RANGES_CXX_STD_14
-#define RANGES_CXX_FEATURE(x) RANGES_CXX_FEATURE_CONCAT(x, 14)
-#else
-#define RANGES_CXX_STD RANGES_CXX_STD_11
-#define RANGES_CXX_FEATURE(x) RANGES_CXX_FEATURE_CONCAT(x, 11)
-#endif
-
-#ifndef RANGES_CXX_STATIC_ASSERT
-#ifdef __cpp_static_assert
-#define RANGES_CXX_STATIC_ASSERT __cpp_static_assert
-#else
-#define RANGES_CXX_STATIC_ASSERT RANGES_CXX_FEATURE(STATIC_ASSERT)
-#endif
-#endif
-
-#ifndef RANGES_CXX_VARIABLE_TEMPLATES
-#ifdef __cpp_variable_templates
-#define RANGES_CXX_VARIABLE_TEMPLATES __cpp_variable_templates
-#else
-#define RANGES_CXX_VARIABLE_TEMPLATES RANGES_CXX_FEATURE(VARIABLE_TEMPLATES)
-#endif
-#endif
-
-#if(defined(__cpp_lib_type_trait_variable_templates) && \
-    __cpp_lib_type_trait_variable_templates > 0) ||     \
-    RANGES_CXX_VER >= RANGES_CXX_STD_17
-#define RANGES_CXX_TRAIT_VARIABLE_TEMPLATES 1
-#else
-#define RANGES_CXX_TRAIT_VARIABLE_TEMPLATES 0
-#endif
-
-#ifndef RANGES_CXX_ATTRIBUTE_DEPRECATED
-#ifdef __has_cpp_attribute
-#define RANGES_CXX_ATTRIBUTE_DEPRECATED __has_cpp_attribute(deprecated)
-#elif defined(__cpp_attribute_deprecated)
-#define RANGES_CXX_ATTRIBUTE_DEPRECATED __cpp_attribute_deprecated
-#else
-#define RANGES_CXX_ATTRIBUTE_DEPRECATED RANGES_CXX_FEATURE(ATTRIBUTE_DEPRECATED)
-#endif
-#endif
-
-#ifndef RANGES_CXX_CONSTEXPR
-#ifdef __cpp_constexpr
-#define RANGES_CXX_CONSTEXPR __cpp_constexpr
-#else
-#define RANGES_CXX_CONSTEXPR RANGES_CXX_FEATURE(CONSTEXPR)
-#endif
-#endif
-
-#ifndef RANGES_CXX_RANGE_BASED_FOR
-#ifdef __cpp_range_based_for
-#define RANGES_CXX_RANGE_BASED_FOR __cpp_range_based_for
-#else
-#define RANGES_CXX_RANGE_BASED_FOR RANGES_CXX_FEATURE(RANGE_BASED_FOR)
-#endif
-#endif
-
-#ifndef RANGES_CXX_LIB_IS_FINAL
-#include <type_traits>
-#ifdef __cpp_lib_is_final
-#define RANGES_CXX_LIB_IS_FINAL __cpp_lib_is_final
-#else
-#define RANGES_CXX_LIB_IS_FINAL RANGES_CXX_FEATURE(LIB_IS_FINAL)
-#endif
-#endif
-
-#ifndef RANGES_CXX_RETURN_TYPE_DEDUCTION
-#ifdef __cpp_return_type_deduction
-#define RANGES_CXX_RETURN_TYPE_DEDUCTION __cpp_return_type_deduction
-#else
-#define RANGES_CXX_RETURN_TYPE_DEDUCTION RANGES_CXX_FEATURE(RETURN_TYPE_DEDUCTION)
-#endif
-#endif
-
-#ifndef RANGES_CXX_GENERIC_LAMBDAS
-#ifdef __cpp_generic_lambdas
-#define RANGES_CXX_GENERIC_LAMBDAS __cpp_generic_lambdas
-#else
-#define RANGES_CXX_GENERIC_LAMBDAS RANGES_CXX_FEATURE(GENERIC_LAMBDAS)
-#endif
-#endif
-
-#ifndef RANGES_CXX_THREAD_LOCAL
-#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED <= 70100
-#define RANGES_CXX_THREAD_LOCAL 0
-#elif defined(__IPHONE_OS_VERSION_MIN_REQUIRED) || \
-    (defined(__clang__) && (defined(__CYGWIN__) || defined(__apple_build_version__)))
-// BUGBUG avoid unresolved __cxa_thread_atexit
-#define RANGES_CXX_THREAD_LOCAL RANGES_CXX_THREAD_LOCAL_PRE_STANDARD
-#else
-#define RANGES_CXX_THREAD_LOCAL RANGES_CXX_FEATURE(THREAD_LOCAL)
-#endif
-#endif
-
-#if !defined(RANGES_DEPRECATED) && !defined(RANGES_DISABLE_DEPRECATED_WARNINGS)
-#if defined(__GNUC__) && !defined(__clang__)
-// GCC's support for [[deprecated("message")]] is unusably buggy.
-#define RANGES_DEPRECATED(MSG) __attribute__((deprecated(MSG)))
-#elif RANGES_CXX_ATTRIBUTE_DEPRECATED && \
-    !((defined(__clang__) || defined(__GNUC__)) && RANGES_CXX_STD < RANGES_CXX_STD_14)
-#define RANGES_DEPRECATED(MSG) [[deprecated(MSG)]]
-#elif defined(__clang__) || defined(__GNUC__)
-#define RANGES_DEPRECATED(MSG) __attribute__((deprecated(MSG)))
-#endif
-#endif
-#ifndef RANGES_DEPRECATED
-#define RANGES_DEPRECATED(MSG)
-#endif
-
-#if !defined(RANGES_DEPRECATED_HEADER) && !defined(RANGES_DISABLE_DEPRECATED_WARNINGS)
-#ifdef __GNUC__
-#define RANGES_DEPRECATED_HEADER(MSG) RANGES_PRAGMA(GCC warning MSG)
-#elif defined(_MSC_VER)
-#define RANGES_STRINGIZE_(MSG) #MSG
-#define RANGES_STRINGIZE(MSG) RANGES_STRINGIZE_(MSG)
-#define RANGES_DEPRECATED_HEADER(MSG) \
-    __pragma(message(__FILE__ "(" RANGES_STRINGIZE(__LINE__) ") : Warning: " MSG))
-#endif
-#else
-#define RANGES_DEPRECATED_HEADER(MSG) /**/
-#endif
-// #ifndef RANGES_DEPRECATED_HEADER
-// #define RANGES_DEPRECATED_HEADER(MSG)
-// #endif
-
-#ifndef RANGES_CXX_COROUTINES
-#if defined(__cpp_coroutines) && defined(__has_include)
-#if __has_include(<coroutine>)
-#define RANGES_CXX_COROUTINES __cpp_coroutines
-#define RANGES_COROUTINES_HEADER <coroutine>
-#define RANGES_COROUTINES_NS std
-#elif __has_include(<experimental/coroutine>)
-#define RANGES_CXX_COROUTINES __cpp_coroutines
-#define RANGES_COROUTINES_HEADER <experimental/coroutine>
-#define RANGES_COROUTINES_NS std::experimental
-#endif
-#endif
-#ifndef RANGES_CXX_COROUTINES
-#define RANGES_CXX_COROUTINES RANGES_CXX_FEATURE(COROUTINES)
-#endif
-#endif
-
-// RANGES_CXX14_CONSTEXPR macro (see also BOOST_CXX14_CONSTEXPR)
-// Note: constexpr implies inline, to retain the same visibility
-// C++14 constexpr functions are inline in C++11
-#if RANGES_CXX_CONSTEXPR >= RANGES_CXX_CONSTEXPR_14
-#define RANGES_CXX14_CONSTEXPR constexpr
-#else
-#define RANGES_CXX14_CONSTEXPR inline
-#endif
-
-#ifdef NDEBUG
-#define RANGES_NDEBUG_CONSTEXPR constexpr
-#else
-#define RANGES_NDEBUG_CONSTEXPR inline
-#endif
-
-#ifndef RANGES_CXX_INLINE_VARIABLES
-#ifdef __cpp_inline_variables
-#define RANGES_CXX_INLINE_VARIABLES __cpp_inline_variables
-#elif defined(__clang__) && (__clang_major__ == 3 && __clang_minor__ == 9) && \
-    RANGES_CXX_VER > RANGES_CXX_STD_14
-// Clang 3.9 supports inline variables in C++17 mode, but doesn't define
-// __cpp_inline_variables
-#define RANGES_CXX_INLINE_VARIABLES RANGES_CXX_INLINE_VARIABLES_17
-#else
-#define RANGES_CXX_INLINE_VARIABLES RANGES_CXX_FEATURE(INLINE_VARIABLES)
-#endif // __cpp_inline_variables
-#endif // RANGES_CXX_INLINE_VARIABLES
-
-#if RANGES_CXX_INLINE_VARIABLES < RANGES_CXX_INLINE_VARIABLES_17 && \
-    !defined(RANGES_DOXYGEN_INVOKED)
-#define RANGES_INLINE_VAR
-#define RANGES_INLINE_VARIABLE(type, name)                           \
-    namespace                                                        \
-    {                                                                \
-        constexpr auto & name = ::ranges::static_const<type>::value; \
-    }
-#else // RANGES_CXX_INLINE_VARIABLES >= RANGES_CXX_INLINE_VARIABLES_17
-#define RANGES_INLINE_VAR inline
-#define RANGES_INLINE_VARIABLE(type, name) \
-    inline constexpr type name{};          \
-    /**/
-#endif // RANGES_CXX_INLINE_VARIABLES
-
-#if defined(RANGES_DOXYGEN_INVOKED)
-#define RANGES_DEFINE_CPO(type, name) \
-    inline constexpr type name{};     \
-    /**/
-#elif RANGES_CXX_INLINE_VARIABLES < RANGES_CXX_INLINE_VARIABLES_17
-#define RANGES_DEFINE_CPO(type, name)                                \
-    namespace                                                        \
-    {                                                                \
-        constexpr auto & name = ::ranges::static_const<type>::value; \
-    }                                                                \
-    /**/
-#else // RANGES_CXX_INLINE_VARIABLES >= RANGES_CXX_INLINE_VARIABLES_17
-#define RANGES_DEFINE_CPO(type, name) \
-    namespace _                       \
-    {                                 \
-        inline constexpr type name{}; \
-    }                                 \
-    using namespace _;                \
-    /**/
-#endif // RANGES_CXX_INLINE_VARIABLES
-
-#ifndef RANGES_DOXYGEN_INVOKED
-#define RANGES_HIDDEN_DETAIL(...) __VA_ARGS__
-#else
-#define RANGES_HIDDEN_DETAIL(...)
-#endif
-
-#ifndef RANGES_DOXYGEN_INVOKED
-#define RANGES_ADL_BARRIER_FOR(S) S##_ns
-#define RANGES_STRUCT_WITH_ADL_BARRIER(S) \
-    _ranges_adl_barrier_noop_;            \
-    namespace RANGES_ADL_BARRIER_FOR(S)   \
-    {                                     \
-        struct S;                         \
-    }                                     \
-    using RANGES_ADL_BARRIER_FOR(S)::S;   \
-    struct RANGES_ADL_BARRIER_FOR(S)::S /**/
-#else
-#define RANGES_ADL_BARRIER_FOR(S)
-#define RANGES_STRUCT_WITH_ADL_BARRIER(S) S
-#endif
-
-#ifndef RANGES_DOXYGEN_INVOKED
-#define RANGES_FUNC_BEGIN(NAME) \
-    struct NAME##_fn            \
-    {
-#define RANGES_FUNC_END(NAME) \
-    }                         \
-    ;                         \
-    RANGES_INLINE_VARIABLE(NAME##_fn, NAME)
-#define RANGES_FUNC(NAME) operator() RANGES_FUNC_CONST_ /**/
-#define RANGES_FUNC_CONST_(...) (__VA_ARGS__) const
-#else
-#define RANGES_FUNC_BEGIN(NAME)
-#define RANGES_FUNC_END(NAME)
-#define RANGES_FUNC(NAME) NAME
-#endif
-
-#ifndef RANGES_CXX_DEDUCTION_GUIDES
-#if defined(__clang__) && defined(__apple_build_version__)
-// Apple's clang version doesn't do deduction guides very well.
-#define RANGES_CXX_DEDUCTION_GUIDES 0
-#elif defined(__cpp_deduction_guides)
-#define RANGES_CXX_DEDUCTION_GUIDES __cpp_deduction_guides
-#else
-#define RANGES_CXX_DEDUCTION_GUIDES RANGES_CXX_FEATURE(DEDUCTION_GUIDES)
-#endif // __cpp_deduction_guides
-#endif // RANGES_CXX_DEDUCTION_GUIDES
-
-// __VA_OPT__
-#ifndef RANGES_CXX_VA_OPT
-#if __cplusplus > 201703L
-#define RANGES_CXX_THIRD_ARG_(A, B, C, ...) C
-#define RANGES_CXX_VA_OPT_I_(...) RANGES_CXX_THIRD_ARG_(__VA_OPT__(, ), 1, 0, ?)
-#define RANGES_CXX_VA_OPT RANGES_CXX_VA_OPT_I_(?)
-#else
-#define RANGES_CXX_VA_OPT 0
-#endif
-#endif // RANGES_CXX_VA_OPT
-
-#ifndef RANGES_CXX_IF_CONSTEXPR
-#ifdef __cpp_if_constexpr
-#define RANGES_CXX_IF_CONSTEXPR __cpp_if_constexpr
-#else
-#define RANGES_CXX_IF_CONSTEXPR RANGES_CXX_FEATURE(IF_CONSTEXPR)
-#endif
-#endif // RANGES_CXX_IF_CONSTEXPR
-
-// Its not enough for the compiler to support this; the stdlib must support it too.
-#ifndef RANGES_CXX_ALIGNED_NEW
-#if(!defined(_LIBCPP_VERSION) ||                                                 \
-    (_LIBCPP_VERSION >= 4000 && !defined(_LIBCPP_HAS_NO_ALIGNED_ALLOCATION))) && \
-    (!defined(__GLIBCXX__) || (defined(_GLIBCXX_RELEASE) && _GLIBCXX_RELEASE >= 7))
-#if defined(__cpp_aligned_new)
-#define RANGES_CXX_ALIGNED_NEW __cpp_aligned_new
-#else
-#define RANGES_CXX_ALIGNED_NEW RANGES_CXX_FEATURE(ALIGNED_NEW)
-#endif
-#else // _LIBCPP_VERSION < 4000 || __GLIBCXX__ < 20170502
-#define RANGES_CXX_ALIGNED_NEW 0L
-#endif
-#endif // RANGES_CXX_ALIGNED_NEW
-
-#if defined(__clang__)
-#define RANGES_IS_SAME(...) __is_same(__VA_ARGS__)
-#elif defined(__GNUC__) && __GNUC__ >= 6
-#define RANGES_IS_SAME(...) __is_same_as(__VA_ARGS__)
-#elif RANGES_CXX_TRAIT_VARIABLE_TEMPLATES
-#define RANGES_IS_SAME(...) std::is_same_v<__VA_ARGS__>
-#else
-#define RANGES_IS_SAME(...) std::is_same<__VA_ARGS__>::value
-#endif
-
-// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=93667
-#if defined(__has_cpp_attribute) && __has_cpp_attribute(no_unique_address) && \
-    !(defined(__GNUC__) && !defined(__clang__) && __GNUC__ >= 10)
-#define RANGES_NO_UNIQUE_ADDRESS [[no_unique_address]]
-#else
-#define RANGES_NO_UNIQUE_ADDRESS
-#endif
-
-#if defined(__clang__)
-#if __has_attribute(no_sanitize)
-#define RANGES_INTENDED_MODULAR_ARITHMETIC \
-    __attribute__((__no_sanitize__("unsigned-integer-overflow")))
-#else
-#define RANGES_INTENDED_MODULAR_ARITHMETIC
-#endif
-#else
-#define RANGES_INTENDED_MODULAR_ARITHMETIC
-#endif
-
-#ifndef RANGES_CONSTEXPR_IF
-#if RANGES_CXX_IF_CONSTEXPR >= RANGES_CXX_IF_CONSTEXPR_17
-#define RANGES_CONSTEXPR_IF(...) false) \
-    {} else if constexpr(__VA_ARGS__
-#else
-#define RANGES_CONSTEXPR_IF(...) __VA_ARGS__
-#endif
-#endif // RANGES_CONSTEXPR_IF
-
-#if !defined(RANGES_BROKEN_CPO_LOOKUP) && !defined(RANGES_DOXYGEN_INVOKED) && \
-    (defined(RANGES_WORKAROUND_GCC_UNFILED0) || defined(RANGES_WORKAROUND_MSVC_895622))
-#define RANGES_BROKEN_CPO_LOOKUP 1
-#endif
-#ifndef RANGES_BROKEN_CPO_LOOKUP
-#define RANGES_BROKEN_CPO_LOOKUP 0
-#endif
-
-#ifndef RANGES_NODISCARD
-#if defined(__has_cpp_attribute) && __has_cpp_attribute(nodiscard)
-#if defined(__clang__) && __cplusplus < 201703L
-// clang complains about using nodiscard in C++14 mode.
-#define RANGES_NODISCARD                           \
-    RANGES_DIAGNOSTIC_PUSH                         \
-    RANGES_DIAGNOSTIC_IGNORE("-Wc++1z-extensions") \
-    [[nodiscard]] RANGES_DIAGNOSTIC_POP /**/
-#else
-#define RANGES_NODISCARD [[nodiscard]]
-#endif
-#else
-#define RANGES_NODISCARD
-#endif
-#endif
-
-#ifndef RANGES_EMPTY_BASES
-#ifdef _MSC_VER
-#define RANGES_EMPTY_BASES __declspec(empty_bases)
-#else
-#define RANGES_EMPTY_BASES
-#endif
-#endif
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/detail/epilogue.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/detail/epilogue.hpp
deleted file mode 100644
index eb188542..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/detail/epilogue.hpp
+++ /dev/null
@@ -1,21 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_PROLOGUE_INCLUDED
-#error "Including epilogue, but prologue not included!"
-#endif
-#undef RANGES_PROLOGUE_INCLUDED
-
-#undef template
-#undef AND
-
-RANGES_DIAGNOSTIC_POP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/detail/prologue.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/detail/prologue.hpp
deleted file mode 100644
index d4c0187c..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/detail/prologue.hpp
+++ /dev/null
@@ -1,37 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_DETAIL_PROLOGUE_HPP
-#define RANGES_V3_DETAIL_PROLOGUE_HPP
-#include <range/v3/detail/config.hpp>
-#endif
-
-#ifdef RANGES_PROLOGUE_INCLUDED
-#error "Prologue already included!"
-#endif
-#define RANGES_PROLOGUE_INCLUDED
-
-RANGES_DIAGNOSTIC_PUSH
-
-#ifdef RANGES_FEWER_WARNINGS
-RANGES_DIAGNOSTIC_IGNORE_UNDEFINED_INTERNAL
-RANGES_DIAGNOSTIC_IGNORE_INDENTATION
-RANGES_DIAGNOSTIC_IGNORE_CXX17_COMPAT
-#endif
-
-RANGES_DIAGNOSTIC_KEYWORD_MACRO
-
-#define template(...)                                                           \
-    CPP_PP_IGNORE_CXX2A_COMPAT_BEGIN                                            \
-    template<__VA_ARGS__ CPP_TEMPLATE_AUX_                                      \
-
-#define AND CPP_and
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/detail/range_access.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/detail/range_access.hpp
deleted file mode 100644
index 34ff4865..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/detail/range_access.hpp
+++ /dev/null
@@ -1,375 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_DETAIL_RANGE_ACCESS_HPP
-#define RANGES_V3_DETAIL_RANGE_ACCESS_HPP
-
-#include <cstddef>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/concepts.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    struct range_access
-    {
-        /// \cond
-    private:
-        template<typename T>
-        static std::false_type single_pass_2_(long);
-        template<typename T>
-        static typename T::single_pass single_pass_2_(int);
-
-        template<typename T>
-        struct single_pass_
-        {
-            using type = decltype(range_access::single_pass_2_<T>(42));
-        };
-
-        template<typename T>
-        static std::false_type contiguous_2_(long);
-        template<typename T>
-        static typename T::contiguous contiguous_2_(int);
-
-        template<typename T>
-        struct contiguous_
-        {
-            using type = decltype(range_access::contiguous_2_<T>(42));
-        };
-
-        template<typename T>
-        static basic_mixin<T> mixin_base_2_(long);
-        template<typename T>
-        static typename T::mixin mixin_base_2_(int);
-
-        template<typename Cur>
-        struct mixin_base_
-        {
-            using type = decltype(range_access::mixin_base_2_<Cur>(42));
-        };
-
-
-    public:
-        template<typename Cur>
-        using single_pass_t = meta::_t<single_pass_<Cur>>;
-
-        template<typename Cur>
-        using contiguous_t = meta::_t<contiguous_<Cur>>;
-
-        template<typename Cur>
-        using mixin_base_t = meta::_t<mixin_base_<Cur>>;
-
-        // clang-format off
-        template<typename Rng>
-        static constexpr auto CPP_auto_fun(begin_cursor)(Rng &rng)
-        (
-            return rng.begin_cursor()
-        )
-        template<typename Rng>
-        static constexpr auto CPP_auto_fun(end_cursor)(Rng &rng)
-        (
-            return rng.end_cursor()
-        )
-
-        template<typename Rng>
-        static constexpr auto CPP_auto_fun(begin_adaptor)(Rng &rng)
-        (
-            return rng.begin_adaptor()
-        )
-        template<typename Rng>
-        static constexpr auto CPP_auto_fun(end_adaptor)(Rng &rng)
-        (
-            return rng.end_adaptor()
-        )
-
-        template<typename Cur>
-        static constexpr auto CPP_auto_fun(read)(Cur const &pos)
-        (
-            return pos.read()
-        )
-        template<typename Cur>
-        static constexpr auto CPP_auto_fun(arrow)(Cur const &pos)
-        (
-            return pos.arrow()
-        )
-        template<typename Cur>
-        static constexpr auto CPP_auto_fun(move)(Cur const &pos)
-        (
-            return pos.move()
-        )
-        template<typename Cur, typename T>
-        static constexpr auto CPP_auto_fun(write)(Cur &pos, T &&t)
-        (
-            return pos.write((T &&) t)
-        )
-        template<typename Cur>
-        static constexpr auto CPP_auto_fun(next)(Cur & pos)
-        (
-            return pos.next()
-        )
-        template<typename Cur, typename O>
-        static constexpr auto CPP_auto_fun(equal)(Cur const &pos, O const &other)
-        (
-            return pos.equal(other)
-        )
-        template<typename Cur>
-        static constexpr auto CPP_auto_fun(prev)(Cur & pos)
-        (
-            return pos.prev()
-        )
-        template<typename Cur, typename D>
-        static constexpr auto CPP_auto_fun(advance)(Cur & pos, D n)
-        (
-            return pos.advance(n)
-        )
-        template<typename Cur, typename O>
-        static constexpr auto CPP_auto_fun(distance_to)(Cur const &pos, O const &other)
-        (
-            return pos.distance_to(other)
-        )
-
-    private:
-        template<typename Cur>
-        using sized_cursor_difference_t = decltype(
-            range_access::distance_to(std::declval<Cur>(), std::declval<Cur>()));
-        // clang-format on
-
-        template<typename T>
-        static std::ptrdiff_t cursor_difference_2_(detail::ignore_t);
-        template<typename T>
-        static sized_cursor_difference_t<T> cursor_difference_2_(long);
-        template<typename T>
-        static typename T::difference_type cursor_difference_2_(int);
-
-        template<typename T>
-        using cursor_reference_t = decltype(std::declval<T const &>().read());
-
-        template<typename T>
-        static meta::id<uncvref_t<cursor_reference_t<T>>> cursor_value_2_(long);
-        template<typename T>
-        static meta::id<typename T::value_type> cursor_value_2_(int);
-
-#ifdef RANGES_WORKAROUND_CWG_1554
-        template<typename Cur>
-        struct cursor_difference
-        {
-            using type = decltype(range_access::cursor_difference_2_<Cur>(42));
-        };
-
-        template<typename Cur>
-        struct cursor_value : decltype(range_access::cursor_value_2_<Cur>(42))
-        {};
-#endif // RANGES_WORKAROUND_CWG_1554
-    public:
-#ifdef RANGES_WORKAROUND_CWG_1554
-        template<typename Cur>
-        using cursor_difference_t = meta::_t<cursor_difference<Cur>>;
-
-        template<typename Cur>
-        using cursor_value_t = meta::_t<cursor_value<Cur>>;
-#else  // ^^^ workaround ^^^ / vvv no workaround vvv
-        template<typename Cur>
-        using cursor_difference_t = decltype(range_access::cursor_difference_2_<Cur>(42));
-
-        template<typename Cur>
-        using cursor_value_t = meta::_t<decltype(range_access::cursor_value_2_<Cur>(42))>;
-#endif // RANGES_WORKAROUND_CWG_1554
-
-        template<typename Cur>
-        static constexpr Cur & pos(basic_iterator<Cur> & it) noexcept
-        {
-            return it.pos();
-        }
-        template<typename Cur>
-        static constexpr Cur const & pos(basic_iterator<Cur> const & it) noexcept
-        {
-            return it.pos();
-        }
-        template<typename Cur>
-        static constexpr Cur && pos(basic_iterator<Cur> && it) noexcept
-        {
-            return detail::move(it.pos());
-        }
-
-        template<typename Cur>
-        static constexpr Cur cursor(basic_iterator<Cur> it)
-        {
-            return std::move(it.pos());
-        }
-        /// endcond
-    };
-    /// @}
-
-    /// \cond
-    namespace detail
-    {
-        //
-        // Concepts that the range cursor must model
-        // clang-format off
-        //
-        template<typename T>
-        CPP_concept cursor =
-            semiregular<T> && semiregular<range_access::mixin_base_t<T>> &&
-            constructible_from<range_access::mixin_base_t<T>, T> &&
-            constructible_from<range_access::mixin_base_t<T>, T const &>;
-            // Axiom: mixin_base_t<T> has a member get(), accessible to derived classes,
-            //   which perfectly-returns the contained cursor object and does not throw
-            //   exceptions.
-
-        template<typename T>
-        CPP_requires(has_cursor_next_,
-            requires(T & t)
-            (
-                range_access::next(t)
-            ));
-        template<typename T>
-        CPP_concept has_cursor_next = CPP_requires_ref(detail::has_cursor_next_, T);
-
-        template<typename S, typename C>
-        CPP_requires(sentinel_for_cursor_,
-            requires(S & s, C & c) //
-            (
-                range_access::equal(c, s),
-                concepts::requires_<convertible_to<decltype(
-                    range_access::equal(c, s)), bool>>
-            ));
-        template<typename S, typename C>
-        CPP_concept sentinel_for_cursor =
-            semiregular<S> &&
-            cursor<C> &&
-            CPP_requires_ref(detail::sentinel_for_cursor_, S, C);
-
-        template<typename T>
-        CPP_requires(readable_cursor_,
-            requires(T & t) //
-            (
-                range_access::read(t)
-            ));
-        template<typename T>
-        CPP_concept readable_cursor = CPP_requires_ref(detail::readable_cursor_, T);
-
-        template<typename T>
-        CPP_requires(has_cursor_arrow_,
-            requires(T const & t) //
-            (
-                range_access::arrow(t)
-            ));
-        template<typename T>
-        CPP_concept has_cursor_arrow = CPP_requires_ref(detail::has_cursor_arrow_, T);
-
-        template<typename T, typename U>
-        CPP_requires(writable_cursor_,
-            requires(T & t, U && u) //
-            (
-                range_access::write(t, (U &&) u)
-            ));
-        template<typename T, typename U>
-        CPP_concept writable_cursor =
-            CPP_requires_ref(detail::writable_cursor_, T, U);
-
-        template<typename S, typename C>
-        CPP_requires(sized_sentinel_for_cursor_,
-            requires(S & s, C & c) //
-            (
-                range_access::distance_to(c, s),
-                concepts::requires_<signed_integer_like_<decltype(
-                    range_access::distance_to(c, s))>>
-            )
-        );
-        template<typename S, typename C>
-        CPP_concept sized_sentinel_for_cursor =
-            sentinel_for_cursor<S, C> &&
-            CPP_requires_ref(detail::sized_sentinel_for_cursor_, S, C);
-
-        template<typename T, typename U>
-        CPP_concept output_cursor =
-            writable_cursor<T, U> && cursor<T>;
-
-        template<typename T>
-        CPP_concept input_cursor =
-            readable_cursor<T> && cursor<T> && has_cursor_next<T>;
-
-        template<typename T>
-        CPP_concept forward_cursor =
-            input_cursor<T> && sentinel_for_cursor<T, T> &&
-            !range_access::single_pass_t<uncvref_t<T>>::value;
-
-        template<typename T>
-        CPP_requires(bidirectional_cursor_,
-            requires(T & t) //
-            (
-                range_access::prev(t)
-            ));
-        template<typename T>
-        CPP_concept bidirectional_cursor =
-            forward_cursor<T> &&
-            CPP_requires_ref(detail::bidirectional_cursor_, T);
-
-        template<typename T>
-        CPP_requires(random_access_cursor_,
-            requires(T & t) //
-            (
-                range_access::advance(t, range_access::distance_to(t, t))
-            ));
-        template<typename T>
-        CPP_concept random_access_cursor =
-            bidirectional_cursor<T> && //
-            sized_sentinel_for_cursor<T, T> && //
-            CPP_requires_ref(detail::random_access_cursor_, T);
-
-        template(class T)(
-            /// \pre
-            requires std::is_lvalue_reference<T>::value)
-        void is_lvalue_reference(T&&);
-
-        template<typename T>
-        CPP_requires(contiguous_cursor_,
-            requires(T & t) //
-            (
-                detail::is_lvalue_reference(range_access::read(t))
-            ));
-        template<typename T>
-        CPP_concept contiguous_cursor =
-            random_access_cursor<T> && //
-            range_access::contiguous_t<uncvref_t<T>>::value && //
-            CPP_requires_ref(detail::contiguous_cursor_, T);
-        // clang-format on
-
-        template<typename Cur, bool IsReadable>
-        RANGES_INLINE_VAR constexpr bool is_writable_cursor_ = true;
-
-        template<typename Cur>
-        RANGES_INLINE_VAR constexpr bool is_writable_cursor_<Cur, true> =
-            (bool) writable_cursor<Cur, range_access::cursor_value_t<Cur>>;
-
-        template<typename Cur>
-        RANGES_INLINE_VAR constexpr bool is_writable_cursor_v =
-            is_writable_cursor_<Cur, (bool)readable_cursor<Cur>>;
-    } // namespace detail
-    /// \endcond
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/detail/satisfy_boost_range.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/detail/satisfy_boost_range.hpp
deleted file mode 100644
index ef566a8a..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/detail/satisfy_boost_range.hpp
+++ /dev/null
@@ -1,87 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_DETAIL_SATISFY_BOOST_RANGE_HPP
-#define RANGES_V3_DETAIL_SATISFY_BOOST_RANGE_HPP
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-
-#ifndef RANGES_DOXYGEN_INVOKED
-namespace boost
-{
-    /// \brief Boost Range specialisation point, for making Boost ranges out of range-v3
-    /// views
-    template<typename T, typename U>
-    struct range_mutable_iterator;
-
-    /// \brief Boost Range specialisation point, for making Boost ranges out of range-v3
-    /// views
-    template<typename T, typename U>
-    struct range_const_iterator;
-
-    /// \brief Boost Range specialisation point, for making Boost ranges out of range-v3
-    /// views
-    template<typename T>
-    struct range_value;
-
-    /// \brief Boost Range specialisation point, for making Boost ranges out of range-v3
-    /// views
-    template<typename T>
-    struct range_size;
-} // namespace boost
-
-/// \brief Macro specialising Boost Range metafunctions for the specified view
-#define RANGES_SATISFY_BOOST_RANGE(view_name)                                           \
-    namespace boost                                                                     \
-    {                                                                                   \
-        template<typename... Ts>                                                        \
-        struct range_mutable_iterator<                                                  \
-            view_name<Ts...>,                                                           \
-            ::meta::if_c<(bool)::ranges::common_range<view_name<Ts...>>>>               \
-        {                                                                               \
-            using type = ::ranges::iterator_t<view_name<Ts...>>;                        \
-        };                                                                              \
-        template<typename... Ts>                                                        \
-        struct range_const_iterator<                                                    \
-            view_name<Ts...>,                                                           \
-            ::meta::if_c<(bool)::ranges::common_range<view_name<Ts...> const>>>         \
-        {                                                                               \
-            using type = ::ranges::iterator_t<view_name<Ts...> const>;                  \
-        };                                                                              \
-        template<typename... Ts>                                                        \
-        struct range_value<view_name<Ts...>>                                            \
-        {                                                                               \
-            using type = ::ranges::range_value_t<view_name<Ts...>>;                     \
-        };                                                                              \
-        template<typename... Ts>                                                        \
-        struct range_size<view_name<Ts...>>                                             \
-          : ::meta::if_c<(bool)::ranges::common_range<view_name<Ts...>>,                \
-                         ::meta::defer<::ranges::range_size_t, view_name<Ts...>>,       \
-                         ::meta::nil_>                                                  \
-        {};                                                                             \
-        template<typename... Ts>                                                        \
-        struct range_size<view_name<Ts...> const>                                       \
-          : ::meta::if_c<(bool)::ranges::common_range<view_name<Ts...> const>,          \
-                         ::meta::defer<::ranges::range_size_t, view_name<Ts...> const>, \
-                         ::meta::nil_>                                                  \
-        {};                                                                             \
-    }
-#else
-#define RANGES_SATISFY_BOOST_RANGE(view_name)
-#endif
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/detail/variant.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/detail/variant.hpp
deleted file mode 100644
index fef94d3f..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/detail/variant.hpp
+++ /dev/null
@@ -1,907 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_DETAIL_VARIANT_HPP
-#define RANGES_V3_DETAIL_VARIANT_HPP
-
-#include <iterator>
-#include <memory>
-#include <new>
-#include <stdexcept>
-#include <tuple>
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/compose.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/utility/get.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    template<std::size_t I>
-    struct emplaced_index_t;
-
-    template<std::size_t I>
-    struct emplaced_index_t : meta::size_t<I>
-    {};
-
-#if RANGES_CXX_INLINE_VARIABLES < RANGES_CXX_INLINE_VARIABLES_17
-    namespace
-    {
-        template<std::size_t I>
-        constexpr auto & emplaced_index = static_const<emplaced_index_t<I>>::value;
-    }
-#else  // RANGES_CXX_INLINE_VARIABLES >= RANGES_CXX_INLINE_VARIABLES_17
-    template<std::size_t I>
-    inline constexpr emplaced_index_t<I> emplaced_index{};
-#endif // RANGES_CXX_INLINE_VARIABLES
-
-    struct bad_variant_access : std::logic_error
-    {
-        explicit bad_variant_access(std::string const & what_arg)
-          : std::logic_error(what_arg)
-        {}
-        explicit bad_variant_access(char const * what_arg)
-          : std::logic_error(what_arg)
-        {}
-    };
-
-    template<typename T, std::size_t Index>
-    struct indexed_element
-    {
-    private:
-        std::add_pointer_t<T> t_;
-
-    public:
-        constexpr explicit indexed_element(T & t) noexcept
-          : t_(std::addressof(t))
-        {}
-        constexpr T & get() const noexcept
-        {
-            return *t_;
-        }
-    };
-    template<typename T, std::size_t Index>
-    struct indexed_element<T &&, Index>
-    {
-    private:
-        T * t_;
-
-    public:
-        constexpr explicit indexed_element(T && t) noexcept
-          : t_(std::addressof(t))
-        {}
-        constexpr T && get() const noexcept
-        {
-            return static_cast<T &&>(*t_);
-        }
-    };
-    template<std::size_t Index>
-    struct indexed_element<void, Index>
-    {
-        void get() const noexcept
-        {}
-    };
-
-    /// \cond
-    namespace detail
-    {
-        struct indexed_element_fn;
-
-        template(typename I, typename S, typename O)(
-            /// \pre
-            requires (!sized_sentinel_for<S, I>)) //
-        O uninitialized_copy(I first, S last, O out)
-        {
-            for(; first != last; ++first, ++out)
-                ::new((void *)std::addressof(*out)) iter_value_t<O>(*first);
-            return out;
-        }
-
-        template(typename I, typename S, typename O)(
-            /// \pre
-            requires sized_sentinel_for<S, I>)
-        O uninitialized_copy(I first, S last, O out)
-        {
-            return std::uninitialized_copy_n(first, (last - first), out);
-        }
-
-        template<typename I, typename O>
-        O uninitialized_copy(I first, I last, O out)
-        {
-            return std::uninitialized_copy(first, last, out);
-        }
-
-        template<typename T, typename Index>
-        struct indexed_datum
-        {
-        private:
-            template<typename, typename>
-            friend struct indexed_datum;
-            T datum_;
-
-        public:
-            CPP_member
-            constexpr CPP_ctor(indexed_datum)()(                          //
-                noexcept(std::is_nothrow_default_constructible<T>::value) //
-                    requires default_constructible<T>)
-              : datum_{}
-            {}
-            template(typename... Ts)(
-                /// \pre
-                requires constructible_from<T, Ts...> AND (sizeof...(Ts) != 0)) //
-            constexpr indexed_datum(Ts &&... ts) noexcept(
-                    std::is_nothrow_constructible<T, Ts...>::value)
-              : datum_(static_cast<Ts &&>(ts)...)
-            {}
-            template(typename U)(
-                /// \pre
-                requires (!same_as<T, U>) AND convertible_to<U, T>)
-            constexpr indexed_datum(indexed_datum<U, Index> that) //
-                noexcept(std::is_nothrow_constructible<T, U>::value) //
-              : datum_(std::move(that.datum_))
-            {}
-            constexpr auto ref() noexcept
-            {
-                return indexed_element<T, Index::value>{datum_};
-            }
-            constexpr auto ref() const noexcept
-            {
-                return indexed_element<T const, Index::value>{datum_};
-            }
-            constexpr T & get() noexcept
-            {
-                return datum_;
-            }
-            constexpr T const & get() const noexcept
-            {
-                return datum_;
-            }
-        };
-
-        template<typename T, std::size_t N, typename Index>
-        struct indexed_datum<T[N], Index>;
-
-        template<typename T, typename Index>
-        struct indexed_datum<T &, Index>
-        {
-        private:
-            template<typename, typename>
-            friend struct indexed_datum;
-            T * t_;
-
-        public:
-            constexpr indexed_datum(T & t) noexcept
-              : t_(std::addressof(t))
-            {}
-            constexpr T & get() const noexcept
-            {
-                return *t_;
-            }
-            constexpr auto ref() const noexcept
-            {
-                return indexed_element<T &, Index::value>{*t_};
-            }
-        };
-        template<typename T, typename Index>
-        struct indexed_datum<T &&, Index>
-        {
-        private:
-            template<typename, typename>
-            friend struct indexed_datum;
-            T * t_;
-
-        public:
-            constexpr indexed_datum(T && t) noexcept
-              : t_(std::addressof(t))
-            {}
-            constexpr T && get() const noexcept
-            {
-                return static_cast<T &&>(*t_);
-            }
-            constexpr auto ref() const noexcept
-            {
-                return indexed_element<T &&, Index::value>{static_cast<T &&>(*t_)};
-            }
-        };
-        template<typename Index>
-        struct indexed_datum<void, Index>
-        {
-            void get() const noexcept
-            {}
-            constexpr indexed_element<void, Index::value> ref() const noexcept
-            {
-                return {};
-            }
-        };
-
-        template<std::size_t Index, typename... Ts>
-        using variant_datum_t =
-            detail::indexed_datum<meta::at_c<meta::list<Ts...>, Index>,
-                                  meta::size_t<Index>>;
-
-        using variant_nil = indexed_datum<void, meta::npos>;
-
-        template<typename Ts,
-                 bool Trivial = meta::apply<
-                     meta::quote<meta::and_>,
-                     meta::transform<Ts, meta::quote<std::is_trivially_destructible>>>::
-                     type::value>
-        struct variant_data_
-        {
-            using type = indexed_datum<void, meta::npos>;
-        };
-
-        template<typename T, typename... Ts>
-        struct variant_data_<meta::list<T, Ts...>, true>
-        {
-            struct type
-            {
-                using head_t = T;
-                using tail_t = meta::_t<variant_data_<meta::list<Ts...>>>;
-                union
-                {
-                    head_t head;
-                    tail_t tail;
-                };
-
-                type() noexcept
-                {}
-                template<typename... Args>
-                constexpr type(meta::size_t<0>, Args &&... args) noexcept(
-                    std::is_nothrow_constructible<head_t, Args...>::value)
-                  : head{((Args &&) args)...}
-                {}
-                template<std::size_t N, typename... Args>
-                constexpr type(meta::size_t<N>, Args &&... args) noexcept(
-                    std::is_nothrow_constructible<tail_t, meta::size_t<N - 1>,
-                                                  Args...>::value)
-                  : tail{meta::size_t<N - 1>{}, ((Args &&) args)...}
-                {}
-            };
-        };
-
-        template<typename T, typename... Ts>
-        struct variant_data_<meta::list<T, Ts...>, false>
-        {
-            struct type
-            {
-                using head_t = T;
-                using tail_t = meta::_t<variant_data_<meta::list<Ts...>>>;
-                union
-                {
-                    head_t head;
-                    tail_t tail;
-                };
-
-                type() noexcept
-                {}
-                ~type()
-                {}
-                template<typename... Args>
-                constexpr type(meta::size_t<0>, Args &&... args) noexcept(
-                    std::is_nothrow_constructible<head_t, Args...>::value)
-                  : head{((Args &&) args)...}
-                {}
-                template<std::size_t N, typename... Args>
-                constexpr type(meta::size_t<N>, Args &&... args) noexcept(
-                    std::is_nothrow_constructible<tail_t, meta::size_t<N - 1>,
-                                                  Args...>::value)
-                  : tail{meta::size_t<N - 1>{}, ((Args &&) args)...}
-                {}
-            };
-        };
-
-        template<typename... Ts>
-        using variant_data = meta::_t<variant_data_<meta::transform<
-            meta::list<Ts...>, meta::as_list<meta::make_index_sequence<sizeof...(Ts)>>,
-            meta::quote<indexed_datum>>>>;
-
-        inline std::size_t variant_move_copy_(std::size_t, variant_nil, variant_nil)
-        {
-            return 0;
-        }
-        template<typename Data0, typename Data1>
-        std::size_t variant_move_copy_(std::size_t n, Data0 & self, Data1 && that)
-        {
-            using Head = typename Data0::head_t;
-            return 0 == n
-                       ? ((void)::new((void *)&self.head) Head(((Data1 &&) that).head), 0)
-                       : variant_move_copy_(n - 1, self.tail, ((Data1 &&) that).tail) + 1;
-        }
-        constexpr bool variant_equal_(std::size_t, variant_nil, variant_nil)
-        {
-            return true;
-        }
-        template<typename Data0, typename Data1>
-        constexpr bool variant_equal_(std::size_t n, Data0 const & self,
-                                      Data1 const & that)
-        {
-            return n == 0 ? self.head.get() == that.head.get()
-                          : variant_equal_(n - 1, self.tail, that.tail);
-        }
-        template<typename Fun, typename Proj = indexed_element_fn>
-        constexpr int variant_visit_(std::size_t, variant_nil, Fun, Proj = {})
-        {
-            return (RANGES_EXPECT(false), 0);
-        }
-        template<typename Data, typename Fun, typename Proj = indexed_element_fn>
-        constexpr int variant_visit_(std::size_t n, Data & self, Fun fun, Proj proj = {})
-        {
-            return 0 == n ? ((void)invoke(fun, invoke(proj, self.head)), 0)
-                          : detail::variant_visit_(
-                                n - 1, self.tail, detail::move(fun), detail::move(proj));
-        }
-
-        struct get_datum_fn
-        {
-            template<typename T>
-            decltype(auto) operator()(T && t) const noexcept
-            {
-                return t.get();
-            }
-        };
-
-        struct indexed_element_fn
-        {
-            template<typename T>
-            decltype(auto) operator()(T && t) const noexcept
-            {
-                return t.ref();
-            }
-        };
-
-        struct empty_variant_tag
-        {};
-
-        struct variant_core_access
-        {
-            template<typename... Ts>
-            static constexpr variant_data<Ts...> & data(variant<Ts...> & var) noexcept
-            {
-                return var.data_();
-            }
-            template<typename... Ts>
-            static constexpr variant_data<Ts...> const & data(
-                variant<Ts...> const & var) noexcept
-            {
-                return var.data_();
-            }
-            template<typename... Ts>
-            static constexpr variant_data<Ts...> && data(variant<Ts...> && var) noexcept
-            {
-                return detail::move(var.data_());
-            }
-            template<typename... Ts>
-            static variant<Ts...> make_empty(meta::id<variant<Ts...>> = {}) noexcept
-            {
-                return variant<Ts...>{empty_variant_tag{}};
-            }
-        };
-
-        struct delete_fn
-        {
-            template<typename T>
-            void operator()(T const & t) const noexcept
-            {
-                t.~T();
-            }
-        };
-
-        template<std::size_t N, typename... Ts>
-        struct construct_fn
-        {
-            std::tuple<Ts...> args_;
-
-            template<typename U, std::size_t... Is>
-            void construct_(U & u, meta::index_sequence<Is...>) noexcept(
-                std::is_nothrow_constructible<U, Ts...>::value)
-            {
-                ::new((void *)std::addressof(u))
-                    U(static_cast<Ts &&>(std::get<Is>(args_))...);
-            }
-
-            construct_fn(Ts &&... ts) noexcept(
-                std::is_nothrow_constructible<std::tuple<Ts...>, Ts...>::value)
-              : args_{static_cast<Ts &&>(ts)...}
-            {}
-            template<typename U, std::size_t M>
-            [[noreturn]] meta::if_c<N != M> operator()(
-                indexed_datum<U, meta::size_t<M>> &) noexcept
-            {
-                RANGES_EXPECT(false);
-            }
-            template<typename U>
-            meta::if_<std::is_object<U>> operator()(
-                indexed_datum<U, meta::size_t<N>> &
-                    u) noexcept(std::is_nothrow_constructible<U, Ts...>::value)
-            {
-                this->construct_(u.get(), meta::make_index_sequence<sizeof...(Ts)>{});
-            }
-            template<typename U>
-            meta::if_<meta::not_<std::is_object<U>>> operator()(
-                indexed_datum<U, meta::size_t<N>> &
-                    u) noexcept(std::is_nothrow_constructible<detail::decay_t<U>,
-                                                              Ts...>::value)
-            {
-                this->construct_(u, meta::make_index_sequence<sizeof...(Ts)>{});
-            }
-        };
-
-        template<typename T, std::size_t N>
-        struct get_fn
-        {
-            T ** t_;
-
-            template<typename U, std::size_t M>
-            [[noreturn]] meta::if_c<M != N> operator()(indexed_element<U, M>) const
-            {
-                throw bad_variant_access("bad variant access");
-            }
-            template<typename U>
-            void operator()(indexed_element<U, N> t) const noexcept
-            {
-                *t_ = std::addressof(t.get());
-            }
-            template<typename U>
-            void operator()(indexed_element<U &&, N> t) const noexcept
-            {
-                U && u = t.get();
-                *t_ = std::addressof(u);
-            }
-            void operator()(indexed_element<void, N>) const noexcept
-            {}
-        };
-
-        template<typename Variant, std::size_t N>
-        struct emplace_fn
-        {
-            Variant * var_;
-            // clang-format off
-            template<typename...Ts>
-            auto CPP_auto_fun(operator())(Ts &&...ts) (const)
-            (
-                return var_->template emplace<N>(static_cast<Ts &&>(ts)...)
-            )
-            // clang-format on
-        };
-
-        template<typename Fun, typename Variant>
-        struct variant_visitor
-        {
-            Fun fun_;
-            Variant * var_;
-
-            // clang-format off
-            template<typename U, std::size_t N>
-            auto CPP_auto_fun(operator())(indexed_element<U, N> u)
-            (
-                return compose(emplace_fn<Variant, N>{var_}, fun_)(u)
-            )
-            // clang-format on
-        };
-
-        template<typename Variant, typename Fun>
-        variant_visitor<Fun, Variant> make_variant_visitor(
-            Variant & var,
-            Fun fun) noexcept(std::is_nothrow_move_constructible<Fun>::value)
-        {
-            return {detail::move(fun), &var};
-        }
-
-        template<typename To, typename From>
-        struct unique_visitor;
-
-        template<typename... To, typename... From>
-        struct unique_visitor<variant<To...>, variant<From...>>
-        {
-            variant<To...> * var_;
-
-            template<typename T, std::size_t N>
-            void operator()(indexed_element<T, N> t) const
-            {
-                using E = meta::at_c<meta::list<From...>, N>;
-                static_assert(RANGES_IS_SAME(T const, E const),
-                              "Is indexed_element broken?");
-                using F = meta::find<meta::list<To...>, E>;
-                static constexpr std::size_t M = sizeof...(To) - F::size();
-                compose(emplace_fn<variant<To...>, M>{var_}, get_datum_fn{})(t);
-            }
-        };
-
-        template<typename T>
-        constexpr T & variant_deref_(T * t) noexcept
-        {
-            return *t;
-        }
-        inline void variant_deref_(void const volatile *) noexcept
-        {}
-
-        template<typename Variant>
-        struct variant_get
-        {
-            //////////////////////////////////////////////////////////////////////////////
-            // get
-            template<std::size_t N>
-            friend meta::_t<
-                std::add_lvalue_reference<meta::at_c<meta::as_list<Variant>, N>>>
-            get(Variant & var)
-            {
-                using elem_t = meta::_t<
-                    std::remove_reference<meta::at_c<meta::as_list<Variant>, N>>>;
-                elem_t * elem = nullptr;
-                auto & data_var = detail::variant_core_access::data(var);
-                detail::variant_visit_(
-                    var.index(), data_var, detail::get_fn<elem_t, N>{&elem});
-                return detail::variant_deref_(elem);
-            }
-            template<std::size_t N>
-            friend meta::_t<
-                std::add_lvalue_reference<meta::at_c<meta::as_list<Variant>, N> const>>
-            get(Variant const & var)
-            {
-                using elem_t = meta::_t<
-                    std::remove_reference<meta::at_c<meta::as_list<Variant>, N> const>>;
-                elem_t * elem = nullptr;
-                auto & data_var = detail::variant_core_access::data(var);
-                detail::variant_visit_(
-                    var.index(), data_var, detail::get_fn<elem_t, N>{&elem});
-                return detail::variant_deref_(elem);
-            }
-            template<std::size_t N>
-            friend meta::_t<
-                std::add_rvalue_reference<meta::at_c<meta::as_list<Variant>, N>>>
-            get(Variant && var)
-            {
-                using elem_t = meta::_t<
-                    std::remove_reference<meta::at_c<meta::as_list<Variant>, N>>>;
-                elem_t * elem = nullptr;
-                auto & data_var = detail::variant_core_access::data(var);
-                detail::variant_visit_(
-                    var.index(), data_var, detail::get_fn<elem_t, N>{&elem});
-                using res_t = meta::_t<
-                    std::add_rvalue_reference<meta::at_c<meta::as_list<Variant>, N>>>;
-                return static_cast<res_t>(detail::variant_deref_(elem));
-            }
-        };
-
-        template<typename Variant,
-                 bool Trivial = std::is_trivially_destructible<meta::apply<
-                     meta::quote<variant_data>, meta::as_list<Variant>>>::value>
-        struct variant_base : variant_get<Variant>
-        {
-            ~variant_base()
-            {
-                static_cast<Variant *>(this)->clear_();
-            }
-        };
-        template<typename... Ts>
-        struct variant_base<variant<Ts...>, true> : variant_get<variant<Ts...>>
-        {};
-
-        template<typename Fun, typename Types, typename Indices, typename = void>
-        struct variant_visit_results
-        {};
-        template<typename Fun, typename... Ts, std::size_t... Is>
-        struct variant_visit_results<
-            Fun, meta::list<Ts...>, meta::index_sequence<Is...>,
-            meta::void_<invoke_result_t<Fun &, indexed_element<Ts, Is>>...>>
-        {
-            using type = variant<invoke_result_t<Fun &, indexed_element<Ts, Is>>...>;
-        };
-        template<typename Fun, typename... Ts>
-        using variant_visit_results_t =
-            meta::_t<variant_visit_results<Fun, meta::list<Ts...>,
-                                           meta::make_index_sequence<sizeof...(Ts)>>>;
-    } // namespace detail
-    /// \endcond
-
-    /// \addtogroup group-utility
-    /// @{
-    template<typename... Ts>
-    struct variant
-      : private detail::variant_data<Ts...>
-      , private detail::variant_base<variant<Ts...>>
-    {
-    private:
-        friend detail::variant_core_access;
-        template<typename...>
-        friend struct variant;
-        friend detail::variant_base<variant, false>;
-        template<std::size_t Index>
-        using datum_t = detail::variant_datum_t<Index, Ts...>;
-        template<typename T>
-        using add_const_t = meta::if_<std::is_void<T>, void, T const>;
-        using unbox_fn = detail::get_datum_fn;
-
-        detail::variant_data<Ts...> & data_() & noexcept
-        {
-            return *this;
-        }
-        detail::variant_data<Ts...> const & data_() const & noexcept
-        {
-            return *this;
-        }
-        detail::variant_data<Ts...> && data_() && noexcept
-        {
-            return static_cast<detail::variant_data<Ts...> &&>(*this);
-        }
-
-        std::size_t index_;
-
-        void clear_() noexcept
-        {
-            if(valid())
-            {
-                detail::variant_visit_(index_, data_(), detail::delete_fn{}, identity{});
-                index_ = (std::size_t)-1;
-            }
-        }
-        template<typename That>
-        void assign_(That && that)
-        {
-            if(that.valid())
-                index_ = detail::variant_move_copy_(
-                    that.index_, data_(), ((That &&) that).data_());
-        }
-        constexpr variant(detail::empty_variant_tag) noexcept
-          : detail::variant_data<Ts...>{}
-          , index_((std::size_t)-1)
-        {}
-        template(typename... Args)(
-            /// \pre
-            requires (sizeof...(Args) == sizeof...(Ts))) //
-        static constexpr bool all_convertible_to(int) noexcept
-        {
-            return and_v<convertible_to<Args, Ts>...>;
-        }
-        template<typename... Args>
-        static constexpr bool all_convertible_to(long) noexcept
-        {
-            return false;
-        }
-
-    public:
-        CPP_member
-        constexpr CPP_ctor(variant)()(                                         //
-            noexcept(std::is_nothrow_default_constructible<datum_t<0>>::value) //
-                requires default_constructible<datum_t<0>>)
-          : variant{emplaced_index<0>}
-        {}
-        template(std::size_t N, typename... Args)(
-            /// \pre
-            requires constructible_from<datum_t<N>, Args...>)
-            constexpr variant(emplaced_index_t<N>, Args &&... args) noexcept(
-                std::is_nothrow_constructible<datum_t<N>, Args...>::value)
-          : detail::variant_data<Ts...>{meta::size_t<N>{}, static_cast<Args &&>(args)...}
-          , index_(N)
-        {}
-        template(std::size_t N, typename T, typename... Args)(
-            /// \pre
-            requires constructible_from<datum_t<N>, std::initializer_list<T> &,
-                                        Args...>)
-            constexpr variant(
-                emplaced_index_t<N>, std::initializer_list<T> il,
-                Args &&... args) noexcept(std::
-                                              is_nothrow_constructible<
-                                                  datum_t<N>, std::initializer_list<T> &,
-                                                  Args...>::value)
-          : detail::variant_data<Ts...>{meta::size_t<N>{},
-                                        il,
-                                        static_cast<Args &&>(args)...}
-          , index_(N)
-        {}
-        template(std::size_t N)(
-            /// \pre
-            requires constructible_from<datum_t<N>, meta::nil_>)
-        constexpr variant(emplaced_index_t<N>, meta::nil_)
-            noexcept(std::is_nothrow_constructible<datum_t<N>, meta::nil_>::value)
-          : detail::variant_data<Ts...>{meta::size_t<N>{}, meta::nil_{}}
-          , index_(N)
-        {}
-        variant(variant && that)
-          : detail::variant_data<Ts...>{}
-          , index_(detail::variant_move_copy_(that.index(), data_(),
-                                              std::move(that.data_())))
-        {}
-        variant(variant const & that)
-          : detail::variant_data<Ts...>{}
-          , index_(detail::variant_move_copy_(that.index(), data_(), that.data_()))
-        {}
-        template(typename... Args)(
-            /// \pre
-            requires (!same_as<variant<Args...>, variant>) AND
-            (all_convertible_to<Args...>(0))) //
-        variant(variant<Args...> that)
-          : detail::variant_data<Ts...>{}
-          , index_(detail::variant_move_copy_(that.index(), data_(),
-                                              std::move(that.data_())))
-        {}
-        variant & operator=(variant && that)
-        {
-            // TODO do a simple move assign when index()==that.index()
-            this->clear_();
-            this->assign_(detail::move(that));
-            return *this;
-        }
-        variant & operator=(variant const & that)
-        {
-            // TODO do a simple copy assign when index()==that.index()
-            this->clear_();
-            this->assign_(that);
-            return *this;
-        }
-        template(typename... Args)(
-            /// \pre
-            requires (!same_as<variant<Args...>, variant>) AND
-            (all_convertible_to<Args...>(0)))
-        variant & operator=(variant<Args...> that)
-        {
-            // TODO do a simple copy assign when index()==that.index() //
-            this->clear_();
-            this->assign_(that);
-            return *this;
-        }
-        static constexpr std::size_t size() noexcept
-        {
-            return sizeof...(Ts);
-        }
-        template(std::size_t N, typename... Args)(
-            /// \pre
-            requires constructible_from<datum_t<N>, Args...>)
-        void emplace(Args &&... args)
-        {
-            this->clear_();
-            detail::construct_fn<N, Args &&...> fn{static_cast<Args &&>(args)...};
-            detail::variant_visit_(N, data_(), std::ref(fn), identity{});
-            index_ = N;
-        }
-        constexpr bool valid() const noexcept
-        {
-            return index() != (std::size_t)-1;
-        }
-        constexpr std::size_t index() const noexcept
-        {
-            return index_;
-        }
-        template<typename Fun>
-        detail::variant_visit_results_t<composed<Fun, unbox_fn>, Ts...> visit(Fun fun)
-        {
-            detail::variant_visit_results_t<composed<Fun, unbox_fn>, Ts...> res{
-                detail::empty_variant_tag{}};
-            detail::variant_visit_(index_,
-                                   data_(),
-                                   detail::make_variant_visitor(
-                                       res, compose(detail::move(fun), unbox_fn{})));
-            return res;
-        }
-        template<typename Fun>
-        detail::variant_visit_results_t<composed<Fun, unbox_fn>, add_const_t<Ts>...>
-        visit(Fun fun) const
-        {
-            detail::variant_visit_results_t<composed<Fun, unbox_fn>, add_const_t<Ts>...>
-                res{detail::empty_variant_tag{}};
-            detail::variant_visit_(index_,
-                                   data_(),
-                                   detail::make_variant_visitor(
-                                       res, compose(detail::move(fun), unbox_fn{})));
-            return res;
-        }
-        template<typename Fun>
-        detail::variant_visit_results_t<Fun, Ts...> visit_i(Fun fun)
-        {
-            detail::variant_visit_results_t<Fun, Ts...> res{detail::empty_variant_tag{}};
-            detail::variant_visit_(
-                index_, data_(), detail::make_variant_visitor(res, detail::move(fun)));
-            return res;
-        }
-        template<typename Fun>
-        detail::variant_visit_results_t<Fun, add_const_t<Ts>...> visit_i(Fun fun) const
-        {
-            detail::variant_visit_results_t<Fun, add_const_t<Ts>...> res{
-                detail::empty_variant_tag{}};
-            detail::variant_visit_(
-                index_, data_(), detail::make_variant_visitor(res, detail::move(fun)));
-            return res;
-        }
-    };
-
-    template(typename... Ts, typename... Us)(
-        /// \pre
-        requires and_v<equality_comparable_with<Ts, Us>...>)
-    bool operator==(variant<Ts...> const & lhs, variant<Us...> const & rhs)
-    {
-        return (!lhs.valid() && !rhs.valid()) ||
-               (lhs.index() == rhs.index() &&
-                detail::variant_equal_(lhs.index(),
-                                       detail::variant_core_access::data(lhs),
-                                       detail::variant_core_access::data(rhs)));
-    }
-
-    template(typename... Ts, typename... Us)(
-        /// \pre
-        requires and_v<equality_comparable_with<Ts, Us>...>)
-    bool operator!=(variant<Ts...> const & lhs, variant<Us...> const & rhs)
-    {
-        return !(lhs == rhs);
-    }
-
-    //////////////////////////////////////////////////////////////////////////////////////
-    // emplace
-    template(std::size_t N, typename... Ts, typename... Args)(
-        /// \pre
-        requires constructible_from<detail::variant_datum_t<N, Ts...>, Args...>)
-    void emplace(variant<Ts...> & var, Args &&... args)
-    {
-        var.template emplace<N>(static_cast<Args &&>(args)...);
-    }
-
-    //////////////////////////////////////////////////////////////////////////////////////
-    // variant_unique
-    template<typename Var>
-    struct variant_unique
-    {};
-
-    template<typename... Ts>
-    struct variant_unique<variant<Ts...>>
-    {
-        using type = meta::apply<meta::quote<variant>, meta::unique<meta::list<Ts...>>>;
-    };
-
-    template<typename Var>
-    using variant_unique_t = meta::_t<variant_unique<Var>>;
-
-    //////////////////////////////////////////////////////////////////////////////////////
-    // unique_variant
-    template<typename... Ts>
-    variant_unique_t<variant<Ts...>> unique_variant(variant<Ts...> const & var)
-    {
-        using From = variant<Ts...>;
-        using To = variant_unique_t<From>;
-        auto res = detail::variant_core_access::make_empty(meta::id<To>{});
-        var.visit_i(detail::unique_visitor<To, From>{&res});
-        RANGES_EXPECT(res.valid());
-        return res;
-    }
-    /// @}
-} // namespace ranges
-
-RANGES_DIAGNOSTIC_PUSH
-RANGES_DIAGNOSTIC_IGNORE_MISMATCHED_TAGS
-
-namespace std
-{
-    template<typename... Ts>
-    struct tuple_size<::ranges::variant<Ts...>> : tuple_size<tuple<Ts...>>
-    {};
-
-    template<size_t I, typename... Ts>
-    struct tuple_element<I, ::ranges::variant<Ts...>> : tuple_element<I, tuple<Ts...>>
-    {};
-} // namespace std
-
-RANGES_DIAGNOSTIC_POP
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/detail/with_braced_init_args.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/detail/with_braced_init_args.hpp
deleted file mode 100644
index 28c684c2..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/detail/with_braced_init_args.hpp
+++ /dev/null
@@ -1,83 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_DETAIL_WITH_BRACED_INIT_ARGS_HPP
-#define RANGES_V3_DETAIL_WITH_BRACED_INIT_ARGS_HPP
-
-#include <initializer_list>
-
-#include <range/v3/functional/invoke.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        // Accepts initializer_lists as either the first or second parameter, or both,
-        // and forwards on to an implementation.
-        template<typename ImplFn>
-        struct with_braced_init_args : ImplFn
-        {
-        private:
-            constexpr ImplFn const & base() const
-            {
-                return *this;
-            }
-
-        public:
-            using ImplFn::operator();
-
-            template<typename V0, typename... Args>
-            constexpr invoke_result_t<ImplFn const &, std::initializer_list<V0>, Args...>
-            operator()(std::initializer_list<V0> && rng0, Args &&... args) const
-            {
-                return base()(static_cast<std::initializer_list<V0> &&>(rng0),
-                              static_cast<Args &&>(args)...);
-            }
-            /// \overload
-            template<typename Rng0, typename V1, typename... Args>
-            constexpr invoke_result_t<ImplFn const &,
-                                      Rng0,
-                                      std::initializer_list<V1>,
-                                      Args...> //
-            operator()(Rng0 && rng0, std::initializer_list<V1> && rng1, Args &&... args)
-                const
-            {
-                return base()( //
-                    static_cast<Rng0 &&>(rng0),
-                    static_cast<std::initializer_list<V1> &&>(rng1),
-                    static_cast<Args &&>(args)...);
-            }
-            /// \overload
-            template<typename V0, typename V1, typename... Args>
-            constexpr invoke_result_t<ImplFn const &,
-                                      std::initializer_list<V0>,
-                                      std::initializer_list<V1>,
-                                      Args...>
-            operator()(std::initializer_list<V0> && rng0,
-                       std::initializer_list<V1> && rng1,
-                       Args &&... args) const
-            {
-                return base()( //
-                    static_cast<std::initializer_list<V0> &&>(rng0),
-                    static_cast<std::initializer_list<V1> &&>(rng1),
-                    static_cast<Args &&>(args)...);
-            }
-        };
-    } // namespace detail
-    /// \endcond
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/distance.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/distance.hpp
deleted file mode 100644
index 6ea8e731..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/distance.hpp
+++ /dev/null
@@ -1,24 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Michel Morin 2014
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_DISTANCE_HPP
-#define RANGES_V3_DISTANCE_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated. Please #include <range/v3/iterator/operations.hpp> "
-    "instead.")
-
-#include <range/v3/iterator/operations.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/empty.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/empty.hpp
deleted file mode 100644
index c23c1a8b..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/empty.hpp
+++ /dev/null
@@ -1,22 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_EMPTY_HPP
-#define RANGES_V3_EMPTY_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated. Please #include <range/v3/range/primitives.hpp> instead.")
-
-#include <range/v3/range/primitives.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/experimental/utility/generator.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/experimental/utility/generator.hpp
deleted file mode 100644
index 4d798a90..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/experimental/utility/generator.hpp
+++ /dev/null
@@ -1,369 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Casey Carter 2017
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_EXPERIMENTAL_UTILITY_GENERATOR_HPP
-#define RANGES_V3_EXPERIMENTAL_UTILITY_GENERATOR_HPP
-
-#include <range/v3/detail/config.hpp>
-#if RANGES_CXX_COROUTINES >= RANGES_CXX_COROUTINES_TS1
-#include <atomic>
-#include <cstddef>
-#include <exception>
-#include RANGES_COROUTINES_HEADER
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/default_sentinel.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/box.hpp>
-#include <range/v3/utility/semiregular_box.hpp>
-#include <range/v3/utility/swap.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/facade.hpp>
-
-#if defined(_MSC_VER) && !defined(RANGES_SILENCE_COROUTINE_WARNING)
-#ifdef __clang__
-#pragma message(                                                 \
-    "DANGER: clang doesn't (yet?) grok the MSVC coroutine ABI. " \
-    "Use at your own risk. "                                     \
-    "(RANGES_SILENCE_COROUTINE_WARNING will silence this message.)")
-#elif defined RANGES_WORKAROUND_MSVC_835948
-#pragma message(                                                                 \
-    "DANGER: ranges::experimental::generator is fine, but this "                 \
-    "version of MSVC likely miscompiles ranges::experimental::sized_generator. " \
-    "Use the latter at your own risk. "                                          \
-    "(RANGES_SILENCE_COROUTINE_WARNING will silence this message.)")
-#endif
-#endif // RANGES_SILENCE_COROUTINE_WARNINGS
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-view
-    /// @{
-    namespace experimental
-    {
-        // The type of size() for a sized_generator
-        using generator_size_t = std::size_t;
-
-        // Type upon which to co_await to set the size of a sized_generator
-        enum struct generator_size : generator_size_t
-        {
-            invalid = ~generator_size_t(0)
-        };
-
-        template<typename Promise = void>
-        struct RANGES_EMPTY_BASES coroutine_owner;
-
-        class enable_coroutine_owner
-        {
-            template<class>
-            friend struct coroutine_owner;
-            std::atomic<unsigned int> refcount_{1};
-        };
-    } // namespace experimental
-
-    /// \cond
-    namespace detail
-    {
-        inline void resume(RANGES_COROUTINES_NS::coroutine_handle<> coro)
-        {
-            // Pre: coro refers to a suspended coroutine.
-            RANGES_EXPECT(coro);
-            RANGES_EXPECT(!coro.done());
-            coro.resume();
-        }
-
-        namespace coroutine_owner_
-        {
-            struct adl_hook
-            {};
-
-            template<typename Promise>
-            void swap(experimental::coroutine_owner<Promise> & x,
-                      experimental::coroutine_owner<Promise> & y) noexcept
-            {
-                x.swap(y);
-            }
-        } // namespace coroutine_owner_
-    }     // namespace detail
-    /// \endcond
-
-    namespace experimental
-    {
-        // An owning coroutine_handle
-        template<typename Promise>
-        struct RANGES_EMPTY_BASES coroutine_owner
-          : private RANGES_COROUTINES_NS::coroutine_handle<Promise>
-          , private detail::coroutine_owner_::adl_hook
-        {
-            CPP_assert(derived_from<Promise, enable_coroutine_owner>);
-            using base_t = RANGES_COROUTINES_NS::coroutine_handle<Promise>;
-
-            using base_t::operator bool;
-            using base_t::done;
-            using base_t::promise;
-
-            coroutine_owner() = default;
-            constexpr explicit coroutine_owner(base_t coro) noexcept
-              : base_t(coro)
-            {}
-            coroutine_owner(coroutine_owner && that) noexcept
-              : base_t(ranges::exchange(that.base(), {}))
-              , copied_(that.copied_.load(std::memory_order_relaxed))
-            {}
-            coroutine_owner(coroutine_owner const & that) noexcept
-              : base_t(that.handle())
-              , copied_(that.handle() != nullptr)
-            {
-                if(*this)
-                {
-                    that.copied_.store(true, std::memory_order_relaxed);
-                    base().promise().refcount_.fetch_add(1, std::memory_order_relaxed);
-                }
-            }
-            ~coroutine_owner()
-            {
-                if(base() && (!copied_.load(std::memory_order_relaxed) ||
-                              1 == base().promise().refcount_.fetch_sub(
-                                       1, std::memory_order_acq_rel)))
-                    base().destroy();
-            }
-            coroutine_owner & operator=(coroutine_owner that) noexcept
-            {
-                swap(that);
-                return *this;
-            }
-            void resume()
-            {
-                detail::resume(handle());
-            }
-            void operator()()
-            {
-                detail::resume(handle());
-            }
-            void swap(coroutine_owner & that) noexcept
-            {
-                bool tmp = copied_.load(std::memory_order_relaxed);
-                copied_.store(that.copied_.load(std::memory_order_relaxed),
-                              std::memory_order_relaxed);
-                that.copied_.store(tmp, std::memory_order_relaxed);
-                std::swap(base(), that.base());
-            }
-            base_t handle() const noexcept
-            {
-                return *this;
-            }
-
-        private:
-            mutable std::atomic<bool> copied_{false};
-
-            base_t & base() noexcept
-            {
-                return *this;
-            }
-        };
-    } // namespace experimental
-
-    /// \cond
-    namespace detail
-    {
-        template<typename Reference>
-        struct generator_promise : experimental::enable_coroutine_owner
-        {
-            std::exception_ptr except_ = nullptr;
-
-            CPP_assert(std::is_reference<Reference>::value ||
-                       copy_constructible<Reference>);
-
-            generator_promise * get_return_object() noexcept
-            {
-                return this;
-            }
-            RANGES_COROUTINES_NS::suspend_always initial_suspend() const noexcept
-            {
-                return {};
-            }
-            RANGES_COROUTINES_NS::suspend_always final_suspend() const noexcept
-            {
-                return {};
-            }
-            void return_void() const noexcept
-            {}
-            void unhandled_exception() noexcept
-            {
-                except_ = std::current_exception();
-                RANGES_EXPECT(except_);
-            }
-            template(typename Arg)(
-                /// \pre
-                requires convertible_to<Arg, Reference> AND
-                        std::is_assignable<semiregular_box_t<Reference> &, Arg>::value) //
-            RANGES_COROUTINES_NS::suspend_always yield_value(Arg && arg) noexcept(
-                std::is_nothrow_assignable<semiregular_box_t<Reference> &, Arg>::value)
-            {
-                ref_ = std::forward<Arg>(arg);
-                return {};
-            }
-            RANGES_COROUTINES_NS::suspend_never await_transform(
-                experimental::generator_size) const noexcept
-            {
-                RANGES_ENSURE_MSG(false,
-                                  "Invalid size request for a non-sized generator");
-                return {};
-            }
-            meta::if_<std::is_reference<Reference>, Reference, Reference const &> read()
-                const noexcept
-            {
-                return ref_;
-            }
-
-        private:
-            semiregular_box_t<Reference> ref_;
-        };
-
-        template<typename Reference>
-        struct sized_generator_promise : generator_promise<Reference>
-        {
-            sized_generator_promise * get_return_object() noexcept
-            {
-                return this;
-            }
-            RANGES_COROUTINES_NS::suspend_never initial_suspend() const noexcept
-            {
-                // sized_generator doesn't suspend at its initial suspend point because...
-                return {};
-            }
-            RANGES_COROUTINES_NS::suspend_always await_transform(
-                experimental::generator_size size) noexcept
-            {
-                // ...we need the coroutine set the size of the range first by
-                // co_awaiting on a generator_size.
-                size_ = size;
-                return {};
-            }
-            experimental::generator_size_t size() const noexcept
-            {
-                RANGES_EXPECT(size_ != experimental::generator_size::invalid);
-                return static_cast<experimental::generator_size_t>(size_);
-            }
-
-        private:
-            experimental::generator_size size_ = experimental::generator_size::invalid;
-        };
-    } // namespace detail
-    /// \endcond
-
-    namespace experimental
-    {
-        template<typename Reference, typename Value = uncvref_t<Reference>>
-        struct sized_generator;
-
-        template<typename Reference, typename Value = uncvref_t<Reference>>
-        struct generator : view_facade<generator<Reference, Value>>
-        {
-            using promise_type = detail::generator_promise<Reference>;
-
-            constexpr generator() noexcept = default;
-            generator(promise_type * p)
-              : coro_{handle::from_promise(*p)}
-            {
-                RANGES_EXPECT(coro_);
-            }
-
-        private:
-            friend range_access;
-            friend struct sized_generator<Reference, Value>;
-            using handle = RANGES_COROUTINES_NS::coroutine_handle<promise_type>;
-            coroutine_owner<promise_type> coro_;
-
-            struct cursor
-            {
-                using value_type = Value;
-
-                cursor() = default;
-                constexpr explicit cursor(handle coro) noexcept
-                  : coro_{coro}
-                {}
-                bool equal(default_sentinel_t) const
-                {
-                    RANGES_EXPECT(coro_);
-                    if(coro_.done())
-                    {
-                        auto & e = coro_.promise().except_;
-                        if(e)
-                            std::rethrow_exception(std::move(e));
-                        return true;
-                    }
-                    return false;
-                }
-                void next()
-                {
-                    detail::resume(coro_);
-                }
-                Reference read() const
-                {
-                    RANGES_EXPECT(coro_);
-                    return coro_.promise().read();
-                }
-
-            private:
-                handle coro_ = nullptr;
-            };
-
-            cursor begin_cursor()
-            {
-                detail::resume(coro_.handle());
-                return cursor{coro_.handle()};
-            }
-        };
-
-        template<typename Reference, typename Value /* = uncvref_t<Reference>*/>
-        struct sized_generator : generator<Reference, Value>
-        {
-            using promise_type = detail::sized_generator_promise<Reference>;
-            using handle = RANGES_COROUTINES_NS::coroutine_handle<promise_type>;
-
-            constexpr sized_generator() noexcept = default;
-            sized_generator(promise_type * p)
-              : generator<Reference, Value>{p}
-            {}
-            generator_size_t size() const noexcept
-            {
-                return promise().size();
-            }
-
-        private:
-            using generator<Reference, Value>::coro_;
-
-            promise_type const & promise() const noexcept
-            {
-                RANGES_EXPECT(coro_);
-                return static_cast<promise_type const &>(coro_.promise());
-            }
-        };
-    } // namespace experimental
-
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif // RANGES_CXX_COROUTINES >= RANGES_CXX_COROUTINES_TS1
-
-#endif // RANGES_V3_EXPERIMENTAL_UTILITY_GENERATOR_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/experimental/view/shared.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/experimental/view/shared.hpp
deleted file mode 100644
index 0f185bc3..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/experimental/view/shared.hpp
+++ /dev/null
@@ -1,135 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Filip Matzner 2017
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_EXPERIMENTAL_VIEW_SHARED_HPP
-#define RANGES_V3_EXPERIMENTAL_VIEW_SHARED_HPP
-
-#include <memory>
-#include <type_traits>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/functional/compose.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/view/all.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    namespace experimental
-    {
-        template<typename Rng>
-        struct shared_view
-          : view_interface<shared_view<Rng>, range_cardinality<Rng>::value>
-        {
-        private:
-            // shared storage
-            std::shared_ptr<Rng> rng_ptr_;
-
-        public:
-            shared_view() = default;
-
-            // construct from a range rvalue
-            explicit shared_view(Rng rng)
-              : rng_ptr_{std::make_shared<Rng>(std::move(rng))}
-            {}
-
-            // use the stored range's begin and end
-            iterator_t<Rng> begin() const
-            {
-                return ranges::begin(*rng_ptr_);
-            }
-            sentinel_t<Rng> end() const
-            {
-                return ranges::end(*rng_ptr_);
-            }
-
-            CPP_member
-            auto CPP_fun(size)()(const
-                /// \pre
-                requires sized_range<Rng>)
-            {
-                return ranges::size(*rng_ptr_);
-            }
-        };
-
-        template<typename SharedFn>
-        struct shared_closure;
-
-        struct RANGES_STRUCT_WITH_ADL_BARRIER(shared_closure_base)
-        {
-            // Piping requires viewable_ranges.
-            template(typename Rng, typename SharedFn)(
-                /// \pre
-                requires range<Rng> AND (!viewable_range<Rng>) AND
-                    constructible_from<detail::decay_t<Rng>, Rng>)
-            friend constexpr auto operator|(Rng && rng, shared_closure<SharedFn> vw)
-            {
-                return static_cast<SharedFn &&>(vw)(static_cast<Rng &&>(rng));
-            }
-
-            template<typename SharedFn, typename Pipeable>
-            friend constexpr auto operator|(shared_closure<SharedFn> sh, Pipeable pipe)
-                -> CPP_broken_friend_ret(shared_closure<composed<Pipeable, SharedFn>>)(
-                    /// \pre
-                    requires (is_pipeable_v<Pipeable>))
-            {
-                return shared_closure<composed<Pipeable, SharedFn>>{compose(
-                    static_cast<Pipeable &&>(pipe), static_cast<SharedFn &&>(sh))};
-            }
-        };
-
-        template<typename SharedFn>
-        struct shared_closure
-          : shared_closure_base
-          , SharedFn
-        {
-            shared_closure() = default;
-            constexpr explicit shared_closure(SharedFn fn)
-              : SharedFn(static_cast<SharedFn &&>(fn))
-            {}
-        };
-
-        namespace views
-        {
-            struct shared_fn
-            {
-                template(typename Rng)(
-                    /// \pre
-                    requires range<Rng> AND (!viewable_range<Rng>)AND
-                        constructible_from<detail::decay_t<Rng>, Rng>)
-                shared_view<detail::decay_t<Rng>> operator()(Rng && rng) const
-                {
-                    return shared_view<detail::decay_t<Rng>>{static_cast<Rng &&>(rng)};
-                }
-            };
-
-            /// \relates shared_fn
-            /// \ingroup group-views
-            RANGES_INLINE_VARIABLE(shared_closure<shared_fn>, shared)
-        } // namespace views
-    }     // namespace experimental
-
-    template<typename SharedFn>
-    RANGES_INLINE_VAR constexpr bool
-        is_pipeable_v<experimental::shared_closure<SharedFn>> = true;
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/front.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/front.hpp
deleted file mode 100644
index 60ed3e32..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/front.hpp
+++ /dev/null
@@ -1,22 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_FRONT_HPP
-#define RANGES_V3_FRONT_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated. Please #include <range/v3/range/operations.hpp> instead.")
-
-#include <range/v3/range/operations.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/functional.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/functional.hpp
deleted file mode 100644
index 8de510ae..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/functional.hpp
+++ /dev/null
@@ -1,32 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2019-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_FUNCTIONAL_HPP
-#define RANGES_V3_FUNCTIONAL_HPP
-
-#include <range/v3/functional/arithmetic.hpp>
-#include <range/v3/functional/bind.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/compose.hpp>
-#include <range/v3/functional/concepts.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/indirect.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/functional/not_fn.hpp>
-#include <range/v3/functional/on.hpp>
-#include <range/v3/functional/overload.hpp>
-#include <range/v3/functional/pipeable.hpp>
-#include <range/v3/functional/reference_wrapper.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/functional/arithmetic.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/functional/arithmetic.hpp
deleted file mode 100644
index 61e2ad1b..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/functional/arithmetic.hpp
+++ /dev/null
@@ -1,112 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_FUNCTIONAL_ARITHMETIC_HPP
-#define RANGES_V3_FUNCTIONAL_ARITHMETIC_HPP
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-functional
-    /// @{
-    struct plus
-    {
-        template<typename T, typename U>
-        constexpr auto operator()(T && t, U && u) const -> decltype((T &&) t + (U &&) u)
-        {
-            return (T &&) t + (U &&) u;
-        }
-        using is_transparent = void;
-    };
-
-    struct minus
-    {
-        template<typename T, typename U>
-        constexpr auto operator()(T && t, U && u) const -> decltype((T &&) t - (U &&) u)
-        {
-            return (T &&) t - (U &&) u;
-        }
-        using is_transparent = void;
-    };
-
-    struct multiplies
-    {
-        template<typename T, typename U>
-        constexpr auto operator()(T && t, U && u) const -> decltype((T &&) t * (U &&) u)
-        {
-            return (T &&) t * (U &&) u;
-        }
-        using is_transparent = void;
-    };
-
-    struct bitwise_or
-    {
-        template<typename T, typename U>
-        constexpr auto operator()(T && t, U && u) const -> decltype((T &&) t | (U &&) u)
-        {
-            return (T &&) t | (U &&) u;
-        }
-        using is_transparent = void;
-    };
-
-    template<typename T>
-    struct convert_to
-    {
-        // clang-format off
-        template<typename U>
-        constexpr auto CPP_auto_fun(operator())(U &&u)(const)
-        (
-            return static_cast<T>((U &&) u)
-        )
-        // clang-format on
-    };
-
-    template<typename T>
-    struct coerce
-    {
-        constexpr T & operator()(T & t) const
-        {
-            return t;
-        }
-        /// \overload
-        constexpr T const & operator()(T const & t) const
-        {
-            return t;
-        }
-        /// \overload
-        constexpr T operator()(T && t) const
-        {
-            return (T &&) t;
-        }
-        T operator()(T const &&) const = delete;
-    };
-
-    template<typename T>
-    struct coerce<T const> : coerce<T>
-    {};
-
-    template<typename T>
-    struct coerce<T &> : coerce<T>
-    {};
-
-    template<typename T>
-    struct coerce<T &&> : coerce<T>
-    {};
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/functional/bind.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/functional/bind.hpp
deleted file mode 100644
index 1ceccd43..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/functional/bind.hpp
+++ /dev/null
@@ -1,127 +0,0 @@
-
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_FUNCTIONAL_BIND_HPP
-#define RANGES_V3_FUNCTIONAL_BIND_HPP
-
-#include <functional>
-#include <type_traits>
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-functional
-    /// @{
-    template<typename T,
-             typename U = meta::if_<
-                 std::is_lvalue_reference<T>,
-                 std::reference_wrapper<meta::_t<std::remove_reference<T>>>, T &&>>
-    U bind_forward(meta::_t<std::remove_reference<T>> & t) noexcept
-    {
-        return static_cast<U>(t);
-    }
-
-    template<typename T>
-    T && bind_forward(meta::_t<std::remove_reference<T>> && t) noexcept
-    {
-        // This is to catch way sketchy stuff like: forward<int const &>(42)
-        static_assert(!std::is_lvalue_reference<T>::value, "You didn't just do that!");
-        return static_cast<T &&>(t);
-    }
-
-    template<typename T>
-    struct bind_element
-      : meta::if_c<RANGES_IS_SAME(detail::decay_t<T>, T), meta::id<T>,
-                   bind_element<detail::decay_t<T>>>
-    {};
-
-    template<typename T>
-    struct bind_element<std::reference_wrapper<T>>
-    {
-        using type = T &;
-    };
-
-    template<typename T>
-    struct bind_element<reference_wrapper<T>>
-    {
-        using type = typename reference_wrapper<T>::reference;
-    };
-
-    template<typename T>
-    using bind_element_t = meta::_t<bind_element<T>>;
-
-    template<typename Bind>
-    struct protector
-    {
-    private:
-        Bind bind_;
-
-    public:
-        protector() = default;
-        protector(Bind b)
-          : bind_(std::move(b))
-        {}
-        // clang-format off
-        template<typename...Ts>
-        auto CPP_auto_fun(operator())(Ts &&...ts)
-        (
-            return bind_(static_cast<Ts &&>(ts)...)
-        )
-        /// \overload
-        template<typename...Ts>
-        auto CPP_auto_fun(operator())(Ts &&...ts) (const)
-        (
-            return bind_(static_cast<Ts &&>(ts)...)
-        )
-        // clang-format on
-    };
-
-    struct protect_fn
-    {
-        template(typename F)(
-            /// \pre
-            requires std::is_bind_expression<uncvref_t<F>>::value) //
-        protector<uncvref_t<F>> operator()(F && f) const
-        {
-            return {static_cast<F &&>(f)};
-        }
-        /// \overload
-        template(typename F)(
-            /// \pre
-            requires (!std::is_bind_expression<uncvref_t<F>>::value)) //
-        F operator()(F && f) const
-        {
-            return static_cast<F &&>(f);
-        }
-    };
-
-    /// Protect a callable so that it can be safely used in a bind expression without
-    /// accidentally becoming a "nested" bind.
-    /// \ingroup group-functional
-    /// \sa `protect_fn`
-    RANGES_INLINE_VARIABLE(protect_fn, protect)
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/functional/bind_back.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/functional/bind_back.hpp
deleted file mode 100644
index 46a0e7d8..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/functional/bind_back.hpp
+++ /dev/null
@@ -1,192 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Andrey Diduh 2019
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_DETAIL_BIND_BACK_HPP
-#define RANGES_V3_DETAIL_BIND_BACK_HPP
-
-#include <tuple>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/utility/tuple_algorithm.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    // bind_back like std::bind_front has no special treatment for nested
-    // bind-expressions or reference_wrappers; there is no need to wrap
-    // Callables with ranges::protect.
-    namespace detail
-    {
-        template<typename Fn, typename... Args>
-        struct bind_back_fn_
-        {
-            using tuple_t = std::tuple<Fn, Args...>;
-            tuple_t fn_args_;
-
-            template<typename... CallArgs>
-            constexpr invoke_result_t<Fn, CallArgs..., Args...> //
-            operator()(CallArgs &&... cargs) &&
-                noexcept(is_nothrow_invocable_v<Fn, CallArgs..., Args...>)
-            {
-                return tuple_apply(
-                    [&](auto && fn, auto &&... args) -> decltype(auto) {
-                        return invoke((decltype(fn))fn,
-                                      (CallArgs &&) cargs...,
-                                      (decltype(args))args...);
-                    },
-                    (std::tuple<Fn, Args...> &&) fn_args_);
-            }
-
-            /// \overload
-            template<typename... CallArgs>
-            constexpr invoke_result_t<Fn &, CallArgs..., Args &...>
-            operator()(CallArgs &&... cargs) &
-                noexcept(is_nothrow_invocable_v<Fn &, CallArgs..., Args &...>)
-            {
-                return tuple_apply(
-                    [&](auto & fn, auto &... args) -> decltype(auto) {
-                        return invoke(fn, (CallArgs &&) cargs..., args...);
-                    },
-                    fn_args_);
-            }
-
-            /// \overload
-            template<typename... CallArgs>
-            constexpr invoke_result_t<Fn const &, CallArgs..., Args const &...>
-            operator()(CallArgs &&... cargs) const & //
-                noexcept(is_nothrow_invocable_v<Fn const &, CallArgs..., Args const &...>)
-            {
-                return tuple_apply(
-                    [&](auto & fn, auto &... args) -> decltype(auto) {
-                        return invoke(fn, (CallArgs &&) cargs..., args...);
-                    },
-                    fn_args_);
-            }
-        };
-
-        /// \cond
-        // Unroll a few instantiations to avoid a heavy-weight tuple instantiation
-        template<typename Fn, typename Arg>
-        struct bind_back_fn_<Fn, Arg>
-        {
-            struct tuple_t
-            {
-                Fn fn_;
-                Arg arg_;
-            };
-            tuple_t fn_args_;
-
-            template<typename... CallArgs>
-            constexpr invoke_result_t<Fn, CallArgs..., Arg> //
-            operator()(CallArgs &&... cargs) && //
-                noexcept(is_nothrow_invocable_v<Fn, CallArgs..., Arg>)
-            {
-                return invoke(
-                    (Fn &&) fn_args_.fn_, (CallArgs &&) cargs..., (Arg &&) fn_args_.arg_);
-            }
-
-            template<typename... CallArgs>
-            constexpr invoke_result_t<Fn &, CallArgs..., Arg &> //
-            operator()(CallArgs &&... cargs) & //
-                noexcept(is_nothrow_invocable_v<Fn &, CallArgs..., Arg &>)
-            {
-                return invoke(fn_args_.fn_, (CallArgs &&) cargs..., fn_args_.arg_);
-            }
-
-            template<typename... CallArgs>
-            constexpr invoke_result_t<Fn const &, CallArgs..., Arg const &> //
-            operator()(CallArgs &&... cargs) const & //
-                noexcept(is_nothrow_invocable_v<Fn const &, CallArgs..., Arg const &>)
-            {
-                return invoke(fn_args_.fn_, (CallArgs &&) cargs..., fn_args_.arg_);
-            }
-        };
-
-        template<typename Fn, typename Arg0, typename Arg1>
-        struct bind_back_fn_<Fn, Arg0, Arg1>
-        {
-            struct tuple_t
-            {
-                Fn fn_;
-                Arg0 arg0_;
-                Arg1 arg1_;
-            };
-            tuple_t fn_args_;
-
-            template<typename... CallArgs>
-            constexpr invoke_result_t<Fn, CallArgs..., Arg0, Arg1> //
-            operator()(CallArgs &&... cargs) && //
-                noexcept(is_nothrow_invocable_v<Fn, CallArgs..., Arg0, Arg1>)
-            {
-                return invoke((Fn &&) fn_args_.fn_,
-                              (CallArgs &&) cargs...,
-                              (Arg0 &&) fn_args_.arg0_,
-                              (Arg1 &&) fn_args_.arg1_);
-            }
-
-            template<typename... CallArgs>
-            constexpr invoke_result_t<Fn &, CallArgs..., Arg0 &, Arg1 &> //
-            operator()(CallArgs &&... cargs) & //
-                noexcept(is_nothrow_invocable_v<Fn &, CallArgs..., Arg0 &, Arg1 &>)
-            {
-                return invoke(
-                    fn_args_.fn_, (CallArgs &&) cargs..., fn_args_.arg0_, fn_args_.arg1_);
-            }
-
-            template<typename... CallArgs>
-            constexpr invoke_result_t<Fn const &, CallArgs..., Arg0 const &, Arg1 const &>
-            operator()(CallArgs &&... cargs) const & 
-                noexcept(is_nothrow_invocable_v<Fn const &,
-                                                CallArgs...,
-                                                Arg0 const &,
-                                                Arg1 const &>)
-            {
-                return invoke(
-                    fn_args_.fn_, (CallArgs &&) cargs..., fn_args_.arg0_, fn_args_.arg1_);
-            }
-        };
-        /// \endcond
-
-        template<typename Fn, typename... Args>
-        using bind_back_fn = bind_back_fn_<decay_t<Fn>, decay_t<Args>...>;
-    } // namespace detail
-
-    struct bind_back_fn
-    {
-        template<typename Fn, typename Arg1, typename... Args>
-        constexpr detail::bind_back_fn<Fn, Arg1, Args...> //
-        operator()(Fn && fn, Arg1 && arg1, Args &&... args) const
-        {
-#if defined(__GNUC__) && !defined(__clang__) && __GNUC__ <= 5
-            using T = typename detail::bind_back_fn<Fn, Arg1, Args...>::tuple_t;
-            return {T{(Fn &&) fn, (Arg1 &&) arg1, (Args &&) args...}};
-#else
-            return {{(Fn &&) fn, (Arg1 &&) arg1, (Args &&) args...}};
-#endif
-        }
-    };
-
-    /// \ingroup group-utility
-    /// \sa `bind_back_fn`
-    RANGES_INLINE_VARIABLE(bind_back_fn, bind_back)
-
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif // RANGES_V3_DETAIL_BIND_BACK_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/functional/comparisons.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/functional/comparisons.hpp
deleted file mode 100644
index e43cb30b..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/functional/comparisons.hpp
+++ /dev/null
@@ -1,133 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_FUNCTIONAL_COMPARISONS_HPP
-#define RANGES_V3_FUNCTIONAL_COMPARISONS_HPP
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-functional
-    /// @{
-    struct equal_to
-    {
-        template(typename T, typename U)(
-            /// \pre
-            requires equality_comparable_with<T, U>)
-        constexpr bool operator()(T && t, U && u) const
-        {
-            return (T &&) t == (U &&) u;
-        }
-        using is_transparent = void;
-    };
-
-    struct not_equal_to
-    {
-        template(typename T, typename U)(
-            /// \pre
-            requires equality_comparable_with<T, U>)
-        constexpr bool operator()(T && t, U && u) const
-        {
-            return !equal_to{}((T &&) t, (U &&) u);
-        }
-        using is_transparent = void;
-    };
-
-    struct less
-    {
-        template(typename T, typename U)(
-            /// \pre
-            requires totally_ordered_with<T, U>)
-        constexpr bool operator()(T && t, U && u) const
-        {
-            return (T &&) t < (U &&) u;
-        }
-        using is_transparent = void;
-    };
-
-    struct less_equal
-    {
-        template(typename T, typename U)(
-            /// \pre
-            requires totally_ordered_with<T, U>)
-        constexpr bool operator()(T && t, U && u) const
-        {
-            return !less{}((U &&) u, (T &&) t);
-        }
-        using is_transparent = void;
-    };
-
-    struct greater_equal
-    {
-        template(typename T, typename U)(
-            /// \pre
-            requires totally_ordered_with<T, U>)
-        constexpr bool operator()(T && t, U && u) const
-        {
-            return !less{}((T &&) t, (U &&) u);
-        }
-        using is_transparent = void;
-    };
-
-    struct greater
-    {
-        template(typename T, typename U)(
-            /// \pre
-            requires totally_ordered_with<T, U>)
-        constexpr bool operator()(T && t, U && u) const
-        {
-            return less{}((U &&) u, (T &&) t);
-        }
-        using is_transparent = void;
-    };
-
-    using ordered_less RANGES_DEPRECATED(
-        "Repace uses of ranges::ordered_less with ranges::less") = less;
-
-#if __cplusplus > 201703L && defined(__cpp_impl_three_way_comparison) && \
-    __has_include(<compare>)
-    struct compare_three_way
-    {
-        template(typename T, typename U)(
-            /// \pre
-            requires three_way_comparable_with<T, U>)
-        constexpr auto operator()(T && t, U && u) const
-            -> decltype((T &&) t <=> (U &&) u)
-        {
-            return (T &&) t <=> (U &&) u;
-        }
-
-        using is_transparent = void;
-    };
-#endif // __cplusplus
-
-    namespace cpp20
-    {
-        using ranges::equal_to;
-        using ranges::greater;
-        using ranges::greater_equal;
-        using ranges::less;
-        using ranges::less_equal;
-        using ranges::not_equal_to;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/functional/compose.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/functional/compose.hpp
deleted file mode 100644
index cd31a35b..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/functional/compose.hpp
+++ /dev/null
@@ -1,104 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_FUNCTIONAL_COMPOSE_HPP
-#define RANGES_V3_FUNCTIONAL_COMPOSE_HPP
-
-#include <type_traits>
-#include <utility>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/detail/config.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-functional
-    /// @{
-    template<typename Second, typename First>
-    struct composed
-    {
-    private:
-        RANGES_NO_UNIQUE_ADDRESS
-        First first_;
-        RANGES_NO_UNIQUE_ADDRESS
-        Second second_;
-
-        // clang-format off
-        template<typename A, typename B, typename... Ts>
-        static constexpr auto //
-        CPP_auto_fun(do_)(A &&a, B &&b, std::false_type, Ts &&... ts)
-        (
-            return invoke((B &&) b, invoke((A &&) a, (Ts &&) ts...))
-        )
-        template<typename A, typename B, typename... Ts>
-        static constexpr auto CPP_auto_fun(do_)(A &&a, B &&b, std::true_type, Ts &&... ts)
-        (
-            return (invoke((A &&) a, (Ts &&) ts...), invoke((B &&) b))
-        )
-    public:
-        composed() = default;
-        // clang-format on
-        constexpr composed(Second second, First first)
-          : first_(std::move(first))
-          , second_(std::move(second))
-        {}
-        // clang-format off
-        template<typename... Ts>
-        constexpr auto CPP_auto_fun(operator())(Ts &&... ts)(mutable &)
-        (
-            return composed::do_(first_,
-                                 second_,
-                                 std::is_void<invoke_result_t<First &, Ts...>>{},
-                                 (Ts &&) ts...)
-        )
-        template<typename... Ts>
-        constexpr auto CPP_auto_fun(operator())(Ts &&... ts)(const &)
-        (
-            return composed::do_((First const &)first_,
-                                 (Second const &)second_,
-                                 std::is_void<invoke_result_t<First const &, Ts...>>{},
-                                 (Ts &&) ts...)
-        )
-        template<typename... Ts>
-        constexpr auto CPP_auto_fun(operator())(Ts &&... ts)(mutable &&)
-        (
-            return composed::do_((First &&)first_,
-                                 (Second &&)second_,
-                                 std::is_void<invoke_result_t<First &&, Ts...>>{},
-                                 (Ts &&) ts...)
-        )
-        // clang-format on
-    };
-
-    struct compose_fn
-    {
-        template<typename Second, typename First>
-        constexpr composed<Second, First> operator()(Second second, First first) const
-        {
-            return {std::move(second), std::move(first)};
-        }
-    };
-
-    /// \ingroup group-functional
-    /// \sa `compose_fn`
-    RANGES_INLINE_VARIABLE(compose_fn, compose)
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/functional/concepts.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/functional/concepts.hpp
deleted file mode 100644
index 0ace3121..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/functional/concepts.hpp
+++ /dev/null
@@ -1,90 +0,0 @@
-
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_FUNCTIONAL_CONCEPTS_HPP
-#define RANGES_V3_FUNCTIONAL_CONCEPTS_HPP
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/functional/invoke.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-functional
-    /// @{
-
-    // clang-format off
-    // WORKAROUND mysterious msvc bug
-#if defined(_MSC_VER)
-    template<typename Fun, typename... Args>
-    CPP_concept invocable =
-        std::is_invocable_v<Fun, Args...>;
-#else
-    template<typename Fun, typename... Args>
-    CPP_requires(invocable_,
-        requires(Fun && fn) //
-        (
-            invoke((Fun &&) fn, std::declval<Args>()...)
-        ));
-    template<typename Fun, typename... Args>
-    CPP_concept invocable =
-        CPP_requires_ref(ranges::invocable_, Fun, Args...);
-#endif
-
-    template<typename Fun, typename... Args>
-    CPP_concept regular_invocable =
-        invocable<Fun, Args...>;
-        // Axiom: equality_preserving(invoke(f, args...))
-
-    template<typename Fun, typename... Args>
-    CPP_requires(predicate_,
-        requires(Fun && fn) //
-        (
-            concepts::requires_<
-                convertible_to<
-                    decltype(invoke((Fun &&) fn, std::declval<Args>()...)),
-                    bool>>
-        ));
-    template<typename Fun, typename... Args>
-    CPP_concept predicate =
-        regular_invocable<Fun, Args...> &&
-        CPP_requires_ref(ranges::predicate_, Fun, Args...);
-
-    template<typename R, typename T, typename U>
-    CPP_concept relation =
-        predicate<R, T, T> &&
-        predicate<R, U, U> &&
-        predicate<R, T, U> &&
-        predicate<R, U, T>;
-
-    template<typename R, typename T, typename U>
-    CPP_concept strict_weak_order =
-        relation<R, T, U>;
-    // clang-format on
-
-    namespace cpp20
-    {
-        using ranges::invocable;
-        using ranges::predicate;
-        using ranges::regular_invocable;
-        using ranges::relation;
-        using ranges::strict_weak_order;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/functional/identity.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/functional/identity.hpp
deleted file mode 100644
index 5f7d8b10..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/functional/identity.hpp
+++ /dev/null
@@ -1,48 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_FUNCTIONAL_IDENTITY_HPP
-#define RANGES_V3_FUNCTIONAL_IDENTITY_HPP
-
-#include <range/v3/detail/config.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-functional
-    /// @{
-    struct identity
-    {
-        template<typename T>
-        constexpr T && operator()(T && t) const noexcept
-        {
-            return (T &&) t;
-        }
-        using is_transparent = void;
-    };
-
-    /// \cond
-    using ident RANGES_DEPRECATED("Replace uses of ranges::ident with ranges::identity") =
-        identity;
-    /// \endcond
-
-    namespace cpp20
-    {
-        using ranges::identity;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/functional/indirect.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/functional/indirect.hpp
deleted file mode 100644
index a9cfc528..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/functional/indirect.hpp
+++ /dev/null
@@ -1,100 +0,0 @@
-
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_FUNCTIONAL_INDIRECT_HPP
-#define RANGES_V3_FUNCTIONAL_INDIRECT_HPP
-
-#include <utility>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/utility/move.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-functional
-    /// @{
-    template<typename Fn>
-    struct indirected
-    {
-    private:
-        RANGES_NO_UNIQUE_ADDRESS
-        Fn fn_;
-
-    public:
-        indirected() = default;
-        indirected(Fn fn)
-          : fn_(std::move(fn))
-        {}
-        // value_type (needs no impl)
-        template<typename... Its>
-        [[noreturn]] invoke_result_t<Fn &, iter_reference_t<Its>...> //
-        operator()(copy_tag, Its...) const
-        {
-            RANGES_EXPECT(false);
-        }
-
-        // Reference
-        // clang-format off
-        template<typename... Its>
-        auto CPP_auto_fun(operator())(Its... its)
-        (
-            return invoke(fn_, *its...)
-        )
-        template<typename... Its>
-        auto CPP_auto_fun(operator())(Its... its)(const)
-        (
-            return invoke((Fn const &)fn_, *its...)
-        )
-
-        // Rvalue reference
-        template<typename... Its>
-        auto CPP_auto_fun(operator())(move_tag, Its... its)
-        (
-            return static_cast<
-                aux::move_t<invoke_result_t<Fn &, iter_reference_t<Its>...>>>(
-                aux::move(invoke(fn_, *its...)))
-        )
-        template<typename... Its>
-        auto CPP_auto_fun(operator())(move_tag, Its... its)(const)
-        (
-            return static_cast<
-                aux::move_t<invoke_result_t<Fn const &, iter_reference_t<Its>...>>>(
-                aux::move(invoke((Fn const &)fn_, *its...)))
-        )
-        // clang-format on
-    };
-
-    struct indirect_fn
-    {
-        template<typename Fn>
-        constexpr indirected<Fn> operator()(Fn fn) const
-        {
-            return indirected<Fn>{detail::move(fn)};
-        }
-    };
-
-    /// \ingroup group-functional
-    /// \sa `indirect_fn`
-    RANGES_INLINE_VARIABLE(indirect_fn, indirect)
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/functional/invoke.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/functional/invoke.hpp
deleted file mode 100644
index d613e06c..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/functional/invoke.hpp
+++ /dev/null
@@ -1,245 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_FUNCTIONAL_INVOKE_HPP
-#define RANGES_V3_FUNCTIONAL_INVOKE_HPP
-
-#include <functional>
-#include <type_traits>
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-RANGES_DIAGNOSTIC_PUSH
-RANGES_DIAGNOSTIC_IGNORE_CXX17_COMPAT
-RANGES_DIAGNOSTIC_IGNORE_DEPRECATED_DECLARATIONS
-
-#ifndef RANGES_CONSTEXPR_INVOKE
-#ifdef RANGES_WORKAROUND_CLANG_23135
-#define RANGES_CONSTEXPR_INVOKE 0
-#else
-#define RANGES_CONSTEXPR_INVOKE 1
-#endif
-#endif
-
-namespace ranges
-{
-    /// \addtogroup group-functional
-    /// @{
-
-    /// \cond
-    namespace detail
-    {
-        RANGES_DIAGNOSTIC_PUSH
-        RANGES_DIAGNOSTIC_IGNORE_VOID_PTR_DEREFERENCE
-
-        template<typename U>
-        U & can_reference_(U &&);
-
-        // clang-format off
-        template<typename T>
-        CPP_requires(dereferenceable_part_,
-            requires(T && t) //
-            (
-                detail::can_reference_(*(T &&) t)
-            ));
-        template<typename T>
-        CPP_concept dereferenceable_ = //
-            CPP_requires_ref(detail::dereferenceable_part_, T);
-        // clang-format on
-
-        RANGES_DIAGNOSTIC_POP
-
-        template<typename T>
-        RANGES_INLINE_VAR constexpr bool is_reference_wrapper_v =
-            meta::is<T, reference_wrapper>::value ||
-            meta::is<T, std::reference_wrapper>::value;
-    } // namespace detail
-    /// \endcond
-
-    template<typename T>
-    RANGES_INLINE_VAR constexpr bool is_reference_wrapper_v =
-        detail::is_reference_wrapper_v<detail::decay_t<T>>;
-
-    template<typename T>
-    using is_reference_wrapper = meta::bool_<is_reference_wrapper_v<T>>;
-
-    /// \cond
-    template<typename T>
-    using is_reference_wrapper_t RANGES_DEPRECATED(
-        "is_reference_wrapper_t is deprecated.") = meta::_t<is_reference_wrapper<T>>;
-    /// \endcond
-
-    struct invoke_fn
-    {
-    private:
-        template(typename, typename T1)(
-            /// \pre
-            requires detail::dereferenceable_<T1>)
-        static constexpr decltype(auto) coerce(T1 && t1, long)
-            noexcept(noexcept(*static_cast<T1 &&>(t1)))
-        {
-            return *static_cast<T1 &&>(t1);
-        }
-
-        template(typename T, typename T1)(
-            /// \pre
-            requires derived_from<detail::decay_t<T1>, T>)
-        static constexpr T1 && coerce(T1 && t1, int) noexcept
-        {
-            return static_cast<T1 &&>(t1);
-        }
-
-        template(typename, typename T1)(
-            /// \pre
-            requires detail::is_reference_wrapper_v<detail::decay_t<T1>>)
-        static constexpr decltype(auto) coerce(T1 && t1, int) noexcept
-        {
-            return static_cast<T1 &&>(t1).get();
-        }
-
-    public:
-        template<typename F, typename T, typename T1, typename... Args>
-        constexpr auto operator()(F T::*f, T1&& t1, Args&&... args) const
-            noexcept(noexcept((invoke_fn::coerce<T>((T1&&) t1, 0).*f)((Args&&) args...)))
-            -> decltype((invoke_fn::coerce<T>((T1&&) t1, 0).*f)((Args&&) args...))
-        {
-            return (invoke_fn::coerce<T>((T1&&) t1, 0).*f)((Args&&) args...);
-        }
-
-        template<typename D, typename T, typename T1>
-        constexpr auto operator()(D T::*f, T1&& t1) const
-            noexcept(noexcept(invoke_fn::coerce<T>((T1&&) t1, 0).*f))
-            -> decltype(invoke_fn::coerce<T>((T1&&) t1, 0).*f)
-        {
-            return invoke_fn::coerce<T>((T1&&) t1, 0).*f;
-        }
-
-        template<typename F, typename... Args>
-        CPP_PP_IIF(RANGES_CONSTEXPR_INVOKE)(CPP_PP_EXPAND, CPP_PP_EAT)(constexpr)
-        auto operator()(F&& f, Args&&... args) const
-            noexcept(noexcept(((F&&) f)((Args&&) args...)))
-            -> decltype(((F&&) f)((Args&&) args...))
-        {
-            return ((F&&) f)((Args&&) args...);
-        }
-    };
-
-    RANGES_INLINE_VARIABLE(invoke_fn, invoke)
-
-#ifdef RANGES_WORKAROUND_MSVC_701385
-    /// \cond
-    namespace detail
-    {
-        template<typename Void, typename Fun, typename... Args>
-        struct _invoke_result_
-        {};
-
-        template<typename Fun, typename... Args>
-        struct _invoke_result_<
-            meta::void_<decltype(invoke(std::declval<Fun>(), std::declval<Args>()...))>,
-            Fun, Args...>
-        {
-            using type = decltype(invoke(std::declval<Fun>(), std::declval<Args>()...));
-        };
-    } // namespace detail
-    /// \endcond
-
-    template<typename Fun, typename... Args>
-    using invoke_result = detail::_invoke_result_<void, Fun, Args...>;
-
-    template<typename Fun, typename... Args>
-    using invoke_result_t = meta::_t<invoke_result<Fun, Args...>>;
-
-#else  // RANGES_WORKAROUND_MSVC_701385
-    template<typename Fun, typename... Args>
-    using invoke_result_t =
-        decltype(invoke(std::declval<Fun>(), std::declval<Args>()...));
-
-    template<typename Fun, typename... Args>
-    struct invoke_result : meta::defer<invoke_result_t, Fun, Args...>
-    {};
-#endif // RANGES_WORKAROUND_MSVC_701385
-
-    /// \cond
-    namespace detail
-    {
-        template<bool IsInvocable>
-        struct is_nothrow_invocable_impl_
-        {
-            template<typename Fn, typename... Args>
-            static constexpr bool apply() noexcept
-            {
-                return false;
-            }
-        };
-        template<>
-        struct is_nothrow_invocable_impl_<true>
-        {
-            template<typename Fn, typename... Args>
-            static constexpr bool apply() noexcept
-            {
-                return noexcept(invoke(std::declval<Fn>(), std::declval<Args>()...));
-            }
-        };
-    } // namespace detail
-    /// \endcond
-
-    template<typename Fn, typename... Args>
-    RANGES_INLINE_VAR constexpr bool is_invocable_v =
-        meta::is_trait<invoke_result<Fn, Args...>>::value;
-
-    template<typename Fn, typename... Args>
-    RANGES_INLINE_VAR constexpr bool is_nothrow_invocable_v =
-        detail::is_nothrow_invocable_impl_<is_invocable_v<Fn, Args...>>::template apply<
-            Fn, Args...>();
-
-    /// \cond
-    template<typename Sig>
-    struct RANGES_DEPRECATED(
-        "ranges::result_of is deprecated. "
-        "Please use ranges::invoke_result") result_of
-    {};
-
-    template<typename Fun, typename... Args>
-    struct RANGES_DEPRECATED(
-        "ranges::result_of is deprecated. "
-        "Please use ranges::invoke_result") result_of<Fun(Args...)>
-      : meta::defer<invoke_result_t, Fun, Args...>
-    {};
-    /// \endcond
-
-    namespace cpp20
-    {
-        using ranges::invoke;
-        using ranges::invoke_result;
-        using ranges::invoke_result_t;
-        using ranges::is_invocable_v;
-        using ranges::is_nothrow_invocable_v;
-    } // namespace cpp20
-
-    /// @}
-} // namespace ranges
-
-RANGES_DIAGNOSTIC_POP
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif // RANGES_V3_FUNCTIONAL_INVOKE_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/functional/not_fn.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/functional/not_fn.hpp
deleted file mode 100644
index a7a5918d..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/functional/not_fn.hpp
+++ /dev/null
@@ -1,103 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_FUNCTIONAL_NOT_FN_HPP
-#define RANGES_V3_FUNCTIONAL_NOT_FN_HPP
-
-#include <type_traits>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/concepts.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-functional
-    /// @{
-    template<typename FD>
-    struct logical_negate
-    {
-    private:
-        CPP_assert(same_as<FD, detail::decay_t<FD>> && move_constructible<FD>);
-        RANGES_NO_UNIQUE_ADDRESS FD pred_;
-
-    public:
-        CPP_member
-        constexpr CPP_ctor(logical_negate)()(                          //
-            noexcept(std::is_nothrow_default_constructible<FD>::value) //
-                requires default_constructible<FD>)
-        {}
-        template(typename T)(
-            /// \pre
-            requires (!same_as<detail::decay_t<T>, logical_negate>) AND
-                constructible_from<FD, T>)
-        constexpr explicit logical_negate(T && pred)
-          : pred_(static_cast<T &&>(pred))
-        {}
-
-        template(typename... Args)(
-            /// \pre
-            requires predicate<FD &, Args...>)
-        constexpr bool operator()(Args &&... args) &
-        {
-            return !invoke(pred_, static_cast<Args &&>(args)...);
-        }
-        /// \overload
-        template(typename... Args)(
-            /// \pre
-            requires predicate<FD const &, Args...>)
-        constexpr bool operator()(Args &&... args) const &
-        {
-            return !invoke(pred_, static_cast<Args &&>(args)...);
-        }
-        /// \overload
-        template(typename... Args)(
-            /// \pre
-            requires predicate<FD, Args...>)
-        constexpr bool operator()(Args &&... args) &&
-        {
-            return !invoke(static_cast<FD &&>(pred_), static_cast<Args &&>(args)...);
-        }
-    };
-
-    struct not_fn_fn
-    {
-        template(typename Pred)(
-            /// \pre
-            requires move_constructible<detail::decay_t<Pred>> AND
-                constructible_from<detail::decay_t<Pred>, Pred>)
-        constexpr logical_negate<detail::decay_t<Pred>> operator()(Pred && pred) const
-        {
-            return logical_negate<detail::decay_t<Pred>>{(Pred &&) pred};
-        }
-    };
-
-    /// \ingroup group-functional
-    /// \sa `not_fn_fn`
-    RANGES_INLINE_VARIABLE(not_fn_fn, not_fn)
-
-    namespace cpp20
-    {
-        using ranges::not_fn;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/functional/on.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/functional/on.hpp
deleted file mode 100644
index 5cadb07f..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/functional/on.hpp
+++ /dev/null
@@ -1,74 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_FUNCTIONAL_ON_HPP
-#define RANGES_V3_FUNCTIONAL_ON_HPP
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/detail/config.hpp>
-#include <range/v3/functional/invoke.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-functional
-    /// @{
-    template<typename Fn1, typename Fn2>
-    struct transformed
-    {
-    private:
-        RANGES_NO_UNIQUE_ADDRESS
-        Fn1 first_;
-        RANGES_NO_UNIQUE_ADDRESS
-        Fn2 second_;
-
-    public:
-        transformed() = default;
-        constexpr transformed(Fn1 fn1, Fn2 fn2)
-          : first_(static_cast<Fn1 &&>(fn1))
-          , second_(static_cast<Fn2 &&>(fn2))
-        {}
-        // clang-format off
-        template<typename... Args>
-        auto CPP_auto_fun(operator())(Args &&... args)
-        (
-            return invoke(first_, invoke(second_, static_cast<Args &&>(args)...))
-        )
-        template<typename... Args>
-        auto CPP_auto_fun(operator())(Args &&... args)(const)
-        (
-            return invoke((Fn1 const &)first_,
-                          invoke((Fn2 const &)second_, static_cast<Args &&>(args)...))
-        )
-        // clang-format on
-    };
-
-    struct on_fn
-    {
-        template<typename Fn1, typename Fn2>
-        constexpr transformed<Fn1, Fn2> operator()(Fn1 fn1, Fn2 fn2) const
-        {
-            return transformed<Fn1, Fn2>{detail::move(fn1), detail::move(fn2)};
-        }
-    };
-
-    /// \ingroup group-functional
-    /// \sa `on_fn`
-    RANGES_INLINE_VARIABLE(on_fn, on)
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/functional/overload.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/functional/overload.hpp
deleted file mode 100644
index 60616103..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/functional/overload.hpp
+++ /dev/null
@@ -1,181 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_FUNCTIONAL_OVERLOAD_HPP
-#define RANGES_V3_FUNCTIONAL_OVERLOAD_HPP
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/concepts.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-functional
-    /// @{
-    /// \cond
-    namespace detail
-    {
-        struct _id
-        {
-            template<typename T>
-            using invoke = T;
-        };
-        struct _ref
-        {
-            template<typename T>
-            using invoke = T &;
-        };
-        struct _cref
-        {
-            template<typename T>
-            using invoke = T const &;
-        };
-        template<typename T>
-        struct _bind_front
-        {
-            template<typename... Args>
-            using invoke = invoke_result_t<T, Args...>;
-        };
-    } // namespace detail
-    /// \endcond
-
-    template<typename... Ts>
-    struct overloaded;
-
-    template<>
-    struct overloaded<>
-    {
-    private:
-        template<typename...>
-        friend struct overloaded;
-        template<typename, typename...>
-        using _result_t = void;
-    };
-
-    template<typename First, typename... Rest>
-    struct overloaded<First, Rest...>
-    {
-    private:
-        template<typename...>
-        friend struct overloaded;
-
-        RANGES_NO_UNIQUE_ADDRESS
-        First first_;
-        RANGES_NO_UNIQUE_ADDRESS
-        overloaded<Rest...> second_;
-
-        template<typename Qual>
-        using _result_first = detail::_bind_front<meta::invoke<Qual, First>>;
-        template<typename Qual>
-        struct _result_second
-        {
-            template<typename... Args>
-            using invoke = typename overloaded<Rest...>
-                ::template _result_t<Qual, Args...>;
-        };
-
-        template<typename Qual, typename... Args>
-        using _result_t =
-            meta::invoke<
-                meta::conditional_t<
-                    (bool) invocable<meta::invoke<Qual, First>, Args...>,
-                    _result_first<Qual>,
-                    _result_second<Qual>>,
-                Args...>;
-
-    public:
-        overloaded() = default;
-        constexpr overloaded(First first, Rest... rest)
-          : first_(static_cast<First &&>(first))
-          , second_{static_cast<Rest &&>(rest)...}
-        {}
-
-        template(typename... Args)(
-            /// \pre
-            requires invocable<First, Args...>)
-        constexpr _result_t<detail::_id, Args...> operator()(Args &&... args) &&
-        {
-            return invoke((First &&) first_, (Args &&) args...);
-        }
-        template(typename... Args)(
-            /// \pre
-            requires (!invocable<First, Args...>) AND
-                invocable<overloaded<Rest...>, Args...>)
-        constexpr _result_t<detail::_id, Args...> operator()(Args &&... args) &&
-        {
-            return invoke((overloaded<Rest...> &&) second_, (Args &&) args...);
-        }
-
-        template(typename... Args)(
-            /// \pre
-            requires invocable<First &, Args...>)
-        constexpr _result_t<detail::_ref, Args...> operator()(Args &&... args) &
-        {
-            return invoke(first_, (Args &&) args...);
-        }
-        template(typename... Args)(
-            /// \pre
-            requires (!invocable<First &, Args...>) AND
-                invocable<overloaded<Rest...> &, Args...>)
-        constexpr _result_t<detail::_ref, Args...> operator()(Args &&... args) &
-        {
-            return invoke(second_, (Args &&) args...);
-        }
-
-        template(typename... Args)(
-            /// \pre
-            requires invocable<First const &, Args...>)
-        constexpr _result_t<detail::_cref, Args...> operator()(Args &&... args) const &
-        {
-            return invoke(first_, (Args &&) args...);
-        }
-        template(typename... Args)(
-            /// \pre
-            requires (!invocable<First const &, Args...>) AND
-                invocable<overloaded<Rest...> const &, Args...>)
-        constexpr _result_t<detail::_cref, Args...> operator()(Args &&... args) const &
-        {
-            return invoke(second_, (Args &&) args...);
-        }
-    };
-
-    struct overload_fn
-    {
-        template<typename Fn>
-        constexpr Fn operator()(Fn fn) const
-        {
-            return fn;
-        }
-        template<typename... Fns>
-        constexpr overloaded<Fns...> operator()(Fns... fns) const
-        {
-            return overloaded<Fns...>{static_cast<Fns &&>(fns)...};
-        }
-    };
-
-    /// \ingroup group-functional
-    /// \sa `overload_fn`
-    RANGES_INLINE_VARIABLE(overload_fn, overload)
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/functional/pipeable.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/functional/pipeable.hpp
deleted file mode 100644
index ef3706cf..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/functional/pipeable.hpp
+++ /dev/null
@@ -1,131 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_FUNCTIONAL_PIPEABLE_HPP
-#define RANGES_V3_FUNCTIONAL_PIPEABLE_HPP
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/compose.hpp>
-#include <range/v3/functional/concepts.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-functional
-    /// @{
-
-    struct pipeable_base;
-
-    template<typename T>
-    RANGES_INLINE_VAR constexpr bool is_pipeable_v = META_IS_BASE_OF(pipeable_base, T);
-
-    template<typename T>
-    RANGES_INLINE_VAR constexpr bool is_pipeable_v<T &> = META_IS_BASE_OF(pipeable_base,
-                                                                          T);
-    template<typename T>
-    RANGES_INLINE_VAR constexpr bool is_pipeable_v<T &&> = META_IS_BASE_OF(pipeable_base,
-                                                                           T);
-    template<typename T>
-    using is_pipeable = meta::bool_<is_pipeable_v<T>>;
-
-    struct make_pipeable_fn
-    {
-        template<typename Fun, typename PipeableBase = pipeable_base>
-        constexpr auto operator()(Fun fun) const
-        {
-            struct local
-              : Fun
-              , PipeableBase
-            {
-                constexpr explicit local(Fun && f)
-                  : Fun(static_cast<Fun &&>(f))
-                {}
-            };
-            return local{static_cast<Fun &&>(fun)};
-        }
-    };
-
-    /// \ingroup group-functional
-    /// \sa `make_pipeable_fn`
-    RANGES_INLINE_VARIABLE(make_pipeable_fn, make_pipeable)
-
-    struct pipeable_access
-    {
-        template<typename Pipeable>
-        struct impl : Pipeable
-        {
-            using Pipeable::pipe;
-        };
-    };
-
-    struct pipeable_base
-    {
-    private:
-        friend pipeable_access;
-
-        // Evaluate the pipe with an argument
-        template(typename Arg, typename Pipe)(
-            /// \pre
-            requires (!is_pipeable_v<Arg>) AND is_pipeable_v<Pipe> AND
-            invocable<Pipe, Arg>) // clang-format off
-        friend constexpr auto operator|(Arg &&arg, Pipe pipe) // clang-format off
-        {
-            return static_cast<Pipe &&>(pipe)(static_cast<Arg &&>(arg));
-        }
-
-        // Compose two pipes
-        template(typename Pipe0, typename Pipe1)(
-            /// \pre
-            requires is_pipeable_v<Pipe0> AND is_pipeable_v<Pipe1>) // clang-format off
-        friend constexpr auto operator|(Pipe0 pipe0, Pipe1 pipe1) // clang-format on
-        {
-            return make_pipeable(compose(detail::move(pipe1), detail::move(pipe0)));
-        }
-
-        template<typename Arg, typename Pipe>
-        friend auto operator|=(Arg & arg, Pipe pipe) //
-            -> CPP_broken_friend_ret(Arg &)(
-                /// \pre
-                requires (is_pipeable_v<Pipe>) &&
-                    (!is_pipeable_v<Arg>) && invocable<Pipe, Arg &>)
-        {
-            static_cast<Pipe &&>(pipe)(arg);
-            return arg;
-        }
-
-        // Default Pipe behavior just passes the argument to the pipe's function call
-        // operator
-        // clang-format off
-        template<typename Arg, typename Pipe>
-        static constexpr auto CPP_auto_fun(pipe)(Arg && arg, Pipe p)
-        (
-            return static_cast<Pipe &&>(p)(static_cast<Arg &&>(arg))
-        )
-        // clang-format on
-    };
-
-    template<typename>
-    using pipeable RANGES_DEPRECATED("Please use pipeable_base instead") = pipeable_base;
-
-    /// \endcond
-
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/functional/reference_wrapper.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/functional/reference_wrapper.hpp
deleted file mode 100644
index 57f87e96..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/functional/reference_wrapper.hpp
+++ /dev/null
@@ -1,187 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_FUNCTIONAL_REFERENCE_WRAPPER_HPP
-#define RANGES_V3_FUNCTIONAL_REFERENCE_WRAPPER_HPP
-
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/utility/addressof.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-functional
-    /// @{
-
-    /// \cond
-    namespace detail
-    {
-        template<typename T>
-        struct reference_wrapper_
-        {
-            T * t_ = nullptr;
-            constexpr reference_wrapper_() = default;
-            constexpr reference_wrapper_(T & t) noexcept
-              : t_(detail::addressof(t))
-            {}
-            constexpr reference_wrapper_(T &&) = delete;
-            constexpr T & get() const noexcept
-            {
-                return *t_;
-            }
-        };
-        template<typename T>
-        struct reference_wrapper_<T &> : reference_wrapper_<T>
-        {
-            using reference_wrapper_<T>::reference_wrapper_;
-        };
-        template<typename T>
-        struct reference_wrapper_<T &&>
-        {
-            T * t_ = nullptr;
-            constexpr reference_wrapper_() = default;
-            constexpr reference_wrapper_(T && t) noexcept
-              : t_(detail::addressof(t))
-            {}
-            constexpr T && get() const noexcept
-            {
-                return static_cast<T &&>(*t_);
-            }
-        };
-    } // namespace detail
-    /// \endcond
-
-    // Can be used to store rvalue references in addition to lvalue references.
-    // Also, see: https://wg21.link/lwg2993
-    template<typename T>
-    struct reference_wrapper : private detail::reference_wrapper_<T>
-    {
-    private:
-        using base_ = detail::reference_wrapper_<T>;
-        using base_::t_;
-
-    public:
-        using type = meta::_t<std::remove_reference<T>>;
-        using reference = meta::if_<std::is_reference<T>, T, T &>;
-
-        constexpr reference_wrapper() = default;
-        template(typename U)(
-            /// \pre
-            requires (!same_as<uncvref_t<U>, reference_wrapper>) AND
-                constructible_from<base_, U>)
-        constexpr reference_wrapper(U && u) noexcept(
-            std::is_nothrow_constructible<base_, U>::value)
-          : detail::reference_wrapper_<T>{static_cast<U &&>(u)}
-        {}
-        constexpr reference get() const noexcept
-        {
-            return this->base_::get();
-        }
-        constexpr operator reference() const noexcept
-        {
-            return get();
-        }
-        template(typename...)(
-            /// \pre
-            requires (!std::is_rvalue_reference<T>::value)) //
-        operator std::reference_wrapper<type>() const noexcept
-        {
-            return {get()};
-        }
-        // clang-format off
-        template<typename ...Args>
-        constexpr auto CPP_auto_fun(operator())(Args &&...args) (const)
-        (
-            return invoke(static_cast<reference>(*t_), static_cast<Args &&>(args)...)
-        )
-        // clang-format on
-    };
-
-    struct ref_fn
-    {
-        template(typename T)(
-            /// \pre
-            requires (!is_reference_wrapper_v<T>)) //
-        reference_wrapper<T> operator()(T & t) const
-        {
-            return {t};
-        }
-        /// \overload
-        template<typename T>
-        reference_wrapper<T> operator()(reference_wrapper<T> t) const
-        {
-            return t;
-        }
-        /// \overload
-        template<typename T>
-        reference_wrapper<T> operator()(std::reference_wrapper<T> t) const
-        {
-            return {t.get()};
-        }
-    };
-
-    /// \ingroup group-functional
-    /// \sa `ref_fn`
-    RANGES_INLINE_VARIABLE(ref_fn, ref)
-
-    template<typename T>
-    using ref_t = decltype(ref(std::declval<T>()));
-
-    struct unwrap_reference_fn
-    {
-        template<typename T>
-        T && operator()(T && t) const noexcept
-        {
-            return static_cast<T &&>(t);
-        }
-        /// \overload
-        template<typename T>
-        typename reference_wrapper<T>::reference operator()(reference_wrapper<T> t) const
-            noexcept
-        {
-            return t.get();
-        }
-        /// \overload
-        template<typename T>
-        T & operator()(std::reference_wrapper<T> t) const noexcept
-        {
-            return t.get();
-        }
-        /// \overload
-        template<typename T>
-        T & operator()(ref_view<T> t) const noexcept
-        {
-            return t.base();
-        }
-    };
-
-    /// \ingroup group-functional
-    /// \sa `unwrap_reference_fn`
-    RANGES_INLINE_VARIABLE(unwrap_reference_fn, unwrap_reference)
-
-    template<typename T>
-    using unwrap_reference_t = decltype(unwrap_reference(std::declval<T>()));
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/getlines.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/getlines.hpp
deleted file mode 100644
index a3599b3d..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/getlines.hpp
+++ /dev/null
@@ -1,22 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_GETLINES_HPP
-#define RANGES_V3_GETLINES_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated. Please #include <range/v3/view/getlines.hpp> instead.")
-
-#include <range/v3/view/getlines.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/index.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/index.hpp
deleted file mode 100644
index 4bcd4cbb..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/index.hpp
+++ /dev/null
@@ -1,23 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Gonzalo Brito Gadeschi 2017
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_INDEX_HPP
-#define RANGES_V3_INDEX_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated. Please #include <range/v3/range/operations.hpp> instead.")
-
-#include <range/v3/range/operations.hpp>
-
-#endif // RANGES_V3_INDEX_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/istream_range.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/istream_range.hpp
deleted file mode 100644
index 150ef947..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/istream_range.hpp
+++ /dev/null
@@ -1,22 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ISTREAM_RANGE_HPP
-#define RANGES_V3_ISTREAM_RANGE_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated. Please #include <range/v3/view/istream.hpp> instead.")
-
-#include <range/v3/view/istream.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/iterator.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/iterator.hpp
deleted file mode 100644
index 5ab2c58c..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/iterator.hpp
+++ /dev/null
@@ -1,32 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2019-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ITERATOR_HPP
-#define RANGES_V3_ITERATOR_HPP
-
-#include <range/v3/iterator/access.hpp>
-#include <range/v3/iterator/basic_iterator.hpp>
-#include <range/v3/iterator/common_iterator.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/counted_iterator.hpp>
-#include <range/v3/iterator/default_sentinel.hpp>
-#include <range/v3/iterator/diffmax_t.hpp>
-#include <range/v3/iterator/insert_iterators.hpp>
-#include <range/v3/iterator/move_iterators.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/reverse_iterator.hpp>
-#include <range/v3/iterator/stream_iterators.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/iterator/unreachable_sentinel.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/iterator/access.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/iterator/access.hpp
deleted file mode 100644
index 9b22c390..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/iterator/access.hpp
+++ /dev/null
@@ -1,304 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ITERATOR_ACCESS_HPP
-#define RANGES_V3_ITERATOR_ACCESS_HPP
-
-#include <iterator>
-#include <type_traits>
-#include <utility>
-
-#include <std/detail/associated_types.hpp>
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/utility/move.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/utility/swap.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-iterator
-    /// @{
-
-    /// \cond
-    namespace detail
-    {
-        template<typename I,
-#ifdef RANGES_WORKAROUND_MSVC_683388
-                 typename R = meta::conditional_t<
-                     std::is_pointer<uncvref_t<I>>::value &&
-                         std::is_array<std::remove_pointer_t<uncvref_t<I>>>::value,
-                     std::add_lvalue_reference_t<std::remove_pointer_t<uncvref_t<I>>>,
-                     decltype(*std::declval<I &>())>,
-#else
-                 typename R = decltype(*std::declval<I &>()),
-#endif
-                 typename = R &>
-        using iter_reference_t_ = R;
-
-#if defined(RANGES_DEEP_STL_INTEGRATION) && RANGES_DEEP_STL_INTEGRATION && \
-    !defined(RANGES_DOXYGEN_INVOKED)
-        template<typename T>
-        using iter_value_t_ =
-            typename meta::conditional_t<
-                is_std_iterator_traits_specialized_v<T>,
-                std::iterator_traits<T>,
-                indirectly_readable_traits<T>>::value_type;
-#else
-        template<typename T>
-        using iter_value_t_ = typename indirectly_readable_traits<T>::value_type;
-#endif
-    } // namespace detail
-    /// \endcond
-
-    template<typename R>
-    using iter_reference_t = detail::iter_reference_t_<R>;
-
-    template<typename R>
-    using iter_value_t = detail::iter_value_t_<uncvref_t<R>>;
-
-    /// \cond
-    namespace _iter_move_
-    {
-#if RANGES_BROKEN_CPO_LOOKUP
-        void iter_move(); // unqualified name lookup block
-#endif
-
-        template<typename T>
-        decltype(iter_move(std::declval<T>())) try_adl_iter_move_(int);
-
-        template<typename T>
-        void try_adl_iter_move_(long);
-
-        template<typename T>
-        RANGES_INLINE_VAR constexpr bool is_adl_indirectly_movable_v =
-            !RANGES_IS_SAME(void, decltype(_iter_move_::try_adl_iter_move_<T>(42)));
-
-        struct fn
-        {
-            // clang-format off
-            template<typename I,
-                     typename = detail::enable_if_t<is_adl_indirectly_movable_v<I &>>>
-#ifndef RANGES_WORKAROUND_CLANG_23135
-            constexpr
-#endif // RANGES_WORKAROUND_CLANG_23135
-            auto CPP_auto_fun(operator())(I &&i)(const)
-            (
-                return iter_move(i)
-            )
-
-            template<
-                typename I,
-                typename = detail::enable_if_t<!is_adl_indirectly_movable_v<I &>>,
-                typename R = iter_reference_t<I>>
-#ifndef RANGES_WORKAROUND_CLANG_23135
-            constexpr
-#endif // RANGES_WORKAROUND_CLANG_23135
-            auto CPP_auto_fun(operator())(I &&i)(const)
-            (
-                return static_cast<aux::move_t<R>>(aux::move(*i))
-            )
-            // clang-format on
-        };
-    } // namespace _iter_move_
-    /// \endcond
-
-    RANGES_DEFINE_CPO(_iter_move_::fn, iter_move)
-
-    /// \cond
-    namespace detail
-    {
-        template<typename I, typename O>
-        auto is_indirectly_movable_(I & (*i)(), O & (*o)(), iter_value_t<I> * v = nullptr)
-            -> always_<std::true_type,
-                       decltype(iter_value_t<I>(iter_move(i()))),
-                       decltype(*v = iter_move(i())),
-                       decltype(*o() = (iter_value_t<I> &&) * v),
-                       decltype(*o() = iter_move(i()))>;
-        template<typename I, typename O>
-        auto is_indirectly_movable_(...) -> std::false_type;
-
-        template<typename I, typename O>
-        auto is_nothrow_indirectly_movable_(iter_value_t<I> * v) -> meta::bool_<
-            noexcept(iter_value_t<I>(iter_move(std::declval<I &>()))) &&
-            noexcept(*v = iter_move(std::declval<I &>())) &&
-            noexcept(*std::declval<O &>() = (iter_value_t<I> &&) * v) &&
-            noexcept(*std::declval<O &>() = iter_move(std::declval<I &>()))>;
-        template<typename I, typename O>
-        auto is_nothrow_indirectly_movable_(...) -> std::false_type;
-    } // namespace detail
-    /// \endcond
-
-    template<typename I, typename O>
-    RANGES_INLINE_VAR constexpr bool is_indirectly_movable_v =
-        decltype(detail::is_indirectly_movable_<I, O>(nullptr, nullptr))::value;
-
-    template<typename I, typename O>
-    RANGES_INLINE_VAR constexpr bool is_nothrow_indirectly_movable_v =
-        decltype(detail::is_nothrow_indirectly_movable_<I, O>(nullptr))::value;
-
-    template<typename I, typename O>
-    struct is_indirectly_movable : meta::bool_<is_indirectly_movable_v<I, O>>
-    {};
-
-    template<typename I, typename O>
-    struct is_nothrow_indirectly_movable
-      : meta::bool_<is_nothrow_indirectly_movable_v<I, O>>
-    {};
-
-    /// \cond
-    namespace _iter_swap_
-    {
-        struct nope
-        {};
-
-        // Q: Should std::reference_wrapper be considered a proxy wrt swapping rvalues?
-        // A: No. Its operator= is currently defined to reseat the references, so
-        //    std::swap(ra, rb) already means something when ra and rb are (lvalue)
-        //    reference_wrappers. That reseats the reference wrappers but leaves the
-        //    referents unmodified. Treating rvalue reference_wrappers differently would
-        //    be confusing.
-
-        // Q: Then why is it OK to "re"-define swap for pairs and tuples of references?
-        // A: Because as defined above, swapping an rvalue tuple of references has the
-        //    same semantics as swapping an lvalue tuple of references. Rather than
-        //    reseat the references, assignment happens *through* the references.
-
-        // Q: But I have an iterator whose operator* returns an rvalue
-        //    std::reference_wrapper<T>. How do I make it model indirectly_swappable?
-        // A: With an overload of iter_swap.
-
-        // Intentionally create an ambiguity with std::iter_swap, which is
-        // unconstrained.
-        template<typename T, typename U>
-        nope iter_swap(T, U) = delete;
-
-#ifdef RANGES_WORKAROUND_MSVC_895622
-        nope iter_swap();
-#endif
-
-        template<typename T, typename U>
-        decltype(iter_swap(std::declval<T>(), std::declval<U>())) try_adl_iter_swap_(int);
-
-        template<typename T, typename U>
-        nope try_adl_iter_swap_(long);
-
-        // Test whether an overload of iter_swap for a T and a U can be found
-        // via ADL with the iter_swap overload above participating in the
-        // overload set. This depends on user-defined iter_swap overloads
-        // being a better match than the overload in namespace std.
-        template<typename T, typename U>
-        RANGES_INLINE_VAR constexpr bool is_adl_indirectly_swappable_v =
-            !RANGES_IS_SAME(nope, decltype(_iter_swap_::try_adl_iter_swap_<T, U>(42)));
-
-        struct fn
-        {
-            // *If* a user-defined iter_swap is found via ADL, call that:
-            template<typename T, typename U>
-            constexpr detail::enable_if_t<is_adl_indirectly_swappable_v<T, U>> operator()(
-                T && t, U && u) const noexcept(noexcept(iter_swap((T &&) t, (U &&) u)))
-            {
-                (void)iter_swap((T &&) t, (U &&) u);
-            }
-
-            // *Otherwise*, for readable types with swappable reference
-            // types, call ranges::swap(*a, *b)
-            template<typename I0, typename I1>
-            constexpr detail::enable_if_t<
-                !is_adl_indirectly_swappable_v<I0, I1> &&
-                is_swappable_with<iter_reference_t<I0>, iter_reference_t<I1>>::value>
-            operator()(I0 && a, I1 && b) const noexcept(noexcept(ranges::swap(*a, *b)))
-            {
-                ranges::swap(*a, *b);
-            }
-
-            // *Otherwise*, for readable types that are mutually
-            // indirectly_movable_storable, implement as:
-            //      iter_value_t<T0> tmp = iter_move(a);
-            //      *a = iter_move(b);
-            //      *b = std::move(tmp);
-            template<typename I0, typename I1>
-            constexpr detail::enable_if_t<
-                !is_adl_indirectly_swappable_v<I0, I1> &&
-                !is_swappable_with<iter_reference_t<I0>, iter_reference_t<I1>>::value &&
-                is_indirectly_movable_v<I0, I1> && is_indirectly_movable_v<I1, I0>>
-            operator()(I0 && a, I1 && b) const
-                noexcept(is_nothrow_indirectly_movable_v<I0, I1> &&
-                             is_nothrow_indirectly_movable_v<I1, I0>)
-            {
-                iter_value_t<I0> v0 = iter_move(a);
-                *a = iter_move(b);
-                *b = detail::move(v0);
-            }
-        };
-    } // namespace _iter_swap_
-    /// \endcond
-
-    /// \relates _iter_swap_::fn
-    RANGES_DEFINE_CPO(_iter_swap_::fn, iter_swap)
-
-    /// \cond
-    namespace detail
-    {
-        template<typename T, typename U>
-        auto is_indirectly_swappable_(T & (*t)(), U & (*u)())
-            -> detail::always_<std::true_type, decltype(iter_swap(t(), u()))>;
-        template<typename T, typename U>
-        auto is_indirectly_swappable_(...) -> std::false_type;
-
-        template<typename T, typename U>
-        auto is_nothrow_indirectly_swappable_(int)
-            -> meta::bool_<noexcept(iter_swap(std::declval<T &>(), std::declval<U &>()))>;
-        template<typename T, typename U>
-        auto is_nothrow_indirectly_swappable_(long) -> std::false_type;
-    } // namespace detail
-    /// \endcond
-
-    template<typename T, typename U>
-    RANGES_INLINE_VAR constexpr bool is_indirectly_swappable_v =
-        decltype(detail::is_indirectly_swappable_<T, U>(nullptr, nullptr))::value;
-
-    template<typename T, typename U>
-    RANGES_INLINE_VAR constexpr bool is_nothrow_indirectly_swappable_v =
-        decltype(detail::is_nothrow_indirectly_swappable_<T, U>(0))::value;
-
-    template<typename T, typename U>
-    struct is_indirectly_swappable : meta::bool_<is_indirectly_swappable_v<T, U>>
-    {};
-
-    template<typename T, typename U>
-    struct is_nothrow_indirectly_swappable
-      : meta::bool_<is_nothrow_indirectly_swappable_v<T, U>>
-    {};
-
-    namespace cpp20
-    {
-        using ranges::iter_move;
-        using ranges::iter_reference_t;
-        using ranges::iter_swap;
-        using ranges::iter_value_t;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif // RANGES_V3_ITERATOR_ACCESS_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/iterator/basic_iterator.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/iterator/basic_iterator.hpp
deleted file mode 100644
index 69889378..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/iterator/basic_iterator.hpp
+++ /dev/null
@@ -1,1081 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ITERATOR_BASIC_ITERATOR_HPP
-#define RANGES_V3_ITERATOR_BASIC_ITERATOR_HPP
-
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/detail/range_access.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/utility/addressof.hpp>
-#include <range/v3/utility/box.hpp>
-#include <range/v3/utility/move.hpp>
-#include <range/v3/utility/semiregular_box.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-RANGES_DIAGNOSTIC_PUSH
-RANGES_DIAGNOSTIC_IGNORE_MULTIPLE_ASSIGNMENT_OPERATORS
-
-namespace ranges
-{
-    /// \addtogroup group-iterator Iterator
-    /// @{
-    ///
-    template<typename T>
-    struct basic_mixin : private box<T>
-    {
-        CPP_member
-        constexpr CPP_ctor(basic_mixin)()(                            //
-            noexcept(std::is_nothrow_default_constructible<T>::value) //
-                requires default_constructible<T>)
-          : box<T>{}
-        {}
-        CPP_member
-        constexpr explicit CPP_ctor(basic_mixin)(T && t)(          //
-            noexcept(std::is_nothrow_move_constructible<T>::value) //
-                requires move_constructible<T>)
-          : box<T>(detail::move(t))
-        {}
-        CPP_member
-        constexpr explicit CPP_ctor(basic_mixin)(T const & t)(     //
-            noexcept(std::is_nothrow_copy_constructible<T>::value) //
-                requires copy_constructible<T>)
-          : box<T>(t)
-        {}
-
-    protected:
-        using box<T>::get;
-    };
-
-    /// \cond
-    namespace detail
-    {
-        template<typename Cur>
-        using cursor_reference_t =
-            decltype(range_access::read(std::declval<Cur const &>()));
-
-        // Compute the rvalue reference type of a cursor
-        template<typename Cur>
-        auto cursor_move(Cur const & cur, int) -> decltype(range_access::move(cur));
-        template<typename Cur>
-        auto cursor_move(Cur const & cur, long) -> aux::move_t<cursor_reference_t<Cur>>;
-
-        template<typename Cur>
-        using cursor_rvalue_reference_t =
-            decltype(detail::cursor_move(std::declval<Cur const &>(), 42));
-
-        // Define conversion operators from the proxy reference type
-        // to the common reference types, so that basic_iterator can model readable
-        // even with getters/setters.
-        template<typename Derived, typename Head>
-        struct proxy_reference_conversion
-        {
-            operator Head() const
-                noexcept(noexcept(Head(Head(std::declval<Derived const &>().read_()))))
-            {
-                return Head(static_cast<Derived const *>(this)->read_());
-            }
-        };
-
-        // Collect the reference types associated with cursors
-        template<typename Cur, bool IsReadable>
-        struct cursor_traits_
-        {
-        private:
-            struct private_
-            {};
-
-        public:
-            using value_t_ = private_;
-            using reference_t_ = private_;
-            using rvalue_reference_t_ = private_;
-            using common_refs = meta::list<>;
-        };
-
-        template<typename Cur>
-        struct cursor_traits_<Cur, true>
-        {
-            using value_t_ = range_access::cursor_value_t<Cur>;
-            using reference_t_ = cursor_reference_t<Cur>;
-            using rvalue_reference_t_ = cursor_rvalue_reference_t<Cur>;
-
-        private:
-            using R1 = reference_t_;
-            using R2 = common_reference_t<reference_t_, value_t_ &>;
-            using R3 = common_reference_t<reference_t_, rvalue_reference_t_>;
-            using tmp1 = meta::list<value_t_, R1>;
-            using tmp2 =
-                meta::if_<meta::in<tmp1, uncvref_t<R2>>, tmp1, meta::push_back<tmp1, R2>>;
-            using tmp3 =
-                meta::if_<meta::in<tmp2, uncvref_t<R3>>, tmp2, meta::push_back<tmp2, R3>>;
-
-        public:
-            using common_refs = meta::unique<meta::pop_front<tmp3>>;
-        };
-
-        template<typename Cur>
-        using cursor_traits = cursor_traits_<Cur, (bool)readable_cursor<Cur>>;
-
-        template<typename Cur>
-        using cursor_value_t = typename cursor_traits<Cur>::value_t_;
-
-        template<typename Cur, bool IsReadable>
-        struct basic_proxy_reference_;
-        template<typename Cur>
-        using basic_proxy_reference =
-            basic_proxy_reference_<Cur, (bool)readable_cursor<Cur>>;
-
-        // The One Proxy Reference type to rule them all. basic_iterator uses this
-        // as the return type of operator* when the cursor type has a set() member
-        // function of the correct signature (i.e., if it can accept a value_type &&).
-        template<typename Cur, bool IsReadable /*= (bool) readable_cursor<Cur>*/>
-        struct RANGES_EMPTY_BASES basic_proxy_reference_
-          : cursor_traits<Cur>
-          // The following adds conversion operators to the common reference
-          // types, so that basic_proxy_reference can model readable
-          , meta::inherit<meta::transform<
-                typename cursor_traits<Cur>::common_refs,
-                meta::bind_front<meta::quote<proxy_reference_conversion>,
-                                 basic_proxy_reference_<Cur, IsReadable>>>>
-        {
-        private:
-            Cur * cur_;
-            template<typename, bool>
-            friend struct basic_proxy_reference_;
-            template<typename, typename>
-            friend struct proxy_reference_conversion;
-            using typename cursor_traits<Cur>::value_t_;
-            using typename cursor_traits<Cur>::reference_t_;
-            using typename cursor_traits<Cur>::rvalue_reference_t_;
-            static_assert((bool)common_reference_with<value_t_ &, reference_t_>,
-                          "Your readable and writable cursor must have a value type and "
-                          "a reference type that share a common reference type. See the "
-                          "ranges::common_reference type trait.");
-            // BUGBUG make these private:
-        public:
-            constexpr reference_t_ read_() const noexcept(
-                noexcept(reference_t_(range_access::read(std::declval<Cur const &>()))))
-            {
-                return range_access::read(*cur_);
-            }
-            template<typename T>
-            constexpr void write_(T && t) const
-            {
-                range_access::write(*cur_, (T &&) t);
-            }
-            // public:
-            basic_proxy_reference_() = default;
-            basic_proxy_reference_(basic_proxy_reference_ const &) = default;
-            template(typename OtherCur)(
-                /// \pre
-                requires convertible_to<OtherCur *, Cur *>)
-            constexpr basic_proxy_reference_(
-                basic_proxy_reference<OtherCur> const & that) noexcept
-              : cur_(that.cur_)
-            {}
-            constexpr explicit basic_proxy_reference_(Cur & cur) noexcept
-              : cur_(&cur)
-            {}
-            CPP_member
-            constexpr auto operator=(basic_proxy_reference_ && that)
-                -> CPP_ret(basic_proxy_reference_ &)(
-                    /// \pre
-                    requires readable_cursor<Cur>)
-            {
-                return *this = that;
-            }
-            CPP_member
-            constexpr auto operator=(basic_proxy_reference_ const & that)
-                -> CPP_ret(basic_proxy_reference_ &)(
-                    /// \pre
-                    requires readable_cursor<Cur>)
-            {
-                this->write_(that.read_());
-                return *this;
-            }
-            CPP_member
-            constexpr auto operator=(basic_proxy_reference_ && that) const
-                -> CPP_ret(basic_proxy_reference_ const &)(
-                    /// \pre
-                    requires readable_cursor<Cur>)
-            {
-                return *this = that;
-            }
-            CPP_member
-            constexpr auto operator=(basic_proxy_reference_ const & that) const
-                -> CPP_ret(basic_proxy_reference_ const &)(
-                    /// \pre
-                    requires readable_cursor<Cur>)
-            {
-                this->write_(that.read_());
-                return *this;
-            }
-            template(typename OtherCur)(
-                /// \pre
-                requires readable_cursor<OtherCur> AND
-                    writable_cursor<Cur, cursor_reference_t<OtherCur>>)
-            constexpr basic_proxy_reference_ & //
-            operator=(basic_proxy_reference<OtherCur> && that)
-            {
-                return *this = that;
-            }
-            template(typename OtherCur)(
-                /// \pre
-                requires readable_cursor<OtherCur> AND
-                    writable_cursor<Cur, cursor_reference_t<OtherCur>>)
-            constexpr basic_proxy_reference_ & //
-            operator=(basic_proxy_reference<OtherCur> const & that)
-            {
-                this->write_(that.read_());
-                return *this;
-            }
-            template(typename OtherCur)(
-                /// \pre
-                requires readable_cursor<OtherCur> AND
-                    writable_cursor<Cur, cursor_reference_t<OtherCur>>)
-            constexpr basic_proxy_reference_ const & //
-            operator=(basic_proxy_reference<OtherCur> && that) const
-            {
-                return *this = that;
-            }
-            template(typename OtherCur)(
-                /// \pre
-                requires readable_cursor<OtherCur> AND
-                    writable_cursor<Cur, cursor_reference_t<OtherCur>>)
-            constexpr basic_proxy_reference_ const & //
-            operator=(basic_proxy_reference<OtherCur> const & that) const
-            {
-                this->write_(that.read_());
-                return *this;
-            }
-            template(typename T)(
-                /// \pre
-                requires writable_cursor<Cur, T>)
-            constexpr basic_proxy_reference_ & operator=(T && t) //
-            {
-                this->write_((T &&) t);
-                return *this;
-            }
-            template(typename T)(
-                /// \pre
-                requires writable_cursor<Cur, T>)
-            constexpr basic_proxy_reference_ const & operator=(T && t) const
-            {
-                this->write_((T &&) t);
-                return *this;
-            }
-        };
-
-        template(typename Cur, bool IsReadable)(
-            /// \pre
-            requires readable_cursor<Cur> AND equality_comparable<cursor_value_t<Cur>>)
-        constexpr bool operator==(basic_proxy_reference_<Cur, IsReadable> const & x,
-                                  cursor_value_t<Cur> const & y)
-        {
-            return x.read_() == y;
-        }
-        template(typename Cur, bool IsReadable)(
-            /// \pre
-            requires readable_cursor<Cur> AND equality_comparable<cursor_value_t<Cur>>)
-        constexpr bool operator!=(basic_proxy_reference_<Cur, IsReadable> const & x,
-                                  cursor_value_t<Cur> const & y)
-        {
-            return !(x == y);
-        }
-        template(typename Cur, bool IsReadable)(
-            /// \pre
-            requires readable_cursor<Cur> AND equality_comparable<cursor_value_t<Cur>>)
-        constexpr bool operator==(cursor_value_t<Cur> const & x,
-                                  basic_proxy_reference_<Cur, IsReadable> const & y)
-        {
-            return x == y.read_();
-        }
-        template(typename Cur, bool IsReadable)(
-            /// \pre
-            requires readable_cursor<Cur> AND equality_comparable<cursor_value_t<Cur>>)
-        constexpr bool operator!=(cursor_value_t<Cur> const & x,
-                                  basic_proxy_reference_<Cur, IsReadable> const & y)
-        {
-            return !(x == y);
-        }
-        template(typename Cur, bool IsReadable)(
-            /// \pre
-            requires readable_cursor<Cur> AND equality_comparable<cursor_value_t<Cur>>)
-        constexpr bool operator==(basic_proxy_reference_<Cur, IsReadable> const & x,
-                                  basic_proxy_reference_<Cur, IsReadable> const & y)
-        {
-            return x.read_() == y.read_();
-        }
-        template(typename Cur, bool IsReadable)(
-            /// \pre
-            requires readable_cursor<Cur> AND equality_comparable<cursor_value_t<Cur>>)
-        constexpr bool operator!=(basic_proxy_reference_<Cur, IsReadable> const & x,
-                                  basic_proxy_reference_<Cur, IsReadable> const & y)
-        {
-            return !(x == y);
-        }
-
-        template<typename Cur>
-        using cpp20_iter_cat_of_t =                             //
-            std::enable_if_t<                                   //
-                input_cursor<Cur>,                              //
-                meta::conditional_t<                            //
-                    contiguous_cursor<Cur>,                     //
-                    ranges::contiguous_iterator_tag,            //
-                    meta::conditional_t<                        //
-                        random_access_cursor<Cur>,              //
-                        std::random_access_iterator_tag,        //
-                        meta::conditional_t<                    //
-                            bidirectional_cursor<Cur>,          //
-                            std::bidirectional_iterator_tag,    //
-                            meta::conditional_t<                //
-                                forward_cursor<Cur>,            //
-                                std::forward_iterator_tag,      //
-                                std::input_iterator_tag>>>>>;
-
-        // clang-format off
-        template(typename C)(
-        concept (cpp17_input_cursor_)(C),
-            // Either it is not single-pass, or else we can create a
-            // proxy for postfix increment.
-            !range_access::single_pass_t<uncvref_t<C>>::value ||
-            (move_constructible<range_access::cursor_value_t<C>> &&
-             constructible_from<range_access::cursor_value_t<C>, cursor_reference_t<C>>)
-        );
-
-        template<typename C>
-        CPP_concept cpp17_input_cursor =
-            input_cursor<C> &&
-            sentinel_for_cursor<C, C> &&
-            CPP_concept_ref(cpp17_input_cursor_, C);
-
-        template(typename C)(
-        concept (cpp17_forward_cursor_)(C),
-            std::is_reference<cursor_reference_t<C>>::value
-        );
-
-        template<typename C>
-        CPP_concept cpp17_forward_cursor =
-            forward_cursor<C> &&
-            CPP_concept_ref(cpp17_forward_cursor_, C);
-        // clang-format on
-
-        template<typename Category, typename Base = void>
-        struct with_iterator_category : Base
-        {
-            using iterator_category = Category;
-        };
-
-        template<typename Category>
-        struct with_iterator_category<Category>
-        {
-            using iterator_category = Category;
-        };
-
-        template<typename Cur>
-        using cpp17_iter_cat_of_t =                      //
-            std::enable_if_t<                            //
-                cpp17_input_cursor<Cur>,                 //
-                meta::conditional_t<                       //
-                    random_access_cursor<Cur>,           //
-                    std::random_access_iterator_tag,     //
-                    meta::conditional_t<                   //
-                        bidirectional_cursor<Cur>,       //
-                        std::bidirectional_iterator_tag, //
-                        meta::conditional_t<               //
-                            cpp17_forward_cursor<Cur>,   //
-                            std::forward_iterator_tag,   //
-                            std::input_iterator_tag>>>>;
-
-        template<typename Cur, typename = void>
-        struct readable_iterator_associated_types_base : range_access::mixin_base_t<Cur>
-        {
-            readable_iterator_associated_types_base() = default;
-            using range_access::mixin_base_t<Cur>::mixin_base_t;
-            readable_iterator_associated_types_base(Cur && cur)
-              : range_access::mixin_base_t<Cur>(static_cast<Cur &&>(cur))
-            {}
-            readable_iterator_associated_types_base(Cur const & cur)
-              : range_access::mixin_base_t<Cur>(cur)
-            {}
-        };
-
-        template<typename Cur>
-        struct readable_iterator_associated_types_base<
-            Cur, always_<void, cpp17_iter_cat_of_t<Cur>>>
-          : range_access::mixin_base_t<Cur>
-        {
-            using iterator_category = cpp17_iter_cat_of_t<Cur>;
-            readable_iterator_associated_types_base() = default;
-            using range_access::mixin_base_t<Cur>::mixin_base_t;
-            readable_iterator_associated_types_base(Cur && cur)
-              : range_access::mixin_base_t<Cur>(static_cast<Cur &&>(cur))
-            {}
-            readable_iterator_associated_types_base(Cur const & cur)
-              : range_access::mixin_base_t<Cur>(cur)
-            {}
-        };
-
-        template<typename Cur, bool IsReadable /*= (bool) readable_cursor<Cur>*/>
-        struct iterator_associated_types_base_ : range_access::mixin_base_t<Cur>
-        {
-            // BUGBUG
-            // protected:
-            using iter_reference_t = basic_proxy_reference<Cur>;
-            using const_reference_t = basic_proxy_reference<Cur const>;
-
-        public:
-            using reference = void;
-            using difference_type = range_access::cursor_difference_t<Cur>;
-
-            iterator_associated_types_base_() = default;
-            using range_access::mixin_base_t<Cur>::mixin_base_t;
-            iterator_associated_types_base_(Cur && cur)
-              : range_access::mixin_base_t<Cur>(static_cast<Cur &&>(cur))
-            {}
-            iterator_associated_types_base_(Cur const & cur)
-              : range_access::mixin_base_t<Cur>(cur)
-            {}
-        };
-
-        template<typename Cur>
-        using cursor_arrow_t = decltype(range_access::arrow(std::declval<Cur const &>()));
-
-        template<typename Cur>
-        struct iterator_associated_types_base_<Cur, true>
-          : readable_iterator_associated_types_base<Cur>
-        {
-            // BUGBUG
-            // protected:
-            using iter_reference_t =
-                meta::conditional_t<is_writable_cursor_v<Cur const>,
-                          basic_proxy_reference<Cur const>,
-                          meta::conditional_t<is_writable_cursor_v<Cur>,
-                                    basic_proxy_reference<Cur>, cursor_reference_t<Cur>>>;
-            using const_reference_t =
-                meta::conditional_t<is_writable_cursor_v<Cur const>,
-                          basic_proxy_reference<Cur const>, cursor_reference_t<Cur>>;
-
-        public:
-            using difference_type = range_access::cursor_difference_t<Cur>;
-            using value_type = range_access::cursor_value_t<Cur>;
-            using reference = iter_reference_t;
-            using iterator_concept = cpp20_iter_cat_of_t<Cur>;
-            using pointer = meta::_t<
-                meta::conditional_t<
-                    (bool)has_cursor_arrow<Cur>,
-                    meta::defer<cursor_arrow_t, Cur>,
-                    std::add_pointer<reference>>>;
-            using common_reference = common_reference_t<reference, value_type &>;
-
-            iterator_associated_types_base_() = default;
-            using readable_iterator_associated_types_base<
-                Cur>::readable_iterator_associated_types_base;
-            iterator_associated_types_base_(Cur && cur)
-              : readable_iterator_associated_types_base<Cur>(static_cast<Cur &&>(cur))
-            {}
-            iterator_associated_types_base_(Cur const & cur)
-              : readable_iterator_associated_types_base<Cur>(cur)
-            {}
-        };
-
-        template<typename Cur>
-        using iterator_associated_types_base =
-            iterator_associated_types_base_<Cur, (bool)readable_cursor<Cur>>;
-
-        template<typename Value>
-        struct postfix_increment_proxy
-        {
-        private:
-            Value cache_;
-
-        public:
-            template<typename T>
-            constexpr postfix_increment_proxy(T && t)
-              : cache_(static_cast<T &&>(t))
-            {}
-            constexpr Value const & operator*() const noexcept
-            {
-                return cache_;
-            }
-        };
-    } // namespace detail
-    /// \endcond
-
-#if RANGES_BROKEN_CPO_LOOKUP
-    namespace _basic_iterator_
-    {
-        template<typename>
-        struct adl_hook
-        {};
-    } // namespace _basic_iterator_
-#endif
-
-    template<typename Cur>
-    struct RANGES_EMPTY_BASES basic_iterator
-      : detail::iterator_associated_types_base<Cur>
-#if RANGES_BROKEN_CPO_LOOKUP
-      , private _basic_iterator_::adl_hook<basic_iterator<Cur>>
-#endif
-    {
-    private:
-        template<typename>
-        friend struct basic_iterator;
-        friend range_access;
-        using base_t = detail::iterator_associated_types_base<Cur>;
-        using mixin_t = range_access::mixin_base_t<Cur>;
-        static_assert((bool)detail::cursor<Cur>, "");
-        using assoc_types_ = detail::iterator_associated_types_base<Cur>;
-        using typename assoc_types_::const_reference_t;
-        using typename assoc_types_::iter_reference_t;
-        constexpr Cur & pos() noexcept
-        {
-            return this->mixin_t::basic_mixin::get();
-        }
-        constexpr Cur const & pos() const noexcept
-        {
-            return this->mixin_t::basic_mixin::get();
-        }
-
-    public:
-        using typename assoc_types_::difference_type;
-        constexpr basic_iterator() = default;
-        template(typename OtherCur)(
-            /// \pre
-            requires (!same_as<OtherCur, Cur>) AND convertible_to<OtherCur, Cur> AND
-            constructible_from<mixin_t, OtherCur>)
-        constexpr basic_iterator(basic_iterator<OtherCur> that)
-          : base_t{std::move(that.pos())}
-        {}
-        // Mix in any additional constructors provided by the mixin
-        using base_t::base_t;
-
-        explicit basic_iterator(Cur && cur)
-          : base_t(static_cast<Cur &&>(cur))
-        {}
-
-        explicit basic_iterator(Cur const & cur)
-          : base_t(cur)
-        {}
-
-        template(typename OtherCur)(
-            /// \pre
-            requires (!same_as<OtherCur, Cur>) AND convertible_to<OtherCur, Cur>)
-        constexpr basic_iterator & operator=(basic_iterator<OtherCur> that)
-        {
-            pos() = std::move(that.pos());
-            return *this;
-        }
-
-        CPP_member
-        constexpr auto operator*() const
-            noexcept(noexcept(range_access::read(std::declval<Cur const &>())))
-            -> CPP_ret(const_reference_t)(
-                /// \pre
-                requires detail::readable_cursor<Cur> &&
-                    (!detail::is_writable_cursor_v<Cur>))
-        {
-            return range_access::read(pos());
-        }
-        CPP_member
-        constexpr auto operator*() //
-            noexcept(noexcept(iter_reference_t{std::declval<Cur &>()})) //
-            -> CPP_ret(iter_reference_t)(
-                /// \pre
-                requires detail::has_cursor_next<Cur> &&
-                    detail::is_writable_cursor_v<Cur>)
-        {
-            return iter_reference_t{pos()};
-        }
-        CPP_member
-        constexpr auto operator*() const
-            noexcept(noexcept(const_reference_t{std::declval<Cur const &>()}))
-            -> CPP_ret(const_reference_t)(
-                /// \pre
-                requires detail::has_cursor_next<Cur> &&
-                    detail::is_writable_cursor_v<Cur const>)
-        {
-            return const_reference_t{pos()};
-        }
-        CPP_member
-        constexpr auto operator*() noexcept //
-            -> CPP_ret(basic_iterator &)(
-                /// \pre
-                requires (!detail::has_cursor_next<Cur>))
-        {
-            return *this;
-        }
-
-        // Use cursor's arrow() member, if any.
-        template(typename C = Cur)(
-            /// \pre
-            requires detail::has_cursor_arrow<C>)
-        constexpr detail::cursor_arrow_t<C> operator-> () const
-            noexcept(noexcept(range_access::arrow(std::declval<C const &>())))
-        {
-            return range_access::arrow(pos());
-        }
-        // Otherwise, if iter_reference_t is an lvalue reference to cv-qualified
-        // iter_value_t, return the address of **this.
-        template(typename C = Cur)(
-            /// \pre
-            requires (!detail::has_cursor_arrow<C>) AND detail::readable_cursor<C> AND
-                std::is_lvalue_reference<const_reference_t>::value AND
-                same_as<typename detail::iterator_associated_types_base<C>::value_type,
-                        uncvref_t<const_reference_t>>)
-        constexpr std::add_pointer_t<const_reference_t> operator-> () const
-            noexcept(noexcept(*std::declval<basic_iterator const &>()))
-        {
-            return detail::addressof(**this);
-        }
-
-        CPP_member
-        constexpr auto operator++() //
-            -> CPP_ret(basic_iterator &)(
-                /// \pre
-                requires detail::has_cursor_next<Cur>)
-        {
-            range_access::next(pos());
-            return *this;
-        }
-        CPP_member
-        constexpr auto operator++() noexcept //
-            -> CPP_ret(basic_iterator &)(
-                /// \pre
-                requires (!detail::has_cursor_next<Cur>))
-        {
-            return *this;
-        }
-
-    private:
-        constexpr basic_iterator post_increment_(std::false_type, int)
-        {
-            basic_iterator tmp{*this};
-            ++*this;
-            return tmp;
-        }
-        // Attempt to satisfy the C++17 iterator requirements by returning a
-        // proxy from postfix increment:
-        template(typename A = assoc_types_, typename V = typename A::value_type)(
-            /// \pre
-            requires constructible_from<V, typename A::reference> AND
-                move_constructible<V>)
-        constexpr auto post_increment_(std::true_type, int) //
-            -> detail::postfix_increment_proxy<V>
-        {
-            detail::postfix_increment_proxy<V> p{**this};
-            ++*this;
-            return p;
-        }
-        constexpr void post_increment_(std::true_type, long)
-        {
-            ++*this;
-        }
-
-    public:
-        CPP_member
-        constexpr auto operator++(int)
-        {
-            return this->post_increment_(meta::bool_ < detail::input_cursor<Cur> &&
-                                             !detail::forward_cursor<Cur>> {},
-                                         0);
-        }
-
-        CPP_member
-        constexpr auto operator--()
-            -> CPP_ret(basic_iterator &)(
-                /// \pre
-                requires detail::bidirectional_cursor<Cur>)
-        {
-            range_access::prev(pos());
-            return *this;
-        }
-        CPP_member
-        constexpr auto operator--(int) //
-            -> CPP_ret(basic_iterator)(
-                /// \pre
-                requires detail::bidirectional_cursor<Cur>)
-        {
-            basic_iterator tmp(*this);
-            --*this;
-            return tmp;
-        }
-        CPP_member
-        constexpr auto operator+=(difference_type n) //
-            -> CPP_ret(basic_iterator &)(
-                /// \pre
-                requires detail::random_access_cursor<Cur>)
-        {
-            range_access::advance(pos(), n);
-            return *this;
-        }
-        CPP_member
-        constexpr auto operator-=(difference_type n) //
-            -> CPP_ret(basic_iterator &)(
-                /// \pre
-                requires detail::random_access_cursor<Cur>)
-        {
-            range_access::advance(pos(), (difference_type)-n);
-            return *this;
-        }
-        CPP_member
-        constexpr auto operator[](difference_type n) const //
-            -> CPP_ret(const_reference_t)(
-                /// \pre
-                requires detail::random_access_cursor<Cur>)
-        {
-            return *(*this + n);
-        }
-
-#if !RANGES_BROKEN_CPO_LOOKUP
-        // Optionally support hooking iter_move when the cursor sports a
-        // move() member function.
-        template<typename C = Cur>
-        friend constexpr auto iter_move(basic_iterator const & it) noexcept(
-            noexcept(range_access::move(std::declval<C const &>())))
-            -> CPP_broken_friend_ret(
-                decltype(range_access::move(std::declval<C const &>())))(
-                /// \pre
-                requires same_as<C, Cur> && detail::input_cursor<Cur>)
-        {
-            return range_access::move(it.pos());
-        }
-#endif
-    };
-
-    template(typename Cur, typename Cur2)(
-        /// \pre
-        requires detail::sentinel_for_cursor<Cur2, Cur>)
-    constexpr bool operator==(basic_iterator<Cur> const & left,
-                              basic_iterator<Cur2> const & right)
-    {
-        return range_access::equal(range_access::pos(left), range_access::pos(right));
-    }
-    template(typename Cur, typename Cur2)(
-        /// \pre
-        requires detail::sentinel_for_cursor<Cur2, Cur>)
-    constexpr bool operator!=(basic_iterator<Cur> const & left,
-                              basic_iterator<Cur2> const & right)
-    {
-        return !(left == right);
-    }
-    template(typename Cur, typename S)(
-        /// \pre
-        requires detail::sentinel_for_cursor<S, Cur>)
-    constexpr bool operator==(basic_iterator<Cur> const & left,
-                              S const & right)
-    {
-        return range_access::equal(range_access::pos(left), right);
-    }
-    template(typename Cur, typename S)(
-        /// \pre
-        requires detail::sentinel_for_cursor<S, Cur>)
-    constexpr bool operator!=(basic_iterator<Cur> const & left,
-                              S const & right)
-    {
-        return !(left == right);
-    }
-    template(typename S, typename Cur)(
-        /// \pre
-        requires detail::sentinel_for_cursor<S, Cur>)
-    constexpr bool operator==(S const & left,
-                              basic_iterator<Cur> const & right)
-    {
-        return right == left;
-    }
-    template(typename S, typename Cur)(
-        /// \pre
-        requires detail::sentinel_for_cursor<S, Cur>)
-    constexpr bool operator!=(S const & left,
-                              basic_iterator<Cur> const & right)
-    {
-        return right != left;
-    }
-
-    template(typename Cur)(
-        /// \pre
-        requires detail::random_access_cursor<Cur>)
-    constexpr basic_iterator<Cur> //
-    operator+(basic_iterator<Cur> left, typename basic_iterator<Cur>::difference_type n)
-    {
-        left += n;
-        return left;
-    }
-    template(typename Cur)(
-        /// \pre
-        requires detail::random_access_cursor<Cur>)
-    constexpr basic_iterator<Cur> //
-    operator+(typename basic_iterator<Cur>::difference_type n, basic_iterator<Cur> right)
-    {
-        right += n;
-        return right;
-    }
-    template(typename Cur)(
-        /// \pre
-        requires detail::random_access_cursor<Cur>)
-    constexpr basic_iterator<Cur> //
-    operator-(basic_iterator<Cur> left, typename basic_iterator<Cur>::difference_type n)
-    {
-        left -= n;
-        return left;
-    }
-    template(typename Cur2, typename Cur)(
-        /// \pre
-        requires detail::sized_sentinel_for_cursor<Cur2, Cur>)
-    constexpr typename basic_iterator<Cur>::difference_type //
-    operator-(basic_iterator<Cur2> const & left, basic_iterator<Cur> const & right)
-    {
-        return range_access::distance_to(range_access::pos(right),
-                                         range_access::pos(left));
-    }
-    template(typename S, typename Cur)(
-        /// \pre
-        requires detail::sized_sentinel_for_cursor<S, Cur>)
-    constexpr typename basic_iterator<Cur>::difference_type //
-    operator-(S const & left, basic_iterator<Cur> const & right)
-    {
-        return range_access::distance_to(range_access::pos(right), left);
-    }
-    template(typename Cur, typename S)(
-        /// \pre
-        requires detail::sized_sentinel_for_cursor<S, Cur>)
-    constexpr typename basic_iterator<Cur>::difference_type //
-    operator-(basic_iterator<Cur> const & left, S const & right)
-    {
-        return -(right - left);
-    }
-    // Asymmetric comparisons
-    template(typename Left, typename Right)(
-        /// \pre
-        requires detail::sized_sentinel_for_cursor<Right, Left>)
-    constexpr bool operator<(basic_iterator<Left> const & left,
-                             basic_iterator<Right> const & right)
-    {
-        return 0 < (right - left);
-    }
-    template(typename Left, typename Right)(
-        /// \pre
-        requires detail::sized_sentinel_for_cursor<Right, Left>)
-    constexpr bool operator<=(basic_iterator<Left> const & left,
-                              basic_iterator<Right> const & right)
-    {
-        return 0 <= (right - left);
-    }
-    template(typename Left, typename Right)(
-        /// \pre
-        requires detail::sized_sentinel_for_cursor<Right, Left>)
-    constexpr bool operator>(basic_iterator<Left> const & left,
-                             basic_iterator<Right> const & right)
-    {
-        return (right - left) < 0;
-    }
-    template(typename Left, typename Right)(
-        /// \pre
-        requires detail::sized_sentinel_for_cursor<Right, Left>)
-    constexpr bool operator>=(basic_iterator<Left> const & left,
-                              basic_iterator<Right> const & right)
-    {
-        return (right - left) <= 0;
-    }
-
-#if RANGES_BROKEN_CPO_LOOKUP
-    namespace _basic_iterator_
-    {
-        // Optionally support hooking iter_move when the cursor sports a
-        // move() member function.
-        template<typename Cur>
-        constexpr auto iter_move(basic_iterator<Cur> const & it) noexcept(
-            noexcept(range_access::move(std::declval<Cur const &>())))
-            -> CPP_broken_friend_ret(
-                decltype(range_access::move(std::declval<Cur const &>())))(
-                /// \pre
-                requires detail::input_cursor<Cur>)
-        {
-            return range_access::move(range_access::pos(it));
-        }
-    } // namespace _basic_iterator_
-#endif
-
-    /// Get a cursor from a basic_iterator
-    struct get_cursor_fn
-    {
-        template<typename Cur>
-        constexpr Cur & operator()(basic_iterator<Cur> & it) const noexcept
-        {
-            return range_access::pos(it);
-        }
-        template<typename Cur>
-        constexpr Cur const & operator()(basic_iterator<Cur> const & it) const noexcept
-        {
-            return range_access::pos(it);
-        }
-        template<typename Cur>
-        constexpr Cur operator()(basic_iterator<Cur> && it) const
-            noexcept(std::is_nothrow_move_constructible<Cur>::value)
-        {
-            return range_access::pos(std::move(it));
-        }
-    };
-
-    /// \sa `get_cursor_fn`
-    RANGES_INLINE_VARIABLE(get_cursor_fn, get_cursor)
-    /// @}
-} // namespace ranges
-
-/// \cond
-namespace concepts
-{
-    // common_reference specializations for basic_proxy_reference
-    template<typename Cur, typename U, template<typename> class TQual,
-             template<typename> class UQual>
-    struct basic_common_reference<::ranges::detail::basic_proxy_reference_<Cur, true>, U,
-                                  TQual, UQual>
-      : basic_common_reference<::ranges::detail::cursor_reference_t<Cur>, U, TQual, UQual>
-    {};
-    template<typename T, typename Cur, template<typename> class TQual,
-             template<typename> class UQual>
-    struct basic_common_reference<T, ::ranges::detail::basic_proxy_reference_<Cur, true>,
-                                  TQual, UQual>
-      : basic_common_reference<T, ::ranges::detail::cursor_reference_t<Cur>, TQual, UQual>
-    {};
-    template<typename Cur1, typename Cur2, template<typename> class TQual,
-             template<typename> class UQual>
-    struct basic_common_reference<::ranges::detail::basic_proxy_reference_<Cur1, true>,
-                                  ::ranges::detail::basic_proxy_reference_<Cur2, true>,
-                                  TQual, UQual>
-      : basic_common_reference<::ranges::detail::cursor_reference_t<Cur1>,
-                               ::ranges::detail::cursor_reference_t<Cur2>, TQual, UQual>
-    {};
-
-    // common_type specializations for basic_proxy_reference
-    template<typename Cur, typename U>
-    struct common_type<::ranges::detail::basic_proxy_reference_<Cur, true>, U>
-      : common_type<::ranges::range_access::cursor_value_t<Cur>, U>
-    {};
-    template<typename T, typename Cur>
-    struct common_type<T, ::ranges::detail::basic_proxy_reference_<Cur, true>>
-      : common_type<T, ::ranges::range_access::cursor_value_t<Cur>>
-    {};
-    template<typename Cur1, typename Cur2>
-    struct common_type<::ranges::detail::basic_proxy_reference_<Cur1, true>,
-                       ::ranges::detail::basic_proxy_reference_<Cur2, true>>
-      : common_type<::ranges::range_access::cursor_value_t<Cur1>,
-                    ::ranges::range_access::cursor_value_t<Cur2>>
-    {};
-} // namespace concepts
-
-#if RANGES_CXX_VER > RANGES_CXX_STD_17
-RANGES_DIAGNOSTIC_PUSH
-RANGES_DIAGNOSTIC_IGNORE_MISMATCHED_TAGS
-RANGES_BEGIN_NAMESPACE_STD
-RANGES_BEGIN_NAMESPACE_VERSION
-    template<typename, typename, template <typename> class, template<typename> class>
-    struct basic_common_reference;
-
-    // common_reference specializations for basic_proxy_reference
-    template<typename Cur, typename U, template<typename> class TQual,
-             template<typename> class UQual>
-    struct basic_common_reference<::ranges::detail::basic_proxy_reference_<Cur, true>, U,
-                                  TQual, UQual>
-      : basic_common_reference<::ranges::detail::cursor_reference_t<Cur>, U, TQual, UQual>
-    {};
-    template<typename T, typename Cur, template<typename> class TQual,
-             template<typename> class UQual>
-    struct basic_common_reference<T, ::ranges::detail::basic_proxy_reference_<Cur, true>,
-                                  TQual, UQual>
-      : basic_common_reference<T, ::ranges::detail::cursor_reference_t<Cur>, TQual, UQual>
-    {};
-    template<typename Cur1, typename Cur2, template<typename> class TQual,
-             template<typename> class UQual>
-    struct basic_common_reference<::ranges::detail::basic_proxy_reference_<Cur1, true>,
-                                  ::ranges::detail::basic_proxy_reference_<Cur2, true>,
-                                  TQual, UQual>
-      : basic_common_reference<::ranges::detail::cursor_reference_t<Cur1>,
-                               ::ranges::detail::cursor_reference_t<Cur2>, TQual, UQual>
-    {};
-
-    template<typename...>
-    struct common_type;
-
-    // common_type specializations for basic_proxy_reference
-    template<typename Cur, typename U>
-    struct common_type<::ranges::detail::basic_proxy_reference_<Cur, true>, U>
-      : common_type<::ranges::range_access::cursor_value_t<Cur>, U>
-    {};
-    template<typename T, typename Cur>
-    struct common_type<T, ::ranges::detail::basic_proxy_reference_<Cur, true>>
-      : common_type<T, ::ranges::range_access::cursor_value_t<Cur>>
-    {};
-    template<typename Cur1, typename Cur2>
-    struct common_type<::ranges::detail::basic_proxy_reference_<Cur1, true>,
-                       ::ranges::detail::basic_proxy_reference_<Cur2, true>>
-      : common_type<::ranges::range_access::cursor_value_t<Cur1>,
-                    ::ranges::range_access::cursor_value_t<Cur2>>
-    {};
-RANGES_END_NAMESPACE_VERSION
-RANGES_END_NAMESPACE_STD
-RANGES_DIAGNOSTIC_POP
-#endif // RANGES_CXX_VER > RANGES_CXX_STD_17
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        template<typename Cur, bool IsReadable>
-        struct std_iterator_traits_
-        {
-            using difference_type =
-                typename iterator_associated_types_base<Cur>::difference_type;
-            using value_type = void;
-            using reference = void;
-            using pointer = void;
-            using iterator_category = std::output_iterator_tag;
-            using iterator_concept = std::output_iterator_tag;
-        };
-
-        template<typename Cur>
-        struct std_iterator_traits_<Cur, true> : iterator_associated_types_base<Cur>
-        {};
-
-        template<typename Cur>
-        using std_iterator_traits = std_iterator_traits_<Cur, (bool)readable_cursor<Cur>>;
-    } // namespace detail
-    /// \endcond
-} // namespace ranges
-
-namespace std
-{
-    template<typename Cur>
-    struct iterator_traits<::ranges::basic_iterator<Cur>>
-      : ::ranges::detail::std_iterator_traits<Cur>
-    {};
-} // namespace std
-/// \endcond
-
-RANGES_DIAGNOSTIC_POP
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/iterator/common_iterator.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/iterator/common_iterator.hpp
deleted file mode 100644
index e89a44c6..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/iterator/common_iterator.hpp
+++ /dev/null
@@ -1,483 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ITERATOR_COMMON_ITERATOR_HPP
-#define RANGES_V3_ITERATOR_COMMON_ITERATOR_HPP
-
-#include <cstdint>
-#include <iterator>
-#include <type_traits>
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/detail/variant.hpp>
-#include <range/v3/iterator/basic_iterator.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/utility/common_tuple.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-iterator
-    /// @{
-
-    /// \cond
-    namespace detail
-    {
-        template<typename I, typename S>
-        variant<I, S> & cidata(common_iterator<I, S> & that)
-        {
-            return that.data_;
-        }
-
-        template<typename I, typename S>
-        variant<I, S> const & cidata(common_iterator<I, S> const & that)
-        {
-            return that.data_;
-        }
-    } // namespace detail
-
-#if RANGES_BROKEN_CPO_LOOKUP
-    namespace _common_iterator_
-    {
-        struct adl_hook
-        {};
-    } // namespace _common_iterator_
-#endif
-    /// \endcond
-
-    template<typename I, typename S>
-    struct common_iterator
-#if RANGES_BROKEN_CPO_LOOKUP
-      : private _common_iterator_::adl_hook
-#endif
-    {
-    private:
-        CPP_assert(input_or_output_iterator<I>);
-        CPP_assert(sentinel_for<S, I>);
-        CPP_assert(!same_as<I, S>);
-        variant<I, S> data_;
-
-        friend variant<I, S> & detail::cidata<>(common_iterator<I, S> &);
-        friend variant<I, S> const & detail::cidata<>(common_iterator<I, S> const &);
-        struct emplace_fn
-        {
-            variant<I, S> * data_;
-            template<typename T, std::size_t N>
-            void operator()(indexed_element<T, N> t) const
-            {
-                ranges::emplace<N>(*data_, t.get());
-            }
-        };
-        struct arrow_proxy_
-        {
-        private:
-            friend common_iterator;
-            iter_value_t<I> keep_;
-            arrow_proxy_(iter_reference_t<I> && x)
-              : keep_(std::move(x))
-            {}
-
-        public:
-            const iter_value_t<I> * operator->() const noexcept
-            {
-                return std::addressof(keep_);
-            }
-        };
-        template<typename T>
-        static T * operator_arrow_(T * p, int) noexcept
-        {
-            return p;
-        }
-        template<typename J, typename = detail::iter_arrow_t<J const>>
-        static J operator_arrow_(J const & j, int) noexcept(noexcept(J(j)))
-        {
-            return j;
-        }
-        template(typename J, typename R = iter_reference_t<J>)(
-            /// \pre
-            requires std::is_reference<R>::value) //
-        static meta::_t<std::add_pointer<R>> operator_arrow_(J const & j, long) noexcept
-        {
-            auto && r = *j;
-            return std::addressof(r);
-        }
-        template(typename J, typename V = iter_value_t<J>)(
-            /// \pre
-            requires constructible_from<V, iter_reference_t<J>>)
-        static arrow_proxy_ operator_arrow_(J const & j, ...) noexcept(noexcept(V(V(*j))))
-        {
-            return arrow_proxy_(*j);
-        }
-
-    public:
-        using difference_type = iter_difference_t<I>;
-
-        common_iterator() = default;
-        common_iterator(I i)
-          : data_(emplaced_index<0>, std::move(i))
-        {}
-        common_iterator(S s)
-          : data_(emplaced_index<1>, std::move(s))
-        {}
-        template(typename I2, typename S2)(
-            /// \pre
-            requires convertible_to<I2, I> AND convertible_to<S2, S>)
-        common_iterator(common_iterator<I2, S2> const & that)
-          : data_(detail::variant_core_access::make_empty<I, S>())
-        {
-            detail::cidata(that).visit_i(emplace_fn{&data_});
-        }
-        template(typename I2, typename S2)(
-            /// \pre
-            requires convertible_to<I2, I> AND convertible_to<S2, S>)
-        common_iterator & operator=(common_iterator<I2, S2> const & that)
-        {
-            detail::cidata(that).visit_i(emplace_fn{&data_});
-            return *this;
-        }
-        iter_reference_t<I> operator*() //
-            noexcept(noexcept(iter_reference_t<I>(*std::declval<I &>())))
-        {
-            return *ranges::get<0>(data_);
-        }
-        CPP_member
-        auto operator*() const //
-            noexcept(noexcept(iter_reference_t<I>(*std::declval<I const &>())))
-            -> CPP_ret(iter_reference_t<I>)(
-                /// \pre
-                requires indirectly_readable<I const>)
-        {
-            return *ranges::get<0>(data_);
-        }
-        template(typename J = I)(
-            /// \pre
-            requires indirectly_readable<J>)
-        auto operator->() const //
-            noexcept(
-                noexcept(common_iterator::operator_arrow_(std::declval<I const &>(), 42)))
-            -> decltype(common_iterator::operator_arrow_(std::declval<J const &>(), 42))
-        {
-            return common_iterator::operator_arrow_(ranges::get<0>(data_), 42);
-        }
-        common_iterator & operator++()
-        {
-            ++ranges::get<0>(data_);
-            return *this;
-        }
-#ifdef RANGES_WORKAROUND_MSVC_677925
-        template(typename I2 = I)(
-            /// \pre
-            requires (!forward_iterator<I2>)) //
-        auto operator++(int) //
-            -> decltype(std::declval<I2 &>()++)
-        {
-            return ranges::get<0>(data_)++;
-        }
-#else  // ^^^ workaround ^^^ / vvv no workaround vvv
-        CPP_member
-        auto operator++(int) //
-            -> CPP_ret(decltype(std::declval<I &>()++))(
-                /// \pre
-                requires (!forward_iterator<I>))
-        {
-            return ranges::get<0>(data_)++;
-        }
-#endif // RANGES_WORKAROUND_MSVC_677925
-        CPP_member
-        auto operator++(int) //
-            -> CPP_ret(common_iterator)(
-                /// \pre
-                requires forward_iterator<I>)
-        {
-            return common_iterator(ranges::get<0>(data_)++);
-        }
-
-#if !RANGES_BROKEN_CPO_LOOKUP
-        template<typename I_ = I>
-        friend constexpr auto iter_move(common_iterator const & i) //
-            noexcept(detail::has_nothrow_iter_move_v<I>)
-            -> CPP_broken_friend_ret(iter_rvalue_reference_t<I>)(
-                /// \pre
-                requires input_iterator<I_>)
-        {
-            return ranges::iter_move(ranges::get<0>(detail::cidata(i)));
-        }
-        template<typename I2, typename S2>
-        friend auto iter_swap(
-            common_iterator const & x,
-            common_iterator<I2, S2> const &
-                y) noexcept(is_nothrow_indirectly_swappable<I, I2>::value)
-            -> CPP_broken_friend_ret(void)(
-                /// \pre
-                requires indirectly_swappable<I2, I>)
-        {
-            return ranges::iter_swap(ranges::get<0>(detail::cidata(x)),
-                                     ranges::get<0>(detail::cidata(y)));
-        }
-#endif
-    };
-
-    /// \cond
-#if RANGES_BROKEN_CPO_LOOKUP
-    namespace _common_iterator_
-    {
-        template<typename I, typename S>
-        constexpr auto iter_move(common_iterator<I, S> const & i) noexcept(
-            detail::has_nothrow_iter_move_v<I>)
-            -> CPP_broken_friend_ret(iter_rvalue_reference_t<I>)(
-                /// \pre
-                requires input_iterator<I>)
-        {
-            return ranges::iter_move(ranges::get<0>(detail::cidata(i)));
-        }
-        template<typename I1, typename S1, typename I2, typename S2>
-        auto iter_swap(common_iterator<I1, S1> const & x,
-                       common_iterator<I2, S2> const & y) //
-            noexcept(is_nothrow_indirectly_swappable<I1, I2>::value)
-                -> CPP_broken_friend_ret(void)(
-                    /// \pre
-                    requires indirectly_swappable<I1, I2>)
-        {
-            return ranges::iter_swap(ranges::get<0>(detail::cidata(x)),
-                                     ranges::get<0>(detail::cidata(y)));
-        }
-    } // namespace _common_iterator_
-#endif
-    /// \endcond
-
-    template(typename I1, typename I2, typename S1, typename S2)(
-        /// \pre
-        requires sentinel_for<S1, I2> AND sentinel_for<S2, I1> AND
-        (!equality_comparable_with<I1, I2>)) //
-    bool operator==(common_iterator<I1, S1> const & x, common_iterator<I2, S2> const & y)
-    {
-        return detail::cidata(x).index() == 1u ? (detail::cidata(y).index() == 1u ||
-                                                  ranges::get<0>(detail::cidata(y)) ==
-                                                      ranges::get<1>(detail::cidata(x)))
-                                               : (detail::cidata(y).index() != 1u ||
-                                                  ranges::get<0>(detail::cidata(x)) ==
-                                                      ranges::get<1>(detail::cidata(y)));
-    }
-
-    template(typename I1, typename I2, typename S1, typename S2)(
-        /// \pre
-        requires sentinel_for<S1, I2> AND sentinel_for<S2, I1> AND
-            equality_comparable_with<I1, I2>)
-    bool operator==(common_iterator<I1, S1> const & x, common_iterator<I2, S2> const & y)
-    {
-        return detail::cidata(x).index() == 1u
-                   ? (detail::cidata(y).index() == 1u ||
-                      ranges::get<0>(detail::cidata(y)) ==
-                          ranges::get<1>(detail::cidata(x)))
-                   : (detail::cidata(y).index() == 1u
-                          ? ranges::get<0>(detail::cidata(x)) ==
-                                ranges::get<1>(detail::cidata(y))
-                          : ranges::get<0>(detail::cidata(x)) ==
-                                ranges::get<0>(detail::cidata(y)));
-    }
-
-    template(typename I1, typename I2, typename S1, typename S2)(
-        /// \pre
-        requires sentinel_for<S1, I2> AND sentinel_for<S2, I1>)
-    bool operator!=(common_iterator<I1, S1> const & x, common_iterator<I2, S2> const & y)
-    {
-        return !(x == y);
-    }
-
-    template(typename I1, typename I2, typename S1, typename S2)(
-        /// \pre
-        requires sized_sentinel_for<I1, I2> AND sized_sentinel_for<S1, I2> AND
-            sized_sentinel_for<S2, I1>)
-    iter_difference_t<I2> operator-(common_iterator<I1, S1> const & x,
-                                    common_iterator<I2, S2> const & y)
-    {
-        return detail::cidata(x).index() == 1u
-                   ? (detail::cidata(y).index() == 1u
-                          ? 0
-                          : ranges::get<1>(detail::cidata(x)) -
-                                ranges::get<0>(detail::cidata(y)))
-                   : (detail::cidata(y).index() == 1u
-                          ? ranges::get<0>(detail::cidata(x)) -
-                                ranges::get<1>(detail::cidata(y))
-                          : ranges::get<0>(detail::cidata(x)) -
-                                ranges::get<0>(detail::cidata(y)));
-    }
-
-    template<typename I, typename S>
-    struct indirectly_readable_traits<common_iterator<I, S>>
-      : meta::if_c<
-        (bool)indirectly_readable<I>,
-        indirectly_readable_traits<I>,
-        meta::nil_>
-    {};
-
-    /// \cond
-    namespace detail
-    {
-        template<typename I>
-        auto demote_common_iter_cat(...) -> nil_;
-        template<typename I>
-        auto demote_common_iter_cat(long)
-            -> with_iterator_category<std::input_iterator_tag>;
-        template(typename I)(
-            /// \pre
-            requires derived_from<typename std::iterator_traits<I>::iterator_category,
-                                      std::forward_iterator_tag>)
-        auto demote_common_iter_cat(int)
-            -> with_iterator_category<std::forward_iterator_tag>;
-
-        template<typename I, bool = (bool)input_iterator<I>>
-        struct common_iterator_std_traits : decltype(detail::demote_common_iter_cat<I>(0))
-        {
-            using difference_type = iter_difference_t<I>;
-            using value_type = iter_value_t<I>;
-            using reference = iter_reference_t<I>;
-            using pointer = detail::iter_pointer_t<I>;
-            using iterator_concept =
-                meta::conditional_t<(bool)forward_iterator<I>, std::forward_iterator_tag,
-                          std::input_iterator_tag>;
-        };
-
-        template<typename I>
-        struct common_iterator_std_traits<I, false>
-        {
-            using difference_type = iter_difference_t<I>;
-            using value_type = void;
-            using reference = void;
-            using pointer = void;
-            using iterator_category = std::output_iterator_tag;
-        };
-
-        // An iterator adaptor that demotes a user-defined difference_type to
-        // std::intmax_t, for use when constructing containers from such
-        // iterators.
-        template<typename I>
-        struct cpp17_iterator_cursor
-        {
-        private:
-            friend range_access;
-            I it_;
-            struct mixin : basic_mixin<cpp17_iterator_cursor>
-            {
-                mixin() = default;
-                #ifndef _MSC_VER
-                using basic_mixin<cpp17_iterator_cursor>::basic_mixin;
-                #else
-                constexpr explicit mixin(cpp17_iterator_cursor && cur)
-                  : basic_mixin<cpp17_iterator_cursor>(
-                        static_cast<cpp17_iterator_cursor &&>(cur))
-                {}
-                constexpr explicit mixin(cpp17_iterator_cursor const & cur)
-                  : basic_mixin<cpp17_iterator_cursor>(cur)
-                {}
-                #endif
-                explicit mixin(I it)
-                  : mixin{cpp17_iterator_cursor{std::move(it)}}
-                {}
-                I base() const
-                {
-                    return this->get().it_;
-                }
-            };
-
-        public:
-            using single_pass = meta::bool_<!forward_iterator<I>>;
-            using difference_type = std::ptrdiff_t;
-            using value_type = iter_value_t<I>;
-
-            cpp17_iterator_cursor() = default;
-            constexpr explicit cpp17_iterator_cursor(I i)
-              : it_(static_cast<I &&>(i))
-            {}
-
-            I arrow() const
-            {
-                return it_;
-            }
-            decltype(auto) read()
-            {
-                return *it_;
-            }
-            decltype(auto) read() const
-            {
-                return *it_;
-            }
-            void next()
-            {
-                ++it_;
-            }
-            bool equal(cpp17_iterator_cursor const & that) const
-            {
-                return it_ == that.it_;
-            }
-            CPP_member
-            auto prev() //
-                -> CPP_ret(void)(
-                    /// \pre
-                    requires bidirectional_iterator<I>)
-            {
-                --it_;
-            }
-            CPP_member
-            auto advance(std::ptrdiff_t n) //
-                -> CPP_ret(void)(
-                    /// \pre
-                    requires random_access_iterator<I>)
-            {
-                it_ += static_cast<iter_difference_t<I>>(n);
-            }
-            CPP_member
-            auto distance_to(cpp17_iterator_cursor const & that) //
-                -> CPP_ret(std::ptrdiff_t)(
-                    /// \pre
-                    requires random_access_iterator<I>)
-            {
-                auto d = that.it_ - it_;
-                RANGES_EXPECT(d <= PTRDIFF_MAX);
-                return static_cast<std::ptrdiff_t>(d);
-            }
-        };
-    } // namespace detail
-    /// \endcond
-
-    namespace cpp20
-    {
-        using ranges::common_iterator;
-    }
-    /// @}
-} // namespace ranges
-
-/// \cond
-RANGES_DIAGNOSTIC_PUSH
-RANGES_DIAGNOSTIC_IGNORE_MISMATCHED_TAGS
-
-namespace std
-{
-    template<typename I, typename S>
-    struct iterator_traits<::ranges::common_iterator<I, S>>
-      : ::ranges::detail::common_iterator_std_traits<I>
-    {};
-} // namespace std
-
-RANGES_DIAGNOSTIC_POP
-/// \endcond
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/iterator/concepts.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/iterator/concepts.hpp
deleted file mode 100644
index de9363ed..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/iterator/concepts.hpp
+++ /dev/null
@@ -1,873 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ITERATOR_CONCEPTS_HPP
-#define RANGES_V3_ITERATOR_CONCEPTS_HPP
-
-#include <iterator>
-#include <type_traits>
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/concepts.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/access.hpp>
-#include <range/v3/iterator/traits.hpp>
-
-#ifdef _GLIBCXX_DEBUG
-#include <debug/safe_iterator.h>
-#endif
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-iterator-concepts
-    /// @{
-
-    /// \cond
-    namespace detail
-    {
-        template<typename I>
-        using iter_traits_t = meta::conditional_t<is_std_iterator_traits_specialized_v<I>,
-                                        std::iterator_traits<I>, I>;
-
-#if defined(_GLIBCXX_DEBUG)
-        template(typename I, typename T, typename Seq)(
-            /// \pre
-            requires same_as<I, __gnu_debug::_Safe_iterator<T *, Seq>>)
-        auto iter_concept_(__gnu_debug::_Safe_iterator<T *, Seq>, priority_tag<3>)
-            -> ranges::contiguous_iterator_tag
-#endif
-#if defined(__GLIBCXX__)
-        template(typename I, typename T, typename Seq)(
-            /// \pre
-            requires same_as<I, __gnu_cxx::__normal_iterator<T *, Seq>>)
-        auto iter_concept_(__gnu_cxx::__normal_iterator<T *, Seq>, priority_tag<3>)
-            -> ranges::contiguous_iterator_tag;
-#endif
-#if defined(_LIBCPP_VERSION)
-        template(typename I, typename T)(
-            /// \pre
-            requires same_as<I, std::__wrap_iter<T *>>)
-        auto iter_concept_(std::__wrap_iter<T *>, priority_tag<3>)
-            -> ranges::contiguous_iterator_tag;
-#endif
-#if defined(_MSVC_STL_VERSION) || defined(_IS_WRS)
-        template(typename I)(
-            /// \pre
-            requires same_as<I, class I::_Array_iterator>)
-        auto iter_concept_(I, priority_tag<3>)
-            -> ranges::contiguous_iterator_tag;
-        template(typename I)(
-            /// \pre
-            requires same_as<I, class I::_Array_const_iterator>)
-        auto iter_concept_(I, priority_tag<3>)
-            -> ranges::contiguous_iterator_tag;
-        template(typename I)(
-            /// \pre
-            requires same_as<I, class I::_Vector_iterator>)
-        auto iter_concept_(I, priority_tag<3>)
-            -> ranges::contiguous_iterator_tag;
-        template(typename I)(
-            /// \pre
-            requires same_as<I, class I::_Vector_const_iterator>)
-        auto iter_concept_(I, priority_tag<3>)
-            -> ranges::contiguous_iterator_tag;
-        template(typename I)(
-            /// \pre
-            requires same_as<I, class I::_String_iterator>)
-        auto iter_concept_(I, priority_tag<3>)
-            -> ranges::contiguous_iterator_tag;
-        template(typename I)(
-            /// \pre
-            requires same_as<I, class I::_String_const_iterator>)
-        auto iter_concept_(I, priority_tag<3>)
-            -> ranges::contiguous_iterator_tag;
-        template(typename I)(
-            /// \pre
-            requires same_as<I, class I::_String_view_iterator>)
-        auto iter_concept_(I, priority_tag<3>)
-            -> ranges::contiguous_iterator_tag;
-#endif
-        template(typename I, typename T)(
-            /// \pre
-            requires same_as<I, T *>)
-        auto iter_concept_(T *, priority_tag<3>)
-            -> ranges::contiguous_iterator_tag;
-        template<typename I>
-        auto iter_concept_(I, priority_tag<2>) ->
-            typename iter_traits_t<I>::iterator_concept;
-        template<typename I>
-        auto iter_concept_(I, priority_tag<1>) ->
-            typename iter_traits_t<I>::iterator_category;
-        template<typename I>
-        auto iter_concept_(I, priority_tag<0>)
-            -> enable_if_t<!is_std_iterator_traits_specialized_v<I>,
-                           std::random_access_iterator_tag>;
-
-        template<typename I>
-        using iter_concept_t =
-            decltype(iter_concept_<I>(std::declval<I>(), priority_tag<3>{}));
-
-        using ::concepts::detail::weakly_equality_comparable_with_;
-
-        template<typename I>
-        using readable_types_t =
-            meta::list<iter_value_t<I>, iter_reference_t<I>, iter_rvalue_reference_t<I>>;
-    } // namespace detail
-      /// \endcond
-
-    // clang-format off
-    template(typename I)(
-    concept (readable_)(I),
-        // requires (I const i)
-        // (
-        //     { *i } -> same_as<iter_reference_t<I>>;
-        //     { iter_move(i) } -> same_as<iter_rvalue_reference_t<I>>;
-        // ) &&
-        same_as<iter_reference_t<I const>, iter_reference_t<I>> AND
-        same_as<iter_rvalue_reference_t<I const>, iter_rvalue_reference_t<I>> AND
-        common_reference_with<iter_reference_t<I> &&, iter_value_t<I> &> AND
-        common_reference_with<iter_reference_t<I> &&,
-                              iter_rvalue_reference_t<I> &&> AND
-        common_reference_with<iter_rvalue_reference_t<I> &&, iter_value_t<I> const &>
-    );
-
-    template<typename I>
-    CPP_concept indirectly_readable = //
-        CPP_concept_ref(ranges::readable_, uncvref_t<I>);
-
-    template<typename I>
-    RANGES_DEPRECATED("Please use ranges::indirectly_readable instead")
-    RANGES_INLINE_VAR constexpr bool readable = //
-        indirectly_readable<I>;
-
-    template<typename O, typename T>
-    CPP_requires(writable_,
-        requires(O && o, T && t) //
-        (
-            *o = (T &&) t,
-            *(O &&) o = (T &&) t,
-            const_cast<iter_reference_t<O> const &&>(*o) = (T &&) t,
-            const_cast<iter_reference_t<O> const &&>(*(O &&) o) = (T &&) t
-        ));
-    template<typename O, typename T>
-    CPP_concept indirectly_writable = //
-        CPP_requires_ref(ranges::writable_, O, T);
-
-    template<typename O, typename T>
-    RANGES_DEPRECATED("Please use ranges::indirectly_writable instead")
-    RANGES_INLINE_VAR constexpr bool writable = //
-        indirectly_writable<O, T>;
-    // clang-format on
-
-    /// \cond
-    namespace detail
-    {
-#if RANGES_CXX_INLINE_VARIABLES >= RANGES_CXX_INLINE_VARIABLES_17
-        template<typename D>
-        inline constexpr bool _is_integer_like_ = std::is_integral<D>::value;
-#else
-        template<typename D, typename = void>
-        constexpr bool _is_integer_like_ = std::is_integral<D>::value;
-#endif
-
-        // gcc10 uses for std::ranges::range_difference_t<
-        // std::ranges::iota_view<size_t, size_t>> == __int128
-#if __SIZEOF_INT128__
-        __extension__ typedef __int128 int128_t;
-#if RANGES_CXX_INLINE_VARIABLES >= RANGES_CXX_INLINE_VARIABLES_17
-        template<>
-        inline constexpr bool _is_integer_like_<int128_t> = true;
-#else
-        template<typename Enable>
-        constexpr bool _is_integer_like_<int128_t, Enable> = true;
-#endif
-#endif // __SIZEOF_INT128__
-
-        // clang-format off
-        template<typename D>
-        CPP_concept integer_like_ = _is_integer_like_<D>;
-            // TODO additional syntactic and semantic requirements
-
-#ifdef RANGES_WORKAROUND_MSVC_792338
-        template<typename D, bool Signed = (D(-1) < D(0))>
-        constexpr bool _is_signed_(D *)
-        {
-            return Signed;
-        }
-        constexpr bool _is_signed_(void *)
-        {
-            return false;
-        }
-
-        template<typename D>
-        CPP_concept signed_integer_like_ =
-            integer_like_<D> && detail::_is_signed_((D*) nullptr);
-#else // ^^^ workaround / no workaround vvv
-        template(typename D)(
-        concept (signed_integer_like_impl_)(D),
-            integer_like_<D> AND
-            concepts::type<std::integral_constant<bool, (D(-1) < D(0))>> AND
-            std::integral_constant<bool, (D(-1) < D(0))>::value
-        );
-
-        template<typename D>
-        CPP_concept signed_integer_like_ =
-            integer_like_<D> &&
-            CPP_concept_ref(detail::signed_integer_like_impl_, D);
-#endif // RANGES_WORKAROUND_MSVC_792338
-        // clang-format on
-    } // namespace detail
-      /// \endcond
-
-    // clang-format off
-    template<typename I>
-    CPP_requires(weakly_incrementable_,
-        requires(I i) //
-        (
-            ++i,
-            i++,
-            concepts::requires_<same_as<I&, decltype(++i)>>
-        ));
-
-    template(typename I)(
-    concept (weakly_incrementable_)(I),
-        concepts::type<iter_difference_t<I>> AND
-        detail::signed_integer_like_<iter_difference_t<I>>);
-
-    template<typename I>
-    CPP_concept weakly_incrementable =
-        semiregular<I> &&
-        CPP_requires_ref(ranges::weakly_incrementable_, I) &&
-        CPP_concept_ref(ranges::weakly_incrementable_, I);
-
-    template<typename I>
-    CPP_requires(incrementable_,
-        requires(I i) //
-        (
-            concepts::requires_<same_as<I, decltype(i++)>>
-        ));
-    template<typename I>
-    CPP_concept incrementable =
-        regular<I> &&
-        weakly_incrementable<I> &&
-        CPP_requires_ref(ranges::incrementable_, I);
-
-    template(typename I)(
-    concept (input_or_output_iterator_)(I),
-        detail::dereferenceable_<I&>
-    );
-
-    template<typename I>
-    CPP_concept input_or_output_iterator =
-        weakly_incrementable<I> &&
-        CPP_concept_ref(ranges::input_or_output_iterator_, I);
-
-    template<typename S, typename I>
-    CPP_concept sentinel_for =
-        semiregular<S> &&
-        input_or_output_iterator<I> &&
-        detail::weakly_equality_comparable_with_<S, I>;
-
-    template<typename S, typename I>
-    CPP_requires(sized_sentinel_for_,
-        requires(S const & s, I const & i) //
-        (
-            s - i,
-            i - s,
-            concepts::requires_<same_as<iter_difference_t<I>, decltype(s - i)>>,
-            concepts::requires_<same_as<iter_difference_t<I>, decltype(i - s)>>
-        ));
-    template(typename S, typename I)(
-    concept (sized_sentinel_for_)(S, I),
-        (!disable_sized_sentinel<std::remove_cv_t<S>, std::remove_cv_t<I>>) AND
-        sentinel_for<S, I>);
-
-    template<typename S, typename I>
-    CPP_concept sized_sentinel_for =
-        CPP_concept_ref(sized_sentinel_for_, S, I) &&
-        CPP_requires_ref(ranges::sized_sentinel_for_, S, I);
-
-    template<typename Out, typename T>
-    CPP_requires(output_iterator_,
-        requires(Out o, T && t) //
-        (
-            *o++ = (T &&) t
-        ));
-    template<typename Out, typename T>
-    CPP_concept output_iterator =
-        input_or_output_iterator<Out> &&
-        indirectly_writable<Out, T> &&
-        CPP_requires_ref(ranges::output_iterator_, Out, T);
-
-    template(typename I, typename Tag)(
-    concept (with_category_)(I, Tag),
-        derived_from<detail::iter_concept_t<I>, Tag>
-    );
-
-    template<typename I>
-    CPP_concept input_iterator =
-        input_or_output_iterator<I> &&
-        indirectly_readable<I> &&
-        CPP_concept_ref(ranges::with_category_, I, std::input_iterator_tag);
-
-    template<typename I>
-    CPP_concept forward_iterator =
-        input_iterator<I> &&
-        incrementable<I> &&
-        sentinel_for<I, I> &&
-        CPP_concept_ref(ranges::with_category_, I, std::forward_iterator_tag);
-
-    template<typename I>
-    CPP_requires(bidirectional_iterator_,
-        requires(I i) //
-        (
-            --i,
-            i--,
-            concepts::requires_<same_as<I&, decltype(--i)>>,
-            concepts::requires_<same_as<I, decltype(i--)>>
-        ));
-    template<typename I>
-    CPP_concept bidirectional_iterator =
-        forward_iterator<I> &&
-        CPP_requires_ref(ranges::bidirectional_iterator_, I) &&
-        CPP_concept_ref(ranges::with_category_, I, std::bidirectional_iterator_tag);
-
-    template<typename I>
-    CPP_requires(random_access_iterator_,
-        requires(I i, iter_difference_t<I> n)
-        (
-            i + n,
-            n + i,
-            i - n,
-            i += n,
-            i -= n,
-            concepts::requires_<same_as<decltype(i + n), I>>,
-            concepts::requires_<same_as<decltype(n + i), I>>,
-            concepts::requires_<same_as<decltype(i - n), I>>,
-            concepts::requires_<same_as<decltype(i += n), I&>>,
-            concepts::requires_<same_as<decltype(i -= n), I&>>,
-            concepts::requires_<same_as<decltype(i[n]), iter_reference_t<I>>>
-        ));
-    template<typename I>
-    CPP_concept random_access_iterator =
-        bidirectional_iterator<I> &&
-        totally_ordered<I> &&
-        sized_sentinel_for<I, I> &&
-        CPP_requires_ref(ranges::random_access_iterator_, I) &&
-        CPP_concept_ref(ranges::with_category_, I, std::random_access_iterator_tag);
-
-    template(typename I)(
-    concept (contiguous_iterator_)(I),
-        std::is_lvalue_reference<iter_reference_t<I>>::value AND
-        same_as<iter_value_t<I>, uncvref_t<iter_reference_t<I>>> AND
-        derived_from<detail::iter_concept_t<I>, ranges::contiguous_iterator_tag>
-    );
-
-    template<typename I>
-    CPP_concept contiguous_iterator =
-        random_access_iterator<I> &&
-        CPP_concept_ref(ranges::contiguous_iterator_, I);
-    // clang-format on
-
-    /////////////////////////////////////////////////////////////////////////////////////
-    // iterator_tag_of
-    template<typename Rng>
-    using iterator_tag_of =                              //
-        std::enable_if_t<                                //
-            input_iterator<Rng>,                         //
-            meta::conditional_t<                           //
-                contiguous_iterator<Rng>,                //
-                ranges::contiguous_iterator_tag,         //
-                meta::conditional_t<                       //
-                    random_access_iterator<Rng>,         //
-                    std::random_access_iterator_tag,     //
-                    meta::conditional_t<                   //
-                        bidirectional_iterator<Rng>,     //
-                        std::bidirectional_iterator_tag, //
-                        meta::conditional_t<               //
-                            forward_iterator<Rng>,       //
-                            std::forward_iterator_tag,   //
-                            std::input_iterator_tag>>>>>;
-
-    /// \cond
-    namespace detail
-    {
-        template<typename, bool>
-        struct iterator_category_
-        {};
-
-        template<typename I>
-        struct iterator_category_<I, true>
-        {
-            using type = iterator_tag_of<I>;
-        };
-
-        template<typename T, typename U = meta::_t<std::remove_const<T>>>
-        using iterator_category = iterator_category_<U, (bool)input_iterator<U>>;
-    } // namespace detail
-    /// \endcond
-
-    /// \cond
-    // Generally useful to know if an iterator is single-pass or not:
-    // clang-format off
-    template<typename I>
-    CPP_concept single_pass_iterator_ =
-        input_or_output_iterator<I> && !forward_iterator<I>;
-    // clang-format on
-    /// \endcond
-
-    //////////////////////////////////////////////////////////////////////////////////////
-    // indirect_result_t
-    template<typename Fun, typename... Is>
-    using indirect_result_t =
-        detail::enable_if_t<(bool)and_v<(bool)indirectly_readable<Is>...>,
-                            invoke_result_t<Fun, iter_reference_t<Is>...>>;
-
-    /// \cond
-    namespace detail
-    {
-        // clang-format off
-        template(typename T1, typename T2, typename T3, typename T4)(
-        concept (common_reference_with_4_impl_)(T1, T2, T3, T4),
-            concepts::type<common_reference_t<T1, T2, T3, T4>>     AND
-            convertible_to<T1, common_reference_t<T1, T2, T3, T4>> AND
-            convertible_to<T2, common_reference_t<T1, T2, T3, T4>> AND
-            convertible_to<T3, common_reference_t<T1, T2, T3, T4>> AND
-            convertible_to<T4, common_reference_t<T1, T2, T3, T4>>
-        );
-
-        template<typename T1, typename T2, typename T3, typename T4>
-        CPP_concept common_reference_with_4_ =
-            CPP_concept_ref(detail::common_reference_with_4_impl_, T1, T2, T3, T4);
-        // axiom: all permutations of T1,T2,T3,T4 have the same
-        // common reference type.
-
-        template(typename F, typename I)(
-        concept (indirectly_unary_invocable_impl_)(F, I),
-            invocable<F &, iter_value_t<I> &> AND
-            invocable<F &, iter_reference_t<I>> AND
-            invocable<F &, iter_common_reference_t<I>> AND
-            common_reference_with<
-                invoke_result_t<F &, iter_value_t<I> &>,
-                invoke_result_t<F &, iter_reference_t<I>>>
-        );
-
-        template<typename F, typename I>
-        CPP_concept indirectly_unary_invocable_ =
-            indirectly_readable<I> &&
-            CPP_concept_ref(detail::indirectly_unary_invocable_impl_, F, I);
-        // clang-format on
-    } // namespace detail
-      /// \endcond
-
-    // clang-format off
-    template<typename F, typename I>
-    CPP_concept indirectly_unary_invocable =
-        detail::indirectly_unary_invocable_<F, I> &&
-        copy_constructible<F>;
-
-    template(typename F, typename I)(
-    concept (indirectly_regular_unary_invocable_)(F, I),
-        regular_invocable<F &, iter_value_t<I> &> AND
-        regular_invocable<F &, iter_reference_t<I>> AND
-        regular_invocable<F &, iter_common_reference_t<I>> AND
-        common_reference_with<
-            invoke_result_t<F &, iter_value_t<I> &>,
-            invoke_result_t<F &, iter_reference_t<I>>>
-    );
-
-    template<typename F, typename I>
-    CPP_concept indirectly_regular_unary_invocable =
-        indirectly_readable<I> &&
-        copy_constructible<F> &&
-        CPP_concept_ref(ranges::indirectly_regular_unary_invocable_, F, I);
-
-    /// \cond
-    // Non-standard indirect invocable concepts
-    template(typename F, typename I1, typename I2)(
-    concept (indirectly_binary_invocable_impl_)(F, I1, I2),
-        invocable<F &, iter_value_t<I1> &, iter_value_t<I2> &> AND
-        invocable<F &, iter_value_t<I1> &, iter_reference_t<I2>> AND
-        invocable<F &, iter_reference_t<I1>, iter_value_t<I2> &> AND
-        invocable<F &, iter_reference_t<I1>, iter_reference_t<I2>> AND
-        invocable<F &, iter_common_reference_t<I1>, iter_common_reference_t<I2>> AND
-        detail::common_reference_with_4_<
-            invoke_result_t<F &, iter_value_t<I1> &, iter_value_t<I2> &>,
-            invoke_result_t<F &, iter_value_t<I1> &, iter_reference_t<I2>>,
-            invoke_result_t<F &, iter_reference_t<I1>, iter_value_t<I2> &>,
-            invoke_result_t<F &, iter_reference_t<I1>, iter_reference_t<I2>>>
-    );
-
-    template<typename F, typename I1, typename I2>
-    CPP_concept indirectly_binary_invocable_ =
-        indirectly_readable<I1> && indirectly_readable<I2> &&
-        copy_constructible<F> &&
-        CPP_concept_ref(ranges::indirectly_binary_invocable_impl_, F, I1, I2);
-
-    template(typename F, typename I1, typename I2)(
-    concept (indirectly_regular_binary_invocable_impl_)(F, I1, I2),
-        regular_invocable<F &, iter_value_t<I1> &, iter_value_t<I2> &> AND
-        regular_invocable<F &, iter_value_t<I1> &, iter_reference_t<I2>> AND
-        regular_invocable<F &, iter_reference_t<I1>, iter_value_t<I2> &> AND
-        regular_invocable<F &, iter_reference_t<I1>, iter_reference_t<I2>> AND
-        regular_invocable<F &, iter_common_reference_t<I1>, iter_common_reference_t<I2>> AND
-        detail::common_reference_with_4_<
-            invoke_result_t<F &, iter_value_t<I1> &, iter_value_t<I2> &>,
-            invoke_result_t<F &, iter_value_t<I1> &, iter_reference_t<I2>>,
-            invoke_result_t<F &, iter_reference_t<I1>, iter_value_t<I2> &>,
-            invoke_result_t<F &, iter_reference_t<I1>, iter_reference_t<I2>>>
-    );
-
-    template<typename F, typename I1, typename I2>
-    CPP_concept indirectly_regular_binary_invocable_ =
-        indirectly_readable<I1> && indirectly_readable<I2> &&
-        copy_constructible<F> &&
-        CPP_concept_ref(ranges::indirectly_regular_binary_invocable_impl_, F, I1, I2);
-    /// \endcond
-
-    template(typename F, typename I)(
-    concept (indirect_unary_predicate_)(F, I),
-        predicate<F &, iter_value_t<I> &> AND
-        predicate<F &, iter_reference_t<I>> AND
-        predicate<F &, iter_common_reference_t<I>>
-    );
-
-    template<typename F, typename I>
-    CPP_concept indirect_unary_predicate =
-        indirectly_readable<I> &&
-        copy_constructible<F> &&
-        CPP_concept_ref(ranges::indirect_unary_predicate_, F, I);
-
-    template(typename F, typename I1, typename I2)(
-    concept (indirect_binary_predicate_impl_)(F, I1, I2),
-        predicate<F &, iter_value_t<I1> &, iter_value_t<I2> &> AND
-        predicate<F &, iter_value_t<I1> &, iter_reference_t<I2>> AND
-        predicate<F &, iter_reference_t<I1>, iter_value_t<I2> &> AND
-        predicate<F &, iter_reference_t<I1>, iter_reference_t<I2>> AND
-        predicate<F &, iter_common_reference_t<I1>, iter_common_reference_t<I2>>
-    );
-
-    template<typename F, typename I1, typename I2>
-    CPP_concept indirect_binary_predicate_ =
-        indirectly_readable<I1> && indirectly_readable<I2> &&
-        copy_constructible<F> &&
-        CPP_concept_ref(ranges::indirect_binary_predicate_impl_, F, I1, I2);
-
-    template(typename F, typename I1, typename I2)(
-    concept (indirect_relation_)(F, I1, I2),
-        relation<F &, iter_value_t<I1> &, iter_value_t<I2> &> AND
-        relation<F &, iter_value_t<I1> &, iter_reference_t<I2>> AND
-        relation<F &, iter_reference_t<I1>, iter_value_t<I2> &> AND
-        relation<F &, iter_reference_t<I1>, iter_reference_t<I2>> AND
-        relation<F &, iter_common_reference_t<I1>, iter_common_reference_t<I2>>
-    );
-
-    template<typename F, typename I1, typename I2 = I1>
-    CPP_concept indirect_relation =
-        indirectly_readable<I1> && indirectly_readable<I2> &&
-        copy_constructible<F> &&
-        CPP_concept_ref(ranges::indirect_relation_, F, I1, I2);
-
-    template(typename F, typename I1, typename I2)(
-    concept (indirect_strict_weak_order_)(F, I1, I2),
-        strict_weak_order<F &, iter_value_t<I1> &, iter_value_t<I2> &> AND
-        strict_weak_order<F &, iter_value_t<I1> &, iter_reference_t<I2>> AND
-        strict_weak_order<F &, iter_reference_t<I1>, iter_value_t<I2> &> AND
-        strict_weak_order<F &, iter_reference_t<I1>, iter_reference_t<I2>> AND
-        strict_weak_order<F &, iter_common_reference_t<I1>, iter_common_reference_t<I2>>
-    );
-
-    template<typename F, typename I1, typename I2 = I1>
-    CPP_concept indirect_strict_weak_order =
-        indirectly_readable<I1> && indirectly_readable<I2> &&
-        copy_constructible<F> &&
-        CPP_concept_ref(ranges::indirect_strict_weak_order_, F, I1, I2);
-    // clang-format on
-
-    //////////////////////////////////////////////////////////////////////////////////////
-    // projected struct, for "projecting" a readable with a unary callable
-    /// \cond
-    namespace detail
-    {
-        RANGES_DIAGNOSTIC_PUSH
-        RANGES_DIAGNOSTIC_IGNORE_UNDEFINED_INTERNAL
-        template<typename I, typename Proj>
-        struct projected_
-        {
-            struct type
-            {
-                using reference = indirect_result_t<Proj &, I>;
-                using value_type = uncvref_t<reference>;
-                reference operator*() const;
-            };
-        };
-        RANGES_DIAGNOSTIC_POP
-
-        template<typename Proj>
-        struct select_projected_
-        {
-            template<typename I>
-            using apply =
-                meta::_t<
-                    detail::enable_if_t<
-                        (bool)indirectly_regular_unary_invocable<Proj, I>,
-                        detail::projected_<I, Proj>>>;
-        };
-
-        template<>
-        struct select_projected_<identity>
-        {
-            template<typename I>
-            using apply = detail::enable_if_t<(bool)indirectly_readable<I>, I>;
-        };
-    } // namespace detail
-    /// \endcond
-
-    template<typename I, typename Proj>
-    using projected = typename detail::select_projected_<Proj>::template apply<I>;
-
-    template<typename I, typename Proj>
-    struct incrementable_traits<detail::projected_<I, Proj>> : incrementable_traits<I>
-    {};
-
-    // clang-format off
-    template(typename I, typename O)(
-    concept (indirectly_movable_)(I, O),
-        indirectly_writable<O, iter_rvalue_reference_t<I>>
-    );
-
-    template<typename I, typename O>
-    CPP_concept indirectly_movable =
-        indirectly_readable<I> && CPP_concept_ref(ranges::indirectly_movable_, I, O);
-
-    template(typename I, typename O)(
-    concept (indirectly_movable_storable_)(I, O),
-        indirectly_writable<O, iter_value_t<I>> AND
-        movable<iter_value_t<I>> AND
-        constructible_from<iter_value_t<I>, iter_rvalue_reference_t<I>> AND
-        assignable_from<iter_value_t<I> &, iter_rvalue_reference_t<I>>
-    );
-
-    template<typename I, typename O>
-    CPP_concept indirectly_movable_storable =
-        indirectly_movable<I, O> &&
-        CPP_concept_ref(ranges::indirectly_movable_storable_, I, O);
-
-    template(typename I, typename O)(
-    concept (indirectly_copyable_)(I, O),
-        indirectly_writable<O, iter_reference_t<I>>
-    );
-
-    template<typename I, typename O>
-    CPP_concept indirectly_copyable =
-        indirectly_readable<I> && CPP_concept_ref(ranges::indirectly_copyable_, I, O);
-
-    template(typename I, typename O)(
-    concept (indirectly_copyable_storable_)(I, O),
-        indirectly_writable<O, iter_value_t<I> const &> AND
-        copyable<iter_value_t<I>> AND
-        constructible_from<iter_value_t<I>, iter_reference_t<I>> AND
-        assignable_from<iter_value_t<I> &, iter_reference_t<I>>
-    );
-
-    template<typename I, typename O>
-    CPP_concept indirectly_copyable_storable =
-        indirectly_copyable<I, O> &&
-        CPP_concept_ref(ranges::indirectly_copyable_storable_, I, O);
-
-    template<typename I1, typename I2>
-    CPP_requires(indirectly_swappable_,
-        requires(I1 const i1, I2 const i2) //
-        (
-            ranges::iter_swap(i1, i2),
-            ranges::iter_swap(i1, i1),
-            ranges::iter_swap(i2, i2),
-            ranges::iter_swap(i2, i1)
-        ));
-    template<typename I1, typename I2 = I1>
-    CPP_concept indirectly_swappable =
-        indirectly_readable<I1> && //
-        indirectly_readable<I2> && //
-        CPP_requires_ref(ranges::indirectly_swappable_, I1, I2);
-
-    template(typename C, typename I1, typename P1, typename I2, typename P2)(
-    concept (projected_indirect_relation_)(C, I1, P1, I2, P2),
-        indirect_relation<C, projected<I1, P1>, projected<I2, P2>>
-    );
-
-    template<typename I1, typename I2, typename C, typename P1 = identity,
-        typename P2 = identity>
-    CPP_concept indirectly_comparable =
-        CPP_concept_ref(ranges::projected_indirect_relation_, C, I1, P1, I2, P2);
-
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Composite concepts for use defining algorithms:
-    template<typename I>
-    CPP_concept permutable =
-        forward_iterator<I> &&
-        indirectly_swappable<I, I> &&
-        indirectly_movable_storable<I, I>;
-
-    template(typename C, typename I1, typename P1, typename I2, typename P2)(
-    concept (projected_indirect_strict_weak_order_)(C, I1, P1, I2, P2),
-        indirect_strict_weak_order<C, projected<I1, P1>, projected<I2, P2>>
-    );
-
-    template<typename I1, typename I2, typename Out, typename C = less,
-        typename P1 = identity, typename P2 = identity>
-    CPP_concept mergeable =
-        input_iterator<I1> &&
-        input_iterator<I2> &&
-        weakly_incrementable<Out> &&
-        indirectly_copyable<I1, Out> &&
-        indirectly_copyable<I2, Out> &&
-        CPP_concept_ref(ranges::projected_indirect_strict_weak_order_, C, I1, P1, I2, P2);
-
-    template<typename I, typename C = less, typename P = identity>
-    CPP_concept sortable =
-        permutable<I> &&
-        CPP_concept_ref(ranges::projected_indirect_strict_weak_order_, C, I, P, I, P);
-    // clang-format on
-
-    struct sentinel_tag
-    {};
-    struct sized_sentinel_tag : sentinel_tag
-    {};
-
-    template<typename S, typename I>
-    using sentinel_tag_of =               //
-        std::enable_if_t<                 //
-            sentinel_for<S, I>,           //
-            meta::conditional_t<            //
-                sized_sentinel_for<S, I>, //
-                sized_sentinel_tag,       //
-                sentinel_tag>>;
-
-    // Deprecated things:
-    /// \cond
-    template<typename I>
-    using iterator_category RANGES_DEPRECATED(
-        "iterator_category is deprecated. Use the iterator concepts instead") =
-        detail::iterator_category<I>;
-
-    template<typename I>
-    using iterator_category_t RANGES_DEPRECATED(
-        "iterator_category_t is deprecated. Use the iterator concepts instead") =
-        meta::_t<detail::iterator_category<I>>;
-
-    template<typename Fun, typename... Is>
-    using indirect_invoke_result_t RANGES_DEPRECATED(
-        "Please switch to indirect_result_t") = indirect_result_t<Fun, Is...>;
-
-    template<typename Fun, typename... Is>
-    struct RANGES_DEPRECATED("Please switch to indirect_result_t") indirect_invoke_result
-      : meta::defer<indirect_result_t, Fun, Is...>
-    {};
-
-    template<typename Sig>
-    struct indirect_result_of
-    {};
-
-    template<typename Fun, typename... Is>
-    struct RANGES_DEPRECATED("Please switch to indirect_result_t")
-        indirect_result_of<Fun(Is...)> : meta::defer<indirect_result_t, Fun, Is...>
-    {};
-
-    template<typename Sig>
-    using indirect_result_of_t RANGES_DEPRECATED("Please switch to indirect_result_t") =
-        meta::_t<indirect_result_of<Sig>>;
-    /// \endcond
-
-    namespace cpp20
-    {
-        using ranges::bidirectional_iterator;
-        using ranges::contiguous_iterator;
-        using ranges::forward_iterator;
-        using ranges::incrementable;
-        using ranges::indirect_relation;
-        using ranges::indirect_result_t;
-        using ranges::indirect_strict_weak_order;
-        using ranges::indirect_unary_predicate;
-        using ranges::indirectly_comparable;
-        using ranges::indirectly_copyable;
-        using ranges::indirectly_copyable_storable;
-        using ranges::indirectly_movable;
-        using ranges::indirectly_movable_storable;
-        using ranges::indirectly_readable;
-        using ranges::indirectly_regular_unary_invocable;
-        using ranges::indirectly_swappable;
-        using ranges::indirectly_unary_invocable;
-        using ranges::indirectly_writable;
-        using ranges::input_iterator;
-        using ranges::input_or_output_iterator;
-        using ranges::mergeable;
-        using ranges::output_iterator;
-        using ranges::permutable;
-        using ranges::projected;
-        using ranges::random_access_iterator;
-        using ranges::sentinel_for;
-        using ranges::sized_sentinel_for;
-        using ranges::sortable;
-        using ranges::weakly_incrementable;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#ifdef _GLIBCXX_DEBUG
-// HACKHACK: workaround underconstrained operator- for libstdc++ debug iterator wrapper
-// by intentionally creating an ambiguity when the wrapped types don't support the
-// necessary operation.
-namespace __gnu_debug
-{
-    template(typename I1, typename I2, typename Seq)(
-        /// \pre
-        requires (!::ranges::sized_sentinel_for<I1, I2>)) //
-    void operator-(_Safe_iterator<I1, Seq> const &, _Safe_iterator<I2, Seq> const &) =
-        delete;
-
-    template(typename I1, typename Seq)(
-        /// \pre
-        requires (!::ranges::sized_sentinel_for<I1, I1>)) //
-    void operator-(_Safe_iterator<I1, Seq> const &, _Safe_iterator<I1, Seq> const &) =
-        delete;
-} // namespace __gnu_debug
-#endif
-
-#if defined(__GLIBCXX__) || (defined(_LIBCPP_VERSION) && _LIBCPP_VERSION <= 3900)
-// HACKHACK: workaround libc++ (https://llvm.org/bugs/show_bug.cgi?id=28421)
-// and libstdc++ (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=71771)
-// underconstrained operator- for reverse_iterator by disabling sized_sentinel_for
-// when the base iterators do not model sized_sentinel_for.
-
-namespace ranges
-{
-    template<typename S, typename I>
-    /*inline*/ constexpr bool
-        disable_sized_sentinel<std::reverse_iterator<S>, std::reverse_iterator<I>> =
-            !static_cast<bool>(sized_sentinel_for<I, S>);
-} // namespace ranges
-
-#endif // defined(__GLIBCXX__) || (defined(_LIBCPP_VERSION) && _LIBCPP_VERSION <= 3900)
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif // RANGES_V3_ITERATOR_CONCEPTS_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/iterator/counted_iterator.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/iterator/counted_iterator.hpp
deleted file mode 100644
index eba9d09e..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/iterator/counted_iterator.hpp
+++ /dev/null
@@ -1,498 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ITERATOR_COUNTED_ITERATOR_HPP
-#define RANGES_V3_ITERATOR_COUNTED_ITERATOR_HPP
-
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/default_sentinel.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-iterator
-    /// @{
-
-    /// \cond
-    namespace _counted_iterator_
-    {
-        struct access
-        {
-            template<typename I>
-            static constexpr iter_difference_t<counted_iterator<I>> & count(
-                counted_iterator<I> & ci) noexcept
-            {
-                return ci.cnt_;
-            }
-
-            template<typename I>
-            static constexpr I & current(counted_iterator<I> & ci) noexcept
-            {
-                return ci.current_;
-            }
-
-            template<typename I>
-            static constexpr I const & current(counted_iterator<I> const & ci) noexcept
-            {
-                return ci.current_;
-            }
-        };
-
-        template<bool>
-        struct contiguous_iterator_concept_base
-        {};
-
-        template<>
-        struct contiguous_iterator_concept_base<true>
-        {
-            using iterator_concept = ranges::contiguous_iterator_tag;
-        };
-    } // namespace _counted_iterator_
-    /// \endcond
-
-    template<typename I>
-        // requires input_or_output_iterator<I>
-    struct counted_iterator
-      : _counted_iterator_::contiguous_iterator_concept_base<(bool)contiguous_iterator<I>>
-    {
-    private:
-        friend advance_fn;
-        CPP_assert(input_or_output_iterator<I>);
-        friend _counted_iterator_::access;
-
-        I current_{};
-        iter_difference_t<I> cnt_{0};
-
-        constexpr void post_increment_(std::true_type)
-        {
-            CPP_assert(std::is_void<decltype(current_++)>());
-            ++current_;
-        }
-        constexpr auto post_increment_(std::false_type) -> decltype(current_++)
-        {
-            CPP_assert(!std::is_void<decltype(current_++)>());
-            auto && tmp = current_++;
-            --cnt_;
-            return static_cast<decltype(tmp) &&>(tmp);
-        }
-
-    public:
-        using iterator_type = I;
-        using difference_type = iter_difference_t<I>;
-
-        counted_iterator() = default;
-
-        constexpr counted_iterator(I x, iter_difference_t<I> n)
-          : current_(std::move(x))
-          , cnt_(n)
-        {
-            RANGES_EXPECT(n >= 0);
-        }
-
-        template(typename I2)(
-            /// \pre
-            requires convertible_to<I2, I>)
-        constexpr counted_iterator(counted_iterator<I2> const & i)
-          : current_(_counted_iterator_::access::current(i))
-          , cnt_(i.count())
-        {}
-
-        template(typename I2)(
-            /// \pre
-            requires convertible_to<I2, I>)
-        constexpr counted_iterator & operator=(counted_iterator<I2> const & i)
-        {
-            current_ = _counted_iterator_::access::current(i);
-            cnt_ = i.count();
-        }
-
-        constexpr I base() const
-        {
-            return current_;
-        }
-
-        constexpr iter_difference_t<I> count() const
-        {
-            return cnt_;
-        }
-
-        constexpr iter_reference_t<I> operator*() noexcept(
-            noexcept(iter_reference_t<I>(*current_)))
-        {
-            RANGES_EXPECT(cnt_ > 0);
-            return *current_;
-        }
-        template(typename I2 = I)(
-            /// \pre
-            requires indirectly_readable<I2 const>)
-        constexpr iter_reference_t<I2> operator*() const //
-            noexcept(noexcept(iter_reference_t<I>(*current_)))
-        {
-            RANGES_EXPECT(cnt_ > 0);
-            return *current_;
-        }
-
-        constexpr counted_iterator & operator++()
-        {
-            RANGES_EXPECT(cnt_ > 0);
-            ++current_;
-            --cnt_;
-            return *this;
-        }
-
-#ifdef RANGES_WORKAROUND_MSVC_677925
-        template(typename I2 = I)(
-            /// \pre
-            requires (!forward_iterator<I2>)) //
-        constexpr auto operator++(int) -> decltype(std::declval<I2 &>()++)
-#else  // ^^^ workaround ^^^ / vvv no workaround vvv
-        CPP_member
-        constexpr auto operator++(int) //
-            -> CPP_ret(decltype(std::declval<I &>()++))(
-                /// \pre
-                requires (!forward_iterator<I>))
-#endif // RANGES_WORKAROUND_MSVC_677925
-        {
-            RANGES_EXPECT(cnt_ > 0);
-            return post_increment_(std::is_void<decltype(current_++)>());
-        }
-
-        CPP_member
-        constexpr auto operator++(int) //
-            -> CPP_ret(counted_iterator)(
-                /// \pre
-                requires forward_iterator<I>)
-        {
-            auto tmp(*this);
-            ++*this;
-            return tmp;
-        }
-
-        CPP_member
-        constexpr auto operator--() //
-            -> CPP_ret(counted_iterator &)(
-                /// \pre
-                requires bidirectional_iterator<I>)
-        {
-            --current_;
-            ++cnt_;
-            return *this;
-        }
-
-        CPP_member
-        constexpr auto operator--(int) //
-            -> CPP_ret(counted_iterator)(
-                /// \pre
-                requires bidirectional_iterator<I>)
-        {
-            auto tmp(*this);
-            --*this;
-            return tmp;
-        }
-
-        CPP_member
-        constexpr auto operator+=(difference_type n) //
-            -> CPP_ret(counted_iterator &)(
-                /// \pre
-                requires random_access_iterator<I>)
-        {
-            RANGES_EXPECT(cnt_ >= n);
-            current_ += n;
-            cnt_ -= n;
-            return *this;
-        }
-
-        CPP_member
-        constexpr auto operator+(difference_type n) const //
-            -> CPP_ret(counted_iterator)(
-                /// \pre
-                requires random_access_iterator<I>)
-        {
-            auto tmp(*this);
-            tmp += n;
-            return tmp;
-        }
-
-        CPP_member
-        constexpr auto operator-=(difference_type n) //
-            -> CPP_ret(counted_iterator &)(
-                /// \pre
-                requires random_access_iterator<I>)
-        {
-            RANGES_EXPECT(cnt_ >= -n);
-            current_ -= n;
-            cnt_ += n;
-            return *this;
-        }
-
-        CPP_member
-        constexpr auto operator-(difference_type n) const //
-            -> CPP_ret(counted_iterator)(
-                /// \pre
-                requires random_access_iterator<I>)
-        {
-            auto tmp(*this);
-            tmp -= n;
-            return tmp;
-        }
-
-        CPP_member
-        constexpr auto operator[](difference_type n) const //
-            -> CPP_ret(iter_reference_t<I>)(
-                /// \pre
-                requires random_access_iterator<I>)
-        {
-            RANGES_EXPECT(cnt_ >= n);
-            return current_[n];
-        }
-
-#if !RANGES_BROKEN_CPO_LOOKUP
-        CPP_broken_friend_member
-        friend constexpr auto iter_move(counted_iterator const & i) //
-            noexcept(detail::has_nothrow_iter_move_v<I>)
-            -> CPP_broken_friend_ret(iter_rvalue_reference_t<I>)(
-                /// \pre
-                requires input_iterator<I>)
-        {
-            return ranges::iter_move(i.current_);
-        }
-        template<typename I2, typename S2>
-        friend constexpr auto iter_swap(counted_iterator const & x,
-                                        counted_iterator<I2> const & y) //
-            noexcept(is_nothrow_indirectly_swappable<I, I2>::value)
-            -> CPP_broken_friend_ret(void)(
-                /// \pre
-                requires indirectly_swappable<I2, I>)
-        {
-            return ranges::iter_swap(x.current_, _counted_iterator_::access::current(y));
-        }
-#endif
-    };
-
-    /// \cond
-#if RANGES_BROKEN_CPO_LOOKUP
-    namespace _counted_iterator_
-    {
-        template<typename I>
-        constexpr auto iter_move(counted_iterator<I> const & i) noexcept(
-            detail::has_nothrow_iter_move_v<I>)
-            -> CPP_broken_friend_ret(iter_rvalue_reference_t<I>)(
-                /// \pre
-                requires input_iterator<I>)
-        {
-            return ranges::iter_move(_counted_iterator_::access::current(i));
-        }
-        template<typename I1, typename I2>
-        constexpr auto iter_swap(
-            counted_iterator<I1> const & x,
-            counted_iterator<I2> const &
-                y) noexcept(is_nothrow_indirectly_swappable<I1, I2>::value)
-            -> CPP_broken_friend_ret(void)(
-                /// \pre
-                requires indirectly_swappable<I2, I1>)
-        {
-            return ranges::iter_swap(_counted_iterator_::access::current(x),
-                                     _counted_iterator_::access::current(y));
-        }
-    } // namespace _counted_iterator_
-#endif
-    /// endcond
-
-    template(typename I1, typename I2)(
-        /// \pre
-        requires common_with<I1, I2>)
-    constexpr bool operator==(counted_iterator<I1> const & x,
-                              counted_iterator<I2> const & y)
-    {
-        return x.count() == y.count();
-    }
-
-    template<typename I>
-    constexpr bool operator==(counted_iterator<I> const & x, default_sentinel_t)
-    {
-        return x.count() == 0;
-    }
-
-    template<typename I>
-    constexpr bool operator==(default_sentinel_t, counted_iterator<I> const & x)
-    {
-        return x.count() == 0;
-    }
-
-    template(typename I1, typename I2)(
-        /// \pre
-        requires common_with<I1, I2>)
-    constexpr bool operator!=(counted_iterator<I1> const & x,
-                              counted_iterator<I2> const & y)
-    {
-        return !(x == y);
-    }
-
-    template<typename I>
-    constexpr bool operator!=(counted_iterator<I> const & x, default_sentinel_t y)
-    {
-        return !(x == y);
-    }
-
-    template<typename I>
-    constexpr bool operator!=(default_sentinel_t x, counted_iterator<I> const & y)
-    {
-        return !(x == y);
-    }
-
-    template(typename I1, typename I2)(
-        /// \pre
-        requires common_with<I1, I2>)
-    constexpr bool operator<(counted_iterator<I1> const & x,
-                             counted_iterator<I2> const & y)
-    {
-        return y.count() < x.count();
-    }
-
-    template(typename I1, typename I2)(
-        /// \pre
-        requires common_with<I1, I2>)
-    constexpr bool operator<=(counted_iterator<I1> const & x,
-                              counted_iterator<I2> const & y)
-    {
-        return !(y < x);
-    }
-
-    template(typename I1, typename I2)(
-        /// \pre
-        requires common_with<I1, I2>)
-    constexpr bool operator>(counted_iterator<I1> const & x,
-                             counted_iterator<I2> const & y)
-    {
-        return y < x;
-    }
-
-    template(typename I1, typename I2)(
-        /// \pre
-        requires common_with<I1, I2>)
-    constexpr bool operator>=(counted_iterator<I1> const & x,
-                              counted_iterator<I2> const & y)
-    {
-        return !(x < y);
-    }
-
-    template(typename I1, typename I2)(
-        /// \pre
-        requires common_with<I1, I2>)
-    constexpr iter_difference_t<I2> operator-(counted_iterator<I1> const & x,
-                                              counted_iterator<I2> const & y)
-    {
-        return y.count() - x.count();
-    }
-
-    template<typename I>
-    constexpr iter_difference_t<I> operator-(counted_iterator<I> const & x,
-                                             default_sentinel_t)
-    {
-        return -x.count();
-    }
-
-    template<typename I>
-    constexpr iter_difference_t<I> operator-(default_sentinel_t,
-                                             counted_iterator<I> const & y)
-    {
-        return y.count();
-    }
-
-    template(typename I)(
-        /// \pre
-        requires random_access_iterator<I>)
-    constexpr counted_iterator<I> operator+(iter_difference_t<I> n,
-                                            counted_iterator<I> const & x)
-    {
-        return x + n;
-    }
-
-    template(typename I)(
-        /// \pre
-        requires input_or_output_iterator<I>)
-    constexpr counted_iterator<I> make_counted_iterator(I i, iter_difference_t<I> n)
-    {
-        return {std::move(i), n};
-    }
-
-    template<typename I>
-    struct indirectly_readable_traits<counted_iterator<I>>
-      : meta::conditional_t<
-            (bool)indirectly_readable<I>,
-            indirectly_readable_traits<I>,
-            meta::nil_>
-    {};
-
-    CPP_template_def(typename I)(
-        /// \pre
-        requires input_or_output_iterator<I>)
-    constexpr void advance_fn::operator()(counted_iterator<I> & i,
-                                          iter_difference_t<I> n) const
-    {
-        RANGES_EXPECT(n <= i.cnt_);
-        advance(i.current_, n);
-        i.cnt_ -= n;
-    }
-
-    namespace cpp20
-    {
-        using ranges::counted_iterator;
-    }
-    /// @}
-} // namespace ranges
-
-/// \cond
-namespace ranges
-{
-    namespace _counted_iterator_
-    {
-        template<typename I, typename = void>
-        struct iterator_traits_
-        {
-            using difference_type = iter_difference_t<I>;
-            using value_type = void;
-            using reference = void;
-            using pointer = void;
-            using iterator_category = std::output_iterator_tag;
-        };
-
-        template<typename I>
-        struct iterator_traits_<I, meta::if_c<input_iterator<I>>>
-          : std::iterator_traits<I>
-        {
-            using pointer = void;
-        };
-    } // namespace _counted_iterator_
-} // namespace ranges
-
-namespace std
-{
-    template<typename I>
-    struct iterator_traits<::ranges::counted_iterator<I>>
-      : ::ranges::_counted_iterator_::iterator_traits_<I>
-    {};
-} // namespace std
-/// \endcond
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/iterator/default_sentinel.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/iterator/default_sentinel.hpp
deleted file mode 100644
index af3c1b13..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/iterator/default_sentinel.hpp
+++ /dev/null
@@ -1,41 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ITERATOR_DEFAULT_SENTINEL_HPP
-#define RANGES_V3_ITERATOR_DEFAULT_SENTINEL_HPP
-
-#include <range/v3/detail/config.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-iterator
-    /// @{
-    struct default_sentinel_t
-    {};
-
-    // Default sentinel
-    RANGES_INLINE_VARIABLE(default_sentinel_t, default_sentinel)
-
-    namespace cpp20
-    {
-        using ranges::default_sentinel;
-        using ranges::default_sentinel_t;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/iterator/diffmax_t.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/iterator/diffmax_t.hpp
deleted file mode 100644
index 334f4226..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/iterator/diffmax_t.hpp
+++ /dev/null
@@ -1,483 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2019-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ITERATOR_DIFFMAX_T_HPP
-#define RANGES_V3_ITERATOR_DIFFMAX_T_HPP
-
-#include <cstdint>
-#include <iosfwd>
-#include <limits>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/concepts.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-RANGES_DIAGNOSTIC_PUSH
-RANGES_DIAGNOSTIC_IGNORE_UNSIGNED_MATH
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        struct diffmax_t
-        {
-        private:
-            bool neg_;
-            std::uintmax_t val_;
-            struct tag
-            {};
-
-            constexpr diffmax_t(tag, bool neg, std::uintmax_t val)
-              : neg_(val && neg)
-              , val_(val)
-            {}
-
-            /// \cond
-            constexpr void _check()
-            {
-                RANGES_ENSURE(!neg_ || val_);
-            }
-            static constexpr diffmax_t _normalize(bool neg, std::uintmax_t val)
-            {
-                return diffmax_t{tag{}, val && neg, val};
-            }
-            /// \endcond
-
-        public:
-            diffmax_t() = default;
-
-            template(typename T)(
-                /// \pre
-                requires integral<T>)
-            constexpr diffmax_t(T val) noexcept
-              : neg_(0 > val)
-              , val_(0 > val ? static_cast<std::uintmax_t>(-val)
-                             : static_cast<std::uintmax_t>(val))
-            {}
-
-            friend constexpr bool operator<(diffmax_t a, diffmax_t b) noexcept
-            {
-                a._check();
-                b._check();
-                return a.neg_ ? (b.neg_ ? a.val_ > b.val_ : true)
-                              : (b.neg_ ? false : a.val_ < b.val_);
-            }
-            friend constexpr bool operator>(diffmax_t a, diffmax_t b) noexcept
-            {
-                return b < a;
-            }
-            friend constexpr bool operator<=(diffmax_t a, diffmax_t b) noexcept
-            {
-                return !(b < a);
-            }
-            friend constexpr bool operator>=(diffmax_t a, diffmax_t b) noexcept
-            {
-                return !(a < b);
-            }
-            friend constexpr bool operator==(diffmax_t a, diffmax_t b) noexcept
-            {
-                a._check();
-                b._check();
-                return a.val_ == b.val_ && a.neg_ == b.neg_;
-            }
-            friend constexpr bool operator!=(diffmax_t a, diffmax_t b) noexcept
-            {
-                return !(a == b);
-            }
-
-            friend constexpr diffmax_t operator+(diffmax_t a) noexcept
-            {
-                return a;
-            }
-            friend constexpr diffmax_t operator-(diffmax_t a) noexcept
-            {
-                return _normalize(!a.neg_, a.val_);
-            }
-
-            friend constexpr diffmax_t operator+(diffmax_t a, diffmax_t b) noexcept
-            {
-                return a.neg_ == b.neg_
-                           ? diffmax_t{tag{}, a.neg_, a.val_ + b.val_}
-                           : (a.neg_ ? (a.val_ > b.val_
-                                            ? diffmax_t{tag{}, true, a.val_ - b.val_}
-                                            : diffmax_t{tag{}, false, b.val_ - a.val_})
-                                     : (b.val_ > a.val_
-                                            ? diffmax_t{tag{}, true, b.val_ - a.val_}
-                                            : diffmax_t{tag{}, false, a.val_ - b.val_}));
-            }
-            friend constexpr diffmax_t operator-(diffmax_t a, diffmax_t b) noexcept
-            {
-                return a + -b;
-            }
-            friend constexpr diffmax_t operator*(diffmax_t a, diffmax_t b) noexcept
-            {
-                return _normalize(a.neg_ ^ b.neg_, a.val_ * b.val_);
-            }
-            friend constexpr diffmax_t operator/(diffmax_t a, diffmax_t b) noexcept
-            {
-                return _normalize(a.neg_ ^ b.neg_, a.val_ / b.val_);
-            }
-            friend constexpr diffmax_t operator%(diffmax_t a, diffmax_t b) noexcept
-            {
-                return _normalize(a.neg_, a.val_ % b.val_);
-            }
-            static constexpr std::uintmax_t compl_if(bool neg,
-                                                     std::uintmax_t val) noexcept
-            {
-                return neg ? ~val + 1 : val;
-            }
-            friend constexpr diffmax_t operator&(diffmax_t a, diffmax_t b) noexcept
-            {
-                return _normalize(
-                    a.neg_ && b.neg_,
-                    compl_if(a.neg_ && b.neg_,
-                             compl_if(a.neg_, a.val_) & compl_if(b.neg_, b.val_)));
-            }
-            friend constexpr diffmax_t operator|(diffmax_t a, diffmax_t b) noexcept
-            {
-                return _normalize(
-                    a.neg_ || b.neg_,
-                    compl_if(a.neg_ || b.neg_,
-                             compl_if(a.neg_, a.val_) | compl_if(b.neg_, b.val_)));
-            }
-            friend constexpr diffmax_t operator^(diffmax_t a, diffmax_t b) noexcept
-            {
-                return _normalize(
-                    bool(a.neg_ ^ b.neg_),
-                    compl_if(bool(a.neg_ ^ b.neg_),
-                             compl_if(a.neg_, a.val_) ^ compl_if(b.neg_, b.val_)));
-            }
-
-            friend constexpr diffmax_t operator<<(diffmax_t a, diffmax_t b) noexcept
-            {
-                RANGES_ENSURE(!a.neg_);
-                return b.neg_ ? diffmax_t{tag{}, false, a.val_ >> b.val_}
-                              : diffmax_t{tag{}, false, a.val_ << b.val_};
-            }
-            friend constexpr diffmax_t operator>>(diffmax_t a, diffmax_t b) noexcept
-            {
-                return b.neg_ ? diffmax_t{tag{}, a.neg_, a.val_ << b.val_}
-                              : diffmax_t{tag{}, a.neg_, a.val_ >> b.val_};
-            }
-
-            friend constexpr diffmax_t & operator+=(diffmax_t & a, diffmax_t b) noexcept
-            {
-                return (a = a + b);
-            }
-            friend constexpr diffmax_t & operator-=(diffmax_t & a, diffmax_t b) noexcept
-            {
-                return (a = a - b);
-            }
-            friend constexpr diffmax_t & operator*=(diffmax_t & a, diffmax_t b) noexcept
-            {
-                return (a = a * b);
-            }
-            friend constexpr diffmax_t & operator/=(diffmax_t & a, diffmax_t b) noexcept
-            {
-                return (a = a / b);
-            }
-            friend constexpr diffmax_t & operator%=(diffmax_t & a, diffmax_t b) noexcept
-            {
-                return (a = a % b);
-            }
-            friend constexpr diffmax_t & operator&=(diffmax_t & a, diffmax_t b) noexcept
-            {
-                return (a = a & b);
-            }
-            friend constexpr diffmax_t & operator|=(diffmax_t & a, diffmax_t b) noexcept
-            {
-                return (a = a | b);
-            }
-            friend constexpr diffmax_t & operator^=(diffmax_t & a, diffmax_t b) noexcept
-            {
-                return (a = a ^ b);
-            }
-            friend constexpr diffmax_t & operator<<=(diffmax_t & a, diffmax_t b) noexcept
-            {
-                a = (a << b);
-                return a;
-            }
-            friend constexpr diffmax_t & operator>>=(diffmax_t & a, diffmax_t b) noexcept
-            {
-                a = (a >> b);
-                return a;
-            }
-
-            template<typename T>
-            friend constexpr auto operator+=(T & a, diffmax_t b) noexcept
-                -> CPP_broken_friend_ret(T &)(
-                    /// \pre
-                    requires integral<T>)
-            {
-                return (a = static_cast<T>(diffmax_t{a} + b));
-            }
-            template<typename T>
-            friend constexpr auto operator-=(T & a, diffmax_t b) noexcept
-                -> CPP_broken_friend_ret(T &)(
-                    /// \pre
-                    requires integral<T>)
-            {
-                return (a = static_cast<T>(diffmax_t{a} - b));
-            }
-            template<typename T>
-            friend constexpr auto operator*=(T & a, diffmax_t b) noexcept
-                -> CPP_broken_friend_ret(T &)(
-                    /// \pre
-                    requires integral<T>)
-            {
-                return (a = static_cast<T>(diffmax_t{a} * b));
-            }
-            template<typename T>
-            friend constexpr auto operator/=(T & a, diffmax_t b) noexcept
-                -> CPP_broken_friend_ret(T &)(
-                    /// \pre
-                    requires integral<T>)
-            {
-                return (a = static_cast<T>(diffmax_t{a} / b));
-            }
-            template<typename T>
-            friend constexpr auto operator%=(T & a, diffmax_t b) noexcept
-                -> CPP_broken_friend_ret(T &)(
-                    /// \pre
-                    requires integral<T>)
-            {
-                return (a = static_cast<T>(diffmax_t{a} % b));
-            }
-            template<typename T>
-            friend constexpr auto operator&=(T & a, diffmax_t b) noexcept
-                -> CPP_broken_friend_ret(T &)(
-                    /// \pre
-                    requires integral<T>)
-            {
-                return (a = static_cast<T>(diffmax_t{a} & b));
-            }
-            template<typename T>
-            friend constexpr auto operator|=(T & a, diffmax_t b) noexcept
-                -> CPP_broken_friend_ret(T &)(
-                    /// \pre
-                    requires integral<T>)
-            {
-                return (a = static_cast<T>(diffmax_t{a} | b));
-            }
-            template<typename T>
-            friend constexpr auto operator^=(T & a, diffmax_t b) noexcept
-                -> CPP_broken_friend_ret(T &)(
-                    /// \pre
-                    requires integral<T>)
-            {
-                return (a = static_cast<T>(diffmax_t{a} ^ b));
-            }
-            template<typename T>
-            friend constexpr auto operator<<=(T & a, diffmax_t b) noexcept
-                -> CPP_broken_friend_ret(T &)(
-                    /// \pre
-                    requires integral<T>)
-            {
-                a = static_cast<T>(diffmax_t{a} << b);
-                return a;
-            }
-            template<typename T>
-            friend constexpr auto operator>>=(T & a, diffmax_t b) noexcept
-                -> CPP_broken_friend_ret(T &)(
-                    /// \pre
-                    requires integral<T>)
-            {
-                a = static_cast<T>(diffmax_t{a} >> b);
-                return a;
-            }
-
-            friend constexpr diffmax_t & operator++(diffmax_t & a) noexcept
-            {
-                a.neg_ = (a.neg_ ? --a.val_ : ++a.val_) && a.neg_;
-                return a;
-            }
-            friend constexpr diffmax_t & operator--(diffmax_t & a) noexcept
-            {
-                a.neg_ = (a.neg_ ? ++a.val_ : --a.val_) && a.neg_;
-                return a;
-            }
-            friend constexpr diffmax_t operator++(diffmax_t & a, int) noexcept
-            {
-                auto tmp = a;
-                ++a;
-                return tmp;
-            }
-            friend constexpr diffmax_t operator--(diffmax_t & a, int) noexcept
-            {
-                auto tmp = a;
-                --a;
-                return tmp;
-            }
-
-            template(typename T)(
-                /// \pre
-                requires integral<T>)
-                constexpr explicit
-                operator T() const noexcept
-            {
-                return neg_ ? -static_cast<T>(val_) : static_cast<T>(val_);
-            }
-            constexpr explicit operator bool() const noexcept
-            {
-                return val_ != 0;
-            }
-            constexpr bool operator!() const noexcept
-            {
-                return val_ == 0;
-            }
-
-            template<typename Ostream>
-            friend auto operator<<(Ostream & sout, diffmax_t a)
-                -> CPP_broken_friend_ret(std::ostream &)(
-                    /// \pre
-                    requires derived_from<
-                        Ostream, std::basic_ostream<typename Ostream::char_type,
-                                                    typename Ostream::traits_type>>)
-            {
-                return sout << (&"-"[!a.neg_]) << a.val_;
-            }
-        };
-
-#if RANGES_CXX_INLINE_VARIABLES >= RANGES_CXX_INLINE_VARIABLES_17
-        template<>
-        inline constexpr bool _is_integer_like_<diffmax_t> = true;
-#else
-        template<typename Enable>
-        constexpr bool _is_integer_like_<diffmax_t, Enable> = true;
-#endif
-    } // namespace detail
-    /// \endcond
-} // namespace ranges
-
-/// \cond
-RANGES_DIAGNOSTIC_IGNORE_MISMATCHED_TAGS
-
-namespace std
-{
-    template<>
-    struct numeric_limits<::ranges::detail::diffmax_t>
-    {
-        static constexpr bool is_specialized = true;
-        static constexpr bool is_signed = true;
-        static constexpr bool is_integer = true;
-        static constexpr bool is_exact = true;
-        static constexpr bool has_infinity = false;
-        static constexpr bool has_quiet_NaN = false;
-        static constexpr bool has_signaling_NaN = false;
-        static constexpr bool has_denorm = false;
-        static constexpr bool has_denorm_loss = false;
-        static constexpr std::float_round_style round_style = std::round_toward_zero;
-        static constexpr bool is_iec559 = false;
-        static constexpr bool is_bounded = true;
-        static constexpr bool is_modulo = false;
-        static constexpr int digits = CHAR_BIT * sizeof(std::uintmax_t) + 1;
-        static constexpr int digits10 =
-            static_cast<int>(digits * 0.301029996); // digits * std::log10(2)
-        static constexpr int max_digits10 = 0;
-        static constexpr int radix = 2;
-        static constexpr int min_exponent = 0;
-        static constexpr int min_exponent10 = 0;
-        static constexpr int max_exponent = 0;
-        static constexpr int max_exponent10 = 0;
-        static constexpr bool traps = true;
-        static constexpr bool tinyness_before = false;
-
-        static constexpr ::ranges::detail::diffmax_t max() noexcept
-        {
-            return std::uintmax_t(-1);
-        }
-        static constexpr ::ranges::detail::diffmax_t min() noexcept
-        {
-            return -max();
-        }
-        static constexpr ::ranges::detail::diffmax_t lowest() noexcept
-        {
-            return min();
-        }
-        static constexpr ::ranges::detail::diffmax_t epsilon() noexcept
-        {
-            return 0;
-        }
-        static constexpr ::ranges::detail::diffmax_t round_error() noexcept
-        {
-            return 0;
-        }
-        static constexpr ::ranges::detail::diffmax_t infinity() noexcept
-        {
-            return 0;
-        }
-        static constexpr ::ranges::detail::diffmax_t quiet_NaN() noexcept
-        {
-            return 0;
-        }
-        static constexpr ::ranges::detail::diffmax_t signaling_NaN() noexcept
-        {
-            return 0;
-        }
-        static constexpr ::ranges::detail::diffmax_t denorm_min() noexcept
-        {
-            return 0;
-        }
-    };
-    template<>
-    struct numeric_limits<::ranges::detail::diffmax_t const>
-      : numeric_limits<::ranges::detail::diffmax_t>
-    {};
-    template<>
-    struct numeric_limits<::ranges::detail::diffmax_t volatile>
-      : numeric_limits<::ranges::detail::diffmax_t>
-    {};
-    template<>
-    struct numeric_limits<::ranges::detail::diffmax_t const volatile>
-      : numeric_limits<::ranges::detail::diffmax_t>
-    {};
-
-#if RANGES_CXX_INLINE_VARIABLES >= RANGES_CXX_INLINE_VARIABLES_17
-    inline constexpr bool numeric_limits<::ranges::detail::diffmax_t>::is_specialized;
-    inline constexpr bool numeric_limits<::ranges::detail::diffmax_t>::is_signed;
-    inline constexpr bool numeric_limits<::ranges::detail::diffmax_t>::is_integer;
-    inline constexpr bool numeric_limits<::ranges::detail::diffmax_t>::is_exact;
-    inline constexpr bool numeric_limits<::ranges::detail::diffmax_t>::has_infinity;
-    inline constexpr bool numeric_limits<::ranges::detail::diffmax_t>::has_quiet_NaN;
-    inline constexpr bool numeric_limits<::ranges::detail::diffmax_t>::has_signaling_NaN;
-    inline constexpr bool numeric_limits<::ranges::detail::diffmax_t>::has_denorm;
-    inline constexpr bool numeric_limits<::ranges::detail::diffmax_t>::has_denorm_loss;
-    inline constexpr std::float_round_style
-        numeric_limits<::ranges::detail::diffmax_t>::round_style;
-    inline constexpr bool numeric_limits<::ranges::detail::diffmax_t>::is_iec559;
-    inline constexpr bool numeric_limits<::ranges::detail::diffmax_t>::is_bounded;
-    inline constexpr bool numeric_limits<::ranges::detail::diffmax_t>::is_modulo;
-    inline constexpr int numeric_limits<::ranges::detail::diffmax_t>::digits;
-    inline constexpr int numeric_limits<::ranges::detail::diffmax_t>::digits10;
-    inline constexpr int numeric_limits<::ranges::detail::diffmax_t>::max_digits10;
-    inline constexpr int numeric_limits<::ranges::detail::diffmax_t>::radix;
-    inline constexpr int numeric_limits<::ranges::detail::diffmax_t>::min_exponent;
-    inline constexpr int numeric_limits<::ranges::detail::diffmax_t>::min_exponent10;
-    inline constexpr int numeric_limits<::ranges::detail::diffmax_t>::max_exponent;
-    inline constexpr int numeric_limits<::ranges::detail::diffmax_t>::max_exponent10;
-    inline constexpr bool numeric_limits<::ranges::detail::diffmax_t>::traps;
-    inline constexpr bool numeric_limits<::ranges::detail::diffmax_t>::tinyness_before;
-#endif
-} // namespace std
-/// \endcond
-
-RANGES_DIAGNOSTIC_POP
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/iterator/insert_iterators.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/iterator/insert_iterators.hpp
deleted file mode 100644
index 9942fd77..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/iterator/insert_iterators.hpp
+++ /dev/null
@@ -1,219 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ITERATOR_INSERT_ITERATORS_HPP
-#define RANGES_V3_ITERATOR_INSERT_ITERATORS_HPP
-
-#include <cstddef>
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/utility/addressof.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-iterator
-    /// @{
-    template<typename Container>
-    struct back_insert_iterator
-    {
-        using container_type = Container;
-        using difference_type = std::ptrdiff_t;
-
-        constexpr back_insert_iterator() = default;
-        constexpr explicit back_insert_iterator(Container & x)
-          : container_(detail::addressof(x))
-        {}
-        back_insert_iterator & operator=(typename Container::value_type const & value)
-        {
-            container_->push_back(value);
-            return *this;
-        }
-        back_insert_iterator & operator=(typename Container::value_type && value)
-        {
-            container_->push_back(std::move(value));
-            return *this;
-        }
-        back_insert_iterator & operator*()
-        {
-            return *this;
-        }
-        back_insert_iterator & operator++()
-        {
-            return *this;
-        }
-        back_insert_iterator operator++(int)
-        {
-            return *this;
-        }
-
-    private:
-        Container * container_ = nullptr;
-    };
-
-    struct back_inserter_fn
-    {
-        template<typename Container>
-        constexpr back_insert_iterator<Container> operator()(Container & x) const
-        {
-            return back_insert_iterator<Container>{x};
-        }
-    };
-
-    /// \sa `back_inserter_fn`
-    RANGES_INLINE_VARIABLE(back_inserter_fn, back_inserter)
-
-    template<typename Container>
-    struct front_insert_iterator
-    {
-        using container_type = Container;
-        using difference_type = std::ptrdiff_t;
-
-        constexpr front_insert_iterator() = default;
-        constexpr explicit front_insert_iterator(Container & x)
-          : container_(detail::addressof(x))
-        {}
-        front_insert_iterator & operator=(typename Container::value_type const & value)
-        {
-            container_->push_front(value);
-            return *this;
-        }
-        front_insert_iterator & operator=(typename Container::value_type && value)
-        {
-            container_->push_front(std::move(value));
-            return *this;
-        }
-        front_insert_iterator & operator*()
-        {
-            return *this;
-        }
-        front_insert_iterator & operator++()
-        {
-            return *this;
-        }
-        front_insert_iterator operator++(int)
-        {
-            return *this;
-        }
-
-    private:
-        Container * container_ = nullptr;
-    };
-
-    struct front_inserter_fn
-    {
-        template<typename Cont>
-        constexpr front_insert_iterator<Cont> operator()(Cont & cont) const
-        {
-            return front_insert_iterator<Cont>{cont};
-        }
-    };
-
-    /// \sa `front_inserter_fn`
-    RANGES_INLINE_VARIABLE(front_inserter_fn, front_inserter)
-
-    template<typename Container>
-    struct insert_iterator
-    {
-        using container_type = Container;
-        using difference_type = std::ptrdiff_t;
-
-        constexpr insert_iterator() = default;
-        constexpr explicit insert_iterator(Container & x, typename Container::iterator w)
-          : container_(detail::addressof(x))
-          , where_(w)
-        {}
-        insert_iterator & operator=(typename Container::value_type const & value)
-        {
-            where_ = ranges::next(container_->insert(where_, value));
-            return *this;
-        }
-        insert_iterator & operator=(typename Container::value_type && value)
-        {
-            where_ = ranges::next(container_->insert(where_, std::move(value)));
-            return *this;
-        }
-        insert_iterator & operator*()
-        {
-            return *this;
-        }
-        insert_iterator & operator++()
-        {
-            return *this;
-        }
-        insert_iterator & operator++(int)
-        {
-            return *this;
-        }
-
-    private:
-        Container * container_ = nullptr;
-        typename Container::iterator where_ = typename Container::iterator();
-    };
-
-    struct inserter_fn
-    {
-        template<typename Cont>
-        constexpr insert_iterator<Cont> operator()(Cont & cont,
-                                                   typename Cont::iterator where) const
-        {
-            return insert_iterator<Cont>{cont, std::move(where)};
-        }
-    };
-
-    /// \sa `inserter_fn`
-    RANGES_INLINE_VARIABLE(inserter_fn, inserter)
-
-    namespace cpp20
-    {
-        using ranges::back_insert_iterator;
-        using ranges::back_inserter;
-        using ranges::front_insert_iterator;
-        using ranges::front_inserter;
-        using ranges::insert_iterator;
-        using ranges::inserter;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-/// \cond
-RANGES_DIAGNOSTIC_PUSH
-RANGES_DIAGNOSTIC_IGNORE_MISMATCHED_TAGS
-
-namespace std
-{
-    template<typename Container>
-    struct iterator_traits<::ranges::back_insert_iterator<Container>>
-      : ::ranges::detail::std_output_iterator_traits<>
-    {};
-
-    template<typename Container>
-    struct iterator_traits<::ranges::front_insert_iterator<Container>>
-      : ::ranges::detail::std_output_iterator_traits<>
-    {};
-
-    template<typename Container>
-    struct iterator_traits<::ranges::insert_iterator<Container>>
-      : ::ranges::detail::std_output_iterator_traits<>
-    {};
-} // namespace std
-
-RANGES_DIAGNOSTIC_POP
-/// \endcond
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif // RANGES_V3_ITERATOR_INSERT_ITERATORS_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/iterator/move_iterators.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/iterator/move_iterators.hpp
deleted file mode 100644
index 0fedbf91..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/iterator/move_iterators.hpp
+++ /dev/null
@@ -1,489 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ITERATOR_MOVE_ITERATORS_HPP
-#define RANGES_V3_ITERATOR_MOVE_ITERATORS_HPP
-
-#include <cstddef>
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/basic_iterator.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-iterator
-    /// @{
-    template<typename I>
-    struct move_iterator
-    {
-    private:
-        CPP_assert(input_iterator<I>);
-        I current_ = I{};
-
-    public:
-        using iterator_type = I;
-        using difference_type = iter_difference_t<I>;
-        using value_type = iter_value_t<I>;
-        using iterator_category = std::input_iterator_tag;
-        using reference = iter_rvalue_reference_t<I>;
-
-        constexpr move_iterator() = default;
-        explicit move_iterator(I i)
-          : current_(i)
-        {}
-        template(typename O)(
-            /// \pre
-            requires convertible_to<O, I>)
-        move_iterator(move_iterator<O> const & i)
-          : current_(i.base())
-        {}
-        template(typename O)(
-            /// \pre
-            requires convertible_to<O, I>)
-        move_iterator & operator=(move_iterator<O> const & i)
-        {
-            current_ = i.base();
-            return *this;
-        }
-        I base() const
-        {
-            return current_;
-        }
-        // clang-format off
-        auto CPP_auto_fun(operator*)()(const)
-        (
-            return iter_move(current_)
-        )
-            // clang-format on
-            move_iterator &
-            operator++()
-        {
-            ++current_;
-            return *this;
-        }
-        CPP_member
-        auto operator++(int) //
-            -> CPP_ret(void)(
-                /// \pre
-                requires (!forward_iterator<I>))
-        {
-            ++current_;
-        }
-        CPP_member
-        auto operator++(int) //
-            -> CPP_ret(move_iterator)(
-                /// \pre
-                requires forward_iterator<I>)
-        {
-            return move_iterator(current_++);
-        }
-        CPP_member
-        auto operator--() //
-            -> CPP_ret(move_iterator &)(
-                /// \pre
-                requires forward_iterator<I>)
-        {
-            --current_;
-            return *this;
-        }
-        CPP_member
-        auto operator--(int) //
-            -> CPP_ret(move_iterator)(
-                /// \pre
-                requires bidirectional_iterator<I>)
-        {
-            return move_iterator(current_--);
-        }
-        CPP_member
-        auto operator+(difference_type n) const //
-            -> CPP_ret(move_iterator)(
-                /// \pre
-                requires random_access_iterator<I>)
-        {
-            return move_iterator(current_ + n);
-        }
-        CPP_member
-        auto operator+=(difference_type n)
-            -> CPP_ret(move_iterator &)(
-                /// \pre
-                requires random_access_iterator<I>)
-        {
-            current_ += n;
-            return *this;
-        }
-        CPP_member
-        auto operator-(difference_type n) const //
-            -> CPP_ret(move_iterator)(
-                /// \pre
-                requires random_access_iterator<I>)
-        {
-            return move_iterator(current_ - n);
-        }
-        CPP_member
-        auto operator-=(difference_type n) //
-            -> CPP_ret(move_iterator &)(
-                /// \pre
-                requires random_access_iterator<I>)
-        {
-            current_ -= n;
-            return *this;
-        }
-        CPP_member
-        auto operator[](difference_type n) const //
-            -> CPP_ret(reference)(
-                /// \pre
-                requires random_access_iterator<I>)
-        {
-            return iter_move(current_ + n);
-        }
-
-        template<typename I2>
-        friend auto operator==(move_iterator const & x, move_iterator<I2> const & y)
-            -> CPP_broken_friend_ret(bool)(
-                /// \pre
-                requires equality_comparable_with<I, I2>)
-        {
-            return x.base() == y.base();
-        }
-        template<typename I2>
-        friend auto operator!=(move_iterator const & x, move_iterator<I2> const & y)
-            -> CPP_broken_friend_ret(bool)(
-                /// \pre
-                requires equality_comparable_with<I, I2>)
-        {
-            return !(x == y);
-        }
-        template<typename I2>
-        friend auto operator<(move_iterator const & x, move_iterator<I2> const & y)
-            -> CPP_broken_friend_ret(bool)(
-                /// \pre
-                requires totally_ordered_with<I, I2>)
-        {
-            return x.base() < y.base();
-        }
-        template<typename I2>
-        friend auto operator<=(move_iterator const & x, move_iterator<I2> const & y)
-            -> CPP_broken_friend_ret(bool)(
-                /// \pre
-                requires totally_ordered_with<I, I2>)
-        {
-            return !(y < x);
-        }
-        template<typename I2>
-        friend auto operator>(move_iterator const & x, move_iterator<I2> const & y)
-            -> CPP_broken_friend_ret(bool)(
-                /// \pre
-                requires totally_ordered_with<I, I2>)
-        {
-            return y < x;
-        }
-        template<typename I2>
-        friend auto operator>=(move_iterator const & x, move_iterator<I2> const & y)
-            -> CPP_broken_friend_ret(bool)(
-                /// \pre
-                requires totally_ordered_with<I, I2>)
-        {
-            return !(x < y);
-        }
-
-        template<typename I2>
-        friend auto operator-(move_iterator const & x, move_iterator<I2> const & y)
-            -> CPP_broken_friend_ret(iter_difference_t<I2>)(
-                /// \pre
-                requires sized_sentinel_for<I, I2>)
-        {
-            return x.base() - y.base();
-        }
-        CPP_broken_friend_member
-        friend auto operator+(iter_difference_t<I> n,
-                              move_iterator const & x)
-            -> CPP_broken_friend_ret(move_iterator)(
-                /// \pre
-                requires random_access_iterator<I>)
-        {
-            return x + n;
-        }
-    };
-
-    struct make_move_iterator_fn
-    {
-        template(typename I)(
-            /// \pre
-            requires input_iterator<I>)
-        constexpr move_iterator<I> operator()(I it) const
-        {
-            return move_iterator<I>{detail::move(it)};
-        }
-    };
-
-    RANGES_INLINE_VARIABLE(make_move_iterator_fn, make_move_iterator)
-
-    template<typename S>
-    struct move_sentinel
-    {
-    private:
-        S sent_;
-
-    public:
-        constexpr move_sentinel()
-          : sent_{}
-        {}
-        constexpr explicit move_sentinel(S s)
-          : sent_(detail::move(s))
-        {}
-        template(typename OS)(
-            /// \pre
-            requires convertible_to<OS, S>)
-        constexpr explicit move_sentinel(move_sentinel<OS> const & that)
-          : sent_(that.base())
-        {}
-        template(typename OS)(
-            /// \pre
-            requires convertible_to<OS, S>)
-        move_sentinel & operator=(move_sentinel<OS> const & that)
-        {
-            sent_ = that.base();
-            return *this;
-        }
-        S base() const
-        {
-            return sent_;
-        }
-
-        template<typename I>
-        friend auto operator==(move_iterator<I> const & i, move_sentinel const & s)
-            -> CPP_broken_friend_ret(bool)(
-                /// \pre
-                requires sentinel_for<S, I>)
-        {
-            return i.base() == s.base();
-        }
-        template<typename I>
-        friend auto operator==(move_sentinel const & s, move_iterator<I> const & i)
-            -> CPP_broken_friend_ret(bool)(
-                /// \pre
-                requires sentinel_for<S, I>)
-        {
-            return s.base() == i.base();
-        }
-        template<typename I>
-        friend auto operator!=(move_iterator<I> const & i, move_sentinel const & s)
-            -> CPP_broken_friend_ret(bool)(
-                /// \pre
-                requires sentinel_for<S, I>)
-        {
-            return i.base() != s.base();
-        }
-        template<typename I>
-        friend auto operator!=(move_sentinel const & s, move_iterator<I> const & i)
-            -> CPP_broken_friend_ret(bool)(
-                /// \pre
-                requires sentinel_for<S, I>)
-        {
-            return s.base() != i.base();
-        }
-    };
-
-    struct make_move_sentinel_fn
-    {
-        template(typename I)(
-            /// \pre
-            requires input_iterator<I>)
-        constexpr move_iterator<I> operator()(I i) const
-        {
-            return move_iterator<I>{detail::move(i)};
-        }
-
-        template(typename S)(
-            /// \pre
-            requires semiregular<S> AND (!input_iterator<S>)) //
-        constexpr move_sentinel<S> operator()(S s) const
-        {
-            return move_sentinel<S>{detail::move(s)};
-        }
-    };
-
-    RANGES_INLINE_VARIABLE(make_move_sentinel_fn, make_move_sentinel)
-
-    /// \cond
-    namespace detail
-    {
-        template<typename I, bool IsReadable>
-        struct move_into_cursor_types_
-        {};
-
-        template<typename I>
-        struct move_into_cursor_types_<I, true>
-        {
-            using value_type = iter_value_t<I>;
-            using single_pass = meta::bool_<(bool)single_pass_iterator_<I>>;
-        };
-
-        template<typename I>
-        using move_into_cursor_types =
-            move_into_cursor_types_<I, (bool)indirectly_readable<I>>;
-
-        template<typename I>
-        struct move_into_cursor : move_into_cursor_types<I>
-        {
-        private:
-            friend range_access;
-            struct mixin : basic_mixin<move_into_cursor>
-            {
-                mixin() = default;
-                #ifndef _MSC_VER
-                using basic_mixin<move_into_cursor>::basic_mixin;
-                #else
-                constexpr explicit mixin(move_into_cursor && cur)
-                  : basic_mixin<move_into_cursor>(static_cast<move_into_cursor &&>(cur))
-                {}
-                constexpr explicit mixin(move_into_cursor const & cur)
-                  : basic_mixin<move_into_cursor>(cur)
-                {}
-                #endif
-                explicit mixin(I it)
-                  : mixin{move_into_cursor{std::move(it)}}
-                {}
-                I base() const
-                {
-                    return this->get().it_;
-                }
-            };
-
-            I it_ = I();
-
-            explicit move_into_cursor(I it)
-              : it_(std::move(it))
-            {}
-            void next()
-            {
-                ++it_;
-            }
-            template(typename T)(
-                /// \pre
-                requires indirectly_writable<I, aux::move_t<T>>)
-            void write(T && t) noexcept(noexcept(*it_ = std::move(t)))
-            {
-                *it_ = std::move(t);
-            }
-            template(typename T)(
-                /// \pre
-                requires indirectly_writable<I, aux::move_t<T>>)
-            void write(T && t) const noexcept(noexcept(*it_ = std::move(t)))
-            {
-                *it_ = std::move(t);
-            }
-            CPP_member
-            auto read() const noexcept(noexcept(*std::declval<I const &>()))
-                -> CPP_ret(iter_reference_t<I>)(
-                    /// \pre
-                    requires indirectly_readable<I>)
-            {
-                return *it_;
-            }
-            CPP_member
-            auto equal(move_into_cursor const & that) const //
-                -> CPP_ret(bool)(
-                    /// \pre
-                    requires input_iterator<I>)
-            {
-                return it_ == that.it_;
-            }
-            CPP_member
-            auto prev() //
-                -> CPP_ret(void)(
-                    /// \pre
-                    requires bidirectional_iterator<I>)
-            {
-                --it_;
-            }
-            CPP_member
-            auto advance(iter_difference_t<I> n) //
-                -> CPP_ret(void)(
-                    /// \pre
-                    requires random_access_iterator<I>)
-            {
-                it_ += n;
-            }
-            CPP_member
-            auto distance_to(move_into_cursor const & that) const //
-                -> CPP_ret(iter_difference_t<I>)(
-                    /// \pre
-                    requires sized_sentinel_for<I, I>)
-            {
-                return that.it_ - it_;
-            }
-            template(typename II = I const)(
-                /// \pre
-                requires same_as<I const, II> AND indirectly_readable<II>)
-            constexpr iter_rvalue_reference_t<II> move() const //
-                noexcept(has_nothrow_iter_move_v<II>)
-            {
-                return iter_move(it_);
-            }
-
-        public:
-            constexpr move_into_cursor() = default;
-        };
-    } // namespace detail
-    /// \endcond
-
-    struct move_into_fn
-    {
-        template<typename I>
-        constexpr move_into_iterator<I> operator()(I it) const
-        {
-            return move_into_iterator<I>{std::move(it)};
-        }
-    };
-
-    /// \sa `move_into_fn`
-    RANGES_INLINE_VARIABLE(move_into_fn, move_into)
-
-    namespace cpp20
-    {
-        using ranges::make_move_iterator;
-        using ranges::move_iterator;
-        using ranges::move_sentinel;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-/// \cond
-RANGES_DIAGNOSTIC_PUSH
-RANGES_DIAGNOSTIC_IGNORE_MISMATCHED_TAGS
-
-namespace std
-{
-    template<typename I>
-    struct iterator_traits<::ranges::move_iterator<I>>
-    {
-        using iterator_category = std::input_iterator_tag;
-        using difference_type = typename ::ranges::move_iterator<I>::difference_type;
-        using value_type = typename ::ranges::move_iterator<I>::value_type;
-        using reference = typename ::ranges::move_iterator<I>::reference;
-        using pointer = meta::_t<std::add_pointer<reference>>;
-    };
-} // namespace std
-
-RANGES_DIAGNOSTIC_POP
-/// \endcond
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif // RANGES_V3_ITERATOR_MOVE_ITERATORS_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/iterator/operations.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/iterator/operations.hpp
deleted file mode 100644
index 8ef8691f..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/iterator/operations.hpp
+++ /dev/null
@@ -1,674 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ITERATOR_OPERATIONS_HPP
-#define RANGES_V3_ITERATOR_OPERATIONS_HPP
-
-#include <type_traits>
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/concepts.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-iterator
-    /// @{
-
-    /// \cond
-    template<typename I>
-        // requires input_or_output_iterator<I>
-    struct counted_iterator;
-    /// \endcond
-
-    struct advance_fn
-    {
-#if RANGES_CXX_IF_CONSTEXPR >= RANGES_CXX_IF_CONSTEXPR_17
-        template(typename I)(
-            /// \pre
-            requires input_or_output_iterator<I>)
-        constexpr void operator()(I & i, iter_difference_t<I> n) const
-        // [[expects: n >= 0 || bidirectional_iterator<I>]]
-        {
-            if constexpr(random_access_iterator<I>)
-            {
-                i += n;
-            }
-            else
-            {
-                if constexpr(bidirectional_iterator<I>)
-                    for(; 0 > n; ++n)
-                        --i;
-                RANGES_EXPECT(0 <= n);
-                for(; 0 < n; --n)
-                    ++i;
-            }
-        }
-
-        template(typename I, typename S)(
-            /// \pre
-            requires sentinel_for<S, I>)
-        constexpr void operator()(I & i, S bound) const
-        // [[expects axiom: reachable(i, bound)]]
-        {
-            if constexpr(assignable_from<I &, S>)
-            {
-                i = std::move(bound);
-            }
-            else if constexpr(sized_sentinel_for<S, I>)
-            {
-                iter_difference_t<I> d = bound - i;
-                RANGES_EXPECT(0 <= d);
-                (*this)(i, d);
-            }
-            else
-                while(i != bound)
-                    ++i;
-        }
-
-        template(typename I, typename S)(
-            /// \pre
-            requires sentinel_for<S, I>)
-        constexpr iter_difference_t<I> //
-        operator()(I & i, iter_difference_t<I> n, S bound) const
-        // [[expects axiom: 0 == n ||
-        //     (0 < n && reachable(i, bound)) ||
-        //     (0 > n && same_as<I, S> && bidirectional_iterator<I> && reachable(bound,
-        //     i))]]
-        {
-            if constexpr(sized_sentinel_for<S, I>)
-            {
-                if(0 == n)
-                    return 0;
-                const auto d = bound - i;
-                if constexpr(bidirectional_iterator<I> && same_as<I, S>)
-                {
-                    RANGES_EXPECT(0 <= n ? 0 <= d : 0 >= d);
-                    if(0 <= n ? d <= n : d >= n)
-                    {
-                        i = std::move(bound);
-                        return n - d;
-                    }
-                }
-                else
-                {
-                    RANGES_EXPECT(0 <= n && 0 <= d);
-                    if(d <= n)
-                    {
-                        (*this)(i, std::move(bound));
-                        return n - d;
-                    }
-                }
-                (*this)(i, n);
-                return 0;
-            }
-            else
-            {
-                if constexpr(bidirectional_iterator<I> && same_as<I, S>)
-                {
-                    if(0 > n)
-                    {
-                        do
-                        {
-                            --i;
-                            ++n;
-                        } while(0 != n && i != bound);
-                        return n;
-                    }
-                }
-                RANGES_EXPECT(0 <= n);
-                while(0 != n && i != bound)
-                {
-                    ++i;
-                    --n;
-                }
-                return n;
-            }
-        }
-#else
-    private:
-        template<typename I>
-        static constexpr void n_(I & i, iter_difference_t<I> n, std::input_iterator_tag);
-        template<typename I>
-        static constexpr void n_(I & i, iter_difference_t<I> n,
-                                 std::bidirectional_iterator_tag);
-        template<typename I>
-        static constexpr void n_(I & i, iter_difference_t<I> n,
-                                 std::random_access_iterator_tag);
-        template<typename I, typename S>
-        static constexpr void to_impl_(I & i, S s, sentinel_tag);
-        template<typename I, typename S>
-        static constexpr void to_impl_(I & i, S s, sized_sentinel_tag);
-        template<typename I, typename S>
-        static constexpr void to_(I & i, S s, std::true_type); // assignable
-        template<typename I, typename S>
-        static constexpr void to_(I & i, S s, std::false_type); // !assignable
-        template<typename I, typename S>
-        static constexpr iter_difference_t<I> bounded_(I & it, iter_difference_t<I> n,
-                                                       S bound, sentinel_tag,
-                                                       std::input_iterator_tag);
-        template<typename I>
-        static constexpr iter_difference_t<I> bounded_(I & it, iter_difference_t<I> n,
-                                                       I bound, sentinel_tag,
-                                                       std::bidirectional_iterator_tag);
-        template<typename I, typename S, typename Concept>
-        static constexpr iter_difference_t<I> bounded_(I & it, iter_difference_t<I> n,
-                                                       S bound, sized_sentinel_tag,
-                                                       Concept);
-
-    public:
-        // Advance a certain number of steps:
-        template(typename I)(
-            /// \pre
-            requires input_or_output_iterator<I>)
-        constexpr void operator()(I & i, iter_difference_t<I> n) const
-        {
-            advance_fn::n_(i, n, iterator_tag_of<I>{});
-        }
-        // Advance to a certain position:
-        template(typename I, typename S)(
-            /// \pre
-            requires sentinel_for<S, I>)
-        constexpr void operator()(I & i, S s) const
-        {
-            advance_fn::to_(
-                i, static_cast<S &&>(s), meta::bool_<assignable_from<I &, S>>());
-        }
-        // Advance a certain number of times, with a bound:
-        template(typename I, typename S)(
-            /// \pre
-            requires sentinel_for<S, I>)
-        constexpr iter_difference_t<I> //
-        operator()(I & it, iter_difference_t<I> n, S bound) const
-        {
-            return advance_fn::bounded_(it,
-                                        n,
-                                        static_cast<S &&>(bound),
-                                        sentinel_tag_of<S, I>(),
-                                        iterator_tag_of<I>());
-        }
-#endif
-
-        template(typename I)(
-            /// \pre
-            requires input_or_output_iterator<I>)
-        constexpr void operator()(counted_iterator<I> & i, iter_difference_t<I> n) const;
-    };
-
-    /// \sa `advance_fn`
-    RANGES_INLINE_VARIABLE(advance_fn, advance)
-
-#if RANGES_CXX_IF_CONSTEXPR < RANGES_CXX_IF_CONSTEXPR_17
-    template<typename I>
-    constexpr void advance_fn::n_(I & i, iter_difference_t<I> n, std::input_iterator_tag)
-    {
-        RANGES_EXPECT(n >= 0);
-        for(; n > 0; --n)
-            ++i;
-    }
-    template<typename I>
-    constexpr void advance_fn::n_(I & i, iter_difference_t<I> n,
-                                  std::bidirectional_iterator_tag)
-    {
-        if(n > 0)
-            for(; n > 0; --n)
-                ++i;
-        else
-            for(; n < 0; ++n)
-                --i;
-    }
-    template<typename I>
-    constexpr void advance_fn::n_(I & i, iter_difference_t<I> n,
-                                  std::random_access_iterator_tag)
-    {
-        i += n;
-    }
-    template<typename I, typename S>
-    constexpr void advance_fn::to_impl_(I & i, S s, sentinel_tag)
-    {
-        while(i != s)
-            ++i;
-    }
-    template<typename I, typename S>
-    constexpr void advance_fn::to_impl_(I & i, S s, sized_sentinel_tag)
-    {
-        iter_difference_t<I> d = s - i;
-        RANGES_EXPECT(0 <= d);
-        advance(i, d);
-    }
-    // Advance to a certain position:
-    template<typename I, typename S>
-    constexpr void advance_fn::to_(I & i, S s, std::true_type)
-    {
-        i = static_cast<S &&>(s);
-    }
-    template<typename I, typename S>
-    constexpr void advance_fn::to_(I & i, S s, std::false_type)
-    {
-        advance_fn::to_impl_(i, static_cast<S &&>(s), sentinel_tag_of<S, I>());
-    }
-    template<typename I, typename S>
-    constexpr iter_difference_t<I> advance_fn::bounded_(I & it, iter_difference_t<I> n,
-                                                        S bound, sentinel_tag,
-                                                        std::input_iterator_tag)
-    {
-        RANGES_EXPECT(0 <= n);
-        for(; 0 != n && it != bound; --n)
-            ++it;
-        return n;
-    }
-    template<typename I>
-    constexpr iter_difference_t<I> advance_fn::bounded_(I & it, iter_difference_t<I> n,
-                                                        I bound, sentinel_tag,
-                                                        std::bidirectional_iterator_tag)
-    {
-        if(0 <= n)
-            for(; 0 != n && it != bound; --n)
-                ++it;
-        else
-            for(; 0 != n && it != bound; ++n)
-                --it;
-        return n;
-    }
-    template<typename I, typename S, typename Concept>
-    constexpr iter_difference_t<I> advance_fn::bounded_(I & it, iter_difference_t<I> n,
-                                                        S bound, sized_sentinel_tag,
-                                                        Concept)
-    {
-        RANGES_EXPECT(((bool)same_as<I, S> || 0 <= n));
-        if(n == 0)
-            return 0;
-        iter_difference_t<I> d = bound - it;
-        RANGES_EXPECT(0 <= n ? 0 <= d : 0 >= d);
-        if(0 <= n ? n >= d : n <= d)
-        {
-            advance(it, static_cast<S &&>(bound));
-            return n - d;
-        }
-        advance(it, n);
-        return 0;
-    }
-#endif
-
-    struct next_fn
-    {
-        template(typename I)(
-            /// \pre
-            requires input_or_output_iterator<I>)
-        constexpr I operator()(I it) const
-        {
-            return ++it;
-        }
-        template(typename I)(
-            /// \pre
-            requires input_or_output_iterator<I>)
-        constexpr I operator()(I it, iter_difference_t<I> n) const
-        {
-            advance(it, n);
-            return it;
-        }
-        template(typename I, typename S)(
-            /// \pre
-            requires sentinel_for<S, I>)
-        constexpr I operator()(I it, S s) const
-        {
-            advance(it, static_cast<S &&>(s));
-            return it;
-        }
-        template(typename I, typename S)(
-            /// \pre
-            requires sentinel_for<S, I>)
-        constexpr I operator()(I it, iter_difference_t<I> n, S bound) const
-        {
-            advance(it, n, static_cast<S &&>(bound));
-            return it;
-        }
-    };
-
-    /// \sa `next_fn`
-    RANGES_INLINE_VARIABLE(next_fn, next)
-
-    struct prev_fn
-    {
-        template(typename I)(
-            /// \pre
-            requires bidirectional_iterator<I>)
-        constexpr I operator()(I it) const
-        {
-            return --it;
-        }
-        template(typename I)(
-            /// \pre
-            requires bidirectional_iterator<I>)
-        constexpr I operator()(I it, iter_difference_t<I> n) const
-        {
-            advance(it, -n);
-            return it;
-        }
-        template(typename I)(
-            /// \pre
-            requires bidirectional_iterator<I>)
-        constexpr I operator()(I it, iter_difference_t<I> n, I bound) const
-        {
-            advance(it, -n, static_cast<I &&>(bound));
-            return it;
-        }
-    };
-
-    /// \sa `prev_fn`
-    RANGES_INLINE_VARIABLE(prev_fn, prev)
-
-    struct iter_enumerate_fn
-    {
-    private:
-        template(typename I, typename S)(
-            /// \pre
-            requires (!sized_sentinel_for<I, I>)) //
-        static constexpr std::pair<iter_difference_t<I>, I> //
-        impl_i(I first, S last, sentinel_tag)
-        {
-            iter_difference_t<I> d = 0;
-            for(; first != last; ++first)
-                ++d;
-            return {d, first};
-        }
-        template(typename I, typename S)(
-            /// \pre
-            requires sized_sentinel_for<I, I>)
-        static constexpr std::pair<iter_difference_t<I>, I> //
-        impl_i(I first, S end_, sentinel_tag)
-        {
-            I last = ranges::next(first, end_);
-            auto n = static_cast<iter_difference_t<I>>(last - first);
-            RANGES_EXPECT(((bool)same_as<I, S> || 0 <= n));
-            return {n, last};
-        }
-        template<typename I, typename S>
-        static constexpr std::pair<iter_difference_t<I>, I> //
-        impl_i(I first, S last, sized_sentinel_tag)
-        {
-            auto n = static_cast<iter_difference_t<I>>(last - first);
-            RANGES_EXPECT(((bool)same_as<I, S> || 0 <= n));
-            return {n, ranges::next(first, last)};
-        }
-
-    public:
-        template(typename I, typename S)(
-            /// \pre
-            requires sentinel_for<S, I>)
-        constexpr std::pair<iter_difference_t<I>, I> operator()(I first, S last) const
-        {
-            return iter_enumerate_fn::impl_i(static_cast<I &&>(first),
-                                             static_cast<S &&>(last),
-                                             sentinel_tag_of<S, I>());
-        }
-    };
-
-    /// \sa `iter_enumerate_fn`
-    RANGES_INLINE_VARIABLE(iter_enumerate_fn, iter_enumerate)
-
-    struct iter_distance_fn
-    {
-    private:
-        template<typename I, typename S>
-        static constexpr iter_difference_t<I> impl_i(I first, S last, sentinel_tag)
-        {
-            return iter_enumerate(static_cast<I &&>(first), static_cast<S &&>(last))
-                .first;
-        }
-        template<typename I, typename S>
-        static constexpr iter_difference_t<I> impl_i(I first, S last, sized_sentinel_tag)
-        {
-            auto n = static_cast<iter_difference_t<I>>(last - first);
-            RANGES_EXPECT(((bool)same_as<I, S> || 0 <= n));
-            return n;
-        }
-
-    public:
-        template(typename I, typename S)(
-            /// \pre
-            requires input_or_output_iterator<I> AND sentinel_for<S, I>)
-        constexpr iter_difference_t<I> operator()(I first, S last) const
-        {
-            return iter_distance_fn::impl_i(static_cast<I &&>(first),
-                                            static_cast<S &&>(last),
-                                            sentinel_tag_of<S, I>());
-        }
-    };
-
-    /// \sa `iter_distance_fn`
-    RANGES_INLINE_VARIABLE(iter_distance_fn, iter_distance)
-
-    struct iter_distance_compare_fn
-    {
-    private:
-        template<typename I, typename S>
-        static constexpr int impl_i(I first, S last, iter_difference_t<I> n, sentinel_tag)
-        {
-            if(n < 0)
-                return 1;
-            for(; n > 0; --n, ++first)
-            {
-                if(first == last)
-                    return -1;
-            }
-            return first == last ? 0 : 1;
-        }
-        template<typename I, typename S>
-        static constexpr int impl_i(I first, S last, iter_difference_t<I> n,
-                                    sized_sentinel_tag)
-        {
-            iter_difference_t<I> dist = last - first;
-            if(n < dist)
-                return 1;
-            if(dist < n)
-                return -1;
-            return 0;
-        }
-
-    public:
-        template(typename I, typename S)(
-            /// \pre
-            requires input_iterator<I> AND sentinel_for<S, I>)
-        constexpr int operator()(I first, S last, iter_difference_t<I> n) const
-        {
-            return iter_distance_compare_fn::impl_i(static_cast<I &&>(first),
-                                                    static_cast<S &&>(last),
-                                                    n,
-                                                    sentinel_tag_of<S, I>());
-        }
-    };
-
-    /// \sa `iter_distance_compare_fn`
-    RANGES_INLINE_VARIABLE(iter_distance_compare_fn, iter_distance_compare)
-
-    // Like distance(b,e), but guaranteed to be O(1)
-    struct iter_size_fn
-    {
-        template(typename I, typename S)(
-            /// \pre
-            requires sized_sentinel_for<S, I>)
-        constexpr meta::_t<std::make_unsigned<iter_difference_t<I>>> //
-        operator()(I const & first, S last) const
-        {
-            using size_type = meta::_t<std::make_unsigned<iter_difference_t<I>>>;
-            iter_difference_t<I> n = last - first;
-            RANGES_EXPECT(0 <= n);
-            return static_cast<size_type>(n);
-        }
-    };
-
-    /// \sa `iter_size_fn`
-    RANGES_INLINE_VARIABLE(iter_size_fn, iter_size)
-
-    /// \cond
-    namespace adl_uncounted_recounted_detail
-    {
-        template<typename I>
-        constexpr I uncounted(I i)
-        {
-            return i;
-        }
-
-        template<typename I>
-        constexpr I recounted(I const &, I i, iter_difference_t<I>)
-        {
-            return i;
-        }
-
-        struct uncounted_fn
-        {
-            template<typename I>
-            constexpr auto operator()(I i) const -> decltype(uncounted((I &&) i))
-            {
-                return uncounted((I &&) i);
-            }
-        };
-
-        struct recounted_fn
-        {
-            template<typename I, typename J>
-            constexpr auto operator()(I i, J j, iter_difference_t<J> n) const
-                -> decltype(recounted((I &&) i, (J &&) j, n))
-            {
-                return recounted((I &&) i, (J &&) j, n);
-            }
-        };
-    } // namespace adl_uncounted_recounted_detail
-    /// \endcond
-
-    RANGES_INLINE_VARIABLE(adl_uncounted_recounted_detail::uncounted_fn, uncounted)
-    RANGES_INLINE_VARIABLE(adl_uncounted_recounted_detail::recounted_fn, recounted)
-
-    struct enumerate_fn : iter_enumerate_fn
-    {
-    private:
-        template<typename Rng>
-        static std::pair<range_difference_t<Rng>, iterator_t<Rng>> impl_r(Rng & rng,
-                                                                          range_tag,
-                                                                          range_tag)
-        {
-            return iter_enumerate(begin(rng), end(rng));
-        }
-        template<typename Rng>
-        static std::pair<range_difference_t<Rng>, iterator_t<Rng>> impl_r(
-            Rng & rng, common_range_tag, sized_range_tag)
-        {
-            return {static_cast<range_difference_t<Rng>>(size(rng)), end(rng)};
-        }
-
-    public:
-        using iter_enumerate_fn::operator();
-
-        template(typename Rng)(
-            /// \pre
-            requires range<Rng>)
-        std::pair<range_difference_t<Rng>, iterator_t<Rng>> operator()(Rng && rng) const
-        {
-            // Better not be trying to compute the distance of an infinite range:
-            RANGES_EXPECT(!is_infinite<Rng>::value);
-            return enumerate_fn::impl_r(
-                rng, common_range_tag_of<Rng>(), sized_range_tag_of<Rng>());
-        }
-    };
-
-    /// \sa `enumerate_fn`
-    RANGES_INLINE_VARIABLE(enumerate_fn, enumerate)
-
-    struct distance_fn : iter_distance_fn
-    {
-    private:
-        template<typename Rng>
-        static range_difference_t<Rng> impl_r(Rng & rng, range_tag)
-        {
-            return enumerate(rng).first;
-        }
-        template<typename Rng>
-        static constexpr range_difference_t<Rng> impl_r(Rng & rng, sized_range_tag)
-        {
-            return static_cast<range_difference_t<Rng>>(size(rng));
-        }
-
-    public:
-        using iter_distance_fn::operator();
-
-        template(typename Rng)(
-            /// \pre
-            requires range<Rng>)
-        constexpr range_difference_t<Rng> operator()(Rng && rng) const
-        {
-            // Better not be trying to compute the distance of an infinite range:
-            RANGES_EXPECT(!is_infinite<Rng>::value);
-            return distance_fn::impl_r(rng, sized_range_tag_of<Rng>());
-        }
-    };
-
-    /// \sa `distance_fn`
-    RANGES_INLINE_VARIABLE(distance_fn, distance)
-
-    // The interface of distance_compare is taken from Util.listLengthCmp in the GHC API.
-    struct distance_compare_fn : iter_distance_compare_fn
-    {
-    private:
-        template<typename Rng>
-        static int impl_r(Rng & rng, range_difference_t<Rng> n, range_tag)
-        {
-            // Infinite ranges are always compared to be larger than a finite number.
-            return is_infinite<Rng>::value
-                       ? 1
-                       : iter_distance_compare(begin(rng), end(rng), n);
-        }
-        template<typename Rng>
-        static int impl_r(Rng & rng, range_difference_t<Rng> n, sized_range_tag)
-        {
-            auto dist = distance(rng); // O(1) since rng is a sized_range
-            if(dist > n)
-                return 1;
-            else if(dist < n)
-                return -1;
-            else
-                return 0;
-        }
-
-    public:
-        using iter_distance_compare_fn::operator();
-
-        template(typename Rng)(
-            /// \pre
-            requires range<Rng>)
-        int operator()(Rng && rng, range_difference_t<Rng> n) const
-        {
-            return distance_compare_fn::impl_r(rng, n, sized_range_tag_of<Rng>());
-        }
-    };
-
-    /// \sa `distance_compare_fn`
-    RANGES_INLINE_VARIABLE(distance_compare_fn, distance_compare)
-
-    namespace cpp20
-    {
-        using ranges::advance;
-        using ranges::distance;
-        using ranges::next;
-        using ranges::prev;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif // RANGES_V3_ITERATOR_OPERATIONS_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/iterator/reverse_iterator.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/iterator/reverse_iterator.hpp
deleted file mode 100644
index 5dda1efb..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/iterator/reverse_iterator.hpp
+++ /dev/null
@@ -1,157 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ITERATOR_REVERSE_ITERATOR_HPP
-#define RANGES_V3_ITERATOR_REVERSE_ITERATOR_HPP
-
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/basic_iterator.hpp>
-#include <range/v3/iterator/concepts.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-iterator
-    /// @{
-
-    /// \cond
-    namespace detail
-    {
-        template<typename I>
-        struct reverse_cursor
-        {
-        private:
-            CPP_assert(bidirectional_iterator<I>);
-            friend range_access;
-            template<typename OtherI>
-            friend struct reverse_cursor;
-            struct mixin : basic_mixin<reverse_cursor>
-            {
-                mixin() = default;
-                #ifndef _MSC_VER
-                using basic_mixin<reverse_cursor>::basic_mixin;
-                #else
-                constexpr explicit mixin(reverse_cursor && cur)
-                  : basic_mixin<reverse_cursor>(static_cast<reverse_cursor &&>(cur))
-                {}
-                constexpr explicit mixin(reverse_cursor const & cur)
-                  : basic_mixin<reverse_cursor>(cur)
-                {}
-                #endif
-                constexpr mixin(I it)
-                  : mixin{reverse_cursor{it}}
-                {}
-                constexpr I base() const
-                {
-                    return this->get().base();
-                }
-            };
-
-            I it_;
-
-            constexpr reverse_cursor(I it)
-              : it_(std::move(it))
-            {}
-            constexpr iter_reference_t<I> read() const
-            {
-                return *arrow();
-            }
-            constexpr I arrow() const
-            {
-                auto tmp = it_;
-                --tmp;
-                return tmp;
-            }
-            constexpr I base() const
-            {
-                return it_;
-            }
-            template(typename J)(
-                /// \pre
-                requires sentinel_for<J, I>)
-            constexpr bool equal(reverse_cursor<J> const & that) const
-            {
-                return it_ == that.it_;
-            }
-            constexpr void next()
-            {
-                --it_;
-            }
-            constexpr void prev()
-            {
-                ++it_;
-            }
-            CPP_member
-            constexpr auto advance(iter_difference_t<I> n) //
-                -> CPP_ret(void)(
-                    /// \pre
-                    requires random_access_iterator<I>)
-            {
-                it_ -= n;
-            }
-            template(typename J)(
-                /// \pre
-                requires sized_sentinel_for<J, I>)
-            constexpr iter_difference_t<I> distance_to(reverse_cursor<J> const & that) //
-                const
-            {
-                return it_ - that.base();
-            }
-            constexpr iter_rvalue_reference_t<I> move() const
-                noexcept(noexcept((void)I(I(it_)), (void)--const_cast<I &>(it_),
-                                  iter_move(it_)))
-            {
-                auto tmp = it_;
-                --tmp;
-                return iter_move(tmp);
-            }
-
-        public:
-            reverse_cursor() = default;
-            template(typename U)(
-                /// \pre
-                requires convertible_to<U, I>)
-            constexpr reverse_cursor(reverse_cursor<U> const & u)
-              : it_(u.base())
-            {}
-        };
-    } // namespace detail
-    /// \endcond
-
-    struct make_reverse_iterator_fn
-    {
-        template(typename I)(
-            /// \pre
-            requires bidirectional_iterator<I>)
-        constexpr reverse_iterator<I> operator()(I i) const
-        {
-            return reverse_iterator<I>(i);
-        }
-    };
-
-    RANGES_INLINE_VARIABLE(make_reverse_iterator_fn, make_reverse_iterator)
-
-    namespace cpp20
-    {
-        using ranges::make_reverse_iterator;
-        using ranges::reverse_iterator;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif // RANGES_V3_ITERATOR_REVERSE_ITERATOR_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/iterator/stream_iterators.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/iterator/stream_iterators.hpp
deleted file mode 100644
index f4f15db6..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/iterator/stream_iterators.hpp
+++ /dev/null
@@ -1,227 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ITERATOR_STREAM_ITERATORS_HPP
-#define RANGES_V3_ITERATOR_STREAM_ITERATORS_HPP
-
-#include <cstddef>
-#include <iosfwd>
-#include <iterator>
-#include <string>
-#include <type_traits>
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/concepts.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-iterator
-    /// @{
-    template<typename T = void, typename Char = char,
-             typename Traits = std::char_traits<Char>>
-    struct ostream_iterator
-    {
-    private:
-        template<class U>
-        using value_t = meta::if_<std::is_void<T>, U, T>;
-
-    public:
-        using difference_type = std::ptrdiff_t;
-        using char_type = Char;
-        using traits_type = Traits;
-        using ostream_type = std::basic_ostream<Char, Traits>;
-
-        constexpr ostream_iterator() = default;
-        ostream_iterator(ostream_type & s, Char const * d = nullptr) noexcept
-          : sout_(&s)
-          , delim_(d)
-        {}
-        template(typename U)(
-            /// \pre
-            requires convertible_to<U, value_t<U> const &>)
-        ostream_iterator & operator=(U && value)
-        {
-            RANGES_EXPECT(sout_);
-            *sout_ << static_cast<value_t<U> const &>(static_cast<U &&>(value));
-            if(delim_)
-                *sout_ << delim_;
-            return *this;
-        }
-        ostream_iterator & operator*()
-        {
-            return *this;
-        }
-        ostream_iterator & operator++()
-        {
-            return *this;
-        }
-        ostream_iterator & operator++(int)
-        {
-            return *this;
-        }
-
-    private:
-        ostream_type * sout_;
-        Char const * delim_;
-    };
-
-    template<typename Delim, typename Char = char,
-             typename Traits = std::char_traits<Char>>
-    struct ostream_joiner
-    {
-        CPP_assert(semiregular<Delim>);
-        using difference_type = std::ptrdiff_t;
-        using char_type = Char;
-        using traits_type = Traits;
-        using ostream_type = std::basic_ostream<Char, Traits>;
-
-        constexpr ostream_joiner() = default;
-        ostream_joiner(ostream_type & s, Delim const & d)
-          : delim_(d)
-          , sout_(std::addressof(s))
-          , first_(true)
-        {}
-        ostream_joiner(ostream_type & s, Delim && d)
-          : delim_(std::move(d))
-          , sout_(std::addressof(s))
-          , first_(true)
-        {}
-        template<typename T>
-        ostream_joiner & operator=(T const & value)
-        {
-            RANGES_EXPECT(sout_);
-            if(!first_)
-                *sout_ << delim_;
-            first_ = false;
-            *sout_ << value;
-            return *this;
-        }
-        ostream_joiner & operator*() noexcept
-        {
-            return *this;
-        }
-        ostream_joiner & operator++() noexcept
-        {
-            return *this;
-        }
-        ostream_joiner & operator++(int) noexcept
-        {
-            return *this;
-        }
-
-    private:
-        Delim delim_;
-        ostream_type * sout_;
-        bool first_;
-    };
-
-    struct make_ostream_joiner_fn
-    {
-        template(typename Delim, typename Char, typename Traits)(
-            /// \pre
-            requires semiregular<detail::decay_t<Delim>>)
-        ostream_joiner<detail::decay_t<Delim>, Char, Traits> //
-        operator()(std::basic_ostream<Char, Traits> & s, Delim && d) const
-        {
-            return {s, std::forward<Delim>(d)};
-        }
-    };
-
-    /// \sa `make_ostream_joiner_fn`
-    RANGES_INLINE_VARIABLE(make_ostream_joiner_fn, make_ostream_joiner)
-
-    template<typename Char, typename Traits = std::char_traits<Char>>
-    struct ostreambuf_iterator
-    {
-    public:
-        typedef ptrdiff_t difference_type;
-        typedef Char char_type;
-        typedef Traits traits_type;
-        typedef std::basic_streambuf<Char, Traits> streambuf_type;
-        typedef std::basic_ostream<Char, Traits> ostream_type;
-
-        constexpr ostreambuf_iterator() = default;
-        ostreambuf_iterator(ostream_type & s) noexcept
-          : ostreambuf_iterator(s.rdbuf())
-        {}
-        ostreambuf_iterator(streambuf_type * s) noexcept
-          : sbuf_(s)
-        {
-            RANGES_ASSERT(s != nullptr);
-        }
-        ostreambuf_iterator & operator=(Char c)
-        {
-            RANGES_ASSERT(sbuf_ != nullptr);
-            if(!failed_)
-                failed_ = (sbuf_->sputc(c) == Traits::eof());
-            return *this;
-        }
-        ostreambuf_iterator & operator*()
-        {
-            return *this;
-        }
-        ostreambuf_iterator & operator++()
-        {
-            return *this;
-        }
-        ostreambuf_iterator & operator++(int)
-        {
-            return *this;
-        }
-        bool failed() const noexcept
-        {
-            return failed_;
-        }
-
-    private:
-        streambuf_type * sbuf_ = nullptr;
-        bool failed_ = false;
-    };
-
-    namespace cpp20
-    {
-        template<typename T, typename Char = char,
-                 typename Traits = std::char_traits<Char>>
-        using ostream_iterator = ranges::ostream_iterator<T, Char, Traits>;
-
-        using ranges::ostreambuf_iterator;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-/// \cond
-RANGES_DIAGNOSTIC_PUSH
-RANGES_DIAGNOSTIC_IGNORE_MISMATCHED_TAGS
-
-namespace std
-{
-    template<typename T, typename Char, typename Traits>
-    struct iterator_traits<::ranges::ostream_iterator<T, Char, Traits>>
-      : ::ranges::detail::std_output_iterator_traits<>
-    {};
-
-    template<typename Char, typename Traits>
-    struct iterator_traits<::ranges::ostreambuf_iterator<Char, Traits>>
-      : ::ranges::detail::std_output_iterator_traits<>
-    {};
-} // namespace std
-
-RANGES_DIAGNOSTIC_POP
-/// \endcond
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif // RANGES_V3_ITERATOR_STREAM_ITERATORS_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/iterator/traits.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/iterator/traits.hpp
deleted file mode 100644
index cb439f6f..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/iterator/traits.hpp
+++ /dev/null
@@ -1,178 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ITERATOR_TRAITS_HPP
-#define RANGES_V3_ITERATOR_TRAITS_HPP
-
-#include <iterator>
-#include <type_traits>
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/access.hpp> // for iter_move, iter_swap
-#include <range/v3/utility/common_type.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-iterator
-    /// @{
-
-    /// \cond
-    using input_iterator_tag RANGES_DEPRECATED(
-        "Please switch to the standard iterator tags") = std::input_iterator_tag;
-    using forward_iterator_tag RANGES_DEPRECATED(
-        "Please switch to the standard iterator tags") = std::forward_iterator_tag;
-    using bidirectional_iterator_tag RANGES_DEPRECATED(
-        "Please switch to the standard iterator tags") = std::bidirectional_iterator_tag;
-    using random_access_iterator_tag RANGES_DEPRECATED(
-        "Please switch to the standard iterator tags") = std::random_access_iterator_tag;
-    /// \endcond
-
-    struct contiguous_iterator_tag : std::random_access_iterator_tag
-    {};
-
-    /// \cond
-    namespace detail
-    {
-        template<typename I, typename = iter_reference_t<I>,
-                 typename R = decltype(iter_move(std::declval<I &>())), typename = R &>
-        using iter_rvalue_reference_t = R;
-
-        template<typename I>
-        RANGES_INLINE_VAR constexpr bool has_nothrow_iter_move_v =
-            noexcept(iter_rvalue_reference_t<I>(ranges::iter_move(std::declval<I &>())));
-    } // namespace detail
-    /// \endcond
-
-    template<typename I>
-    using iter_rvalue_reference_t = detail::iter_rvalue_reference_t<I>;
-
-    template<typename I>
-    using iter_common_reference_t =
-        common_reference_t<iter_reference_t<I>, iter_value_t<I> &>;
-
-#if defined(RANGES_DEEP_STL_INTEGRATION) && RANGES_DEEP_STL_INTEGRATION && \
-    !defined(RANGES_DOXYGEN_INVOKED)
-    template<typename T>
-    using iter_difference_t =
-        typename meta::conditional_t<detail::is_std_iterator_traits_specialized_v<T>,
-                                   std::iterator_traits<uncvref_t<T>>,
-                                   incrementable_traits<uncvref_t<T>>>::difference_type;
-#else
-    template<typename T>
-    using iter_difference_t =
-        typename incrementable_traits<uncvref_t<T>>::difference_type;
-#endif
-
-    // Defined in <range/v3/iterator/access.hpp>
-    // template<typename T>
-    // using iter_value_t = ...
-
-    // Defined in <range/v3/iterator/access.hpp>
-    // template<typename R>
-    // using iter_reference_t = detail::iter_reference_t_<R>;
-
-    // Defined in <range/v3/range_fwd.hpp>:
-    // template<typename S, typename I>
-    // inline constexpr bool disable_sized_sentinel = false;
-
-    /// \cond
-    namespace detail
-    {
-        template<typename I>
-        using iter_size_t =
-            meta::_t<meta::conditional_t<std::is_integral<iter_difference_t<I>>::value,
-                               std::make_unsigned<iter_difference_t<I>>,
-                               meta::id<iter_difference_t<I>>>>;
-
-        template<typename I>
-        using iter_arrow_t = decltype(std::declval<I &>().operator->());
-
-        template<typename I>
-        using iter_pointer_t =
-            meta::_t<meta::conditional_t<
-                        meta::is_trait<meta::defer<iter_arrow_t, I>>::value,
-                        meta::defer<iter_arrow_t, I>,
-                        std::add_pointer<iter_reference_t<I>>>>;
-
-        template<typename T>
-        struct difference_type_ : meta::defer<iter_difference_t, T>
-        {};
-
-        template<typename T>
-        struct value_type_ : meta::defer<iter_value_t, T>
-        {};
-
-        template<typename T>
-        struct size_type_ : meta::defer<iter_size_t, T>
-        {};
-    } // namespace detail
-
-    template<typename T>
-    using difference_type_t RANGES_DEPRECATED(
-        "ranges::difference_type_t is deprecated. Please use "
-        "ranges::iter_difference_t instead.") = iter_difference_t<T>;
-
-    template<typename T>
-    using value_type_t RANGES_DEPRECATED(
-        "ranges::value_type_t is deprecated. Please use "
-        "ranges::iter_value_t instead.") = iter_value_t<T>;
-
-    template<typename R>
-    using reference_t RANGES_DEPRECATED(
-        "ranges::reference_t is deprecated. Use ranges::iter_reference_t "
-        "instead.") = iter_reference_t<R>;
-
-    template<typename I>
-    using rvalue_reference_t RANGES_DEPRECATED(
-        "rvalue_reference_t is deprecated; "
-        "use iter_rvalue_reference_t instead") = iter_rvalue_reference_t<I>;
-
-    template<typename T>
-    struct RANGES_DEPRECATED(
-        "ranges::size_type is deprecated. Iterators do not have an associated "
-        "size_type.") size_type : detail::size_type_<T>
-    {};
-
-    template<typename I>
-    using size_type_t RANGES_DEPRECATED("size_type_t is deprecated.") =
-        detail::iter_size_t<I>;
-    /// \endcond
-
-    namespace cpp20
-    {
-        using ranges::iter_common_reference_t;
-        using ranges::iter_difference_t;
-        using ranges::iter_reference_t;
-        using ranges::iter_rvalue_reference_t;
-        using ranges::iter_value_t;
-
-        // Specialize these in the ranges:: namespace
-        using ranges::disable_sized_sentinel;
-        template<typename T>
-        using incrementable_traits = ranges::incrementable_traits<T>;
-        template<typename T>
-        using indirectly_readable_traits = ranges::indirectly_readable_traits<T>;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif // RANGES_V3_ITERATOR_TRAITS_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/iterator/unreachable_sentinel.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/iterator/unreachable_sentinel.hpp
deleted file mode 100644
index 1d7595d8..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/iterator/unreachable_sentinel.hpp
+++ /dev/null
@@ -1,74 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_ITERATOR_UNREACHABLE_SENTINEL_HPP
-#define RANGES_V3_ITERATOR_UNREACHABLE_SENTINEL_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/concepts.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-iterator
-    /// @{
-    struct unreachable_sentinel_t
-    {
-        template<typename I>
-        friend constexpr auto operator==(I const &, unreachable_sentinel_t) noexcept
-            -> CPP_broken_friend_ret(bool)(
-                /// \pre
-                requires weakly_incrementable<I>)
-        {
-            return false;
-        }
-        template<typename I>
-        friend constexpr auto operator==(unreachable_sentinel_t, I const &) noexcept
-            -> CPP_broken_friend_ret(bool)(
-                /// \pre
-                requires weakly_incrementable<I>)
-        {
-            return false;
-        }
-        template<typename I>
-        friend constexpr auto operator!=(I const &, unreachable_sentinel_t) noexcept
-            -> CPP_broken_friend_ret(bool)(
-                /// \pre
-                requires weakly_incrementable<I>)
-        {
-            return true;
-        }
-        template<typename I>
-        friend constexpr auto operator!=(unreachable_sentinel_t, I const &) noexcept
-            -> CPP_broken_friend_ret(bool)(
-                /// \pre
-                requires weakly_incrementable<I>)
-        {
-            return true;
-        }
-    };
-
-    RANGES_INLINE_VARIABLE(unreachable_sentinel_t, unreachable)
-
-    namespace cpp20
-    {
-        using ranges::unreachable;
-        using ranges::unreachable_sentinel_t;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif // RANGES_V3_ITERATOR_UNREACHABLE_SENTINEL_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/iterator_range.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/iterator_range.hpp
deleted file mode 100644
index 12a19848..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/iterator_range.hpp
+++ /dev/null
@@ -1,392 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ITERATOR_RANGE_HPP
-#define RANGES_V3_ITERATOR_RANGE_HPP
-
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/unreachable_sentinel.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/interface.hpp>
-
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated. Please switch to subrange in "
-    "<range/v3/view/subrange.hpp>.")
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-
-    /// \cond
-    namespace _iterator_range_
-    {
-        struct adl_hook_
-        {};
-
-        // A temporary iterator_range can be safely passed to ranges::begin and
-        // ranges::end.
-        template<class I, class S>
-        constexpr I begin(iterator_range<I, S> && r) noexcept(
-            std::is_nothrow_copy_constructible<I>::value)
-        {
-            return r.begin();
-        }
-        template<class I, class S>
-        constexpr I begin(iterator_range<I, S> const && r) noexcept(
-            std::is_nothrow_copy_constructible<I>::value)
-        {
-            return r.begin();
-        }
-        template<class I, class S>
-        constexpr S end(iterator_range<I, S> && r) noexcept(
-            std::is_nothrow_copy_constructible<S>::value)
-        {
-            return r.end();
-        }
-        template<class I, class S>
-        constexpr S end(iterator_range<I, S> const && r) noexcept(
-            std::is_nothrow_copy_constructible<S>::value)
-        {
-            return r.end();
-        }
-
-        // A temporary sized_iterator_range can be safely passed to ranges::begin and
-        // ranges::end.
-        template<class I, class S>
-        constexpr I begin(sized_iterator_range<I, S> && r) noexcept(
-            std::is_nothrow_copy_constructible<I>::value)
-        {
-            return r.begin();
-        }
-        template<class I, class S>
-        constexpr I begin(sized_iterator_range<I, S> const && r) noexcept(
-            std::is_nothrow_copy_constructible<I>::value)
-        {
-            return r.begin();
-        }
-        template<class I, class S>
-        constexpr S end(sized_iterator_range<I, S> && r) noexcept(
-            std::is_nothrow_copy_constructible<S>::value)
-        {
-            return r.end();
-        }
-        template<class I, class S>
-        constexpr S end(sized_iterator_range<I, S> const && r) noexcept(
-            std::is_nothrow_copy_constructible<S>::value)
-        {
-            return r.end();
-        }
-    } // namespace _iterator_range_
-    /// \endcond
-
-    template<typename I, typename S /*= I*/>
-    struct RANGES_EMPTY_BASES iterator_range
-      : view_interface<iterator_range<I, S>,
-                       same_as<S, unreachable_sentinel_t> ? infinite : unknown>
-      , compressed_pair<I, S>
-      , _iterator_range_::adl_hook_
-    {
-    private:
-        template<typename, typename>
-        friend struct iterator_range;
-        template<typename, typename>
-        friend struct sized_iterator_range;
-        compressed_pair<I, S> & base() noexcept
-        {
-            return *this;
-        }
-        compressed_pair<I, S> const & base() const noexcept
-        {
-            return *this;
-        }
-        using compressed_pair<I, S>::first;
-        using compressed_pair<I, S>::second;
-
-    public:
-        using iterator = I;
-        using sentinel = S;
-        /// \cond
-        using const_iterator = I; // Mostly to avoid spurious errors in Boost.Range
-        /// \endcond
-
-        constexpr I & begin() &
-        {
-            return this->first();
-        }
-        constexpr I const & begin() const &
-        {
-            return this->first();
-        }
-
-        constexpr S & end() &
-        {
-            return this->second();
-        }
-        constexpr S const & end() const &
-        {
-            return this->second();
-        }
-
-        iterator_range() = default;
-        constexpr iterator_range(I first, S last)
-          : compressed_pair<I, S>{detail::move(first), detail::move(last)}
-        {}
-        template(typename X, typename Y)(
-            /// \pre
-            requires constructible_from<I, X> AND constructible_from<S, Y>)
-        constexpr iterator_range(iterator_range<X, Y> rng)
-          : compressed_pair<I, S>{detail::move(rng.begin()), detail::move(rng.end())}
-        {}
-        template(typename X, typename Y)(
-            /// \pre
-            requires constructible_from<I, X> AND constructible_from<S, Y>)
-        constexpr explicit iterator_range(std::pair<X, Y> rng)
-          : compressed_pair<I, S>{detail::move(rng.first), detail::move(rng.second)}
-        {}
-        template(typename X, typename Y)(
-            /// \pre
-            requires assignable_from<I &, X> AND assignable_from<S &, Y>)
-        iterator_range & operator=(iterator_range<X, Y> rng)
-        {
-            base().first() = std::move(rng.base()).first();
-            base().second() = std::move(rng.base()).second();
-            return *this;
-        }
-        template(typename X, typename Y)(
-            /// \pre
-            requires convertible_to<I, X> AND convertible_to<S, Y>)
-        constexpr operator std::pair<X, Y>() const
-        {
-            return {base().first(), base().second()};
-        }
-        constexpr bool empty() const
-        {
-            return base().first() == base().second();
-        }
-    };
-
-    // Like iterator_range, but with a known size. The first and second members
-    // are private to prevent inadvertent violations of the class invariant.
-    //
-    // Class invariant:
-    //   distance(begin(), end()) == size()
-    //
-    template<typename I, typename S /* = I */>
-    struct sized_iterator_range
-      : view_interface<sized_iterator_range<I, S>, finite>
-      , _iterator_range_::adl_hook_
-    {
-        using size_type = detail::iter_size_t<I>;
-        using iterator = I;
-        using sentinel = S;
-#ifndef RANGES_DOXYGEN_INVOKED
-        using const_iterator = I; // Mostly to avoid spurious errors in Boost.Range
-#endif
-
-    private:
-        template<typename X, typename Y>
-        friend struct sized_iterator_range;
-        iterator_range<I, S> rng_;
-        size_type size_;
-
-    public:
-        sized_iterator_range() = default;
-        RANGES_NDEBUG_CONSTEXPR sized_iterator_range(I first, S last, size_type size)
-          : rng_{detail::move(first), detail::move(last)}
-          , size_(size)
-        {
-#ifndef NDEBUG
-            RANGES_ASSERT(!(bool)forward_iterator<I> ||
-                          static_cast<size_type>(ranges::distance(rng_)) == size_);
-#endif
-        }
-        template(typename X, typename Y)(
-            /// \pre
-            requires constructible_from<I, X> AND constructible_from<S, Y>)
-        RANGES_NDEBUG_CONSTEXPR sized_iterator_range(std::pair<X, Y> rng, size_type size)
-          : sized_iterator_range{detail::move(rng).first, detail::move(rng).second, size}
-        {}
-        template(typename X, typename Y)(
-            /// \pre
-            requires constructible_from<I, X> AND constructible_from<S, Y>)
-        RANGES_NDEBUG_CONSTEXPR sized_iterator_range(iterator_range<X, Y> rng,
-                                                     size_type size)
-          : sized_iterator_range{detail::move(rng).first(),
-                                 detail::move(rng).second,
-                                 size}
-        {}
-        template(typename X, typename Y)(
-            /// \pre
-            requires constructible_from<I, X> AND constructible_from<S, Y>)
-        RANGES_NDEBUG_CONSTEXPR sized_iterator_range(sized_iterator_range<X, Y> rng)
-          : sized_iterator_range{detail::move(rng).rng_.first(),
-                                 detail::move(rng).rng_.second,
-                                 rng.size_}
-        {}
-        template(typename X, typename Y)(
-            /// \pre
-            requires assignable_from<I &, X> AND assignable_from<S &, Y>)
-        sized_iterator_range & operator=(sized_iterator_range<X, Y> rng)
-        {
-            rng_ = detail::move(rng).rng_;
-            size_ = rng.size_;
-            return *this;
-        }
-        I begin() const
-        {
-            return rng_.begin();
-        }
-        S end() const
-        {
-            return rng_.end();
-        }
-        size_type size() const noexcept
-        {
-            return size_;
-        }
-        template(typename X, typename Y)(
-            /// \pre
-            requires convertible_to<I, X> AND convertible_to<S, Y>)
-        constexpr operator std::pair<X, Y>() const
-        {
-            return rng_;
-        }
-        template(typename X, typename Y)(
-            /// \pre
-            requires convertible_to<I, X> AND convertible_to<S, Y>)
-        constexpr operator iterator_range<X, Y>() const
-        {
-            return rng_;
-        }
-        constexpr operator iterator_range<I, S> const &() const & noexcept
-        {
-            return rng_;
-        }
-        // clang-format off
-        /// Tuple-like access for `sized_iterator_range`
-        template(std::size_t N)(
-            /// \pre
-            requires (N < 2))        //
-        friend constexpr auto CPP_auto_fun(get)(sized_iterator_range const &p)
-        (
-            // return ranges::get<N>(p.rng_)
-            return ranges::get<N>(p.*&sized_iterator_range::rng_) // makes clang happy
-        )
-        // clang-format on
-        /// \overload
-        template(std::size_t N)(
-            /// \pre
-            requires (N == 2)) //
-        friend constexpr size_type get(sized_iterator_range const & p) noexcept
-        {
-            return p.size();
-        }
-    };
-
-    struct make_iterator_range_fn
-    {
-        /// \return `{first, last}`
-        template(typename I, typename S)(
-            /// \pre
-            requires sentinel_for<S, I>)
-        constexpr iterator_range<I, S> operator()(I first, S last) const
-        {
-            return {detail::move(first), detail::move(last)};
-        }
-
-        /// \return `{first, last, size}`
-        template(typename I, typename S)(
-            /// \pre
-            requires sentinel_for<S, I>)
-        constexpr sized_iterator_range<I, S> //
-        operator()(I first, S last, detail::iter_size_t<I> sz) const
-        {
-            return {detail::move(first), detail::move(last), sz};
-        }
-    };
-
-    /// \sa `make_iterator_range_fn`
-    RANGES_INLINE_VARIABLE(make_iterator_range_fn, make_iterator_range)
-
-    // TODO add specialization of range_cardinality for when we can determine the range is
-    // infinite
-
-    /// @}
-} // namespace ranges
-
-// The standard is inconsistent about whether these are classes or structs
-RANGES_DIAGNOSTIC_PUSH
-RANGES_DIAGNOSTIC_IGNORE_MISMATCHED_TAGS
-
-/// \cond
-namespace std
-{
-    template<typename I, typename S>
-    struct tuple_size<::ranges::iterator_range<I, S>> : std::integral_constant<size_t, 2>
-    {};
-
-    template<typename I, typename S>
-    struct tuple_element<0, ::ranges::iterator_range<I, S>>
-    {
-        using type = I;
-    };
-
-    template<typename I, typename S>
-    struct tuple_element<1, ::ranges::iterator_range<I, S>>
-    {
-        using type = S;
-    };
-
-    template<typename I, typename S>
-    struct tuple_size<::ranges::sized_iterator_range<I, S>>
-      : std::integral_constant<size_t, 3>
-    {};
-
-    template<typename I, typename S>
-    struct tuple_element<0, ::ranges::sized_iterator_range<I, S>>
-    {
-        using type = I;
-    };
-
-    template<typename I, typename S>
-    struct tuple_element<1, ::ranges::sized_iterator_range<I, S>>
-    {
-        using type = S;
-    };
-
-    template<typename I, typename S>
-    struct tuple_element<2, ::ranges::sized_iterator_range<I, S>>
-    {
-        using type = typename ::ranges::sized_iterator_range<I, S>::size_type;
-    };
-} // namespace std
-/// \endcond
-
-RANGES_DIAGNOSTIC_POP
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/numeric.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/numeric.hpp
deleted file mode 100644
index 23202409..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/numeric.hpp
+++ /dev/null
@@ -1,20 +0,0 @@
-///////////////////////////////////////////////////////////////////////////////
-/// \file numeric.hpp
-///   Contains range-based versions of the numeric algorithms
-//
-// Copyright Eric Niebler 2014-present
-//
-// Distributed under the Boost Software License, Version 1.0. (See
-// accompanying file LICENSE_1_0.txt or copy at
-// http://www.boost.org/LICENSE_1_0.txt)
-
-#ifndef RANGES_V3_NUMERIC_HPP
-#define RANGES_V3_NUMERIC_HPP
-
-#include <range/v3/numeric/accumulate.hpp>
-#include <range/v3/numeric/adjacent_difference.hpp>
-#include <range/v3/numeric/inner_product.hpp>
-#include <range/v3/numeric/iota.hpp>
-#include <range/v3/numeric/partial_sum.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/numeric/accumulate.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/numeric/accumulate.hpp
deleted file mode 100644
index e88cce37..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/numeric/accumulate.hpp
+++ /dev/null
@@ -1,69 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_NUMERIC_ACCUMULATE_HPP
-#define RANGES_V3_NUMERIC_ACCUMULATE_HPP
-
-#include <meta/meta.hpp>
-
-#include <range/v3/functional/arithmetic.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-numerics
-    /// @{
-    struct accumulate_fn
-    {
-        template(typename I, typename S, typename T, typename Op = plus,
-                 typename P = identity)(
-            /// \pre
-            requires sentinel_for<S, I> AND input_iterator<I> AND
-                indirectly_binary_invocable_<Op, T *, projected<I, P>> AND
-                assignable_from<T &, indirect_result_t<Op &, T *, projected<I, P>>>)
-        T operator()(I first, S last, T init, Op op = Op{},
-                        P proj = P{}) const
-        {
-            for(; first != last; ++first)
-                init = invoke(op, init, invoke(proj, *first));
-            return init;
-        }
-
-        template(typename Rng, typename T, typename Op = plus, typename P = identity)(
-            /// \pre
-            requires input_range<Rng> AND
-                indirectly_binary_invocable_<Op, T *, projected<iterator_t<Rng>, P>> AND
-                assignable_from<
-                    T &, indirect_result_t<Op &, T *, projected<iterator_t<Rng>, P>>>)
-        T operator()(Rng && rng, T init, Op op = Op{}, P proj = P{}) const
-        {
-            return (*this)(
-                begin(rng), end(rng), std::move(init), std::move(op), std::move(proj));
-        }
-    };
-
-    RANGES_INLINE_VARIABLE(accumulate_fn, accumulate)
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/numeric/adjacent_difference.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/numeric/adjacent_difference.hpp
deleted file mode 100644
index 1dd26abc..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/numeric/adjacent_difference.hpp
+++ /dev/null
@@ -1,156 +0,0 @@
-/// \file
-// Range v3 library
-//
-// Copyright Eric Niebler 2004
-// Copyright Gonzalo Brito Gadeschi 2014
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-// Implementation based on the code in libc++
-//   http://http://libcxx.llvm.org/
-
-#ifndef RANGES_V3_NUMERIC_ADJACENT_DIFFERENCE_HPP
-#define RANGES_V3_NUMERIC_ADJACENT_DIFFERENCE_HPP
-
-#include <meta/meta.hpp>
-
-#include <range/v3/algorithm/result_types.hpp>
-#include <range/v3/functional/arithmetic.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/iterator/unreachable_sentinel.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-numerics
-    /// @{
-    // clang-format off
-    template(typename I, typename O, typename BOp, typename P)(
-    concept (differenceable_)(I, O, BOp, P),
-        invocable<P&, iter_value_t<I>> AND
-        copy_constructible<uncvref_t<invoke_result_t<P&, iter_value_t<I>>>> AND
-        movable<uncvref_t<invoke_result_t<P&, iter_value_t<I>>>> AND
-        output_iterator<O, invoke_result_t<P&, iter_value_t<I>>> AND
-        invocable<
-            BOp&,
-            invoke_result_t<
-                P&,
-                iter_value_t<I>>,
-                invoke_result_t<P&, iter_value_t<I>>> AND
-        output_iterator<
-            O,
-            invoke_result_t<
-                BOp&,
-                invoke_result_t<P&, iter_value_t<I>>,
-                invoke_result_t<P&, iter_value_t<I>>>>);
-
-    template<typename I, typename O, typename BOp = minus, typename P = identity>
-    CPP_concept differenceable =
-        input_iterator<I> &&
-        CPP_concept_ref(ranges::differenceable_, I, O, BOp, P);
-    // clang-format on
-
-    template<typename I, typename O>
-    using adjacent_difference_result = detail::in_out_result<I, O>;
-
-    struct adjacent_difference_fn
-    {
-        template(typename I, typename S, typename O, typename S2, typename BOp = minus,
-                 typename P = identity)(
-            /// \pre
-            requires sentinel_for<S, I> AND sentinel_for<S2, O> AND
-                differenceable<I, O, BOp, P>)
-        adjacent_difference_result<I, O> operator()(I first,
-                                                    S last,
-                                                    O result,
-                                                    S2 end_result,
-                                                    BOp bop = BOp{},
-                                                    P proj = P{}) const
-        {
-            // BUGBUG think about the use of coerce here.
-            using V = iter_value_t<I>;
-            using X = invoke_result_t<P &, V>;
-            coerce<V> v;
-            coerce<X> x;
-
-            if(first != last && result != end_result)
-            {
-                auto t1(x(invoke(proj, v(*first))));
-                *result = t1;
-                for(++first, ++result; first != last && result != end_result;
-                    ++first, ++result)
-                {
-                    auto t2(x(invoke(proj, v(*first))));
-                    *result = invoke(bop, t2, t1);
-                    t1 = std::move(t2);
-                }
-            }
-            return {first, result};
-        }
-
-        template(typename I, typename S, typename O, typename BOp = minus,
-                 typename P = identity)(
-            /// \pre
-            requires sentinel_for<S, I> AND differenceable<I, O, BOp, P>)
-        adjacent_difference_result<I, O> //
-        operator()(I first, S last, O result, BOp bop = BOp{}, P proj = P{}) const
-        {
-            return (*this)(std::move(first),
-                           std::move(last),
-                           std::move(result),
-                           unreachable,
-                           std::move(bop),
-                           std::move(proj));
-        }
-
-        template(typename Rng, typename ORef, typename BOp = minus, typename P = identity,
-                 typename I = iterator_t<Rng>, typename O = uncvref_t<ORef>)(
-            /// \pre
-            requires range<Rng> AND differenceable<I, O, BOp, P>)
-        adjacent_difference_result<borrowed_iterator_t<Rng>, O> //
-        operator()(Rng && rng, ORef && result, BOp bop = BOp{}, P proj = P{}) const
-        {
-            return (*this)(begin(rng),
-                           end(rng),
-                           static_cast<ORef &&>(result),
-                           std::move(bop),
-                           std::move(proj));
-        }
-
-        template(typename Rng, typename ORng, typename BOp = minus, typename P = identity,
-                 typename I = iterator_t<Rng>, typename O = iterator_t<ORng>)(
-            /// \pre
-            requires range<Rng> AND range<ORng> AND differenceable<I, O, BOp, P>)
-        adjacent_difference_result<borrowed_iterator_t<Rng>, borrowed_iterator_t<ORng>>
-        operator()(Rng && rng, ORng && result, BOp bop = BOp{}, P proj = P{}) const
-        {
-            return (*this)(begin(rng),
-                           end(rng),
-                           begin(result),
-                           end(result),
-                           std::move(bop),
-                           std::move(proj));
-        }
-    };
-
-    RANGES_INLINE_VARIABLE(adjacent_difference_fn, adjacent_difference)
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/numeric/inner_product.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/numeric/inner_product.hpp
deleted file mode 100644
index 2aa54768..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/numeric/inner_product.hpp
+++ /dev/null
@@ -1,160 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//  Copyright Gonzalo Brito Gadeschi 2014
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_NUMERIC_INNER_PRODUCT_HPP
-#define RANGES_V3_NUMERIC_INNER_PRODUCT_HPP
-
-#include <meta/meta.hpp>
-
-#include <range/v3/functional/arithmetic.hpp>
-#include <range/v3/functional/concepts.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/iterator/unreachable_sentinel.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-numerics
-    /// @{
-    // clang-format off
-    template(typename I1, typename I2, typename T, typename BOp1, typename BOp2,
-        typename P1, typename P2)(
-    concept (inner_product_constraints_)(I1, I2, T, BOp1, BOp2, P1, P2),
-        invocable<P1&, iter_value_t<I1>> AND
-        invocable<P2&, iter_value_t<I2>> AND
-        invocable<
-            BOp2&,
-            invoke_result_t<P1&, iter_value_t<I1>>,
-            invoke_result_t<P2&, iter_value_t<I2>>> AND
-        invocable<
-            BOp1&,
-            T,
-            invoke_result_t<
-                BOp2&,
-                invoke_result_t<P1&, iter_value_t<I1>>,
-                invoke_result_t<P2&, iter_value_t<I2>>>> AND
-        assignable_from<
-            T&,
-            invoke_result_t<
-                BOp1&,
-                T,
-                invoke_result_t<
-                    BOp2&,
-                    invoke_result_t<P1&, iter_value_t<I1>>,
-                    invoke_result_t<P2&, iter_value_t<I2>>>>>
-    );
-    template<typename I1, typename I2, typename T, typename BOp1 = plus,
-        typename BOp2 = multiplies, typename P1 = identity, typename P2 = identity>
-    CPP_concept inner_product_constraints =
-        input_iterator<I1> &&
-        input_iterator<I2> &&
-        CPP_concept_ref(ranges::inner_product_constraints_, I1, I2, T, BOp1, BOp2, P1, P2);
-    // clang-format on
-
-    struct inner_product_fn
-    {
-        template(typename I1, typename S1, typename I2, typename S2, typename T,
-                 typename BOp1 = plus, typename BOp2 = multiplies, typename P1 = identity,
-                 typename P2 = identity)(
-            /// \pre
-            requires sentinel_for<S1, I1> AND sentinel_for<S2, I2> AND
-                inner_product_constraints<I1, I2, T, BOp1, BOp2, P1, P2>)
-        T operator()(I1 begin1, S1 end1, I2 begin2, S2 end2, T init,
-                     BOp1 bop1 = BOp1{}, BOp2 bop2 = BOp2{}, P1 proj1 = P1{},
-                     P2 proj2 = P2{}) const
-        {
-            for(; begin1 != end1 && begin2 != end2; ++begin1, ++begin2)
-                init =
-                    invoke(bop1,
-                           init,
-                           invoke(bop2, invoke(proj1, *begin1), invoke(proj2, *begin2)));
-            return init;
-        }
-
-        template(typename I1, typename S1, typename I2, typename T, typename BOp1 = plus,
-                 typename BOp2 = multiplies, typename P1 = identity,
-                 typename P2 = identity)(
-            /// \pre
-            requires sentinel_for<S1, I1> AND
-                inner_product_constraints<I1, I2, T, BOp1, BOp2, P1, P2>)
-        T operator()(I1 begin1, S1 end1, I2 begin2, T init, BOp1 bop1 = BOp1{},
-                     BOp2 bop2 = BOp2{}, P1 proj1 = P1{}, P2 proj2 = P2{}) const
-        {
-            return (*this)(std::move(begin1),
-                           std::move(end1),
-                           std::move(begin2),
-                           unreachable,
-                           std::move(init),
-                           std::move(bop1),
-                           std::move(bop2),
-                           std::move(proj1),
-                           std::move(proj2));
-        }
-
-        template(typename Rng1, typename I2Ref, typename T, typename BOp1 = plus,
-                 typename BOp2 = multiplies, typename P1 = identity,
-                 typename P2 = identity, typename I1 = iterator_t<Rng1>,
-                 typename I2 = uncvref_t<I2Ref>)(
-            /// \pre
-            requires range<Rng1> AND
-                inner_product_constraints<I1, I2, T, BOp1, BOp2, P1, P2>)
-        T operator()(Rng1 && rng1, I2Ref && begin2, T init, BOp1 bop1 = BOp1{},
-                     BOp2 bop2 = BOp2{}, P1 proj1 = P1{}, P2 proj2 = P2{}) const
-        {
-            return (*this)(begin(rng1),
-                           end(rng1),
-                           static_cast<I2Ref &&>(begin2),
-                           std::move(init),
-                           std::move(bop1),
-                           std::move(bop2),
-                           std::move(proj1),
-                           std::move(proj2));
-        }
-
-        template(typename Rng1, typename Rng2, typename T, typename BOp1 = plus,
-                 typename BOp2 = multiplies, typename P1 = identity,
-                 typename P2 = identity, typename I1 = iterator_t<Rng1>,
-                 typename I2 = iterator_t<Rng2>)(
-            /// \pre
-            requires range<Rng1> AND range<Rng2> AND
-                inner_product_constraints<I1, I2, T, BOp1, BOp2, P1, P2>)
-        T operator()(Rng1 && rng1, Rng2 && rng2, T init, BOp1 bop1 = BOp1{},
-                     BOp2 bop2 = BOp2{}, P1 proj1 = P1{}, P2 proj2 = P2{}) const
-        {
-            return (*this)(begin(rng1),
-                           end(rng1),
-                           begin(rng2),
-                           end(rng2),
-                           std::move(init),
-                           std::move(bop1),
-                           std::move(bop2),
-                           std::move(proj1),
-                           std::move(proj2));
-        }
-    };
-
-    RANGES_INLINE_VARIABLE(inner_product_fn, inner_product)
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/numeric/iota.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/numeric/iota.hpp
deleted file mode 100644
index 5ccc6ff9..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/numeric/iota.hpp
+++ /dev/null
@@ -1,57 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_NUMERIC_IOTA_HPP
-#define RANGES_V3_NUMERIC_IOTA_HPP
-
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-numerics
-    /// @{
-    struct iota_fn
-    {
-        template(typename O, typename S, typename T)(
-            /// \pre
-            requires output_iterator<O, T const &> AND sentinel_for<S, O> AND
-                weakly_incrementable<T>)
-        O operator()(O first, S last, T val) const
-        {
-            for(; first != last; ++first, ++val)
-                *first = detail::as_const(val);
-            return first;
-        }
-
-        template(typename Rng, typename T)(
-            /// \pre
-            requires output_range<Rng, T const &> AND weakly_incrementable<T>)
-        borrowed_iterator_t<Rng> operator()(Rng && rng, T val) const //
-        {
-            return (*this)(begin(rng), end(rng), detail::move(val));
-        }
-    };
-
-    RANGES_INLINE_VARIABLE(iota_fn, iota)
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/numeric/partial_sum.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/numeric/partial_sum.hpp
deleted file mode 100644
index 4baff66d..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/numeric/partial_sum.hpp
+++ /dev/null
@@ -1,174 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//  Copyright Gonzalo Brito Gadeschi 2014
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_NUMERIC_PARTIAL_SUM_HPP
-#define RANGES_V3_NUMERIC_PARTIAL_SUM_HPP
-
-#include <meta/meta.hpp>
-
-#include <range/v3/algorithm/result_types.hpp>
-#include <range/v3/functional/arithmetic.hpp>
-#include <range/v3/functional/compose.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/iterator/unreachable_sentinel.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-numerics
-    /// @{
-
-    /// \cond
-    namespace detail
-    {
-        // Only needed for type-checking purposes:
-        struct as_lvalue_fn
-        {
-            template<typename T>
-            constexpr T & operator()(T && t) const noexcept
-            {
-                return t;
-            }
-        };
-        template<typename I>
-        using as_value_type_t = composed<as_lvalue_fn, coerce<iter_value_t<I>>>;
-    } // namespace detail
-      /// \endcond
-
-    // axiom: BOp is associative over values of I.
-    // clang-format off
-    template(typename I, typename BOp)(
-    concept (indirect_semigroup_)(I, BOp),
-        copyable<iter_value_t<I>> AND
-        indirectly_regular_binary_invocable_<
-            composed<coerce<iter_value_t<I>>, BOp>,
-            iter_value_t<I>*, I>
-    );
-    template<typename I, typename BOp>
-    CPP_concept indirect_semigroup =
-        indirectly_readable<I> &&
-        CPP_concept_ref(ranges::indirect_semigroup_, I, BOp);
-
-    template(typename I, typename O, typename BOp, typename P)(
-    concept (partial_sum_constraints_)(I, O, BOp, P),
-        indirect_semigroup<
-            projected<projected<I, detail::as_value_type_t<I>>, P>,
-            BOp> AND
-        output_iterator<
-            O,
-            iter_value_t<
-                projected<projected<I, detail::as_value_type_t<I>>, P>> const &>
-    );
-    template<typename I, typename O, typename BOp = plus, typename P = identity>
-    CPP_concept partial_sum_constraints =
-        input_iterator<I> &&
-        CPP_concept_ref(ranges::partial_sum_constraints_, I, O, BOp, P);
-    // clang-format on
-
-    template<typename I, typename O>
-    using partial_sum_result = detail::in_out_result<I, O>;
-
-    struct partial_sum_fn
-    {
-        template(typename I, typename S1, typename O, typename S2, typename BOp = plus,
-                 typename P = identity)(
-            /// \pre
-            requires sentinel_for<S1, I> AND sentinel_for<S2, O> AND
-                partial_sum_constraints<I, O, BOp, P>)
-        partial_sum_result<I, O> operator()(I first,
-                                            S1 last,
-                                            O result,
-                                            S2 end_result,
-                                            BOp bop = BOp{},
-                                            P proj = P{}) const
-        {
-            using X = projected<projected<I, detail::as_value_type_t<I>>, P>;
-            coerce<iter_value_t<I>> val_i;
-            coerce<iter_value_t<X>> val_x;
-            if(first != last && result != end_result)
-            {
-                auto && cur1 = val_i(*first);
-                iter_value_t<X> t(invoke(proj, cur1));
-                *result = t;
-                for(++first, ++result; first != last && result != end_result;
-                    ++first, ++result)
-                {
-                    auto && cur2 = val_i(*first);
-                    t = val_x(invoke(bop, t, invoke(proj, cur2)));
-                    *result = t;
-                }
-            }
-            return {first, result};
-        }
-
-        template(typename I, typename S, typename O, typename BOp = plus,
-                 typename P = identity)(
-            /// \pre
-            requires sentinel_for<S, I> AND partial_sum_constraints<I, O, BOp, P>)
-        partial_sum_result<I, O> //
-        operator()(I first, S last, O result, BOp bop = BOp{}, P proj = P{}) const
-        {
-            return (*this)(std::move(first),
-                           std::move(last),
-                           std::move(result),
-                           unreachable,
-                           std::move(bop),
-                           std::move(proj));
-        }
-
-        template(typename Rng, typename ORef, typename BOp = plus, typename P = identity,
-                 typename I = iterator_t<Rng>, typename O = uncvref_t<ORef>)(
-            /// \pre
-            requires range<Rng> AND partial_sum_constraints<I, O, BOp, P>)
-        partial_sum_result<borrowed_iterator_t<Rng>, O> //
-        operator()(Rng && rng, ORef && result, BOp bop = BOp{}, P proj = P{}) const
-        {
-            return (*this)(begin(rng),
-                           end(rng),
-                           static_cast<ORef &&>(result),
-                           std::move(bop),
-                           std::move(proj));
-        }
-
-        template(typename Rng, typename ORng, typename BOp = plus, typename P = identity,
-                 typename I = iterator_t<Rng>, typename O = iterator_t<ORng>)(
-            /// \pre
-            requires range<Rng> AND range<ORng> AND partial_sum_constraints<I, O, BOp, P>)
-        partial_sum_result<borrowed_iterator_t<Rng>, borrowed_iterator_t<ORng>> //
-        operator()(Rng && rng, ORng && result, BOp bop = BOp{}, P proj = P{}) const
-        {
-            return (*this)(begin(rng),
-                           end(rng),
-                           begin(result),
-                           end(result),
-                           std::move(bop),
-                           std::move(proj));
-        }
-    };
-
-    RANGES_INLINE_VARIABLE(partial_sum_fn, partial_sum)
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/range.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/range.hpp
deleted file mode 100644
index 1a256b22..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/range.hpp
+++ /dev/null
@@ -1,25 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2019-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ITERATOR_HPP
-#define RANGES_V3_ITERATOR_HPP
-
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/conversion.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/range/operations.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/range/traits.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/range/access.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/range/access.hpp
deleted file mode 100644
index 34cc949b..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/range/access.hpp
+++ /dev/null
@@ -1,724 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_RANGE_ACCESS_HPP
-#define RANGES_V3_RANGE_ACCESS_HPP
-
-#include <functional> // for reference_wrapper (whose use with begin/end is deprecated)
-#include <initializer_list>
-#include <iterator>
-#include <limits>
-#include <utility>
-
-#ifdef __has_include
-#if __has_include(<span>)
-#include <span>
-#endif
-#if __has_include(<string_view>)
-#include <string_view>
-#endif
-#endif
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/reverse_iterator.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-#if defined(__cpp_lib_string_view) && __cpp_lib_string_view > 0
-    template<class CharT, class Traits>
-    RANGES_INLINE_VAR constexpr bool
-        enable_borrowed_range<std::basic_string_view<CharT, Traits>> = true;
-#endif
-
-#if defined(__cpp_lib_span) && __cpp_lib_span > 0
-    template<class T, std::size_t N>
-    RANGES_INLINE_VAR constexpr bool enable_borrowed_range<std::span<T, N>> = true;
-#endif
-
-    namespace detail
-    {
-        template<typename T>
-        RANGES_INLINE_VAR constexpr bool _borrowed_range =
-            enable_borrowed_range<uncvref_t<T>>;
-
-        template<typename T>
-        RANGES_INLINE_VAR constexpr bool _borrowed_range<T &> = true;
-    } // namespace detail
-
-    /// \cond
-    namespace _begin_
-    {
-        // Poison pill for std::begin. (See the detailed discussion at
-        // https://github.com/ericniebler/stl2/issues/139)
-        template<typename T>
-        void begin(T &&) = delete;
-
-#ifdef RANGES_WORKAROUND_MSVC_895622
-        void begin();
-#endif
-
-        template<typename T>
-        void begin(std::initializer_list<T>) = delete;
-
-        template(typename I)(
-            /// \pre
-            requires input_or_output_iterator<I>)
-        void is_iterator(I);
-
-        // clang-format off
-        template<typename T>
-        CPP_requires(has_member_begin_,
-            requires(T & t) //
-            (
-                _begin_::is_iterator(t.begin())
-            ));
-        template<typename T>
-        CPP_concept has_member_begin =
-            CPP_requires_ref(_begin_::has_member_begin_, T);
-
-        template<typename T>
-        CPP_requires(has_non_member_begin_,
-            requires(T & t) //
-            (
-                _begin_::is_iterator(begin(t))
-            ));
-        template<typename T>
-        CPP_concept has_non_member_begin =
-            CPP_requires_ref(_begin_::has_non_member_begin_, T);
-        // clang-format on
-
-        struct fn
-        {
-        private:
-            template<bool>
-            struct impl_
-            {
-                // has_member_begin == true
-                template<typename R>
-                static constexpr auto invoke(R && r) noexcept(noexcept(r.begin()))
-                {
-                    return r.begin();
-                }
-            };
-
-            template<typename R>
-            using impl = impl_<has_member_begin<R>>;
-
-        public:
-            template<typename R, std::size_t N>
-            void operator()(R(&&)[N]) const = delete;
-
-            template<typename R, std::size_t N>
-            constexpr R * operator()(R (&array)[N]) const noexcept
-            {
-                return array;
-            }
-
-            template(typename R)(
-                /// \pre
-                requires detail::_borrowed_range<R> AND
-                    (has_member_begin<R> || has_non_member_begin<R>))
-            constexpr auto operator()(R && r) const //
-                noexcept(noexcept(impl<R>::invoke(r)))
-            {
-                return impl<R>::invoke(r);
-            }
-
-            template<typename T, typename Fn = fn>
-            RANGES_DEPRECATED(
-                "Using a reference_wrapper as a range is deprecated. Use views::ref "
-                "instead.")
-            constexpr auto
-            operator()(std::reference_wrapper<T> ref) const
-                noexcept(noexcept(Fn{}(ref.get()))) -> decltype(Fn{}(ref.get()))
-            {
-                return Fn{}(ref.get());
-            }
-
-            template<typename T, typename Fn = fn>
-            RANGES_DEPRECATED(
-                "Using a reference_wrapper as a range is deprecated. Use views::ref "
-                "instead.")
-            constexpr auto
-            operator()(ranges::reference_wrapper<T> ref) const
-                noexcept(noexcept(Fn{}(ref.get()))) -> decltype(Fn{}(ref.get()))
-            {
-                return Fn{}(ref.get());
-            }
-        };
-
-        template<>
-        struct fn::impl_<false>
-        {
-            // has_member_begin == false
-            template<typename R>
-            static constexpr auto invoke(R && r) noexcept(noexcept(begin(r)))
-            {
-                return begin(r);
-            }
-        };
-
-        template<typename R>
-        using _t = decltype(fn{}(std::declval<R>()));
-    } // namespace _begin_
-    /// \endcond
-
-    /// \ingroup group-range
-    /// \param r
-    /// \return \c r, if \c r is an array. Otherwise, `r.begin()` if that expression is
-    ///   well-formed and returns an input_or_output_iterator. Otherwise, `begin(r)` if
-    ///   that expression returns an input_or_output_iterator.
-    RANGES_DEFINE_CPO(_begin_::fn, begin)
-
-    /// \cond
-    namespace _end_
-    {
-        // Poison pill for std::end. (See the detailed discussion at
-        // https://github.com/ericniebler/stl2/issues/139)
-        template<typename T>
-        void end(T &&) = delete;
-
-#ifdef RANGES_WORKAROUND_MSVC_895622
-        void end();
-#endif
-
-        template<typename T>
-        void end(std::initializer_list<T>) = delete;
-
-        template(typename I, typename S)(
-            /// \pre
-            requires sentinel_for<S, I>)
-        void _is_sentinel(S, I);
-
-        // clang-format off
-        template<typename T>
-        CPP_requires(has_member_end_,
-            requires(T & t) //
-            (
-                _end_::_is_sentinel(t.end(), ranges::begin(t))
-            ));
-        template<typename T>
-        CPP_concept has_member_end =
-            CPP_requires_ref(_end_::has_member_end_, T);
-
-        template<typename T>
-        CPP_requires(has_non_member_end_,
-            requires(T & t) //
-            (
-                _end_::_is_sentinel(end(t), ranges::begin(t))
-            ));
-        template<typename T>
-        CPP_concept has_non_member_end =
-            CPP_requires_ref(_end_::has_non_member_end_, T);
-        // clang-format on
-
-        struct fn
-        {
-        private:
-            template<bool>
-            struct impl_
-            {
-                // has_member_end == true
-                template<typename R>
-                static constexpr auto invoke(R && r) noexcept(noexcept(r.end()))
-                {
-                    return r.end();
-                }
-            };
-
-            template<typename Int>
-            using iter_diff_t =
-                meta::_t<meta::conditional_t<std::is_integral<Int>::value,
-                                             std::make_signed<Int>, //
-                                             meta::id<Int>>>;
-
-            template<typename R>
-            using impl = impl_<has_member_end<R>>;
-
-        public:
-            template<typename R, std::size_t N>
-            void operator()(R(&&)[N]) const = delete;
-
-            template<typename R, std::size_t N>
-            constexpr R * operator()(R (&array)[N]) const noexcept
-            {
-                return array + N;
-            }
-
-            template(typename R)(
-                /// \pre
-                requires detail::_borrowed_range<R> AND
-                    (has_member_end<R> || has_non_member_end<R>))
-            constexpr auto operator()(R && r) const //
-                noexcept(noexcept(impl<R>::invoke(r))) //
-            {
-                return impl<R>::invoke(r);
-            }
-
-            template<typename T, typename Fn = fn>
-            RANGES_DEPRECATED(
-                "Using a reference_wrapper as a range is deprecated. Use views::ref "
-                "instead.")
-            constexpr auto
-            operator()(std::reference_wrapper<T> ref) const
-                noexcept(noexcept(Fn{}(ref.get()))) -> decltype(Fn{}(ref.get()))
-            {
-                return Fn{}(ref.get());
-            }
-
-            template<typename T, typename Fn = fn>
-            RANGES_DEPRECATED(
-                "Using a reference_wrapper as a range is deprecated. Use views::ref "
-                "instead.")
-            constexpr auto
-            operator()(ranges::reference_wrapper<T> ref) const
-                noexcept(noexcept(Fn{}(ref.get()))) -> decltype(Fn{}(ref.get()))
-            {
-                return Fn{}(ref.get());
-            }
-
-            template(typename Int)(
-                /// \pre
-                requires detail::integer_like_<Int>)
-            auto operator-(Int dist) const
-                -> detail::from_end_<iter_diff_t<Int>>
-            {
-                using SInt = iter_diff_t<Int>;
-                RANGES_EXPECT(0 <= dist);
-                RANGES_EXPECT(dist <=
-                              static_cast<Int>((std::numeric_limits<SInt>::max)()));
-                return detail::from_end_<SInt>{-static_cast<SInt>(dist)};
-            }
-        };
-
-        // has_member_end == false
-        template<>
-        struct fn::impl_<false>
-        {
-            template<typename R>
-            static constexpr auto invoke(R && r) noexcept(noexcept(end(r)))
-            {
-                return end(r);
-            }
-        };
-
-        template<typename R>
-        using _t = decltype(fn{}(std::declval<R>()));
-    } // namespace _end_
-    /// \endcond
-
-    /// \ingroup group-range
-    /// \param r
-    /// \return \c r+size(r), if \c r is an array. Otherwise, `r.end()` if that expression
-    /// is
-    ///   well-formed and returns an input_or_output_iterator. Otherwise, `end(r)` if that
-    ///   expression returns an input_or_output_iterator.
-    RANGES_DEFINE_CPO(_end_::fn, end)
-
-    /// \cond
-    namespace _cbegin_
-    {
-        struct fn
-        {
-            template<typename R>
-            constexpr _begin_::_t<detail::as_const_t<R>> operator()(R && r) const
-                noexcept(noexcept(ranges::begin(detail::as_const(r))))
-            {
-                return ranges::begin(detail::as_const(r));
-            }
-        };
-    } // namespace _cbegin_
-    /// \endcond
-
-    /// \ingroup group-range
-    /// \param r
-    /// \return The result of calling `ranges::begin` with a const-qualified
-    ///    reference to r.
-    RANGES_INLINE_VARIABLE(_cbegin_::fn, cbegin)
-
-    /// \cond
-    namespace _cend_
-    {
-        struct fn
-        {
-            template<typename R>
-            constexpr _end_::_t<detail::as_const_t<R>> operator()(R && r) const
-                noexcept(noexcept(ranges::end(detail::as_const(r))))
-            {
-                return ranges::end(detail::as_const(r));
-            }
-        };
-    } // namespace _cend_
-    /// \endcond
-
-    /// \ingroup group-range
-    /// \param r
-    /// \return The result of calling `ranges::end` with a const-qualified
-    ///    reference to r.
-    RANGES_INLINE_VARIABLE(_cend_::fn, cend)
-
-    /// \cond
-    namespace _rbegin_
-    {
-        template<typename R>
-        void rbegin(R &&) = delete;
-        // Non-standard, to keep unqualified rbegin(r) from finding std::rbegin
-        // and returning a std::reverse_iterator.
-        template<typename T>
-        void rbegin(std::initializer_list<T>) = delete;
-        template<typename T, std::size_t N>
-        void rbegin(T (&)[N]) = delete;
-
-        // clang-format off
-        template<typename T>
-        CPP_requires(has_member_rbegin_,
-            requires(T & t) //
-            (
-                _begin_::is_iterator(t.rbegin())
-            ));
-        template<typename T>
-        CPP_concept has_member_rbegin =
-            CPP_requires_ref(_rbegin_::has_member_rbegin_, T);
-
-        template<typename T>
-        CPP_requires(has_non_member_rbegin_,
-            requires(T & t) //
-            (
-                _begin_::is_iterator(rbegin(t))
-            ));
-        template<typename T>
-        CPP_concept has_non_member_rbegin =
-            CPP_requires_ref(_rbegin_::has_non_member_rbegin_, T);
-
-        template<typename I>
-        void _same_type(I, I);
-
-        template<typename T>
-        CPP_requires(can_reverse_end_,
-            requires(T & t) //
-            (
-                // make_reverse_iterator is constrained with
-                // bidirectional_iterator.
-                ranges::make_reverse_iterator(ranges::end(t)),
-                _rbegin_::_same_type(ranges::begin(t), ranges::end(t))
-            ));
-        template<typename T>
-        CPP_concept can_reverse_end =
-            CPP_requires_ref(_rbegin_::can_reverse_end_, T);
-        // clang-format on
-
-        struct fn
-        {
-        private:
-            // has_member_rbegin == true
-            template<int>
-            struct impl_
-            {
-                template<typename R>
-                static constexpr auto invoke(R && r) noexcept(noexcept(r.rbegin()))
-                {
-                    return r.rbegin();
-                }
-            };
-
-            template<typename R>
-            using impl =
-                impl_<has_member_rbegin<R> ? 0 : has_non_member_rbegin<R> ? 1 : 2>;
-
-        public:
-            template(typename R)(
-                /// \pre
-                requires detail::_borrowed_range<R> AND
-                    (has_member_rbegin<R> ||
-                     has_non_member_rbegin<R> ||
-                     can_reverse_end<R>)) //
-            constexpr auto operator()(R && r) const //
-                noexcept(noexcept(impl<R>::invoke(r))) //
-            {
-                return impl<R>::invoke(r);
-            }
-
-            template<typename T, typename Fn = fn>
-            RANGES_DEPRECATED(
-                "Using a reference_wrapper as a range is deprecated. Use views::ref "
-                "instead.")
-            constexpr auto operator()(std::reference_wrapper<T> ref) const //
-                noexcept(noexcept(Fn{}(ref.get()))) //
-                -> decltype(Fn{}(ref.get()))
-            {
-                return Fn{}(ref.get());
-            }
-
-            template<typename T, typename Fn = fn>
-            RANGES_DEPRECATED(
-                "Using a reference_wrapper as a range is deprecated. Use views::ref "
-                "instead.")
-            constexpr auto
-            operator()(ranges::reference_wrapper<T> ref) const
-                noexcept(noexcept(Fn{}(ref.get()))) //
-                -> decltype(Fn{}(ref.get()))
-            {
-                return Fn{}(ref.get());
-            }
-        };
-
-        // has_non_member_rbegin == true
-        template<>
-        struct fn::impl_<1>
-        {
-            template<typename R>
-            static constexpr auto invoke(R && r) noexcept(noexcept(rbegin(r)))
-            {
-                return rbegin(r);
-            }
-        };
-
-        // can_reverse_end
-        template<>
-        struct fn::impl_<2>
-        {
-            template<typename R>
-            static constexpr auto invoke(R && r)
-                noexcept(noexcept(ranges::make_reverse_iterator(ranges::end(r))))
-            {
-                return ranges::make_reverse_iterator(ranges::end(r));
-            }
-        };
-
-        template<typename R>
-        using _t = decltype(fn{}(std::declval<R>()));
-    } // namespace _rbegin_
-    /// \endcond
-
-    /// \ingroup group-range
-    /// \param r
-    /// \return `make_reverse_iterator(r + ranges::size(r))` if r is an array. Otherwise,
-    ///   `r.rbegin()` if that expression is well-formed and returns an
-    ///   input_or_output_iterator. Otherwise, `make_reverse_iterator(ranges::end(r))` if
-    ///   `ranges::begin(r)` and `ranges::end(r)` are both well-formed and have the same
-    ///   type that satisfies `bidirectional_iterator`.
-    RANGES_DEFINE_CPO(_rbegin_::fn, rbegin)
-
-    /// \cond
-    namespace _rend_
-    {
-        template<typename R>
-        void rend(R &&) = delete;
-        // Non-standard, to keep unqualified rend(r) from finding std::rend
-        // and returning a std::reverse_iterator.
-        template<typename T>
-        void rend(std::initializer_list<T>) = delete;
-        template<typename T, std::size_t N>
-        void rend(T (&)[N]) = delete;
-
-        // clang-format off
-        template<typename T>
-        CPP_requires(has_member_rend_,
-            requires(T & t) //
-            (
-                _end_::_is_sentinel(t.rend(), ranges::rbegin(t))
-            ));
-        template<typename T>
-        CPP_concept has_member_rend =
-            CPP_requires_ref(_rend_::has_member_rend_, T);
-
-        template<typename T>
-        CPP_requires(has_non_member_rend_,
-            requires(T & t) //
-            (
-                _end_::_is_sentinel(rend(t), ranges::rbegin(t))
-            ));
-        template<typename T>
-        CPP_concept has_non_member_rend =
-            CPP_requires_ref(_rend_::has_non_member_rend_, T);
-
-        template<typename T>
-        CPP_requires(can_reverse_begin_,
-            requires(T & t) //
-            (
-                // make_reverse_iterator is constrained with
-                // bidirectional_iterator.
-                ranges::make_reverse_iterator(ranges::begin(t)),
-                _rbegin_::_same_type(ranges::begin(t), ranges::end(t))
-            ));
-        template<typename T>
-        CPP_concept can_reverse_begin =
-            CPP_requires_ref(_rend_::can_reverse_begin_, T);
-        // clang-format on
-
-        struct fn
-        {
-        private:
-            // has_member_rbegin == true
-            template<int>
-            struct impl_
-            {
-                template<typename R>
-                static constexpr auto invoke(R && r) noexcept(noexcept(r.rend()))
-                {
-                    return r.rend();
-                }
-            };
-
-            template<typename R>
-            using impl = impl_<has_member_rend<R> ? 0 : has_non_member_rend<R> ? 1 : 2>;
-
-        public:
-            template(typename R)(
-                /// \pre
-                requires detail::_borrowed_range<R> AND
-                    (has_member_rend<R> || //
-                     has_non_member_rend<R> || //
-                     can_reverse_begin<R>)) //
-            constexpr auto operator()(R && r) const
-                noexcept(noexcept(impl<R>::invoke(r))) //
-            {
-                return impl<R>::invoke(r);
-            }
-
-            template<typename T, typename Fn = fn>
-            RANGES_DEPRECATED(
-                "Using a reference_wrapper as a range is deprecated. Use views::ref "
-                "instead.")
-            constexpr auto operator()(std::reference_wrapper<T> ref) const
-                noexcept(noexcept(Fn{}(ref.get()))) //
-                -> decltype(Fn{}(ref.get()))
-            {
-                return Fn{}(ref.get());
-            }
-
-            template<typename T, typename Fn = fn>
-            RANGES_DEPRECATED(
-                "Using a reference_wrapper as a range is deprecated. Use views::ref "
-                "instead.")
-            constexpr auto operator()(ranges::reference_wrapper<T> ref) const
-                noexcept(noexcept(Fn{}(ref.get()))) //
-                -> decltype(Fn{}(ref.get()))
-            {
-                return Fn{}(ref.get());
-            }
-        };
-
-        // has_non_member_rend == true
-        template<>
-        struct fn::impl_<1>
-        {
-            template<typename R>
-            static constexpr auto invoke(R && r) noexcept(noexcept(rend(r)))
-            {
-                return rend(r);
-            }
-        };
-
-        // can_reverse_begin
-        template<>
-        struct fn::impl_<2>
-        {
-            template<typename R>
-            static constexpr auto invoke(R && r)
-                noexcept(noexcept(ranges::make_reverse_iterator(ranges::begin(r))))
-            {
-                return ranges::make_reverse_iterator(ranges::begin(r));
-            }
-        };
-
-        template<typename R>
-        using _t = decltype(fn{}(std::declval<R>()));
-    } // namespace _rend_
-    /// \endcond
-
-    /// \ingroup group-range
-    /// \param r
-    /// \return `make_reverse_iterator(r)` if `r` is an array. Otherwise,
-    ///   `r.rend()` if that expression is well-formed and returns a type that
-    ///   satisfies `sentinel_for<S, I>` where `I` is the type of `ranges::rbegin(r)`.
-    ///   Otherwise, `make_reverse_iterator(ranges::begin(r))` if `ranges::begin(r)`
-    ///   and `ranges::end(r)` are both well-formed and have the same type that
-    ///   satisfies `bidirectional_iterator`.
-    RANGES_DEFINE_CPO(_rend_::fn, rend)
-
-    /// \cond
-    namespace _crbegin_
-    {
-        struct fn
-        {
-            template<typename R>
-            constexpr _rbegin_::_t<detail::as_const_t<R>> operator()(R && r) const
-                noexcept(noexcept(ranges::rbegin(detail::as_const(r))))
-            {
-                return ranges::rbegin(detail::as_const(r));
-            }
-        };
-    } // namespace _crbegin_
-    /// \endcond
-
-    /// \ingroup group-range
-    /// \param r
-    /// \return The result of calling `ranges::rbegin` with a const-qualified
-    ///    reference to r.
-    RANGES_INLINE_VARIABLE(_crbegin_::fn, crbegin)
-
-    /// \cond
-    namespace _crend_
-    {
-        struct fn
-        {
-            template<typename R>
-            constexpr _rend_::_t<detail::as_const_t<R>> operator()(R && r) const
-                noexcept(noexcept(ranges::rend(detail::as_const(r))))
-            {
-                return ranges::rend(detail::as_const(r));
-            }
-        };
-    } // namespace _crend_
-    /// \endcond
-
-    /// \ingroup group-range
-    /// \param r
-    /// \return The result of calling `ranges::rend` with a const-qualified
-    ///    reference to r.
-    RANGES_INLINE_VARIABLE(_crend_::fn, crend)
-
-    template<typename Rng>
-    using iterator_t = decltype(begin(std::declval<Rng &>()));
-
-    template<typename Rng>
-    using sentinel_t = decltype(end(std::declval<Rng &>()));
-
-    namespace cpp20
-    {
-        using ranges::begin;
-        using ranges::cbegin;
-        using ranges::cend;
-        using ranges::crbegin;
-        using ranges::crend;
-        using ranges::end;
-        using ranges::rbegin;
-        using ranges::rend;
-
-        using ranges::iterator_t;
-        using ranges::sentinel_t;
-
-        using ranges::enable_borrowed_range;
-    } // namespace cpp20
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/range/concepts.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/range/concepts.hpp
deleted file mode 100644
index 6f8e1305..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/range/concepts.hpp
+++ /dev/null
@@ -1,306 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_RANGE_CONCEPTS_HPP
-#define RANGES_V3_RANGE_CONCEPTS_HPP
-
-#include <initializer_list>
-#include <type_traits>
-#include <utility>
-
-#ifdef __has_include
-#if __has_include(<span>)
-#include <span>
-#endif
-#if __has_include(<string_view>)
-#include <string_view>
-#endif
-#endif
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/range/traits.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-range
-    /// @{
-
-    ///
-    /// Range concepts below
-    ///
-
-    // clang-format off
-    template<typename T>
-    CPP_requires(_range_,
-        requires(T & t) //
-        (
-            ranges::begin(t), // not necessarily equality-preserving
-            ranges::end(t)
-        ));
-    template<typename T>
-    CPP_concept range =
-        CPP_requires_ref(ranges::_range_, T);
-
-    template<typename T>
-    CPP_concept borrowed_range =
-        range<T> && detail::_borrowed_range<T>;
-
-    template <typename R>
-    RANGES_DEPRECATED("Please use ranges::borrowed_range instead.")
-    RANGES_INLINE_VAR constexpr bool safe_range = borrowed_range<R>;
-
-    template(typename T, typename V)(
-    concept (output_range_)(T, V),
-        output_iterator<iterator_t<T>, V>
-    );
-    template<typename T, typename V>
-    CPP_concept output_range =
-        range<T> && CPP_concept_ref(ranges::output_range_, T, V);
-
-    template(typename T)(
-    concept (input_range_)(T),
-        input_iterator<iterator_t<T>>
-    );
-    template<typename T>
-    CPP_concept input_range =
-        range<T> && CPP_concept_ref(ranges::input_range_, T);
-
-    template(typename T)(
-    concept (forward_range_)(T),
-        forward_iterator<iterator_t<T>>
-    );
-    template<typename T>
-    CPP_concept forward_range =
-        input_range<T> && CPP_concept_ref(ranges::forward_range_, T);
-
-    template(typename T)(
-    concept (bidirectional_range_)(T),
-        bidirectional_iterator<iterator_t<T>>
-    );
-    template<typename T>
-    CPP_concept bidirectional_range =
-        forward_range<T> && CPP_concept_ref(ranges::bidirectional_range_, T);
-
-    template(typename T)(
-    concept (random_access_range_)(T),
-        random_access_iterator<iterator_t<T>>
-    );
-
-    template<typename T>
-    CPP_concept random_access_range =
-        bidirectional_range<T> && CPP_concept_ref(ranges::random_access_range_, T);
-    // clang-format on
-
-    /// \cond
-    namespace detail
-    {
-        template<typename Rng>
-        using data_t = decltype(ranges::data(std::declval<Rng &>()));
-
-        template<typename Rng>
-        using element_t = meta::_t<std::remove_pointer<data_t<Rng>>>;
-    } // namespace detail
-      /// \endcond
-
-    // clang-format off
-    template(typename T)(
-    concept (contiguous_range_)(T),
-        contiguous_iterator<iterator_t<T>> AND
-        same_as<detail::data_t<T>, std::add_pointer_t<iter_reference_t<iterator_t<T>>>>
-    );
-
-    template<typename T>
-    CPP_concept contiguous_range =
-        random_access_range<T> && CPP_concept_ref(ranges::contiguous_range_, T);
-
-    template(typename T)(
-    concept (common_range_)(T),
-        same_as<iterator_t<T>, sentinel_t<T>>
-    );
-
-    template<typename T>
-    CPP_concept common_range =
-        range<T> && CPP_concept_ref(ranges::common_range_, T);
-
-    /// \cond
-    template<typename T>
-    CPP_concept bounded_range =
-        common_range<T>;
-    /// \endcond
-
-    template<typename T>
-    CPP_requires(sized_range_,
-        requires(T & t) //
-        (
-            ranges::size(t)
-        ));
-    template(typename T)(
-    concept (sized_range_)(T),
-        detail::integer_like_<range_size_t<T>>);
-
-    template<typename T>
-    CPP_concept sized_range =
-        range<T> &&
-        !disable_sized_range<uncvref_t<T>> &&
-        CPP_requires_ref(ranges::sized_range_, T) &&
-        CPP_concept_ref(ranges::sized_range_, T);
-    // clang-format on
-
-    /// \cond
-    namespace ext
-    {
-        template<typename T>
-        struct enable_view
-          : std::is_base_of<view_base, T>
-        {};
-    } // namespace detail
-    /// \endcond
-
-    // Specialize this if the default is wrong.
-    template<typename T>
-    RANGES_INLINE_VAR constexpr bool enable_view =
-        ext::enable_view<T>::value;
-
-#if defined(__cpp_lib_string_view) && __cpp_lib_string_view > 0
-    template<typename Char, typename Traits>
-    RANGES_INLINE_VAR constexpr bool enable_view<std::basic_string_view<Char, Traits>> =
-        true;
-#endif
-
-#if defined(__cpp_lib_span) && __cpp_lib_span > 0
-    template<typename T, std::size_t N>
-    RANGES_INLINE_VAR constexpr bool enable_view<std::span<T, N>> = N + 1 < 2;
-#endif
-
-    ///
-    /// View concepts below
-    ///
-
-    // clang-format off
-    template<typename T>
-    CPP_concept view_ =
-        range<T> &&
-        semiregular<T> &&
-        enable_view<T>;
-
-    template<typename T>
-    CPP_concept viewable_range =
-        range<T> &&
-        (borrowed_range<T> || view_<uncvref_t<T>>);
-    // clang-format on
-
-    //////////////////////////////////////////////////////////////////////////////////////
-    // range_tag
-    struct range_tag
-    {};
-
-    struct input_range_tag : range_tag
-    {};
-    struct forward_range_tag : input_range_tag
-    {};
-    struct bidirectional_range_tag : forward_range_tag
-    {};
-    struct random_access_range_tag : bidirectional_range_tag
-    {};
-    struct contiguous_range_tag : random_access_range_tag
-    {};
-
-    template<typename Rng>
-    using range_tag_of =                          //
-        std::enable_if_t<                         //
-            range<Rng>,                           //
-            meta::conditional_t<                    //
-                contiguous_range<Rng>,            //
-                contiguous_range_tag,             //
-                meta::conditional_t<                //
-                    random_access_range<Rng>,     //
-                    random_access_range_tag,      //
-                    meta::conditional_t<            //
-                        bidirectional_range<Rng>, //
-                        bidirectional_range_tag,  //
-                        meta::conditional_t<        //
-                            forward_range<Rng>,   //
-                            forward_range_tag,    //
-                            meta::conditional_t<    //
-                                input_range<Rng>, //
-                                input_range_tag,  //
-                                range_tag>>>>>>;
-
-    //////////////////////////////////////////////////////////////////////////////////////
-    // common_range_tag_of
-    struct common_range_tag : range_tag
-    {};
-
-    template<typename Rng>
-    using common_range_tag_of = //
-        std::enable_if_t<       //
-            range<Rng>,         //
-            meta::conditional_t<common_range<Rng>, common_range_tag, range_tag>>;
-
-    //////////////////////////////////////////////////////////////////////////////////////
-    // sized_range_concept
-    struct sized_range_tag : range_tag
-    {};
-
-    template<typename Rng>
-    using sized_range_tag_of = //
-        std::enable_if_t<      //
-            range<Rng>,        //
-            meta::conditional_t<sized_range<Rng>, sized_range_tag, range_tag>>;
-
-    /// \cond
-    namespace view_detail_
-    {
-        // clang-format off
-        template<typename T>
-        CPP_concept view =
-            ranges::view_<T>;
-        // clang-format on
-    } // namespace view_detail_
-    /// \endcond
-
-    namespace cpp20
-    {
-        using ranges::borrowed_range;
-        using ranges::bidirectional_range;
-        using ranges::common_range;
-        using ranges::contiguous_range;
-        using ranges::enable_view;
-        using ranges::forward_range;
-        using ranges::input_range;
-        using ranges::output_range;
-        using ranges::random_access_range;
-        using ranges::range;
-        using ranges::sized_range;
-        using ranges::viewable_range;
-        using ranges::view_detail_::view;
-        using ranges::view_base;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/range/conversion.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/range/conversion.hpp
deleted file mode 100644
index 376504de..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/range/conversion.hpp
+++ /dev/null
@@ -1,530 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_RANGE_CONVERSION_HPP
-#define RANGES_V3_RANGE_CONVERSION_HPP
-
-#include <vector>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/action/concepts.hpp>
-#include <range/v3/functional/pipeable.hpp>
-#include <range/v3/iterator/common_iterator.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        struct to_container
-        {
-            template<typename MetaFn>
-            struct fn;
-
-            template<typename MetaFn, typename Fn>
-            struct closure;
-
-            template<typename MetaFn, typename Rng>
-            using container_t = meta::invoke<MetaFn, Rng>;
-
-            template<typename Rng, typename MetaFn>
-            friend auto operator|(Rng && rng,
-                                  closure<MetaFn, fn<MetaFn>> (*)(to_container))
-                -> CPP_broken_friend_ret(container_t<MetaFn, Rng>)(
-                    /// \pre
-                    requires invocable<fn<MetaFn>, Rng>)
-            {
-                return fn<MetaFn>{}(static_cast<Rng &&>(rng));
-            }
-
-            template<typename MetaFn, typename Pipeable>
-            friend auto operator|(closure<MetaFn, fn<MetaFn>> (*)(to_container),
-                                  Pipeable pipe)
-                -> CPP_broken_friend_ret(
-                    closure<MetaFn, composed<Pipeable, fn<MetaFn>>>)(
-                    /// \pre
-                    requires (is_pipeable_v<Pipeable>))
-            {
-                return closure<MetaFn, composed<Pipeable, fn<MetaFn>>>{
-                    compose(static_cast<Pipeable &&>(pipe), fn<MetaFn>{})};
-            }
-        };
-
-        // A simple, light-weight transform iterator that applies ranges::to
-        // to each element in the range. Used by ranges::to to convert a range
-        // of ranges into a container of containers.
-        template<typename Rng, typename Cont>
-        struct to_container_iterator
-        {
-        private:
-            using I = range_cpp17_iterator_t<Rng>;
-            using ValueType = range_value_t<Cont>;
-            I it_;
-
-        public:
-            using difference_type = typename std::iterator_traits<I>::difference_type;
-            using value_type = ValueType;
-            using reference = ValueType;
-            using pointer = typename std::iterator_traits<I>::pointer;
-            using iterator_category = typename std::iterator_traits<I>::iterator_category;
-
-            to_container_iterator() = default;
-            template<typename OtherIt>
-            to_container_iterator(OtherIt it)
-              : it_(std::move(it))
-            {}
-            friend bool operator==(to_container_iterator const & a,
-                                   to_container_iterator const & b)
-            {
-                return a.it_ == b.it_;
-            }
-            friend bool operator!=(to_container_iterator const & a,
-                                   to_container_iterator const & b)
-            {
-                return !(a == b);
-            }
-            reference operator*() const
-            {
-                return to_container::fn<meta::id<ValueType>>{}(*it_);
-            }
-            to_container_iterator & operator++()
-            {
-                ++it_;
-                return *this;
-            }
-            to_container_iterator operator++(int)
-            {
-                auto tmp = *this;
-                ++it_;
-                return tmp;
-            }
-            CPP_member
-            auto operator--() //
-                -> CPP_ret(to_container_iterator &)(
-                    /// \pre
-                    requires derived_from<iterator_category,
-                                          std::bidirectional_iterator_tag>)
-            {
-                --it_;
-                return *this;
-            }
-            CPP_member
-            auto operator--(int) //
-                -> CPP_ret(to_container_iterator &)(
-                    /// \pre
-                    requires derived_from<iterator_category,
-                                          std::bidirectional_iterator_tag>)
-            {
-                auto tmp = *this;
-                ++it_;
-                return tmp;
-            }
-            CPP_member
-            auto operator+=(difference_type n) //
-                -> CPP_ret(to_container_iterator &)(
-                    /// \pre
-                    requires derived_from<iterator_category,
-                                          std::random_access_iterator_tag>)
-            {
-                it_ += n;
-                return *this;
-            }
-            CPP_member
-            auto operator-=(difference_type n) //
-                -> CPP_ret(to_container_iterator &)(
-                    /// \pre
-                    requires derived_from<iterator_category,
-                                          std::random_access_iterator_tag>)
-            {
-                it_ -= n;
-                return *this;
-            }
-            CPP_broken_friend_member
-            friend auto operator+(to_container_iterator i, difference_type n) //
-                -> CPP_broken_friend_ret(to_container_iterator)(
-                    /// \pre
-                    requires derived_from<iterator_category,
-                                          std::random_access_iterator_tag>)
-            {
-                return i += n;
-            }
-            CPP_broken_friend_member
-            friend auto operator-(to_container_iterator i, difference_type n) //
-                -> CPP_broken_friend_ret(to_container_iterator)(
-                    /// \pre
-                    requires derived_from<iterator_category,
-                                          std::random_access_iterator_tag>)
-            {
-                return i -= n;
-            }
-            CPP_broken_friend_member
-            friend auto operator-(difference_type n, to_container_iterator i) //
-                -> CPP_broken_friend_ret(to_container_iterator)(
-                    /// \pre
-                    requires derived_from<iterator_category,
-                                          std::random_access_iterator_tag>)
-            {
-                return i -= n;
-            }
-            CPP_broken_friend_member
-            friend auto operator-(to_container_iterator const & i,
-                                  to_container_iterator const & j) //
-                -> CPP_broken_friend_ret(difference_type)(
-                    /// \pre
-                    requires derived_from<iterator_category,
-                                          std::random_access_iterator_tag>)
-            {
-                return i.it_ - j.it_;
-            }
-            CPP_member
-            auto operator[](difference_type n) const //
-                -> CPP_ret(reference)(
-                    /// \pre
-                    requires derived_from<iterator_category,
-                                          std::random_access_iterator_tag>)
-            {
-                return *(*this + n);
-            }
-        };
-
-        template<typename Rng, typename Cont>
-        using to_container_iterator_t =
-            enable_if_t<(bool)range<Rng>, to_container_iterator<Rng, Cont>>;
-
-        // clang-format off
-        template(typename Rng)(
-        concept (range_and_not_view_)(Rng),
-            range<Rng> AND (!view_<Rng>));
-
-        template<typename Rng>
-        CPP_concept range_and_not_view =
-            CPP_concept_ref(range_and_not_view_, Rng);
-
-        template(typename Rng, typename Cont)(
-        concept (convertible_to_cont_impl_)(Rng, Cont),
-            constructible_from<range_value_t<Cont>, range_reference_t<Rng>> AND
-            constructible_from<
-                Cont,
-                range_cpp17_iterator_t<Rng>,
-                range_cpp17_iterator_t<Rng>>
-        );
-        template<typename Rng, typename Cont>
-        CPP_concept convertible_to_cont = //
-            range_and_not_view<Cont> && //
-            move_constructible<Cont> && //
-            CPP_concept_ref(detail::convertible_to_cont_impl_, Rng, Cont);
-
-        template(typename Rng, typename Cont)(
-        concept (convertible_to_cont_cont_impl_)(Rng, Cont),
-            range_and_not_view<range_value_t<Cont>> AND
-            // Test that each element of the input range can be ranges::to<>
-            // to the output container.
-            invocable<
-                to_container::fn<meta::id<range_value_t<Cont>>>,
-                range_reference_t<Rng>> AND
-            constructible_from<
-                Cont,
-                to_container_iterator_t<Rng, Cont>,
-                to_container_iterator_t<Rng, Cont>>
-        );
-        template<typename Rng, typename Cont>
-        CPP_concept convertible_to_cont_cont = //
-            range<Cont> && //
-            (!view_<Cont>) && //
-            move_constructible<Cont> && //
-            CPP_concept_ref(detail::convertible_to_cont_cont_impl_, Rng, Cont);
-
-        template<typename C, typename I, typename R>
-        CPP_concept to_container_reserve = //
-            reservable_with_assign<C, I> && //
-            sized_range<R>;
-
-        template<typename MetaFn, typename Rng>
-        using container_t = meta::invoke<MetaFn, Rng>;
-        // clang-format on
-
-        struct RANGES_STRUCT_WITH_ADL_BARRIER(to_container_closure_base)
-        {
-            // clang-format off
-            template(typename Rng, typename MetaFn, typename Fn)(
-                /// \pre
-                requires input_range<Rng> AND
-                    convertible_to_cont<Rng, container_t<MetaFn, Rng>>)
-            friend constexpr auto
-            operator|(Rng && rng, to_container::closure<MetaFn, Fn> fn)
-            {
-                return static_cast<Fn &&>(fn)(static_cast<Rng &&>(rng));
-            }
-
-            template(typename Rng, typename MetaFn, typename Fn)(
-                /// \pre
-                requires input_range<Rng> AND
-                    (!convertible_to_cont<Rng, container_t<MetaFn, Rng>>) AND
-                    convertible_to_cont_cont<Rng, container_t<MetaFn, Rng>>)
-            friend constexpr auto
-            operator|(Rng && rng, to_container::closure<MetaFn, Fn> fn)
-            {
-                return static_cast<Fn &&>(fn)(static_cast<Rng &&>(rng));
-            }
-
-            template<typename MetaFn, typename Fn, typename Pipeable>
-            friend constexpr auto operator|(to_container::closure<MetaFn, Fn> sh,
-                                            Pipeable pipe)
-                -> CPP_broken_friend_ret(
-                    to_container::closure<MetaFn, composed<Pipeable, Fn>>)(
-                    /// \pre
-                    requires is_pipeable_v<Pipeable>)
-            {
-                return to_container::closure<MetaFn, composed<Pipeable, Fn>>{
-                    compose(static_cast<Pipeable &&>(pipe), static_cast<Fn &&>(sh))};
-            }
-        };
-
-        template<typename MetaFn, typename Fn>
-        struct to_container::closure
-          : to_container_closure_base
-          , Fn
-        {
-            closure() = default;
-            constexpr explicit closure(Fn fn)
-              : Fn(static_cast<Fn &&>(fn))
-            {}
-        };
-
-        template<typename MetaFn>
-        struct to_container::fn
-        {
-        private:
-            template<typename Cont, typename I, typename Rng>
-            static Cont impl(Rng && rng, std::false_type)
-            {
-                return Cont(I{ranges::begin(rng)}, I{ranges::end(rng)});
-            }
-            template<typename Cont, typename I, typename Rng>
-            static auto impl(Rng && rng, std::true_type)
-            {
-                Cont c;
-                auto const rng_size = ranges::size(rng);
-                using size_type = decltype(c.max_size());
-                using C = common_type_t<range_size_t<Rng>, size_type>;
-                RANGES_EXPECT(static_cast<C>(rng_size) <= static_cast<C>(c.max_size()));
-                c.reserve(static_cast<size_type>(rng_size));
-                c.assign(I{ranges::begin(rng)}, I{ranges::end(rng)});
-                return c;
-            }
-
-        public:
-            template(typename Rng)(
-                /// \pre
-                requires input_range<Rng> AND
-                    convertible_to_cont<Rng, container_t<MetaFn, Rng>>)
-            container_t<MetaFn, Rng> operator()(Rng && rng) const
-            {
-                static_assert(!is_infinite<Rng>::value,
-                              "Attempt to convert an infinite range to a container.");
-                using cont_t = container_t<MetaFn, Rng>;
-                using iter_t = range_cpp17_iterator_t<Rng>;
-                using use_reserve_t =
-                    meta::bool_<(bool)to_container_reserve<cont_t, iter_t, Rng>>;
-                return impl<cont_t, iter_t>(static_cast<Rng &&>(rng), use_reserve_t{});
-            }
-            template(typename Rng)(
-                /// \pre
-                requires input_range<Rng> AND
-                    (!convertible_to_cont<Rng, container_t<MetaFn, Rng>>) AND
-                    convertible_to_cont_cont<Rng, container_t<MetaFn, Rng>>)
-            container_t<MetaFn, Rng> operator()(Rng && rng) const
-            {
-                static_assert(!is_infinite<Rng>::value,
-                              "Attempt to convert an infinite range to a container.");
-                using cont_t = container_t<MetaFn, Rng>;
-                using iter_t = to_container_iterator<Rng, cont_t>;
-                using use_reserve_t =
-                    meta::bool_<(bool)to_container_reserve<cont_t, iter_t, Rng>>;
-                return impl<cont_t, iter_t>(static_cast<Rng &&>(rng), use_reserve_t{});
-            }
-        };
-
-        template<typename MetaFn, typename Fn>
-        using to_container_closure = to_container::closure<MetaFn, Fn>;
-
-        template<typename MetaFn>
-        using to_container_fn = to_container_closure<MetaFn, to_container::fn<MetaFn>>;
-
-        template<template<typename...> class ContT>
-        struct from_range
-        {
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-            // Attempt to use a deduction guide first...
-            template<typename Rng>
-            static auto from_rng_(int) //
-                -> decltype(ContT(range_cpp17_iterator_t<Rng>{},
-                                  range_cpp17_iterator_t<Rng>{}));
-            // No deduction guide. Fallback to instantiating with the
-            // iterator's value type.
-            template<typename Rng>
-            static auto from_rng_(long) //
-                -> meta::invoke<meta::quote<ContT>, range_value_t<Rng>>;
-
-            template<typename Rng>
-            using invoke = decltype(from_range::from_rng_<Rng>(0));
-#else
-            template<typename Rng>
-            using invoke = meta::invoke<meta::quote<ContT>, range_value_t<Rng>>;
-#endif
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// \addtogroup group-range
-    /// @{
-
-    /// \ingroup group-range
-    RANGES_INLINE_VARIABLE(detail::to_container_fn<detail::from_range<std::vector>>,
-                           to_vector)
-
-    /// \cond
-    namespace _to_
-    {
-        /// \endcond
-
-        /// \brief For initializing a container of the specified type with the elements of
-        /// an Range
-        template<template<typename...> class ContT>
-        auto to(RANGES_HIDDEN_DETAIL(detail::to_container = {}))
-            -> detail::to_container_fn<detail::from_range<ContT>>
-        {
-            return {};
-        }
-
-        /// \overload
-        template(template<typename...> class ContT, typename Rng)(
-            /// \pre
-            requires range<Rng> AND
-                detail::convertible_to_cont<Rng, ContT<range_value_t<Rng>>>)
-        auto to(Rng && rng) -> ContT<range_value_t<Rng>>
-        {
-            return detail::to_container_fn<detail::from_range<ContT>>{}(
-                static_cast<Rng &&>(rng));
-        }
-
-        /// \overload
-        template<typename Cont>
-        auto to(RANGES_HIDDEN_DETAIL(detail::to_container = {}))
-            -> detail::to_container_fn<meta::id<Cont>>
-        {
-            return {};
-        }
-
-        /// \overload
-        template(typename Cont, typename Rng)(
-            /// \pre
-            requires range<Rng> AND detail::convertible_to_cont<Rng, Cont>)
-        auto to(Rng && rng) -> Cont
-        {
-            return detail::to_container_fn<meta::id<Cont>>{}(static_cast<Rng &&>(rng));
-        }
-
-        /// \cond
-        // Slightly odd initializer_list overloads, undocumented for now.
-        template(template<typename...> class ContT, typename T)(
-            /// \pre
-            requires detail::convertible_to_cont<std::initializer_list<T>, ContT<T>>)
-        auto to(std::initializer_list<T> il) -> ContT<T>
-        {
-            return detail::to_container_fn<detail::from_range<ContT>>{}(il);
-        }
-        template(typename Cont, typename T)(
-            /// \pre
-            requires detail::convertible_to_cont<std::initializer_list<T>, Cont>)
-        auto to(std::initializer_list<T> il) -> Cont
-        {
-            return detail::to_container_fn<meta::id<Cont>>{}(il);
-        }
-        /// \endcond
-
-        /// \cond
-    } // namespace _to_
-    using namespace _to_;
-    /// \endcond
-    /// @}
-
-    ////////////////////////////////////////////////////////////////////////////
-    /// \cond
-    namespace _to_
-    {
-        // The old name "ranges::to_" is now deprecated:
-        template<template<typename...> class ContT>
-        RANGES_DEPRECATED("Please use ranges::to (no underscore) instead.")
-        detail::to_container_fn<detail::from_range<ContT>> to_(detail::to_container = {})
-        {
-            return {};
-        }
-        template(template<typename...> class ContT, typename Rng)(
-            /// \pre
-            requires range<Rng> AND
-                detail::convertible_to_cont<Rng, ContT<range_value_t<Rng>>>)
-        RANGES_DEPRECATED("Please use ranges::to (no underscore) instead.")
-        ContT<range_value_t<Rng>> to_(Rng && rng)
-        {
-            return static_cast<Rng &&>(rng) | ranges::to_<ContT>();
-        }
-        template(template<typename...> class ContT, typename T)(
-            /// \pre
-            requires detail::convertible_to_cont<std::initializer_list<T>, ContT<T>>)
-        RANGES_DEPRECATED("Please use ranges::to (no underscore) instead.")
-        ContT<T> to_(std::initializer_list<T> il)
-        {
-            return il | ranges::to_<ContT>();
-        }
-        template<typename Cont>
-        RANGES_DEPRECATED("Please use ranges::to (no underscore) instead.")
-        detail::to_container_fn<meta::id<Cont>> to_(detail::to_container = {})
-        {
-            return {};
-        }
-        template(typename Cont, typename Rng)(
-            /// \pre
-            requires range<Rng> AND detail::convertible_to_cont<Rng, Cont>)
-        RANGES_DEPRECATED("Please use ranges::to (no underscore) instead.")
-        Cont to_(Rng && rng)
-        {
-            return static_cast<Rng &&>(rng) | ranges::to_<Cont>();
-        }
-        template(typename Cont, typename T)(
-            /// \pre
-            requires detail::convertible_to_cont<std::initializer_list<T>, Cont>)
-        RANGES_DEPRECATED("Please use ranges::to (no underscore) instead.")
-        Cont to_(std::initializer_list<T> list)
-        {
-            return list | ranges::to_<Cont>();
-        }
-    } // namespace _to_
-    /// \endcond
-
-    template<typename MetaFn, typename Fn>
-    RANGES_INLINE_VAR constexpr bool
-        is_pipeable_v<detail::to_container_closure<MetaFn, Fn>> = true;
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/range/dangling.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/range/dangling.hpp
deleted file mode 100644
index 0f047741..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/range/dangling.hpp
+++ /dev/null
@@ -1,96 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_RANGE_DANGLING_HPP
-#define RANGES_V3_RANGE_DANGLING_HPP
-
-#include <utility>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \ingroup group-range
-    /// A placeholder for an iterator or a sentinel into a range that may
-    /// no longer be valid.
-    struct dangling
-    {
-        dangling() = default;
-        /// Implicit converting constructor; ignores argument
-        template(typename T)(
-            /// \pre
-            requires not_same_as_<T, dangling>)
-        constexpr dangling(T &&)
-        {}
-    };
-
-    /// \cond
-    namespace detail
-    {
-        template(class R, class U)(
-            /// \pre
-            requires range<R>)
-            using maybe_dangling_ =     //
-                meta::conditional_t<detail::_borrowed_range<R>, U, dangling>;
-    }
-    /// \endcond
-
-    template<typename Rng>
-    using borrowed_iterator_t = detail::maybe_dangling_<Rng, iterator_t<Rng>>;
-
-    template<typename Rng>
-    using safe_iterator_t RANGES_DEPRECATED(
-        "Please use ranges::borrowed_iterator_t instead.") = borrowed_iterator_t<Rng>;
-
-    /// \cond
-    struct _sanitize_fn
-    {
-        template<typename T>
-        constexpr T && operator()(T && t) const noexcept
-        {
-            return static_cast<T &&>(t);
-        }
-    };
-
-    using sanitize_fn RANGES_DEPRECATED(
-        "The sanitize function is unneeded and deprecated.") = _sanitize_fn;
-
-    namespace
-    {
-        RANGES_DEPRECATED("The sanitize function is unneeded and deprecated.")
-        constexpr auto & sanitize = static_const<_sanitize_fn>::value;
-    } // namespace
-    /// \endcond
-
-    namespace cpp20
-    {
-        using ranges::dangling;
-        using ranges::borrowed_iterator_t;
-
-        template<typename Rng>
-        using safe_iterator_t RANGES_DEPRECATED(
-            "Please use ranges::borrowed_iterator_t instead.") = borrowed_iterator_t<Rng>;
-    } // namespace cpp20
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/range/operations.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/range/operations.hpp
deleted file mode 100644
index 4665657b..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/range/operations.hpp
+++ /dev/null
@@ -1,128 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Gonzalo Brito Gadeschi 2017
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_RANGE_OPERATIONS_HPP
-#define RANGES_V3_RANGE_OPERATIONS_HPP
-
-#include <stdexcept>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// Checked indexed range access.
-    ///
-    /// \ingroup group-range
-    struct at_fn
-    {
-        /// \return `begin(rng)[n]`
-        template(typename Rng)(
-            /// \pre
-            requires random_access_range<Rng> AND sized_range<Rng> AND
-                borrowed_range<Rng>)
-        constexpr range_reference_t<Rng> //
-        operator()(Rng && rng, range_difference_t<Rng> n) const
-        {
-            // Workaround https://gcc.gnu.org/bugzilla/show_bug.cgi?id=67371 in GCC 5
-            check_throw(rng, n);
-            return ranges::begin(rng)[n];
-        }
-
-    private:
-        template<typename Rng>
-        static constexpr void check_throw(Rng && rng, range_difference_t<Rng> n)
-        {
-            (n < 0 || n >= ranges::distance(rng)) ? throw std::out_of_range("ranges::at")
-                                                  : void(0);
-        }
-    };
-
-    /// Checked indexed range access.
-    ///
-    /// \ingroup group-range
-    /// \sa `at_fn`
-    RANGES_INLINE_VARIABLE(at_fn, at)
-
-    /// Unchecked indexed range access.
-    ///
-    /// \ingroup group-range
-    struct index_fn
-    {
-        /// \return `begin(rng)[n]`
-        template(typename Rng, typename Int)(
-            /// \pre
-            requires random_access_range<Rng> AND integral<Int> AND borrowed_range<Rng>)
-        constexpr range_reference_t<Rng> operator()(Rng && rng, Int n) const //
-        {
-            using D = range_difference_t<Rng>;
-            RANGES_EXPECT(0 <= static_cast<D>(n));
-            RANGES_EXPECT(!(bool)sized_range<Rng> ||
-                          static_cast<D>(n) < ranges::distance(rng));
-            return ranges::begin(rng)[static_cast<D>(n)];
-        }
-    };
-
-    /// Unchecked indexed range access.
-    ///
-    /// \ingroup group-range
-    /// \sa `index_fn`
-    RANGES_INLINE_VARIABLE(index_fn, index)
-
-    /// \ingroup group-range
-    struct back_fn
-    {
-        /// \return `*prev(end(rng))`
-        template(typename Rng)(
-            /// \pre
-            requires common_range<Rng> AND bidirectional_range<Rng> AND
-                borrowed_range<Rng>)
-        constexpr range_reference_t<Rng> operator()(Rng && rng) const
-        {
-            return *prev(end(rng));
-        }
-    };
-
-    /// \ingroup group-range
-    /// \sa `back_fn`
-    RANGES_INLINE_VARIABLE(back_fn, back)
-
-    /// \ingroup group-range
-    struct front_fn
-    {
-        /// \return `*begin(rng)`
-        template(typename Rng)(
-            /// \pre
-            requires forward_range<Rng> AND borrowed_range<Rng>)
-        constexpr range_reference_t<Rng> operator()(Rng && rng) const
-        {
-            return *begin(rng);
-        }
-    };
-
-    /// \ingroup group-range
-    /// \sa `front_fn`
-    RANGES_INLINE_VARIABLE(front_fn, front)
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/range/primitives.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/range/primitives.hpp
deleted file mode 100644
index b5bea097..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/range/primitives.hpp
+++ /dev/null
@@ -1,335 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_RANGE_PRIMITIVES_HPP
-#define RANGES_V3_RANGE_PRIMITIVES_HPP
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/utility/addressof.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-range
-    // Specialize this if the default is wrong.
-    template<typename T>
-    RANGES_INLINE_VAR constexpr bool disable_sized_range = false;
-
-    /// \cond
-    namespace _size_
-    {
-        template<typename T>
-        void size(T &&) = delete;
-
-#ifdef RANGES_WORKAROUND_MSVC_895622
-        void size();
-#endif
-
-        struct fn
-        {
-        private:
-            template<typename R>
-            using member_size_t = decltype(+(std::declval<R>()).size());
-            template<typename R>
-            using non_member_size_t = decltype(+size(std::declval<R>()));
-
-            template<typename R, std::size_t N>
-            static constexpr std::size_t impl_(R (&)[N], int) noexcept
-            {
-                return N;
-            }
-
-            template<typename R, std::size_t N>
-            static constexpr std::size_t impl_(R(&&)[N], int) noexcept
-            {
-                return N;
-            }
-
-            // Prefer member if it returns integral.
-            template(typename R)(
-                /// \pre
-                requires integral<member_size_t<R>> AND
-                    (!disable_sized_range<uncvref_t<R>>)) //
-            static constexpr member_size_t<R> impl_(R && r, int) //
-                noexcept(noexcept(((R &&) r).size()))
-            {
-                return ((R &&) r).size();
-            }
-
-            // Use ADL if it returns integral.
-            template(typename R)(
-                /// \pre
-                requires integral<non_member_size_t<R>> AND
-                    (!disable_sized_range<uncvref_t<R>>)) //
-            static constexpr non_member_size_t<R> impl_(R && r, long) //
-                noexcept(noexcept(size((R &&) r)))
-            {
-                return size((R &&) r);
-            }
-
-            template(typename R)(
-                /// \pre
-                requires forward_iterator<_begin_::_t<R>> AND
-                    sized_sentinel_for<_end_::_t<R>, _begin_::_t<R>>)
-            static constexpr auto impl_(R && r, ...)
-                -> detail::iter_size_t<_begin_::_t<R>>
-            {
-                using size_type = detail::iter_size_t<_begin_::_t<R>>;
-                return static_cast<size_type>(ranges::end((R &&) r) -
-                                              ranges::begin((R &&) r));
-            }
-
-        public:
-            template<typename R>
-            constexpr auto operator()(R && r) const
-                noexcept(noexcept(fn::impl_((R &&) r, 0)))
-                    -> decltype(fn::impl_((R &&) r, 0))
-            {
-                return fn::impl_((R &&) r, 0);
-            }
-
-            template<typename T, typename Fn = fn>
-            RANGES_DEPRECATED(
-                "Using a reference_wrapper as a Range is deprecated. Use views::ref "
-                "instead.")
-            constexpr auto
-            operator()(std::reference_wrapper<T> ref) const
-                noexcept(noexcept(Fn{}(ref.get()))) -> decltype(Fn{}(ref.get()))
-            {
-                return Fn{}(ref.get());
-            }
-
-            template<typename T, typename Fn = fn>
-            RANGES_DEPRECATED(
-                "Using a reference_wrapper as a Range is deprecated. Use views::ref "
-                "instead.")
-            constexpr auto
-            operator()(ranges::reference_wrapper<T> ref) const
-                noexcept(noexcept(Fn{}(ref.get()))) -> decltype(Fn{}(ref.get()))
-            {
-                return Fn{}(ref.get());
-            }
-        };
-    } // namespace _size_
-    /// \endcond
-
-    /// \ingroup group-range
-    /// \return For a given expression `E` of type `T`, `ranges::size(E)` is equivalent
-    /// to:
-    ///   * `+extent_v<T>` if `T` is an array type.
-    ///   * Otherwise, `+E.size()` if it is a valid expression and its type `I` models
-    ///     `integral` and `disable_sized_range<std::remove_cvref_t<T>>` is false.
-    ///   * Otherwise, `+size(E)` if it is a valid expression and its type `I` models
-    ///     `integral` with overload resolution performed in a context that includes the
-    ///     declaration:
-    ///     \code
-    ///     template<class T> void size(T&&) = delete;
-    ///     \endcode
-    ///     and does not include a declaration of `ranges::size`, and
-    ///     `disable_sized_range<std::remove_cvref_t<T>>` is false.
-    ///   * Otherwise, `static_cast<U>(ranges::end(E) - ranges::begin(E))` where `U` is
-    ///     `std::make_unsigned_t<iter_difference_t<iterator_t<T>>>` if
-    ///     `iter_difference_t<iterator_t<T>>` satisfies `integral` and
-    ///     `iter_difference_t<iterator_t<T>>` otherwise; except that `E` is
-    ///     evaluated once, if it is a valid expression and the types `I` and `S` of
-    ///     `ranges::begin(E)` and `ranges::end(E)` model `sized_sentinel_for<S, I>` and
-    ///     `forward_iterator<I>`.
-    ///   * Otherwise, `ranges::size(E)` is ill-formed.
-    RANGES_DEFINE_CPO(_size_::fn, size)
-
-    // Customization point data
-    /// \cond
-    namespace _data_
-    {
-        struct fn
-        {
-        private:
-            template<typename R>
-            using member_data_t = detail::decay_t<decltype(std::declval<R>().data())>;
-
-            template(typename R)(
-                /// \pre
-                requires std::is_pointer<member_data_t<R &>>::value) //
-            static constexpr member_data_t<R &> impl_(R & r, detail::priority_tag<2>)
-                noexcept(noexcept(r.data())) 
-            {
-                return r.data();
-            }
-            template(typename R)(
-                /// \pre
-                requires std::is_pointer<_begin_::_t<R>>::value) //
-            static constexpr _begin_::_t<R> impl_(R && r, detail::priority_tag<1>)
-                noexcept(noexcept(ranges::begin((R &&) r)))
-            {
-                return ranges::begin((R &&) r);
-            }
-            template(typename R)(
-                /// \pre
-                requires contiguous_iterator<_begin_::_t<R>>)
-            static constexpr auto impl_(R && r, detail::priority_tag<0>) noexcept(
-                noexcept(ranges::begin((R &&) r) == ranges::end((R &&) r)
-                             ? nullptr
-                             : detail::addressof(*ranges::begin((R &&) r))))
-                -> decltype(detail::addressof(*ranges::begin((R &&) r)))
-            {
-                return ranges::begin((R &&) r) == ranges::end((R &&) r)
-                           ? nullptr
-                           : detail::addressof(*ranges::begin((R &&) r));
-            }
-
-        public:
-            template<typename charT, typename Traits, typename Alloc>
-            constexpr charT * operator()(
-                std::basic_string<charT, Traits, Alloc> & s) const noexcept
-            {
-                // string doesn't have non-const data before C++17
-                return const_cast<charT *>(detail::as_const(s).data());
-            }
-
-            template<typename R>
-            constexpr auto operator()(R && r) const
-                noexcept(noexcept(fn::impl_((R &&) r, detail::priority_tag<2>{})))
-                    -> decltype(fn::impl_((R &&) r, detail::priority_tag<2>{}))
-            {
-                return fn::impl_((R &&) r, detail::priority_tag<2>{});
-            }
-        };
-
-        template<typename R>
-        using _t = decltype(fn{}(std::declval<R>()));
-    } // namespace _data_
-    /// \endcond
-
-    RANGES_INLINE_VARIABLE(_data_::fn, data)
-
-    /// \cond
-    namespace _cdata_
-    {
-        struct fn
-        {
-            template<typename R>
-            constexpr _data_::_t<R const &> operator()(R const & r) const
-                noexcept(noexcept(ranges::data(r)))
-            {
-                return ranges::data(r);
-            }
-            template<typename R>
-            constexpr _data_::_t<R const> operator()(R const && r) const
-                noexcept(noexcept(ranges::data((R const &&)r)))
-            {
-                return ranges::data((R const &&)r);
-            }
-        };
-    } // namespace _cdata_
-    /// \endcond
-
-    /// \ingroup group-range
-    /// \param r
-    /// \return The result of calling `ranges::data` with a const-qualified
-    ///    (lvalue or rvalue) reference to `r`.
-    RANGES_INLINE_VARIABLE(_cdata_::fn, cdata)
-
-    /// \cond
-    namespace _empty_
-    {
-        struct fn
-        {
-        private:
-            // Prefer member if it is valid.
-            template<typename R>
-            static constexpr auto impl_(R && r, detail::priority_tag<2>) noexcept(
-                noexcept(bool(((R &&) r).empty()))) -> decltype(bool(((R &&) r).empty()))
-            {
-                return bool(((R &&) r).empty());
-            }
-
-            // Fall back to size == 0.
-            template<typename R>
-            static constexpr auto impl_(R && r, detail::priority_tag<1>) noexcept(
-                noexcept(bool(ranges::size((R &&) r) == 0)))
-                -> decltype(bool(ranges::size((R &&) r) == 0))
-            {
-                return bool(ranges::size((R &&) r) == 0);
-            }
-
-            // Fall further back to begin == end.
-            template(typename R)(
-                /// \pre
-                requires forward_iterator<_begin_::_t<R>>)
-            static constexpr auto impl_(R && r, detail::priority_tag<0>) noexcept(
-                noexcept(bool(ranges::begin((R &&) r) == ranges::end((R &&) r))))
-                -> decltype(bool(ranges::begin((R &&) r) ==
-                                         ranges::end((R &&) r)))
-            {
-                return bool(ranges::begin((R &&) r) == ranges::end((R &&) r));
-            }
-
-        public:
-            template<typename R>
-            constexpr auto operator()(R && r) const
-                noexcept(noexcept(fn::impl_((R &&) r, detail::priority_tag<2>{})))
-                    -> decltype(fn::impl_((R &&) r, detail::priority_tag<2>{}))
-            {
-                return fn::impl_((R &&) r, detail::priority_tag<2>{});
-            }
-
-            template<typename T, typename Fn = fn>
-            RANGES_DEPRECATED(
-                "Using a reference_wrapper as a Range is deprecated. Use views::ref "
-                "instead.")
-            constexpr auto
-            operator()(std::reference_wrapper<T> ref) const
-                noexcept(noexcept(Fn{}(ref.get()))) -> decltype(Fn{}(ref.get()))
-            {
-                return Fn{}(ref.get());
-            }
-
-            template<typename T, typename Fn = fn>
-            RANGES_DEPRECATED(
-                "Using a reference_wrapper as a Range is deprecated. Use views::ref "
-                "instead.")
-            constexpr auto
-            operator()(ranges::reference_wrapper<T> ref) const
-                noexcept(noexcept(Fn{}(ref.get()))) -> decltype(Fn{}(ref.get()))
-            {
-                return Fn{}(ref.get());
-            }
-        };
-    } // namespace _empty_
-    /// \endcond
-
-    /// \ingroup group-range
-    /// \return true if and only if range contains no elements.
-    RANGES_INLINE_VARIABLE(_empty_::fn, empty)
-
-    namespace cpp20
-    {
-        // Specialize this is namespace ranges::
-        using ranges::cdata;
-        using ranges::data;
-        using ranges::disable_sized_range;
-        using ranges::empty;
-        using ranges::size;
-    } // namespace cpp20
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/range/traits.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/range/traits.hpp
deleted file mode 100644
index 1467a28a..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/range/traits.hpp
+++ /dev/null
@@ -1,142 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_RANGE_TRAITS_HPP
-#define RANGES_V3_RANGE_TRAITS_HPP
-
-#include <array>
-#include <iterator>
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/primitives.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        template<typename I, typename S>
-        using common_iterator_impl_t =
-            enable_if_t<(bool)(input_or_output_iterator<I> && sentinel_for<S, I>),
-                        common_iterator<I, S>>;
-    }
-    /// \endcond
-
-    /// \addtogroup group-range
-    /// @{
-    template<typename I, typename S>
-    using common_iterator_t = meta::conditional_t<std::is_same<I, S>::value, I,
-                                                detail::common_iterator_impl_t<I, S>>;
-
-    /// \cond
-    namespace detail
-    {
-        template<typename I, typename S>
-        using cpp17_iterator_t =
-            meta::conditional_t<std::is_integral<iter_difference_t<I>>::value,
-                      common_iterator_t<I, S>, cpp17_iterator<common_iterator_t<I, S>>>;
-    }
-    /// \endcond
-
-    // Aliases (SFINAE-able)
-    template<typename Rng>
-    using range_difference_t = iter_difference_t<iterator_t<Rng>>;
-
-    template<typename Rng>
-    using range_value_t = iter_value_t<iterator_t<Rng>>;
-
-    template<typename Rng>
-    using range_reference_t = iter_reference_t<iterator_t<Rng>>;
-
-    template<typename Rng>
-    using range_rvalue_reference_t = iter_rvalue_reference_t<iterator_t<Rng>>;
-
-    template<typename Rng>
-    using range_common_reference_t = iter_common_reference_t<iterator_t<Rng>>;
-
-    template<typename Rng>
-    using range_size_t = decltype(ranges::size(std::declval<Rng &>()));
-
-    /// \cond
-    template<typename Rng>
-    using range_difference_type_t RANGES_DEPRECATED(
-        "range_difference_type_t is deprecated. Use the range_difference_t instead.") =
-        iter_difference_t<iterator_t<Rng>>;
-
-    template<typename Rng>
-    using range_value_type_t RANGES_DEPRECATED(
-        "range_value_type_t is deprecated. Use the range_value_t instead.") =
-        iter_value_t<iterator_t<Rng>>;
-
-    template<typename Rng>
-    using range_category_t RANGES_DEPRECATED(
-        "range_category_t is deprecated. Use the range concepts instead.") =
-        meta::_t<detail::iterator_category<iterator_t<Rng>>>;
-
-    template<typename Rng>
-    using range_size_type_t RANGES_DEPRECATED(
-        "range_size_type_t is deprecated. Use range_size_t instead.") =
-        detail::iter_size_t<iterator_t<Rng>>;
-    /// \endcond
-
-    template<typename Rng>
-    using range_common_iterator_t = common_iterator_t<iterator_t<Rng>, sentinel_t<Rng>>;
-
-    /// \cond
-    namespace detail
-    {
-        template<typename Rng>
-        using range_cpp17_iterator_t = cpp17_iterator_t<iterator_t<Rng>, sentinel_t<Rng>>;
-
-        std::integral_constant<cardinality, finite> test_cardinality(void *);
-        template<cardinality Card>
-        std::integral_constant<cardinality, Card> test_cardinality(basic_view<Card> *);
-        template<typename T, std::size_t N>
-        std::integral_constant<cardinality, static_cast<cardinality>(N)> test_cardinality(
-            T (*)[N]);
-        template<typename T, std::size_t N>
-        std::integral_constant<cardinality, static_cast<cardinality>(N)> test_cardinality(
-            std::array<T, N> *);
-    } // namespace detail
-    /// \endcond
-
-    // User customization point for specifying the cardinality of ranges:
-    template<typename Rng, typename Void /*= void*/>
-    struct range_cardinality
-      : meta::conditional_t<RANGES_IS_SAME(Rng, uncvref_t<Rng>),
-                          decltype(detail::test_cardinality(
-                              static_cast<uncvref_t<Rng> *>(nullptr))),
-                          range_cardinality<uncvref_t<Rng>>>
-    {};
-
-    /// @}
-    namespace cpp20
-    {
-        using ranges::range_difference_t;
-        using ranges::range_reference_t;
-        using ranges::range_rvalue_reference_t;
-        using ranges::range_value_t;
-    } // namespace cpp20
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/range_access.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/range_access.hpp
deleted file mode 100644
index 0d8184c4..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/range_access.hpp
+++ /dev/null
@@ -1,23 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_OLD_RANGE_ACCESS_HPP
-#define RANGES_V3_OLD_RANGE_ACCESS_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated. Please #include <range/v3/range/operations.hpp> instead.")
-
-#include <range/v3/range/operations.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/range_concepts.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/range_concepts.hpp
deleted file mode 100644
index 5ccb2938..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/range_concepts.hpp
+++ /dev/null
@@ -1,22 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_DEPRECATED_RANGE_CONCEPTS_HPP
-#define RANGES_V3_DEPRECATED_RANGE_CONCEPTS_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated. Please #include <range/v3/range/concepts.hpp> instead.")
-
-#include <range/v3/range/concepts.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/range_for.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/range_for.hpp
deleted file mode 100644
index e60bb5ff..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/range_for.hpp
+++ /dev/null
@@ -1,50 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_RANGE_FOR_HPP
-#define RANGES_V3_RANGE_FOR_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/range/access.hpp>
-
-#if RANGES_CXX_RANGE_BASED_FOR < RANGES_CXX_RANGE_BASED_FOR_17
-/// A range-based for macro, basically a hack until the built-in range-for can handle
-/// Ranges that have a different type for begin and end. \ingroup range-core
-#define RANGES_FOR(VAR_DECL, ...)                                              \
-    if(bool CPP_PP_CAT(_range_v3_done, __LINE__) = false) {}                   \
-    else                                                                       \
-        for(auto && CPP_PP_CAT(_range_v3_rng, __LINE__) = (__VA_ARGS__);       \
-            !CPP_PP_CAT(_range_v3_done, __LINE__);)                            \
-            for(auto CPP_PP_CAT(_range_v3_begin, __LINE__) =                   \
-                    ranges::begin(CPP_PP_CAT(_range_v3_rng, __LINE__));        \
-                !CPP_PP_CAT(_range_v3_done, __LINE__);                         \
-                CPP_PP_CAT(_range_v3_done, __LINE__) = true)                   \
-                for(auto CPP_PP_CAT(_range_v3_end, __LINE__) =                 \
-                        ranges::end(CPP_PP_CAT(_range_v3_rng, __LINE__));      \
-                    !CPP_PP_CAT(_range_v3_done, __LINE__) &&                   \
-                    CPP_PP_CAT(_range_v3_begin, __LINE__) !=                   \
-                        CPP_PP_CAT(_range_v3_end, __LINE__);                   \
-                    ++CPP_PP_CAT(_range_v3_begin, __LINE__))                   \
-                    if(!(CPP_PP_CAT(_range_v3_done, __LINE__) = true)) {}      \
-                    else                                                       \
-                        for(VAR_DECL = *CPP_PP_CAT(_range_v3_begin, __LINE__); \
-                            CPP_PP_CAT(_range_v3_done, __LINE__);              \
-                            CPP_PP_CAT(_range_v3_done, __LINE__) = false)      \
-    /**/
-
-#else
-#define RANGES_FOR(VAR_DECL, ...) for(VAR_DECL : (__VA_ARGS__))
-#endif
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/range_fwd.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/range_fwd.hpp
deleted file mode 100644
index 43e06f89..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/range_fwd.hpp
+++ /dev/null
@@ -1,931 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_RANGE_FWD_HPP
-#define RANGES_V3_RANGE_FWD_HPP
-
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-#include <concepts/compare.hpp>
-
-#include <range/v3/detail/config.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/version.hpp>
-
-/// \defgroup group-iterator Iterator
-/// Iterator functionality
-
-/// \defgroup group-iterator-concepts Iterator Concepts
-/// \ingroup group-iterator
-/// Iterator concepts
-
-/// \defgroup group-range Range
-/// Core range functionality
-
-/// \defgroup group-range-concepts Range Concepts
-/// \ingroup group-range
-/// Range concepts
-
-/// \defgroup group-algorithms Algorithms
-/// Iterator- and range-based algorithms, like the standard algorithms
-
-/// \defgroup group-views Views
-/// Lazy, non-owning, non-mutating, composable range views
-
-/// \defgroup group-actions Actions
-/// Eager, mutating, composable algorithms
-
-/// \defgroup group-utility Utility
-/// Utility classes
-
-/// \defgroup group-functional Functional
-/// Function and function object utilities
-
-/// \defgroup group-numerics Numerics
-/// Numeric utilities
-
-#include <range/v3/detail/prologue.hpp>
-
-RANGES_DIAGNOSTIC_PUSH
-RANGES_DIAGNOSTIC_IGNORE_CXX17_COMPAT
-
-namespace ranges
-{
-    /// \cond
-    namespace views
-    {
-    }
-
-    namespace actions
-    {
-    }
-
-// GCC either fails to accept an attribute on a namespace, or else
-// it ignores the deprecation attribute. Frustrating.
-#if(RANGES_CXX_VER < RANGES_CXX_STD_17 || defined(__GNUC__) && !defined(__clang__))
-    inline namespace v3
-    {
-        using namespace ranges;
-    }
-
-    namespace view = views;
-    namespace action = actions;
-#else
-    inline namespace RANGES_DEPRECATED(
-        "The name ranges::v3 namespace is deprecated. "
-        "Please discontinue using it.") v3
-    {
-        using namespace ranges;
-    }
-
-    namespace RANGES_DEPRECATED(
-        "The ranges::view namespace has been renamed to ranges::views. "
-        "(Sorry!)") view
-    {
-        using namespace views;
-    }
-
-    namespace RANGES_DEPRECATED(
-        "The ranges::action namespace has been renamed to ranges::actions. "
-        "(Sorry!)") action
-    {
-        using namespace actions;
-    }
-#endif
-
-    namespace _end_
-    {
-        struct fn;
-    }
-    using end_fn = _end_::fn;
-
-    namespace _size_
-    {
-        struct fn;
-    }
-
-    template<typename>
-    struct result_of;
-
-    template<typename Sig>
-    using result_of_t RANGES_DEPRECATED(
-        "ranges::result_of_t is deprecated. "
-        "Please use ranges::invoke_result_t") = meta::_t<result_of<Sig>>;
-    /// \endcond
-
-    template<typename...>
-    struct variant;
-
-    struct dangling;
-
-    struct make_pipeable_fn;
-
-    struct pipeable_base;
-
-    template<typename First, typename Second>
-    struct composed;
-
-    template<typename... Fns>
-    struct overloaded;
-
-    namespace actions
-    {
-        template<typename ActionFn>
-        struct action_closure;
-    }
-
-    namespace views
-    {
-        template<typename ViewFn>
-        struct view_closure;
-    }
-
-    struct advance_fn;
-
-    struct advance_to_fn;
-
-    struct advance_bounded_fn;
-
-    struct next_fn;
-
-    struct prev_fn;
-
-    struct distance_fn;
-
-    struct iter_size_fn;
-
-    template<typename T>
-    struct indirectly_readable_traits;
-
-    template<typename T>
-    using readable_traits RANGES_DEPRECATED("Please use ranges::indirectly_readable_traits")
-     = indirectly_readable_traits<T>;
-
-    template<typename T>
-    struct incrementable_traits;
-
-    struct view_base
-    {};
-
-    /// \cond
-    namespace detail
-    {
-        template<typename T>
-        struct difference_type_;
-
-        template<typename T>
-        struct value_type_;
-    } // namespace detail
-
-    template<typename T>
-    using difference_type RANGES_DEPRECATED(
-        "ranges::difference_type<T>::type is deprecated. Use "
-        "ranges::incrementable_traits<T>::difference_type instead.") =
-        detail::difference_type_<T>;
-
-    template<typename T>
-    using value_type RANGES_DEPRECATED(
-        "ranges::value_type<T>::type is deprecated. Use "
-        "ranges::indirectly_readable_traits<T>::value_type instead.") = detail::value_type_<T>;
-
-    template<typename T>
-    struct size_type;
-    /// \endcond
-
-    /// \cond
-    namespace detail
-    {
-        struct ignore_t
-        {
-            ignore_t() = default;
-            template<typename T>
-            constexpr ignore_t(T &&) noexcept
-            {}
-            template<typename T>
-            constexpr ignore_t const & operator=(T &&) const noexcept
-            {
-                return *this;
-            }
-        };
-
-        struct value_init
-        {
-            template<typename T>
-            operator T() const
-            {
-                return T{};
-            }
-        };
-
-        struct make_compressed_pair_fn;
-
-        template<typename T>
-        constexpr meta::_t<std::remove_reference<T>> && move(T && t) noexcept
-        {
-            return static_cast<meta::_t<std::remove_reference<T>> &&>(t);
-        }
-
-        struct as_const_fn
-        {
-            template<typename T>
-            constexpr T const & operator()(T & t) const noexcept
-            {
-                return t;
-            }
-            template<typename T>
-            constexpr T const && operator()(T && t) const noexcept
-            {
-                return (T &&) t;
-            }
-        };
-
-        RANGES_INLINE_VARIABLE(as_const_fn, as_const)
-
-        template<typename T>
-        using as_const_t = decltype(as_const(std::declval<T>()));
-
-        template<typename T>
-        using decay_t = meta::_t<std::decay<T>>;
-
-        template<typename T, typename R = meta::_t<std::remove_reference<T>>>
-        using as_ref_t =
-            meta::_t<std::add_lvalue_reference<meta::_t<std::remove_const<R>>>>;
-
-        template<typename T, typename R = meta::_t<std::remove_reference<T>>>
-        using as_cref_t = meta::_t<std::add_lvalue_reference<R const>>;
-
-        struct get_first;
-        struct get_second;
-
-        template<typename Val1, typename Val2>
-        struct replacer_fn;
-
-        template<typename Pred, typename Val>
-        struct replacer_if_fn;
-
-        template<typename I>
-        struct move_into_cursor;
-
-        template<typename Int>
-        struct from_end_;
-
-        template<typename... Ts>
-        constexpr int ignore_unused(Ts &&...)
-        {
-            return 42;
-        }
-
-        template<int I>
-        struct priority_tag : priority_tag<I - 1>
-        {};
-
-        template<>
-        struct priority_tag<0>
-        {};
-
-#if defined(__clang__) && !defined(_LIBCPP_VERSION)
-        template<typename T, typename... Args>
-        RANGES_INLINE_VAR constexpr bool is_trivially_constructible_v =
-            __is_trivially_constructible(T, Args...);
-        template<typename T>
-        RANGES_INLINE_VAR constexpr bool is_trivially_default_constructible_v =
-            is_trivially_constructible_v<T>;
-        template<typename T>
-        RANGES_INLINE_VAR constexpr bool is_trivially_copy_constructible_v =
-            is_trivially_constructible_v<T, T const &>;
-        template<typename T>
-        RANGES_INLINE_VAR constexpr bool is_trivially_move_constructible_v =
-            is_trivially_constructible_v<T, T>;
-        template<typename T>
-        RANGES_INLINE_VAR constexpr bool is_trivially_copyable_v =
-            __is_trivially_copyable(T);
-        template<typename T, typename U>
-        RANGES_INLINE_VAR constexpr bool is_trivially_assignable_v =
-            __is_trivially_assignable(T, U);
-        template<typename T>
-        RANGES_INLINE_VAR constexpr bool is_trivially_copy_assignable_v =
-            is_trivially_assignable_v<T &, T const &>;
-        template<typename T>
-        RANGES_INLINE_VAR constexpr bool is_trivially_move_assignable_v =
-            is_trivially_assignable_v<T &, T>;
-
-        template<typename T, typename... Args>
-        struct is_trivially_constructible
-          : meta::bool_<is_trivially_constructible_v<T, Args...>>
-        {};
-        template<typename T>
-        struct is_trivially_default_constructible
-          : meta::bool_<is_trivially_default_constructible_v<T>>
-        {};
-        template<typename T>
-        struct is_trivially_copy_constructible
-          : meta::bool_<is_trivially_copy_constructible_v<T>>
-        {};
-        template<typename T>
-        struct is_trivially_move_constructible
-          : meta::bool_<is_trivially_move_constructible_v<T>>
-        {};
-        template<typename T>
-        struct is_trivially_copyable
-          : meta::bool_<is_trivially_copyable_v<T>>
-        {};
-        template<typename T, typename U>
-        struct is_trivially_assignable
-          : meta::bool_<is_trivially_assignable_v<T, U>>
-        {};
-        template<typename T>
-        struct is_trivially_copy_assignable
-          : meta::bool_<is_trivially_copy_assignable_v<T>>
-        {};
-        template<typename T>
-        struct is_trivially_move_assignable
-          : meta::bool_<is_trivially_move_assignable_v<T>>
-        {};
-#else
-        using std::is_trivially_constructible;
-        using std::is_trivially_default_constructible;
-        using std::is_trivially_copy_assignable;
-        using std::is_trivially_copy_constructible;
-        using std::is_trivially_copyable;
-        using std::is_trivially_assignable;
-        using std::is_trivially_move_assignable;
-        using std::is_trivially_move_constructible;
-#if META_CXX_TRAIT_VARIABLE_TEMPLATES
-        using std::is_trivially_constructible_v;
-        using std::is_trivially_default_constructible_v;
-        using std::is_trivially_copy_assignable_v;
-        using std::is_trivially_copy_constructible_v;
-        using std::is_trivially_copyable_v;
-        using std::is_trivially_assignable_v;
-        using std::is_trivially_move_assignable_v;
-        using std::is_trivially_move_constructible_v;
-#else
-        template<typename T, typename... Args>
-        RANGES_INLINE_VAR constexpr bool is_trivially_constructible_v =
-            is_trivially_constructible<T, Args...>::value;
-        template<typename T>
-        RANGES_INLINE_VAR constexpr bool is_trivially_default_constructible_v =
-            is_trivially_default_constructible<T>::value;
-        template<typename T>
-        RANGES_INLINE_VAR constexpr bool is_trivially_copy_constructible_v =
-            is_trivially_copy_constructible<T>::value;
-        template<typename T>
-        RANGES_INLINE_VAR constexpr bool is_trivially_move_constructible_v =
-            is_trivially_move_constructible<T>::value;
-        template<typename T>
-        RANGES_INLINE_VAR constexpr bool is_trivially_copyable_v =
-            is_trivially_copyable<T>::value;
-        template<typename T, typename U>
-        RANGES_INLINE_VAR constexpr bool is_trivially_assignable_v =
-            is_trivially_assignable<T, U>::value;
-        template<typename T>
-        RANGES_INLINE_VAR constexpr bool is_trivially_copy_assignable_v =
-            is_trivially_copy_assignable<T>::value;
-        template<typename T>
-        RANGES_INLINE_VAR constexpr bool is_trivially_move_assignable_v =
-            is_trivially_move_assignable<T>::value;
-#endif
-#endif
-
-        template<typename T>
-        RANGES_INLINE_VAR constexpr bool is_trivial_v =
-            is_trivially_copyable_v<T> &&
-            is_trivially_default_constructible_v<T>;
-
-        template<typename T>
-        struct is_trivial
-          : meta::bool_<is_trivial_v<T>>
-        {};
-
-#if RANGES_CXX_LIB_IS_FINAL > 0
-#if defined(__clang__) && !defined(_LIBCPP_VERSION)
-        template<typename T>
-        RANGES_INLINE_VAR constexpr bool is_final_v = __is_final(T);
-
-        template<typename T>
-        struct is_final
-          : meta::bool_<is_final_v<T>>
-        {};
-#else
-        using std::is_final;
-#if META_CXX_TRAIT_VARIABLE_TEMPLATES
-        using std::is_final_v;
-#else
-        template<typename T>
-        RANGES_INLINE_VAR constexpr bool is_final_v = is_final<T>::value;
-#endif
-#endif
-#else
-        template<typename T>
-        RANGES_INLINE_VAR constexpr bool is_final_v = false;
-
-        template<typename T>
-        using is_final = std::false_type;
-#endif
-
-        // Work around libc++'s buggy std::is_function
-        // Function types here:
-        template<typename T>
-        char (&is_function_impl_(priority_tag<0>))[1];
-
-        // Array types here:
-        template<typename T, typename = decltype((*(T *)0)[0])>
-        char (&is_function_impl_(priority_tag<1>))[2];
-
-        // Anything that can be returned from a function here (including
-        // void and reference types):
-        template<typename T, typename = T (*)()>
-        char (&is_function_impl_(priority_tag<2>))[3];
-
-        // Classes and unions (including abstract types) here:
-        template<typename T, typename = int T::*>
-        char (&is_function_impl_(priority_tag<3>))[4];
-
-        template<typename T>
-        RANGES_INLINE_VAR constexpr bool is_function_v =
-            sizeof(detail::is_function_impl_<T>(priority_tag<3>{})) == 1;
-
-        template<typename T>
-        struct remove_rvalue_reference
-        {
-            using type = T;
-        };
-
-        template<typename T>
-        struct remove_rvalue_reference<T &&>
-        {
-            using type = T;
-        };
-
-        template<typename T>
-        using remove_rvalue_reference_t = meta::_t<remove_rvalue_reference<T>>;
-
-        // Workaround bug in the Standard Library:
-        // From cannot be an incomplete class type despite that
-        // is_convertible<X, Y> should be equivalent to is_convertible<X&&, Y>
-        // in such a case.
-        template<typename From, typename To>
-        using is_convertible =
-            std::is_convertible<meta::_t<std::add_rvalue_reference<From>>, To>;
-    } // namespace detail
-    /// \endcond
-
-    struct begin_tag
-    {};
-    struct end_tag
-    {};
-    struct copy_tag
-    {};
-    struct move_tag
-    {};
-
-    template<typename T>
-    using uncvref_t = meta::_t<std::remove_cv<meta::_t<std::remove_reference<T>>>>;
-
-    struct not_equal_to;
-    struct equal_to;
-    struct less;
-#if __cplusplus > 201703L && defined(__cpp_impl_three_way_comparison) && __has_include(<compare>)
-    struct compare_three_way;
-#endif // __cplusplus
-    struct identity;
-    template<typename Pred>
-    struct logical_negate;
-
-    enum cardinality : std::ptrdiff_t
-    {
-        infinite = -3,
-        unknown = -2,
-        finite = -1
-    };
-
-    template<typename Rng, typename Void = void>
-    struct range_cardinality;
-
-    template<typename Rng>
-    using is_finite = meta::bool_<range_cardinality<Rng>::value >= finite>;
-
-    template<typename Rng>
-    using is_infinite = meta::bool_<range_cardinality<Rng>::value == infinite>;
-
-    template<typename S, typename I>
-    RANGES_INLINE_VAR constexpr bool disable_sized_sentinel = false;
-
-    template<typename R>
-    RANGES_INLINE_VAR constexpr bool enable_borrowed_range = false;
-
-    namespace detail
-    {
-        template<typename R>
-        RANGES_DEPRECATED("Please use ranges::enable_borrowed_range instead.")
-        RANGES_INLINE_VAR constexpr bool enable_safe_range = enable_borrowed_range<R>;
-    } // namespace detail
-
-    using detail::enable_safe_range;
-
-    template<typename Cur>
-    struct basic_mixin;
-
-    template<typename Cur>
-    struct RANGES_EMPTY_BASES basic_iterator;
-
-    template<cardinality>
-    struct basic_view : view_base
-    {};
-
-    template<typename Derived, cardinality C = finite>
-    struct view_facade;
-
-    template<typename Derived, typename BaseRng,
-             cardinality C = range_cardinality<BaseRng>::value>
-    struct view_adaptor;
-
-    template<typename I, typename S>
-    struct common_iterator;
-
-    /// \cond
-    namespace detail
-    {
-        template<typename I>
-        struct cpp17_iterator_cursor;
-
-        template<typename I>
-        using cpp17_iterator = basic_iterator<cpp17_iterator_cursor<I>>;
-    } // namespace detail
-    /// \endcond
-
-    template<typename First, typename Second>
-    struct compressed_pair;
-
-    template<typename T>
-    struct bind_element;
-
-    template<typename T>
-    using bind_element_t = meta::_t<bind_element<T>>;
-
-    template<typename Derived, cardinality = finite>
-    struct view_interface;
-
-    template<typename T>
-    struct istream_view;
-
-    template<typename I, typename S = I>
-    struct RANGES_EMPTY_BASES iterator_range;
-
-    template<typename I, typename S = I>
-    struct sized_iterator_range;
-
-    template<typename T>
-    struct reference_wrapper;
-
-    // Views
-    //
-    template<typename Rng, typename Pred>
-    struct RANGES_EMPTY_BASES adjacent_filter_view;
-
-    namespace views
-    {
-        struct adjacent_filter_fn;
-    }
-
-    template<typename Rng, typename Pred>
-    struct RANGES_EMPTY_BASES adjacent_remove_if_view;
-
-    namespace views
-    {
-        struct adjacent_remove_if_fn;
-    }
-
-    namespace views
-    {
-        struct all_fn;
-    }
-
-    template<typename Rng>
-    struct const_view;
-
-    namespace views
-    {
-        struct const_fn;
-    }
-
-    template<typename I>
-    struct counted_view;
-
-    namespace views
-    {
-        struct counted_fn;
-    }
-
-    struct default_sentinel_t;
-
-    template<typename I>
-    struct move_iterator;
-
-    template<typename I>
-    using move_into_iterator = basic_iterator<detail::move_into_cursor<I>>;
-
-    template<typename Rng, bool = (bool)is_infinite<Rng>()>
-    struct RANGES_EMPTY_BASES cycled_view;
-
-    namespace views
-    {
-        struct cycle_fn;
-    }
-
-    /// \cond
-    namespace detail
-    {
-        template<typename I>
-        struct reverse_cursor;
-    }
-    /// \endcond
-
-    template<typename I>
-    using reverse_iterator = basic_iterator<detail::reverse_cursor<I>>;
-
-    template<typename T>
-    struct empty_view;
-
-    namespace views
-    {
-        struct empty_fn;
-    }
-
-    template<typename Rng, typename Fun>
-    struct group_by_view;
-
-    namespace views
-    {
-        struct group_by_fn;
-    }
-
-    template<typename Rng>
-    struct indirect_view;
-
-    namespace views
-    {
-        struct indirect_fn;
-    }
-
-    struct unreachable_sentinel_t;
-
-    template<typename From, typename To = unreachable_sentinel_t>
-    struct iota_view;
-
-    template<typename From, typename To = From>
-    struct closed_iota_view;
-
-    namespace views
-    {
-        struct iota_fn;
-        struct closed_iota_fn;
-    } // namespace views
-
-    template<typename Rng>
-    struct join_view;
-
-    template<typename Rng, typename ValRng>
-    struct join_with_view;
-
-    namespace views
-    {
-        struct join_fn;
-    }
-
-    template<typename... Rngs>
-    struct concat_view;
-
-    namespace views
-    {
-        struct concat_fn;
-    }
-
-    template<typename Rng, typename Fun>
-    struct partial_sum_view;
-
-    namespace views
-    {
-        struct partial_sum_fn;
-    }
-
-    template<typename Rng>
-    struct move_view;
-
-    namespace views
-    {
-        struct move_fn;
-    }
-
-    template<typename Rng>
-    struct ref_view;
-
-    namespace views
-    {
-        struct ref_fn;
-    }
-
-    template<typename Val>
-    struct repeat_view;
-
-    namespace views
-    {
-        struct repeat_fn;
-    }
-
-    template<typename Rng>
-    struct RANGES_EMPTY_BASES reverse_view;
-
-    namespace views
-    {
-        struct reverse_fn;
-    }
-
-    template<typename Rng>
-    struct slice_view;
-
-    namespace views
-    {
-        struct slice_fn;
-    }
-
-    // template<typename Rng, typename Fun>
-    // struct split_view;
-
-    // namespace views
-    // {
-    //     struct split_fn;
-    // }
-
-    template<typename Rng>
-    struct single_view;
-
-    namespace views
-    {
-        struct single_fn;
-    }
-
-    template<typename Rng>
-    struct stride_view;
-
-    namespace views
-    {
-        struct stride_fn;
-    }
-
-    template<typename Rng>
-    struct take_view;
-
-    namespace views
-    {
-        struct take_fn;
-    }
-
-    /// \cond
-    namespace detail
-    {
-        template<typename Rng>
-        struct is_random_access_common_;
-
-        template<typename Rng,
-                 bool IsRandomAccessCommon = is_random_access_common_<Rng>::value>
-        struct take_exactly_view_;
-    } // namespace detail
-    /// \endcond
-
-    template<typename Rng>
-    using take_exactly_view = detail::take_exactly_view_<Rng>;
-
-    namespace views
-    {
-        struct take_exactly_fn;
-    }
-
-    template<typename Rng, typename Pred>
-    struct iter_take_while_view;
-
-    template<typename Rng, typename Pred>
-    struct take_while_view;
-
-    namespace views
-    {
-        struct iter_take_while_fn;
-        struct take_while_fn;
-    } // namespace views
-
-    template<typename Rng, typename Regex, typename SubMatchRange>
-    struct tokenize_view;
-
-    namespace views
-    {
-        struct tokenize_fn;
-    }
-
-    template<typename Rng, typename Fun>
-    struct iter_transform_view;
-
-    template<typename Rng, typename Fun>
-    struct transform_view;
-
-    namespace views
-    {
-        struct transform_fn;
-    }
-
-    template<typename Rng, typename Val1, typename Val2>
-    using replace_view = iter_transform_view<Rng, detail::replacer_fn<Val1, Val2>>;
-
-    template<typename Rng, typename Pred, typename Val>
-    using replace_if_view = iter_transform_view<Rng, detail::replacer_if_fn<Pred, Val>>;
-
-    namespace views
-    {
-        struct replace_fn;
-
-        struct replace_if_fn;
-    } // namespace views
-
-    template<typename Rng, typename Pred>
-    struct trim_view;
-
-    namespace views
-    {
-        struct trim_fn;
-    }
-
-    template<typename I>
-    struct unbounded_view;
-
-    namespace views
-    {
-        struct unbounded_fn;
-    }
-
-    template<typename Rng>
-    using unique_view = adjacent_filter_view<Rng, logical_negate<equal_to>>;
-
-    namespace views
-    {
-        struct unique_fn;
-    }
-
-    template<typename Rng>
-    using keys_range_view = transform_view<Rng, detail::get_first>;
-
-    template<typename Rng>
-    using values_view = transform_view<Rng, detail::get_second>;
-
-    namespace views
-    {
-        struct keys_fn;
-
-        struct values_fn;
-    } // namespace views
-
-    template<typename Fun, typename... Rngs>
-    struct iter_zip_with_view;
-
-    template<typename Fun, typename... Rngs>
-    struct zip_with_view;
-
-    template<typename... Rngs>
-    struct zip_view;
-
-    namespace views
-    {
-        struct iter_zip_with_fn;
-
-        struct zip_with_fn;
-
-        struct zip_fn;
-    } // namespace views
-} // namespace ranges
-
-/// \cond
-namespace ranges
-{
-    namespace concepts = ::concepts;
-    using namespace ::concepts::defs;
-    using ::concepts::and_v;
-} // namespace ranges
-/// \endcond
-
-RANGES_DIAGNOSTIC_POP
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/range_traits.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/range_traits.hpp
deleted file mode 100644
index 9b567431..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/range_traits.hpp
+++ /dev/null
@@ -1,22 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_OLD_RANGE_TRAITS_HPP
-#define RANGES_V3_OLD_RANGE_TRAITS_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated. Please #include <range/v3/range/traits.hpp> instead.")
-
-#include <range/v3/range/traits.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/size.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/size.hpp
deleted file mode 100644
index 3b70b896..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/size.hpp
+++ /dev/null
@@ -1,22 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_SIZE_HPP
-#define RANGES_V3_SIZE_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated. Please #include <range/v3/range/primitives.hpp> instead.")
-
-#include <range/v3/range/primitives.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/span.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/span.hpp
deleted file mode 100644
index 2412a626..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/span.hpp
+++ /dev/null
@@ -1,22 +0,0 @@
-// Range v3 library
-//
-//  Copyright Casey Carter 2016-2017
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_SPAN_HPP
-#define RANGES_V3_SPAN_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated. Please #include <range/v3/view/span.hpp> instead.")
-
-#include <range/v3/view/span.hpp>
-
-#endif // RANGES_V3_SPAN_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/to_container.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/to_container.hpp
deleted file mode 100644
index 85ac20b2..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/to_container.hpp
+++ /dev/null
@@ -1,22 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_TO_CONTAINER_HPP
-#define RANGES_V3_TO_CONTAINER_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated. Please #include <range/v3/range/conversion.hpp> instead.")
-
-#include <range/v3/range/conversion.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility.hpp
deleted file mode 100644
index ff9e833e..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility.hpp
+++ /dev/null
@@ -1,37 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2019-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_ITERATOR_HPP
-#define RANGES_V3_ITERATOR_HPP
-
-#include <range/v3/utility/any.hpp>
-#include <range/v3/utility/box.hpp>
-#include <range/v3/utility/common_tuple.hpp>
-#include <range/v3/utility/common_type.hpp>
-#include <range/v3/utility/compressed_pair.hpp>
-#include <range/v3/utility/copy.hpp>
-#include <range/v3/utility/get.hpp>
-#include <range/v3/utility/in_place.hpp>
-#include <range/v3/utility/memory.hpp>
-#include <range/v3/utility/move.hpp>
-#include <range/v3/utility/optional.hpp>
-#include <range/v3/utility/polymorphic_cast.hpp>
-#include <range/v3/utility/random.hpp>
-#include <range/v3/utility/scope_exit.hpp>
-#include <range/v3/utility/semiregular_box.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/utility/swap.hpp>
-#include <range/v3/utility/tuple_algorithm.hpp>
-#include <range/v3/utility/variant.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/addressof.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/addressof.hpp
deleted file mode 100644
index 4fcb58e7..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/addressof.hpp
+++ /dev/null
@@ -1,80 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_UTILITY_ADDRESSOF_HPP
-#define RANGES_V3_UTILITY_ADDRESSOF_HPP
-
-#include <memory>
-#include <type_traits>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/detail/config.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-#ifdef __cpp_lib_addressof_constexpr
-        using std::addressof;
-#else
-        namespace check_addressof
-        {
-            inline ignore_t operator&(ignore_t)
-            {
-                return {};
-            }
-            template<typename T>
-            auto addressof(T & t)
-            {
-                return &t;
-            }
-        } // namespace check_addressof
-
-        template<typename T>
-        constexpr bool has_bad_addressof()
-        {
-            return !std::is_scalar<T>::value &&
-                   !RANGES_IS_SAME(decltype(check_addressof::addressof(*(T *)nullptr)),
-                                   ignore_t);
-        }
-
-        template(typename T)(
-            /// \pre
-            requires(has_bad_addressof<T>()))
-        T * addressof(T & arg) noexcept
-        {
-            return std::addressof(arg);
-        }
-
-        template(typename T)(
-            /// \pre
-            requires (!has_bad_addressof<T>()))
-        constexpr T * addressof(T & arg) noexcept
-        {
-            return &arg;
-        }
-
-        template<typename T>
-        T const * addressof(T const &&) = delete;
-#endif
-    } // namespace detail
-    /// \endcond
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/any.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/any.hpp
deleted file mode 100644
index 1d63eb8e..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/any.hpp
+++ /dev/null
@@ -1,236 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2015-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_UTILITY_ANY_HPP
-#define RANGES_V3_UTILITY_ANY_HPP
-
-#include <memory>
-#include <type_traits>
-#include <typeinfo>
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/utility/swap.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-RANGES_DIAGNOSTIC_PUSH
-RANGES_DIAGNOSTIC_IGNORE_DEPRECATED_DECLARATIONS
-
-namespace ranges
-{
-    struct bad_any_cast : std::bad_cast
-    {
-        virtual const char * what() const noexcept override
-        {
-            return "bad any_cast";
-        }
-    };
-
-    struct RANGES_DEPRECATED(
-        "ranges::any will be going away in the not-too-distant future. "
-        "We suggest you use std::any or boost::any instead (or simply steal "
-        "this header and maintain it yourself).") any;
-
-    template<typename T>
-    meta::if_c<std::is_reference<T>() || copyable<T>, T> any_cast(any &);
-
-    template<typename T>
-    meta::if_c<std::is_reference<T>() || copyable<T>, T> any_cast(any const &);
-
-    template<typename T>
-    meta::if_c<std::is_reference<T>() || copyable<T>, T> any_cast(any &&);
-
-    template<typename T>
-    T * any_cast(any *) noexcept;
-
-    template<typename T>
-    T const * any_cast(any const *) noexcept;
-
-    struct any
-    {
-    private:
-        template<typename T>
-        friend meta::if_c<std::is_reference<T>() || (bool)copyable<T>, T> any_cast(any &);
-
-        template<typename T>
-        friend meta::if_c<std::is_reference<T>() || (bool)copyable<T>, T> any_cast(
-            any const &);
-
-        template<typename T>
-        friend meta::if_c<std::is_reference<T>() || (bool)copyable<T>, T> any_cast(
-            any &&);
-
-        template<typename T>
-        friend T * any_cast(any *) noexcept;
-
-        template<typename T>
-        friend T const * any_cast(any const *) noexcept;
-
-        struct interface
-        {
-            virtual ~interface()
-            {}
-            virtual interface * clone() const = 0;
-            virtual std::type_info const & type() const noexcept = 0;
-        };
-
-        template<typename T>
-        struct impl final : interface
-        {
-        private:
-            T obj;
-
-        public:
-            impl() = default;
-            impl(T o)
-              : obj(std::move(o))
-            {}
-            T & get()
-            {
-                return obj;
-            }
-            T const & get() const
-            {
-                return obj;
-            }
-            impl * clone() const override
-            {
-                return new impl{obj};
-            }
-            std::type_info const & type() const noexcept override
-            {
-                return typeid(T);
-            }
-        };
-
-        std::unique_ptr<interface> ptr_;
-
-    public:
-        any() noexcept = default;
-        template(typename TRef, typename T = detail::decay_t<TRef>)(
-            /// \pre
-            requires copyable<T> AND (!same_as<T, any>)) //
-        any(TRef && t)
-          : ptr_(new impl<T>(static_cast<TRef &&>(t)))
-        {}
-        any(any &&) noexcept = default;
-        any(any const & that)
-          : ptr_{that.ptr_ ? that.ptr_->clone() : nullptr}
-        {}
-        any & operator=(any &&) noexcept = default;
-        any & operator=(any const & that)
-        {
-            ptr_.reset(that.ptr_ ? that.ptr_->clone() : nullptr);
-            return *this;
-        }
-        template(typename TRef, typename T = detail::decay_t<TRef>)(
-            /// \pre
-            requires copyable<T> AND (!same_as<T, any>)) //
-        any & operator=(TRef && t)
-        {
-            any{static_cast<TRef &&>(t)}.swap(*this);
-            return *this;
-        }
-        void clear() noexcept
-        {
-            ptr_.reset();
-        }
-        bool empty() const noexcept
-        {
-            return !ptr_;
-        }
-        std::type_info const & type() const noexcept
-        {
-            return ptr_ ? ptr_->type() : typeid(void);
-        }
-        void swap(any & that) noexcept
-        {
-            ptr_.swap(that.ptr_);
-        }
-
-#if !RANGES_BROKEN_CPO_LOOKUP
-        friend void swap(any & x, any & y) noexcept
-        {
-            x.swap(y);
-        }
-#endif
-    };
-
-#if RANGES_BROKEN_CPO_LOOKUP
-    namespace _any_
-    {
-        inline void swap(any & x, any & y) noexcept
-        {
-            x.swap(y);
-        }
-    } // namespace _any_
-#endif
-
-    /// \throw bad_any_cast
-    template<typename T>
-    meta::if_c<std::is_reference<T>() || copyable<T>, T> any_cast(any & x)
-    {
-        if(x.type() != typeid(detail::decay_t<T>))
-            throw bad_any_cast{};
-        return static_cast<any::impl<detail::decay_t<T>> *>(x.ptr_.get())->get();
-    }
-
-    /// \overload
-    template<typename T>
-    meta::if_c<std::is_reference<T>() || copyable<T>, T> any_cast(any const & x)
-    {
-        if(x.type() != typeid(detail::decay_t<T>))
-            throw bad_any_cast{};
-        return static_cast<any::impl<detail::decay_t<T>> const *>(x.ptr_.get())->get();
-    }
-
-    /// \overload
-    template<typename T>
-    meta::if_c<std::is_reference<T>() || copyable<T>, T> any_cast(any && x)
-    {
-        if(x.type() != typeid(detail::decay_t<T>))
-            throw bad_any_cast{};
-        return static_cast<any::impl<detail::decay_t<T>> *>(x.ptr_.get())->get();
-    }
-
-    /// \overload
-    template<typename T>
-    T * any_cast(any * p) noexcept
-    {
-        if(p && p->ptr_)
-            if(any::impl<T> * q = dynamic_cast<any::impl<T> *>(p->ptr_.get()))
-                return &q->get();
-        return nullptr;
-    }
-
-    /// \overload
-    template<typename T>
-    T const * any_cast(any const * p) noexcept
-    {
-        if(p && p->ptr_)
-            if(any::impl<T> const * q = dynamic_cast<any::impl<T> const *>(p->ptr_.get()))
-                return &q->get();
-        return nullptr;
-    }
-} // namespace ranges
-
-RANGES_DIAGNOSTIC_POP
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/associated_types.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/associated_types.hpp
deleted file mode 100644
index d6ab188e..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/associated_types.hpp
+++ /dev/null
@@ -1,23 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-2014, 2016
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_UTILITY_ASSOCIATED_TYPES_HPP
-#define RANGES_V3_UTILITY_ASSOCIATED_TYPES_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated. Please #include <range/v3/iterator/traits.hpp> instead.")
-
-#include <range/v3/iterator/traits.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/basic_iterator.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/basic_iterator.hpp
deleted file mode 100644
index 8591d1c1..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/basic_iterator.hpp
+++ /dev/null
@@ -1,23 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_UTILITY_BASIC_ITERATOR_HPP
-#define RANGES_V3_UTILITY_BASIC_ITERATOR_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated. Please #include <range/v3/iterator/basic_iterator.hpp> "
-    "instead.")
-
-#include <range/v3/iterator/basic_iterator.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/box.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/box.hpp
deleted file mode 100644
index f7d521c7..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/box.hpp
+++ /dev/null
@@ -1,380 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_UTILITY_BOX_HPP
-#define RANGES_V3_UTILITY_BOX_HPP
-
-#include <cstdlib>
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/utility/get.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-RANGES_DIAGNOSTIC_PUSH
-RANGES_DIAGNOSTIC_IGNORE_DEPRECATED_DECLARATIONS
-
-namespace ranges
-{
-    /// \addtogroup group-utility Utility
-    /// @{
-    ///
-
-    /// \cond
-    template<typename T>
-    struct RANGES_DEPRECATED("The ranges::mutable_ class template is deprecated") mutable_
-    {
-        mutable T value;
-
-        CPP_member
-        constexpr CPP_ctor(mutable_)()(
-            /// \pre
-            requires std::is_default_constructible<T>::value)
-          : value{}
-        {}
-        constexpr explicit mutable_(T const & t)
-          : value(t)
-        {}
-        constexpr explicit mutable_(T && t)
-          : value(detail::move(t))
-        {}
-        mutable_ const & operator=(T const & t) const
-        {
-            value = t;
-            return *this;
-        }
-        mutable_ const & operator=(T && t) const
-        {
-            value = detail::move(t);
-            return *this;
-        }
-        constexpr operator T &() const &
-        {
-            return value;
-        }
-    };
-
-    template<typename T, T v>
-    struct RANGES_DEPRECATED("The ranges::constant class template is deprecated") constant
-    {
-        constant() = default;
-        constexpr explicit constant(T const &)
-        {}
-        constant & operator=(T const &)
-        {
-            return *this;
-        }
-        constant const & operator=(T const &) const
-        {
-            return *this;
-        }
-        constexpr operator T() const
-        {
-            return v;
-        }
-        constexpr T exchange(T const &) const
-        {
-            return v;
-        }
-    };
-    /// \endcond
-
-    /// \cond
-    namespace detail
-    {
-        // "box" has three different implementations that store a T differently:
-        enum class box_compress
-        {
-            none, // Nothing special: get() returns a reference to a T member subobject
-            ebo,  // Apply Empty Base Optimization: get() returns a reference to a T base
-                  // subobject
-            coalesce // Coalesce all Ts into one T: get() returns a reference to a static
-                     // T singleton
-        };
-
-        // Per N4582, lambda closures are *not*:
-        // - aggregates             ([expr.prim.lambda]/4)
-        // - default constructible_from  ([expr.prim.lambda]/p21)
-        // - copy assignable        ([expr.prim.lambda]/p21)
-        template<typename Fn>
-        using could_be_lambda = meta::bool_<!std::is_default_constructible<Fn>::value &&
-                                            !std::is_copy_assignable<Fn>::value>;
-
-        template<typename>
-        constexpr box_compress box_compression_(...)
-        {
-            return box_compress::none;
-        }
-        template<typename T, typename = meta::if_<meta::strict_and<
-                                 std::is_empty<T>,
-                                 meta::bool_<!detail::is_final_v<T>>
-#if defined(__GNUC__) && !defined(__clang__) && __GNUC__ == 6 && __GNUC_MINOR__ < 2
-                                 // GCC 6.0 & 6.1 find empty lambdas' implicit conversion
-                                 // to function pointer when doing overload resolution
-                                 // for function calls. That causes hard errors.
-                                 // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=71117
-                                 ,
-                                 meta::not_<could_be_lambda<T>>
-#endif
-                                 >>>
-        constexpr box_compress box_compression_(long)
-        {
-            return box_compress::ebo;
-        }
-#ifndef RANGES_WORKAROUND_MSVC_249830
-        // MSVC pukes passing non-constant-expression objects to constexpr
-        // functions, so do not coalesce.
-        template<typename T,
-                 typename =
-                     meta::if_<meta::strict_and<std::is_empty<T>, detail::is_trivial<T>>>>
-        constexpr box_compress box_compression_(int)
-        {
-            return box_compress::coalesce;
-        }
-#endif
-        template<typename T>
-        constexpr box_compress box_compression()
-        {
-            return box_compression_<T>(0);
-        }
-    } // namespace detail
-    /// \endcond
-
-    template<typename Element, typename Tag = void,
-             detail::box_compress = detail::box_compression<Element>()>
-    class box
-    {
-        Element value;
-
-    public:
-        CPP_member
-        constexpr CPP_ctor(box)()(                                          //
-            noexcept(std::is_nothrow_default_constructible<Element>::value) //
-                requires std::is_default_constructible<Element>::value)
-          : value{}
-        {}
-#if defined(__cpp_conditional_explicit) && __cpp_conditional_explicit > 0
-        template(typename E)(
-            /// \pre
-            requires (!same_as<box, detail::decay_t<E>>) AND
-                constructible_from<Element, E>)
-        constexpr explicit(!convertible_to<E, Element>) box(E && e)
-            noexcept(std::is_nothrow_constructible<Element, E>::value) //
-          : value(static_cast<E &&>(e))
-        {}
-#else
-        template(typename E)(
-            /// \pre
-            requires (!same_as<box, detail::decay_t<E>>) AND
-                constructible_from<Element, E> AND
-                convertible_to<E, Element>)
-        constexpr box(E && e)
-            noexcept(std::is_nothrow_constructible<Element, E>::value)
-          : value(static_cast<E &&>(e))
-        {}
-        template(typename E)(
-            /// \pre
-            requires (!same_as<box, detail::decay_t<E>>) AND
-                constructible_from<Element, E> AND
-                (!convertible_to<E, Element>))
-        constexpr explicit box(E && e)
-            noexcept(std::is_nothrow_constructible<Element, E>::value) //
-          : value(static_cast<E &&>(e))
-        {}
-#endif
-
-        constexpr Element & get() & noexcept
-        {
-            return value;
-        }
-        constexpr Element const & get() const & noexcept
-        {
-            return value;
-        }
-        constexpr Element && get() && noexcept
-        {
-            return detail::move(value);
-        }
-        constexpr Element const && get() const && noexcept
-        {
-            return detail::move(value);
-        }
-    };
-
-    template<typename Element, typename Tag>
-    class box<Element, Tag, detail::box_compress::ebo> : Element
-    {
-    public:
-        CPP_member
-        constexpr CPP_ctor(box)()(                                          //
-            noexcept(std::is_nothrow_default_constructible<Element>::value) //
-                requires std::is_default_constructible<Element>::value)
-          : Element{}
-        {}
-#if defined(__cpp_conditional_explicit) && __cpp_conditional_explicit > 0
-        template(typename E)(
-            /// \pre
-            requires (!same_as<box, detail::decay_t<E>>) AND
-                constructible_from<Element, E>)
-        constexpr explicit(!convertible_to<E, Element>) box(E && e)
-            noexcept(std::is_nothrow_constructible<Element, E>::value) //
-          : Element(static_cast<E &&>(e))
-        {}
-#else
-        template(typename E)(
-            /// \pre
-            requires (!same_as<box, detail::decay_t<E>>) AND
-                constructible_from<Element, E> AND
-                convertible_to<E, Element>)
-        constexpr box(E && e)
-            noexcept(std::is_nothrow_constructible<Element, E>::value) //
-          : Element(static_cast<E &&>(e))
-        {}
-        template(typename E)(
-            /// \pre
-            requires (!same_as<box, detail::decay_t<E>>) AND
-                constructible_from<Element, E> AND
-                (!convertible_to<E, Element>))
-        constexpr explicit box(E && e)
-            noexcept(std::is_nothrow_constructible<Element, E>::value) //
-          : Element(static_cast<E &&>(e))
-        {}
-#endif
-
-        constexpr Element & get() & noexcept
-        {
-            return *this;
-        }
-        constexpr Element const & get() const & noexcept
-        {
-            return *this;
-        }
-        constexpr Element && get() && noexcept
-        {
-            return detail::move(*this);
-        }
-        constexpr Element const && get() const && noexcept
-        {
-            return detail::move(*this);
-        }
-    };
-
-    template<typename Element, typename Tag>
-    class box<Element, Tag, detail::box_compress::coalesce>
-    {
-        static Element value;
-
-    public:
-        constexpr box() noexcept = default;
-
-#if defined(__cpp_conditional_explicit) && __cpp_conditional_explicit > 0
-        template(typename E)(
-            /// \pre
-            requires (!same_as<box, detail::decay_t<E>>) AND
-                constructible_from<Element, E>)
-        constexpr explicit(!convertible_to<E, Element>) box(E &&) noexcept
-        {}
-#else
-        template(typename E)(
-            /// \pre
-            requires (!same_as<box, detail::decay_t<E>>) AND
-                constructible_from<Element, E> AND
-                convertible_to<E, Element>)
-        constexpr box(E &&) noexcept
-        {}
-        template(typename E)(
-            /// \pre
-            requires (!same_as<box, detail::decay_t<E>>) AND
-                constructible_from<Element, E> AND
-                (!convertible_to<E, Element>))
-        constexpr explicit box(E &&) noexcept
-        {}
-#endif
-
-        constexpr Element & get() & noexcept
-        {
-            return value;
-        }
-        constexpr Element const & get() const & noexcept
-        {
-            return value;
-        }
-        constexpr Element && get() && noexcept
-        {
-            return detail::move(value);
-        }
-        constexpr Element const && get() const && noexcept
-        {
-            return detail::move(value);
-        }
-    };
-
-    template<typename Element, typename Tag>
-    Element box<Element, Tag, detail::box_compress::coalesce>::value{};
-
-    /// \cond
-    namespace _get_
-    {
-        /// \endcond
-        // Get by tag type
-        template<typename Tag, typename Element, detail::box_compress BC>
-        constexpr Element & get(box<Element, Tag, BC> & b) noexcept
-        {
-            return b.get();
-        }
-        template<typename Tag, typename Element, detail::box_compress BC>
-        constexpr Element const & get(box<Element, Tag, BC> const & b) noexcept
-        {
-            return b.get();
-        }
-        template<typename Tag, typename Element, detail::box_compress BC>
-        constexpr Element && get(box<Element, Tag, BC> && b) noexcept
-        {
-            return detail::move(b).get();
-        }
-        // Get by index
-        template<std::size_t I, typename Element, detail::box_compress BC>
-        constexpr Element & get(box<Element, meta::size_t<I>, BC> & b) noexcept
-        {
-            return b.get();
-        }
-        template<std::size_t I, typename Element, detail::box_compress BC>
-        constexpr Element const & get(
-            box<Element, meta::size_t<I>, BC> const & b) noexcept
-        {
-            return b.get();
-        }
-        template<std::size_t I, typename Element, detail::box_compress BC>
-        constexpr Element && get(box<Element, meta::size_t<I>, BC> && b) noexcept
-        {
-            return detail::move(b).get();
-        }
-        /// \cond
-    } // namespace _get_
-    /// \endcond
-    /// @}
-} // namespace ranges
-
-RANGES_DIAGNOSTIC_POP
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/common_iterator.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/common_iterator.hpp
deleted file mode 100644
index 1e0885b7..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/common_iterator.hpp
+++ /dev/null
@@ -1,23 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_UTILITY_COMMON_ITERATOR_HPP
-#define RANGES_V3_UTILITY_COMMON_ITERATOR_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated. Please #include <range/v3/iterator/common_iterator.hpp> "
-    "instead.")
-
-#include <range/v3/iterator/common_iterator.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/common_tuple.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/common_tuple.hpp
deleted file mode 100644
index eb45c7b1..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/common_tuple.hpp
+++ /dev/null
@@ -1,827 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_UTILITY_COMMON_TUPLE_HPP
-#define RANGES_V3_UTILITY_COMMON_TUPLE_HPP
-
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/detail/adl_get.hpp>
-#include <range/v3/functional/bind.hpp>
-#include <range/v3/functional/reference_wrapper.hpp>
-#include <range/v3/utility/common_type.hpp>
-#include <range/v3/utility/tuple_algorithm.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        template<typename... Us, typename Tup, std::size_t... Is>
-        std::tuple<Us...> to_std_tuple(Tup && tup, meta::index_sequence<Is...>)
-        {
-            return std::tuple<Us...>{adl_get<Is>(static_cast<Tup &&>(tup))...};
-        }
-
-#ifdef RANGES_WORKAROUND_MSVC_786312
-        template<std::size_t, typename...>
-        struct args_;
-
-        template<typename, typename>
-        inline constexpr bool argstructible = false;
-        template<std::size_t N, typename... Ts, typename... Us>
-        inline constexpr bool argstructible<args_<N, Ts...>, args_<N, Us...>> =
-            (META_IS_CONSTRUCTIBLE(Ts, Us) && ...);
-
-        template<typename, typename>
-        inline constexpr bool argsignable = false;
-        template<std::size_t N, typename... Ts, typename... Us>
-        inline constexpr bool argsignable<args_<N, Ts...>, args_<N, Us...>> =
-            (std::is_assignable_v<Ts &, Us> && ...);
-#endif // RANGES_WORKAROUND_MSVC_786312
-
-        template<std::size_t N, typename... Ts>
-        struct args_
-        {
-            template<typename... Us>
-            args_(args_<N, Us...>, meta::if_c<
-#ifdef RANGES_WORKAROUND_MSVC_786312
-                                       argstructible<args_, args_<N, Us...>>
-#else  // ^^^ workaround / no workaround vvv
-                                       meta::and_c<META_IS_CONSTRUCTIBLE(Ts,
-                                                                         Us)...>::value
-#endif // RANGES_WORKAROUND_MSVC_786312
-                                       > * = nullptr)
-            {}
-            template<typename... Us>
-            meta::if_c<
-#ifdef RANGES_WORKAROUND_MSVC_786312
-                argsignable<args_, args_<N, Us...>>,
-#else  // ^^^ workaround / no workaround vvv
-                meta::and_c<std::is_assignable<Ts &, Us>::value...>::value,
-#endif // RANGES_WORKAROUND_MSVC_786312
-                args_ &>
-            operator=(args_<N, Us...>)
-            {
-                return *this;
-            }
-        };
-        template<typename... Ts>
-        using args = args_<sizeof...(Ts), Ts...>;
-        template<typename... Ts>
-        using rargs = args_<sizeof...(Ts), Ts &...>;
-    } // namespace detail
-    /// \endcond
-
-    template<typename... Ts>
-    struct common_tuple : _tuple_wrapper_::forward_tuple_interface<std::tuple<Ts...>>
-    {
-    private:
-        template<typename That, std::size_t... Is>
-        common_tuple(That && that, meta::index_sequence<Is...>)
-          : common_tuple::forward_tuple_interface{
-                detail::adl_get<Is>(static_cast<That &&>(that))...}
-        {}
-        struct element_assign_
-        {
-            template<typename T, typename U>
-            int operator()(T & t, U && u) const
-            {
-                t = static_cast<U &&>(u);
-                return 0;
-            }
-        };
-
-    public:
-        // Construction
-        CPP_member
-        CPP_ctor(common_tuple)()( //
-            noexcept( //
-                meta::and_c<std::is_nothrow_default_constructible<Ts>::value...>::value)
-                requires default_constructible<std::tuple<Ts...>>)
-          : common_tuple::forward_tuple_interface{}
-        {}
-        template(typename... Us)(
-            /// \pre
-            requires constructible_from<detail::args<Ts...>, detail::args<Us...>>)
-        explicit common_tuple(Us &&... us) //
-            noexcept(meta::and_c<std::is_nothrow_constructible<Ts, Us>::value...>::value)
-          : common_tuple::forward_tuple_interface{static_cast<Us &&>(us)...}
-        {}
-        template(typename... Us)(
-            /// \pre
-            requires constructible_from<detail::args<Ts...>, detail::rargs<Us...>>)
-        common_tuple(std::tuple<Us...> & that) //
-            noexcept(
-                meta::and_c<std::is_nothrow_constructible<Ts, Us &>::value...>::value) //
-          : common_tuple(that, meta::make_index_sequence<sizeof...(Ts)>{})
-        {}
-        template(typename... Us)(
-            /// \pre
-            requires constructible_from<detail::args<Ts...>, detail::rargs<Us const...>>)
-        common_tuple(std::tuple<Us...> const & that) //
-            noexcept(meta::and_c<
-                     std::is_nothrow_constructible<Ts, Us const &>::value...>::value) //
-          : common_tuple(that, meta::make_index_sequence<sizeof...(Ts)>{})
-        {}
-        template(typename... Us)(
-            /// \pre
-            requires constructible_from<detail::args<Ts...>, detail::args<Us...>>)
-        common_tuple(std::tuple<Us...> && that) //
-            noexcept(
-                meta::and_c<std::is_nothrow_constructible<Ts, Us>::value...>::value) //
-          : common_tuple(std::move(that), meta::make_index_sequence<sizeof...(Ts)>{})
-        {}
-        template(typename... Us)(
-            /// \pre
-            requires constructible_from<detail::args<Ts...>, detail::rargs<Us...>>)
-        common_tuple(common_tuple<Us...> & that) //
-            noexcept(
-                meta::and_c<std::is_nothrow_constructible<Ts, Us &>::value...>::value) //
-          : common_tuple(that, meta::make_index_sequence<sizeof...(Ts)>{})
-        {}
-        template(typename... Us)(
-            /// \pre
-            requires constructible_from<detail::args<Ts...>, detail::rargs<Us const...>>)
-        common_tuple(common_tuple<Us...> const & that) //
-            noexcept(meta::and_c<
-                     std::is_nothrow_constructible<Ts, Us const &>::value...>::value) //
-          : common_tuple(that, meta::make_index_sequence<sizeof...(Ts)>{})
-        {}
-        template(typename... Us)(
-            /// \pre
-            requires constructible_from<detail::args<Ts...>, detail::args<Us...>>)
-        common_tuple(common_tuple<Us...> && that) //
-            noexcept(
-                meta::and_c<std::is_nothrow_constructible<Ts, Us>::value...>::value) //
-          : common_tuple(std::move(that), meta::make_index_sequence<sizeof...(Ts)>{})
-        {}
-
-        std::tuple<Ts...> & base() noexcept
-        {
-            return *this;
-        }
-        std::tuple<Ts...> const & base() const noexcept
-        {
-            return *this;
-        }
-
-        // Assignment
-        template(typename... Us)(
-            /// \pre
-            requires std::is_assignable<detail::args<Ts...> &,
-                                        detail::rargs<Us...>>::value) //
-        common_tuple & operator=(std::tuple<Us...> & that) noexcept(
-            meta::and_c<std::is_nothrow_assignable<Ts &, Us &>::value...>::value)
-        {
-            (void)tuple_transform(base(), that, element_assign_{});
-            return *this;
-        }
-        template(typename... Us)(
-            /// \pre
-            requires std::is_assignable<detail::args<Ts...> &,
-                                        detail::rargs<Us const...>>::value) //
-        common_tuple & operator=(std::tuple<Us...> const & that) noexcept(
-            meta::and_c<std::is_nothrow_assignable<Ts &, Us const &>::value...>::value)
-        {
-            (void)tuple_transform(base(), that, element_assign_{});
-            return *this;
-        }
-        template(typename... Us)(
-            /// \pre
-            requires std::is_assignable<detail::args<Ts...> &,
-                                        detail::args<Us...>>::value) //
-        common_tuple & operator=(std::tuple<Us...> && that) noexcept(
-            meta::and_c<std::is_nothrow_assignable<Ts &, Us>::value...>::value)
-        {
-            (void)tuple_transform(base(), std::move(that), element_assign_{});
-            return *this;
-        }
-
-        template(typename... Us)(
-            /// \pre
-            requires std::is_assignable<detail::args<Ts const...> &,
-                                        detail::rargs<Us...>>::value)
-        common_tuple const & operator=(std::tuple<Us...> & that) const noexcept(
-            meta::and_c<std::is_nothrow_assignable<Ts const &, Us &>::value...>::value)
-        {
-            (void)tuple_transform(base(), that, element_assign_{});
-            return *this;
-        }
-        template(typename... Us)(
-            /// \pre
-            requires std::is_assignable<detail::args<Ts const...> &,
-                                        detail::rargs<Us const...>>::value)
-        common_tuple const & operator=(std::tuple<Us...> const & that) const
-            noexcept(meta::and_c<
-                     std::is_nothrow_assignable<Ts const &, Us const &>::value...>::value)
-        {
-            (void)tuple_transform(base(), that, element_assign_{});
-            return *this;
-        }
-        template(typename... Us)(
-            /// \pre
-            requires std::is_assignable<detail::args<Ts const...> &,
-                                        detail::args<Us...>>::value)
-        common_tuple const & operator=(std::tuple<Us...> && that) const noexcept(
-            meta::and_c<std::is_nothrow_assignable<Ts const &, Us &&>::value...>::value)
-        {
-            (void)tuple_transform(base(), std::move(that), element_assign_{});
-            return *this;
-        }
-
-        // Conversion
-        template(typename... Us)(
-            /// \pre
-            requires constructible_from<detail::args<Us...>, detail::rargs<Ts...>>)
-        operator std::tuple<Us...>() & noexcept(
-                meta::and_c<std::is_nothrow_constructible<Us, Ts &>::value...>::value)
-        {
-            return detail::to_std_tuple<Us...>(
-                *this, meta::make_index_sequence<sizeof...(Ts)>{});
-        }
-        template(typename... Us)(
-            /// \pre
-            requires constructible_from<detail::args<Us...>,
-                                        detail::rargs<Ts const...>>)
-        operator std::tuple<Us...>() const & noexcept(
-            meta::and_c<std::is_nothrow_constructible<Us, Ts const &>::value...>::value)
-        {
-            return detail::to_std_tuple<Us...>(
-                *this, meta::make_index_sequence<sizeof...(Ts)>{});
-        }
-        template(typename... Us)(
-            /// \pre
-            requires constructible_from<detail::args<Us...>, detail::args<Ts...>>)
-        operator std::tuple<Us...>() &&
-            noexcept(meta::and_c<std::is_nothrow_constructible<Us, Ts>::value...>::value)
-        {
-            return detail::to_std_tuple<Us...>(
-                std::move(*this), meta::make_index_sequence<sizeof...(Ts)>{});
-        }
-    };
-
-    // Logical operators
-#define LOGICAL_OP(OP, CONCEPT)                                                    \
-    template(typename... Ts, typename... Us)(                                      \
-        requires and_v<CONCEPT<Ts, Us>...>)                                        \
-    bool operator OP(common_tuple<Ts...> const & a, common_tuple<Us...> const & b) \
-    {                                                                              \
-        return a.base() OP b.base();                                               \
-    }                                                                              \
-    template(typename... Ts, typename... Us)(                                      \
-        requires and_v<CONCEPT<Ts, Us>...>)                                        \
-    bool operator OP(std::tuple<Ts...> const & a, common_tuple<Us...> const & b)   \
-    {                                                                              \
-        return a OP b.base();                                                      \
-    }                                                                              \
-    template(typename... Ts, typename... Us)(                                      \
-        requires and_v<CONCEPT<Ts, Us>...>)                                        \
-    bool operator OP(common_tuple<Ts...> const & a, std::tuple<Us...> const & b)   \
-    {                                                                              \
-        return a.base() OP b;                                                      \
-    }                                                                              \
-    /**/
-    LOGICAL_OP(==, equality_comparable_with)
-    LOGICAL_OP(!=, equality_comparable_with)
-    LOGICAL_OP(<, totally_ordered_with)
-    LOGICAL_OP(<=, totally_ordered_with)
-    LOGICAL_OP(>, totally_ordered_with)
-    LOGICAL_OP(>=, totally_ordered_with)
-#undef LOGICAL_OP
-
-    struct make_common_tuple_fn
-    {
-        template<typename... Args>
-        common_tuple<bind_element_t<Args>...> operator()(Args &&... args) const noexcept(
-            meta::and_c<std::is_nothrow_constructible<
-                bind_element_t<Args>, unwrap_reference_t<Args>>::value...>::value)
-        {
-            return common_tuple<bind_element_t<Args>...>{
-                unwrap_reference(static_cast<Args &&>(args))...};
-        }
-    };
-
-    /// \ingroup group-utility
-    /// \sa `make_common_tuple_fn`
-    RANGES_INLINE_VARIABLE(make_common_tuple_fn, make_common_tuple)
-
-    template<typename F, typename S>
-    struct common_pair : std::pair<F, S>
-    {
-    private:
-        std::pair<F, S> const & base() const noexcept
-        {
-            return *this;
-        }
-
-    public:
-        // Construction
-        CPP_member
-        CPP_ctor(common_pair)()( //
-            noexcept(std::is_nothrow_default_constructible<F>::value && //
-                     std::is_nothrow_default_constructible<S>::value) //
-            requires default_constructible<F> && default_constructible<S>)
-          : std::pair<F, S>{}
-        {}
-        template(typename F2, typename S2)(
-            /// \pre
-            requires constructible_from<F, F2> AND constructible_from<S, S2>)
-        common_pair(F2 && f2, S2 && s2) //
-            noexcept(std::is_nothrow_constructible<F, F2>::value &&
-                     std::is_nothrow_constructible<S, S2>::value) //
-          : std::pair<F, S>{static_cast<F2 &&>(f2), static_cast<S2 &&>(s2)}
-        {}
-        template(typename F2, typename S2)(
-            /// \pre
-            requires constructible_from<F, F2 &> AND constructible_from<S, S2 &>)
-        common_pair(std::pair<F2, S2> & that) //
-            noexcept(std::is_nothrow_constructible<F, F2 &>::value &&
-                     std::is_nothrow_constructible<S, S2 &>::value) //
-          : std::pair<F, S>{that.first, that.second}
-        {}
-        template(typename F2, typename S2)(
-            /// \pre
-            requires constructible_from<F, F2 const &> AND
-                constructible_from<S, S2 const &>)
-        common_pair(std::pair<F2, S2> const & that) //
-            noexcept(std::is_nothrow_constructible<F, F2 const &>::value &&
-                     std::is_nothrow_constructible<S, S2 const &>::value) //
-          : std::pair<F, S>{that.first, that.second}
-        {}
-        template(typename F2, typename S2)(
-            /// \pre
-            requires constructible_from<F, F2> AND constructible_from<S, S2>)
-        common_pair(std::pair<F2, S2> && that) //
-            noexcept(std::is_nothrow_constructible<F, F2>::value &&
-                     std::is_nothrow_constructible<S, S2>::value) //
-          : std::pair<F, S>{std::forward<F2>(that.first), std::forward<S2>(that.second)}
-        {}
-
-        // Conversion
-        template(typename F2, typename S2)(
-            /// \pre
-            requires constructible_from<F2, F &> AND constructible_from<S2, S &>)
-        operator std::pair<F2, S2>() & //
-            noexcept(std::is_nothrow_constructible<F2, F &>::value &&
-                     std::is_nothrow_constructible<S2, S &>::value)
-        {
-            return {this->first, this->second};
-        }
-        template(typename F2, typename S2)(
-            /// \pre
-            requires constructible_from<F2, F const &> AND
-                constructible_from<S2, S const &>)
-        operator std::pair<F2, S2>() const & //
-            noexcept(std::is_nothrow_constructible<F2, F const &>::value &&
-                     std::is_nothrow_constructible<S2, S const &>::value)
-        {
-            return {this->first, this->second};
-        }
-        template(typename F2, typename S2)(
-            /// \pre
-            requires constructible_from<F2, F> AND constructible_from<S2, S>)
-        operator std::pair<F2, S2>() &&
-            noexcept(std::is_nothrow_constructible<F2, F>::value &&
-                     std::is_nothrow_constructible<S2, S>::value)
-        {
-            return {std::forward<F>(this->first), std::forward<S>(this->second)};
-        }
-
-        // Assignment
-        template(typename F2, typename S2)(
-            /// \pre
-            requires assignable_from<F &, F2 &> AND assignable_from<S &, S2 &>)
-        common_pair & operator=(std::pair<F2, S2> & that) //
-            noexcept(std::is_nothrow_assignable<F &, F2 &>::value &&
-                     std::is_nothrow_assignable<S &, S2 &>::value)
-        {
-            this->first = that.first;
-            this->second = that.second;
-            return *this;
-        }
-        template(typename F2, typename S2)(
-            /// \pre
-            requires assignable_from<F &, F2 const &> AND
-                assignable_from<S &, S2 const &>)
-        common_pair & operator=(std::pair<F2, S2> const & that) //
-            noexcept(std::is_nothrow_assignable<F &, F2 const &>::value &&
-                     std::is_nothrow_assignable<S &, S2 const &>::value)
-        {
-            this->first = that.first;
-            this->second = that.second;
-            return *this;
-        }
-        template(typename F2, typename S2)(
-            /// \pre
-            requires assignable_from<F &, F2> AND assignable_from<S &, S2>)
-        common_pair & operator=(std::pair<F2, S2> && that) //
-            noexcept(std::is_nothrow_assignable<F &, F2>::value &&
-                     std::is_nothrow_assignable<S &, S2>::value)
-        {
-            this->first = static_cast<F2 &&>(that.first);
-            this->second = static_cast<S2 &&>(that.second);
-            return *this;
-        }
-
-        template(typename F2, typename S2)(
-            /// \pre
-            requires assignable_from<F const &, F2 &> AND
-                assignable_from<S const &, S2 &>)
-        common_pair const & operator=(std::pair<F2, S2> & that) const //
-            noexcept(std::is_nothrow_assignable<F const &, F2 &>::value &&
-                     std::is_nothrow_assignable<S const &, S2 &>::value)
-        {
-            this->first = that.first;
-            this->second = that.second;
-            return *this;
-        }
-        template(typename F2, typename S2)(
-            /// \pre
-            requires assignable_from<F const &, F2 const &> AND
-                        assignable_from<S const &, S2 const &>)
-        common_pair const & operator=(std::pair<F2, S2> const & that) const //
-            noexcept(std::is_nothrow_assignable<F const &, F2 const &>::value &&
-                     std::is_nothrow_assignable<S const &, S2 const &>::value)
-        {
-            this->first = that.first;
-            this->second = that.second;
-            return *this;
-        }
-        template(typename F2, typename S2)(
-            /// \pre
-            requires assignable_from<F const &, F2> AND assignable_from<S const &, S2>)
-        common_pair const & operator=(std::pair<F2, S2> && that) const //
-            noexcept(std::is_nothrow_assignable<F const &, F2 &&>::value &&
-                     std::is_nothrow_assignable<S const &, S2 &&>::value)
-        {
-            this->first = static_cast<F2 &&>(that.first);
-            this->second = static_cast<S2 &&>(that.second);
-            return *this;
-        }
-    };
-
-    // Logical operators
-    template(typename F1, typename S1, typename F2, typename S2)(
-        /// \pre
-        requires equality_comparable_with<F1, F2> AND equality_comparable_with<S1, S2>)
-    bool operator==(common_pair<F1, S1> const & a, common_pair<F2, S2> const & b)
-    {
-        return a.first == b.first && a.second == b.second;
-    }
-    template(typename F1, typename S1, typename F2, typename S2)(
-        /// \pre
-        requires equality_comparable_with<F1, F2> AND equality_comparable_with<S1, S2>)
-    bool operator==(common_pair<F1, S1> const & a, std::pair<F2, S2> const & b)
-    {
-        return a.first == b.first && a.second == b.second;
-    }
-    template(typename F1, typename S1, typename F2, typename S2)(
-        /// \pre
-        requires equality_comparable_with<F1, F2> AND equality_comparable_with<S1, S2>)
-    bool operator==(std::pair<F1, S1> const & a, common_pair<F2, S2> const & b)
-    {
-        return a.first == b.first && a.second == b.second;
-    }
-    template(typename F1, typename S1, typename F2, typename S2)(
-        /// \pre
-        requires totally_ordered_with<F1, F2> AND totally_ordered_with<S1, S2>)
-    bool operator<(common_pair<F1, S1> const & a, common_pair<F2, S2> const & b)
-    {
-        return a.first < b.first || (!(b.first < a.first) && a.second < b.second);
-    }
-    template(typename F1, typename S1, typename F2, typename S2)(
-        /// \pre
-        requires totally_ordered_with<F1, F2> AND totally_ordered_with<S1, S2>)
-    bool operator<(std::pair<F1, S1> const & a, common_pair<F2, S2> const & b)
-    {
-        return a.first < b.first || (!(b.first < a.first) && a.second < b.second);
-    }
-    template(typename F1, typename S1, typename F2, typename S2)(
-        /// \pre
-        requires totally_ordered_with<F1, F2> AND totally_ordered_with<S1, S2>)
-    bool operator<(common_pair<F1, S1> const & a, std::pair<F2, S2> const & b)
-    {
-        return a.first < b.first || (!(b.first < a.first) && a.second < b.second);
-    }
-#define LOGICAL_OP(OP, CONCEPT, RET)                                               \
-    template(typename F1, typename S1, typename F2, typename S2)(                  \
-        requires CONCEPT<F1, F2> AND CONCEPT<S1, S2>)                              \
-    bool operator OP(common_pair<F1, S1> const & a, common_pair<F2, S2> const & b) \
-    {                                                                              \
-        return RET;                                                                \
-    }                                                                              \
-    template(typename F1, typename S1, typename F2, typename S2)(                  \
-        requires CONCEPT<F1, F2> AND CONCEPT<S1, S2>)                              \
-    bool operator OP(std::pair<F1, S1> const & a, common_pair<F2, S2> const & b)   \
-    {                                                                              \
-        return RET;                                                                \
-    }                                                                              \
-    template(typename F1, typename S1, typename F2, typename S2)(                  \
-        requires CONCEPT<F1, F2> AND CONCEPT<S1, S2>)                              \
-    bool operator OP(common_pair<F1, S1> const & a, std::pair<F2, S2> const & b)   \
-    {                                                                              \
-        return RET;                                                                \
-    }                                                                              \
-    /**/
-    LOGICAL_OP(!=, equality_comparable_with, !(a == b))
-    LOGICAL_OP(<=, totally_ordered_with, !(b < a))
-    LOGICAL_OP(>, totally_ordered_with, (b < a))
-    LOGICAL_OP(>=, totally_ordered_with, !(a < b))
-#undef LOGICAL_OP
-
-    struct make_common_pair_fn
-    {
-        template<typename First, typename Second, typename F = bind_element_t<First>,
-                 typename S = bind_element_t<Second>>
-        common_pair<F, S> operator()(First && f, Second && s) const //
-            noexcept(std::is_nothrow_constructible<F, unwrap_reference_t<First>>::value &&
-                     std::is_nothrow_constructible<F, unwrap_reference_t<Second>>::value)
-        {
-            return {unwrap_reference(static_cast<First &&>(f)),
-                    unwrap_reference(static_cast<Second &&>(s))};
-        }
-    };
-
-    /// \ingroup group-utility
-    /// \sa `make_common_pair_fn`
-    RANGES_INLINE_VARIABLE(make_common_pair_fn, make_common_pair)
-
-    /// \cond
-    namespace detail
-    {
-        template<typename, typename, typename, typename = void>
-        struct common_type_tuple_like
-        {};
-
-        template<template<typename...> class T0, typename... Ts,
-                 template<typename...> class T1, typename... Us, typename TupleLike>
-        struct common_type_tuple_like<T0<Ts...>, T1<Us...>, TupleLike,
-                                      meta::if_c<sizeof...(Ts) == sizeof...(Us)>>
-          : meta::lazy::let<
-                meta::lazy::invoke<TupleLike, meta::lazy::_t<common_type<Ts, Us>>...>>
-        {};
-
-        template<typename, typename, typename, typename = void>
-        struct common_ref_tuple_like
-        {};
-
-        template<template<typename...> class T0, typename... Ts,
-                 template<typename...> class T1, typename... Us, typename TupleLike>
-        struct common_ref_tuple_like<T0<Ts...>, T1<Us...>, TupleLike,
-                                     meta::if_c<sizeof...(Ts) == sizeof...(Us)>>
-          : meta::lazy::let<meta::lazy::invoke<
-                TupleLike, meta::lazy::_t<common_reference<Ts, Us>>...>>
-        {};
-    } // namespace detail
-    /// \endcond
-} // namespace ranges
-
-/// \cond
-namespace concepts
-{
-    // common_type for pairs
-    template<typename F1, typename S1, typename F2, typename S2>
-    struct common_type<std::pair<F1, S1>, ranges::common_pair<F2, S2>>
-      : ranges::detail::common_type_tuple_like<
-            std::pair<F1, S1>, ranges::common_pair<F2, S2>,
-            meta::quote<ranges::common_pair>>
-    {};
-    template<typename F1, typename S1, typename F2, typename S2>
-    struct common_type<ranges::common_pair<F1, S1>, std::pair<F2, S2>>
-      : ranges::detail::common_type_tuple_like<
-            ranges::common_pair<F1, S1>, std::pair<F2, S2>,
-            meta::quote<ranges::common_pair>>
-    {};
-    template<typename F1, typename S1, typename F2, typename S2>
-    struct common_type<ranges::common_pair<F1, S1>, ranges::common_pair<F2, S2>>
-      : ranges::detail::common_type_tuple_like<ranges::common_pair<F1, S1>,
-                                               ranges::common_pair<F2, S2>,
-                                               meta::quote<ranges::common_pair>>
-    {};
-    // common_type for tuples
-    template<typename... Ts, typename... Us>
-    struct common_type<ranges::common_tuple<Ts...>, std::tuple<Us...>>
-      : ranges::detail::common_type_tuple_like<
-            ranges::common_tuple<Ts...>, std::tuple<Us...>,
-            meta::quote<ranges::common_tuple>>
-    {};
-    template<typename... Ts, typename... Us>
-    struct common_type<std::tuple<Ts...>, ranges::common_tuple<Us...>>
-      : ranges::detail::common_type_tuple_like<
-            std::tuple<Ts...>, ranges::common_tuple<Us...>,
-            meta::quote<ranges::common_tuple>>
-    {};
-    template<typename... Ts, typename... Us>
-    struct common_type<ranges::common_tuple<Ts...>, ranges::common_tuple<Us...>>
-      : ranges::detail::common_type_tuple_like<ranges::common_tuple<Ts...>,
-                                               ranges::common_tuple<Us...>,
-                                               meta::quote<ranges::common_tuple>>
-    {};
-
-    // common reference for pairs
-    template<typename F1, typename S1, typename F2, typename S2,
-             template<typename> class Qual1, template<typename> class Qual2>
-    struct basic_common_reference<ranges::common_pair<F1, S1>, std::pair<F2, S2>, Qual1,
-                                  Qual2>
-      : ranges::detail::common_ref_tuple_like<
-            ranges::common_pair<Qual1<F1>, Qual1<S1>>, std::pair<Qual2<F2>, Qual2<S2>>,
-            meta::quote<ranges::common_pair>>
-    {};
-    template<typename F1, typename S1, typename F2, typename S2,
-             template<typename> class Qual1, template<typename> class Qual2>
-    struct basic_common_reference<std::pair<F1, S1>, ranges::common_pair<F2, S2>, Qual1,
-                                  Qual2>
-      : ranges::detail::common_ref_tuple_like<
-            std::pair<Qual1<F1>, Qual1<S1>>, ranges::common_pair<Qual2<F2>, Qual2<S2>>,
-            meta::quote<ranges::common_pair>>
-    {};
-    template<typename F1, typename S1, typename F2, typename S2,
-             template<typename> class Qual1, template<typename> class Qual2>
-    struct basic_common_reference<ranges::common_pair<F1, S1>,
-                                  ranges::common_pair<F2, S2>, Qual1, Qual2>
-      : ranges::detail::common_ref_tuple_like<ranges::common_pair<Qual1<F1>, Qual1<S1>>,
-                                              ranges::common_pair<Qual2<F2>, Qual2<S2>>,
-                                              meta::quote<ranges::common_pair>>
-    {};
-    // common reference for tuples
-    template<typename... Ts, typename... Us, template<typename> class Qual1,
-             template<typename> class Qual2>
-    struct basic_common_reference<ranges::common_tuple<Ts...>, std::tuple<Us...>, Qual1,
-                                  Qual2>
-      : ranges::detail::common_ref_tuple_like<
-            ranges::common_tuple<Qual1<Ts>...>, std::tuple<Qual2<Us>...>,
-            meta::quote<ranges::common_tuple>>
-    {};
-    template<typename... Ts, typename... Us, template<typename> class Qual1,
-             template<typename> class Qual2>
-    struct basic_common_reference<std::tuple<Ts...>, ranges::common_tuple<Us...>, Qual1,
-                                  Qual2>
-      : ranges::detail::common_ref_tuple_like<
-            std::tuple<Qual1<Ts>...>, ranges::common_tuple<Qual2<Us>...>,
-            meta::quote<ranges::common_tuple>>
-    {};
-    template<typename... Ts, typename... Us, template<typename> class Qual1,
-             template<typename> class Qual2>
-    struct basic_common_reference<ranges::common_tuple<Ts...>,
-                                  ranges::common_tuple<Us...>, Qual1, Qual2>
-      : ranges::detail::common_ref_tuple_like<ranges::common_tuple<Qual1<Ts>...>,
-                                              ranges::common_tuple<Qual2<Us>...>,
-                                              meta::quote<ranges::common_tuple>>
-    {};
-} // namespace concepts
-/// \endcond
-
-RANGES_DIAGNOSTIC_PUSH
-RANGES_DIAGNOSTIC_IGNORE_MISMATCHED_TAGS
-RANGES_BEGIN_NAMESPACE_STD
-    template<typename First, typename Second>
-    struct tuple_size<::ranges::common_pair<First, Second>>
-      : std::integral_constant<size_t, 2>
-    {};
-
-    template<typename First, typename Second>
-    struct tuple_element<0, ::ranges::common_pair<First, Second>>
-    {
-        using type = First;
-    };
-
-    template<typename First, typename Second>
-    struct tuple_element<1, ::ranges::common_pair<First, Second>>
-    {
-        using type = Second;
-    };
-
-    template<typename... Ts>
-    struct tuple_size<::ranges::common_tuple<Ts...>>
-      : std::integral_constant<size_t, sizeof...(Ts)>
-    {};
-
-    template<size_t N, typename... Ts>
-    struct tuple_element<N, ::ranges::common_tuple<Ts...>>
-      : tuple_element<N, tuple<Ts...>>
-    {};
-
-#if RANGES_CXX_VER > RANGES_CXX_STD_17
-RANGES_BEGIN_NAMESPACE_VERSION
-    template<typename...>
-    struct common_type;
-
-    // common_type for pairs
-    template<typename F1, typename S1, typename F2, typename S2>
-    struct common_type<std::pair<F1, S1>, ::ranges::common_pair<F2, S2>>
-      : ::ranges::detail::common_type_tuple_like<
-            std::pair<F1, S1>, ::ranges::common_pair<F2, S2>,
-            ::meta::quote<::ranges::common_pair>>
-    {};
-    template<typename F1, typename S1, typename F2, typename S2>
-    struct common_type<::ranges::common_pair<F1, S1>, std::pair<F2, S2>>
-      : ::ranges::detail::common_type_tuple_like<
-            ::ranges::common_pair<F1, S1>, std::pair<F2, S2>,
-            ::meta::quote<::ranges::common_pair>>
-    {};
-    template<typename F1, typename S1, typename F2, typename S2>
-    struct common_type<::ranges::common_pair<F1, S1>, ::ranges::common_pair<F2, S2>>
-      : ::ranges::detail::common_type_tuple_like<::ranges::common_pair<F1, S1>,
-                                               ::ranges::common_pair<F2, S2>,
-                                               ::meta::quote<::ranges::common_pair>>
-    {};
-    // common_type for tuples
-    template<typename... Ts, typename... Us>
-    struct common_type<::ranges::common_tuple<Ts...>, std::tuple<Us...>>
-      : ::ranges::detail::common_type_tuple_like<
-            ::ranges::common_tuple<Ts...>, std::tuple<Us...>,
-            ::meta::quote<::ranges::common_tuple>>
-    {};
-    template<typename... Ts, typename... Us>
-    struct common_type<std::tuple<Ts...>, ::ranges::common_tuple<Us...>>
-      : ::ranges::detail::common_type_tuple_like<
-            std::tuple<Ts...>, ::ranges::common_tuple<Us...>,
-            ::meta::quote<::ranges::common_tuple>>
-    {};
-    template<typename... Ts, typename... Us>
-    struct common_type<::ranges::common_tuple<Ts...>, ::ranges::common_tuple<Us...>>
-      : ::ranges::detail::common_type_tuple_like<::ranges::common_tuple<Ts...>,
-                                               ::ranges::common_tuple<Us...>,
-                                               ::meta::quote<::ranges::common_tuple>>
-    {};
-
-    template<typename, typename, template<typename> class, template<typename> class>
-    struct basic_common_reference;
-
-    // common reference for pairs
-    template<typename F1, typename S1, typename F2, typename S2,
-             template<typename> class Qual1, template<typename> class Qual2>
-    struct basic_common_reference<::ranges::common_pair<F1, S1>, std::pair<F2, S2>, Qual1,
-                                  Qual2>
-      : ::ranges::detail::common_ref_tuple_like<
-            ::ranges::common_pair<Qual1<F1>, Qual1<S1>>, std::pair<Qual2<F2>, Qual2<S2>>,
-            ::meta::quote<::ranges::common_pair>>
-    {};
-    template<typename F1, typename S1, typename F2, typename S2,
-             template<typename> class Qual1, template<typename> class Qual2>
-    struct basic_common_reference<std::pair<F1, S1>, ::ranges::common_pair<F2, S2>, Qual1,
-                                  Qual2>
-      : ::ranges::detail::common_ref_tuple_like<
-            std::pair<Qual1<F1>, Qual1<S1>>, ::ranges::common_pair<Qual2<F2>, Qual2<S2>>,
-            ::meta::quote<::ranges::common_pair>>
-    {};
-    template<typename F1, typename S1, typename F2, typename S2,
-             template<typename> class Qual1, template<typename> class Qual2>
-    struct basic_common_reference<::ranges::common_pair<F1, S1>,
-                                  ::ranges::common_pair<F2, S2>, Qual1, Qual2>
-      : ::ranges::detail::common_ref_tuple_like<::ranges::common_pair<Qual1<F1>, Qual1<S1>>,
-                                              ::ranges::common_pair<Qual2<F2>, Qual2<S2>>,
-                                              ::meta::quote<::ranges::common_pair>>
-    {};
-    // common reference for tuples
-    template<typename... Ts, typename... Us, template<typename> class Qual1,
-             template<typename> class Qual2>
-    struct basic_common_reference<::ranges::common_tuple<Ts...>, std::tuple<Us...>, Qual1,
-                                  Qual2>
-      : ::ranges::detail::common_ref_tuple_like<
-            ::ranges::common_tuple<Qual1<Ts>...>, std::tuple<Qual2<Us>...>,
-            ::meta::quote<::ranges::common_tuple>>
-    {};
-    template<typename... Ts, typename... Us, template<typename> class Qual1,
-             template<typename> class Qual2>
-    struct basic_common_reference<std::tuple<Ts...>, ::ranges::common_tuple<Us...>, Qual1,
-                                  Qual2>
-      : ::ranges::detail::common_ref_tuple_like<
-            std::tuple<Qual1<Ts>...>, ::ranges::common_tuple<Qual2<Us>...>,
-            ::meta::quote<::ranges::common_tuple>>
-    {};
-    template<typename... Ts, typename... Us, template<typename> class Qual1,
-             template<typename> class Qual2>
-    struct basic_common_reference<::ranges::common_tuple<Ts...>,
-                                  ::ranges::common_tuple<Us...>, Qual1, Qual2>
-      : ::ranges::detail::common_ref_tuple_like<::ranges::common_tuple<Qual1<Ts>...>,
-                                              ::ranges::common_tuple<Qual2<Us>...>,
-                                              ::meta::quote<::ranges::common_tuple>>
-    {};
-RANGES_END_NAMESPACE_VERSION
-#endif // RANGES_CXX_VER > RANGES_CXX_STD_17
-RANGES_END_NAMESPACE_STD
-RANGES_DIAGNOSTIC_POP
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/common_type.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/common_type.hpp
deleted file mode 100644
index cd738170..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/common_type.hpp
+++ /dev/null
@@ -1,175 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_UTILITY_COMMON_TYPE_HPP
-#define RANGES_V3_UTILITY_COMMON_TYPE_HPP
-
-#include <tuple>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <concepts/type_traits.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-// Sadly, this is necessary because of:
-//  - std::common_type is !SFINAE-friendly, and
-//  - The specification of std::common_type makes it impossibly
-//    difficult to specialize on user-defined types without spamming
-//    out a bajillion copies to handle all combinations of cv and ref
-//    qualifiers.
-
-namespace ranges
-{
-    template<typename... Ts>
-    using common_type = concepts::common_type<Ts...>;
-
-    template<typename... Ts>
-    using common_type_t = concepts::common_type_t<Ts...>;
-
-    template<typename... Ts>
-    using common_reference = concepts::common_reference<Ts...>;
-
-    template<typename... Ts>
-    using common_reference_t = concepts::common_reference_t<Ts...>;
-
-    /// \cond
-    template<typename F, typename S>
-    struct common_pair;
-
-    template<typename... Ts>
-    struct common_tuple;
-    /// \endcond
-} // namespace ranges
-
-/// \cond
-// Specializations for pair and tuple
-namespace concepts
-{
-    // common_type for std::pairs
-    template<typename F1, typename S1, typename F2, typename S2>
-    struct common_type<std::pair<F1, S1>, ::ranges::common_pair<F2, S2>>;
-
-    template<typename F1, typename S1, typename F2, typename S2>
-    struct common_type<::ranges::common_pair<F1, S1>, std::pair<F2, S2>>;
-
-    template<typename F1, typename S1, typename F2, typename S2>
-    struct common_type<::ranges::common_pair<F1, S1>, ::ranges::common_pair<F2, S2>>;
-
-    // common_type for std::tuples
-    template<typename... Ts, typename... Us>
-    struct common_type<::ranges::common_tuple<Ts...>, std::tuple<Us...>>;
-
-    template<typename... Ts, typename... Us>
-    struct common_type<std::tuple<Ts...>, ::ranges::common_tuple<Us...>>;
-
-    template<typename... Ts, typename... Us>
-    struct common_type<::ranges::common_tuple<Ts...>, ::ranges::common_tuple<Us...>>;
-
-    // A common reference for std::pairs
-    template<typename F1, typename S1, typename F2, typename S2,
-             template<typename> class Qual1, template<typename> class Qual2>
-    struct basic_common_reference<::ranges::common_pair<F1, S1>, std::pair<F2, S2>, Qual1, Qual2>;
-
-    template<typename F1, typename S1, typename F2, typename S2,
-             template<typename> class Qual1, template<typename> class Qual2>
-    struct basic_common_reference<std::pair<F1, S1>, ::ranges::common_pair<F2, S2>, Qual1, Qual2>;
-
-    template<typename F1, typename S1, typename F2, typename S2,
-             template<typename> class Qual1, template<typename> class Qual2>
-    struct basic_common_reference<::ranges::common_pair<F1, S1>, ::ranges::common_pair<F2, S2>, Qual1, Qual2>;
-
-    // A common reference for std::tuples
-    template<typename... Ts, typename... Us, template<typename> class Qual1,
-             template<typename> class Qual2>
-    struct basic_common_reference<::ranges::common_tuple<Ts...>, std::tuple<Us...>, Qual1, Qual2>;
-
-    template<typename... Ts, typename... Us, template<typename> class Qual1,
-             template<typename> class Qual2>
-    struct basic_common_reference<std::tuple<Ts...>, ::ranges::common_tuple<Us...>, Qual1, Qual2>;
-
-    template<typename... Ts, typename... Us, template<typename> class Qual1,
-             template<typename> class Qual2>
-    struct basic_common_reference<::ranges::common_tuple<Ts...>, ::ranges::common_tuple<Us...>, Qual1, Qual2>;
-} // namespace concepts
-
-#if RANGES_CXX_VER > RANGES_CXX_STD_17
-RANGES_DIAGNOSTIC_PUSH
-RANGES_DIAGNOSTIC_IGNORE_MISMATCHED_TAGS
-RANGES_BEGIN_NAMESPACE_STD
-RANGES_BEGIN_NAMESPACE_VERSION
-
-    template<typename...>
-    struct common_type;
-
-    // common_type for std::pairs
-    template<typename F1, typename S1, typename F2, typename S2>
-    struct common_type<std::pair<F1, S1>, ::ranges::common_pair<F2, S2>>;
-
-    template<typename F1, typename S1, typename F2, typename S2>
-    struct common_type<::ranges::common_pair<F1, S1>, std::pair<F2, S2>>;
-
-    template<typename F1, typename S1, typename F2, typename S2>
-    struct common_type<::ranges::common_pair<F1, S1>, ::ranges::common_pair<F2, S2>>;
-
-    // common_type for std::tuples
-    template<typename... Ts, typename... Us>
-    struct common_type<::ranges::common_tuple<Ts...>, std::tuple<Us...>>;
-
-    template<typename... Ts, typename... Us>
-    struct common_type<std::tuple<Ts...>, ::ranges::common_tuple<Us...>>;
-
-    template<typename... Ts, typename... Us>
-    struct common_type<::ranges::common_tuple<Ts...>, ::ranges::common_tuple<Us...>>;
-
-    template<typename, typename, template<typename> class, template<typename> class>
-    struct basic_common_reference;
-
-    // A common reference for std::pairs
-    template<typename F1, typename S1, typename F2, typename S2,
-             template<typename> class Qual1, template<typename> class Qual2>
-    struct basic_common_reference<::ranges::common_pair<F1, S1>, std::pair<F2, S2>, Qual1, Qual2>;
-
-    template<typename F1, typename S1, typename F2, typename S2,
-             template<typename> class Qual1, template<typename> class Qual2>
-    struct basic_common_reference<std::pair<F1, S1>, ::ranges::common_pair<F2, S2>, Qual1, Qual2>;
-
-    template<typename F1, typename S1, typename F2, typename S2,
-             template<typename> class Qual1, template<typename> class Qual2>
-    struct basic_common_reference<::ranges::common_pair<F1, S1>, ::ranges::common_pair<F2, S2>, Qual1, Qual2>;
-
-    // A common reference for std::tuples
-    template<typename... Ts, typename... Us, template<typename> class Qual1,
-             template<typename> class Qual2>
-    struct basic_common_reference<::ranges::common_tuple<Ts...>, std::tuple<Us...>, Qual1, Qual2>;
-
-    template<typename... Ts, typename... Us, template<typename> class Qual1,
-             template<typename> class Qual2>
-    struct basic_common_reference<std::tuple<Ts...>, ::ranges::common_tuple<Us...>, Qual1, Qual2>;
-
-    template<typename... Ts, typename... Us, template<typename> class Qual1,
-             template<typename> class Qual2>
-    struct basic_common_reference<::ranges::common_tuple<Ts...>, ::ranges::common_tuple<Us...>, Qual1, Qual2>;
-
-RANGES_END_NAMESPACE_VERSION
-RANGES_END_NAMESPACE_STD
-RANGES_DIAGNOSTIC_POP
-#endif // RANGES_CXX_VER > RANGES_CXX_STD_17
-/// \endcond
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/compressed_pair.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/compressed_pair.hpp
deleted file mode 100644
index 759c26d2..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/compressed_pair.hpp
+++ /dev/null
@@ -1,232 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_UTILITY_COMPRESSED_PAIR_HPP
-#define RANGES_V3_UTILITY_COMPRESSED_PAIR_HPP
-
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/utility/box.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace compressed_tuple_detail
-    {
-        // tagging individual elements with the complete type list disambiguates
-        // base classes when composing compressed_tuples recursively.
-        template<typename T, std::size_t I, typename... Ts>
-        using storage = box<T, meta::list<meta::size_t<I>, Ts...>>;
-
-        template<typename List, typename Indices>
-        struct compressed_tuple_;
-        template<typename... Ts, std::size_t... Is>
-        struct RANGES_EMPTY_BASES
-            compressed_tuple_<meta::list<Ts...>, meta::index_sequence<Is...>>
-          : storage<Ts, Is, Ts...>...
-        {
-            static_assert(same_as<meta::index_sequence<Is...>,
-                                  meta::make_index_sequence<sizeof...(Is)>>,
-                          "What madness is this?!?");
-
-            compressed_tuple_() = default;
-
-            template<typename... Args,
-                     meta::if_<meta::and_c<META_IS_CONSTRUCTIBLE(Ts, Args)...>, int> = 0>
-            constexpr compressed_tuple_(Args &&... args) noexcept(
-                meta::strict_and<std::is_nothrow_constructible<storage<Ts, Is, Ts...>,
-                                                               Args>...>::value)
-              : storage<Ts, Is, Ts...>{static_cast<Args &&>(args)}...
-            {}
-
-            template<
-                typename... Us,
-                meta::if_<meta::and_c<META_IS_CONSTRUCTIBLE(Us, Ts const &)...>, int> = 0>
-            constexpr operator std::tuple<Us...>() const noexcept(
-                meta::strict_and<std::is_nothrow_constructible<Us, Ts const &>...>::value)
-            {
-                return std::tuple<Us...>{get<Is>(*this)...};
-            }
-
-            template<std::size_t I, typename T = meta::at_c<meta::list<Ts...>, I>>
-            friend constexpr T & get(compressed_tuple_ & tuple) noexcept
-            {
-                return static_cast<storage<T, I, Ts...> &>(tuple).get();
-            }
-            template<std::size_t I, typename T = meta::at_c<meta::list<Ts...>, I>>
-            friend constexpr T const & get(compressed_tuple_ const & tuple) noexcept
-            {
-                return static_cast<storage<T, I, Ts...> const &>(tuple).get();
-            }
-            template<std::size_t I, typename T = meta::at_c<meta::list<Ts...>, I>>
-            friend constexpr T && get(compressed_tuple_ && tuple) noexcept
-            {
-                return static_cast<storage<T, I, Ts...> &&>(tuple).get();
-            }
-            template<std::size_t I, typename T = meta::at_c<meta::list<Ts...>, I>>
-            friend constexpr T const && get(compressed_tuple_ const && tuple) noexcept
-            {
-                return static_cast<storage<T, I, Ts...> const &&>(tuple).get();
-            }
-        };
-
-        template<typename... Ts>
-        using compressed_tuple RANGES_DEPRECATED(
-            "ranges::compressed_tuple is deprecated.") =
-            compressed_tuple_<meta::list<Ts...>,
-                              meta::make_index_sequence<sizeof...(Ts)>>;
-    } // namespace compressed_tuple_detail
-    /// \endcond
-
-    using compressed_tuple_detail::compressed_tuple;
-
-    struct make_compressed_tuple_fn
-    {
-        // clang-format off
-        template<typename... Args>
-        constexpr auto CPP_auto_fun(operator())(Args &&... args) (const)
-        (
-            return compressed_tuple<bind_element_t<Args>...>{
-                static_cast<Args &&>(args)...}
-        )
-        // clang-format on
-    };
-
-    /// \ingroup group-utility
-    /// \sa `make_compressed_tuple_fn`
-    RANGES_INLINE_VARIABLE(make_compressed_tuple_fn, make_compressed_tuple)
-
-    template<typename First, typename Second>
-    struct RANGES_EMPTY_BASES compressed_pair
-      : box<First, meta::size_t<0>>
-      , box<Second, meta::size_t<1>>
-    {
-        using first_type = First;
-        using second_type = Second;
-
-        compressed_pair() = default;
-
-        template(typename U, typename V)(
-            /// \pre
-            requires constructible_from<First, U> AND constructible_from<Second, V>)
-        constexpr compressed_pair(U && u, V && v) //
-            noexcept(noexcept(First((U &&) u)) && noexcept(Second((V &&) v)))
-          : box<First, meta::size_t<0>>{(U &&) u}
-          , box<Second, meta::size_t<1>>{(V &&) v}
-        {}
-
-        constexpr First & first() &
-        {
-            return this->box<First, meta::size_t<0>>::get();
-        }
-        constexpr First const & first() const &
-        {
-            return this->box<First, meta::size_t<0>>::get();
-        }
-        constexpr First && first() &&
-        {
-            return static_cast<First &&>(this->box<First, meta::size_t<0>>::get());
-        }
-
-        constexpr Second & second() &
-        {
-            return this->box<Second, meta::size_t<1>>::get();
-        }
-        constexpr Second const & second() const &
-        {
-            return this->box<Second, meta::size_t<1>>::get();
-        }
-        constexpr Second && second() &&
-        {
-            return static_cast<Second &&>(this->box<Second, meta::size_t<1>>::get());
-        }
-
-        template(typename F, typename S)(
-            /// \pre
-            requires convertible_to<First const &, F> AND
-                convertible_to<Second const &, S>)
-            constexpr
-            operator std::pair<F, S>() const
-        {
-            return std::pair<F, S>{first(), second()};
-        }
-    };
-
-    struct make_compressed_pair_fn
-    {
-        // clang-format off
-        template<typename First, typename Second>
-        constexpr auto CPP_auto_fun(operator())(First &&f, Second &&s) (const)
-        (
-            return compressed_pair<bind_element_t<First>, bind_element_t<Second>>{
-                static_cast<First &&>(f), static_cast<Second &&>(s)
-            }
-        )
-        // clang-format on
-    };
-
-    /// \ingroup group-utility
-    /// \sa `make_compressed_pair_fn`
-    RANGES_INLINE_VARIABLE(make_compressed_pair_fn, make_compressed_pair)
-} // namespace ranges
-
-RANGES_DIAGNOSTIC_PUSH
-RANGES_DIAGNOSTIC_IGNORE_MISMATCHED_TAGS
-namespace std
-{
-    template<typename... Ts, size_t... Is>
-    struct tuple_size<::ranges::compressed_tuple_detail::compressed_tuple_<
-        ::meta::list<Ts...>, ::meta::index_sequence<Is...>>>
-      : integral_constant<size_t, sizeof...(Ts)>
-    {};
-
-    template<size_t I, typename... Ts, size_t... Is>
-    struct tuple_element<I, ::ranges::compressed_tuple_detail::compressed_tuple_<
-                                ::meta::list<Ts...>, ::meta::index_sequence<Is...>>>
-    {
-        using type = ::meta::at_c<::meta::list<Ts...>, I>;
-    };
-
-    template<typename First, typename Second>
-    struct tuple_size<::ranges::compressed_pair<First, Second>>
-      : integral_constant<size_t, 2>
-    {};
-
-    template<typename First, typename Second>
-    struct tuple_element<0, ::ranges::compressed_pair<First, Second>>
-    {
-        using type = First;
-    };
-
-    template<typename First, typename Second>
-    struct tuple_element<1, ::ranges::compressed_pair<First, Second>>
-    {
-        using type = Second;
-    };
-} // namespace std
-RANGES_DIAGNOSTIC_POP
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/concepts.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/concepts.hpp
deleted file mode 100644
index b8a1c91f..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/concepts.hpp
+++ /dev/null
@@ -1,27 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_UTILITY_CONCEPTS_HPP
-#define RANGES_V3_UTILITY_CONCEPTS_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated. Please #include <concepts/concepts.hpp> instead.")
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/utility/common_type.hpp>
-#include <range/v3/utility/swap.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/copy.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/copy.hpp
deleted file mode 100644
index 18d7b0ca..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/copy.hpp
+++ /dev/null
@@ -1,62 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_UTILITY_COPY_HPP
-#define RANGES_V3_UTILITY_COPY_HPP
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-utility
-    /// @{
-    namespace aux
-    {
-        struct copy_fn : copy_tag
-        {
-            template(typename T)(
-                /// \pre
-                requires constructible_from<detail::decay_t<T>, T>)
-            constexpr auto operator()(T && t) const -> detail::decay_t<T>
-            {
-                return static_cast<T &&>(t);
-            }
-
-            /// \ingroup group-utility
-            /// \sa `copy_fn`
-            template<typename T>
-            friend constexpr auto operator|(T && t, copy_fn)
-                -> CPP_broken_friend_ret(detail::decay_t<T>)(
-                    /// \pre
-                    requires constructible_from<detail::decay_t<T>, T>)
-            {
-                return static_cast<T &&>(t);
-            }
-        };
-
-        /// \ingroup group-utility
-        /// \sa `copy_fn`
-        RANGES_INLINE_VARIABLE(copy_fn, copy)
-    } // namespace aux
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/counted_iterator.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/counted_iterator.hpp
deleted file mode 100644
index 1564e277..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/counted_iterator.hpp
+++ /dev/null
@@ -1,22 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_UTILITY_COUNTED_ITERATOR_HPP
-#define RANGES_V3_UTILITY_COUNTED_ITERATOR_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated. Please #include <range/v3/iterator/counted_iterator.hpp> "
-    "instead.")
-
-#include <range/v3/iterator/counted_iterator.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/dangling.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/dangling.hpp
deleted file mode 100644
index 60eed25d..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/dangling.hpp
+++ /dev/null
@@ -1,22 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_UTILITY_DANGLING_HPP
-#define RANGES_V3_UTILITY_DANGLING_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated. Please #include <range/v3/range/dangling.hpp> instead.")
-
-#include <range/v3/range/dangling.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/functional.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/functional.hpp
deleted file mode 100644
index 641883fa..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/functional.hpp
+++ /dev/null
@@ -1,42 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_UTILITY_FUNCTIONAL_HPP
-#define RANGES_V3_UTILITY_FUNCTIONAL_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header has been deprecated. Please find what you are looking for in the "
-    "range/v3/functional/ directory.")
-
-#include <range/v3/detail/with_braced_init_args.hpp>
-#include <range/v3/functional/arithmetic.hpp>
-#include <range/v3/functional/bind.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/compose.hpp>
-#include <range/v3/functional/concepts.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/indirect.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/functional/not_fn.hpp>
-#include <range/v3/functional/on.hpp>
-#include <range/v3/functional/overload.hpp>
-#include <range/v3/functional/pipeable.hpp>
-#include <range/v3/functional/reference_wrapper.hpp>
-
-namespace ranges
-{
-    using detail::with_braced_init_args;
-} // namespace ranges
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/get.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/get.hpp
deleted file mode 100644
index fc424786..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/get.hpp
+++ /dev/null
@@ -1,73 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_UTILITY_GET_HPP
-#define RANGES_V3_UTILITY_GET_HPP
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/detail/adl_get.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-utility Utility
-    /// @{
-    ///
-
-    /// \cond
-    namespace _get_
-    {
-        /// \endcond
-        // clang-format off
-        template<std::size_t I, typename TupleLike>
-        constexpr auto CPP_auto_fun(get)(TupleLike &&t)
-        (
-            return detail::adl_get<I>(static_cast<TupleLike &&>(t))
-        )
-        template<typename T, typename TupleLike>
-        constexpr auto CPP_auto_fun(get)(TupleLike &&t)
-        (
-            return detail::adl_get<T>(static_cast<TupleLike &&>(t))
-        )
-            // clang-format on
-
-            template<typename T>
-            T & get(meta::id_t<T> & value) noexcept
-        {
-            return value;
-        }
-        template<typename T>
-        T const & get(meta::id_t<T> const & value) noexcept
-        {
-            return value;
-        }
-        template<typename T>
-        T && get(meta::id_t<T> && value) noexcept
-        {
-            return static_cast<T &&>(value);
-        }
-        /// \cond
-    } // namespace _get_
-    using namespace _get_;
-    /// \endcond
-
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/in_place.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/in_place.hpp
deleted file mode 100644
index 061ee343..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/in_place.hpp
+++ /dev/null
@@ -1,33 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_UTILITY_IN_PLACE_HPP
-#define RANGES_V3_UTILITY_IN_PLACE_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \ingroup group-utility
-    struct in_place_t
-    {};
-    RANGES_INLINE_VARIABLE(in_place_t, in_place)
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/infinity.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/infinity.hpp
deleted file mode 100644
index 1d7ada98..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/infinity.hpp
+++ /dev/null
@@ -1,75 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_UTILITY_INFINITY_HPP
-#define RANGES_V3_UTILITY_INFINITY_HPP
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated and will be removed from a future version of range-v3.")
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    struct infinity
-    {
-        friend constexpr bool operator==(infinity, infinity)
-        {
-            return true;
-        }
-        friend constexpr bool operator!=(infinity, infinity)
-        {
-            return false;
-        }
-        template<typename Integer>
-        friend constexpr auto operator==(Integer, infinity) noexcept
-            -> CPP_broken_friend_ret(bool)(
-                /// \pre
-                requires integral<Integer>)
-        {
-            return false;
-        }
-        template<typename Integer>
-        friend constexpr auto operator==(infinity, Integer) noexcept
-            -> CPP_broken_friend_ret(bool)(
-                /// \pre
-                requires integral<Integer>)
-        {
-            return false;
-        }
-        template<typename Integer>
-        friend constexpr auto operator!=(Integer, infinity) noexcept
-            -> CPP_broken_friend_ret(bool)(
-                /// \pre
-                requires integral<Integer>)
-        {
-            return true;
-        }
-        template<typename Integer>
-        friend constexpr auto operator!=(infinity, Integer) noexcept
-            -> CPP_broken_friend_ret(bool)(
-                /// \pre
-                requires integral<Integer>)
-        {
-            return true;
-        }
-    };
-    /// \endcond
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/invoke.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/invoke.hpp
deleted file mode 100644
index a88f4210..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/invoke.hpp
+++ /dev/null
@@ -1,23 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_UTILITY_INVOKE_HPP
-#define RANGES_V3_UTILITY_INVOKE_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This file has been deprecated. Please #include <range/v3/functional/invoke.hpp> "
-    "instead.")
-
-#include <range/v3/functional/invoke.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/iterator.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/iterator.hpp
deleted file mode 100644
index b9848e26..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/iterator.hpp
+++ /dev/null
@@ -1,31 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_UTILITY_ITERATOR_HPP
-#define RANGES_V3_UTILITY_ITERATOR_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    R"(This header is deprecated. Please include one of the following depending on your need:
-    <range/v3/iterator/operations.hpp>,
-    <range/v3/iterator/insert_iterators.hpp>,
-    <range/v3/iterator/move_iterators.hpp>,
-    <range/v3/iterator/reverse_iterator.hpp>,
-    <range/v3/iterator/stream_iterators.hpp>)")
-
-#include <range/v3/iterator/insert_iterators.hpp>
-#include <range/v3/iterator/move_iterators.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/reverse_iterator.hpp>
-#include <range/v3/iterator/stream_iterators.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/iterator_concepts.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/iterator_concepts.hpp
deleted file mode 100644
index 619d0d53..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/iterator_concepts.hpp
+++ /dev/null
@@ -1,23 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_UTILITY_ITERATOR_CONCEPTS_HPP
-#define RANGES_V3_UTILITY_ITERATOR_CONCEPTS_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated. Please #include <range/v3/iterator/concepts.hpp> "
-    "instead.")
-
-#include <range/v3/iterator/concepts.hpp>
-
-#endif // RANGES_V3_UTILITY_ITERATOR_CONCEPTS_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/iterator_traits.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/iterator_traits.hpp
deleted file mode 100644
index feaf30e6..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/iterator_traits.hpp
+++ /dev/null
@@ -1,22 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_UTILITY_ITERATOR_TRAITS_HPP
-#define RANGES_V3_UTILITY_ITERATOR_TRAITS_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated. Please #include <range/v3/iterator/traits.hpp> instead.")
-
-#include <range/v3/iterator/traits.hpp>
-
-#endif // RANGES_V3_UTILITY_ITERATOR_TRAITS_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/memory.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/memory.hpp
deleted file mode 100644
index 4bb826cb..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/memory.hpp
+++ /dev/null
@@ -1,262 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//===-------------------------- algorithm ---------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-#ifndef RANGES_V3_UTILITY_MEMORY_HPP
-#define RANGES_V3_UTILITY_MEMORY_HPP
-
-#include <cstdint>
-#include <memory>
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/detail/config.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/utility/polymorphic_cast.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        template<typename T>
-        std::pair<T *, std::ptrdiff_t> get_temporary_buffer_impl(std::size_t n) noexcept
-        {
-            if(n > PTRDIFF_MAX / sizeof(T))
-                n = PTRDIFF_MAX / sizeof(T);
-
-            void * ptr = nullptr;
-            for(; ptr == nullptr && n > 0; n /= 2)
-            {
-#if RANGES_CXX_ALIGNED_NEW < RANGES_CXX_ALIGNED_NEW_17
-                static_assert(alignof(T) <= alignof(std::max_align_t),
-                              "Sorry: over-aligned types are supported only with C++17.");
-#else  // RANGES_CXX_ALIGNED_NEW
-                if(RANGES_CONSTEXPR_IF(alignof(T) > __STDCPP_DEFAULT_NEW_ALIGNMENT__))
-                    ptr = ::operator new(
-                        sizeof(T) * n, std::align_val_t{alignof(T)}, std::nothrow);
-                else
-#endif // RANGES_CXX_ALIGNED_NEW
-                ptr = ::operator new(sizeof(T) * n, std::nothrow);
-            }
-
-            return {static_cast<T *>(ptr), static_cast<std::ptrdiff_t>(n)};
-        }
-
-        template<typename T, typename D>
-        std::pair<T *, std::ptrdiff_t> get_temporary_buffer(D count) noexcept
-        {
-            RANGES_EXPECT(count >= 0);
-            return detail::get_temporary_buffer_impl<T>(static_cast<std::size_t>(count));
-        }
-
-        struct return_temporary_buffer
-        {
-            template<typename T>
-            void operator()(T * p) const
-            {
-#if RANGES_CXX_ALIGNED_NEW < RANGES_CXX_ALIGNED_NEW_17
-                static_assert(alignof(T) <= alignof(std::max_align_t),
-                              "Sorry: over-aligned types are supported only with C++17.");
-#else  // RANGES_CXX_ALIGNED_NEW
-                if(RANGES_CONSTEXPR_IF(alignof(T) > __STDCPP_DEFAULT_NEW_ALIGNMENT__))
-                    ::operator delete(p, std::align_val_t{alignof(T)});
-                else
-#endif // RANGES_CXX_ALIGNED_NEW
-                ::operator delete(p);
-            }
-        };
-
-        template(typename T, typename... Args)(
-            /// \pre
-            requires (!std::is_array<T>::value)) //
-        std::unique_ptr<T> make_unique(Args &&... args)
-        {
-            return std::unique_ptr<T>{new T(static_cast<Args &&>(args)...)};
-        }
-    } // namespace detail
-    /// \endcond
-
-    /// \addtogroup group-utility
-    /// @{
-    template<typename O, typename Val>
-    struct raw_storage_iterator
-    {
-    private:
-        CPP_assert(output_iterator<O, Val>);
-        CPP_assert(std::is_lvalue_reference<iter_reference_t<O>>());
-        O out_;
-
-    public:
-        using difference_type = iter_difference_t<O>;
-        raw_storage_iterator() = default;
-        explicit raw_storage_iterator(O out)
-          : out_(std::move(out))
-        {}
-        raw_storage_iterator & operator*() noexcept
-        {
-            return *this;
-        }
-        CPP_member
-        auto operator=(Val const & val) //
-            -> CPP_ret(raw_storage_iterator &)(
-                /// \pre
-                requires copy_constructible<Val>)
-        {
-            ::new((void *)std::addressof(*out_)) Val(val);
-            return *this;
-        }
-        CPP_member
-        auto operator=(Val && val) //
-            -> CPP_ret(raw_storage_iterator &)(
-                /// \pre
-                requires move_constructible<Val>)
-        {
-            ::new((void *)std::addressof(*out_)) Val(std::move(val));
-            return *this;
-        }
-        raw_storage_iterator & operator++()
-        {
-            ++out_;
-            return *this;
-        }
-        CPP_member
-        auto operator++(int) //
-            -> CPP_ret(void)(
-                /// \pre
-                requires (!forward_iterator<O>))
-        {
-            ++out_;
-        }
-        CPP_member
-        auto operator++(int) //
-            -> CPP_ret(raw_storage_iterator)(
-                /// \pre
-                requires forward_iterator<O>)
-        {
-            auto tmp = *this;
-            ++out_;
-            return tmp;
-        }
-        O base() const
-        {
-            return out_;
-        }
-    };
-
-    template<typename I>
-    struct iterator_wrapper
-    {
-    private:
-        CPP_assert(input_or_output_iterator<I>);
-        mutable I * i_ = nullptr;
-
-    public:
-        using difference_type = iter_difference_t<I>;
-        iterator_wrapper() = default;
-        iterator_wrapper(iterator_wrapper const & that)
-          : i_(that.i_)
-        {
-            that.i_ = nullptr;
-        }
-        iterator_wrapper & operator=(iterator_wrapper const & that)
-        {
-            i_ = that.i_;
-            that.i_ = nullptr;
-            return *this;
-        }
-        iterator_wrapper(I & i)
-          : i_(std::addressof(i))
-        {}
-        // clang-format off
-        auto CPP_auto_fun(operator*)()(const)
-        (
-            return **i_
-        )
-            // clang-format on
-            iterator_wrapper &
-            operator++()
-        {
-            ++*i_;
-            return *this;
-        }
-        void operator++(int)
-        {
-            ++*i_;
-        }
-        I base() const
-        {
-            return *i_;
-        }
-    };
-
-    template(typename I)(
-        /// \pre
-        requires input_or_output_iterator<I>)
-    iterator_wrapper<I> iter_ref(I & i)
-    {
-        return i;
-    }
-
-    template<typename I>
-    struct indirectly_readable_traits<iterator_wrapper<I>>
-      : meta::if_c<(bool)input_iterator<I>, indirectly_readable_traits<I>, meta::nil_>
-    {};
-
-    template<typename Val>
-    struct raw_buffer
-    {
-    private:
-        Val * begin_;
-        raw_storage_iterator<Val *, Val> rsi_;
-
-    public:
-        explicit raw_buffer(Val * first)
-          : begin_(first)
-          , rsi_(first)
-        {}
-        raw_buffer(raw_buffer &&) = default;
-        raw_buffer(raw_buffer const &) = delete;
-        ~raw_buffer()
-        {
-            for(; begin_ != rsi_.base(); ++begin_)
-                begin_->~Val();
-        }
-        iterator_wrapper<raw_storage_iterator<Val *, Val>> begin()
-        {
-            return ranges::iter_ref(rsi_);
-        }
-    };
-
-    template<typename Val>
-    raw_buffer<Val> make_raw_buffer(Val * val)
-    {
-        return raw_buffer<Val>(val);
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/move.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/move.hpp
deleted file mode 100644
index 7af9be12..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/move.hpp
+++ /dev/null
@@ -1,65 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_UTILITY_MOVE_HPP
-#define RANGES_V3_UTILITY_MOVE_HPP
-
-#include <type_traits>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    namespace aux
-    {
-        /// \ingroup group-utility
-        struct move_fn : move_tag
-        {
-            template<typename T>
-            constexpr meta::_t<std::remove_reference<T>> && operator()(T && t) const //
-                noexcept
-            {
-                return static_cast<meta::_t<std::remove_reference<T>> &&>(t);
-            }
-
-            /// \ingroup group-utility
-            /// \sa `move_fn`
-            template<typename T>
-            friend constexpr decltype(auto) operator|(T && t, move_fn move) noexcept
-            {
-                return move(t);
-            }
-        };
-
-        /// \ingroup group-utility
-        /// \sa `move_fn`
-        RANGES_INLINE_VARIABLE(move_fn, move)
-
-        /// \ingroup group-utility
-        /// \sa `move_fn`
-        template<typename R>
-        using move_t =
-            meta::if_c<std::is_reference<R>::value, meta::_t<std::remove_reference<R>> &&,
-                       detail::decay_t<R>>;
-    } // namespace aux
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/nullptr_v.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/nullptr_v.hpp
deleted file mode 100644
index b8338b04..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/nullptr_v.hpp
+++ /dev/null
@@ -1,40 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013,2014.
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_UTILITY_NULLPTR_V_HPP
-#define RANGES_V3_UTILITY_NULLPTR_V_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated and will be removed from a future version of range-v3.")
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \ingroup group-utility
-    template<typename T>
-    constexpr T * _nullptr_v()
-    {
-        return nullptr;
-    }
-
-#if RANGES_CXX_VARIABLE_TEMPLATES
-    /// \ingroup group-utility
-    template<typename T>
-    constexpr T * nullptr_v = nullptr;
-#endif
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/optional.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/optional.hpp
deleted file mode 100644
index 9f155040..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/optional.hpp
+++ /dev/null
@@ -1,992 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Casey Carter 2017
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_UTILITY_OPTIONAL_HPP
-#define RANGES_V3_UTILITY_OPTIONAL_HPP
-
-#include <exception>
-#include <initializer_list>
-#include <memory>
-#include <new>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/detail/config.hpp>
-#include <range/v3/utility/addressof.hpp>
-#include <range/v3/utility/in_place.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/utility/swap.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    template<typename>
-    struct optional;
-
-    struct bad_optional_access : std::exception
-    {
-        virtual const char * what() const noexcept override
-        {
-            return "bad optional access";
-        }
-    };
-
-    struct nullopt_t
-    {
-        struct tag
-        {};
-        constexpr explicit nullopt_t(tag) noexcept
-        {}
-    };
-#if RANGES_CXX_INLINE_VARIABLES >= RANGES_CXX_INLINE_VARIABLES_17
-    inline constexpr nullopt_t nullopt{nullopt_t::tag{}};
-#else
-    /// \cond
-    namespace detail
-    {
-        template<typename>
-        struct nullopt_holder
-        {
-            static constexpr nullopt_t nullopt{nullopt_t::tag{}};
-        };
-        template<typename T>
-        constexpr nullopt_t nullopt_holder<T>::nullopt;
-    } // namespace detail
-    /// \endcond
-    namespace
-    {
-        constexpr auto & nullopt = detail::nullopt_holder<void>::nullopt;
-    }
-#endif
-
-    /// \cond
-    namespace detail
-    {
-        template<typename = void>
-        [[noreturn]] bool throw_bad_optional_access()
-        {
-            throw bad_optional_access{};
-        }
-
-        namespace optional_adl
-        {
-            template<typename T, bool = std::is_trivially_destructible<T>::value>
-            struct optional_storage
-            {
-                union
-                {
-                    char dummy_;
-                    meta::_t<std::remove_cv<T>> data_;
-                };
-                bool engaged_;
-
-                constexpr optional_storage() noexcept
-                  : optional_storage(
-                        tag{},
-                        meta::bool_<detail::is_trivially_default_constructible_v<T> &&
-                                    detail::is_trivially_copyable_v<T>>{})
-                {}
-                template(typename... Args)(
-                    /// \pre
-                    requires constructible_from<T, Args...>)
-                    constexpr explicit optional_storage(in_place_t,
-                                                        Args &&... args) //
-                    noexcept(std::is_nothrow_constructible<T, Args...>::value)
-                  : data_(static_cast<Args &&>(args)...)
-                  , engaged_{true}
-                {}
-
-                constexpr void reset() noexcept
-                {
-                    engaged_ = false;
-                }
-
-            private:
-                struct tag
-                {};
-                constexpr optional_storage(tag, std::false_type) noexcept
-                  : dummy_{}
-                  , engaged_{false}
-                {}
-                constexpr optional_storage(tag, std::true_type) noexcept
-                  : data_{}
-                  , engaged_{false}
-                {}
-            };
-
-            template<typename T>
-            struct optional_storage<T, false>
-            {
-                union
-                {
-                    char dummy_;
-                    meta::_t<std::remove_cv<T>> data_;
-                };
-                bool engaged_;
-
-                ~optional_storage()
-                {
-                    reset();
-                }
-                constexpr optional_storage() noexcept
-                  : dummy_{}
-                  , engaged_{false}
-                {}
-                template(typename... Args)(
-                    /// \pre
-                    requires constructible_from<T, Args...>)
-                    constexpr explicit optional_storage(in_place_t,
-                                                        Args &&... args) //
-                    noexcept(std::is_nothrow_constructible<T, Args...>::value)
-                  : data_(static_cast<Args &&>(args)...)
-                  , engaged_{true}
-                {}
-                optional_storage(optional_storage const &) = default;
-                optional_storage(optional_storage &&) = default;
-                optional_storage & operator=(optional_storage const &) = default;
-                optional_storage & operator=(optional_storage &&) = default;
-
-                void reset() noexcept
-                {
-                    if(engaged_)
-                    {
-                        data_.~T();
-                        engaged_ = false;
-                    }
-                }
-            };
-
-            template<typename T>
-            struct optional_base : private optional_storage<T>
-            {
-                using optional_storage<T>::optional_storage;
-                using optional_storage<T>::reset;
-
-                constexpr bool has_value() const noexcept
-                {
-                    return engaged_;
-                }
-                constexpr T & operator*() & noexcept
-                {
-                    return RANGES_EXPECT(engaged_), data_;
-                }
-                constexpr T const & operator*() const & noexcept
-                {
-                    return RANGES_EXPECT(engaged_), data_;
-                }
-                constexpr T && operator*() && noexcept
-                {
-                    return RANGES_EXPECT(engaged_), detail::move(data_);
-                }
-                constexpr T const && operator*() const && noexcept
-                {
-                    return RANGES_EXPECT(engaged_), detail::move(data_);
-                }
-                constexpr T * operator->() noexcept
-                {
-                    return RANGES_EXPECT(engaged_), detail::addressof(data_);
-                }
-                constexpr T const * operator->() const noexcept
-                {
-                    return RANGES_EXPECT(engaged_), detail::addressof(data_);
-                }
-                CPP_member
-                constexpr auto swap(optional_base & that) //
-                    noexcept(std::is_nothrow_move_constructible<T>::value &&
-                             is_nothrow_swappable<T>::value) //
-                    -> CPP_ret(void)(
-                        /// \pre
-                        requires move_constructible<T> && swappable<T>)
-                {
-                    constexpr bool can_swap_trivially =
-                        !::concepts::adl_swap_detail::is_adl_swappable_v<T> &&
-                        detail::is_trivially_move_constructible_v<T> &&
-                        detail::is_trivially_move_assignable_v<T>;
-
-                    swap_(meta::bool_<can_swap_trivially>{}, that);
-                }
-
-            protected:
-                template(typename... Args)(
-                    /// \pre
-                    requires constructible_from<T, Args...>)
-                T & construct_from(Args &&... args)
-                    noexcept(std::is_nothrow_constructible<T, Args...>::value)
-                {
-                    RANGES_EXPECT(!engaged_);
-                    auto const address = static_cast<void *>(std::addressof(data_));
-                    ::new(address) T(static_cast<Args &&>(args)...);
-                    engaged_ = true;
-                    return data_;
-                }
-                template<typename U>
-                constexpr void assign_from(U && that) noexcept(
-                    std::is_nothrow_constructible<T, decltype(*static_cast<U &&>(that))>::
-                        value && std::is_nothrow_assignable<
-                            T &, decltype(*static_cast<U &&>(that))>::value)
-                {
-                    if(!that.has_value())
-                        reset();
-                    else if(engaged_)
-                        data_ = *static_cast<U &&>(that);
-                    else
-                    {
-                        auto const address =
-                            static_cast<void *>(detail::addressof(data_));
-                        ::new(address) T(*static_cast<U &&>(that));
-                        engaged_ = true;
-                    }
-                }
-
-            private:
-                constexpr void swap_(std::true_type, optional_base & that) noexcept
-                {
-                    ranges::swap(static_cast<optional_storage<T> &>(*this),
-                                 static_cast<optional_storage<T> &>(that));
-                }
-                constexpr void swap_(std::false_type, optional_base & that) noexcept(
-                    std::is_nothrow_move_constructible<T>::value &&
-                        is_nothrow_swappable<T>::value)
-                {
-                    if(that.engaged_ == engaged_)
-                    {
-                        if(engaged_)
-                            ranges::swap(data_, that.data_);
-                    }
-                    else
-                    {
-                        auto & src = engaged_ ? *this : that;
-                        auto & dst = engaged_ ? that : *this;
-                        dst.construct_from(detail::move(src.data_));
-                        src.reset();
-                    }
-                }
-
-                using optional_storage<T>::engaged_;
-                using optional_storage<T>::data_;
-            };
-
-            template<typename T>
-            struct optional_base<T &>
-            {
-                optional_base() = default;
-                template(typename Arg)(
-                    /// \pre
-                    requires constructible_from<T &, Arg>)
-                constexpr explicit optional_base(in_place_t, Arg && arg) noexcept //
-                  : ptr_(detail::addressof(arg))
-                {}
-                constexpr bool has_value() const noexcept
-                {
-                    return ptr_;
-                }
-                constexpr T & operator*() const noexcept
-                {
-                    return RANGES_EXPECT(ptr_), *ptr_;
-                }
-                constexpr T * operator->() const noexcept
-                {
-                    return RANGES_EXPECT(ptr_), ptr_;
-                }
-                constexpr void reset() noexcept
-                {
-                    ptr_ = nullptr;
-                }
-                CPP_member
-                constexpr auto swap(optional_base & that) //
-                    noexcept(is_nothrow_swappable<T>::value) //
-                    -> CPP_ret(void)(
-                        /// \pre
-                        requires swappable<T>)
-                {
-                    if(ptr_ && that.ptr_)
-                        ranges::swap(*ptr_, *that.ptr_);
-                    else
-                        ranges::swap(ptr_, that.ptr_);
-                }
-
-            protected:
-                template(typename U)(
-                    /// \pre
-                    requires convertible_to<U &, T &>)
-                constexpr T & construct_from(U && ref) noexcept
-                {
-                    RANGES_EXPECT(!ptr_);
-                    ptr_ = detail::addressof(ref);
-                    return *ptr_;
-                }
-                template<typename U>
-                constexpr void assign_from(U && that)
-                {
-                    if(ptr_ && that.ptr_)
-                        *ptr_ = *that.ptr_;
-                    else
-                        ptr_ = that.ptr_;
-                }
-
-            private:
-                T * ptr_ = nullptr;
-            };
-
-            template<typename T>
-            struct optional_copy : optional_base<T>
-            {
-                optional_copy() = default;
-                optional_copy(optional_copy const & that) noexcept(
-                    std::is_nothrow_copy_constructible<T>::value)
-                {
-                    if(that.has_value())
-                        this->construct_from(*that);
-                }
-                optional_copy(optional_copy &&) = default;
-                optional_copy & operator=(optional_copy const &) = default;
-                optional_copy & operator=(optional_copy &&) = default;
-
-                using optional_base<T>::optional_base;
-            };
-
-            template<typename T>
-            using copy_construct_layer =
-                meta::if_c<std::is_copy_constructible<T>::value &&
-                               !detail::is_trivially_copy_constructible_v<T>,
-                           optional_copy<T>, optional_base<T>>;
-
-            template<typename T>
-            struct optional_move : copy_construct_layer<T>
-            {
-                optional_move() = default;
-                optional_move(optional_move const &) = default;
-                optional_move(optional_move && that) noexcept(
-                    std::is_nothrow_move_constructible<T>::value)
-                {
-                    if(that.has_value())
-                        this->construct_from(std::move(*that));
-                }
-                optional_move & operator=(optional_move const &) = default;
-                optional_move & operator=(optional_move &&) = default;
-
-                using copy_construct_layer<T>::copy_construct_layer;
-            };
-
-            template<typename T>
-            using move_construct_layer =
-                meta::if_c<std::is_move_constructible<T>::value &&
-                               !detail::is_trivially_move_constructible_v<T>,
-                           optional_move<T>, copy_construct_layer<T>>;
-
-            template<typename T>
-            struct optional_copy_assign : move_construct_layer<T>
-            {
-                optional_copy_assign() = default;
-                optional_copy_assign(optional_copy_assign const &) = default;
-                optional_copy_assign(optional_copy_assign &&) = default;
-                optional_copy_assign & operator=(optional_copy_assign const & that) //
-                    noexcept(std::is_nothrow_copy_constructible<T>::value &&
-                                 std::is_nothrow_copy_assignable<T>::value)
-                {
-                    this->assign_from(that);
-                    return *this;
-                }
-                optional_copy_assign & operator=(optional_copy_assign &&) = default;
-
-                using move_construct_layer<T>::move_construct_layer;
-            };
-
-            template<typename T>
-            struct deleted_copy_assign : move_construct_layer<T>
-            {
-                deleted_copy_assign() = default;
-                deleted_copy_assign(deleted_copy_assign const &) = default;
-                deleted_copy_assign(deleted_copy_assign &&) = default;
-                deleted_copy_assign & operator=(deleted_copy_assign const &) = delete;
-                deleted_copy_assign & operator=(deleted_copy_assign &&) = default;
-
-                using move_construct_layer<T>::move_construct_layer;
-            };
-
-            template<typename T>
-            using copy_assign_layer = meta::if_c<
-                std::is_copy_constructible<T>::value && std::is_copy_assignable<T>::value,
-                meta::if_c<std::is_reference<T>::value ||
-                               !(detail::is_trivially_copy_constructible_v<T> &&
-                                 detail::is_trivially_copy_assignable_v<T>),
-                           optional_copy_assign<T>, move_construct_layer<T>>,
-                deleted_copy_assign<T>>;
-
-            template<typename T>
-            struct optional_move_assign : copy_assign_layer<T>
-            {
-                optional_move_assign() = default;
-                optional_move_assign(optional_move_assign const &) = default;
-                optional_move_assign(optional_move_assign &&) = default;
-                optional_move_assign & operator=(optional_move_assign const &) = default;
-                optional_move_assign & operator=(optional_move_assign && that) noexcept(
-                    std::is_nothrow_move_constructible<T>::value &&
-                        std::is_nothrow_move_assignable<T>::value)
-                {
-                    this->assign_from(std::move(that));
-                    return *this;
-                }
-
-                using copy_assign_layer<T>::copy_assign_layer;
-            };
-
-            template<typename T>
-            struct deleted_move_assign : copy_assign_layer<T>
-            {
-                deleted_move_assign() = default;
-                deleted_move_assign(deleted_move_assign const &) = default;
-                deleted_move_assign(deleted_move_assign &&) = default;
-                deleted_move_assign & operator=(deleted_move_assign const &) = default;
-                deleted_move_assign & operator=(deleted_move_assign &&) = delete;
-
-                using copy_assign_layer<T>::copy_assign_layer;
-            };
-
-            template<typename T>
-            using move_assign_layer = meta::if_c<
-                std::is_move_constructible<T>::value && std::is_move_assignable<T>::value,
-                meta::if_c<std::is_reference<T>::value ||
-                               !(detail::is_trivially_move_constructible_v<T> &&
-                                 detail::is_trivially_move_assignable_v<T>),
-                           optional_move_assign<T>, copy_assign_layer<T>>,
-                deleted_move_assign<T>>;
-        } // namespace optional_adl
-    }     // namespace detail
-    /// \endcond
-
-    // clang-format off
-    template<typename U, typename T>
-    CPP_concept optional_should_convert =
-        !(
-            constructible_from<T, optional<U> &       > ||
-            constructible_from<T, optional<U> &&      > ||
-            constructible_from<T, optional<U> const & > ||
-            constructible_from<T, optional<U> const &&> ||
-            convertible_to<optional<U> &,        T> ||
-            convertible_to<optional<U> &&,       T> ||
-            convertible_to<optional<U> const &,  T> ||
-            convertible_to<optional<U> const &&, T>
-        );
-
-    template<typename U, typename T>
-    CPP_concept optional_should_convert_assign =
-        optional_should_convert<U, T> &&
-        !(assignable_from<T &, optional<U> &> ||
-        assignable_from<T &, optional<U> &&> ||
-        assignable_from<T &, optional<U> const &> ||
-        assignable_from<T &, optional<U> const &&>);
-    // clang-format on
-
-    template<typename T>
-    struct optional : detail::optional_adl::move_assign_layer<T>
-    {
-    private:
-        using base_t = detail::optional_adl::move_assign_layer<T>;
-
-    public:
-        CPP_assert(destructible<T>);
-        static_assert(std::is_object<T>::value || std::is_lvalue_reference<T>::value, "");
-        static_assert((bool)!same_as<nullopt_t, uncvref_t<T>>, "");
-        static_assert((bool)!same_as<in_place_t, uncvref_t<T>>, "");
-        using value_type = meta::_t<std::remove_cv<T>>;
-
-        constexpr optional() noexcept
-        {}
-        constexpr optional(nullopt_t) noexcept
-          : optional{}
-        {}
-        optional(optional const &) = default;
-        optional(optional &&) = default;
-
-        using base_t::base_t;
-
-        template(typename E, typename... Args)(
-            /// \pre
-            requires constructible_from<T, std::initializer_list<E> &, Args...>)
-        constexpr explicit optional(in_place_t, std::initializer_list<E> il,
-                                    Args &&... args) //
-            noexcept(std::is_nothrow_constructible<T, std::initializer_list<E> &,
-                                                   Args...>::value)
-          : base_t(in_place, il, static_cast<Args &&>(args)...)
-        {}
-
-#if defined(__cpp_conditional_explicit) && __cpp_conditional_explicit > 0
-        template(typename U = T)(
-            /// \pre
-            requires (!same_as<detail::decay_t<U>, in_place_t>) AND
-                (!same_as<detail::decay_t<U>, optional>) AND
-                constructible_from<T, U>)
-        constexpr explicit(!convertible_to<U, T>) optional(U && v)
-          : base_t(in_place, static_cast<U &&>(v))
-        {}
-
-        template(typename U)(
-            /// \pre
-            requires optional_should_convert<U, T> AND
-                constructible_from<T, U const &>)
-        explicit(!convertible_to<U const &, T>) optional(optional<U> const & that)
-        {
-            if(that.has_value())
-                base_t::construct_from(*that);
-        }
-#else
-        template(typename U = T)(
-            /// \pre
-            requires (!same_as<detail::decay_t<U>, in_place_t>) AND
-                (!same_as<detail::decay_t<U>, optional>) AND
-                constructible_from<T, U> AND
-                convertible_to<U, T>)
-        constexpr optional(U && v)
-          : base_t(in_place, static_cast<U &&>(v))
-        {}
-        template(typename U = T)(
-            /// \pre
-            requires (!same_as<detail::decay_t<U>, in_place_t>) AND
-                (!same_as<detail::decay_t<U>, optional>) AND
-                constructible_from<T, U> AND
-                (!convertible_to<U, T>))
-        constexpr explicit optional(U && v)
-          : base_t(in_place, static_cast<U &&>(v))
-        {}
-
-        template(typename U)(
-            /// \pre
-            requires optional_should_convert<U, T> AND
-                constructible_from<T, U const &> AND
-                convertible_to<U const &, T>)
-        optional(optional<U> const & that)
-        {
-            if(that.has_value())
-                base_t::construct_from(*that);
-        }
-        template(typename U)(
-            /// \pre
-            requires optional_should_convert<U, T> AND
-                constructible_from<T, U const &> AND
-                (!convertible_to<U const &, T>))
-        explicit optional(optional<U> const & that)
-        {
-            if(that.has_value())
-                base_t::construct_from(*that);
-        }
-#endif
-
-        template(typename U)(
-            /// \pre
-            requires optional_should_convert<U, T> AND constructible_from<T, U> AND
-                convertible_to<U, T>)
-        optional(optional<U> && that)
-        {
-            if(that.has_value())
-                base_t::construct_from(detail::move(*that));
-        }
-        template(typename U)(
-            /// \pre
-            requires optional_should_convert<U, T> AND constructible_from<T, U> AND
-            (!convertible_to<U, T>)) //
-        explicit optional(optional<U> && that)
-        {
-            if(that.has_value())
-                base_t::construct_from(detail::move(*that));
-        }
-
-        constexpr optional & operator=(nullopt_t) noexcept
-        {
-            reset();
-            return *this;
-        }
-
-        optional & operator=(optional const &) = default;
-        optional & operator=(optional &&) = default;
-
-        template(typename U = T)(
-            /// \pre
-            requires (!same_as<optional, detail::decay_t<U>>) AND
-                (!(satisfies<T, std::is_scalar> && same_as<T, detail::decay_t<U>>)) AND
-                constructible_from<T, U> AND
-                assignable_from<T &, U>)
-        constexpr optional & operator=(U && u) noexcept(
-            std::is_nothrow_constructible<T, U>::value &&
-                std::is_nothrow_assignable<T &, U>::value)
-        {
-            if(has_value())
-                **this = static_cast<U &&>(u);
-            else
-                base_t::construct_from(static_cast<U &&>(u));
-            return *this;
-        }
-
-        template(typename U)(
-            /// \pre
-            requires optional_should_convert_assign<U, T> AND
-                constructible_from<T, const U &> AND
-                assignable_from<T &, const U &>)
-        constexpr optional & operator=(optional<U> const & that)
-        {
-            base_t::assign_from(that);
-            return *this;
-        }
-
-        template(typename U)(
-            /// \pre
-            requires optional_should_convert_assign<U, T> AND
-                constructible_from<T, U> AND
-                assignable_from<T &, U>)
-        constexpr optional & operator=(optional<U> && that)
-        {
-            base_t::assign_from(std::move(that));
-            return *this;
-        }
-
-        template(typename... Args)(
-            /// \pre
-            requires constructible_from<T, Args...>)
-        T & emplace(Args &&... args) noexcept(
-            std::is_nothrow_constructible<T, Args...>::value)
-        {
-            reset();
-            return base_t::construct_from(static_cast<Args &&>(args)...);
-        }
-        template(typename E, typename... Args)(
-            /// \pre
-            requires constructible_from<T, std::initializer_list<E> &, Args...>)
-        T & emplace(std::initializer_list<E> il, Args &&... args) noexcept(
-            std::is_nothrow_constructible<T, std::initializer_list<E> &, Args...>::value)
-        {
-            reset();
-            return base_t::construct_from(il, static_cast<Args &&>(args)...);
-        }
-
-        using base_t::swap;
-        using base_t::operator->;
-        using base_t::operator*;
-
-        constexpr explicit operator bool() const noexcept
-        {
-            return has_value();
-        }
-        using base_t::has_value;
-
-        constexpr T const & value() const &
-        {
-            return (has_value() || detail::throw_bad_optional_access()), **this;
-        }
-        constexpr T & value() &
-        {
-            return (has_value() || detail::throw_bad_optional_access()), **this;
-        }
-        constexpr T const && value() const &&
-        {
-            return (has_value() || detail::throw_bad_optional_access()),
-                   detail::move(**this);
-        }
-        constexpr T && value() &&
-        {
-            return (has_value() || detail::throw_bad_optional_access()),
-                   detail::move(**this);
-        }
-
-        template(typename U)(
-            /// \pre
-            requires copy_constructible<T> AND convertible_to<U, T>)
-        constexpr T value_or(U && u) const &
-        {
-            return has_value() ? **this : static_cast<T>((U &&) u);
-        }
-        template(typename U)(
-            /// \pre
-            requires move_constructible<T> AND convertible_to<U, T>)
-        constexpr T value_or(U && u) &&
-        {
-            return has_value() ? detail::move(**this) : static_cast<T>((U &&) u);
-        }
-
-        using base_t::reset;
-    };
-
-    /// \cond
-    namespace detail
-    {
-        namespace optional_adl
-        {
-            constexpr bool convert_bool(bool b) noexcept
-            {
-                return b;
-            }
-
-            // Relational operators [optional.relops]
-            template<typename T, typename U>
-            constexpr auto operator==(optional<T> const & x, optional<U> const & y) //
-                noexcept(noexcept(convert_bool(*x == *y)))
-                    -> decltype(convert_bool(*x == *y))
-            {
-                return x.has_value() == y.has_value() && (!x || convert_bool(*x == *y));
-            }
-            template<typename T, typename U>
-            constexpr auto operator!=(optional<T> const & x, optional<U> const & y) //
-                noexcept(noexcept(convert_bool(*x != *y)))
-                    -> decltype(convert_bool(*x != *y))
-            {
-                return x.has_value() != y.has_value() || (x && convert_bool(*x != *y));
-            }
-            template<typename T, typename U>
-            constexpr auto operator<(optional<T> const & x, optional<U> const & y) //
-                noexcept(noexcept(convert_bool(*x < *y)))
-                    -> decltype(convert_bool(*x < *y))
-            {
-                return y && (!x || convert_bool(*x < *y));
-            }
-            template<typename T, typename U>
-            constexpr auto operator>(optional<T> const & x, optional<U> const & y) //
-                noexcept(noexcept(convert_bool(*x > *y)))
-                    -> decltype(convert_bool(*x > *y))
-            {
-                return x && (!y || convert_bool(*x > *y));
-            }
-            template<typename T, typename U>
-            constexpr auto operator<=(optional<T> const & x, optional<U> const & y) //
-                noexcept(noexcept(convert_bool(*x <= *y)))
-                    -> decltype(convert_bool(*x <= *y))
-            {
-                return !x || (y && convert_bool(*x <= *y));
-            }
-            template<typename T, typename U>
-            constexpr auto operator>=(optional<T> const & x, optional<U> const & y) //
-                noexcept(noexcept(convert_bool(*x >= *y)))
-                    -> decltype(convert_bool(*x >= *y))
-            {
-                return !y || (x && convert_bool(*x >= *y));
-            }
-
-            // Comparisons with nullopt [optional.nullops]
-            template<typename T>
-            constexpr bool operator==(optional<T> const & x, nullopt_t) noexcept
-            {
-                return !x;
-            }
-            template<typename T>
-            constexpr bool operator==(nullopt_t, optional<T> const & x) noexcept
-            {
-                return !x;
-            }
-            template<typename T>
-            constexpr bool operator!=(optional<T> const & x, nullopt_t) noexcept
-            {
-                return !!x;
-            }
-            template<typename T>
-            constexpr bool operator!=(nullopt_t, optional<T> const & x) noexcept
-            {
-                return !!x;
-            }
-            template<typename T>
-            constexpr bool operator<(optional<T> const &, nullopt_t) noexcept
-            {
-                return false;
-            }
-            template<typename T>
-            constexpr bool operator<(nullopt_t, optional<T> const & x) noexcept
-            {
-                return !!x;
-            }
-            template<typename T>
-            constexpr bool operator>(optional<T> const & x, nullopt_t) noexcept
-            {
-                return !!x;
-            }
-            template<typename T>
-            constexpr bool operator>(nullopt_t, optional<T> const &) noexcept
-            {
-                return false;
-            }
-            template<typename T>
-            constexpr bool operator<=(optional<T> const & x, nullopt_t) noexcept
-            {
-                return !x;
-            }
-            template<typename T>
-            constexpr bool operator<=(nullopt_t, optional<T> const &) noexcept
-            {
-                return true;
-            }
-            template<typename T>
-            constexpr bool operator>=(optional<T> const &, nullopt_t) noexcept
-            {
-                return true;
-            }
-            template<typename T>
-            constexpr bool operator>=(nullopt_t, optional<T> const & x) noexcept
-            {
-                return !x;
-            }
-
-            // Comparisons with T [optional.comp_with_t]
-            template<typename T, typename U>
-            constexpr auto operator==(optional<T> const & x, U const & y) //
-                noexcept(noexcept(convert_bool(*x == y)))                 //
-                -> decltype(convert_bool(*x == y))
-            {
-                return x && convert_bool(*x == y);
-            }
-            template<typename T, typename U>
-            constexpr auto operator==(T const & x, optional<U> const & y) //
-                noexcept(noexcept(convert_bool(x == *y)))                 //
-                -> decltype(convert_bool(x == *y))
-            {
-                return y && convert_bool(x == *y);
-            }
-            template<typename T, typename U>
-            constexpr auto operator!=(optional<T> const & x, U const & y) //
-                noexcept(noexcept(convert_bool(*x != y)))                 //
-                -> decltype(convert_bool(*x != y))
-            {
-                return !x || convert_bool(*x != y);
-            }
-            template<typename T, typename U>
-            constexpr auto operator!=(T const & x, optional<U> const & y) //
-                noexcept(noexcept(convert_bool(x != *y)))                 //
-                -> decltype(convert_bool(x != *y))
-            {
-                return !y || convert_bool(x != *y);
-            }
-            template<typename T, typename U>
-            constexpr auto operator<(optional<T> const & x, U const & y) //
-                noexcept(noexcept(convert_bool(*x < y)))                 //
-                -> decltype(convert_bool(*x < y))
-            {
-                return !x || convert_bool(*x < y);
-            }
-            template<typename T, typename U>
-            constexpr auto operator<(T const & x, optional<U> const & y) //
-                noexcept(noexcept(convert_bool(x < *y)))                 //
-                -> decltype(convert_bool(x < *y))
-            {
-                return y && convert_bool(x < *y);
-            }
-            template<typename T, typename U>
-            constexpr auto operator>(optional<T> const & x, U const & y) //
-                noexcept(noexcept(convert_bool(*x > y))) -> decltype(convert_bool(*x > y))
-            {
-                return x && convert_bool(*x > y);
-            }
-            template<typename T, typename U>
-            constexpr auto operator>(T const & x, optional<U> const & y) //
-                noexcept(noexcept(convert_bool(x > *y)))                 //
-                -> decltype(convert_bool(x > *y))
-            {
-                return !y || convert_bool(x > *y);
-            }
-            template<typename T, typename U>
-            constexpr auto operator<=(optional<T> const & x, U const & y) //
-                noexcept(noexcept(convert_bool(*x <= y)))                 //
-                -> decltype(convert_bool(*x <= y))
-            {
-                return !x || convert_bool(*x <= y);
-            }
-            template<typename T, typename U>
-            constexpr auto operator<=(T const & x, optional<U> const & y) //
-                noexcept(noexcept(convert_bool(x <= *y)))                 //
-                -> decltype(convert_bool(x <= *y))
-            {
-                return y && convert_bool(x <= *y);
-            }
-            template<typename T, typename U>
-            constexpr auto operator>=(optional<T> const & x, U const & y) //
-                noexcept(noexcept(convert_bool(*x >= y)))                 //
-                -> decltype(convert_bool(*x >= y))
-            {
-                return x && convert_bool(*x >= y);
-            }
-            template<typename T, typename U>
-            constexpr auto operator>=(T const & x, optional<U> const & y) //
-                noexcept(noexcept(convert_bool(x >= *y)))                 //
-                -> decltype(convert_bool(x >= *y))
-            {
-                return !y || convert_bool(x >= *y);
-            }
-
-            // clang-format off
-            template<typename T>
-            auto CPP_auto_fun(swap)(optional<T> &x, optional<T> &y)
-            (
-                return x.swap(y)
-            )
-            // clang-format on
-        } // namespace optional_adl
-    } // namespace detail
-    /// \endcond
-
-    // clang-format off
-    template<typename T>
-    constexpr auto CPP_auto_fun(make_optional)(T &&t)
-    (
-        return optional<detail::decay_t<T>>{static_cast<T &&>(t)}
-    )
-    template<typename T, typename... Args>
-    constexpr auto CPP_auto_fun(make_optional)(Args &&... args)
-    (
-        return optional<T>{in_place, static_cast<Args &&>(args)...}
-    )
-    template<typename T, typename U, typename... Args>
-    constexpr auto CPP_auto_fun(make_optional)(std::initializer_list<U> il,
-                                               Args &&... args)
-    (
-        return optional<T>{in_place, il, static_cast<Args &&>(args)...}
-    )
-    // clang-format on
-
-    /// \cond
-    namespace detail
-    {
-        template<typename T, typename Tag = void, bool Enable = true>
-        struct non_propagating_cache : optional<T>
-        {
-            non_propagating_cache() = default;
-            constexpr non_propagating_cache(nullopt_t) noexcept
-            {}
-            constexpr non_propagating_cache(non_propagating_cache const &) noexcept
-              : optional<T>{}
-            {}
-            constexpr non_propagating_cache(non_propagating_cache && that) noexcept
-              : optional<T>{}
-            {
-                that.optional<T>::reset();
-            }
-            constexpr non_propagating_cache & operator=(
-                non_propagating_cache const &) noexcept
-            {
-                optional<T>::reset();
-                return *this;
-            }
-            constexpr non_propagating_cache & operator=(
-                non_propagating_cache && that) noexcept
-            {
-                that.optional<T>::reset();
-                optional<T>::reset();
-                return *this;
-            }
-            using optional<T>::operator=;
-        };
-
-        template<typename T, typename Tag>
-        struct non_propagating_cache<T, Tag, false>
-        {};
-    } // namespace detail
-    /// \endcond
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/polymorphic_cast.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/polymorphic_cast.hpp
deleted file mode 100644
index e0949ab1..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/polymorphic_cast.hpp
+++ /dev/null
@@ -1,46 +0,0 @@
-//  (C) Copyright Kevlin Henney and Dave Abrahams 1999.
-//  Distributed under the Boost
-//  Software License, Version 1.0. (See accompanying file
-//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-#ifndef RANGES_V3_UTILITY_POLYMORPHIC_CAST_HPP
-#define RANGES_V3_UTILITY_POLYMORPHIC_CAST_HPP
-
-#include <memory>
-#include <type_traits>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/detail/config.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    template<typename Target, typename Source>
-    auto polymorphic_downcast(Source * x) noexcept
-        -> meta::if_<std::is_pointer<Target>,
-                     decltype((static_cast<Target>(x), dynamic_cast<Target>(x)))>
-    {
-        auto result = static_cast<Target>(x);
-        RANGES_ASSERT(dynamic_cast<Target>(x) == result);
-        return result;
-    }
-    template<typename Target, typename Source>
-    auto polymorphic_downcast(Source && x) noexcept
-        -> meta::if_<std::is_reference<Target>,
-                     decltype((static_cast<Target>(std::declval<Source>()),
-                               dynamic_cast<Target>(std::declval<Source>())))>
-    {
-        auto && result = static_cast<Target>(static_cast<Source &&>(x));
-#ifndef NDEBUG
-        auto && dresult = dynamic_cast<Target>(static_cast<Source &&>(x));
-        RANGES_ASSERT(std::addressof(dresult) == std::addressof(result));
-#endif
-        return static_cast<Target>(result);
-    }
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif // RANGES_V3_UTILITY_POLYMORPHIC_CAST_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/random.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/random.hpp
deleted file mode 100644
index 3196756f..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/random.hpp
+++ /dev/null
@@ -1,498 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-/*
- * Random-Number Utilities (randutil)
- *     Addresses common issues with C++11 random number generation.
- *     Makes good seeding easier, and makes using RNGs easy while retaining
- *     all the power.
- *
- * The MIT License (MIT)
- *
- * Copyright (c) 2015 Melissa E. O'Neill
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-#ifndef RANGES_V3_UTILITY_RANDOM_HPP
-#define RANGES_V3_UTILITY_RANDOM_HPP
-
-#include <array>
-#include <cstddef>
-#include <cstdint>
-#include <initializer_list>
-#include <new>
-#include <random>
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/copy.hpp>
-#include <range/v3/algorithm/generate.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/functional/reference_wrapper.hpp>
-#include <range/v3/iterator/concepts.hpp>
-
-#if !RANGES_CXX_THREAD_LOCAL
-#include <mutex>
-#endif
-
-#include <range/v3/detail/prologue.hpp>
-
-RANGES_DIAGNOSTIC_PUSH
-RANGES_DIAGNOSTIC_IGNORE_CXX17_COMPAT
-
-namespace ranges
-{
-    /// \addtogroup group-numerics
-    /// @{
-    // clang-format off
-    template<typename Gen>
-    CPP_requires(uniform_random_bit_generator_,
-        requires() //
-        (
-            Gen::min(),
-            Gen::max()
-        ));
-    template(typename Gen)(
-    concept (uniform_random_bit_generator_)(Gen),
-        unsigned_integral<invoke_result_t<Gen &>> AND
-        same_as<invoke_result_t<Gen &>, decltype(Gen::min())> AND
-        same_as<invoke_result_t<Gen &>, decltype(Gen::max())>);
-
-    template<typename Gen>
-    CPP_concept uniform_random_bit_generator =
-        invocable<Gen &> &&
-        CPP_requires_ref(ranges::uniform_random_bit_generator_, Gen) &&
-        CPP_concept_ref(ranges::uniform_random_bit_generator_, Gen);
-    // clang-format on
-    /// @}
-
-    /// \cond
-    namespace detail
-    {
-        namespace randutils
-        {
-            inline std::array<std::uint32_t, 8> get_entropy()
-            {
-                std::array<std::uint32_t, 8> seeds;
-
-                // Hopefully high-quality entropy from random_device.
-#if defined(__GLIBCXX__) && defined(RANGES_WORKAROUND_VALGRIND_RDRAND)
-                std::random_device rd{"/dev/urandom"};
-#else
-                std::random_device rd;
-#endif
-                std::uniform_int_distribution<std::uint32_t> dist{};
-                ranges::generate(seeds, [&] { return dist(rd); });
-
-                return seeds;
-            }
-
-            template(typename I)(
-                /// \pre
-                requires unsigned_integral<I>)
-            constexpr I fast_exp(I x, I power, I result = I{1})
-            {
-                return power == I{0}
-                           ? result
-                           : randutils::fast_exp(
-                                 x * x, power >> 1, result * (power & I{1} ? x : 1));
-            }
-
-            //////////////////////////////////////////////////////////////////////////////
-            //
-            // seed_seq_fe
-            //
-            //////////////////////////////////////////////////////////////////////////////
-
-            /*
-             * seed_seq_fe implements a fixed-entropy seed sequence; it conforms to all
-             * the requirements of a Seed Sequence concept.
-             *
-             * seed_seq_fe<N> implements a seed sequence which seeds based on a store of
-             * N * 32 bits of entropy.  Typically, it would be initialized with N or more
-             * integers.
-             *
-             * seed_seq_fe128 and seed_seq_fe256 are provided as convenience typedefs for
-             * 128- and 256-bit entropy stores respectively.  These variants outperform
-             * std::seed_seq, while being better mixing the bits it is provided as
-             * entropy. In almost all common use cases, they serve as better drop-in
-             * replacements for seed_seq.
-             *
-             * Technical details
-             *
-             * Assuming it constructed with M seed integers as input, it exhibits the
-             * following properties
-             *
-             * * Diffusion/Avalanche:  A single-bit change in any of the M inputs has a
-             *   50% chance of flipping every bit in the bitstream produced by generate.
-             *   Initializing the N-word entropy store with M words requires O(N * M)
-             *   time precisely because of the avalanche requirements.  Once constructed,
-             *   calls to generate are linear in the number of words generated.
-             *
-             * * Bias freedom/Bijection: If M == N, the state of the entropy store is a
-             *   bijection from the M inputs (i.e., no states occur twice, none are
-             *   omitted). If M > N the number of times each state can occur is the same
-             *   (each state occurs 2**(32*(M-N)) times, where ** is the power function).
-             *   If M < N, some states cannot occur (bias) but no state occurs more
-             *   than once (it's impossible to avoid bias if M < N; ideally N should not
-             *   be chosen so that it is more than M).
-             *
-             *   Likewise, the generate function has similar properties (with the entropy
-             *   store as the input data).  If more outputs are requested than there is
-             *   entropy, some outputs cannot occur.  For example, the Mersenne Twister
-             *   will request 624 outputs, to initialize its 19937-bit state, which is
-             *   much larger than a 128-bit or 256-bit entropy pool.  But in practice,
-             *   limiting the Mersenne Twister to 2**128 possible initializations gives
-             *   us enough initializations to give a unique initialization to trillions
-             *   of computers for billions of years.  If you really have 624 words of
-             *   *real* high-quality entropy you want to use, you probably don't need
-             *   an entropy mixer like this class at all.  But if you *really* want to,
-             *   nothing is stopping you from creating a randutils::seed_seq_fe<624>.
-             *
-             * * As a consequence of the above properties, if all parts of the provided
-             *   seed data are kept constant except one, and the remaining part is varied
-             *   through K different states, K different output sequences will be
-             *   produced.
-             *
-             * * Also, because the amount of entropy stored is fixed, this class never
-             *   performs dynamic allocation and is free of the possibility of generating
-             *   an exception.
-             *
-             * Ideas used to implement this code include hashing, a simple PCG generator
-             * based on an MCG base with an XorShift output function and permutation
-             * functions on tuples.
-             *
-             * More detail at
-             *     http://www.pcg-random.org/posts/developing-a-seed_seq-alternative.html
-             */
-
-            template<std::size_t count, typename IntRep = std::uint32_t>
-            struct seed_seq_fe
-            {
-            public:
-                CPP_assert(unsigned_integral<IntRep>);
-                typedef IntRep result_type;
-
-            private:
-                static constexpr std::size_t mix_rounds = 1 + (count <= 2);
-
-                static constexpr std::uint32_t INIT_A = 0x43b0d7e5;
-                static constexpr std::uint32_t MULT_A = 0x931e8875;
-
-                static constexpr std::uint32_t INIT_B = 0x8b51f9dd;
-                static constexpr std::uint32_t MULT_B = 0x58f38ded;
-
-                static constexpr std::uint32_t MIX_MULT_L = 0xca01f9dd;
-                static constexpr std::uint32_t MIX_MULT_R = 0x4973f715;
-                static constexpr std::uint32_t XSHIFT = sizeof(IntRep) * 8 / 2;
-
-                std::array<IntRep, count> mixer_;
-
-                template(typename I, typename S)(
-                    /// \pre
-                    requires input_iterator<I> AND sentinel_for<S, I> AND
-                        convertible_to<iter_reference_t<I>, IntRep>)
-                void mix_entropy(I first, S last)
-                {
-                    auto hash_const = INIT_A;
-                    auto hash = [&](IntRep value) RANGES_INTENDED_MODULAR_ARITHMETIC {
-                        value ^= hash_const;
-                        hash_const *= MULT_A;
-                        value *= hash_const;
-                        value ^= value >> XSHIFT;
-                        return value;
-                    };
-                    auto mix = [](IntRep x, IntRep y) RANGES_INTENDED_MODULAR_ARITHMETIC {
-                        IntRep result = MIX_MULT_L * x - MIX_MULT_R * y;
-                        result ^= result >> XSHIFT;
-                        return result;
-                    };
-
-                    for(auto & elem : mixer_)
-                    {
-                        if(first != last)
-                        {
-                            elem = hash(static_cast<IntRep>(*first));
-                            ++first;
-                        }
-                        else
-                            elem = hash(IntRep{0});
-                    }
-                    for(auto & src : mixer_)
-                        for(auto & dest : mixer_)
-                            if(&src != &dest)
-                                dest = mix(dest, hash(src));
-                    for(; first != last; ++first)
-                        for(auto & dest : mixer_)
-                            dest = mix(dest, hash(static_cast<IntRep>(*first)));
-                }
-
-            public:
-                seed_seq_fe(const seed_seq_fe &) = delete;
-                void operator=(const seed_seq_fe &) = delete;
-
-                template(typename T)(
-                    /// \pre
-                    requires convertible_to<T const &, IntRep>)
-                seed_seq_fe(std::initializer_list<T> init)
-                {
-                    seed(init.begin(), init.end());
-                }
-
-                template(typename I, typename S)(
-                    /// \pre
-                    requires input_iterator<I> AND sentinel_for<S, I> AND
-                        convertible_to<iter_reference_t<I>, IntRep>)
-                seed_seq_fe(I first, S last)
-                {
-                    seed(first, last);
-                }
-
-                // generating functions
-                template(typename I, typename S)(
-                    /// \pre
-                    requires random_access_iterator<I> AND sentinel_for<S, I>)
-                RANGES_INTENDED_MODULAR_ARITHMETIC //
-                void generate(I first, S const last) const
-                {
-                    auto src_begin = mixer_.begin();
-                    auto src_end = mixer_.end();
-                    auto src = src_begin;
-                    auto hash_const = INIT_B;
-                    for(; first != last; ++first)
-                    {
-                        auto dataval = *src;
-                        if(++src == src_end)
-                            src = src_begin;
-                        dataval ^= hash_const;
-                        hash_const *= MULT_B;
-                        dataval *= hash_const;
-                        dataval ^= dataval >> XSHIFT;
-                        *first = dataval;
-                    }
-                }
-
-                constexpr std::size_t size() const
-                {
-                    return count;
-                }
-
-                template(typename O)(
-                    /// \pre
-                    requires weakly_incrementable<O> AND
-                        indirectly_copyable<decltype(mixer_.begin()), O>)
-                RANGES_INTENDED_MODULAR_ARITHMETIC void param(O dest) const
-                {
-                    constexpr IntRep INV_A = randutils::fast_exp(MULT_A, IntRep(-1));
-                    constexpr IntRep MIX_INV_L =
-                        randutils::fast_exp(MIX_MULT_L, IntRep(-1));
-
-                    auto mixer_copy = mixer_;
-                    for(std::size_t round = 0; round < mix_rounds; ++round)
-                    {
-                        // Advance to the final value.  We'll backtrack from that.
-                        auto hash_const =
-                            INIT_A * randutils::fast_exp(MULT_A, IntRep(count * count));
-
-                        for(auto src = mixer_copy.rbegin(); src != mixer_copy.rend();
-                            ++src)
-                            for(auto rdest = mixer_copy.rbegin();
-                                rdest != mixer_copy.rend();
-                                ++rdest)
-                                if(src != rdest)
-                                {
-                                    IntRep revhashed = *src;
-                                    auto mult_const = hash_const;
-                                    hash_const *= INV_A;
-                                    revhashed ^= hash_const;
-                                    revhashed *= mult_const;
-                                    revhashed ^= revhashed >> XSHIFT;
-                                    IntRep unmixed = *rdest;
-                                    unmixed ^= unmixed >> XSHIFT;
-                                    unmixed += MIX_MULT_R * revhashed;
-                                    unmixed *= MIX_INV_L;
-                                    *rdest = unmixed;
-                                }
-
-                        for(auto i = mixer_copy.rbegin(); i != mixer_copy.rend(); ++i)
-                        {
-                            IntRep unhashed = *i;
-                            unhashed ^= unhashed >> XSHIFT;
-                            unhashed *= randutils::fast_exp(hash_const, IntRep(-1));
-                            hash_const *= INV_A;
-                            unhashed ^= hash_const;
-                            *i = unhashed;
-                        }
-                    }
-                    ranges::copy(mixer_copy, dest);
-                }
-
-                template(typename I, typename S)(
-                    /// \pre
-                    requires input_iterator<I> AND sentinel_for<S, I> AND
-                        convertible_to<iter_reference_t<I>, IntRep>)
-                void seed(I first, S last)
-                {
-                    mix_entropy(first, last);
-                    // For very small sizes, we do some additional mixing.  For normal
-                    // sizes, this loop never performs any iterations.
-                    for(std::size_t i = 1; i < mix_rounds; ++i)
-                        stir();
-                }
-
-                seed_seq_fe & stir()
-                {
-                    mix_entropy(mixer_.begin(), mixer_.end());
-                    return *this;
-                }
-            };
-
-            using seed_seq_fe128 = seed_seq_fe<4, std::uint32_t>;
-            using seed_seq_fe256 = seed_seq_fe<8, std::uint32_t>;
-
-            //////////////////////////////////////////////////////////////////////////////
-            //
-            // auto_seeded
-            //
-            //////////////////////////////////////////////////////////////////////////////
-
-            /*
-             * randutils::auto_seeded
-             *
-             *   Extends a seed sequence class with a nondeterministic default
-             * constructor. Uses a variety of local sources of entropy to portably
-             * initialize any seed sequence to a good default state.
-             *
-             *   In normal use, it's accessed via one of the following type aliases, which
-             *   use seed_seq_fe128 and seed_seq_fe256 above.
-             *
-             *       randutils::auto_seed_128
-             *       randutils::auto_seed_256
-             *
-             *   It's discussed in detail at
-             *       http://www.pcg-random.org/posts/simple-portable-cpp-seed-entropy.html
-             *   and its motivation (why you can't just use std::random_device) here
-             *       http://www.pcg-random.org/posts/cpps-random_device.html
-             */
-
-            template<typename SeedSeq>
-            struct auto_seeded : public SeedSeq
-            {
-                auto_seeded()
-                  : auto_seeded(randutils::get_entropy())
-                {}
-                template<std::size_t N>
-                auto_seeded(std::array<std::uint32_t, N> const & seeds)
-                  : SeedSeq(seeds.begin(), seeds.end())
-                {}
-                using SeedSeq::SeedSeq;
-
-                const SeedSeq & base() const
-                {
-                    return *this;
-                }
-                SeedSeq & base()
-                {
-                    return *this;
-                }
-            };
-
-            using auto_seed_128 = auto_seeded<seed_seq_fe128>;
-            using auto_seed_256 = auto_seeded<seed_seq_fe256>;
-        } // namespace randutils
-
-        using default_URNG = meta::if_c<(sizeof(void *) >= sizeof(long long)),
-                                        std::mt19937_64, std::mt19937>;
-
-#if !RANGES_CXX_THREAD_LOCAL
-        template<typename URNG>
-        class sync_URNG : private URNG
-        {
-            mutable std::mutex mtx_;
-
-        public:
-            using URNG::URNG;
-            sync_URNG() = default;
-            using typename URNG::result_type;
-            result_type operator()()
-            {
-                std::lock_guard<std::mutex> guard{mtx_};
-                return static_cast<URNG &>(*this)();
-            }
-            using URNG::max;
-            using URNG::min;
-        };
-        using default_random_engine = sync_URNG<default_URNG>;
-#else
-        using default_random_engine = default_URNG;
-#endif
-
-        template<typename T = void>
-        default_random_engine & get_random_engine()
-        {
-            using Seeder = meta::if_c<(sizeof(default_URNG) > 16),
-                                      randutils::auto_seed_256,
-                                      randutils::auto_seed_128>;
-
-#if RANGES_CXX_THREAD_LOCAL >= RANGES_CXX_THREAD_LOCAL_11
-            static thread_local default_random_engine engine{Seeder{}.base()};
-
-#elif RANGES_CXX_THREAD_LOCAL
-            static __thread bool initialized = false;
-            static __thread meta::_t<std::aligned_storage<sizeof(default_random_engine),
-                                                          alignof(default_random_engine)>>
-                storage;
-
-            if(!initialized)
-            {
-                ::new(static_cast<void *>(&storage))
-                    default_random_engine{Seeder{}.base()};
-                initialized = true;
-            }
-            auto & engine = reinterpret_cast<default_random_engine &>(storage);
-#else
-            static default_random_engine engine{Seeder{}.base()};
-#endif // RANGES_CXX_THREAD_LOCAL
-
-            return engine;
-        }
-    } // namespace detail
-    /// \endcond
-} // namespace ranges
-
-RANGES_DIAGNOSTIC_POP
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/scope_exit.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/scope_exit.hpp
deleted file mode 100644
index 243e23a1..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/scope_exit.hpp
+++ /dev/null
@@ -1,97 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2017-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_UTILITY_SCOPE_EXIT_HPP
-#define RANGES_V3_UTILITY_SCOPE_EXIT_HPP
-
-#include <functional>
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    template<typename Fun>
-    struct scope_exit
-    {
-    private:
-        using nothrow_move_t = std::is_nothrow_move_constructible<Fun>;
-        using nothrow_copy_t = std::is_nothrow_copy_constructible<Fun>;
-
-        Fun fun_;
-        bool dismissed_{false};
-
-        using ref_t = decltype(std::ref(std::declval<Fun const &>()));
-        using guard = scope_exit<ref_t>;
-
-        scope_exit(Fun const & fun, guard && g)
-          : fun_(fun)
-        {
-            g.dismiss();
-        }
-
-        scope_exit(Fun const & fun, std::false_type)
-          : scope_exit(fun, guard{std::ref(fun)})
-        {}
-
-        scope_exit(Fun const & fun, std::true_type) noexcept
-          : fun_(fun)
-        {}
-
-        scope_exit(Fun && fun, std::true_type) noexcept
-          : fun_(std::move(fun))
-        {}
-
-    public:
-        explicit scope_exit(Fun const & fun) noexcept(
-            noexcept(scope_exit(fun, nothrow_copy_t{})))
-          : scope_exit(fun, nothrow_copy_t{})
-        {}
-
-        explicit scope_exit(Fun && fun) noexcept(noexcept(scope_exit(std::move(fun),
-                                                                     nothrow_move_t{})))
-          : scope_exit(std::move(fun), nothrow_move_t{})
-        {}
-
-        scope_exit(scope_exit const &) = delete;
-
-        scope_exit(scope_exit && that) noexcept(
-            std::is_nothrow_move_constructible<Fun>::value)
-          : scope_exit(std::move((that.dismiss(), that)).fun_)
-        {}
-
-        ~scope_exit()
-        {
-            if(!dismissed_)
-                fun_();
-        }
-
-        void dismiss() noexcept
-        {
-            dismissed_ = true;
-        }
-    };
-
-    template<typename Fun, typename ScopeExit = scope_exit<meta::_t<std::decay<Fun>>>>
-    ScopeExit make_scope_exit(Fun && fun) noexcept(
-        noexcept(ScopeExit(ScopeExit((Fun &&) fun))))
-    {
-        return ScopeExit((Fun &&) fun);
-    }
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/semiregular.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/semiregular.hpp
deleted file mode 100644
index 8f481fc1..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/semiregular.hpp
+++ /dev/null
@@ -1,24 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_UTILITY_SEMIREGULAR_HPP
-#define RANGES_V3_UTILITY_SEMIREGULAR_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated. Please #include <range/v3/utility/semiregular_box.hpp> "
-    "instead.")
-
-#include <range/v3/utility/semiregular_box.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/semiregular_box.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/semiregular_box.hpp
deleted file mode 100644
index 65e0e59d..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/semiregular_box.hpp
+++ /dev/null
@@ -1,344 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_UTILITY_SEMIREGULAR_BOX_HPP
-#define RANGES_V3_UTILITY_SEMIREGULAR_BOX_HPP
-
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/concepts.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/functional/reference_wrapper.hpp>
-#include <range/v3/utility/get.hpp>
-#include <range/v3/utility/in_place.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    template<typename T>
-    struct semiregular_box;
-
-    namespace detail
-    {
-        struct semiregular_get
-        {
-            // clang-format off
-            template<typename T>
-            friend auto CPP_auto_fun(get)(meta::id_t<semiregular_box<T>> &t)
-            (
-                return t.get()
-            )
-            template<typename T>
-            friend auto CPP_auto_fun(get)(meta::id_t<semiregular_box<T>> const &t)
-            (
-                return t.get()
-            )
-            template<typename T>
-            friend auto CPP_auto_fun(get)(meta::id_t<semiregular_box<T>> &&t)
-            (
-                return detail::move(t).get()
-            )
-            // clang-format on
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// \addtogroup group-utility
-    /// @{
-    template<typename T>
-    struct semiregular_box : private detail::semiregular_get
-    {
-    private:
-        struct tag
-        {};
-        template<typename... Args>
-        void construct_from(Args &&... args)
-        {
-            new((void *)std::addressof(data_)) T(static_cast<Args &&>(args)...);
-            engaged_ = true;
-        }
-        void move_assign(T && t, std::true_type)
-        {
-            data_ = detail::move(t);
-        }
-        void move_assign(T && t, std::false_type)
-        {
-            reset();
-            construct_from(detail::move(t));
-        }
-        void copy_assign(T const & t, std::true_type)
-        {
-            data_ = t;
-        }
-        void copy_assign(T && t, std::false_type)
-        {
-            reset();
-            construct_from(t);
-        }
-        constexpr semiregular_box(tag, std::false_type) noexcept
-        {}
-        constexpr semiregular_box(tag, std::true_type) noexcept(
-            std::is_nothrow_default_constructible<T>::value)
-          : data_{}
-          , engaged_(true)
-        {}
-        void reset()
-        {
-            if(engaged_)
-            {
-                data_.~T();
-                engaged_ = false;
-            }
-        }
-        union
-        {
-            char ch_{};
-            T data_;
-        };
-        bool engaged_{false};
-
-    public:
-        constexpr semiregular_box() noexcept(
-            std::is_nothrow_default_constructible<T>::value ||
-            !std::is_default_constructible<T>::value)
-          : semiregular_box(tag{}, std::is_default_constructible<T>{})
-        {}
-        semiregular_box(semiregular_box && that) noexcept(
-            std::is_nothrow_move_constructible<T>::value)
-        {
-            if(that.engaged_)
-                this->construct_from(detail::move(that.data_));
-        }
-        semiregular_box(semiregular_box const & that) noexcept(
-            std::is_nothrow_copy_constructible<T>::value)
-        {
-            if(that.engaged_)
-                this->construct_from(that.data_);
-        }
-#if defined(__cpp_conditional_explicit) && 0 < __cpp_conditional_explicit
-        template(typename U)(
-            /// \pre
-            requires (!same_as<uncvref_t<U>, semiregular_box>) AND
-                constructible_from<T, U>)
-        explicit(!convertible_to<U, T>) constexpr semiregular_box(U && u)
-            noexcept(std::is_nothrow_constructible<T, U>::value)
-          : semiregular_box(in_place, static_cast<U &&>(u))
-        {}
-#else
-        template(typename U)(
-            /// \pre
-            requires (!same_as<uncvref_t<U>, semiregular_box>) AND
-                constructible_from<T, U> AND (!convertible_to<U, T>)) //
-        constexpr explicit semiregular_box(U && u)
-            noexcept(std::is_nothrow_constructible<T, U>::value)
-          : semiregular_box(in_place, static_cast<U &&>(u))
-        {}
-        template(typename U)(
-            /// \pre
-            requires (!same_as<uncvref_t<U>, semiregular_box>) AND
-                constructible_from<T, U> AND convertible_to<U, T>)
-        constexpr semiregular_box(U && u)
-            noexcept(std::is_nothrow_constructible<T, U>::value)
-          : semiregular_box(in_place, static_cast<U &&>(u))
-        {}
-#endif
-        template(typename... Args)(
-            /// \pre
-            requires constructible_from<T, Args...>)
-        constexpr semiregular_box(in_place_t, Args &&... args) //
-            noexcept(std::is_nothrow_constructible<T, Args...>::value)
-          : data_(static_cast<Args &&>(args)...)
-          , engaged_(true)
-        {}
-        ~semiregular_box()
-        {
-            reset();
-        }
-        semiregular_box & operator=(semiregular_box && that) noexcept(
-            std::is_nothrow_move_constructible<T>::value &&
-            (!std::is_move_assignable<T>::value ||
-             std::is_nothrow_move_assignable<T>::value))
-        {
-            if(engaged_ && that.engaged_)
-                this->move_assign(detail::move(that.data_), std::is_move_assignable<T>());
-            else if(that.engaged_)
-                this->construct_from(detail::move(that.data_));
-            else if(engaged_)
-                this->reset();
-            return *this;
-        }
-        semiregular_box & operator=(semiregular_box const & that) noexcept(
-            std::is_nothrow_copy_constructible<T>::value &&
-            (!std::is_copy_assignable<T>::value ||
-             std::is_nothrow_copy_assignable<T>::value))
-        {
-            if(engaged_ && that.engaged_)
-                this->copy_assign(that.data_, std::is_copy_assignable<T>());
-            else if(that.engaged_)
-                this->construct_from(that.data_);
-            else if(engaged_)
-                this->reset();
-            return *this;
-        }
-        constexpr T & get() & noexcept
-        {
-            return RANGES_ENSURE(engaged_), data_;
-        }
-        constexpr T const & get() const & noexcept
-        {
-            return RANGES_ENSURE(engaged_), data_;
-        }
-        constexpr T && get() && noexcept
-        {
-            return RANGES_ENSURE(engaged_), detail::move(data_);
-        }
-        T const && get() const && = delete;
-        constexpr operator T &() & noexcept
-        {
-            return get();
-        }
-        constexpr operator T const &() const & noexcept
-        {
-            return get();
-        }
-        constexpr operator T &&() && noexcept
-        {
-            return detail::move(get());
-        }
-        operator T const &&() const && = delete;
-        // clang-format off
-        template(typename... Args)(
-            /// \pre
-            requires invocable<T &, Args...>)
-        constexpr decltype(auto) operator()(Args &&... args) &
-            noexcept(is_nothrow_invocable_v<T &, Args...>)
-        {
-            return invoke(data_, static_cast<Args &&>(args)...);
-        }
-        template(typename... Args)(
-            /// \pre
-            requires invocable<T const &, Args...>)
-        constexpr decltype(auto) operator()(Args &&... args) const &
-            noexcept(is_nothrow_invocable_v<T const &, Args...>)
-        {
-            return invoke(data_, static_cast<Args &&>(args)...);
-        }
-        template(typename... Args)(
-            /// \pre
-            requires invocable<T, Args...>)
-        constexpr decltype(auto) operator()(Args &&... args) &&
-            noexcept(is_nothrow_invocable_v<T, Args...>)
-        {
-            return invoke(static_cast<T &&>(data_), static_cast<Args &&>(args)...);
-        }
-        template<typename... Args>
-        void operator()(Args &&...) const && = delete;
-        // clang-format on
-    };
-
-    template<typename T>
-    struct semiregular_box<T &>
-      : private ranges::reference_wrapper<T &>
-      , private detail::semiregular_get
-    {
-        semiregular_box() = default;
-        template(typename Arg)(
-            /// \pre
-            requires constructible_from<ranges::reference_wrapper<T &>, Arg &>)
-        semiregular_box(in_place_t, Arg & arg) noexcept //
-          : ranges::reference_wrapper<T &>(arg)
-        {}
-        using ranges::reference_wrapper<T &>::get;
-        using ranges::reference_wrapper<T &>::operator T &;
-        using ranges::reference_wrapper<T &>::operator();
-
-#if defined(_MSC_VER)
-        template(typename U)(
-            /// \pre
-            requires (!same_as<uncvref_t<U>, semiregular_box>) AND
-            constructible_from<ranges::reference_wrapper<T &>, U>)
-        constexpr semiregular_box(U && u) noexcept(
-            std::is_nothrow_constructible<ranges::reference_wrapper<T &>, U>::value)
-          : ranges::reference_wrapper<T &>{static_cast<U &&>(u)}
-        {}
-#else
-        using ranges::reference_wrapper<T &>::reference_wrapper;
-#endif
-    };
-
-    template<typename T>
-    struct semiregular_box<T &&>
-      : private ranges::reference_wrapper<T &&>
-      , private detail::semiregular_get
-    {
-        semiregular_box() = default;
-        template(typename Arg)(
-            /// \pre
-            requires constructible_from<ranges::reference_wrapper<T &&>, Arg>)
-        semiregular_box(in_place_t, Arg && arg) noexcept //
-          : ranges::reference_wrapper<T &&>(static_cast<Arg &&>(arg))
-        {}
-        using ranges::reference_wrapper<T &&>::get;
-        using ranges::reference_wrapper<T &&>::operator T &&;
-        using ranges::reference_wrapper<T &&>::operator();
-
-#if defined(_MSC_VER)
-        template(typename U)(
-            /// \pre
-            requires (!same_as<uncvref_t<U>, semiregular_box>) AND
-            constructible_from<ranges::reference_wrapper<T &&>, U>)
-        constexpr semiregular_box(U && u) noexcept(
-            std::is_nothrow_constructible<ranges::reference_wrapper<T &&>, U>::value)
-          : ranges::reference_wrapper<T &&>{static_cast<U &&>(u)}
-        {}
-#else
-        using ranges::reference_wrapper<T &&>::reference_wrapper;
-#endif
-    };
-
-    template<typename T>
-    using semiregular_box_t = meta::if_c<(bool)semiregular<T>, T, semiregular_box<T>>;
-
-    template<typename T, bool IsConst = false>
-    using semiregular_box_ref_or_val_t = meta::if_c<
-        (bool)semiregular<T>,
-        meta::if_c<IsConst || std::is_empty<T>::value, T, reference_wrapper<T>>,
-        reference_wrapper<
-            meta::if_c<IsConst, semiregular_box<T> const, semiregular_box<T>>>>;
-    /// @}
-
-    /// \cond
-    template<typename T>
-    using semiregular_t RANGES_DEPRECATED("Please use semiregular_box_t instead.") =
-        semiregular_box_t<T>;
-
-    template<typename T, bool IsConst = false>
-    using semiregular_ref_or_val_t RANGES_DEPRECATED(
-        "Please use semiregular_box_ref_or_val_t instead.") =
-        semiregular_box_ref_or_val_t<T, IsConst>;
-    /// \endcond
-
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/static_const.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/static_const.hpp
deleted file mode 100644
index 690a1428..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/static_const.hpp
+++ /dev/null
@@ -1,32 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_UTILITY_STATIC_CONST_HPP
-#define RANGES_V3_UTILITY_STATIC_CONST_HPP
-
-namespace ranges
-{
-    /// \ingroup group-utility
-
-    template<typename T>
-    struct static_const
-    {
-        static constexpr T value{};
-    };
-
-    /// \ingroup group-utility
-    /// \sa `static_const`
-    template<typename T>
-    constexpr T static_const<T>::value;
-} // namespace ranges
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/swap.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/swap.hpp
deleted file mode 100644
index 3a492a45..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/swap.hpp
+++ /dev/null
@@ -1,55 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-// The implementation of swap (see below) has been adapted from libc++
-// (http://libcxx.llvm.org).
-
-#ifndef RANGES_V3_UTILITY_SWAP_HPP
-#define RANGES_V3_UTILITY_SWAP_HPP
-
-#include <concepts/swap.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    template<typename T>
-    using is_swappable = concepts::is_swappable<T>;
-
-    template<typename T>
-    using is_nothrow_swappable = concepts::is_nothrow_swappable<T>;
-
-    template<typename T, typename U>
-    using is_swappable_with = concepts::is_swappable_with<T, U>;
-
-    template<typename T, typename U>
-    using is_nothrow_swappable_with = concepts::is_nothrow_swappable_with<T, U>;
-
-    using concepts::exchange;
-
-    /// \ingroup group-utility
-    /// \relates concepts::adl_swap_detail::swap_fn
-    RANGES_DEFINE_CPO(uncvref_t<decltype(concepts::swap)>, swap)
-
-    namespace cpp20
-    {
-        using ranges::swap;
-    }
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/tagged_pair.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/tagged_pair.hpp
deleted file mode 100644
index f967f778..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/tagged_pair.hpp
+++ /dev/null
@@ -1,236 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#ifndef RANGES_V3_UTILITY_TAGGED_PAIR_HPP
-#define RANGES_V3_UTILITY_TAGGED_PAIR_HPP
-
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/detail/adl_get.hpp>
-#include <range/v3/utility/swap.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-RANGES_DIAGNOSTIC_PUSH
-RANGES_DIAGNOSTIC_IGNORE_DEPRECATED_DECLARATIONS
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        template<typename T>
-        using tag_spec = meta::front<meta::as_list<T>>;
-
-        template<typename T>
-        using tag_elem = meta::back<meta::as_list<T>>;
-
-        template<typename Base, std::size_t, typename...>
-        struct tagged_chain
-        {
-            using type = _tuple_wrapper_::forward_tuple_interface<Base>;
-        };
-        template<typename Base, std::size_t I, typename First, typename... Rest>
-        struct tagged_chain<Base, I, First, Rest...>
-        {
-            using type = typename First::template getter<
-                Base, I, meta::_t<tagged_chain<Base, I + 1, Rest...>>>;
-        };
-    } // namespace detail
-
-#if RANGES_BROKEN_CPO_LOOKUP
-    namespace _tagged_
-    {
-        struct adl_hook_
-        {};
-    } // namespace _tagged_
-#endif
-    /// \endcond
-
-    template<typename Base, typename... Tags>
-    class RANGES_EMPTY_BASES RANGES_DEPRECATED(
-        "Class template tagged is deprecated.") tagged
-      : public meta::_t<detail::tagged_chain<Base, 0, Tags...>>
-#if RANGES_BROKEN_CPO_LOOKUP
-      , private _tagged_::adl_hook_
-#endif
-    {
-        CPP_assert(same_as<Base, uncvref_t<Base>>);
-        using base_t = meta::_t<detail::tagged_chain<Base, 0, Tags...>>;
-
-        template<typename Other>
-        struct can_convert
-          : meta::bool_<!RANGES_IS_SAME(Other, Base) &&
-                        detail::is_convertible<Other, Base>::value>
-        {};
-
-    public:
-        tagged() = default;
-        using base_t::base_t;
-        template(typename Other)(
-            /// \pre
-            requires can_convert<Other>::value)          //
-        constexpr tagged(tagged<Other, Tags...> && that) //
-            noexcept(std::is_nothrow_constructible<Base, Other>::value)
-          : base_t(static_cast<Other &&>(that))
-        {}
-        template(typename Other)(
-            /// \pre
-            requires can_convert<Other>::value)               //
-        constexpr tagged(tagged<Other, Tags...> const & that) //
-            noexcept(std::is_nothrow_constructible<Base, Other const &>::value)
-          : base_t(static_cast<Other const &>(that))
-        {}
-        template(typename Other)(
-            /// \pre
-            requires can_convert<Other>::value) //
-        constexpr tagged & operator=(tagged<Other, Tags...> && that) //
-            noexcept(
-                noexcept(std::declval<Base &>() = static_cast<Other &&>(that)))
-        {
-            static_cast<Base &>(*this) = static_cast<Other &&>(that);
-            return *this;
-        }
-        template(typename Other)(
-            /// \pre
-            requires can_convert<Other>::value) //
-        constexpr tagged & operator=(tagged<Other, Tags...> const & that) //
-            noexcept(
-                noexcept(std::declval<Base &>() = static_cast<Other const &>(that)))
-        {
-            static_cast<Base &>(*this) = static_cast<Other const &>(that);
-            return *this;
-        }
-        template(typename U)(
-            /// \pre
-            requires (!same_as<tagged, detail::decay_t<U>>) AND
-                satisfies<Base &, std::is_assignable, U>)
-        constexpr tagged & operator=(U && u) //
-            noexcept(noexcept(std::declval<Base &>() = static_cast<U &&>(u)))
-        {
-            static_cast<Base &>(*this) = static_cast<U &&>(u);
-            return *this;
-        }
-        template(typename B = Base)(
-            /// \pre
-            requires is_swappable<B>::value) //
-        constexpr void swap(tagged & that) noexcept(is_nothrow_swappable<B>::value)
-        {
-            ranges::swap(static_cast<Base &>(*this), static_cast<Base &>(that));
-        }
-#if !RANGES_BROKEN_CPO_LOOKUP
-        template<typename B = Base>
-        friend constexpr auto swap(tagged & x, tagged & y) //
-            noexcept(is_nothrow_swappable<B>::value)
-            -> CPP_broken_friend_ret(void)(
-                /// \pre
-                requires is_swappable<B>::value)
-        {
-            x.swap(y);
-        }
-#endif
-    };
-
-#if RANGES_BROKEN_CPO_LOOKUP
-    namespace _tagged_
-    {
-        template(typename Base, typename... Tags)(
-            /// \pre
-            requires is_swappable<Base>::value) //
-        constexpr void swap(tagged<Base, Tags...> & x, tagged<Base, Tags...> & y) //
-            noexcept(is_nothrow_swappable<Base>::value)
-        {
-            x.swap(y);
-        }
-    } // namespace _tagged_
-#endif
-
-    template<typename F, typename S>
-    using tagged_pair RANGES_DEPRECATED("ranges::tagged_pair is deprecated.") =
-        tagged<std::pair<detail::tag_elem<F>, detail::tag_elem<S>>, detail::tag_spec<F>,
-               detail::tag_spec<S>>;
-
-    template<typename Tag1, typename Tag2, typename T1, typename T2,
-             typename R = tagged_pair<Tag1(bind_element_t<T1>), Tag2(bind_element_t<T2>)>>
-    RANGES_DEPRECATED("ranges::make_tagged_pair is deprecated.")
-    constexpr R make_tagged_pair(T1 && t1, T2 && t2) noexcept(
-        std::is_nothrow_constructible<R, T1, T2>::value)
-    {
-        return {static_cast<T1 &&>(t1), static_cast<T2 &&>(t2)};
-    }
-} // namespace ranges
-
-#define RANGES_DEFINE_TAG_SPECIFIER(NAME)                                               \
-    namespace tag                                                                       \
-    {                                                                                   \
-        struct NAME                                                                     \
-        {                                                                               \
-            template<typename Untagged, std::size_t I, typename Next>                   \
-            class getter : public Next                                                  \
-            {                                                                           \
-            protected:                                                                  \
-                ~getter() = default;                                                    \
-                                                                                        \
-            public:                                                                     \
-                getter() = default;                                                     \
-                getter(getter &&) = default;                                            \
-                getter(getter const &) = default;                                       \
-                using Next::Next;                                                       \
-                getter & operator=(getter &&) = default;                                \
-                getter & operator=(getter const &) = default;                           \
-                constexpr meta::_t<std::tuple_element<I, Untagged>> & NAME() &          \
-                    noexcept(noexcept(detail::adl_get<I>(std::declval<Untagged &>())))  \
-                {                                                                       \
-                    return detail::adl_get<I>(static_cast<Untagged &>(*this));          \
-                }                                                                       \
-                constexpr meta::_t<std::tuple_element<I, Untagged>> && NAME() &&        \
-                    noexcept(noexcept(detail::adl_get<I>(std::declval<Untagged>())))    \
-                {                                                                       \
-                    return detail::adl_get<I>(static_cast<Untagged &&>(*this));         \
-                }                                                                       \
-                constexpr meta::_t<std::tuple_element<I, Untagged>> const & NAME()      \
-                    const & noexcept(                                                   \
-                        noexcept(detail::adl_get<I>(std::declval<Untagged const &>()))) \
-                {                                                                       \
-                    return detail::adl_get<I>(static_cast<Untagged const &>(*this));    \
-                }                                                                       \
-            };                                                                          \
-        };                                                                              \
-    }                                                                                   \
-    /**/
-
-RANGES_DIAGNOSTIC_IGNORE_MISMATCHED_TAGS
-
-namespace std
-{
-    template<typename Untagged, typename... Tags>
-    struct tuple_size<::ranges::tagged<Untagged, Tags...>> : tuple_size<Untagged>
-    {};
-
-    template<size_t N, typename Untagged, typename... Tags>
-    struct tuple_element<N, ::ranges::tagged<Untagged, Tags...>>
-      : tuple_element<N, Untagged>
-    {};
-} // namespace std
-
-RANGES_DIAGNOSTIC_POP
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/tagged_tuple.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/tagged_tuple.hpp
deleted file mode 100644
index 4efe07d4..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/tagged_tuple.hpp
+++ /dev/null
@@ -1,45 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#ifndef RANGES_V3_UTILITY_TAGGED_TUPLE_HPP
-#define RANGES_V3_UTILITY_TAGGED_TUPLE_HPP
-
-#include <tuple>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/utility/tagged_pair.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-RANGES_DIAGNOSTIC_PUSH
-RANGES_DIAGNOSTIC_IGNORE_DEPRECATED_DECLARATIONS
-
-namespace ranges
-{
-    template<typename... Ts>
-    using tagged_tuple RANGES_DEPRECATED("ranges::tagged_tuple is deprecated.") =
-        tagged<std::tuple<detail::tag_elem<Ts>...>, detail::tag_spec<Ts>...>;
-
-    template<typename... Tags, typename... Ts>
-    RANGES_DEPRECATED("ranges::make_tagged_tuple is deprecated.")
-    constexpr tagged_tuple<Tags(bind_element_t<Ts>)...> make_tagged_tuple(Ts &&... ts)
-    {
-        return tagged_tuple<Tags(bind_element_t<Ts>)...>{static_cast<Ts &&>(ts)...};
-    }
-} // namespace ranges
-
-RANGES_DIAGNOSTIC_POP
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/tuple_algorithm.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/tuple_algorithm.hpp
deleted file mode 100644
index dcaedb41..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/tuple_algorithm.hpp
+++ /dev/null
@@ -1,196 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_UTILITY_TUPLE_ALGORITHM_HPP
-#define RANGES_V3_UTILITY_TUPLE_ALGORITHM_HPP
-
-#include <initializer_list>
-#include <tuple>
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/detail/adl_get.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-utility
-    /// @{
-    template<typename Tup>
-    using tuple_indices_t = meta::make_index_sequence<
-        std::tuple_size<typename std::remove_reference<Tup>::type>::value>;
-
-    struct tuple_apply_fn
-    {
-        // clang-format off
-    private:
-        template<typename Fun, typename Tup, std::size_t... Is>
-        static constexpr auto //
-        CPP_auto_fun(impl)(Fun &&fun, Tup &&tup, meta::index_sequence<Is...>)
-        (
-            return invoke(static_cast<Fun &&>(fun),
-                          detail::adl_get<Is>(static_cast<Tup &&>(tup))...)
-        )
-    public:
-        template<typename Fun, typename Tup>
-        constexpr auto CPP_auto_fun(operator())(Fun &&fun, Tup &&tup)(const)
-        (
-            return tuple_apply_fn::impl(static_cast<Fun &&>(fun),
-                                        static_cast<Tup &&>(tup),
-                                        tuple_indices_t<Tup>{})
-        )
-        // clang-format on
-    };
-
-    /// \ingroup group-utility
-    /// \sa `tuple_apply_fn`
-    RANGES_INLINE_VARIABLE(tuple_apply_fn, tuple_apply)
-
-    struct tuple_transform_fn
-    {
-        // clang-format off
-    private:
-        template<typename Tup, typename Fun, std::size_t... Is>
-        static constexpr auto //
-        CPP_auto_fun(impl1)(Tup &&tup, Fun &fun, meta::index_sequence<Is...>)
-        (
-            return std::tuple<
-                decltype(fun(detail::adl_get<Is>(static_cast<Tup &&>(tup))))...>{
-                fun(detail::adl_get<Is>(static_cast<Tup &&>(
-                    tup)))...}
-        )
-        template<typename Tup0, typename Tup1, typename Fun, std::size_t... Is>
-        static constexpr auto CPP_auto_fun(impl2)(Tup0 &&tup0, Tup1 &&tup1, Fun &fun,
-                                        meta::index_sequence<Is...>)
-        (
-            return std::tuple<
-                decltype(fun(detail::adl_get<Is>(static_cast<Tup0 &&>(tup0)),
-                             detail::adl_get<Is>(static_cast<Tup1 &&>(tup1))))...>{
-                fun(detail::adl_get<Is>(static_cast<Tup0 &&>(tup0)),
-                    detail::adl_get<Is>(static_cast<Tup1 &&>(tup1)))...}
-        )
-    public:
-        template<typename Tup, typename Fun>
-        constexpr auto CPP_auto_fun(operator())(Tup &&tup, Fun fun)(const)
-        (
-            return tuple_transform_fn::impl1(
-                static_cast<Tup &&>(tup), fun,
-                tuple_indices_t<Tup>{})
-        )
-        template<typename Tup0, typename Tup1, typename Fun>
-        constexpr auto CPP_auto_fun(operator())(Tup0 &&tup0, Tup1 &&tup1, Fun fun)(const)
-        (
-            return tuple_transform_fn::impl2(static_cast<Tup0 &&>(tup0),
-                                             static_cast<Tup1 &&>(tup1), fun,
-                                             tuple_indices_t<Tup0>{})
-        )
-        // clang-format on
-    };
-
-    /// \ingroup group-utility
-    /// \sa `tuple_transform_fn`
-    RANGES_INLINE_VARIABLE(tuple_transform_fn, tuple_transform)
-
-    struct tuple_foldl_fn
-    {
-    private:
-        template<typename Tup, typename Val, typename Fun>
-        static constexpr Val impl(Tup &&, Val val, Fun &)
-        {
-            return val;
-        }
-        // clang-format off
-        template<std::size_t I0, std::size_t... Is, typename Tup, typename Val,
-                 typename Fun, typename Impl = tuple_foldl_fn>
-        static constexpr auto CPP_auto_fun(impl)(Tup &&tup, Val val, Fun &fun)
-        (
-            return Impl::template impl<Is...>(
-                static_cast<Tup &&>(tup),
-                fun(std::move(val), detail::adl_get<I0>(static_cast<Tup &&>(tup))),
-                fun)
-        )
-        template<typename Tup, typename Val, typename Fun, std::size_t... Is>
-        static constexpr auto CPP_auto_fun(impl2)(Tup &&tup, Val val, Fun &fun,
-                                        meta::index_sequence<Is...>)
-        (
-            return tuple_foldl_fn::impl<Is...>(static_cast<Tup &&>(tup),
-                                               std::move(val),
-                                               fun)
-        )
-    public:
-        template<typename Tup, typename Val, typename Fun>
-        constexpr auto CPP_auto_fun(operator())(Tup &&tup, Val val, Fun fun)(const)
-        (
-            return tuple_foldl_fn::impl2(static_cast<Tup &&>(tup),
-                                         std::move(val),
-                                         fun,
-                                         tuple_indices_t<Tup>{})
-        )
-        // clang-format on
-    };
-
-    /// \ingroup group-utility
-    /// \sa `tuple_foldl_fn`
-    RANGES_INLINE_VARIABLE(tuple_foldl_fn, tuple_foldl)
-
-    struct tuple_for_each_fn
-    {
-    private:
-        template<typename Tup, typename Fun, std::size_t... Is>
-        static constexpr void impl(Tup && tup, Fun & fun, meta::index_sequence<Is...>)
-        {
-            (void)std::initializer_list<int>{
-                ((void)fun(detail::adl_get<Is>(static_cast<Tup &&>(tup))), 42)...};
-        }
-
-    public:
-        template<typename Tup, typename Fun>
-        constexpr Fun operator()(Tup && tup, Fun fun) const
-        {
-            return tuple_for_each_fn::impl(
-                       static_cast<Tup &&>(tup), fun, tuple_indices_t<Tup>{}),
-                   fun;
-        }
-    };
-
-    /// \ingroup group-utility
-    /// \sa `tuple_for_each_fn`
-    RANGES_INLINE_VARIABLE(tuple_for_each_fn, tuple_for_each)
-
-    struct make_tuple_fn
-    {
-        // clang-format off
-        template<typename... Ts>
-        constexpr auto CPP_auto_fun(operator())(Ts &&... ts)(const)
-        (
-            return std::make_tuple(static_cast<Ts &&>(ts)...)
-        )
-        // clang-format on
-    };
-
-    /// \ingroup group-utility
-    /// \sa `make_tuple_fn`
-    RANGES_INLINE_VARIABLE(make_tuple_fn, make_tuple)
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/unreachable.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/unreachable.hpp
deleted file mode 100644
index f01aa358..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/unreachable.hpp
+++ /dev/null
@@ -1,22 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_UTILITY_UNREACHABLE_HPP
-#define RANGES_V3_UTILITY_UNREACHABLE_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated. Please #include "
-    "<range/v3/iterator/unreachable_sentinel.hpp> instead.")
-
-#include <range/v3/iterator/unreachable_sentinel.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/utility/variant.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/utility/variant.hpp
deleted file mode 100644
index 03911c0c..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/utility/variant.hpp
+++ /dev/null
@@ -1,142 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_UTILITY_VARIANT_HPP
-#define RANGES_V3_UTILITY_VARIANT_HPP
-
-#include <range/v3/algorithm/copy.hpp>
-#include <range/v3/algorithm/move.hpp>
-#include <range/v3/detail/variant.hpp>
-#include <range/v3/iterator/move_iterators.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/primitives.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        template<typename T, std::size_t N, typename Index>
-        struct indexed_datum<T[N], Index>
-        {
-        private:
-            union
-            {
-                char c;
-                T data_[N];
-            };
-            void fill_default_(T * p, std::true_type)
-            {
-                for(; p != ranges::end(data_); ++p)
-                    ::new((void *)p) T{};
-            }
-            void fill_default_(T * p, std::false_type)
-            {
-                RANGES_EXPECT(p == ranges::end(data_));
-            }
-
-        public:
-            CPP_member
-            constexpr CPP_ctor(indexed_datum)(meta::nil_ = {})(
-                /// \pre
-                requires default_constructible<T>)
-              : data_{}
-            {}
-            CPP_member
-            CPP_ctor(indexed_datum)(indexed_datum && that)(
-                /// \pre
-                requires move_constructible<T>)
-            {
-                std::uninitialized_copy_n(make_move_iterator(that.data_), N, data_);
-            }
-            CPP_member
-            CPP_ctor(indexed_datum)(indexed_datum const & that)(
-                /// \pre
-                requires copy_constructible<T>)
-            {
-                std::uninitialized_copy_n(that.data_, N, data_);
-            }
-            // \pre Requires distance(first, last) <= N
-            // \pre Requires default_constructible<T> || distance(first, last) == N
-            template(typename I, typename S)(
-                /// \pre
-                requires sentinel_for<S, I> AND input_iterator<I> AND
-                    constructible_from<T, iter_reference_t<I>>)
-            indexed_datum(I first, S last)
-            {
-                T * p = detail::uninitialized_copy(first, last, data_);
-                this->fill_default_(p, meta::bool_<default_constructible<T>>{});
-            }
-            // \pre Requires distance(r) <= N
-            // \pre Requires default_constructible<T> || distance(r) == N
-            template(typename R)(
-                /// \pre
-                requires input_range<R> AND constructible_from<T, range_reference_t<R>>)
-            explicit indexed_datum(R && r)
-              : indexed_datum{ranges::begin(r), ranges::end(r)}
-            {}
-            CPP_member
-            auto operator=(indexed_datum && that) //
-                -> CPP_ret(indexed_datum &)(
-                    /// \pre
-                    requires assignable_from<T &, T>)
-            {
-                ranges::move(that.data_, data_);
-                return *this;
-            }
-            CPP_member
-            auto operator=(indexed_datum const & that) //
-                -> CPP_ret(indexed_datum &)(
-                    /// \pre
-                    requires assignable_from<T &, T const &>)
-            {
-                ranges::copy(that.data_, data_);
-                return *this;
-            }
-            // \pre Requires ranges::distance(r) <= N
-            template(typename R)(
-                /// \pre
-                requires input_range<R> AND assignable_from<T &, range_reference_t<R>>)
-            indexed_datum & operator=(R && r)
-            {
-                ranges::copy(r, data_);
-                return *this;
-            }
-            constexpr auto ref()
-            {
-                return indexed_element<T(&)[N], Index::value>{data_};
-            }
-            constexpr auto ref() const
-            {
-                return indexed_element<T const(&)[N], Index::value>{data_};
-            }
-            constexpr T (&get() noexcept)[N]
-            {
-                return data_;
-            }
-            constexpr T const (&get() const noexcept)[N]
-            {
-                return data_;
-            }
-        };
-    } // namespace detail
-    /// \endcond
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/version.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/version.hpp
deleted file mode 100644
index 29adc700..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/version.hpp
+++ /dev/null
@@ -1,24 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2017-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VERSION_HPP
-#define RANGES_V3_VERSION_HPP
-
-#define RANGE_V3_MAJOR 0
-#define RANGE_V3_MINOR 11
-#define RANGE_V3_PATCHLEVEL 0
-
-#define RANGE_V3_VERSION \
-    (RANGE_V3_MAJOR * 10000 + RANGE_V3_MINOR * 100 + RANGE_V3_PATCHLEVEL)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view.hpp
deleted file mode 100644
index 51cd2016..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view.hpp
+++ /dev/null
@@ -1,89 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_HPP
-#define RANGES_V3_VIEW_HPP
-
-#include <range/v3/view/adaptor.hpp>
-#include <range/v3/view/addressof.hpp>
-#include <range/v3/view/adjacent_filter.hpp>
-#include <range/v3/view/adjacent_remove_if.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/any_view.hpp>
-#include <range/v3/view/c_str.hpp>
-#include <range/v3/view/cache1.hpp>
-#include <range/v3/view/cartesian_product.hpp>
-#include <range/v3/view/chunk.hpp>
-#include <range/v3/view/common.hpp>
-#include <range/v3/view/concat.hpp>
-#include <range/v3/view/const.hpp>
-#include <range/v3/view/counted.hpp>
-#include <range/v3/view/cycle.hpp>
-#include <range/v3/view/delimit.hpp>
-#include <range/v3/view/drop.hpp>
-#include <range/v3/view/drop_exactly.hpp>
-#include <range/v3/view/drop_last.hpp>
-#include <range/v3/view/drop_while.hpp>
-#include <range/v3/view/empty.hpp>
-#include <range/v3/view/enumerate.hpp>
-#include <range/v3/view/exclusive_scan.hpp>
-#include <range/v3/view/facade.hpp>
-#include <range/v3/view/filter.hpp>
-#include <range/v3/view/for_each.hpp>
-#include <range/v3/view/generate.hpp>
-#include <range/v3/view/generate_n.hpp>
-#include <range/v3/view/getlines.hpp>
-#include <range/v3/view/group_by.hpp>
-#include <range/v3/view/indices.hpp>
-#include <range/v3/view/indirect.hpp>
-#include <range/v3/view/intersperse.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/istream.hpp>
-#include <range/v3/view/join.hpp>
-#include <range/v3/view/linear_distribute.hpp>
-#include <range/v3/view/map.hpp>
-#include <range/v3/view/move.hpp>
-#include <range/v3/view/partial_sum.hpp>
-#include <range/v3/view/ref.hpp>
-#include <range/v3/view/remove.hpp>
-#include <range/v3/view/remove_if.hpp>
-#include <range/v3/view/repeat.hpp>
-#include <range/v3/view/repeat_n.hpp>
-#include <range/v3/view/replace.hpp>
-#include <range/v3/view/replace_if.hpp>
-#include <range/v3/view/reverse.hpp>
-#include <range/v3/view/sample.hpp>
-#include <range/v3/view/set_algorithm.hpp>
-#include <range/v3/view/single.hpp>
-#include <range/v3/view/slice.hpp>
-#include <range/v3/view/sliding.hpp>
-#include <range/v3/view/span.hpp>
-#include <range/v3/view/split.hpp>
-#include <range/v3/view/split_when.hpp>
-#include <range/v3/view/stride.hpp>
-#include <range/v3/view/subrange.hpp>
-#include <range/v3/view/tail.hpp>
-#include <range/v3/view/take.hpp>
-#include <range/v3/view/take_exactly.hpp>
-#include <range/v3/view/take_last.hpp>
-#include <range/v3/view/take_while.hpp>
-#include <range/v3/view/tokenize.hpp>
-#include <range/v3/view/transform.hpp>
-#include <range/v3/view/trim.hpp>
-#include <range/v3/view/unbounded.hpp>
-#include <range/v3/view/unique.hpp>
-#include <range/v3/view/view.hpp>
-#include <range/v3/view/zip.hpp>
-#include <range/v3/view/zip_with.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/adaptor.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/adaptor.hpp
deleted file mode 100644
index 0297d7f3..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/adaptor.hpp
+++ /dev/null
@@ -1,587 +0,0 @@
-/// \file
-// Range v3 library
-//
-// Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_VIEW_ADAPTOR_HPP
-#define RANGES_V3_VIEW_ADAPTOR_HPP
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/compressed_pair.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/facade.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        template<typename Derived>
-        using begin_adaptor_t = detail::decay_t<decltype(
-            range_access::begin_adaptor(std::declval<Derived &>()))>;
-
-        template<typename Derived>
-        using end_adaptor_t = detail::decay_t<decltype(
-            range_access::end_adaptor(std::declval<Derived &>()))>;
-
-        template<typename Derived>
-        using adapted_iterator_t = detail::decay_t<decltype(
-            std::declval<begin_adaptor_t<Derived>>().begin(std::declval<Derived &>()))>;
-
-        template<typename Derived>
-        using adapted_sentinel_t = detail::decay_t<decltype(
-            std::declval<end_adaptor_t<Derived>>().end(std::declval<Derived &>()))>;
-
-        struct adaptor_base_current_mem_fn
-        {};
-
-        template<typename BaseIter, typename Adapt>
-        constexpr int which_adaptor_value_(priority_tag<0>)
-        {
-            return 0;
-        }
-        template<typename BaseIter, typename Adapt>
-        constexpr always_<int, decltype(Adapt::read(std::declval<BaseIter const &>(),
-                                                    adaptor_base_current_mem_fn{}))> //
-        which_adaptor_value_(priority_tag<1>)
-        {
-            return 1;
-        }
-        template<typename BaseIter, typename Adapt>
-        constexpr always_<int, typename Adapt::value_type> //
-        which_adaptor_value_(priority_tag<2>)
-        {
-            return 2;
-        }
-
-        template<typename BaseIter, typename Adapt,
-                 int = detail::which_adaptor_value_<BaseIter, Adapt>(priority_tag<2>{})>
-        struct adaptor_value_type_
-        {
-            compressed_pair<BaseIter, Adapt> data_;
-        };
-        template<typename BaseIter, typename Adapt>
-        struct adaptor_value_type_<BaseIter, Adapt, 1>
-        {
-            using value_type = iter_value_t<BaseIter>;
-            compressed_pair<BaseIter, Adapt> data_;
-        };
-        template<typename BaseIter, typename Adapt>
-        struct adaptor_value_type_<BaseIter, Adapt, 2>
-        {
-#ifdef RANGES_WORKAROUND_MSVC_688606
-            using value_type = typename indirectly_readable_traits<Adapt>::value_type;
-#else  // ^^^ workaround ^^^ / vvv no workaround vvv
-            using value_type = typename Adapt::value_type;
-#endif // RANGES_WORKAROUND_MSVC_688606
-            compressed_pair<BaseIter, Adapt> data_;
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// \addtogroup group-views
-    /// @{
-    template<typename BaseIt, typename Adapt>
-    struct adaptor_cursor;
-
-    template<typename BaseSent, typename Adapt>
-    struct base_adaptor_sentinel;
-
-    struct adaptor_base
-    {
-        adaptor_base() = default;
-        adaptor_base(adaptor_base &&) = default;
-        adaptor_base(adaptor_base const &) = default;
-        adaptor_base & operator=(adaptor_base &&) = default;
-        adaptor_base & operator=(adaptor_base const &) = default;
-
-        adaptor_base(detail::ignore_t, detail::ignore_t = {}, detail::ignore_t = {})
-        {}
-        // clang-format off
-        template<typename Rng>
-        static constexpr auto CPP_auto_fun(begin)(Rng &rng)
-        (
-            return ranges::begin(rng.base())
-        )
-        template<typename Rng>
-        static constexpr auto CPP_auto_fun(end)(Rng &rng)
-        (
-            return ranges::end(rng.base())
-        )
-            // clang-format on
-            template(typename I)(
-                /// \pre
-                requires equality_comparable<I>)
-            static bool equal(I const & it0, I const & it1)
-        {
-            return it0 == it1;
-        }
-        template(typename I)(
-            /// \pre
-            requires input_or_output_iterator<I>)
-        static iter_reference_t<I> read(I const & it,
-                                        detail::adaptor_base_current_mem_fn = {})
-            noexcept(noexcept(iter_reference_t<I>(*it)))
-        {
-            return *it;
-        }
-        template(typename I)(
-            /// \pre
-            requires input_or_output_iterator<I>)
-        static void next(I & it)
-        {
-            ++it;
-        }
-        template(typename I)(
-            /// \pre
-            requires bidirectional_iterator<I>)
-        static void prev(I & it)
-        {
-            --it;
-        }
-        template(typename I)(
-            /// \pre
-            requires random_access_iterator<I>)
-        static void advance(I & it, iter_difference_t<I> n)
-        {
-            it += n;
-        }
-        template(typename I)(
-            /// \pre
-            requires sized_sentinel_for<I, I>)
-        static iter_difference_t<I> distance_to(I const & it0, I const & it1)
-        {
-            return it1 - it0;
-        }
-        template(typename I, typename S)(
-            /// \pre
-            requires sentinel_for<S, I>)
-        static constexpr bool empty(I const & it, S const & last)
-        {
-            return it == last;
-        }
-    };
-
-    // Build a sentinel out of a sentinel into the adapted range, and an
-    // adaptor that customizes behavior.
-    template<typename BaseSent, typename Adapt>
-    struct base_adaptor_sentinel
-    {
-    private:
-        template<typename, typename>
-        friend struct adaptor_cursor;
-        RANGES_NO_UNIQUE_ADDRESS compressed_pair<BaseSent, Adapt> data_;
-
-    public:
-        base_adaptor_sentinel() = default;
-        base_adaptor_sentinel(BaseSent sent, Adapt adapt)
-          : data_{std::move(sent), std::move(adapt)}
-        {}
-
-        // All sentinels into adapted ranges have a base() member for fetching
-        // the underlying sentinel.
-        BaseSent base() const
-        {
-            return data_.first();
-        }
-
-    protected:
-        // Adaptor accessor
-        Adapt & get()
-        {
-            return data_.second();
-        }
-        Adapt const & get() const
-        {
-            return data_.second();
-        }
-    };
-
-    /// \cond
-    namespace detail
-    {
-        template<typename BaseSent, typename Adapt>
-        meta::id<base_adaptor_sentinel<BaseSent, Adapt>> base_adaptor_sentinel_2_(long);
-
-        template<typename BaseSent, typename Adapt>
-        meta::id<typename Adapt::template mixin<base_adaptor_sentinel<BaseSent, Adapt>>>
-        base_adaptor_sentinel_2_(int);
-
-        template<typename BaseSent, typename Adapt>
-        struct base_adaptor_sentinel_
-          : decltype(base_adaptor_sentinel_2_<BaseSent, Adapt>(42))
-        {};
-
-        template<typename BaseSent, typename Adapt>
-        using adaptor_sentinel_ = meta::_t<base_adaptor_sentinel_<BaseSent, Adapt>>;
-    } // namespace detail
-    /// \endcond
-
-    template<typename BaseSent, typename Adapt>
-    struct adaptor_sentinel : detail::adaptor_sentinel_<BaseSent, Adapt>
-    {
-        using detail::adaptor_sentinel_<BaseSent, Adapt>::adaptor_sentinel_;
-    };
-
-    // Build a cursor out of an iterator into the adapted range, and an
-    // adaptor that customizes behavior.
-    template<typename BaseIter, typename Adapt>
-    struct adaptor_cursor : private detail::adaptor_value_type_<BaseIter, Adapt>
-    {
-    private:
-        friend range_access;
-        template<typename, typename>
-        friend struct adaptor_cursor;
-        using base_t = detail::adaptor_value_type_<BaseIter, Adapt>;
-        using single_pass = meta::bool_<(bool)range_access::single_pass_t<Adapt>() ||
-                                        (bool)single_pass_iterator_<BaseIter>>;
-
-        struct basic_adaptor_mixin : basic_mixin<adaptor_cursor>
-        {
-            basic_adaptor_mixin() = default;
-            #ifndef _MSC_VER
-            using basic_mixin<adaptor_cursor>::basic_mixin;
-            #else
-            constexpr explicit basic_adaptor_mixin(adaptor_cursor && cur)
-              : basic_mixin<adaptor_cursor>(static_cast<adaptor_cursor &&>(cur))
-            {}
-            constexpr explicit basic_adaptor_mixin(adaptor_cursor const & cur)
-              : basic_mixin<adaptor_cursor>(cur)
-            {}
-            #endif
-            // All iterators into adapted ranges have a base() member for fetching
-            // the underlying iterator.
-            BaseIter base() const
-            {
-                return basic_adaptor_mixin::basic_mixin::get().data_.first();
-            }
-
-        protected:
-            // Adaptor accessor
-            Adapt & get()
-            {
-                return basic_adaptor_mixin::basic_mixin::get().data_.second();
-            }
-            const Adapt & get() const
-            {
-                return basic_adaptor_mixin::basic_mixin::get().data_.second();
-            }
-        };
-
-        template<typename Adapt_>
-        static meta::id<basic_adaptor_mixin> basic_adaptor_mixin_2_(long);
-
-        template<typename Adapt_>
-        static meta::id<typename Adapt_::template mixin<basic_adaptor_mixin>>
-        basic_adaptor_mixin_2_(int);
-
-        using mixin = meta::_t<decltype(basic_adaptor_mixin_2_<Adapt>(42))>;
-
-        template<typename A = Adapt, typename R = decltype(std::declval<A const &>().read(
-                                         std::declval<BaseIter const &>()))>
-        R read() const noexcept(
-            noexcept(std::declval<A const &>().read(std::declval<BaseIter const &>())))
-        {
-            using V = range_access::cursor_value_t<adaptor_cursor>;
-            static_assert(common_reference_with<R &&, V &>,
-                          "In your adaptor, you've specified a value type that does not "
-                          "share a common reference type with the return type of read.");
-            return this->data_.second().read(this->data_.first());
-        }
-        template<typename A = Adapt, typename = decltype(std::declval<A &>().next(
-                                         std::declval<BaseIter &>()))>
-        void next()
-        {
-            this->data_.second().next(this->data_.first());
-        }
-        template<typename A = Adapt,
-                 typename = decltype(std::declval<A const &>().equal(
-                     std::declval<BaseIter const &>(), std::declval<BaseIter const &>(),
-                     std::declval<A const &>()))>
-        bool equal_(adaptor_cursor const & that, int) const
-        {
-            return this->data_.second().equal(
-                this->data_.first(), that.data_.first(), that.data_.second());
-        }
-        template<typename A = Adapt,
-                 typename = decltype(std::declval<A const &>().equal(
-                     std::declval<BaseIter const &>(), std::declval<BaseIter const &>()))>
-        bool equal_(adaptor_cursor const & that, long) const
-        {
-            return this->data_.second().equal(this->data_.first(), that.data_.first());
-        }
-        template<typename C = adaptor_cursor>
-        auto equal(adaptor_cursor const & that) const
-            -> decltype(std::declval<C const &>().equal_(that, 42))
-        {
-            return this->equal_(that, 42);
-        }
-        template<typename S, typename A,
-                 typename = decltype(std::declval<A const &>().empty(
-                     std::declval<BaseIter const &>(), std::declval<Adapt const &>(),
-                     std::declval<S const &>()))>
-        constexpr bool equal_(adaptor_sentinel<S, A> const & that, int) const
-        {
-            return that.data_.second().empty(
-                this->data_.first(), this->data_.second(), that.data_.first());
-        }
-        template<typename S, typename A,
-                 typename = decltype(std::declval<A const &>().empty(
-                     std::declval<BaseIter const &>(), std::declval<S const &>()))>
-        constexpr bool equal_(adaptor_sentinel<S, A> const & that, long) const
-        {
-            return that.data_.second().empty(this->data_.first(), that.data_.first());
-        }
-        template<typename S, typename A>
-        constexpr auto equal(adaptor_sentinel<S, A> const & that) const
-            -> decltype(std::declval<adaptor_cursor const &>().equal_(that, 42))
-        {
-            return this->equal_(that, 42);
-        }
-        template<typename A = Adapt, typename = decltype(std::declval<A &>().prev(
-                                         std::declval<BaseIter &>()))>
-        void prev()
-        {
-            this->data_.second().prev(this->data_.first());
-        }
-        template<typename A = Adapt, typename = decltype(std::declval<A &>().advance(
-                                         std::declval<BaseIter &>(), 0))>
-        void advance(iter_difference_t<BaseIter> n)
-        {
-            this->data_.second().advance(this->data_.first(), n);
-        }
-        template<typename A = Adapt,
-                 typename R = decltype(std::declval<A const &>().distance_to(
-                     std::declval<BaseIter const &>(), std::declval<BaseIter const &>(),
-                     std::declval<A const &>()))>
-        R distance_to_(adaptor_cursor const & that, int) const
-        {
-            return this->data_.second().distance_to(
-                this->data_.first(), that.data_.first(), that.data_.second());
-        }
-        template<typename A = Adapt,
-                 typename R = decltype(std::declval<A const &>().distance_to(
-                     std::declval<BaseIter const &>(), std::declval<BaseIter const &>()))>
-        R distance_to_(adaptor_cursor const & that, long) const
-        {
-            return this->data_.second().distance_to(this->data_.first(),
-                                                    that.data_.first());
-        }
-        template<typename C = adaptor_cursor>
-        auto distance_to(adaptor_cursor const & that) const
-            -> decltype(std::declval<C const &>().distance_to_(that, 42))
-        {
-            return this->distance_to_(that, 42);
-        }
-        // If the adaptor has an iter_move function, use it.
-        template<typename A = Adapt,
-                 typename X = decltype(std::declval<A const &>().iter_move(
-                     std::declval<BaseIter const &>()))>
-        X iter_move_(int) const noexcept(noexcept(
-            std::declval<A const &>().iter_move(std::declval<BaseIter const &>())))
-        {
-            using V = range_access::cursor_value_t<adaptor_cursor>;
-            using R = decltype(this->data_.second().read(this->data_.first()));
-            static_assert(
-                common_reference_with<X &&, V const &>,
-                "In your adaptor, the result of your iter_move member function does "
-                "not share a common reference with your value type.");
-            static_assert(
-                common_reference_with<R &&, X &&>,
-                "In your adaptor, the result of your iter_move member function does "
-                "not share a common reference with the result of your read member "
-                "function.");
-            return this->data_.second().iter_move(this->data_.first());
-        }
-        // If there is no iter_move member and the adaptor has not overridden the read
-        // member function, then dispatch to the base iterator's iter_move function.
-        template<typename A = Adapt,
-                 typename R = decltype(std::declval<A const &>().read(
-                     std::declval<BaseIter const &>(),
-                     detail::adaptor_base_current_mem_fn{})),
-                 typename X = iter_rvalue_reference_t<BaseIter>>
-        X iter_move_(long) const
-            noexcept(noexcept(X(ranges::iter_move(std::declval<BaseIter const &>()))))
-        {
-            return ranges::iter_move(this->data_.first());
-        }
-        // If the adaptor does not have an iter_move function but overrides the read
-        // member function, apply std::move to the result of calling read.
-        template<typename A = Adapt,
-                 typename R = decltype(
-                     std::declval<A const &>().read(std::declval<BaseIter const &>())),
-                 typename X = aux::move_t<R>>
-        X iter_move_(detail::ignore_t) const noexcept(noexcept(X(static_cast<X &&>(
-            std::declval<A const &>().read(std::declval<BaseIter const &>())))))
-        {
-            using V = range_access::cursor_value_t<adaptor_cursor>;
-            static_assert(
-                common_reference_with<X &&, V const &>,
-                "In your adaptor, you've specified a value type that does not share a "
-                "common "
-                "reference type with the result of moving the result of the read member "
-                "function. Consider defining an iter_move function in your adaptor.");
-            return static_cast<X &&>(this->data_.second().read(this->data_.first()));
-        }
-        // Gives users a way to override the default iter_move function in their adaptors.
-        auto move() const
-            noexcept(noexcept(std::declval<const adaptor_cursor &>().iter_move_(42)))
-                -> decltype(std::declval<const adaptor_cursor &>().iter_move_(42))
-        {
-            return iter_move_(42);
-        }
-
-    public:
-        adaptor_cursor() = default;
-        adaptor_cursor(BaseIter iter, Adapt adapt)
-          : base_t{{std::move(iter), std::move(adapt)}}
-        {}
-        template(typename OtherIter, typename OtherAdapt)(
-            /// \pre
-            requires //
-                (!same_as<adaptor_cursor<OtherIter, OtherAdapt>, adaptor_cursor>) AND
-                convertible_to<OtherIter, BaseIter> AND
-                convertible_to<OtherAdapt, Adapt>)
-        adaptor_cursor(adaptor_cursor<OtherIter, OtherAdapt> that)
-          : base_t{{std::move(that.data_.first()), std::move(that.data_.second())}}
-        {}
-    };
-
-    template<typename D>
-    using adaptor_cursor_t =
-        adaptor_cursor<detail::adapted_iterator_t<D>, detail::begin_adaptor_t<D>>;
-
-    template<typename D>
-    using adaptor_sentinel_t = meta::if_c<
-        same_as<detail::adapted_iterator_t<D>, detail::adapted_sentinel_t<D>> &&
-            same_as<detail::begin_adaptor_t<D>, detail::end_adaptor_t<D>>,
-        adaptor_cursor_t<D>,
-        adaptor_sentinel<detail::adapted_sentinel_t<D>, detail::end_adaptor_t<D>>>;
-
-    template<typename Derived, typename BaseRng,
-             cardinality Cardinality /*= range_cardinality<BaseRng>::value*/>
-    struct view_adaptor : view_facade<Derived, Cardinality>
-    {
-    private:
-        friend Derived;
-        friend range_access;
-        friend adaptor_base;
-        CPP_assert(viewable_range<BaseRng>);
-        using base_range_t = views::all_t<BaseRng>;
-        using view_facade<Derived, Cardinality>::derived;
-
-        base_range_t rng_;
-
-        constexpr adaptor_base begin_adaptor() const noexcept
-        {
-            return {};
-        }
-        constexpr adaptor_base end_adaptor() const noexcept
-        {
-            return {};
-        }
-
-        template<typename D>
-        static constexpr adaptor_cursor_t<D> begin_cursor_(D & d) noexcept(noexcept(
-            adaptor_cursor_t<D>{std::declval<detail::begin_adaptor_t<D> &>().begin(d),
-                                range_access::begin_adaptor(d)}))
-        {
-            auto adapt = range_access::begin_adaptor(d);
-            auto pos = adapt.begin(d);
-            return {std::move(pos), std::move(adapt)};
-        }
-        template(typename D = Derived)(
-            /// \pre
-            requires same_as<D, Derived>)
-        constexpr auto begin_cursor() noexcept(
-            noexcept(view_adaptor::begin_cursor_(std::declval<D &>())))
-            -> decltype(view_adaptor::begin_cursor_(std::declval<D &>()))
-        {
-            return view_adaptor::begin_cursor_(derived());
-        }
-        template(typename D = Derived)(
-            /// \pre
-            requires same_as<D, Derived> AND range<base_range_t const>)
-        constexpr auto begin_cursor() const
-            noexcept(noexcept(view_adaptor::begin_cursor_(std::declval<D const &>())))
-                -> decltype(view_adaptor::begin_cursor_(std::declval<D const &>()))
-        {
-            return view_adaptor::begin_cursor_(derived());
-        }
-
-        template<typename D>
-        static constexpr adaptor_sentinel_t<D> end_cursor_(D & d) noexcept(noexcept(
-            adaptor_sentinel_t<D>{std::declval<detail::end_adaptor_t<D> &>().end(d),
-                                  range_access::end_adaptor(d)}))
-        {
-            auto adapt = range_access::end_adaptor(d);
-            auto pos = adapt.end(d);
-            return {std::move(pos), std::move(adapt)};
-        }
-        template(typename D = Derived)(
-            /// \pre
-            requires same_as<D, Derived>)
-        constexpr auto end_cursor() noexcept(
-            noexcept(view_adaptor::end_cursor_(std::declval<D &>())))
-            -> decltype(view_adaptor::end_cursor_(std::declval<D &>()))
-        {
-            return view_adaptor::end_cursor_(derived());
-        }
-        template(typename D = Derived)(
-            /// \pre
-            requires same_as<D, Derived> AND range<base_range_t const>)
-        constexpr auto end_cursor() const noexcept(
-            noexcept(view_adaptor::end_cursor_(std::declval<D const &>())))
-            -> decltype(view_adaptor::end_cursor_(std::declval<D const &>()))
-        {
-            return view_adaptor::end_cursor_(derived());
-        }
-
-    protected:
-        ~view_adaptor() = default;
-
-    public:
-        view_adaptor() = default;
-        view_adaptor(view_adaptor &&) = default;
-        view_adaptor(view_adaptor const &) = default;
-        view_adaptor & operator=(view_adaptor &&) = default;
-        view_adaptor & operator=(view_adaptor const &) = default;
-        constexpr explicit view_adaptor(BaseRng && rng)
-          : rng_(views::all(static_cast<BaseRng &&>(rng)))
-        {}
-        constexpr base_range_t & base() noexcept
-        {
-            return rng_;
-        }
-        /// \overload
-        constexpr base_range_t const & base() const noexcept
-        {
-            return rng_;
-        }
-    };
-
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/addressof.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/addressof.hpp
deleted file mode 100644
index 2e626e9e..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/addressof.hpp
+++ /dev/null
@@ -1,66 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Andrey Diduh 2019
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_ADDRESSOF_HPP
-#define RANGES_V3_VIEW_ADDRESSOF_HPP
-
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/utility/addressof.hpp>
-#include <range/v3/view/transform.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    namespace views
-    {
-        struct addressof_fn
-        {
-        private:
-            struct take_address
-            {
-                template<typename V>
-                constexpr V * operator()(V & value) const noexcept
-                {
-                    return detail::addressof(value);
-                }
-            };
-
-        public:
-            template(typename Rng)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng> AND
-                    std::is_lvalue_reference<range_reference_t<Rng>>::value) //
-            constexpr auto CPP_auto_fun(operator())(Rng && rng)(const) //
-            (
-                return transform(all(static_cast<Rng &&>(rng)), take_address{}) //
-            )
-        };
-
-        /// \relates addressof_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(view_closure<addressof_fn>, addressof)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif // RANGES_V3_VIEW_ADDRESSOF_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/adjacent_filter.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/adjacent_filter.hpp
deleted file mode 100644
index b1462fa2..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/adjacent_filter.hpp
+++ /dev/null
@@ -1,191 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_ADJACENT_FILTER_HPP
-#define RANGES_V3_VIEW_ADJACENT_FILTER_HPP
-
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/adjacent_find.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/utility/semiregular_box.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/adaptor.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        // clang-format off
-        template(typename Rng, typename Pred)(
-        concept (adjacent_filter_constraints_)(Rng, Pred),
-            indirect_binary_predicate_<Pred, iterator_t<Rng>, iterator_t<Rng>>
-        );
-        template<typename Rng, typename Pred>
-        CPP_concept adjacent_filter_constraints =
-            viewable_range<Rng> && forward_range<Rng> &&
-            CPP_concept_ref(detail::adjacent_filter_constraints_, Rng, Pred);
-        // clang-format on
-    } // namespace detail
-    /// \endcond
-
-    /// \addtogroup group-views
-    /// @{
-    template<typename Rng, typename Pred>
-    struct RANGES_EMPTY_BASES adjacent_filter_view
-      : view_adaptor<adjacent_filter_view<Rng, Pred>, Rng,
-                     is_finite<Rng>::value ? finite : range_cardinality<Rng>::value>
-      , private box<semiregular_box_t<Pred>, adjacent_filter_view<Rng, Pred>>
-    {
-    private:
-        friend range_access;
-
-        template<bool Const>
-        struct adaptor : adaptor_base
-        {
-        private:
-            friend struct adaptor<!Const>;
-            using CRng = meta::const_if_c<Const, Rng>;
-            using Parent = meta::const_if_c<Const, adjacent_filter_view>;
-            Parent * rng_;
-
-        public:
-            adaptor() = default;
-            constexpr adaptor(Parent * rng) noexcept
-              : rng_(rng)
-            {}
-            template(bool Other)(
-                /// \pre
-                requires Const && CPP_NOT(Other)) //
-                constexpr adaptor(adaptor<Other> that)
-              : rng_(that.rng_)
-            {}
-            constexpr void next(iterator_t<CRng> & it) const
-            {
-                auto const last = ranges::end(rng_->base());
-                auto & pred = rng_->adjacent_filter_view::box::get();
-                RANGES_EXPECT(it != last);
-                for(auto tmp = it; ++it != last; tmp = it)
-                    if(invoke(pred, *tmp, *it))
-                        break;
-            }
-            CPP_member
-            constexpr auto prev(iterator_t<CRng> & it) const //
-                -> CPP_ret(void)(
-                    /// \pre
-                    requires bidirectional_range<CRng>)
-            {
-                auto const first = ranges::begin(rng_->base());
-                auto & pred = rng_->adjacent_filter_view::box::get();
-                RANGES_EXPECT(it != first);
-                --it;
-                while(it != first)
-                {
-                    auto tmp = it;
-                    if(invoke(pred, *--tmp, *it))
-                        break;
-                    it = tmp;
-                }
-            }
-            void distance_to() = delete;
-        };
-        constexpr adaptor<false> begin_adaptor() noexcept
-        {
-            return {this};
-        }
-        CPP_member
-        constexpr auto begin_adaptor() const noexcept //
-            -> CPP_ret(adaptor<true>)(
-                /// \pre
-                requires detail::adjacent_filter_constraints<Rng const, Pred const>)
-        {
-            return {this};
-        }
-        constexpr adaptor<false> end_adaptor() noexcept
-        {
-            return {this};
-        }
-        CPP_member
-        constexpr auto end_adaptor() const noexcept //
-            -> CPP_ret(adaptor<true>)(
-                /// \pre
-                requires detail::adjacent_filter_constraints<Rng const, Pred const>)
-        {
-            return {this};
-        }
-
-    public:
-        adjacent_filter_view() = default;
-        constexpr adjacent_filter_view(Rng rng, Pred pred)
-          : adjacent_filter_view::view_adaptor{detail::move(rng)}
-          , adjacent_filter_view::box(detail::move(pred))
-        {}
-    };
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template(typename Rng, typename Fun)(
-        /// \pre
-        requires copy_constructible<Rng>)
-        adjacent_filter_view(Rng &&, Fun)
-            ->adjacent_filter_view<views::all_t<Rng>, Fun>;
-#endif
-
-    namespace views
-    {
-        struct adjacent_filter_base_fn
-        {
-            template(typename Rng, typename Pred)(
-                /// \pre
-                requires detail::adjacent_filter_constraints<Rng, Pred>)
-            constexpr adjacent_filter_view<all_t<Rng>, Pred> //
-            operator()(Rng && rng, Pred pred) const
-            {
-                return {all(static_cast<Rng &&>(rng)), std::move(pred)};
-            }
-        };
-
-        struct adjacent_filter_fn : adjacent_filter_base_fn
-        {
-            using adjacent_filter_base_fn::operator();
-
-            template<typename Pred>
-            constexpr auto operator()(Pred pred) const
-            {
-                return make_view_closure(
-                    bind_back(adjacent_filter_base_fn{}, std::move(pred)));
-            }
-        };
-
-        /// \relates adjacent_filter_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(adjacent_filter_fn, adjacent_filter)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::adjacent_filter_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/adjacent_remove_if.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/adjacent_remove_if.hpp
deleted file mode 100644
index 014efcdf..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/adjacent_remove_if.hpp
+++ /dev/null
@@ -1,191 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_ADJACENT_REMOVE_IF_HPP
-#define RANGES_V3_VIEW_ADJACENT_REMOVE_IF_HPP
-
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/utility/box.hpp>
-#include <range/v3/utility/optional.hpp>
-#include <range/v3/utility/semiregular_box.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/adaptor.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    template<typename Rng, typename Pred>
-    struct RANGES_EMPTY_BASES adjacent_remove_if_view
-      : view_adaptor<adjacent_remove_if_view<Rng, Pred>, Rng,
-                     is_finite<Rng>::value ? finite : range_cardinality<Rng>::value>
-      , private box<semiregular_box_t<Pred>, adjacent_remove_if_view<Rng, Pred>>
-    {
-        adjacent_remove_if_view() = default;
-        constexpr adjacent_remove_if_view(Rng rng, Pred pred)
-          : adjacent_remove_if_view::view_adaptor{detail::move(rng)}
-          , adjacent_remove_if_view::box(detail::move(pred))
-        {}
-
-    private:
-        friend range_access;
-
-        struct adaptor : adaptor_base
-        {
-        private:
-            adjacent_remove_if_view * rng_;
-
-        public:
-            adaptor() = default;
-            constexpr adaptor(adjacent_remove_if_view * rng) noexcept
-              : rng_(rng)
-            {}
-            static constexpr iterator_t<Rng> begin(adjacent_remove_if_view & rng)
-            {
-                return *rng.begin_;
-            }
-            constexpr void next(iterator_t<Rng> & it) const
-            {
-                RANGES_ASSERT(it != ranges::end(rng_->base()));
-                rng_->satisfy_forward(++it);
-            }
-            CPP_member
-            constexpr auto prev(iterator_t<Rng> & it) const //
-                -> CPP_ret(void)(
-                    /// \pre
-                    requires bidirectional_range<Rng>)
-            {
-                rng_->satisfy_reverse(it);
-            }
-            void advance() = delete;
-            void distance_to() = delete;
-        };
-        constexpr adaptor begin_adaptor()
-        {
-            cache_begin();
-            return {this};
-        }
-        CPP_member
-        constexpr auto end_adaptor() //
-            -> CPP_ret(adaptor)(
-                /// \pre
-                requires common_range<Rng>)
-        {
-            if(bidirectional_range<Rng>)
-                cache_begin();
-            return {this};
-        }
-        CPP_member
-        constexpr auto end_adaptor() noexcept //
-            -> CPP_ret(adaptor_base)(
-                /// \pre
-                requires (!common_range<Rng>))
-        {
-            return {};
-        }
-
-        constexpr void satisfy_forward(iterator_t<Rng> & it)
-        {
-            auto const last = ranges::end(this->base());
-            if(it == last)
-                return;
-            auto & pred = this->adjacent_remove_if_view::box::get();
-            for(auto nxt = it; ++nxt != last && invoke(pred, *it, *nxt); it = nxt)
-                ;
-        }
-        constexpr void satisfy_reverse(iterator_t<Rng> & it)
-        {
-            auto const & first = *begin_;
-            RANGES_ASSERT(it != first);
-            (void)first;
-            auto prv = it;
-            --it;
-            if(prv == ranges::end(this->base()))
-            {
-                return;
-            }
-            auto & pred = this->adjacent_remove_if_view::box::get();
-            for(; invoke(pred, *it, *prv); prv = it, --it)
-                RANGES_ASSERT(it != first);
-        }
-
-        void cache_begin()
-        {
-            if(begin_)
-                return;
-            auto it = ranges::begin(this->base());
-            satisfy_forward(it);
-            begin_.emplace(std::move(it));
-        }
-
-        detail::non_propagating_cache<iterator_t<Rng>> begin_;
-    };
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template(typename Rng, typename Fun)(
-        /// \pre
-        requires copy_constructible<Rng>)
-    adjacent_remove_if_view(Rng &&, Fun)
-        -> adjacent_remove_if_view<views::all_t<Rng>, Fun>;
-#endif
-
-    namespace views
-    {
-        struct adjacent_remove_if_base_fn
-        {
-            template(typename Rng, typename Pred)(
-                /// \pre
-                requires viewable_range<Rng> AND forward_range<Rng> AND
-                    indirect_binary_predicate_<Pred, iterator_t<Rng>, iterator_t<Rng>>)
-            constexpr adjacent_remove_if_view<all_t<Rng>, Pred> //
-            operator()(Rng && rng, Pred pred) const
-            {
-                return {all(static_cast<Rng &&>(rng)), std::move(pred)};
-            }
-        };
-
-        struct adjacent_remove_if_fn : adjacent_remove_if_base_fn
-        {
-            using adjacent_remove_if_base_fn::operator();
-
-            template<typename Pred>
-            constexpr auto operator()(Pred pred) const
-            {
-                return make_view_closure(
-                    bind_back(adjacent_remove_if_base_fn{}, std::move(pred)));
-            }
-        };
-
-        /// \relates adjacent_remove_if_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(adjacent_remove_if_fn, adjacent_remove_if)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::adjacent_remove_if_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/all.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/all.hpp
deleted file mode 100644
index 831e8ac5..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/all.hpp
+++ /dev/null
@@ -1,128 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_VIEW_ALL_HPP
-#define RANGES_V3_VIEW_ALL_HPP
-
-#include <type_traits>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/ref.hpp>
-#include <range/v3/view/subrange.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    namespace views
-    {
-        struct all_fn
-        {
-        private:
-            /// If it's a view already, pass it though.
-            template<typename T>
-            static constexpr auto from_range_(T && t, std::true_type, detail::ignore_t,
-                                              detail::ignore_t)
-            {
-                return static_cast<T &&>(t);
-            }
-
-            /// If it is container-like, turn it into a view, being careful
-            /// to preserve the Sized-ness of the range.
-            template<typename T>
-            static constexpr auto from_range_(T && t, std::false_type, std::true_type,
-                                              detail::ignore_t)
-            {
-                return ranges::views::ref(t);
-            }
-
-            /// Not a view and not an lvalue? If it's a borrowed_range, then
-            /// return a subrange holding the range's begin/end.
-            template<typename T>
-            static constexpr auto from_range_(T && t, std::false_type, std::false_type,
-                                              std::true_type)
-            {
-                return make_subrange(static_cast<T &&>(t));
-            }
-
-        public:
-            template(typename T)(
-                /// \pre
-                requires range<T &> AND viewable_range<T>)
-            constexpr auto operator()(T && t) const
-            {
-                return all_fn::from_range_(static_cast<T &&>(t),
-                                           meta::bool_<view_<uncvref_t<T>>>{},
-                                           std::is_lvalue_reference<T>{},
-                                           meta::bool_<borrowed_range<T>>{});
-            }
-
-            template<typename T>
-            RANGES_DEPRECATED("Passing a reference_wrapper to views::all is deprecated.")
-            constexpr ref_view<T> operator()(std::reference_wrapper<T> r) const
-            {
-                return ranges::views::ref(r.get());
-            }
-        };
-
-        /// \relates all_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(view_closure<all_fn>, all)
-
-        template<typename Rng>
-        using all_t = decltype(all(std::declval<Rng>()));
-    } // namespace views
-
-    template<typename Rng>
-    struct identity_adaptor : Rng
-    {
-        CPP_assert(view_<Rng>);
-
-        identity_adaptor() = default;
-        constexpr explicit identity_adaptor(Rng const & rng)
-          : Rng(rng)
-        {}
-        constexpr explicit identity_adaptor(Rng && rng)
-          : Rng(detail::move(rng))
-        {}
-    };
-
-    namespace cpp20
-    {
-        namespace views
-        {
-            using ranges::views::all;
-            using ranges::views::all_t;
-        }
-        template(typename Rng)(
-            /// \pre
-            requires viewable_range<Rng>)
-        using all_view RANGES_DEPRECATED(
-            "Please use ranges::cpp20::views::all_t instead.") =
-                ranges::views::all_t<Rng>;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/any_view.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/any_view.hpp
deleted file mode 100644
index ee1655d2..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/any_view.hpp
+++ /dev/null
@@ -1,696 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Casey Carter 2017
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_ANY_VIEW_HPP
-#define RANGES_V3_VIEW_ANY_VIEW_HPP
-
-#include <type_traits>
-#include <typeinfo>
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/default_sentinel.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/addressof.hpp>
-#include <range/v3/utility/memory.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/facade.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-RANGES_DIAGNOSTIC_PUSH
-RANGES_DIAGNOSTIC_IGNORE_INCONSISTENT_OVERRIDE
-
-namespace ranges
-{
-    /// \brief An enum that denotes the supported subset of range concepts supported by a
-    /// range.
-    enum class category
-    {
-        none = 0,             ///<\brief No concepts met.
-        input = 1,            ///<\brief satisfies ranges::concepts::input_range
-        forward = 3,          ///<\brief satisfies ranges::concepts::forward_range
-        bidirectional = 7,    ///<\brief satisfies ranges::concepts::bidirectional_range
-        random_access = 15,   ///<\brief satisfies ranges::concepts::random_access_range
-        mask = random_access, ///<\brief Mask away any properties other than iterator
-                              ///< category
-        sized = 16,           ///<\brief satisfies ranges::concepts::sized_range
-    };
-
-    /** \name Binary operators for ranges::category
-     *  \relates ranges::category
-     *  \{
-     */
-    constexpr category operator&(category lhs, category rhs) noexcept
-    {
-        return static_cast<category>(
-            static_cast<meta::_t<std::underlying_type<category>>>(lhs) &
-            static_cast<meta::_t<std::underlying_type<category>>>(rhs));
-    }
-
-    constexpr category operator|(category lhs, category rhs) noexcept
-    {
-        return static_cast<category>(
-            static_cast<meta::_t<std::underlying_type<category>>>(lhs) |
-            static_cast<meta::_t<std::underlying_type<category>>>(rhs));
-    }
-
-    constexpr category operator^(category lhs, category rhs) noexcept
-    {
-        return static_cast<category>(
-            static_cast<meta::_t<std::underlying_type<category>>>(lhs) ^
-            static_cast<meta::_t<std::underlying_type<category>>>(rhs));
-    }
-
-    constexpr category operator~(category lhs) noexcept
-    {
-        return static_cast<category>(
-            ~static_cast<meta::_t<std::underlying_type<category>>>(lhs));
-    }
-
-    constexpr category & operator&=(category & lhs, category rhs) noexcept
-    {
-        return (lhs = lhs & rhs);
-    }
-
-    constexpr category & operator|=(category & lhs, category rhs) noexcept
-    {
-        return (lhs = lhs | rhs);
-    }
-
-    constexpr category & operator^=(category & lhs, category rhs) noexcept
-    {
-        return (lhs = lhs ^ rhs);
-    }
-    //!\}
-
-    /// \brief For a given range, return a ranges::category enum with the satisfied
-    /// concepts.
-    template<typename Rng>
-    constexpr category get_categories() noexcept
-    {
-        return (input_range<Rng> ? category::input : category::none) |
-               (forward_range<Rng> ? category::forward : category::none) |
-               (bidirectional_range<Rng> ? category::bidirectional : category::none) |
-               (random_access_range<Rng> ? category::random_access : category::none) |
-               (sized_range<Rng> ? category::sized : category::none);
-    }
-
-    /// \cond
-    namespace detail
-    {
-        // workaround the fact that typeid ignores cv-qualifiers
-        template<typename>
-        struct rtti_tag
-        {};
-
-        struct any_ref
-        {
-            any_ref() = default;
-            template<typename T>
-            constexpr any_ref(T & obj) noexcept
-              : obj_(detail::addressof(obj))
-#ifndef NDEBUG
-              , info_(&typeid(rtti_tag<T>))
-#endif
-            {}
-            template<typename T>
-            T & get() const noexcept
-            {
-                RANGES_ASSERT(obj_ && info_ && *info_ == typeid(rtti_tag<T>));
-                return *const_cast<T *>(static_cast<T const volatile *>(obj_));
-            }
-
-        private:
-            void const volatile * obj_ = nullptr;
-#ifndef NDEBUG
-            std::type_info const * info_ = nullptr;
-#endif
-        };
-
-        template<typename Base>
-        struct cloneable : Base
-        {
-            using Base::Base;
-            virtual ~cloneable() = default;
-            cloneable() = default;
-            cloneable(cloneable const &) = delete;
-            cloneable & operator=(cloneable const &) = delete;
-            virtual std::unique_ptr<cloneable> clone() const = 0;
-        };
-
-        // clang-format off
-        template(typename Rng, typename Ref)(
-        concept (any_compatible_range_)(Rng, Ref),
-            convertible_to<range_reference_t<Rng>, Ref>
-        );
-        template<typename Rng, typename Ref>
-        CPP_concept any_compatible_range =
-            CPP_concept_ref(detail::any_compatible_range_, Rng, Ref);
-        // clang-format on
-
-        template<typename Rng, typename = void>
-        struct any_view_sentinel_impl
-          : private box<sentinel_t<Rng>, any_view_sentinel_impl<Rng>>
-        {
-        private:
-            using box_t = typename any_view_sentinel_impl::box;
-
-        public:
-            any_view_sentinel_impl() = default;
-            any_view_sentinel_impl(Rng & rng)
-              : box_t(ranges::end(rng))
-            {}
-            void init(Rng & rng) noexcept
-            {
-                box_t::get() = ranges::end(rng);
-            }
-            sentinel_t<Rng> const & get(Rng &) const noexcept
-            {
-                return box_t::get();
-            }
-        };
-
-        template<typename Rng>
-        struct any_view_sentinel_impl<
-            Rng, meta::void_<decltype(ranges::end(std::declval<Rng const &>()))>>
-        {
-            any_view_sentinel_impl() = default;
-            any_view_sentinel_impl(Rng &) noexcept
-            {}
-            void init(Rng &) noexcept
-            {}
-            sentinel_t<Rng> get(Rng & rng) const noexcept
-            {
-                return ranges::end(rng);
-            }
-        };
-
-        template<typename Ref, bool Sized = false>
-        struct any_input_view_interface
-        {
-            virtual ~any_input_view_interface() = default;
-            virtual void init() = 0;
-            virtual bool done() = 0;
-            virtual Ref read() const = 0;
-            virtual void next() = 0;
-        };
-        template<typename Ref>
-        struct any_input_view_interface<Ref, true> : any_input_view_interface<Ref, false>
-        {
-            virtual std::size_t size() = 0;
-        };
-
-        template<typename Ref>
-        struct any_input_cursor
-        {
-            using single_pass = std::true_type;
-
-            any_input_cursor() = default;
-            constexpr any_input_cursor(any_input_view_interface<Ref> & view) noexcept
-              : view_{detail::addressof(view)}
-            {}
-            Ref read() const
-            {
-                return view_->read();
-            }
-            void next()
-            {
-                view_->next();
-            }
-            bool equal(any_input_cursor const &) const noexcept
-            {
-                return true;
-            }
-            bool equal(default_sentinel_t) const
-            {
-                return !view_ || view_->done();
-            }
-
-        private:
-            any_input_view_interface<Ref> * view_ = nullptr;
-        };
-
-        template<typename Rng, typename Ref, bool Sized = false>
-        struct RANGES_EMPTY_BASES any_input_view_impl
-          : any_input_view_interface<Ref, Sized>
-          , private any_view_sentinel_impl<Rng>
-        {
-            CPP_assert(any_compatible_range<Rng, Ref>);
-            CPP_assert(!Sized || (bool)sized_range<Rng>);
-
-            explicit any_input_view_impl(Rng rng)
-              : rng_{std::move(rng)}
-            {}
-            any_input_view_impl(any_input_view_impl const &) = delete;
-            any_input_view_impl & operator=(any_input_view_impl const &) = delete;
-
-        private:
-            using sentinel_box_t = any_view_sentinel_impl<Rng>;
-
-            virtual void init() override
-            {
-                sentinel_box_t::init(rng_);
-                current_ = ranges::begin(rng_);
-            }
-            virtual bool done() override
-            {
-                return current_ == sentinel_box_t::get(rng_);
-            }
-            virtual Ref read() const override
-            {
-                return *current_;
-            }
-            virtual void next() override
-            {
-                ++current_;
-            }
-            std::size_t size() // override-ish
-            {
-                return static_cast<std::size_t>(ranges::size(rng_));
-            }
-
-            RANGES_NO_UNIQUE_ADDRESS Rng rng_;
-            RANGES_NO_UNIQUE_ADDRESS iterator_t<Rng> current_{};
-        };
-
-        template<typename Ref, category Cat = category::forward, typename enable = void>
-        struct any_cursor_interface;
-
-        template<typename Ref, category Cat>
-        struct any_cursor_interface<
-            Ref, Cat, meta::if_c<(Cat & category::mask) == category::forward>>
-        {
-            virtual ~any_cursor_interface() = default;
-            virtual any_ref iter()
-                const = 0; // returns a const ref to the cursor's wrapped iterator
-            virtual Ref read() const = 0;
-            virtual bool equal(any_cursor_interface const &) const = 0;
-            virtual void next() = 0;
-        };
-
-        template<typename Ref, category Cat>
-        struct any_cursor_interface<
-            Ref, Cat, meta::if_c<(Cat & category::mask) == category::bidirectional>>
-          : any_cursor_interface<Ref, (Cat & ~category::mask) | category::forward>
-        {
-            virtual void prev() = 0;
-        };
-
-        template<typename Ref, category Cat>
-        struct any_cursor_interface<
-            Ref, Cat, meta::if_c<(Cat & category::mask) == category::random_access>>
-          : any_cursor_interface<Ref, (Cat & ~category::mask) | category::bidirectional>
-        {
-            virtual void advance(std::ptrdiff_t) = 0;
-            virtual std::ptrdiff_t distance_to(any_cursor_interface const &) const = 0;
-        };
-
-        template<typename Ref, category Cat>
-        using any_cloneable_cursor_interface = cloneable<any_cursor_interface<Ref, Cat>>;
-
-        template<typename I, typename Ref, category Cat>
-        struct any_cursor_impl : any_cloneable_cursor_interface<Ref, Cat>
-        {
-            CPP_assert(convertible_to<iter_reference_t<I>, Ref>);
-            CPP_assert((Cat & category::forward) == category::forward);
-
-            any_cursor_impl() = default;
-            any_cursor_impl(I it)
-              : it_{std::move(it)}
-            {}
-
-        private:
-            using Forward =
-                any_cursor_interface<Ref, (Cat & ~category::mask) | category::forward>;
-
-            I it_;
-
-            any_ref iter() const override
-            {
-                return it_;
-            }
-            Ref read() const override
-            {
-                return *it_;
-            }
-            bool equal(Forward const & that_) const override
-            {
-                auto & that = polymorphic_downcast<any_cursor_impl const &>(that_);
-                return that.it_ == it_;
-            }
-            void next() override
-            {
-                ++it_;
-            }
-            std::unique_ptr<any_cloneable_cursor_interface<Ref, Cat>> clone()
-                const override
-            {
-                return detail::make_unique<any_cursor_impl>(it_);
-            }
-            void prev() // override (sometimes; it's complicated)
-            {
-                --it_;
-            }
-            void advance(std::ptrdiff_t n) // override-ish
-            {
-                it_ += n;
-            }
-            std::ptrdiff_t distance_to(
-                any_cursor_interface<Ref, Cat> const & that_) const // override-ish
-            {
-                auto & that = polymorphic_downcast<any_cursor_impl const &>(that_);
-                return static_cast<std::ptrdiff_t>(that.it_ - it_);
-            }
-        };
-
-        struct fully_erased_view
-        {
-            virtual bool at_end(
-                any_ref) = 0; // any_ref is a const ref to a wrapped iterator
-                              // to be compared to the erased view's last sentinel
-        protected:
-            ~fully_erased_view() = default;
-        };
-
-        struct any_sentinel
-        {
-            any_sentinel() = default;
-            constexpr explicit any_sentinel(fully_erased_view & view) noexcept
-              : view_{&view}
-            {}
-
-        private:
-            template<typename, category>
-            friend struct any_cursor;
-
-            fully_erased_view * view_ = nullptr;
-        };
-
-        template<typename Ref, category Cat>
-        struct any_cursor
-        {
-        private:
-            CPP_assert((Cat & category::forward) == category::forward);
-
-            std::unique_ptr<any_cloneable_cursor_interface<Ref, Cat>> ptr_;
-
-            template<typename Rng>
-            using impl_t = any_cursor_impl<iterator_t<Rng>, Ref, Cat>;
-
-        public:
-            any_cursor() = default;
-            template(typename Rng)(
-                /// \pre
-                requires (!same_as<detail::decay_t<Rng>, any_cursor>) AND
-                    forward_range<Rng> AND
-                    any_compatible_range<Rng, Ref>)
-            explicit any_cursor(Rng && rng)
-              : ptr_{detail::make_unique<impl_t<Rng>>(begin(rng))}
-            {}
-            any_cursor(any_cursor &&) = default;
-            any_cursor(any_cursor const & that)
-              : ptr_{that.ptr_ ? that.ptr_->clone() : nullptr}
-            {}
-            any_cursor & operator=(any_cursor &&) = default;
-            any_cursor & operator=(any_cursor const & that)
-            {
-                ptr_ = (that.ptr_ ? that.ptr_->clone() : nullptr);
-                return *this;
-            }
-            Ref read() const
-            {
-                RANGES_EXPECT(ptr_);
-                return ptr_->read();
-            }
-            bool equal(any_cursor const & that) const
-            {
-                RANGES_EXPECT(!ptr_ == !that.ptr_);
-                return !ptr_ || ptr_->equal(*that.ptr_);
-            }
-            bool equal(any_sentinel const & that) const
-            {
-                RANGES_EXPECT(!ptr_ == !that.view_);
-                return !ptr_ || that.view_->at_end(ptr_->iter());
-            }
-            void next()
-            {
-                RANGES_EXPECT(ptr_);
-                ptr_->next();
-            }
-            CPP_member
-            auto prev() //
-                -> CPP_ret(void)(
-                    /// \pre
-                    requires (category::bidirectional == (Cat & category::bidirectional)))
-            {
-                RANGES_EXPECT(ptr_);
-                ptr_->prev();
-            }
-            CPP_member
-            auto advance(std::ptrdiff_t n) //
-                -> CPP_ret(void)(
-                    /// \pre
-                    requires (category::random_access == (Cat & category::random_access)))
-            {
-                RANGES_EXPECT(ptr_);
-                ptr_->advance(n);
-            }
-            CPP_member
-            auto distance_to(any_cursor const & that) const //
-                -> CPP_ret(std::ptrdiff_t)(
-                    /// \pre
-                    requires (category::random_access == (Cat & category::random_access)))
-            {
-                RANGES_EXPECT(!ptr_ == !that.ptr_);
-                return !ptr_ ? 0 : ptr_->distance_to(*that.ptr_);
-            }
-        };
-
-        template<typename Ref, category Cat,
-                 bool = (Cat & category::sized) == category::sized>
-        struct any_view_interface : fully_erased_view
-        {
-            CPP_assert((Cat & category::forward) == category::forward);
-
-            virtual ~any_view_interface() = default;
-            virtual any_cursor<Ref, Cat> begin_cursor() = 0;
-        };
-        template<typename Ref, category Cat>
-        struct any_view_interface<Ref, Cat, true> : any_view_interface<Ref, Cat, false>
-        {
-            virtual std::size_t size() = 0;
-        };
-
-        template<typename Ref, category Cat>
-        using any_cloneable_view_interface = cloneable<any_view_interface<Ref, Cat>>;
-
-        template<typename Rng, typename Ref, category Cat>
-        struct RANGES_EMPTY_BASES any_view_impl
-          : any_cloneable_view_interface<Ref, Cat>
-          , private box<Rng, any_view_impl<Rng, Ref, Cat>>
-          , private any_view_sentinel_impl<Rng>
-        {
-            CPP_assert((Cat & category::forward) == category::forward);
-            CPP_assert(any_compatible_range<Rng, Ref>);
-            CPP_assert((Cat & category::sized) == category::none ||
-                       (bool)sized_range<Rng>);
-
-            any_view_impl() = default;
-            any_view_impl(Rng rng)
-              : range_box_t{std::move(rng)}
-              , sentinel_box_t{range_box_t::get()}
-            // NB: initialization order dependence
-            {}
-
-        private:
-            using range_box_t = box<Rng, any_view_impl>;
-            using sentinel_box_t = any_view_sentinel_impl<Rng>;
-
-            any_cursor<Ref, Cat> begin_cursor() override
-            {
-                return any_cursor<Ref, Cat>{range_box_t::get()};
-            }
-            bool at_end(any_ref it_) override
-            {
-                auto & it = it_.get<iterator_t<Rng> const>();
-                return it == sentinel_box_t::get(range_box_t::get());
-            }
-            std::unique_ptr<any_cloneable_view_interface<Ref, Cat>> clone() const override
-            {
-                return detail::make_unique<any_view_impl>(range_box_t::get());
-            }
-            std::size_t size() // override-ish
-            {
-                return static_cast<std::size_t>(ranges::size(range_box_t::get()));
-            }
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// \brief A type-erased view
-    /// \ingroup group-views
-    template<typename Ref, category Cat = category::input, typename enable = void>
-    struct any_view
-      : view_facade<any_view<Ref, Cat>,
-                    (Cat & category::sized) == category::sized ? finite : unknown>
-    {
-        friend range_access;
-        CPP_assert((Cat & category::forward) == category::forward);
-
-        any_view() = default;
-        template(typename Rng)(
-            /// \pre
-            requires //
-                (!same_as<detail::decay_t<Rng>, any_view>) AND
-                input_range<Rng> AND
-                detail::any_compatible_range<Rng, Ref>)
-        any_view(Rng && rng)
-          : any_view(static_cast<Rng &&>(rng),
-                     meta::bool_<(get_categories<Rng>() & Cat) == Cat>{})
-        {}
-        any_view(any_view &&) = default;
-        any_view(any_view const & that)
-          : ptr_{that.ptr_ ? that.ptr_->clone() : nullptr}
-        {}
-        any_view & operator=(any_view &&) = default;
-        any_view & operator=(any_view const & that)
-        {
-            ptr_ = (that.ptr_ ? that.ptr_->clone() : nullptr);
-            return *this;
-        }
-
-        CPP_member
-        auto size() //
-            -> CPP_ret(std::size_t)(
-                /// \pre
-                requires (category::sized == (Cat & category::sized)))
-        {
-            return ptr_ ? ptr_->size() : 0;
-        }
-
-    private:
-        template<typename Rng>
-        using impl_t = detail::any_view_impl<views::all_t<Rng>, Ref, Cat>;
-        template<typename Rng>
-        any_view(Rng && rng, std::true_type)
-          : ptr_{detail::make_unique<impl_t<Rng>>(views::all(static_cast<Rng &&>(rng)))}
-        {}
-        template<typename Rng>
-        any_view(Rng &&, std::false_type)
-        {
-            static_assert(
-                (get_categories<Rng>() & Cat) == Cat,
-                "The range passed to any_view() does not model the requested category");
-        }
-
-        detail::any_cursor<Ref, Cat> begin_cursor()
-        {
-            return ptr_ ? ptr_->begin_cursor() : detail::value_init{};
-        }
-        detail::any_sentinel end_cursor() noexcept
-        {
-            return detail::any_sentinel{*ptr_};
-        }
-
-        std::unique_ptr<detail::any_cloneable_view_interface<Ref, Cat>> ptr_;
-    };
-
-    // input and not forward
-    template<typename Ref, category Cat>
-    struct any_view<Ref, Cat, meta::if_c<(Cat & category::forward) == category::input>>
-      : view_facade<any_view<Ref, Cat, void>,
-                    (Cat & category::sized) == category::sized ? finite : unknown>
-    {
-        friend range_access;
-
-        any_view() = default;
-        template(typename Rng)(
-            /// \pre
-            requires //
-                (!same_as<detail::decay_t<Rng>, any_view>) AND
-                input_range<Rng> AND
-                detail::any_compatible_range<Rng, Ref>)
-        any_view(Rng && rng)
-          : ptr_{std::make_shared<impl_t<Rng>>(views::all(static_cast<Rng &&>(rng)))}
-        {}
-
-        CPP_member
-        auto size() //
-            -> CPP_ret(std::size_t)(
-                /// \pre
-                requires (category::sized == (Cat & category::sized)))
-        {
-            return ptr_ ? ptr_->size() : 0;
-        }
-
-    private:
-        template<typename Rng>
-        using impl_t =
-            detail::any_input_view_impl<views::all_t<Rng>, Ref,
-                                        (Cat & category::sized) == category::sized>;
-
-        detail::any_input_cursor<Ref> begin_cursor()
-        {
-            if(!ptr_)
-                return {};
-
-            ptr_->init();
-            return detail::any_input_cursor<Ref>{*ptr_};
-        }
-
-        std::shared_ptr<detail::any_input_view_interface<Ref, (Cat & category::sized) ==
-                                                                  category::sized>>
-            ptr_;
-    };
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template(typename Rng)(
-        /// \pre
-        requires view_<Rng>)
-        any_view(Rng &&)
-            ->any_view<range_reference_t<Rng>, get_categories<Rng>()>;
-#endif
-
-    template<typename Ref>
-    using any_input_view RANGES_DEPRECATED(
-        "Use any_view<Ref, category::input> instead.") = any_view<Ref, category::input>;
-
-    template<typename Ref>
-    using any_forward_view RANGES_DEPRECATED(
-        "Use any_view<Ref, category::forward> instead.") =
-        any_view<Ref, category::forward>;
-
-    template<typename Ref>
-    using any_bidirectional_view RANGES_DEPRECATED(
-        "Use any_view<Ref, category::bidirectional> instead.") =
-        any_view<Ref, category::bidirectional>;
-
-    template<typename Ref>
-    using any_random_access_view RANGES_DEPRECATED(
-        "Use any_view<Ref, category::random_access> instead.") =
-        any_view<Ref, category::random_access>;
-} // namespace ranges
-
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::any_view)
-
-RANGES_DIAGNOSTIC_POP
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/bounded.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/bounded.hpp
deleted file mode 100644
index 75932323..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/bounded.hpp
+++ /dev/null
@@ -1,22 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_VIEW_BOUNDED_HPP
-#define RANGES_V3_VIEW_BOUNDED_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated. Please #include <range/v3/view/common.hpp> instead.")
-
-#include <range/v3/view/common.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/c_str.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/c_str.hpp
deleted file mode 100644
index 07016805..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/c_str.hpp
+++ /dev/null
@@ -1,96 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_VIEW_C_STR_HPP
-#define RANGES_V3_VIEW_C_STR_HPP
-
-#include <type_traits>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/unreachable_sentinel.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/delimit.hpp>
-#include <range/v3/view/subrange.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        template<typename T>
-        struct is_char_type_ : std::false_type
-        {};
-
-        template<>
-        struct is_char_type_<char> : std::true_type
-        {};
-
-        template<>
-        struct is_char_type_<wchar_t> : std::true_type
-        {};
-
-        template<>
-        struct is_char_type_<char16_t> : std::true_type
-        {};
-
-        template<>
-        struct is_char_type_<char32_t> : std::true_type
-        {};
-
-        template<typename T>
-        using is_char_type = is_char_type_<meta::_t<std::remove_cv<T>>>;
-    } // namespace detail
-    /// \endcond
-
-    /// \addtogroup group-views
-    /// @{
-    namespace views
-    {
-        /// View a `\0`-terminated C string (e.g. from a const char*) as a
-        /// range.
-        struct c_str_fn
-        {
-            // Fixed-length
-            template(typename Char, std::size_t N)(
-                /// \pre
-                requires detail::is_char_type<Char>::value) //
-            ranges::subrange<Char *> operator()(Char (&sz)[N]) const
-            {
-                return {&sz[0], &sz[N - 1]};
-            }
-
-            // Null-terminated
-            template(typename Char)(
-                /// \pre
-                requires detail::is_char_type<Char>::value) //
-            ranges::delimit_view<
-                ranges::subrange<Char *, ranges::unreachable_sentinel_t>,
-                meta::_t<std::remove_cv<Char>>> //
-            operator()(Char * sz) const volatile
-            {
-                using ch_t = meta::_t<std::remove_cv<Char>>;
-                return ranges::views::delimit(sz, ch_t(0));
-            }
-        };
-
-        /// \relates c_str_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(c_str_fn, c_str)
-    } // namespace views
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/cache1.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/cache1.hpp
deleted file mode 100644
index 1fecc16a..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/cache1.hpp
+++ /dev/null
@@ -1,208 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_VIEW_CACHE1_HPP
-#define RANGES_V3_VIEW_CACHE1_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/detail/range_access.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/optional.hpp>
-#include <range/v3/view/adaptor.hpp>
-#include <range/v3/view/all.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    template<typename Rng>
-    struct cache1_view : view_facade<cache1_view<Rng>, range_cardinality<Rng>::value>
-    {
-    private:
-        CPP_assert(view_<Rng>);
-        CPP_assert(input_range<Rng>);
-        CPP_assert(constructible_from<range_value_t<Rng>, range_reference_t<Rng>>);
-        friend range_access;
-        Rng rng_;
-        bool dirty_;
-        detail::non_propagating_cache<range_value_t<Rng>> cache_;
-
-        CPP_member
-        auto update_(range_reference_t<Rng> && val) //
-            -> CPP_ret(void)(
-                /// \pre
-                requires assignable_from<range_value_t<Rng> &, range_reference_t<Rng>>)
-        {
-            if(!cache_)
-                cache_.emplace(static_cast<range_reference_t<Rng> &&>(val));
-            else
-                *cache_ = static_cast<range_reference_t<Rng> &&>(val);
-        }
-        CPP_member
-        auto update_(range_reference_t<Rng> && val) //
-            -> CPP_ret(void)(
-                /// \pre
-                requires (!assignable_from<range_value_t<Rng> &, range_reference_t<Rng>>))
-        {
-            cache_.emplace(static_cast<range_reference_t<Rng> &&>(val));
-        }
-
-        struct cursor;
-
-        struct sentinel
-        {
-        private:
-            friend cursor;
-            sentinel_t<Rng> last_;
-
-        public:
-            sentinel() = default;
-            constexpr explicit sentinel(sentinel_t<Rng> last)
-              : last_(std::move(last))
-            {}
-        };
-
-        struct cursor
-        {
-        private:
-            cache1_view * parent_;
-            iterator_t<Rng> current_;
-
-        public:
-            using value_type = range_value_t<Rng>;
-            using single_pass = std::true_type;
-            using difference_type = range_difference_t<Rng>;
-
-            cursor() = default;
-
-            constexpr explicit cursor(cache1_view * parent, iterator_t<Rng> current)
-              : parent_(parent)
-              , current_(std::move(current))
-            {}
-            range_value_t<Rng> && read() const
-            {
-                if(parent_->dirty_)
-                {
-                    parent_->update_(*current_);
-                    parent_->dirty_ = false;
-                }
-                return std::move(*parent_->cache_);
-            }
-            void next()
-            {
-                ++current_;
-                parent_->dirty_ = true;
-            }
-            bool equal(cursor const & that) const
-            {
-                return current_ == that.current_;
-            }
-            bool equal(sentinel const & that) const
-            {
-                return current_ == that.last_;
-            }
-            CPP_member
-            auto distance_to(cursor const & that) const //
-                -> CPP_ret(difference_type)(
-                    /// \pre
-                    requires sized_sentinel_for<iterator_t<Rng>, iterator_t<Rng>>)
-            {
-                return that.current_ - current_;
-            }
-            CPP_member
-            auto distance_to(sentinel const & that) const //
-                -> CPP_ret(difference_type)(
-                    /// \pre
-                    requires sized_sentinel_for<sentinel_t<Rng>, iterator_t<Rng>>)
-            {
-                return that.last_ - current_;
-            }
-        };
-
-        cursor begin_cursor()
-        {
-            dirty_ = true;
-            return cursor{this, ranges::begin(rng_)};
-        }
-
-        cursor end_cursor_impl(std::true_type)
-        {
-            return cursor{this, ranges::end(rng_)};
-        }
-        sentinel end_cursor_impl(std::false_type)
-        {
-            return sentinel{ranges::end(rng_)};
-        }
-        auto end_cursor()
-        {
-            return end_cursor_impl(meta::bool_<(bool)common_range<Rng>>{});
-        }
-
-    public:
-        cache1_view() = default;
-        constexpr explicit cache1_view(Rng rng)
-          : rng_{std::move(rng)}
-        {}
-        CPP_member
-        constexpr auto CPP_fun(size)()(
-            /// \pre
-            requires sized_range<Rng>)
-        {
-            return ranges::size(rng_);
-        }
-    };
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template<typename Rng>
-    cache1_view(Rng &&) //
-        -> cache1_view<views::all_t<Rng>>;
-#endif
-
-    namespace views
-    {
-        struct cache1_fn
-        {
-            /// \brief Caches the most recent element within the view so that
-            /// dereferencing the view's iterator multiple times doesn't incur any
-            /// recomputation. This can be useful in adaptor pipelines that include
-            /// combinations of \c view::filter and \c view::transform, for instance.
-            /// \note \c views::cache1 is always single-pass.
-            template(typename Rng)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng> AND
-                    constructible_from<range_value_t<Rng>, range_reference_t<Rng>>)
-            constexpr cache1_view<all_t<Rng>> operator()(Rng && rng) const //
-            {
-                return cache1_view<all_t<Rng>>{all(static_cast<Rng &&>(rng))};
-            }
-        };
-
-        /// \relates cache1_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(view_closure<cache1_fn>, cache1)
-    } // namespace views
-
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::cache1_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/cartesian_product.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/cartesian_product.hpp
deleted file mode 100644
index c0acdf00..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/cartesian_product.hpp
+++ /dev/null
@@ -1,504 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-2014.
-//  Copyright Casey Carter 2017.
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_CARTESIAN_PRODUCT_HPP
-#define RANGES_V3_VIEW_CARTESIAN_PRODUCT_HPP
-
-#include <cstdint>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/default_sentinel.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/utility/tuple_algorithm.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/empty.hpp>
-#include <range/v3/view/facade.hpp>
-#include <range/v3/view/view.hpp> // for dereference_fn
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        template<typename State, typename Value>
-        using product_cardinality = std::integral_constant<
-            cardinality,
-            State::value == 0 || Value::value == 0
-                ? static_cast<cardinality>(0)
-                : State::value == unknown || Value::value == unknown
-                      ? unknown
-                      : State::value == infinite || Value::value == infinite
-                            ? infinite
-                            : State::value == finite || Value::value == finite
-                                  ? finite
-                                  : static_cast<cardinality>(
-                                        State::value * Value::value)>;
-
-        struct cartesian_size_fn
-        {
-            template(typename Size, typename Rng)(
-                /// \pre
-                requires integer_like_<Size> AND sized_range<Rng> AND
-                    common_with<Size, range_size_t<Rng>>)
-            common_type_t<Size, range_size_t<Rng>> operator()(Size s, Rng && rng) const
-            {
-                using S = common_type_t<Size, range_size_t<Rng>>;
-                return static_cast<S>(s) * static_cast<S>(ranges::size(rng));
-            }
-        };
-
-        template<typename... Views>
-        using cartesian_product_cardinality =
-            meta::fold<meta::list<range_cardinality<Views>...>,
-                       std::integral_constant<cardinality, static_cast<cardinality>(
-                                                               (sizeof...(Views) > 0))>,
-                       meta::quote<detail::product_cardinality>>;
-    } // namespace detail
-      /// \endcond
-
-    /// \addtogroup group-views
-    /// @{
-
-    // clang-format off
-    template<typename...Views>
-    CPP_concept cartesian_produce_view_can_const =
-        and_v<range<Views const>...>;
-
-    template(typename IsConst, typename... Views)(
-    concept (cartesian_produce_view_can_size_)(IsConst, Views...),
-        and_v<common_with<std::uintmax_t, range_size_t<meta::const_if<IsConst, Views>>>...>
-    );
-    template<typename IsConst, typename...Views>
-    CPP_concept cartesian_produce_view_can_size =
-        and_v<sized_range<meta::const_if<IsConst, Views>>...> &&
-        CPP_concept_ref(ranges::cartesian_produce_view_can_size_, IsConst, Views...);
-
-    template(typename IsConst, typename... Views)(
-    concept (cartesian_produce_view_can_distance_)(IsConst, Views...),
-        and_v<sized_sentinel_for<
-            iterator_t<meta::const_if<IsConst, Views>>,
-            iterator_t<meta::const_if<IsConst, Views>>>...>
-    );
-    template<typename IsConst, typename...Views>
-    CPP_concept cartesian_produce_view_can_distance =
-        cartesian_produce_view_can_size<IsConst, Views...> &&
-        CPP_concept_ref(ranges::cartesian_produce_view_can_distance_, IsConst, Views...);
-
-    template(typename IsConst, typename... Views)(
-    concept (cartesian_produce_view_can_random_)(IsConst, Views...),
-        and_v<random_access_iterator<iterator_t<meta::const_if<IsConst, Views>>>...>
-    );
-    template<typename IsConst, typename...Views>
-    CPP_concept cartesian_produce_view_can_random =
-        cartesian_produce_view_can_distance<IsConst, Views...> &&
-        CPP_concept_ref(ranges::cartesian_produce_view_can_random_, IsConst, Views...);
-
-    template(typename IsConst, typename... Views)(
-    concept (cartesian_produce_view_can_bidi_)(IsConst, Views...),
-        and_v<common_range<meta::const_if<IsConst, Views>>...,
-            bidirectional_iterator<iterator_t<meta::const_if<IsConst, Views>>>...>
-    );
-    template<typename IsConst, typename...Views>
-    CPP_concept cartesian_produce_view_can_bidi =
-        cartesian_produce_view_can_random<IsConst, Views...> ||
-        CPP_concept_ref(ranges::cartesian_produce_view_can_bidi_, IsConst, Views...);
-    // clang-format on
-
-    template<typename... Views>
-    struct cartesian_product_view
-      : view_facade<cartesian_product_view<Views...>,
-                    detail::cartesian_product_cardinality<Views...>::value>
-    {
-    private:
-        friend range_access;
-        CPP_assert(and_v<(forward_range<Views> && view_<Views>)...>);
-        CPP_assert(sizeof...(Views) != 0);
-
-        static constexpr auto my_cardinality =
-            detail::cartesian_product_cardinality<Views...>::value;
-
-        std::tuple<Views...> views_;
-
-        template<bool IsConst_>
-        struct cursor
-        {
-        private:
-            using IsConst = meta::bool_<IsConst_>;
-            friend cursor<true>;
-            template<typename T>
-            using constify_if = meta::const_if_c<IsConst_, T>;
-            using difference_type =
-                common_type_t<std::intmax_t, range_difference_t<Views>...>;
-
-            constify_if<cartesian_product_view> * view_;
-            std::tuple<iterator_t<constify_if<Views>>...> its_;
-
-            void next_(meta::size_t<1>)
-            {
-                auto & v = std::get<0>(view_->views_);
-                auto & i = std::get<0>(its_);
-                auto const last = ranges::end(v);
-                RANGES_EXPECT(i != last);
-                ++i;
-            }
-            template<std::size_t N>
-            void next_(meta::size_t<N>)
-            {
-                auto & v = std::get<N - 1>(view_->views_);
-                auto & i = std::get<N - 1>(its_);
-                auto const last = ranges::end(v);
-                RANGES_EXPECT(i != last);
-                if(++i == last)
-                {
-                    i = ranges::begin(v);
-                    next_(meta::size_t<N - 1>{});
-                }
-            }
-            void prev_(meta::size_t<0>)
-            {
-                RANGES_EXPECT(false);
-            }
-            template<std::size_t N>
-            void prev_(meta::size_t<N>)
-            {
-                auto & v = std::get<N - 1>(view_->views_);
-                auto & i = std::get<N - 1>(its_);
-                if(i == ranges::begin(v))
-                {
-                    CPP_assert(cartesian_produce_view_can_bidi<IsConst, Views...>);
-                    // cartesian_produce_view_can_bidi<IsConst, Views...> implies this
-                    // advance call is O(1)
-                    ranges::advance(i, ranges::end(v));
-                    prev_(meta::size_t<N - 1>{});
-                }
-                --i;
-            }
-            bool equal_(cursor const &, meta::size_t<0>) const
-            {
-                return true;
-            }
-            template<std::size_t N>
-            bool equal_(cursor const & that, meta::size_t<N>) const
-            {
-                return std::get<N - 1>(its_) == std::get<N - 1>(that.its_) &&
-                       equal_(that, meta::size_t<N - 1>{});
-            }
-            difference_type distance_(cursor const & that, meta::size_t<1>) const
-            {
-                return difference_type{std::get<0>(that.its_) - std::get<0>(its_)};
-            }
-            template<std::size_t N>
-            difference_type distance_(cursor const & that, meta::size_t<N>) const
-            {
-                difference_type const d = distance_(that, meta::size_t<N - 1>{});
-                auto const scale = ranges::distance(std::get<N - 1>(view_->views_));
-                auto const increment = std::get<N - 1>(that.its_) - std::get<N - 1>(its_);
-                return difference_type{d * scale + increment};
-            }
-            void advance_(meta::size_t<0>, difference_type)
-            {
-                RANGES_EXPECT(false);
-            }
-            RANGES_DIAGNOSTIC_PUSH
-            RANGES_DIAGNOSTIC_IGNORE_DIVIDE_BY_ZERO
-            template<std::size_t N>
-            void advance_(meta::size_t<N>, difference_type n)
-            {
-                if(n == 0)
-                    return;
-
-                auto & i = std::get<N - 1>(its_);
-                auto const my_size = static_cast<difference_type>(
-                    ranges::size(std::get<N - 1>(view_->views_)));
-                auto const first = ranges::begin(std::get<N - 1>(view_->views_));
-
-                auto const idx = static_cast<difference_type>(i - first);
-                RANGES_EXPECT(0 <= idx);
-                RANGES_EXPECT(idx < my_size || (N == 1 && idx == my_size && n < 0));
-                RANGES_EXPECT(n < INTMAX_MAX - idx);
-                n += idx;
-
-                auto n_div = n / my_size;
-                auto n_mod = n % my_size;
-
-                if(RANGES_CONSTEXPR_IF(N != 1))
-                {
-                    if(n_mod < 0)
-                    {
-                        n_mod += my_size;
-                        --n_div;
-                    }
-                    advance_(meta::size_t<N - 1>{}, n_div);
-                }
-                RANGES_EXPECT(0 <= n_mod && n_mod < my_size);
-
-                if(RANGES_CONSTEXPR_IF(N == 1))
-                {
-                    if(n_div > 0)
-                    {
-                        RANGES_EXPECT(n_div == 1);
-                        RANGES_EXPECT(n_mod == 0);
-                        n_mod = my_size;
-                    }
-                    else if(n_div < 0)
-                    {
-                        RANGES_EXPECT(n_div == -1);
-                        RANGES_EXPECT(n_mod == 0);
-                    }
-                }
-
-                using D = iter_difference_t<decltype(first)>;
-                i = first + static_cast<D>(n_mod);
-            }
-            RANGES_DIAGNOSTIC_POP
-            void check_at_end_(meta::size_t<1>, bool at_end = false)
-            {
-                if(at_end)
-                    ranges::advance(std::get<0>(its_),
-                                    ranges::end(std::get<0>(view_->views_)));
-            }
-            template<std::size_t N>
-            void check_at_end_(meta::size_t<N>, bool at_end = false)
-            {
-                return check_at_end_(
-                    meta::size_t<N - 1>{},
-                    at_end || bool(std::get<N - 1>(its_) ==
-                                   ranges::end(std::get<N - 1>(view_->views_))));
-            }
-            cursor(end_tag, constify_if<cartesian_product_view> * view,
-                   std::true_type) // common_with
-              : cursor(begin_tag{}, view)
-            {
-                CPP_assert(
-                    common_range<meta::at_c<meta::list<constify_if<Views>...>, 0>>);
-                std::get<0>(its_) = ranges::end(std::get<0>(view->views_));
-            }
-            cursor(end_tag, constify_if<cartesian_product_view> * view,
-                   std::false_type) // !common_with
-              : cursor(begin_tag{}, view)
-            {
-                using View0 = meta::at_c<meta::list<constify_if<Views>...>, 0>;
-                CPP_assert(!common_range<View0> && random_access_range<View0> &&
-                           sized_range<View0>);
-                std::get<0>(its_) += ranges::distance(std::get<0>(view->views_));
-            }
-
-        public:
-            using value_type = std::tuple<range_value_t<Views>...>;
-
-            cursor() = default;
-            explicit cursor(begin_tag, constify_if<cartesian_product_view> * view)
-              : view_(view)
-              , its_(tuple_transform(view->views_, ranges::begin))
-            {
-                // If any of the constituent views is empty, the cartesian_product is
-                // empty and this "begin" iterator needs to become an "end" iterator.
-                check_at_end_(meta::size_t<sizeof...(Views)>{});
-            }
-            explicit cursor(end_tag, constify_if<cartesian_product_view> * view)
-              : cursor(
-                    end_tag{}, view,
-                    meta::bool_<
-                        common_range<meta::at_c<meta::list<constify_if<Views>...>, 0>>>{})
-            {}
-            template(bool Other)(
-                /// \pre
-                requires IsConst_ AND CPP_NOT(Other)) //
-            cursor(cursor<Other> that)
-              : view_(that.view_)
-              , its_(std::move(that.its_))
-            {}
-            common_tuple<range_reference_t<constify_if<Views>>...> read() const
-            {
-                return tuple_transform(its_, detail::dereference_fn{});
-            }
-            void next()
-            {
-                next_(meta::size_t<sizeof...(Views)>{});
-            }
-            bool equal(default_sentinel_t) const
-            {
-                return std::get<0>(its_) == ranges::end(std::get<0>(view_->views_));
-            }
-            bool equal(cursor const & that) const
-            {
-                return equal_(that, meta::size_t<sizeof...(Views)>{});
-            }
-            CPP_member
-            auto prev() -> CPP_ret(void)(
-                /// \pre
-                requires cartesian_produce_view_can_bidi<IsConst, Views...>)
-            {
-                prev_(meta::size_t<sizeof...(Views)>{});
-            }
-            CPP_member
-            auto CPP_fun(distance_to)(cursor const & that)(
-                const requires cartesian_produce_view_can_distance<IsConst, Views...>)
-            {
-                return distance_(that, meta::size_t<sizeof...(Views)>{});
-            }
-            CPP_member
-            auto advance(difference_type n) //
-                -> CPP_ret(void)(
-                    /// \pre
-                    requires cartesian_produce_view_can_random<IsConst, Views...>)
-            {
-                advance_(meta::size_t<sizeof...(Views)>{}, n);
-            }
-        };
-        cursor<false> begin_cursor()
-        {
-            return cursor<false>{begin_tag{}, this};
-        }
-        CPP_member
-        auto begin_cursor() const //
-            -> CPP_ret(cursor<true>)(
-                /// \pre
-                requires cartesian_produce_view_can_const<Views...>)
-        {
-            return cursor<true>{begin_tag{}, this};
-        }
-        CPP_member
-        auto end_cursor() //
-            -> CPP_ret(cursor<false>)(
-                /// \pre
-                requires cartesian_produce_view_can_bidi<std::false_type, Views...>)
-        {
-            return cursor<false>{end_tag{}, this};
-        }
-        CPP_member
-        auto end_cursor() const //
-            -> CPP_ret(cursor<true>)(
-                /// \pre
-                requires cartesian_produce_view_can_bidi<std::true_type, Views...>)
-        {
-            return cursor<true>{end_tag{}, this};
-        }
-        CPP_member
-        auto end_cursor() const //
-            -> CPP_ret(default_sentinel_t)(
-                /// \pre
-                requires (!cartesian_produce_view_can_bidi<std::true_type, Views...>))
-        {
-            return {};
-        }
-
-    public:
-        cartesian_product_view() = default;
-        constexpr explicit cartesian_product_view(Views... views)
-          : views_{detail::move(views)...}
-        {}
-        template(int = 42)(
-            /// \pre
-            requires (my_cardinality >= 0)) //
-            static constexpr std::size_t size() noexcept
-        {
-            return std::size_t{my_cardinality};
-        }
-        CPP_member
-        auto CPP_fun(size)()(const //
-                             requires (my_cardinality < 0) &&
-                             cartesian_produce_view_can_size<std::true_type, Views...>)
-        {
-            return tuple_foldl(views_, std::uintmax_t{1}, detail::cartesian_size_fn{});
-        }
-        CPP_member
-        auto CPP_fun(size)()(
-            /// \pre
-            requires (my_cardinality < 0) &&
-                cartesian_produce_view_can_size<std::false_type, Views...>)
-        {
-            return tuple_foldl(views_, std::uintmax_t{1}, detail::cartesian_size_fn{});
-        }
-    };
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template<typename... Rng>
-    cartesian_product_view(Rng &&...) //
-        -> cartesian_product_view<views::all_t<Rng>...>;
-#endif
-
-    namespace views
-    {
-        struct cartesian_product_fn
-        {
-            constexpr empty_view<std::tuple<>> operator()() const noexcept
-            {
-                return {};
-            }
-            template(typename... Rngs)(
-                /// \pre
-                requires (sizeof...(Rngs) != 0) AND
-                concepts::and_v<(forward_range<Rngs> && viewable_range<Rngs>)...>)
-            constexpr cartesian_product_view<all_t<Rngs>...> operator()(Rngs &&... rngs)
-                const
-            {
-                return cartesian_product_view<all_t<Rngs>...>{
-                    all(static_cast<Rngs &&>(rngs))...};
-            }
-#if defined(_MSC_VER)
-            template(typename Rng0)(
-                /// \pre
-                requires forward_range<Rng0> AND viewable_range<Rng0>)
-            constexpr cartesian_product_view<all_t<Rng0>> operator()(Rng0 && rng0) const
-            {
-                return cartesian_product_view<all_t<Rng0>>{
-                    all(static_cast<Rng0 &&>(rng0))};
-            }
-            template(typename Rng0, typename Rng1)(
-                /// \pre
-                requires forward_range<Rng0> AND viewable_range<Rng0> AND
-                             forward_range<Rng1> AND viewable_range<Rng1>)
-            constexpr cartesian_product_view<all_t<Rng0>, all_t<Rng1>> //
-            operator()(Rng0 && rng0, Rng1 && rng1) const
-            {
-                return cartesian_product_view<all_t<Rng0>, all_t<Rng1>>{
-                    all(static_cast<Rng0 &&>(rng0)), //
-                    all(static_cast<Rng1 &&>(rng1))};
-            }
-            template(typename Rng0, typename Rng1, typename Rng2)(
-                /// \pre
-                requires forward_range<Rng0> AND viewable_range<Rng0> AND
-                    forward_range<Rng1> AND viewable_range<Rng1> AND
-                    forward_range<Rng2> AND viewable_range<Rng2>)
-            constexpr cartesian_product_view<all_t<Rng0>, all_t<Rng1>, all_t<Rng2>> //
-            operator()(Rng0 && rng0, Rng1 && rng1, Rng2 && rng2) const
-            {
-                return cartesian_product_view<all_t<Rng0>, all_t<Rng1>, all_t<Rng2>>{
-                    all(static_cast<Rng0 &&>(rng0)), //
-                    all(static_cast<Rng1 &&>(rng1)), //
-                    all(static_cast<Rng2 &&>(rng2))};
-            }
-#endif
-        };
-
-        RANGES_INLINE_VARIABLE(cartesian_product_fn, cartesian_product)
-    } // namespace views
-
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/chunk.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/chunk.hpp
deleted file mode 100644
index 5ef9b389..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/chunk.hpp
+++ /dev/null
@@ -1,477 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_CHUNK_HPP
-#define RANGES_V3_VIEW_CHUNK_HPP
-
-#include <limits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/iterator/default_sentinel.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/box.hpp>
-#include <range/v3/utility/optional.hpp> // for non_propagating_cache
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/adaptor.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/facade.hpp>
-#include <range/v3/view/take.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        template<typename Rng, bool Const>
-        constexpr bool can_sized_sentinel_() noexcept
-        {
-            using I = iterator_t<meta::const_if_c<Const, Rng>>;
-            return (bool)sized_sentinel_for<I, I>;
-        }
-
-        template<typename T>
-        struct zero
-        {
-            zero() = default;
-            constexpr explicit zero(T const &) noexcept
-            {}
-            constexpr zero & operator=(T const &) noexcept
-            {
-                return *this;
-            }
-            constexpr zero const & operator=(T const &) const noexcept
-            {
-                return *this;
-            }
-            constexpr operator T() const
-            {
-                return T(0);
-            }
-            constexpr T exchange(T const &) const
-            {
-                return T(0);
-            }
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// \addtogroup group-views
-    /// @{
-    template<typename Rng, bool IsForwardRange>
-    struct chunk_view_
-      : view_adaptor<chunk_view_<Rng, IsForwardRange>, Rng,
-                     is_finite<Rng>::value ? finite : range_cardinality<Rng>::value>
-    {
-    private:
-        friend range_access;
-        CPP_assert(forward_range<Rng>);
-
-        template<bool Const>
-        using offset_t =
-            meta::if_c<bidirectional_range<meta::const_if_c<Const, Rng>> ||
-                           detail::can_sized_sentinel_<Rng, Const>(),
-                       range_difference_t<Rng>, detail::zero<range_difference_t<Rng>>>;
-
-        range_difference_t<Rng> n_ = 0;
-
-        template<bool Const>
-        struct RANGES_EMPTY_BASES adaptor
-          : adaptor_base
-          , private box<offset_t<Const>>
-        {
-        private:
-            friend adaptor<!Const>;
-            using CRng = meta::const_if_c<Const, Rng>;
-
-            range_difference_t<CRng> n_;
-            sentinel_t<CRng> end_;
-
-            constexpr offset_t<Const> const & offset() const
-            {
-                offset_t<Const> const & result = this->box<offset_t<Const>>::get();
-                RANGES_EXPECT(0 <= result && result < n_);
-                return result;
-            }
-            constexpr offset_t<Const> & offset()
-            {
-                return const_cast<offset_t<Const> &>(
-                    const_cast<adaptor const &>(*this).offset());
-            }
-
-        public:
-            adaptor() = default;
-            constexpr adaptor(meta::const_if_c<Const, chunk_view_> * cv)
-              : box<offset_t<Const>>{0}
-              , n_((RANGES_EXPECT(0 < cv->n_), cv->n_))
-              , end_(ranges::end(cv->base()))
-            {}
-            template(bool Other)(
-                /// \pre
-                requires Const AND CPP_NOT(Other)) //
-            constexpr adaptor(adaptor<Other> that)
-              : box<offset_t<Const>>(that.offset())
-              , n_(that.n_)
-              , end_(that.end_)
-            {}
-            constexpr auto read(iterator_t<CRng> const & it) const
-                -> decltype(views::take(make_subrange(it, end_), n_))
-            {
-                RANGES_EXPECT(it != end_);
-                RANGES_EXPECT(0 == offset());
-                return views::take(make_subrange(it, end_), n_);
-            }
-            constexpr void next(iterator_t<CRng> & it)
-            {
-                RANGES_EXPECT(it != end_);
-                RANGES_EXPECT(0 == offset());
-                offset() = ranges::advance(it, n_, end_);
-            }
-            CPP_member
-            constexpr auto prev(iterator_t<CRng> & it) //
-                -> CPP_ret(void)(
-                    /// \pre
-                    requires bidirectional_range<CRng>)
-            {
-                ranges::advance(it, -n_ + offset());
-                offset() = 0;
-            }
-            CPP_member
-            constexpr auto distance_to(iterator_t<CRng> const & here,
-                                       iterator_t<CRng> const & there,
-                                       adaptor const & that) const
-                -> CPP_ret(range_difference_t<Rng>)(
-                    /// \pre
-                    requires (detail::can_sized_sentinel_<Rng, Const>()))
-            {
-                auto const delta = (there - here) + (that.offset() - offset());
-                // This can fail for cyclic base ranges when the chunk size does not
-                // divide the cycle length. Such iterator pairs are NOT in the domain of
-                // -.
-                RANGES_ENSURE(0 == delta % n_);
-                return delta / n_;
-            }
-            CPP_member
-            constexpr auto advance(iterator_t<CRng> & it, range_difference_t<Rng> n) //
-                -> CPP_ret(void)(
-                    /// \pre
-                    requires random_access_range<CRng>)
-            {
-                using Limits = std::numeric_limits<range_difference_t<CRng>>;
-                if(0 < n)
-                {
-                    RANGES_EXPECT(0 == offset());
-                    RANGES_EXPECT(n <= Limits::max() / n_);
-                    auto const remainder = ranges::advance(it, n * n_, end_) % n_;
-                    RANGES_EXPECT(0 <= remainder && remainder < n_);
-                    offset() = remainder;
-                }
-                else if(0 > n)
-                {
-                    RANGES_EXPECT(n >= Limits::min() / n_);
-                    ranges::advance(it, n * n_ + offset());
-                    offset() = 0;
-                }
-            }
-        };
-
-        constexpr adaptor<simple_view<Rng>()> begin_adaptor()
-        {
-            return adaptor<simple_view<Rng>()>{this};
-        }
-        CPP_member
-        constexpr auto begin_adaptor() const //
-            -> CPP_ret(adaptor<true>)(
-                /// \pre
-                requires forward_range<Rng const>)
-        {
-            return adaptor<true>{this};
-        }
-        template<typename Size>
-        constexpr Size size_(Size base_size) const
-        {
-            auto const n = static_cast<Size>(n_);
-            return base_size / n + (0 != (base_size % n));
-        }
-
-    public:
-        chunk_view_() = default;
-        constexpr chunk_view_(Rng rng, range_difference_t<Rng> n)
-          : chunk_view_::view_adaptor(detail::move(rng))
-          , n_((RANGES_EXPECT(0 < n), n))
-        {}
-        CPP_member
-        constexpr auto CPP_fun(size)()(const
-            /// \pre
-            requires sized_range<Rng const>)
-        {
-            return size_(ranges::size(this->base()));
-        }
-        CPP_member
-        constexpr auto CPP_fun(size)()(
-            /// \pre
-            requires sized_range<Rng>)
-        {
-            return size_(ranges::size(this->base()));
-        }
-    };
-
-    template<typename Rng>
-    struct chunk_view_<Rng, false>
-      : view_facade<chunk_view_<Rng, false>,
-                    is_finite<Rng>::value ? finite : range_cardinality<Rng>::value>
-    {
-    private:
-        friend range_access;
-        CPP_assert(input_range<Rng> && !forward_range<Rng>);
-
-        using iter_cache_t = detail::non_propagating_cache<iterator_t<Rng>>;
-
-        Rng base_;
-        range_difference_t<Rng> n_;
-        range_difference_t<Rng> remainder_;
-        mutable iter_cache_t it_cache_;
-
-        constexpr iterator_t<Rng> & it() noexcept
-        {
-            return *it_cache_;
-        }
-        constexpr iterator_t<Rng> const & it() const noexcept
-        {
-            return *it_cache_;
-        }
-
-        struct outer_cursor
-        {
-        private:
-            struct inner_view : view_facade<inner_view, finite>
-            {
-            private:
-                friend range_access;
-
-                using value_type = range_value_t<Rng>;
-
-                chunk_view_ * rng_ = nullptr;
-
-                constexpr bool done() const noexcept
-                {
-                    RANGES_EXPECT(rng_);
-                    return rng_->remainder_ == 0;
-                }
-                constexpr bool equal(default_sentinel_t) const noexcept
-                {
-                    return done();
-                }
-                constexpr iter_reference_t<iterator_t<Rng>> read() const
-                {
-                    RANGES_EXPECT(!done());
-                    return *rng_->it();
-                }
-                constexpr iter_rvalue_reference_t<iterator_t<Rng>> move() const
-                {
-                    RANGES_EXPECT(!done());
-                    return ranges::iter_move(rng_->it());
-                }
-                constexpr void next()
-                {
-                    RANGES_EXPECT(!done());
-                    ++rng_->it();
-                    --rng_->remainder_;
-                    if(rng_->remainder_ != 0 && rng_->it() == ranges::end(rng_->base_))
-                        rng_->remainder_ = 0;
-                }
-                CPP_member
-                constexpr auto distance_to(default_sentinel_t) const
-                    -> CPP_ret(range_difference_t<Rng>)(
-                        /// \pre
-                        requires sized_sentinel_for<sentinel_t<Rng>, iterator_t<Rng>>)
-                {
-                    RANGES_EXPECT(rng_);
-                    auto const d = ranges::end(rng_->base_) - rng_->it();
-                    return ranges::min(d, rng_->remainder_);
-                }
-
-            public:
-                inner_view() = default;
-                constexpr explicit inner_view(chunk_view_ & view) noexcept
-                  : rng_{&view}
-                {}
-                CPP_member
-                constexpr auto CPP_fun(size)()(
-                    /// \pre
-                    requires sized_sentinel_for<sentinel_t<Rng>, iterator_t<Rng>>)
-                {
-                    using size_type = detail::iter_size_t<iterator_t<Rng>>;
-                    return static_cast<size_type>(distance_to(default_sentinel_t{}));
-                }
-            };
-
-            chunk_view_ * rng_ = nullptr;
-
-        public:
-            using value_type = inner_view;
-
-            outer_cursor() = default;
-            constexpr explicit outer_cursor(chunk_view_ * view) noexcept
-              : rng_{view}
-            {}
-            constexpr inner_view read() const
-            {
-                RANGES_EXPECT(!done());
-                return inner_view{*rng_};
-            }
-            constexpr bool done() const
-            {
-                RANGES_EXPECT(rng_);
-                return rng_->it() == ranges::end(rng_->base_) && rng_->remainder_ != 0;
-            }
-            constexpr bool equal(default_sentinel_t) const
-            {
-                return done();
-            }
-            constexpr void next()
-            {
-                RANGES_EXPECT(!done());
-                ranges::advance(rng_->it(), rng_->remainder_, ranges::end(rng_->base_));
-                rng_->remainder_ = rng_->n_;
-            }
-            CPP_member
-            constexpr auto distance_to(default_sentinel_t) const
-                -> CPP_ret(range_difference_t<Rng>)(
-                    /// \pre
-                    requires sized_sentinel_for<sentinel_t<Rng>, iterator_t<Rng>>)
-            {
-                RANGES_EXPECT(rng_);
-                auto d = ranges::end(rng_->base_) - rng_->it();
-                if(d < rng_->remainder_)
-                    return 1;
-
-                d -= rng_->remainder_;
-                d = (d + rng_->n_ - 1) / rng_->n_;
-                d += (rng_->remainder_ != 0);
-                return d;
-            }
-        };
-
-        constexpr outer_cursor begin_cursor() noexcept
-        {
-            it_cache_ = ranges::begin(base_);
-            return outer_cursor{this};
-        }
-        template<typename Size>
-        constexpr Size size_(Size base_size) const
-        {
-            auto const n = static_cast<Size>(this->n_);
-            return base_size / n + (0 != base_size % n);
-        }
-
-    public:
-        chunk_view_() = default;
-        constexpr chunk_view_(Rng rng, range_difference_t<Rng> n)
-          : base_(detail::move(rng))
-          , n_((RANGES_EXPECT(0 < n), n))
-          , remainder_(n)
-          , it_cache_{nullopt}
-        {}
-        CPP_member
-        constexpr auto CPP_fun(size)()(const
-            /// \pre
-            requires sized_range<Rng const>)
-        {
-            return size_(ranges::size(base_));
-        }
-        CPP_member
-        constexpr auto CPP_fun(size)()(
-            /// \pre
-            requires sized_range<Rng>)
-        {
-            return size_(ranges::size(base_));
-        }
-        Rng base() const
-        {
-            return base_;
-        }
-    };
-
-    template<typename Rng>
-    struct chunk_view : chunk_view_<Rng, (bool)forward_range<Rng>>
-    {
-        chunk_view() = default;
-        constexpr chunk_view(Rng rng, range_difference_t<Rng> n)
-          : chunk_view_<Rng, (bool)forward_range<Rng>>(static_cast<Rng &&>(rng), n)
-        {}
-    };
-
-    // Need to keep extra state for input_range, but forward_range is transparent
-    template<typename Rng>
-    RANGES_INLINE_VAR constexpr bool enable_borrowed_range<chunk_view<Rng>> =
-        enable_borrowed_range<Rng> && forward_range<Rng>;
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template<typename Rng>
-    chunk_view(Rng &&, range_difference_t<Rng>)
-        -> chunk_view<views::all_t<Rng>>;
-#endif
-
-    namespace views
-    {
-        // In:  range<T>
-        // Out: range<range<T>>, where each inner range has $n$ elements.
-        //                       The last range may have fewer.
-        struct chunk_base_fn
-        {
-            template(typename Rng)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng>)
-            constexpr chunk_view<all_t<Rng>> //
-            operator()(Rng && rng, range_difference_t<Rng> n) const
-            {
-                return {all(static_cast<Rng &&>(rng)), n};
-            }
-        };
-
-        struct chunk_fn : chunk_base_fn
-        {
-            using chunk_base_fn::operator();
-
-            template(typename Int)(
-                /// \pre
-                requires detail::integer_like_<Int>)
-            constexpr auto operator()(Int n) const
-            {
-                return make_view_closure(bind_back(chunk_base_fn{}, n));
-            }
-        };
-
-        /// \relates chunk_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(chunk_fn, chunk)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::chunk_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/common.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/common.hpp
deleted file mode 100644
index fa4dbe7a..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/common.hpp
+++ /dev/null
@@ -1,244 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_VIEW_COMMON_HPP
-#define RANGES_V3_VIEW_COMMON_HPP
-
-#include <type_traits>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/common_iterator.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/interface.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-
-    /// \cond
-    namespace detail
-    {
-        // clang-format off
-        template<typename R>
-        CPP_concept random_access_and_sized_range =
-            random_access_range<R> && sized_range<R>;
-        // clang-format on
-
-        template<typename R>
-        using common_view_iterator_t =
-            meta::if_c<random_access_and_sized_range<R>, iterator_t<R>,
-                       common_iterator_t<iterator_t<R>, sentinel_t<R>>>;
-
-        template<typename Rng>
-        struct is_common_range : meta::bool_<common_range<Rng>>
-        {};
-    } // namespace detail
-    /// \endcond
-
-    template<typename Rng, bool = detail::is_common_range<Rng>::value>
-    struct common_view : view_interface<common_view<Rng>, range_cardinality<Rng>::value>
-    {
-    private:
-        CPP_assert(view_<Rng>);
-        CPP_assert(!(common_range<Rng> && view_<Rng>));
-        Rng rng_;
-
-        sentinel_t<Rng> end_(std::false_type)
-        {
-            return ranges::end(rng_);
-        }
-        iterator_t<Rng> end_(std::true_type)
-        {
-            return ranges::begin(rng_) + ranges::distance(rng_);
-        }
-        template(bool Const = true)(
-            /// \pre
-            requires Const AND range<meta::const_if_c<Const, Rng>>)
-        sentinel_t<meta::const_if_c<Const, Rng>> end_(std::false_type) const
-        {
-            return ranges::end(rng_);
-        }
-        template(bool Const = true)(
-            /// \pre
-            requires Const AND range<meta::const_if_c<Const, Rng>>)
-        iterator_t<meta::const_if_c<Const, Rng>> end_(std::true_type) const
-        {
-            return ranges::begin(rng_) + ranges::distance(rng_);
-        }
-
-    public:
-        common_view() = default;
-        explicit common_view(Rng rng)
-          : rng_(detail::move(rng))
-        {}
-        Rng base() const
-        {
-            return rng_;
-        }
-
-        detail::common_view_iterator_t<Rng> begin()
-        {
-            return detail::common_view_iterator_t<Rng>{ranges::begin(rng_)};
-        }
-        detail::common_view_iterator_t<Rng> end()
-        {
-            return detail::common_view_iterator_t<Rng>{
-                end_(meta::bool_<detail::random_access_and_sized_range<Rng>>{})};
-        }
-        CPP_member
-        auto CPP_fun(size)()(
-            /// \pre
-            requires sized_range<Rng>)
-        {
-            return ranges::size(rng_);
-        }
-
-        template(bool Const = true)(
-            /// \pre
-            requires range<meta::const_if_c<Const, Rng>>)
-        auto begin() const
-            -> detail::common_view_iterator_t<meta::const_if_c<Const, Rng>>
-        {
-            return detail::common_view_iterator_t<meta::const_if_c<Const, Rng>>{
-                ranges::begin(rng_)};
-        }
-        template(bool Const = true)(
-            /// \pre
-            requires range<meta::const_if_c<Const, Rng>>)
-        auto end() const
-            -> detail::common_view_iterator_t<meta::const_if_c<Const, Rng>>
-        {
-            return detail::common_view_iterator_t<meta::const_if_c<Const, Rng>>{
-                end_(meta::bool_<detail::random_access_and_sized_range<
-                         meta::const_if_c<Const, Rng>>>{})};
-        }
-        CPP_member
-        auto CPP_fun(size)()(const
-            /// \pre
-            requires sized_range<Rng const>)
-        {
-            return ranges::size(rng_);
-        }
-    };
-
-    template<typename Rng, bool B>
-    RANGES_INLINE_VAR constexpr bool enable_borrowed_range<common_view<Rng, B>> = //
-        enable_borrowed_range<Rng>;
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template(typename Rng)(
-        /// \pre
-        requires (!common_range<Rng>)) //
-        common_view(Rng &&)
-            ->common_view<views::all_t<Rng>>;
-#endif
-
-    template<typename Rng>
-    struct common_view<Rng, true> : identity_adaptor<Rng>
-    {
-        CPP_assert(common_range<Rng>);
-        using identity_adaptor<Rng>::identity_adaptor;
-    };
-
-    namespace views
-    {
-        struct cpp20_common_fn
-        {
-            template(typename Rng)(
-                /// \pre
-                requires viewable_range<Rng> AND common_range<Rng>)
-            all_t<Rng> operator()(Rng && rng) const
-            {
-                return all(static_cast<Rng &&>(rng));
-            }
-
-            template(typename Rng)(
-                /// \pre
-                requires viewable_range<Rng> AND (!common_range<Rng>)) //
-            common_view<all_t<Rng>> operator()(Rng && rng) const
-            {
-                return common_view<all_t<Rng>>{all(static_cast<Rng &&>(rng))};
-            }
-        };
-
-        struct common_fn
-        {
-            template(typename Rng)(
-                /// \pre
-                requires viewable_range<Rng>)
-            common_view<all_t<Rng>> operator()(Rng && rng) const
-            {
-                return common_view<all_t<Rng>>{all(static_cast<Rng &&>(rng))};
-            }
-        };
-
-        /// \relates common_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(view_closure<common_fn>, common)
-    } // namespace views
-    /// @}
-
-    /// \cond
-    template<typename Rng>
-    using bounded_view RANGES_DEPRECATED(
-        "The name bounded_view is deprecated. "
-        "Please use common_view instead.") = common_view<Rng>;
-    /// \endcond
-
-    namespace views
-    {
-        /// \cond
-        namespace
-        {
-            RANGES_DEPRECATED(
-                "The name views::bounded is deprecated. "
-                "Please use views::common instead.")
-            RANGES_INLINE_VAR constexpr auto & bounded = common;
-        } // namespace
-
-        template<typename Rng>
-        using bounded_t RANGES_DEPRECATED("The name views::bounded_t is deprecated.") =
-            decltype(common(std::declval<Rng>()));
-        /// \endcond
-    } // namespace views
-
-    namespace cpp20
-    {
-        namespace views
-        {
-            RANGES_INLINE_VARIABLE(
-                ranges::views::view_closure<ranges::views::cpp20_common_fn>, common)
-        }
-        template(typename Rng)(
-            /// \pre
-            requires view_<Rng> && (!common_range<Rng>)) //
-            using common_view = ranges::common_view<Rng>;
-    } // namespace cpp20
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::common_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/concat.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/concat.hpp
deleted file mode 100644
index 6b1e5c8a..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/concat.hpp
+++ /dev/null
@@ -1,473 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-2014.
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_CONCAT_HPP
-#define RANGES_V3_VIEW_CONCAT_HPP
-
-#include <tuple>
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/arithmetic.hpp>
-#include <range/v3/functional/compose.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/utility/tuple_algorithm.hpp>
-#include <range/v3/utility/variant.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/facade.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        template<typename State, typename Value>
-        using concat_cardinality_ = std::integral_constant<
-            cardinality,
-            State::value == infinite || Value::value == infinite
-                ? infinite
-                : State::value == unknown || Value::value == unknown
-                      ? unknown
-                      : State::value == finite || Value::value == finite
-                            ? finite
-                            : static_cast<cardinality>(State::value + Value::value)>;
-
-        template<typename... Rngs>
-        using concat_cardinality =
-            meta::fold<meta::list<range_cardinality<Rngs>...>,
-                       std::integral_constant<cardinality, static_cast<cardinality>(0)>,
-                       meta::quote<concat_cardinality_>>;
-    } // namespace detail
-    /// \endcond
-
-    /// \addtogroup group-views
-    /// @{
-    template<typename... Rngs>
-    struct concat_view
-      : view_facade<concat_view<Rngs...>, detail::concat_cardinality<Rngs...>::value>
-    {
-    private:
-        friend range_access;
-        using difference_type_ = common_type_t<range_difference_t<Rngs>...>;
-        static constexpr std::size_t cranges{sizeof...(Rngs)};
-        std::tuple<Rngs...> rngs_;
-
-        template<bool IsConst>
-        struct cursor;
-
-        template<bool IsConst>
-        struct sentinel
-        {
-        private:
-            friend struct sentinel<!IsConst>;
-            friend struct cursor<IsConst>;
-            template<typename T>
-            using constify_if = meta::const_if_c<IsConst, T>;
-            using concat_view_t = constify_if<concat_view>;
-            sentinel_t<constify_if<meta::back<meta::list<Rngs...>>>> end_;
-
-        public:
-            sentinel() = default;
-            sentinel(concat_view_t * rng, end_tag)
-              : end_(end(std::get<cranges - 1>(rng->rngs_)))
-            {}
-            template(bool Other)(
-                /// \pre
-                requires IsConst AND CPP_NOT(Other)) //
-            sentinel(sentinel<Other> that)
-              : end_(std::move(that.end_))
-            {}
-        };
-
-        template<bool IsConst>
-        struct cursor
-        {
-            using difference_type = common_type_t<range_difference_t<Rngs>...>;
-
-        private:
-            friend struct cursor<!IsConst>;
-            template<typename T>
-            using constify_if = meta::const_if_c<IsConst, T>;
-            using concat_view_t = constify_if<concat_view>;
-            concat_view_t * rng_;
-            variant<iterator_t<constify_if<Rngs>>...> its_;
-
-            template<std::size_t N>
-            void satisfy(meta::size_t<N>)
-            {
-                RANGES_EXPECT(its_.index() == N);
-                if(ranges::get<N>(its_) == end(std::get<N>(rng_->rngs_)))
-                {
-                    ranges::emplace<N + 1>(its_, begin(std::get<N + 1>(rng_->rngs_)));
-                    this->satisfy(meta::size_t<N + 1>{});
-                }
-            }
-            void satisfy(meta::size_t<cranges - 1>)
-            {
-                RANGES_EXPECT(its_.index() == cranges - 1);
-            }
-            struct next_fun
-            {
-                cursor * pos;
-                template(typename I, std::size_t N)(
-                    /// \pre
-                    requires input_iterator<I>)
-                void operator()(indexed_element<I, N> it) const
-                {
-                    RANGES_ASSERT(it.get() != end(std::get<N>(pos->rng_->rngs_)));
-                    ++it.get();
-                    pos->satisfy(meta::size_t<N>{});
-                }
-            };
-            struct prev_fun
-            {
-                cursor * pos;
-                template(typename I)(
-                    /// \pre
-                    requires bidirectional_iterator<I>)
-                void operator()(indexed_element<I, 0> it) const
-                {
-                    RANGES_ASSERT(it.get() != begin(std::get<0>(pos->rng_->rngs_)));
-                    --it.get();
-                }
-                template(typename I, std::size_t N)(
-                    /// \pre
-                    requires (N != 0) AND bidirectional_iterator<I>)
-                void operator()(indexed_element<I, N> it) const
-                {
-                    if(it.get() == begin(std::get<N>(pos->rng_->rngs_)))
-                    {
-                        auto && rng = std::get<N - 1>(pos->rng_->rngs_);
-                        ranges::emplace<N - 1>(
-                            pos->its_,
-                            ranges::next(ranges::begin(rng), ranges::end(rng)));
-                        pos->its_.visit_i(*this);
-                    }
-                    else
-                        --it.get();
-                }
-            };
-            struct advance_fwd_fun
-            {
-                cursor * pos;
-                difference_type n;
-                template(typename I)(
-                    /// \pre
-                    requires random_access_iterator<I>)
-                void operator()(indexed_element<I, cranges - 1> it) const
-                {
-                    ranges::advance(it.get(), n);
-                }
-                template(typename I, std::size_t N)(
-                    /// \pre
-                    requires random_access_iterator<I>)
-                void operator()(indexed_element<I, N> it) const
-                {
-                    auto last = ranges::end(std::get<N>(pos->rng_->rngs_));
-                    // BUGBUG If distance(it, last) > n, then using bounded advance
-                    // is O(n) when it need not be since the last iterator position
-                    // is actually not interesting. Only the "rest" is needed, which
-                    // can sometimes be O(1).
-                    auto rest = ranges::advance(it.get(), n, std::move(last));
-                    pos->satisfy(meta::size_t<N>{});
-                    if(rest != 0)
-                        pos->its_.visit_i(advance_fwd_fun{pos, rest});
-                }
-            };
-            struct advance_rev_fun
-            {
-                cursor * pos;
-                difference_type n;
-                template(typename I)(
-                    /// \pre
-                    requires random_access_iterator<I>)
-                void operator()(indexed_element<I, 0> it) const
-                {
-                    ranges::advance(it.get(), n);
-                }
-                template(typename I, std::size_t N)(
-                    /// \pre
-                    requires random_access_iterator<I>)
-                void operator()(indexed_element<I, N> it) const
-                {
-                    auto first = ranges::begin(std::get<N>(pos->rng_->rngs_));
-                    if(it.get() == first)
-                    {
-                        auto && rng = std::get<N - 1>(pos->rng_->rngs_);
-                        ranges::emplace<N - 1>(
-                            pos->its_,
-                            ranges::next(ranges::begin(rng), ranges::end(rng)));
-                        pos->its_.visit_i(*this);
-                    }
-                    else
-                    {
-                        auto rest = ranges::advance(it.get(), n, std::move(first));
-                        if(rest != 0)
-                            pos->its_.visit_i(advance_rev_fun{pos, rest});
-                    }
-                }
-            };
-            [[noreturn]] static difference_type distance_to_(meta::size_t<cranges>,
-                                                             cursor const &,
-                                                             cursor const &)
-            {
-                RANGES_EXPECT(false);
-            }
-            template<std::size_t N>
-            static difference_type distance_to_(meta::size_t<N>, cursor const & from,
-                                                cursor const & to)
-            {
-                if(from.its_.index() > N)
-                    return cursor::distance_to_(meta::size_t<N + 1>{}, from, to);
-                if(from.its_.index() == N)
-                {
-                    if(to.its_.index() == N)
-                        return distance(ranges::get<N>(from.its_),
-                                        ranges::get<N>(to.its_));
-                    return distance(ranges::get<N>(from.its_),
-                                    end(std::get<N>(from.rng_->rngs_))) +
-                           cursor::distance_to_(meta::size_t<N + 1>{}, from, to);
-                }
-                if(from.its_.index() < N && to.its_.index() > N)
-                    return distance(std::get<N>(from.rng_->rngs_)) +
-                           cursor::distance_to_(meta::size_t<N + 1>{}, from, to);
-                RANGES_EXPECT(to.its_.index() == N);
-                return distance(begin(std::get<N>(from.rng_->rngs_)),
-                                ranges::get<N>(to.its_));
-            }
-
-        public:
-            // BUGBUG what about rvalue_reference and common_reference?
-            using reference = common_reference_t<range_reference_t<constify_if<Rngs>>...>;
-            using single_pass = meta::or_c<single_pass_iterator_<iterator_t<Rngs>>...>;
-            cursor() = default;
-            cursor(concat_view_t * rng, begin_tag)
-              : rng_(rng)
-              , its_{emplaced_index<0>, begin(std::get<0>(rng->rngs_))}
-            {
-                this->satisfy(meta::size_t<0>{});
-            }
-            cursor(concat_view_t * rng, end_tag)
-              : rng_(rng)
-              , its_{emplaced_index<cranges - 1>, end(std::get<cranges - 1>(rng->rngs_))}
-            {}
-            template(bool Other)(
-                /// \pre
-                requires IsConst && CPP_NOT(Other)) //
-            cursor(cursor<Other> that)
-              : rng_(that.rng_)
-              , its_(std::move(that.its_))
-            {}
-            reference read() const
-            {
-                // Kind of a dumb implementation. Surely there's a better way.
-                return ranges::get<0>(unique_variant(its_.visit(
-                    compose(convert_to<reference>{}, detail::dereference_fn{}))));
-            }
-            void next()
-            {
-                its_.visit_i(next_fun{this});
-            }
-            CPP_member
-            auto equal(cursor const & pos) const //
-                -> CPP_ret(bool)(
-                    /// \pre
-                    requires //
-                        equality_comparable<variant<iterator_t<constify_if<Rngs>>...>>)
-            {
-                return its_ == pos.its_;
-            }
-            bool equal(sentinel<IsConst> const & pos) const
-            {
-                return its_.index() == cranges - 1 &&
-                       ranges::get<cranges - 1>(its_) == pos.end_;
-            }
-            CPP_member
-            auto prev() //
-                -> CPP_ret(void)(
-                    /// \pre
-                    requires and_v<bidirectional_range<Rngs>...>)
-            {
-                its_.visit_i(prev_fun{this});
-            }
-            CPP_member
-            auto advance(difference_type n) //
-                -> CPP_ret(void)(
-                    /// \pre
-                    requires and_v<random_access_range<Rngs>...>)
-            {
-                if(n > 0)
-                    its_.visit_i(advance_fwd_fun{this, n});
-                else if(n < 0)
-                    its_.visit_i(advance_rev_fun{this, n});
-            }
-            CPP_member
-            auto distance_to(cursor const & that) const //
-                -> CPP_ret(difference_type)(
-                    /// \pre
-                    requires and_v<sized_sentinel_for<iterator_t<Rngs>,
-                                                      iterator_t<Rngs>>...>)
-            {
-                if(its_.index() <= that.its_.index())
-                    return cursor::distance_to_(meta::size_t<0>{}, *this, that);
-                return -cursor::distance_to_(meta::size_t<0>{}, that, *this);
-            }
-        };
-        cursor<meta::and_c<simple_view<Rngs>()...>::value> begin_cursor()
-        {
-            return {this, begin_tag{}};
-        }
-        meta::if_<meta::and_c<(bool)common_range<Rngs>...>,
-                  cursor<meta::and_c<simple_view<Rngs>()...>::value>,
-                  sentinel<meta::and_c<simple_view<Rngs>()...>::value>>
-        end_cursor()
-        {
-            return {this, end_tag{}};
-        }
-        CPP_member
-        auto begin_cursor() const //
-            -> CPP_ret(cursor<true>)(
-                /// \pre
-                requires and_v<range<Rngs const>...>)
-        {
-            return {this, begin_tag{}};
-        }
-        CPP_member
-        auto end_cursor() const //
-            -> CPP_ret(
-                meta::if_<meta::and_c<(bool)common_range<Rngs const>...>, //
-                          cursor<true>, //
-                          sentinel<true>>)(
-            /// \pre
-            requires and_v<range<Rngs const>...>)
-        {
-            return {this, end_tag{}};
-        }
-
-    public:
-        concat_view() = default;
-        explicit concat_view(Rngs... rngs)
-          : rngs_{std::move(rngs)...}
-        {}
-        CPP_member
-        constexpr auto size() const //
-            -> CPP_ret(std::size_t)(
-                /// \pre
-                requires (detail::concat_cardinality<Rngs...>::value >= 0))
-        {
-            return static_cast<std::size_t>(detail::concat_cardinality<Rngs...>::value);
-        }
-        CPP_member
-        constexpr auto CPP_fun(size)()(
-            const requires(detail::concat_cardinality<Rngs...>::value < 0) &&
-            and_v<sized_range<Rngs const>...>)
-        {
-            using size_type = common_type_t<range_size_t<Rngs const>...>;
-            return tuple_foldl(
-                tuple_transform(rngs_,
-                                [](auto && r) -> size_type { return ranges::size(r); }),
-                size_type{0},
-                plus{});
-        }
-        CPP_member
-        constexpr auto CPP_fun(size)()(
-            /// \pre
-            requires (detail::concat_cardinality<Rngs...>::value < 0) &&
-            and_v<sized_range<Rngs>...>)
-        {
-            using size_type = common_type_t<range_size_t<Rngs>...>;
-            return tuple_foldl(
-                tuple_transform(rngs_,
-                                [](auto && r) -> size_type { return ranges::size(r); }),
-                size_type{0},
-                plus{});
-        }
-    };
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template<typename... Rng>
-    concat_view(Rng &&...) //
-        -> concat_view<views::all_t<Rng>...>;
-#endif
-
-    namespace views
-    {
-        struct concat_fn
-        {
-            template(typename... Rngs)(
-                /// \pre
-                requires and_v<(viewable_range<Rngs> && input_range<Rngs>)...>)
-            concat_view<all_t<Rngs>...> operator()(Rngs &&... rngs) const
-            {
-                return concat_view<all_t<Rngs>...>{all(static_cast<Rngs &&>(rngs))...};
-            }
-            template(typename Rng)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng>)
-            all_t<Rng> operator()(Rng && rng) const //
-            {
-                return all(static_cast<Rng &&>(rng));
-            }
-            // MSVC doesn't like variadics in operator() for some reason
-#if defined(_MSC_VER)
-            template(typename Rng0, typename Rng1)(
-                /// \pre
-                requires viewable_range<Rng0> AND input_range<Rng0> AND
-                        viewable_range<Rng1> AND input_range<Rng1>)
-            concat_view<all_t<Rng0>, all_t<Rng1>> operator()(Rng0 && rng0, Rng1 && rng1)
-                const
-            {
-                return concat_view<all_t<Rng0>, all_t<Rng1>>{
-                    all(static_cast<Rng0 &&>(rng0)),
-                    all(static_cast<Rng1 &&>(rng1))};
-            }
-            template(typename Rng0, typename Rng1, typename Rng2)(
-                /// \pre
-                requires viewable_range<Rng0> AND input_range<Rng0> AND
-                    viewable_range<Rng1> AND input_range<Rng1> AND
-                    viewable_range<Rng2> AND input_range<Rng2>)
-            concat_view<all_t<Rng0>, all_t<Rng1>, all_t<Rng2>> //
-            operator()(Rng0 && rng0, Rng1 && rng1, Rng2 && rng2) const
-            {
-                return concat_view<all_t<Rng0>, all_t<Rng1>, all_t<Rng2>>{
-                    all(static_cast<Rng0 &&>(rng0)),
-                    all(static_cast<Rng1 &&>(rng1)),
-                    all(static_cast<Rng2 &&>(rng2))};
-            }
-#endif
-        };
-
-        /// \relates concat_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(concat_fn, concat)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::concat_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/const.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/const.hpp
deleted file mode 100644
index af18e509..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/const.hpp
+++ /dev/null
@@ -1,148 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_CONST_HPP
-#define RANGES_V3_VIEW_CONST_HPP
-
-#include <type_traits>
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/utility/common_type.hpp>
-#include <range/v3/utility/move.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/adaptor.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    template<typename Rng>
-    struct const_view : view_adaptor<const_view<Rng>, Rng>
-    {
-    private:
-        friend range_access;
-        template<bool Const>
-        struct adaptor : adaptor_base
-        {
-            using CRng = meta::const_if_c<Const, Rng>;
-            using value_ = range_value_t<CRng>;
-            using reference_ =
-                common_reference_t<value_ const &&, range_reference_t<CRng>>;
-            using rvalue_reference_ =
-                common_reference_t<value_ const &&, range_rvalue_reference_t<CRng>>;
-            adaptor() = default;
-            template(bool Other)(
-                /// \pre
-                requires Const && CPP_NOT(Other)) //
-                constexpr adaptor(adaptor<Other>)
-            {}
-            reference_ read(iterator_t<CRng> const & it) const
-            {
-                return *it;
-            }
-            rvalue_reference_ iter_move(iterator_t<CRng> const & it) const
-                noexcept(noexcept(rvalue_reference_(ranges::iter_move(it))))
-            {
-                return ranges::iter_move(it);
-            }
-        };
-        adaptor<simple_view<Rng>()> begin_adaptor()
-        {
-            return {};
-        }
-        CPP_member
-        auto begin_adaptor() const //
-            -> CPP_ret(adaptor<true>)(
-                /// \pre
-                requires range<Rng const>)
-        {
-            return {};
-        }
-        adaptor<simple_view<Rng>()> end_adaptor()
-        {
-            return {};
-        }
-        CPP_member
-        auto end_adaptor() const //
-            -> CPP_ret(adaptor<true>)(
-                /// \pre
-                requires range<Rng const>)
-        {
-            return {};
-        }
-
-    public:
-        const_view() = default;
-        explicit const_view(Rng rng)
-          : const_view::view_adaptor{std::move(rng)}
-        {}
-        CPP_member
-        constexpr auto CPP_fun(size)()(
-            /// \pre
-            requires sized_range<Rng>)
-        {
-            return ranges::size(this->base());
-        }
-        CPP_member
-        constexpr auto CPP_fun(size)()(const
-            /// \pre
-            requires sized_range<Rng const>)
-        {
-            return ranges::size(this->base());
-        }
-    };
-
-    template<typename Rng>
-    RANGES_INLINE_VAR constexpr bool enable_borrowed_range<const_view<Rng>> = //
-        enable_borrowed_range<Rng>;
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template<typename Rng>
-    const_view(Rng &&) //
-        -> const_view<views::all_t<Rng>>;
-#endif
-
-    namespace views
-    {
-        struct const_fn
-        {
-            template(typename Rng)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng>)
-            const_view<all_t<Rng>> operator()(Rng && rng) const
-            {
-                return const_view<all_t<Rng>>{all(static_cast<Rng &&>(rng))};
-            }
-        };
-
-        /// \relates const_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(view_closure<const_fn>, const_)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::const_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/counted.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/counted.hpp
deleted file mode 100644
index 380dd348..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/counted.hpp
+++ /dev/null
@@ -1,131 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_VIEW_COUNTED_HPP
-#define RANGES_V3_VIEW_COUNTED_HPP
-
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/counted_iterator.hpp>
-#include <range/v3/iterator/default_sentinel.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/interface.hpp>
-#include <range/v3/view/subrange.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    template<typename I>
-    struct counted_view : view_interface<counted_view<I>, finite>
-    {
-    private:
-        friend range_access;
-        I it_;
-        iter_difference_t<I> n_;
-
-    public:
-        counted_view() = default;
-        counted_view(I it, iter_difference_t<I> n)
-          : it_(it)
-          , n_(n)
-        {
-            RANGES_EXPECT(0 <= n_);
-        }
-        counted_iterator<I> begin() const
-        {
-            return make_counted_iterator(it_, n_);
-        }
-        default_sentinel_t end() const
-        {
-            return {};
-        }
-        auto size() const
-        {
-            return static_cast<detail::iter_size_t<I>>(n_);
-        }
-    };
-
-    template<typename I>
-    RANGES_INLINE_VAR constexpr bool enable_borrowed_range<counted_view<I>> = true;
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template<typename I>
-    counted_view(I, iter_difference_t<I>)
-        -> counted_view<I>;
-#endif
-
-    namespace views
-    {
-        struct cpp20_counted_fn
-        {
-            template(typename I)(
-                /// \pre
-                requires input_or_output_iterator<I> AND (!random_access_iterator<I>)) //
-            subrange<counted_iterator<I>, default_sentinel_t> //
-            operator()(I it, iter_difference_t<I> n) const
-            {
-                return {make_counted_iterator(std::move(it), n), default_sentinel};
-            }
-            template(typename I)(
-                /// \pre
-                requires random_access_iterator<I>)
-            subrange<I> operator()(I it, iter_difference_t<I> n) const
-            {
-                return {it, it + n};
-            }
-        };
-
-        struct counted_fn
-        {
-            template(typename I)(
-                /// \pre
-                requires input_or_output_iterator<I> AND (!random_access_iterator<I>)) //
-            counted_view<I> operator()(I it, iter_difference_t<I> n) const
-            {
-                return {std::move(it), n};
-            }
-            template(typename I)(
-                /// \pre
-                requires random_access_iterator<I>)
-            subrange<I> operator()(I it, iter_difference_t<I> n) const
-            {
-                return {it, it + n};
-            }
-        };
-
-        /// \relates counted_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(counted_fn, counted)
-    } // namespace views
-
-    namespace cpp20
-    {
-        namespace views
-        {
-            RANGES_INLINE_VARIABLE(ranges::views::cpp20_counted_fn, counted)
-        }
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::counted_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/cycle.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/cycle.hpp
deleted file mode 100644
index 10c16713..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/cycle.hpp
+++ /dev/null
@@ -1,251 +0,0 @@
-/// \file cycle.hpp
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//  Copyright Gonzalo Brito Gadeschi 2015
-//  Copyright Casey Carter 2015
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_CYCLE_HPP
-#define RANGES_V3_VIEW_CYCLE_HPP
-
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/unreachable_sentinel.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/box.hpp>
-#include <range/v3/utility/get.hpp>
-#include <range/v3/utility/optional.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/facade.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    template<typename Rng, bool /* = (bool) is_infinite<Rng>() */>
-    struct RANGES_EMPTY_BASES cycled_view
-      : view_facade<cycled_view<Rng>, infinite>
-      , private detail::non_propagating_cache<iterator_t<Rng>, cycled_view<Rng>,
-                                              !common_range<Rng>>
-    {
-    private:
-        CPP_assert(forward_range<Rng> && !is_infinite<Rng>::value);
-        friend range_access;
-        Rng rng_;
-
-        using cache_t = detail::non_propagating_cache<iterator_t<Rng>, cycled_view<Rng>,
-                                                      !common_range<Rng>>;
-
-        template<bool IsConst>
-        struct cursor
-        {
-        private:
-            friend struct cursor<!IsConst>;
-            template<typename T>
-            using constify_if = meta::const_if_c<IsConst, T>;
-            using cycled_view_t = constify_if<cycled_view>;
-            using CRng = constify_if<Rng>;
-            using iterator = iterator_t<CRng>;
-
-            cycled_view_t * rng_{};
-            iterator it_{};
-            std::intmax_t n_ = 0;
-
-            iterator get_end_(std::true_type, bool = false) const
-            {
-                return ranges::end(rng_->rng_);
-            }
-            template<bool CanBeEmpty = false>
-            iterator get_end_(std::false_type, meta::bool_<CanBeEmpty> = {}) const
-            {
-                auto & end_ = static_cast<cache_t &>(*rng_);
-                RANGES_EXPECT(CanBeEmpty || end_);
-                if(CanBeEmpty && !end_)
-                    end_ = ranges::next(it_, ranges::end(rng_->rng_));
-                return *end_;
-            }
-            void set_end_(std::true_type) const
-            {}
-            void set_end_(std::false_type) const
-            {
-                auto & end_ = static_cast<cache_t &>(*rng_);
-                if(!end_)
-                    end_ = it_;
-            }
-
-        public:
-            cursor() = default;
-            cursor(cycled_view_t * rng)
-              : rng_(rng)
-              , it_(ranges::begin(rng->rng_))
-            {}
-            template(bool Other)(
-                /// \pre
-                requires IsConst AND CPP_NOT(Other)) //
-            cursor(cursor<Other> that)
-              : rng_(that.rng_)
-              , it_(std::move(that.it_))
-            {}
-            // clang-format off
-            auto CPP_auto_fun(read)()(const)
-            (
-                return *it_
-            )
-            // clang-format on
-            CPP_member
-            auto equal(cursor const & pos) const //
-                -> CPP_ret(bool)(
-                    /// \pre
-                    requires equality_comparable<iterator>)
-            {
-                RANGES_EXPECT(rng_ == pos.rng_);
-                return n_ == pos.n_ && it_ == pos.it_;
-            }
-            void next()
-            {
-                auto const last = ranges::end(rng_->rng_);
-                RANGES_EXPECT(it_ != last);
-                if(++it_ == last)
-                {
-                    ++n_;
-                    this->set_end_(meta::bool_<(bool)common_range<CRng>>{});
-                    it_ = ranges::begin(rng_->rng_);
-                }
-            }
-            CPP_member
-            auto prev() //
-                -> CPP_ret(void)(
-                    /// \pre
-                    requires bidirectional_range<CRng>)
-            {
-                if(it_ == ranges::begin(rng_->rng_))
-                {
-                    RANGES_EXPECT(n_ > 0); // decrementing the begin iterator?!
-                    --n_;
-                    it_ = this->get_end_(meta::bool_<(bool)common_range<CRng>>{});
-                }
-                --it_;
-            }
-            template(typename Diff)(
-                /// \pre
-                requires random_access_range<CRng> AND
-                    detail::integer_like_<Diff>) void advance(Diff n)
-            {
-                auto const first = ranges::begin(rng_->rng_);
-                auto const last = this->get_end_(meta::bool_<(bool)common_range<CRng>>{},
-                                                 meta::bool_<true>());
-                auto const dist = last - first;
-                auto const d = it_ - first;
-                auto const off = (d + n) % dist;
-                n_ += (d + n) / dist;
-                RANGES_EXPECT(n_ >= 0);
-                using D = range_difference_t<Rng>;
-                it_ = first + static_cast<D>(off < 0 ? off + dist : off);
-            }
-            CPP_member
-            auto CPP_fun(distance_to)(cursor const & that)(
-                const requires sized_sentinel_for<iterator, iterator>)
-            {
-                RANGES_EXPECT(that.rng_ == rng_);
-                auto const first = ranges::begin(rng_->rng_);
-                auto const last = this->get_end_(meta::bool_<(bool)common_range<Rng>>{},
-                                                 meta::bool_<true>());
-                auto const dist = last - first;
-                return (that.n_ - n_) * dist + (that.it_ - it_);
-            }
-        };
-
-        CPP_member
-        auto begin_cursor() //
-            -> CPP_ret(cursor<false>)(
-                /// \pre
-                requires (!simple_view<Rng>() || !common_range<Rng const>))
-        {
-            return {this};
-        }
-        CPP_member
-        auto begin_cursor() const //
-            -> CPP_ret(cursor<true>)(
-                /// \pre
-                requires common_range<Rng const>)
-        {
-            return {this};
-        }
-        unreachable_sentinel_t end_cursor() const
-        {
-            return unreachable;
-        }
-
-    public:
-        cycled_view() = default;
-        /// \pre <tt>!empty(rng)</tt>
-        explicit cycled_view(Rng rng)
-          : rng_(std::move(rng))
-        {
-            RANGES_EXPECT(!ranges::empty(rng_));
-        }
-    };
-
-    template<typename Rng>
-    struct cycled_view<Rng, true> : identity_adaptor<Rng>
-    {
-        CPP_assert(is_infinite<Rng>::value);
-        using identity_adaptor<Rng>::identity_adaptor;
-    };
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template<typename Rng>
-    cycled_view(Rng &&) //
-        -> cycled_view<views::all_t<Rng>>;
-#endif
-
-    namespace views
-    {
-        /// Returns an infinite range that endlessly repeats the source
-        /// range.
-        struct cycle_fn
-        {
-            /// \pre <tt>!empty(rng)</tt>
-            template(typename Rng)(
-                /// \pre
-                requires viewable_range<Rng> AND forward_range<Rng>)
-            cycled_view<all_t<Rng>> operator()(Rng && rng) const
-            {
-                return cycled_view<all_t<Rng>>{all(static_cast<Rng &&>(rng))};
-            }
-        };
-
-        /// \relates cycle_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(view_closure<cycle_fn>, cycle)
-    } // namespace views
-      /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::cycled_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/delimit.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/delimit.hpp
deleted file mode 100644
index 56bb9abe..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/delimit.hpp
+++ /dev/null
@@ -1,135 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_DELIMIT_HPP
-#define RANGES_V3_VIEW_DELIMIT_HPP
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/unreachable_sentinel.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/adaptor.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/subrange.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    template<typename Rng, typename Val>
-    struct delimit_view
-      : view_adaptor<delimit_view<Rng, Val>, Rng,
-                     is_finite<Rng>::value ? finite : unknown>
-    {
-    private:
-        friend range_access;
-        Val value_;
-
-        struct sentinel_adaptor : adaptor_base
-        {
-            sentinel_adaptor() = default;
-            sentinel_adaptor(Val value)
-              : value_(std::move(value))
-            {}
-            template<class I, class S>
-            bool empty(I const & it, S const & last) const
-            {
-                return it == last || *it == value_;
-            }
-            Val value_;
-        };
-
-        sentinel_adaptor end_adaptor() const
-        {
-            return {value_};
-        }
-
-    public:
-        delimit_view() = default;
-        constexpr delimit_view(Rng rng, Val value)
-          : delimit_view::view_adaptor{std::move(rng)}
-          , value_(std::move(value))
-        {}
-    };
-
-    // the begin iterator will be an iterator into the underlying view (conditionally
-    // borrowed) and the end iterator owns the value to be compared against (borrowed)
-    template<typename Rng, typename Val>
-    RANGES_INLINE_VAR constexpr bool enable_borrowed_range<delimit_view<Rng, Val>> = //
-        enable_borrowed_range<Rng>;
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template(typename Rng, typename Val)(
-        /// \pre
-        requires copy_constructible<Val>)
-    delimit_view(Rng &&, Val)
-        -> delimit_view<views::all_t<Rng>, Val>;
-#endif
-
-    namespace views
-    {
-        struct delimit_base_fn
-        {
-            template(typename I_, typename Val, typename I = detail::decay_t<I_>)(
-                /// \pre
-                requires (!range<I_>) AND convertible_to<I_, I> AND input_iterator<I> AND
-                    semiregular<Val> AND
-                    equality_comparable_with<Val, iter_reference_t<I>>)
-            constexpr auto operator()(I_ && begin_, Val value) const
-                -> delimit_view<subrange<I, unreachable_sentinel_t>, Val>
-            {
-                return {{static_cast<I_ &&>(begin_), {}}, std::move(value)};
-            }
-
-            template(typename Rng, typename Val)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng> AND semiregular<
-                        Val> AND equality_comparable_with<Val, range_reference_t<Rng>>)
-            constexpr auto operator()(Rng && rng, Val value) const //
-                -> delimit_view<all_t<Rng>, Val>
-            {
-                return {all(static_cast<Rng &&>(rng)), std::move(value)};
-            }
-        };
-
-        struct delimit_fn : delimit_base_fn
-        {
-            using delimit_base_fn::operator();
-
-            template<typename Val>
-            constexpr auto operator()(Val value) const
-            {
-                return make_view_closure(bind_back(delimit_base_fn{}, std::move(value)));
-            }
-        };
-
-        /// \relates delimit_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(delimit_fn, delimit)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::delimit_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/drop.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/drop.hpp
deleted file mode 100644
index 691f6a41..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/drop.hpp
+++ /dev/null
@@ -1,211 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_DROP_HPP
-#define RANGES_V3_VIEW_DROP_HPP
-
-#include <type_traits>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/min.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/box.hpp>
-#include <range/v3/utility/optional.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/interface.hpp>
-#include <range/v3/view/subrange.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    template<typename Rng>
-    struct RANGES_EMPTY_BASES drop_view
-      : view_interface<drop_view<Rng>,
-                       is_finite<Rng>::value ? finite : range_cardinality<Rng>::value>
-      , private detail::non_propagating_cache<iterator_t<Rng>, drop_view<Rng>,
-                                              !random_access_range<Rng>>
-    {
-    private:
-        using difference_type_ = range_difference_t<Rng>;
-        Rng rng_;
-        difference_type_ n_;
-
-        template(bool Const = true)(
-            /// \pre
-            requires Const AND range<meta::const_if_c<Const, Rng>>)
-        iterator_t<meta::const_if_c<Const, Rng>> //
-        get_begin_(std::true_type, std::true_type) const
-        {
-            CPP_assert(random_access_range<meta::const_if_c<Const, Rng>>);
-            return next(ranges::begin(rng_), n_, ranges::end(rng_));
-        }
-        iterator_t<Rng> get_begin_(std::true_type, std::false_type)
-        {
-            CPP_assert(random_access_range<Rng>);
-            return next(ranges::begin(rng_), n_, ranges::end(rng_));
-        }
-        iterator_t<Rng> get_begin_(std::false_type, detail::ignore_t)
-        {
-            CPP_assert(!random_access_range<Rng>);
-            using cache_t =
-                detail::non_propagating_cache<iterator_t<Rng>, drop_view<Rng>>;
-            auto & begin_ = static_cast<cache_t &>(*this);
-            if(!begin_)
-                begin_ = next(ranges::begin(rng_), n_, ranges::end(rng_));
-            return *begin_;
-        }
-
-    public:
-        drop_view() = default;
-        drop_view(Rng rng, difference_type_ n)
-          : rng_(std::move(rng))
-          , n_(n)
-        {
-            RANGES_EXPECT(n >= 0);
-        }
-        iterator_t<Rng> begin()
-        {
-            return this->get_begin_(meta::bool_<random_access_range<Rng>>{},
-                                    std::false_type{});
-        }
-        sentinel_t<Rng> end()
-        {
-            return ranges::end(rng_);
-        }
-        template(bool Const = true)(
-            /// \pre
-            requires Const AND random_access_range<meta::const_if_c<Const, Rng>>)
-        iterator_t<meta::const_if_c<Const, Rng>> begin() const
-        {
-            return this->get_begin_(std::true_type{}, std::true_type{});
-        }
-        template(bool Const = true)(
-            /// \pre
-            requires Const AND random_access_range<meta::const_if_c<Const, Rng>>)
-        sentinel_t<meta::const_if_c<Const, Rng>> end() const
-        {
-            return ranges::end(rng_);
-        }
-        CPP_member
-        auto CPP_fun(size)()(const //
-            requires sized_range<Rng const>)
-        {
-            auto const s = ranges::size(rng_);
-            auto const n = static_cast<range_size_t<Rng const>>(n_);
-            return s < n ? 0 : s - n;
-        }
-        CPP_member
-        auto CPP_fun(size)()(
-            /// \pre
-            requires sized_range<Rng>)
-        {
-            auto const s = ranges::size(rng_);
-            auto const n = static_cast<range_size_t<Rng>>(n_);
-            return s < n ? 0 : s - n;
-        }
-        Rng base() const
-        {
-            return rng_;
-        }
-    };
-
-    template<typename Rng>
-    RANGES_INLINE_VAR constexpr bool enable_borrowed_range<drop_view<Rng>> = //
-        enable_borrowed_range<Rng>;
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template<typename Rng>
-    drop_view(Rng &&, range_difference_t<Rng>)
-        -> drop_view<views::all_t<Rng>>;
-#endif
-
-    namespace views
-    {
-        struct drop_base_fn
-        {
-        private:
-            template<typename Rng>
-            static auto impl_(Rng && rng, range_difference_t<Rng> n, input_range_tag)
-                -> drop_view<all_t<Rng>>
-            {
-                return {all(static_cast<Rng &&>(rng)), n};
-            }
-            template(typename Rng)(
-                /// \pre
-                requires borrowed_range<Rng> AND sized_range<Rng>)
-            static subrange<iterator_t<Rng>, sentinel_t<Rng>> //
-            impl_(Rng && rng, range_difference_t<Rng> n, random_access_range_tag)
-            {
-                return {begin(rng) + ranges::min(n, distance(rng)), end(rng)};
-            }
-
-        public:
-            template(typename Rng)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng>)
-            auto operator()(Rng && rng, range_difference_t<Rng> n) const
-            {
-                return drop_base_fn::impl_(
-                    static_cast<Rng &&>(rng), n, range_tag_of<Rng>{});
-            }
-        };
-
-        struct drop_fn : drop_base_fn
-        {
-            using drop_base_fn::operator();
-
-            template(typename Int)(
-                /// \pre
-                requires detail::integer_like_<Int>)
-            constexpr auto operator()(Int n) const
-            {
-                return make_view_closure(bind_back(drop_base_fn{}, n));
-            }
-        };
-
-        /// \relates drop_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(drop_fn, drop)
-    } // namespace views
-
-    namespace cpp20
-    {
-        namespace views
-        {
-            using ranges::views::drop;
-        }
-        template(typename Rng)(
-            /// \pre
-            requires view_<Rng>)
-            using drop_view = ranges::drop_view<Rng>;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::drop_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/drop_exactly.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/drop_exactly.hpp
deleted file mode 100644
index 7f1d7b23..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/drop_exactly.hpp
+++ /dev/null
@@ -1,192 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_DROP_EXACTLY_HPP
-#define RANGES_V3_VIEW_DROP_EXACTLY_HPP
-
-#include <type_traits>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/box.hpp>
-#include <range/v3/utility/optional.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/interface.hpp>
-#include <range/v3/view/subrange.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    template<typename Rng>
-    struct RANGES_EMPTY_BASES drop_exactly_view
-      : view_interface<drop_exactly_view<Rng>,
-                       is_finite<Rng>::value ? finite : range_cardinality<Rng>::value>
-      , private detail::non_propagating_cache<iterator_t<Rng>, drop_exactly_view<Rng>,
-                                              !random_access_range<Rng>>
-    {
-    private:
-        using difference_type_ = range_difference_t<Rng>;
-        Rng rng_;
-        difference_type_ n_;
-
-        // random_access_range == true
-        template(bool Const = true)(
-            /// \pre
-            requires Const AND random_access_range<meta::const_if_c<Const, Rng>>)
-        iterator_t<meta::const_if_c<Const, Rng>> get_begin_(std::true_type) const
-        {
-            return next(ranges::begin(rng_), n_);
-        }
-        iterator_t<Rng> get_begin_(std::true_type)
-        {
-            return next(ranges::begin(rng_), n_);
-        }
-        // random_access_range == false
-        iterator_t<Rng> get_begin_(std::false_type)
-        {
-            using cache_t =
-                detail::non_propagating_cache<iterator_t<Rng>, drop_exactly_view<Rng>>;
-            auto & begin_ = static_cast<cache_t &>(*this);
-            if(!begin_)
-                begin_ = next(ranges::begin(rng_), n_);
-            return *begin_;
-        }
-
-    public:
-        drop_exactly_view() = default;
-        drop_exactly_view(Rng rng, difference_type_ n)
-          : rng_(std::move(rng))
-          , n_(n)
-        {
-            RANGES_EXPECT(n >= 0);
-        }
-        iterator_t<Rng> begin()
-        {
-            return this->get_begin_(meta::bool_<random_access_range<Rng>>{});
-        }
-        sentinel_t<Rng> end()
-        {
-            return ranges::end(rng_);
-        }
-        template(bool Const = true)(
-            /// \pre
-            requires Const AND random_access_range<meta::const_if_c<Const, Rng>>)
-        iterator_t<meta::const_if_c<Const, Rng>> begin() const
-        {
-            return this->get_begin_(std::true_type{});
-        }
-        template(bool Const = true)(
-            /// \pre
-            requires Const AND random_access_range<meta::const_if_c<Const, Rng>>)
-        sentinel_t<meta::const_if_c<Const, Rng>> end() const
-        {
-            return ranges::end(rng_);
-        }
-        CPP_member
-        auto CPP_fun(size)()(const
-            /// \pre
-            requires sized_range<Rng const>)
-        {
-            return ranges::size(rng_) - static_cast<range_size_t<Rng const>>(n_);
-        }
-        CPP_member
-        auto CPP_fun(size)()(
-            /// \pre
-            requires sized_range<Rng>)
-        {
-            return ranges::size(rng_) - static_cast<range_size_t<Rng>>(n_);
-        }
-        Rng base() const
-        {
-            return rng_;
-        }
-    };
-
-    template<typename Rng>
-    RANGES_INLINE_VAR constexpr bool enable_borrowed_range<drop_exactly_view<Rng>> = //
-        enable_borrowed_range<Rng>;
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template<typename Rng>
-    drop_exactly_view(Rng &&, range_difference_t<Rng>)
-        ->drop_exactly_view<views::all_t<Rng>>;
-#endif
-
-    namespace views
-    {
-        struct drop_exactly_base_fn
-        {
-        private:
-            template<typename Rng>
-            static auto impl_(Rng && rng, range_difference_t<Rng> n, input_range_tag)
-                -> drop_exactly_view<all_t<Rng>>
-            {
-                return {all(static_cast<Rng &&>(rng)), n};
-            }
-            template(typename Rng)(
-                /// \pre
-                requires borrowed_range<Rng>)
-            static subrange<iterator_t<Rng>, sentinel_t<Rng>> //
-            impl_(Rng && rng, range_difference_t<Rng> n, random_access_range_tag)
-            {
-                return {begin(rng) + n, end(rng)};
-            }
-
-        public:
-            template(typename Rng)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng>)
-            auto operator()(Rng && rng, range_difference_t<Rng> n) const
-            {
-                return drop_exactly_base_fn::impl_(
-                    static_cast<Rng &&>(rng), n, range_tag_of<Rng>{});
-            }
-        };
-
-        struct drop_exactly_fn : drop_exactly_base_fn
-        {
-            using drop_exactly_base_fn::operator();
-
-            template(typename Int)(
-                /// \pre
-                requires detail::integer_like_<Int>)
-            constexpr auto operator()(Int n) const
-            {
-                return make_view_closure(bind_back(drop_exactly_base_fn{}, n));
-            }
-        };
-
-        /// \relates drop_exactly_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(drop_exactly_fn, drop_exactly)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::drop_exactly_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/drop_last.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/drop_last.hpp
deleted file mode 100644
index efb9cbb9..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/drop_last.hpp
+++ /dev/null
@@ -1,383 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Andrey Diduh 2019
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_DROP_LAST_HPP
-#define RANGES_V3_VIEW_DROP_LAST_HPP
-
-#include <type_traits>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/iterator/counted_iterator.hpp>
-#include <range/v3/iterator/default_sentinel.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/utility/optional.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/adaptor.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/interface.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-
-    /// \cond
-    namespace detail
-    {
-        namespace drop_last_view
-        {
-            template<typename Rng>
-            range_size_t<Rng> get_size(Rng & rng, range_difference_t<Rng> n_)
-            {
-                RANGES_EXPECT(n_ >= 0);
-                range_size_t<Rng> const initial_size = ranges::size(rng);
-                range_size_t<Rng> const n = static_cast<range_size_t<Rng>>(n_);
-                RANGES_EXPECT(initial_size >= n);
-                return initial_size > n ? initial_size - n : 0;
-            }
-
-            template(typename Rng)(
-                /// \pre
-                requires random_access_range<Rng> AND sized_range<Rng>)
-            iterator_t<Rng> get_end(Rng & rng, range_difference_t<Rng> n, int)
-            {
-                return begin(rng) + static_cast<range_difference_t<Rng>>(
-                                        drop_last_view::get_size(rng, n));
-            }
-            template(typename Rng)(
-                /// \pre
-                requires bidirectional_range<Rng> AND common_range<Rng>)
-            iterator_t<Rng> get_end(Rng & rng, range_difference_t<Rng> n, long)
-            {
-                return prev(end(rng), n, begin(rng));
-            }
-
-            enum class mode_enum
-            {
-                bidi,
-                forward,
-                sized,
-                invalid
-            };
-
-            template<mode_enum Mode>
-            using mode_t = std::integral_constant<mode_enum, Mode>;
-
-            using mode_bidi = mode_t<mode_enum::bidi>;
-            using mode_forward = mode_t<mode_enum::forward>;
-            using mode_sized = mode_t<mode_enum::sized>;
-            using mode_invalid = mode_t<mode_enum::invalid>;
-
-            template<typename Rng>
-            constexpr mode_enum get_mode() noexcept
-            {
-                // keep range bound
-                // Sized Bidi O(N)
-                return (random_access_range<Rng> && view_<Rng> && sized_range<Rng>) ||
-                               (bidirectional_range<Rng> && view_<Rng> &&
-                                common_range<Rng>)
-                           ? mode_enum::bidi                        //
-                           : sized_range<Rng> && view_<Rng>         //
-                                 ? mode_enum::sized                 //
-                                 : forward_range<Rng> && view_<Rng> //
-                                       ? mode_enum::forward         //
-                                       : mode_enum::invalid;        //
-
-                // max performance
-                // Sized Bidi O(1)
-                // Sized Bidi use mode::sized instead of mode::bidi - thus become unbound.
-                /*return (random_access_range<Rng> && view_<Rng> && sized_range<Rng> &&
-                   view_<Rng>) || (bidirectional_range<Rng> && view_<Rng> &&
-                   common_range<Rng> && view_<Rng>) ? mode::bidi : sized_range<Rng> &&
-                   view_<Rng> ? mode::sized : bidirectional_range<Rng> && view_<Rng> &&
-                   common_range<Rng> && view_<Rng> ? mode::bidi : forward_range<Rng> &&
-                   view_<Rng> ? mode::forward : mode::invalid;*/
-            }
-
-            template<typename Rng>
-            using mode_of = mode_t<drop_last_view::get_mode<Rng>()>;
-        } // namespace drop_last_view
-    }     // namespace detail
-    /// \endcond
-
-    template<typename Rng, typename = detail::drop_last_view::mode_of<Rng>>
-    struct drop_last_view
-    {};
-
-    template<typename Rng>
-    struct drop_last_view<Rng, detail::drop_last_view::mode_bidi>
-      : view_interface<drop_last_view<Rng, detail::drop_last_view::mode_bidi>,
-                       is_finite<Rng>::value
-                           ? finite
-                           : range_cardinality<Rng>::value> // finite at best
-    {
-        CPP_assert(
-            (random_access_range<Rng> && view_<Rng> && sized_range<Rng>) ||
-            (bidirectional_range<Rng> && view_<Rng> && common_range<Rng>));
-
-    private:
-        friend range_access;
-        using difference_t = range_difference_t<Rng>;
-
-        Rng rng_;
-        difference_t n_;
-        detail::non_propagating_cache<iterator_t<Rng>> end_;
-
-    public:
-        drop_last_view() = default;
-        constexpr drop_last_view(Rng rng, difference_t n)
-          : rng_(std::move(rng))
-          , n_(n)
-        {
-            RANGES_EXPECT(n >= 0);
-        }
-
-        iterator_t<Rng> begin()
-        {
-            return ranges::begin(rng_);
-        }
-        sentinel_t<Rng> end()
-        {
-            if(!end_)
-                end_ = detail::drop_last_view::get_end(rng_, n_, 0);
-            return *end_;
-        }
-        template(typename CRng = Rng const)(
-            /// \pre
-            requires random_access_range<CRng> AND sized_range<CRng>)
-        iterator_t<CRng> begin() const
-        {
-            return ranges::begin(rng_);
-        }
-        template(typename CRng = Rng const)(
-            /// \pre
-            requires random_access_range<CRng> AND sized_range<CRng>)
-        iterator_t<CRng> end() const
-        {
-            return detail::drop_last_view::get_end(rng_, n_, 0);
-        }
-
-        CPP_member
-        auto CPP_fun(size)()(
-            /// \pre
-            requires sized_range<Rng>)
-        {
-            return detail::drop_last_view::get_size(rng_, n_);
-        }
-        CPP_member
-        auto CPP_fun(size)()(const //
-            requires sized_range<Rng const>)
-        {
-            return detail::drop_last_view::get_size(rng_, n_);
-        }
-
-        Rng & base()
-        {
-            return rng_;
-        }
-        Rng const & base() const
-        {
-            return rng_;
-        }
-    };
-
-    template<typename Rng>
-    struct drop_last_view<Rng, detail::drop_last_view::mode_forward>
-      : view_adaptor<drop_last_view<Rng, detail::drop_last_view::mode_forward>, Rng,
-                     is_finite<Rng>::value
-                         ? finite
-                         : range_cardinality<Rng>::value> // finite at best (but
-                                                          // unknown is expected)
-    {
-        CPP_assert(forward_range<Rng> && view_<Rng>);
-
-    private:
-        friend range_access;
-
-        using difference_t = range_difference_t<Rng>;
-        difference_t n_;
-        detail::non_propagating_cache<iterator_t<Rng>> probe_begin;
-
-        struct adaptor : adaptor_base
-        {
-            iterator_t<Rng> probe_;
-
-            adaptor() = default;
-            adaptor(iterator_t<Rng> probe_first)
-              : probe_(std::move(probe_first))
-            {}
-            void next(iterator_t<Rng> & it)
-            {
-                ++it;
-                ++probe_;
-            }
-        };
-
-        struct sentinel_adaptor : adaptor_base
-        {
-            template<typename I, typename S>
-            bool empty(I const &, adaptor const & ia, S const & s) const
-            {
-                return ia.probe_ == s;
-            }
-        };
-
-        adaptor begin_adaptor()
-        {
-            if(!probe_begin)
-                probe_begin = next(begin(this->base()), n_, end(this->base()));
-            return {*probe_begin};
-        }
-        sentinel_adaptor end_adaptor()
-        {
-            return {};
-        }
-
-    public:
-        drop_last_view() = default;
-        constexpr drop_last_view(Rng rng, difference_t n)
-          : drop_last_view::view_adaptor(std::move(rng))
-          , n_(n)
-        {
-            RANGES_EXPECT(n >= 0);
-        }
-
-        CPP_member
-        auto CPP_fun(size)()(
-            /// \pre
-            requires sized_range<Rng>)
-        {
-            return detail::drop_last_view::get_size(this->base(), n_);
-        }
-        CPP_member
-        auto CPP_fun(size)()(const //
-            requires sized_range<Rng const>)
-        {
-            return detail::drop_last_view::get_size(this->base(), n_);
-        }
-    };
-
-    template<typename Rng>
-    struct drop_last_view<Rng, detail::drop_last_view::mode_sized>
-      : view_interface<drop_last_view<Rng, detail::drop_last_view::mode_sized>, finite>
-    {
-        CPP_assert(sized_range<Rng> && view_<Rng>);
-
-    private:
-        friend range_access;
-
-        using difference_t = range_difference_t<Rng>;
-        Rng rng_;
-        difference_t n_;
-
-    public:
-        drop_last_view() = default;
-        constexpr drop_last_view(Rng rng, difference_t n)
-          : rng_(std::move(rng))
-          , n_(n)
-        {
-            RANGES_EXPECT(n >= 0);
-        }
-
-        counted_iterator<iterator_t<Rng>> begin()
-        {
-            return {ranges::begin(rng_), static_cast<difference_t>(size())};
-        }
-        template(typename CRng = Rng const)(
-            /// \pre
-            requires sized_range<CRng>)
-        counted_iterator<iterator_t<CRng>> begin() const
-        {
-            return {ranges::begin(rng_), static_cast<difference_t>(size())};
-        }
-        default_sentinel_t end() const
-        {
-            return {};
-        }
-        range_size_t<Rng> size()
-        {
-            return detail::drop_last_view::get_size(this->base(), n_);
-        }
-        CPP_member
-        auto CPP_fun(size)()(const //
-            requires sized_range<Rng const>)
-        {
-            return detail::drop_last_view::get_size(this->base(), n_);
-        }
-
-        Rng & base()
-        {
-            return rng_;
-        }
-        Rng const & base() const
-        {
-            return rng_;
-        }
-    };
-
-    template<typename Rng, typename T>
-    RANGES_INLINE_VAR constexpr bool enable_borrowed_range<drop_last_view<Rng, T>> = //
-        enable_borrowed_range<Rng>;
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template<typename Rng>
-    drop_last_view(Rng &&, range_difference_t<Rng>)
-        -> drop_last_view<views::all_t<Rng>>;
-#endif
-
-    namespace views
-    {
-        struct drop_last_base_fn
-        {
-            template(typename Rng)(
-                /// \pre
-                requires sized_range<Rng> || forward_range<Rng>)
-            constexpr auto operator()(Rng && rng, range_difference_t<Rng> n) const
-                -> drop_last_view<all_t<Rng>>
-            {
-                return {all(static_cast<Rng &&>(rng)), n};
-            }
-        };
-
-        struct drop_last_fn : drop_last_base_fn
-        {
-            using drop_last_base_fn::operator();
-
-            template(typename Int)(
-                /// \pre
-                requires detail::integer_like_<Int>)
-            constexpr auto operator()(Int n) const
-            {
-                return make_view_closure(bind_back(drop_last_base_fn{}, n));
-            }
-        };
-
-        RANGES_INLINE_VARIABLE(drop_last_fn, drop_last)
-    } // namespace views
-
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::drop_last_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/drop_while.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/drop_while.hpp
deleted file mode 100644
index 3b06e8c0..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/drop_while.hpp
+++ /dev/null
@@ -1,170 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_DROP_WHILE_HPP
-#define RANGES_V3_VIEW_DROP_WHILE_HPP
-
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/find_if_not.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/functional/compose.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/optional.hpp>
-#include <range/v3/utility/semiregular_box.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/interface.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    template<typename Rng, typename Pred>
-    struct drop_while_view
-      : view_interface<drop_while_view<Rng, Pred>,
-                       is_finite<Rng>::value ? finite : unknown>
-    {
-    private:
-        Rng rng_;
-        RANGES_NO_UNIQUE_ADDRESS semiregular_box_t<Pred> pred_;
-        detail::non_propagating_cache<iterator_t<Rng>> begin_;
-
-        iterator_t<Rng> get_begin_()
-        {
-            if(!begin_)
-                begin_ = find_if_not(rng_, std::ref(pred_));
-            return *begin_;
-        }
-
-    public:
-        drop_while_view() = default;
-        drop_while_view(Rng rng, Pred pred)
-          : rng_(std::move(rng))
-          , pred_(std::move(pred))
-        {}
-        iterator_t<Rng> begin()
-        {
-            return get_begin_();
-        }
-        sentinel_t<Rng> end()
-        {
-            return ranges::end(rng_);
-        }
-        Rng base() const
-        {
-            return rng_;
-        }
-    };
-
-    // unlike take_while_view, drop_while_view is transparently safe because we only
-    // need the predicate to find begin()
-    template<typename Rng, typename Pred>
-    RANGES_INLINE_VAR constexpr bool enable_borrowed_range<drop_while_view<Rng, Pred>> =
-        enable_borrowed_range<Rng>;
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template(typename Rng, typename Fun)(
-        /// \pre
-        requires copy_constructible<Fun>)
-    drop_while_view(Rng &&, Fun)
-        -> drop_while_view<views::all_t<Rng>, Fun>;
-#endif
-
-    template<typename Rng, typename Pred>
-    RANGES_INLINE_VAR constexpr bool disable_sized_range<drop_while_view<Rng, Pred>> =
-        true;
-
-    namespace views
-    {
-        struct drop_while_base_fn
-        {
-            template(typename Rng, typename Pred)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng> AND
-                    indirect_unary_predicate<Pred, iterator_t<Rng>>)
-            auto operator()(Rng && rng, Pred pred) const
-                -> drop_while_view<all_t<Rng>, Pred>
-            {
-                return {all(static_cast<Rng &&>(rng)), std::move(pred)};
-            }
-            template(typename Rng, typename Pred, typename Proj)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng> AND
-                    indirect_unary_predicate<composed<Pred, Proj>, iterator_t<Rng>>)
-            auto operator()(Rng && rng, Pred pred, Proj proj) const
-                -> drop_while_view<all_t<Rng>, composed<Pred, Proj>>
-            {
-                return {all(static_cast<Rng &&>(rng)),
-                        compose(std::move(pred), std::move(proj))};
-            }
-        };
-
-        struct drop_while_bind_fn
-        {
-            template<typename Pred>
-            constexpr auto operator()(Pred pred) const // TODO: underconstrained
-            {
-                return make_view_closure(
-                    bind_back(drop_while_base_fn{}, std::move(pred)));
-            }
-            template(typename Pred, typename Proj)(
-                /// \pre
-                requires (!range<Pred>)) // TODO: underconstrained
-            constexpr auto operator()(Pred && pred, Proj proj) const
-            {
-                return make_view_closure(bind_back(
-                    drop_while_base_fn{}, static_cast<Pred &&>(pred), std::move(proj)));
-            }
-        };
-
-        struct RANGES_EMPTY_BASES drop_while_fn
-           : drop_while_base_fn, drop_while_bind_fn
-        {
-            using drop_while_base_fn::operator();
-            using drop_while_bind_fn::operator();
-        };
-
-        /// \relates drop_while_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(drop_while_fn, drop_while)
-    } // namespace views
-
-    namespace cpp20
-    {
-        namespace views
-        {
-            using ranges::views::drop_while;
-        }
-        template(typename Rng, typename Pred)(
-            /// \pre
-            requires viewable_range<Rng> AND input_range<Rng> AND
-                indirect_unary_predicate<Pred, iterator_t<Rng>>)
-            using drop_while_view = ranges::drop_while_view<Rng, Pred>;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::drop_while_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/empty.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/empty.hpp
deleted file mode 100644
index f1e6dab4..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/empty.hpp
+++ /dev/null
@@ -1,86 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_EMPTY_HPP
-#define RANGES_V3_VIEW_EMPTY_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/view/interface.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    template<typename T>
-    struct empty_view : view_interface<empty_view<T>, (cardinality)0>
-    {
-        static_assert(std::is_object<T>::value,
-                      "The template parameter to empty_view must be an object type.");
-        empty_view() = default;
-        static constexpr T * begin() noexcept
-        {
-            return nullptr;
-        }
-        static constexpr T * end() noexcept
-        {
-            return nullptr;
-        }
-        static constexpr std::size_t size() noexcept
-        {
-            return 0u;
-        }
-        static constexpr T * data() noexcept
-        {
-            return nullptr;
-        }
-        RANGES_DEPRECATED(
-            "Replace views::empty<T>() with views::empty<>. "
-            "It is now a variable template.")
-        empty_view operator()() const
-        {
-            return *this;
-        }
-    };
-
-    template<typename T>
-    RANGES_INLINE_VAR constexpr bool enable_borrowed_range<empty_view<T>> = true;
-
-    namespace views
-    {
-        template<typename T>
-        RANGES_INLINE_VAR constexpr empty_view<T> empty{};
-    }
-
-    namespace cpp20
-    {
-        namespace views
-        {
-            using ranges::views::empty;
-        }
-        template(typename T)(
-            /// \pre
-            requires std::is_object<T>::value) //
-            using empty_view = ranges::empty_view<T>;
-    } // namespace cpp20
-
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::empty_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/enumerate.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/enumerate.hpp
deleted file mode 100644
index 8a88a78e..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/enumerate.hpp
+++ /dev/null
@@ -1,118 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Casey Carter 2018-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_ENUMERATE_HPP
-#define RANGES_V3_VIEW_ENUMERATE_HPP
-
-#include <range/v3/core.hpp>
-#include <range/v3/iterator/unreachable_sentinel.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/facade.hpp>
-#include <range/v3/view/zip.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        // Counts from zero up.
-        // See https://github.com/ericniebler/range-v3/issues/1141
-        // for why we don't just use iota_view.
-        template<typename Size, typename Diff>
-        struct index_view : view_facade<index_view<Size, Diff>, infinite>
-        {
-        private:
-            friend range_access;
-
-            struct cursor
-            {
-                using difference_type = Diff;
-
-            private:
-                friend range_access;
-                Size index_{0};
-
-                Size read() const
-                {
-                    return index_;
-                }
-                void next()
-                {
-                    ++index_;
-                }
-                bool equal(cursor const & that) const
-                {
-                    return that.index_ == index_;
-                }
-                void prev()
-                {
-                    --index_;
-                }
-                void advance(Diff n)
-                {
-                    index_ += static_cast<Size>(n);
-                }
-                Diff distance_to(cursor const & that) const
-                {
-                    return static_cast<Diff>(static_cast<Diff>(that.index_) -
-                                             static_cast<Diff>(index_));
-                }
-
-            public:
-                cursor() = default;
-            };
-            cursor begin_cursor() const
-            {
-                return cursor{};
-            }
-            unreachable_sentinel_t end_cursor() const
-            {
-                return unreachable;
-            }
-
-        public:
-            index_view() = default;
-        };
-    } // namespace detail
-    /// \endcond
-    /// \addtogroup group-views
-    /// @{
-    namespace views
-    {
-        /// Lazily pairs each element in a source range with
-        /// its corresponding index.
-        struct enumerate_fn
-        {
-            template(typename Rng)(
-                /// \pre
-                requires viewable_range<Rng>)
-            auto operator()(Rng && rng) const
-            {
-                using D = range_difference_t<Rng>;
-                using S = detail::iter_size_t<iterator_t<Rng>>;
-                return zip(detail::index_view<S, D>(), all(static_cast<Rng &&>(rng)));
-            }
-        };
-
-        /// \relates enumerate_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(view_closure<enumerate_fn>, enumerate)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/exclusive_scan.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/exclusive_scan.hpp
deleted file mode 100644
index f7950f2c..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/exclusive_scan.hpp
+++ /dev/null
@@ -1,200 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Mitsutaka Takeda 2018-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_EXCLUSIVE_SCAN_HPP
-#define RANGES_V3_VIEW_EXCLUSIVE_SCAN_HPP
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/arithmetic.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/view/adaptor.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    // clang-format off
-    template(typename Rng, typename T, typename Fun)(
-    concept (exclusive_scan_constraints_)(Rng, T, Fun),
-        invocable<Fun &, T, range_reference_t<Rng>> AND
-        assignable_from<T &, invoke_result_t<Fun &, T, range_reference_t<Rng>>>
-    );
-    template<typename Rng, typename T, typename Fun>
-    CPP_concept exclusive_scan_constraints =
-        viewable_range<Rng> && input_range<Rng> &&
-        copy_constructible<T> &&
-        CPP_concept_ref(ranges::exclusive_scan_constraints_, Rng, T, Fun);
-    // clang-format on
-
-    /// \addtogroup group-views
-    /// @{
-    template<typename Rng, typename T, typename Fun>
-    struct exclusive_scan_view : view_adaptor<exclusive_scan_view<Rng, T, Fun>, Rng>
-    {
-    private:
-        friend range_access;
-        CPP_assert(exclusive_scan_constraints<Rng, T, Fun>);
-
-        semiregular_box_t<T> init_;
-        semiregular_box_t<Fun> fun_;
-        using single_pass = meta::bool_<single_pass_iterator_<iterator_t<Rng>>>;
-        using use_sentinel_t = meta::bool_<!common_range<Rng> || single_pass{}>;
-
-        template<bool IsConst>
-        struct adaptor : adaptor_base
-        {
-        private:
-            friend struct adaptor<!IsConst>;
-            using exclusive_scan_view_t = meta::const_if_c<IsConst, exclusive_scan_view>;
-            using CRng = meta::const_if_c<IsConst, Rng>;
-            semiregular_box_t<T> sum_;
-            exclusive_scan_view_t * rng_;
-
-            // clang-format off
-            auto CPP_auto_fun(move_or_copy_init)(std::false_type)
-            (
-                return (rng_->init_)
-            )
-
-            // If the base range is single-pass, we can move the init value.
-            auto CPP_auto_fun(move_or_copy_init)(std::true_type)
-            (
-                return std::move(rng_->init_)
-            )
-                // clang-format on
-                public : using single_pass = exclusive_scan_view::single_pass;
-            adaptor() = default;
-            adaptor(exclusive_scan_view_t * rng)
-              : rng_(rng)
-            {}
-            template(bool Other)(
-                /// \pre
-                requires IsConst AND CPP_NOT(Other)) //
-            adaptor(adaptor<Other> that)
-              : rng_(that.rng_)
-            {}
-            iterator_t<CRng> begin(exclusive_scan_view_t &)
-            {
-                sum_ = move_or_copy_init(single_pass{});
-                return ranges::begin(rng_->base());
-            }
-            T read(iterator_t<CRng> const &) const
-            {
-                return sum_;
-            }
-            void next(iterator_t<CRng> & it)
-            {
-                RANGES_EXPECT(it != ranges::end(rng_->base()));
-                sum_ = invoke(rng_->fun_, static_cast<T &&>(std::move(sum_)), *it);
-                ++it;
-            }
-            void prev() = delete;
-        };
-
-        adaptor<false> begin_adaptor()
-        {
-            return {this};
-        }
-        meta::if_<use_sentinel_t, adaptor_base, adaptor<false>> end_adaptor()
-        {
-            return {this};
-        }
-        CPP_member
-        auto begin_adaptor() const //
-            -> CPP_ret(adaptor<true>)(
-                /// \pre
-                requires exclusive_scan_constraints<Rng const, T, Fun const>)
-        {
-            return {this};
-        }
-        CPP_member
-        auto end_adaptor() const
-            -> CPP_ret(meta::if_<use_sentinel_t, adaptor_base, adaptor<true>>)(
-                /// \pre
-                requires exclusive_scan_constraints<Rng const, T, Fun const>)
-        {
-            return {this};
-        }
-
-    public:
-        exclusive_scan_view() = default;
-        constexpr exclusive_scan_view(Rng rng, T init, Fun fun)
-          : exclusive_scan_view::view_adaptor{std::move(rng)}
-          , init_(std::move(init))
-          , fun_(std::move(fun))
-        {}
-        CPP_member
-        auto CPP_fun(size)()(const
-            /// \pre
-            requires sized_range<Rng const>)
-        {
-            return ranges::size(this->base());
-        }
-        CPP_member
-        auto CPP_fun(size)()(
-            /// \pre
-            requires sized_range<Rng>)
-        {
-            return ranges::size(this->base());
-        }
-    };
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template(typename Rng, typename T, typename Fun)(
-        /// \pre
-        requires copy_constructible<T> AND copy_constructible<Fun>)
-    exclusive_scan_view(Rng &&, T, Fun) //
-        -> exclusive_scan_view<views::all_t<Rng>, T, Fun>;
-#endif
-
-    namespace views
-    {
-        struct exclusive_scan_base_fn
-        {
-            template(typename Rng, typename T, typename Fun = plus)(
-                /// \pre
-                requires exclusive_scan_constraints<Rng, T, Fun>)
-            constexpr exclusive_scan_view<all_t<Rng>, T, Fun> //
-            operator()(Rng && rng, T init, Fun fun = Fun{}) const
-            {
-                return {all(static_cast<Rng &&>(rng)), std::move(init), std::move(fun)};
-            }
-        };
-
-        struct exclusive_scan_fn : exclusive_scan_base_fn
-        {
-            using exclusive_scan_base_fn::operator();
-
-            template<typename T, typename Fun = plus>
-            constexpr auto operator()(T init, Fun fun = {}) const
-            {
-                return make_view_closure(
-                    bind_back(exclusive_scan_base_fn{}, std::move(init), std::move(fun)));
-            }
-        };
-
-        /// \relates exclusive_scan_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(exclusive_scan_fn, exclusive_scan)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif // RANGES_V3_VIEW_EXCLUSIVE_SCAN_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/facade.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/facade.hpp
deleted file mode 100644
index 597c899c..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/facade.hpp
+++ /dev/null
@@ -1,141 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_VIEW_FACADE_HPP
-#define RANGES_V3_VIEW_FACADE_HPP
-
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/basic_iterator.hpp>
-#include <range/v3/iterator/default_sentinel.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/view/interface.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        template<typename Derived>
-        using begin_cursor_t = detail::decay_t<decltype(
-            range_access::begin_cursor(std::declval<Derived &>()))>;
-
-        template<typename Derived>
-        using end_cursor_t = detail::decay_t<decltype(
-            range_access::end_cursor(std::declval<Derived &>()))>;
-
-        template<typename Derived>
-        using facade_iterator_t = basic_iterator<begin_cursor_t<Derived>>;
-
-        template<typename Derived>
-        using facade_sentinel_t =
-            meta::if_c<same_as<begin_cursor_t<Derived>, end_cursor_t<Derived>>,
-                       facade_iterator_t<Derived>, end_cursor_t<Derived>>;
-    } // namespace detail
-    /// \endcond
-
-    /// \addtogroup group-views
-    /// @{
-
-    /// \brief A utility for constructing a view from a (derived) type that
-    /// implements begin and end cursors.
-    /// \tparam Derived A type that derives from `view_facade` and implements
-    /// begin and end cursors. This type is permitted to be incomplete.
-    /// \tparam Cardinality The cardinality of this view: `finite`, `infinite`,
-    /// or `unknown`. See `ranges::cardinality`.
-    template<typename Derived, cardinality Cardinality>
-    struct view_facade : view_interface<Derived, Cardinality>
-    {
-    protected:
-        friend range_access;
-        struct view_as_cursor : Derived
-        {
-            view_as_cursor() = default;
-            explicit view_as_cursor(Derived const * derived)
-              : Derived(*derived)
-            {}
-            explicit operator bool() = delete;
-            explicit operator bool() const = delete;
-        };
-        // Default implementations
-        constexpr view_as_cursor begin_cursor() const
-        {
-            return view_as_cursor{static_cast<Derived const *>(this)};
-        }
-        constexpr default_sentinel_t end_cursor() const
-        {
-            return {};
-        }
-
-    public:
-        /// Let `d` be `static_cast<Derived &>(*this)`. Let `b` be
-        /// `std::as_const(d).begin_cursor()` if that expression is well-formed;
-        /// otherwise, let `b` be `d.begin_cursor()`. Let `B` be the type of
-        /// `b`.
-        /// \return `ranges::basic_iterator<B>(b)`
-        template(typename D = Derived)(
-            /// \pre
-            requires same_as<D, Derived>)
-        constexpr auto begin() -> detail::facade_iterator_t<D>
-        {
-            return detail::facade_iterator_t<D>{
-                range_access::begin_cursor(*static_cast<Derived *>(this))};
-        }
-        /// \overload
-        template(typename D = Derived)(
-            /// \pre
-            requires same_as<D, Derived>)
-        constexpr auto begin() const -> detail::facade_iterator_t<D const>
-        {
-            return detail::facade_iterator_t<D const>{
-                range_access::begin_cursor(*static_cast<Derived const *>(this))};
-        }
-        /// Let `d` be `static_cast<Derived &>(*this)`. Let `e` be
-        /// `std::as_const(d).end_cursor()` if that expression is well-formed;
-        /// otherwise, let `e` be `d.end_cursor()`. Let `E` be the type of
-        /// `e`.
-        /// \return `ranges::basic_iterator<E>(e)` if `E` is the same
-        /// as `B` computed above for `begin()`; otherwise, return `e`.
-        template(typename D = Derived)(
-            /// \pre
-            requires same_as<D, Derived>)
-        constexpr auto end() -> detail::facade_sentinel_t<D>
-        {
-            return static_cast<detail::facade_sentinel_t<D>>(
-                range_access::end_cursor(*static_cast<Derived *>(this)));
-        }
-        /// \overload
-        template(typename D = Derived)(
-            /// \pre
-            requires same_as<D, Derived>)
-        constexpr auto end() const -> detail::facade_sentinel_t<D const>
-        {
-            return static_cast<detail::facade_sentinel_t<D const>>(
-                range_access::end_cursor(*static_cast<Derived const *>(this)));
-        }
-    };
-
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/filter.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/filter.hpp
deleted file mode 100644
index e7a712dc..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/filter.hpp
+++ /dev/null
@@ -1,144 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_FILTER_HPP
-#define RANGES_V3_VIEW_FILTER_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/functional/compose.hpp>
-#include <range/v3/functional/not_fn.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/remove_if.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    template<typename Rng, typename Pred>
-    struct filter_view : remove_if_view<Rng, logical_negate<Pred>>
-    {
-        filter_view() = default;
-        constexpr filter_view(Rng rng, Pred pred)
-          : filter_view::remove_if_view{std::move(rng), not_fn(std::move(pred))}
-        {}
-    };
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template(typename Rng, typename Pred)(
-        /// \pre
-        requires input_range<Rng> AND indirect_unary_predicate<Pred, iterator_t<Rng>> AND
-            view_<Rng> AND std::is_object<Pred>::value) //
-        filter_view(Rng &&, Pred)
-            ->filter_view<views::all_t<Rng>, Pred>;
-#endif
-
-    namespace views
-    {
-        struct filter_fn;
-
-        /// Given a source range and a unary predicate,
-        /// present a view of the elements that satisfy the predicate.
-        struct cpp20_filter_base_fn
-        {
-            template(typename Rng, typename Pred)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng> AND
-                    indirect_unary_predicate<Pred, iterator_t<Rng>>)
-            constexpr filter_view<all_t<Rng>, Pred> operator()(Rng && rng, Pred pred) //
-                const
-            {
-                return filter_view<all_t<Rng>, Pred>{all(static_cast<Rng &&>(rng)),
-                                                     std::move(pred)};
-            }
-        };
-
-        struct cpp20_filter_fn : cpp20_filter_base_fn
-        {
-            using cpp20_filter_base_fn::operator();
-
-            template<typename Pred>
-            constexpr auto operator()(Pred pred) const
-            {
-                return make_view_closure(
-                    bind_back(cpp20_filter_base_fn{}, std::move(pred)));
-            }
-        };
-
-        /// Given a source range, unary predicate, and optional projection,
-        /// present a view of the elements that satisfy the predicate.
-        struct filter_base_fn : cpp20_filter_base_fn
-        {
-            using cpp20_filter_base_fn::operator();
-
-            template(typename Rng, typename Pred, typename Proj)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng> AND
-                    indirect_unary_predicate<Pred, projected<iterator_t<Rng>, Proj>>)
-            constexpr filter_view<all_t<Rng>, composed<Pred, Proj>> //
-            operator()(Rng && rng, Pred pred, Proj proj) const
-            {
-                return filter_view<all_t<Rng>, composed<Pred, Proj>>{
-                    all(static_cast<Rng &&>(rng)),
-                    compose(std::move(pred), std::move(proj))};
-            }
-        };
-
-        struct filter_fn : filter_base_fn
-        {
-            using filter_base_fn::operator();
-
-            template<typename Pred>
-            constexpr auto operator()(Pred pred) const
-            {
-                return make_view_closure(bind_back(filter_base_fn{}, std::move(pred)));
-            }
-
-            template(typename Pred, typename Proj)(
-                /// \pre
-                requires (!range<Pred>))
-            constexpr auto operator()(Pred pred, Proj proj) const
-            {
-                return make_view_closure(
-                    bind_back(filter_base_fn{}, std::move(pred), std::move(proj)));
-            }
-        };
-
-        /// \relates filter_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(filter_fn, filter)
-    } // namespace views
-
-    namespace cpp20
-    {
-        namespace views
-        {
-            RANGES_INLINE_VARIABLE(ranges::views::cpp20_filter_fn, filter)
-        }
-        template(typename V, typename Pred)(
-            /// \pre
-            requires input_range<V> AND indirect_unary_predicate<Pred, iterator_t<V>> AND
-                view_<V> AND std::is_object<Pred>::value) //
-            using filter_view = ranges::filter_view<V, Pred>;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::filter_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/for_each.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/for_each.hpp
deleted file mode 100644
index 82b4e9be..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/for_each.hpp
+++ /dev/null
@@ -1,143 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_FOR_EACH_HPP
-#define RANGES_V3_VIEW_FOR_EACH_HPP
-
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/generate_n.hpp>
-#include <range/v3/view/join.hpp>
-#include <range/v3/view/repeat_n.hpp>
-#include <range/v3/view/single.hpp>
-#include <range/v3/view/transform.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-
-    namespace views
-    {
-        /// Lazily applies an unary function to each element in the source
-        /// range that returns another range (possibly empty), flattening
-        /// the result.
-        struct for_each_base_fn
-        {
-            template(typename Rng, typename Fun)(
-                /// \pre
-                requires viewable_range<Rng> AND transformable_range<Rng, Fun> AND
-                    joinable_range<transform_view<all_t<Rng>, Fun>>)
-            constexpr auto operator()(Rng && rng, Fun fun) const
-            {
-                return join(transform(static_cast<Rng &&>(rng), std::move(fun)));
-            }
-        };
-
-        struct for_each_fn : for_each_base_fn
-        {
-            using for_each_base_fn::operator();
-
-            template<typename Fun>
-            constexpr auto operator()(Fun fun) const
-            {
-                return make_view_closure(bind_back(for_each_base_fn{}, std::move(fun)));
-            }
-        };
-
-        /// \relates for_each_fn
-        RANGES_INLINE_VARIABLE(for_each_fn, for_each)
-    } // namespace views
-
-    struct yield_fn
-    {
-        template(typename V)(
-            /// \pre
-            requires copy_constructible<V>)
-        single_view<V> operator()(V v) const
-        {
-            return views::single(std::move(v));
-        }
-    };
-
-    /// \relates yield_fn
-    RANGES_INLINE_VARIABLE(yield_fn, yield)
-
-    struct yield_from_fn
-    {
-        template(typename Rng)(
-            /// \pre
-            requires view_<Rng>)
-        Rng operator()(Rng rng) const
-        {
-            return rng;
-        }
-    };
-
-    /// \relates yield_from_fn
-    RANGES_INLINE_VARIABLE(yield_from_fn, yield_from)
-
-    struct yield_if_fn
-    {
-        template<typename V>
-        repeat_n_view<V> operator()(bool b, V v) const
-        {
-            return views::repeat_n(std::move(v), b ? 1 : 0);
-        }
-    };
-
-    /// \relates yield_if_fn
-    RANGES_INLINE_VARIABLE(yield_if_fn, yield_if)
-
-    struct lazy_yield_if_fn
-    {
-        template(typename F)(
-            /// \pre
-            requires invocable<F &>)
-        generate_n_view<F> operator()(bool b, F f) const
-        {
-            return views::generate_n(std::move(f), b ? 1 : 0);
-        }
-    };
-
-    /// \relates lazy_yield_if_fn
-    RANGES_INLINE_VARIABLE(lazy_yield_if_fn, lazy_yield_if)
-    /// @}
-
-    /// \cond
-    template(typename Rng, typename Fun)(
-        /// \pre
-        requires viewable_range<Rng> AND views::transformable_range<Rng, Fun> AND
-            input_range<invoke_result_t<Fun &, range_reference_t<Rng>>>)
-        auto
-        operator>>=(Rng && rng, Fun fun)
-    {
-        return views::for_each(static_cast<Rng &&>(rng), std::move(fun));
-    }
-    /// \endcond
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/generate.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/generate.hpp
deleted file mode 100644
index 22040e94..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/generate.hpp
+++ /dev/null
@@ -1,121 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_GENERATE_HPP
-#define RANGES_V3_VIEW_GENERATE_HPP
-
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/unreachable_sentinel.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/optional.hpp>
-#include <range/v3/utility/semiregular_box.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/facade.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    template<typename G>
-    struct generate_view : view_facade<generate_view<G>, infinite>
-    {
-    private:
-        friend range_access;
-        using result_t = invoke_result_t<G &>;
-        semiregular_box_t<G> gen_;
-        detail::non_propagating_cache<result_t> val_;
-        struct cursor
-        {
-        private:
-            generate_view * view_;
-
-        public:
-            cursor() = default;
-            explicit cursor(generate_view * view)
-              : view_(view)
-            {}
-            result_t && read() const
-            {
-                if(!view_->val_)
-                    view_->val_.emplace(view_->gen_());
-                return static_cast<result_t &&>(static_cast<result_t &>(*view_->val_));
-            }
-            void next()
-            {
-                if(view_->val_)
-                    view_->val_.reset();
-                else
-                    static_cast<void>(view_->gen_());
-            }
-        };
-        cursor begin_cursor()
-        {
-            return cursor{this};
-        }
-        unreachable_sentinel_t end_cursor() const
-        {
-            return {};
-        }
-
-    public:
-        generate_view() = default;
-        explicit generate_view(G g)
-          : gen_(std::move(g))
-        {}
-        result_t & cached()
-        {
-            return *val_;
-        }
-    };
-
-    namespace views
-    {
-        struct generate_fn
-        {
-            template(typename G)(
-                /// \pre
-                requires invocable<G &> AND copy_constructible<G> AND
-                    std::is_object<detail::decay_t<invoke_result_t<G &>>>::value AND
-                    constructible_from<detail::decay_t<invoke_result_t<G &>>,
-                                       invoke_result_t<G &>> AND
-                    assignable_from<detail::decay_t<invoke_result_t<G &>> &,
-                                    invoke_result_t<G &>>)
-            generate_view<G> operator()(G g) const
-            {
-                return generate_view<G>{std::move(g)};
-            }
-        };
-
-        /// \relates generate_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(generate_fn, generate)
-    } // namespace views
-    /// \@}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::generate_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/generate_n.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/generate_n.hpp
deleted file mode 100644
index 23791314..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/generate_n.hpp
+++ /dev/null
@@ -1,128 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_GENERATE_N_HPP
-#define RANGES_V3_VIEW_GENERATE_N_HPP
-
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/default_sentinel.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/semiregular_box.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/facade.hpp>
-#include <range/v3/view/generate.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    template<typename G>
-    struct generate_n_view : view_facade<generate_n_view<G>, finite>
-    {
-    private:
-        friend range_access;
-        using result_t = invoke_result_t<G &>;
-        semiregular_box_t<G> gen_;
-        detail::non_propagating_cache<result_t> val_;
-        std::size_t n_;
-        struct cursor
-        {
-        private:
-            generate_n_view * rng_;
-
-        public:
-            cursor() = default;
-            explicit cursor(generate_n_view * rng)
-              : rng_(rng)
-            {}
-            bool equal(default_sentinel_t) const
-            {
-                return 0 == rng_->n_;
-            }
-            result_t && read() const
-            {
-                if(!rng_->val_)
-                    rng_->val_.emplace(rng_->gen_());
-                return static_cast<result_t &&>(static_cast<result_t &>(*rng_->val_));
-            }
-            void next()
-            {
-                RANGES_EXPECT(0 != rng_->n_);
-                if(rng_->val_)
-                    rng_->val_.reset();
-                else
-                    static_cast<void>(rng_->gen_());
-                --rng_->n_;
-            }
-        };
-        cursor begin_cursor()
-        {
-            return cursor{this};
-        }
-
-    public:
-        generate_n_view() = default;
-        explicit generate_n_view(G g, std::size_t n)
-          : gen_(std::move(g))
-          , n_(n)
-        {}
-        result_t & cached()
-        {
-            return *val_;
-        }
-        std::size_t size() const
-        {
-            return n_;
-        }
-    };
-
-    namespace views
-    {
-        struct generate_n_fn
-        {
-            template(typename G)(
-                /// \pre
-                requires invocable<G &> AND copy_constructible<G> AND
-                    std::is_object<detail::decay_t<invoke_result_t<G &>>>::value AND
-                    constructible_from<detail::decay_t<invoke_result_t<G &>>,
-                                       invoke_result_t<G &>> AND
-                    assignable_from<detail::decay_t<invoke_result_t<G &>> &,
-                                    invoke_result_t<G &>>)
-            generate_n_view<G> operator()(G g, std::size_t n) const
-            {
-                return generate_n_view<G>{std::move(g), n};
-            }
-        };
-
-        /// \relates generate_n_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(generate_n_fn, generate_n)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::generate_n_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/getlines.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/getlines.hpp
deleted file mode 100644
index 7f0c10f5..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/getlines.hpp
+++ /dev/null
@@ -1,112 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_GETLINES_HPP
-#define RANGES_V3_VIEW_GETLINES_HPP
-
-#include <istream>
-#include <string>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/default_sentinel.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/facade.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    struct getlines_view : view_facade<getlines_view, unknown>
-    {
-    private:
-        friend range_access;
-        std::istream * sin_;
-        std::string str_;
-        char delim_;
-        struct cursor
-        {
-        private:
-            friend range_access;
-            using single_pass = std::true_type;
-            getlines_view * rng_ = nullptr;
-
-        public:
-            cursor() = default;
-            explicit cursor(getlines_view * rng)
-              : rng_(rng)
-            {}
-            void next()
-            {
-                rng_->next();
-            }
-            std::string & read() const noexcept
-            {
-                return rng_->str_;
-            }
-            bool equal(default_sentinel_t) const
-            {
-                return !rng_->sin_;
-            }
-            bool equal(cursor that) const
-            {
-                return !rng_->sin_ == !that.rng_->sin_;
-            }
-        };
-        void next()
-        {
-            if(!std::getline(*sin_, str_, delim_))
-                sin_ = nullptr;
-        }
-        cursor begin_cursor()
-        {
-            return cursor{this};
-        }
-
-    public:
-        getlines_view() = default;
-        getlines_view(std::istream & sin, char delim = '\n')
-          : sin_(&sin)
-          , str_{}
-          , delim_(delim)
-        {
-            this->next(); // prime the pump
-        }
-        std::string & cached() noexcept
-        {
-            return str_;
-        }
-    };
-
-    /// \cond
-    using getlines_range RANGES_DEPRECATED(
-        "getlines_range has been renamed getlines_view") = getlines_view;
-    /// \endcond
-
-    struct getlines_fn
-    {
-        getlines_view operator()(std::istream & sin, char delim = '\n') const
-        {
-            return getlines_view{sin, delim};
-        }
-    };
-
-    RANGES_INLINE_VARIABLE(getlines_fn, getlines)
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/group_by.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/group_by.hpp
deleted file mode 100644
index 4c2af292..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/group_by.hpp
+++ /dev/null
@@ -1,206 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_GROUP_BY_HPP
-#define RANGES_V3_VIEW_GROUP_BY_HPP
-
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/find_if_not.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/default_sentinel.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/optional.hpp>
-#include <range/v3/utility/semiregular_box.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/facade.hpp>
-#include <range/v3/view/subrange.hpp>
-#include <range/v3/view/take_while.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    // TODO group_by could support Input ranges by keeping mutable state in
-    // the range itself. The group_by view would then be mutable-only and
-    // Input.
-
-    /// \addtogroup group-views
-    /// @{
-    template<typename Rng, typename Fun>
-    struct group_by_view
-      : view_facade<group_by_view<Rng, Fun>,
-                    is_finite<Rng>::value ? finite : range_cardinality<Rng>::value>
-    {
-    private:
-        friend range_access;
-        Rng rng_;
-        // cached version of the end of the first subrange / start of the second subrange
-        detail::non_propagating_cache<iterator_t<Rng>> second_;
-        semiregular_box_t<Fun> fun_;
-
-        struct pred
-        {
-            iterator_t<Rng> first_;
-            semiregular_box_ref_or_val_t<Fun, false> fun_;
-            bool operator()(range_reference_t<Rng> r) const
-            {
-                return invoke(fun_, *first_, r);
-            }
-        };
-
-        struct cursor
-        {
-        private:
-            friend range_access;
-            friend group_by_view;
-            iterator_t<Rng> cur_;
-            iterator_t<Rng> next_cur_;
-            sentinel_t<Rng> last_;
-            semiregular_box_ref_or_val_t<Fun, false> fun_;
-
-            struct mixin : basic_mixin<cursor>
-            {
-                mixin() = default;
-                #ifndef _MSC_VER
-                using basic_mixin<cursor>::basic_mixin;
-                #else
-                constexpr explicit mixin(cursor && cur)
-                  : basic_mixin<cursor>(static_cast<cursor &&>(cur))
-                {}
-                constexpr explicit mixin(cursor const & cur)
-                  : basic_mixin<cursor>(cur)
-                {}
-                #endif
-                iterator_t<Rng> base() const
-                {
-                    return this->get().cur_;
-                }
-            };
-
-            #ifdef _MSC_VER
-            template<typename I = iterator_t<Rng>>
-            subrange<I> read() const
-            {
-                return {cur_, next_cur_};
-            }
-            #else
-            subrange<iterator_t<Rng>> read() const
-            {
-                return {cur_, next_cur_};
-            }
-            #endif
-            void next()
-            {
-                cur_ = next_cur_;
-                next_cur_ = cur_ != last_
-                                ? find_if_not(ranges::next(cur_), last_, pred{cur_, fun_})
-                                : cur_;
-            }
-
-            bool equal(default_sentinel_t) const
-            {
-                return cur_ == last_;
-            }
-            bool equal(cursor const & that) const
-            {
-                return cur_ == that.cur_;
-            }
-            cursor(semiregular_box_ref_or_val_t<Fun, false> fun, iterator_t<Rng> first,
-                   iterator_t<Rng> next_cur, sentinel_t<Rng> last)
-              : cur_(first)
-              , next_cur_(next_cur)
-              , last_(last)
-              , fun_(fun)
-            {}
-
-        public:
-            cursor() = default;
-        };
-        cursor begin_cursor()
-        {
-            auto b = ranges::begin(rng_);
-            auto e = ranges::end(rng_);
-            if(!second_)
-            {
-                second_ = b != e ? find_if_not(ranges::next(b), e, pred{b, fun_}) : b;
-            }
-            return {fun_, b, *second_, e};
-        }
-
-    public:
-        group_by_view() = default;
-        constexpr group_by_view(Rng rng, Fun fun)
-          : rng_(std::move(rng))
-          , fun_(std::move(fun))
-        {}
-        Rng base() const
-        {
-            return rng_;
-        }
-    };
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template(typename Rng, typename Fun)(
-        /// \pre
-        requires copy_constructible<Fun>)
-        group_by_view(Rng &&, Fun)
-            ->group_by_view<views::all_t<Rng>, Fun>;
-#endif
-
-    namespace views
-    {
-        struct group_by_base_fn
-        {
-            template(typename Rng, typename Fun)(
-                /// \pre
-                requires viewable_range<Rng> AND forward_range<Rng> AND
-                    indirect_relation<Fun, iterator_t<Rng>>)
-            constexpr group_by_view<all_t<Rng>, Fun> operator()(Rng && rng, Fun fun) const
-            {
-                return {all(static_cast<Rng &&>(rng)), std::move(fun)};
-            }
-        };
-
-        struct group_by_fn : group_by_base_fn
-        {
-            using group_by_base_fn::operator();
-
-            template<typename Fun>
-            constexpr auto operator()(Fun fun) const
-            {
-                return make_view_closure(bind_back(group_by_base_fn{}, std::move(fun)));
-            }
-        };
-
-        /// \relates group_by_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(group_by_fn, group_by)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::group_by_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/indices.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/indices.hpp
deleted file mode 100644
index 7c5dda72..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/indices.hpp
+++ /dev/null
@@ -1,84 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//  Copyright Gonzalo Brito Gadeschi
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_INDICES_HPP
-#define RANGES_V3_VIEW_INDICES_HPP
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/iota.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    namespace views
-    {
-        /// Half-open range of indices: [from, to).
-        struct indices_fn : iota_view<std::size_t>
-        {
-            indices_fn() = default;
-
-            template(typename Val)(
-                /// \pre
-                requires integral<Val>)
-            iota_view<Val, Val> operator()(Val to) const
-            {
-                return {Val(), to};
-            }
-            template(typename Val)(
-                /// \pre
-                requires integral<Val>)
-            iota_view<Val, Val> operator()(Val from, Val to) const
-            {
-                return {from, to};
-            }
-        };
-
-        /// Inclusive range of indices: [from, to].
-        struct closed_indices_fn
-        {
-            template(typename Val)(
-                /// \pre
-                requires integral<Val>)
-            closed_iota_view<Val> operator()(Val to) const
-            {
-                return {Val(), to};
-            }
-            template(typename Val)(
-                /// \pre
-                requires integral<Val>)
-            closed_iota_view<Val> operator()(Val from, Val to) const
-            {
-                return {from, to};
-            }
-        };
-
-        /// \relates indices_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(indices_fn, indices)
-
-        /// \relates closed_indices_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(closed_indices_fn, closed_indices)
-    } // namespace views
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif // RANGES_V3_VIEW_INDICES_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/indirect.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/indirect.hpp
deleted file mode 100644
index 4c7484ad..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/indirect.hpp
+++ /dev/null
@@ -1,163 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_INDIRECT_HPP
-#define RANGES_V3_VIEW_INDIRECT_HPP
-
-#include <iterator>
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/move.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/adaptor.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    template<typename Rng>
-    struct indirect_view : view_adaptor<indirect_view<Rng>, Rng>
-    {
-    private:
-        friend range_access;
-
-        template<bool IsConst>
-        struct adaptor : adaptor_base
-        {
-            friend adaptor<!IsConst>;
-            using CRng = meta::const_if_c<IsConst, Rng>;
-
-            adaptor() = default;
-            template(bool Other)(
-                /// \pre
-                requires IsConst && CPP_NOT(Other)) //
-            constexpr adaptor(adaptor<Other>) noexcept
-            {}
-
-            // clang-format off
-            constexpr auto CPP_auto_fun(read)(iterator_t<CRng> const &it)(const)
-            (
-                return **it
-            )
-            constexpr auto CPP_auto_fun(iter_move)(iterator_t<CRng> const &it)(const)
-            (
-                return ranges::iter_move(*it)
-            )
-            // clang-format on
-        };
-
-        CPP_member
-        constexpr auto begin_adaptor() noexcept //
-            -> CPP_ret(adaptor<false>)(
-                /// \pre
-                requires (!simple_view<Rng>()))
-        {
-            return {};
-        }
-        CPP_member
-        constexpr auto begin_adaptor() const noexcept //
-            -> CPP_ret(adaptor<true>)(
-                /// \pre
-                requires range<Rng const>)
-        {
-            return {};
-        }
-
-        CPP_member
-        constexpr auto end_adaptor() noexcept //
-            -> CPP_ret(adaptor<false>)(
-                /// \pre
-                requires (!simple_view<Rng>()))
-        {
-            return {};
-        }
-        CPP_member
-        constexpr auto end_adaptor() const noexcept //
-            -> CPP_ret(adaptor<true>)(
-                /// \pre
-                requires range<Rng const>)
-        {
-            return {};
-        }
-
-    public:
-        indirect_view() = default;
-        constexpr explicit indirect_view(Rng rng)
-          : indirect_view::view_adaptor{detail::move(rng)}
-        {}
-        CPP_member
-        constexpr auto CPP_fun(size)()(const //
-            requires sized_range<Rng const>)
-        {
-            return ranges::size(this->base());
-        }
-        CPP_member
-        constexpr auto CPP_fun(size)()(
-            /// \pre
-            requires sized_range<Rng>)
-        {
-            return ranges::size(this->base());
-        }
-    };
-
-    template<typename Rng>
-    RANGES_INLINE_VAR constexpr bool enable_borrowed_range<indirect_view<Rng>> = //
-        enable_borrowed_range<Rng>;
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template<typename Rng>
-    indirect_view(Rng &&) //
-        -> indirect_view<views::all_t<Rng>>;
-#endif
-
-    namespace views
-    {
-        struct indirect_fn
-        {
-            template(typename Rng)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng> AND
-                // We shouldn't need to strip references to test if something
-                // is readable. https://github.com/ericniebler/stl2/issues/594
-                // indirectly_readable<range_reference_t<Rng>>)
-                ((bool)indirectly_readable<range_value_t<Rng>>)) // Cast to bool needed
-                                                                 // for GCC (???))
-            constexpr auto operator()(Rng && rng) const
-            {
-                return indirect_view<all_t<Rng>>{all(static_cast<Rng &&>(rng))};
-            }
-        };
-
-        /// \relates indirect_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(view_closure<indirect_fn>, indirect)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::indirect_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/interface.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/interface.hpp
deleted file mode 100644
index 6c63dbf5..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/interface.hpp
+++ /dev/null
@@ -1,551 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_VIEW_INTERFACE_HPP
-#define RANGES_V3_VIEW_INTERFACE_HPP
-
-#include <iosfwd>
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/common_iterator.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/range/traits.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-#if defined(RANGES_WORKAROUND_GCC_91525)
-#define CPP_template_gcc_workaround CPP_template_sfinae
-#else
-#define CPP_template_gcc_workaround template
-#endif
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        template<typename From, typename To = From>
-        struct slice_bounds
-        {
-            From from;
-            To to;
-            template(typename F, typename T)(
-                /// \pre
-                requires convertible_to<F, From> AND convertible_to<T, To>)
-            constexpr slice_bounds(F f, T t)
-              : from(static_cast<From>(f))
-              , to(static_cast<To>(t))
-            {}
-        };
-
-        template<typename Int>
-        struct from_end_
-        {
-            Int dist_;
-
-            constexpr explicit from_end_(Int dist)
-              : dist_(dist)
-            {}
-
-            template(typename Other)(
-                /// \pre
-                requires integer_like_<Other> AND explicitly_convertible_to<Other, Int>)
-            constexpr operator from_end_<Other>() const
-            {
-                return from_end_<Other>{static_cast<Other>(dist_)};
-            }
-        };
-
-        template<typename Rng>
-        using from_end_of_t = from_end_<range_difference_t<Rng>>;
-
-        // clang-format off
-        template<typename Rng>
-        CPP_requires(_can_empty_,
-            requires(Rng & rng) //
-            (
-                ranges::empty(rng)
-            ));
-        template<typename Rng>
-        CPP_concept can_empty_ = //
-            CPP_requires_ref(detail::_can_empty_, Rng);
-        // clang-format on
-
-        template<cardinality C>
-        RANGES_INLINE_VAR constexpr bool has_fixed_size_ = (C >= 0 || C == infinite);
-
-        template<bool>
-        struct dependent_
-        {
-            template<typename T>
-            using invoke = T;
-        };
-
-        template<typename Stream, typename Rng>
-        Stream & print_rng_(Stream & sout, Rng & rng)
-        {
-            sout << '[';
-            auto it = ranges::begin(rng);
-            auto const e = ranges::end(rng);
-            if(it != e)
-            {
-                for(;;)
-                {
-                    sout << *it;
-                    if(++it == e)
-                        break;
-                    sout << ',';
-                }
-            }
-            sout << ']';
-            return sout;
-        }
-    } // namespace detail
-    /// \endcond
-
-    /// \addtogroup group-views
-    /// @{
-    template<typename Derived, cardinality Cardinality /* = finite*/>
-    struct view_interface : basic_view<Cardinality>
-    {
-    protected:
-        template<bool B>
-        using D = meta::invoke<detail::dependent_<B>, Derived>;
-
-        constexpr Derived & derived() noexcept
-        {
-            CPP_assert(derived_from<Derived, view_interface>);
-            return static_cast<Derived &>(*this);
-        }
-        /// \overload
-        constexpr Derived const & derived() const noexcept
-        {
-            CPP_assert(derived_from<Derived, view_interface>);
-            return static_cast<Derived const &>(*this);
-        }
-
-    public:
-        view_interface() = default;
-        view_interface(view_interface &&) = default;
-        view_interface(view_interface const &) = default;
-        view_interface & operator=(view_interface &&) = default;
-        view_interface & operator=(view_interface const &) = default;
-        /// \brief Test whether a range can be empty:
-        CPP_member
-        constexpr auto empty() const noexcept //
-            -> CPP_ret(bool)(
-                /// \pre
-                requires (detail::has_fixed_size_<Cardinality>))
-        {
-            return Cardinality == 0;
-        }
-        /// \overload
-        template(bool True = true)(
-            /// \pre
-            requires True AND (Cardinality < 0) AND (Cardinality != infinite) AND
-                (!forward_range<D<True>>) AND sized_range<D<True>>)
-        constexpr bool empty() //
-            noexcept(noexcept(bool(ranges::size(std::declval<D<True> &>()) == 0)))
-        {
-            return ranges::size(derived()) == 0;
-        }
-        /// \overload
-        template(bool True = true)(
-            /// \pre
-            requires True AND (Cardinality < 0) AND (Cardinality != infinite) AND
-                (!forward_range<D<True> const>) AND sized_range<D<True> const>)
-        constexpr bool empty() const //
-            noexcept(noexcept(bool(ranges::size(std::declval<D<True> const &>()) == 0)))
-        {
-            return ranges::size(derived()) == 0;
-        }
-        /// \overload
-        template(bool True = true)(
-            /// \pre
-            requires True AND (!detail::has_fixed_size_<Cardinality>) AND
-                forward_range<D<True>>)
-        constexpr bool empty() noexcept(
-            noexcept(bool(ranges::begin(std::declval<D<True> &>()) ==
-                          ranges::end(std::declval<D<True> &>()))))
-        {
-            return bool(ranges::begin(derived()) == ranges::end(derived()));
-        }
-        /// \overload
-        template(bool True = true)(
-            /// \pre
-            requires True AND (!detail::has_fixed_size_<Cardinality>) AND
-                forward_range<D<True> const>)
-        constexpr bool empty() const
-            noexcept(noexcept(bool(ranges::begin(std::declval<D<True> const &>()) ==
-                                   ranges::end(std::declval<D<True> const &>()))))
-        {
-            return bool(ranges::begin(derived()) == ranges::end(derived()));
-        }
-        CPP_template_gcc_workaround(bool True = true)(
-            /// \pre
-            requires True && detail::can_empty_<D<True>>) // clang-format off
-        constexpr explicit operator bool()
-            noexcept(noexcept(ranges::empty(std::declval<D<True> &>())))
-        {
-            return !ranges::empty(derived());
-        }
-        // clang-format on
-        /// \overload
-        CPP_template_gcc_workaround(bool True = true)(
-            /// \pre
-            requires True && detail::can_empty_<D<True> const>) // clang-format off
-        constexpr explicit operator bool() const
-            noexcept(noexcept(ranges::empty(std::declval<D<True> const &>())))
-        {
-            return !ranges::empty(derived());
-        }
-        // clang-format on
-        /// If the size of the range is known at compile-time and finite,
-        /// return it.
-        template(bool True = true, int = 42)(
-            /// \pre
-            requires True AND (Cardinality >= 0)) //
-        static constexpr std::size_t size() noexcept
-        {
-            return static_cast<std::size_t>(Cardinality);
-        }
-        /// If `sized_sentinel_for<sentinel_t<Derived>, iterator_t<Derived>>` is
-        /// satisfied, and if `Derived` is a `forward_range`, then return
-        /// `end - begin` cast to an unsigned integer.
-        template(bool True = true)(
-            /// \pre
-            requires True AND (Cardinality < 0) AND
-                sized_sentinel_for<sentinel_t<D<True>>, iterator_t<D<True>>> AND
-                forward_range<D<True>>)
-        constexpr detail::iter_size_t<iterator_t<D<True>>> size()
-        {
-            using size_type = detail::iter_size_t<iterator_t<D<True>>>;
-            return static_cast<size_type>(derived().end() - derived().begin());
-        }
-        /// \overload
-        template(bool True = true)(
-            /// \pre
-            requires True AND (Cardinality < 0) AND
-                sized_sentinel_for<sentinel_t<D<True> const>,
-                                   iterator_t<D<True> const>> AND
-                forward_range<D<True> const>)
-        constexpr detail::iter_size_t<iterator_t<D<True>>> size() const //
-        {
-            using size_type = detail::iter_size_t<iterator_t<D<True>>>;
-            return static_cast<size_type>(derived().end() - derived().begin());
-        }
-        /// Access the first element in a range:
-        template(bool True = true)(
-            /// \pre
-            requires True AND forward_range<D<True>>)
-        constexpr range_reference_t<D<True>> front()
-        {
-            return *derived().begin();
-        }
-        /// \overload
-        template(bool True = true)(
-            /// \pre
-            requires True AND forward_range<D<True> const>)
-        constexpr range_reference_t<D<True> const> front() const
-        {
-            return *derived().begin();
-        }
-        /// Access the last element in a range:
-        template(bool True = true)(
-            /// \pre
-            requires True AND common_range<D<True>> AND bidirectional_range<D<True>>)
-        constexpr range_reference_t<D<True>> back()
-        {
-            return *prev(derived().end());
-        }
-        /// \overload
-        template(bool True = true)(
-            /// \pre
-            requires True AND common_range<D<True> const> AND
-                bidirectional_range<D<True> const>)
-        constexpr range_reference_t<D<True> const> back() const
-        {
-            return *prev(derived().end());
-        }
-        /// Simple indexing:
-        template(bool True = true)(
-            /// \pre
-            requires True AND random_access_range<D<True>>)
-        constexpr range_reference_t<D<True>> operator[](range_difference_t<D<True>> n)
-        {
-            return derived().begin()[n];
-        }
-        /// \overload
-        template(bool True = true)(
-            /// \pre
-            requires True AND random_access_range<D<True> const>)
-        constexpr range_reference_t<D<True> const> //
-        operator[](range_difference_t<D<True>> n) const
-        {
-            return derived().begin()[n];
-        }
-        /// Returns a pointer to the block of memory
-        /// containing the elements of a contiguous range:
-        template(bool True = true)(
-            /// \pre
-            requires True AND contiguous_iterator<iterator_t<D<True>>>)
-        constexpr std::add_pointer_t<range_reference_t<D<True>>> data() //
-        {
-            return std::addressof(*ranges::begin(derived()));
-        }
-        /// \overload
-        template(bool True = true)(
-            /// \pre
-            requires True AND contiguous_iterator<iterator_t<D<True> const>>)
-        constexpr std::add_pointer_t<range_reference_t<D<True> const>> data() const //
-        {
-            return std::addressof(*ranges::begin(derived()));
-        }
-        /// Returns a reference to the element at specified location pos, with bounds
-        /// checking.
-        template(bool True = true)(
-            /// \pre
-            requires True AND random_access_range<D<True>> AND sized_range<D<True>>)
-        constexpr range_reference_t<D<True>> at(range_difference_t<D<True>> n)
-        {
-            using size_type = range_size_t<Derived>;
-            if(n < 0 || size_type(n) >= ranges::size(derived()))
-            {
-                throw std::out_of_range("view_interface::at");
-            }
-            return derived().begin()[n];
-        }
-        /// \overload
-        template(bool True = true)(
-            /// \pre
-            requires True AND random_access_range<D<True> const> AND
-                sized_range<D<True> const>)
-        constexpr range_reference_t<D<True> const> at(range_difference_t<D<True>> n) const
-        {
-            using size_type = range_size_t<Derived const>;
-            if(n < 0 || size_type(n) >= ranges::size(derived()))
-            {
-                throw std::out_of_range("view_interface::at");
-            }
-            return derived().begin()[n];
-        }
-        /// Python-ic slicing:
-        //      rng[{4,6}]
-        template(bool True = true, typename Slice = views::slice_fn)(
-            /// \pre
-            requires True AND input_range<D<True> &>)
-        constexpr auto
-            operator[](detail::slice_bounds<range_difference_t<D<True>>> offs) &
-        {
-            return Slice{}(derived(), offs.from, offs.to);
-        }
-        /// \overload
-        template(bool True = true, typename Slice = views::slice_fn)(
-            /// \pre
-            requires True AND input_range<D<True> const &>)
-        constexpr auto
-            operator[](detail::slice_bounds<range_difference_t<D<True>>> offs) const &
-        {
-            return Slice{}(derived(), offs.from, offs.to);
-        }
-        /// \overload
-        template(bool True = true, typename Slice = views::slice_fn)(
-            /// \pre
-            requires True AND input_range<D<True>>)
-        constexpr auto
-            operator[](detail::slice_bounds<range_difference_t<D<True>>> offs) &&
-        {
-            return Slice{}(detail::move(derived()), offs.from, offs.to);
-        }
-        //      rng[{4,end-2}]
-        /// \overload
-        template(bool True = true, typename Slice = views::slice_fn)(
-            /// \pre
-            requires True AND input_range<D<True> &> AND sized_range<D<True> &>)
-        constexpr auto //
-        operator[](detail::slice_bounds<range_difference_t<D<True>>,
-                                        detail::from_end_of_t<D<True>>> offs) &
-        {
-            return Slice{}(derived(), offs.from, offs.to);
-        }
-        /// \overload
-        template(bool True = true, typename Slice = views::slice_fn)(
-            /// \pre
-            requires True AND input_range<D<True> const &> AND
-                sized_range<D<True> const &>)
-        constexpr auto //
-        operator[](detail::slice_bounds<range_difference_t<D<True>>,
-                                        detail::from_end_of_t<D<True>>> offs) const &
-        {
-            return Slice{}(derived(), offs.from, offs.to);
-        }
-        /// \overload
-        template(bool True = true, typename Slice = views::slice_fn)(
-            /// \pre
-            requires True AND input_range<D<True>> AND sized_range<D<True>>)
-        constexpr auto //
-        operator[](detail::slice_bounds<range_difference_t<D<True>>,
-                                        detail::from_end_of_t<D<True>>> offs) &&
-        {
-            return Slice{}(detail::move(derived()), offs.from, offs.to);
-        }
-        //      rng[{end-4,end-2}]
-        /// \overload
-        template(bool True = true, typename Slice = views::slice_fn)(
-            /// \pre
-            requires True AND (forward_range<D<True> &> ||
-                              (input_range<D<True> &> && sized_range<D<True> &>))) //
-        constexpr auto //
-        operator[](detail::slice_bounds<detail::from_end_of_t<D<True>>,
-                                        detail::from_end_of_t<D<True>>> offs) &
-        {
-            return Slice{}(derived(), offs.from, offs.to);
-        }
-        /// \overload
-        template(bool True = true, typename Slice = views::slice_fn)(
-            /// \pre
-            requires True AND
-            (forward_range<D<True> const &> ||
-             (input_range<D<True> const &> && sized_range<D<True> const &>))) //
-        constexpr auto //
-        operator[](detail::slice_bounds<detail::from_end_of_t<D<True>>,
-                                        detail::from_end_of_t<D<True>>> offs) const &
-        {
-            return Slice{}(derived(), offs.from, offs.to);
-        }
-        /// \overload
-        template(bool True = true, typename Slice = views::slice_fn)(
-            /// \pre
-            requires True AND
-                (forward_range<D<True>> ||
-                    (input_range<D<True>> && sized_range<D<True>>))) //
-        constexpr auto //
-        operator[](detail::slice_bounds<detail::from_end_of_t<D<True>>,
-                                        detail::from_end_of_t<D<True>>> offs) &&
-        {
-            return Slice{}(detail::move(derived()), offs.from, offs.to);
-        }
-        //      rng[{4,end}]
-        /// \overload
-        template(bool True = true, typename Slice = views::slice_fn)(
-            /// \pre
-            requires True AND input_range<D<True> &>)
-        constexpr auto //
-        operator[](detail::slice_bounds<range_difference_t<D<True>>, end_fn> offs) &
-        {
-            return Slice{}(derived(), offs.from, offs.to);
-        }
-        /// \overload
-        template(bool True = true, typename Slice = views::slice_fn)(
-            /// \pre
-            requires True AND input_range<D<True> const &>)
-        constexpr auto //
-        operator[](detail::slice_bounds<range_difference_t<D<True>>, end_fn> offs) const &
-        {
-            return Slice{}(derived(), offs.from, offs.to);
-        }
-        /// \overload
-        template(bool True = true, typename Slice = views::slice_fn)(
-            /// \pre
-            requires True AND input_range<D<True>>)
-        constexpr auto //
-        operator[](detail::slice_bounds<range_difference_t<D<True>>, end_fn> offs) &&
-        {
-            return Slice{}(detail::move(derived()), offs.from, offs.to);
-        }
-        //      rng[{end-4,end}]
-        /// \overload
-        template(bool True = true, typename Slice = views::slice_fn)(
-            /// \pre
-            requires True AND
-                (forward_range<D<True> &> ||
-                    (input_range<D<True> &> && sized_range<D<True> &>))) //
-        constexpr auto //
-        operator[](detail::slice_bounds<detail::from_end_of_t<D<True>>, end_fn> offs) &
-        {
-            return Slice{}(derived(), offs.from, offs.to);
-        }
-        /// \overload
-        template(bool True = true, typename Slice = views::slice_fn)(
-            /// \pre
-            requires True AND
-                (forward_range<D<True> const &> ||
-                    (input_range<D<True> const &> && sized_range<D<True> const &>))) //
-        constexpr auto //
-        operator[](
-            detail::slice_bounds<detail::from_end_of_t<D<True>>, end_fn> offs) const &
-        {
-            return Slice{}(derived(), offs.from, offs.to);
-        }
-        /// \overload
-        template(bool True = true, typename Slice = views::slice_fn)(
-            /// \pre
-            requires True AND
-                (forward_range<D<True>> ||
-                    (input_range<D<True>> && sized_range<D<True>>))) //
-        constexpr auto //
-        operator[](detail::slice_bounds<detail::from_end_of_t<D<True>>, end_fn> offs) &&
-        {
-            return Slice{}(detail::move(derived()), offs.from, offs.to);
-        }
-    private:
-        /// \brief Print a range to an ostream
-        template<bool True = true>
-        friend auto operator<<(std::ostream & sout, Derived const & rng)
-            -> CPP_broken_friend_ret(std::ostream &)(
-                /// \pre
-                requires True && input_range<D<True> const>)
-        {
-            return detail::print_rng_(sout, rng);
-        }
-        /// \overload
-        template<bool True = true>
-        friend auto operator<<(std::ostream & sout, Derived & rng)
-            -> CPP_broken_friend_ret(std::ostream &)(
-                /// \pre
-                requires True && (!range<D<True> const>) && input_range<D<True>>)
-        {
-            return detail::print_rng_(sout, rng);
-        }
-        /// \overload
-        template<bool True = true>
-        friend auto operator<<(std::ostream & sout, Derived && rng)
-            -> CPP_broken_friend_ret(std::ostream &)(
-                /// \pre
-                requires True && (!range<D<True> const>) && input_range<D<True>>)
-        {
-            return detail::print_rng_(sout, rng);
-        }
-    };
-
-    namespace cpp20
-    {
-        template(typename Derived)(
-            /// \pre
-            requires std::is_class<Derived>::value AND
-                same_as<Derived, meta::_t<std::remove_cv<Derived>>>)
-        using view_interface = ranges::view_interface<Derived, ranges::unknown>;
-    }
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/intersperse.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/intersperse.hpp
deleted file mode 100644
index c1e6bf1c..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/intersperse.hpp
+++ /dev/null
@@ -1,268 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_INTERSPERSE_HPP
-#define RANGES_V3_VIEW_INTERSPERSE_HPP
-
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/adaptor.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    template<typename Rng>
-    struct intersperse_view
-      : view_adaptor<intersperse_view<Rng>, Rng,
-                     (range_cardinality<Rng>::value > 0)
-                         ? static_cast<cardinality>(range_cardinality<Rng>::value * 2 - 1)
-                         : range_cardinality<Rng>::value>
-    {
-        intersperse_view() = default;
-        constexpr intersperse_view(Rng rng, range_value_t<Rng> val)
-          : intersperse_view::view_adaptor{detail::move(rng)}
-          , val_(detail::move(val))
-        {}
-        CPP_member
-        constexpr auto CPP_fun(size)()(const //
-            requires sized_range<Rng const>)
-        {
-            auto const n = ranges::size(this->base());
-            return n ? n * 2 - 1 : 0;
-        }
-        CPP_member
-        constexpr auto CPP_fun(size)()(
-            /// \pre
-            requires sized_range<Rng>)
-        {
-            auto const n = ranges::size(this->base());
-            return n ? n * 2 - 1 : 0;
-        }
-
-    private:
-        friend range_access;
-        template<bool Const>
-        struct cursor_adaptor : adaptor_base
-        {
-        private:
-            friend struct cursor_adaptor<!Const>;
-            using CRng = meta::const_if_c<Const, Rng>;
-            bool toggle_ = false;
-            range_value_t<Rng> val_;
-
-        public:
-            cursor_adaptor() = default;
-            constexpr explicit cursor_adaptor(range_value_t<Rng> const & val)
-              : val_{val}
-            {}
-            template(bool Other)(
-                /// \pre
-                requires Const AND CPP_NOT(Other)) //
-            cursor_adaptor(cursor_adaptor<Other> that)
-              : toggle_(that.toggle_)
-              , val_(std::move(that.val_))
-            {}
-            template<typename View>
-            constexpr iterator_t<CRng> begin(View & view)
-            {
-                auto first = ranges::begin(view.base());
-                toggle_ = first != ranges::end(view.base());
-                return first;
-            }
-            constexpr range_value_t<Rng> read(iterator_t<CRng> const & it) const
-            {
-                return toggle_ ? *it : val_;
-            }
-            CPP_member
-            constexpr auto equal(iterator_t<CRng> const & it0,
-                                 iterator_t<CRng> const & it1,
-                                 cursor_adaptor const & other) const //
-                -> CPP_ret(bool)(
-                    /// \pre
-                    requires sentinel_for<iterator_t<CRng>, iterator_t<CRng>>)
-            {
-                return it0 == it1 && toggle_ == other.toggle_;
-            }
-            constexpr void next(iterator_t<CRng> & it)
-            {
-                if(toggle_)
-                    ++it;
-                toggle_ = !toggle_;
-            }
-            CPP_member
-            constexpr auto prev(iterator_t<CRng> & it) //
-                -> CPP_ret(void)(
-                    /// \pre
-                    requires bidirectional_range<CRng>)
-            {
-                toggle_ = !toggle_;
-                if(toggle_)
-                    --it;
-            }
-            CPP_member
-            constexpr auto distance_to(iterator_t<CRng> const & it,
-                                       iterator_t<CRng> const & other_it,
-                                       cursor_adaptor const & other) const
-                -> CPP_ret(range_difference_t<Rng>)(
-                    /// \pre
-                    requires sized_sentinel_for<iterator_t<CRng>, iterator_t<CRng>>)
-            {
-                return (other_it - it) * 2 + (other.toggle_ - toggle_);
-            }
-            CPP_member
-            constexpr auto advance(iterator_t<CRng> & it, range_difference_t<CRng> n) //
-                -> CPP_ret(void)(
-                    /// \pre
-                    requires random_access_range<CRng>)
-            {
-                ranges::advance(it, n >= 0 ? (n + toggle_) / 2 : (n - !toggle_) / 2);
-                if(n % 2 != 0)
-                    toggle_ = !toggle_;
-            }
-        };
-        template<bool Const>
-        struct sentinel_adaptor : adaptor_base
-        {
-        private:
-            using CRng = meta::const_if_c<Const, Rng>;
-
-        public:
-            sentinel_adaptor() = default;
-            template(bool Other)(
-                /// \pre
-                requires Const AND CPP_NOT(Other)) //
-            sentinel_adaptor(sentinel_adaptor<Other>)
-            {}
-            static constexpr bool empty(iterator_t<CRng> const & it,
-                                        cursor_adaptor<Const> const &,
-                                        sentinel_t<CRng> const & sent)
-            {
-                return it == sent;
-            }
-        };
-        constexpr cursor_adaptor<false> begin_adaptor()
-        {
-            return cursor_adaptor<false>{val_};
-        }
-        CPP_member
-        constexpr auto begin_adaptor() const //
-            -> CPP_ret(cursor_adaptor<true>)(
-                /// \pre
-                requires range<Rng const>)
-        {
-            return cursor_adaptor<true>{val_};
-        }
-        CPP_member
-        constexpr auto end_adaptor() //
-            -> CPP_ret(cursor_adaptor<false>)(
-                /// \pre
-                requires common_range<Rng> && (!single_pass_iterator_<iterator_t<Rng>>))
-        {
-            return cursor_adaptor<false>{val_};
-        }
-        CPP_member
-        constexpr auto end_adaptor() noexcept //
-            -> CPP_ret(sentinel_adaptor<false>)(
-                /// \pre
-                requires (!common_range<Rng>) || single_pass_iterator_<iterator_t<Rng>>)
-        {
-            return {};
-        }
-        template(bool Const = true)(
-            /// \pre
-            requires Const AND range<meta::const_if_c<Const, Rng>> AND
-                common_range<meta::const_if_c<Const, Rng>> AND
-            (!single_pass_iterator_<iterator_t<meta::const_if_c<Const, Rng>>>)) //
-        constexpr cursor_adaptor<Const> end_adaptor() const
-        {
-            return cursor_adaptor<true>{val_};
-        }
-        template(bool Const = true)(
-            /// \pre
-            requires Const AND range<meta::const_if_c<Const, Rng>> AND
-                (!common_range<meta::const_if_c<Const, Rng>> ||
-                 single_pass_iterator_<iterator_t<meta::const_if_c<Const, Rng>>>)) //
-        constexpr sentinel_adaptor<Const> end_adaptor() const noexcept
-        {
-            return {};
-        }
-
-        range_value_t<Rng> val_;
-    };
-
-    template<typename Rng>
-    RANGES_INLINE_VAR constexpr bool enable_borrowed_range<intersperse_view<Rng>> = //
-        enable_borrowed_range<Rng>;
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template<typename Rng>
-    intersperse_view(Rng &&, range_value_t<Rng>)
-        -> intersperse_view<views::all_t<Rng>>;
-#endif
-
-    namespace views
-    {
-        struct intersperse_base_fn
-        {
-            template(typename Rng)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng> AND
-                    convertible_to<range_reference_t<Rng>, range_value_t<Rng>> AND
-                        semiregular<range_value_t<Rng>>)
-            constexpr intersperse_view<all_t<Rng>> //
-            operator()(Rng && rng, range_value_t<Rng> val) const
-            {
-                return {all(static_cast<Rng &&>(rng)), std::move(val)};
-            }
-        };
-
-        struct intersperse_fn : intersperse_base_fn
-        {
-            using intersperse_base_fn::operator();
-
-            template(typename T)(
-                /// \pre
-                requires copyable<T>)
-            constexpr auto operator()(T t) const
-            {
-                return make_view_closure(bind_back(intersperse_base_fn{}, std::move(t)));
-            }
-        };
-
-        /// \relates intersperse_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(intersperse_fn, intersperse)
-    } // namespace views
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::intersperse_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/iota.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/iota.hpp
deleted file mode 100644
index 21a19d67..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/iota.hpp
+++ /dev/null
@@ -1,580 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_IOTA_HPP
-#define RANGES_V3_VIEW_IOTA_HPP
-
-#include <climits>
-#include <cstdint>
-#include <limits>
-#include <type_traits>
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/default_sentinel.hpp>
-#include <range/v3/iterator/diffmax_t.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/delimit.hpp>
-#include <range/v3/view/facade.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-RANGES_DIAGNOSTIC_PUSH
-RANGES_DIAGNOSTIC_IGNORE_UNSIGNED_MATH
-RANGES_DIAGNOSTIC_IGNORE_TRUNCATION
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        template<std::size_t N, typename = void>
-        struct promote_as_signed_
-        {
-            // This shouldn't cause us to LOSE precision, but maybe it doesn't
-            // net us any either.
-            static_assert(sizeof(std::intmax_t) * CHAR_BIT >= N,
-                          "Possible extended integral type?");
-            using difference_type = diffmax_t;
-        };
-
-        template<std::size_t N>
-        struct promote_as_signed_<N, enable_if_t<(N < 16)>>
-        {
-            using difference_type = std::int_fast16_t;
-        };
-
-        template<std::size_t N>
-        struct promote_as_signed_<N, enable_if_t<(N >= 16 && N < 32)>>
-        {
-            using difference_type = std::int_fast32_t;
-        };
-
-        template<std::size_t N>
-        struct promote_as_signed_<N, enable_if_t<(N >= 32 && N < 64)>>
-        {
-            using difference_type = std::int_fast64_t;
-        };
-
-        template<typename I>
-        using iota_difference_t = typename meta::conditional_t<
-            std::is_integral<I>::value && sizeof(I) == sizeof(iter_difference_t<I>),
-            promote_as_signed_<sizeof(iter_difference_t<I>) * CHAR_BIT>,
-            with_difference_type_<iter_difference_t<I>>>::difference_type;
-
-        // clang-format off
-        template<typename I>
-        CPP_requires(_decrementable_,
-            requires(I i) //
-            (
-                --i,
-                i--,
-                concepts::requires_<same_as<I&, decltype(--i)>>,
-                concepts::requires_<same_as<I, decltype(i--)>>
-            ));
-        template<typename I>
-        CPP_concept decrementable_ =
-            incrementable<I> &&
-            CPP_requires_ref(detail::_decrementable_, I);
-
-        template<typename I>
-        CPP_requires(_advanceable_,
-            requires(I i, I const j, iota_difference_t<I> const n) //
-            (
-                j - j,
-                i += n,
-                i -= n,
-                static_cast<I>(j - n),
-                static_cast<I>(j + n),
-                static_cast<I>(n + j),
-                // NOT TO SPEC:
-                // Unsigned integers are advanceable, but subtracting them results in
-                // an unsigned integral, which is not the same as the difference type,
-                // which is signed.
-                concepts::requires_<convertible_to<decltype(j - j), iota_difference_t<I>>>,
-                concepts::requires_<same_as<I&, decltype(i += n)>>,
-                concepts::requires_<same_as<I&, decltype(i -= n)>> //,
-                // concepts::requires_<convertible_to<decltype(i - n), I>>,
-                // concepts::requires_<convertible_to<decltype(i + n), I>>,
-                // concepts::requires_<convertible_to<decltype(n + i), I>>
-            ));
-        template<typename I>
-        CPP_concept advanceable_ =
-            decrementable_<I> && totally_ordered<I> &&
-            CPP_requires_ref(detail::_advanceable_, I);
-        // clang-format on
-
-        template(typename I)(
-            /// \pre
-            requires (!unsigned_integral<I>)) //
-        void iota_advance_(I & i, iota_difference_t<I> n)
-        {
-            // TODO: bounds-check this
-            i += n;
-        }
-
-        template(typename Int)(
-            /// \pre
-            requires unsigned_integral<Int>)
-        void iota_advance_(Int & i, iota_difference_t<Int> n)
-        {
-            // TODO: bounds-check this
-            if(n >= 0)
-                i += static_cast<Int>(n);
-            else
-                i -= static_cast<Int>(-n);
-        }
-
-        template(typename I)(
-            /// \pre
-            requires advanceable_<I> AND (!integral<I>)) //
-        iota_difference_t<I> iota_distance_(I const & i, I const & s)
-        {
-            return static_cast<iota_difference_t<I>>(s - i);
-        }
-
-        template(typename Int)(
-            /// \pre
-            requires signed_integral<Int>)
-        iota_difference_t<Int> iota_distance_(Int i0, Int i1)
-        {
-            // TODO: bounds-check this
-            return static_cast<iota_difference_t<Int>>(
-                static_cast<iota_difference_t<Int>>(i1) -
-                static_cast<iota_difference_t<Int>>(i0));
-        }
-
-        template(typename Int)(
-            /// \pre
-            requires unsigned_integral<Int>)
-        iota_difference_t<Int> iota_distance_(Int i0, Int i1)
-        {
-            // TODO: bounds-check this
-            return (i0 > i1) ? static_cast<iota_difference_t<Int>>(
-                                   -static_cast<iota_difference_t<Int>>(i0 - i1))
-                             : static_cast<iota_difference_t<Int>>(i1 - i0);
-        }
-    } // namespace detail
-    /// \endcond
-
-    /// \addtogroup group-views
-    /// @{
-
-    /// An iota view in a closed range
-    template<typename From, typename To /* = From */>
-    struct RANGES_EMPTY_BASES closed_iota_view
-      : view_facade<closed_iota_view<From, To>, finite>
-    {
-    private:
-        friend range_access;
-
-        From from_ = From();
-        RANGES_NO_UNIQUE_ADDRESS To to_ = To();
-
-        struct cursor
-        {
-            using difference_type = detail::iota_difference_t<From>;
-
-        private:
-            friend range_access;
-            From from_ = From();
-            RANGES_NO_UNIQUE_ADDRESS To to_ = To();
-            bool done_ = false;
-
-            From read() const
-            {
-                RANGES_EXPECT(!done_);
-                return from_;
-            }
-            void next()
-            {
-                RANGES_EXPECT(!done_);
-                if(from_ == to_)
-                    done_ = true;
-                else
-                    ++from_;
-            }
-            bool equal(default_sentinel_t) const
-            {
-                return done_;
-            }
-            CPP_member
-            auto equal(cursor const & that) const //
-                -> CPP_ret(bool)(
-                    /// \pre
-                    requires equality_comparable<From>)
-            {
-                return that.from_ == from_ && that.done_ == done_;
-            }
-            CPP_member
-            auto prev() //
-                -> CPP_ret(void)(
-                    /// \pre
-                    requires detail::decrementable_<From>)
-            {
-                if(done_)
-                    done_ = false;
-                else
-                    --from_;
-            }
-            CPP_member
-            auto advance(difference_type n) //
-                -> CPP_ret(void)(
-                    /// \pre
-                    requires detail::advanceable_<From>)
-            {
-                if(n > 0)
-                {
-                    RANGES_ENSURE(detail::iota_distance_(from_, to_) >= n - !done_);
-                    detail::iota_advance_(
-                        from_,
-                        n - (done_ = (detail::iota_distance_(from_, to_) <= n - !done_)));
-                }
-                else if(n < 0)
-                    detail::iota_advance_(from_, n + std::exchange(done_, false));
-            }
-            CPP_member
-            auto distance_to(cursor const & that) const //
-                -> CPP_ret(difference_type)(
-                    /// \pre
-                    requires detail::advanceable_<From>)
-            {
-                using D = difference_type;
-                return static_cast<D>(detail::iota_distance_(from_, that.from_)) +
-                       ((D)that.done_ - (D)done_);
-            }
-            CPP_member
-            auto distance_to(default_sentinel_t) const //
-                -> CPP_ret(difference_type)(
-                    /// \pre
-                    requires sized_sentinel_for<To, From>)
-            {
-                return difference_type(to_ - from_) + !done_;
-            }
-
-        public:
-            cursor() = default;
-            constexpr cursor(From from, To to, bool done = false)
-              : from_(std::move(from))
-              , to_(std::move(to))
-              , done_(done)
-            {}
-        };
-
-        cursor begin_cursor() const
-        {
-            return {from_, to_};
-        }
-        CPP_member
-        auto end_cursor() const //
-            -> CPP_ret(cursor)(
-                /// \pre
-                requires same_as<From, To>)
-        {
-            return {to_, to_, true};
-        }
-        CPP_member
-        auto end_cursor() const //
-            -> CPP_ret(default_sentinel_t)(
-                /// \pre
-                requires (!same_as<From, To>))
-        {
-            return {};
-        }
-
-        constexpr void check_bounds_(std::true_type)
-        {
-            RANGES_EXPECT(from_ <= to_);
-        }
-        constexpr void check_bounds_(std::false_type)
-        {}
-
-    public:
-        closed_iota_view() = default;
-        constexpr closed_iota_view(meta::id_t<From> from, meta::id_t<To> to)
-          : from_(std::move(from))
-          , to_(std::move(to))
-        {
-            check_bounds_(meta::bool_<totally_ordered_with<From, To>>{});
-        }
-    };
-
-    template<typename From, typename To>
-    RANGES_INLINE_VAR constexpr bool enable_borrowed_range<closed_iota_view<From, To>> =
-        true;
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template(typename From, typename To)(
-        /// \pre
-        requires weakly_incrementable<From> AND semiregular<To> AND
-        (!integral<From> || !integral<To> ||
-         std::is_signed<From>::value == std::is_signed<To>::value)) //
-        closed_iota_view(From, To)
-            ->closed_iota_view<From, To>;
-#endif
-
-    template<typename From, typename To /* = unreachable_sentinel_t*/>
-    struct RANGES_EMPTY_BASES iota_view
-      : view_facade<iota_view<From, To>,
-                    same_as<To, unreachable_sentinel_t>
-                        ? infinite
-                        : std::is_integral<From>::value && std::is_integral<To>::value
-                              ? finite
-                              : unknown>
-    {
-    private:
-        friend range_access;
-        From from_ = From();
-        RANGES_NO_UNIQUE_ADDRESS To to_ = To();
-
-        struct cursor;
-        struct sentinel
-        {
-        private:
-            friend struct cursor;
-            RANGES_NO_UNIQUE_ADDRESS To to_;
-
-        public:
-            sentinel() = default;
-            constexpr explicit sentinel(To to)
-              : to_(std::move(to))
-            {}
-        };
-
-        struct cursor
-        {
-            using difference_type = detail::iota_difference_t<From>;
-
-        private:
-            friend range_access;
-            From from_;
-
-            From read() const
-            {
-                return from_;
-            }
-            void next()
-            {
-                ++from_;
-            }
-            bool equal(sentinel const & that) const
-            {
-                return from_ == that.to_;
-            }
-            CPP_member
-            auto equal(cursor const & that) const //
-                -> CPP_ret(bool)(
-                    /// \pre
-                    requires equality_comparable<From>)
-            {
-                return that.from_ == from_;
-            }
-            CPP_member
-            auto prev() //
-                -> CPP_ret(void)(
-                    /// \pre
-                    requires detail::decrementable_<From>)
-            {
-                --from_;
-            }
-            CPP_member
-            auto advance(difference_type n) //
-                -> CPP_ret(void)(
-                    /// \pre
-                    requires detail::advanceable_<From>)
-            {
-                detail::iota_advance_(from_, n);
-            }
-            // Not to spec: TODO the relational operators will effectively be constrained
-            // with Advanceable, but they should be constrained with totally_ordered.
-            // Reimplement iota_view without view_facade or basic_iterator.
-            CPP_member
-            auto distance_to(cursor const & that) const //
-                -> CPP_ret(difference_type)(
-                    /// \pre
-                    requires detail::advanceable_<From>)
-            {
-                return detail::iota_distance_(from_, that.from_);
-            }
-            // Extension: see https://github.com/ericniebler/stl2/issues/613
-            CPP_member
-            auto distance_to(sentinel const & that) const //
-                -> CPP_ret(difference_type)(
-                    /// \pre
-                    requires sized_sentinel_for<To, From>)
-            {
-                return that.to_ - from_;
-            }
-
-        public:
-            cursor() = default;
-            constexpr explicit cursor(From from)
-              : from_(std::move(from))
-            {}
-        };
-        cursor begin_cursor() const
-        {
-            return cursor{from_};
-        }
-        CPP_member
-        auto CPP_fun(end_cursor)()(const //
-            requires(same_as<To, unreachable_sentinel_t>))
-        {
-            return unreachable;
-        }
-        CPP_member
-        auto CPP_fun(end_cursor)()(const //
-            requires(!same_as<To, unreachable_sentinel_t>))
-        {
-            return meta::conditional_t<same_as<From, To>, cursor, sentinel>{to_};
-        }
-        constexpr void check_bounds_(std::true_type)
-        {
-            RANGES_EXPECT(from_ <= to_);
-        }
-        constexpr void check_bounds_(std::false_type)
-        {}
-
-    public:
-#ifdef RANGES_WORKAROUND_MSVC_934264
-        constexpr
-#endif // RANGES_WORKAROUND_MSVC_934264
-            iota_view() = default;
-        constexpr explicit iota_view(From from)
-          : from_(std::move(from))
-        {}
-        constexpr iota_view(meta::id_t<From> from, meta::id_t<To> to)
-          : from_(std::move(from))
-          , to_(std::move(to))
-        {
-            check_bounds_(meta::bool_<totally_ordered_with<From, To>>{});
-        }
-    };
-
-    template<typename From, typename To>
-    RANGES_INLINE_VAR constexpr bool enable_borrowed_range<iota_view<From, To>> = true;
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template(typename From, typename To)(
-        /// \pre
-        requires weakly_incrementable<From> AND semiregular<To> AND
-        (!integral<From> || !integral<To> ||
-         std::is_signed<From>::value == std::is_signed<To>::value)) //
-        iota_view(From, To)
-            ->iota_view<From, To>;
-#endif
-
-    namespace views
-    {
-        struct iota_fn
-        {
-            template(typename From)(
-                /// \pre
-                requires weakly_incrementable<From>)
-            iota_view<From> operator()(From value) const
-            {
-                return iota_view<From>{std::move(value)};
-            }
-            template(typename From, typename To)(
-                /// \pre
-                requires weakly_incrementable<From> AND semiregular<To> AND
-                    detail::weakly_equality_comparable_with_<From, To> AND
-                (!integral<From> || !integral<To> ||
-                 std::is_signed<From>::value == std::is_signed<To>::value)) //
-            iota_view<From, To> operator()(From from, To to) const
-            {
-                return {std::move(from), std::move(to)};
-            }
-        };
-
-        struct closed_iota_fn
-        {
-            template(typename From, typename To)(
-                /// \pre
-                requires weakly_incrementable<From> AND semiregular<To> AND
-                        detail::weakly_equality_comparable_with_<From, To> AND
-                    (!integral<From> || !integral<To> ||
-                     std::is_signed<From>::value == std::is_signed<To>::value)) //
-            closed_iota_view<From, To> operator()(From from, To to) const
-            {
-                return {std::move(from), std::move(to)};
-            }
-        };
-
-        /// \relates iota_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(iota_fn, iota)
-
-        /// \relates closed_iota_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(closed_iota_fn, closed_iota)
-
-        struct ints_fn : iota_view<int>
-        {
-            ints_fn() = default;
-
-            template(typename Val)(
-                /// \pre
-                requires integral<Val>)
-            RANGES_DEPRECATED(
-                "This potentially confusing API is deprecated. Prefer to "
-                "explicitly specify the upper bound as with ranges::unreachable, as in "
-                "views::ints( n, unreachable )")
-            constexpr iota_view<Val> operator()(Val value) const //
-            {
-                return iota_view<Val>{value};
-            }
-            template(typename Val)(
-                /// \pre
-                requires integral<Val>)
-            constexpr iota_view<Val> operator()(Val value, unreachable_sentinel_t) const
-            {
-                return iota_view<Val>{value};
-            }
-            template(typename Val)(
-                /// \pre
-                requires integral<Val>)
-            constexpr iota_view<Val, Val> operator()(Val from, Val to) const
-            {
-                return {from, to};
-            }
-        };
-
-        /// \relates ints_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(ints_fn, ints)
-    } // namespace views
-
-    namespace cpp20
-    {
-        namespace views
-        {
-            using ranges::views::iota;
-        }
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::closed_iota_view)
-RANGES_SATISFY_BOOST_RANGE(::ranges::iota_view)
-
-RANGES_DIAGNOSTIC_POP
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/istream.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/istream.hpp
deleted file mode 100644
index c708a17f..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/istream.hpp
+++ /dev/null
@@ -1,124 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_ISTREAM_HPP
-#define RANGES_V3_VIEW_ISTREAM_HPP
-
-#include <istream>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/default_sentinel.hpp>
-#include <range/v3/utility/semiregular_box.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/facade.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    template<typename Val>
-    struct istream_view : view_facade<istream_view<Val>, unknown>
-    {
-    private:
-        friend range_access;
-        std::istream * sin_;
-        semiregular_box_t<Val> obj_;
-        struct cursor
-        {
-        private:
-            friend range_access;
-            using single_pass = std::true_type;
-            istream_view * rng_ = nullptr;
-
-        public:
-            cursor() = default;
-            explicit cursor(istream_view * rng)
-              : rng_(rng)
-            {}
-            void next()
-            {
-                rng_->next();
-            }
-            Val & read() const noexcept
-            {
-                return rng_->cached();
-            }
-            bool equal(default_sentinel_t) const
-            {
-                return !rng_->sin_;
-            }
-            bool equal(cursor that) const
-            {
-                return !rng_->sin_ == !that.rng_->sin_;
-            }
-        };
-        void next()
-        {
-            if(!(*sin_ >> cached()))
-                sin_ = nullptr;
-        }
-        cursor begin_cursor()
-        {
-            return cursor{this};
-        }
-
-    public:
-        istream_view() = default;
-        explicit istream_view(std::istream & sin)
-          : sin_(&sin)
-          , obj_{}
-        {
-            next(); // prime the pump
-        }
-        Val & cached() noexcept
-        {
-            return obj_;
-        }
-    };
-
-    /// \cond
-    template<typename Val>
-    using istream_range RANGES_DEPRECATED(
-        "istream_range<T> has been renamed to istream_view<T>") = istream_view<Val>;
-    /// \endcond
-
-    /// \cond
-    namespace _istream_
-    {
-        /// \endcond
-        template(typename Val)(
-            /// \pre
-            requires copy_constructible<Val> AND default_constructible<Val>)
-        inline istream_view<Val> istream(std::istream & sin)
-        {
-            return istream_view<Val>{sin};
-        }
-        /// \cond
-    } // namespace _istream_
-    using namespace _istream_;
-    /// \endcond
-
-    namespace cpp20
-    {
-        template<typename Val>
-        using basic_istream_view = ::ranges::istream_view<Val>;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/join.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/join.hpp
deleted file mode 100644
index f950b416..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/join.hpp
+++ /dev/null
@@ -1,658 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_JOIN_HPP
-#define RANGES_V3_VIEW_JOIN_HPP
-
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/iterator/default_sentinel.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/range_for.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/utility/variant.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/facade.hpp>
-#include <range/v3/view/single.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        // Compute the cardinality of a joined range
-        constexpr cardinality join_cardinality_(
-            cardinality Outer, cardinality Inner,
-            cardinality Joiner = static_cast<cardinality>(0)) noexcept
-        {
-            return Outer == infinite || Inner == infinite ||
-                           (Joiner == infinite && Outer != 0 && Outer != 1)
-                       ? infinite
-                       : Outer == unknown || Inner == unknown ||
-                                 (Joiner == unknown && Outer != 0 && Outer != 1)
-                             ? unknown
-                             : Outer == finite || Inner == finite ||
-                                       (Joiner == finite && Outer != 0 && Outer != 1)
-                                   ? finite
-                                   : static_cast<cardinality>(
-                                         Outer * Inner +
-                                         (Outer == 0 ? 0 : (Outer - 1) * Joiner));
-        }
-
-        template<typename Range>
-        constexpr cardinality join_cardinality() noexcept
-        {
-            return detail::join_cardinality_(
-                range_cardinality<Range>::value,
-                range_cardinality<range_reference_t<Range>>::value);
-        }
-
-        template<typename Range, typename JoinRange>
-        constexpr cardinality join_cardinality() noexcept
-        {
-            return detail::join_cardinality_(
-                range_cardinality<Range>::value,
-                range_cardinality<range_reference_t<Range>>::value,
-                range_cardinality<JoinRange>::value);
-        }
-
-        template<typename Inner>
-        struct store_inner_
-        {
-            views::all_t<Inner> inner_ = views::all_t<Inner>();
-
-            constexpr views::all_t<Inner> & update_inner_(Inner && inner)
-            {
-                return (inner_ = views::all(static_cast<Inner &&>(inner)));
-            }
-            constexpr views::all_t<Inner> & get_inner_(ignore_t) noexcept
-            {
-                return inner_;
-            }
-        };
-
-        struct pass_thru_inner_
-        {
-            // Intentionally promote xvalues to lvalues here:
-            template<typename Inner>
-            static constexpr Inner & update_inner_(Inner && inner) noexcept
-            {
-                return inner;
-            }
-            template<typename OuterIt>
-            static constexpr decltype(auto) get_inner_(OuterIt && outer_it)
-            {
-                return *outer_it;
-            }
-        };
-
-        template<typename Rng>
-        using join_view_inner =
-            meta::conditional_t<!std::is_reference<range_reference_t<Rng>>::value,
-                      store_inner_<range_reference_t<Rng>>, pass_thru_inner_>;
-
-        // clang-format off
-        template<typename I>
-        CPP_requires(has_member_arrow_,
-            requires(I i) //
-            (
-                i.operator->()
-            ));
-
-        template<typename I>
-        CPP_concept has_arrow_ =
-            input_iterator<I> &&
-            (std::is_pointer<I>::value || CPP_requires_ref(detail::has_member_arrow_, I));
-        // clang-format on
-    } // namespace detail
-    /// \endcond
-
-    /// \addtogroup group-views
-    /// @{
-
-    // Join a range of ranges
-    template<typename Rng>
-    struct RANGES_EMPTY_BASES join_view
-      : view_facade<join_view<Rng>, detail::join_cardinality<Rng>()>
-      , private detail::join_view_inner<Rng>
-    {
-        CPP_assert(input_range<Rng> && view_<Rng>);
-        CPP_assert(input_range<range_reference_t<Rng>>);
-        CPP_assert(std::is_reference<range_reference_t<Rng>>::value ||
-                   view_<range_reference_t<Rng>>);
-
-        join_view() = default;
-        explicit join_view(Rng rng)
-          : outer_(views::all(std::move(rng)))
-        {}
-        // Not to spec
-        CPP_member
-        static constexpr auto size() //
-            -> CPP_ret(std::size_t)(
-                /// \pre
-                requires (detail::join_cardinality<Rng>() >= 0))
-        {
-            return static_cast<std::size_t>(detail::join_cardinality<Rng>());
-        }
-        // Not to spec
-        CPP_member
-        constexpr auto CPP_fun(size)()(
-            /// \pre
-            requires(detail::join_cardinality<Rng>() < 0) &&
-                (range_cardinality<Rng>::value >= 0) &&
-                forward_range<Rng> &&
-                sized_range<range_reference_t<Rng>>)
-        {
-            range_size_t<range_reference_t<Rng>> n = 0;
-            RANGES_FOR(auto && inner, outer_)
-                n += ranges::size(inner);
-            return n;
-        }
-        // // ericniebler/stl2#605
-        constexpr Rng base() const
-        {
-            return outer_;
-        }
-
-    private:
-        friend range_access;
-        Rng outer_{};
-
-        template<bool Const>
-        struct cursor
-        {
-        private:
-            using Parent = meta::conditional_t<Const, join_view const, join_view>;
-            using COuter = meta::conditional_t<Const, Rng const, Rng>;
-            using CInner = range_reference_t<COuter>;
-            using ref_is_glvalue = std::is_reference<CInner>;
-
-            Parent * rng_ = nullptr;
-            iterator_t<COuter> outer_it_{};
-            iterator_t<CInner> inner_it_{};
-
-            void satisfy()
-            {
-                for(; outer_it_ != ranges::end(rng_->outer_); ++outer_it_)
-                {
-                    auto & inner = rng_->update_inner_(*outer_it_);
-                    inner_it_ = ranges::begin(inner);
-                    if(inner_it_ != ranges::end(inner))
-                        return;
-                }
-                if(RANGES_CONSTEXPR_IF(ref_is_glvalue::value))
-                    inner_it_ = iterator_t<CInner>();
-            }
-
-        public:
-            using single_pass = meta::bool_<single_pass_iterator_<iterator_t<COuter>> ||
-                                            single_pass_iterator_<iterator_t<CInner>> ||
-                                            !ref_is_glvalue::value>;
-            cursor() = default;
-            template<typename BeginOrEnd>
-            constexpr cursor(Parent * rng, BeginOrEnd begin_or_end)
-              : rng_{rng}
-              , outer_it_(begin_or_end(rng->outer_))
-            {
-                satisfy();
-            }
-            template(bool Other)(
-                /// \pre
-                requires Const AND CPP_NOT(Other) AND
-                convertible_to<iterator_t<Rng>, iterator_t<COuter>> AND
-                convertible_to<iterator_t<range_reference_t<Rng>>,
-                               iterator_t<CInner>>)
-            constexpr cursor(cursor<Other> that)
-              : rng_(that.rng_)
-              , outer_it_(std::move(that.outer_it_))
-              , inner_it_(std::move(that.inner_it_))
-            {}
-            CPP_member
-            constexpr auto arrow() //
-                -> CPP_ret(iterator_t<CInner>)(
-                    /// \pre
-                    requires detail::has_arrow_<iterator_t<CInner>>)
-            {
-                return inner_it_;
-            }
-            constexpr bool equal(default_sentinel_t) const
-            {
-                return outer_it_ == ranges::end(rng_->outer_);
-            }
-            CPP_member
-            constexpr auto equal(cursor const & that) const //
-                -> CPP_ret(bool)(
-                    /// \pre
-                    requires ref_is_glvalue::value && //
-                        equality_comparable<iterator_t<COuter>> && //
-                        equality_comparable<iterator_t<CInner>>)
-            {
-                return outer_it_ == that.outer_it_ && inner_it_ == that.inner_it_;
-            }
-            constexpr void next()
-            {
-                auto && inner_rng = rng_->get_inner_(outer_it_);
-                if(++inner_it_ == ranges::end(inner_rng))
-                {
-                    ++outer_it_;
-                    satisfy();
-                }
-            }
-            CPP_member
-            constexpr auto prev() //
-                -> CPP_ret(void)(
-                    /// \pre
-                    requires ref_is_glvalue::value && //
-                        bidirectional_range<COuter> && //
-                        bidirectional_range<CInner> && //
-                        common_range<CInner>) // ericniebler/stl2#606
-            {
-                if(outer_it_ == ranges::end(rng_->outer_))
-                    inner_it_ = ranges::end(*--outer_it_);
-                while(inner_it_ == ranges::begin(*outer_it_))
-                    inner_it_ = ranges::end(*--outer_it_);
-                --inner_it_;
-            }
-            // clang-format off
-            constexpr auto CPP_auto_fun(read)()(const)
-            (
-                return *inner_it_
-            )
-            constexpr auto CPP_auto_fun(move)()(const)
-            (
-                return iter_move(inner_it_)
-            )
-            // clang-format on
-        };
-        static constexpr bool use_const_always() noexcept
-        {
-            return simple_view<Rng>() && std::is_reference<range_reference_t<Rng>>::value;
-        }
-        struct end_cursor_fn
-        {
-            constexpr auto operator()(join_view * this_, std::true_type) const
-            {
-                return cursor<use_const_always()>{this_, ranges::end};
-            }
-            constexpr auto operator()(join_view *, std::false_type) const
-            {
-                return default_sentinel_t{};
-            }
-        };
-        struct cend_cursor_fn
-        {
-            constexpr auto operator()(join_view const * this_, std::true_type) const
-            {
-                return cursor<true>{this_, ranges::end};
-            }
-            constexpr auto operator()(join_view const *, std::false_type) const
-            {
-                return default_sentinel_t{};
-            }
-        };
-
-        constexpr cursor<use_const_always()> begin_cursor()
-        {
-            return {this, ranges::begin};
-        }
-
-        template(bool Const = true)(
-            /// \pre
-            requires Const AND input_range<meta::const_if_c<Const, Rng>> AND
-                std::is_reference<range_reference_t<meta::const_if_c<Const, Rng>>>::value)
-        constexpr cursor<Const> begin_cursor() const
-        {
-            return {this, ranges::begin};
-        }
-
-        constexpr auto end_cursor()
-        {
-            using cond =
-                meta::bool_<std::is_reference<range_reference_t<Rng>>::value &&
-                            forward_range<Rng> && forward_range<range_reference_t<Rng>> &&
-                            common_range<Rng> && common_range<range_reference_t<Rng>>>;
-            return end_cursor_fn{}(this, cond{});
-        }
-
-        template(bool Const = true)(
-            /// \pre
-            requires Const AND input_range<meta::const_if_c<Const, Rng>> AND
-                std::is_reference<range_reference_t<meta::const_if_c<Const, Rng>>>::value)
-        constexpr auto end_cursor() const
-        {
-            using CRng = meta::const_if_c<Const, Rng>;
-            using cond =
-                meta::bool_<std::is_reference<range_reference_t<CRng>>::value &&
-                            forward_range<CRng> &&
-                            forward_range<range_reference_t<CRng>> &&
-                            common_range<CRng> && common_range<range_reference_t<CRng>>>;
-            return cend_cursor_fn{}(this, cond{});
-        }
-    };
-
-    // Join a range of ranges, inserting a range of values between them.
-    // TODO: Support const iteration when range_reference_t<Rng> is a true reference.
-    template<typename Rng, typename ValRng>
-    struct join_with_view
-      : view_facade<join_with_view<Rng, ValRng>, detail::join_cardinality<Rng, ValRng>()>
-    {
-        CPP_assert(input_range<Rng>);
-        CPP_assert(input_range<range_reference_t<Rng>>);
-        CPP_assert(forward_range<ValRng>);
-        CPP_assert(
-            common_with<range_value_t<range_reference_t<Rng>>, range_value_t<ValRng>>);
-        CPP_assert(semiregular<common_type_t<range_value_t<range_reference_t<Rng>>,
-                                             range_value_t<ValRng>>>);
-
-        join_with_view() = default;
-        join_with_view(Rng rng, ValRng val)
-          : outer_(views::all(std::move(rng)))
-          , val_(views::all(std::move(val)))
-        {}
-        CPP_member
-        static constexpr auto size() //
-            -> CPP_ret(std::size_t)(
-                /// \pre
-                requires (detail::join_cardinality<Rng, ValRng>() >= 0))
-        {
-            return static_cast<std::size_t>(detail::join_cardinality<Rng, ValRng>());
-        }
-        CPP_member
-        auto CPP_fun(size)()(const //
-            requires(detail::join_cardinality<Rng, ValRng>() < 0) &&
-                (range_cardinality<Rng>::value >= 0) && forward_range<Rng> &&
-                sized_range<range_reference_t<Rng>> && sized_range<ValRng>)
-        {
-            range_size_t<range_reference_t<Rng>> n = 0;
-            RANGES_FOR(auto && inner, outer_)
-                n += ranges::size(inner);
-            return n + (range_cardinality<Rng>::value == 0
-                            ? 0
-                            : ranges::size(val_) * (range_cardinality<Rng>::value - 1));
-        }
-
-    private:
-        friend range_access;
-        using Outer = views::all_t<Rng>;
-        // Intentionally promote xvalues to lvalues here:
-        using Inner = views::all_t<range_reference_t<Outer> &>;
-
-        Outer outer_{};
-        Inner inner_{};
-        views::all_t<ValRng> val_{};
-
-        class cursor
-        {
-            join_with_view * rng_ = nullptr;
-            iterator_t<Outer> outer_it_{};
-            variant<iterator_t<ValRng>, iterator_t<Inner>> cur_{};
-
-            void satisfy()
-            {
-                while(true)
-                {
-                    if(cur_.index() == 0)
-                    {
-                        if(ranges::get<0>(cur_) != ranges::end(rng_->val_))
-                            break;
-                        // Intentionally promote xvalues to lvalues here:
-                        auto && tmp = *outer_it_;
-                        rng_->inner_ = views::all(tmp);
-                        ranges::emplace<1>(cur_, ranges::begin(rng_->inner_));
-                    }
-                    else
-                    {
-                        if(ranges::get<1>(cur_) != ranges::end(rng_->inner_))
-                            break;
-                        if(++outer_it_ == ranges::end(rng_->outer_))
-                            break;
-                        ranges::emplace<0>(cur_, ranges::begin(rng_->val_));
-                    }
-                }
-            }
-
-        public:
-            using value_type = common_type_t<range_value_t<Inner>, range_value_t<ValRng>>;
-            using reference =
-                common_reference_t<range_reference_t<Inner>, range_reference_t<ValRng>>;
-            using rvalue_reference = common_reference_t<range_rvalue_reference_t<Inner>,
-                                                        range_rvalue_reference_t<ValRng>>;
-            using single_pass = std::true_type;
-            cursor() = default;
-            cursor(join_with_view * rng)
-              : rng_{rng}
-              , outer_it_(ranges::begin(rng->outer_))
-            {
-                if(outer_it_ != ranges::end(rng->outer_))
-                {
-                    // Intentionally promote xvalues to lvalues here:
-                    auto && tmp = *outer_it_;
-                    rng->inner_ = views::all(tmp);
-                    ranges::emplace<1>(cur_, ranges::begin(rng->inner_));
-                    satisfy();
-                }
-            }
-            bool equal(default_sentinel_t) const
-            {
-                return outer_it_ == ranges::end(rng_->outer_);
-            }
-            void next()
-            {
-                // visit(cur_, [](auto& it){ ++it; });
-                if(cur_.index() == 0)
-                {
-                    auto & it = ranges::get<0>(cur_);
-                    RANGES_ASSERT(it != ranges::end(rng_->val_));
-                    ++it;
-                }
-                else
-                {
-                    auto & it = ranges::get<1>(cur_);
-                    RANGES_ASSERT(it != ranges::end(rng_->inner_));
-                    ++it;
-                }
-                satisfy();
-            }
-            reference read() const
-            {
-                // return visit(cur_, [](auto& it) -> reference { return *it; });
-                if(cur_.index() == 0)
-                    return *ranges::get<0>(cur_);
-                else
-                    return *ranges::get<1>(cur_);
-            }
-            rvalue_reference move() const
-            {
-                // return visit(cur_, [](auto& it) -> rvalue_reference { return
-                // iter_move(it); });
-                if(cur_.index() == 0)
-                    return iter_move(ranges::get<0>(cur_));
-                else
-                    return iter_move(ranges::get<1>(cur_));
-            }
-        };
-        cursor begin_cursor()
-        {
-            return {this};
-        }
-    };
-
-    namespace views
-    {
-        /// \cond
-        // Don't forget to update views::for_each whenever this set
-        // of concepts changes
-        // clang-format off
-        template(typename Rng)(
-        concept (joinable_range_)(Rng),
-            input_range<range_reference_t<Rng>> AND
-            (std::is_reference<range_reference_t<Rng>>::value ||
-                view_<range_reference_t<Rng>>)
-        );
-        template<typename Rng>
-        CPP_concept joinable_range =
-            viewable_range<Rng> && input_range<Rng> &&
-            CPP_concept_ref(views::joinable_range_, Rng);
-
-        template(typename Rng, typename ValRng)(
-        concept (joinable_with_range_)(Rng, ValRng),
-            common_with<
-                range_value_t<ValRng>,
-                range_value_t<range_reference_t<Rng>>> AND
-            semiregular<
-                common_type_t<
-                    range_value_t<ValRng>,
-                    range_value_t<range_reference_t<Rng>>>> AND
-            common_reference_with<
-                range_reference_t<ValRng>,
-                range_reference_t<range_reference_t<Rng>>> AND
-            common_reference_with<
-                range_rvalue_reference_t<ValRng>,
-                range_rvalue_reference_t<range_reference_t<Rng>>>
-        );
-        template<typename Rng, typename ValRng>
-        CPP_concept joinable_with_range =
-            joinable_range<Rng> &&
-            viewable_range<ValRng> && forward_range<ValRng> &&
-            CPP_concept_ref(views::joinable_with_range_, Rng, ValRng);
-        // clang-format on
-        /// \endcond
-
-        struct cpp20_join_fn
-        {
-            template(typename Rng)(
-                /// \pre
-                requires joinable_range<Rng>)
-            join_view<all_t<Rng>> operator()(Rng && rng) const
-            {
-                return join_view<all_t<Rng>>{all(static_cast<Rng &&>(rng))};
-            }
-        };
-
-        struct join_base_fn : cpp20_join_fn
-        {
-        private:
-            template<typename Rng>
-            using inner_value_t = range_value_t<range_reference_t<Rng>>;
-        public:
-            using cpp20_join_fn::operator();
-
-            template(typename Rng)(
-                /// \pre
-                requires joinable_with_range<Rng, single_view<inner_value_t<Rng>>>)
-            join_with_view<all_t<Rng>, single_view<inner_value_t<Rng>>> //
-            operator()(Rng && rng, inner_value_t<Rng> v) const
-            {
-                return {all(static_cast<Rng &&>(rng)), single(std::move(v))};
-            }
-
-            template(typename Rng, typename ValRng)(
-                /// \pre
-                requires joinable_with_range<Rng, ValRng>)
-            join_with_view<all_t<Rng>, all_t<ValRng>> //
-            operator()(Rng && rng, ValRng && val) const
-            {
-                return {all(static_cast<Rng &&>(rng)), all(static_cast<ValRng &&>(val))};
-            }
-
-            /// \cond
-            template<typename Rng, typename T>
-            invoke_result_t<join_base_fn, Rng, T &> //
-            operator()(Rng && rng, detail::reference_wrapper_<T> r) const
-            {
-                return (*this)(static_cast<Rng &&>(rng), r.get());
-            }
-            /// \endcond
-        };
-
-        struct join_bind_fn
-        {
-            template(typename T)(
-                /// \pre
-                requires (!joinable_range<T>)) // TODO: underconstrained
-            constexpr auto operator()(T && t)const
-            {
-                return make_view_closure(bind_back(join_base_fn{}, static_cast<T &&>(t)));
-            }
-            template(typename T)(
-                /// \pre
-                requires (!joinable_range<T &>) AND range<T &>)
-            constexpr auto operator()(T & t) const
-            {
-                return make_view_closure(bind_back(join_base_fn{},
-                                                   detail::reference_wrapper_<T>(t)));
-            }
-        };
-
-        struct RANGES_EMPTY_BASES join_fn
-          : join_base_fn, join_bind_fn
-        {
-            using join_base_fn::operator();
-            using join_bind_fn::operator();
-        };
-
-        /// \relates join_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(view_closure<join_fn>, join)
-    } // namespace views
-    /// @}
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template(typename Rng)(
-        /// \pre
-        requires views::joinable_range<Rng>)
-        explicit join_view(Rng &&)
-            ->join_view<views::all_t<Rng>>;
-
-    template(typename Rng, typename ValRng)(
-        /// \pre
-        requires views::joinable_with_range<Rng, ValRng>)
-        explicit join_with_view(Rng &&, ValRng &&)
-            ->join_with_view<views::all_t<Rng>, views::all_t<ValRng>>;
-#endif
-
-    namespace cpp20
-    {
-        namespace views
-        {
-            RANGES_INLINE_VARIABLE(
-                ranges::views::view_closure<ranges::views::cpp20_join_fn>, join)
-        }
-        template(typename Rng)(
-            /// \pre
-            requires input_range<Rng> AND view_<Rng> AND
-                input_range<iter_reference_t<iterator_t<Rng>>> AND
-            (std::is_reference<iter_reference_t<iterator_t<Rng>>>::value ||
-             view_<iter_value_t<iterator_t<Rng>>>)) //
-            using join_view = ranges::join_view<Rng>;
-    } // namespace cpp20
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::join_view)
-RANGES_SATISFY_BOOST_RANGE(::ranges::join_with_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/linear_distribute.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/linear_distribute.hpp
deleted file mode 100644
index 066bf581..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/linear_distribute.hpp
+++ /dev/null
@@ -1,119 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Casey Carter 2017
-//  Copyright Gonzalo Brito Gadeschi 2017
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_LINEAR_DISTRIBUTE_HPP
-#define RANGES_V3_VIEW_LINEAR_DISTRIBUTE_HPP
-
-#include <type_traits>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/default_sentinel.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/facade.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    namespace views
-    {
-        /// \addtogroup group-views
-        /// @{
-
-        template<typename T>
-        struct linear_distribute_view : view_facade<linear_distribute_view<T>, finite>
-        {
-            CPP_assert(std::is_arithmetic<T>());
-
-        private:
-            friend range_access;
-
-            T from_, to_;
-            std::ptrdiff_t n_;
-
-            constexpr T read() const noexcept
-            {
-                return from_;
-            }
-            constexpr bool equal(default_sentinel_t) const noexcept
-            {
-                return n_ == 0;
-            }
-            constexpr bool equal(linear_distribute_view const & other) const noexcept
-            {
-                bool const eq = n_ == other.n_;
-                RANGES_DIAGNOSTIC_PUSH
-                RANGES_DIAGNOSTIC_IGNORE_FLOAT_EQUAL
-                RANGES_EXPECT(to_ == other.to_);
-                RANGES_EXPECT(!eq || from_ == other.from_);
-                RANGES_DIAGNOSTIC_POP
-                return eq;
-            }
-            constexpr void next() noexcept
-            {
-                RANGES_EXPECT(n_ > 0);
-                --n_;
-                if(n_ == 0)
-                {
-                    from_ = to_;
-                }
-                else
-                {
-                    from_ += (to_ - from_) / T(n_);
-                }
-            }
-
-        public:
-            constexpr linear_distribute_view() = default;
-            constexpr linear_distribute_view(T from, T to__, std::ptrdiff_t n) noexcept
-              : from_(from)
-              , to_(to__)
-              , n_(n)
-            {
-                RANGES_EXPECT(n_ > 0);
-                RANGES_EXPECT(to_ >= from_);
-            }
-            constexpr std::size_t size() const noexcept
-            {
-                return static_cast<std::size_t>(n_);
-            }
-        };
-
-        /// Distributes `n` values linearly in the closed interval [`from`, `to`].
-        ///
-        /// \pre `from <= to && n > 0`
-        ///
-        /// If `from == to`, returns n-times `to`.
-        /// If `n == 1` returns `to`.
-        struct linear_distribute_fn
-        {
-            template(typename T)(
-                /// \pre
-                requires std::is_arithmetic<T>::value)
-            constexpr auto operator()(T from, T to, std::ptrdiff_t n) const
-            {
-                return linear_distribute_view<T>{from, to, n};
-            }
-        };
-
-        /// \relates linear_distribute_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(linear_distribute_fn, linear_distribute)
-    } // namespace views
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/map.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/map.hpp
deleted file mode 100644
index 5e20c8fc..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/map.hpp
+++ /dev/null
@@ -1,151 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_MAP_HPP
-#define RANGES_V3_VIEW_MAP_HPP
-
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/transform.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-// TODO: Reuse subrange's pair_like concept here and have get_first and get_second
-// dispatch through get<>()
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        template<typename T>
-        constexpr T & get_first_second_helper(T & t, std::true_type) noexcept
-        {
-            return t;
-        }
-
-        template(typename T)(
-            /// \pre
-            requires move_constructible<T>)
-        constexpr T get_first_second_helper(T & t, std::false_type) //
-            noexcept(std::is_nothrow_move_constructible<T>::value)
-        {
-            return std::move(t);
-        }
-
-        template<typename P, typename E>
-        using get_first_second_tag = meta::bool_<std::is_lvalue_reference<P>::value ||
-                                                 std::is_lvalue_reference<E>::value>;
-
-        struct get_first
-        {
-            // clang-format off
-            template<typename Pair>
-            constexpr auto CPP_auto_fun(operator())(Pair &&p)(const)
-            (
-                return get_first_second_helper(
-                    p.first,
-                    get_first_second_tag<Pair, decltype(p.first)>{})
-            )
-            // clang-format on
-        };
-
-        struct get_second
-        {
-            // clang-format off
-            template<typename Pair>
-            constexpr auto CPP_auto_fun(operator())(Pair &&p)(const)
-            (
-                return get_first_second_helper(
-                    p.second,
-                    get_first_second_tag<Pair, decltype(p.second)>{})
-            )
-            // clang-format on
-        };
-
-        // clang-format off
-        template<typename T>
-        CPP_concept kv_pair_like_ =
-            invocable<get_first const &, T> &&
-            invocable<get_second const &, T>;
-        // clang-format on
-    } // namespace detail
-    /// \endcond
-
-    /// \addtogroup group-views
-    /// @{
-    namespace views
-    {
-        struct keys_fn
-        {
-            template(typename Rng)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng> AND
-                    detail::kv_pair_like_<range_reference_t<Rng>>)
-            keys_range_view<all_t<Rng>> operator()(Rng && rng) const
-            {
-                return {all(static_cast<Rng &&>(rng)), detail::get_first{}};
-            }
-        };
-
-        struct values_fn
-        {
-            template(typename Rng)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng> AND
-                    detail::kv_pair_like_<range_reference_t<Rng>>)
-            values_view<all_t<Rng>> operator()(Rng && rng) const
-            {
-                return {all(static_cast<Rng &&>(rng)), detail::get_second{}};
-            }
-        };
-
-        /// \relates keys_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(view_closure<keys_fn>, keys)
-
-        /// \relates values_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(view_closure<values_fn>, values)
-    } // namespace views
-
-    template<typename Rng>
-    RANGES_INLINE_VAR constexpr bool enable_borrowed_range<keys_range_view<Rng>> =
-        enable_borrowed_range<Rng>;
-    template<typename Rng>
-    RANGES_INLINE_VAR constexpr bool enable_borrowed_range<values_view<Rng>> =
-        enable_borrowed_range<Rng>;
-
-    namespace cpp20
-    {
-        namespace views
-        {
-            using ranges::views::keys;
-            using ranges::views::values;
-        } // namespace views
-        // TODO(@cjdb): provide implementation for elements_view
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/move.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/move.hpp
deleted file mode 100644
index fcd8b0f2..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/move.hpp
+++ /dev/null
@@ -1,141 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_MOVE_HPP
-#define RANGES_V3_VIEW_MOVE_HPP
-
-#include <type_traits>
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/adaptor.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    template<typename Rng>
-    struct move_view : view_adaptor<move_view<Rng>, Rng>
-    {
-    private:
-        friend range_access;
-        template<bool Const>
-        struct adaptor : adaptor_base
-        {
-            adaptor() = default;
-            template(bool Other)(
-                /// \pre
-                requires Const AND CPP_NOT(Other)) //
-            constexpr adaptor(adaptor<Other>)
-            {}
-            using CRng = meta::const_if_c<Const, Rng>;
-            using value_type = range_value_t<Rng>;
-            range_rvalue_reference_t<CRng> read(iterator_t<CRng> const & it) const
-            {
-                return ranges::iter_move(it);
-            }
-            range_rvalue_reference_t<CRng> iter_move(iterator_t<CRng> const & it) const
-            {
-                return ranges::iter_move(it);
-            }
-        };
-        adaptor<simple_view<Rng>()> begin_adaptor()
-        {
-            return {};
-        }
-        adaptor<simple_view<Rng>()> end_adaptor()
-        {
-            return {};
-        }
-        CPP_member
-        auto begin_adaptor() const //
-            -> CPP_ret(adaptor<true>)(
-                /// \pre
-                requires input_range<Rng const>)
-        {
-            return {};
-        }
-        CPP_member
-        auto end_adaptor() const //
-            -> CPP_ret(adaptor<true>)(
-                /// \pre
-                requires input_range<Rng const>)
-        {
-            return {};
-        }
-
-    public:
-        move_view() = default;
-        explicit move_view(Rng rng)
-          : move_view::view_adaptor{std::move(rng)}
-        {}
-        CPP_member
-        auto CPP_fun(size)()(const //
-            requires sized_range<Rng const>)
-        {
-            return ranges::size(this->base());
-        }
-        CPP_member
-        auto CPP_fun(size)()(
-            /// \pre
-            requires sized_range<Rng>)
-        {
-            return ranges::size(this->base());
-        }
-    };
-
-    template<typename Rng>
-    RANGES_INLINE_VAR constexpr bool enable_borrowed_range<move_view<Rng>> =
-        enable_borrowed_range<Rng>;
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template<typename Rng>
-    move_view(Rng &&) //
-        -> move_view<views::all_t<Rng>>;
-#endif
-
-    namespace views
-    {
-        struct move_fn
-        {
-            template(typename Rng)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng>)
-            move_view<all_t<Rng>> operator()(Rng && rng) const
-            {
-                return move_view<all_t<Rng>>{all(static_cast<Rng &&>(rng))};
-            }
-        };
-
-        /// \relates move_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(view_closure<move_fn>, move)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::move_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/partial_sum.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/partial_sum.hpp
deleted file mode 100644
index e237bd90..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/partial_sum.hpp
+++ /dev/null
@@ -1,235 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_PARTIAL_SUM_HPP
-#define RANGES_V3_VIEW_PARTIAL_SUM_HPP
-
-#include <iterator>
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/arithmetic.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/addressof.hpp>
-#include <range/v3/utility/semiregular_box.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/facade.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        // clang-format off
-        template(typename Rng, typename Fun)(
-        concept (partial_sum_view_constraints_)(Rng, Fun),
-            copy_constructible<range_value_t<Rng>> AND
-            constructible_from<range_value_t<Rng>, range_reference_t<Rng>> AND
-            assignable_from<range_value_t<Rng> &, range_reference_t<Rng>> AND
-            indirectly_binary_invocable_<Fun &, iterator_t<Rng>, iterator_t<Rng>> AND
-            assignable_from<
-                range_value_t<Rng> &,
-                indirect_result_t<Fun &, iterator_t<Rng>, iterator_t<Rng>>>
-        );
-        template<typename Rng, typename Fun>
-        CPP_concept partial_sum_view_constraints =
-            input_range<Rng> &&
-            copy_constructible<Fun> &&
-            CPP_concept_ref(detail::partial_sum_view_constraints_, Rng, Fun);
-        // clang-format on
-    } // namespace detail
-    /// \endcond
-
-    /// \addtogroup group-views
-    /// @{
-    template<typename Rng, typename Fun>
-    struct partial_sum_view
-      : view_facade<partial_sum_view<Rng, Fun>, range_cardinality<Rng>::value>
-    {
-    private:
-        friend range_access;
-        CPP_assert(view_<Rng>);
-        CPP_assert(detail::partial_sum_view_constraints<Rng, Fun>);
-
-        RANGES_NO_UNIQUE_ADDRESS Rng base_{};
-        RANGES_NO_UNIQUE_ADDRESS semiregular_box_t<Fun> fun_;
-
-        template<bool IsConst>
-        struct cursor
-        {
-        private:
-            friend cursor<true>;
-
-            using Parent = meta::const_if_c<IsConst, partial_sum_view>;
-            using Base = meta::const_if_c<IsConst, Rng>;
-
-            Parent * parent_ = nullptr;
-            RANGES_NO_UNIQUE_ADDRESS iterator_t<Base> current_{};
-            RANGES_NO_UNIQUE_ADDRESS semiregular_box_t<range_value_t<Rng>> sum_;
-
-        public:
-            using single_pass = meta::bool_<single_pass_iterator_<iterator_t<Base>>>;
-
-            cursor() = default;
-            constexpr explicit cursor(Parent * rng)
-              : parent_{rng}
-              , current_(ranges::begin(rng->base_))
-            {
-                if(current_ != ranges::end(rng->base_))
-                    sum_ = *current_;
-            }
-            template(bool Other)(
-                /// \pre
-                requires IsConst AND CPP_NOT(Other) AND
-                convertible_to<iterator_t<Rng> const &,
-                               iterator_t<Base>>)
-            constexpr cursor(cursor<Other> const & that)
-              : parent_{that.parent_}
-              , current_(that.current_)
-              , sum_(that.sum_)
-            {}
-            constexpr range_value_t<Rng> read() const
-            {
-                RANGES_EXPECT(current_ != ranges::end(parent_->base_));
-                return sum_;
-            }
-            constexpr void next()
-            {
-                auto last = ranges::end(parent_->base_);
-                RANGES_EXPECT(current_ != last);
-                if(++current_ != last)
-                {
-                    auto & sum = static_cast<range_value_t<Rng> &>(sum_);
-                    using F = meta::const_if_c<IsConst, Fun>;
-                    auto & f = static_cast<F &>(parent_->fun_);
-                    sum = invoke(f, sum, *current_);
-                }
-            }
-            constexpr bool equal(default_sentinel_t) const
-            {
-                return current_ == ranges::end(parent_->base_);
-            }
-            CPP_member
-            constexpr bool CPP_fun(equal)(cursor const & that)(const //
-                requires equality_comparable<iterator_t<Base>>)
-            {
-                RANGES_EXPECT(parent_ == that.parent_);
-                return current_ == that.current_;
-            }
-        };
-
-        constexpr cursor<false> begin_cursor()
-        {
-            return cursor<false>{this};
-        }
-        template(typename CRng = Rng const)(
-            /// \pre
-            requires detail::partial_sum_view_constraints<CRng, Fun const>)
-        constexpr cursor<true> begin_cursor() const
-        {
-            return cursor<true>{this};
-        }
-
-    public:
-        partial_sum_view() = default;
-        constexpr partial_sum_view(Rng rng, Fun fun) noexcept(
-            std::is_nothrow_move_constructible<Rng>::value &&
-                std::is_nothrow_move_constructible<Fun>::value)
-          : base_(std::move(rng))
-          , fun_(std::move(fun))
-        {}
-        CPP_member
-        constexpr auto CPP_fun(size)()(
-            /// \pre
-            requires sized_range<Rng>)
-        {
-            return ranges::size(base_);
-        }
-        CPP_member
-        constexpr auto CPP_fun(size)()(const //
-            requires sized_range<Rng const>)
-        {
-            return ranges::size(base_);
-        }
-    };
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template(typename Rng, typename Fun)(
-        /// \pre
-        requires copy_constructible<Fun>)
-    partial_sum_view(Rng &&, Fun)
-        -> partial_sum_view<views::all_t<Rng>, Fun>;
-#endif
-
-    namespace views
-    {
-        struct partial_sum_base_fn
-        {
-            template(typename Rng, typename Fun = plus)(
-                /// \pre
-                requires detail::partial_sum_view_constraints<all_t<Rng>, Fun>)
-            constexpr partial_sum_view<all_t<Rng>, Fun> //
-            operator()(Rng && rng, Fun fun = {}) const
-            {
-                return {all(static_cast<Rng &&>(rng)), std::move(fun)};
-            }
-        };
-
-        struct partial_sum_fn : partial_sum_base_fn
-        {
-            using partial_sum_base_fn::operator();
-
-            template(typename Fun)(
-                /// \pre
-                requires (!range<Fun>))
-            constexpr auto operator()(Fun && fun) const
-            {
-                return make_view_closure(
-                    bind_back(partial_sum_base_fn{}, static_cast<Fun &&>(fun)));
-            }
-            template<typename Fun = plus>
-            RANGES_DEPRECATED(
-                "Use \"ranges::views::partial_sum\" instead of "
-                "\"ranges::views::partial_sum()\".")
-            constexpr auto
-            operator()() const
-            {
-                return make_view_closure(bind_back(partial_sum_base_fn{}, Fun{}));
-            }
-        };
-
-        /// \relates partial_sum_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(view_closure<partial_sum_fn>, partial_sum)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::partial_sum_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/ref.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/ref.hpp
deleted file mode 100644
index 66dce196..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/ref.hpp
+++ /dev/null
@@ -1,129 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_REF_HPP
-#define RANGES_V3_VIEW_REF_HPP
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/addressof.hpp>
-#include <range/v3/view/interface.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    template<typename Rng>
-    struct ref_view;
-
-    template<typename Rng>
-    RANGES_INLINE_VAR constexpr bool enable_borrowed_range<ref_view<Rng>> = true;
-
-    /// \addtogroup group-views
-    /// @{
-    template<typename Rng>
-    struct ref_view : view_interface<ref_view<Rng>, range_cardinality<Rng>::value>
-    {
-    private:
-        CPP_assert(range<Rng>);
-        static_assert(std::is_object<Rng>::value, "");
-        Rng * rng_ = nullptr; // exposition only
-    public:
-        constexpr ref_view() noexcept = default;
-        constexpr ref_view(Rng & rng) noexcept
-          : rng_(detail::addressof(rng))
-        {}
-        constexpr Rng & base() const noexcept
-        {
-            return *rng_;
-        }
-        constexpr iterator_t<Rng> begin() const noexcept(noexcept(ranges::begin(*rng_)))
-        {
-            return ranges::begin(*rng_);
-        }
-        constexpr sentinel_t<Rng> end() const noexcept(noexcept(ranges::end(*rng_)))
-        {
-            return ranges::end(*rng_);
-        }
-        CPP_member
-        constexpr auto empty() const noexcept(noexcept(ranges::empty(*rng_)))
-            -> CPP_ret(bool)(
-                /// \pre
-                requires detail::can_empty_<Rng>)
-        {
-            return ranges::empty(*rng_);
-        }
-        CPP_member
-        constexpr auto CPP_fun(size)()(const //
-            noexcept(noexcept(ranges::size(*rng_))) //
-            requires sized_range<Rng>)
-        {
-            return ranges::size(*rng_);
-        }
-        CPP_member
-        constexpr auto CPP_fun(data)()(const //
-            noexcept(noexcept(ranges::data(*rng_))) //
-            requires contiguous_range<Rng>)
-        {
-            return ranges::data(*rng_);
-        }
-    };
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template(typename R)(
-        /// \pre
-        requires range<R>)
-    ref_view(R &) //
-        -> ref_view<R>;
-#endif
-
-    namespace views
-    {
-        struct ref_fn
-        {
-            template(typename Rng)(
-                /// \pre
-                requires range<Rng>)
-            constexpr ref_view<Rng> operator()(Rng & rng) const noexcept
-            {
-                return ref_view<Rng>(rng);
-            }
-            template<typename Rng>
-            void operator()(Rng const && rng) const = delete;
-        };
-
-        /// \relates const_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(ref_fn, ref)
-    } // namespace views
-
-    namespace cpp20
-    {
-        template(typename Rng)(
-            /// \pre
-            requires std::is_object<Rng>::value) //
-            using ref_view = ranges::ref_view<Rng>;
-    }
-} // namespace ranges
-
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::ref_view)
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/remove.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/remove.hpp
deleted file mode 100644
index 833d73bb..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/remove.hpp
+++ /dev/null
@@ -1,113 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Andrey Diduh 2019
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_REMOVE_HPP
-#define RANGES_V3_VIEW_REMOVE_HPP
-
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/view/remove_if.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    namespace views
-    {
-        struct remove_base_fn
-        {
-        private:
-            template<typename Value>
-            struct pred_
-            {
-                Value value_;
-                template(typename T)(
-                    /// \pre
-                    requires equality_comparable_with<T, Value const &>)
-                bool operator()(T && other) const
-                {
-                    return static_cast<T &&>(other) == value_;
-                }
-            };
-
-        public:
-            template(typename Rng, typename Value)(
-                /// \pre
-                requires move_constructible<Value> AND viewable_range<Rng> AND
-                    input_range<Rng> AND
-                    indirectly_comparable<iterator_t<Rng>, Value const *, equal_to>)
-            constexpr auto operator()(Rng && rng, Value value) const
-            {
-                return remove_if(static_cast<Rng &&>(rng),
-                                 pred_<Value>{std::move(value)});
-            }
-
-            template(typename Rng, typename Value, typename Proj)(
-                /// \pre
-                requires move_constructible<Value> AND viewable_range<Rng> AND
-                    input_range<Rng> AND
-                    indirectly_comparable<iterator_t<Rng>, Value const *, equal_to, Proj>)
-            constexpr auto operator()(Rng && rng, Value value, Proj proj) const
-            {
-                return remove_if(static_cast<Rng &&>(rng),
-                                 pred_<Value>{std::move(value)},
-                                 std::move(proj));
-            }
-        };
-
-        struct remove_bind_fn
-        {
-            template<typename Value>
-            constexpr auto operator()(Value value) const // TODO: underconstrained
-            {
-                return make_view_closure(bind_back(remove_base_fn{}, std::move(value)));
-            }
-            template(typename Value, typename Proj)(
-                /// \pre
-                requires (!range<Value>)) // TODO: underconstrained
-            constexpr auto operator()(Value && value, Proj proj) const
-            {
-                return make_view_closure(bind_back(
-                    remove_base_fn{}, static_cast<Value &&>(value), std::move(proj)));
-            }
-        };
-
-        struct RANGES_EMPTY_BASES remove_fn
-          : remove_base_fn, remove_bind_fn
-        {
-            using remove_base_fn::operator();
-            using remove_bind_fn::operator();
-        };
-
-        /// \relates remove_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(remove_fn, remove)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif // RANGES_V3_VIEW_REMOVE_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/remove_if.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/remove_if.hpp
deleted file mode 100644
index 9e04115e..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/remove_if.hpp
+++ /dev/null
@@ -1,216 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_REMOVE_IF_HPP
-#define RANGES_V3_VIEW_REMOVE_IF_HPP
-
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/functional/compose.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/box.hpp>
-#include <range/v3/utility/optional.hpp>
-#include <range/v3/utility/semiregular_box.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/adaptor.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    template<typename Rng, typename Pred>
-    struct RANGES_EMPTY_BASES remove_if_view
-      : view_adaptor<remove_if_view<Rng, Pred>, Rng,
-                     is_finite<Rng>::value ? finite : range_cardinality<Rng>::value>
-      , private box<semiregular_box_t<Pred>>
-    {
-        remove_if_view() = default;
-        constexpr remove_if_view(Rng rng, Pred pred)
-          : remove_if_view::view_adaptor{detail::move(rng)}
-          , remove_if_view::box(detail::move(pred))
-        {}
-
-    private:
-        friend range_access;
-
-        struct adaptor : adaptor_base
-        {
-            adaptor() = default;
-            constexpr adaptor(remove_if_view * rng) noexcept
-              : rng_(rng)
-            {}
-            static constexpr iterator_t<Rng> begin(remove_if_view & rng)
-            {
-                return *rng.begin_;
-            }
-            constexpr void next(iterator_t<Rng> & it) const
-            {
-                RANGES_ASSERT(it != ranges::end(rng_->base()));
-                rng_->satisfy_forward(++it);
-            }
-            CPP_member
-            constexpr auto prev(iterator_t<Rng> & it) const //
-                -> CPP_ret(void)(
-                    /// \pre
-                    requires bidirectional_range<Rng>)
-            {
-                rng_->satisfy_reverse(it);
-            }
-            void advance() = delete;
-            void distance_to() = delete;
-
-        private:
-            remove_if_view * rng_;
-        };
-        constexpr adaptor begin_adaptor()
-        {
-            cache_begin();
-            return {this};
-        }
-        CPP_member
-        constexpr auto end_adaptor() const noexcept //
-            -> CPP_ret(adaptor_base)(
-                /// \pre
-                requires (!common_range<Rng>))
-        {
-            return {};
-        }
-        CPP_member
-        constexpr auto end_adaptor() //
-            -> CPP_ret(adaptor)(
-                /// \pre
-                requires common_range<Rng>)
-        {
-            if(bidirectional_range<Rng>)
-                cache_begin();
-            return {this};
-        }
-
-        constexpr void satisfy_forward(iterator_t<Rng> & it)
-        {
-            auto const last = ranges::end(this->base());
-            auto & pred = this->remove_if_view::box::get();
-            while(it != last && invoke(pred, *it))
-                ++it;
-        }
-        constexpr void satisfy_reverse(iterator_t<Rng> & it)
-        {
-            RANGES_ASSERT(begin_);
-            auto const & first = *begin_;
-            auto & pred = this->remove_if_view::box::get();
-            do
-            {
-                RANGES_ASSERT(it != first);
-                (void)first;
-                --it;
-            } while(invoke(pred, *it));
-        }
-
-        constexpr void cache_begin()
-        {
-            if(begin_)
-                return;
-            auto it = ranges::begin(this->base());
-            satisfy_forward(it);
-            begin_.emplace(std::move(it));
-        }
-
-        detail::non_propagating_cache<iterator_t<Rng>> begin_;
-    };
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template(typename Rng, typename Pred)(
-        /// \pre
-        requires copy_constructible<Pred>)
-    remove_if_view(Rng &&, Pred)
-        -> remove_if_view<views::all_t<Rng>, Pred>;
-#endif
-
-    namespace views
-    {
-        /// Given a source range, unary predicate, and optional projection,
-        /// present a view of the elements that do not satisfy the predicate.
-        struct remove_if_base_fn
-        {
-            template(typename Rng, typename Pred)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng> AND
-                    indirect_unary_predicate<Pred, iterator_t<Rng>>)
-            constexpr remove_if_view<all_t<Rng>, Pred> operator()(Rng && rng, Pred pred)
-                const
-            {
-                return remove_if_view<all_t<Rng>, Pred>{all(static_cast<Rng &&>(rng)),
-                                                        std::move(pred)};
-            }
-            template(typename Rng, typename Pred, typename Proj)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng> AND
-                    indirect_unary_predicate<Pred, projected<iterator_t<Rng>, Proj>>)
-            constexpr remove_if_view<all_t<Rng>, composed<Pred, Proj>> //
-            operator()(Rng && rng, Pred pred, Proj proj) const
-            {
-                return remove_if_view<all_t<Rng>, composed<Pred, Proj>>{
-                    all(static_cast<Rng &&>(rng)),
-                    compose(std::move(pred), std::move(proj))};
-            }
-        };
-
-        struct remove_if_bind_fn
-        {
-            template<typename Pred>
-            constexpr auto operator()(Pred pred) const // TODO: underconstrained
-            {
-                return make_view_closure(bind_back(remove_if_base_fn{}, std::move(pred)));
-            }
-            template(typename Pred, typename Proj)(
-                /// \pre
-                requires (!range<Pred>)) // TODO: underconstrained
-            constexpr auto operator()(Pred && pred, Proj proj) const
-            {
-                return make_view_closure(bind_back(
-                    remove_if_base_fn{}, static_cast<Pred &&>(pred), std::move(proj)));
-            }
-        };
-
-        struct RANGES_EMPTY_BASES remove_if_fn
-          : remove_if_base_fn, remove_if_bind_fn
-        {
-            using remove_if_base_fn::operator();
-            using remove_if_bind_fn::operator();
-        };
-
-        /// \relates remove_if_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(remove_if_fn, remove_if)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::remove_if_view)
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/repeat.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/repeat.hpp
deleted file mode 100644
index bc366c78..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/repeat.hpp
+++ /dev/null
@@ -1,124 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_REPEAT_HPP
-#define RANGES_V3_VIEW_REPEAT_HPP
-
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/unreachable_sentinel.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/utility/semiregular_box.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/facade.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-
-    // Ordinarily, a view shouldn't contain its elements. This is so that copying
-    // and assigning ranges is O(1), and also so that in the event of element
-    // mutation, all the copies of the range see the mutation the same way. The
-    // repeat_view *does* own its lone element, though. This is OK because:
-    //  - O(N) copying is fine when N==1 as it is in this case, and
-    //  - The element is immutable, so there is no potential for incorrect
-    //    semantics.
-    template<typename Val>
-    struct repeat_view : view_facade<repeat_view<Val>, infinite>
-    {
-    private:
-        semiregular_box_t<Val> value_;
-        friend range_access;
-
-        struct cursor
-        {
-        private:
-            Val const * value_;
-            std::ptrdiff_t n_ = 0;
-
-        public:
-            cursor() = default;
-            explicit cursor(Val const & value)
-              : value_(std::addressof(value))
-            {}
-            Val const & read() const noexcept
-            {
-                return *value_;
-            }
-            bool equal(cursor const & that) const
-            {
-                return n_ == that.n_;
-            }
-            void next()
-            {
-                ++n_;
-            }
-            void prev()
-            {
-                --n_;
-            }
-            void advance(std::ptrdiff_t d)
-            {
-                n_ += d;
-            }
-            std::ptrdiff_t distance_to(cursor const & that) const
-            {
-                return that.n_ - n_;
-            }
-        };
-        cursor begin_cursor() const
-        {
-            return cursor{value_};
-        }
-        unreachable_sentinel_t end_cursor() const
-        {
-            return unreachable;
-        }
-
-    public:
-        repeat_view() = default;
-        constexpr explicit repeat_view(Val value)
-          : value_(detail::move(value))
-        {}
-    };
-
-    namespace views
-    {
-        struct repeat_fn
-        {
-            template(typename Val)(
-                /// \pre
-                requires copy_constructible<Val>)
-            repeat_view<Val> operator()(Val value) const
-            {
-                return repeat_view<Val>{std::move(value)};
-            }
-        };
-
-        /// \relates repeat_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(repeat_fn, repeat)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::repeat_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/repeat_n.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/repeat_n.hpp
deleted file mode 100644
index 80dda8fb..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/repeat_n.hpp
+++ /dev/null
@@ -1,132 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_REPEAT_N_HPP
-#define RANGES_V3_VIEW_REPEAT_N_HPP
-
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/default_sentinel.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/utility/semiregular_box.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/facade.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-
-    // Ordinarily, a view shouldn't contain its elements. This is so that copying
-    // and assigning ranges is O(1), and also so that in the event of element
-    // mutation, all the copies of the range see the mutation the same way. The
-    // repeat_n_view *does* own its lone element, though. This is OK because:
-    //  - O(N) copying is fine when N==1 as it is in this case, and
-    //  - The element is immutable, so there is no potential for incorrect
-    //    semantics.
-    template<typename Val>
-    struct repeat_n_view : view_facade<repeat_n_view<Val>, finite>
-    {
-    private:
-        friend range_access;
-        semiregular_box_t<Val> value_;
-        std::ptrdiff_t n_;
-
-        struct cursor
-        {
-        private:
-            Val const * value_;
-            std::ptrdiff_t n_;
-
-        public:
-            cursor() = default;
-            cursor(Val const & value, std::ptrdiff_t n)
-              : value_(std::addressof(value))
-              , n_(n)
-            {}
-            Val const & read() const
-            {
-                return *value_;
-            }
-            constexpr bool equal(default_sentinel_t) const
-            {
-                return 0 == n_;
-            }
-            bool equal(cursor const & that) const
-            {
-                return n_ == that.n_;
-            }
-            void next()
-            {
-                RANGES_EXPECT(0 != n_);
-                --n_;
-            }
-            void prev()
-            {
-                ++n_;
-            }
-            void advance(std::ptrdiff_t n)
-            {
-                n_ -= n;
-            }
-            std::ptrdiff_t distance_to(cursor const & that) const
-            {
-                return n_ - that.n_;
-            }
-        };
-        cursor begin_cursor() const
-        {
-            return {value_, n_};
-        }
-
-    public:
-        repeat_n_view() = default;
-        constexpr repeat_n_view(Val value, std::ptrdiff_t n)
-          : value_(detail::move(value))
-          , n_((RANGES_EXPECT(0 <= n), n))
-        {}
-        constexpr std::size_t size() const
-        {
-            return static_cast<std::size_t>(n_);
-        }
-    };
-
-    namespace views
-    {
-        struct repeat_n_fn
-        {
-            template(typename Val)(
-                /// \pre
-                requires copy_constructible<Val>)
-            repeat_n_view<Val> operator()(Val value, std::ptrdiff_t n) const
-            {
-                return repeat_n_view<Val>{std::move(value), n};
-            }
-        };
-
-        /// \relates repeat_n_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(repeat_n_fn, repeat_n)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::repeat_n_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/replace.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/replace.hpp
deleted file mode 100644
index fadfa20e..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/replace.hpp
+++ /dev/null
@@ -1,144 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_REPLACE_HPP
-#define RANGES_V3_VIEW_REPLACE_HPP
-
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/transform.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        template<typename Val1, typename Val2>
-        struct replacer_fn
-        {
-        private:
-            Val1 old_value_;
-            Val2 new_value_;
-
-        public:
-            replacer_fn() = default;
-            constexpr replacer_fn(Val1 old_value, Val2 new_value)
-              : old_value_(std::move(old_value))
-              , new_value_(std::move(new_value))
-            {}
-
-            template<typename I>
-            [[noreturn]] common_type_t<decay_t<unwrap_reference_t<Val2 const &>>,
-                                       iter_value_t<I>> &
-            operator()(copy_tag, I const &) const
-            {
-                RANGES_EXPECT(false);
-            }
-
-            template<typename I>
-            common_reference_t<unwrap_reference_t<Val2 const &>, iter_reference_t<I>>
-            operator()(I const & i) const
-            {
-                auto && x = *i;
-                if(x == unwrap_reference(old_value_))
-                    return unwrap_reference(new_value_);
-                return ((decltype(x) &&)x);
-            }
-
-            template<typename I>
-            common_reference_t<unwrap_reference_t<Val2 const &>,
-                               iter_rvalue_reference_t<I>>
-            operator()(move_tag, I const & i) const
-            {
-                auto && x = iter_move(i);
-                if(x == unwrap_reference(old_value_))
-                    return unwrap_reference(new_value_);
-                return ((decltype(x) &&)x);
-            }
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// \addtogroup group-views
-    /// @{
-    namespace views
-    {
-        struct replace_base_fn
-        {
-            template(typename Rng, typename Val1, typename Val2)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng> AND
-                    same_as<
-                        detail::decay_t<unwrap_reference_t<Val1>>,
-                        detail::decay_t<unwrap_reference_t<Val2>>> AND
-                    equality_comparable_with<
-                        detail::decay_t<unwrap_reference_t<Val1>>,
-                        range_value_t<Rng>> AND
-                    common_with<detail::decay_t<unwrap_reference_t<Val2 const &>>,
-                                range_value_t<Rng>> AND
-                    common_reference_with<unwrap_reference_t<Val2 const &>,
-                                            range_reference_t<Rng>> AND
-                    common_reference_with<
-                        unwrap_reference_t<Val2 const &>,
-                        range_rvalue_reference_t<Rng>>)
-            constexpr replace_view< //
-                all_t<Rng>, //
-                detail::decay_t<Val1>, //
-                detail::decay_t<Val2>> //
-            operator()(Rng && rng, Val1 && old_value,
-                                      Val2 && new_value) const //
-            {
-                return {
-                    all(static_cast<Rng &&>(rng)),
-                    {static_cast<Val1 &&>(old_value), static_cast<Val2 &&>(new_value)}};
-            }
-        };
-
-        struct replace_fn : replace_base_fn
-        {
-            using replace_base_fn::operator();
-
-            template(typename Val1, typename Val2)(
-                /// \pre
-                requires same_as<detail::decay_t<unwrap_reference_t<Val1>>,
-                                 detail::decay_t<unwrap_reference_t<Val2>>>)
-            constexpr auto operator()(Val1 old_value, Val2 new_value) const
-            {
-                return make_view_closure(bind_back(
-                    replace_base_fn{}, std::move(old_value), std::move(new_value)));
-            }
-        };
-
-        /// \relates replace_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(replace_fn, replace)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/replace_if.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/replace_if.hpp
deleted file mode 100644
index 8eee0e58..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/replace_if.hpp
+++ /dev/null
@@ -1,162 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_REPLACE_IF_HPP
-#define RANGES_V3_VIEW_REPLACE_IF_HPP
-
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/utility/compressed_pair.hpp>
-#include <range/v3/utility/semiregular_box.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/transform.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        template<typename Pred, typename Val>
-        struct replacer_if_fn : compressed_pair<semiregular_box_t<Pred>, Val>
-        {
-        private:
-            using base_t = compressed_pair<semiregular_box_t<Pred>, Val>;
-            using base_t::first;
-            using base_t::second;
-
-        public:
-            replacer_if_fn() = default;
-            constexpr replacer_if_fn(Pred pred, Val new_value)
-              : base_t{std::move(pred), std::move(new_value)}
-            {}
-
-            template<typename I>
-            [[noreturn]] common_type_t<decay_t<unwrap_reference_t<Val const &>>,
-                                       iter_value_t<I>> &
-            operator()(copy_tag, I const &) const
-            {
-                RANGES_EXPECT(false);
-            }
-
-            template(typename I)(
-                /// \pre
-                requires (!invocable<Pred const &, iter_reference_t<I>>))
-            common_reference_t<unwrap_reference_t<Val const &>, iter_reference_t<I>> //
-            operator()(I const & i)
-            {
-                auto && x = *i;
-                if(invoke(first(), (decltype(x) &&)x)) //
-                    return unwrap_reference(second());
-                return (decltype(x) &&)x;
-            }
-            template(typename I)(
-                /// \pre
-                requires invocable<Pred const &, iter_reference_t<I>>)
-            common_reference_t<unwrap_reference_t<Val const &>, iter_reference_t<I>> //
-            operator()(I const & i) const
-            {
-                auto && x = *i;
-                if(invoke(first(), (decltype(x) &&)x)) //
-                    return unwrap_reference(second());
-                return (decltype(x) &&)x;
-            }
-
-            template(typename I)(
-                /// \pre
-                requires (!invocable<Pred const &, iter_rvalue_reference_t<I>>))
-            common_reference_t<
-                unwrap_reference_t<Val const &>, //
-                iter_rvalue_reference_t<I>> //
-            operator()(move_tag, I const & i)
-            {
-                auto && x = iter_move(i);
-                if(invoke(first(), (decltype(x) &&)x)) //
-                    return unwrap_reference(second());
-                return (decltype(x) &&)x;
-            }
-            template(typename I)(
-                /// \pre
-                requires invocable<Pred const &, iter_rvalue_reference_t<I>>)
-            common_reference_t< //
-                unwrap_reference_t<Val const &>, //
-                iter_rvalue_reference_t<I>> //
-            operator()(move_tag, I const & i) const
-            {
-                auto && x = iter_move(i);
-                if(invoke(first(), (decltype(x) &&)x)) //
-                    return unwrap_reference(second());
-                return (decltype(x) &&)x;
-            }
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// \addtogroup group-views
-    /// @{
-    namespace views
-    {
-        struct replace_if_base_fn
-        {
-            template(typename Rng, typename Pred, typename Val)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng> AND
-                    indirect_unary_predicate<Pred, iterator_t<Rng>> AND
-                    common_with<detail::decay_t<unwrap_reference_t<Val const &>>,
-                                range_value_t<Rng>> AND
-                    common_reference_with<unwrap_reference_t<Val const &>,
-                                          range_reference_t<Rng>> AND
-                    common_reference_with<unwrap_reference_t<Val const &>,
-                                          range_rvalue_reference_t<Rng>>)
-            constexpr replace_if_view<all_t<Rng>, Pred, Val> //
-            operator()(Rng && rng, Pred pred, Val new_value) const
-            {
-                return {all(static_cast<Rng &&>(rng)),
-                        {std::move(pred), std::move(new_value)}};
-            }
-        };
-
-        struct replace_if_fn : replace_if_base_fn
-        {
-            using replace_if_base_fn::operator();
-
-            template<typename Pred, typename Val>
-            constexpr auto operator()(Pred pred, Val new_value) const
-            {
-                return make_view_closure(bind_back(
-                    replace_if_base_fn{}, std::move(pred), std::move(new_value)));
-            }
-        };
-
-        /// \relates replace_if_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(replace_if_fn, replace_if)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/reverse.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/reverse.hpp
deleted file mode 100644
index 066b29cd..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/reverse.hpp
+++ /dev/null
@@ -1,191 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_REVERSE_HPP
-#define RANGES_V3_VIEW_REVERSE_HPP
-
-#include <iterator>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/reverse_iterator.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/box.hpp>
-#include <range/v3/utility/get.hpp>
-#include <range/v3/utility/optional.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/adaptor.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    template<typename Rng>
-    struct RANGES_EMPTY_BASES reverse_view
-      : view_interface<reverse_view<Rng>, range_cardinality<Rng>::value>
-      , private detail::non_propagating_cache<iterator_t<Rng>, reverse_view<Rng>,
-                                              !common_range<Rng>>
-    {
-    private:
-        CPP_assert(bidirectional_range<Rng>);
-        Rng rng_;
-        constexpr reverse_iterator<iterator_t<Rng>> begin_(std::true_type)
-        {
-            return make_reverse_iterator(ranges::end(rng_));
-        }
-        constexpr reverse_iterator<iterator_t<Rng>> begin_(std::false_type)
-        {
-            using cache_t =
-                detail::non_propagating_cache<iterator_t<Rng>, reverse_view<Rng>>;
-            auto & end_ = static_cast<cache_t &>(*this);
-            if(!end_)
-            {
-#if defined(_MSC_VER)
-                auto tmp = ranges::begin(rng_);
-                auto e = ranges::end(rng_);
-                while(tmp != e)
-                    ++tmp;
-#else
-                auto tmp = ranges::next(ranges::begin(rng_), ranges::end(rng_));
-#endif
-                end_ = std::move(tmp);
-            }
-            return make_reverse_iterator(*end_);
-        }
-
-    public:
-        reverse_view() = default;
-        constexpr explicit reverse_view(Rng rng)
-          : rng_(detail::move(rng))
-        {}
-        Rng base() const
-        {
-            return rng_;
-        }
-        constexpr reverse_iterator<iterator_t<Rng>> begin()
-        {
-            return begin_(meta::bool_<(bool)common_range<Rng>>{});
-        }
-        template(bool Const = true)(
-            /// \pre
-            requires Const AND common_range<meta::const_if_c<Const, Rng>>)
-        constexpr reverse_iterator<iterator_t<meta::const_if_c<Const, Rng>>> begin() const
-        {
-            return make_reverse_iterator(ranges::end(rng_));
-        }
-        constexpr reverse_iterator<iterator_t<Rng>> end()
-        {
-            return make_reverse_iterator(ranges::begin(rng_));
-        }
-        template(bool Const = true)(
-            /// \pre
-            requires Const AND common_range<meta::const_if_c<Const, Rng>>)
-        constexpr reverse_iterator<iterator_t<meta::const_if_c<Const, Rng>>> end() const
-        {
-            return make_reverse_iterator(ranges::begin(rng_));
-        }
-        CPP_member
-        constexpr auto CPP_fun(size)()(
-            /// \pre
-            requires sized_range<Rng>)
-        {
-            return ranges::size(rng_);
-        }
-        CPP_member
-        constexpr auto CPP_fun(size)()(const //
-            requires sized_range<Rng const>)
-        {
-            return ranges::size(rng_);
-        }
-    };
-
-    template<typename Rng>
-    struct reverse_view<reverse_view<Rng>> : Rng
-    {
-        CPP_assert(bidirectional_range<Rng>);
-        CPP_assert(
-            same_as<detail::decay_t<decltype(std::declval<reverse_view<Rng>>().base())>,
-                    Rng>);
-
-        reverse_view() = default;
-        constexpr explicit reverse_view(reverse_view<Rng> rng)
-          : Rng(rng.base())
-        {}
-
-        constexpr reverse_view<Rng> base() const
-        {
-            return reverse_view<Rng>{*this};
-        }
-    };
-
-    template<typename Rng>
-    RANGES_INLINE_VAR constexpr bool enable_borrowed_range<reverse_view<Rng>> =
-        enable_borrowed_range<Rng>;
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template<typename Rng>
-    reverse_view(Rng &&) //
-        -> reverse_view<views::all_t<Rng>>;
-
-    template<typename Rng>
-    reverse_view(reverse_view<Rng>)
-        -> reverse_view<reverse_view<Rng>>;
-#endif
-
-    namespace views
-    {
-        struct reverse_fn
-        {
-            template(typename Rng)(
-                /// \pre
-                requires viewable_range<Rng> AND bidirectional_range<Rng>)
-            constexpr reverse_view<all_t<Rng>> operator()(Rng && rng) const
-            {
-                return reverse_view<all_t<Rng>>{all(static_cast<Rng &&>(rng))};
-            }
-        };
-
-        /// \relates reverse_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(view_closure<reverse_fn>, reverse)
-    } // namespace views
-
-    namespace cpp20
-    {
-        namespace views
-        {
-            using ranges::views::reverse;
-        }
-        template(typename Rng)(
-            /// \pre
-            requires view_<Rng> AND bidirectional_range<Rng>)
-        using reverse_view = ranges::reverse_view<Rng>;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::reverse_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/sample.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/sample.hpp
deleted file mode 100644
index 222658ce..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/sample.hpp
+++ /dev/null
@@ -1,271 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_SAMPLE_HPP
-#define RANGES_V3_VIEW_SAMPLE_HPP
-
-#include <meta/meta.hpp>
-
-#include <range/v3/algorithm/shuffle.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/default_sentinel.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/facade.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        template<typename Rng,
-                 bool = (bool)sized_sentinel_for<sentinel_t<Rng>, iterator_t<Rng>>>
-        class size_tracker
-        {
-            range_difference_t<Rng> size_;
-
-        public:
-            CPP_assert(forward_range<Rng> || sized_range<Rng>);
-            size_tracker() = default;
-            size_tracker(Rng & rng)
-              : size_(ranges::distance(rng))
-            {}
-            void decrement()
-            {
-                --size_;
-            }
-            range_difference_t<Rng> get(Rng &, iterator_t<Rng> &) const
-            {
-                return size_;
-            }
-        };
-
-        // Impl for sized_sentinel_for (no need to store anything)
-        template<typename Rng>
-        class size_tracker<Rng, true>
-        {
-        public:
-            size_tracker() = default;
-            size_tracker(Rng &)
-            {}
-            void decrement()
-            {}
-            range_difference_t<Rng> get(Rng & rng, iterator_t<Rng> const & it) const
-            {
-                return ranges::end(rng) - it;
-            }
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// \addtogroup group-views
-    /// @{
-
-    // Take a random sampling from another view
-    template<typename Rng, typename URNG>
-    class sample_view : public view_facade<sample_view<Rng, URNG>, finite>
-    {
-        friend range_access;
-        using D = range_difference_t<Rng>;
-        Rng rng_;
-        // Mutable is OK here because sample_view is an Input view.
-        mutable range_difference_t<Rng> size_;
-        URNG * engine_;
-
-        template<bool IsConst>
-        class cursor
-        {
-            friend cursor<!IsConst>;
-
-            using Base = meta::const_if_c<IsConst, Rng>;
-            meta::const_if_c<IsConst, sample_view> * parent_;
-            iterator_t<Base> current_;
-            RANGES_NO_UNIQUE_ADDRESS detail::size_tracker<Base> size_;
-
-            D pop_size()
-            {
-                return size_.get(parent_->rng_, current_);
-            }
-            void advance()
-            {
-                if(parent_->size_ > 0)
-                {
-                    using Dist = std::uniform_int_distribution<D>;
-                    Dist dist{};
-                    URNG & engine = *parent_->engine_;
-
-                    for(;; ++current_, size_.decrement())
-                    {
-                        RANGES_ASSERT(current_ != ranges::end(parent_->rng_));
-                        auto n = pop_size();
-                        RANGES_EXPECT(n > 0);
-                        typename Dist::param_type const interval{0, n - 1};
-                        if(dist(engine, interval) < parent_->size_)
-                            break;
-                    }
-                }
-            }
-
-        public:
-            using value_type = range_value_t<Rng>;
-            using difference_type = D;
-
-            cursor() = default;
-            explicit cursor(meta::const_if_c<IsConst, sample_view> * rng)
-              : parent_(rng)
-              , current_(ranges::begin(rng->rng_))
-              , size_{rng->rng_}
-            {
-                auto n = pop_size();
-                if(rng->size_ > n)
-                    rng->size_ = n;
-                advance();
-            }
-            template(bool Other)(
-                /// \pre
-                requires IsConst AND CPP_NOT(Other)) //
-            cursor(cursor<Other> that)
-              : parent_(that.parent_)
-              , current_(std::move(that.current_))
-              , size_(that.size_)
-            {}
-            range_reference_t<Rng> read() const
-            {
-                return *current_;
-            }
-            bool equal(default_sentinel_t) const
-            {
-                RANGES_EXPECT(parent_);
-                return parent_->size_ <= 0;
-            }
-            void next()
-            {
-                RANGES_EXPECT(parent_);
-                RANGES_EXPECT(parent_->size_ > 0);
-                --parent_->size_;
-                RANGES_ASSERT(current_ != ranges::end(parent_->rng_));
-                ++current_;
-                size_.decrement();
-                advance();
-            }
-        };
-
-        cursor<false> begin_cursor()
-        {
-            return cursor<false>{this};
-        }
-        template(bool Const = true)(
-            /// \pre
-            requires Const AND
-            (sized_range<meta::const_if_c<Const, Rng>> ||
-             sized_sentinel_for<sentinel_t<meta::const_if_c<Const, Rng>>,
-                                iterator_t<meta::const_if_c<Const, Rng>>> ||
-             forward_range<meta::const_if_c<Const, Rng>>)) //
-        cursor<Const> begin_cursor() const
-        {
-            return cursor<true>{this};
-        }
-
-    public:
-        sample_view() = default;
-
-        explicit sample_view(Rng rng, D sample_size, URNG & generator)
-          : rng_(std::move(rng))
-          , size_(sample_size)
-          , engine_(std::addressof(generator))
-        {
-            RANGES_EXPECT(sample_size >= 0);
-        }
-
-        Rng base() const
-        {
-            return rng_;
-        }
-    };
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template<typename Rng, typename URNG>
-    sample_view(Rng &&, range_difference_t<Rng>, URNG &)
-        ->sample_view<views::all_t<Rng>, URNG>;
-#endif
-
-    namespace views
-    {
-        /// Returns a random sample of a range of length `size(range)`.
-        struct sample_base_fn
-        {
-            template(typename Rng, typename URNG = detail::default_random_engine)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng> AND
-                    uniform_random_bit_generator<URNG> AND
-                    convertible_to<invoke_result_t<URNG &>, range_difference_t<Rng>> AND
-                    (sized_range<Rng> ||
-                     sized_sentinel_for<sentinel_t<Rng>, iterator_t<Rng>> ||
-                     forward_range<Rng>)) //
-            sample_view<all_t<Rng>, URNG> operator()(
-                Rng && rng,
-                range_difference_t<Rng> sample_size,
-                URNG & generator = detail::get_random_engine()) const
-            {
-                return sample_view<all_t<Rng>, URNG>{
-                    all(static_cast<Rng &&>(rng)), sample_size, generator};
-            }
-
-            /// \cond
-            template<typename Rng, typename URNG>
-            invoke_result_t<sample_base_fn, Rng, range_difference_t<Rng>, URNG &> //
-            operator()(
-                Rng && rng,
-                range_difference_t<Rng> sample_size,
-                detail::reference_wrapper_<URNG> r) const
-            {
-                return (*this)(static_cast<Rng &&>(rng), sample_size, r.get());
-            }
-            /// \endcond
-        };
-
-        struct sample_fn : sample_base_fn
-        {
-            using sample_base_fn::operator();
-
-            template(typename Size, typename URNG = detail::default_random_engine)(
-                /// \pre
-                requires integral<Size> AND uniform_random_bit_generator<URNG>)
-            constexpr auto operator()(
-                Size n,
-                URNG & urng = detail::get_random_engine()) const //
-            {
-                return make_view_closure(bind_back(
-                    sample_base_fn{}, n, detail::reference_wrapper_<URNG>(urng)));
-            }
-        };
-
-        /// \relates sample_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(sample_fn, sample)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::sample_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/set_algorithm.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/set_algorithm.hpp
deleted file mode 100644
index 2ad7591a..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/set_algorithm.hpp
+++ /dev/null
@@ -1,907 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//  Copyright Tomislav Ivek 2015-2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_SET_ALGORITHM_HPP
-#define RANGES_V3_VIEW_SET_ALGORITHM_HPP
-
-#include <algorithm>
-#include <iterator>
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/comparisons.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/default_sentinel.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/move.hpp>
-#include <range/v3/utility/semiregular_box.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/facade.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-
-    /// \cond
-    namespace detail
-    {
-        template<typename Rng1, typename Rng2, typename C, typename P1, typename P2,
-                 template<bool, typename...> class Cursor, cardinality Cardinality>
-        struct set_algorithm_view
-          : view_facade<set_algorithm_view<Rng1, Rng2, C, P1, P2, Cursor, Cardinality>,
-                        Cardinality>
-        {
-        private:
-            friend range_access;
-            semiregular_box_t<C> pred_;
-            semiregular_box_t<P1> proj1_;
-            semiregular_box_t<P2> proj2_;
-            Rng1 rng1_;
-            Rng2 rng2_;
-
-            template<bool IsConst>
-            using cursor = Cursor<IsConst, Rng1, Rng2, C, P1, P2>;
-
-            cursor<simple_view<Rng1>() && simple_view<Rng2>()> begin_cursor()
-            {
-                return {pred_,
-                        proj1_,
-                        proj2_,
-                        ranges::begin(rng1_),
-                        ranges::end(rng1_),
-                        ranges::begin(rng2_),
-                        ranges::end(rng2_)};
-            }
-            CPP_member
-            auto begin_cursor() const //
-                -> CPP_ret(cursor<true>)(
-                    /// \pre
-                    requires range<Rng1 const> && range<Rng2 const>)
-            {
-                return {pred_,
-                        proj1_,
-                        proj2_,
-                        ranges::begin(rng1_),
-                        ranges::end(rng1_),
-                        ranges::begin(rng2_),
-                        ranges::end(rng2_)};
-            }
-
-        public:
-            set_algorithm_view() = default;
-            set_algorithm_view(Rng1 rng1, Rng2 rng2, C pred, P1 proj1, P2 proj2)
-              : pred_(std::move(pred))
-              , proj1_(std::move(proj1))
-              , proj2_(std::move(proj2))
-              , rng1_(std::move(rng1))
-              , rng2_(std::move(rng2))
-            {}
-        };
-
-        template<bool IsConst, typename Rng1, typename Rng2, typename C, typename P1,
-                 typename P2>
-        struct set_difference_cursor
-        {
-        private:
-            friend struct set_difference_cursor<!IsConst, Rng1, Rng2, C, P1, P2>;
-            using pred_ref_ = semiregular_box_ref_or_val_t<C, IsConst>;
-            using proj1_ref_ = semiregular_box_ref_or_val_t<P1, IsConst>;
-            using proj2_ref_ = semiregular_box_ref_or_val_t<P2, IsConst>;
-            pred_ref_ pred_;
-            proj1_ref_ proj1_;
-            proj2_ref_ proj2_;
-
-            template<typename T>
-            using constify_if = meta::const_if_c<IsConst, T>;
-
-            using R1 = constify_if<Rng1>;
-            using R2 = constify_if<Rng2>;
-
-            iterator_t<R1> it1_;
-            sentinel_t<R1> end1_;
-
-            iterator_t<R2> it2_;
-            sentinel_t<R2> end2_;
-
-            void satisfy()
-            {
-                while(it1_ != end1_)
-                {
-                    if(it2_ == end2_)
-                        return;
-
-                    if(invoke(pred_, invoke(proj1_, *it1_), invoke(proj2_, *it2_)))
-                        return;
-
-                    if(!invoke(pred_, invoke(proj2_, *it2_), invoke(proj1_, *it1_)))
-                        ++it1_;
-
-                    ++it2_;
-                }
-            }
-
-        public:
-            using value_type = range_value_t<constify_if<Rng1>>;
-            using single_pass = meta::or_c<single_pass_iterator_<iterator_t<R1>>,
-                                           single_pass_iterator_<iterator_t<R2>>>;
-
-            set_difference_cursor() = default;
-            set_difference_cursor(pred_ref_ pred, proj1_ref_ proj1, proj2_ref_ proj2,
-                                  iterator_t<R1> it1, sentinel_t<R1> end1,
-                                  iterator_t<R2> it2, sentinel_t<R2> end2)
-              : pred_(std::move(pred))
-              , proj1_(std::move(proj1))
-              , proj2_(std::move(proj2))
-              , it1_(std::move(it1))
-              , end1_(std::move(end1))
-              , it2_(std::move(it2))
-              , end2_(std::move(end2))
-            {
-                satisfy();
-            }
-            template(bool Other)(
-                /// \pre
-                requires IsConst && CPP_NOT(Other)) //
-                set_difference_cursor(
-                    set_difference_cursor<Other, Rng1, Rng2, C, P1, P2> that)
-              : pred_(std::move(that.pred_))
-              , proj1_(std::move(that.proj1_))
-              , proj2_(std::move(that.proj2_))
-              , it1_(std::move(that.it1_))
-              , end1_(std::move(that.end1_))
-              , it2_(std::move(that.it2_))
-              , end2_(std::move(that.end2_))
-            {}
-            // clang-format off
-            auto CPP_auto_fun(read)()(const)
-            (
-                return *it1_
-            )
-            // clang-format on
-            void next()
-            {
-                ++it1_;
-                satisfy();
-            }
-            CPP_member
-            auto equal(set_difference_cursor const & that) const //
-                -> CPP_ret(bool)(
-                    /// \pre
-                    requires forward_range<Rng1>)
-            {
-                // does not support comparing iterators from different ranges
-                return it1_ == that.it1_;
-            }
-            bool equal(default_sentinel_t) const
-            {
-                return it1_ == end1_;
-            }
-            // clang-format off
-            auto CPP_auto_fun(move)()(const)
-            (
-                return iter_move(it1_)
-            )
-            // clang-format on
-        };
-
-        constexpr cardinality set_difference_cardinality(cardinality c1, cardinality c2)
-        {
-            return (c1 == unknown)
-                       ? unknown
-                       : (c1 >= 0) || (c1 == finite) ? finite : // else, c1 == infinite
-                             (c2 >= 0) || (c2 == finite) ? infinite : unknown;
-        }
-    } // namespace detail
-    /// \endcond
-
-    template<typename Rng1, typename Rng2, typename C, typename P1, typename P2>
-    using set_difference_view =
-        detail::set_algorithm_view<Rng1, Rng2, C, P1, P2, detail::set_difference_cursor,
-                                   detail::set_difference_cardinality(
-                                       range_cardinality<Rng1>::value,
-                                       range_cardinality<Rng2>::value)>;
-
-    namespace views
-    {
-        struct set_difference_base_fn
-        {
-            template(typename Rng1, typename Rng2, typename C = less,
-                     typename P1 = identity, typename P2 = identity)(
-                /// \pre
-                requires //
-                    viewable_range<Rng1> AND input_range<Rng1> AND
-                    viewable_range<Rng2> AND input_range<Rng2> AND
-                    indirect_relation<C,
-                                      projected<iterator_t<Rng1>, P1>,
-                                      projected<iterator_t<Rng2>, P2>>)
-            set_difference_view<all_t<Rng1>, all_t<Rng2>, C, P1, P2> //
-            operator()(Rng1 && rng1,
-                       Rng2 && rng2,
-                       C pred = C{},
-                       P1 proj1 = P1{},
-                       P2 proj2 = P2{}) const
-            {
-                return {all(static_cast<Rng1 &&>(rng1)),
-                        all(static_cast<Rng2 &&>(rng2)),
-                        std::move(pred),
-                        std::move(proj1),
-                        std::move(proj2)};
-            }
-        };
-
-        struct set_difference_fn : set_difference_base_fn
-        {
-            using set_difference_base_fn::operator();
-
-            template(typename Rng2, typename C = less, typename P1 = identity,
-                     typename P2 = identity)(
-                /// \pre
-                requires viewable_range<Rng2> AND input_range<Rng2> AND (!range<C>))
-            constexpr auto operator()(Rng2 && rng2,
-                                      C && pred = C{},
-                                      P1 proj1 = P1{},
-                                      P2 proj2 = P2{}) const
-            {
-                return make_view_closure(bind_back(set_difference_base_fn{},
-                                                   all(rng2),
-                                                   static_cast<C &&>(pred),
-                                                   std::move(proj1),
-                                                   std::move(proj2)));
-            }
-        };
-
-        /// \relates set_difference_fn
-        RANGES_INLINE_VARIABLE(set_difference_fn, set_difference)
-    } // namespace views
-
-    /// \cond
-    namespace detail
-    {
-        template<bool IsConst, typename Rng1, typename Rng2, typename C, typename P1,
-                 typename P2>
-        struct set_intersection_cursor
-        {
-        private:
-            friend struct set_intersection_cursor<!IsConst, Rng1, Rng2, C, P1, P2>;
-            using pred_ref_ = semiregular_box_ref_or_val_t<C, IsConst>;
-            using proj1_ref_ = semiregular_box_ref_or_val_t<P1, IsConst>;
-            using proj2_ref_ = semiregular_box_ref_or_val_t<P2, IsConst>;
-            pred_ref_ pred_;
-            proj1_ref_ proj1_;
-            proj2_ref_ proj2_;
-
-            template<typename T>
-            using constify_if = meta::const_if_c<IsConst, T>;
-
-            using R1 = constify_if<Rng1>;
-            using R2 = constify_if<Rng2>;
-
-            iterator_t<R1> it1_;
-            sentinel_t<R1> end1_;
-
-            iterator_t<R2> it2_;
-            sentinel_t<R2> end2_;
-
-            void satisfy()
-            {
-                while(it1_ != end1_ && it2_ != end2_)
-                {
-                    if(invoke(pred_, invoke(proj1_, *it1_), invoke(proj2_, *it2_)))
-                        ++it1_;
-                    else
-                    {
-                        if(!invoke(pred_, invoke(proj2_, *it2_), invoke(proj1_, *it1_)))
-                            return;
-                        ++it2_;
-                    }
-                }
-            }
-
-        public:
-            using value_type = range_value_t<R1>;
-            using single_pass = meta::or_c<single_pass_iterator_<iterator_t<R1>>,
-                                           single_pass_iterator_<iterator_t<R2>>>;
-
-            set_intersection_cursor() = default;
-            set_intersection_cursor(pred_ref_ pred, proj1_ref_ proj1, proj2_ref_ proj2,
-                                    iterator_t<R1> it1, sentinel_t<R1> end1,
-                                    iterator_t<R2> it2, sentinel_t<R2> end2)
-              : pred_(std::move(pred))
-              , proj1_(std::move(proj1))
-              , proj2_(std::move(proj2))
-              , it1_(std::move(it1))
-              , end1_(std::move(end1))
-              , it2_(std::move(it2))
-              , end2_(std::move(end2))
-            {
-                satisfy();
-            }
-            template(bool Other)(
-                /// \pre
-                requires IsConst && CPP_NOT(Other)) //
-                set_intersection_cursor(
-                    set_intersection_cursor<Other, Rng1, Rng2, C, P1, P2> that)
-              : pred_(std::move(that.pred_))
-              , proj1_(std::move(that.proj1_))
-              , proj2_(std::move(that.proj2_))
-              , it1_(std::move(that.it1_))
-              , end1_(std::move(that.end1_))
-              , it2_(std::move(that.it2_))
-              , end2_(std::move(that.end2_))
-            {}
-            // clang-format off
-            auto CPP_auto_fun(read)()(const)
-            (
-                return *it1_
-            )
-            // clang-format on
-            void next()
-            {
-                ++it1_;
-                ++it2_;
-                satisfy();
-            }
-            CPP_member
-            auto equal(set_intersection_cursor const & that) const //
-                -> CPP_ret(bool)(
-                    /// \pre
-                    requires forward_range<Rng1>)
-            {
-                // does not support comparing iterators from different ranges
-                return it1_ == that.it1_;
-            }
-            bool equal(default_sentinel_t) const
-            {
-                return (it1_ == end1_) || (it2_ == end2_);
-            }
-            // clang-format off
-            auto CPP_auto_fun(move)()(const)
-            (
-                return iter_move(it1_)
-            )
-            // clang-format on
-        };
-
-        constexpr cardinality set_intersection_cardinality(cardinality c1, cardinality c2)
-        {
-            return (c1 == unknown) || (c2 == unknown)
-                       ? unknown
-                       : (c1 >= 0 || c1 == finite) || (c2 >= 0 || c2 == finite) ? finite
-                                                                                : unknown;
-        }
-    } // namespace detail
-    /// \endcond
-
-    template<typename Rng1, typename Rng2, typename C, typename P1, typename P2>
-    using set_intersection_view =
-        detail::set_algorithm_view<Rng1, Rng2, C, P1, P2, detail::set_intersection_cursor,
-                                   detail::set_intersection_cardinality(
-                                       range_cardinality<Rng1>::value,
-                                       range_cardinality<Rng2>::value)>;
-
-    namespace views
-    {
-        struct set_intersection_base_fn
-        {
-            template(typename Rng1, typename Rng2, typename C = less,
-                     typename P1 = identity, typename P2 = identity)(
-                /// \pre
-                requires viewable_range<Rng1> AND input_range<Rng1> AND
-                    viewable_range<Rng2> AND input_range<Rng2> AND
-                    indirect_relation<
-                        C,
-                        projected<iterator_t<Rng1>, P1>,
-                        projected<iterator_t<Rng2>, P2>>)
-            set_intersection_view<all_t<Rng1>, all_t<Rng2>, C, P1, P2>
-            operator()(Rng1 && rng1,
-                       Rng2 && rng2,
-                       C pred = C{},
-                       P1 proj1 = P1{},
-                       P2 proj2 = P2{}) const
-            {
-                return {all(static_cast<Rng1 &&>(rng1)),
-                        all(static_cast<Rng2 &&>(rng2)),
-                        std::move(pred),
-                        std::move(proj1),
-                        std::move(proj2)};
-            }
-        };
-
-        struct set_intersection_fn : set_intersection_base_fn
-        {
-            using set_intersection_base_fn::operator();
-
-            template(typename Rng2, typename C = less, typename P1 = identity,
-                     typename P2 = identity)(
-                /// \pre
-                requires viewable_range<Rng2> AND input_range<Rng2> AND (!range<C>))
-            constexpr auto operator()(Rng2 && rng2,
-                                      C && pred = C{},
-                                      P1 proj1 = P1{},
-                                      P2 proj2 = P2{}) const
-            {
-                return make_view_closure(bind_back(set_intersection_base_fn{},
-                                                   all(rng2),
-                                                   static_cast<C &&>(pred),
-                                                   std::move(proj1),
-                                                   std::move(proj2)));
-            }
-        };
-
-        /// \relates set_intersection_fn
-        RANGES_INLINE_VARIABLE(set_intersection_fn, set_intersection)
-    } // namespace views
-
-    /// \cond
-    namespace detail
-    {
-        template<bool IsConst, typename Rng1, typename Rng2, typename C, typename P1,
-                 typename P2>
-        struct set_union_cursor
-        {
-        private:
-            friend struct set_union_cursor<!IsConst, Rng1, Rng2, C, P1, P2>;
-            using pred_ref_ = semiregular_box_ref_or_val_t<C, IsConst>;
-            using proj1_ref_ = semiregular_box_ref_or_val_t<P1, IsConst>;
-            using proj2_ref_ = semiregular_box_ref_or_val_t<P2, IsConst>;
-            pred_ref_ pred_;
-            proj1_ref_ proj1_;
-            proj2_ref_ proj2_;
-
-            template<typename T>
-            using constify_if = meta::const_if_c<IsConst, T>;
-
-            using R1 = constify_if<Rng1>;
-            using R2 = constify_if<Rng2>;
-
-            iterator_t<R1> it1_;
-            sentinel_t<R1> end1_;
-
-            iterator_t<R2> it2_;
-            sentinel_t<R2> end2_;
-
-            enum class state_t
-            {
-                FIRST,
-                SECOND
-            } state;
-
-            void satisfy()
-            {
-                if(it1_ == end1_)
-                {
-                    state = state_t::SECOND;
-                    return;
-                }
-
-                if(it2_ == end2_)
-                {
-                    state = state_t::FIRST;
-                    return;
-                }
-
-                if(invoke(pred_, invoke(proj2_, *it2_), invoke(proj1_, *it1_)))
-                {
-                    state = state_t::SECOND;
-                    return;
-                }
-
-                if(!invoke(pred_, invoke(proj1_, *it1_), invoke(proj2_, *it2_)))
-                    ++it2_;
-
-                state = state_t::FIRST;
-            }
-
-        public:
-            using value_type = common_type_t<range_value_t<R1>, range_value_t<R2>>;
-            using reference_type =
-                common_reference_t<range_reference_t<R1>, range_reference_t<R2>>;
-            using rvalue_reference_type =
-                common_reference_t<range_rvalue_reference_t<R1>,
-                                   range_rvalue_reference_t<R2>>;
-            using single_pass = meta::or_c<single_pass_iterator_<iterator_t<R1>>,
-                                           single_pass_iterator_<iterator_t<R2>>>;
-
-            set_union_cursor() = default;
-            set_union_cursor(pred_ref_ pred, proj1_ref_ proj1, proj2_ref_ proj2,
-                             iterator_t<R1> it1, sentinel_t<R1> end1, iterator_t<R2> it2,
-                             sentinel_t<R2> end2)
-              : pred_(std::move(pred))
-              , proj1_(std::move(proj1))
-              , proj2_(std::move(proj2))
-              , it1_(std::move(it1))
-              , end1_(std::move(end1))
-              , it2_(std::move(it2))
-              , end2_(std::move(end2))
-            {
-                satisfy();
-            }
-            template(bool Other)(
-                /// \pre
-                requires IsConst AND CPP_NOT(Other))
-                set_union_cursor(set_union_cursor<Other, Rng1, Rng2, C, P1, P2> that)
-              : pred_(std::move(that.pred_))
-              , proj1_(std::move(that.proj1_))
-              , proj2_(std::move(that.proj2_))
-              , it1_(std::move(that.it1_))
-              , end1_(std::move(that.end1_))
-              , it2_(std::move(that.it2_))
-              , end2_(std::move(that.end2_))
-            {}
-            reference_type read() const noexcept(noexcept(*it1_) && noexcept(*it2_))
-            {
-                if(state == state_t::SECOND)
-                    return *it2_;
-                else
-                    return *it1_;
-            }
-            void next()
-            {
-                if(state == state_t::FIRST)
-                    ++it1_;
-                else
-                    ++it2_;
-                satisfy();
-            }
-            CPP_member
-            auto equal(set_union_cursor const & that) const //
-                -> CPP_ret(bool)(
-                    /// \pre
-                    requires forward_range<Rng1> && forward_range<Rng2>)
-            {
-                // does not support comparing iterators from different ranges
-                return (it1_ == that.it1_) && (it2_ == that.it2_);
-            }
-            bool equal(default_sentinel_t) const
-            {
-                return (it1_ == end1_) && (it2_ == end2_);
-            }
-            rvalue_reference_type move() const
-                noexcept(noexcept(iter_move(it1_)) && noexcept(iter_move(it2_)))
-            {
-                if(state == state_t::SECOND)
-                    return iter_move(it2_);
-                else
-                    return iter_move(it1_);
-            }
-        };
-
-        constexpr cardinality set_union_cardinality(cardinality c1, cardinality c2)
-        {
-            return (c1 == infinite) || (c2 == infinite)
-                       ? infinite
-                       : (c1 == unknown) || (c2 == unknown) ? unknown : finite;
-        }
-    } // namespace detail
-    /// \endcond
-
-    template<typename Rng1, typename Rng2, typename C, typename P1, typename P2>
-    using set_union_view =
-        detail::set_algorithm_view<Rng1, Rng2, C, P1, P2, detail::set_union_cursor,
-                                   detail::set_union_cardinality(
-                                       range_cardinality<Rng1>::value,
-                                       range_cardinality<Rng2>::value)>;
-
-    namespace views
-    {
-        struct set_union_base_fn
-        {
-        public:
-            template(typename Rng1, typename Rng2, typename C = less,
-                     typename P1 = identity, typename P2 = identity)(
-                /// \pre
-                requires //
-                    viewable_range<Rng1> AND input_range<Rng1> AND
-                    viewable_range<Rng2> AND input_range<Rng2> AND
-                    common_with<range_value_t<Rng1>, range_value_t<Rng2>> AND
-                    common_reference_with<range_reference_t<Rng1>,
-                                          range_reference_t<Rng2>> AND
-                    common_reference_with<range_rvalue_reference_t<Rng1>,
-                                          range_rvalue_reference_t<Rng2>> AND
-                    indirect_relation<C,
-                                      projected<iterator_t<Rng1>, P1>,
-                                      projected<iterator_t<Rng2>, P2>>)
-            set_union_view<all_t<Rng1>, all_t<Rng2>, C, P1, P2> //
-            operator()(Rng1 && rng1,
-                       Rng2 && rng2,
-                       C pred = C{},
-                       P1 proj1 = P1{},
-                       P2 proj2 = P2{}) const
-            {
-                return {all(static_cast<Rng1 &&>(rng1)),
-                        all(static_cast<Rng2 &&>(rng2)),
-                        std::move(pred),
-                        std::move(proj1),
-                        std::move(proj2)};
-            }
-        };
-
-        struct set_union_fn : set_union_base_fn
-        {
-            using set_union_base_fn::operator();
-
-            template(typename Rng2, typename C = less, typename P1 = identity,
-                     typename P2 = identity)(
-                /// \pre
-                requires viewable_range<Rng2> AND input_range<Rng2> AND (!range<C>))
-            constexpr auto operator()(Rng2 && rng2,
-                                      C && pred = C{},
-                                      P1 proj1 = P1{},
-                                      P2 proj2 = P2{}) const
-            {
-                return make_view_closure(bind_back(set_union_base_fn{},
-                                                   all(rng2),
-                                                   static_cast<C &&>(pred),
-                                                   std::move(proj1),
-                                                   std::move(proj2)));
-            }
-        };
-
-        /// \relates set_union_fn
-        RANGES_INLINE_VARIABLE(set_union_fn, set_union)
-    } // namespace views
-
-    /// \cond
-    namespace detail
-    {
-        template<bool IsConst, typename Rng1, typename Rng2, typename C, typename P1,
-                 typename P2>
-        struct set_symmetric_difference_cursor
-        {
-        private:
-            friend struct set_symmetric_difference_cursor<!IsConst, Rng1, Rng2, C, P1,
-                                                          P2>;
-            using pred_ref_ = semiregular_box_ref_or_val_t<C, IsConst>;
-            using proj1_ref_ = semiregular_box_ref_or_val_t<P1, IsConst>;
-            using proj2_ref_ = semiregular_box_ref_or_val_t<P2, IsConst>;
-            pred_ref_ pred_;
-            proj1_ref_ proj1_;
-            proj2_ref_ proj2_;
-
-            template<typename T>
-            using constify_if = meta::const_if_c<IsConst, T>;
-
-            using R1 = constify_if<Rng1>;
-            using R2 = constify_if<Rng2>;
-
-            iterator_t<R1> it1_;
-            sentinel_t<R1> end1_;
-
-            iterator_t<R2> it2_;
-            sentinel_t<R2> end2_;
-
-            enum class state_t
-            {
-                FIRST,
-                SECOND,
-                ONLY_FIRST,
-                ONLY_SECOND
-            } state;
-
-            void satisfy()
-            {
-                while(it1_ != end1_)
-                {
-                    if(it2_ == end2_)
-                    {
-                        state = state_t::ONLY_FIRST;
-                        return;
-                    }
-
-                    if(invoke(pred_, invoke(proj1_, *it1_), invoke(proj2_, *it2_)))
-                    {
-                        state = state_t::FIRST;
-                        return;
-                    }
-                    else
-                    {
-                        if(invoke(pred_, invoke(proj2_, *it2_), invoke(proj1_, *it1_)))
-                        {
-                            state = state_t::SECOND;
-                            return;
-                        }
-                        else
-                        {
-                            ++it1_;
-                            ++it2_;
-                        }
-                    }
-                }
-                state = state_t::ONLY_SECOND;
-            }
-
-        public:
-            using value_type = common_type_t<range_value_t<R1>, range_value_t<R2>>;
-            using reference_type =
-                common_reference_t<range_reference_t<R1>, range_reference_t<R2>>;
-            using rvalue_reference_type =
-                common_reference_t<range_rvalue_reference_t<R1>,
-                                   range_rvalue_reference_t<R2>>;
-            using single_pass = meta::or_c<single_pass_iterator_<iterator_t<R1>>,
-                                           single_pass_iterator_<iterator_t<R2>>>;
-
-            set_symmetric_difference_cursor() = default;
-            set_symmetric_difference_cursor(pred_ref_ pred, proj1_ref_ proj1,
-                                            proj2_ref_ proj2, iterator_t<R1> it1,
-                                            sentinel_t<R1> end1, iterator_t<R2> it2,
-                                            sentinel_t<R2> end2)
-              : pred_(std::move(pred))
-              , proj1_(std::move(proj1))
-              , proj2_(std::move(proj2))
-              , it1_(std::move(it1))
-              , end1_(std::move(end1))
-              , it2_(std::move(it2))
-              , end2_(std::move(end2))
-              , state()
-            {
-                satisfy();
-            }
-            template(bool Other)(
-                /// \pre
-                requires IsConst && CPP_NOT(Other)) //
-            set_symmetric_difference_cursor(
-                    set_symmetric_difference_cursor<Other, Rng1, Rng2, C, P1, P2> that)
-              : pred_(std::move(that.pred_))
-              , proj1_(std::move(that.proj1_))
-              , proj2_(std::move(that.proj2_))
-              , it1_(std::move(that.it1_))
-              , end1_(std::move(that.end1_))
-              , it2_(std::move(that.it2_))
-              , end2_(std::move(that.end2_))
-              , state(that.state)
-            {}
-            reference_type read() const noexcept(noexcept(*it1_) && noexcept(*it2_))
-            {
-                if(state == state_t::SECOND || state == state_t::ONLY_SECOND)
-                    return *it2_;
-                else
-                    return *it1_;
-            }
-            void next()
-            {
-                switch(state)
-                {
-                case state_t::FIRST:
-                    ++it1_;
-                    satisfy();
-                    break;
-                case state_t::ONLY_FIRST:
-                    ++it1_;
-                    break;
-                case state_t::SECOND:
-                    ++it2_;
-                    satisfy();
-                    break;
-                case state_t::ONLY_SECOND:
-                    ++it2_;
-                    break;
-                }
-            }
-            CPP_member
-            auto equal(set_symmetric_difference_cursor const & that) const
-                -> CPP_ret(bool)(
-                    /// \pre
-                    requires forward_range<R1> && forward_range<R2>)
-            {
-                // does not support comparing iterators from different ranges:
-                return (it1_ == that.it1_) && (it2_ == that.it2_);
-            }
-            bool equal(default_sentinel_t) const
-            {
-                return (it1_ == end1_) && (it2_ == end2_);
-            }
-            rvalue_reference_type move() const
-                noexcept(noexcept(iter_move(it1_)) && noexcept(iter_move(it2_)))
-            {
-                if(state == state_t::SECOND || state == state_t::ONLY_SECOND)
-                    return iter_move(it2_);
-                else
-                    return iter_move(it1_);
-            }
-        };
-
-        constexpr cardinality set_symmetric_difference_cardinality(cardinality c1,
-                                                                   cardinality c2)
-        {
-            return (c1 == unknown) || (c2 == unknown)
-                       ? unknown
-                       : (c1 == infinite) != (c2 == infinite)
-                             ? infinite
-                             : (c1 == infinite) && (c2 == infinite) ? unknown : finite;
-        }
-
-    } // namespace detail
-    /// \endcond
-
-    template<typename Rng1, typename Rng2, typename C, typename P1, typename P2>
-    using set_symmetric_difference_view = detail::set_algorithm_view<
-        Rng1, Rng2, C, P1, P2, detail::set_symmetric_difference_cursor,
-        detail::set_symmetric_difference_cardinality(range_cardinality<Rng1>::value,
-                                                     range_cardinality<Rng2>::value)>;
-
-    namespace views
-    {
-        struct set_symmetric_difference_base_fn
-        {
-            template(typename Rng1, typename Rng2, typename C = less,
-                     typename P1 = identity, typename P2 = identity)(
-                /// \pre
-                requires //
-                    viewable_range<Rng1> AND input_range<Rng1> AND
-                    viewable_range<Rng2> AND input_range<Rng2> AND
-                    common_with<range_value_t<Rng1>, range_value_t<Rng2>> AND
-                    common_reference_with<range_reference_t<Rng1>,
-                                          range_reference_t<Rng2>> AND
-                    common_reference_with<range_rvalue_reference_t<Rng1>,
-                                          range_rvalue_reference_t<Rng2>> AND
-                    indirect_relation<C,
-                                      projected<iterator_t<Rng1>, P1>,
-                                      projected<iterator_t<Rng2>, P2>>)
-            set_symmetric_difference_view<all_t<Rng1>, all_t<Rng2>, C, P1, P2>
-            operator()(Rng1 && rng1,
-                       Rng2 && rng2,
-                       C pred = C{},
-                       P1 proj1 = P1{},
-                       P2 proj2 = P2{}) const
-            {
-                return {all(static_cast<Rng1 &&>(rng1)),
-                        all(static_cast<Rng2 &&>(rng2)),
-                        std::move(pred),
-                        std::move(proj1),
-                        std::move(proj2)};
-            }
-        };
-
-        struct set_symmetric_difference_fn : set_symmetric_difference_base_fn
-        {
-            using set_symmetric_difference_base_fn::operator();
-
-            template(typename Rng2, typename C = less, typename P1 = identity,
-                     typename P2 = identity)(
-                /// \pre
-                requires viewable_range<Rng2> AND input_range<Rng2> AND (!range<C>))
-            constexpr auto operator()(Rng2 && rng2,
-                                      C && pred = C{},
-                                      P1 proj1 = P1{},
-                                      P2 proj2 = P2{}) const
-            {
-                return make_view_closure(bind_back(set_symmetric_difference_base_fn{},
-                                                   all(rng2),
-                                                   static_cast<C &&>(pred),
-                                                   std::move(proj1),
-                                                   std::move(proj2)));
-            }
-        };
-
-        /// \relates set_symmetric_difference_fn
-        RANGES_INLINE_VARIABLE(set_symmetric_difference_fn, set_symmetric_difference)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/single.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/single.hpp
deleted file mode 100644
index d9a47403..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/single.hpp
+++ /dev/null
@@ -1,144 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_SINGLE_HPP
-#define RANGES_V3_VIEW_SINGLE_HPP
-
-#include <type_traits>
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/addressof.hpp>
-#include <range/v3/utility/optional.hpp>
-#include <range/v3/utility/semiregular_box.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/facade.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    template<typename T>
-    struct single_view : view_interface<single_view<T>, (cardinality)1>
-    {
-    private:
-        CPP_assert(copy_constructible<T>);
-        static_assert(std::is_object<T>::value,
-                      "The template parameter of single_view must be an object type");
-        semiregular_box_t<T> value_;
-        template<typename... Args>
-        constexpr single_view(in_place_t, std::true_type, Args &&... args)
-          : value_{static_cast<Args &&>(args)...}
-        {}
-        template<typename... Args>
-        constexpr single_view(in_place_t, std::false_type, Args &&... args)
-          : value_{in_place, static_cast<Args &&>(args)...}
-        {}
-
-    public:
-        single_view() = default;
-        constexpr explicit single_view(T const & t)
-          : value_(t)
-        {}
-        constexpr explicit single_view(T && t)
-          : value_(std::move(t))
-        {}
-        template(class... Args)(
-            /// \pre
-            requires constructible_from<T, Args...>)
-            constexpr single_view(in_place_t, Args &&... args)
-          : single_view{in_place,
-                        meta::bool_<(bool)semiregular<T>>{},
-                        static_cast<Args &&>(args)...}
-        {}
-        constexpr T * begin() noexcept
-        {
-            return data();
-        }
-        constexpr T const * begin() const noexcept
-        {
-            return data();
-        }
-        constexpr T * end() noexcept
-        {
-            return data() + 1;
-        }
-        constexpr T const * end() const noexcept
-        {
-            return data() + 1;
-        }
-        static constexpr std::size_t size() noexcept
-        {
-            return 1u;
-        }
-        constexpr T * data() noexcept
-        {
-            return detail::addressof(static_cast<T &>(value_));
-        }
-        constexpr T const * data() const noexcept
-        {
-            return detail::addressof(static_cast<T const &>(value_));
-        }
-    };
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template<class T>
-    explicit single_view(T &&) //
-        -> single_view<detail::decay_t<T>>;
-#endif
-
-    namespace views
-    {
-        struct single_fn
-        {
-            template(typename Val)(
-                /// \pre
-                requires copy_constructible<Val>)
-            single_view<Val> operator()(Val value) const
-            {
-                return single_view<Val>{std::move(value)};
-            }
-        };
-
-        /// \relates single_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(single_fn, single)
-    } // namespace views
-
-    namespace cpp20
-    {
-        namespace views
-        {
-            using ranges::views::single;
-        }
-        template(typename T)(
-            /// \pre
-            requires std::is_object<T>::value) //
-            using single_view = ranges::single_view<T>;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::single_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/slice.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/slice.hpp
deleted file mode 100644
index 6da83595..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/slice.hpp
+++ /dev/null
@@ -1,354 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_SLICE_HPP
-#define RANGES_V3_VIEW_SLICE_HPP
-
-#include <type_traits>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/iterator/counted_iterator.hpp>
-#include <range/v3/iterator/default_sentinel.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/optional.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/drop_exactly.hpp>
-#include <range/v3/view/facade.hpp>
-#include <range/v3/view/subrange.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        template<typename Rng, typename Int>
-        iterator_t<Rng> pos_at_(Rng && rng, Int i, input_range_tag, std::true_type)
-        {
-            RANGES_EXPECT(0 <= i);
-            return next(ranges::begin(rng), i);
-        }
-
-        template<typename Rng, typename Int>
-        iterator_t<Rng> pos_at_(Rng && rng, Int i, bidirectional_range_tag,
-                                std::false_type)
-        {
-            if(0 > i)
-            {
-                // If it's not common and we know the size, faster to count from the front
-                if(RANGES_CONSTEXPR_IF(sized_range<Rng> && !common_range<Rng>))
-                    return next(ranges::begin(rng), distance(rng) + i);
-                // Otherwise, probably faster to count from the back.
-                return next(ranges::next(ranges::begin(rng), ranges::end(rng)), i);
-            }
-            return next(ranges::begin(rng), i);
-        }
-
-        template<typename Rng, typename Int>
-        iterator_t<Rng> pos_at_(Rng && rng, Int i, input_range_tag, std::false_type)
-        {
-            RANGES_EXPECT(i >= 0 || (bool)sized_range<Rng> || (bool)forward_range<Rng>);
-            if(0 > i)
-                return next(ranges::begin(rng), distance(rng) + i);
-            return next(ranges::begin(rng), i);
-        }
-
-        template<typename Rng, bool IsRandomAccess>
-        struct slice_view_ : view_facade<slice_view<Rng>, finite>
-        {
-        private:
-            friend range_access;
-            Rng rng_;
-            range_difference_t<Rng> from_, count_;
-            detail::non_propagating_cache<iterator_t<Rng>> begin_;
-
-            iterator_t<Rng> get_begin_()
-            {
-                if(!begin_)
-                    begin_ = detail::pos_at_(
-                        rng_, from_, range_tag_of<Rng>{}, is_infinite<Rng>{});
-                return *begin_;
-            }
-
-        public:
-            slice_view_() = default;
-            constexpr slice_view_(Rng rng, range_difference_t<Rng> from,
-                                  range_difference_t<Rng> count)
-              : rng_(std::move(rng))
-              , from_(from)
-              , count_(count)
-            {}
-            counted_iterator<iterator_t<Rng>> begin()
-            {
-                return make_counted_iterator(get_begin_(), count_);
-            }
-            default_sentinel_t end()
-            {
-                return {};
-            }
-            auto size() const
-            {
-                return static_cast<detail::iter_size_t<iterator_t<Rng>>>(count_);
-            }
-            Rng base() const
-            {
-                return rng_;
-            }
-        };
-
-        template<typename Rng>
-        struct slice_view_<Rng, true> : view_interface<slice_view<Rng>, finite>
-        {
-        private:
-            Rng rng_;
-            range_difference_t<Rng> from_, count_;
-
-        public:
-            slice_view_() = default;
-            constexpr slice_view_(Rng rng, range_difference_t<Rng> from,
-                                  range_difference_t<Rng> count)
-              : rng_(std::move(rng))
-              , from_(from)
-              , count_(count)
-            {
-                RANGES_EXPECT(0 <= count_);
-            }
-            iterator_t<Rng> begin()
-            {
-                return detail::pos_at_(
-                    rng_, from_, range_tag_of<Rng>{}, is_infinite<Rng>{});
-            }
-            iterator_t<Rng> end()
-            {
-                return detail::pos_at_(
-                           rng_, from_, range_tag_of<Rng>{}, is_infinite<Rng>{}) +
-                       count_;
-            }
-            template(typename BaseRng = Rng)(
-                /// \pre
-                requires range<BaseRng const>)
-            iterator_t<BaseRng const> begin() const
-            {
-                return detail::pos_at_(
-                    rng_, from_, range_tag_of<Rng>{}, is_infinite<Rng>{});
-            }
-            template(typename BaseRng = Rng)(
-                /// \pre
-                requires range<BaseRng const>)
-            iterator_t<BaseRng const> end() const
-            {
-                return detail::pos_at_(
-                           rng_, from_, range_tag_of<Rng>{}, is_infinite<Rng>{}) +
-                       count_;
-            }
-            auto size() const
-            {
-                return static_cast<detail::iter_size_t<iterator_t<Rng>>>(count_);
-            }
-            Rng base() const
-            {
-                return rng_;
-            }
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// \addtogroup group-views
-    /// @{
-    template<typename Rng>
-    struct slice_view : detail::slice_view_<Rng, (bool)random_access_range<Rng>>
-    {
-        using detail::slice_view_<Rng, (bool)random_access_range<Rng>>::slice_view_;
-    };
-
-    template<typename Rng>
-    RANGES_INLINE_VAR constexpr bool enable_borrowed_range<slice_view<Rng>> = //
-        enable_borrowed_range<Rng>;
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template<typename Rng>
-    slice_view(Rng &&, range_difference_t<Rng>, range_difference_t<Rng>)
-        ->slice_view<views::all_t<Rng>>;
-#endif
-
-    namespace views
-    {
-        struct slice_base_fn
-        {
-        private:
-            template<typename Rng>
-            static constexpr slice_view<all_t<Rng>> impl_(Rng && rng,
-                                                          range_difference_t<Rng> from,
-                                                          range_difference_t<Rng> count,
-                                                          input_range_tag, range_tag = {})
-            {
-                return {all(static_cast<Rng &&>(rng)), from, count};
-            }
-            template(typename Rng)(
-                /// \pre
-                requires borrowed_range<Rng>)
-            static subrange<iterator_t<Rng>> impl_(Rng && rng,
-                                                   range_difference_t<Rng> from,
-                                                   range_difference_t<Rng> count,
-                                                   random_access_range_tag,
-                                                   common_range_tag = {})
-            {
-                auto it =
-                    detail::pos_at_(rng, from, range_tag_of<Rng>{}, is_infinite<Rng>{});
-                return {it, it + count};
-            }
-
-        public:
-            // slice(rng, 2, 4)
-            template(typename Rng)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng>)
-            constexpr auto operator()(Rng && rng,
-                                      range_difference_t<Rng> from,
-                                      range_difference_t<Rng> to) const
-            {
-                RANGES_EXPECT(0 <= from && from <= to);
-                return slice_base_fn::impl_(
-                    static_cast<Rng &&>(rng), from, to - from, range_tag_of<Rng>{});
-            }
-            // slice(rng, 4, end-2)
-            //  TODO Support Forward, non-Sized ranges by returning a range that
-            //       doesn't know it's size?
-            template(typename Rng)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng> AND sized_range<Rng>)
-            auto operator()(Rng && rng,
-                            range_difference_t<Rng> from,
-                            detail::from_end_of_t<Rng> to) const
-            {
-                static_assert(!is_infinite<Rng>::value,
-                              "Can't index from the end of an infinite range!");
-                RANGES_EXPECT(0 <= from);
-                RANGES_ASSERT(from <= distance(rng) + to.dist_);
-                return slice_base_fn::impl_(static_cast<Rng &&>(rng),
-                                            from,
-                                            distance(rng) + to.dist_ - from,
-                                            range_tag_of<Rng>{});
-            }
-            // slice(rng, end-4, end-2)
-            template(typename Rng)(
-                /// \pre
-                requires viewable_range<Rng> AND
-                    (forward_range<Rng> || (input_range<Rng> && sized_range<Rng>)))
-            auto operator()(Rng && rng,
-                            detail::from_end_of_t<Rng> from,
-                            detail::from_end_of_t<Rng> to) const
-            {
-                static_assert(!is_infinite<Rng>::value,
-                              "Can't index from the end of an infinite range!");
-                RANGES_EXPECT(from.dist_ <= to.dist_);
-                return slice_base_fn::impl_(static_cast<Rng &&>(rng),
-                                            from.dist_,
-                                            to.dist_ - from.dist_,
-                                            range_tag_of<Rng>{},
-                                            common_range_tag_of<Rng>{});
-            }
-            // slice(rng, 4, end)
-            template(typename Rng)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng>)
-            auto operator()(Rng && rng, range_difference_t<Rng> from, end_fn) const
-            {
-                RANGES_EXPECT(0 <= from);
-                return ranges::views::drop_exactly(static_cast<Rng &&>(rng), from);
-            }
-            // slice(rng, end-4, end)
-            template(typename Rng)(
-                /// \pre
-                requires viewable_range<Rng> AND
-                    (forward_range<Rng> || (input_range<Rng> && sized_range<Rng>)))
-            auto operator()(Rng && rng,
-                            detail::from_end_of_t<Rng> from,
-                            end_fn) const
-            {
-                static_assert(!is_infinite<Rng>::value,
-                              "Can't index from the end of an infinite range!");
-                return slice_base_fn::impl_(static_cast<Rng &&>(rng),
-                                            from.dist_,
-                                            -from.dist_,
-                                            range_tag_of<Rng>{},
-                                            common_range_tag_of<Rng>{});
-            }
-        };
-
-        struct slice_fn : slice_base_fn
-        {
-            using slice_base_fn::operator();
-
-            // Overloads for the pipe syntax: rng | views::slice(from,to)
-            template(typename Int)(
-                /// \pre
-                requires detail::integer_like_<Int>)
-            constexpr auto operator()(Int from, Int to) const
-            {
-                return make_view_closure(bind_back(slice_base_fn{}, from, to));
-            }
-            template(typename Int)(
-                /// \pre
-                requires detail::integer_like_<Int>)
-            constexpr auto operator()(Int from, detail::from_end_<Int> to) const
-            {
-                return make_view_closure(bind_back(slice_base_fn{}, from, to));
-            }
-            template(typename Int)(
-                /// \pre
-                requires detail::integer_like_<Int>)
-            constexpr auto operator()(detail::from_end_<Int> from,
-                                      detail::from_end_<Int> to) const
-            {
-                return make_view_closure(bind_back(slice_base_fn{}, from, to));
-            }
-            template(typename Int)(
-                /// \pre
-                requires detail::integer_like_<Int>)
-            constexpr auto operator()(Int from, end_fn) const
-            {
-                return make_view_closure(
-                    bind_back(ranges::views::drop_exactly_base_fn{}, from));
-            }
-            template(typename Int)(
-                /// \pre
-                requires detail::integer_like_<Int>)
-            constexpr auto operator()(detail::from_end_<Int> from, end_fn to) const
-            {
-                return make_view_closure(bind_back(slice_base_fn{}, from, to));
-            }
-        };
-
-        /// \relates _slice_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(slice_fn, slice)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::slice_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/sliding.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/sliding.hpp
deleted file mode 100644
index 2bcc7866..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/sliding.hpp
+++ /dev/null
@@ -1,415 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//  Copyright Tobias Mayer 2016
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_SLIDING_HPP
-#define RANGES_V3_VIEW_SLIDING_HPP
-
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/optional.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/adaptor.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/counted.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace sliding_view_detail
-    {
-        enum class cache
-        {
-            none,
-            first,
-            last
-        };
-
-        template<typename Rng>
-        using caching = std::integral_constant<
-            cache, random_access_range<Rng> && sized_range<Rng>
-                       ? cache::none
-                       : bidirectional_range<Rng> && common_range<Rng> ? cache::last
-                                                                       : cache::first>;
-    } // namespace sliding_view_detail
-    /// \endcond
-
-    template<typename Rng,
-             sliding_view_detail::cache = sliding_view_detail::caching<Rng>::value>
-    struct sliding_view;
-
-    /// \cond
-    namespace sliding_view_detail
-    {
-        template<typename Rng>
-        using uncounted_t =
-            decltype(ranges::uncounted(std::declval<iterator_t<Rng> &>()));
-
-        template<typename Rng, bool = (bool)random_access_range<Rng>>
-        struct trailing
-        {
-            trailing() = default;
-            constexpr trailing(Rng & rng)
-              : it_{uncounted(ranges::begin(rng))}
-            {}
-            constexpr uncounted_t<Rng> get(iterator_t<Rng> const &,
-                                           range_difference_t<Rng>) const
-            {
-                return it_;
-            }
-            void next()
-            {
-                ++it_;
-            }
-            CPP_member
-            auto prev() //
-                -> CPP_ret(void)(
-                    /// \pre
-                    requires bidirectional_range<Rng>)
-            {
-                --it_;
-            }
-
-        private:
-            uncounted_t<Rng> it_;
-        };
-
-        template<typename Rng>
-        struct trailing<Rng, true>
-        {
-            trailing() = default;
-            constexpr trailing(Rng &) noexcept
-            {}
-            constexpr uncounted_t<Rng> get(iterator_t<Rng> const & it,
-                                           range_difference_t<Rng> n) const
-            {
-                return uncounted(it - (n - 1));
-            }
-            void next()
-            {}
-            void prev()
-            {}
-        };
-
-        template<typename Rng>
-        struct RANGES_EMPTY_BASES sv_base
-          : view_adaptor<sliding_view<Rng>, Rng,
-                         is_finite<Rng>::value ? finite : range_cardinality<Rng>::value>
-          , private detail::non_propagating_cache<iterator_t<Rng>, sv_base<Rng>,
-                                                  caching<Rng>::value != cache::none>
-        {
-            CPP_assert(forward_range<Rng>);
-            sv_base() = default;
-            sv_base(Rng rng, range_difference_t<Rng> n)
-              : sv_base::view_adaptor(std::move(rng))
-              , n_(n)
-            {
-                RANGES_ASSERT(0 < n_);
-            }
-            CPP_member
-            auto CPP_fun(size)()(const //
-                requires sized_range<Rng const>)
-            {
-                auto const count = ranges::size(this->base());
-                auto const n = static_cast<range_size_t<Rng const>>(n_);
-                return count < n ? 0 : count - n + 1;
-            }
-            CPP_member
-            auto CPP_fun(size)()(
-                /// \pre
-                requires sized_range<Rng>)
-            {
-                auto const count = ranges::size(this->base());
-                auto const n = static_cast<range_size_t<Rng>>(n_);
-                return count < n ? 0 : count - n + 1;
-            }
-
-        protected:
-            range_difference_t<Rng> n_;
-
-            optional<iterator_t<Rng>> & cache() &
-            {
-                return static_cast<cache_t &>(*this);
-            }
-            optional<iterator_t<Rng>> const & cache() const &
-            {
-                return static_cast<cache_t const &>(*this);
-            }
-
-        private:
-            using cache_t = detail::non_propagating_cache<iterator_t<Rng>, sv_base<Rng>>;
-        };
-    } // namespace sliding_view_detail
-    /// \endcond
-
-    /// \addtogroup group-views
-    /// @{
-    template<typename Rng>
-    struct sliding_view<Rng, sliding_view_detail::cache::first>
-      : sliding_view_detail::sv_base<Rng>
-    {
-    private:
-        friend range_access;
-
-        iterator_t<Rng> get_first()
-        {
-            auto & first = this->cache();
-            if(!first)
-            {
-                first = ranges::next(
-                    ranges::begin(this->base()), this->n_ - 1, ranges::end(this->base()));
-            }
-            return *first;
-        }
-
-        struct RANGES_EMPTY_BASES adaptor
-          : adaptor_base
-          , sliding_view_detail::trailing<Rng>
-        {
-        private:
-            using base_t = sliding_view_detail::trailing<Rng>;
-            range_difference_t<Rng> n_ = {};
-
-        public:
-            adaptor() = default;
-            adaptor(sliding_view * v)
-              : base_t{v->base()}
-              , n_{v->n_}
-            {}
-            iterator_t<Rng> begin(sliding_view & v)
-            {
-                return v.get_first();
-            }
-            auto read(iterator_t<Rng> const & it) const
-                -> decltype(views::counted(uncounted(it), n_))
-            {
-                return views::counted(base_t::get(it, n_), n_);
-            }
-            void next(iterator_t<Rng> & it)
-            {
-                ++it;
-                base_t::next();
-            }
-            CPP_member
-            auto prev(iterator_t<Rng> & it) //
-                -> CPP_ret(void)(
-                    /// \pre
-                    requires bidirectional_range<Rng>)
-            {
-                base_t::prev();
-                --it;
-            }
-            CPP_member
-            auto advance(iterator_t<Rng> & it, range_difference_t<Rng> n)
-                -> CPP_ret(void)(
-                    /// \pre
-                    requires random_access_range<Rng>)
-            {
-                it += n;
-            }
-        };
-
-        adaptor begin_adaptor()
-        {
-            return {this};
-        }
-        meta::if_c<common_range<Rng>, adaptor, adaptor_base> end_adaptor()
-        {
-            return {this};
-        }
-
-    public:
-        using sliding_view::sv_base::sv_base;
-    };
-
-    template<typename Rng>
-    struct sliding_view<Rng, sliding_view_detail::cache::last>
-      : sliding_view_detail::sv_base<Rng>
-    {
-    private:
-        friend range_access;
-
-        iterator_t<Rng> get_last()
-        {
-            auto & last = this->cache();
-            if(!last)
-            {
-                last = ranges::prev(
-                    ranges::end(this->base()), this->n_ - 1, ranges::begin(this->base()));
-            }
-            return *last;
-        }
-
-        struct adaptor : adaptor_base
-        {
-        private:
-            range_difference_t<Rng> n_ = {};
-
-        public:
-            adaptor() = default;
-            adaptor(sliding_view * v)
-              : n_{v->n_}
-            {}
-            iterator_t<Rng> end(sliding_view & v)
-            {
-                return v.get_last();
-            }
-            auto read(iterator_t<Rng> const & it) const
-                -> decltype(views::counted(uncounted(it), n_))
-            {
-                return views::counted(uncounted(it), n_);
-            }
-        };
-
-        adaptor begin_adaptor()
-        {
-            return {this};
-        }
-        adaptor end_adaptor()
-        {
-            return {this};
-        }
-
-    public:
-        using sliding_view::sv_base::sv_base;
-    };
-
-    template<typename Rng>
-    struct sliding_view<Rng, sliding_view_detail::cache::none>
-      : sliding_view_detail::sv_base<Rng>
-    {
-    private:
-        friend range_access;
-
-        template<bool Const>
-        struct adaptor : adaptor_base
-        {
-        private:
-            friend adaptor<!Const>;
-            using CRng = meta::const_if_c<Const, Rng>;
-            range_difference_t<Rng> n_ = 0;
-
-        public:
-            adaptor() = default;
-            adaptor(range_difference_t<Rng> n)
-              : n_(n)
-            {}
-            template(bool Other)(
-                /// \pre
-                requires Const AND CPP_NOT(Other)) //
-            adaptor(adaptor<Other> that)
-              : n_(that.n_)
-            {}
-            iterator_t<CRng> end(meta::const_if_c<Const, sliding_view> & v) const
-            {
-                auto const sz = ranges::distance(v.base());
-                auto const offset = n_ - 1 < sz ? n_ - 1 : sz;
-                return ranges::begin(v.base()) + (sz - offset);
-            }
-            auto read(iterator_t<CRng> const & it) const
-                -> decltype(views::counted(uncounted(it), n_))
-            {
-                return views::counted(uncounted(it), n_);
-            }
-        };
-
-        adaptor<simple_view<Rng>()> begin_adaptor()
-        {
-            return {this->n_};
-        }
-        CPP_member
-        auto begin_adaptor() const //
-            -> CPP_ret(adaptor<true>)(
-                /// \pre
-                requires range<Rng const>)
-        {
-            return {this->n_};
-        }
-        adaptor<simple_view<Rng>()> end_adaptor()
-        {
-            return {this->n_};
-        }
-        CPP_member
-        auto end_adaptor() const //
-            -> CPP_ret(adaptor<true>)(
-                /// \pre
-                requires range<Rng const>)
-        {
-            return {this->n_};
-        }
-
-    public:
-        using sliding_view::sv_base::sv_base;
-    };
-
-    template<typename Rng>
-    RANGES_INLINE_VAR constexpr bool enable_borrowed_range<sliding_view<Rng>> = //
-        enable_borrowed_range<Rng>;
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template<typename Rng>
-    sliding_view(Rng &&, range_difference_t<Rng>)
-        -> sliding_view<views::all_t<Rng>>;
-#endif
-
-    namespace views
-    {
-        // In:  range<T>
-        // Out: range<range<T>>, where each inner range has $n$ elements.
-        struct sliding_base_fn
-        {
-            template(typename Rng)(
-                /// \pre
-                requires viewable_range<Rng> AND forward_range<Rng>)
-            constexpr sliding_view<all_t<Rng>> //
-            operator()(Rng && rng, range_difference_t<Rng> n) const
-            {
-                return {all(static_cast<Rng &&>(rng)), n};
-            }
-        };
-
-        struct sliding_fn : sliding_base_fn
-        {
-            using sliding_base_fn::operator();
-
-            template<typename Int>
-            constexpr auto CPP_fun(operator())(Int n)(const //
-                                                      requires detail::integer_like_<Int>)
-            {
-                return make_view_closure(bind_back(sliding_base_fn{}, n));
-            }
-        };
-
-        /// \relates sliding_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(sliding_fn, sliding)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/span.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/span.hpp
deleted file mode 100644
index 96f98e84..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/span.hpp
+++ /dev/null
@@ -1,430 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Casey Carter 2016-2017
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_SPAN_HPP
-#define RANGES_V3_VIEW_SPAN_HPP
-
-#include <cstddef>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/equal.hpp>
-#include <range/v3/algorithm/lexicographical_compare.hpp>
-#include <range/v3/iterator/reverse_iterator.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/view/interface.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-
-    /// \cond
-    namespace detail
-    {
-        using span_index_t = std::ptrdiff_t;
-    } // namespace detail
-    /// \endcond
-
-    constexpr detail::span_index_t dynamic_extent = -1;
-
-    /// \cond
-    namespace detail
-    {
-        template(typename To, typename From)(
-            /// \pre
-            requires integral<To> AND integral<From>)
-        constexpr To narrow_cast(From from) noexcept
-        {
-            using C = common_type_t<To, From>;
-            return RANGES_EXPECT((from > 0) == (static_cast<To>(from) > 0)),
-                   RANGES_EXPECT(static_cast<C>(from) ==
-                                 static_cast<C>(static_cast<To>(from))),
-                   static_cast<To>(from);
-        }
-
-        template<typename T>
-        constexpr span_index_t byte_size(span_index_t n) noexcept
-        {
-            return n == dynamic_extent ? dynamic_extent
-                                       : (RANGES_EXPECT(n >= 0),
-                                          RANGES_EXPECT(narrow_cast<std::size_t>(n) <=
-                                                        PTRDIFF_MAX / sizeof(T)),
-                                          n * narrow_cast<span_index_t>(sizeof(T)));
-        }
-
-        template<span_index_t N>
-        struct span_extent
-        {
-            CPP_assert(N >= 0);
-
-            constexpr span_extent() noexcept = default;
-            constexpr span_extent(span_index_t size) noexcept
-              // this constructor does nothing, the delegation exists only
-              // to provide a place for the contract check expression.
-              : span_extent{(RANGES_EXPECT(size == N), tag{})}
-            {}
-
-            constexpr span_index_t size() const noexcept
-            {
-                return N;
-            }
-
-        private:
-            struct tag
-            {};
-            constexpr span_extent(tag) noexcept
-            {}
-        };
-        template<>
-        struct span_extent<dynamic_extent>
-        {
-            span_extent() = default;
-            constexpr span_extent(span_index_t size) noexcept
-              : size_{((void)RANGES_EXPECT(size >= 0), size)}
-            {}
-            constexpr span_index_t size() const noexcept
-            {
-                return size_;
-            }
-
-        private:
-            span_index_t size_ = 0;
-        };
-
-        constexpr span_index_t subspan_extent(span_index_t Extent, span_index_t Offset,
-                                              span_index_t Count) noexcept
-        {
-            return Count == dynamic_extent && Extent != dynamic_extent ? Extent - Offset
-                                                                       : Count;
-        }
-    } // namespace detail
-
-    // clang-format off
-    template(typename Rng, typename T)(
-    concept (span_compatible_range_)(Rng, T),
-        detail::is_convertible<detail::element_t<Rng>(*)[], T(*)[]>::value
-    );
-    template<typename Rng, typename T>
-    CPP_concept span_compatible_range =
-        sized_range<Rng> && contiguous_range<Rng> &&
-        CPP_concept_ref(ranges::span_compatible_range_, Rng, T);
-
-    template<typename Rng, detail::span_index_t N>
-    CPP_concept span_dynamic_conversion =
-        N == dynamic_extent ||
-            range_cardinality<Rng>::value < cardinality();
-
-    template<typename Rng, detail::span_index_t N>
-    CPP_concept span_static_conversion =
-        N != dynamic_extent && range_cardinality<Rng>::value == N;
-    // clang-format on
-    /// \endcond
-
-    template<typename T, detail::span_index_t N = dynamic_extent>
-    struct RANGES_EMPTY_BASES span
-      : public view_interface<
-            span<T, N>, (N == dynamic_extent ? finite : static_cast<cardinality>(N))>
-      , public detail::span_extent<N>
-    {
-        CPP_assert(std::is_object<T>::value);
-
-        using element_type = T;
-        using value_type = meta::_t<std::remove_cv<T>>;
-        using index_type = detail::span_index_t;
-        using difference_type = index_type;
-        using pointer = T *;
-        using reference = T &;
-        using iterator = T *;
-        using reverse_iterator = ranges::reverse_iterator<iterator>;
-
-        static constexpr index_type extent = N;
-
-        constexpr span() noexcept = default;
-        constexpr span(pointer ptr, index_type cnt) noexcept
-          : detail::span_extent<N>{(RANGES_EXPECT(cnt >= 0), cnt)}
-          , data_{(RANGES_EXPECT(0 == cnt || ptr != nullptr), ptr)}
-        {}
-        template<typename = void> // Artificially templatize so that the other
-                                  // constructor is preferred for {ptr, 0}
-        constexpr span(pointer first, pointer last) noexcept
-          : span{first, last - first}
-        {}
-
-        template(typename Rng)(
-            /// \pre
-            requires (!same_as<span, uncvref_t<Rng>>) AND
-                span_compatible_range<Rng, T> AND
-                span_dynamic_conversion<Rng, N>)
-        constexpr span(Rng && rng) noexcept(noexcept(ranges::data(rng),
-                                                        ranges::size(rng)))
-          : span{ranges::data(rng), detail::narrow_cast<index_type>(ranges::size(rng))}
-        {}
-
-        template(typename Rng)(
-            /// \pre
-            requires (!same_as<span, uncvref_t<Rng>>) AND
-                span_compatible_range<Rng, T> AND
-                span_static_conversion<Rng, N>)
-        constexpr span(Rng && rng) noexcept(noexcept(ranges::data(rng)))
-          : span{ranges::data(rng), N}
-        {}
-
-        template<index_type Count>
-        constexpr span<T, Count> first() const noexcept
-        {
-            static_assert(Count >= 0, "Count of elements to extract cannot be negative.");
-            static_assert(
-                N == dynamic_extent || Count <= N,
-                "Count of elements to extract must be less than the static span extent.");
-            return RANGES_EXPECT(Count <= size()),
-                   RANGES_EXPECT(Count == 0 || data_ != nullptr),
-                   span<T, Count>{data_, Count};
-        }
-        constexpr span<T> first(index_type cnt) const noexcept
-        {
-            return RANGES_EXPECT(cnt >= 0 && cnt <= size()),
-                   RANGES_EXPECT(cnt == 0 || data_ != nullptr), span<T>{data_, cnt};
-        }
-
-        template<index_type Count>
-        constexpr span<T, Count> last() const noexcept
-        {
-            static_assert(Count >= 0, "Count of elements to extract cannot be negative.");
-            static_assert(
-                N == dynamic_extent || Count <= N,
-                "Count of elements to extract must be less than the static span extent.");
-            return RANGES_EXPECT(Count <= size()),
-                   RANGES_EXPECT((Count == 0 && size() == 0) || data_ != nullptr),
-                   span<T, Count>{data_ + size() - Count, Count};
-        }
-        constexpr span<T> last(index_type cnt) const noexcept
-        {
-            return RANGES_EXPECT(cnt >= 0 && cnt <= size()),
-                   RANGES_EXPECT((cnt == 0 && size() == 0) || data_ != nullptr),
-                   span<T>{data_ + size() - cnt, cnt};
-        }
-
-        template<index_type Offset, index_type Count>
-        constexpr span<T, detail::subspan_extent(N, Offset, Count)> subspan() const
-            noexcept
-        {
-            static_assert(Offset >= 0,
-                          "Offset of first element to extract cannot be negative.");
-            static_assert(Count >= dynamic_extent,
-                          "Count of elements to extract cannot be negative.");
-            static_assert(
-                N == dynamic_extent ||
-                    N >= Offset + (Count == dynamic_extent ? 0 : Count),
-                "Sequence of elements to extract must be within the static span extent.");
-            return RANGES_EXPECT(size() >=
-                                 Offset + (Count == dynamic_extent ? 0 : Count)),
-                   RANGES_EXPECT((Offset == 0 && Count <= 0) || data_ != nullptr),
-                   span<T, detail::subspan_extent(N, Offset, Count)>{
-                       data_ + Offset, Count == dynamic_extent ? size() - Offset : Count};
-        }
-        template<index_type Offset>
-        constexpr span<T, (N >= Offset ? N - Offset : dynamic_extent)> subspan() const
-            noexcept
-        {
-            static_assert(Offset >= 0,
-                          "Offset of first element to extract cannot be negative.");
-            static_assert(N == dynamic_extent || N >= Offset,
-                          "Offset of first element to extract must be within the static "
-                          "span extent.");
-            return RANGES_EXPECT(size() >= Offset),
-                   RANGES_EXPECT((Offset == 0 && size() == 0) || data_ != nullptr),
-                   span < T,
-                   N >= Offset ? N - Offset
-                               : dynamic_extent > {data_ + Offset, size() - Offset};
-        }
-        constexpr span<T, dynamic_extent> subspan(index_type offset) const noexcept
-        {
-            return RANGES_EXPECT(offset >= 0), RANGES_EXPECT(size() >= offset),
-                   RANGES_EXPECT((offset == 0 && size() == 0) || data_ != nullptr),
-                   span<T, dynamic_extent>{data_ + offset, size() - offset};
-        }
-        constexpr span<T, dynamic_extent> subspan(index_type offset, index_type cnt) const
-            noexcept
-        {
-            return RANGES_EXPECT(offset >= 0), RANGES_EXPECT(cnt >= 0),
-                   RANGES_EXPECT(size() >= offset + cnt),
-                   RANGES_EXPECT((offset == 0 && cnt == 0) || data_ != nullptr),
-                   span<T, dynamic_extent>{data_ + offset, cnt};
-        }
-
-        constexpr pointer data() const noexcept
-        {
-            return data_;
-        }
-        using detail::span_extent<N>::size;
-        constexpr index_type size_bytes() const noexcept
-        {
-            return detail::byte_size<T>(size());
-        }
-        constexpr bool empty() const noexcept
-        {
-            return size() == 0;
-        }
-
-        constexpr reference operator[](index_type idx) const noexcept
-        {
-            return RANGES_EXPECT(idx >= 0), RANGES_EXPECT(idx < size()),
-                   RANGES_EXPECT(data_), data_[idx];
-        }
-
-        constexpr iterator begin() const noexcept
-        {
-            return RANGES_EXPECT(!size() || data_), data_;
-        }
-        constexpr iterator end() const noexcept
-        {
-            return RANGES_EXPECT(!size() || data_), data_ + size();
-        }
-        constexpr reverse_iterator rbegin() const noexcept
-        {
-            return reverse_iterator{end()};
-        }
-        constexpr reverse_iterator rend() const noexcept
-        {
-            return reverse_iterator{begin()};
-        }
-
-        template(typename U, index_type M)(
-            /// \pre
-            requires equality_comparable_with<T, U>)
-        bool operator==(span<U, M> const & that) const
-        {
-            RANGES_EXPECT(!size() || data());
-            RANGES_EXPECT(!that.size() || that.data());
-            return ranges::equal(*this, that);
-        }
-        template(typename U, index_type M)(
-            /// \pre
-            requires equality_comparable_with<T, U>)
-        bool operator!=(span<U, M> const & that) const
-        {
-            return !(*this == that);
-        }
-
-        template(typename U, index_type M)(
-            /// \pre
-            requires totally_ordered_with<T, U>)
-        bool operator<(span<U, M> const & that) const
-        {
-            RANGES_EXPECT(!size() || data());
-            RANGES_EXPECT(!that.size() || that.data());
-            return ranges::lexicographical_compare(*this, that);
-        }
-        template(typename U, index_type M)(
-            /// \pre
-            requires totally_ordered_with<T, U>)
-        bool operator>(span<U, M> const & that) const
-        {
-            return that < *this;
-        }
-        template(typename U, index_type M)(
-            /// \pre
-            requires totally_ordered_with<T, U>)
-        bool operator<=(span<U, M> const & that) const
-        {
-            return !(that < *this);
-        }
-        template(typename U, index_type M)(
-            /// \pre
-            requires totally_ordered_with<T, U>)
-        bool operator>=(span<U, M> const & that) const
-        {
-            return !(*this < that);
-        }
-
-    private:
-        T * data_ = nullptr;
-    };
-
-    template<typename T, detail::span_index_t N>
-    RANGES_INLINE_VAR constexpr bool enable_borrowed_range<span<T, N>> = true;
-
-    template<typename T, detail::span_index_t N>
-    constexpr detail::span_index_t span<T, N>::extent;
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template(typename Rng)(
-        /// \pre
-        requires contiguous_range<Rng>)
-        span(Rng && rng)
-            ->span<detail::element_t<Rng>, (range_cardinality<Rng>::value < cardinality()
-                                                ? dynamic_extent
-                                                : static_cast<detail::span_index_t>(
-                                                      range_cardinality<Rng>::value))>;
-#endif
-
-    template<typename T, detail::span_index_t N>
-    span<unsigned char const, detail::byte_size<T>(N)> as_bytes(span<T, N> s) noexcept
-    {
-        return {reinterpret_cast<unsigned char const *>(s.data()), s.size_bytes()};
-    }
-    template<typename T, detail::span_index_t N>
-    span<unsigned char, detail::byte_size<T>(N)> as_writeable_bytes(span<T, N> s) noexcept
-    {
-        return {reinterpret_cast<unsigned char *>(s.data()), s.size_bytes()};
-    }
-
-    template<typename ElementType>
-    constexpr span<ElementType> make_span(ElementType * ptr,
-                                          detail::span_index_t cnt) noexcept
-    {
-        return span<ElementType>{ptr, cnt};
-    }
-    template<typename ElementType>
-    constexpr span<ElementType> make_span(ElementType * first,
-                                          ElementType * last) noexcept
-    {
-        return span<ElementType>{first, last};
-    }
-    template(typename Rng)(
-        /// \pre
-        requires contiguous_range<Rng> AND
-        (range_cardinality<Rng>::value < cardinality())) //
-        constexpr span<detail::element_t<Rng>> make_span(Rng && rng) noexcept(
-            noexcept(ranges::data(rng), ranges::size(rng)))
-    {
-        return {ranges::data(rng),
-                detail::narrow_cast<detail::span_index_t>(ranges::size(rng))};
-    }
-    template(typename Rng)(
-        /// \pre
-        requires contiguous_range<Rng> AND
-        (range_cardinality<Rng>::value >= cardinality())) //
-        constexpr span<
-            detail::element_t<Rng>,
-            static_cast<detail::span_index_t>(
-                range_cardinality<Rng>::
-                    value)> make_span(Rng && rng) noexcept(noexcept(ranges::data(rng)))
-    {
-        return {ranges::data(rng), range_cardinality<Rng>::value};
-    }
-
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif // RANGES_V3_VIEW_SPAN_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/split.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/split.hpp
deleted file mode 100644
index facf1b37..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/split.hpp
+++ /dev/null
@@ -1,716 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_SPLIT_HPP
-#define RANGES_V3_VIEW_SPLIT_HPP
-
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/mismatch.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/iterator/default_sentinel.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/interface.hpp>
-#include <range/v3/view/single.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-
-    /// \cond
-    namespace detail
-    {
-        // clang-format off
-#if defined(_MSC_VER) && !defined(__clang__) && \
-    RANGES_CXX_VER <= RANGES_CXX_STD_17
-        template<typename R, std::size_t Sz = static_cast<std::size_t>(R::size())>
-        constexpr bool _is_tiny_range_(R const *) noexcept
-        {
-            return R::size() <= 1u;
-        }
-        constexpr bool _is_tiny_range_(void const*) noexcept
-        {
-            return false;
-        }
-        template<typename R>
-        CPP_concept tiny_range =
-            sized_range<R> &&
-            detail::_is_tiny_range_(static_cast<std::add_pointer_t<R>>(nullptr));
-#else // ^^^^ workaround / no workaround vvvv
-        template(typename R)(
-        concept (tiny_range_)(R),
-            ranges::type<
-                std::integral_constant<decltype(R::size()), R::size()>> AND
-            (R::size() <= 1)
-        );
-        template<typename R>
-        CPP_concept tiny_range =
-            sized_range<R> &&
-            CPP_concept_ref(detail::tiny_range_, std::remove_reference_t<R>);
-#endif
-        // clang-format on
-    } // namespace detail
-
-    template<typename V, typename Pattern>
-#if CPP_CXX_CONCEPTS
-        requires input_range<V> && forward_range<Pattern> && view_<V> && view_<
-            Pattern> && indirectly_comparable<iterator_t<V>, iterator_t<Pattern>,
-                                              ranges::equal_to> &&
-        (forward_range<V> || detail::tiny_range<Pattern>)
-#endif
-            struct split_view;
-
-    namespace detail
-    {
-        struct there
-        {
-            template<typename T>
-            static decltype(auto) current_(T & t) noexcept
-            {
-                return (t.curr_);
-            }
-        };
-
-        template<typename It>
-        struct here
-        {
-            It curr_ = It();
-            It & current_(ignore_t) noexcept
-            {
-                return curr_;
-            }
-            It const & current_(ignore_t) const noexcept
-            {
-                return curr_;
-            }
-        };
-
-        template<bool>
-        struct here_or_there_
-        {
-            template<typename>
-            using invoke = there;
-        };
-
-        template<>
-        struct here_or_there_<true>
-        {
-            template<typename It>
-            using invoke = here<It>;
-        };
-
-        template<typename It>
-        using split_view_base = meta::invoke<here_or_there_<!forward_iterator<It>>, It>;
-
-        template<typename JoinView, bool Const>
-        struct split_outer_iterator;
-
-        template<typename JoinView, bool Const>
-        struct split_inner_iterator;
-
-        template<typename V, typename Pattern, bool Const>
-        struct split_inner_iterator<split_view<V, Pattern>, Const>
-        {
-        private:
-            using Outer = split_outer_iterator<split_view<V, Pattern>, Const>;
-            using Base = meta::const_if_c<Const, V>;
-            using BaseIterCategory =
-                typename std::iterator_traits<iterator_t<Base>>::iterator_category;
-            Outer i_ = Outer();
-            bool incremented_ = false;
-            constexpr decltype(auto) current_() noexcept
-            {
-                return i_.current_();
-            }
-            constexpr decltype(auto) current_() const noexcept
-            {
-                return i_.current_();
-            }
-            constexpr bool done_() const
-            {
-                auto cur = current_();
-                auto last = ranges::end(i_.parent_->base_);
-                if(cur == last)
-                    return true;
-                auto pcur = ranges::begin(i_.parent_->pattern_);
-                auto pend = ranges::end(i_.parent_->pattern_);
-                if(pcur == pend)
-                    return incremented_;
-                do
-                {
-                    if(*cur != *pcur)
-                        return false;
-                    if(++pcur == pend)
-                        return true;
-                } while(++cur != last);
-                return false;
-            }
-#if RANGES_CXX_IF_CONSTEXPR < RANGES_CXX_IF_CONSTEXPR_17
-            constexpr void pre_inc(std::true_type) // Forward
-            {
-                ++current_();
-            }
-            constexpr void pre_inc(std::false_type) // Input
-            {
-                if(Pattern::size() != 0)
-                    ++current_();
-            }
-            constexpr split_inner_iterator post_inc(std::true_type) // Forward
-            {
-                auto tmp = *this;
-                pre_inc(std::true_type{});
-                return tmp;
-            }
-            constexpr void post_inc(std::false_type) // Input
-            {
-                pre_inc(std::false_type{});
-            }
-#endif
-        public:
-            using iterator_concept = typename Outer::iterator_concept;
-            using iterator_category =
-                meta::conditional_t<
-                    derived_from<BaseIterCategory, std::forward_iterator_tag>,
-                    std::forward_iterator_tag,
-                    std::input_iterator_tag>;
-            using value_type = range_value_t<Base>;
-            using difference_type = range_difference_t<Base>;
-            using reference = range_reference_t<Base>;        // Not to spec
-            using pointer = iter_pointer_t<iterator_t<Base>>; // Not to spec
-
-            split_inner_iterator() = default;
-
-            constexpr explicit split_inner_iterator(Outer i)
-              : i_(std::move(i))
-            {}
-
-            constexpr decltype(auto) operator*() const
-            {
-                return *current_();
-            }
-
-            constexpr split_inner_iterator & operator++()
-            {
-                incremented_ = true;
-#if RANGES_CXX_IF_CONSTEXPR >= RANGES_CXX_IF_CONSTEXPR_17
-                if constexpr(!forward_range<Base>)
-                    if constexpr(Pattern::size() == 0)
-                        return *this;
-                ++current_();
-#else
-                pre_inc(meta::bool_<forward_range<Base>>{});
-#endif
-                return *this;
-            }
-
-            constexpr decltype(auto) operator++(int)
-            {
-#if RANGES_CXX_IF_CONSTEXPR >= RANGES_CXX_IF_CONSTEXPR_17
-                if constexpr(forward_range<V>)
-                {
-                    auto tmp = *this;
-                    ++*this;
-                    return tmp;
-                }
-                else
-                    ++*this;
-#else
-                return post_inc(meta::bool_<forward_range<V>>{});
-#endif
-            }
-
-            CPP_broken_friend_member
-            friend constexpr auto operator==(split_inner_iterator const & x,
-                                             split_inner_iterator const & y)
-                -> CPP_broken_friend_ret(bool)(
-                    /// \pre
-                    requires forward_range<Base>)
-            {
-                return x.i_.curr_ == y.i_.curr_;
-            }
-            CPP_broken_friend_member
-            friend constexpr auto operator!=(split_inner_iterator const & x,
-                                             split_inner_iterator const & y)
-                -> CPP_broken_friend_ret(bool)(
-                    /// \pre
-                    requires forward_range<Base>)
-            {
-                return x.i_.curr_ != y.i_.curr_;
-            }
-#ifdef RANGES_WORKAROUND_MSVC_756601
-            template<typename = void>
-#endif // RANGES_WORKAROUND_MSVC_756601
-            friend constexpr bool operator==(split_inner_iterator const & x,
-                                             default_sentinel_t)
-            {
-                return x.done_();
-            }
-#ifdef RANGES_WORKAROUND_MSVC_756601
-            template<typename = void>
-#endif // RANGES_WORKAROUND_MSVC_756601
-            friend constexpr bool operator==(default_sentinel_t,
-                                             split_inner_iterator const & x)
-            {
-                return x.done_();
-            }
-#ifdef RANGES_WORKAROUND_MSVC_756601
-            template<typename = void>
-#endif // RANGES_WORKAROUND_MSVC_756601
-            friend constexpr bool operator!=(split_inner_iterator const & x,
-                                             default_sentinel_t)
-            {
-                return !x.done_();
-            }
-#ifdef RANGES_WORKAROUND_MSVC_756601
-            template<typename = void>
-#endif // RANGES_WORKAROUND_MSVC_756601
-            friend constexpr bool operator!=(default_sentinel_t,
-                                             split_inner_iterator const & x)
-            {
-                return !x.done_();
-            }
-#ifdef RANGES_WORKAROUND_MSVC_756601
-            template<typename = void>
-#endif // RANGES_WORKAROUND_MSVC_756601
-            friend constexpr decltype(auto) iter_move(
-                split_inner_iterator const &
-                    i) noexcept(noexcept(ranges::iter_move(i.current_())))
-            {
-                return ranges::iter_move(i.current_());
-            }
-            CPP_broken_friend_member
-            friend constexpr auto iter_swap(
-                split_inner_iterator const & x,
-                split_inner_iterator const &
-                    y) noexcept(noexcept(ranges::iter_swap(x.current_(), y.current_())))
-                -> CPP_broken_friend_ret(void)(
-                    /// \pre
-                    requires indirectly_swappable<iterator_t<Base>>)
-            {
-                ranges::iter_swap(x.current_(), y.current_());
-            }
-        };
-
-        template<typename It>
-        using split_outer_iterator_base =
-            meta::invoke<here_or_there_<forward_iterator<It>>, It>;
-
-        template<typename JoinView, bool Const>
-        struct split_outer_iterator;
-
-        template<typename V, typename Pattern, bool Const>
-        struct split_outer_iterator<split_view<V, Pattern>, Const>
-          : split_outer_iterator_base<iterator_t<meta::const_if_c<Const, V>>>
-        {
-        private:
-            friend struct split_inner_iterator<split_view<V, Pattern>, Const>;
-            using Parent = meta::const_if_c<Const, split_view<V, Pattern>>;
-            using Base = meta::const_if_c<Const, V>;
-            using Current = split_outer_iterator_base<iterator_t<Base>>;
-
-            Parent * parent_ = nullptr;
-            constexpr decltype(auto) current_() noexcept
-            {
-                return parent_->current_(*this);
-            }
-            constexpr decltype(auto) current_() const noexcept
-            {
-                return parent_->current_(*this);
-            }
-            constexpr decltype(auto) base_() const noexcept
-            {
-                return (parent_->base_);
-            }
-#if RANGES_CXX_IF_CONSTEXPR < RANGES_CXX_IF_CONSTEXPR_17
-            constexpr split_outer_iterator post_inc(std::true_type) // Forward
-            {
-                auto tmp = *this;
-                ++*this;
-                return tmp;
-            }
-            constexpr void post_inc(std::false_type) // Input
-            {
-                ++*this;
-            }
-#endif
-
-        public:
-            using iterator_concept =
-                meta::conditional_t<forward_range<Base>, std::forward_iterator_tag,
-                          std::input_iterator_tag>;
-            using iterator_category = std::input_iterator_tag;
-            struct value_type : view_interface<value_type>
-            {
-            private:
-                split_outer_iterator i_ = split_outer_iterator();
-
-            public:
-                value_type() = default;
-                constexpr explicit value_type(split_outer_iterator i)
-                  : i_(std::move(i))
-                {}
-                constexpr split_inner_iterator<split_view<V, Pattern>, Const> begin()
-                    const
-                {
-                    return split_inner_iterator<split_view<V, Pattern>, Const>(i_);
-                }
-                constexpr default_sentinel_t end() const
-                {
-                    return default_sentinel;
-                }
-            };
-            using difference_type = range_difference_t<Base>;
-            using reference = value_type; // Not to spec
-            using pointer = value_type *; // Not to spec
-
-            split_outer_iterator() = default;
-
-            CPP_member
-            constexpr explicit CPP_ctor(split_outer_iterator)(Parent & parent)(
-                /// \pre
-                requires (!forward_range<Base>))
-              : parent_(&parent)
-            {}
-
-            CPP_member
-            constexpr CPP_ctor(split_outer_iterator)(Parent & parent,
-                                                     iterator_t<Base> current)(
-                /// \pre
-                requires forward_range<Base>)
-              : Current{std::move(current)}
-              , parent_(&parent)
-            {}
-
-            template(bool Other)(
-                /// \pre
-                requires Const AND CPP_NOT(Other) AND
-                convertible_to<iterator_t<V>, iterator_t<Base>>)
-            constexpr split_outer_iterator(
-                split_outer_iterator<split_view<V, Pattern>, Other> i)
-              : Current{std::move(i.curr_)}
-              , parent_(i.parent_)
-            {}
-
-            constexpr value_type operator*() const
-            {
-                return value_type{*this};
-            }
-
-            constexpr split_outer_iterator & operator++()
-            {
-                auto & current = current_();
-                const auto last = ranges::end(base_());
-                if(current == last)
-                    return *this;
-                auto const pbegin = ranges::begin(parent_->pattern_);
-                auto const pend = ranges::end(parent_->pattern_);
-                if(pbegin == pend)
-                    ++current;
-                else
-                    do
-                    {
-                        const auto ret = ranges::mismatch(current, last, pbegin, pend);
-                        if(ret.in2 == pend)
-                        {
-                            current = ret.in1; // The pattern matched; skip it
-                            break;
-                        }
-                    } while(++current != last);
-                return *this;
-            }
-
-            constexpr decltype(auto) operator++(int)
-            {
-#if RANGES_CXX_IF_CONSTEXPR >= RANGES_CXX_IF_CONSTEXPR_17
-                if constexpr(forward_range<Base>)
-                {
-                    auto tmp = *this;
-                    ++*this;
-                    return tmp;
-                }
-                else
-                    ++*this;
-#else
-                return post_inc(meta::bool_<forward_range<Base>>{});
-#endif
-            }
-
-            CPP_broken_friend_member
-            friend constexpr auto operator==(split_outer_iterator const & x,
-                                             split_outer_iterator const & y)
-                -> CPP_broken_friend_ret(bool)(
-                    /// \pre
-                    requires forward_range<Base>)
-            {
-                return x.curr_ == y.curr_;
-            }
-            CPP_broken_friend_member
-            friend constexpr auto operator!=(split_outer_iterator const & x,
-                                             split_outer_iterator const & y)
-                -> CPP_broken_friend_ret(bool)(
-                    /// \pre
-                    requires forward_range<Base>)
-            {
-                return x.curr_ != y.curr_;
-            }
-#ifdef RANGES_WORKAROUND_MSVC_756601
-            template<typename = void>
-#endif // RANGES_WORKAROUND_MSVC_756601
-            friend constexpr bool operator==(split_outer_iterator const & x,
-                                             default_sentinel_t)
-            {
-                return x.current_() == ranges::end(x.base_());
-            }
-#ifdef RANGES_WORKAROUND_MSVC_756601
-            template<typename = void>
-#endif // RANGES_WORKAROUND_MSVC_756601
-            friend constexpr bool operator==(default_sentinel_t,
-                                             split_outer_iterator const & x)
-            {
-                return x.current_() == ranges::end(x.base_());
-            }
-#ifdef RANGES_WORKAROUND_MSVC_756601
-            template<typename = void>
-#endif // RANGES_WORKAROUND_MSVC_756601
-            friend constexpr bool operator!=(split_outer_iterator const & x,
-                                             default_sentinel_t)
-            {
-                return x.current_() != ranges::end(x.base_());
-            }
-#ifdef RANGES_WORKAROUND_MSVC_756601
-            template<typename = void>
-#endif // RANGES_WORKAROUND_MSVC_756601
-            friend constexpr bool operator!=(default_sentinel_t,
-                                             split_outer_iterator const & x)
-            {
-                return x.current_() != ranges::end(x.base_());
-            }
-        };
-    } // namespace detail
-    /// \endcond
-
-    template<typename V, typename Pattern>
-#if CPP_CXX_CONCEPTS
-        requires input_range<V> && forward_range<Pattern> && view_<V> && view_<
-            Pattern> && indirectly_comparable<iterator_t<V>, iterator_t<Pattern>,
-                                              ranges::equal_to> &&
-        (forward_range<V> || detail::tiny_range<Pattern>)
-#endif
-            struct RANGES_EMPTY_BASES split_view
-      : view_interface<split_view<V, Pattern>, is_finite<V>::value ? finite : unknown>
-      , private detail::split_view_base<iterator_t<V>>
-    {
-    private:
-        template<typename, bool>
-        friend struct detail::split_outer_iterator;
-        template<typename, bool>
-        friend struct detail::split_inner_iterator;
-
-        V base_ = V();
-        Pattern pattern_ = Pattern();
-        template<bool Const>
-        using outer_iterator = detail::split_outer_iterator<split_view, Const>;
-
-#if RANGES_CXX_IF_CONSTEXPR < RANGES_CXX_IF_CONSTEXPR_17
-        outer_iterator<simple_view<V>()> begin_(std::true_type)
-        {
-            return outer_iterator<simple_view<V>()>{*this, ranges::begin(base_)};
-        }
-        outer_iterator<false> begin_(std::false_type)
-        {
-            this->curr_ = ranges::begin(base_);
-            return outer_iterator<false>{*this};
-        }
-
-        outer_iterator<simple_view<V>()> end_(std::true_type) const
-        {
-            return outer_iterator<true>{*this, ranges::end(base_)};
-        }
-        default_sentinel_t end_(std::false_type) const
-        {
-            return default_sentinel;
-        }
-#endif
-
-    public:
-        split_view() = default;
-
-        constexpr split_view(V base, Pattern pattern)
-          : base_((V &&) base)
-          , pattern_((Pattern &&) pattern)
-        {}
-
-        CPP_member
-        constexpr CPP_ctor(split_view)(V base, range_value_t<V> e)(
-            /// \pre
-            requires constructible_from<Pattern, range_value_t<V>>)
-          : base_(std::move(base))
-          , pattern_(e)
-        {}
-
-        constexpr V base() const
-        {
-            return base_;
-        }
-
-        constexpr outer_iterator<forward_range<V> && simple_view<V>()> begin()
-        {
-#if RANGES_CXX_IF_CONSTEXPR >= RANGES_CXX_IF_CONSTEXPR_17
-            if constexpr(forward_range<V>)
-                return outer_iterator<simple_view<V>()>{*this, ranges::begin(base_)};
-            else
-            {
-                this->curr_ = ranges::begin(base_);
-                return outer_iterator<false>{*this};
-            }
-#else
-            return begin_(meta::bool_<forward_range<V>>{});
-#endif
-        }
-        CPP_member
-        constexpr auto begin() const //
-            -> CPP_ret(outer_iterator<true>)(
-                /// \pre
-                requires forward_range<V> && forward_range<const V>)
-        {
-            return {*this, ranges::begin(base_)};
-        }
-        CPP_member
-        constexpr auto end() //
-            -> CPP_ret(outer_iterator<simple_view<V>()>)(
-                /// \pre
-                requires forward_range<V> && common_range<V>)
-        {
-            return outer_iterator<simple_view<V>()>{*this, ranges::end(base_)};
-        }
-        constexpr auto end() const
-        {
-#if RANGES_CXX_IF_CONSTEXPR >= RANGES_CXX_IF_CONSTEXPR_17
-            if constexpr(forward_range<V> && forward_range<const V> &&
-                         common_range<const V>)
-                return outer_iterator<true>{*this, ranges::end(base_)};
-            else
-                return default_sentinel;
-#else
-            return end_(meta::bool_ < forward_range<V> && forward_range<const V> &&
-                        common_range<const V> > {});
-#endif
-        }
-    };
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template(typename R, typename P)(
-        /// \pre
-        requires input_range<R> AND forward_range<P> AND viewable_range<R> AND
-            viewable_range<P> AND
-            indirectly_comparable<iterator_t<R>, iterator_t<P>, ranges::equal_to> AND
-            (forward_range<R> || detail::tiny_range<P>)) //
-    split_view(R &&, P &&)
-            ->split_view<views::all_t<R>, views::all_t<P>>;
-
-    template(typename R)(
-        /// \pre
-        requires input_range<R>)
-        split_view(R &&, range_value_t<R>)
-            ->split_view<views::all_t<R>, single_view<range_value_t<R>>>;
-#endif
-
-    namespace views
-    {
-        struct split_base_fn
-        {
-            template(typename Rng)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng> AND
-                    indirectly_comparable<iterator_t<Rng>,
-                                          range_value_t<Rng> const *,
-                                          ranges::equal_to>)
-            constexpr split_view<all_t<Rng>, single_view<range_value_t<Rng>>> //
-            operator()(Rng && rng, range_value_t<Rng> val) const
-            {
-                return {all(static_cast<Rng &&>(rng)), single(std::move(val))};
-            }
-
-            template(typename Rng, typename Pattern)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng> AND
-                    viewable_range<Pattern> AND forward_range<Pattern> AND
-                    indirectly_comparable<
-                        iterator_t<Rng>,
-                        iterator_t<Pattern>,
-                        ranges::equal_to> AND
-                    (forward_range<Rng> || detail::tiny_range<Pattern>)) //
-            constexpr split_view<all_t<Rng>, all_t<Pattern>> //
-            operator()(Rng && rng, Pattern && pattern) const
-            {
-                return {all((Rng &&) rng), all((Pattern &&) pattern)};
-            }
-        };
-
-        struct split_fn : split_base_fn
-        {
-            using split_base_fn::operator();
-
-            template<typename T>
-            constexpr auto operator()(T t) const
-            {
-                return make_view_closure(bind_back(split_base_fn{}, std::move(t)));
-            }
-        };
-
-        /// \relates split_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(split_fn, split)
-    } // namespace views
-
-    namespace cpp20
-    {
-        namespace views
-        {
-            using ranges::views::split;
-        }
-        template(typename Rng, typename Pattern)(
-            /// \pre
-            requires input_range<Rng> AND forward_range<Pattern> AND view_<Rng> AND
-                view_<Pattern> AND
-                indirectly_comparable<
-                    iterator_t<Rng>,
-                    iterator_t<Pattern>,
-                    ranges::equal_to> AND
-                (forward_range<Rng> || ranges::detail::tiny_range<Pattern>)) //
-        using split_view =
-            ranges::split_view<Rng, Pattern>;
-    } // namespace cpp20
-
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::split_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/split_when.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/split_when.hpp
deleted file mode 100644
index 21f55aa7..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/split_when.hpp
+++ /dev/null
@@ -1,236 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_SPLIT_WHEN_HPP
-#define RANGES_V3_VIEW_SPLIT_WHEN_HPP
-
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/find_if_not.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/default_sentinel.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/facade.hpp>
-#include <range/v3/view/indirect.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/take_while.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-
-    template<typename Rng, typename Fun>
-    struct split_when_view
-      : view_facade<split_when_view<Rng, Fun>,
-                    is_finite<Rng>::value ? finite : range_cardinality<Rng>::value>
-    {
-    private:
-        friend range_access;
-        Rng rng_;
-        semiregular_box_t<Fun> fun_;
-
-        template<bool IsConst>
-        struct cursor
-        {
-        private:
-            friend range_access;
-            friend split_when_view;
-            friend struct cursor<!IsConst>;
-            bool zero_;
-            using CRng = meta::const_if_c<IsConst, Rng>;
-            iterator_t<CRng> cur_;
-            sentinel_t<CRng> last_;
-            using fun_ref_t = semiregular_box_ref_or_val_t<Fun, IsConst>;
-            fun_ref_t fun_;
-
-            struct search_pred
-            {
-                bool zero_;
-                iterator_t<CRng> first_;
-                sentinel_t<CRng> last_;
-                fun_ref_t fun_;
-                bool operator()(iterator_t<CRng> cur) const
-                {
-                    return (zero_ && cur == first_) ||
-                           (cur != last_ && !invoke(fun_, cur, last_).first);
-                }
-            };
-            using reference_ =
-                indirect_view<take_while_view<iota_view<iterator_t<CRng>>, search_pred>>;
-            reference_ read() const
-            {
-                return reference_{{views::iota(cur_), {zero_, cur_, last_, fun_}}};
-            }
-            void next()
-            {
-                RANGES_EXPECT(cur_ != last_);
-                // If the last match consumed zero elements, bump the position.
-                if(zero_)
-                {
-                    zero_ = false;
-                    ++cur_;
-                }
-                for(; cur_ != last_; ++cur_)
-                {
-                    auto p = invoke(fun_, cur_, last_);
-                    if(p.first)
-                    {
-                        zero_ = (cur_ == p.second);
-                        cur_ = p.second;
-                        return;
-                    }
-                }
-            }
-            bool equal(default_sentinel_t) const
-            {
-                return cur_ == last_;
-            }
-            bool equal(cursor const & that) const
-            {
-                return cur_ == that.cur_;
-            }
-            cursor(fun_ref_t fun, iterator_t<CRng> first, sentinel_t<CRng> last)
-              : cur_(first)
-              , last_(last)
-              , fun_(fun)
-            {
-                // For skipping an initial zero-length match
-                auto p = invoke(fun, first, last);
-                zero_ = p.first && first == p.second;
-            }
-
-        public:
-            cursor() = default;
-            template(bool Other)(
-                /// \pre
-                requires IsConst AND CPP_NOT(Other)) //
-            cursor(cursor<Other> that)
-              : cursor{std::move(that.cur_), std::move(that.last_), std::move(that.fun_)}
-            {}
-        };
-        cursor<false> begin_cursor()
-        {
-            return {fun_, ranges::begin(rng_), ranges::end(rng_)};
-        }
-        template(bool Const = true)(
-            /// \pre
-            requires Const AND range<meta::const_if_c<Const, Rng>> AND
-                invocable<Fun const &, iterator_t<meta::const_if_c<Const, Rng>>,
-                          sentinel_t<meta::const_if_c<Const, Rng>>>)
-        cursor<Const> begin_cursor() const
-        {
-            return {fun_, ranges::begin(rng_), ranges::end(rng_)};
-        }
-
-    public:
-        split_when_view() = default;
-        split_when_view(Rng rng, Fun fun)
-          : rng_(std::move(rng))
-          , fun_(std::move(fun))
-        {}
-    };
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template(typename Rng, typename Fun)(
-        /// \pre
-        requires copy_constructible<Fun>)
-    split_when_view(Rng &&, Fun)
-        -> split_when_view<views::all_t<Rng>, Fun>;
-#endif
-
-    namespace views
-    {
-        struct split_when_base_fn
-        {
-        private:
-            template<typename Pred>
-            struct predicate_pred_
-            {
-                semiregular_box_t<Pred> pred_;
-
-                template(typename I, typename S)(
-                    /// \pre
-                    requires sentinel_for<S, I>)
-                std::pair<bool, I> operator()(I cur, S last) const
-                {
-                    auto where = ranges::find_if_not(cur, last, std::ref(pred_));
-                    return {cur != where, where};
-                }
-            };
-
-        public:
-            template(typename Rng, typename Fun)(
-                /// \pre
-                requires viewable_range<Rng> AND forward_range<Rng> AND
-                    invocable<Fun &, iterator_t<Rng>, sentinel_t<Rng>> AND
-                    invocable<Fun &, iterator_t<Rng>, iterator_t<Rng>> AND
-                    copy_constructible<Fun> AND
-                    convertible_to<
-                        invoke_result_t<Fun &, iterator_t<Rng>, sentinel_t<Rng>>,
-                        std::pair<bool, iterator_t<Rng>>>)
-            split_when_view<all_t<Rng>, Fun> operator()(Rng && rng, Fun fun) const //
-            {
-                return {all(static_cast<Rng &&>(rng)), std::move(fun)};
-            }
-            template(typename Rng, typename Fun)(
-                /// \pre
-                requires viewable_range<Rng> AND forward_range<Rng> AND
-                    predicate<Fun const &, range_reference_t<Rng>> AND
-                    copy_constructible<Fun>)
-            split_when_view<all_t<Rng>, predicate_pred_<Fun>> //
-            operator()(Rng && rng, Fun fun) const
-            {
-                return {all(static_cast<Rng &&>(rng)),
-                        predicate_pred_<Fun>{std::move(fun)}};
-            }
-        };
-
-        struct split_when_fn : split_when_base_fn
-        {
-            using split_when_base_fn::operator();
-
-            template<typename T>
-            constexpr auto operator()(T && t) const
-            {
-                return make_view_closure(
-                    bind_back(split_when_base_fn{}, static_cast<T &&>(t)));
-            }
-        };
-
-        /// \relates split_when_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(split_when_fn, split_when)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::split_when_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/stride.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/stride.hpp
deleted file mode 100644
index bf0edb9e..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/stride.hpp
+++ /dev/null
@@ -1,350 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//  Copyright Casey Carter 2017
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_STRIDE_HPP
-#define RANGES_V3_VIEW_STRIDE_HPP
-
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/adaptor.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    template<typename Rng>
-    struct stride_view;
-
-    namespace detail
-    {
-        template<typename Rng>
-        using stride_view_adaptor =
-            view_adaptor<stride_view<Rng>, Rng,
-                         is_finite<Rng>::value ? finite : range_cardinality<Rng>::value>;
-
-        // Bidirectional stride views need to remember the distance between
-        // the penultimate iterator and the last iterator - which may be less
-        // than the stride - so that decrementing an last iterator properly
-        // produces the penultimate iterator. stride_view_base specializes on
-        // that distinction so that only Bidirectional stride views have the
-        // data member "offset_".
-        template<typename Rng, bool BidiRange>
-        struct stride_view_base_;
-        template<typename Rng>
-        using stride_view_base = stride_view_base_<Rng, (bool)bidirectional_range<Rng>>;
-
-        template<typename Rng, bool /*= bidirectional_range<Rng>*/>
-        struct stride_view_base_ : stride_view_adaptor<Rng>
-        {
-            stride_view_base_() = default;
-            constexpr stride_view_base_(Rng && rng, range_difference_t<Rng> const stride)
-              : stride_view_adaptor<Rng>{std::move(rng)}
-              , stride_{(RANGES_EXPECT(0 < stride), stride)}
-              , offset_{calc_offset(meta::bool_<sized_range<Rng>>{})}
-            {}
-
-        protected:
-            constexpr void set_offset(range_difference_t<Rng> const delta) noexcept
-            {
-                RANGES_EXPECT(0 <= delta && delta < stride_);
-                if(0 > offset_)
-                    offset_ = delta;
-                else
-                    RANGES_EXPECT(offset_ == delta);
-            }
-            constexpr void set_offset(range_difference_t<Rng> const) const noexcept
-            {}
-            constexpr range_difference_t<Rng> get_offset(bool check = true) const noexcept
-            {
-                RANGES_EXPECT(!check || 0 <= offset_);
-                return offset_;
-            }
-
-            range_difference_t<Rng> stride_;
-            range_difference_t<Rng> offset_ = -1;
-
-        private:
-            constexpr range_difference_t<Rng> calc_offset(std::true_type)
-            {
-                if(auto const rem = ranges::distance(this->base()) % stride_)
-                    return stride_ - rem;
-                else
-                    return 0;
-            }
-            constexpr range_difference_t<Rng> calc_offset(std::false_type) const noexcept
-            {
-                return -1;
-            }
-        };
-
-        template<typename Rng>
-        struct stride_view_base_<Rng, false> : stride_view_adaptor<Rng>
-        {
-            stride_view_base_() = default;
-            constexpr stride_view_base_(Rng && rng, range_difference_t<Rng> const stride)
-              : stride_view_adaptor<Rng>{std::move(rng)}
-              , stride_{(RANGES_EXPECT(0 < stride), stride)}
-            {}
-
-        protected:
-            constexpr void set_offset(range_difference_t<Rng> const) const noexcept
-            {}
-            constexpr range_difference_t<Rng> get_offset(bool = true) const noexcept
-            {
-                return 0;
-            }
-
-            range_difference_t<Rng> stride_;
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// \addtogroup group-views
-    /// @{
-    template<typename Rng>
-    struct stride_view : detail::stride_view_base<Rng>
-    {
-    private:
-        friend range_access;
-
-        // stride_view const models Range if Rng const models Range, and
-        // either (1) Rng is sized, so we can pre-calculate offset_, or (2)
-        // Rng is !Bidirectional, so it does not need offset_.
-        static constexpr bool const_iterable() noexcept
-        {
-            return range<Rng const> &&
-                   (sized_range<Rng const> || !bidirectional_range<Rng const>);
-        }
-
-        // If the underlying range doesn't model common_range, then we can't
-        // decrement the last and there's no reason to adapt the sentinel. Strictly
-        // speaking, we don't have to adapt the last iterator of input and forward
-        // ranges, but in the interests of making the resulting stride view model
-        // common_range, adapt it anyway.
-        template<bool Const>
-        static constexpr bool can_bound() noexcept
-        {
-            using CRng = meta::const_if_c<Const, Rng>;
-            return common_range<CRng> &&
-                   (sized_range<CRng> || !bidirectional_range<CRng>);
-        }
-
-        template<bool Const>
-        struct adaptor : adaptor_base
-        {
-        private:
-            friend struct adaptor<!Const>;
-            using CRng = meta::const_if_c<Const, Rng>;
-            using stride_view_t = meta::const_if_c<Const, stride_view>;
-            stride_view_t * rng_;
-
-        public:
-            adaptor() = default;
-            constexpr adaptor(stride_view_t * rng) noexcept
-              : rng_(rng)
-            {}
-            template(bool Other)(
-                /// \pre
-                requires Const AND CPP_NOT(Other)) //
-            adaptor(adaptor<Other> that)
-              : rng_(that.rng_)
-            {}
-            constexpr void next(iterator_t<CRng> & it)
-            {
-                auto const last = ranges::end(rng_->base());
-                RANGES_EXPECT(it != last);
-                auto const delta = ranges::advance(it, rng_->stride_, last);
-                if(it == last)
-                {
-                    rng_->set_offset(delta);
-                }
-            }
-            CPP_member
-            constexpr auto prev(iterator_t<CRng> & it) //
-                -> CPP_ret(void)(
-                    /// \pre
-                    requires bidirectional_range<CRng>)
-            {
-                RANGES_EXPECT(it != ranges::begin(rng_->base()));
-                auto delta = -rng_->stride_;
-                if(it == ranges::end(rng_->base()))
-                {
-                    RANGES_EXPECT(rng_->get_offset() >= 0);
-                    delta += rng_->get_offset();
-                }
-                ranges::advance(it, delta);
-            }
-            template(typename Other)(
-                /// \pre
-                requires sized_sentinel_for<Other, iterator_t<CRng>>)
-            constexpr range_difference_t<Rng> distance_to(iterator_t<CRng> const & here,
-                                                          Other const & there) const
-            {
-                range_difference_t<Rng> delta = there - here;
-                if(delta < 0)
-                    delta -= rng_->stride_ - 1;
-                else
-                    delta += rng_->stride_ - 1;
-                return delta / rng_->stride_;
-            }
-            CPP_member
-            constexpr auto advance(iterator_t<CRng> & it, range_difference_t<Rng> n) //
-                -> CPP_ret(void)(
-                    /// \pre
-                    requires random_access_range<CRng>)
-            {
-                if(0 == n)
-                    return;
-                n *= rng_->stride_;
-                auto const last = ranges::end(rng_->base());
-                if(it == last)
-                {
-                    RANGES_EXPECT(n < 0);
-                    RANGES_EXPECT(rng_->get_offset() >= 0);
-                    n += rng_->get_offset();
-                }
-                if(0 < n)
-                {
-                    auto delta = ranges::advance(it, n, last);
-                    if(it == last)
-                    {
-                        // advance hit the last of the base range.
-                        rng_->set_offset(delta % rng_->stride_);
-                    }
-                }
-                else if(0 > n)
-                {
-#ifdef NDEBUG
-                    ranges::advance(it, n);
-#else
-                    auto const first = ranges::begin(rng_->base());
-                    auto const delta = ranges::advance(it, n, first);
-                    RANGES_EXPECT(delta == 0);
-#endif
-                }
-            }
-        };
-        constexpr adaptor<false> begin_adaptor() noexcept
-        {
-            return adaptor<false>{this};
-        }
-        CPP_member
-        constexpr auto begin_adaptor() const noexcept
-            -> CPP_ret(adaptor<true>)(
-                /// \pre
-                requires(const_iterable()))
-        {
-            return adaptor<true>{this};
-        }
-
-        constexpr meta::if_c<can_bound<false>(), adaptor<false>, adaptor_base> //
-        end_adaptor() noexcept
-        {
-            return {this};
-        }
-        CPP_member
-        constexpr auto end_adaptor() const noexcept //
-            -> CPP_ret(meta::if_c<can_bound<true>(), adaptor<true>, adaptor_base>)(
-                /// \pre
-                requires (const_iterable()))
-        {
-            return {this};
-        }
-
-    public:
-        stride_view() = default;
-        constexpr stride_view(Rng rng, range_difference_t<Rng> const stride)
-          : detail::stride_view_base<Rng>{std::move(rng), stride}
-        {}
-        CPP_member
-        constexpr auto CPP_fun(size)()(
-            /// \pre
-            requires sized_range<Rng>)
-        {
-            using size_type = range_size_t<Rng>;
-            auto const n = ranges::size(this->base());
-            return (n + static_cast<size_type>(this->stride_) - 1) /
-                   static_cast<size_type>(this->stride_);
-        }
-        CPP_member
-        constexpr auto CPP_fun(size)()(const //
-            requires sized_range<Rng const>)
-        {
-            using size_type = range_size_t<Rng const>;
-            auto const n = ranges::size(this->base());
-            return (n + static_cast<size_type>(this->stride_) - 1) /
-                   static_cast<size_type>(this->stride_);
-        }
-    };
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template<typename Rng>
-    stride_view(Rng &&, range_difference_t<Rng>)
-        -> stride_view<views::all_t<Rng>>;
-#endif
-
-    namespace views
-    {
-        struct stride_base_fn
-        {
-            template(typename Rng)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng>)
-            constexpr stride_view<all_t<Rng>> //
-            operator()(Rng && rng, range_difference_t<Rng> step) const
-            {
-                return stride_view<all_t<Rng>>{all(static_cast<Rng &&>(rng)), step};
-            }
-        };
-
-        struct stride_fn : stride_base_fn
-        {
-            using stride_base_fn::operator();
-
-            template(typename Difference)(
-                /// \pre
-                requires detail::integer_like_<Difference>)
-            constexpr auto operator()(Difference step) const
-            {
-                return make_view_closure(bind_back(stride_base_fn{}, step));
-            }
-        };
-
-        /// \relates stride_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(stride_fn, stride)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::stride_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/subrange.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/subrange.hpp
deleted file mode 100644
index 73829cfa..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/subrange.hpp
+++ /dev/null
@@ -1,487 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//  Copyright Casey Carter 2017
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_SUBRANGE_HPP
-#define RANGES_V3_VIEW_SUBRANGE_HPP
-
-#include <tuple>
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/unreachable_sentinel.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/dangling.hpp>
-#include <range/v3/utility/get.hpp>
-#include <range/v3/view/interface.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    enum class subrange_kind : bool
-    {
-        unsized,
-        sized
-    };
-
-    /// \cond
-    namespace detail
-    {
-        // clang-format off
-        template<typename From, typename To>
-        CPP_concept convertible_to_not_slicing_ =
-            convertible_to<From, To> &&
-            // A conversion is a slicing conversion if the source and the destination
-            // are both pointers, and if the pointed-to types differ after removing
-            // cv qualifiers.
-            (!(std::is_pointer<decay_t<From>>::value &&
-                std::is_pointer<decay_t<To>>::value &&
-                not_same_as_<std::remove_pointer_t<decay_t<From>>,
-                             std::remove_pointer_t<decay_t<To>>>));
-
-        template<std::size_t N, typename T>
-        using tuple_element_fun_t = void (*)(meta::_t<std::tuple_element<N, T>> const &);
-
-        template<typename T>
-        CPP_requires(pair_like_impl_, //
-            requires(T t, tuple_element_fun_t<0, T> p0, tuple_element_fun_t<1, T> p1) //
-            (
-                p0( get<0>(t) ),
-                p1( get<1>(t) )
-            ));
-        template<typename T>
-        CPP_concept pair_like_impl_ = CPP_requires_ref(detail::pair_like_impl_, T);
-
-        template(typename T)(
-        concept (is_complete_)(T),
-            0 != sizeof(T));
-
-        template<typename T>
-        CPP_concept is_complete_ = //
-            CPP_concept_ref(is_complete_, T);
-
-        template(typename T)( //
-        concept (pair_like_)(T), //
-            is_complete_<std::tuple_size<T>> AND
-            derived_from<std::tuple_size<T>, meta::size_t<2>> AND
-            detail::pair_like_impl_<T>);
-
-        template<typename T>
-        CPP_concept pair_like = //
-            CPP_concept_ref(detail::pair_like_, T);
-
-        // clang-format off
-        template(typename T, typename U, typename V)( //
-        concept (pair_like_convertible_from_helper_)(T, U, V), //
-            convertible_to_not_slicing_<U, meta::_t<std::tuple_element<0, T>>> AND
-            convertible_to<V, meta::_t<std::tuple_element<1, T>>>);
-
-        template<typename T, typename U, typename V>
-        CPP_concept pair_like_convertible_from_helper_ = //
-            CPP_concept_ref(pair_like_convertible_from_helper_, T, U, V);
-
-        template(typename T, typename U, typename V)( //
-        concept (pair_like_convertible_from_impl_)(T, U, V),
-            (!range<T>) AND
-            constructible_from<T, U, V> AND
-            pair_like<uncvref_t<T>> AND
-            pair_like_convertible_from_helper_<T, U, V>);
-
-        template<typename T, typename U, typename V>
-        CPP_concept pair_like_convertible_from_ =
-            CPP_concept_ref(detail::pair_like_convertible_from_impl_, T, U, V);
-
-        template(typename R, typename I, typename S)(
-        concept (range_convertible_to_impl_)(R, I, S),
-            convertible_to_not_slicing_<iterator_t<R>, I> AND
-            convertible_to<sentinel_t<R>, S>);
-
-        template<typename R, typename I, typename S>
-        CPP_concept range_convertible_to_ =
-            borrowed_range<R> &&
-            CPP_concept_ref(detail::range_convertible_to_impl_, R, I, S);
-        // clang-format on
-
-        template(typename S, typename I)(
-            /// \pre
-            requires sentinel_for<S, I>)
-        constexpr bool is_sized_sentinel_() noexcept
-        {
-            return (bool)sized_sentinel_for<S, I>;
-        }
-
-        template<subrange_kind K, typename S, typename I>
-        constexpr bool store_size_() noexcept
-        {
-            return K == subrange_kind::sized && !(bool)sized_sentinel_for<S, I>;
-        }
-    } // namespace detail
-    /// \endcond
-
-    template< //
-        typename I, //
-        typename S = I, //
-        subrange_kind K = static_cast<subrange_kind>(detail::is_sized_sentinel_<S, I>())>
-    struct subrange;
-
-    template<typename I, typename S, subrange_kind K>
-    RANGES_INLINE_VAR constexpr bool enable_borrowed_range<subrange<I, S, K>> = true;
-
-    /// \cond
-    namespace _subrange_
-    {
-        struct adl_hook
-        {};
-
-        template(std::size_t N, typename I, typename S, subrange_kind K)(
-            /// \pre
-            requires (N == 0)) //
-        constexpr I get(subrange<I, S, K> const & r)
-        {
-            return r.begin();
-        }
-        template(std::size_t N, typename I, typename S, subrange_kind K)(
-            /// \pre
-            requires (N == 1)) //
-        constexpr S get(subrange<I, S, K> const & r)
-        {
-            return r.end();
-        }
-    } // namespace _subrange_
-    /// \endcond
-
-    template<typename I, typename S, subrange_kind K>
-    struct subrange
-      : view_interface<subrange<I, S, K>,
-                       same_as<S, unreachable_sentinel_t>
-                           ? infinite
-                           : K == subrange_kind::sized ? finite : unknown>
-      , private _subrange_::adl_hook
-    {
-        CPP_assert(input_or_output_iterator<I>);
-        CPP_assert(sentinel_for<S, I>);
-        CPP_assert(K == subrange_kind::sized || !sized_sentinel_for<S, I>);
-        CPP_assert(K != subrange_kind::sized || !same_as<S, unreachable_sentinel_t>);
-
-        using size_type = detail::iter_size_t<I>;
-        using iterator = I;
-        using sentinel = S;
-
-        subrange() = default;
-
-        template(typename I2)(
-            /// \pre
-            requires detail::convertible_to_not_slicing_<I2, I> AND
-            (!detail::store_size_<K, S, I>())) //
-        constexpr subrange(I2 && i, S s)
-          : data_{static_cast<I2 &&>(i), std::move(s)}
-        {}
-
-        template(typename I2)(
-            /// \pre
-            requires detail::convertible_to_not_slicing_<I2, I> AND
-            (detail::store_size_<K, S, I>())) //
-        constexpr subrange(I2 && i, S s, size_type n)
-          : data_{static_cast<I2 &&>(i), std::move(s), n}
-        {
-            if(RANGES_CONSTEXPR_IF((bool)random_access_iterator<I>))
-            {
-                using D = iter_difference_t<I>;
-                RANGES_EXPECT(n <= (size_type)std::numeric_limits<D>::max());
-                RANGES_EXPECT(ranges::next(first_(), (D)n) == last_());
-            }
-        }
-        template(typename I2)(
-            /// \pre
-            requires detail::convertible_to_not_slicing_<I2, I> AND
-                sized_sentinel_for<S, I>)
-        constexpr subrange(I2 && i, S s, size_type n)
-          : data_{static_cast<I2 &&>(i), std::move(s)}
-        {
-            RANGES_EXPECT(static_cast<size_type>(last_() - first_()) == n);
-        }
-
-        template(typename R)(
-            /// \pre
-            requires (!same_as<detail::decay_t<R>, subrange>) AND
-                detail::range_convertible_to_<R, I, S> AND
-                (!detail::store_size_<K, S, I>()))
-        constexpr subrange(R && r)
-          : subrange{ranges::begin(r), ranges::end(r)}
-        {}
-
-        template(typename R)(
-            /// \pre
-            requires (!same_as<detail::decay_t<R>, subrange>) AND
-                detail::range_convertible_to_<R, I, S> AND
-                (detail::store_size_<K, S, I>()) AND
-                sized_range<R>)
-        constexpr subrange(R && r)
-          : subrange{ranges::begin(r), ranges::end(r), ranges::size(r)}
-        {}
-
-        template(typename R)(
-            /// \pre
-            requires (K == subrange_kind::sized) AND
-                detail::range_convertible_to_<R, I, S>)
-        constexpr subrange(R && r, size_type n) //
-          : subrange{ranges::begin(r), ranges::end(r), n}
-        {
-            if(RANGES_CONSTEXPR_IF((bool)sized_range<R>))
-            {
-                RANGES_EXPECT(n == ranges::size(r));
-            }
-        }
-
-        template(typename PairLike)(
-            /// \pre
-            requires (!same_as<PairLike, subrange>) AND
-                detail::pair_like_convertible_from_<PairLike, I const &, S const &>)
-        constexpr operator PairLike() const
-        {
-            return PairLike(first_(), last_());
-        }
-
-        constexpr I begin() const noexcept(std::is_nothrow_copy_constructible<I>::value)
-        {
-            return first_();
-        }
-        constexpr S end() const noexcept(std::is_nothrow_copy_constructible<S>::value)
-        {
-            return last_();
-        }
-        constexpr bool empty() const
-        {
-            return first_() == last_();
-        }
-
-        CPP_member
-        constexpr auto size() const //
-            -> CPP_ret(size_type)(
-                /// \pre
-                requires (K == subrange_kind::sized))
-        {
-            return get_size_();
-        }
-
-        RANGES_NODISCARD
-        constexpr subrange next(iter_difference_t<I> n = 1) const
-        {
-            auto tmp = *this;
-            tmp.advance(n);
-            return tmp;
-        }
-
-        CPP_member
-        RANGES_NODISCARD constexpr auto prev(iter_difference_t<I> n = 1) const
-            -> CPP_ret(subrange)(
-                /// \pre
-                requires bidirectional_iterator<I>)
-        {
-            auto tmp = *this;
-            tmp.advance(-n);
-            return tmp;
-        }
-
-        constexpr subrange & advance(iter_difference_t<I> n)
-        {
-            set_size_(get_size_() -
-                      static_cast<size_type>(n - ranges::advance(first_(), n, last_())));
-            return *this;
-        }
-
-    private:
-        using data_t =
-            meta::conditional_t< //
-                detail::store_size_<K, S, I>(), //
-                std::tuple<I, S, size_type>, //
-                std::tuple<I, S>>;
-        data_t data_;
-
-        constexpr I & first_() noexcept
-        {
-            return std::get<0>(data_);
-        }
-        constexpr const I & first_() const noexcept
-        {
-            return std::get<0>(data_);
-        }
-        constexpr S & last_() noexcept
-        {
-            return std::get<1>(data_);
-        }
-        constexpr const S & last_() const noexcept
-        {
-            return std::get<1>(data_);
-        }
-        CPP_member
-        constexpr auto get_size_() const //
-            -> CPP_ret(size_type)(
-                /// \pre
-                requires sized_sentinel_for<S, I>)
-        {
-            return static_cast<size_type>(last_() - first_());
-        }
-        CPP_member
-        constexpr auto get_size_() const noexcept //
-            -> CPP_ret(size_type)(
-                /// \pre
-                requires (detail::store_size_<K, S, I>()))
-        {
-            return std::get<2>(data_);
-        }
-        static constexpr void set_size_(...) noexcept
-        {}
-        CPP_member
-        constexpr auto set_size_(size_type n) noexcept //
-            -> CPP_ret(void)(
-                /// \pre
-                requires (detail::store_size_<K, S, I>()))
-        {
-            std::get<2>(data_) = n;
-        }
-    };
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template<typename I, typename S>
-    subrange(I, S) //
-        -> subrange<I, S>;
-
-    template(typename I, typename S)(
-        /// \pre
-        requires input_or_output_iterator<I> AND sentinel_for<S, I>)
-    subrange(I, S, detail::iter_size_t<I>)
-        -> subrange<I, S, subrange_kind::sized>;
-
-    template(typename R)(
-        /// \pre
-        requires borrowed_range<R>)
-    subrange(R &&) //
-        -> subrange<iterator_t<R>, sentinel_t<R>,
-                    (sized_range<R> ||
-                        sized_sentinel_for<sentinel_t<R>, iterator_t<R>>)
-                           ? subrange_kind::sized
-                           : subrange_kind::unsized>;
-
-    template(typename R)(
-        /// \pre
-        requires borrowed_range<R>)
-    subrange(R &&, detail::iter_size_t<iterator_t<R>>)
-        -> subrange<iterator_t<R>, sentinel_t<R>, subrange_kind::sized>;
-#endif
-
-    // in lieu of deduction guides, use make_subrange
-    struct make_subrange_fn
-    {
-        template<typename I, typename S>
-        constexpr subrange<I, S> operator()(I i, S s) const
-        {
-            return {i, s};
-        }
-        template(typename I, typename S)(
-            /// \pre
-            requires input_or_output_iterator<I> AND sentinel_for<S, I>)
-        constexpr subrange<I, S, subrange_kind::sized> //
-        operator()(I i, S s, detail::iter_size_t<I> n) const
-        {
-            return {i, s, n};
-        }
-        template(typename R)(
-            /// \pre
-            requires borrowed_range<R>)
-        constexpr auto operator()(R && r) const
-            -> subrange<iterator_t<R>, sentinel_t<R>,
-                     (sized_range<R> || sized_sentinel_for<sentinel_t<R>, iterator_t<R>>)
-                         ? subrange_kind::sized
-                         : subrange_kind::unsized>
-        {
-            return {(R &&) r};
-        }
-        template(typename R)(
-            /// \pre
-            requires borrowed_range<R>)
-        constexpr subrange<iterator_t<R>, sentinel_t<R>, subrange_kind::sized> //
-        operator()(R && r, detail::iter_size_t<iterator_t<R>> n) const
-        {
-            return {(R &&) r, n};
-        }
-    };
-
-    /// \relates make_subrange_fn
-    /// \ingroup group-views
-    RANGES_INLINE_VARIABLE(make_subrange_fn, make_subrange)
-
-    template<typename R>
-    using borrowed_subrange_t = detail::maybe_dangling_<R, subrange<iterator_t<R>>>;
-
-    template<typename R>
-    using safe_subrange_t RANGES_DEPRECATED("Use borrowed_subrange_t instead.") =
-        borrowed_subrange_t<R>;
-
-    namespace cpp20
-    {
-        using ranges::subrange_kind;
-
-        template(typename I,                                                //
-                 typename S = I,                                            //
-                 subrange_kind K =                                          //
-                 static_cast<subrange_kind>(                                //
-                     detail::is_sized_sentinel_<S, I>()))(
-            /// \pre
-            requires input_or_output_iterator<I> AND sentinel_for<S, I> AND
-                (K == subrange_kind::sized || !sized_sentinel_for<S, I>))   //
-        using subrange = ranges::subrange<I, S, K>;
-
-        using ranges::borrowed_subrange_t;
-
-        template<typename R>
-        using safe_subrange_t RANGES_DEPRECATED("Use borrowed_subrange_t instead.") =
-            borrowed_subrange_t<R>;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-RANGES_DIAGNOSTIC_PUSH
-RANGES_DIAGNOSTIC_IGNORE_MISMATCHED_TAGS
-
-namespace std
-{
-    template<typename I, typename S, ::ranges::subrange_kind K>
-    struct tuple_size<::ranges::subrange<I, S, K>> : std::integral_constant<size_t, 2>
-    {};
-    template<typename I, typename S, ::ranges::subrange_kind K>
-    struct tuple_element<0, ::ranges::subrange<I, S, K>>
-    {
-        using type = I;
-    };
-    template<typename I, typename S, ::ranges::subrange_kind K>
-    struct tuple_element<1, ::ranges::subrange<I, S, K>>
-    {
-        using type = S;
-    };
-} // namespace std
-
-RANGES_DIAGNOSTIC_POP
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/tail.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/tail.hpp
deleted file mode 100644
index 512d3573..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/tail.hpp
+++ /dev/null
@@ -1,151 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_TAIL_HPP
-#define RANGES_V3_VIEW_TAIL_HPP
-
-#include <type_traits>
-#include <utility>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/interface.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    namespace detail
-    {
-        template<typename T>
-        constexpr T prev_or_zero_(T n)
-        {
-            return n == 0 ? T(0) : T(n - 1);
-        }
-    } // namespace detail
-
-    /// \addtogroup group-views
-    /// @{
-    template<typename Rng>
-    struct tail_view
-      : view_interface<tail_view<Rng>,
-                       (range_cardinality<Rng>::value >= 0)
-                           ? detail::prev_or_zero_(range_cardinality<Rng>::value)
-                           : range_cardinality<Rng>::value>
-    {
-    private:
-        Rng rng_;
-
-    public:
-        tail_view() = default;
-        tail_view(Rng rng)
-          : rng_(static_cast<Rng &&>(rng))
-        {
-            CPP_assert(input_range<Rng>);
-        }
-        iterator_t<Rng> begin()
-        {
-            return next(ranges::begin(rng_), 1, ranges::end(rng_));
-        }
-        template(bool Const = true)(
-            /// \pre
-            requires Const AND range<meta::const_if_c<Const, Rng>>)
-        iterator_t<meta::const_if_c<Const, Rng>> begin() const
-        {
-            return next(ranges::begin(rng_), 1, ranges::end(rng_));
-        }
-        sentinel_t<Rng> end()
-        {
-            return ranges::end(rng_);
-        }
-        template(bool Const = true)(
-            /// \pre
-            requires Const AND range<meta::const_if_c<Const, Rng>>)
-        sentinel_t<meta::const_if_c<Const, Rng>> end() const
-        {
-            return ranges::end(rng_);
-        }
-        // Strange cast to bool in the requires clause is to work around gcc bug.
-        CPP_member
-        constexpr auto CPP_fun(size)()(
-            /// \pre
-            requires(bool(sized_range<Rng>)))
-        {
-            using size_type = range_size_t<Rng>;
-            return range_cardinality<Rng>::value >= 0
-                       ? detail::prev_or_zero_((size_type)range_cardinality<Rng>::value)
-                       : detail::prev_or_zero_(ranges::size(rng_));
-        }
-        CPP_member
-        constexpr auto CPP_fun(size)()(const //
-            requires(bool(sized_range<Rng const>)))
-        {
-            using size_type = range_size_t<Rng>;
-            return range_cardinality<Rng>::value >= 0
-                       ? detail::prev_or_zero_((size_type)range_cardinality<Rng>::value)
-                       : detail::prev_or_zero_(ranges::size(rng_));
-        }
-        Rng base() const
-        {
-            return rng_;
-        }
-    };
-
-    template<typename Rng>
-    RANGES_INLINE_VAR constexpr bool enable_borrowed_range<tail_view<Rng>> = //
-        enable_borrowed_range<Rng>;
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template(typename Rng)(
-        /// \pre
-        requires viewable_range<Rng>)
-        tail_view(Rng &&)
-            ->tail_view<views::all_t<Rng>>;
-#endif
-
-    namespace views
-    {
-        struct tail_fn
-        {
-            template(typename Rng)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng>)
-            meta::if_c<range_cardinality<Rng>::value == 0,
-                       all_t<Rng>,
-                       tail_view<all_t<Rng>>> //
-            operator()(Rng && rng) const
-            {
-                return all(static_cast<Rng &&>(rng));
-            }
-        };
-
-        /// \relates tail_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(view_closure<tail_fn>, tail)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::tail_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/take.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/take.hpp
deleted file mode 100644
index 64fd647e..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/take.hpp
+++ /dev/null
@@ -1,334 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_TAKE_HPP
-#define RANGES_V3_VIEW_TAKE_HPP
-
-#include <type_traits>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/min.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/iterator/counted_iterator.hpp>
-#include <range/v3/iterator/default_sentinel.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-
-    template<typename Rng>
-    struct take_view : view_interface<take_view<Rng>, finite>
-    {
-    private:
-        CPP_assert(view_<Rng>);
-        Rng base_ = Rng();
-        range_difference_t<Rng> count_ = 0;
-        template<bool Const>
-        struct sentinel
-        {
-        private:
-            using Base = meta::conditional_t<Const, Rng const, Rng>;
-            using CI = counted_iterator<iterator_t<Base>>;
-            sentinel_t<Base> end_ = sentinel_t<Base>();
-
-        public:
-            sentinel() = default;
-            constexpr explicit sentinel(sentinel_t<Base> last)
-              : end_(std::move(last))
-            {}
-            template(bool Other)(
-                /// \pre
-                requires Const AND CPP_NOT(Other) AND
-                convertible_to<sentinel_t<Rng>,
-                               sentinel_t<Base>>)
-                constexpr sentinel(sentinel<Other> that)
-              : end_(std::move(that.end_))
-            {}
-            constexpr sentinel_t<Base> base() const
-            {
-                return end_;
-            }
-#ifdef RANGES_WORKAROUND_MSVC_756601
-            template<typename = void>
-#endif // RANGES_WORKAROUND_MSVC_756601
-            friend constexpr bool operator==(sentinel const & x, CI const & y)
-            {
-                return y.count() == 0 || y.base() == x.end_;
-            }
-#ifdef RANGES_WORKAROUND_MSVC_756601
-            template<typename = void>
-#endif // RANGES_WORKAROUND_MSVC_756601
-            friend constexpr bool operator==(CI const & y, sentinel const & x)
-            {
-                return y.count() == 0 || y.base() == x.end_;
-            }
-#ifdef RANGES_WORKAROUND_MSVC_756601
-            template<typename = void>
-#endif // RANGES_WORKAROUND_MSVC_756601
-            friend constexpr bool operator!=(sentinel const & x, CI const & y)
-            {
-                return y.count() != 0 && y.base() != x.end_;
-            }
-#ifdef RANGES_WORKAROUND_MSVC_756601
-            template<typename = void>
-#endif // RANGES_WORKAROUND_MSVC_756601
-            friend constexpr bool operator!=(CI const & y, sentinel const & x)
-            {
-                return y.count() != 0 && y.base() != x.end_;
-            }
-        };
-
-#if RANGES_CXX_IF_CONSTEXPR < RANGES_CXX_IF_CONSTEXPR_17
-        template<typename Take>
-        static auto begin_random_access_(Take & take, std::true_type)
-        {
-            return ranges::begin(take.base_);
-        }
-        template<typename Take>
-        static auto begin_random_access_(Take & take, std::false_type)
-        {
-            auto s = static_cast<range_difference_t<Rng>>(take.size());
-            return make_counted_iterator(ranges::begin(take.base_), s);
-        }
-        template<typename Take>
-        static auto begin_sized_(Take & take, std::true_type)
-        {
-            return begin_random_access_(
-                take, meta::bool_<random_access_range<decltype((take.base_))>>{});
-        }
-        template<typename Take>
-        static auto begin_sized_(Take & take, std::false_type)
-        {
-            return make_counted_iterator(ranges::begin(take.base_), take.count_);
-        }
-
-        template<typename Take>
-        static auto end_random_access_(Take & take, std::true_type)
-        {
-            return ranges::begin(take.base_) +
-                   static_cast<range_difference_t<Rng>>(take.size());
-        }
-        static auto end_random_access_(detail::ignore_t, std::false_type)
-        {
-            return default_sentinel;
-        }
-        template<typename Take>
-        static auto end_sized_(Take & take, std::true_type, std::false_type) // sized
-        {
-            return end_random_access_(
-                take, meta::bool_<random_access_range<decltype((take.base_))>>{});
-        }
-        static auto end_sized_(detail::ignore_t, std::false_type,
-                               std::true_type) // infinite
-        {
-            return default_sentinel;
-        }
-        static auto end_sized_(take_view & take, std::false_type, std::false_type)
-        {
-            return sentinel<false>{ranges::end(take.base_)};
-        }
-        static auto end_sized_(take_view const & take, std::false_type, std::false_type)
-        {
-            return sentinel<true>{ranges::end(take.base_)};
-        }
-#endif
-    public:
-        take_view() = default;
-
-        constexpr take_view(Rng base, range_difference_t<Rng> cnt)
-          : base_(std::move(base))
-          , count_(cnt)
-        {}
-
-        constexpr Rng base() const
-        {
-            return base_;
-        }
-
-        CPP_member
-        constexpr auto CPP_fun(begin)()(
-            /// \pre
-            requires(!simple_view<Rng>()))
-        {
-#if RANGES_CXX_IF_CONSTEXPR >= RANGES_CXX_IF_CONSTEXPR_17
-            if constexpr(sized_range<Rng>)
-                if constexpr(random_access_range<Rng>)
-                    return ranges::begin(base_);
-                else
-                {
-                    // cannot always delegate to size() member on GCC with ConceptsTS
-#if defined(__cpp_concepts) && __cpp_concepts <= 201507
-                    auto s = ranges::min(
-                        static_cast<range_difference_t<Rng>>(count_),
-                        static_cast<range_difference_t<Rng>>(ranges::size(base_)));
-#else
-                    auto s = static_cast<range_difference_t<Rng>>(size());
-#endif
-                    return make_counted_iterator(ranges::begin(base_), s);
-                }
-            else
-                return make_counted_iterator(ranges::begin(base_), count_);
-#else
-            return begin_sized_(*this, meta::bool_<sized_range<Rng>>{});
-#endif
-        }
-
-        CPP_member
-        constexpr auto CPP_fun(begin)()(const //
-            requires range<Rng const>)
-        {
-#if RANGES_CXX_IF_CONSTEXPR >= RANGES_CXX_IF_CONSTEXPR_17
-            if constexpr(sized_range<Rng const>)
-                if constexpr(random_access_range<Rng const>)
-                    return ranges::begin(base_);
-                else
-                {
-                    auto s = static_cast<range_difference_t<Rng>>(size());
-                    return make_counted_iterator(ranges::begin(base_), s);
-                }
-            else
-                return make_counted_iterator(ranges::begin(base_), count_);
-#else
-            return begin_sized_(*this, meta::bool_<sized_range<Rng const>>{});
-#endif
-        }
-
-        CPP_member
-        constexpr auto CPP_fun(end)()(
-            /// \pre
-            requires(!simple_view<Rng>()))
-        {
-#if RANGES_CXX_IF_CONSTEXPR >= RANGES_CXX_IF_CONSTEXPR_17
-            if constexpr(sized_range<Rng>)
-                if constexpr(random_access_range<Rng>)
-                    return ranges::begin(base_) +
-                           static_cast<range_difference_t<Rng>>(size());
-                else
-                    return default_sentinel;
-            // Not to spec: Infinite ranges:
-            else if constexpr(is_infinite<Rng>::value)
-                return default_sentinel;
-            else
-                return sentinel<false>{ranges::end(base_)};
-#else
-            return end_sized_(*this, meta::bool_<sized_range<Rng>>{}, is_infinite<Rng>{});
-#endif
-        }
-
-        CPP_member
-        constexpr auto CPP_fun(end)()(const //
-            requires range<Rng const>)
-        {
-#if RANGES_CXX_IF_CONSTEXPR >= RANGES_CXX_IF_CONSTEXPR_17
-            if constexpr(sized_range<Rng const>)
-                if constexpr(random_access_range<Rng const>)
-                    return ranges::begin(base_) +
-                           static_cast<range_difference_t<Rng>>(size());
-                else
-                    return default_sentinel;
-            // Not to spec: Infinite ranges:
-            else if constexpr(is_infinite<Rng const>::value)
-                return default_sentinel;
-            else
-                return sentinel<true>{ranges::end(base_)};
-#else
-            return end_sized_(
-                *this, meta::bool_<sized_range<Rng const>>{}, is_infinite<Rng const>{});
-#endif
-        }
-
-        CPP_member
-        constexpr auto CPP_fun(size)()(
-            /// \pre
-            requires sized_range<Rng>)
-        {
-            auto n = ranges::size(base_);
-            return ranges::min(n, static_cast<decltype(n)>(count_));
-        }
-        CPP_member
-        constexpr auto CPP_fun(size)()(const //
-            requires sized_range<Rng const>)
-        {
-            auto n = ranges::size(base_);
-            return ranges::min(n, static_cast<decltype(n)>(count_));
-        }
-    };
-
-    template<typename Rng>
-    RANGES_INLINE_VAR constexpr bool enable_borrowed_range<take_view<Rng>> = //
-        enable_borrowed_range<Rng>;
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template<typename Rng>
-    take_view(Rng &&, range_difference_t<Rng>)
-        -> take_view<views::all_t<Rng>>;
-#endif
-
-    namespace views
-    {
-        struct take_base_fn
-        {
-            template(typename Rng)(
-                /// \pre
-                requires viewable_range<Rng>)
-            take_view<all_t<Rng>> operator()(Rng && rng, range_difference_t<Rng> n) const
-            {
-                return {all(static_cast<Rng &&>(rng)), n};
-            }
-        };
-
-        struct take_fn : take_base_fn
-        {
-            using take_base_fn::operator();
-
-            template(typename Int)(
-                /// \pre
-                requires detail::integer_like_<Int>)
-            constexpr auto operator()(Int n) const
-            {
-                return make_view_closure(bind_back(take_base_fn{}, n));
-            }
-        };
-
-        /// \relates take_fn
-        RANGES_INLINE_VARIABLE(take_fn, take)
-    } // namespace views
-
-    namespace cpp20
-    {
-        namespace views
-        {
-            using ranges::views::take;
-        }
-        template(typename Rng)(
-            /// \pre
-            requires view_<Rng>)
-        using take_view = ranges::take_view<Rng>;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::take_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/take_exactly.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/take_exactly.hpp
deleted file mode 100644
index c38e56c7..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/take_exactly.hpp
+++ /dev/null
@@ -1,207 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_TAKE_EXACTLY_HPP
-#define RANGES_V3_VIEW_TAKE_EXACTLY_HPP
-
-#include <type_traits>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/iterator/counted_iterator.hpp>
-#include <range/v3/iterator/default_sentinel.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/counted.hpp>
-#include <range/v3/view/interface.hpp>
-#include <range/v3/view/subrange.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        template<typename Rng>
-        struct is_random_access_common_
-          : meta::bool_<(bool)random_access_range<Rng> && (bool)common_range<Rng>>
-        {};
-
-        // BUGBUG Per the discussion in https://github.com/ericniebler/stl2/issues/63,
-        // it's unclear if we can infer anything from random_access_range<Rng> &&
-        // common_range<Rng>
-        template<typename Rng,
-                 bool IsRandomAccessCommon /*= is_random_access_common_<Rng>::value*/>
-        struct take_exactly_view_
-          : view_interface<take_exactly_view_<Rng, IsRandomAccessCommon>, finite>
-        {
-        private:
-            Rng rng_;
-            range_difference_t<Rng> n_;
-
-        public:
-            take_exactly_view_() = default;
-            take_exactly_view_(Rng rng, range_difference_t<Rng> n)
-              : rng_(std::move(rng))
-              , n_(n)
-            {
-                RANGES_EXPECT(n >= 0);
-            }
-            counted_iterator<iterator_t<Rng>> begin()
-            {
-                return {ranges::begin(rng_), n_};
-            }
-            template(typename BaseRng = Rng)(
-                /// \pre
-                requires range<BaseRng const>)
-            counted_iterator<iterator_t<BaseRng const>> begin() const
-            {
-                return {ranges::begin(rng_), n_};
-            }
-            default_sentinel_t end() const
-            {
-                return {};
-            }
-            auto size() const
-            {
-                return static_cast<detail::iter_size_t<iterator_t<Rng>>>(n_);
-            }
-            Rng base() const
-            {
-                return rng_;
-            }
-        };
-
-        template<typename Rng>
-        struct take_exactly_view_<Rng, true>
-          : view_interface<take_exactly_view_<Rng, true>, finite>
-        {
-        private:
-            Rng rng_;
-            range_difference_t<Rng> n_;
-
-        public:
-            take_exactly_view_() = default;
-            take_exactly_view_(Rng rng, range_difference_t<Rng> n)
-              : rng_(std::move(rng))
-              , n_(n)
-            {
-                RANGES_EXPECT(n >= 0);
-                RANGES_EXPECT(!(bool)sized_range<Rng> || n <= ranges::distance(rng_));
-            }
-            iterator_t<Rng> begin()
-            {
-                return ranges::begin(rng_);
-            }
-            iterator_t<Rng> end()
-            {
-                return ranges::begin(rng_) + n_;
-            }
-            CPP_member
-            auto CPP_fun(begin)()(const //
-                requires range<Rng const>)
-            {
-                return ranges::begin(rng_);
-            }
-            CPP_member
-            auto CPP_fun(end)()(const //
-                requires range<Rng const>)
-            {
-                return ranges::begin(rng_) + n_;
-            }
-            detail::iter_size_t<iterator_t<Rng>> size() const
-            {
-                return static_cast<detail::iter_size_t<iterator_t<Rng>>>(n_);
-            }
-            Rng base() const
-            {
-                return rng_;
-            }
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// \addtogroup group-views
-    /// @{
-    template<typename Rng>
-    using take_exactly_view = detail::take_exactly_view_<Rng>;
-
-    template<typename Rng, bool B>
-    RANGES_INLINE_VAR constexpr bool //
-        enable_borrowed_range<detail::take_exactly_view_<Rng, B>> = //
-            enable_borrowed_range<Rng>;
-
-    namespace views
-    {
-        struct take_exactly_base_fn
-        {
-        private:
-            template<typename Rng>
-            static constexpr take_exactly_view<all_t<Rng>> impl_(
-                Rng && rng, range_difference_t<Rng> n, input_range_tag)
-            {
-                return {all(static_cast<Rng &&>(rng)), n};
-            }
-            template(typename Rng)(
-                /// \pre
-                requires borrowed_range<Rng>)
-            static constexpr subrange<iterator_t<Rng>> impl_(Rng && rng,
-                                                             range_difference_t<Rng> n,
-                                                             random_access_range_tag)
-            {
-                return {begin(rng), next(begin(rng), n)};
-            }
-
-        public:
-            template(typename Rng)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng>)
-            constexpr auto operator()(Rng && rng, range_difference_t<Rng> n) const
-            {
-                return take_exactly_base_fn::impl_(
-                    static_cast<Rng &&>(rng), n, range_tag_of<Rng>{});
-            }
-        };
-
-        struct take_exactly_fn : take_exactly_base_fn
-        {
-            using take_exactly_base_fn::operator();
-
-            template(typename Int)(
-                /// \pre
-                requires detail::integer_like_<Int>)
-            constexpr auto operator()(Int n) const
-            {
-                return make_view_closure(bind_back(take_exactly_base_fn{}, n));
-            }
-        };
-
-        /// \relates take_exactly_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(take_exactly_fn, take_exactly)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::detail::take_exactly_view_)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/take_last.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/take_last.hpp
deleted file mode 100644
index f60722c8..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/take_last.hpp
+++ /dev/null
@@ -1,68 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Barry Revzin 2019-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_TAKE_LAST_HPP
-#define RANGES_V3_VIEW_TAKE_LAST_HPP
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/operations.hpp>
-#include <range/v3/view/drop_exactly.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-
-    namespace views
-    {
-        struct take_last_base_fn
-        {
-            template(typename Rng)(
-                /// \pre
-                requires viewable_range<Rng> AND sized_range<Rng>)
-            auto operator()(Rng && rng, range_difference_t<Rng> n) const
-            {
-                auto sz = ranges::distance(rng);
-                return drop_exactly(static_cast<Rng &&>(rng), sz > n ? sz - n : 0);
-            }
-        };
-
-        struct take_last_fn : take_last_base_fn
-        {
-            using take_last_base_fn::operator();
-
-            template(typename Int)(
-                /// \pre
-                requires detail::integer_like_<Int>)
-            constexpr auto operator()(Int n) const
-            {
-                return make_view_closure(bind_back(take_last_base_fn{}, n));
-            }
-        };
-
-        /// \relates take_last_fn
-        RANGES_INLINE_VARIABLE(take_last_fn, take_last)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/take_while.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/take_while.hpp
deleted file mode 100644
index e04eacdc..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/take_while.hpp
+++ /dev/null
@@ -1,218 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_TAKE_WHILE_HPP
-#define RANGES_V3_VIEW_TAKE_WHILE_HPP
-
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/functional/compose.hpp>
-#include <range/v3/functional/indirect.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/utility/semiregular_box.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/adaptor.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    template<typename Rng, typename Pred>
-    struct iter_take_while_view
-      : view_adaptor<iter_take_while_view<Rng, Pred>, Rng,
-                     is_finite<Rng>::value ? finite : unknown>
-    {
-    private:
-        friend range_access;
-        RANGES_NO_UNIQUE_ADDRESS semiregular_box_t<Pred> pred_;
-
-        template<bool IsConst>
-        struct sentinel_adaptor : adaptor_base
-        {
-        private:
-            friend struct sentinel_adaptor<!IsConst>;
-            using CRng = meta::const_if_c<IsConst, Rng>;
-            RANGES_NO_UNIQUE_ADDRESS semiregular_box_ref_or_val_t<Pred, IsConst> pred_;
-
-        public:
-            sentinel_adaptor() = default;
-            sentinel_adaptor(semiregular_box_ref_or_val_t<Pred, IsConst> pred)
-              : pred_(std::move(pred))
-            {}
-            template(bool Other)(
-                /// \pre
-                requires IsConst AND CPP_NOT(Other)) //
-                sentinel_adaptor(sentinel_adaptor<Other> that)
-              : pred_(std::move(that.pred_))
-            {}
-            bool empty(iterator_t<CRng> const & it, sentinel_t<CRng> const & last) const
-            {
-                return it == last || !invoke(pred_, it);
-            }
-        };
-        sentinel_adaptor<false> end_adaptor()
-        {
-            return {pred_};
-        }
-        template(bool Const = true)(
-            /// \pre
-            requires Const AND range<meta::const_if_c<Const, Rng>> AND
-                invocable<Pred const &, iterator_t<meta::const_if_c<Const, Rng>>>)
-        sentinel_adaptor<Const> end_adaptor() const
-        {
-            return {pred_};
-        }
-
-    public:
-        iter_take_while_view() = default;
-        constexpr iter_take_while_view(Rng rng, Pred pred)
-          : iter_take_while_view::view_adaptor{std::move(rng)}
-          , pred_(std::move(pred))
-        {}
-    };
-
-    template<typename Rng, typename Pred>
-    struct take_while_view : iter_take_while_view<Rng, indirected<Pred>>
-    {
-        take_while_view() = default;
-        constexpr take_while_view(Rng rng, Pred pred)
-          : iter_take_while_view<Rng, indirected<Pred>>{std::move(rng),
-                                                        indirect(std::move(pred))}
-        {}
-    };
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template(typename Rng, typename Fun)(
-        /// \pre
-        requires copy_constructible<Fun>)
-    take_while_view(Rng &&, Fun)
-        -> take_while_view<views::all_t<Rng>, Fun>;
-#endif
-
-    namespace views
-    {
-        struct iter_take_while_base_fn
-        {
-            template(typename Rng, typename Pred)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng> AND
-                    predicate<Pred &, iterator_t<Rng>> AND copy_constructible<Pred>)
-            constexpr iter_take_while_view<all_t<Rng>, Pred> //
-            operator()(Rng && rng, Pred pred) const
-            {
-                return {all(static_cast<Rng &&>(rng)), std::move(pred)};
-            }
-        };
-
-        struct iter_take_while_fn : iter_take_while_base_fn
-        {
-            using iter_take_while_base_fn::operator();
-
-            template<typename Pred>
-            constexpr auto operator()(Pred pred) const
-            {
-                return make_view_closure(
-                    bind_back(iter_take_while_base_fn{}, std::move(pred)));
-            }
-        };
-
-        struct take_while_base_fn
-        {
-            template(typename Rng, typename Pred)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng> AND
-                    indirect_unary_predicate<Pred &, iterator_t<Rng>>)
-            constexpr take_while_view<all_t<Rng>, Pred> //
-            operator()(Rng && rng, Pred pred) const
-            {
-                return {all(static_cast<Rng &&>(rng)), std::move(pred)};
-            }
-            template(typename Rng, typename Pred, typename Proj)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng> AND
-                    indirect_unary_predicate<composed<Pred, Proj> &, iterator_t<Rng>>)
-            constexpr take_while_view<all_t<Rng>, composed<Pred, Proj>> //
-            operator()(Rng && rng, Pred pred, Proj proj) const
-            {
-                return {all(static_cast<Rng &&>(rng)),
-                        compose(std::move(pred), std::move(proj))};
-            }
-        };
-
-        struct take_while_bind_fn
-        {
-            template<typename Pred>
-            constexpr auto operator()(Pred pred) const // TODO: underconstrained
-            {
-                return make_view_closure(
-                    bind_back(take_while_base_fn{}, std::move(pred)));
-            }
-            template(typename Pred, typename Proj)(
-                /// \pre
-                requires (!range<Pred>)) // TODO: underconstrained
-            constexpr auto operator()(Pred && pred, Proj proj) const
-                                                          
-            {
-                return make_view_closure(bind_back(
-                    take_while_base_fn{}, static_cast<Pred &&>(pred), std::move(proj)));
-            }
-        };
-
-        struct RANGES_EMPTY_BASES take_while_fn
-          : take_while_base_fn, take_while_bind_fn
-        {
-            using take_while_base_fn::operator();
-            using take_while_bind_fn::operator();
-        };
-
-        /// \relates iter_take_while_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(iter_take_while_fn, iter_take_while)
-
-        /// \relates take_while_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(take_while_fn, take_while)
-    } // namespace views
-
-    namespace cpp20
-    {
-        namespace views
-        {
-            using ranges::views::take_while;
-        }
-        template(typename Rng, typename Pred)(
-            /// \pre
-            requires viewable_range<Rng> AND input_range<Rng> AND
-                predicate<Pred &, iterator_t<Rng>> AND copy_constructible<Pred>)
-            using take_while_view = ranges::take_while_view<Rng, Pred>;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::iter_take_while_view)
-RANGES_SATISFY_BOOST_RANGE(::ranges::take_while_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/tokenize.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/tokenize.hpp
deleted file mode 100644
index a264bccb..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/tokenize.hpp
+++ /dev/null
@@ -1,213 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_TOKENIZE_HPP
-#define RANGES_V3_VIEW_TOKENIZE_HPP
-
-#include <initializer_list>
-#include <regex>
-#include <type_traits>
-#include <utility>
-#include <vector>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/interface.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    template<typename Rng, typename Regex, typename SubMatchRange>
-    struct tokenize_view
-      : view_interface<tokenize_view<Rng, Regex, SubMatchRange>,
-                       is_finite<Rng>::value ? finite : range_cardinality<Rng>::value>
-    {
-    private:
-        CPP_assert(bidirectional_range<Rng> && view_<Rng> && common_range<Rng>);
-        CPP_assert(semiregular<Regex>);
-        CPP_assert(semiregular<SubMatchRange>);
-
-        Rng rng_;
-        Regex rex_;
-        SubMatchRange subs_;
-        std::regex_constants::match_flag_type flags_;
-        template<bool Const>
-        using iterator_t =
-            std::regex_token_iterator<iterator_t<meta::const_if_c<Const, Rng>>>;
-
-    public:
-        tokenize_view() = default;
-        tokenize_view(Rng rng, Regex rex, SubMatchRange subs,
-                      std::regex_constants::match_flag_type flags)
-          : rng_(std::move(rng))
-          , rex_(std::move(rex))
-          , subs_(std::move(subs))
-          , flags_(flags)
-        {}
-        iterator_t<simple_view<Rng>()> begin()
-        {
-            meta::const_if_c<simple_view<Rng>(), Rng> & rng = rng_;
-            return {ranges::begin(rng), ranges::end(rng), rex_, subs_, flags_};
-        }
-        template(bool Const = true)(
-            /// \pre
-            requires range<Rng const>)
-        iterator_t<Const> begin() const
-        {
-            return {ranges::begin(rng_), ranges::end(rng_), rex_, subs_, flags_};
-        }
-        iterator_t<simple_view<Rng>()> end()
-        {
-            return {};
-        }
-        template(bool Const = true)(
-            /// \pre
-            requires range<Rng const>)
-        iterator_t<Const> end() const
-        {
-            return {};
-        }
-        Rng base() const
-        {
-            return rng_;
-        }
-    };
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template(typename Rng, typename Regex, typename SubMatchRange)(
-        /// \pre
-        requires copy_constructible<Regex> AND copy_constructible<SubMatchRange>)
-        tokenize_view(Rng &&, Regex, SubMatchRange)
-            ->tokenize_view<views::all_t<Rng>, Regex, SubMatchRange>;
-#endif
-
-    namespace views
-    {
-        struct tokenize_base_fn
-        {
-            template(typename Rng, typename Regex)(
-                /// \pre
-                requires bidirectional_range<Rng> AND common_range<Rng> AND
-                    same_as< //
-                        range_value_t<Rng>, //
-                        typename detail::decay_t<Regex>::value_type>)
-            tokenize_view<all_t<Rng>, detail::decay_t<Regex>, int> //
-            operator()(Rng && rng,
-                       Regex && rex,
-                       int sub = 0,
-                       std::regex_constants::match_flag_type flags =
-                            std::regex_constants::match_default) const //
-            {
-                return {all(static_cast<Rng &&>(rng)),
-                        static_cast<Regex &&>(rex),
-                        sub,
-                        flags};
-            }
-
-            template(typename Rng, typename Regex)(
-                /// \pre
-                requires bidirectional_range<Rng> AND common_range<Rng> AND
-                    same_as<range_value_t<Rng>,
-                            typename detail::decay_t<Regex>::value_type>)
-            tokenize_view<all_t<Rng>, detail::decay_t<Regex>, std::vector<int>> //
-            operator()(Rng && rng,
-                       Regex && rex,
-                       std::vector<int> subs,
-                       std::regex_constants::match_flag_type flags =
-                           std::regex_constants::match_default) const //
-            {
-                return {all(static_cast<Rng &&>(rng)),
-                        static_cast<Regex &&>(rex),
-                        std::move(subs),
-                        flags};
-            }
-
-            template(typename Rng, typename Regex)(
-                /// \pre
-                requires bidirectional_range<Rng> AND common_range<Rng> AND
-                    same_as<range_value_t<Rng>,
-                            typename detail::decay_t<Regex>::value_type>)
-            tokenize_view<all_t<Rng>,
-                          detail::decay_t<Regex>,
-                          std::initializer_list<int>> //
-            operator()(Rng && rng,
-                       Regex && rex,
-                       std::initializer_list<int> subs,
-                       std::regex_constants::match_flag_type flags =
-                           std::regex_constants::match_default) const //
-            {
-                return {all(static_cast<Rng &&>(rng)),
-                        static_cast<Regex &&>(rex),
-                        std::move(subs),
-                        flags};
-            }
-        };
-
-        struct tokenize_fn : tokenize_base_fn
-        {
-            using tokenize_base_fn::operator();
-
-            template<typename Regex>
-            constexpr auto operator()(Regex && rex,
-                                      int sub = 0,
-                                      std::regex_constants::match_flag_type flags =
-                                          std::regex_constants::match_default) const
-            {
-                return make_view_closure(bind_back(
-                    tokenize_base_fn{}, static_cast<Regex &&>(rex), sub, flags));
-            }
-
-            template<typename Regex>
-            auto operator()(Regex && rex,
-                            std::vector<int> subs,
-                            std::regex_constants::match_flag_type flags =
-                                std::regex_constants::match_default) const
-            {
-                return bind_back(tokenize_base_fn{},
-                                 static_cast<Regex &&>(rex),
-                                 std::move(subs),
-                                 flags);
-            }
-
-            template<typename Regex>
-            constexpr auto operator()(Regex && rex,
-                                      std::initializer_list<int> subs,
-                                      std::regex_constants::match_flag_type flags =
-                                          std::regex_constants::match_default) const
-            {
-                return make_view_closure(bind_back(
-                    tokenize_base_fn{}, static_cast<Regex &&>(rex), subs, flags));
-            }
-        };
-
-        /// \relates tokenize_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(tokenize_fn, tokenize)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::tokenize_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/transform.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/transform.hpp
deleted file mode 100644
index e5f40f65..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/transform.hpp
+++ /dev/null
@@ -1,592 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_TRANSFORM_HPP
-#define RANGES_V3_VIEW_TRANSFORM_HPP
-
-#include <iterator>
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/algorithm/max.hpp>
-#include <range/v3/algorithm/min.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/functional/indirect.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/move.hpp>
-#include <range/v3/utility/semiregular_box.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/adaptor.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        constexpr cardinality transform2_cardinality(cardinality c1, cardinality c2)
-        {
-            return c1 >= 0 || c2 >= 0
-                       ? (c1 >= 0 && c2 >= 0 ? (c1 < c2 ? c1 : c2) : finite)
-                       : c1 == finite || c2 == finite
-                             ? finite
-                             : c1 == unknown || c2 == unknown ? unknown : infinite;
-        }
-
-        // clang-format off
-        template(typename Fun, typename Rng)(
-        concept (iter_transform_1_readable_)(Fun, Rng),
-            regular_invocable<Fun &, iterator_t<Rng>> AND
-            regular_invocable<Fun &, copy_tag, iterator_t<Rng>> AND
-            regular_invocable<Fun &, move_tag, iterator_t<Rng>> AND
-            common_reference_with<
-                invoke_result_t<Fun &, iterator_t<Rng>> &&,
-                invoke_result_t<Fun &, copy_tag, iterator_t<Rng>> &> AND
-            common_reference_with<
-                invoke_result_t<Fun &, iterator_t<Rng>> &&,
-                invoke_result_t<Fun &, move_tag, iterator_t<Rng>> &&> AND
-            common_reference_with<
-                invoke_result_t<Fun &, move_tag, iterator_t<Rng>> &&,
-                invoke_result_t<Fun &, copy_tag, iterator_t<Rng>> const &>
-        );
-        template<typename Fun, typename Rng>
-        CPP_concept iter_transform_1_readable =
-            CPP_concept_ref(detail::iter_transform_1_readable_, Fun, Rng);
-
-        template(typename Fun, typename Rng1, typename Rng2)(
-        concept (iter_transform_2_readable_)(Fun, Rng1, Rng2),
-            regular_invocable<Fun &, iterator_t<Rng1>, iterator_t<Rng2>> AND
-            regular_invocable<Fun &, copy_tag, iterator_t<Rng1>, iterator_t<Rng2>> AND
-            regular_invocable<Fun &, move_tag, iterator_t<Rng1>, iterator_t<Rng2>> AND
-            common_reference_with<
-                invoke_result_t<Fun &, iterator_t<Rng1>, iterator_t<Rng2>> &&,
-                invoke_result_t<Fun &, copy_tag, iterator_t<Rng1>, iterator_t<Rng2>> &> AND
-            common_reference_with<
-                invoke_result_t<Fun &, iterator_t<Rng1>, iterator_t<Rng2>> &&,
-                invoke_result_t<Fun &, move_tag, iterator_t<Rng1>, iterator_t<Rng2>> &&> AND
-            common_reference_with<
-                invoke_result_t<Fun &, move_tag, iterator_t<Rng1>, iterator_t<Rng2>> &&,
-                invoke_result_t<Fun &, copy_tag, iterator_t<Rng1>, iterator_t<Rng2>> const &>
-        );
-        template<typename Fun, typename Rng1, typename Rng2>
-        CPP_concept iter_transform_2_readable =
-            CPP_concept_ref(detail::iter_transform_2_readable_, Fun, Rng1, Rng2);
-        // clang-format on
-    } // namespace detail
-    /// \endcond
-
-    /// \addtogroup group-views
-    /// @{
-    template<typename Rng, typename Fun>
-    struct iter_transform_view : view_adaptor<iter_transform_view<Rng, Fun>, Rng>
-    {
-    private:
-        friend range_access;
-        RANGES_NO_UNIQUE_ADDRESS semiregular_box_t<Fun> fun_;
-        template<bool Const>
-        using use_sentinel_t =
-            meta::bool_<!common_range<meta::const_if_c<Const, Rng>> ||
-                        single_pass_iterator_<iterator_t<meta::const_if_c<Const, Rng>>>>;
-
-        template<bool IsConst>
-        struct adaptor : adaptor_base
-        {
-        private:
-            friend struct adaptor<!IsConst>;
-            using CRng = meta::const_if_c<IsConst, Rng>;
-            using fun_ref_ = semiregular_box_ref_or_val_t<Fun, IsConst>;
-            RANGES_NO_UNIQUE_ADDRESS fun_ref_ fun_;
-
-        public:
-            using value_type =
-                detail::decay_t<invoke_result_t<Fun &, copy_tag, iterator_t<CRng>>>;
-            adaptor() = default;
-            adaptor(fun_ref_ fun)
-              : fun_(std::move(fun))
-            {}
-            template(bool Other)(
-                /// \pre
-                requires IsConst AND CPP_NOT(Other)) //
-            adaptor(adaptor<Other> that)
-              : fun_(std::move(that.fun_))
-            {}
-
-            // clang-format off
-            auto CPP_auto_fun(read)(iterator_t<CRng> it)(const)
-            (
-                return invoke(fun_, it)
-            )
-            auto CPP_auto_fun(iter_move)(iterator_t<CRng> it)(const)
-            (
-                return invoke(fun_, move_tag{}, it)
-            )
-            // clang-format on
-        };
-
-        adaptor<false> begin_adaptor()
-        {
-            return {fun_};
-        }
-        template(bool Const = true)(
-            /// \pre
-            requires Const AND range<meta::const_if_c<Const, Rng>> AND
-                detail::iter_transform_1_readable<Fun const,
-                                                  meta::const_if_c<Const, Rng>>)
-        adaptor<Const> begin_adaptor() const
-        {
-            return {fun_};
-        }
-        meta::if_<use_sentinel_t<false>, adaptor_base, adaptor<false>> end_adaptor()
-        {
-            return {fun_};
-        }
-        template(bool Const = true)(
-            /// \pre
-            requires Const AND range<meta::const_if_c<Const, Rng>> AND
-                    detail::iter_transform_1_readable<Fun const,
-                                                      meta::const_if_c<Const, Rng>>)
-        meta::if_<use_sentinel_t<Const>, adaptor_base, adaptor<Const>> end_adaptor() const
-        {
-            return {fun_};
-        }
-
-    public:
-        iter_transform_view() = default;
-        iter_transform_view(Rng rng, Fun fun)
-          : iter_transform_view::view_adaptor{std::move(rng)}
-          , fun_(std::move(fun))
-        {}
-        CPP_member
-        constexpr auto CPP_fun(size)()(
-            /// \pre
-            requires sized_range<Rng>)
-        {
-            return ranges::size(this->base());
-        }
-        CPP_member
-        constexpr auto CPP_fun(size)()(const //
-            requires sized_range<Rng const>)
-        {
-            return ranges::size(this->base());
-        }
-    };
-
-    template<typename Rng, typename Fun>
-    struct transform_view : iter_transform_view<Rng, indirected<Fun>>
-    {
-        transform_view() = default;
-        transform_view(Rng rng, Fun fun)
-          : iter_transform_view<Rng, indirected<Fun>>{std::move(rng),
-                                                      indirect(std::move(fun))}
-        {}
-    };
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template(typename Rng, typename Fun)(
-        /// \pre
-        requires copy_constructible<Fun>)
-    transform_view(Rng &&, Fun)
-        -> transform_view<views::all_t<Rng>, Fun>;
-#endif
-
-    template<typename Rng1, typename Rng2, typename Fun>
-    struct iter_transform2_view
-      : view_facade<iter_transform2_view<Rng1, Rng2, Fun>,
-                    detail::transform2_cardinality(range_cardinality<Rng1>::value,
-                                                   range_cardinality<Rng2>::value)>
-    {
-    private:
-        friend range_access;
-        RANGES_NO_UNIQUE_ADDRESS semiregular_box_t<Fun> fun_;
-        Rng1 rng1_;
-        Rng2 rng2_;
-        using difference_type_ =
-            common_type_t<range_difference_t<Rng1>, range_difference_t<Rng2>>;
-
-        static constexpr cardinality my_cardinality = detail::transform2_cardinality(
-            range_cardinality<Rng1>::value, range_cardinality<Rng2>::value);
-
-        template<bool>
-        struct cursor;
-
-        template<bool Const>
-        struct sentinel
-        {
-        private:
-            friend struct cursor<Const>;
-            sentinel_t<meta::const_if_c<Const, Rng1>> end1_;
-            sentinel_t<meta::const_if_c<Const, Rng2>> end2_;
-
-        public:
-            sentinel() = default;
-            sentinel(meta::const_if_c<Const, iter_transform2_view> * parent,
-                     decltype(ranges::end))
-              : end1_(end(parent->rng1_))
-              , end2_(end(parent->rng2_))
-            {}
-            template(bool Other)(
-                /// \pre
-                requires Const AND CPP_NOT(Other)) //
-            sentinel(sentinel<Other> that)
-              : end1_(std::move(that.end1_))
-              , end2_(std::move(that.end2_))
-            {}
-        };
-
-        template<bool Const>
-        struct cursor
-        {
-        private:
-            using fun_ref_ = semiregular_box_ref_or_val_t<Fun, Const>;
-            using R1 = meta::const_if_c<Const, Rng1>;
-            using R2 = meta::const_if_c<Const, Rng2>;
-            fun_ref_ fun_;
-            iterator_t<R1> it1_;
-            iterator_t<R2> it2_;
-
-        public:
-            using difference_type = difference_type_;
-            using single_pass = meta::or_c<(bool)single_pass_iterator_<iterator_t<R1>>,
-                                           (bool)single_pass_iterator_<iterator_t<R2>>>;
-            using value_type =
-                detail::decay_t<invoke_result_t<meta::const_if_c<Const, Fun> &, copy_tag,
-                                                iterator_t<R1>, iterator_t<R2>>>;
-
-            cursor() = default;
-            template<typename BeginEndFn>
-            cursor(meta::const_if_c<Const, iter_transform2_view> * parent,
-                   BeginEndFn begin_end)
-              : fun_(parent->fun_)
-              , it1_(begin_end(parent->rng1_))
-              , it2_(begin_end(parent->rng2_))
-            {}
-            template(bool Other)(
-                /// \pre
-                requires Const AND CPP_NOT(Other)) //
-            cursor(cursor<Other> that)
-              : fun_(std::move(that.fun_))
-              , it1_(std::move(that.end1_))
-              , it2_(std::move(that.end2_))
-            {}
-            // clang-format off
-            auto CPP_auto_fun(read)()(const)
-            (
-                return invoke(fun_, it1_, it2_)
-            )
-                // clang-format on
-                void next()
-            {
-                ++it1_;
-                ++it2_;
-            }
-            CPP_member
-            auto equal(cursor const & that) const //
-                -> CPP_ret(bool)(
-                    /// \pre
-                    requires forward_range<Rng1> && forward_range<Rng2>)
-            {
-                // By returning true if *any* of the iterators are equal, we allow
-                // transformed ranges to be of different lengths, stopping when the first
-                // one reaches the last.
-                return it1_ == that.it1_ || it2_ == that.it2_;
-            }
-            bool equal(sentinel<Const> const & s) const
-            {
-                // By returning true if *any* of the iterators are equal, we allow
-                // transformed ranges to be of different lengths, stopping when the first
-                // one reaches the last.
-                return it1_ == s.end1_ || it2_ == s.end2_;
-            }
-            CPP_member
-            auto prev() //
-                -> CPP_ret(void)(
-                    /// \pre
-                    requires bidirectional_range<R1> && bidirectional_range<R2>)
-            {
-                --it1_;
-                --it2_;
-            }
-            CPP_member
-            auto advance(difference_type n) -> CPP_ret(void)(
-                /// \pre
-                requires random_access_range<R1> && random_access_range<R2>)
-            {
-                ranges::advance(it1_, n);
-                ranges::advance(it2_, n);
-            }
-            CPP_member
-            auto distance_to(cursor const & that) const //
-                -> CPP_ret(difference_type)(
-                    /// \pre
-                    requires sized_sentinel_for<iterator_t<R1>, iterator_t<R1>> &&
-                        sized_sentinel_for<iterator_t<R2>, iterator_t<R2>>)
-            {
-                // Return the smallest distance (in magnitude) of any of the iterator
-                // pairs. This is to accommodate zippers of sequences of different length.
-                difference_type d1 = that.it1_ - it1_, d2 = that.it2_ - it2_;
-                return 0 < d1 ? ranges::min(d1, d2) : ranges::max(d1, d2);
-            }
-            // clang-format off
-            auto CPP_auto_fun(move)()(const)
-            (
-                return invoke(fun_, move_tag{}, it1_, it2_)
-            )
-            // clang-format on
-        };
-
-        template<bool Const>
-        using end_cursor_t = meta::if_c<
-            common_range<meta::const_if_c<Const, Rng1>> &&
-                common_range<meta::const_if_c<Const, Rng2>> &&
-                !single_pass_iterator_<iterator_t<meta::const_if_c<Const, Rng1>>> &&
-                !single_pass_iterator_<iterator_t<meta::const_if_c<Const, Rng2>>>,
-            cursor<Const>, sentinel<Const>>;
-
-        cursor<simple_view<Rng1>() && simple_view<Rng2>()> begin_cursor()
-        {
-            return {this, ranges::begin};
-        }
-        end_cursor_t<simple_view<Rng1>() && simple_view<Rng2>()> end_cursor()
-        {
-            return {this, ranges::end};
-        }
-        template(bool Const = true)(
-            /// \pre
-            requires Const AND range<meta::const_if_c<Const, Rng1>> AND
-                range<meta::const_if_c<Const, Rng2>> AND
-                detail::iter_transform_2_readable< //
-                    Fun const, //
-                    meta::const_if_c<Const, Rng1>, //
-                    meta::const_if_c<Const, Rng2>>)
-        cursor<true> begin_cursor() const
-        {
-            return {this, ranges::begin};
-        }
-        template(bool Const = true)(
-            /// \pre
-            requires Const AND range<meta::const_if_c<Const, Rng1>> AND
-                range<meta::const_if_c<Const, Rng2>> AND
-                detail::iter_transform_2_readable< //
-                    Fun const, //
-                    meta::const_if_c<Const, Rng1>, //
-                    meta::const_if_c<Const, Rng2>>)
-        end_cursor_t<Const> end_cursor() const
-        {
-            return {this, ranges::end};
-        }
-        template<typename Self>
-        static constexpr auto size_(Self & self)
-        {
-            using size_type = common_type_t<range_size_t<Rng1>, range_size_t<Rng2>>;
-            return ranges::min(static_cast<size_type>(ranges::size(self.rng1_)),
-                               static_cast<size_type>(ranges::size(self.rng2_)));
-        }
-
-        template<bool B>
-        using R1 = meta::invoke<detail::dependent_<B>, Rng1>;
-        template<bool B>
-        using R2 = meta::invoke<detail::dependent_<B>, Rng2>;
-
-    public:
-        iter_transform2_view() = default;
-        constexpr iter_transform2_view(Rng1 rng1, Rng2 rng2, Fun fun)
-          : fun_(std::move(fun))
-          , rng1_(std::move(rng1))
-          , rng2_(std::move(rng2))
-        {}
-        CPP_member
-        static constexpr auto size() //
-            -> CPP_ret(std::size_t)(
-                /// \pre
-                requires (my_cardinality >= 0))
-        {
-            return static_cast<std::size_t>(my_cardinality);
-        }
-        template(bool True = true)(
-            /// \pre
-            requires (my_cardinality < 0) AND sized_range<Rng1 const> AND
-            sized_range<Rng2 const> AND
-            common_with<range_size_t<R1<True>>, range_size_t<R2<True>>>)
-            constexpr auto size() const
-        {
-            return size_(*this);
-        }
-        template(bool True = true)(
-            /// \pre
-            requires (my_cardinality < 0) AND sized_range<Rng1> AND sized_range<Rng2> AND
-            common_with<range_size_t<R1<True>>, range_size_t<R2<True>>>)
-            constexpr auto size()
-        {
-            return size_(*this);
-        }
-    };
-
-    template<typename Rng1, typename Rng2, typename Fun>
-    struct transform2_view : iter_transform2_view<Rng1, Rng2, indirected<Fun>>
-    {
-        transform2_view() = default;
-        constexpr transform2_view(Rng1 rng1, Rng2 rng2, Fun fun)
-          : iter_transform2_view<Rng1, Rng2, indirected<Fun>>{std::move(rng1),
-                                                              std::move(rng2),
-                                                              indirect(std::move(fun))}
-        {}
-    };
-
-    namespace views
-    {
-        struct iter_transform_base_fn
-        {
-            template(typename Rng, typename Fun)(
-                /// \pre
-                requires viewable_range<Rng> AND input_range<Rng> AND
-                    copy_constructible<Fun> AND
-                    detail::iter_transform_1_readable<Fun, Rng>)
-            constexpr iter_transform_view<all_t<Rng>, Fun> //
-            operator()(Rng && rng, Fun fun) const
-            {
-                return {all(static_cast<Rng &&>(rng)), std::move(fun)};
-            }
-
-            template(typename Rng1, typename Rng2, typename Fun)(
-                /// \pre
-                requires viewable_range<Rng1> AND input_range<Rng1> AND
-                    viewable_range<Rng2> AND input_range<Rng2> AND
-                    copy_constructible<Fun> AND
-                    common_with<range_difference_t<Rng1>, range_difference_t<Rng1>> AND
-                    detail::iter_transform_2_readable<Fun, Rng1, Rng2>)
-            constexpr iter_transform2_view<all_t<Rng1>, all_t<Rng2>, Fun> //
-            operator()(Rng1 && rng1, Rng2 && rng2, Fun fun) const
-            {
-                return {all(static_cast<Rng1 &&>(rng1)),
-                        all(static_cast<Rng2 &&>(rng2)),
-                        std::move(fun)};
-            }
-        };
-
-        struct iter_transform_fn : iter_transform_base_fn
-        {
-            using iter_transform_base_fn::operator();
-
-            template<typename Fun>
-            constexpr auto operator()(Fun fun) const
-            {
-                return make_view_closure(
-                    bind_back(iter_transform_base_fn{}, std::move(fun)));
-            }
-        };
-
-        /// \relates iter_transform_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(iter_transform_fn, iter_transform)
-
-        // Don't forget to update views::for_each whenever this set
-        // of concepts changes
-        // clang-format off
-        template(typename Rng, typename Fun)(
-        concept (transformable_range_)(Rng, Fun),
-            regular_invocable<Fun &, range_reference_t<Rng>> AND
-            (!std::is_void<indirect_result_t<Fun &, iterator_t<Rng>>>::value)
-        );
-        template<typename Rng, typename Fun>
-        CPP_concept transformable_range =
-            viewable_range<Rng> && input_range<Rng> &&
-            copy_constructible<Fun> &&
-            CPP_concept_ref(views::transformable_range_, Rng, Fun);
-
-        template(typename Rng1, typename Rng2, typename Fun)(
-        concept (transformable_ranges_)(Rng1, Rng2, Fun),
-            regular_invocable<Fun &, range_reference_t<Rng1>, range_reference_t<Rng2>> AND
-            (!std::is_void<
-                indirect_result_t<Fun &, iterator_t<Rng1>, iterator_t<Rng2>>>::value)
-        );
-        template<typename Rng1, typename Rng2, typename Fun>
-        CPP_concept transformable_ranges =
-            viewable_range<Rng1> && input_range<Rng1> &&
-            viewable_range<Rng2> && input_range<Rng2> &&
-            copy_constructible<Fun> &&
-            CPP_concept_ref(views::transformable_ranges_, Rng1, Rng2, Fun);
-        // clang-format on
-
-        struct transform_base_fn
-        {
-            template(typename Rng, typename Fun)(
-                /// \pre
-                requires transformable_range<Rng, Fun>)
-            constexpr transform_view<all_t<Rng>, Fun> operator()(Rng && rng, Fun fun)
-                const
-            {
-                return {all(static_cast<Rng &&>(rng)), std::move(fun)};
-            }
-
-            template(typename Rng1, typename Rng2, typename Fun)(
-                /// \pre
-                requires transformable_ranges<Rng1, Rng2, Fun>)
-            constexpr transform2_view<all_t<Rng1>, all_t<Rng2>, Fun> //
-            operator()(Rng1 && rng1, Rng2 && rng2, Fun fun) const
-            {
-                return {all(static_cast<Rng1 &&>(rng1)),
-                        all(static_cast<Rng2 &&>(rng2)),
-                        std::move(fun)};
-            }
-        };
-
-        struct transform_fn : transform_base_fn
-        {
-            using transform_base_fn::operator();
-
-            template<typename Fun>
-            constexpr auto operator()(Fun fun) const
-            {
-                return make_view_closure(bind_back(transform_base_fn{}, std::move(fun)));
-            }
-        };
-
-        /// \relates transform_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(transform_fn, transform)
-    } // namespace views
-
-    namespace cpp20
-    {
-        namespace views
-        {
-            using ranges::views::transform;
-        }
-        template(typename Rng, typename F)(
-            /// \pre
-            requires input_range<Rng> AND copy_constructible<F> AND view_<Rng> AND
-                std::is_object<F>::value AND
-                    regular_invocable<F &, iter_reference_t<iterator_t<Rng>>>)
-            using transform_view = ranges::transform_view<Rng, F>;
-    } // namespace cpp20
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::iter_transform_view)
-RANGES_SATISFY_BOOST_RANGE(::ranges::transform_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/trim.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/trim.hpp
deleted file mode 100644
index e63f2148..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/trim.hpp
+++ /dev/null
@@ -1,165 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Johel Guerrero 2019
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_TRIM_HPP
-#define RANGES_V3_VIEW_TRIM_HPP
-
-#include <utility>
-
-#include <concepts/concepts.hpp>
-
-#include <range/v3/algorithm/find_if_not.hpp>
-#include <range/v3/detail/config.hpp>
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/functional/compose.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/utility/optional.hpp>
-#include <range/v3/utility/semiregular_box.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/interface.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    template<typename Rng, typename Pred>
-    struct trim_view : view_interface<trim_view<Rng, Pred>>
-    {
-    private:
-        Rng rng_;
-        semiregular_box_t<Pred> pred_;
-        detail::non_propagating_cache<iterator_t<Rng>> begin_;
-        detail::non_propagating_cache<iterator_t<Rng>> end_;
-
-    public:
-        CPP_assert(bidirectional_range<Rng> && view_<Rng> && indirect_unary_predicate<
-                   Pred, iterator_t<Rng>> && common_range<Rng>);
-
-        trim_view() = default;
-        constexpr trim_view(Rng rng, Pred pred)
-          : rng_(std::move(rng))
-          , pred_(std::move(pred))
-        {}
-
-        iterator_t<Rng> begin()
-        {
-            if(!begin_)
-                begin_ = find_if_not(rng_, std::ref(pred_));
-            return *begin_;
-        }
-        iterator_t<Rng> end()
-        {
-            if(!end_)
-            {
-                const auto first = begin();
-                auto last = ranges::end(rng_);
-                while(last != first)
-                    if(!invoke(pred_, *--last))
-                    {
-                        ++last;
-                        break;
-                    }
-                end_ = std::move(last);
-            }
-            return *end_;
-        }
-
-        Rng base() const
-        {
-            return rng_;
-        }
-    };
-
-    template<typename Rng, typename Pred>
-    RANGES_INLINE_VAR constexpr bool enable_borrowed_range<trim_view<Rng, Pred>> = //
-        enable_borrowed_range<Rng>;
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template<typename Rng, typename Pred>
-    trim_view(Rng &&, Pred) //
-        -> trim_view<views::all_t<Rng>, Pred>;
-#endif
-
-    template<typename Rng, typename Pred>
-    RANGES_INLINE_VAR constexpr bool disable_sized_range<trim_view<Rng, Pred>> = true;
-
-    namespace views
-    {
-        struct trim_base_fn
-        {
-            template(typename Rng, typename Pred)(
-                /// \pre
-                requires viewable_range<Rng> AND bidirectional_range<Rng> AND
-                    indirect_unary_predicate<Pred, iterator_t<Rng>> AND
-                        common_range<Rng>)
-            constexpr trim_view<all_t<Rng>, Pred> //
-            operator()(Rng && rng, Pred pred) const //
-            {
-                return {all(static_cast<Rng &&>(rng)), std::move(pred)};
-            }
-            template(typename Rng, typename Pred, typename Proj)(
-                /// \pre
-                requires viewable_range<Rng> AND bidirectional_range<Rng> AND
-                    indirect_unary_predicate<composed<Pred, Proj>, iterator_t<Rng>> AND
-                    common_range<Rng>)
-            constexpr trim_view<all_t<Rng>, composed<Pred, Proj>> //
-            operator()(Rng && rng, Pred pred, Proj proj) const
-            {
-                return {all(static_cast<Rng &&>(rng)),
-                        compose(std::move(pred), std::move(proj))};
-            }
-        };
-
-        struct trim_bind_fn
-        {
-            template<typename Pred>
-            constexpr auto operator()(Pred pred) const // TODO: underconstrained
-            {
-                return make_view_closure(bind_back(trim_base_fn{}, std::move(pred)));
-            }
-            template(typename Pred, typename Proj)(
-                /// \pre
-                requires (!range<Pred>)) // TODO: underconstrained
-            constexpr auto operator()(Pred && pred, Proj proj) const
-            {
-                return make_view_closure(bind_back(
-                    trim_base_fn{}, static_cast<Pred &&>(pred), std::move(proj)));
-            }
-        };
-
-        struct RANGES_EMPTY_BASES trim_fn
-          : trim_base_fn, trim_bind_fn
-        {
-            using trim_base_fn::operator();
-            using trim_bind_fn::operator();
-        };
-
-        /// \relates trim_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(trim_fn, trim)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::trim_view)
-
-#endif // RANGES_V3_VIEW_TRIM_HPP
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/unbounded.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/unbounded.hpp
deleted file mode 100644
index 92f9c998..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/unbounded.hpp
+++ /dev/null
@@ -1,75 +0,0 @@
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_UNBOUNDED_HPP
-#define RANGES_V3_VIEW_UNBOUNDED_HPP
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/unreachable_sentinel.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/interface.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    template<typename I>
-    struct unbounded_view : view_interface<unbounded_view<I>, infinite>
-    {
-    private:
-        I it_;
-
-    public:
-        unbounded_view() = default;
-        constexpr explicit unbounded_view(I it)
-          : it_(detail::move(it))
-        {}
-        constexpr I begin() const
-        {
-            return it_;
-        }
-        constexpr unreachable_sentinel_t end() const
-        {
-            return {};
-        }
-    };
-
-    template<typename I>
-    RANGES_INLINE_VAR constexpr bool enable_borrowed_range<unbounded_view<I>> = true;
-
-    namespace views
-    {
-        struct unbounded_fn
-        {
-            template(typename I)(
-                /// \pre
-                requires input_iterator<I>)
-            constexpr unbounded_view<I> operator()(I it) const
-            {
-                return unbounded_view<I>{detail::move(it)};
-            }
-        };
-
-        /// \relates unbounded_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(unbounded_fn, unbounded)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::unbounded_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/unique.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/unique.hpp
deleted file mode 100644
index e24b398e..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/unique.hpp
+++ /dev/null
@@ -1,74 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_UNIQUE_HPP
-#define RANGES_V3_VIEW_UNIQUE_HPP
-
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/functional/not_fn.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/view/adjacent_filter.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/view.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-    namespace views
-    {
-        struct unique_base_fn
-        {
-            template(typename Rng, typename C = equal_to)(
-                /// \pre
-                requires viewable_range<Rng> AND forward_range<Rng> AND
-                    indirect_relation<C, iterator_t<Rng>>)
-            constexpr adjacent_filter_view<all_t<Rng>, logical_negate<C>> //
-            operator()(Rng && rng, C pred = {}) const
-            {
-                return {all(static_cast<Rng &&>(rng)), not_fn(pred)};
-            }
-        };
-
-        struct unique_fn : unique_base_fn
-        {
-            using unique_base_fn::operator();
-
-            template(typename C)(
-                /// \pre
-                requires (!range<C>))
-            constexpr auto operator()(C && pred) const
-            {
-                return make_view_closure(
-                    bind_back(unique_base_fn{}, static_cast<C &&>(pred)));
-            }
-        };
-
-        /// \relates unique_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(view_closure<unique_fn>, unique)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/view.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/view.hpp
deleted file mode 100644
index b24cf0bc..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/view.hpp
+++ /dev/null
@@ -1,285 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_VIEW_HPP
-#define RANGES_V3_VIEW_VIEW_HPP
-
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/compose.hpp>
-#include <range/v3/functional/concepts.hpp>
-#include <range/v3/functional/pipeable.hpp>
-#include <range/v3/functional/reference_wrapper.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/static_const.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-views
-    /// @{
-
-    /// \cond
-    namespace detail
-    {
-        struct dereference_fn
-        {
-            // clang-format off
-            template<typename I>
-            constexpr auto CPP_auto_fun(operator())(I &&i) (const)
-            (
-                return *(I &&) i
-            )
-            // clang-format on
-        };
-
-        struct view_closure_base_
-        {};
-    } // namespace detail
-      /// \endcond
-
-    // clang-format off
-    template(typename Rng)(
-    concept (simple_view_impl_)(Rng),
-        same_as<iterator_t<Rng>, iterator_t<Rng const>> AND
-        same_as<sentinel_t<Rng>, sentinel_t<Rng const>>);
-
-    template<typename Rng>
-    CPP_concept simple_view_ =
-        view_<Rng> &&
-        range<Rng const> &&
-        CPP_concept_ref(ranges::simple_view_impl_, Rng);
-
-    template(typename ViewFn, typename Rng)(
-    concept (invocable_view_closure_)(ViewFn, Rng),
-        !derived_from<invoke_result_t<ViewFn, Rng>, detail::view_closure_base_>);
-
-    template<typename ViewFn, typename Rng>
-    CPP_concept invocable_view_closure =
-        invocable<ViewFn, Rng> &&
-        CPP_concept_ref(ranges::invocable_view_closure_, ViewFn, Rng);
-    // clang-format on
-
-    template<typename Rng>
-    constexpr bool simple_view() noexcept
-    {
-        return (bool)simple_view_<Rng>;
-    }
-
-    struct make_view_closure_fn
-    {
-        template<typename Fun>
-        constexpr views::view_closure<Fun> operator()(Fun fun) const
-        {
-            return views::view_closure<Fun>{static_cast<Fun &&>(fun)};
-        }
-    };
-
-    /// \ingroup group-views
-    /// \sa make_view_closure_fn
-    RANGES_INLINE_VARIABLE(make_view_closure_fn, make_view_closure)
-
-    namespace views
-    {
-        struct RANGES_STRUCT_WITH_ADL_BARRIER(view_closure_base)
-          : detail::view_closure_base_
-        {
-            // Piping requires viewable_ranges. Pipeing a value into a closure
-            // should not yield another closure.
-            template(typename Rng, typename ViewFn)(
-                /// \pre
-                requires viewable_range<Rng> AND
-                    invocable_view_closure<ViewFn, Rng>)
-            friend constexpr auto operator|(Rng && rng, view_closure<ViewFn> vw)
-            {
-                return static_cast<ViewFn &&>(vw)(static_cast<Rng &&>(rng));
-            }
-
-#ifndef RANGES_WORKAROUND_CLANG_43400
-            // This overload is deleted because when piping a range into an
-            // view, it must be moved in.
-            template<typename Rng, typename ViewFn>         // **************************
-            friend constexpr auto                           // **************************
-            operator|(Rng &&, view_closure<ViewFn> const &) // ******* READ THIS ********
-                                                            // **** IF YOUR COMPILE *****
-                -> CPP_broken_friend_ret(Rng)(              // ****** BREAKS HERE *******
-                    requires range<Rng> &&                  // **************************
-                    (!viewable_range<Rng>)) = delete;       // **************************
-            // **************************************************************************
-            // *    When piping a range into an adaptor, the range must satisfy the     *
-            // *    "viewable_range" concept. A range is viewable when either or both   *
-            // *    of these things are true:                                           *
-            // *      - The range is an lvalue (not a temporary object), OR             *
-            // *      - The range is a view (not a container).                          *
-            // **************************************************************************
-#endif
-
-            template<typename ViewFn, typename Pipeable>
-            friend constexpr auto operator|(view_closure<ViewFn> vw, Pipeable pipe)
-                -> CPP_broken_friend_ret(view_closure<composed<Pipeable, ViewFn>>)(
-                    /// \pre
-                    requires (is_pipeable_v<Pipeable>))
-            {
-                return make_view_closure(
-                    compose(static_cast<Pipeable &&>(pipe), static_cast<ViewFn &&>(vw)));
-            }
-        };
-
-#ifdef RANGES_WORKAROUND_CLANG_43400
-        namespace RANGES_ADL_BARRIER_FOR(view_closure_base)
-        {
-            // This overload is deleted because when piping a range into an
-            // view, it must be moved in.
-            template(typename Rng, typename ViewFn)(           // ************************
-                requires range<Rng> AND (!viewable_range<Rng>))// ************************
-            constexpr Rng                                      // ************************
-            operator|(Rng &&, view_closure<ViewFn> const &)    // ****** READ THIS *******
-                = delete;                                      // *** IF YOUR COMPILE ****
-                                                               // ***** BREAKS HERE ******
-                                                               // ************************
-                                                               // ************************
-            // ***************************************************************************
-            // *    When piping a range into an adaptor, the range must satisfy the      *
-            // *    "viewable_range" concept. A range is viewable when either or both    *
-            // *    of these things are true:                                            *
-            // *      - The range is an lvalue (not a temporary object), OR              *
-            // *      - The range is a view (not a container).                           *
-            // ***************************************************************************
-        } // namespace )
-#endif    // RANGES_WORKAROUND_CLANG_43400
-
-        template<typename ViewFn>
-        struct RANGES_EMPTY_BASES view_closure
-          : view_closure_base
-          , ViewFn
-        {
-            view_closure() = default;
-
-            constexpr explicit view_closure(ViewFn fn)
-              : ViewFn(static_cast<ViewFn &&>(fn))
-            {}
-        };
-
-        /// \cond
-        /// DEPRECATED STUFF
-        struct view_access_
-        {
-            template<typename ViewFn>
-            struct impl
-            {
-                // clang-format off
-                template<typename... Ts, typename V = ViewFn>
-                static constexpr auto CPP_auto_fun(bind)(Ts &&... ts)
-                (
-                    return V::bind(static_cast<Ts &&>(ts)...)
-                )
-                // clang-format on
-            };
-        };
-
-        using view_access RANGES_DEPRECATED(
-            "view_access and views::view<> are deprecated. Please "
-            "replace view<> with view_closure<> and discontinue use of view_access.") =
-            view_access_;
-
-        template<typename>
-        struct old_view_;
-
-        struct make_view_fn_
-        {
-            template<typename Fun>
-            constexpr old_view_<Fun> operator()(Fun fun) const
-            {
-                return old_view_<Fun>{static_cast<Fun &&>(fun)};
-            }
-        };
-        using make_view_fn RANGES_DEPRECATED(
-            "make_view_fn is deprecated. Please use "
-            "make_view_closure instead.") = make_view_fn_;
-
-        namespace
-        {
-            RANGES_DEPRECATED(
-                "make_view and views::view<> has been deprecated. Please switch to "
-                "make_view_closure and views::view_closure.")
-            RANGES_INLINE_VAR constexpr auto & make_view =
-                static_const<make_view_fn_>::value;
-        } // namespace
-
-        template<typename ViewFn>
-        struct old_view_ : pipeable_base
-        {
-        private:
-            ViewFn vw_;
-            friend pipeable_access;
-
-            // Piping requires range arguments or lvalue containers.
-            template(typename Rng, typename Vw)(
-                /// \pre
-                requires viewable_range<Rng> AND invocable<ViewFn &, Rng>)
-            static constexpr auto pipe(Rng && rng, Vw && v)
-            {
-                return v.vw_(static_cast<Rng &&>(rng));
-            }
-
-        public:
-            old_view_() = default;
-
-            constexpr explicit old_view_(ViewFn a) noexcept(
-                std::is_nothrow_move_constructible<ViewFn>::value)
-              : vw_(std::move(a))
-            {}
-
-            // Calling directly requires a viewable_range.
-            template(typename Rng, typename... Rest)(
-                /// \pre
-                requires viewable_range<Rng> AND invocable<ViewFn const &, Rng, Rest...>)
-            constexpr invoke_result_t<ViewFn const &, Rng, Rest...> //
-            operator()(Rng && rng, Rest &&... rest) const
-            {
-                return vw_(static_cast<Rng &&>(rng), static_cast<Rest &&>(rest)...);
-            }
-
-            // Currying overload.
-            // clang-format off
-            template<typename... Ts, typename V = ViewFn>
-            constexpr auto CPP_auto_fun(operator())(Ts &&... ts)(const)
-            (
-                return make_view_fn_{}(
-                    view_access_::impl<V>::bind(vw_, static_cast<Ts &&>(ts)...))
-            )
-            // clang-format on
-        };
-
-        template<typename ViewFn>
-        using view RANGES_DEPRECATED(
-            "The views::view<> template is deprecated. Please switch to view_closure") =
-            old_view_<ViewFn>;
-        /// \endcond
-    } // namespace views
-
-    template<typename ViewFn>
-    RANGES_INLINE_VAR constexpr bool is_pipeable_v<views::view_closure<ViewFn>> = true;
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/zip.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/zip.hpp
deleted file mode 100644
index c8364583..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/zip.hpp
+++ /dev/null
@@ -1,199 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_ZIP_HPP
-#define RANGES_V3_VIEW_ZIP_HPP
-
-#include <tuple>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/utility/common_tuple.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/empty.hpp>
-#include <range/v3/view/zip_with.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        struct indirect_zip_fn_
-        {
-            // tuple value
-            template(typename... Its)(
-                /// \pre
-                requires (sizeof...(Its) != 2) AND and_v<indirectly_readable<Its>...>)
-            std::tuple<iter_value_t<Its>...> operator()(copy_tag, Its...) const
-            {
-                RANGES_EXPECT(false);
-            }
-
-            // tuple reference
-            template(typename... Its)(
-                /// \pre
-                requires (sizeof...(Its) != 2) AND and_v<indirectly_readable<Its>...>)
-            common_tuple<iter_reference_t<Its>...>
-            operator()(Its const &... its) const //
-                noexcept(meta::and_c<noexcept(iter_reference_t<Its>(*its))...>::value)
-            {
-                return common_tuple<iter_reference_t<Its>...>{*its...};
-            }
-
-            // tuple rvalue reference
-            template(typename... Its)(
-                /// \pre
-                requires (sizeof...(Its) != 2) AND and_v<indirectly_readable<Its>...>)
-            common_tuple<iter_rvalue_reference_t<Its>...> //
-            operator()(move_tag, Its const &... its) const //
-                noexcept(meta::and_c<noexcept(
-                             iter_rvalue_reference_t<Its>(iter_move(its)))...>::value)
-            {
-                return common_tuple<iter_rvalue_reference_t<Its>...>{iter_move(its)...};
-            }
-
-            // pair value
-            template(typename It1, typename It2)(
-                /// \pre
-                requires indirectly_readable<It1> AND indirectly_readable<It2>)
-            std::pair<iter_value_t<It1>, iter_value_t<It2>> //
-            operator()(copy_tag, It1, It2) const
-            {
-                RANGES_EXPECT(false);
-            }
-
-            // pair reference
-            template(typename It1, typename It2)(
-                /// \pre
-                requires indirectly_readable<It1> AND indirectly_readable<It2>)
-            common_pair<iter_reference_t<It1>, iter_reference_t<It2>>
-            operator()(It1 const & it1, It2 const & it2) const //
-                noexcept( //
-                    noexcept(iter_reference_t<It1>(*it1)) && //
-                    noexcept(iter_reference_t<It2>(*it2)))
-            {
-                return {*it1, *it2};
-            }
-
-            // pair rvalue reference
-            template(typename It1, typename It2)(
-                /// \pre
-                requires indirectly_readable<It1> AND indirectly_readable<It2>)
-            common_pair<iter_rvalue_reference_t<It1>, iter_rvalue_reference_t<It2>>
-            operator()(move_tag, It1 const & it1, It2 const & it2) const
-                noexcept(noexcept(iter_rvalue_reference_t<It1>(iter_move(it1))) &&
-                         noexcept(iter_rvalue_reference_t<It2>(iter_move(it2))))
-            {
-                return {iter_move(it1), iter_move(it2)};
-            }
-        };
-    } // namespace detail
-    /// \endcond
-
-    /// \addtogroup group-views
-    /// @{
-    template<typename... Rngs>
-    struct zip_view : iter_zip_with_view<detail::indirect_zip_fn_, Rngs...>
-    {
-        CPP_assert(sizeof...(Rngs) != 0);
-
-        zip_view() = default;
-        explicit zip_view(Rngs... rngs)
-          : iter_zip_with_view<detail::indirect_zip_fn_, Rngs...>{
-                detail::indirect_zip_fn_{},
-                std::move(rngs)...}
-        {}
-    };
-
-    template<typename... Rng>
-    RANGES_INLINE_VAR constexpr bool enable_borrowed_range<zip_view<Rng...>> =
-        and_v<enable_borrowed_range<Rng>...>;
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template<typename... Rng>
-    zip_view(Rng &&...) //
-        -> zip_view<views::all_t<Rng>...>;
-#endif
-
-    namespace views
-    {
-        struct zip_fn
-        {
-            constexpr empty_view<std::tuple<>> operator()() const noexcept
-            {
-                return {};
-            }
-            template(typename... Rngs)(
-                /// \pre
-                requires and_v<viewable_range<Rngs>...> AND
-                and_v<input_range<Rngs>...> AND
-                (sizeof...(Rngs) != 0)) //
-            zip_view<all_t<Rngs>...> operator()(Rngs &&... rngs) const
-            {
-                return zip_view<all_t<Rngs>...>{all(static_cast<Rngs &&>(rngs))...};
-            }
-#if defined(_MSC_VER)
-            template(typename Rng0)(
-                /// \pre
-                requires input_range<Rng0> AND viewable_range<Rng0>)
-            constexpr zip_view<all_t<Rng0>> operator()(Rng0 && rng0) const
-            {
-                return zip_view<all_t<Rng0>>{all(static_cast<Rng0 &&>(rng0))};
-            }
-            template(typename Rng0, typename Rng1)(
-                /// \pre
-                requires input_range<Rng0> AND viewable_range<Rng0> AND
-                    input_range<Rng1> AND viewable_range<Rng1>)
-            constexpr zip_view<all_t<Rng0>, all_t<Rng1>> //
-            operator()(Rng0 && rng0, Rng1 && rng1) const
-            {
-                return zip_view<all_t<Rng0>, all_t<Rng1>>{ //
-                    all(static_cast<Rng0 &&>(rng0)),       //
-                    all(static_cast<Rng1 &&>(rng1))};
-            }
-            template(typename Rng0, typename Rng1, typename Rng2)(
-                /// \pre
-                requires input_range<Rng0> AND viewable_range<Rng0> AND
-                    input_range<Rng1> AND viewable_range<Rng1> AND
-                    input_range<Rng2> AND viewable_range<Rng2>)
-            constexpr zip_view<all_t<Rng0>, all_t<Rng1>, all_t<Rng2>> //
-            operator()(Rng0 && rng0, Rng1 && rng1, Rng2 && rng2) const
-            {
-                return zip_view<all_t<Rng0>, all_t<Rng1>, all_t<Rng2>>{ //
-                    all(static_cast<Rng0 &&>(rng0)),                    //
-                    all(static_cast<Rng1 &&>(rng1)),                    //
-                    all(static_cast<Rng2 &&>(rng2))};
-            }
-#endif
-        };
-
-        /// \relates zip_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(zip_fn, zip)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::zip_view)
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view/zip_with.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view/zip_with.hpp
deleted file mode 100644
index f93b9dfa..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view/zip_with.hpp
+++ /dev/null
@@ -1,460 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VIEW_ZIP_WITH_HPP
-#define RANGES_V3_VIEW_ZIP_WITH_HPP
-
-#include <limits>
-#include <tuple>
-#include <type_traits>
-#include <utility>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/range_fwd.hpp>
-
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/functional/indirect.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/utility/common_type.hpp>
-#include <range/v3/utility/semiregular_box.hpp>
-#include <range/v3/utility/static_const.hpp>
-#include <range/v3/utility/tuple_algorithm.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/empty.hpp>
-#include <range/v3/view/facade.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \cond
-    namespace detail
-    {
-        struct equal_to_
-        {
-            template<typename T, typename U>
-            bool operator()(T const & t, U const & u) const
-            {
-                return static_cast<bool>(t == u);
-            }
-        };
-        RANGES_INLINE_VARIABLE(equal_to_, equal_to)
-
-        struct dec_
-        {
-            template<typename T>
-            void operator()(T & t) const
-            {
-                --t;
-            }
-        };
-        RANGES_INLINE_VARIABLE(dec_, dec)
-
-        struct inc_
-        {
-            template<typename T>
-            void operator()(T & t) const
-            {
-                ++t;
-            }
-        };
-        RANGES_INLINE_VARIABLE(inc_, inc)
-
-        struct _advance_
-        {
-            template(typename I, typename Diff)(
-                /// \pre
-                requires input_or_output_iterator<I> AND integer_like_<Diff>)
-            void operator()(I & i, Diff n) const
-            {
-                advance(i, static_cast<iter_difference_t<I>>(n));
-            }
-        };
-        RANGES_INLINE_VARIABLE(_advance_, advance_)
-
-        struct distance_to_
-        {
-            template<typename T>
-            constexpr auto operator()(T const & t, T const & u) const -> decltype(u - t)
-            {
-                return u - t;
-            }
-        };
-        RANGES_INLINE_VARIABLE(distance_to_, distance_to)
-
-        struct _min_
-        {
-            template<typename T, typename U>
-            constexpr auto operator()(T const & t, U const & u) const
-                -> decltype(true ? t : u)
-            {
-                return u < t ? u : t;
-            }
-        };
-        RANGES_INLINE_VARIABLE(_min_, min_)
-
-        struct _max_
-        {
-            template<typename T, typename U>
-            constexpr auto operator()(T const & t, U const & u) const
-                -> decltype(true ? u : t)
-            {
-                return u < t ? t : u;
-            }
-        };
-        RANGES_INLINE_VARIABLE(_max_, max_)
-
-        template<typename State, typename Value>
-        using zip_cardinality = std::integral_constant<
-            cardinality,
-            State::value >= 0 && Value::value >= 0
-                ? min_(State::value, Value::value)
-                : State::value >=0 && Value::value == infinite
-                    ? State::value
-                    : State::value == infinite && Value::value >= 0
-                        ? Value::value
-                        : State::value == finite || Value::value == finite
-                            ? finite
-                            : State::value == unknown || Value::value == unknown
-                                    ? unknown
-                                    : infinite>;
-    } // namespace detail
-    /// \endcond
-
-    namespace views
-    {
-        // clang-format off
-        template(typename Fun, typename... Rngs)(
-        concept (zippable_with_)(Fun, Rngs...),
-            invocable<Fun&, iterator_t<Rngs>...> AND
-            invocable<Fun&, copy_tag, iterator_t<Rngs>...> AND
-            invocable<Fun&, move_tag, iterator_t<Rngs>...>
-        );
-        template<typename Fun, typename ...Rngs>
-        CPP_concept zippable_with =
-            and_v<input_range<Rngs>...> &&
-            copy_constructible<Fun> &&
-            CPP_concept_ref(views::zippable_with_, Fun, Rngs...);
-        // clang-format on
-    } // namespace views
-
-    /// \addtogroup group-views
-    /// @{
-    template<typename Fun, typename... Rngs>
-    struct iter_zip_with_view
-      : view_facade<iter_zip_with_view<Fun, Rngs...>,
-                    meta::fold<meta::list<range_cardinality<Rngs>...>,
-                               std::integral_constant<cardinality, cardinality::infinite>,
-                               meta::quote<detail::zip_cardinality>>::value>
-    {
-    private:
-        CPP_assert(sizeof...(Rngs) != 0);
-        friend range_access;
-
-        semiregular_box_t<Fun> fun_;
-        std::tuple<Rngs...> rngs_;
-        using difference_type_ = common_type_t<range_difference_t<Rngs>...>;
-
-        template<bool Const>
-        struct cursor;
-
-        template<bool Const>
-        struct sentinel
-        {
-        private:
-            friend struct cursor<Const>;
-            friend struct sentinel<!Const>;
-            std::tuple<sentinel_t<meta::const_if_c<Const, Rngs>>...> ends_;
-
-        public:
-            sentinel() = default;
-            sentinel(detail::ignore_t,
-                     std::tuple<sentinel_t<meta::const_if_c<Const, Rngs>>...> ends)
-              : ends_(std::move(ends))
-            {}
-            template(bool Other)(
-                /// \pre
-                requires Const AND CPP_NOT(Other)) //
-            sentinel(sentinel<Other> that)
-              : ends_(std::move(that.ends_))
-            {}
-        };
-
-        template<bool Const>
-        struct cursor
-        {
-        private:
-            friend struct cursor<!Const>;
-            using fun_ref_ = semiregular_box_ref_or_val_t<Fun, Const>;
-            fun_ref_ fun_;
-            std::tuple<iterator_t<meta::const_if_c<Const, Rngs>>...> its_;
-
-        public:
-            using difference_type =
-                common_type_t<range_difference_t<meta::const_if_c<Const, Rngs>>...>;
-            using single_pass = meta::or_c<(
-                bool)single_pass_iterator_<iterator_t<meta::const_if_c<Const, Rngs>>>...>;
-            using value_type = detail::decay_t<invoke_result_t<
-                fun_ref_ &, copy_tag, iterator_t<meta::const_if_c<Const, Rngs>>...>>;
-
-            cursor() = default;
-            cursor(fun_ref_ fun,
-                   std::tuple<iterator_t<meta::const_if_c<Const, Rngs>>...> its)
-              : fun_(std::move(fun))
-              , its_(std::move(its))
-            {}
-            template(bool Other)(
-                /// \pre
-                requires Const AND CPP_NOT(Other)) //
-            cursor(cursor<Other> that)
-              : fun_(std::move(that.fun_))
-              , its_(std::move(that.its_))
-            {}
-            // clang-format off
-            auto CPP_auto_fun(read)()(const)
-            (
-                return tuple_apply(fun_, its_)
-            )
-            // clang-format on
-            void next()
-            {
-                tuple_for_each(its_, detail::inc);
-            }
-            CPP_member
-            auto equal(cursor const & that) const //
-                -> CPP_ret(bool)(
-                    /// \pre
-                    requires and_v<
-                        sentinel_for<iterator_t<meta::const_if_c<Const, Rngs>>,
-                                    iterator_t<meta::const_if_c<Const, Rngs>>>...>)
-            {
-                // By returning true if *any* of the iterators are equal, we allow
-                // zipped ranges to be of different lengths, stopping when the first
-                // one reaches the last.
-                return tuple_foldl(tuple_transform(its_, that.its_, detail::equal_to),
-                                   false,
-                                   [](bool a, bool b) { return a || b; });
-            }
-            bool equal(sentinel<Const> const & s) const
-            {
-                // By returning true if *any* of the iterators are equal, we allow
-                // zipped ranges to be of different lengths, stopping when the first
-                // one reaches the last.
-                return tuple_foldl(tuple_transform(its_, s.ends_, detail::equal_to),
-                                   false,
-                                   [](bool a, bool b) { return a || b; });
-            }
-            CPP_member
-            auto prev() //
-                -> CPP_ret(void)(
-                    /// \pre
-                    requires and_v<bidirectional_range<meta::const_if_c<Const, Rngs>>...>)
-            {
-                tuple_for_each(its_, detail::dec);
-            }
-            CPP_member
-            auto advance(difference_type n) //
-                -> CPP_ret(void)(
-                    /// \pre
-                    requires and_v<random_access_range<meta::const_if_c<Const, Rngs>>...>)
-            {
-                tuple_for_each(its_, bind_back(detail::advance_, n));
-            }
-            CPP_member
-            auto distance_to(cursor const & that) const //
-                -> CPP_ret(difference_type)(
-                    /// \pre
-                    requires and_v<
-                        sized_sentinel_for<iterator_t<meta::const_if_c<Const, Rngs>>,
-                                           iterator_t<meta::const_if_c<Const, Rngs>>>...>)
-            {
-                // Return the smallest distance (in magnitude) of any of the iterator
-                // pairs. This is to accommodate zippers of sequences of different length.
-                if(0 < std::get<0>(that.its_) - std::get<0>(its_))
-                    return tuple_foldl(
-                        tuple_transform(its_, that.its_, detail::distance_to),
-                        (std::numeric_limits<difference_type>::max)(),
-                        detail::min_);
-                else
-                    return tuple_foldl(
-                        tuple_transform(its_, that.its_, detail::distance_to),
-                        (std::numeric_limits<difference_type>::min)(),
-                        detail::max_);
-            }
-            // clang-format off
-            template<std::size_t... Is>
-            auto CPP_auto_fun(move_)(meta::index_sequence<Is...>)(const)
-            (
-                return invoke(fun_, move_tag{}, std::get<Is>(its_)...)
-            )
-                // clang-format on
-                auto move() const noexcept(noexcept(std::declval<cursor const &>().move_(
-                    meta::make_index_sequence<sizeof...(Rngs)>{})))
-                    -> decltype(std::declval<cursor const &>().move_(
-                        meta::make_index_sequence<sizeof...(Rngs)>{}))
-            {
-                return move_(meta::make_index_sequence<sizeof...(Rngs)>{});
-            }
-        };
-
-        template<bool Const>
-        using end_cursor_t =
-            meta::if_c<concepts::and_v<(bool)common_range<Rngs>...,
-                                       !(bool)single_pass_iterator_<iterator_t<Rngs>>...>,
-                       cursor<Const>, sentinel<Const>>;
-
-        cursor<false> begin_cursor()
-        {
-            return {fun_, tuple_transform(rngs_, ranges::begin)};
-        }
-        end_cursor_t<false> end_cursor()
-        {
-            return {fun_, tuple_transform(rngs_, ranges::end)};
-        }
-        template(bool Const = true)(
-            /// \pre
-            requires Const AND and_v<range<Rngs const>...> AND
-                views::zippable_with<Fun, meta::if_c<Const, Rngs const>...>)
-        cursor<Const> begin_cursor() const
-        {
-            return {fun_, tuple_transform(rngs_, ranges::begin)};
-        }
-        template(bool Const = true)(
-            /// \pre
-            requires Const AND and_v<range<Rngs const>...> AND
-                views::zippable_with<Fun, meta::if_c<Const, Rngs const>...>)
-        end_cursor_t<Const> end_cursor() const
-        {
-            return {fun_, tuple_transform(rngs_, ranges::end)};
-        }
-
-    public:
-        iter_zip_with_view() = default;
-        explicit iter_zip_with_view(Rngs... rngs)
-          : fun_(Fun{})
-          , rngs_{std::move(rngs)...}
-        {}
-        explicit iter_zip_with_view(Fun fun, Rngs... rngs)
-          : fun_(std::move(fun))
-          , rngs_{std::move(rngs)...}
-        {}
-        CPP_member
-        constexpr auto CPP_fun(size)()(const //
-            requires and_v<sized_range<Rngs const>...>)
-        {
-            using size_type = common_type_t<range_size_t<Rngs const>...>;
-            return range_cardinality<iter_zip_with_view>::value >= 0
-                       ? size_type{(
-                             std::size_t)range_cardinality<iter_zip_with_view>::value}
-                       : tuple_foldl(tuple_transform(rngs_,
-                                                     [](auto && r) -> size_type {
-                                                         return ranges::size(r);
-                                                     }),
-                                     (std::numeric_limits<size_type>::max)(),
-                                     detail::min_);
-        }
-    };
-
-    template<typename Fun, typename... Rngs>
-    struct zip_with_view : iter_zip_with_view<indirected<Fun>, Rngs...>
-    {
-        CPP_assert(sizeof...(Rngs) != 0);
-
-        zip_with_view() = default;
-        explicit zip_with_view(Rngs... rngs)
-          : iter_zip_with_view<indirected<Fun>, Rngs...>{{Fun{}}, std::move(rngs)...}
-        {}
-        explicit zip_with_view(Fun fun, Rngs... rngs)
-          : iter_zip_with_view<indirected<Fun>, Rngs...>{{std::move(fun)},
-                                                         std::move(rngs)...}
-        {}
-    };
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-    template(typename Fun, typename... Rng)(
-        /// \pre
-        requires copy_constructible<Fun>)
-    zip_with_view(Fun, Rng &&...)
-        -> zip_with_view<Fun, views::all_t<Rng>...>;
-#endif
-
-    namespace views
-    {
-        struct iter_zip_with_fn
-        {
-            template(typename... Rngs, typename Fun)(
-                /// \pre
-                requires and_v<viewable_range<Rngs>...> AND
-                    zippable_with<Fun, Rngs...> AND (sizeof...(Rngs) != 0)) //
-            iter_zip_with_view<Fun, all_t<Rngs>...> //
-            operator()(Fun fun, Rngs &&... rngs) const
-            {
-                return iter_zip_with_view<Fun, all_t<Rngs>...>{
-                    std::move(fun), all(static_cast<Rngs &&>(rngs))...};
-            }
-
-            template(typename Fun)(
-                /// \pre
-                requires zippable_with<Fun>)
-            constexpr empty_view<std::tuple<>> operator()(Fun) const noexcept
-            {
-                return {};
-            }
-        };
-
-        /// \relates iter_zip_with_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(iter_zip_with_fn, iter_zip_with)
-
-        struct zip_with_fn
-        {
-            template(typename... Rngs, typename Fun)(
-                /// \pre
-                requires and_v<viewable_range<Rngs>...> AND
-                    and_v<input_range<Rngs>...> AND copy_constructible<Fun> AND
-                    invocable<Fun &, range_reference_t<Rngs>...> AND
-                    (sizeof...(Rngs) != 0)) //
-            zip_with_view<Fun, all_t<Rngs>...> operator()(Fun fun, Rngs &&... rngs) const
-            {
-                return zip_with_view<Fun, all_t<Rngs>...>{
-                    std::move(fun), all(static_cast<Rngs &&>(rngs))...};
-            }
-
-            template(typename Fun)(
-                /// \pre
-                requires copy_constructible<Fun> AND invocable<Fun &>)
-            constexpr empty_view<std::tuple<>> operator()(Fun) const noexcept
-            {
-                return {};
-            }
-        };
-
-        /// \relates zip_with_fn
-        /// \ingroup group-views
-        RANGES_INLINE_VARIABLE(zip_with_fn, zip_with)
-    } // namespace views
-    /// @}
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#include <range/v3/detail/satisfy_boost_range.hpp>
-RANGES_SATISFY_BOOST_RANGE(::ranges::iter_zip_with_view)
-RANGES_SATISFY_BOOST_RANGE(::ranges::zip_with_view)
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view_adaptor.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view_adaptor.hpp
deleted file mode 100644
index 6f30c95f..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view_adaptor.hpp
+++ /dev/null
@@ -1,21 +0,0 @@
-// Range v3 library
-//
-// Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_OLD_VIEW_ADAPTOR_HPP
-#define RANGES_V3_OLD_VIEW_ADAPTOR_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated. Please #include <range/v3/view/adaptor.hpp> instead.")
-
-#include <range/v3/view/adaptor.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view_facade.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view_facade.hpp
deleted file mode 100644
index ddfaa065..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view_facade.hpp
+++ /dev/null
@@ -1,21 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_OLD_VIEW_FACADE_HPP
-#define RANGES_V3_OLD_VIEW_FACADE_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated. Please #include <range/v3/view/facade.hpp> instead.")
-
-#include <range/v3/view/facade.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/range/v3/view_interface.hpp b/src/contrib/range-v3-0.11.0/include/range/v3/view_interface.hpp
deleted file mode 100644
index cd6e52da..00000000
--- a/src/contrib/range-v3-0.11.0/include/range/v3/view_interface.hpp
+++ /dev/null
@@ -1,21 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_V3_OLD_VIEW_INTERFACE_HPP
-#define RANGES_V3_OLD_VIEW_INTERFACE_HPP
-
-#include <range/v3/detail/config.hpp>
-RANGES_DEPRECATED_HEADER(
-    "This header is deprecated. Please #include <range/v3/view/interface.hpp> instead.")
-
-#include <range/v3/view/interface.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/std/detail/associated_types.hpp b/src/contrib/range-v3-0.11.0/include/std/detail/associated_types.hpp
deleted file mode 100644
index b642166d..00000000
--- a/src/contrib/range-v3-0.11.0/include/std/detail/associated_types.hpp
+++ /dev/null
@@ -1,304 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-2014, 2016-present
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_STD_DETAIL_ASSOCIATED_TYPES_HPP
-#define RANGES_V3_STD_DETAIL_ASSOCIATED_TYPES_HPP
-
-#include <climits>
-#include <cstdint>
-
-#include <range/v3/detail/config.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    /// \addtogroup group-iterator
-    /// @{
-
-    ////////////////////////////////////////////////////////////////////////////////////////
-    /// \cond
-    namespace detail
-    {
-        struct nil_
-        {};
-
-        template<typename T, typename...>
-        using always_ = T;
-
-#if defined(_MSC_VER) && !defined(__clang__) && !defined(__EDG__)
-        // MSVC laughs at your silly micro-optimizations and implements
-        // conditional_t, enable_if_t, is_object_v, and is_integral_v in the
-        // compiler.
-        using std::conditional_t;
-        using std::enable_if;
-        using std::enable_if_t;
-#else  // ^^^ MSVC / not MSVC vvv
-        template<bool>
-        struct _cond
-        {
-            template<typename, typename U>
-            using invoke = U;
-        };
-        template<>
-        struct _cond<true>
-        {
-            template<typename T, typename>
-            using invoke = T;
-        };
-        template<bool B, typename T, typename U>
-        using conditional_t = typename _cond<B>::template invoke<T, U>;
-
-        template<bool>
-        struct enable_if
-        {};
-        template<>
-        struct enable_if<true>
-        {
-            template<typename T>
-            using invoke = T;
-        };
-        template<bool B, typename T = void>
-        using enable_if_t = typename enable_if<B>::template invoke<T>;
-
-#ifndef __clang__
-        // NB: insufficient for MSVC, which (non-conformingly) allows function
-        // pointers to implicitly convert to void*.
-        void is_objptr_(void const volatile *);
-
-        // std::is_object, optimized for compile time.
-        template<typename T>
-        constexpr bool is_object_(long)
-        {
-            return false;
-        }
-        template<typename T>
-        constexpr bool is_object_(int, T * (*q)(T &) = nullptr, T * p = nullptr,
-                                  decltype(detail::is_objptr_(q(*p))) * = nullptr)
-        {
-            return (void)p, (void)q, true;
-        }
-#endif // !__clang__
-
-        template<typename T>
-        constexpr bool is_integral_(...)
-        {
-            return false;
-        }
-        template<typename T, T = 1>
-        constexpr bool is_integral_(long)
-        {
-            return true;
-        }
-#if defined(__cpp_nontype_template_parameter_class) && \
-    __cpp_nontype_template_parameter_class > 0
-        template<typename T>
-        constexpr bool is_integral_(int, int T::* = nullptr)
-        {
-            return false;
-        }
-#endif
-#endif // detect MSVC
-
-        template<typename T>
-        struct with_difference_type_
-        {
-            using difference_type = T;
-        };
-
-        template<typename T>
-        using difference_result_t =
-            decltype(std::declval<T const &>() - std::declval<T const &>());
-
-        template<typename, typename = void>
-        struct incrementable_traits_2_
-        {};
-
-        template<typename T>
-        struct incrementable_traits_2_<
-            T,
-#if defined(_MSC_VER) && !defined(__clang__) && !defined(__EDG__)
-            std::enable_if_t<std::is_integral_v<difference_result_t<T>>>>
-#elif defined(RANGES_WORKAROUND_GCC_91923)
-            std::enable_if_t<std::is_integral<difference_result_t<T>>::value>>
-#else
-            always_<void, int[is_integral_<difference_result_t<T>>(0)]>>
-#endif // detect MSVC
-        {
-            using difference_type = std::make_signed_t<difference_result_t<T>>;
-        };
-
-        template<typename T, typename = void>
-        struct incrementable_traits_1_ : incrementable_traits_2_<T>
-        {};
-
-        template<typename T>
-        struct incrementable_traits_1_<T *>
-#ifdef __clang__
-          : conditional_t<__is_object(T), with_difference_type_<std::ptrdiff_t>, nil_>
-#elif defined(_MSC_VER) && !defined(__EDG__)
-          : conditional_t<std::is_object_v<T>, with_difference_type_<std::ptrdiff_t>, nil_>
-#else // ^^^ MSVC / not MSVC vvv
-          : conditional_t<is_object_<T>(0), with_difference_type_<std::ptrdiff_t>, nil_>
-#endif // detect MSVC
-        {};
-
-        template<typename T>
-        struct incrementable_traits_1_<T, always_<void, typename T::difference_type>>
-        {
-            using difference_type = typename T::difference_type;
-        };
-    } // namespace detail
-    /// \endcond
-
-    template<typename T>
-    struct incrementable_traits : detail::incrementable_traits_1_<T>
-    {};
-
-    template<typename T>
-    struct incrementable_traits<T const> : incrementable_traits<T>
-    {};
-
-    /// \cond
-    namespace detail
-    {
-#ifdef __clang__
-        template<typename T, bool = __is_object(T)>
-#elif defined(_MSC_VER) && !defined(__EDG__)
-        template<typename T, bool = std::is_object_v<T>>
-#else // ^^^ MSVC / not MSVC vvv
-        template<typename T, bool = is_object_<T>(0)>
-#endif // detect MSVC
-        struct with_value_type_
-        {};
-        template<typename T>
-        struct with_value_type_<T, true>
-        {
-            using value_type = T;
-        };
-        template<typename T>
-        struct with_value_type_<T const, true>
-        {
-            using value_type = T;
-        };
-        template<typename T>
-        struct with_value_type_<T volatile, true>
-        {
-            using value_type = T;
-        };
-        template<typename T>
-        struct with_value_type_<T const volatile, true>
-        {
-            using value_type = T;
-        };
-        template<typename, typename = void>
-        struct readable_traits_2_
-        {};
-        template<typename T>
-        struct readable_traits_2_<T, always_<void, typename T::element_type>>
-          : with_value_type_<typename T::element_type>
-        {};
-        template<typename T, typename = void>
-        struct readable_traits_1_ : readable_traits_2_<T>
-        {};
-        template<typename T>
-        struct readable_traits_1_<T[]> : with_value_type_<T>
-        {};
-        template<typename T, std::size_t N>
-        struct readable_traits_1_<T[N]> : with_value_type_<T>
-        {};
-        template<typename T>
-        struct readable_traits_1_<T *> : detail::with_value_type_<T>
-        {};
-        template<typename T>
-        struct readable_traits_1_<T, always_<void, typename T::value_type>>
-          : with_value_type_<typename T::value_type>
-        {};
-    } // namespace detail
-    /// \endcond
-
-    ////////////////////////////////////////////////////////////////////////////////////////
-    // Not to spec:
-    // * For class types with both member value_type and element_type, value_type is
-    //   preferred (see ericniebler/stl2#299).
-    template<typename T>
-    struct indirectly_readable_traits : detail::readable_traits_1_<T>
-    {};
-
-    template<typename T>
-    struct indirectly_readable_traits<T const> : indirectly_readable_traits<T>
-    {};
-
-    /// \cond
-    namespace detail
-    {
-        template<typename D = std::ptrdiff_t>
-        struct std_output_iterator_traits
-        {
-            using iterator_category = std::output_iterator_tag;
-            using difference_type = D;
-            using value_type = void;
-            using reference = void;
-            using pointer = void;
-        };
-
-        // For testing whether a particular instantiation of std::iterator_traits
-        // is user-specified or not.
-#if defined(_MSVC_STL_UPDATE) && defined(__cpp_lib_concepts) && _MSVC_STL_UPDATE >= 201908L
-        template<typename I>
-        inline constexpr bool is_std_iterator_traits_specialized_v =
-            !std::_Is_from_primary<std::iterator_traits<I>>;
-#else
-#if defined(__GLIBCXX__)
-        template<typename I>
-        char (&is_std_iterator_traits_specialized_impl_(std::__iterator_traits<I> *))[2];
-        template<typename I>
-        char is_std_iterator_traits_specialized_impl_(void *);
-#elif defined(_LIBCPP_VERSION)
-        template<typename I, bool B>
-        char (
-            &is_std_iterator_traits_specialized_impl_(std::__iterator_traits<I, B> *))[2];
-        template<typename I>
-        char is_std_iterator_traits_specialized_impl_(void *);
-#elif defined(_MSVC_STL_VERSION)
-        template<typename I>
-        char (&is_std_iterator_traits_specialized_impl_(
-            std::_Iterator_traits_base<I> *))[2];
-        template<typename I>
-        char is_std_iterator_traits_specialized_impl_(void *);
-#else
-        template<typename I>
-        char (&is_std_iterator_traits_specialized_impl_(void *))[2];
-#endif
-        template<typename, typename T>
-        char (&is_std_iterator_traits_specialized_impl_(std::iterator_traits<T *> *))[2];
-
-        template<typename I>
-        RANGES_INLINE_VAR constexpr bool is_std_iterator_traits_specialized_v =
-            1 == sizeof(is_std_iterator_traits_specialized_impl_<I>(
-                     static_cast<std::iterator_traits<I> *>(nullptr)));
-
-        // The standard iterator_traits<T *> specialization(s) do not count
-        // as user-specialized. This will no longer be necessary in C++20.
-        // This helps with `T volatile*` and `void *`.
-        template<typename T>
-        RANGES_INLINE_VAR constexpr bool is_std_iterator_traits_specialized_v<T *> =
-            false;
-#endif
-    } // namespace detail
-    /// \endcond
-} // namespace ranges
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/include/std/iterator b/src/contrib/range-v3-0.11.0/include/std/iterator
deleted file mode 100644
index 23d5cf36..00000000
--- a/src/contrib/range-v3-0.11.0/include/std/iterator
+++ /dev/null
@@ -1,278 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2018-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_STD_ITERATOR
-#define RANGES_V3_STD_ITERATOR
-
-#if defined(__GNUC__)
-#include_next <iterator>
-#elif defined(_MSC_VER)
-#include <../include/iterator> // HACKHACK
-#else
-#error "Cannot use range-v3 STL deep integration on this platform."
-#endif
-
-#if RANGES_DEEP_STL_INTEGRATION
-
-#include <range/v3/detail/config.hpp>
-#include <std/detail/associated_types.hpp>
-
-#include <range/v3/detail/prologue.hpp>
-
-namespace ranges
-{
-    template<typename I>
-    struct incrementable_traits;
-
-    template<typename I>
-    struct indirectly_readable_traits;
-
-    /// \cond
-    namespace detail
-    {
-        template<typename I>
-        typename incrementable_traits<I>::difference_type cpp17_difference_type_(int);
-        template<typename I>
-        void cpp17_difference_type_(long);
-
-        template<typename I>
-        typename I::pointer cpp17_pointer_type_(int);
-        template<typename I>
-        auto cpp17_pointer_type_(long, I *pi = nullptr) -> decltype(pi->operator->());
-        template<typename I>
-        void cpp17_pointer_type_(...);
-
-        template<typename I>
-        typename I::reference cpp17_reference_type_(int);
-        template<typename I>
-        auto cpp17_reference_type_(long, I *pi = nullptr) -> decltype(**pi);
-
-        template<typename I>
-        auto cpp17_iterator_category_4_(long)
-        {
-            return std::bidirectional_iterator_tag{};
-        }
-        // Satisfies Cpp17RandomAccessIterator?
-        template<typename I>
-        auto cpp17_iterator_category_4_(
-            int,
-            I *pi = nullptr,
-            typename incrementable_traits<I>::difference_type d = 0,
-            always_<
-                void,
-                int[RANGES_IS_SAME(decltype(*pi += d), I &)],
-                int[RANGES_IS_SAME(decltype(*pi -= d), I &)],
-                int[RANGES_IS_SAME(decltype(*pi + d), I)],
-                int[RANGES_IS_SAME(decltype(*pi - d), I)],
-                int[RANGES_IS_SAME(decltype(d + *pi), I)],
-                int[RANGES_IS_SAME(decltype(*pi - *pi), decltype(d))],
-                int[RANGES_IS_SAME(decltype((*pi)[d]), decltype(**pi))],
-                decltype(*pi < *pi ? true : false),
-                decltype(*pi > *pi ? true : false),
-                decltype(*pi <= *pi ? true : false),
-                decltype(*pi >= *pi ? true : false)
-            > * = nullptr)
-        {
-            return std::random_access_iterator_tag{};
-        }
-
-        template<typename I>
-        auto cpp17_iterator_category_3_(long)
-        {
-            return std::forward_iterator_tag{};
-        }
-        // Satisfies Cpp17BidirectionalIterator?
-        template<typename I>
-        auto cpp17_iterator_category_3_(
-            int,
-            I *pi = nullptr,
-            void (*fn)(I const &) = nullptr,
-            always_<
-                void,
-                decltype(fn((*pi)--)), // i-- convertible to I const &
-                int[RANGES_IS_SAME(decltype(--*pi), I &)], // --i has type I &
-                // *i has the same type as *i--
-                int[RANGES_IS_SAME(decltype(**pi), decltype(*(*pi)--))]
-            > * = nullptr)
-        {
-            return cpp17_iterator_category_4_<I>(0);
-        }
-
-        template<typename I>
-        auto cpp17_iterator_category_2_(long)
-        {
-            return std::input_iterator_tag{};
-        }
-        // Satisfies Cpp17ForwardIterator?
-        template<typename I>
-        auto cpp17_iterator_category_2_(
-            int,
-            I *pi = nullptr,
-            void (*fn)(I const &) = nullptr,
-            typename indirectly_readable_traits<I>::value_type *pv = nullptr,
-            typename indirectly_readable_traits<I>::value_type const *pcv = nullptr,
-            always_<
-                void,
-                decltype(I{}), // Default constructible
-                decltype(fn((*pi)++)), // i++ convertible to I const &
-                // *i has the same type as *i++
-                int[RANGES_IS_SAME(decltype(**pi), decltype(*(*pi)++))],
-                // *i is a real reference to value_type
-#ifdef RANGES_WORKAROUND_MSVC_793042
-                enable_if_t<RANGES_IS_SAME(decltype(**pi), decltype(*pv)) ||
-                            RANGES_IS_SAME(decltype(**pi), decltype(*pcv)) ||
-                            RANGES_IS_SAME(decltype(**pi), typename indirectly_readable_traits<I>::value_type &&) ||
-                            RANGES_IS_SAME(decltype(**pi), typename indirectly_readable_traits<I>::value_type const &&)>
-#else // ^^^ workaround / no workaround vvv
-                int[RANGES_IS_SAME(decltype(**pi), decltype(*pv)) ||
-                    RANGES_IS_SAME(decltype(**pi), decltype(*pcv)) ||
-                    RANGES_IS_SAME(decltype(**pi), typename indirectly_readable_traits<I>::value_type &&) ||
-                    RANGES_IS_SAME(decltype(**pi), typename indirectly_readable_traits<I>::value_type const &&)]
-#endif // RANGES_WORKAROUND_MSVC_793042
-            > * = nullptr)
-        {
-            return cpp17_iterator_category_3_<I>(0);
-        }
-
-        template<typename I>
-        using cpp17_readable_iterator_category_t =
-            decltype(detail::cpp17_iterator_category_2_<I>(0));
-
-        template<typename I>
-        auto cpp17_iterator_category_(long)
-        {
-            return cpp17_iterator_category_2_<I>(0);
-        }
-        // Explicitly declares its category?
-        template<typename I>
-        typename I::iterator_category cpp17_iterator_category_(int)
-        {
-            return {};
-        }
-
-        template<typename I>
-        auto std_iterator_traits_impl_2_(long)
-        {
-            return std_output_iterator_traits<
-                decltype(detail::cpp17_difference_type_<I>(0))>{};
-        }
-        // Satisfies Cpp17InputIterator?
-        template<typename I>
-        auto std_iterator_traits_impl_2_(
-            int,
-            I *pi = nullptr,
-            typename incrementable_traits<I>::difference_type d = 0,
-            typename indirectly_readable_traits<I>::value_type const *pcv = nullptr,
-            always_<
-                void,
-                int[decltype(d)(-1) < decltype(d)(0)], // signed difference type
-                decltype(decltype(*pcv)(**pi)),        // sensible reference/value type
-                decltype(decltype(*pcv)(*(*pi)++)),    // sensible post-increment result
-                decltype(*pi == *pi ? true : false),   // equality comparable
-                decltype(*pi != *pi ? true : false)    //     "        "
-            > * = nullptr)
-        {
-            using D = typename incrementable_traits<I>::difference_type;
-            struct yes_traits
-            {
-                using difference_type = D;
-                using value_type = typename indirectly_readable_traits<I>::value_type;
-                using reference = decltype(cpp17_reference_type_<I>(0));
-                using pointer = decltype(cpp17_pointer_type_<I>(0));
-                using iterator_category = decltype(cpp17_iterator_category_<I>(0));
-            };
-            struct no_traits
-            {};
-            return conditional_t<is_integral_<D>(0), yes_traits, no_traits>{};
-        }
-
-        template<typename I>
-        nil_ std_iterator_traits_impl_(long)
-        {
-            return {};
-        }
-        // Satisfies Cpp17Iterator?
-        template<typename I>
-        auto std_iterator_traits_impl_(
-            int,
-            I *pi = nullptr,
-            void (*nv)(...) = nullptr,
-            always_<
-                void,
-                decltype(nv(**pi)),
-                int[RANGES_IS_SAME(decltype(++*pi), I &)],
-                decltype(nv(*(*pi)++))
-            > * = nullptr)
-        {
-            return std_iterator_traits_impl_2_<I>(0);
-        }
-
-        template<typename T>
-        constexpr bool has_iterator_typedefs_impl_(
-            int,
-            always_<
-                void,
-                typename T::difference_type,
-                typename T::value_type,
-                typename T::pointer,
-                typename T::reference,
-                typename T::iterator_category
-            > * = nullptr)
-        {
-            return true;
-        }
-        template<typename T>
-        constexpr bool has_iterator_typedefs_impl_(long)
-        {
-            return false;
-        }
-    }
-    /// \endcond
-} // namespace ranges
-
-// Hijack the primary std::iterator_traits template from each of the 3 major
-// standard library implementations
-RANGES_BEGIN_NAMESPACE_STD
-RANGES_BEGIN_NAMESPACE_VERSION
-#if defined(__GLIBCXX__)
-    template<typename I>
-    struct __iterator_traits<
-        I,
-        ::ranges::detail::enable_if_t<!::ranges::detail::has_iterator_typedefs_impl_<I>(0)>>
-      : decltype(::ranges::detail::std_iterator_traits_impl_<I>(0))
-    {};
-#elif defined(_LIBCPP_VERSION)
-    template<typename I>
-    struct __iterator_traits<I, false> // doesn't have I::iterator_category
-      : decltype(::ranges::detail::std_iterator_traits_impl_<I>(0))
-    {};
-#elif defined(_MSVC_STL_VERSION)
-    template<typename I>
-    struct _Iterator_traits_base<
-        I,
-#ifdef RANGES_WORKAROUND_MSVC_792338
-        ::ranges::detail::enable_if_t<decltype(bool_constant<
-            !::ranges::detail::has_iterator_typedefs_impl_<I>(0)>{})::value>>
-#else // ^^^ workaround / no workaround vvv
-        ::ranges::detail::enable_if_t<!::ranges::detail::has_iterator_typedefs_impl_<I>(0)>>
-#endif // RANGES_WORKAROUND_MSVC_792338
-      : decltype(::ranges::detail::std_iterator_traits_impl_<I>(0))
-    {};
-#endif
-RANGES_END_NAMESPACE_VERSION
-RANGES_END_NAMESPACE_STD
-
-#include <range/v3/detail/epilogue.hpp>
-
-#endif // RANGES_DEEP_STL_INTEGRATION
-
-#endif // RANGES_V3_STD_ITERATOR
diff --git a/src/contrib/range-v3-0.11.0/install_libcxx.sh b/src/contrib/range-v3-0.11.0/install_libcxx.sh
deleted file mode 100755
index 321aa1b3..00000000
--- a/src/contrib/range-v3-0.11.0/install_libcxx.sh
+++ /dev/null
@@ -1,103 +0,0 @@
-#!/usr/bin/env bash
-
-TRUNK_VERSION="9.0.0"
-
-set -e
-
-# The pattern of clang --version is: clang version X.Y.Z (sometimes, see below).
-COMPILER_VERSION_OUTPUT="$($CXX --version)"
-arr=(${COMPILER_VERSION_OUTPUT// / })
-
-COMPILER="${arr[0]}"
-VERSION="${arr[2]}"
-
-case $COMPILER in
-    "clang")
-        # Some Ubuntu clang builds are advertised as "just clang", but the
-        # Version still follows the pattern: 3.6.2-svn240577-1~exp1
-        # echo "Compiler is clang :)"
-        arr2=(${VERSION//-/ })
-        VERSION="${arr2[0]}"
-        ;;
-    "Ubuntu")
-        # Ubuntu renames _some_ (not all) of its clang compilers, the pattern of
-        # clang --version is then:
-        # Ubuntu clang version 3.6.2-svn240577-1~exp1
-        COMPILER="${arr[1]}"
-        VERSION="${arr[3]}"
-        arr2=(${VERSION//-/ })
-        VERSION="${arr2[0]}"
-        ;;
-    *)
-        echo "case did not match: compiler: ${COMPILER}"
-        exit 1
-        ;;
-esac
-
-if [ ${COMPILER} != "clang" ]; then
-    echo "Error: trying to install libc++ for a compiler that is not clang: ${COMPILER}"
-    exit 1
-fi
-
-if [ -z ${VERSION+x} ]; then
-    echo "Malformed libc++ version - I give up."
-    exit 4
-fi
-
-if [ ${VERSION} == $TRUNK_VERSION ]; then
-    echo "Fetching libc++ and libc++abi tip-of-trunk..."
-
-    # Checkout LLVM sources
-    git clone --depth=1 https://github.com/llvm-mirror/llvm.git llvm-source
-    git clone --depth=1 https://github.com/llvm-mirror/libcxx.git llvm-source/projects/libcxx
-    git clone --depth=1 https://github.com/llvm-mirror/libcxxabi.git llvm-source/projects/libcxxabi
-else
-    echo "Fetching libc++/libc++abi version: ${VERSION}..."
-    LLVM_URL="https://releases.llvm.org/${VERSION}/llvm-${VERSION}.src.tar.xz"
-    LIBCXX_URL="https://releases.llvm.org/${VERSION}/libcxx-${VERSION}.src.tar.xz"
-    LIBCXXABI_URL="https://releases.llvm.org/${VERSION}/libcxxabi-${VERSION}.src.tar.xz"
-    curl -O $LLVM_URL
-    curl -O $LIBCXX_URL
-    curl -O $LIBCXXABI_URL
-
-    mkdir llvm-source
-    mkdir llvm-source/projects
-    mkdir llvm-source/projects/libcxx
-    mkdir llvm-source/projects/libcxxabi
-
-    tar -xf llvm-${VERSION}.src.tar.xz -C llvm-source --strip-components=1
-    tar -xf libcxx-${VERSION}.src.tar.xz -C llvm-source/projects/libcxx --strip-components=1
-    tar -xf libcxxabi-${VERSION}.src.tar.xz -C llvm-source/projects/libcxxabi --strip-components=1
-fi
-
-TARGET=`pwd`/llvm
-mkdir "${TARGET}"
-mkdir llvm-build
-cd llvm-build
-
-# - libc++ versions < 4.x do not have the install-cxxabi and install-cxx targets
-# - only ASAN is enabled for clang/libc++ versions < 4.x
-if [[ $VERSION == *"3."* ]]; then
-    cmake -DCMAKE_C_COMPILER=${CC} -DCMAKE_CXX_COMPILER=${CXX} \
-          -DCMAKE_BUILD_TYPE=RelWithDebInfo -DCMAKE_INSTALL_PREFIX="${TARGET}" \
-          ../llvm-source
-    if [[ $SANITIZER == "Address;Undefined" ]]; then
-        ASAN_FLAGS="-fsanitize=address"
-        cmake -DCMAKE_CXX_FLAGS="${ASAN_FLAGS}" -DCMAKE_EXE_LINKER_FLAGS="${ASAN_FLAGS}" ../llvm-source
-    fi
-    make cxx -j2 VERBOSE=1
-    mkdir "${TARGET}/lib"
-    mkdir "${TARGET}/include"
-    cp -r lib/* "${TARGET}/lib"
-    cp -r include/c++ "${TARGET}/include"
-else
-    cmake -DCMAKE_C_COMPILER=${CC} -DCMAKE_CXX_COMPILER=${CXX} \
-          -DCMAKE_BUILD_TYPE=RelWithDebInfo -DCMAKE_INSTALL_PREFIX="${TARGET}" \
-          -DLIBCXX_ABI_UNSTABLE=ON \
-          -DLLVM_USE_SANITIZER=${SANITIZER} \
-          ../llvm-source
-    make cxx -j2 VERBOSE=1
-    make install-cxxabi install-cxx
-fi
-
-exit 0
diff --git a/src/contrib/range-v3-0.11.0/perf/CMakeLists.txt b/src/contrib/range-v3-0.11.0/perf/CMakeLists.txt
deleted file mode 100644
index 6391292c..00000000
--- a/src/contrib/range-v3-0.11.0/perf/CMakeLists.txt
+++ /dev/null
@@ -1,10 +0,0 @@
-set(CMAKE_FOLDER "perf")
-
-add_executable(counted_insertion_sort counted_insertion_sort.cpp)
-target_link_libraries(counted_insertion_sort range-v3)
-
-add_executable(range_conversion range_conversion.cpp)
-target_link_libraries(range_conversion range-v3 benchmark_main)
-
-add_executable(sort_patterns sort_patterns.cpp)
-target_link_libraries(sort_patterns range-v3)
diff --git a/src/contrib/range-v3-0.11.0/perf/counted_insertion_sort.cpp b/src/contrib/range-v3-0.11.0/perf/counted_insertion_sort.cpp
deleted file mode 100644
index 378910e8..00000000
--- a/src/contrib/range-v3-0.11.0/perf/counted_insertion_sort.cpp
+++ /dev/null
@@ -1,187 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#include <chrono>
-#include <iostream>
-#include <random>
-#include <range/v3/all.hpp>
-
-RANGES_DIAGNOSTIC_IGNORE_SIGN_CONVERSION
-
-class timer
-{
-public:
-    using clock_t = std::chrono::high_resolution_clock;
-    using duration_t = clock_t::time_point::duration;
-
-    timer()
-    {
-        reset();
-    }
-    void reset()
-    {
-        start_ = clock_t::now();
-    }
-    duration_t elapsed() const
-    {
-        return clock_t::now() - start_;
-    }
-    friend std::ostream &operator<<(std::ostream &sout, timer const &t)
-    {
-        return sout << t.elapsed().count() << "ms";
-    }
-private:
-    clock_t::time_point start_;
-};
-
-template<typename D>
-std::chrono::milliseconds::rep to_millis(D d) {
-  return std::chrono::duration_cast<std::chrono::milliseconds>(d).count();
-}
-
-template<typename It>
-struct forward_iterator
-{
-    It it_;
-public:
-    typedef          std::forward_iterator_tag                 iterator_category;
-    typedef typename std::iterator_traits<It>::value_type      value_type;
-    typedef typename std::iterator_traits<It>::difference_type difference_type;
-    typedef It                                                 pointer;
-    typedef typename std::iterator_traits<It>::reference       reference;
-
-    forward_iterator() = default;
-    explicit forward_iterator(It it) : it_(std::move(it)) {}
-
-    reference operator*() const {return *it_;}
-    pointer operator->() const {return it_;}
-
-    forward_iterator& operator++() {++it_; return *this;}
-    forward_iterator operator++(int)
-        {forward_iterator tmp(*this); ++(*this); return tmp;}
-
-    friend bool operator==(const forward_iterator& x, const forward_iterator& y)
-        {return x.it_ == y.it_;}
-    friend bool operator!=(const forward_iterator& x, const forward_iterator& y)
-        {return !(x == y);}
-};
-
-template<typename I, typename V2>
-I upper_bound_n(I first, typename std::iterator_traits<I>::difference_type d, V2 const &val)
-{
-    while(0 != d)
-    {
-        auto half = d / 2;
-        auto middle = std::next(first, half);
-        if(val < *middle)
-            d = half;
-        else
-        {
-            first = ++middle;
-            d -= half + 1;
-        }
-    }
-    return first;
-}
-
-template<typename I>
-void insertion_sort_n(I first, typename std::iterator_traits<I>::difference_type n)
-{
-    auto m = 0;
-    for(auto it = first; m != n; ++it, ++m)
-    {
-        auto insertion = upper_bound_n(first, m, *it);
-        ranges::rotate(insertion, it, std::next(it));
-    }
-}
-
-template<typename I, typename S>
-void insertion_sort(I first, S last)
-{
-    for(auto it = first; it != last; ++it)
-    {
-        auto insertion = ranges::upper_bound(first, it, *it);
-        ranges::rotate(insertion, it, std::next(it));
-    }
-}
-
-template<typename Rng>
-void insertion_sort(Rng && rng)
-{
-    ::insertion_sort(std::begin(rng), std::end(rng));
-}
-
-std::unique_ptr<int> data(int i)
-{
-    std::unique_ptr<int> a(new int[i]);
-    auto rng = ranges::views::counted(a.get(), i);
-    ranges::iota(rng, 0);
-    return a;
-}
-
-template<typename Gen>
-void shuffle(int *a, int i, Gen && rand)
-{
-    auto rng = ranges::views::counted(a, i);
-    rng |= ranges::actions::shuffle(std::forward<Gen>(rand));
-}
-
-constexpr int cloops = 3;
-
-template<typename I>
-void benchmark_n(int i)
-{
-    std::mt19937 gen;
-    auto a = data(i);
-    timer::duration_t ms = {};
-    for(int j = 0; j < cloops; ++j)
-    {
-        ::shuffle(a.get(), i, gen);
-        timer t;
-        insertion_sort_n(I{a.get()}, i);
-        ms += t.elapsed();
-    }
-    std::cout << to_millis(ms/cloops) << std::endl;
-}
-
-template<typename I>
-void benchmark_counted(int i)
-{
-    std::mt19937 gen;
-    auto a = data(i);
-    timer::duration_t ms = {};
-    for(int j = 0; j < cloops; ++j)
-    {
-        ::shuffle(a.get(), i, gen);
-        timer t;
-        insertion_sort(ranges::views::counted(I{a.get()}, i));
-        ms += t.elapsed();
-    }
-    std::cout << to_millis(ms/cloops) << std::endl;
-}
-
-int main(int argc, char *argv[])
-{
-    if(argc < 2)
-        return -1;
-
-    int i = std::atoi(argv[1]);
-    std::cout << "insertion_sort_n (random-access) : ";
-    benchmark_n<int*>(i);
-    std::cout << "insertion_sort   (random-access) : ";
-    benchmark_counted<int*>(i);
-    std::cout << "\n";
-    std::cout << "insertion_sort_n (forward)       : ";
-    benchmark_n<forward_iterator<int*>>(i);
-    std::cout << "insertion_sort   (forward)       : ";
-    benchmark_counted<forward_iterator<int*>>(i);
-}
diff --git a/src/contrib/range-v3-0.11.0/perf/range_conversion.cpp b/src/contrib/range-v3-0.11.0/perf/range_conversion.cpp
deleted file mode 100644
index 27ec5c5f..00000000
--- a/src/contrib/range-v3-0.11.0/perf/range_conversion.cpp
+++ /dev/null
@@ -1,101 +0,0 @@
-// Range v3 library
-//
-//  Copyright 2019-present Christopher Di Bella
-//  Copyright 2019-present Eric Niebler
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-// Benchmark for https://github.com/ericniebler/range-v3/issues/1337
-
-#include <string>
-#include <vector>
-
-#include <benchmark/benchmark.h>
-
-#include <range/v3/algorithm/equal.hpp>
-#include <range/v3/range/conversion.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/view/common.hpp>
-#include <range/v3/view/reverse.hpp>
-#include <range/v3/view/transform.hpp>
-
-using namespace ranges;
-
-namespace
-{
-    auto palindrome_range_common(std::vector<std::string> const & words)
-    {
-        auto is_palindrome = [](auto const & word) {
-            return !ranges::empty(word) && ranges::equal(word, word | views::reverse);
-        };
-
-        auto palindrome_excalim = [&is_palindrome](auto const & word) {
-            return is_palindrome(word) ? word + '!' : word;
-        };
-
-        auto result = words | views::transform(palindrome_excalim) | views::common;
-
-        return std::vector<std::string>{ranges::begin(result), ranges::end(result)};
-    }
-
-    auto palindrome_range_to(std::vector<std::string> const & words)
-    {
-        auto is_palindrome = [](auto const & word) {
-            return !ranges::empty(word) && ranges::equal(word, word | views::reverse);
-        };
-
-        auto palindrome_excalim = [&is_palindrome](auto const & word) {
-            return is_palindrome(word) ? word + '!' : word;
-        };
-
-        return words | views::transform(palindrome_excalim) | ranges::to<std::vector>;
-    }
-} // namespace
-
-class Words : public ::benchmark::Fixture
-{
-protected:
-    std::vector<std::string> words_;
-
-public:
-    void SetUp(const ::benchmark::State &)
-    {
-        auto magic = 476'000u;
-        words_.reserve(magic);
-        for(auto i = 0u; i < magic; ++i)
-        {
-            words_.push_back("this");
-            words_.push_back("is");
-            words_.push_back("his");
-            words_.push_back("face");
-            words_.push_back("abba");
-            words_.push_back("toot");
-        }
-    }
-};
-
-BENCHMARK_F(Words, RangeCommon)(benchmark::State & st)
-{
-    for(auto _ : st)
-    {
-        auto result = ::palindrome_range_common(words_);
-        benchmark::DoNotOptimize(result.data());
-        benchmark::ClobberMemory();
-    }
-}
-
-BENCHMARK_F(Words, RangeTo)(benchmark::State & st)
-{
-    for(auto _ : st)
-    {
-        auto result = ::palindrome_range_to(words_);
-        benchmark::DoNotOptimize(result.data());
-        benchmark::ClobberMemory();
-    }
-}
diff --git a/src/contrib/range-v3-0.11.0/perf/sort_patterns.cpp b/src/contrib/range-v3-0.11.0/perf/sort_patterns.cpp
deleted file mode 100644
index 227e4258..00000000
--- a/src/contrib/range-v3-0.11.0/perf/sort_patterns.cpp
+++ /dev/null
@@ -1,256 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//  Copyright Gonzalo Brito Gadeschi 2015
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#include <range/v3/detail/config.hpp>
-
-#if RANGES_CXX_RETURN_TYPE_DEDUCTION >= RANGES_CXX_RETURN_TYPE_DEDUCTION_14 && \
-    RANGES_CXX_GENERIC_LAMBDAS >= RANGES_CXX_GENERIC_LAMBDAS_14
-
-#include <iostream>
-#include <iomanip>
-#include <vector>
-#include <random>
-#include <functional>
-#include <climits>
-#include <chrono>
-#include <algorithm>
-#include <range/v3/all.hpp>
-
-RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS
-RANGES_DIAGNOSTIC_IGNORE_SIGN_CONVERSION
-
-namespace
-{
-  /// Creates an geometric infinite sequence starting at 1 where the
-  /// successor is multiplied by \p V
-  auto geometric_sequence(std::size_t V) {
-    std::size_t N = 1;
-    return ranges::views::generate([N, V]() mutable {
-      auto old = N;
-      N *= V;
-      return old;
-    });
-  }
-
-  /// Creates an geometric infinite sequence starting at 1 where the
-  /// successor is multiplied by \p V
-  auto geometric_sequence_n(std::size_t V, std::size_t limit) {
-    return geometric_sequence(V) |
-      ranges::views::take_while([limit](std::size_t n) { return n <= limit; });
-  }
-
-  /// Random uniform integer sequence
-  struct random_uniform_integer_sequence {
-    std::default_random_engine gen;
-    std::uniform_int_distribution<> dist;
-    auto operator()(std::size_t) {
-      return ranges::views::generate([&]{ return dist(gen); });
-    }
-    static std::string name() { return "random_uniform_integer_sequence"; }
-  };
-
-  struct ascending_integer_sequence {
-    auto operator()(std::size_t) { return ranges::views::iota(1); }
-    static std::string name() { return "ascending_integer_sequence"; }
-  };
-
-  struct descending_integer_sequence {
-    auto operator()(std::size_t) {
-      return ranges::views::iota(0ll, std::numeric_limits<long long>::max()) |
-            ranges::views::reverse;
-    }
-    static std::string name() { return "descending_integer_sequence"; }
-  };
-
-  auto even = [](auto i) { return i % 2 == 0; };
-  auto odd = [](auto i) { return !even(i); };
-
-  struct even_odd_integer_sequence {
-    static std::string name() { return "even_odd_integer_sequence"; }
-    auto operator()(std::size_t n) {
-      return ranges::views::concat(ranges::views::ints(std::size_t{0}, n) | ranges::views::filter(even),
-                                  ranges::views::ints(std::size_t{0}, n) | ranges::views::filter(odd));
-    }
-  };
-
-  struct organ_pipe_integer_sequence {
-    static std::string name() { return "organ_pipe_integer_sequence"; }
-    auto operator()(std::size_t n) {
-      return ranges::views::concat(ranges::views::ints(std::size_t{0}, n/2),
-                                  ranges::views::ints(std::size_t{0}, n/2 + 1)
-                                  | ranges::views::reverse);
-    }
-  };
-
-  template<typename Seq>
-  void print(Seq seq, std::size_t n) {
-    std::cout << "sequence: " << seq.name() << '\n';
-    RANGES_FOR(auto i, seq(n) | ranges::views::take(n)) {
-      std::cout << i << '\n';
-    }
-  }
-
-  /// Returns the duration of a computation
-  using clock_t = std::chrono::high_resolution_clock;
-  using duration_t = clock_t::duration;
-
-  template<typename Computation>
-  auto duration(Computation &&c) {
-    auto time = []{ return clock_t::now(); };
-    const auto start = time();
-    c();
-    return time() - start;
-  }
-
-  template<typename Duration>
-  auto to_millis(Duration d) {
-    return std::chrono::duration_cast<std::chrono::milliseconds>(d).count();
-  }
-
-  template<typename Durations> auto compute_mean(Durations &&durations) {
-    using D = ranges::range_value_t<Durations>;
-    D total = ranges::accumulate(durations, D{}, ranges::plus{}, ranges::convert_to<D>{});
-    return total / ranges::size(durations);
-  }
-
-  template<typename Durations> auto compute_stddev(Durations &&durations) {
-    using D = ranges::range_value_t<Durations>;
-    using Rep = typename D::rep;
-    const auto mean = compute_mean(durations);
-    const auto stddev = ranges::accumulate(
-      durations | ranges::views::transform([=](auto i) {
-        auto const delta = (i - mean).count();
-        return delta * delta;
-      }), Rep{}, ranges::plus{}, ranges::convert_to<Rep>{});
-    return D{static_cast<typename D::rep>(std::sqrt(stddev / ranges::size(durations)))};
-  }
-
-  struct benchmark {
-    struct result_t {
-      duration_t mean_t;
-      duration_t max_t;
-      duration_t min_t;
-      std::size_t size;
-      duration_t deviation;
-    };
-    std::vector<result_t> results;
-
-    template<typename Computation, typename Sizes>
-    benchmark(Computation &&c, Sizes &&sizes, double target_deviation = 0.25,
-              std::size_t max_iters = 100, std::size_t min_iters = 5) {
-
-      RANGES_FOR(auto size, sizes) {
-        std::vector<duration_t> durations;
-        duration_t deviation;
-        duration_t mean_duration;
-        std::size_t iter;
-
-        for (iter = 0; iter < max_iters; ++iter) {
-          c.init(size);
-          durations.emplace_back(duration(c));
-          mean_duration = compute_mean(durations);
-          if (++iter == max_iters) {
-            break;
-          }
-          if (iter >= min_iters) {
-            deviation = compute_stddev(durations);
-            if (deviation < target_deviation * mean_duration)
-              break;
-          }
-        }
-        auto minmax = ranges::minmax(durations);
-        results.emplace_back(
-            result_t{mean_duration, minmax.max, minmax.min, size, deviation});
-        std::cerr << "size: " << size << " iter: " << iter
-                  << " dev: " << to_millis(deviation)
-                  << " mean: " << to_millis(mean_duration)
-                  << " max: " << to_millis(minmax.max)
-                  << " min: " << to_millis(minmax.min) << '\n';
-      }
-    }
-  };
-
-  template<typename Seq, typename Comp>
-  struct computation_on_sequence {
-    Seq seq;
-    Comp comp;
-    std::vector<ranges::range_value_t<decltype(seq(std::size_t{}))>> data;
-    computation_on_sequence(Seq s, Comp c, std::size_t max_size)
-        : seq(std::move(s)), comp(std::move(c)) {
-      data.reserve(max_size);
-    }
-    void init(std::size_t size) {
-      data.resize(size);
-      ranges::copy(seq(size) | ranges::views::take(size), ranges::begin(data));
-    }
-    void operator()() { comp(data); }
-  };
-
-  template<typename Seq, typename Comp>
-  auto make_computation_on_sequence(Seq s, Comp c, std::size_t max_size) {
-    return computation_on_sequence<Seq, Comp>(std::move(s), std::move(c),
-                                              max_size);
-  }
-
-  template<typename Seq> void benchmark_sort(Seq &&seq, std::size_t max_size) {
-    auto ranges_sort_comp =
-        make_computation_on_sequence(seq, ranges::sort, max_size);
-
-    auto std_sort_comp = make_computation_on_sequence(
-        seq, [](auto &&v) { std::sort(std::begin(v), std::end(v)); }, max_size);
-
-    auto ranges_sort_benchmark =
-        benchmark(ranges_sort_comp, geometric_sequence_n(2, max_size));
-
-    auto std_sort_benchmark =
-        benchmark(std_sort_comp, geometric_sequence_n(2, max_size));
-    using std::setw;
-    std::cout << '#'
-              << "pattern: " << seq.name() << '\n';
-    std::cout << '#' << setw(19) << 'N' << setw(20) << "ranges::sort" << setw(20)
-              << "std::sort"
-              << '\n';
-    RANGES_FOR(auto p, ranges::views::zip(ranges_sort_benchmark.results,
-                                         std_sort_benchmark.results)) {
-      auto rs = p.first;
-      auto ss = p.second;
-
-      std::cout << setw(20) << rs.size << setw(20) << to_millis(rs.mean_t)
-                << setw(20) << to_millis(ss.mean_t) << '\n';
-    }
-  }
-} // unnamed namespace
-
-int main()
-{
-  constexpr std::size_t max_size = 2000000;
-
-  print(random_uniform_integer_sequence(), 20);
-  print(ascending_integer_sequence(), 20);
-  print(descending_integer_sequence(), 20);
-  print(even_odd_integer_sequence(), 20);
-  print(organ_pipe_integer_sequence(), 20);
-
-  benchmark_sort(random_uniform_integer_sequence(), max_size);
-  benchmark_sort(ascending_integer_sequence(), max_size);
-  benchmark_sort(descending_integer_sequence(), max_size);
-  benchmark_sort(organ_pipe_integer_sequence(), max_size);
-}
-
-#else
-
-#pragma message("sort_patterns requires C++14 return type deduction and generic lambdas")
-
-int main() {}
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/test/CMakeLists.txt b/src/contrib/range-v3-0.11.0/test/CMakeLists.txt
deleted file mode 100644
index 889f314a..00000000
--- a/src/contrib/range-v3-0.11.0/test/CMakeLists.txt
+++ /dev/null
@@ -1,21 +0,0 @@
-include(../cmake/ranges_diagnostics.cmake)
-
-set(CMAKE_FOLDER "test")
-
-add_subdirectory(action)
-add_subdirectory(algorithm)
-add_subdirectory(iterator)
-add_subdirectory(functional)
-add_subdirectory(numeric)
-add_subdirectory(range)
-add_subdirectory(utility)
-add_subdirectory(view)
-add_subdirectory(experimental)
-
-rv3_add_test(test.config config config.cpp)
-rv3_add_test(test.constexpr_core constexpr_core constexpr_core.cpp)
-rv3_add_test(test.multiple multiple multiple1.cpp multiple2.cpp)
-rv3_add_test(test.bug474 bug474 bug474.cpp)
-rv3_add_test(test.bug566 bug566 bug566.cpp)
-rv3_add_test(test.bug1322 bug1322 bug1322.cpp)
-rv3_add_test(test.bug1335 bug1335 bug1335.cpp)
diff --git a/src/contrib/range-v3-0.11.0/test/action/CMakeLists.txt b/src/contrib/range-v3-0.11.0/test/action/CMakeLists.txt
deleted file mode 100644
index de409123..00000000
--- a/src/contrib/range-v3-0.11.0/test/action/CMakeLists.txt
+++ /dev/null
@@ -1,24 +0,0 @@
-set(CMAKE_FOLDER "${CMAKE_FOLDER}/action")
-
-rv3_add_test(test.act.concepts act.concepts cont_concepts.cpp)
-rv3_add_test(test.act.adjacent_remove_if act.adjacent_remove_if adjacent_remove_if.cpp)
-rv3_add_test(test.act.drop act.drop drop.cpp)
-rv3_add_test(test.act.drop_while act.drop_while drop_while.cpp)
-rv3_add_test(test.act.insert act.insert insert.cpp)
-rv3_add_test(test.act.join act.join join.cpp)
-rv3_add_test(test.act.push_front act.push_front push_front.cpp)
-rv3_add_test(test.act.push_back act.push_back push_back.cpp)
-rv3_add_test(test.act.remove_if act.remove_if remove_if.cpp)
-rv3_add_test(test.act.remove act.remove remove.cpp)
-rv3_add_test(test.act.unstable_remove_if act.unstable_remove_if unstable_remove_if.cpp)
-rv3_add_test(test.act.reverse act.reverse reverse.cpp)
-rv3_add_test(test.act.shuffle act.shuffle shuffle.cpp)
-rv3_add_test(test.act.slice act.slice slice.cpp)
-rv3_add_test(test.act.sort act.sort sort.cpp)
-rv3_add_test(test.act.split act.split split.cpp)
-rv3_add_test(test.act.stable_sort act.stable_sort stable_sort.cpp)
-rv3_add_test(test.act.stride act.stride stride.cpp)
-rv3_add_test(test.act.take act.take take.cpp)
-rv3_add_test(test.act.take_while act.take_while take_while.cpp)
-rv3_add_test(test.act.transform act.transform transform.cpp)
-rv3_add_test(test.act.unique act.unique unique.cpp)
diff --git a/src/contrib/range-v3-0.11.0/test/action/adjacent_remove_if.cpp b/src/contrib/range-v3-0.11.0/test/action/adjacent_remove_if.cpp
deleted file mode 100644
index e8726664..00000000
--- a/src/contrib/range-v3-0.11.0/test/action/adjacent_remove_if.cpp
+++ /dev/null
@@ -1,34 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler
-//  Copyright Christopher Di Bella
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#include <range/v3/action/adjacent_remove_if.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include <range/v3/core.hpp>
-#include <range/v3/view/iota.hpp>
-#include <vector>
-
-int main()
-{
-    using namespace ranges;
-
-    auto v = views::ints(1,21) | to<std::vector>();
-    auto & v2 = actions::adjacent_remove_if(v, [](int x, int y){ return (x + y) % 3 == 0; });
-    CHECK(std::addressof(v) == std::addressof(v2));
-    check_equal(v, {2, 3, 5, 6, 8, 9, 11, 12, 14, 15, 17, 18, 20});
-
-    v |= actions::adjacent_remove_if([](int x, int y){ return (y - x) == 2; });
-    check_equal(v, {2, 5, 8, 11, 14, 17, 20});
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/action/cont_concepts.cpp b/src/contrib/range-v3-0.11.0/test/action/cont_concepts.cpp
deleted file mode 100644
index 38ed033d..00000000
--- a/src/contrib/range-v3-0.11.0/test/action/cont_concepts.cpp
+++ /dev/null
@@ -1,43 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-
-#include <array>
-#include <vector>
-#include <memory>
-#include <range/v3/core.hpp>
-#include <range/v3/action/concepts.hpp>
-#include <range/v3/view/ref.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    int rgi[6];
-    CPP_assert(range<decltype(rgi)>);
-    CPP_assert(!semi_container<decltype(rgi)>);
-
-    std::array<int, 6> a;
-    CPP_assert(semi_container<decltype(a)>);
-    CPP_assert(!container<decltype(a)>);
-
-    std::vector<int> v;
-    CPP_assert(container<decltype(v)>);
-
-    std::vector<std::unique_ptr<int>> v2;
-    CPP_assert(container<decltype(v2)>);
-
-    CPP_assert(lvalue_container_like<decltype((v2))>);
-    CPP_assert(!lvalue_container_like<decltype(std::move(v2))>);
-
-    CPP_assert(lvalue_container_like<decltype(views::ref(v2))>);
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/action/drop.cpp b/src/contrib/range-v3-0.11.0/test/action/drop.cpp
deleted file mode 100644
index f9b58629..00000000
--- a/src/contrib/range-v3-0.11.0/test/action/drop.cpp
+++ /dev/null
@@ -1,39 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/action/drop.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    auto v = views::ints(1,21) | to<std::vector>();
-    auto & v2 = actions::drop(v, 3);
-    CHECK(&v2 == &v);
-    CHECK(v.size() == 17u);
-    CHECK(v[0] == 4);
-
-    v = std::move(v) | actions::drop(3);
-    CHECK(v.size() == 14u);
-    CHECK(v[0] == 7);
-
-    v |= actions::drop(3);
-    CHECK(v.size() == 11u);
-    CHECK(v[0] == 10);
-
-    v |= actions::drop(100);
-    CHECK(v.size() == 0u);
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/action/drop_while.cpp b/src/contrib/range-v3-0.11.0/test/action/drop_while.cpp
deleted file mode 100644
index 80848029..00000000
--- a/src/contrib/range-v3-0.11.0/test/action/drop_while.cpp
+++ /dev/null
@@ -1,41 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/algorithm/move.hpp>
-#include <range/v3/action/drop_while.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-    using namespace std::placeholders;
-
-    auto v = views::ints(1,21) | to<std::vector>();
-    auto & v2 = actions::drop_while(v, std::bind(std::less<int>(), _1, 4));
-    CHECK(&v2 == &v);
-    CHECK(v.size() == 17u);
-    CHECK(v[0] == 4);
-
-    v = std::move(v) | actions::drop_while([](int i){return i < 7;});
-    CHECK(v.size() == 14u);
-    CHECK(v[0] == 7);
-
-    v |= actions::drop_while([](int i){return i < 10;});
-    CHECK(v.size() == 11u);
-    CHECK(v[0] == 10);
-
-    v |= actions::drop_while([](int){return true;});
-    CHECK(v.size() == 0u);
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/action/insert.cpp b/src/contrib/range-v3-0.11.0/test/action/insert.cpp
deleted file mode 100644
index 0aad245b..00000000
--- a/src/contrib/range-v3-0.11.0/test/action/insert.cpp
+++ /dev/null
@@ -1,90 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-
-#include <set>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/take.hpp>
-#include <range/v3/view/for_each.hpp>
-#include <range/v3/view/ref.hpp>
-#include <range/v3/action/insert.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-template<typename T>
-struct vector_like : std::vector<T> {
-    using std::vector<T>::vector;
-
-    using typename std::vector<T>::size_type;
-
-    size_type last_reservation{};
-    size_type reservation_count{};
-
-    void reserve(size_type n) {
-      std::vector<T>::reserve(n);
-      last_reservation = n;
-      ++reservation_count;
-    }
-};
-
-int main()
-{
-    using namespace ranges;
-
-    {
-        std::vector<int> v;
-        auto i = insert(v, v.begin(), 42);
-        CHECK(i == v.begin());
-        ::check_equal(v, {42});
-        insert(v, v.end(), {1,2,3});
-        ::check_equal(v, {42,1,2,3});
-
-        insert(v, v.begin(), views::ints | views::take(3));
-        ::check_equal(v, {0,1,2,42,1,2,3});
-
-        int rg[] = {9,8,7};
-        insert(v, v.begin()+3, rg);
-        ::check_equal(v, {0,1,2,9,8,7,42,1,2,3});
-        insert(v, v.begin()+1, rg);
-        ::check_equal(v, {0,9,8,7,1,2,9,8,7,42,1,2,3});
-    }
-
-    {
-        std::set<int> s;
-        insert(s,
-            views::ints|views::take(10)|views::for_each([](int i){return yield_if(i%2==0,i);}));
-        ::check_equal(s, {0,2,4,6,8});
-        auto j = insert(s, 10);
-        CHECK(j.first == prev(s.end()));
-        CHECK(j.second == true);
-        ::check_equal(s, {0,2,4,6,8,10});
-
-        insert(views::ref(s), 12);
-        ::check_equal(s, {0,2,4,6,8,10,12});
-    }
-
-    {
-        const std::size_t N = 1024;
-        vector_like<int> vl;
-        insert(vl, vl.end(), views::iota(0, int{N}));
-        CHECK(vl.reservation_count == 1u);
-        CHECK(vl.last_reservation == N);
-        auto r = views::iota(0, int{2 * N});
-        insert(vl, vl.begin() + 42, begin(r), end(r));
-        CHECK(vl.reservation_count == 2u);
-        CHECK(vl.last_reservation == 3 * N);
-        int i = 42;
-        insert(vl, vl.end(), &i, &i + 1);
-        CHECK(vl.reservation_count == 3u);
-        CHECK(vl.last_reservation > 3 * N + 1);
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/action/join.cpp b/src/contrib/range-v3-0.11.0/test/action/join.cpp
deleted file mode 100644
index 4c8c6a49..00000000
--- a/src/contrib/range-v3-0.11.0/test/action/join.cpp
+++ /dev/null
@@ -1,34 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-
-#include <vector>
-#include <string>
-#include <range/v3/core.hpp>
-#include <range/v3/action/join.hpp>
-#include <range/v3/algorithm/move.hpp>
-#include <range/v3/algorithm/equal.hpp>
-#include <range/v3/view/transform.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    std::vector<std::string> v {"hello"," ","world"};
-    auto s = v | move | actions::join;
-    static_assert(std::is_same<decltype(s), std::string>::value, "");
-    CHECK(s == "hello world");
-
-    auto s2 = v | views::transform(views::all) | actions::join;
-    static_assert(std::is_same<decltype(s2), std::vector<char>>::value, "");
-    CHECK(std::string(s2.begin(), s2.end()) == "hello world");
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/action/push_back.cpp b/src/contrib/range-v3-0.11.0/test/action/push_back.cpp
deleted file mode 100644
index 955f4713..00000000
--- a/src/contrib/range-v3-0.11.0/test/action/push_back.cpp
+++ /dev/null
@@ -1,100 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-
-#include <list>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/take.hpp>
-#include <range/v3/view/for_each.hpp>
-#include <range/v3/action/push_back.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    {
-        std::vector<int> v;
-        push_back(v, {1,2,3});
-        ::check_equal(v, {1,2,3});
-
-        push_back(v, views::iota(10) | views::take(3));
-        ::check_equal(v, {1,2,3,10,11,12});
-
-        push_back(v, views::iota(10) | views::take(3));
-        ::check_equal(v, {1,2,3,10,11,12,10,11,12});
-
-        int rg[] = {9,8,7};
-        push_back(v, rg);
-        ::check_equal(v, {1,2,3,10,11,12,10,11,12,9,8,7});
-        push_back(v, rg);
-        ::check_equal(v, {1,2,3,10,11,12,10,11,12,9,8,7,9,8,7});
-
-        std::list<int> s;
-        push_back(s,
-            views::ints|views::take(10)|views::for_each([](int i){return yield_if(i%2==0,i);}));
-        ::check_equal(s, {0,2,4,6,8});
-        push_back(s, 10);
-        ::check_equal(s, {0,2,4,6,8,10});
-    }
-
-    {
-        std::vector<int> v;
-        v = std::move(v) | push_back({1,2,3});
-        ::check_equal(v, {1,2,3});
-
-        v = std::move(v) | push_back(views::iota(10) | views::take(3));
-        ::check_equal(v, {1,2,3,10,11,12});
-
-        v = std::move(v) | push_back(views::iota(10) | views::take(3));
-        ::check_equal(v, {1,2,3,10,11,12,10,11,12});
-
-        int rg[] = {9,8,7};
-        v = std::move(v) | push_back(rg);
-        ::check_equal(v, {1,2,3,10,11,12,10,11,12,9,8,7});
-        v = std::move(v) | push_back(rg);
-        ::check_equal(v, {1,2,3,10,11,12,10,11,12,9,8,7,9,8,7});
-
-        std::list<int> s;
-        s = std::move(s) | push_back(
-            views::ints|views::take(10)|views::for_each([](int i){return yield_if(i%2==0,i);}));
-        ::check_equal(s, {0,2,4,6,8});
-        s = std::move(s) | push_back(10);
-        ::check_equal(s, {0,2,4,6,8,10});
-    }
-
-    {
-        std::vector<int> v;
-        v |= push_back({1,2,3});
-        ::check_equal(v, {1,2,3});
-
-        v |= push_back(views::iota(10) | views::take(3));
-        ::check_equal(v, {1,2,3,10,11,12});
-
-        v |= push_back(views::iota(10) | views::take(3));
-        ::check_equal(v, {1,2,3,10,11,12,10,11,12});
-
-        int rg[] = {9,8,7};
-        v |= push_back(rg);
-        ::check_equal(v, {1,2,3,10,11,12,10,11,12,9,8,7});
-        v |= push_back(rg);
-        ::check_equal(v, {1,2,3,10,11,12,10,11,12,9,8,7,9,8,7});
-
-        std::list<int> s;
-        s |= push_back(
-            views::ints|views::take(10)|views::for_each([](int i){return yield_if(i%2==0,i);}));
-        ::check_equal(s, {0,2,4,6,8});
-        s |= push_back(10);
-        ::check_equal(s, {0,2,4,6,8,10});
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/action/push_front.cpp b/src/contrib/range-v3-0.11.0/test/action/push_front.cpp
deleted file mode 100644
index 460277ed..00000000
--- a/src/contrib/range-v3-0.11.0/test/action/push_front.cpp
+++ /dev/null
@@ -1,100 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-
-#include <list>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/take.hpp>
-#include <range/v3/view/for_each.hpp>
-#include <range/v3/action/push_front.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    {
-        std::vector<int> v;
-        push_front(v, {1,2,3});
-        ::check_equal(v, {1,2,3});
-
-        push_front(v, views::iota(10) | views::take(3));
-        ::check_equal(v, {10,11,12,1,2,3});
-
-        push_front(v, views::iota(10) | views::take(3));
-        ::check_equal(v, {10,11,12,10,11,12,1,2,3});
-
-        int rg[] = {9,8,7};
-        push_front(v, rg);
-        ::check_equal(v, {9,8,7,10,11,12,10,11,12,1,2,3});
-        push_front(v, rg);
-        ::check_equal(v, {9,8,7,9,8,7,10,11,12,10,11,12,1,2,3});
-
-        std::list<int> s;
-        push_front(s,
-            views::ints|views::take(10)|views::for_each([](int i){return yield_if(i%2==0,i);}));
-        ::check_equal(s, {0,2,4,6,8});
-        push_front(s, -2);
-        ::check_equal(s, {-2,0,2,4,6,8});
-    }
-
-    {
-        std::vector<int> v;
-        v = std::move(v) | push_front({1,2,3});
-        ::check_equal(v, {1,2,3});
-
-        v = std::move(v) | push_front(views::iota(10) | views::take(3));
-        ::check_equal(v, {10,11,12,1,2,3});
-
-        v = std::move(v) | push_front(views::iota(10) | views::take(3));
-        ::check_equal(v, {10,11,12,10,11,12,1,2,3});
-
-        int rg[] = {9,8,7};
-        v = std::move(v) | push_front(rg);
-        ::check_equal(v, {9,8,7,10,11,12,10,11,12,1,2,3});
-        v = std::move(v) | push_front(rg);
-        ::check_equal(v, {9,8,7,9,8,7,10,11,12,10,11,12,1,2,3});
-
-        std::list<int> s;
-        s = std::move(s) | push_front(
-            views::ints|views::take(10)|views::for_each([](int i){return yield_if(i%2==0,i);}));
-        ::check_equal(s, {0,2,4,6,8});
-        s = std::move(s) | push_front(-2);
-        ::check_equal(s, {-2,0,2,4,6,8});
-    }
-
-    {
-        std::vector<int> v;
-        v |= push_front({1,2,3});
-        ::check_equal(v, {1,2,3});
-
-        v |= push_front(views::iota(10) | views::take(3));
-        ::check_equal(v, {10,11,12,1,2,3});
-
-        v |= push_front(views::iota(10) | views::take(3));
-        ::check_equal(v, {10,11,12,10,11,12,1,2,3});
-
-        int rg[] = {9,8,7};
-        v |= push_front(rg);
-        ::check_equal(v, {9,8,7,10,11,12,10,11,12,1,2,3});
-        v |= push_front(rg);
-        ::check_equal(v, {9,8,7,9,8,7,10,11,12,10,11,12,1,2,3});
-
-        std::list<int> s;
-        s |= push_front(
-            views::ints|views::take(10)|views::for_each([](int i){return yield_if(i%2==0,i);}));
-        ::check_equal(s, {0,2,4,6,8});
-        s |= push_front(-2);
-        ::check_equal(s, {-2,0,2,4,6,8});
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/action/remove.cpp b/src/contrib/range-v3-0.11.0/test/action/remove.cpp
deleted file mode 100644
index 4e7fc18c..00000000
--- a/src/contrib/range-v3-0.11.0/test/action/remove.cpp
+++ /dev/null
@@ -1,68 +0,0 @@
-// Range v3 library
-//
-//  Copyright Andrey Diduh 2019
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <vector>
-#include <string>
-#include <range/v3/action/remove.hpp>
-
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-using namespace ranges;
-
-struct Data
-{
-    int i;
-
-    Data() = default;
-    explicit Data(int j) : i(j) {}
-
-    bool operator==(const Data& other) const {
-        return other.i == i;
-    }
-    bool operator!=(const Data& other) const {
-        return other.i != i;
-    }
-};
-
-void simple_test()
-{
-    std::vector<Data> list;
-    list.emplace_back(Data{1});
-    list.emplace_back(Data{2});
-    list.emplace_back(Data{3});
-    list.emplace_back(Data{4});
-
-    Data d2{2};
-
-    const auto remove_data = actions::remove(d2);
-
-    list |= remove_data;
-    check_equal(list, {Data{1}, Data{3}, Data{4}});
-
-    list |= actions::remove(3, &Data::i);
-    check_equal(list, {Data{1}, Data{4}});
-}
-
-void string_test()
-{
-    std::vector<std::string> list = {"aaa", "bbb", "ccc"};
-    list |= actions::remove("bbb");
-    check_equal(list, {"aaa", "ccc"});
-}
-
-int main()
-{
-    simple_test();
-    string_test();
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/action/remove_if.cpp b/src/contrib/range-v3-0.11.0/test/action/remove_if.cpp
deleted file mode 100644
index ec64e284..00000000
--- a/src/contrib/range-v3-0.11.0/test/action/remove_if.cpp
+++ /dev/null
@@ -1,32 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/algorithm/move.hpp>
-#include <range/v3/action/sort.hpp>
-#include <range/v3/action/remove_if.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    auto v = views::ints(1,21) | to<std::vector>();
-    auto & v2 = actions::remove_if(v, [](int i){return i % 2 == 0;});
-    CHECK(&v2 == &v);
-    check_equal(v, {1,3,5,7,9,11,13,15,17,19});
-
-    auto && v3 = v | move | actions::remove_if(std::bind(std::less<int>{}, std::placeholders::_1, 10));
-    check_equal(v3, {11,13,15,17,19});
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/action/reverse.cpp b/src/contrib/range-v3-0.11.0/test/action/reverse.cpp
deleted file mode 100644
index b16ee3fc..00000000
--- a/src/contrib/range-v3-0.11.0/test/action/reverse.cpp
+++ /dev/null
@@ -1,35 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/repeat_n.hpp>
-#include <range/v3/view/for_each.hpp>
-#include <range/v3/action/reverse.hpp>
-#include <range/v3/action/unique.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-using namespace ranges;
-
-int main()
-{
-    // [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,...]
-    auto v =
-        views::for_each(views::ints(1,6), [](int i){
-            return yield_from(views::repeat_n(i,i));
-        }) | to<std::vector>();
-    check_equal(v, {1,2,2,3,3,3,4,4,4,4,5,5,5,5,5});
-
-    v |= actions::unique | actions::reverse;
-    check_equal(v, {5,4,3,2,1});
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/action/shuffle.cpp b/src/contrib/range-v3-0.11.0/test/action/shuffle.cpp
deleted file mode 100644
index 51f33007..00000000
--- a/src/contrib/range-v3-0.11.0/test/action/shuffle.cpp
+++ /dev/null
@@ -1,70 +0,0 @@
-// Range v3 library
-//
-//  Copyright Filip Matzner 2015
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-
-#include <vector>
-#include <random>
-#include <range/v3/core.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/stride.hpp>
-#include <range/v3/algorithm/copy.hpp>
-#include <range/v3/algorithm/move.hpp>
-#include <range/v3/algorithm/is_sorted.hpp>
-#include <range/v3/algorithm/equal.hpp>
-#include <range/v3/algorithm/sort.hpp>
-#include <range/v3/action/shuffle.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-    std::mt19937 gen;
-
-    // "Ints" view vs. shuffled
-    auto v = views::ints(0,100) | to<std::vector>();
-    auto v2 = v | copy | actions::shuffle(gen);
-    CHECK(is_sorted(v));
-    CHECK(!is_sorted(v2));
-    CHECK(size(v2) == size(v));
-    CPP_assert(same_as<decltype(v), decltype(v2)>);
-    CHECK(!equal(v, v2));
-
-    // "Ints" view vs. shuffled and sorted
-    sort(v2);
-    CHECK(is_sorted(v2));
-    CHECK(equal(v, v2));
-
-    // Shuffled vs. shuffled
-    v |= actions::shuffle(gen);
-    v2 = v2 | move | actions::shuffle(gen);
-    CHECK(!is_sorted(v));
-    CHECK(!is_sorted(v2));
-    CHECK(size(v2) == size(v));
-    CHECK(!equal(v, v2));
-
-    // Container algorithms can also be called directly
-    // in which case they take and return by reference
-    v = views::ints(0,100) | to<std::vector>();
-    auto & v3 = actions::shuffle(v, gen);
-    CHECK(!is_sorted(v));
-    CHECK(&v3 == &v);
-
-    // Create and shuffle container reference
-    v = views::ints(0,100) | to<std::vector>();
-    auto r = views::ref(v);
-    r |= actions::shuffle(gen);
-    CHECK(!is_sorted(v));
-
-    // Can pipe a view to a "container" algorithm.
-    v = views::ints(0,100) | to<std::vector>();
-    v | views::stride(2) | actions::shuffle(gen);
-    CHECK(!is_sorted(v));
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/action/slice.cpp b/src/contrib/range-v3-0.11.0/test/action/slice.cpp
deleted file mode 100644
index ff01398e..00000000
--- a/src/contrib/range-v3-0.11.0/test/action/slice.cpp
+++ /dev/null
@@ -1,71 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-
-#include <array>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/stride.hpp>
-#include <range/v3/algorithm/copy.hpp>
-#include <range/v3/algorithm/move.hpp>
-#include <range/v3/algorithm/equal.hpp>
-#include <range/v3/action/slice.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-    {
-        auto v = views::ints(0, 100) | to<std::vector>();
-
-        auto v2 = v | copy | actions::slice(10, 20);
-        CHECK(size(v2) == 10u);
-        CPP_assert(same_as<decltype(v), decltype(v2)>);
-        ::check_equal(v2, {10, 11, 12, 13, 14, 15, 16, 17, 18, 19});
-
-        v2 = v2 | move | actions::slice(2, 8);
-        ::check_equal(v2, {12, 13, 14, 15, 16, 17});
-
-        v2 |= actions::slice(0, 0);
-        CHECK(v2.size() == 0u);
-
-        auto &v3 = actions::slice(v, 90, 100);
-        CHECK(&v3 == &v);
-        ::check_equal(v, {90, 91, 92, 93, 94, 95, 96, 97, 98, 99});
-    }
-
-    {
-        auto rng = views::ints(0, 100) | to<std::vector>();
-
-        rng |= actions::slice(20, end - 70);
-        CHECK(size(rng) == 10u);
-        ::check_equal(rng, {20, 21, 22, 23, 24, 25, 26, 27, 28, 29});
-
-        rng |= actions::slice(end - 10, end - 5);
-        CHECK(size(rng) == 5u);
-        ::check_equal(rng, {20, 21, 22, 23, 24});
-    }
-
-    {
-        auto rng = views::ints(0, 100) | to<std::vector>();
-
-        auto &rng_copy = actions::slice(rng, 90, end);
-        CHECK(&rng_copy == &rng);
-        CHECK(size(rng_copy) == 10u);
-        ::check_equal(rng, {90, 91, 92, 93, 94, 95, 96, 97, 98, 99});
-
-        rng |= actions::slice(end - 5, end);
-        CHECK(&rng_copy == &rng);
-        CHECK(size(rng_copy) == 5u);
-        ::check_equal(rng, {95, 96, 97, 98, 99});
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/action/sort.cpp b/src/contrib/range-v3-0.11.0/test/action/sort.cpp
deleted file mode 100644
index 8c6ef67f..00000000
--- a/src/contrib/range-v3-0.11.0/test/action/sort.cpp
+++ /dev/null
@@ -1,69 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-
-#include <array>
-#include <random>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/stride.hpp>
-#include <range/v3/view/take.hpp>
-#include <range/v3/algorithm/shuffle.hpp>
-#include <range/v3/algorithm/copy.hpp>
-#include <range/v3/algorithm/move.hpp>
-#include <range/v3/algorithm/is_sorted.hpp>
-#include <range/v3/algorithm/equal.hpp>
-#include <range/v3/action/shuffle.hpp>
-#include <range/v3/action/sort.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-    std::mt19937 gen;
-
-    auto v = views::ints(0,100) | to<std::vector>();
-    v |= actions::shuffle(gen);
-    CHECK(!is_sorted(v));
-
-    auto v2 = v | copy | actions::sort;
-    CHECK(size(v2) == size(v));
-    CHECK(is_sorted(v2));
-    CHECK(!is_sorted(v));
-    CPP_assert(same_as<decltype(v), decltype(v2)>);
-
-    v |= actions::sort;
-    CHECK(is_sorted(v));
-
-    v |= actions::shuffle(gen);
-    CHECK(!is_sorted(v));
-
-    v = v | move | actions::sort(std::less<int>());
-    CHECK(is_sorted(v));
-    CHECK(equal(v, v2));
-
-    // Container algorithms can also be called directly
-    // in which case they take and return by reference
-    shuffle(v, gen);
-    CHECK(!is_sorted(v));
-    auto & v3 = actions::sort(v);
-    CHECK(is_sorted(v));
-    CHECK(&v3 == &v);
-
-    auto r = views::ref(v);
-    r |= actions::sort;
-
-    // Can pipe a view to a "container" algorithm.
-    actions::sort(v, std::greater<int>());
-    v | views::stride(2) | actions::sort;
-    check_equal(views::take(v, 10), {1,98,3,96,5,94,7,92,9,90});
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/action/split.cpp b/src/contrib/range-v3-0.11.0/test/action/split.cpp
deleted file mode 100644
index 57d439e7..00000000
--- a/src/contrib/range-v3-0.11.0/test/action/split.cpp
+++ /dev/null
@@ -1,139 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-
-#include <cctype>
-#include <string>
-#include <vector>
-
-#include <range/v3/action/split.hpp>
-#include <range/v3/action/split_when.hpp>
-#include <range/v3/algorithm/move.hpp>
-#include <range/v3/core.hpp>
-#include <range/v3/view/c_str.hpp>
-#include <range/v3/view/iota.hpp>
-
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    {
-        auto v = views::ints(1, 21) | to<std::vector>();
-        std::vector<std::vector<int>> rgv = actions::split(v, 10);
-        CHECK(rgv.size() == 2u);
-        ::check_equal(rgv[0], {1,2,3,4,5,6,7,8,9});
-        ::check_equal(rgv[1], {11,12,13,14,15,16,17,18,19,20});
-
-        using I = std::vector<int>::iterator;
-        std::vector<std::vector<int>> rgv2 = actions::split_when(
-            v, [](I b, I) { return std::make_pair(0 == (*b) % 2, next(b)); });
-        CHECK(rgv2.size() == 10u);
-        ::check_equal(rgv2[0], {1});
-        ::check_equal(rgv2[1], {3});
-        ::check_equal(rgv2[2], {5});
-        ::check_equal(rgv2[3], {7});
-        ::check_equal(rgv2[4], {9});
-        ::check_equal(rgv2[5], {11});
-        ::check_equal(rgv2[6], {13});
-        ::check_equal(rgv2[7], {15});
-        ::check_equal(rgv2[8], {17});
-        ::check_equal(rgv2[9], {19});
-    }
-
-    {
-        std::string s{"This is his face"};
-        std::vector<std::string> rgs = actions::split(s, views::c_str(" "));
-        CHECK(rgs.size() == 4u);
-        CHECK(rgs[0] == "This");
-        CHECK(rgs[1] == "is");
-        CHECK(rgs[2] == "his");
-        CHECK(rgs[3] == "face");
-    }
-
-    {
-        std::string s{"This is his face"};
-        std::vector<std::string> rgs = std::move(s) | actions::split(views::c_str(" "));
-        CHECK(rgs.size() == 4u);
-        CHECK(rgs[0] == "This");
-        CHECK(rgs[1] == "is");
-        CHECK(rgs[2] == "his");
-        CHECK(rgs[3] == "face");
-    }
-
-    {
-        std::string s{"This is his face"};
-        char ch[] =  {' '};
-        std::vector<std::string> rgs = actions::split(s, ch);
-        CHECK(rgs.size() == 4u);
-        CHECK(rgs[0] == "This");
-        CHECK(rgs[1] == "is");
-        CHECK(rgs[2] == "his");
-        CHECK(rgs[3] == "face");
-    }
-
-    {
-        std::string s{"This is his face"};
-        char ch[] =  {' '};
-        std::vector<std::string> rgs = std::move(s) | actions::split(ch);
-        CHECK(rgs.size() == 4u);
-        CHECK(rgs[0] == "This");
-        CHECK(rgs[1] == "is");
-        CHECK(rgs[2] == "his");
-        CHECK(rgs[3] == "face");
-    }
-
-    {
-        auto rgi = views::ints(1,21);
-        std::vector<std::vector<int>> rgv3 = actions::split(rgi, 10);
-        CHECK(rgv3.size() == 2u);
-        ::check_equal(rgv3[0], {1,2,3,4,5,6,7,8,9});
-        ::check_equal(rgv3[1], {11,12,13,14,15,16,17,18,19,20});
-    }
-
-    {
-        auto rgi = views::ints(1,21);
-        std::vector<std::vector<int>> rgv3 = std::move(rgi) | actions::split(10);
-        CHECK(rgv3.size() == 2u);
-        ::check_equal(rgv3[0], {1,2,3,4,5,6,7,8,9});
-        ::check_equal(rgv3[1], {11,12,13,14,15,16,17,18,19,20});
-    }
-
-    {
-        std::string str("now  is \t the\ttime");
-        auto toks = actions::split_when(str, +[](int i) { return std::isspace(i); });
-        static_assert(std::is_same<decltype(toks), std::vector<std::string>>::value, "");
-        CHECK(toks.size() == 4u);
-        if(toks.size() == 4u)
-        {
-            CHECK(toks[0] == "now");
-            CHECK(toks[1] == "is");
-            CHECK(toks[2] == "the");
-            CHECK(toks[3] == "time");
-        }
-    }
-
-    {
-        std::string str("now  is \t the\ttime");
-        auto toks =
-            std::move(str) | actions::split_when(+[](int i) { return std::isspace(i); });
-        static_assert(std::is_same<decltype(toks), std::vector<std::string>>::value, "");
-        CHECK(toks.size() == 4u);
-        if(toks.size() == 4u)
-        {
-            CHECK(toks[0] == "now");
-            CHECK(toks[1] == "is");
-            CHECK(toks[2] == "the");
-            CHECK(toks[3] == "time");
-        }
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/action/stable_sort.cpp b/src/contrib/range-v3-0.11.0/test/action/stable_sort.cpp
deleted file mode 100644
index 1cc5303e..00000000
--- a/src/contrib/range-v3-0.11.0/test/action/stable_sort.cpp
+++ /dev/null
@@ -1,88 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-
-#include <array>
-#include <random>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/stride.hpp>
-#include <range/v3/view/take.hpp>
-#include <range/v3/algorithm/shuffle.hpp>
-#include <range/v3/algorithm/copy.hpp>
-#include <range/v3/algorithm/move.hpp>
-#include <range/v3/algorithm/is_sorted.hpp>
-#include <range/v3/algorithm/equal.hpp>
-#include <range/v3/action/shuffle.hpp>
-#include <range/v3/action/stable_sort.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-#if !defined(__clang__) || !defined(_MSVC_STL_VERSION) // Avoid #890
-void test_bug632()
-{
-    const std::vector<double> scores = { 3.0, 1.0, 2.0 };
-    std::vector<int> indices = { 0, 1, 2 };
-
-    indices |= ranges::actions::stable_sort(
-        ranges::less{},
-        [&] (const int &x) { return scores[ (std::size_t)x ]; }
-    );
-
-    ::check_equal( indices, {1, 2, 0} );
-}
-
-int main()
-{
-    using namespace ranges;
-    std::mt19937 gen;
-
-    auto v = views::ints(0,100) | to<std::vector>();
-    v |= actions::shuffle(gen);
-    CHECK(!is_sorted(v));
-
-    auto v2 = v | copy | actions::stable_sort;
-    CHECK(size(v2) == size(v));
-    CHECK(is_sorted(v2));
-    CHECK(!is_sorted(v));
-    CPP_assert(same_as<decltype(v), decltype(v2)>);
-
-    v |= actions::stable_sort;
-    CHECK(is_sorted(v));
-
-    v |= actions::shuffle(gen);
-    CHECK(!is_sorted(v));
-
-    v = v | move | actions::stable_sort(std::less<int>());
-    CHECK(is_sorted(v));
-    CHECK(equal(v, v2));
-
-    // Container algorithms can also be called directly
-    // in which case they take and return by reference
-    shuffle(v, gen);
-    CHECK(!is_sorted(v));
-    auto & v3 = actions::stable_sort(v);
-    CHECK(is_sorted(v));
-    CHECK(&v3 == &v);
-
-    auto r = views::ref(v);
-    r |= actions::stable_sort;
-
-    // Can pipe a view to a "container" algorithm.
-    actions::stable_sort(v, std::greater<int>());
-    v | views::stride(2) | actions::stable_sort;
-    check_equal(views::take(v, 10), {1,98,3,96,5,94,7,92,9,90});
-
-    test_bug632();
-
-    return ::test_result();
-}
-#else // Avoid #890
-int main() {}
-#endif // Avoid #890
diff --git a/src/contrib/range-v3-0.11.0/test/action/stride.cpp b/src/contrib/range-v3-0.11.0/test/action/stride.cpp
deleted file mode 100644
index a1d46171..00000000
--- a/src/contrib/range-v3-0.11.0/test/action/stride.cpp
+++ /dev/null
@@ -1,47 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-
-#include <array>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/algorithm/copy.hpp>
-#include <range/v3/algorithm/move.hpp>
-#include <range/v3/algorithm/equal.hpp>
-#include <range/v3/action/stride.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    auto v = views::ints(0,100) | to<std::vector>();
-
-    auto v2 = v | copy | actions::stride(10);
-    CHECK(size(v2) == 10u);
-    CPP_assert(same_as<decltype(v), decltype(v2)>);
-    ::check_equal(v2, {0,10,20,30,40,50,60,70,80,90});
-
-    v2 = v2 | move | actions::stride(4);
-    ::check_equal(v2, {0,40,80});
-
-    v2 |= actions::stride(2);
-    ::check_equal(v2, {0,80});
-    v2 |= actions::stride(1);
-    ::check_equal(v2, {0,80});
-    v2 |= actions::stride(10);
-    ::check_equal(v2, {0});
-
-    auto & v3 = actions::stride(v, 30);
-    CHECK(&v3 == &v);
-    ::check_equal(v, {0,30,60,90});
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/action/take.cpp b/src/contrib/range-v3-0.11.0/test/action/take.cpp
deleted file mode 100644
index 3f89ef09..00000000
--- a/src/contrib/range-v3-0.11.0/test/action/take.cpp
+++ /dev/null
@@ -1,43 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/algorithm/move.hpp>
-#include <range/v3/action/take.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    auto v = views::ints(1,21) | to<std::vector>();
-    auto & v2 = actions::take(v, 17);
-    CHECK(&v2 == &v);
-    CHECK(v.size() == 17u);
-    CHECK(v.back() == 17);
-
-    v = std::move(v) | actions::take(14);
-    CHECK(v.size() == 14u);
-    CHECK(v.back() == 14);
-
-    v |= actions::take(11);
-    CHECK(v.size() == 11u);
-    CHECK(v.back() == 11);
-
-    v |= actions::take(100);
-    CHECK(v.size() == 11u);
-
-    v |= actions::take(0);
-    CHECK(v.size() == 0u);
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/action/take_while.cpp b/src/contrib/range-v3-0.11.0/test/action/take_while.cpp
deleted file mode 100644
index 8fd3db4f..00000000
--- a/src/contrib/range-v3-0.11.0/test/action/take_while.cpp
+++ /dev/null
@@ -1,44 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/algorithm/move.hpp>
-#include <range/v3/action/take_while.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-    using namespace std::placeholders;
-
-    auto v = views::ints(1,21) | to<std::vector>();
-    auto & v2 = actions::take_while(v, std::bind(std::less<int>(), _1, 18));
-    CHECK(&v2 == &v);
-    CHECK(v.size() == 17u);
-    CHECK(v.back() == 17);
-
-    v = std::move(v) | actions::take_while([](int i){return i < 15;});
-    CHECK(v.size() == 14u);
-    CHECK(v.back() == 14);
-
-    v |= actions::take_while([](int i){return i < 12;});
-    CHECK(v.size() == 11u);
-    CHECK(v.back() == 11);
-
-    v |= actions::take_while([](int){return true;});
-    CHECK(v.size() == 11u);
-
-    v |= actions::take_while([](int){return false;});
-    CHECK(v.size() == 0u);
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/action/transform.cpp b/src/contrib/range-v3-0.11.0/test/action/transform.cpp
deleted file mode 100644
index 5b3920dd..00000000
--- a/src/contrib/range-v3-0.11.0/test/action/transform.cpp
+++ /dev/null
@@ -1,35 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-
-#include <array>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/algorithm/copy.hpp>
-#include <range/v3/algorithm/move.hpp>
-#include <range/v3/algorithm/equal.hpp>
-#include <range/v3/action/transform.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    auto v = views::ints(0,10) | to<std::vector>();
-
-    auto v0 = v | copy | actions::transform([](int i){return i*i;});
-    CPP_assert(same_as<decltype(v), decltype(v0)>);
-    ::check_equal(v0, {0,1,4,9,16,25,36,49,64,81});
-
-    actions::transform(v, [](int i){return i*i;});
-    ::check_equal(v, {0,1,4,9,16,25,36,49,64,81});
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/action/unique.cpp b/src/contrib/range-v3-0.11.0/test/action/unique.cpp
deleted file mode 100644
index 8881ea96..00000000
--- a/src/contrib/range-v3-0.11.0/test/action/unique.cpp
+++ /dev/null
@@ -1,44 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-
-#include <random>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/repeat_n.hpp>
-#include <range/v3/view/for_each.hpp>
-#include <range/v3/view/take.hpp>
-#include <range/v3/algorithm/shuffle.hpp>
-#include <range/v3/algorithm/equal.hpp>
-#include <range/v3/algorithm/is_sorted.hpp>
-#include <range/v3/action/shuffle.hpp>
-#include <range/v3/action/sort.hpp>
-#include <range/v3/action/unique.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-    std::mt19937 gen;
-
-    // [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,...]
-    auto v =
-        views::for_each(views::ints(1,100), [](int i){
-            return yield_from(views::repeat_n(i,i));
-        }) | to<std::vector>();
-    check_equal(views::take(v, 15), {1,2,2,3,3,3,4,4,4,4,5,5,5,5,5});
-    v |= actions::shuffle(gen);
-    CHECK(!is_sorted(v));
-
-    v |= actions::sort | actions::unique;
-    CHECK(equal(v, views::ints(1,100)));
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/action/unstable_remove_if.cpp b/src/contrib/range-v3-0.11.0/test/action/unstable_remove_if.cpp
deleted file mode 100644
index 0aa8c4ac..00000000
--- a/src/contrib/range-v3-0.11.0/test/action/unstable_remove_if.cpp
+++ /dev/null
@@ -1,222 +0,0 @@
-// Range v3 library
-//
-//  Copyright Andrey Diduh 2019
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <vector>
-#include <cstdlib>
-#include <ctime>
-#include <random>
-
-#include <range/v3/action/unstable_remove_if.hpp>
-#include <range/v3/action/remove_if.hpp>
-#include <range/v3/action/sort.hpp>
-
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-void logic_test()
-{
-    using namespace ranges;
-
-    const auto make_vector = []() -> std::vector<int> {
-        return {1,2,3,4,5};
-    };
-
-    // empty
-    {
-        std::vector<int> vec;
-        vec |= actions::unstable_remove_if([](int) { return true; });
-        CHECK(vec.empty());
-    }
-
-    // all stay
-    {
-        std::vector<int> vec = make_vector();
-        vec |= actions::unstable_remove_if([](int) { return false; });
-        check_equal(vec, {1,2,3,4,5});
-    }
-
-    // all remove
-    {
-        std::vector<int> vec = make_vector();
-        vec |= actions::unstable_remove_if([](int) { return true; });
-        CHECK(vec.empty());
-    }
-
-    // remove one in the middle
-    {
-        std::vector<int> vec = make_vector();
-        vec |= actions::unstable_remove_if([](int i) { return i == 2; });
-        check_equal(vec, {1,5,3,4});
-    }
-
-    // remove first
-    {
-        std::vector<int> vec = make_vector();
-        vec |= actions::unstable_remove_if([](int i) { return i == 1; });
-        check_equal(vec, {5,2,3,4});
-    }
-
-    // remove last
-    {
-        std::vector<int> vec = make_vector();
-        vec |= actions::unstable_remove_if([](int i) { return i == 5; });
-        check_equal(vec, {1,2,3,4});
-    }
-
-    // remove group in the middle
-    {
-        std::vector<int> vec = make_vector();
-        vec |= actions::unstable_remove_if([](int i) { return i == 2 || i == 3 || i == 4; });
-        check_equal(vec, {1,5});
-    }
-
-    // remove group in the begin
-    {
-        std::vector<int> vec = make_vector();
-        vec |= actions::unstable_remove_if([](int i) { return i == 1 || i == 2 || i == 3; });
-        check_equal(vec, {5,4});
-    }
-
-    // remove group in the end
-    {
-        std::vector<int> vec = make_vector();
-        vec |= actions::unstable_remove_if([](int i) { return i == 3 || i == 4 || i == 5; });
-        check_equal(vec, {1,2});
-    }
-
-    // remains one in the middle
-    {
-        std::vector<int> vec = make_vector();
-        vec |= actions::unstable_remove_if([](int i) { return i != 3; });
-        check_equal(vec, {3});
-    }
-    // remains group in the middle
-    {
-        std::vector<int> vec = make_vector();
-        vec |= actions::unstable_remove_if([](int i) { return (i != 3) && (i != 4); });
-        check_equal(vec, {4,3});
-    }
-}
-
-class fuzzy_test_fn
-{
-    int size;
-#if defined(__GLIBCXX__) && defined(RANGES_WORKAROUND_VALGRIND_RDRAND)
-    std::random_device rd{"/dev/urandom"};
-#else
-    std::random_device rd;
-#endif
-    std::mt19937 eng{rd()};
-    std::uniform_int_distribution<int> distr;
-
-public:
-    explicit fuzzy_test_fn(int sz)
-      : size(sz)
-      , distr{0, sz}
-    {}
-
-    void operator()()
-    {
-        struct Int
-        {
-            int value;
-
-            explicit Int(int v)
-              : value(v)
-            {}
-            Int(Int const &) = default;
-            Int(Int&& other) noexcept
-              : value(0)
-            {
-                *this = std::move(other);
-            }
-
-            Int &operator=(Int const &) = default;
-            Int &operator=(Int&& other) noexcept
-            {
-                const int sentinel = -1;
-                CHECK(other.value != sentinel);
-
-                value = other.value;
-                other.value = sentinel;
-                return *this;
-            }
-
-            RANGES_DIAGNOSTIC_PUSH
-            RANGES_DIAGNOSTIC_IGNORE_UNNEEDED_MEMBER
-            bool operator==(Int const &other) const
-            {
-                return value == other.value;
-            }
-            bool operator!=(Int const &other) const
-            {
-                return value != other.value;
-            }
-            bool operator<(Int const &other) const
-            {
-                return value < other.value;
-            }
-            bool operator>(Int const &other) const
-            {
-                return value > other.value;
-            }
-            bool operator<=(Int const &other) const
-            {
-                return value <= other.value;
-            }
-            bool operator>=(Int const &other) const
-            {
-                return value >= other.value;
-            }
-            RANGES_DIAGNOSTIC_POP
-        };
-
-        using namespace ranges;
-        std::vector<Int> ordered_list;
-        std::vector<Int> unordered_list;
-
-        // fill
-        for(int i=0; i < size; ++i)
-        {
-            ordered_list.emplace_back(i);
-            unordered_list.emplace_back(i);
-        }
-
-        // erase
-        const int erase_count = distr(eng);
-        for(int i=0; i < erase_count; ++i)
-        {
-            const int value = distr(eng);
-            const auto pred = [value](Int j) { return j.value == value; };
-            unordered_list |= actions::unstable_remove_if(pred);
-            ordered_list |= actions::remove_if(pred);
-        }
-
-        // compare
-        unordered_list |= actions::sort;
-        CHECK(ordered_list == unordered_list);
-    }
-};
-
-int main()
-{
-    logic_test();
-
-    {
-        const int size = 100;
-        const int repeats = 1000;
-        fuzzy_test_fn fuzzy_test(size);
-        for(int i=0; i < repeats; ++i)
-            fuzzy_test();
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/CMakeLists.txt b/src/contrib/range-v3-0.11.0/test/algorithm/CMakeLists.txt
deleted file mode 100644
index b59e0ce3..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/CMakeLists.txt
+++ /dev/null
@@ -1,113 +0,0 @@
-set(CMAKE_FOLDER "${CMAKE_FOLDER}/algorithm")
-
-rv3_add_test(test.alg.adjacent_find alg.adjacent_find adjacent_find.cpp)
-rv3_add_test(test.alg.adjacent_remove_if alg.adjacent_remove_if adjacent_remove_if.cpp)
-rv3_add_test(test.alg.all_of alg.all_of all_of.cpp)
-rv3_add_test(test.alg.any_of alg.any_of any_of.cpp)
-rv3_add_test(test.alg.none_of alg.none_of none_of.cpp)
-rv3_add_test(test.alg.binary_search alg.binary_search binary_search.cpp)
-rv3_add_test(test.alg.contains alg.contains contains.cpp)
-rv3_add_test(test.alg.copy alg.copy copy.cpp)
-rv3_add_test(test.alg.copy_backward alg.copy_backward copy_backward.cpp)
-rv3_add_test(test.alg.count alg.count count.cpp)
-rv3_add_test(test.alg.count_if alg.count_if count_if.cpp)
-rv3_add_test(test.alg.ends_with alg.ends_with ends_with.cpp)
-rv3_add_test(test.alg.equal alg.equal equal.cpp)
-rv3_add_test(test.alg.equal_range alg.equal_range equal_range.cpp)
-rv3_add_test(test.alg.fill alg.fill fill.cpp)
-rv3_add_test(test.alg.find alg.find find.cpp)
-rv3_add_test(test.alg.find_end alg.find_end find_end.cpp)
-rv3_add_test(test.alg.find_if alg.find_if find_if.cpp)
-rv3_add_test(test.alg.find_first_of alg.find_first_of find_first_of.cpp)
-rv3_add_test(test.alg.for_each alg.for_each for_each.cpp)
-rv3_add_test(test.alg.for_each_n alg.for_each_n for_each_n.cpp)
-rv3_add_test(test.alg.generate alg.generate generate.cpp)
-rv3_add_test(test.alg.generate_n alg.generate_n generate_n.cpp)
-rv3_add_test(test.alg.includes alg.includes includes.cpp)
-rv3_add_test(test.alg.inplace_merge alg.inplace_merge inplace_merge.cpp)
-rv3_add_test(test.alg.is_heap1 alg.is_heap1 is_heap1.cpp)
-rv3_add_test(test.alg.is_heap2 alg.is_heap2 is_heap2.cpp)
-rv3_add_test(test.alg.is_heap3 alg.is_heap3 is_heap3.cpp)
-rv3_add_test(test.alg.is_heap4 alg.is_heap4 is_heap4.cpp)
-rv3_add_test(test.alg.is_heap_until1 alg.is_heap_until1 is_heap_until1.cpp)
-rv3_add_test(test.alg.is_heap_until2 alg.is_heap_until2 is_heap_until2.cpp)
-rv3_add_test(test.alg.is_heap_until3 alg.is_heap_until3 is_heap_until3.cpp)
-rv3_add_test(test.alg.is_heap_until4 alg.is_heap_until4 is_heap_until4.cpp)
-rv3_add_test(test.alg.is_partitioned alg.is_partitioned is_partitioned.cpp)
-rv3_add_test(test.alg.is_permutation alg.is_permutation is_permutation.cpp)
-rv3_add_test(test.alg.is_sorted_until alg.is_sorted_until is_sorted_until.cpp)
-rv3_add_test(test.alg.is_sorted alg.is_sorted is_sorted.cpp)
-rv3_add_test(test.alg.lexicographical_compare alg.lexicographical_compare lexicographical_compare.cpp)
-rv3_add_test(test.alg.lower_bound alg.lower_bound lower_bound.cpp)
-rv3_add_test(test.alg.make_heap alg.make_heap make_heap.cpp)
-rv3_add_test(test.alg.max alg.max max.cpp)
-rv3_add_test(test.alg.max_element alg.max_element max_element.cpp)
-rv3_add_test(test.alg.merge alg.merge merge.cpp)
-rv3_add_test(test.alg.min alg.min min.cpp)
-rv3_add_test(test.alg.min_element alg.min_element min_element.cpp)
-rv3_add_test(test.alg.minmax alg.minmax minmax.cpp)
-rv3_add_test(test.alg.minmax_element alg.minmax_element minmax_element.cpp)
-rv3_add_test(test.alg.mismatch alg.mismatch mismatch.cpp)
-rv3_add_test(test.alg.move alg.move move.cpp)
-rv3_add_test(test.alg.move_backward alg.move_backward move_backward.cpp)
-rv3_add_test(test.alg.next_permutation alg.next_permutation next_permutation.cpp)
-rv3_add_test(test.alg.nth_element alg.nth_element nth_element.cpp)
-rv3_add_test(test.alg.partial_sort alg.partial_sort partial_sort.cpp)
-rv3_add_test(test.alg.partial_sort_copy alg.partial_sort_copy partial_sort_copy.cpp)
-rv3_add_test(test.alg.partition alg.partition partition.cpp)
-rv3_add_test(test.alg.partition_copy alg.partition_copy partition_copy.cpp)
-rv3_add_test(test.alg.partition_point alg.partition_point partition_point.cpp)
-rv3_add_test(test.alg.pop_heap alg.pop_heap pop_heap.cpp)
-rv3_add_test(test.alg.prev_permutation alg.prev_permutation prev_permutation.cpp)
-rv3_add_test(test.alg.push_heap alg.push_heap push_heap.cpp)
-rv3_add_test(test.alg.remove alg.remove remove.cpp)
-rv3_add_test(test.alg.remove_copy alg.remove_copy remove_copy.cpp)
-rv3_add_test(test.alg.remove_copy_if alg.remove_copy_if remove_copy_if.cpp)
-rv3_add_test(test.alg.remove_if alg.remove_if remove_if.cpp)
-rv3_add_test(test.alg.replace alg.replace replace.cpp)
-rv3_add_test(test.alg.replace_copy alg.replace_copy replace_copy.cpp)
-rv3_add_test(test.alg.replace_copy_if alg.replace_copy_if replace_copy_if.cpp)
-rv3_add_test(test.alg.replace_if alg.replace_if replace_if.cpp)
-rv3_add_test(test.alg.reverse alg.reverse reverse.cpp)
-rv3_add_test(test.alg.reverse_copy alg.reverse_copy reverse_copy.cpp)
-rv3_add_test(test.alg.rotate alg.rotate rotate.cpp)
-rv3_add_test(test.alg.rotate_copy alg.rotate_copy rotate_copy.cpp)
-rv3_add_test(test.alg.sample alg.sample sample.cpp)
-rv3_add_test(test.alg.search alg.search search.cpp)
-rv3_add_test(test.alg.search_n alg.search_n search_n.cpp)
-rv3_add_test(test.alg.set_difference1 alg.set_difference1 set_difference1.cpp)
-rv3_add_test(test.alg.set_difference2 alg.set_difference2 set_difference2.cpp)
-rv3_add_test(test.alg.set_difference3 alg.set_difference3 set_difference3.cpp)
-rv3_add_test(test.alg.set_difference4 alg.set_difference4 set_difference4.cpp)
-rv3_add_test(test.alg.set_difference5 alg.set_difference5 set_difference5.cpp)
-rv3_add_test(test.alg.set_difference6 alg.set_difference6 set_difference6.cpp)
-rv3_add_test(test.alg.set_intersection1 alg.set_intersection1 set_intersection1.cpp)
-rv3_add_test(test.alg.set_intersection2 alg.set_intersection2 set_intersection2.cpp)
-rv3_add_test(test.alg.set_intersection3 alg.set_intersection3 set_intersection3.cpp)
-rv3_add_test(test.alg.set_intersection4 alg.set_intersection4 set_intersection4.cpp)
-rv3_add_test(test.alg.set_intersection5 alg.set_intersection5 set_intersection5.cpp)
-rv3_add_test(test.alg.set_intersection6 alg.set_intersection6 set_intersection6.cpp)
-rv3_add_test(test.alg.set_symmetric_difference1 alg.set_symmetric_difference1 set_symmetric_difference1.cpp)
-rv3_add_test(test.alg.set_symmetric_difference2 alg.set_symmetric_difference2 set_symmetric_difference2.cpp)
-rv3_add_test(test.alg.set_symmetric_difference3 alg.set_symmetric_difference3 set_symmetric_difference3.cpp)
-rv3_add_test(test.alg.set_symmetric_difference4 alg.set_symmetric_difference4 set_symmetric_difference4.cpp)
-rv3_add_test(test.alg.set_symmetric_difference5 alg.set_symmetric_difference5 set_symmetric_difference5.cpp)
-rv3_add_test(test.alg.set_symmetric_difference6 alg.set_symmetric_difference6 set_symmetric_difference6.cpp)
-rv3_add_test(test.alg.set_union1 alg.set_union1 set_union1.cpp)
-rv3_add_test(test.alg.set_union2 alg.set_union2 set_union2.cpp)
-rv3_add_test(test.alg.set_union3 alg.set_union3 set_union3.cpp)
-rv3_add_test(test.alg.set_union4 alg.set_union4 set_union4.cpp)
-rv3_add_test(test.alg.set_union5 alg.set_union5 set_union5.cpp)
-rv3_add_test(test.alg.set_union6 alg.set_union6 set_union6.cpp)
-rv3_add_test(test.alg.shuffle alg.shuffle shuffle.cpp)
-rv3_add_test(test.alg.sort alg.sort sort.cpp)
-rv3_add_test(test.alg.sort_heap alg.sort_heap sort_heap.cpp)
-rv3_add_test(test.alg.stable_partition alg.stable_partition stable_partition.cpp)
-rv3_add_test(test.alg.stable_sort alg.stable_sort stable_sort.cpp)
-rv3_add_test(test.alg.starts_with alg.starts_with starts_with.cpp)
-rv3_add_test(test.alg.swap_ranges alg.swap_ranges swap_ranges.cpp)
-rv3_add_test(test.alg.transform alg.transform transform.cpp)
-rv3_add_test(test.alg.unique alg.unique unique.cpp)
-rv3_add_test(test.alg.unique_copy alg.unique_copy unique_copy.cpp)
-rv3_add_test(test.alg.upper_bound alg.upper_bound upper_bound.cpp)
-rv3_add_test(test.alg.sort_n_with_buffer alg.sort_n_with_buffer sort_n_with_buffer.cpp)
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/adjacent_find.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/adjacent_find.cpp
deleted file mode 100644
index b6e96414..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/adjacent_find.cpp
+++ /dev/null
@@ -1,30 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/adjacent_find.hpp>
-#include "../simple_test.hpp"
-
-int main()
-{
-    int v1[] = { 0, 2, 2, 4, 6 };
-    CHECK(ranges::adjacent_find(ranges::begin(v1), ranges::end(v1)) == &v1[1]);
-    CHECK(ranges::adjacent_find(v1) == &v1[1]);
-
-    std::pair<int, int> v2[] = {{0, 0}, {0, 2}, {0, 2}, {0, 4}, {0, 6}};
-    CHECK(ranges::adjacent_find(ranges::begin(v2), ranges::end(v2),
-        ranges::equal_to{}, &std::pair<int, int>::second) == &v2[1]);
-    CHECK(ranges::adjacent_find(v2, ranges::equal_to{}, &std::pair<int, int>::second) == &v2[1]);
-    static_assert(std::is_same<std::pair<int,int>*,
-                               decltype(ranges::adjacent_find(v2, ranges::equal_to{},
-                                    &std::pair<int, int>::second))>::value, "");
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/adjacent_remove_if.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/adjacent_remove_if.cpp
deleted file mode 100644
index 6afec2d5..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/adjacent_remove_if.cpp
+++ /dev/null
@@ -1,197 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler
-//  Copyright Christopher Di Bella
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-#include <range/v3/algorithm/adjacent_remove_if.hpp>
-#include <range/v3/core.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-template<class Iter, class Sent = Iter>
-void
-test_iter()
-{
-   int ia[] = {0, 1, 1, 1, 4, 2, 2, 4, 2};
-   constexpr auto sa = ranges::size(ia);
-   Iter r = ranges::adjacent_remove_if(Iter(ia), Sent(ia+sa), ranges::equal_to{});
-   CHECK(base(r) == ia + sa-3);
-   CHECK(ia[0] == 0);
-   CHECK(ia[1] == 1);
-   CHECK(ia[2] == 4);
-   CHECK(ia[3] == 2);
-   CHECK(ia[4] == 4);
-   CHECK(ia[5] == 2);
-}
-
-template<class Iter, class Sent = Iter>
-void
-test_range()
-{
-    int ia[] = {0, 1, 1, 1, 4, 2, 2, 4, 2};
-    constexpr auto sa = ranges::size(ia);
-    Iter r = ranges::adjacent_remove_if(
-        ranges::make_subrange(Iter(ia), Sent(ia+sa)),
-        ranges::equal_to{});
-    CHECK(base(r) == ia + sa-3);
-    CHECK(ia[0] == 0);
-    CHECK(ia[1] == 1);
-    CHECK(ia[2] == 4);
-    CHECK(ia[3] == 2);
-    CHECK(ia[4] == 4);
-    CHECK(ia[5] == 2);
-}
-
-struct pred
-{
-    bool operator()(const std::unique_ptr<int> &i, const std::unique_ptr<int> &j)
-    {
-        return *i == 2 && *j == 3;
-    }
-};
-
-template<class Iter, class Sent = Iter>
-void
-test_iter_rvalue()
-{
-    constexpr unsigned sa = 9;
-    std::unique_ptr<int> ia[sa];
-    ia[0].reset(new int(0));
-    ia[1].reset(new int(1));
-    ia[2].reset(new int(2));
-    ia[3].reset(new int(3));
-    ia[4].reset(new int(4));
-    ia[5].reset(new int(2));
-    ia[6].reset(new int(3));
-    ia[7].reset(new int(4));
-    ia[8].reset(new int(2));
-    Iter r = ranges::adjacent_remove_if(Iter(ia), Sent(ia+sa), pred());
-    CHECK(base(r) == ia + sa-2);
-    CHECK(*ia[0] == 0);
-    CHECK(*ia[1] == 1);
-    CHECK(*ia[2] == 3);
-    CHECK(*ia[3] == 4);
-    CHECK(*ia[4] == 3);
-    CHECK(*ia[5] == 4);
-    CHECK(*ia[6] == 2);
-}
-
-template<class Iter, class Sent = Iter>
-void
-test_range_rvalue()
-{
-    constexpr unsigned sa = 9;
-    std::unique_ptr<int> ia[sa];
-    ia[0].reset(new int(0));
-    ia[1].reset(new int(1));
-    ia[2].reset(new int(2));
-    ia[3].reset(new int(3));
-    ia[4].reset(new int(4));
-    ia[5].reset(new int(2));
-    ia[6].reset(new int(3));
-    ia[7].reset(new int(4));
-    ia[8].reset(new int(2));
-    Iter r = ranges::adjacent_remove_if(ranges::make_subrange(Iter(ia), Sent(ia+sa)), pred());
-    CHECK(base(r) == ia + sa-2);
-    CHECK(*ia[0] == 0);
-    CHECK(*ia[1] == 1);
-    CHECK(*ia[2] == 3);
-    CHECK(*ia[3] == 4);
-    CHECK(*ia[4] == 3);
-    CHECK(*ia[5] == 4);
-    CHECK(*ia[6] == 2);
-}
-
-struct S
-{
-    int i;
-};
-
-int main()
-{
-    test_iter<ForwardIterator<int*> >();
-    test_iter<BidirectionalIterator<int*> >();
-    test_iter<RandomAccessIterator<int*> >();
-    test_iter<int*>();
-    test_iter<ForwardIterator<int*>, Sentinel<int*>>();
-    test_iter<BidirectionalIterator<int*>, Sentinel<int*>>();
-    test_iter<RandomAccessIterator<int*>, Sentinel<int*>>();
-    test_range<ForwardIterator<int*> >();
-    test_range<BidirectionalIterator<int*> >();
-    test_range<RandomAccessIterator<int*> >();
-    test_range<int*>();
-    test_range<ForwardIterator<int*>, Sentinel<int*>>();
-    test_range<BidirectionalIterator<int*>, Sentinel<int*>>();
-    test_range<RandomAccessIterator<int*>, Sentinel<int*>>();
-
-    test_iter_rvalue<ForwardIterator<std::unique_ptr<int>*> >();
-    test_iter_rvalue<BidirectionalIterator<std::unique_ptr<int>*> >();
-    test_iter_rvalue<RandomAccessIterator<std::unique_ptr<int>*> >();
-    test_iter_rvalue<std::unique_ptr<int>*>();
-    test_iter_rvalue<ForwardIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*>>();
-    test_iter_rvalue<BidirectionalIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*>>();
-    test_iter_rvalue<RandomAccessIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*>>();
-
-    test_range_rvalue<ForwardIterator<std::unique_ptr<int>*> >();
-    test_range_rvalue<BidirectionalIterator<std::unique_ptr<int>*> >();
-    test_range_rvalue<RandomAccessIterator<std::unique_ptr<int>*> >();
-    test_range_rvalue<std::unique_ptr<int>*>();
-    test_range_rvalue<ForwardIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*>>();
-    test_range_rvalue<BidirectionalIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*>>();
-    test_range_rvalue<RandomAccessIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*>>();
-
-    {
-        // Check projection
-        S ia[] = {S{0}, S{1}, S{1}, S{1}, S{4}, S{2}, S{2}, S{4}, S{2}};
-        constexpr auto sa = ranges::size(ia);
-        S* r = ranges::adjacent_remove_if(ia, ranges::equal_to{}, &S::i);
-        CHECK(r == ia + sa-3);
-        CHECK(ia[0].i == 0);
-        CHECK(ia[1].i == 1);
-        CHECK(ia[2].i == 4);
-        CHECK(ia[3].i == 2);
-        CHECK(ia[4].i == 4);
-        CHECK(ia[5].i == 2);
-    }
-
-    {
-        // Check rvalue range
-        S ia[] = {S{0}, S{1}, S{1}, S{2}, S{3}, S{5}, S{8}, S{13}, S{21}};
-        constexpr auto sa = ranges::size(ia);
-        using namespace std::placeholders;
-        auto r = ranges::adjacent_remove_if(
-            ranges::views::all(ia),
-            [](int x, int y) noexcept { return (x + y) % 2 == 0; },
-            &S::i);
-        CHECK(r == ia + sa-3);
-        CHECK(ia[0].i == 0);
-        CHECK(ia[1].i == 1);
-        CHECK(ia[2].i == 2);
-        CHECK(ia[3].i == 5);
-        CHECK(ia[4].i == 8);
-        CHECK(ia[5].i == 21);
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/all_of.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/all_of.cpp
deleted file mode 100644
index 928ea0e6..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/all_of.cpp
+++ /dev/null
@@ -1,62 +0,0 @@
-// Range v3 library
-//
-//  Copyright Andrew Sutton 2014
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/all_of.hpp>
-#include "../simple_test.hpp"
-
-bool even(int n) { return n % 2 == 0; }
-
-struct S {
-  S(bool p) : test(p) { }
-
-  bool p() const { return test; }
-
-  bool test;
-};
-
-int main()
-{
-  std::vector<int> all_even { 0, 2, 4, 6 };
-  std::vector<int> one_even { 1, 3, 4, 7 };
-  std::vector<int> none_even { 1, 3, 5, 7 };
-  CHECK(ranges::all_of(all_even.begin(), all_even.end(), even));
-  CHECK(!ranges::all_of(one_even.begin(), one_even.end(), even));
-  CHECK(!ranges::all_of(none_even.begin(), none_even.end(), even));
-
-  CHECK(ranges::all_of(all_even, even));
-  CHECK(!ranges::all_of(one_even, even));
-  CHECK(!ranges::all_of(none_even, even));
-
-  using ILI = std::initializer_list<int>;
-  CHECK(ranges::all_of(ILI{0, 2, 4, 6}, [](int n) { return n % 2 == 0; }));
-  CHECK(!ranges::all_of(ILI{1, 3, 4, 7}, [](int n) { return n % 2 == 0; }));
-  CHECK(!ranges::all_of(ILI{1, 3, 5, 7}, [](int n) { return n % 2 == 0; }));
-
-  std::vector<S> all_true { true, true, true };
-  std::vector<S> one_true { false, false, true };
-  std::vector<S> none_true { false, false, false };
-  CHECK(ranges::all_of(all_true.begin(), all_true.end(), &S::p));
-  CHECK(!ranges::all_of(one_true.begin(), one_true.end(), &S::p));
-  CHECK(!ranges::all_of(none_true.begin(), none_true.end(), &S::p));
-
-  CHECK(ranges::all_of(all_true, &S::p));
-  CHECK(!ranges::all_of(one_true, &S::p));
-  CHECK(!ranges::all_of(none_true, &S::p));
-
-  using ILS = std::initializer_list<S>;
-  CHECK(ranges::all_of(ILS{S(true), S(true), S(true)}, &S::p));
-  CHECK(!ranges::all_of(ILS{S(false), S(true), S(false)}, &S::p));
-  CHECK(!ranges::all_of(ILS{S(false), S(false), S(false)}, &S::p));
-
-  return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/any_of.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/any_of.cpp
deleted file mode 100644
index 8e09d8fa..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/any_of.cpp
+++ /dev/null
@@ -1,63 +0,0 @@
-// Range v3 library
-//
-//  Copyright Andrew Sutton 2014
-//  Copyright Gonzalo Brito Gadeschi 2014
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/any_of.hpp>
-#include "../simple_test.hpp"
-
-bool even(int n) { return n % 2 == 0; }
-
-struct S {
-  S(bool p) : test(p) { }
-
-  bool p() const { return test; }
-
-  bool test;
-};
-
-int main()
-{
-  std::vector<int> all_even { 0, 2, 4, 6 };
-  std::vector<int> one_even { 1, 3, 4, 7 };
-  std::vector<int> none_even { 1, 3, 5, 7 };
-  CHECK(ranges::any_of(all_even.begin(), all_even.end(), even));
-  CHECK(ranges::any_of(one_even.begin(), one_even.end(), even));
-  CHECK(!ranges::any_of(none_even.begin(), none_even.end(), even));
-
-  CHECK(ranges::any_of(all_even, even));
-  CHECK(ranges::any_of(one_even, even));
-  CHECK(!ranges::any_of(none_even, even));
-
-  using ILI = std::initializer_list<int>;
-  CHECK(ranges::any_of(ILI{0, 2, 4, 6}, [](int n) { return n % 2 == 0; }));
-  CHECK(ranges::any_of(ILI{1, 3, 4, 7}, [](int n) { return n % 2 == 0; }));
-  CHECK(!ranges::any_of(ILI{1, 3, 5, 7}, [](int n) { return n % 2 == 0; }));
-
-  std::vector<S> all_true { true, true, true };
-  std::vector<S> one_true { false, false, true };
-  std::vector<S> none_true { false, false, false };
-  CHECK(ranges::any_of(all_true.begin(), all_true.end(), &S::p));
-  CHECK(ranges::any_of(one_true.begin(), one_true.end(), &S::p));
-  CHECK(!ranges::any_of(none_true.begin(), none_true.end(), &S::p));
-
-  CHECK(ranges::any_of(all_true, &S::p));
-  CHECK(ranges::any_of(one_true, &S::p));
-  CHECK(!ranges::any_of(none_true, &S::p));
-
-  using ILS = std::initializer_list<S>;
-  CHECK(ranges::any_of(ILS{S(true), S(true), S(true)}, &S::p));
-  CHECK(ranges::any_of(ILS{S(false), S(true), S(false)}, &S::p));
-  CHECK(!ranges::any_of(ILS{S(false), S(false), S(false)}, &S::p));
-
-  return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/binary_search.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/binary_search.cpp
deleted file mode 100644
index 7cff68e0..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/binary_search.cpp
+++ /dev/null
@@ -1,54 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-#include <utility>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/binary_search.hpp>
-#include "../simple_test.hpp"
-
-int main()
-{
-    using ranges::begin;
-    using ranges::end;
-    using ranges::size;
-    using ranges::less;
-
-    std::pair<int, int> a[] = {{0, 0}, {0, 1}, {1, 2}, {1, 3}, {3, 4}, {3, 5}};
-    const std::pair<int, int> c[] = {{0, 0}, {0, 1}, {1, 2}, {1, 3}, {3, 4}, {3, 5}};
-
-    CHECK(ranges::binary_search(begin(a), end(a), a[0]));
-    CHECK(ranges::binary_search(begin(a), end(a), a[1], less()));
-    CHECK(ranges::binary_search(begin(a), end(a), 1, less(), &std::pair<int, int>::first));
-
-    CHECK(ranges::binary_search(a, a[2]));
-    CHECK(ranges::binary_search(c, c[3]));
-
-    CHECK(ranges::binary_search(a, a[4], less()));
-    CHECK(ranges::binary_search(c, c[5], less()));
-
-    CHECK(ranges::binary_search(a, 1, less(), &std::pair<int, int>::first));
-    CHECK(ranges::binary_search(c, 1, less(), &std::pair<int, int>::first));
-
-    CHECK(ranges::binary_search(a, 0, less(), &std::pair<int, int>::first));
-    CHECK(ranges::binary_search(c, 0, less(), &std::pair<int, int>::first));
-
-    CHECK(!ranges::binary_search(a, -1, less(), &std::pair<int, int>::first));
-    CHECK(!ranges::binary_search(c, -1, less(), &std::pair<int, int>::first));
-
-    CHECK(!ranges::binary_search(a, 4, less(), &std::pair<int, int>::first));
-    CHECK(!ranges::binary_search(c, 4, less(), &std::pair<int, int>::first));
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/contains.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/contains.cpp
deleted file mode 100644
index a61b529e..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/contains.cpp
+++ /dev/null
@@ -1,39 +0,0 @@
-// Range v3 library
-//
-//  Copyright Johel Guerrero 2019
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#include <range/v3/algorithm/contains.hpp>
-
-#include "../simple_test.hpp"
-
-int main()
-{
-    using ranges::contains;
-
-    constexpr int rng[] = {4, 2};
-    const auto first = rng;
-    const auto last = rng + 2;
-
-    CHECK(!contains(first, first, 0));
-    CHECK(!contains(first, last, 1));
-    CHECK(contains(first, last, 2));
-    CHECK(!contains(first, last, 3));
-    CHECK(contains(first, last, 4));
-
-#ifndef RANGES_WORKAROUND_CLANG_23135
-    static_assert(!contains(rng, 1), "");
-    static_assert(contains(rng, 2), "");
-    static_assert(!contains(rng, 3), "");
-    static_assert(contains(rng, 4), "");
-#endif
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/copy.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/copy.cpp
deleted file mode 100644
index 27f3f091..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/copy.cpp
+++ /dev/null
@@ -1,95 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <vector>
-#include <sstream>
-#include <cstring>
-#include <utility>
-#include <algorithm>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/copy.hpp>
-#include <range/v3/algorithm/equal.hpp>
-#include <range/v3/view/delimit.hpp>
-#include <range/v3/iterator/stream_iterators.hpp>
-#include "../simple_test.hpp"
-#include "../test_iterators.hpp"
-
-#if RANGES_CXX_CONSTEXPR >= RANGES_CXX_CONSTEXPR_14 && RANGES_CONSTEXPR_INVOKE
-constexpr /*c++14*/
-bool test_constexpr_copy()
-{
-    int a[4] = {0, 0, 0, 0};
-    int const b[4] = {1, 2, 3, 4};
-    ranges::copy(b, a);
-    return ranges::equal(b, a);
-}
-
-static_assert(test_constexpr_copy(), "");
-#endif
-
-int main()
-{
-    using ranges::begin;
-    using ranges::end;
-    using ranges::size;
-
-    std::pair<int, int> const a[] = {{0, 0}, {0, 1}, {1, 2}, {1, 3}, {3, 4}, {3, 5}};
-    static_assert(size(a) == 6, "");
-    std::pair<int, int> out[size(a)] = {};
-
-    auto res = ranges::copy(begin(a), end(a), out);
-    CHECK(res.in == end(a));
-    CHECK(res.out == out + size(out));
-    CHECK(std::equal(a, a + size(a), out));
-
-    std::fill_n(out, size(out), std::make_pair(0, 0));
-    CHECK(!std::equal(a, a + size(a), out));
-
-    res = ranges::copy(a, out);
-    CHECK(res.in == a + size(a));
-    CHECK(res.out == out + size(out));
-    CHECK(std::equal(a, a + size(a), out));
-
-    std::fill_n(out, size(out), std::make_pair(0, 0));
-
-    using ranges::views::delimit;
-    {
-        char const *sz = "hello world";
-        char buf[50];
-        auto str = delimit(sz, '\0');
-        auto res3 = ranges::copy(str, buf);
-        *res3.out = '\0';
-        CHECK(res3.in == std::next(begin(str), static_cast<std::ptrdiff_t>(std::strlen(sz))));
-        CHECK(res3.out == buf + std::strlen(sz));
-        CHECK(std::strcmp(sz, buf) == 0);
-    }
-
-    {
-        char const *sz = "hello world";
-        char buf[50];
-        auto str = delimit(sz, '\0');
-        auto res3 = ranges::copy(std::move(str), buf);
-        *res3.out = '\0';
-        CHECK(!::is_dangling(res3.in));
-        CHECK(res3.out == buf + std::strlen(sz));
-        CHECK(std::strcmp(sz, buf) == 0);
-    }
-
-    {
-        using namespace ranges;
-        std::ostringstream sout;
-        std::vector<int> copy_vec{1,1,1,1,1};
-        copy(copy_vec, ostream_iterator<>(sout, " "));
-        CHECK(sout.str() == "1 1 1 1 1 ");
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/copy_backward.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/copy_backward.cpp
deleted file mode 100644
index bb652576..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/copy_backward.cpp
+++ /dev/null
@@ -1,74 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <cstring>
-#include <algorithm>
-#include <utility>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/copy_backward.hpp>
-#include "../simple_test.hpp"
-#include "../test_iterators.hpp"
-
-int main()
-{
-    using ranges::begin;
-    using ranges::end;
-    using ranges::size;
-
-    std::pair<int, int> const a[] = {{0, 0}, {0, 1}, {1, 2}, {1, 3}, {3, 4}, {3, 5}};
-    static_assert(size(a) == 6, "");
-    std::pair<int, int> out[size(a)] = {};
-
-    {
-        auto res = ranges::copy_backward(begin(a), end(a), end(out));
-        CHECK(res.in == end(a));
-        CHECK(res.out == begin(out));
-        CHECK(std::equal(a, a + size(a), out));
-    }
-
-    {
-        std::fill_n(out, size(out), std::make_pair(0, 0));
-        auto res = ranges::copy_backward(a, end(out));
-        CHECK(res.in == end(a));
-        CHECK(res.out == begin(out));
-        CHECK(std::equal(a, a + size(a), out));
-    }
-
-#ifndef RANGES_WORKAROUND_MSVC_573728
-    {
-        std::fill_n(out, size(out), std::make_pair(0, 0));
-        auto res = ranges::copy_backward(std::move(a), end(out));
-        CHECK(::is_dangling(res.in));
-        CHECK(res.out == begin(out));
-        CHECK(std::equal(a, a + size(a), out));
-    }
-#endif
-
-    {
-        std::fill_n(out, size(out), std::make_pair(0, 0));
-        std::vector<std::pair<int, int>> vec(begin(a), end(a));
-        auto res = ranges::copy_backward(std::move(vec), end(out));
-        CHECK(::is_dangling(res.in));
-        CHECK(res.out == begin(out));
-        CHECK(std::equal(a, a + size(a), out));
-    }
-
-    {
-        std::fill_n(out, size(out), std::make_pair(0, 0));
-        auto res = ranges::copy_backward(ranges::views::all(a), end(out));
-        CHECK(res.in == end(a));
-        CHECK(res.out == begin(out));
-        CHECK(std::equal(a, a + size(a), out));
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/count.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/count.cpp
deleted file mode 100644
index 30d7a5c8..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/count.cpp
+++ /dev/null
@@ -1,61 +0,0 @@
-// Range v3 library
-//
-//  Copyright Andrew Sutton 2014
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/count.hpp>
-#include "../simple_test.hpp"
-#include "../test_iterators.hpp"
-
-struct S
-{
-    int i;
-};
-
-int main()
-{
-    using namespace ranges;
-
-    int ia[] = {0, 1, 2, 2, 0, 1, 2, 3};
-    constexpr auto cia = size(ia);
-
-    CHECK(count(InputIterator<const int*>(ia),
-                Sentinel<const int*>(ia + cia), 2) == 3);
-    CHECK(count(InputIterator<const int*>(ia),
-                Sentinel<const int*>(ia + cia), 7) == 0);
-    CHECK(count(InputIterator<const int*>(ia),
-                Sentinel<const int*>(ia), 2) == 0);
-
-    CHECK(count(make_subrange(InputIterator<const int*>(ia),
-                      Sentinel<const int*>(ia + cia)), 2) == 3);
-    CHECK(count(make_subrange(InputIterator<const int*>(ia),
-                      Sentinel<const int*>(ia + cia)), 7) == 0);
-    CHECK(count(make_subrange(InputIterator<const int*>(ia),
-                      Sentinel<const int*>(ia)), 2) == 0);
-
-    S sa[] = {{0}, {1}, {2}, {2}, {0}, {1}, {2}, {3}};
-    constexpr auto csa = size(ia);
-
-    CHECK(count(InputIterator<const S*>(sa),
-                Sentinel<const S*>(sa + csa), 2, &S::i) == 3);
-    CHECK(count(InputIterator<const S*>(sa),
-                Sentinel<const S*>(sa + csa), 7, &S::i) == 0);
-    CHECK(count(InputIterator<const S*>(sa),
-                Sentinel<const S*>(sa), 2, &S::i) == 0);
-
-    CHECK(count(make_subrange(InputIterator<const S*>(sa),
-                      Sentinel<const S*>(sa + csa)), 2, &S::i) == 3);
-    CHECK(count(make_subrange(InputIterator<const S*>(sa),
-                      Sentinel<const S*>(sa + csa)), 7, &S::i) == 0);
-    CHECK(count(make_subrange(InputIterator<const S*>(sa),
-                      Sentinel<const S*>(sa)), 2, &S::i) == 0);
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/count_if.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/count_if.cpp
deleted file mode 100644
index dc04dc7f..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/count_if.cpp
+++ /dev/null
@@ -1,78 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/count_if.hpp>
-#include "../simple_test.hpp"
-#include "../test_iterators.hpp"
-
-struct S
-{
-    int i;
-};
-
-struct T
-{
-    bool b;
-    bool m() { return b; }
-};
-
-int main()
-{
-    using namespace ranges;
-    auto equals = [](int i){ return std::bind(equal_to{}, i, std::placeholders::_1); };
-
-    int ia[] = {0, 1, 2, 2, 0, 1, 2, 3};
-    constexpr auto cia = size(ia);
-
-    CHECK(count_if(InputIterator<const int*>(ia),
-                   Sentinel<const int*>(ia + cia), equals(2)) == 3);
-    CHECK(count_if(InputIterator<const int*>(ia),
-                   Sentinel<const int*>(ia + cia), equals(7)) == 0);
-    CHECK(count_if(InputIterator<const int*>(ia),
-                   Sentinel<const int*>(ia), equals(2)) == 0);
-
-    CHECK(count_if(make_subrange(InputIterator<const int*>(ia),
-                         Sentinel<const int*>(ia + cia)), equals(2)) == 3);
-    CHECK(count_if(make_subrange(InputIterator<const int*>(ia),
-                         Sentinel<const int*>(ia + cia)), equals(7)) == 0);
-    CHECK(count_if(make_subrange(InputIterator<const int*>(ia),
-                         Sentinel<const int*>(ia)), equals(2)) == 0);
-
-    S sa[] = {{0}, {1}, {2}, {2}, {0}, {1}, {2}, {3}};
-    constexpr auto csa = size(ia);
-
-    CHECK(count_if(InputIterator<const S*>(sa),
-                   Sentinel<const S*>(sa + csa), equals(2), &S::i) == 3);
-    CHECK(count_if(InputIterator<const S*>(sa),
-                   Sentinel<const S*>(sa + csa), equals(7), &S::i) == 0);
-    CHECK(count_if(InputIterator<const S*>(sa),
-                   Sentinel<const S*>(sa), equals(2), &S::i) == 0);
-
-    CHECK(count_if(make_subrange(InputIterator<const S*>(sa),
-                         Sentinel<const S*>(sa + csa)), equals(2), &S::i) == 3);
-    CHECK(count_if(make_subrange(InputIterator<const S*>(sa),
-                         Sentinel<const S*>(sa + csa)), equals(7), &S::i) == 0);
-    CHECK(count_if(make_subrange(InputIterator<const S*>(sa),
-                         Sentinel<const S*>(sa)), equals(2), &S::i) == 0);
-
-    T ta[] = {{true}, {false}, {true}, {false}, {false}, {true}, {false}, {false}, {true}, {false}};
-    CHECK(count_if(InputIterator<T*>(ta),
-                   Sentinel<T*>(ta + size(ta)), &T::m) == 4);
-    CHECK(count_if(InputIterator<T*>(ta),
-                   Sentinel<T*>(ta + size(ta)), &T::b) == 4);
-    CHECK(count_if(make_subrange(InputIterator<T*>(ta),
-                         Sentinel<T*>(ta + size(ta))), &T::m) == 4);
-    CHECK(count_if(make_subrange(InputIterator<T*>(ta),
-                         Sentinel<T*>(ta + size(ta))), &T::b) == 4);
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/ends_with.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/ends_with.cpp
deleted file mode 100644
index 596a187f..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/ends_with.cpp
+++ /dev/null
@@ -1,111 +0,0 @@
-// Range v3 library
-//
-//  Copyright Johel Guerrero 2019
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#include <initializer_list>
-#include <range/v3/algorithm/ends_with.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/view/subrange.hpp>
-#include "../simple_test.hpp"
-#include "../test_iterators.hpp"
-
-int comparison_count = 0;
-
-template<typename T>
-bool counting_equals(const T &a, const T &b)
-{
-    ++comparison_count;
-    return a == b;
-}
-
-int main()
-{
-    using namespace ranges;
-    int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
-    constexpr auto as = distance(ia);
-    int ib[] = {5, 6, 7, 8, 9};
-    constexpr auto bs = distance(ib);
-    CHECK(ends_with(RandomAccessIterator<const int*>(ia),
-                     RandomAccessIterator<const int*>(ia + as),
-                     RandomAccessIterator<const int*>(ib),
-                     RandomAccessIterator<const int*>(ib + bs)));
-    CHECK(!ends_with(InputIterator<const int*>(ia),
-                      InputIterator<const int*, true>(ia + as),
-                      InputIterator<const int*>(ib),
-                      InputIterator<const int*, true>(ib + bs - 1)));
-    CHECK(!ends_with(ForwardIterator<const int*>(ia),
-                      Sentinel<const int*>(ia + as),
-                      ForwardIterator<const int*>(ib),
-                      Sentinel<const int*>(ib + bs - 1)));
-    CHECK(!ends_with(make_subrange(RandomAccessIterator<const int*>(ia),
-                      RandomAccessIterator<const int*>(ia + as)),
-                      make_subrange(RandomAccessIterator<const int*>(ib),
-                      RandomAccessIterator<const int*>(ib + bs - 1))));
-    CHECK(ends_with(make_subrange(InputIterator<const int*>(ia),
-                     InputIterator<const int*, true>(ia + as)),
-                     make_subrange(InputIterator<const int*>(ib),
-                     InputIterator<const int*, true>(ib + bs))));
-    CHECK(ends_with(make_subrange(ForwardIterator<const int*>(ia),
-                     Sentinel<const int*>(ia + as)),
-                     make_subrange(ForwardIterator<const int*>(ib),
-                     Sentinel<const int*>(ib + bs))));
-    comparison_count = 0;
-    CHECK(!ends_with(RandomAccessIterator<const int*>(ib),
-                      RandomAccessIterator<const int*>(ib + bs),
-                      RandomAccessIterator<const int*>(ia),
-                      RandomAccessIterator<const int*>(ia + as),
-                      counting_equals<int>));
-    CHECK(comparison_count == 0);
-    comparison_count = 0;
-    CHECK(ends_with(InputIterator<const int*>(ia),
-                     InputIterator<const int*, true>(ia + as),
-                     InputIterator<const int*>(ib),
-                     InputIterator<const int*, true>(ib + bs),
-                     counting_equals<int>));
-    CHECK(comparison_count > 0);
-    comparison_count = 0;
-    CHECK(ends_with(ForwardIterator<const int*>(ia),
-                     Sentinel<const int*>(ia + as),
-                     ForwardIterator<const int*>(ib),
-                     Sentinel<const int*>(ib + bs),
-                     counting_equals<int>));
-    CHECK(comparison_count > 0);
-    comparison_count = 0;
-    CHECK(ends_with(make_subrange(RandomAccessIterator<const int*>(ia),
-                     RandomAccessIterator<const int*>(ia + as)),
-                     make_subrange(RandomAccessIterator<const int*>(ib),
-                     RandomAccessIterator<const int*>(ib + bs)),
-                     counting_equals<int>));
-    CHECK(comparison_count > 0);
-    comparison_count = 0;
-    CHECK(!ends_with(make_subrange(InputIterator<const int*>(ib),
-                      InputIterator<const int*, true>(ib + bs - 1)),
-                      make_subrange(InputIterator<const int*>(ib),
-                      InputIterator<const int*, true>(ib + bs)),
-                      counting_equals<int>));
-    CHECK(comparison_count == 0);
-    comparison_count = 0;
-    CHECK(!ends_with(make_subrange(ForwardIterator<const int*>(ia),
-                      Sentinel<const int*>(ia)),
-                      make_subrange(ForwardIterator<const int*>(ib),
-                      Sentinel<const int*>(ib + bs)),
-                      counting_equals<int>));
-    CHECK(comparison_count == 0);
-
-#if RANGES_CXX_CONSTEXPR >= RANGES_CXX_CONSTEXPR_14 && RANGES_CONSTEXPR_INVOKE
-    using IL = std::initializer_list<int>;
-    static_assert(ends_with(IL{0, 1, 2, 3, 4}, IL{3, 4}), "");
-    static_assert(!ends_with(IL{0, 1, 2, 3, 4}, IL{2, 3}), "");
-    static_assert(ends_with(IL{}, IL{}), "");
-#endif
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/equal.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/equal.cpp
deleted file mode 100644
index 9e03d428..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/equal.cpp
+++ /dev/null
@@ -1,295 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/equal.hpp>
-#include <range/v3/view/unbounded.hpp>
-#include "../simple_test.hpp"
-#include "../test_iterators.hpp"
-
-RANGES_DIAGNOSTIC_IGNORE_DEPRECATED_DECLARATIONS
-
-void test()
-{
-    using namespace ranges;
-    int ia[] = {0, 1, 2, 3, 4, 5};
-    constexpr auto s = size(ia);
-    int ib[s] = {0, 1, 2, 5, 4, 5};
-    CHECK(equal(InputIterator<const int*>(ia),
-                 Sentinel<const int*>(ia+s),
-                 InputIterator<const int*>(ia)));
-    CHECK(equal(InputIterator<const int*>(ia),
-                 Sentinel<const int*>(ia+s),
-                 InputIterator<const int*>(ia),
-                 Sentinel<const int*>(ia+s)));
-    CHECK(equal(RandomAccessIterator<const int*>(ia),
-                 RandomAccessIterator<const int*>(ia+s),
-                 RandomAccessIterator<const int*>(ia),
-                 RandomAccessIterator<const int*>(ia + s)));
-    CHECK(equal(RandomAccessIterator<const int*>(ia),
-                 Sentinel<const int*>(ia+s),
-                 RandomAccessIterator<const int*>(ia),
-                 Sentinel<const int*>(ia + s)));
-    CHECK(!equal(InputIterator<const int*>(ia),
-                  Sentinel<const int*>(ia+s),
-                  InputIterator<const int*>(ib)));
-    CHECK(!equal(InputIterator<const int*>(ia),
-                  Sentinel<const int*>(ia+s),
-                  InputIterator<const int*>(ib),
-                  Sentinel<const int*>(ib + s)));
-    CHECK(!equal(RandomAccessIterator<const int*>(ia),
-                  RandomAccessIterator<const int*>(ia+s),
-                  RandomAccessIterator<const int*>(ib),
-                  RandomAccessIterator<const int*>(ib+s)));
-    CHECK(!equal(RandomAccessIterator<const int*>(ia),
-                  Sentinel<const int*>(ia+s),
-                  RandomAccessIterator<const int*>(ib),
-                  Sentinel<const int*>(ib + s)));
-    CHECK(!equal(InputIterator<const int*>(ia),
-                  Sentinel<const int*>(ia+s),
-                  InputIterator<const int*>(ia),
-                  Sentinel<const int*>(ia + s - 1)));
-    CHECK(!equal(RandomAccessIterator<const int*>(ia),
-                  RandomAccessIterator<const int*>(ia+s),
-                  RandomAccessIterator<const int*>(ia),
-                  RandomAccessIterator<const int*>(ia+s-1)));
-    CHECK(!equal(RandomAccessIterator<const int*>(ia),
-                  Sentinel<const int*>(ia+s),
-                  RandomAccessIterator<const int*>(ia),
-                  Sentinel<const int*>(ia + s - 1)));
-}
-
-void test_rng()
-{
-    using namespace ranges;
-    int ia[] = {0, 1, 2, 3, 4, 5};
-    constexpr auto s = size(ia);
-    int ib[s] = {0, 1, 2, 5, 4, 5};
-    CHECK(equal(make_subrange(InputIterator<const int*>(ia),
-                 Sentinel<const int*>(ia+s)),
-                 InputIterator<const int*>(ia)));
-    CHECK(equal(make_subrange(InputIterator<const int*>(ia),
-                 Sentinel<const int*>(ia+s)),
-                 make_subrange(InputIterator<const int*>(ia),
-                 Sentinel<const int*>(ia+s))));
-    CHECK(equal(make_subrange(RandomAccessIterator<const int*>(ia),
-                 RandomAccessIterator<const int*>(ia+s)),
-                 make_subrange(RandomAccessIterator<const int*>(ia),
-                 RandomAccessIterator<const int*>(ia + s))));
-    CHECK(equal(make_subrange(RandomAccessIterator<const int*>(ia),
-                 Sentinel<const int*>(ia+s)),
-                 make_subrange(RandomAccessIterator<const int*>(ia),
-                 Sentinel<const int*>(ia + s))));
-    CHECK(!equal(make_subrange(InputIterator<const int*>(ia),
-                  Sentinel<const int*>(ia+s)),
-                  InputIterator<const int*>(ib)));
-    CHECK(!equal(make_subrange(InputIterator<const int*>(ia),
-                  Sentinel<const int*>(ia+s)),
-                  make_subrange(InputIterator<const int*>(ib),
-                  Sentinel<const int*>(ib + s))));
-    CHECK(!equal(make_subrange(RandomAccessIterator<const int*>(ia),
-                  RandomAccessIterator<const int*>(ia+s)),
-                  make_subrange(RandomAccessIterator<const int*>(ib),
-                  RandomAccessIterator<const int*>(ib+s))));
-    CHECK(!equal(make_subrange(RandomAccessIterator<const int*>(ia),
-                  Sentinel<const int*>(ia+s)),
-                  make_subrange(RandomAccessIterator<const int*>(ib),
-                  Sentinel<const int*>(ib + s))));
-    CHECK(!equal(make_subrange(InputIterator<const int*>(ia),
-                  Sentinel<const int*>(ia+s)),
-                  make_subrange(InputIterator<const int*>(ia),
-                  Sentinel<const int*>(ia + s - 1))));
-    CHECK(!equal(make_subrange(RandomAccessIterator<const int*>(ia),
-                  RandomAccessIterator<const int*>(ia+s)),
-                  make_subrange(RandomAccessIterator<const int*>(ia),
-                  RandomAccessIterator<const int*>(ia+s-1))));
-    CHECK(!equal(make_subrange(RandomAccessIterator<const int*>(ia),
-                  Sentinel<const int*>(ia+s)),
-                  make_subrange(RandomAccessIterator<const int*>(ia),
-                  Sentinel<const int*>(ia + s - 1))));
-}
-
-int comparison_count = 0;
-
-template<typename T>
-bool counting_equals(const T &a, const T &b)
-{
-    ++comparison_count;
-    return a == b;
-}
-
-void test_pred()
-{
-    using namespace ranges;
-    int ia[] = {0, 1, 2, 3, 4, 5};
-    constexpr auto s = size(ia);
-    int ib[s] = {0, 1, 2, 5, 4, 5};
-    CHECK(equal(InputIterator<const int*>(ia),
-                 Sentinel<const int*>(ia+s),
-                 InputIterator<const int*>(ia),
-                 std::equal_to<int>()));
-    CHECK(equal(InputIterator<const int*>(ia),
-                 Sentinel<const int*>(ia+s),
-                 InputIterator<const int*>(ia),
-                 Sentinel<const int*>(ia + s),
-                 std::equal_to<int>()));
-    CHECK(equal(RandomAccessIterator<const int*>(ia),
-                 RandomAccessIterator<const int*>(ia+s),
-                 RandomAccessIterator<const int*>(ia),
-                 RandomAccessIterator<const int*>(ia+s),
-                 std::equal_to<int>()));
-    CHECK(equal(RandomAccessIterator<const int*>(ia),
-                 Sentinel<const int*>(ia+s),
-                 RandomAccessIterator<const int*>(ia),
-                 Sentinel<const int*>(ia + s),
-                 std::equal_to<int>()));
-
-    comparison_count = 0;
-    CHECK(!equal(InputIterator<const int*>(ia),
-                 Sentinel<const int*>(ia+s),
-                 InputIterator<const int*>(ia),
-                 Sentinel<const int*>(ia + s - 1),
-                 counting_equals<int>));
-    CHECK(comparison_count > 0);
-    comparison_count = 0;
-    CHECK(!equal(RandomAccessIterator<const int*>(ia),
-                 RandomAccessIterator<const int*>(ia+s),
-                 RandomAccessIterator<const int*>(ia),
-                 RandomAccessIterator<const int*>(ia+s-1),
-                 counting_equals<int>));
-    CHECK(comparison_count == 0);
-    comparison_count = 0;
-    CHECK(!equal(RandomAccessIterator<const int*>(ia),
-                 Sentinel<const int*>(ia+s),
-                 RandomAccessIterator<const int*>(ia),
-                 Sentinel<const int*>(ia + s - 1),
-                 counting_equals<int>));
-    CHECK(comparison_count > 0);
-    CHECK(!equal(InputIterator<const int*>(ia),
-                  Sentinel<const int*>(ia+s),
-                  InputIterator<const int*>(ib),
-                  std::equal_to<int>()));
-    CHECK(!equal(InputIterator<const int*>(ia),
-                  Sentinel<const int*>(ia+s),
-                  InputIterator<const int*>(ib),
-                  Sentinel<const int*>(ib + s),
-                  std::equal_to<int>()));
-    CHECK(!equal(RandomAccessIterator<const int*>(ia),
-                  RandomAccessIterator<const int*>(ia+s),
-                  RandomAccessIterator<const int*>(ib),
-                  RandomAccessIterator<const int*>(ib+s),
-                  std::equal_to<int>()));
-    CHECK(!equal(RandomAccessIterator<const int*>(ia),
-                  Sentinel<const int*>(ia+s),
-                  RandomAccessIterator<const int*>(ib),
-                  Sentinel<const int*>(ib + s),
-                  std::equal_to<int>()));
-}
-
-void test_rng_pred()
-{
-    using namespace ranges;
-    int ia[] = {0, 1, 2, 3, 4, 5};
-    constexpr auto s = size(ia);
-    int ib[s] = {0, 1, 2, 5, 4, 5};
-    CHECK(equal(make_subrange(InputIterator<const int*>(ia),
-                 Sentinel<const int*>(ia+s)),
-                 InputIterator<const int*>(ia),
-                 std::equal_to<int>()));
-    CHECK(equal(make_subrange(InputIterator<const int*>(ia),
-                 Sentinel<const int*>(ia+s)),
-                 make_subrange(InputIterator<const int*>(ia),
-                 Sentinel<const int*>(ia + s)),
-                 std::equal_to<int>()));
-    CHECK(equal(make_subrange(RandomAccessIterator<const int*>(ia),
-                 RandomAccessIterator<const int*>(ia+s)),
-                 make_subrange(RandomAccessIterator<const int*>(ia),
-                 RandomAccessIterator<const int*>(ia+s)),
-                 std::equal_to<int>()));
-    CHECK(equal(make_subrange(RandomAccessIterator<const int*>(ia),
-                 Sentinel<const int*>(ia+s)),
-                 make_subrange(RandomAccessIterator<const int*>(ia),
-                 Sentinel<const int*>(ia + s)),
-                 std::equal_to<int>()));
-
-    comparison_count = 0;
-    CHECK(!equal(make_subrange(InputIterator<const int*>(ia),
-                 Sentinel<const int*>(ia+s)),
-                 make_subrange(InputIterator<const int*>(ia),
-                 Sentinel<const int*>(ia + s - 1)),
-                 counting_equals<int>));
-    CHECK(comparison_count > 0);
-    comparison_count = 0;
-    CHECK(!equal(make_subrange(RandomAccessIterator<const int*>(ia),
-                 RandomAccessIterator<const int*>(ia+s)),
-                 make_subrange(RandomAccessIterator<const int*>(ia),
-                 RandomAccessIterator<const int*>(ia+s-1)),
-                 counting_equals<int>));
-    CHECK(comparison_count == 0);
-    comparison_count = 0;
-    CHECK(!equal(make_subrange(RandomAccessIterator<const int*>(ia),
-                 Sentinel<const int*>(ia+s)),
-                 make_subrange(RandomAccessIterator<const int*>(ia),
-                 Sentinel<const int*>(ia + s - 1)),
-                 counting_equals<int>));
-    CHECK(comparison_count > 0);
-    CHECK(!equal(make_subrange(InputIterator<const int*>(ia),
-                  Sentinel<const int*>(ia+s)),
-                  InputIterator<const int*>(ib),
-                  std::equal_to<int>()));
-    CHECK(!equal(make_subrange(InputIterator<const int*>(ia),
-                  Sentinel<const int*>(ia+s)),
-                  make_subrange(InputIterator<const int*>(ib),
-                  Sentinel<const int*>(ib + s)),
-                  std::equal_to<int>()));
-    CHECK(!equal(make_subrange(RandomAccessIterator<const int*>(ia),
-                  RandomAccessIterator<const int*>(ia+s)),
-                  make_subrange(RandomAccessIterator<const int*>(ib),
-                  RandomAccessIterator<const int*>(ib+s)),
-                  std::equal_to<int>()));
-    CHECK(!equal(make_subrange(RandomAccessIterator<const int*>(ia),
-                  Sentinel<const int*>(ia+s)),
-                  make_subrange(RandomAccessIterator<const int*>(ib),
-                  Sentinel<const int*>(ib + s)),
-                  std::equal_to<int>()));
-}
-
-int main()
-{
-    ::test();
-    ::test_rng();
-    ::test_pred();
-    ::test_rng_pred();
-
-    using IL = std::initializer_list<int>;
-    int *p = nullptr;
-    static_assert(std::is_same<bool, decltype(ranges::equal(IL{1, 2, 3, 4}, p))>::value, "");
-    static_assert(std::is_same<bool, decltype(ranges::equal(IL{1, 2, 3, 4}, IL{1, 2, 3, 4}))>::value, "");
-    static_assert(std::is_same<bool, decltype(ranges::equal(IL{1, 2, 3, 4}, ranges::views::unbounded(p)))>::value, "");
-
-#if RANGES_CXX_CONSTEXPR >= RANGES_CXX_CONSTEXPR_14 && RANGES_CONSTEXPR_INVOKE
-    static_assert(ranges::equal(IL{1, 2, 3, 4}, IL{1, 2, 3, 4}), "");
-    static_assert(!ranges::equal(IL{1, 2, 3, 4}, IL{1, 2, 3}), "");
-    static_assert(!ranges::equal(IL{1, 2, 3, 4}, IL{1, 2, 4, 3}), "");
-    static_assert(ranges::equal(IL{}, IL{}), "");
-#endif
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/equal_range.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/equal_range.cpp
deleted file mode 100644
index 005e1cbb..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/equal_range.cpp
+++ /dev/null
@@ -1,120 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <vector>
-#include <iterator>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/copy.hpp>
-#include <range/v3/algorithm/equal_range.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/insert_iterators.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/join.hpp>
-#include <range/v3/view/repeat_n.hpp>
-#include <range/v3/view/take.hpp>
-#include <range/v3/view/transform.hpp>
-#include "../simple_test.hpp"
-#include "../test_iterators.hpp"
-
-struct my_int
-{
-    int value;
-};
-
-bool compare(my_int lhs, my_int rhs)
-{
-    return lhs.value < rhs.value;
-}
-
-void not_totally_ordered()
-{
-    // This better compile!
-    std::vector<my_int> vec;
-    ranges::equal_range(vec, my_int{10}, compare);
-}
-
-template<class Iter, class Sent, class T, class Proj = ranges::identity>
-void
-test(Iter first, Sent last, const T& value, Proj proj = Proj{})
-{
-    ranges::subrange<Iter, Iter> i =
-        ranges::equal_range(first, last, value, ranges::less{}, proj);
-    for (Iter j = first; j != i.begin(); ++j)
-        CHECK(ranges::invoke(proj, *j) < value);
-    for (Iter j = i.begin(); j != last; ++j)
-        CHECK(!(ranges::invoke(proj, *j) < value));
-    for (Iter j = first; j != i.end(); ++j)
-        CHECK(!(value < ranges::invoke(proj, *j)));
-    for (Iter j = i.end(); j != last; ++j)
-        CHECK(value < ranges::invoke(proj, *j));
-
-    auto res = ranges::equal_range(
-        ranges::make_subrange(first, last), value, ranges::less{}, proj);
-    for (Iter j = first; j != res.begin(); ++j)
-        CHECK(ranges::invoke(proj, *j) < value);
-    for (Iter j = res.begin(); j != last; ++j)
-        CHECK(!(ranges::invoke(proj, *j) < value));
-    for (Iter j = first; j != res.end(); ++j)
-        CHECK(!(value < ranges::invoke(proj, *j)));
-    for (Iter j = res.end(); j != last; ++j)
-        CHECK(value < ranges::invoke(proj, *j));
-}
-
-template<class Iter, class Sent = Iter>
-void
-test()
-{
-    using namespace ranges::views;
-    static constexpr unsigned M = 10;
-    std::vector<int> v;
-    auto input = ints | take(100) | transform([](int i){return repeat_n(i,M);}) | join;
-    ranges::copy(input, ranges::back_inserter(v));
-    for (int x = 0; x <= (int)M; ++x)
-        test(Iter(v.data()), Sent(v.data()+v.size()), x);
-}
-
-int main()
-{
-    int d[] = {0, 1, 2, 3};
-    for (int* e = d; e <= d+4; ++e)
-        for (int x = -1; x <= 4; ++x)
-            test(d, e, x);
-
-    test<ForwardIterator<const int*> >();
-    test<BidirectionalIterator<const int*> >();
-    test<RandomAccessIterator<const int*> >();
-    test<const int*>();
-
-    test<ForwardIterator<const int*>, Sentinel<const int*> >();
-    test<BidirectionalIterator<const int*>, Sentinel<const int*> >();
-    test<RandomAccessIterator<const int*>, Sentinel<const int*> >();
-
-    {
-        struct foo { int i; };
-
-        foo some_foos[] = {{1}, {2}, {4}};
-        test(some_foos, some_foos + 3, 2, &foo::i);
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/fill.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/fill.cpp
deleted file mode 100644
index afe10fb2..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/fill.cpp
+++ /dev/null
@@ -1,100 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <cstring>
-#include <string>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/fill.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-template<class Iter, class Sent = Iter>
-void
-test_char()
-{
-    const unsigned n = 4;
-    char ca[n] = {0};
-    auto i = ranges::fill(Iter(ca), Sent(ca+n), char(1));
-    CHECK(ca[0] == 1);
-    CHECK(ca[1] == 1);
-    CHECK(ca[2] == 1);
-    CHECK(ca[3] == 1);
-    CHECK(i == Iter(ca + 4));
-
-    auto rng = ranges::make_subrange(Iter(ca), Sent(ca+n));
-    i = ranges::fill(rng, char(2));
-    CHECK(ca[0] == 2);
-    CHECK(ca[1] == 2);
-    CHECK(ca[2] == 2);
-    CHECK(ca[3] == 2);
-    CHECK(i == Iter(ca + 4));
-
-    auto j = ranges::fill(::MakeTestRange(Iter(ca), Sent(ca+n)), char(3));
-    CHECK(ca[0] == 3);
-    CHECK(ca[1] == 3);
-    CHECK(ca[2] == 3);
-    CHECK(ca[3] == 3);
-    CHECK(::is_dangling(j));
-}
-
-template<class Iter, class Sent = Iter>
-void
-test_int()
-{
-    const unsigned n = 4;
-    int ia[n] = {0};
-    ranges::fill(Iter(ia), Sent(ia+n), 1);
-    CHECK(ia[0] == 1);
-    CHECK(ia[1] == 1);
-    CHECK(ia[2] == 1);
-    CHECK(ia[3] == 1);
-
-    auto rng = ranges::make_subrange(Iter(ia), Sent(ia+n));
-    ranges::fill(rng, 2);
-    CHECK(ia[0] == 2);
-    CHECK(ia[2] == 2);
-    CHECK(ia[2] == 2);
-    CHECK(ia[3] == 2);
-}
-
-int main()
-{
-    test_char<ForwardIterator<char*> >();
-    test_char<BidirectionalIterator<char*> >();
-    test_char<RandomAccessIterator<char*> >();
-    test_char<char*>();
-
-    test_char<ForwardIterator<char*>, Sentinel<char*> >();
-    test_char<BidirectionalIterator<char*>, Sentinel<char*> >();
-    test_char<RandomAccessIterator<char*>, Sentinel<char*> >();
-
-    test_int<ForwardIterator<int*> >();
-    test_int<BidirectionalIterator<int*> >();
-    test_int<RandomAccessIterator<int*> >();
-    test_int<int*>();
-
-    test_int<ForwardIterator<int*>, Sentinel<int*> >();
-    test_int<BidirectionalIterator<int*>, Sentinel<int*> >();
-    test_int<RandomAccessIterator<int*>, Sentinel<int*> >();
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/find.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/find.cpp
deleted file mode 100644
index f1944f3e..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/find.cpp
+++ /dev/null
@@ -1,91 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <utility>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/find.hpp>
-#include "../simple_test.hpp"
-#include "../test_iterators.hpp"
-
-struct S
-{
-    int i_;
-};
-
-int main()
-{
-    using namespace ranges;
-
-    int ia[] = {0, 1, 2, 3, 4, 5};
-    constexpr auto s = size(ia);
-
-    {
-        InputIterator<const int*> r = find(InputIterator<const int*>(ia),
-                                            InputIterator<const int*>(ia+s), 3);
-        CHECK(*r == 3);
-        r = find(InputIterator<const int*>(ia),
-                 InputIterator<const int*>(ia+s), 10);
-        CHECK(r == InputIterator<const int*>(ia+s));
-
-        r = find(InputIterator<const int*>(ia),
-                 Sentinel<const int*>(ia+s), 3);
-        CHECK(*r == 3);
-        r = find(InputIterator<const int*>(ia),
-                 Sentinel<const int*>(ia+s), 10);
-        CHECK(r == InputIterator<const int*>(ia+s));
-    }
-
-    {
-        int *pi = find(ia, 3);
-        CHECK(*pi == 3);
-        pi = find(ia, 10);
-        CHECK(pi == ia+s);
-    }
-
-    {
-#ifndef RANGES_WORKAROUND_MSVC_573728
-        auto pj0 = find(std::move(ia), 3);
-        CHECK(::is_dangling(pj0));
-#endif // RANGES_WORKAROUND_MSVC_573728
-        std::vector<int> vec(begin(ia), end(ia));
-        auto pj1 = find(std::move(vec), 3);
-        CHECK(::is_dangling(pj1));
-        auto pj2 = find(views::all(ia), 10);
-        CHECK(pj2 == ia+s);
-    }
-
-    {
-        S sa[] = {{0}, {1}, {2}, {3}, {4}, {5}};
-        S *ps = find(sa, 3, &S::i_);
-        CHECK(ps->i_ == 3);
-        ps = find(sa, 10, &S::i_);
-        CHECK(ps == end(sa));
-    }
-
-    {
-        // https://github.com/Microsoft/Range-V3-VS2015/issues/9
-        auto vec = std::vector<std::string>{{"a"}, {"b"}, {"c"}};
-        auto it = ranges::find(vec, "b");
-        CHECK(it == vec.begin() + 1);
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/find_end.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/find_end.cpp
deleted file mode 100644
index 7f4f0fde..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/find_end.cpp
+++ /dev/null
@@ -1,296 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <utility>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/find_end.hpp>
-#include "../simple_test.hpp"
-#include "../test_iterators.hpp"
-
-template<class Iter1, class Iter2, typename Sent1 = Iter1, typename Sent2 = Iter2>
-void
-test()
-{
-    using namespace ranges;
-
-    int ia[] = {0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 0, 1, 2, 3, 0, 1, 2, 0, 1, 0};
-    constexpr auto sa = size(ia);
-    int b[] = {0};
-    int c[] = {0, 1};
-    int d[] = {0, 1, 2};
-    int e[] = {0, 1, 2, 3};
-    int f[] = {0, 1, 2, 3, 4};
-    int g[] = {0, 1, 2, 3, 4, 5};
-    int h[] = {0, 1, 2, 3, 4, 5, 6};
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(b), Sent2(b + 1)).begin() == Iter1(ia + sa - 1));
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(b), Sent2(b + 1)).end() == Iter1(ia + sa - 1 + 1));
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(c), Sent2(c + 2)).begin() == Iter1(ia + 18));
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(c), Sent2(c + 2)).end() == Iter1(ia + 18 + 2));
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(d), Sent2(d + 3)).begin() == Iter1(ia + 15));
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(d), Sent2(d + 3)).end() == Iter1(ia + 15 + 3));
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(e), Sent2(e + 4)).begin() == Iter1(ia + 11));
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(e), Sent2(e + 4)).end() == Iter1(ia + 11 + 4));
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(f), Sent2(f + 5)).begin() == Iter1(ia + 6));
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(f), Sent2(f + 5)).end() == Iter1(ia + 6 + 5));
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(g), Sent2(g + 6)).begin() == Iter1(ia));
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(g), Sent2(g + 6)).end() == Iter1(ia + 6));
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(h), Sent2(h + 7)).begin() == Iter1(ia + sa));
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(h), Sent2(h + 7)).end() == Iter1(ia + sa));
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(b), Sent2(b)).begin() == Iter1(ia + sa));
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(b), Sent2(b)).end() == Iter1(ia + sa));
-    CHECK(find_end(Iter1(ia), Sent1(ia), Iter2(b), Sent2(b + 1)).begin() == Iter1(ia));
-    CHECK(find_end(Iter1(ia), Sent1(ia), Iter2(b), Sent2(b + 1)).end() == Iter1(ia));
-
-    auto ir = make_subrange(Iter1(ia), Sent1(ia + sa));
-    CHECK(find_end(ir, make_subrange(Iter2(b), Sent2(b + 1))).begin() == Iter1(ia + sa - 1));
-    CHECK(find_end(ir, make_subrange(Iter2(b), Sent2(b + 1))).end() == Iter1(ia + sa - 1 + 1));
-    CHECK(find_end(ir, make_subrange(Iter2(c), Sent2(c + 2))).begin() == Iter1(ia + 18));
-    CHECK(find_end(ir, make_subrange(Iter2(c), Sent2(c + 2))).end() == Iter1(ia + 18 + 2));
-    CHECK(find_end(ir, make_subrange(Iter2(d), Sent2(d + 3))).begin() == Iter1(ia + 15));
-    CHECK(find_end(ir, make_subrange(Iter2(d), Sent2(d + 3))).end() == Iter1(ia + 15 + 3));
-    CHECK(find_end(ir, make_subrange(Iter2(e), Sent2(e + 4))).begin() == Iter1(ia + 11));
-    CHECK(find_end(ir, make_subrange(Iter2(e), Sent2(e + 4))).end() == Iter1(ia + 11 + 4));
-    CHECK(find_end(ir, make_subrange(Iter2(f), Sent2(f + 5))).begin() == Iter1(ia + 6));
-    CHECK(find_end(ir, make_subrange(Iter2(f), Sent2(f + 5))).end() == Iter1(ia + 6 + 5));
-    CHECK(find_end(ir, make_subrange(Iter2(g), Sent2(g + 6))).begin() == Iter1(ia));
-    CHECK(find_end(ir, make_subrange(Iter2(g), Sent2(g + 6))).end() == Iter1(ia + 6));
-    CHECK(find_end(ir, make_subrange(Iter2(h), Sent2(h + 7))).begin() == Iter1(ia + sa));
-    CHECK(find_end(ir, make_subrange(Iter2(h), Sent2(h + 7))).end() == Iter1(ia + sa));
-    CHECK(find_end(ir, make_subrange(Iter2(b), Sent2(b))).begin() == Iter1(ia + sa));
-    CHECK(find_end(ir, make_subrange(Iter2(b), Sent2(b))).end() == Iter1(ia + sa));
-
-    CHECK(find_end(std::move(ir), make_subrange(Iter2(b), Sent2(b + 1))).begin() == Iter1(ia + sa - 1));
-    CHECK(find_end(std::move(ir), make_subrange(Iter2(c), Sent2(c + 2))).begin() == Iter1(ia + 18));
-    CHECK(find_end(std::move(ir), make_subrange(Iter2(c), Sent2(c + 2))).end() == Iter1(ia + 18 + 2));
-    CHECK(find_end(std::move(ir), make_subrange(Iter2(d), Sent2(d + 3))).begin() == Iter1(ia + 15));
-    CHECK(find_end(std::move(ir), make_subrange(Iter2(d), Sent2(d + 3))).end() == Iter1(ia + 15 + 3));
-    CHECK(find_end(std::move(ir), make_subrange(Iter2(e), Sent2(e + 4))).begin() == Iter1(ia + 11));
-    CHECK(find_end(std::move(ir), make_subrange(Iter2(e), Sent2(e + 4))).end() == Iter1(ia + 11 + 4));
-    CHECK(find_end(std::move(ir), make_subrange(Iter2(f), Sent2(f + 5))).begin() == Iter1(ia + 6));
-    CHECK(find_end(std::move(ir), make_subrange(Iter2(f), Sent2(f + 5))).end() == Iter1(ia + 6 + 5));
-    CHECK(find_end(std::move(ir), make_subrange(Iter2(g), Sent2(g + 6))).begin() == Iter1(ia));
-    CHECK(find_end(std::move(ir), make_subrange(Iter2(g), Sent2(g + 6))).end() == Iter1(ia + 6));
-    CHECK(find_end(std::move(ir), make_subrange(Iter2(h), Sent2(h + 7))).begin() == Iter1(ia + sa));
-    CHECK(find_end(std::move(ir), make_subrange(Iter2(h), Sent2(h + 7))).end() == Iter1(ia + sa));
-    CHECK(find_end(std::move(ir), make_subrange(Iter2(b), Sent2(b))).begin() == Iter1(ia + sa));
-
-    auto er = make_subrange(Iter1(ia), Sent1(ia));
-    CHECK(find_end(er, make_subrange(Iter2(b), Sent2(b + 1))).begin() == Iter1(ia));
-    CHECK(find_end(er, make_subrange(Iter2(b), Sent2(b + 1))).end() == Iter1(ia));
-    CHECK(find_end(std::move(er), make_subrange(Iter2(b), Sent2(b + 1))).begin() == Iter1(ia));
-    CHECK(find_end(std::move(er), make_subrange(Iter2(b), Sent2(b + 1))).end() == Iter1(ia));
-}
-
-struct count_equal
-{
-    static unsigned count;
-    template<class T>
-    bool operator()(const T& x, const T& y)
-    {
-        ++count; return x == y;
-    }
-};
-
-unsigned count_equal::count = 0;
-
-template<class Iter1, class Iter2, typename Sent1 = Iter1, typename Sent2 = Iter2>
-void
-test_pred()
-{
-    using namespace ranges;
-
-    int ia[] = {0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 0, 1, 2, 3, 0, 1, 2, 0, 1, 0};
-    constexpr auto sa = size(ia);
-    int b[] = {0};
-    int c[] = {0, 1};
-    int d[] = {0, 1, 2};
-    int e[] = {0, 1, 2, 3};
-    int f[] = {0, 1, 2, 3, 4};
-    int g[] = {0, 1, 2, 3, 4, 5};
-    int h[] = {0, 1, 2, 3, 4, 5, 6};
-
-    count_equal::count = 0;
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(b), Sent2(b + 1), count_equal()).begin() == Iter1(ia + sa - 1));
-    CHECK(count_equal::count <= 1 * (sa - 1 + 1));
-    count_equal::count = 0;
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(c), Sent2(c + 2), count_equal()).begin() == Iter1(ia + 18));
-    CHECK(count_equal::count <= 2 * (sa - 2 + 1));
-    count_equal::count = 0;
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(d), Sent2(d + 3), count_equal()).begin() == Iter1(ia + 15));
-    CHECK(count_equal::count <= 3 * (sa - 3 + 1));
-    count_equal::count = 0;
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(e), Sent2(e + 4), count_equal()).begin() == Iter1(ia + 11));
-    CHECK(count_equal::count <= 4 * (sa - 4 + 1));
-    count_equal::count = 0;
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(f), Sent2(f + 5), count_equal()).begin() == Iter1(ia + 6));
-    CHECK(count_equal::count <= 5 * (sa - 5 + 1));
-    count_equal::count = 0;
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(g), Sent2(g + 6), count_equal()).begin() == Iter1(ia));
-    CHECK(count_equal::count <= 6 * (sa - 6 + 1));
-    count_equal::count = 0;
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(h), Sent2(h + 7), count_equal()).begin() == Iter1(ia + sa));
-    CHECK(count_equal::count <= 7 * (sa - 7 + 1));
-    count_equal::count = 0;
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(b), Sent2(b), count_equal()).begin() == Iter1(ia + sa));
-    CHECK(count_equal::count == 0u);
-    count_equal::count = 0;
-    CHECK(find_end(Iter1(ia), Sent1(ia), Iter2(b), Sent2(b + 1), count_equal()).begin() == Iter1(ia));
-    CHECK(count_equal::count == 0u);
-
-    auto ir = make_subrange(Iter1(ia), Sent1(ia + sa));
-    count_equal::count = 0;
-    CHECK(find_end(ir, make_subrange(Iter2(b), Sent2(b + 1)), count_equal()).begin() == Iter1(ia + sa - 1));
-    CHECK(count_equal::count <= 1 * (sa - 1 + 1));
-    count_equal::count = 0;
-    CHECK(find_end(ir, make_subrange(Iter2(c), Sent2(c + 2)), count_equal()).begin() == Iter1(ia + 18));
-    CHECK(count_equal::count <= 2 * (sa - 2 + 1));
-    count_equal::count = 0;
-    CHECK(find_end(ir, make_subrange(Iter2(d), Sent2(d + 3)), count_equal()).begin() == Iter1(ia + 15));
-    CHECK(count_equal::count <= 3 * (sa - 3 + 1));
-    count_equal::count = 0;
-    CHECK(find_end(ir, make_subrange(Iter2(e), Sent2(e + 4)), count_equal()).begin() == Iter1(ia + 11));
-    CHECK(count_equal::count <= 4 * (sa - 4 + 1));
-    count_equal::count = 0;
-    CHECK(find_end(ir, make_subrange(Iter2(f), Sent2(f + 5)), count_equal()).begin() == Iter1(ia + 6));
-    CHECK(count_equal::count <= 5 * (sa - 5 + 1));
-    count_equal::count = 0;
-    CHECK(find_end(ir, make_subrange(Iter2(g), Sent2(g + 6)), count_equal()).begin() == Iter1(ia));
-    CHECK(count_equal::count <= 6 * (sa - 6 + 1));
-    count_equal::count = 0;
-    CHECK(find_end(ir, make_subrange(Iter2(h), Sent2(h + 7)), count_equal()).begin() == Iter1(ia + sa));
-    CHECK(count_equal::count <= 7 * (sa - 7 + 1));
-    count_equal::count = 0;
-    CHECK(find_end(ir, make_subrange(Iter2(b), Sent2(b)), count_equal()).begin() == Iter1(ia + sa));
-    CHECK(count_equal::count == 0u);
-    count_equal::count = 0;
-    auto er = make_subrange(Iter1(ia), Sent1(ia));
-    CHECK(find_end(er, make_subrange(Iter2(b), Sent2(b + 1)), count_equal()).begin() == Iter1(ia));
-    CHECK(count_equal::count == 0u);
-
-    static_assert(std::is_same<subrange<Iter1>, decltype(find_end(er, {1, 2, 3}))>::value, "");
-}
-
-struct S
-{
-    int i_;
-};
-
-template<class Iter1, class Iter2, typename Sent1 = Iter1, typename Sent2 = Iter2>
-void
-test_proj()
-{
-    using namespace ranges;
-
-    S ia[] = {{0}, {1}, {2}, {3}, {4}, {5}, {0}, {1}, {2}, {3}, {4}, {0}, {1}, {2}, {3}, {0}, {1}, {2}, {0}, {1}, {0}};
-    constexpr auto sa = size(ia);
-    int b[] = {0};
-    int c[] = {0, 1};
-    int d[] = {0, 1, 2};
-    int e[] = {0, 1, 2, 3};
-    int f[] = {0, 1, 2, 3, 4};
-    int g[] = {0, 1, 2, 3, 4, 5};
-    int h[] = {0, 1, 2, 3, 4, 5, 6};
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(b), Sent2(b + 1), equal_to(), &S::i_).begin() == Iter1(ia + sa - 1));
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(c), Sent2(c + 2), equal_to(), &S::i_).begin() == Iter1(ia + 18));
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(d), Sent2(d + 3), equal_to(), &S::i_).begin() == Iter1(ia + 15));
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(e), Sent2(e + 4), equal_to(), &S::i_).begin() == Iter1(ia + 11));
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(f), Sent2(f + 5), equal_to(), &S::i_).begin() == Iter1(ia + 6));
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(g), Sent2(g + 6), equal_to(), &S::i_).begin() == Iter1(ia));
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(h), Sent2(h + 7), equal_to(), &S::i_).begin() == Iter1(ia + sa));
-    CHECK(find_end(Iter1(ia), Sent1(ia + sa), Iter2(b), Sent2(b), equal_to(), &S::i_).begin() == Iter1(ia + sa));
-    CHECK(find_end(Iter1(ia), Sent1(ia), Iter2(b), Sent2(b + 1), equal_to(), &S::i_).begin() == Iter1(ia));
-
-    auto ir = make_subrange(Iter1(ia), Sent1(ia + sa));
-    CHECK(find_end(ir, make_subrange(Iter2(b), Sent2(b + 1)), equal_to(), &S::i_).begin() == Iter1(ia + sa - 1));
-    CHECK(find_end(ir, make_subrange(Iter2(c), Sent2(c + 2)), equal_to(), &S::i_).begin() == Iter1(ia + 18));
-    CHECK(find_end(ir, make_subrange(Iter2(d), Sent2(d + 3)), equal_to(), &S::i_).begin() == Iter1(ia + 15));
-    CHECK(find_end(ir, make_subrange(Iter2(e), Sent2(e + 4)), equal_to(), &S::i_).begin() == Iter1(ia + 11));
-    CHECK(find_end(ir, make_subrange(Iter2(f), Sent2(f + 5)), equal_to(), &S::i_).begin() == Iter1(ia + 6));
-    CHECK(find_end(ir, make_subrange(Iter2(g), Sent2(g + 6)), equal_to(), &S::i_).begin() == Iter1(ia));
-    CHECK(find_end(ir, make_subrange(Iter2(h), Sent2(h + 7)), equal_to(), &S::i_).begin() == Iter1(ia + sa));
-    CHECK(find_end(ir, make_subrange(Iter2(b), Sent2(b)), equal_to(), &S::i_).begin() == Iter1(ia + sa));
-    auto er = make_subrange(Iter1(ia), Sent1(ia));
-    CHECK(find_end(er, make_subrange(Iter2(b), Sent2(b + 1)), equal_to(), &S::i_).begin() == Iter1(ia));
-}
-
-int main()
-{
-    test<ForwardIterator<const int*>, ForwardIterator<const int*> >();
-    // test<ForwardIterator<const int*>, BidirectionalIterator<const int*> >();
-    // test<ForwardIterator<const int*>, RandomAccessIterator<const int*> >();
-    // test<BidirectionalIterator<const int*>, ForwardIterator<const int*> >();
-    // test<BidirectionalIterator<const int*>, BidirectionalIterator<const int*> >();
-    // test<BidirectionalIterator<const int*>, RandomAccessIterator<const int*> >();
-    // test<RandomAccessIterator<const int*>, ForwardIterator<const int*> >();
-    // test<RandomAccessIterator<const int*>, BidirectionalIterator<const int*> >();
-    // test<RandomAccessIterator<const int*>, RandomAccessIterator<const int*> >();
-
-    // test<ForwardIterator<const int*>, ForwardIterator<const int*>, Sentinel<const int*>, Sentinel<const int *> >();
-    // test<ForwardIterator<const int*>, BidirectionalIterator<const int*>, Sentinel<const int*>, Sentinel<const int *> >();
-    // test<ForwardIterator<const int*>, RandomAccessIterator<const int*>, Sentinel<const int*>, Sentinel<const int *> >();
-    // test<BidirectionalIterator<const int*>, ForwardIterator<const int*>, Sentinel<const int*>, Sentinel<const int *> >();
-    // test<BidirectionalIterator<const int*>, BidirectionalIterator<const int*>, Sentinel<const int*>, Sentinel<const int *> >();
-    // test<BidirectionalIterator<const int*>, RandomAccessIterator<const int*>, Sentinel<const int*>, Sentinel<const int *> >();
-    // test<RandomAccessIterator<const int*>, ForwardIterator<const int*>, Sentinel<const int*>, Sentinel<const int *> >();
-    // test<RandomAccessIterator<const int*>, BidirectionalIterator<const int*>, Sentinel<const int*>, Sentinel<const int *> >();
-    // test<RandomAccessIterator<const int*>, RandomAccessIterator<const int*>, Sentinel<const int*>, Sentinel<const int *> >();
-
-    // test_pred<ForwardIterator<const int*>, ForwardIterator<const int*> >();
-    // test_pred<ForwardIterator<const int*>, BidirectionalIterator<const int*> >();
-    // test_pred<ForwardIterator<const int*>, RandomAccessIterator<const int*> >();
-    // test_pred<BidirectionalIterator<const int*>, ForwardIterator<const int*> >();
-    // test_pred<BidirectionalIterator<const int*>, BidirectionalIterator<const int*> >();
-    // test_pred<BidirectionalIterator<const int*>, RandomAccessIterator<const int*> >();
-    // test_pred<RandomAccessIterator<const int*>, ForwardIterator<const int*> >();
-    // test_pred<RandomAccessIterator<const int*>, BidirectionalIterator<const int*> >();
-    // test_pred<RandomAccessIterator<const int*>, RandomAccessIterator<const int*> >();
-
-    // test_pred<ForwardIterator<const int*>, ForwardIterator<const int*>, Sentinel<const int*>, Sentinel<const int *> >();
-    // test_pred<ForwardIterator<const int*>, BidirectionalIterator<const int*>, Sentinel<const int*>, Sentinel<const int *> >();
-    // test_pred<ForwardIterator<const int*>, RandomAccessIterator<const int*>, Sentinel<const int*>, Sentinel<const int *> >();
-    // test_pred<BidirectionalIterator<const int*>, ForwardIterator<const int*>, Sentinel<const int*>, Sentinel<const int *> >();
-    // test_pred<BidirectionalIterator<const int*>, BidirectionalIterator<const int*>, Sentinel<const int*>, Sentinel<const int *> >();
-    // test_pred<BidirectionalIterator<const int*>, RandomAccessIterator<const int*>, Sentinel<const int*>, Sentinel<const int *> >();
-    // test_pred<RandomAccessIterator<const int*>, ForwardIterator<const int*>, Sentinel<const int*>, Sentinel<const int *> >();
-    // test_pred<RandomAccessIterator<const int*>, BidirectionalIterator<const int*>, Sentinel<const int*>, Sentinel<const int *> >();
-    // test_pred<RandomAccessIterator<const int*>, RandomAccessIterator<const int*>, Sentinel<const int*>, Sentinel<const int *> >();
-
-    // test_proj<ForwardIterator<const S*>, ForwardIterator<const int*> >();
-    // test_proj<ForwardIterator<const S*>, BidirectionalIterator<const int*> >();
-    // test_proj<ForwardIterator<const S*>, RandomAccessIterator<const int*> >();
-    // test_proj<BidirectionalIterator<const S*>, ForwardIterator<const int*> >();
-    // test_proj<BidirectionalIterator<const S*>, BidirectionalIterator<const int*> >();
-    // test_proj<BidirectionalIterator<const S*>, RandomAccessIterator<const int*> >();
-    // test_proj<RandomAccessIterator<const S*>, ForwardIterator<const int*> >();
-    // test_proj<RandomAccessIterator<const S*>, BidirectionalIterator<const int*> >();
-    // test_proj<RandomAccessIterator<const S*>, RandomAccessIterator<const int*> >();
-
-    // test_proj<ForwardIterator<const S*>, ForwardIterator<const int*>, Sentinel<const S*>, Sentinel<const int *> >();
-    // test_proj<ForwardIterator<const S*>, BidirectionalIterator<const int*>, Sentinel<const S*>, Sentinel<const int *> >();
-    // test_proj<ForwardIterator<const S*>, RandomAccessIterator<const int*>, Sentinel<const S*>, Sentinel<const int *> >();
-    // test_proj<BidirectionalIterator<const S*>, ForwardIterator<const int*>, Sentinel<const S*>, Sentinel<const int *> >();
-    // test_proj<BidirectionalIterator<const S*>, BidirectionalIterator<const int*>, Sentinel<const S*>, Sentinel<const int *> >();
-    // test_proj<BidirectionalIterator<const S*>, RandomAccessIterator<const int*>, Sentinel<const S*>, Sentinel<const int *> >();
-    // test_proj<RandomAccessIterator<const S*>, ForwardIterator<const int*>, Sentinel<const S*>, Sentinel<const int *> >();
-    // test_proj<RandomAccessIterator<const S*>, BidirectionalIterator<const int*>, Sentinel<const S*>, Sentinel<const int *> >();
-    // test_proj<RandomAccessIterator<const S*>, RandomAccessIterator<const int*>, Sentinel<const S*>, Sentinel<const int *> >();
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/find_first_of.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/find_first_of.cpp
deleted file mode 100644
index 57cff29e..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/find_first_of.cpp
+++ /dev/null
@@ -1,221 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/find_first_of.hpp>
-#include "../simple_test.hpp"
-#include "../test_iterators.hpp"
-#include "../test_utils.hpp"
-
-namespace rng = ranges;
-
-void test_iter()
-{
-    using namespace ranges;
-    int ia[] = {0, 1, 2, 3, 0, 1, 2, 3};
-    static constexpr auto sa = size(ia);
-    int ib[] = {1, 3, 5, 7};
-    static constexpr auto sb = size(ib);
-    CHECK(rng::find_first_of(InputIterator<const int*>(ia),
-                             Sentinel<const int*>(ia + sa),
-                             ForwardIterator<const int*>(ib),
-                             Sentinel<const int*>(ib + sb)) ==
-                             InputIterator<const int*>(ia+1));
-    int ic[] = {7};
-    CHECK(rng::find_first_of(InputIterator<const int*>(ia),
-                             Sentinel<const int*>(ia + sa),
-                             ForwardIterator<const int*>(ic),
-                             Sentinel<const int*>(ic + 1)) ==
-                             InputIterator<const int*>(ia+sa));
-    CHECK(rng::find_first_of(InputIterator<const int*>(ia),
-                             Sentinel<const int*>(ia + sa),
-                             ForwardIterator<const int*>(ic),
-                             Sentinel<const int*>(ic)) ==
-                             InputIterator<const int*>(ia+sa));
-    CHECK(rng::find_first_of(InputIterator<const int*>(ia),
-                             Sentinel<const int*>(ia),
-                             ForwardIterator<const int*>(ic),
-                             Sentinel<const int*>(ic+1)) ==
-                             InputIterator<const int*>(ia));
-}
-
-void test_iter_pred()
-{
-    using namespace ranges;
-    int ia[] = {0, 1, 2, 3, 0, 1, 2, 3};
-    static constexpr auto sa = size(ia);
-    int ib[] = {1, 3, 5, 7};
-    static constexpr auto sb = size(ib);
-    CHECK(rng::find_first_of(InputIterator<const int*>(ia),
-                             Sentinel<const int*>(ia + sa),
-                             ForwardIterator<const int*>(ib),
-                             Sentinel<const int*>(ib + sb),
-                             std::equal_to<int>()) ==
-                             InputIterator<const int*>(ia+1));
-    int ic[] = {7};
-    CHECK(rng::find_first_of(InputIterator<const int*>(ia),
-                             Sentinel<const int*>(ia + sa),
-                             ForwardIterator<const int*>(ic),
-                             Sentinel<const int*>(ic + 1),
-                             std::equal_to<int>()) ==
-                             InputIterator<const int*>(ia+sa));
-    CHECK(rng::find_first_of(InputIterator<const int*>(ia),
-                             Sentinel<const int*>(ia + sa),
-                             ForwardIterator<const int*>(ic),
-                             Sentinel<const int*>(ic),
-                             std::equal_to<int>()) ==
-                             InputIterator<const int*>(ia+sa));
-    CHECK(rng::find_first_of(InputIterator<const int*>(ia),
-                             Sentinel<const int*>(ia),
-                             ForwardIterator<const int*>(ic),
-                             Sentinel<const int*>(ic+1),
-                             std::equal_to<int>()) ==
-                             InputIterator<const int*>(ia));
-}
-
-void test_rng()
-{
-    using namespace ranges;
-    int ia[] = {0, 1, 2, 3, 0, 1, 2, 3};
-    static constexpr auto sa = size(ia);
-    int ib[] = {1, 3, 5, 7};
-    static constexpr auto sb = size(ib);
-    CHECK(rng::find_first_of(make_subrange(InputIterator<const int*>(ia),
-                             InputIterator<const int*>(ia + sa)),
-                             make_subrange(ForwardIterator<const int*>(ib),
-                             ForwardIterator<const int*>(ib + sb))) ==
-                             InputIterator<const int*>(ia+1));
-    CHECK(::is_dangling(rng::find_first_of(::MakeTestRange(InputIterator<const int*>(ia),
-                             InputIterator<const int*>(ia + sa)),
-                             make_subrange(ForwardIterator<const int*>(ib),
-                             ForwardIterator<const int*>(ib + sb)))));
-    int ic[] = {7};
-    CHECK(rng::find_first_of(make_subrange(InputIterator<const int*>(ia),
-                             InputIterator<const int*>(ia + sa)),
-                             make_subrange(ForwardIterator<const int*>(ic),
-                             ForwardIterator<const int*>(ic + 1))) ==
-                             InputIterator<const int*>(ia+sa));
-    CHECK(rng::find_first_of(make_subrange(InputIterator<const int*>(ia),
-                             InputIterator<const int*>(ia + sa)),
-                             make_subrange(ForwardIterator<const int*>(ic),
-                             ForwardIterator<const int*>(ic))) ==
-                             InputIterator<const int*>(ia+sa));
-    CHECK(rng::find_first_of(make_subrange(InputIterator<const int*>(ia),
-                             InputIterator<const int*>(ia)),
-                             make_subrange(ForwardIterator<const int*>(ic),
-                             ForwardIterator<const int*>(ic+1))) ==
-                             InputIterator<const int*>(ia));
-    CHECK(::is_dangling(rng::find_first_of(::MakeTestRange(InputIterator<const int*>(ia),
-                             InputIterator<const int*>(ia + sa)),
-                             make_subrange(ForwardIterator<const int*>(ic),
-                             ForwardIterator<const int*>(ic + 1)))));
-    CHECK(::is_dangling(rng::find_first_of(::MakeTestRange(InputIterator<const int*>(ia),
-                             InputIterator<const int*>(ia + sa)),
-                             make_subrange(ForwardIterator<const int*>(ic),
-                             ForwardIterator<const int*>(ic)))));
-    CHECK(::is_dangling(rng::find_first_of(::MakeTestRange(InputIterator<const int*>(ia),
-                             InputIterator<const int*>(ia)),
-                             make_subrange(ForwardIterator<const int*>(ic),
-                             ForwardIterator<const int*>(ic+1)))));
-}
-
-void test_rng_pred()
-{
-    using namespace ranges;
-    int ia[] = {0, 1, 2, 3, 0, 1, 2, 3};
-    static constexpr auto sa = size(ia);
-    int ib[] = {1, 3, 5, 7};
-    static constexpr auto sb = size(ib);
-    CHECK(rng::find_first_of(make_subrange(InputIterator<const int*>(ia),
-                             InputIterator<const int*>(ia + sa)),
-                             make_subrange(ForwardIterator<const int*>(ib),
-                             ForwardIterator<const int*>(ib + sb)),
-                             std::equal_to<int>()) ==
-                             InputIterator<const int*>(ia+1));
-    int ic[] = {7};
-    CHECK(rng::find_first_of(make_subrange(InputIterator<const int*>(ia),
-                             InputIterator<const int*>(ia + sa)),
-                             make_subrange(ForwardIterator<const int*>(ic),
-                             ForwardIterator<const int*>(ic + 1)),
-                             std::equal_to<int>()) ==
-                             InputIterator<const int*>(ia+sa));
-    CHECK(rng::find_first_of(make_subrange(InputIterator<const int*>(ia),
-                             InputIterator<const int*>(ia + sa)),
-                             make_subrange(ForwardIterator<const int*>(ic),
-                             ForwardIterator<const int*>(ic)),
-                             std::equal_to<int>()) ==
-                             InputIterator<const int*>(ia+sa));
-    CHECK(rng::find_first_of(make_subrange(InputIterator<const int*>(ia),
-                             InputIterator<const int*>(ia)),
-                             make_subrange(ForwardIterator<const int*>(ic),
-                             ForwardIterator<const int*>(ic+1)),
-                             std::equal_to<int>()) ==
-                             InputIterator<const int*>(ia));
-}
-
-struct S
-{
-    int i;
-};
-
-void test_rng_pred_proj()
-{
-    using namespace ranges;
-    S ia[] = {S{0}, S{1}, S{2}, S{3}, S{0}, S{1}, S{2}, S{3}};
-    static constexpr auto sa = size(ia);
-    S ib[] = {S{1}, S{3}, S{5}, S{7}};
-    static constexpr auto sb = size(ib);
-    CHECK(rng::find_first_of(make_subrange(InputIterator<const S*>(ia),
-                             InputIterator<const S*>(ia + sa)),
-                             make_subrange(ForwardIterator<const S*>(ib),
-                             ForwardIterator<const S*>(ib + sb)),
-                             std::equal_to<int>(), &S::i, &S::i) ==
-                             InputIterator<const S*>(ia+1));
-    S ic[] = {S{7}};
-    CHECK(rng::find_first_of(make_subrange(InputIterator<const S*>(ia),
-                             InputIterator<const S*>(ia + sa)),
-                             make_subrange(ForwardIterator<const S*>(ic),
-                             ForwardIterator<const S*>(ic + 1)),
-                             std::equal_to<int>(), &S::i, &S::i) ==
-                             InputIterator<const S*>(ia+sa));
-    CHECK(rng::find_first_of(make_subrange(InputIterator<const S*>(ia),
-                             InputIterator<const S*>(ia + sa)),
-                             make_subrange(ForwardIterator<const S*>(ic),
-                             ForwardIterator<const S*>(ic)),
-                             std::equal_to<int>(), &S::i, &S::i) ==
-                             InputIterator<const S*>(ia+sa));
-    CHECK(rng::find_first_of(make_subrange(InputIterator<const S*>(ia),
-                             InputIterator<const S*>(ia)),
-                             make_subrange(ForwardIterator<const S*>(ic),
-                             ForwardIterator<const S*>(ic+1)),
-                             std::equal_to<int>(), &S::i, &S::i) ==
-                             InputIterator<const S*>(ia));
-}
-
-
-int main()
-{
-    ::test_iter();
-    ::test_iter_pred();
-    ::test_rng();
-    ::test_rng_pred();
-    ::test_rng_pred_proj();
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/find_if.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/find_if.cpp
deleted file mode 100644
index 949b1fbc..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/find_if.cpp
+++ /dev/null
@@ -1,98 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <utility>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/find_if.hpp>
-#include "../simple_test.hpp"
-#include "../test_iterators.hpp"
-
-struct S
-{
-    int i_;
-};
-
-int main()
-{
-    using namespace ranges;
-
-    int ia[] = {0, 1, 2, 3, 4, 5};
-    constexpr auto s = size(ia);
-
-    {
-        InputIterator<const int*> r = find_if(InputIterator<const int*>(ia),
-                                              InputIterator<const int*>(ia + s),
-                                              [](int i){return i == 3;});
-        CHECK(*r == 3);
-        r = find_if(InputIterator<const int*>(ia),
-                    InputIterator<const int*>(ia+s),
-                    [](int i){return i == 10;});
-        CHECK(r == InputIterator<const int*>(ia+s));
-
-        r = find_if(InputIterator<const int*>(ia),
-                    Sentinel<const int*>(ia+s),
-                    [](int i){return i == 3;});
-        CHECK(*r == 3);
-        r = find_if(InputIterator<const int*>(ia),
-                    Sentinel<const int*>(ia+s),
-                    [](int i){return i == 10;});
-        CHECK(r == InputIterator<const int*>(ia+s));
-    }
-
-    {
-        int *pi = find_if(ia, [](int i){return i == 3;});
-        CHECK(*pi == 3);
-        pi = find_if(ia, [](int i){return i == 10;});
-        CHECK(pi == ia+s);
-    }
-
-#ifndef RANGES_WORKAROUND_MSVC_573728
-    {
-        auto pj0 = find_if(std::move(ia), [](int i){return i == 3;});
-        CHECK(::is_dangling(pj0));
-        auto pj1 = find_if(std::move(ia), [](int i){return i == 10;});
-        CHECK(::is_dangling(pj1));
-    }
-#endif // RANGES_WORKAROUND_MSVC_573728
-
-    {
-        std::vector<int> const vec(begin(ia), end(ia));
-        auto pj0 = find_if(std::move(vec), [](int i){return i == 3;});
-        CHECK(::is_dangling(pj0));
-        auto pj1 = find_if(std::move(vec), [](int i){return i == 10;});
-        CHECK(::is_dangling(pj1));
-    }
-
-    {
-        auto* ignore = find_if(ranges::views::all(ia), [](int i){return i == 10;});
-        (void)ignore;
-    }
-
-    {
-        S sa[] = {{0}, {1}, {2}, {3}, {4}, {5}};
-        S *ps = find_if(sa, [](int i){return i == 3;}, &S::i_);
-        CHECK(ps->i_ == 3);
-        ps = find_if(sa, [](int i){return i == 10;}, &S::i_);
-        CHECK(ps == end(sa));
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/for_each.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/for_each.cpp
deleted file mode 100644
index 9ab28d2b..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/for_each.cpp
+++ /dev/null
@@ -1,51 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/for_each.hpp>
-#include "../simple_test.hpp"
-#include "../test_iterators.hpp"
-
-struct S
-{
-    void p() const { *p_ += i_; }
-    int *p_;
-    int i_;
-};
-
-int main()
-{
-    int sum = 0;
-    auto fun = [&](int i){sum += i; };
-    std::vector<int> v1 { 0, 2, 4, 6 };
-    CHECK(ranges::for_each(v1.begin(), v1.end(), fun).in == v1.end());
-    CHECK(ranges::for_each(v1, fun).in == v1.end());
-    CHECK(sum == 24);
-
-    sum = 0;
-    auto rfun = [&](int & i){sum += i; };
-    CHECK(ranges::for_each(v1.begin(), v1.end(), rfun).in == v1.end());
-    CHECK(ranges::for_each(v1, rfun).in == v1.end());
-    CHECK(sum == 24);
-
-    sum = 0;
-    std::vector<S> v2{{&sum, 0}, {&sum, 2}, {&sum, 4}, {&sum, 6}};
-    CHECK(ranges::for_each(v2.begin(), v2.end(), &S::p).in == v2.end());
-    CHECK(ranges::for_each(v2, &S::p).in == v2.end());
-    CHECK(sum == 24);
-
-    sum = 0;
-    CHECK(::is_dangling(ranges::for_each(::MakeTestRange(v1.begin(), v1.end()), fun).in));
-    CHECK(sum == 12);
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/for_each_n.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/for_each_n.cpp
deleted file mode 100644
index a528940a..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/for_each_n.cpp
+++ /dev/null
@@ -1,54 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Rostislav Khlebnikov 2017
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/for_each_n.hpp>
-#include "../simple_test.hpp"
-
-struct S
-{
-    void p() const { *p_ += i_; }
-    int *p_;
-    int i_;
-};
-
-int main()
-{
-    int sum = 0;
-    auto const fun = [&](int i){ sum += i; };
-    std::vector<int> v1 { 1, 2, 4, 6 };
-    CHECK(ranges::for_each_n(v1.begin(), 2, fun) == v1.begin() + 2);
-    CHECK(ranges::for_each_n(v1, 2, fun) == v1.begin() + 2);
-    CHECK(sum == 3 * 2);
-
-    sum = 0;
-    auto const rfun = [&](int & i){ sum += i; };
-    auto const sz = static_cast<int>(v1.size());
-    CHECK(ranges::for_each_n(v1.begin(), sz, rfun) == v1.end());
-    CHECK(ranges::for_each_n(v1, sz, rfun) == v1.end());
-    CHECK(sum == 13 * 2);
-
-    sum = 0;
-    std::vector<S> v2{{&sum, 1}, {&sum, 2}, {&sum, 4}, {&sum, 6}};
-    CHECK(ranges::for_each_n(v2.begin(), 3, &S::p) == v2.begin() + 3);
-    CHECK(ranges::for_each_n(v2, 3, &S::p) == v2.begin() + 3);
-    CHECK(sum == 7 * 2);
-
-    sum = 0;
-    CHECK(ranges::for_each_n(v2.begin(), 4, fun, &S::i_) == v2.begin() + 4);
-    CHECK(ranges::for_each_n(v2, 4, fun, &S::i_) == v2.begin() + 4);
-    CHECK(sum == 13 * 2);
-
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/generate.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/generate.cpp
deleted file mode 100644
index 6c8daad4..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/generate.cpp
+++ /dev/null
@@ -1,98 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/generate.hpp>
-#include <range/v3/iterator/insert_iterators.hpp>
-#include <range/v3/view/counted.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-struct gen_test
-{
-    int i_;
-    gen_test() = default;
-    gen_test(int i) : i_(i) {}
-    int operator()() {return i_++;}
-};
-
-template<class Iter, class Sent = Iter>
-void
-test()
-{
-    const unsigned n = 4;
-    int ia[n] = {0};
-    ranges::generate_result<Iter, gen_test> res = ranges::generate(Iter(ia), Sent(ia + n), gen_test(1));
-    CHECK(ia[0] == 1);
-    CHECK(ia[1] == 2);
-    CHECK(ia[2] == 3);
-    CHECK(ia[3] == 4);
-    CHECK(res.out == Iter(ia + n));
-    CHECK(res.fun.i_ == 5);
-
-    auto rng = ::MakeTestRange(Iter(ia), Sent(ia + n));
-    res = ranges::generate(rng, res.fun);
-    CHECK(ia[0] == 5);
-    CHECK(ia[1] == 6);
-    CHECK(ia[2] == 7);
-    CHECK(ia[3] == 8);
-    CHECK(res.out == Iter(ia + n));
-    CHECK(res.fun.i_ == 9);
-
-    auto res2 = ranges::generate(std::move(rng), res.fun);
-    CHECK(ia[0] == 9);
-    CHECK(ia[1] == 10);
-    CHECK(ia[2] == 11);
-    CHECK(ia[3] == 12);
-    CHECK(::is_dangling(res2.out));
-    CHECK(res2.fun.i_ == 13);
-}
-
-void test2()
-{
-    // Test ranges::generate with a genuine output range
-    std::vector<int> v;
-    auto rng = ranges::views::counted(ranges::back_inserter(v), 5);
-    ranges::generate(rng, gen_test(1));
-    CHECK(v.size() == 5u);
-    CHECK(v[0] == 1);
-    CHECK(v[1] == 2);
-    CHECK(v[2] == 3);
-    CHECK(v[3] == 4);
-    CHECK(v[4] == 5);
-}
-
-int main()
-{
-    test<ForwardIterator<int*> >();
-    test<BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<int*> >();
-    test<int*>();
-
-    test<ForwardIterator<int*>, Sentinel<int*> >();
-    test<BidirectionalIterator<int*>, Sentinel<int*> >();
-    test<RandomAccessIterator<int*>, Sentinel<int*> >();
-
-    test2();
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/generate_n.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/generate_n.cpp
deleted file mode 100644
index 3f228978..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/generate_n.cpp
+++ /dev/null
@@ -1,79 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/generate_n.hpp>
-#include <range/v3/iterator/insert_iterators.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-struct gen_test
-{
-    int i_;
-    gen_test() = default;
-    gen_test(int i) : i_(i) {}
-    int operator()() {return i_++;}
-};
-
-template<class Iter, class Sent = Iter>
-void
-test()
-{
-    const unsigned n = 4;
-    int ia[n] = {0};
-    ranges::generate_n_result<Iter, gen_test> res = ranges::generate_n(Iter(ia), n, gen_test(1));
-    CHECK(ia[0] == 1);
-    CHECK(ia[1] == 2);
-    CHECK(ia[2] == 3);
-    CHECK(ia[3] == 4);
-    CHECK(res.out == Iter(ia + n));
-    CHECK(res.fun.i_ == 5);
-}
-
-void test2()
-{
-    // Test ranges::generate with a genuine output range
-    std::vector<int> v;
-    ranges::generate_n(ranges::back_inserter(v), 5, gen_test(1));
-    CHECK(v.size() == 5u);
-    CHECK(v[0] == 1);
-    CHECK(v[1] == 2);
-    CHECK(v[2] == 3);
-    CHECK(v[3] == 4);
-    CHECK(v[4] == 5);
-}
-
-int main()
-{
-    test<ForwardIterator<int*> >();
-    test<BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<int*> >();
-    test<int*>();
-
-    test<ForwardIterator<int*>, Sentinel<int*> >();
-    test<BidirectionalIterator<int*>, Sentinel<int*> >();
-    test<RandomAccessIterator<int*>, Sentinel<int*> >();
-
-    test2();
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/includes.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/includes.cpp
deleted file mode 100644
index 68425716..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/includes.cpp
+++ /dev/null
@@ -1,153 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <functional>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/set_algorithm.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS
-
-namespace
-{
-    auto const true_  = [](bool b){CHECK(b);};
-    auto const false_ = [](bool b){CHECK(!b);};
-
-    template<class Iter1, class Iter2>
-    void
-    test_iter()
-    {
-        int ia[] = {1, 2, 2, 3, 3, 3, 4, 4, 4, 4};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        int ib[] = {2, 4};
-        const unsigned sb = sizeof(ib)/sizeof(ib[0]);
-        int ic[] = {1, 2};
-        int id[] = {3, 3, 3, 3};
-
-        auto includes = make_testable_2<true, true>(ranges::includes);
-
-        includes(Iter1(ia), Iter1(ia), Iter2(ib), Iter2(ib)).check(true_);
-        includes(Iter1(ia), Iter1(ia), Iter2(ib), Iter2(ib+1)).check(false_);
-        includes(Iter1(ia), Iter1(ia+1), Iter2(ib), Iter2(ib)).check(true_);
-        includes(Iter1(ia), Iter1(ia+sa), Iter2(ia), Iter2(ia+sa)).check(true_);
-
-        includes(Iter1(ia), Iter1(ia+sa), Iter2(ib), Iter2(ib+sb)).check(true_);
-        includes(Iter1(ib), Iter1(ib+sb), Iter2(ia), Iter2(ia+sa)).check(false_);
-
-        includes(Iter1(ia), Iter1(ia+2), Iter2(ic), Iter2(ic+2)).check(true_);
-        includes(Iter1(ia), Iter1(ia+2), Iter2(ib), Iter2(ib+2)).check(false_);
-
-        includes(Iter1(ia), Iter1(ia+sa), Iter2(id), Iter2(id+1)).check(true_);
-        includes(Iter1(ia), Iter1(ia+sa), Iter2(id), Iter2(id+2)).check(true_);
-        includes(Iter1(ia), Iter1(ia+sa), Iter2(id), Iter2(id+3)).check(true_);
-        includes(Iter1(ia), Iter1(ia+sa), Iter2(id), Iter2(id+4)).check(false_);
-    }
-
-    template<class Iter1, class Iter2>
-    void
-    test_comp()
-    {
-        int ia[] = {1, 2, 2, 3, 3, 3, 4, 4, 4, 4};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        int ib[] = {2, 4};
-        const unsigned sb = sizeof(ib)/sizeof(ib[0]);
-        int ic[] = {1, 2};
-        int id[] = {3, 3, 3, 3};
-
-        auto includes = make_testable_2<true, true>(ranges::includes);
-
-        includes(Iter1(ia), Iter1(ia), Iter2(ib), Iter2(ib), std::less<int>()).check(true_);
-        includes(Iter1(ia), Iter1(ia), Iter2(ib), Iter2(ib+1), std::less<int>()).check(false_);
-        includes(Iter1(ia), Iter1(ia+1), Iter2(ib), Iter2(ib), std::less<int>()).check(true_);
-        includes(Iter1(ia), Iter1(ia+sa), Iter2(ia), Iter2(ia+sa), std::less<int>()).check(true_);
-
-        includes(Iter1(ia), Iter1(ia+sa), Iter2(ib), Iter2(ib+sb), std::less<int>()).check(true_);
-        includes(Iter1(ib), Iter1(ib+sb), Iter2(ia), Iter2(ia+sa), std::less<int>()).check(false_);
-
-        includes(Iter1(ia), Iter1(ia+2), Iter2(ic), Iter2(ic+2), std::less<int>()).check(true_);
-        includes(Iter1(ia), Iter1(ia+2), Iter2(ib), Iter2(ib+2), std::less<int>()).check(false_);
-
-        includes(Iter1(ia), Iter1(ia+sa), Iter2(id), Iter2(id+1), std::less<int>()).check(true_);
-        includes(Iter1(ia), Iter1(ia+sa), Iter2(id), Iter2(id+2), std::less<int>()).check(true_);
-        includes(Iter1(ia), Iter1(ia+sa), Iter2(id), Iter2(id+3), std::less<int>()).check(true_);
-        includes(Iter1(ia), Iter1(ia+sa), Iter2(id), Iter2(id+4), std::less<int>()).check(false_);
-    }
-
-    template<class Iter1, class Iter2>
-    void test()
-    {
-        test_iter<Iter1, Iter2>();
-        test_comp<Iter1, Iter2>();
-    }
-
-    struct S
-    {
-        int i;
-    };
-
-    struct T
-    {
-        int j;
-    };
-}
-
-int main()
-{
-    test<InputIterator<const int*>, InputIterator<const int*> >();
-    test<InputIterator<const int*>, ForwardIterator<const int*> >();
-    test<InputIterator<const int*>, BidirectionalIterator<const int*> >();
-    test<InputIterator<const int*>, RandomAccessIterator<const int*> >();
-    test<InputIterator<const int*>, const int*>();
-
-    test<ForwardIterator<const int*>, InputIterator<const int*> >();
-    test<ForwardIterator<const int*>, ForwardIterator<const int*> >();
-    test<ForwardIterator<const int*>, BidirectionalIterator<const int*> >();
-    test<ForwardIterator<const int*>, RandomAccessIterator<const int*> >();
-    test<ForwardIterator<const int*>, const int*>();
-
-    test<BidirectionalIterator<const int*>, InputIterator<const int*> >();
-    test<BidirectionalIterator<const int*>, ForwardIterator<const int*> >();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<const int*> >();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<const int*> >();
-    test<BidirectionalIterator<const int*>, const int*>();
-
-    test<RandomAccessIterator<const int*>, InputIterator<const int*> >();
-    test<RandomAccessIterator<const int*>, ForwardIterator<const int*> >();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<const int*> >();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<const int*> >();
-    test<RandomAccessIterator<const int*>, const int*>();
-
-    test<const int*, InputIterator<const int*> >();
-    test<const int*, ForwardIterator<const int*> >();
-    test<const int*, BidirectionalIterator<const int*> >();
-    test<const int*, RandomAccessIterator<const int*> >();
-    test<const int*, const int*>();
-
-    // Test projections
-    {
-        S ia[] = {{1}, {2}, {2}, {3}, {3}, {3}, {4}, {4}, {4}, {4}};
-        T id[] = {{3}, {3}, {3}};
-        CHECK(ranges::includes(ia, id, std::less<int>(), &S::i, &T::j));
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/inplace_merge.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/inplace_merge.cpp
deleted file mode 100644
index 3dc4da48..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/inplace_merge.cpp
+++ /dev/null
@@ -1,142 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <algorithm>
-#include <random>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/inplace_merge.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS
-RANGES_DIAGNOSTIC_IGNORE_SIGN_CONVERSION
-
-namespace
-{
-    std::mt19937 gen;
-
-    template<class Iter, typename Sent = Iter>
-    void
-    test_one_iter(unsigned N, unsigned M)
-    {
-        RANGES_ENSURE(M <= N);
-        int* ia = new int[N];
-        for (unsigned i = 0; i < N; ++i)
-            ia[i] = i;
-        std::shuffle(ia, ia+N, gen);
-        std::sort(ia, ia+M);
-        std::sort(ia+M, ia+N);
-        auto res = ranges::inplace_merge(Iter(ia), Iter(ia+M), Sent(ia+N));
-        CHECK(res == Iter(ia+N));
-        if(N > 0)
-        {
-            CHECK(ia[0] == 0);
-            CHECK(ia[N-1] == (int)N-1);
-            CHECK(std::is_sorted(ia, ia+N));
-        }
-        delete [] ia;
-    }
-
-    template<class Iter, typename Sent = Iter>
-    void
-    test_one_rng(unsigned N, unsigned M)
-    {
-        RANGES_ENSURE(M <= N);
-        int* ia = new int[N];
-        for (unsigned i = 0; i < N; ++i)
-            ia[i] = i;
-        std::shuffle(ia, ia+N, gen);
-        std::sort(ia, ia+M);
-        std::sort(ia+M, ia+N);
-        auto res = ranges::inplace_merge(ranges::make_subrange(Iter(ia), Sent(ia+N)), Iter(ia+M));
-        CHECK(res == Iter(ia+N));
-        if(N > 0)
-        {
-            CHECK(ia[0] == 0);
-            CHECK(ia[N-1] == (int)N-1);
-            CHECK(std::is_sorted(ia, ia+N));
-        }
-
-        std::shuffle(ia, ia+N, gen);
-        std::sort(ia, ia+M);
-        std::sort(ia+M, ia+N);
-        auto res2 = ranges::inplace_merge(::MakeTestRange(Iter(ia), Sent(ia+N)), Iter(ia+M));
-        CHECK(::is_dangling(res2));
-        if(N > 0)
-        {
-            CHECK(ia[0] == 0);
-            CHECK(ia[N-1] == (int)N-1);
-            CHECK(std::is_sorted(ia, ia+N));
-        }
-
-        delete [] ia;
-    }
-
-    template<class Iter>
-    void
-    test_one(unsigned N, unsigned M)
-    {
-        test_one_iter<Iter>(N, M);
-        test_one_iter<Iter, typename sentinel_type<Iter>::type>(N, M);
-        test_one_rng<Iter>(N, M);
-        test_one_rng<Iter, typename sentinel_type<Iter>::type>(N, M);
-    }
-
-    template<class Iter>
-    void
-    test(unsigned N)
-    {
-        test_one<Iter>(N, 0);
-        test_one<Iter>(N, N/4);
-        test_one<Iter>(N, N/2);
-        test_one<Iter>(N, 3*N/4);
-        test_one<Iter>(N, N);
-    }
-
-    template<class Iter>
-    void
-    test()
-    {
-        test_one<Iter>(0, 0);
-        test_one<Iter>(1, 0);
-        test_one<Iter>(1, 1);
-        test_one<Iter>(2, 0);
-        test_one<Iter>(2, 1);
-        test_one<Iter>(2, 2);
-        test_one<Iter>(3, 0);
-        test_one<Iter>(3, 1);
-        test_one<Iter>(3, 2);
-        test_one<Iter>(3, 3);
-        test<Iter>(4);
-        test<Iter>(100);
-        test<Iter>(1000);
-    }
-}
-
-int main()
-{
-    // test<ForwardIterator<int*> >();
-    test<BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<int*> >();
-    test<int*>();
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/is_heap.hpp b/src/contrib/range-v3-0.11.0/test/algorithm/is_heap.hpp
deleted file mode 100644
index 107ddd28..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/is_heap.hpp
+++ /dev/null
@@ -1,1063 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-// Implementation based on the code in libc++
-//   http://http://libcxx.llvm.org/
-
-#include <algorithm>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/heap_algorithm.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-void test()
-{
-
-#if defined(IS_HEAP_1) || defined(IS_HEAP_2)
-    auto is_heap = make_testable_1(ranges::is_heap);
-#endif
-
-#ifdef IS_HEAP_1
-    int i1[] = {0, 0};
-    is_heap(i1, i1).check([&](bool r){ CHECK(r); });
-    is_heap(i1, i1+1).check([&](bool r){ CHECK(r == (std::is_heap_until(i1, i1+1) == i1+1)); });
-    int i2[] = {0, 1};
-    int i3[] = {1, 0};
-    is_heap(i1, i1+2).check([&](bool r){ CHECK(r == (std::is_heap_until(i1, i1+2) == i1+2)); });
-    is_heap(i2, i2+2).check([&](bool r){ CHECK(r == (std::is_heap_until(i2, i2+2) == i2+2)); });
-    is_heap(i3, i3+2).check([&](bool r){ CHECK(r == (std::is_heap_until(i3, i3+2) == i3+2)); });
-    int i4[] = {0, 0, 0};
-    int i5[] = {0, 0, 1};
-    int i6[] = {0, 1, 0};
-    int i7[] = {0, 1, 1};
-    int i8[] = {1, 0, 0};
-    int i9[] = {1, 0, 1};
-    int i10[] = {1, 1, 0};
-    is_heap(i4, i4+3).check([&](bool r){ CHECK(r == (std::is_heap_until(i4, i4+3) == i4+3)); });
-    is_heap(i5, i5+3).check([&](bool r){ CHECK(r == (std::is_heap_until(i5, i5+3) == i5+3)); });
-    is_heap(i6, i6+3).check([&](bool r){ CHECK(r == (std::is_heap_until(i6, i6+3) == i6+3)); });
-    is_heap(i7, i7+3).check([&](bool r){ CHECK(r == (std::is_heap_until(i7, i7+3) == i7+3)); });
-    is_heap(i8, i8+3).check([&](bool r){ CHECK(r == (std::is_heap_until(i8, i8+3) == i8+3)); });
-    is_heap(i9, i9+3).check([&](bool r){ CHECK(r == (std::is_heap_until(i9, i9+3) == i9+3)); });
-    is_heap(i10, i10+3).check([&](bool r){ CHECK(r == (std::is_heap_until(i10, i10+3) == i10+3)); });
-    int i11[] = {0, 0, 0, 0};
-    int i12[] = {0, 0, 0, 1};
-    int i13[] = {0, 0, 1, 0};
-    int i14[] = {0, 0, 1, 1};
-    int i15[] = {0, 1, 0, 0};
-    int i16[] = {0, 1, 0, 1};
-    int i17[] = {0, 1, 1, 0};
-    int i18[] = {0, 1, 1, 1};
-    int i19[] = {1, 0, 0, 0};
-    int i20[] = {1, 0, 0, 1};
-    int i21[] = {1, 0, 1, 0};
-    int i22[] = {1, 0, 1, 1};
-    int i23[] = {1, 1, 0, 0};
-    int i24[] = {1, 1, 0, 1};
-    int i25[] = {1, 1, 1, 0};
-    is_heap(i11, i11+4).check([&](bool r){ CHECK(r == (std::is_heap_until(i11, i11+4) == i11+4)); });
-    is_heap(i12, i12+4).check([&](bool r){ CHECK(r == (std::is_heap_until(i12, i12+4) == i12+4)); });
-    is_heap(i13, i13+4).check([&](bool r){ CHECK(r == (std::is_heap_until(i13, i13+4) == i13+4)); });
-    is_heap(i14, i14+4).check([&](bool r){ CHECK(r == (std::is_heap_until(i14, i14+4) == i14+4)); });
-    is_heap(i15, i15+4).check([&](bool r){ CHECK(r == (std::is_heap_until(i15, i15+4) == i15+4)); });
-    is_heap(i16, i16+4).check([&](bool r){ CHECK(r == (std::is_heap_until(i16, i16+4) == i16+4)); });
-    is_heap(i17, i17+4).check([&](bool r){ CHECK(r == (std::is_heap_until(i17, i17+4) == i17+4)); });
-    is_heap(i18, i18+4).check([&](bool r){ CHECK(r == (std::is_heap_until(i18, i18+4) == i18+4)); });
-    is_heap(i19, i19+4).check([&](bool r){ CHECK(r == (std::is_heap_until(i19, i19+4) == i19+4)); });
-    is_heap(i20, i20+4).check([&](bool r){ CHECK(r == (std::is_heap_until(i20, i20+4) == i20+4)); });
-    is_heap(i21, i21+4).check([&](bool r){ CHECK(r == (std::is_heap_until(i21, i21+4) == i21+4)); });
-    is_heap(i22, i22+4).check([&](bool r){ CHECK(r == (std::is_heap_until(i22, i22+4) == i22+4)); });
-    is_heap(i23, i23+4).check([&](bool r){ CHECK(r == (std::is_heap_until(i23, i23+4) == i23+4)); });
-    is_heap(i24, i24+4).check([&](bool r){ CHECK(r == (std::is_heap_until(i24, i24+4) == i24+4)); });
-    is_heap(i25, i25+4).check([&](bool r){ CHECK(r == (std::is_heap_until(i25, i25+4) == i25+4)); });
-    int i26[] = {0, 0, 0, 0, 0};
-    int i27[] = {0, 0, 0, 0, 1};
-    int i28[] = {0, 0, 0, 1, 0};
-    int i29[] = {0, 0, 0, 1, 1};
-    int i30[] = {0, 0, 1, 0, 0};
-    int i31[] = {0, 0, 1, 0, 1};
-    int i32[] = {0, 0, 1, 1, 0};
-    int i33[] = {0, 0, 1, 1, 1};
-    int i34[] = {0, 1, 0, 0, 0};
-    int i35[] = {0, 1, 0, 0, 1};
-    int i36[] = {0, 1, 0, 1, 0};
-    int i37[] = {0, 1, 0, 1, 1};
-    int i38[] = {0, 1, 1, 0, 0};
-    int i39[] = {0, 1, 1, 0, 1};
-    int i40[] = {0, 1, 1, 1, 0};
-    int i41[] = {0, 1, 1, 1, 1};
-    int i42[] = {1, 0, 0, 0, 0};
-    int i43[] = {1, 0, 0, 0, 1};
-    int i44[] = {1, 0, 0, 1, 0};
-    int i45[] = {1, 0, 0, 1, 1};
-    int i46[] = {1, 0, 1, 0, 0};
-    int i47[] = {1, 0, 1, 0, 1};
-    int i48[] = {1, 0, 1, 1, 0};
-    int i49[] = {1, 0, 1, 1, 1};
-    int i50[] = {1, 1, 0, 0, 0};
-    int i51[] = {1, 1, 0, 0, 1};
-    int i52[] = {1, 1, 0, 1, 0};
-    int i53[] = {1, 1, 0, 1, 1};
-    int i54[] = {1, 1, 1, 0, 0};
-    int i55[] = {1, 1, 1, 0, 1};
-    int i56[] = {1, 1, 1, 1, 0};
-    is_heap(i26, i26+5).check([&](bool r){ CHECK(r == (std::is_heap_until(i26, i26+5) == i26+5)); });
-    is_heap(i27, i27+5).check([&](bool r){ CHECK(r == (std::is_heap_until(i27, i27+5) == i27+5)); });
-    is_heap(i28, i28+5).check([&](bool r){ CHECK(r == (std::is_heap_until(i28, i28+5) == i28+5)); });
-    is_heap(i29, i29+5).check([&](bool r){ CHECK(r == (std::is_heap_until(i29, i29+5) == i29+5)); });
-    is_heap(i30, i30+5).check([&](bool r){ CHECK(r == (std::is_heap_until(i30, i30+5) == i30+5)); });
-    is_heap(i31, i31+5).check([&](bool r){ CHECK(r == (std::is_heap_until(i31, i31+5) == i31+5)); });
-    is_heap(i32, i32+5).check([&](bool r){ CHECK(r == (std::is_heap_until(i32, i32+5) == i32+5)); });
-    is_heap(i33, i33+5).check([&](bool r){ CHECK(r == (std::is_heap_until(i33, i33+5) == i33+5)); });
-    is_heap(i34, i34+5).check([&](bool r){ CHECK(r == (std::is_heap_until(i34, i34+5) == i34+5)); });
-    is_heap(i35, i35+5).check([&](bool r){ CHECK(r == (std::is_heap_until(i35, i35+5) == i35+5)); });
-    is_heap(i36, i36+5).check([&](bool r){ CHECK(r == (std::is_heap_until(i36, i36+5) == i36+5)); });
-    is_heap(i37, i37+5).check([&](bool r){ CHECK(r == (std::is_heap_until(i37, i37+5) == i37+5)); });
-    is_heap(i38, i38+5).check([&](bool r){ CHECK(r == (std::is_heap_until(i38, i38+5) == i38+5)); });
-    is_heap(i39, i39+5).check([&](bool r){ CHECK(r == (std::is_heap_until(i39, i39+5) == i39+5)); });
-    is_heap(i40, i40+5).check([&](bool r){ CHECK(r == (std::is_heap_until(i40, i40+5) == i40+5)); });
-    is_heap(i41, i41+5).check([&](bool r){ CHECK(r == (std::is_heap_until(i41, i41+5) == i41+5)); });
-    is_heap(i42, i42+5).check([&](bool r){ CHECK(r == (std::is_heap_until(i42, i42+5) == i42+5)); });
-    is_heap(i43, i43+5).check([&](bool r){ CHECK(r == (std::is_heap_until(i43, i43+5) == i43+5)); });
-    is_heap(i44, i44+5).check([&](bool r){ CHECK(r == (std::is_heap_until(i44, i44+5) == i44+5)); });
-    is_heap(i45, i45+5).check([&](bool r){ CHECK(r == (std::is_heap_until(i45, i45+5) == i45+5)); });
-    is_heap(i46, i46+5).check([&](bool r){ CHECK(r == (std::is_heap_until(i46, i46+5) == i46+5)); });
-    is_heap(i47, i47+5).check([&](bool r){ CHECK(r == (std::is_heap_until(i47, i47+5) == i47+5)); });
-    is_heap(i48, i48+5).check([&](bool r){ CHECK(r == (std::is_heap_until(i48, i48+5) == i48+5)); });
-    is_heap(i49, i49+5).check([&](bool r){ CHECK(r == (std::is_heap_until(i49, i49+5) == i49+5)); });
-    is_heap(i50, i50+5).check([&](bool r){ CHECK(r == (std::is_heap_until(i50, i50+5) == i50+5)); });
-    is_heap(i51, i51+5).check([&](bool r){ CHECK(r == (std::is_heap_until(i51, i51+5) == i51+5)); });
-    is_heap(i52, i52+5).check([&](bool r){ CHECK(r == (std::is_heap_until(i52, i52+5) == i52+5)); });
-    is_heap(i53, i53+5).check([&](bool r){ CHECK(r == (std::is_heap_until(i53, i53+5) == i53+5)); });
-    is_heap(i54, i54+5).check([&](bool r){ CHECK(r == (std::is_heap_until(i54, i54+5) == i54+5)); });
-    is_heap(i55, i55+5).check([&](bool r){ CHECK(r == (std::is_heap_until(i55, i55+5) == i55+5)); });
-    is_heap(i56, i56+5).check([&](bool r){ CHECK(r == (std::is_heap_until(i56, i56+5) == i56+5)); });
-    int i57[] = {0, 0, 0, 0, 0, 0};
-    int i58[] = {0, 0, 0, 0, 0, 1};
-    int i59[] = {0, 0, 0, 0, 1, 0};
-    int i60[] = {0, 0, 0, 0, 1, 1};
-    int i61[] = {0, 0, 0, 1, 0, 0};
-    int i62[] = {0, 0, 0, 1, 0, 1};
-    int i63[] = {0, 0, 0, 1, 1, 0};
-    int i64[] = {0, 0, 0, 1, 1, 1};
-    int i65[] = {0, 0, 1, 0, 0, 0};
-    int i66[] = {0, 0, 1, 0, 0, 1};
-    int i67[] = {0, 0, 1, 0, 1, 0};
-    int i68[] = {0, 0, 1, 0, 1, 1};
-    int i69[] = {0, 0, 1, 1, 0, 0};
-    int i70[] = {0, 0, 1, 1, 0, 1};
-    int i71[] = {0, 0, 1, 1, 1, 0};
-    int i72[] = {0, 0, 1, 1, 1, 1};
-    int i73[] = {0, 1, 0, 0, 0, 0};
-    int i74[] = {0, 1, 0, 0, 0, 1};
-    int i75[] = {0, 1, 0, 0, 1, 0};
-    int i76[] = {0, 1, 0, 0, 1, 1};
-    int i77[] = {0, 1, 0, 1, 0, 0};
-    int i78[] = {0, 1, 0, 1, 0, 1};
-    int i79[] = {0, 1, 0, 1, 1, 0};
-    int i80[] = {0, 1, 0, 1, 1, 1};
-    int i81[] = {0, 1, 1, 0, 0, 0};
-    int i82[] = {0, 1, 1, 0, 0, 1};
-    int i83[] = {0, 1, 1, 0, 1, 0};
-    int i84[] = {0, 1, 1, 0, 1, 1};
-    int i85[] = {0, 1, 1, 1, 0, 0};
-    int i86[] = {0, 1, 1, 1, 0, 1};
-    int i87[] = {0, 1, 1, 1, 1, 0};
-    int i88[] = {0, 1, 1, 1, 1, 1};
-    int i89[] = {1, 0, 0, 0, 0, 0};
-    int i90[] = {1, 0, 0, 0, 0, 1};
-    int i91[] = {1, 0, 0, 0, 1, 0};
-    int i92[] = {1, 0, 0, 0, 1, 1};
-    int i93[] = {1, 0, 0, 1, 0, 0};
-    int i94[] = {1, 0, 0, 1, 0, 1};
-    int i95[] = {1, 0, 0, 1, 1, 0};
-    int i96[] = {1, 0, 0, 1, 1, 1};
-    int i97[] = {1, 0, 1, 0, 0, 0};
-    int i98[] = {1, 0, 1, 0, 0, 1};
-    int i99[] = {1, 0, 1, 0, 1, 0};
-    int i100[] = {1, 0, 1, 0, 1, 1};
-    int i101[] = {1, 0, 1, 1, 0, 0};
-    int i102[] = {1, 0, 1, 1, 0, 1};
-    int i103[] = {1, 0, 1, 1, 1, 0};
-    int i104[] = {1, 0, 1, 1, 1, 1};
-    int i105[] = {1, 1, 0, 0, 0, 0};
-    int i106[] = {1, 1, 0, 0, 0, 1};
-    int i107[] = {1, 1, 0, 0, 1, 0};
-    int i108[] = {1, 1, 0, 0, 1, 1};
-    int i109[] = {1, 1, 0, 1, 0, 0};
-    int i110[] = {1, 1, 0, 1, 0, 1};
-    int i111[] = {1, 1, 0, 1, 1, 0};
-    int i112[] = {1, 1, 0, 1, 1, 1};
-    int i113[] = {1, 1, 1, 0, 0, 0};
-    int i114[] = {1, 1, 1, 0, 0, 1};
-    int i115[] = {1, 1, 1, 0, 1, 0};
-    int i116[] = {1, 1, 1, 0, 1, 1};
-    int i117[] = {1, 1, 1, 1, 0, 0};
-    int i118[] = {1, 1, 1, 1, 0, 1};
-    int i119[] = {1, 1, 1, 1, 1, 0};
-    is_heap(i57, i57+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i57, i57+6) == i57+6)); });
-    is_heap(i58, i58+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i58, i58+6) == i58+6)); });
-    is_heap(i59, i59+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i59, i59+6) == i59+6)); });
-    is_heap(i60, i60+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i60, i60+6) == i60+6)); });
-    is_heap(i61, i61+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i61, i61+6) == i61+6)); });
-    is_heap(i62, i62+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i62, i62+6) == i62+6)); });
-    is_heap(i63, i63+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i63, i63+6) == i63+6)); });
-    is_heap(i64, i64+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i64, i64+6) == i64+6)); });
-    is_heap(i65, i65+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i65, i65+6) == i65+6)); });
-    is_heap(i66, i66+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i66, i66+6) == i66+6)); });
-    is_heap(i67, i67+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i67, i67+6) == i67+6)); });
-    is_heap(i68, i68+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i68, i68+6) == i68+6)); });
-    is_heap(i69, i69+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i69, i69+6) == i69+6)); });
-    is_heap(i70, i70+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i70, i70+6) == i70+6)); });
-    is_heap(i71, i71+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i71, i71+6) == i71+6)); });
-    is_heap(i72, i72+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i72, i72+6) == i72+6)); });
-    is_heap(i73, i73+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i73, i73+6) == i73+6)); });
-    is_heap(i74, i74+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i74, i74+6) == i74+6)); });
-    is_heap(i75, i75+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i75, i75+6) == i75+6)); });
-    is_heap(i76, i76+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i76, i76+6) == i76+6)); });
-    is_heap(i77, i77+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i77, i77+6) == i77+6)); });
-    is_heap(i78, i78+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i78, i78+6) == i78+6)); });
-    is_heap(i79, i79+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i79, i79+6) == i79+6)); });
-    is_heap(i80, i80+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i80, i80+6) == i80+6)); });
-    is_heap(i81, i81+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i81, i81+6) == i81+6)); });
-    is_heap(i82, i82+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i82, i82+6) == i82+6)); });
-    is_heap(i83, i83+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i83, i83+6) == i83+6)); });
-    is_heap(i84, i84+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i84, i84+6) == i84+6)); });
-    is_heap(i85, i85+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i85, i85+6) == i85+6)); });
-    is_heap(i86, i86+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i86, i86+6) == i86+6)); });
-    is_heap(i87, i87+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i87, i87+6) == i87+6)); });
-    is_heap(i88, i88+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i88, i88+6) == i88+6)); });
-    is_heap(i89, i89+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i89, i89+6) == i89+6)); });
-    is_heap(i90, i90+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i90, i90+6) == i90+6)); });
-    is_heap(i91, i91+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i91, i91+6) == i91+6)); });
-    is_heap(i92, i92+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i92, i92+6) == i92+6)); });
-    is_heap(i93, i93+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i93, i93+6) == i93+6)); });
-    is_heap(i94, i94+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i94, i94+6) == i94+6)); });
-    is_heap(i95, i95+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i95, i95+6) == i95+6)); });
-    is_heap(i96, i96+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i96, i96+6) == i96+6)); });
-    is_heap(i97, i97+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i97, i97+6) == i97+6)); });
-    is_heap(i98, i98+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i98, i98+6) == i98+6)); });
-    is_heap(i99, i99+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i99, i99+6) == i99+6)); });
-    is_heap(i100, i100+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i100, i100+6) == i100+6)); });
-    is_heap(i101, i101+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i101, i101+6) == i101+6)); });
-    is_heap(i102, i102+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i102, i102+6) == i102+6)); });
-    is_heap(i103, i103+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i103, i103+6) == i103+6)); });
-    is_heap(i104, i104+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i104, i104+6) == i104+6)); });
-    is_heap(i105, i105+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i105, i105+6) == i105+6)); });
-    is_heap(i106, i106+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i106, i106+6) == i106+6)); });
-    is_heap(i107, i107+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i107, i107+6) == i107+6)); });
-    is_heap(i108, i108+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i108, i108+6) == i108+6)); });
-    is_heap(i109, i109+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i109, i109+6) == i109+6)); });
-    is_heap(i110, i110+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i110, i110+6) == i110+6)); });
-    is_heap(i111, i111+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i111, i111+6) == i111+6)); });
-    is_heap(i112, i112+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i112, i112+6) == i112+6)); });
-    is_heap(i113, i113+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i113, i113+6) == i113+6)); });
-    is_heap(i114, i114+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i114, i114+6) == i114+6)); });
-    is_heap(i115, i115+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i115, i115+6) == i115+6)); });
-    is_heap(i116, i116+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i116, i116+6) == i116+6)); });
-    is_heap(i117, i117+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i117, i117+6) == i117+6)); });
-    is_heap(i118, i118+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i118, i118+6) == i118+6)); });
-    is_heap(i119, i119+6).check([&](bool r){ CHECK(r == (std::is_heap_until(i119, i119+6) == i119+6)); });
-#endif
-#ifdef IS_HEAP_2
-    int i120[] = {0, 0, 0, 0, 0, 0, 0};
-    int i121[] = {0, 0, 0, 0, 0, 0, 1};
-    int i122[] = {0, 0, 0, 0, 0, 1, 0};
-    int i123[] = {0, 0, 0, 0, 0, 1, 1};
-    int i124[] = {0, 0, 0, 0, 1, 0, 0};
-    int i125[] = {0, 0, 0, 0, 1, 0, 1};
-    int i126[] = {0, 0, 0, 0, 1, 1, 0};
-    int i127[] = {0, 0, 0, 0, 1, 1, 1};
-    int i128[] = {0, 0, 0, 1, 0, 0, 0};
-    int i129[] = {0, 0, 0, 1, 0, 0, 1};
-    int i130[] = {0, 0, 0, 1, 0, 1, 0};
-    int i131[] = {0, 0, 0, 1, 0, 1, 1};
-    int i132[] = {0, 0, 0, 1, 1, 0, 0};
-    int i133[] = {0, 0, 0, 1, 1, 0, 1};
-    int i134[] = {0, 0, 0, 1, 1, 1, 0};
-    int i135[] = {0, 0, 0, 1, 1, 1, 1};
-    int i136[] = {0, 0, 1, 0, 0, 0, 0};
-    int i137[] = {0, 0, 1, 0, 0, 0, 1};
-    int i138[] = {0, 0, 1, 0, 0, 1, 0};
-    int i139[] = {0, 0, 1, 0, 0, 1, 1};
-    int i140[] = {0, 0, 1, 0, 1, 0, 0};
-    int i141[] = {0, 0, 1, 0, 1, 0, 1};
-    int i142[] = {0, 0, 1, 0, 1, 1, 0};
-    int i143[] = {0, 0, 1, 0, 1, 1, 1};
-    int i144[] = {0, 0, 1, 1, 0, 0, 0};
-    int i145[] = {0, 0, 1, 1, 0, 0, 1};
-    int i146[] = {0, 0, 1, 1, 0, 1, 0};
-    int i147[] = {0, 0, 1, 1, 0, 1, 1};
-    int i148[] = {0, 0, 1, 1, 1, 0, 0};
-    int i149[] = {0, 0, 1, 1, 1, 0, 1};
-    int i150[] = {0, 0, 1, 1, 1, 1, 0};
-    int i151[] = {0, 0, 1, 1, 1, 1, 1};
-    int i152[] = {0, 1, 0, 0, 0, 0, 0};
-    int i153[] = {0, 1, 0, 0, 0, 0, 1};
-    int i154[] = {0, 1, 0, 0, 0, 1, 0};
-    int i155[] = {0, 1, 0, 0, 0, 1, 1};
-    int i156[] = {0, 1, 0, 0, 1, 0, 0};
-    int i157[] = {0, 1, 0, 0, 1, 0, 1};
-    int i158[] = {0, 1, 0, 0, 1, 1, 0};
-    int i159[] = {0, 1, 0, 0, 1, 1, 1};
-    int i160[] = {0, 1, 0, 1, 0, 0, 0};
-    int i161[] = {0, 1, 0, 1, 0, 0, 1};
-    int i162[] = {0, 1, 0, 1, 0, 1, 0};
-    int i163[] = {0, 1, 0, 1, 0, 1, 1};
-    int i164[] = {0, 1, 0, 1, 1, 0, 0};
-    int i165[] = {0, 1, 0, 1, 1, 0, 1};
-    int i166[] = {0, 1, 0, 1, 1, 1, 0};
-    int i167[] = {0, 1, 0, 1, 1, 1, 1};
-    int i168[] = {0, 1, 1, 0, 0, 0, 0};
-    int i169[] = {0, 1, 1, 0, 0, 0, 1};
-    int i170[] = {0, 1, 1, 0, 0, 1, 0};
-    int i171[] = {0, 1, 1, 0, 0, 1, 1};
-    int i172[] = {0, 1, 1, 0, 1, 0, 0};
-    int i173[] = {0, 1, 1, 0, 1, 0, 1};
-    int i174[] = {0, 1, 1, 0, 1, 1, 0};
-    int i175[] = {0, 1, 1, 0, 1, 1, 1};
-    int i176[] = {0, 1, 1, 1, 0, 0, 0};
-    int i177[] = {0, 1, 1, 1, 0, 0, 1};
-    int i178[] = {0, 1, 1, 1, 0, 1, 0};
-    int i179[] = {0, 1, 1, 1, 0, 1, 1};
-    int i180[] = {0, 1, 1, 1, 1, 0, 0};
-    int i181[] = {0, 1, 1, 1, 1, 0, 1};
-    int i182[] = {0, 1, 1, 1, 1, 1, 0};
-    int i183[] = {0, 1, 1, 1, 1, 1, 1};
-    int i184[] = {1, 0, 0, 0, 0, 0, 0};
-    int i185[] = {1, 0, 0, 0, 0, 0, 1};
-    int i186[] = {1, 0, 0, 0, 0, 1, 0};
-    int i187[] = {1, 0, 0, 0, 0, 1, 1};
-    int i188[] = {1, 0, 0, 0, 1, 0, 0};
-    int i189[] = {1, 0, 0, 0, 1, 0, 1};
-    int i190[] = {1, 0, 0, 0, 1, 1, 0};
-    int i191[] = {1, 0, 0, 0, 1, 1, 1};
-    int i192[] = {1, 0, 0, 1, 0, 0, 0};
-    int i193[] = {1, 0, 0, 1, 0, 0, 1};
-    int i194[] = {1, 0, 0, 1, 0, 1, 0};
-    int i195[] = {1, 0, 0, 1, 0, 1, 1};
-    int i196[] = {1, 0, 0, 1, 1, 0, 0};
-    int i197[] = {1, 0, 0, 1, 1, 0, 1};
-    int i198[] = {1, 0, 0, 1, 1, 1, 0};
-    int i199[] = {1, 0, 0, 1, 1, 1, 1};
-    int i200[] = {1, 0, 1, 0, 0, 0, 0};
-    int i201[] = {1, 0, 1, 0, 0, 0, 1};
-    int i202[] = {1, 0, 1, 0, 0, 1, 0};
-    int i203[] = {1, 0, 1, 0, 0, 1, 1};
-    int i204[] = {1, 0, 1, 0, 1, 0, 0};
-    int i205[] = {1, 0, 1, 0, 1, 0, 1};
-    int i206[] = {1, 0, 1, 0, 1, 1, 0};
-    int i207[] = {1, 0, 1, 0, 1, 1, 1};
-    int i208[] = {1, 0, 1, 1, 0, 0, 0};
-    int i209[] = {1, 0, 1, 1, 0, 0, 1};
-    int i210[] = {1, 0, 1, 1, 0, 1, 0};
-    int i211[] = {1, 0, 1, 1, 0, 1, 1};
-    int i212[] = {1, 0, 1, 1, 1, 0, 0};
-    int i213[] = {1, 0, 1, 1, 1, 0, 1};
-    int i214[] = {1, 0, 1, 1, 1, 1, 0};
-    int i215[] = {1, 0, 1, 1, 1, 1, 1};
-    int i216[] = {1, 1, 0, 0, 0, 0, 0};
-    int i217[] = {1, 1, 0, 0, 0, 0, 1};
-    int i218[] = {1, 1, 0, 0, 0, 1, 0};
-    int i219[] = {1, 1, 0, 0, 0, 1, 1};
-    int i220[] = {1, 1, 0, 0, 1, 0, 0};
-    int i221[] = {1, 1, 0, 0, 1, 0, 1};
-    int i222[] = {1, 1, 0, 0, 1, 1, 0};
-    int i223[] = {1, 1, 0, 0, 1, 1, 1};
-    int i224[] = {1, 1, 0, 1, 0, 0, 0};
-    int i225[] = {1, 1, 0, 1, 0, 0, 1};
-    int i226[] = {1, 1, 0, 1, 0, 1, 0};
-    int i227[] = {1, 1, 0, 1, 0, 1, 1};
-    int i228[] = {1, 1, 0, 1, 1, 0, 0};
-    int i229[] = {1, 1, 0, 1, 1, 0, 1};
-    int i230[] = {1, 1, 0, 1, 1, 1, 0};
-    int i231[] = {1, 1, 0, 1, 1, 1, 1};
-    int i232[] = {1, 1, 1, 0, 0, 0, 0};
-    int i233[] = {1, 1, 1, 0, 0, 0, 1};
-    int i234[] = {1, 1, 1, 0, 0, 1, 0};
-    int i235[] = {1, 1, 1, 0, 0, 1, 1};
-    int i236[] = {1, 1, 1, 0, 1, 0, 0};
-    int i237[] = {1, 1, 1, 0, 1, 0, 1};
-    int i238[] = {1, 1, 1, 0, 1, 1, 0};
-    int i239[] = {1, 1, 1, 0, 1, 1, 1};
-    int i240[] = {1, 1, 1, 1, 0, 0, 0};
-    int i241[] = {1, 1, 1, 1, 0, 0, 1};
-    int i242[] = {1, 1, 1, 1, 0, 1, 0};
-    int i243[] = {1, 1, 1, 1, 0, 1, 1};
-    int i244[] = {1, 1, 1, 1, 1, 0, 0};
-    int i245[] = {1, 1, 1, 1, 1, 0, 1};
-    int i246[] = {1, 1, 1, 1, 1, 1, 0};
-    is_heap(i120, i120+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i120, i120+7) == i120+7)); });
-    is_heap(i121, i121+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i121, i121+7) == i121+7)); });
-    is_heap(i122, i122+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i122, i122+7) == i122+7)); });
-    is_heap(i123, i123+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i123, i123+7) == i123+7)); });
-    is_heap(i124, i124+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i124, i124+7) == i124+7)); });
-    is_heap(i125, i125+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i125, i125+7) == i125+7)); });
-    is_heap(i126, i126+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i126, i126+7) == i126+7)); });
-    is_heap(i127, i127+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i127, i127+7) == i127+7)); });
-    is_heap(i128, i128+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i128, i128+7) == i128+7)); });
-    is_heap(i129, i129+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i129, i129+7) == i129+7)); });
-    is_heap(i130, i130+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i130, i130+7) == i130+7)); });
-    is_heap(i131, i131+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i131, i131+7) == i131+7)); });
-    is_heap(i132, i132+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i132, i132+7) == i132+7)); });
-    is_heap(i133, i133+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i133, i133+7) == i133+7)); });
-    is_heap(i134, i134+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i134, i134+7) == i134+7)); });
-    is_heap(i135, i135+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i135, i135+7) == i135+7)); });
-    is_heap(i136, i136+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i136, i136+7) == i136+7)); });
-    is_heap(i137, i137+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i137, i137+7) == i137+7)); });
-    is_heap(i138, i138+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i138, i138+7) == i138+7)); });
-    is_heap(i139, i139+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i139, i139+7) == i139+7)); });
-    is_heap(i140, i140+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i140, i140+7) == i140+7)); });
-    is_heap(i141, i141+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i141, i141+7) == i141+7)); });
-    is_heap(i142, i142+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i142, i142+7) == i142+7)); });
-    is_heap(i143, i143+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i143, i143+7) == i143+7)); });
-    is_heap(i144, i144+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i144, i144+7) == i144+7)); });
-    is_heap(i145, i145+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i145, i145+7) == i145+7)); });
-    is_heap(i146, i146+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i146, i146+7) == i146+7)); });
-    is_heap(i147, i147+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i147, i147+7) == i147+7)); });
-    is_heap(i148, i148+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i148, i148+7) == i148+7)); });
-    is_heap(i149, i149+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i149, i149+7) == i149+7)); });
-    is_heap(i150, i150+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i150, i150+7) == i150+7)); });
-    is_heap(i151, i151+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i151, i151+7) == i151+7)); });
-    is_heap(i152, i152+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i152, i152+7) == i152+7)); });
-    is_heap(i153, i153+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i153, i153+7) == i153+7)); });
-    is_heap(i154, i154+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i154, i154+7) == i154+7)); });
-    is_heap(i155, i155+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i155, i155+7) == i155+7)); });
-    is_heap(i156, i156+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i156, i156+7) == i156+7)); });
-    is_heap(i157, i157+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i157, i157+7) == i157+7)); });
-    is_heap(i158, i158+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i158, i158+7) == i158+7)); });
-    is_heap(i159, i159+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i159, i159+7) == i159+7)); });
-    is_heap(i160, i160+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i160, i160+7) == i160+7)); });
-    is_heap(i161, i161+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i161, i161+7) == i161+7)); });
-    is_heap(i162, i162+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i162, i162+7) == i162+7)); });
-    is_heap(i163, i163+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i163, i163+7) == i163+7)); });
-    is_heap(i164, i164+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i164, i164+7) == i164+7)); });
-    is_heap(i165, i165+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i165, i165+7) == i165+7)); });
-    is_heap(i166, i166+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i166, i166+7) == i166+7)); });
-    is_heap(i167, i167+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i167, i167+7) == i167+7)); });
-    is_heap(i168, i168+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i168, i168+7) == i168+7)); });
-    is_heap(i169, i169+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i169, i169+7) == i169+7)); });
-    is_heap(i170, i170+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i170, i170+7) == i170+7)); });
-    is_heap(i171, i171+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i171, i171+7) == i171+7)); });
-    is_heap(i172, i172+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i172, i172+7) == i172+7)); });
-    is_heap(i173, i173+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i173, i173+7) == i173+7)); });
-    is_heap(i174, i174+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i174, i174+7) == i174+7)); });
-    is_heap(i175, i175+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i175, i175+7) == i175+7)); });
-    is_heap(i176, i176+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i176, i176+7) == i176+7)); });
-    is_heap(i177, i177+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i177, i177+7) == i177+7)); });
-    is_heap(i178, i178+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i178, i178+7) == i178+7)); });
-    is_heap(i179, i179+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i179, i179+7) == i179+7)); });
-    is_heap(i180, i180+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i180, i180+7) == i180+7)); });
-    is_heap(i181, i181+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i181, i181+7) == i181+7)); });
-    is_heap(i182, i182+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i182, i182+7) == i182+7)); });
-    is_heap(i183, i183+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i183, i183+7) == i183+7)); });
-    is_heap(i184, i184+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i184, i184+7) == i184+7)); });
-    is_heap(i185, i185+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i185, i185+7) == i185+7)); });
-    is_heap(i186, i186+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i186, i186+7) == i186+7)); });
-    is_heap(i187, i187+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i187, i187+7) == i187+7)); });
-    is_heap(i188, i188+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i188, i188+7) == i188+7)); });
-    is_heap(i189, i189+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i189, i189+7) == i189+7)); });
-    is_heap(i190, i190+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i190, i190+7) == i190+7)); });
-    is_heap(i191, i191+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i191, i191+7) == i191+7)); });
-    is_heap(i192, i192+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i192, i192+7) == i192+7)); });
-    is_heap(i193, i193+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i193, i193+7) == i193+7)); });
-    is_heap(i194, i194+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i194, i194+7) == i194+7)); });
-    is_heap(i195, i195+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i195, i195+7) == i195+7)); });
-    is_heap(i196, i196+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i196, i196+7) == i196+7)); });
-    is_heap(i197, i197+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i197, i197+7) == i197+7)); });
-    is_heap(i198, i198+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i198, i198+7) == i198+7)); });
-    is_heap(i199, i199+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i199, i199+7) == i199+7)); });
-    is_heap(i200, i200+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i200, i200+7) == i200+7)); });
-    is_heap(i201, i201+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i201, i201+7) == i201+7)); });
-    is_heap(i202, i202+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i202, i202+7) == i202+7)); });
-    is_heap(i203, i203+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i203, i203+7) == i203+7)); });
-    is_heap(i204, i204+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i204, i204+7) == i204+7)); });
-    is_heap(i205, i205+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i205, i205+7) == i205+7)); });
-    is_heap(i206, i206+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i206, i206+7) == i206+7)); });
-    is_heap(i207, i207+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i207, i207+7) == i207+7)); });
-    is_heap(i208, i208+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i208, i208+7) == i208+7)); });
-    is_heap(i209, i209+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i209, i209+7) == i209+7)); });
-    is_heap(i210, i210+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i210, i210+7) == i210+7)); });
-    is_heap(i211, i211+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i211, i211+7) == i211+7)); });
-    is_heap(i212, i212+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i212, i212+7) == i212+7)); });
-    is_heap(i213, i213+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i213, i213+7) == i213+7)); });
-    is_heap(i214, i214+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i214, i214+7) == i214+7)); });
-    is_heap(i215, i215+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i215, i215+7) == i215+7)); });
-    is_heap(i216, i216+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i216, i216+7) == i216+7)); });
-    is_heap(i217, i217+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i217, i217+7) == i217+7)); });
-    is_heap(i218, i218+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i218, i218+7) == i218+7)); });
-    is_heap(i219, i219+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i219, i219+7) == i219+7)); });
-    is_heap(i220, i220+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i220, i220+7) == i220+7)); });
-    is_heap(i221, i221+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i221, i221+7) == i221+7)); });
-    is_heap(i222, i222+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i222, i222+7) == i222+7)); });
-    is_heap(i223, i223+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i223, i223+7) == i223+7)); });
-    is_heap(i224, i224+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i224, i224+7) == i224+7)); });
-    is_heap(i225, i225+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i225, i225+7) == i225+7)); });
-    is_heap(i226, i226+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i226, i226+7) == i226+7)); });
-    is_heap(i227, i227+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i227, i227+7) == i227+7)); });
-    is_heap(i228, i228+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i228, i228+7) == i228+7)); });
-    is_heap(i229, i229+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i229, i229+7) == i229+7)); });
-    is_heap(i230, i230+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i230, i230+7) == i230+7)); });
-    is_heap(i231, i231+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i231, i231+7) == i231+7)); });
-    is_heap(i232, i232+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i232, i232+7) == i232+7)); });
-    is_heap(i233, i233+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i233, i233+7) == i233+7)); });
-    is_heap(i234, i234+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i234, i234+7) == i234+7)); });
-    is_heap(i235, i235+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i235, i235+7) == i235+7)); });
-    is_heap(i236, i236+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i236, i236+7) == i236+7)); });
-    is_heap(i237, i237+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i237, i237+7) == i237+7)); });
-    is_heap(i238, i238+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i238, i238+7) == i238+7)); });
-    is_heap(i239, i239+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i239, i239+7) == i239+7)); });
-    is_heap(i240, i240+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i240, i240+7) == i240+7)); });
-    is_heap(i241, i241+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i241, i241+7) == i241+7)); });
-    is_heap(i242, i242+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i242, i242+7) == i242+7)); });
-    is_heap(i243, i243+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i243, i243+7) == i243+7)); });
-    is_heap(i244, i244+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i244, i244+7) == i244+7)); });
-    is_heap(i245, i245+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i245, i245+7) == i245+7)); });
-    is_heap(i246, i246+7).check([&](bool r){ CHECK(r == (std::is_heap_until(i246, i246+7) == i246+7)); });
-#endif
-}
-
-void test_comp()
-{
-#if defined(IS_HEAP_3) || defined(IS_HEAP_4)
-    auto is_heap = make_testable_1(ranges::is_heap);
-#endif
-
-#ifdef IS_HEAP_3
-    int i1[] = {0, 0};
-    is_heap(i1, i1, std::greater<int>()).check([&](bool r){ CHECK(r); });
-    is_heap(i1, i1+1, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i1, i1+1, std::greater<int>()) == i1+1)); });
-    int i2[] = {0, 1};
-    int i3[] = {1, 0};
-    is_heap(i1, i1+2, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i1, i1+2, std::greater<int>()) == i1+2)); });
-    is_heap(i2, i2+2, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i2, i2+2, std::greater<int>()) == i2+2)); });
-    is_heap(i3, i3+2, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i3, i3+2, std::greater<int>()) == i3+2)); });
-    int i4[] = {0, 0, 0};
-    int i5[] = {0, 0, 1};
-    int i6[] = {0, 1, 0};
-    int i7[] = {0, 1, 1};
-    int i8[] = {1, 0, 0};
-    int i9[] = {1, 0, 1};
-    int i10[] = {1, 1, 0};
-    is_heap(i4, i4+3, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i4, i4+3, std::greater<int>()) == i4+3)); });
-    is_heap(i5, i5+3, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i5, i5+3, std::greater<int>()) == i5+3)); });
-    is_heap(i6, i6+3, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i6, i6+3, std::greater<int>()) == i6+3)); });
-    is_heap(i7, i7+3, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i7, i7+3, std::greater<int>()) == i7+3)); });
-    is_heap(i8, i8+3, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i8, i8+3, std::greater<int>()) == i8+3)); });
-    is_heap(i9, i9+3, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i9, i9+3, std::greater<int>()) == i9+3)); });
-    is_heap(i10, i10+3, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i10, i10+3, std::greater<int>()) == i10+3)); });
-    int i11[] = {0, 0, 0, 0};
-    int i12[] = {0, 0, 0, 1};
-    int i13[] = {0, 0, 1, 0};
-    int i14[] = {0, 0, 1, 1};
-    int i15[] = {0, 1, 0, 0};
-    int i16[] = {0, 1, 0, 1};
-    int i17[] = {0, 1, 1, 0};
-    int i18[] = {0, 1, 1, 1};
-    int i19[] = {1, 0, 0, 0};
-    int i20[] = {1, 0, 0, 1};
-    int i21[] = {1, 0, 1, 0};
-    int i22[] = {1, 0, 1, 1};
-    int i23[] = {1, 1, 0, 0};
-    int i24[] = {1, 1, 0, 1};
-    int i25[] = {1, 1, 1, 0};
-    is_heap(i11, i11+4, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i11, i11+4, std::greater<int>()) == i11+4)); });
-    is_heap(i12, i12+4, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i12, i12+4, std::greater<int>()) == i12+4)); });
-    is_heap(i13, i13+4, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i13, i13+4, std::greater<int>()) == i13+4)); });
-    is_heap(i14, i14+4, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i14, i14+4, std::greater<int>()) == i14+4)); });
-    is_heap(i15, i15+4, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i15, i15+4, std::greater<int>()) == i15+4)); });
-    is_heap(i16, i16+4, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i16, i16+4, std::greater<int>()) == i16+4)); });
-    is_heap(i17, i17+4, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i17, i17+4, std::greater<int>()) == i17+4)); });
-    is_heap(i18, i18+4, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i18, i18+4, std::greater<int>()) == i18+4)); });
-    is_heap(i19, i19+4, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i19, i19+4, std::greater<int>()) == i19+4)); });
-    is_heap(i20, i20+4, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i20, i20+4, std::greater<int>()) == i20+4)); });
-    is_heap(i21, i21+4, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i21, i21+4, std::greater<int>()) == i21+4)); });
-    is_heap(i22, i22+4, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i22, i22+4, std::greater<int>()) == i22+4)); });
-    is_heap(i23, i23+4, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i23, i23+4, std::greater<int>()) == i23+4)); });
-    is_heap(i24, i24+4, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i24, i24+4, std::greater<int>()) == i24+4)); });
-    is_heap(i25, i25+4, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i25, i25+4, std::greater<int>()) == i25+4)); });
-    int i26[] = {0, 0, 0, 0, 0};
-    int i27[] = {0, 0, 0, 0, 1};
-    int i28[] = {0, 0, 0, 1, 0};
-    int i29[] = {0, 0, 0, 1, 1};
-    int i30[] = {0, 0, 1, 0, 0};
-    int i31[] = {0, 0, 1, 0, 1};
-    int i32[] = {0, 0, 1, 1, 0};
-    int i33[] = {0, 0, 1, 1, 1};
-    int i34[] = {0, 1, 0, 0, 0};
-    int i35[] = {0, 1, 0, 0, 1};
-    int i36[] = {0, 1, 0, 1, 0};
-    int i37[] = {0, 1, 0, 1, 1};
-    int i38[] = {0, 1, 1, 0, 0};
-    int i39[] = {0, 1, 1, 0, 1};
-    int i40[] = {0, 1, 1, 1, 0};
-    int i41[] = {0, 1, 1, 1, 1};
-    int i42[] = {1, 0, 0, 0, 0};
-    int i43[] = {1, 0, 0, 0, 1};
-    int i44[] = {1, 0, 0, 1, 0};
-    int i45[] = {1, 0, 0, 1, 1};
-    int i46[] = {1, 0, 1, 0, 0};
-    int i47[] = {1, 0, 1, 0, 1};
-    int i48[] = {1, 0, 1, 1, 0};
-    int i49[] = {1, 0, 1, 1, 1};
-    int i50[] = {1, 1, 0, 0, 0};
-    int i51[] = {1, 1, 0, 0, 1};
-    int i52[] = {1, 1, 0, 1, 0};
-    int i53[] = {1, 1, 0, 1, 1};
-    int i54[] = {1, 1, 1, 0, 0};
-    int i55[] = {1, 1, 1, 0, 1};
-    int i56[] = {1, 1, 1, 1, 0};
-    is_heap(i26, i26+5, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i26, i26+5, std::greater<int>()) == i26+5)); });
-    is_heap(i27, i27+5, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i27, i27+5, std::greater<int>()) == i27+5)); });
-    is_heap(i28, i28+5, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i28, i28+5, std::greater<int>()) == i28+5)); });
-    is_heap(i29, i29+5, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i29, i29+5, std::greater<int>()) == i29+5)); });
-    is_heap(i30, i30+5, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i30, i30+5, std::greater<int>()) == i30+5)); });
-    is_heap(i31, i31+5, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i31, i31+5, std::greater<int>()) == i31+5)); });
-    is_heap(i32, i32+5, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i32, i32+5, std::greater<int>()) == i32+5)); });
-    is_heap(i33, i33+5, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i33, i33+5, std::greater<int>()) == i33+5)); });
-    is_heap(i34, i34+5, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i34, i34+5, std::greater<int>()) == i34+5)); });
-    is_heap(i35, i35+5, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i35, i35+5, std::greater<int>()) == i35+5)); });
-    is_heap(i36, i36+5, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i36, i36+5, std::greater<int>()) == i36+5)); });
-    is_heap(i37, i37+5, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i37, i37+5, std::greater<int>()) == i37+5)); });
-    is_heap(i38, i38+5, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i38, i38+5, std::greater<int>()) == i38+5)); });
-    is_heap(i39, i39+5, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i39, i39+5, std::greater<int>()) == i39+5)); });
-    is_heap(i40, i40+5, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i40, i40+5, std::greater<int>()) == i40+5)); });
-    is_heap(i41, i41+5, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i41, i41+5, std::greater<int>()) == i41+5)); });
-    is_heap(i42, i42+5, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i42, i42+5, std::greater<int>()) == i42+5)); });
-    is_heap(i43, i43+5, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i43, i43+5, std::greater<int>()) == i43+5)); });
-    is_heap(i44, i44+5, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i44, i44+5, std::greater<int>()) == i44+5)); });
-    is_heap(i45, i45+5, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i45, i45+5, std::greater<int>()) == i45+5)); });
-    is_heap(i46, i46+5, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i46, i46+5, std::greater<int>()) == i46+5)); });
-    is_heap(i47, i47+5, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i47, i47+5, std::greater<int>()) == i47+5)); });
-    is_heap(i48, i48+5, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i48, i48+5, std::greater<int>()) == i48+5)); });
-    is_heap(i49, i49+5, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i49, i49+5, std::greater<int>()) == i49+5)); });
-    is_heap(i50, i50+5, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i50, i50+5, std::greater<int>()) == i50+5)); });
-    is_heap(i51, i51+5, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i51, i51+5, std::greater<int>()) == i51+5)); });
-    is_heap(i52, i52+5, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i52, i52+5, std::greater<int>()) == i52+5)); });
-    is_heap(i53, i53+5, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i53, i53+5, std::greater<int>()) == i53+5)); });
-    is_heap(i54, i54+5, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i54, i54+5, std::greater<int>()) == i54+5)); });
-    is_heap(i55, i55+5, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i55, i55+5, std::greater<int>()) == i55+5)); });
-    is_heap(i56, i56+5, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i56, i56+5, std::greater<int>()) == i56+5)); });
-    int i57[] = {0, 0, 0, 0, 0, 0};
-    int i58[] = {0, 0, 0, 0, 0, 1};
-    int i59[] = {0, 0, 0, 0, 1, 0};
-    int i60[] = {0, 0, 0, 0, 1, 1};
-    int i61[] = {0, 0, 0, 1, 0, 0};
-    int i62[] = {0, 0, 0, 1, 0, 1};
-    int i63[] = {0, 0, 0, 1, 1, 0};
-    int i64[] = {0, 0, 0, 1, 1, 1};
-    int i65[] = {0, 0, 1, 0, 0, 0};
-    int i66[] = {0, 0, 1, 0, 0, 1};
-    int i67[] = {0, 0, 1, 0, 1, 0};
-    int i68[] = {0, 0, 1, 0, 1, 1};
-    int i69[] = {0, 0, 1, 1, 0, 0};
-    int i70[] = {0, 0, 1, 1, 0, 1};
-    int i71[] = {0, 0, 1, 1, 1, 0};
-    int i72[] = {0, 0, 1, 1, 1, 1};
-    int i73[] = {0, 1, 0, 0, 0, 0};
-    int i74[] = {0, 1, 0, 0, 0, 1};
-    int i75[] = {0, 1, 0, 0, 1, 0};
-    int i76[] = {0, 1, 0, 0, 1, 1};
-    int i77[] = {0, 1, 0, 1, 0, 0};
-    int i78[] = {0, 1, 0, 1, 0, 1};
-    int i79[] = {0, 1, 0, 1, 1, 0};
-    int i80[] = {0, 1, 0, 1, 1, 1};
-    int i81[] = {0, 1, 1, 0, 0, 0};
-    int i82[] = {0, 1, 1, 0, 0, 1};
-    int i83[] = {0, 1, 1, 0, 1, 0};
-    int i84[] = {0, 1, 1, 0, 1, 1};
-    int i85[] = {0, 1, 1, 1, 0, 0};
-    int i86[] = {0, 1, 1, 1, 0, 1};
-    int i87[] = {0, 1, 1, 1, 1, 0};
-    int i88[] = {0, 1, 1, 1, 1, 1};
-    int i89[] = {1, 0, 0, 0, 0, 0};
-    int i90[] = {1, 0, 0, 0, 0, 1};
-    int i91[] = {1, 0, 0, 0, 1, 0};
-    int i92[] = {1, 0, 0, 0, 1, 1};
-    int i93[] = {1, 0, 0, 1, 0, 0};
-    int i94[] = {1, 0, 0, 1, 0, 1};
-    int i95[] = {1, 0, 0, 1, 1, 0};
-    int i96[] = {1, 0, 0, 1, 1, 1};
-    int i97[] = {1, 0, 1, 0, 0, 0};
-    int i98[] = {1, 0, 1, 0, 0, 1};
-    int i99[] = {1, 0, 1, 0, 1, 0};
-    int i100[] = {1, 0, 1, 0, 1, 1};
-    int i101[] = {1, 0, 1, 1, 0, 0};
-    int i102[] = {1, 0, 1, 1, 0, 1};
-    int i103[] = {1, 0, 1, 1, 1, 0};
-    int i104[] = {1, 0, 1, 1, 1, 1};
-    int i105[] = {1, 1, 0, 0, 0, 0};
-    int i106[] = {1, 1, 0, 0, 0, 1};
-    int i107[] = {1, 1, 0, 0, 1, 0};
-    int i108[] = {1, 1, 0, 0, 1, 1};
-    int i109[] = {1, 1, 0, 1, 0, 0};
-    int i110[] = {1, 1, 0, 1, 0, 1};
-    int i111[] = {1, 1, 0, 1, 1, 0};
-    int i112[] = {1, 1, 0, 1, 1, 1};
-    int i113[] = {1, 1, 1, 0, 0, 0};
-    int i114[] = {1, 1, 1, 0, 0, 1};
-    int i115[] = {1, 1, 1, 0, 1, 0};
-    int i116[] = {1, 1, 1, 0, 1, 1};
-    int i117[] = {1, 1, 1, 1, 0, 0};
-    int i118[] = {1, 1, 1, 1, 0, 1};
-    int i119[] = {1, 1, 1, 1, 1, 0};
-    is_heap(i57, i57+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i57, i57+6, std::greater<int>()) == i57+6)); });
-    is_heap(i58, i58+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i58, i58+6, std::greater<int>()) == i58+6)); });
-    is_heap(i59, i59+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i59, i59+6, std::greater<int>()) == i59+6)); });
-    is_heap(i60, i60+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i60, i60+6, std::greater<int>()) == i60+6)); });
-    is_heap(i61, i61+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i61, i61+6, std::greater<int>()) == i61+6)); });
-    is_heap(i62, i62+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i62, i62+6, std::greater<int>()) == i62+6)); });
-    is_heap(i63, i63+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i63, i63+6, std::greater<int>()) == i63+6)); });
-    is_heap(i64, i64+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i64, i64+6, std::greater<int>()) == i64+6)); });
-    is_heap(i65, i65+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i65, i65+6, std::greater<int>()) == i65+6)); });
-    is_heap(i66, i66+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i66, i66+6, std::greater<int>()) == i66+6)); });
-    is_heap(i67, i67+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i67, i67+6, std::greater<int>()) == i67+6)); });
-    is_heap(i68, i68+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i68, i68+6, std::greater<int>()) == i68+6)); });
-    is_heap(i69, i69+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i69, i69+6, std::greater<int>()) == i69+6)); });
-    is_heap(i70, i70+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i70, i70+6, std::greater<int>()) == i70+6)); });
-    is_heap(i71, i71+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i71, i71+6, std::greater<int>()) == i71+6)); });
-    is_heap(i72, i72+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i72, i72+6, std::greater<int>()) == i72+6)); });
-    is_heap(i73, i73+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i73, i73+6, std::greater<int>()) == i73+6)); });
-    is_heap(i74, i74+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i74, i74+6, std::greater<int>()) == i74+6)); });
-    is_heap(i75, i75+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i75, i75+6, std::greater<int>()) == i75+6)); });
-    is_heap(i76, i76+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i76, i76+6, std::greater<int>()) == i76+6)); });
-    is_heap(i77, i77+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i77, i77+6, std::greater<int>()) == i77+6)); });
-    is_heap(i78, i78+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i78, i78+6, std::greater<int>()) == i78+6)); });
-    is_heap(i79, i79+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i79, i79+6, std::greater<int>()) == i79+6)); });
-    is_heap(i80, i80+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i80, i80+6, std::greater<int>()) == i80+6)); });
-    is_heap(i81, i81+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i81, i81+6, std::greater<int>()) == i81+6)); });
-    is_heap(i82, i82+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i82, i82+6, std::greater<int>()) == i82+6)); });
-    is_heap(i83, i83+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i83, i83+6, std::greater<int>()) == i83+6)); });
-    is_heap(i84, i84+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i84, i84+6, std::greater<int>()) == i84+6)); });
-    is_heap(i85, i85+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i85, i85+6, std::greater<int>()) == i85+6)); });
-    is_heap(i86, i86+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i86, i86+6, std::greater<int>()) == i86+6)); });
-    is_heap(i87, i87+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i87, i87+6, std::greater<int>()) == i87+6)); });
-    is_heap(i88, i88+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i88, i88+6, std::greater<int>()) == i88+6)); });
-    is_heap(i89, i89+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i89, i89+6, std::greater<int>()) == i89+6)); });
-    is_heap(i90, i90+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i90, i90+6, std::greater<int>()) == i90+6)); });
-    is_heap(i91, i91+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i91, i91+6, std::greater<int>()) == i91+6)); });
-    is_heap(i92, i92+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i92, i92+6, std::greater<int>()) == i92+6)); });
-    is_heap(i93, i93+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i93, i93+6, std::greater<int>()) == i93+6)); });
-    is_heap(i94, i94+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i94, i94+6, std::greater<int>()) == i94+6)); });
-    is_heap(i95, i95+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i95, i95+6, std::greater<int>()) == i95+6)); });
-    is_heap(i96, i96+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i96, i96+6, std::greater<int>()) == i96+6)); });
-    is_heap(i97, i97+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i97, i97+6, std::greater<int>()) == i97+6)); });
-    is_heap(i98, i98+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i98, i98+6, std::greater<int>()) == i98+6)); });
-    is_heap(i99, i99+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i99, i99+6, std::greater<int>()) == i99+6)); });
-    is_heap(i100, i100+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i100, i100+6, std::greater<int>()) == i100+6)); });
-    is_heap(i101, i101+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i101, i101+6, std::greater<int>()) == i101+6)); });
-    is_heap(i102, i102+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i102, i102+6, std::greater<int>()) == i102+6)); });
-    is_heap(i103, i103+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i103, i103+6, std::greater<int>()) == i103+6)); });
-    is_heap(i104, i104+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i104, i104+6, std::greater<int>()) == i104+6)); });
-    is_heap(i105, i105+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i105, i105+6, std::greater<int>()) == i105+6)); });
-    is_heap(i106, i106+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i106, i106+6, std::greater<int>()) == i106+6)); });
-    is_heap(i107, i107+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i107, i107+6, std::greater<int>()) == i107+6)); });
-    is_heap(i108, i108+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i108, i108+6, std::greater<int>()) == i108+6)); });
-    is_heap(i109, i109+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i109, i109+6, std::greater<int>()) == i109+6)); });
-    is_heap(i110, i110+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i110, i110+6, std::greater<int>()) == i110+6)); });
-    is_heap(i111, i111+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i111, i111+6, std::greater<int>()) == i111+6)); });
-    is_heap(i112, i112+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i112, i112+6, std::greater<int>()) == i112+6)); });
-    is_heap(i113, i113+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i113, i113+6, std::greater<int>()) == i113+6)); });
-    is_heap(i114, i114+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i114, i114+6, std::greater<int>()) == i114+6)); });
-    is_heap(i115, i115+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i115, i115+6, std::greater<int>()) == i115+6)); });
-    is_heap(i116, i116+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i116, i116+6, std::greater<int>()) == i116+6)); });
-    is_heap(i117, i117+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i117, i117+6, std::greater<int>()) == i117+6)); });
-    is_heap(i118, i118+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i118, i118+6, std::greater<int>()) == i118+6)); });
-    is_heap(i119, i119+6, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i119, i119+6, std::greater<int>()) == i119+6)); });
-#endif
-#ifdef IS_HEAP_4
-    int i120[] = {0, 0, 0, 0, 0, 0, 0};
-    int i121[] = {0, 0, 0, 0, 0, 0, 1};
-    int i122[] = {0, 0, 0, 0, 0, 1, 0};
-    int i123[] = {0, 0, 0, 0, 0, 1, 1};
-    int i124[] = {0, 0, 0, 0, 1, 0, 0};
-    int i125[] = {0, 0, 0, 0, 1, 0, 1};
-    int i126[] = {0, 0, 0, 0, 1, 1, 0};
-    int i127[] = {0, 0, 0, 0, 1, 1, 1};
-    int i128[] = {0, 0, 0, 1, 0, 0, 0};
-    int i129[] = {0, 0, 0, 1, 0, 0, 1};
-    int i130[] = {0, 0, 0, 1, 0, 1, 0};
-    int i131[] = {0, 0, 0, 1, 0, 1, 1};
-    int i132[] = {0, 0, 0, 1, 1, 0, 0};
-    int i133[] = {0, 0, 0, 1, 1, 0, 1};
-    int i134[] = {0, 0, 0, 1, 1, 1, 0};
-    int i135[] = {0, 0, 0, 1, 1, 1, 1};
-    int i136[] = {0, 0, 1, 0, 0, 0, 0};
-    int i137[] = {0, 0, 1, 0, 0, 0, 1};
-    int i138[] = {0, 0, 1, 0, 0, 1, 0};
-    int i139[] = {0, 0, 1, 0, 0, 1, 1};
-    int i140[] = {0, 0, 1, 0, 1, 0, 0};
-    int i141[] = {0, 0, 1, 0, 1, 0, 1};
-    int i142[] = {0, 0, 1, 0, 1, 1, 0};
-    int i143[] = {0, 0, 1, 0, 1, 1, 1};
-    int i144[] = {0, 0, 1, 1, 0, 0, 0};
-    int i145[] = {0, 0, 1, 1, 0, 0, 1};
-    int i146[] = {0, 0, 1, 1, 0, 1, 0};
-    int i147[] = {0, 0, 1, 1, 0, 1, 1};
-    int i148[] = {0, 0, 1, 1, 1, 0, 0};
-    int i149[] = {0, 0, 1, 1, 1, 0, 1};
-    int i150[] = {0, 0, 1, 1, 1, 1, 0};
-    int i151[] = {0, 0, 1, 1, 1, 1, 1};
-    int i152[] = {0, 1, 0, 0, 0, 0, 0};
-    int i153[] = {0, 1, 0, 0, 0, 0, 1};
-    int i154[] = {0, 1, 0, 0, 0, 1, 0};
-    int i155[] = {0, 1, 0, 0, 0, 1, 1};
-    int i156[] = {0, 1, 0, 0, 1, 0, 0};
-    int i157[] = {0, 1, 0, 0, 1, 0, 1};
-    int i158[] = {0, 1, 0, 0, 1, 1, 0};
-    int i159[] = {0, 1, 0, 0, 1, 1, 1};
-    int i160[] = {0, 1, 0, 1, 0, 0, 0};
-    int i161[] = {0, 1, 0, 1, 0, 0, 1};
-    int i162[] = {0, 1, 0, 1, 0, 1, 0};
-    int i163[] = {0, 1, 0, 1, 0, 1, 1};
-    int i164[] = {0, 1, 0, 1, 1, 0, 0};
-    int i165[] = {0, 1, 0, 1, 1, 0, 1};
-    int i166[] = {0, 1, 0, 1, 1, 1, 0};
-    int i167[] = {0, 1, 0, 1, 1, 1, 1};
-    int i168[] = {0, 1, 1, 0, 0, 0, 0};
-    int i169[] = {0, 1, 1, 0, 0, 0, 1};
-    int i170[] = {0, 1, 1, 0, 0, 1, 0};
-    int i171[] = {0, 1, 1, 0, 0, 1, 1};
-    int i172[] = {0, 1, 1, 0, 1, 0, 0};
-    int i173[] = {0, 1, 1, 0, 1, 0, 1};
-    int i174[] = {0, 1, 1, 0, 1, 1, 0};
-    int i175[] = {0, 1, 1, 0, 1, 1, 1};
-    int i176[] = {0, 1, 1, 1, 0, 0, 0};
-    int i177[] = {0, 1, 1, 1, 0, 0, 1};
-    int i178[] = {0, 1, 1, 1, 0, 1, 0};
-    int i179[] = {0, 1, 1, 1, 0, 1, 1};
-    int i180[] = {0, 1, 1, 1, 1, 0, 0};
-    int i181[] = {0, 1, 1, 1, 1, 0, 1};
-    int i182[] = {0, 1, 1, 1, 1, 1, 0};
-    int i183[] = {0, 1, 1, 1, 1, 1, 1};
-    int i184[] = {1, 0, 0, 0, 0, 0, 0};
-    int i185[] = {1, 0, 0, 0, 0, 0, 1};
-    int i186[] = {1, 0, 0, 0, 0, 1, 0};
-    int i187[] = {1, 0, 0, 0, 0, 1, 1};
-    int i188[] = {1, 0, 0, 0, 1, 0, 0};
-    int i189[] = {1, 0, 0, 0, 1, 0, 1};
-    int i190[] = {1, 0, 0, 0, 1, 1, 0};
-    int i191[] = {1, 0, 0, 0, 1, 1, 1};
-    int i192[] = {1, 0, 0, 1, 0, 0, 0};
-    int i193[] = {1, 0, 0, 1, 0, 0, 1};
-    int i194[] = {1, 0, 0, 1, 0, 1, 0};
-    int i195[] = {1, 0, 0, 1, 0, 1, 1};
-    int i196[] = {1, 0, 0, 1, 1, 0, 0};
-    int i197[] = {1, 0, 0, 1, 1, 0, 1};
-    int i198[] = {1, 0, 0, 1, 1, 1, 0};
-    int i199[] = {1, 0, 0, 1, 1, 1, 1};
-    int i200[] = {1, 0, 1, 0, 0, 0, 0};
-    int i201[] = {1, 0, 1, 0, 0, 0, 1};
-    int i202[] = {1, 0, 1, 0, 0, 1, 0};
-    int i203[] = {1, 0, 1, 0, 0, 1, 1};
-    int i204[] = {1, 0, 1, 0, 1, 0, 0};
-    int i205[] = {1, 0, 1, 0, 1, 0, 1};
-    int i206[] = {1, 0, 1, 0, 1, 1, 0};
-    int i207[] = {1, 0, 1, 0, 1, 1, 1};
-    int i208[] = {1, 0, 1, 1, 0, 0, 0};
-    int i209[] = {1, 0, 1, 1, 0, 0, 1};
-    int i210[] = {1, 0, 1, 1, 0, 1, 0};
-    int i211[] = {1, 0, 1, 1, 0, 1, 1};
-    int i212[] = {1, 0, 1, 1, 1, 0, 0};
-    int i213[] = {1, 0, 1, 1, 1, 0, 1};
-    int i214[] = {1, 0, 1, 1, 1, 1, 0};
-    int i215[] = {1, 0, 1, 1, 1, 1, 1};
-    int i216[] = {1, 1, 0, 0, 0, 0, 0};
-    int i217[] = {1, 1, 0, 0, 0, 0, 1};
-    int i218[] = {1, 1, 0, 0, 0, 1, 0};
-    int i219[] = {1, 1, 0, 0, 0, 1, 1};
-    int i220[] = {1, 1, 0, 0, 1, 0, 0};
-    int i221[] = {1, 1, 0, 0, 1, 0, 1};
-    int i222[] = {1, 1, 0, 0, 1, 1, 0};
-    int i223[] = {1, 1, 0, 0, 1, 1, 1};
-    int i224[] = {1, 1, 0, 1, 0, 0, 0};
-    int i225[] = {1, 1, 0, 1, 0, 0, 1};
-    int i226[] = {1, 1, 0, 1, 0, 1, 0};
-    int i227[] = {1, 1, 0, 1, 0, 1, 1};
-    int i228[] = {1, 1, 0, 1, 1, 0, 0};
-    int i229[] = {1, 1, 0, 1, 1, 0, 1};
-    int i230[] = {1, 1, 0, 1, 1, 1, 0};
-    int i231[] = {1, 1, 0, 1, 1, 1, 1};
-    int i232[] = {1, 1, 1, 0, 0, 0, 0};
-    int i233[] = {1, 1, 1, 0, 0, 0, 1};
-    int i234[] = {1, 1, 1, 0, 0, 1, 0};
-    int i235[] = {1, 1, 1, 0, 0, 1, 1};
-    int i236[] = {1, 1, 1, 0, 1, 0, 0};
-    int i237[] = {1, 1, 1, 0, 1, 0, 1};
-    int i238[] = {1, 1, 1, 0, 1, 1, 0};
-    int i239[] = {1, 1, 1, 0, 1, 1, 1};
-    int i240[] = {1, 1, 1, 1, 0, 0, 0};
-    int i241[] = {1, 1, 1, 1, 0, 0, 1};
-    int i242[] = {1, 1, 1, 1, 0, 1, 0};
-    int i243[] = {1, 1, 1, 1, 0, 1, 1};
-    int i244[] = {1, 1, 1, 1, 1, 0, 0};
-    int i245[] = {1, 1, 1, 1, 1, 0, 1};
-    int i246[] = {1, 1, 1, 1, 1, 1, 0};
-    is_heap(i120, i120+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i120, i120+7, std::greater<int>()) == i120+7)); });
-    is_heap(i121, i121+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i121, i121+7, std::greater<int>()) == i121+7)); });
-    is_heap(i122, i122+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i122, i122+7, std::greater<int>()) == i122+7)); });
-    is_heap(i123, i123+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i123, i123+7, std::greater<int>()) == i123+7)); });
-    is_heap(i124, i124+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i124, i124+7, std::greater<int>()) == i124+7)); });
-    is_heap(i125, i125+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i125, i125+7, std::greater<int>()) == i125+7)); });
-    is_heap(i126, i126+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i126, i126+7, std::greater<int>()) == i126+7)); });
-    is_heap(i127, i127+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i127, i127+7, std::greater<int>()) == i127+7)); });
-    is_heap(i128, i128+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i128, i128+7, std::greater<int>()) == i128+7)); });
-    is_heap(i129, i129+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i129, i129+7, std::greater<int>()) == i129+7)); });
-    is_heap(i130, i130+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i130, i130+7, std::greater<int>()) == i130+7)); });
-    is_heap(i131, i131+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i131, i131+7, std::greater<int>()) == i131+7)); });
-    is_heap(i132, i132+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i132, i132+7, std::greater<int>()) == i132+7)); });
-    is_heap(i133, i133+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i133, i133+7, std::greater<int>()) == i133+7)); });
-    is_heap(i134, i134+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i134, i134+7, std::greater<int>()) == i134+7)); });
-    is_heap(i135, i135+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i135, i135+7, std::greater<int>()) == i135+7)); });
-    is_heap(i136, i136+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i136, i136+7, std::greater<int>()) == i136+7)); });
-    is_heap(i137, i137+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i137, i137+7, std::greater<int>()) == i137+7)); });
-    is_heap(i138, i138+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i138, i138+7, std::greater<int>()) == i138+7)); });
-    is_heap(i139, i139+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i139, i139+7, std::greater<int>()) == i139+7)); });
-    is_heap(i140, i140+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i140, i140+7, std::greater<int>()) == i140+7)); });
-    is_heap(i141, i141+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i141, i141+7, std::greater<int>()) == i141+7)); });
-    is_heap(i142, i142+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i142, i142+7, std::greater<int>()) == i142+7)); });
-    is_heap(i143, i143+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i143, i143+7, std::greater<int>()) == i143+7)); });
-    is_heap(i144, i144+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i144, i144+7, std::greater<int>()) == i144+7)); });
-    is_heap(i145, i145+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i145, i145+7, std::greater<int>()) == i145+7)); });
-    is_heap(i146, i146+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i146, i146+7, std::greater<int>()) == i146+7)); });
-    is_heap(i147, i147+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i147, i147+7, std::greater<int>()) == i147+7)); });
-    is_heap(i148, i148+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i148, i148+7, std::greater<int>()) == i148+7)); });
-    is_heap(i149, i149+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i149, i149+7, std::greater<int>()) == i149+7)); });
-    is_heap(i150, i150+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i150, i150+7, std::greater<int>()) == i150+7)); });
-    is_heap(i151, i151+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i151, i151+7, std::greater<int>()) == i151+7)); });
-    is_heap(i152, i152+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i152, i152+7, std::greater<int>()) == i152+7)); });
-    is_heap(i153, i153+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i153, i153+7, std::greater<int>()) == i153+7)); });
-    is_heap(i154, i154+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i154, i154+7, std::greater<int>()) == i154+7)); });
-    is_heap(i155, i155+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i155, i155+7, std::greater<int>()) == i155+7)); });
-    is_heap(i156, i156+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i156, i156+7, std::greater<int>()) == i156+7)); });
-    is_heap(i157, i157+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i157, i157+7, std::greater<int>()) == i157+7)); });
-    is_heap(i158, i158+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i158, i158+7, std::greater<int>()) == i158+7)); });
-    is_heap(i159, i159+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i159, i159+7, std::greater<int>()) == i159+7)); });
-    is_heap(i160, i160+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i160, i160+7, std::greater<int>()) == i160+7)); });
-    is_heap(i161, i161+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i161, i161+7, std::greater<int>()) == i161+7)); });
-    is_heap(i162, i162+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i162, i162+7, std::greater<int>()) == i162+7)); });
-    is_heap(i163, i163+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i163, i163+7, std::greater<int>()) == i163+7)); });
-    is_heap(i164, i164+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i164, i164+7, std::greater<int>()) == i164+7)); });
-    is_heap(i165, i165+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i165, i165+7, std::greater<int>()) == i165+7)); });
-    is_heap(i166, i166+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i166, i166+7, std::greater<int>()) == i166+7)); });
-    is_heap(i167, i167+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i167, i167+7, std::greater<int>()) == i167+7)); });
-    is_heap(i168, i168+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i168, i168+7, std::greater<int>()) == i168+7)); });
-    is_heap(i169, i169+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i169, i169+7, std::greater<int>()) == i169+7)); });
-    is_heap(i170, i170+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i170, i170+7, std::greater<int>()) == i170+7)); });
-    is_heap(i171, i171+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i171, i171+7, std::greater<int>()) == i171+7)); });
-    is_heap(i172, i172+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i172, i172+7, std::greater<int>()) == i172+7)); });
-    is_heap(i173, i173+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i173, i173+7, std::greater<int>()) == i173+7)); });
-    is_heap(i174, i174+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i174, i174+7, std::greater<int>()) == i174+7)); });
-    is_heap(i175, i175+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i175, i175+7, std::greater<int>()) == i175+7)); });
-    is_heap(i176, i176+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i176, i176+7, std::greater<int>()) == i176+7)); });
-    is_heap(i177, i177+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i177, i177+7, std::greater<int>()) == i177+7)); });
-    is_heap(i178, i178+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i178, i178+7, std::greater<int>()) == i178+7)); });
-    is_heap(i179, i179+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i179, i179+7, std::greater<int>()) == i179+7)); });
-    is_heap(i180, i180+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i180, i180+7, std::greater<int>()) == i180+7)); });
-    is_heap(i181, i181+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i181, i181+7, std::greater<int>()) == i181+7)); });
-    is_heap(i182, i182+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i182, i182+7, std::greater<int>()) == i182+7)); });
-    is_heap(i183, i183+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i183, i183+7, std::greater<int>()) == i183+7)); });
-    is_heap(i184, i184+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i184, i184+7, std::greater<int>()) == i184+7)); });
-    is_heap(i185, i185+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i185, i185+7, std::greater<int>()) == i185+7)); });
-    is_heap(i186, i186+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i186, i186+7, std::greater<int>()) == i186+7)); });
-    is_heap(i187, i187+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i187, i187+7, std::greater<int>()) == i187+7)); });
-    is_heap(i188, i188+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i188, i188+7, std::greater<int>()) == i188+7)); });
-    is_heap(i189, i189+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i189, i189+7, std::greater<int>()) == i189+7)); });
-    is_heap(i190, i190+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i190, i190+7, std::greater<int>()) == i190+7)); });
-    is_heap(i191, i191+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i191, i191+7, std::greater<int>()) == i191+7)); });
-    is_heap(i192, i192+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i192, i192+7, std::greater<int>()) == i192+7)); });
-    is_heap(i193, i193+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i193, i193+7, std::greater<int>()) == i193+7)); });
-    is_heap(i194, i194+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i194, i194+7, std::greater<int>()) == i194+7)); });
-    is_heap(i195, i195+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i195, i195+7, std::greater<int>()) == i195+7)); });
-    is_heap(i196, i196+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i196, i196+7, std::greater<int>()) == i196+7)); });
-    is_heap(i197, i197+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i197, i197+7, std::greater<int>()) == i197+7)); });
-    is_heap(i198, i198+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i198, i198+7, std::greater<int>()) == i198+7)); });
-    is_heap(i199, i199+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i199, i199+7, std::greater<int>()) == i199+7)); });
-    is_heap(i200, i200+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i200, i200+7, std::greater<int>()) == i200+7)); });
-    is_heap(i201, i201+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i201, i201+7, std::greater<int>()) == i201+7)); });
-    is_heap(i202, i202+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i202, i202+7, std::greater<int>()) == i202+7)); });
-    is_heap(i203, i203+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i203, i203+7, std::greater<int>()) == i203+7)); });
-    is_heap(i204, i204+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i204, i204+7, std::greater<int>()) == i204+7)); });
-    is_heap(i205, i205+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i205, i205+7, std::greater<int>()) == i205+7)); });
-    is_heap(i206, i206+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i206, i206+7, std::greater<int>()) == i206+7)); });
-    is_heap(i207, i207+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i207, i207+7, std::greater<int>()) == i207+7)); });
-    is_heap(i208, i208+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i208, i208+7, std::greater<int>()) == i208+7)); });
-    is_heap(i209, i209+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i209, i209+7, std::greater<int>()) == i209+7)); });
-    is_heap(i210, i210+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i210, i210+7, std::greater<int>()) == i210+7)); });
-    is_heap(i211, i211+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i211, i211+7, std::greater<int>()) == i211+7)); });
-    is_heap(i212, i212+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i212, i212+7, std::greater<int>()) == i212+7)); });
-    is_heap(i213, i213+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i213, i213+7, std::greater<int>()) == i213+7)); });
-    is_heap(i214, i214+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i214, i214+7, std::greater<int>()) == i214+7)); });
-    is_heap(i215, i215+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i215, i215+7, std::greater<int>()) == i215+7)); });
-    is_heap(i216, i216+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i216, i216+7, std::greater<int>()) == i216+7)); });
-    is_heap(i217, i217+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i217, i217+7, std::greater<int>()) == i217+7)); });
-    is_heap(i218, i218+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i218, i218+7, std::greater<int>()) == i218+7)); });
-    is_heap(i219, i219+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i219, i219+7, std::greater<int>()) == i219+7)); });
-    is_heap(i220, i220+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i220, i220+7, std::greater<int>()) == i220+7)); });
-    is_heap(i221, i221+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i221, i221+7, std::greater<int>()) == i221+7)); });
-    is_heap(i222, i222+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i222, i222+7, std::greater<int>()) == i222+7)); });
-    is_heap(i223, i223+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i223, i223+7, std::greater<int>()) == i223+7)); });
-    is_heap(i224, i224+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i224, i224+7, std::greater<int>()) == i224+7)); });
-    is_heap(i225, i225+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i225, i225+7, std::greater<int>()) == i225+7)); });
-    is_heap(i226, i226+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i226, i226+7, std::greater<int>()) == i226+7)); });
-    is_heap(i227, i227+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i227, i227+7, std::greater<int>()) == i227+7)); });
-    is_heap(i228, i228+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i228, i228+7, std::greater<int>()) == i228+7)); });
-    is_heap(i229, i229+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i229, i229+7, std::greater<int>()) == i229+7)); });
-    is_heap(i230, i230+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i230, i230+7, std::greater<int>()) == i230+7)); });
-    is_heap(i231, i231+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i231, i231+7, std::greater<int>()) == i231+7)); });
-    is_heap(i232, i232+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i232, i232+7, std::greater<int>()) == i232+7)); });
-    is_heap(i233, i233+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i233, i233+7, std::greater<int>()) == i233+7)); });
-    is_heap(i234, i234+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i234, i234+7, std::greater<int>()) == i234+7)); });
-    is_heap(i235, i235+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i235, i235+7, std::greater<int>()) == i235+7)); });
-    is_heap(i236, i236+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i236, i236+7, std::greater<int>()) == i236+7)); });
-    is_heap(i237, i237+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i237, i237+7, std::greater<int>()) == i237+7)); });
-    is_heap(i238, i238+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i238, i238+7, std::greater<int>()) == i238+7)); });
-    is_heap(i239, i239+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i239, i239+7, std::greater<int>()) == i239+7)); });
-    is_heap(i240, i240+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i240, i240+7, std::greater<int>()) == i240+7)); });
-    is_heap(i241, i241+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i241, i241+7, std::greater<int>()) == i241+7)); });
-    is_heap(i242, i242+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i242, i242+7, std::greater<int>()) == i242+7)); });
-    is_heap(i243, i243+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i243, i243+7, std::greater<int>()) == i243+7)); });
-    is_heap(i244, i244+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i244, i244+7, std::greater<int>()) == i244+7)); });
-    is_heap(i245, i245+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i245, i245+7, std::greater<int>()) == i245+7)); });
-    is_heap(i246, i246+7, std::greater<int>()).check([&](bool r){ CHECK(r == (std::is_heap_until(i246, i246+7, std::greater<int>()) == i246+7)); });
-#endif
-}
-
-struct S
-{
-    int i;
-};
-
-int main()
-{
-    test();
-    test_comp();
-
-    // Test projections:
-    S i183[] = {S{0}, S{1}, S{1}, S{1}, S{1}, S{1}, S{1}};
-    CHECK(ranges::is_heap(i183, i183+7, std::greater<int>(), &S::i));
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/is_heap1.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/is_heap1.cpp
deleted file mode 100644
index 7b1a8553..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/is_heap1.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define IS_HEAP_1
-#include "./is_heap.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/is_heap2.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/is_heap2.cpp
deleted file mode 100644
index 089d9cb3..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/is_heap2.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define IS_HEAP_2
-#include "./is_heap.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/is_heap3.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/is_heap3.cpp
deleted file mode 100644
index 96512df6..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/is_heap3.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define IS_HEAP_3
-#include "./is_heap.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/is_heap4.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/is_heap4.cpp
deleted file mode 100644
index c9f54978..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/is_heap4.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define IS_HEAP_4
-#include "./is_heap.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/is_heap_until.hpp b/src/contrib/range-v3-0.11.0/test/algorithm/is_heap_until.hpp
deleted file mode 100644
index 2915283a..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/is_heap_until.hpp
+++ /dev/null
@@ -1,1070 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-// Implementation based on the code in libc++
-//   http://http://libcxx.llvm.org/
-
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/heap_algorithm.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-void test()
-{
-#ifdef IS_HEAP_UNTIL_1
-    auto is_heap_until = make_testable_1(ranges::is_heap_until);
-    int i1[] = {0, 0};
-    is_heap_until(i1, i1).check([&](int*r){CHECK(r == i1);});
-
-    is_heap_until(i1, i1).check([&](int *r){ CHECK(r == i1); });
-    is_heap_until(i1, i1+1).check([&](int *r){ CHECK(r == i1+1); });
-    int i2[] = {0, 1};
-    int i3[] = {1, 0};
-    is_heap_until(i1, i1+2).check([&](int *r){ CHECK(r == i1+2); });
-    is_heap_until(i2, i2+2).check([&](int *r){ CHECK(r == i2+1); });
-    is_heap_until(i3, i3+2).check([&](int *r){ CHECK(r == i3+2); });
-    int i4[] = {0, 0, 0};
-    int i5[] = {0, 0, 1};
-    int i6[] = {0, 1, 0};
-    int i7[] = {0, 1, 1};
-    int i8[] = {1, 0, 0};
-    int i9[] = {1, 0, 1};
-    int i10[] = {1, 1, 0};
-    is_heap_until(i4, i4+3).check([&](int *r){ CHECK(r == i4+3); });
-    is_heap_until(i5, i5+3).check([&](int *r){ CHECK(r == i5+2); });
-    is_heap_until(i6, i6+3).check([&](int *r){ CHECK(r == i6+1); });
-    is_heap_until(i7, i7+3).check([&](int *r){ CHECK(r == i7+1); });
-    is_heap_until(i8, i8+3).check([&](int *r){ CHECK(r == i8+3); });
-    is_heap_until(i9, i9+3).check([&](int *r){ CHECK(r == i9+3); });
-    is_heap_until(i10, i10+3).check([&](int *r){ CHECK(r == i10+3); });
-    int i11[] = {0, 0, 0, 0};
-    int i12[] = {0, 0, 0, 1};
-    int i13[] = {0, 0, 1, 0};
-    int i14[] = {0, 0, 1, 1};
-    int i15[] = {0, 1, 0, 0};
-    int i16[] = {0, 1, 0, 1};
-    int i17[] = {0, 1, 1, 0};
-    int i18[] = {0, 1, 1, 1};
-    int i19[] = {1, 0, 0, 0};
-    int i20[] = {1, 0, 0, 1};
-    int i21[] = {1, 0, 1, 0};
-    int i22[] = {1, 0, 1, 1};
-    int i23[] = {1, 1, 0, 0};
-    int i24[] = {1, 1, 0, 1};
-    int i25[] = {1, 1, 1, 0};
-    is_heap_until(i11, i11+4).check([&](int *r){ CHECK(r == i11+4); });
-    is_heap_until(i12, i12+4).check([&](int *r){ CHECK(r == i12+3); });
-    is_heap_until(i13, i13+4).check([&](int *r){ CHECK(r == i13+2); });
-    is_heap_until(i14, i14+4).check([&](int *r){ CHECK(r == i14+2); });
-    is_heap_until(i15, i15+4).check([&](int *r){ CHECK(r == i15+1); });
-    is_heap_until(i16, i16+4).check([&](int *r){ CHECK(r == i16+1); });
-    is_heap_until(i17, i17+4).check([&](int *r){ CHECK(r == i17+1); });
-    is_heap_until(i18, i18+4).check([&](int *r){ CHECK(r == i18+1); });
-    is_heap_until(i19, i19+4).check([&](int *r){ CHECK(r == i19+4); });
-    is_heap_until(i20, i20+4).check([&](int *r){ CHECK(r == i20+3); });
-    is_heap_until(i21, i21+4).check([&](int *r){ CHECK(r == i21+4); });
-    is_heap_until(i22, i22+4).check([&](int *r){ CHECK(r == i22+3); });
-    is_heap_until(i23, i23+4).check([&](int *r){ CHECK(r == i23+4); });
-    is_heap_until(i24, i24+4).check([&](int *r){ CHECK(r == i24+4); });
-    is_heap_until(i25, i25+4).check([&](int *r){ CHECK(r == i25+4); });
-    int i26[] = {0, 0, 0, 0, 0};
-    int i27[] = {0, 0, 0, 0, 1};
-    int i28[] = {0, 0, 0, 1, 0};
-    int i29[] = {0, 0, 0, 1, 1};
-    int i30[] = {0, 0, 1, 0, 0};
-    int i31[] = {0, 0, 1, 0, 1};
-    int i32[] = {0, 0, 1, 1, 0};
-    int i33[] = {0, 0, 1, 1, 1};
-    int i34[] = {0, 1, 0, 0, 0};
-    int i35[] = {0, 1, 0, 0, 1};
-    int i36[] = {0, 1, 0, 1, 0};
-    int i37[] = {0, 1, 0, 1, 1};
-    int i38[] = {0, 1, 1, 0, 0};
-    int i39[] = {0, 1, 1, 0, 1};
-    int i40[] = {0, 1, 1, 1, 0};
-    int i41[] = {0, 1, 1, 1, 1};
-    int i42[] = {1, 0, 0, 0, 0};
-    int i43[] = {1, 0, 0, 0, 1};
-    int i44[] = {1, 0, 0, 1, 0};
-    int i45[] = {1, 0, 0, 1, 1};
-    int i46[] = {1, 0, 1, 0, 0};
-    int i47[] = {1, 0, 1, 0, 1};
-    int i48[] = {1, 0, 1, 1, 0};
-    int i49[] = {1, 0, 1, 1, 1};
-    int i50[] = {1, 1, 0, 0, 0};
-    int i51[] = {1, 1, 0, 0, 1};
-    int i52[] = {1, 1, 0, 1, 0};
-    int i53[] = {1, 1, 0, 1, 1};
-    int i54[] = {1, 1, 1, 0, 0};
-    int i55[] = {1, 1, 1, 0, 1};
-    int i56[] = {1, 1, 1, 1, 0};
-    is_heap_until(i26, i26+5).check([&](int *r){ CHECK(r == i26+5); });
-    is_heap_until(i27, i27+5).check([&](int *r){ CHECK(r == i27+4); });
-    is_heap_until(i28, i28+5).check([&](int *r){ CHECK(r == i28+3); });
-    is_heap_until(i29, i29+5).check([&](int *r){ CHECK(r == i29+3); });
-    is_heap_until(i30, i30+5).check([&](int *r){ CHECK(r == i30+2); });
-    is_heap_until(i31, i31+5).check([&](int *r){ CHECK(r == i31+2); });
-    is_heap_until(i32, i32+5).check([&](int *r){ CHECK(r == i32+2); });
-    is_heap_until(i33, i33+5).check([&](int *r){ CHECK(r == i33+2); });
-    is_heap_until(i34, i34+5).check([&](int *r){ CHECK(r == i34+1); });
-    is_heap_until(i35, i35+5).check([&](int *r){ CHECK(r == i35+1); });
-    is_heap_until(i36, i36+5).check([&](int *r){ CHECK(r == i36+1); });
-    is_heap_until(i37, i37+5).check([&](int *r){ CHECK(r == i37+1); });
-    is_heap_until(i38, i38+5).check([&](int *r){ CHECK(r == i38+1); });
-    is_heap_until(i39, i39+5).check([&](int *r){ CHECK(r == i39+1); });
-    is_heap_until(i40, i40+5).check([&](int *r){ CHECK(r == i40+1); });
-    is_heap_until(i41, i41+5).check([&](int *r){ CHECK(r == i41+1); });
-    is_heap_until(i42, i42+5).check([&](int *r){ CHECK(r == i42+5); });
-    is_heap_until(i43, i43+5).check([&](int *r){ CHECK(r == i43+4); });
-    is_heap_until(i44, i44+5).check([&](int *r){ CHECK(r == i44+3); });
-    is_heap_until(i45, i45+5).check([&](int *r){ CHECK(r == i45+3); });
-    is_heap_until(i46, i46+5).check([&](int *r){ CHECK(r == i46+5); });
-    is_heap_until(i47, i47+5).check([&](int *r){ CHECK(r == i47+4); });
-    is_heap_until(i48, i48+5).check([&](int *r){ CHECK(r == i48+3); });
-    is_heap_until(i49, i49+5).check([&](int *r){ CHECK(r == i49+3); });
-    is_heap_until(i50, i50+5).check([&](int *r){ CHECK(r == i50+5); });
-    is_heap_until(i51, i51+5).check([&](int *r){ CHECK(r == i51+5); });
-    is_heap_until(i52, i52+5).check([&](int *r){ CHECK(r == i52+5); });
-    is_heap_until(i53, i53+5).check([&](int *r){ CHECK(r == i53+5); });
-    is_heap_until(i54, i54+5).check([&](int *r){ CHECK(r == i54+5); });
-    is_heap_until(i55, i55+5).check([&](int *r){ CHECK(r == i55+5); });
-    is_heap_until(i56, i56+5).check([&](int *r){ CHECK(r == i56+5); });
-    int i57[] = {0, 0, 0, 0, 0, 0};
-    int i58[] = {0, 0, 0, 0, 0, 1};
-    int i59[] = {0, 0, 0, 0, 1, 0};
-    int i60[] = {0, 0, 0, 0, 1, 1};
-    int i61[] = {0, 0, 0, 1, 0, 0};
-    int i62[] = {0, 0, 0, 1, 0, 1};
-    int i63[] = {0, 0, 0, 1, 1, 0};
-    int i64[] = {0, 0, 0, 1, 1, 1};
-    int i65[] = {0, 0, 1, 0, 0, 0};
-    int i66[] = {0, 0, 1, 0, 0, 1};
-    int i67[] = {0, 0, 1, 0, 1, 0};
-    int i68[] = {0, 0, 1, 0, 1, 1};
-    int i69[] = {0, 0, 1, 1, 0, 0};
-    int i70[] = {0, 0, 1, 1, 0, 1};
-    int i71[] = {0, 0, 1, 1, 1, 0};
-    int i72[] = {0, 0, 1, 1, 1, 1};
-    int i73[] = {0, 1, 0, 0, 0, 0};
-    int i74[] = {0, 1, 0, 0, 0, 1};
-    int i75[] = {0, 1, 0, 0, 1, 0};
-    int i76[] = {0, 1, 0, 0, 1, 1};
-    int i77[] = {0, 1, 0, 1, 0, 0};
-    int i78[] = {0, 1, 0, 1, 0, 1};
-    int i79[] = {0, 1, 0, 1, 1, 0};
-    int i80[] = {0, 1, 0, 1, 1, 1};
-    int i81[] = {0, 1, 1, 0, 0, 0};
-    int i82[] = {0, 1, 1, 0, 0, 1};
-    int i83[] = {0, 1, 1, 0, 1, 0};
-    int i84[] = {0, 1, 1, 0, 1, 1};
-    int i85[] = {0, 1, 1, 1, 0, 0};
-    int i86[] = {0, 1, 1, 1, 0, 1};
-    int i87[] = {0, 1, 1, 1, 1, 0};
-    int i88[] = {0, 1, 1, 1, 1, 1};
-    int i89[] = {1, 0, 0, 0, 0, 0};
-    int i90[] = {1, 0, 0, 0, 0, 1};
-    int i91[] = {1, 0, 0, 0, 1, 0};
-    int i92[] = {1, 0, 0, 0, 1, 1};
-    int i93[] = {1, 0, 0, 1, 0, 0};
-    int i94[] = {1, 0, 0, 1, 0, 1};
-    int i95[] = {1, 0, 0, 1, 1, 0};
-    int i96[] = {1, 0, 0, 1, 1, 1};
-    int i97[] = {1, 0, 1, 0, 0, 0};
-    int i98[] = {1, 0, 1, 0, 0, 1};
-    int i99[] = {1, 0, 1, 0, 1, 0};
-    int i100[] = {1, 0, 1, 0, 1, 1};
-    int i101[] = {1, 0, 1, 1, 0, 0};
-    int i102[] = {1, 0, 1, 1, 0, 1};
-    int i103[] = {1, 0, 1, 1, 1, 0};
-    int i104[] = {1, 0, 1, 1, 1, 1};
-    int i105[] = {1, 1, 0, 0, 0, 0};
-    int i106[] = {1, 1, 0, 0, 0, 1};
-    int i107[] = {1, 1, 0, 0, 1, 0};
-    int i108[] = {1, 1, 0, 0, 1, 1};
-    int i109[] = {1, 1, 0, 1, 0, 0};
-    int i110[] = {1, 1, 0, 1, 0, 1};
-    int i111[] = {1, 1, 0, 1, 1, 0};
-    int i112[] = {1, 1, 0, 1, 1, 1};
-    int i113[] = {1, 1, 1, 0, 0, 0};
-    int i114[] = {1, 1, 1, 0, 0, 1};
-    int i115[] = {1, 1, 1, 0, 1, 0};
-    int i116[] = {1, 1, 1, 0, 1, 1};
-    int i117[] = {1, 1, 1, 1, 0, 0};
-    int i118[] = {1, 1, 1, 1, 0, 1};
-    int i119[] = {1, 1, 1, 1, 1, 0};
-    is_heap_until(i57, i57+6).check([&](int *r){ CHECK(r == i57+6); });
-    is_heap_until(i58, i58+6).check([&](int *r){ CHECK(r == i58+5); });
-    is_heap_until(i59, i59+6).check([&](int *r){ CHECK(r == i59+4); });
-    is_heap_until(i60, i60+6).check([&](int *r){ CHECK(r == i60+4); });
-    is_heap_until(i61, i61+6).check([&](int *r){ CHECK(r == i61+3); });
-    is_heap_until(i62, i62+6).check([&](int *r){ CHECK(r == i62+3); });
-    is_heap_until(i63, i63+6).check([&](int *r){ CHECK(r == i63+3); });
-    is_heap_until(i64, i64+6).check([&](int *r){ CHECK(r == i64+3); });
-    is_heap_until(i65, i65+6).check([&](int *r){ CHECK(r == i65+2); });
-    is_heap_until(i66, i66+6).check([&](int *r){ CHECK(r == i66+2); });
-    is_heap_until(i67, i67+6).check([&](int *r){ CHECK(r == i67+2); });
-    is_heap_until(i68, i68+6).check([&](int *r){ CHECK(r == i68+2); });
-    is_heap_until(i69, i69+6).check([&](int *r){ CHECK(r == i69+2); });
-    is_heap_until(i70, i70+6).check([&](int *r){ CHECK(r == i70+2); });
-    is_heap_until(i71, i71+6).check([&](int *r){ CHECK(r == i71+2); });
-    is_heap_until(i72, i72+6).check([&](int *r){ CHECK(r == i72+2); });
-    is_heap_until(i73, i73+6).check([&](int *r){ CHECK(r == i73+1); });
-    is_heap_until(i74, i74+6).check([&](int *r){ CHECK(r == i74+1); });
-    is_heap_until(i75, i75+6).check([&](int *r){ CHECK(r == i75+1); });
-    is_heap_until(i76, i76+6).check([&](int *r){ CHECK(r == i76+1); });
-    is_heap_until(i77, i77+6).check([&](int *r){ CHECK(r == i77+1); });
-    is_heap_until(i78, i78+6).check([&](int *r){ CHECK(r == i78+1); });
-    is_heap_until(i79, i79+6).check([&](int *r){ CHECK(r == i79+1); });
-    is_heap_until(i80, i80+6).check([&](int *r){ CHECK(r == i80+1); });
-    is_heap_until(i81, i81+6).check([&](int *r){ CHECK(r == i81+1); });
-    is_heap_until(i82, i82+6).check([&](int *r){ CHECK(r == i82+1); });
-    is_heap_until(i83, i83+6).check([&](int *r){ CHECK(r == i83+1); });
-    is_heap_until(i84, i84+6).check([&](int *r){ CHECK(r == i84+1); });
-    is_heap_until(i85, i85+6).check([&](int *r){ CHECK(r == i85+1); });
-    is_heap_until(i86, i86+6).check([&](int *r){ CHECK(r == i86+1); });
-    is_heap_until(i87, i87+6).check([&](int *r){ CHECK(r == i87+1); });
-    is_heap_until(i88, i88+6).check([&](int *r){ CHECK(r == i88+1); });
-    is_heap_until(i89, i89+6).check([&](int *r){ CHECK(r == i89+6); });
-    is_heap_until(i90, i90+6).check([&](int *r){ CHECK(r == i90+5); });
-    is_heap_until(i91, i91+6).check([&](int *r){ CHECK(r == i91+4); });
-    is_heap_until(i92, i92+6).check([&](int *r){ CHECK(r == i92+4); });
-    is_heap_until(i93, i93+6).check([&](int *r){ CHECK(r == i93+3); });
-    is_heap_until(i94, i94+6).check([&](int *r){ CHECK(r == i94+3); });
-    is_heap_until(i95, i95+6).check([&](int *r){ CHECK(r == i95+3); });
-    is_heap_until(i96, i96+6).check([&](int *r){ CHECK(r == i96+3); });
-    is_heap_until(i97, i97+6).check([&](int *r){ CHECK(r == i97+6); });
-    is_heap_until(i98, i98+6).check([&](int *r){ CHECK(r == i98+6); });
-    is_heap_until(i99, i99+6).check([&](int *r){ CHECK(r == i99+4); });
-    is_heap_until(i100, i100+6).check([&](int *r){ CHECK(r == i100+4); });
-    is_heap_until(i101, i101+6).check([&](int *r){ CHECK(r == i101+3); });
-    is_heap_until(i102, i102+6).check([&](int *r){ CHECK(r == i102+3); });
-    is_heap_until(i103, i103+6).check([&](int *r){ CHECK(r == i103+3); });
-    is_heap_until(i104, i104+6).check([&](int *r){ CHECK(r == i104+3); });
-    is_heap_until(i105, i105+6).check([&](int *r){ CHECK(r == i105+6); });
-    is_heap_until(i106, i106+6).check([&](int *r){ CHECK(r == i106+5); });
-    is_heap_until(i107, i107+6).check([&](int *r){ CHECK(r == i107+6); });
-    is_heap_until(i108, i108+6).check([&](int *r){ CHECK(r == i108+5); });
-    is_heap_until(i109, i109+6).check([&](int *r){ CHECK(r == i109+6); });
-    is_heap_until(i110, i110+6).check([&](int *r){ CHECK(r == i110+5); });
-    is_heap_until(i111, i111+6).check([&](int *r){ CHECK(r == i111+6); });
-    is_heap_until(i112, i112+6).check([&](int *r){ CHECK(r == i112+5); });
-    is_heap_until(i113, i113+6).check([&](int *r){ CHECK(r == i113+6); });
-    is_heap_until(i114, i114+6).check([&](int *r){ CHECK(r == i114+6); });
-    is_heap_until(i115, i115+6).check([&](int *r){ CHECK(r == i115+6); });
-    is_heap_until(i116, i116+6).check([&](int *r){ CHECK(r == i116+6); });
-    is_heap_until(i117, i117+6).check([&](int *r){ CHECK(r == i117+6); });
-    is_heap_until(i118, i118+6).check([&](int *r){ CHECK(r == i118+6); });
-    is_heap_until(i119, i119+6).check([&](int *r){ CHECK(r == i119+6); });
-#endif
-#ifdef IS_HEAP_UNTIL_2
-    auto is_heap_until = make_testable_1(ranges::is_heap_until);
-    int i120[] = {0, 0, 0, 0, 0, 0, 0};
-    int i121[] = {0, 0, 0, 0, 0, 0, 1};
-    int i122[] = {0, 0, 0, 0, 0, 1, 0};
-    int i123[] = {0, 0, 0, 0, 0, 1, 1};
-    int i124[] = {0, 0, 0, 0, 1, 0, 0};
-    int i125[] = {0, 0, 0, 0, 1, 0, 1};
-    int i126[] = {0, 0, 0, 0, 1, 1, 0};
-    int i127[] = {0, 0, 0, 0, 1, 1, 1};
-    int i128[] = {0, 0, 0, 1, 0, 0, 0};
-    int i129[] = {0, 0, 0, 1, 0, 0, 1};
-    int i130[] = {0, 0, 0, 1, 0, 1, 0};
-    int i131[] = {0, 0, 0, 1, 0, 1, 1};
-    int i132[] = {0, 0, 0, 1, 1, 0, 0};
-    int i133[] = {0, 0, 0, 1, 1, 0, 1};
-    int i134[] = {0, 0, 0, 1, 1, 1, 0};
-    int i135[] = {0, 0, 0, 1, 1, 1, 1};
-    int i136[] = {0, 0, 1, 0, 0, 0, 0};
-    int i137[] = {0, 0, 1, 0, 0, 0, 1};
-    int i138[] = {0, 0, 1, 0, 0, 1, 0};
-    int i139[] = {0, 0, 1, 0, 0, 1, 1};
-    int i140[] = {0, 0, 1, 0, 1, 0, 0};
-    int i141[] = {0, 0, 1, 0, 1, 0, 1};
-    int i142[] = {0, 0, 1, 0, 1, 1, 0};
-    int i143[] = {0, 0, 1, 0, 1, 1, 1};
-    int i144[] = {0, 0, 1, 1, 0, 0, 0};
-    int i145[] = {0, 0, 1, 1, 0, 0, 1};
-    int i146[] = {0, 0, 1, 1, 0, 1, 0};
-    int i147[] = {0, 0, 1, 1, 0, 1, 1};
-    int i148[] = {0, 0, 1, 1, 1, 0, 0};
-    int i149[] = {0, 0, 1, 1, 1, 0, 1};
-    int i150[] = {0, 0, 1, 1, 1, 1, 0};
-    int i151[] = {0, 0, 1, 1, 1, 1, 1};
-    int i152[] = {0, 1, 0, 0, 0, 0, 0};
-    int i153[] = {0, 1, 0, 0, 0, 0, 1};
-    int i154[] = {0, 1, 0, 0, 0, 1, 0};
-    int i155[] = {0, 1, 0, 0, 0, 1, 1};
-    int i156[] = {0, 1, 0, 0, 1, 0, 0};
-    int i157[] = {0, 1, 0, 0, 1, 0, 1};
-    int i158[] = {0, 1, 0, 0, 1, 1, 0};
-    int i159[] = {0, 1, 0, 0, 1, 1, 1};
-    int i160[] = {0, 1, 0, 1, 0, 0, 0};
-    int i161[] = {0, 1, 0, 1, 0, 0, 1};
-    int i162[] = {0, 1, 0, 1, 0, 1, 0};
-    int i163[] = {0, 1, 0, 1, 0, 1, 1};
-    int i164[] = {0, 1, 0, 1, 1, 0, 0};
-    int i165[] = {0, 1, 0, 1, 1, 0, 1};
-    int i166[] = {0, 1, 0, 1, 1, 1, 0};
-    int i167[] = {0, 1, 0, 1, 1, 1, 1};
-    int i168[] = {0, 1, 1, 0, 0, 0, 0};
-    int i169[] = {0, 1, 1, 0, 0, 0, 1};
-    int i170[] = {0, 1, 1, 0, 0, 1, 0};
-    int i171[] = {0, 1, 1, 0, 0, 1, 1};
-    int i172[] = {0, 1, 1, 0, 1, 0, 0};
-    int i173[] = {0, 1, 1, 0, 1, 0, 1};
-    int i174[] = {0, 1, 1, 0, 1, 1, 0};
-    int i175[] = {0, 1, 1, 0, 1, 1, 1};
-    int i176[] = {0, 1, 1, 1, 0, 0, 0};
-    int i177[] = {0, 1, 1, 1, 0, 0, 1};
-    int i178[] = {0, 1, 1, 1, 0, 1, 0};
-    int i179[] = {0, 1, 1, 1, 0, 1, 1};
-    int i180[] = {0, 1, 1, 1, 1, 0, 0};
-    int i181[] = {0, 1, 1, 1, 1, 0, 1};
-    int i182[] = {0, 1, 1, 1, 1, 1, 0};
-    int i183[] = {0, 1, 1, 1, 1, 1, 1};
-    int i184[] = {1, 0, 0, 0, 0, 0, 0};
-    int i185[] = {1, 0, 0, 0, 0, 0, 1};
-    int i186[] = {1, 0, 0, 0, 0, 1, 0};
-    int i187[] = {1, 0, 0, 0, 0, 1, 1};
-    int i188[] = {1, 0, 0, 0, 1, 0, 0};
-    int i189[] = {1, 0, 0, 0, 1, 0, 1};
-    int i190[] = {1, 0, 0, 0, 1, 1, 0};
-    int i191[] = {1, 0, 0, 0, 1, 1, 1};
-    int i192[] = {1, 0, 0, 1, 0, 0, 0};
-    int i193[] = {1, 0, 0, 1, 0, 0, 1};
-    int i194[] = {1, 0, 0, 1, 0, 1, 0};
-    int i195[] = {1, 0, 0, 1, 0, 1, 1};
-    int i196[] = {1, 0, 0, 1, 1, 0, 0};
-    int i197[] = {1, 0, 0, 1, 1, 0, 1};
-    int i198[] = {1, 0, 0, 1, 1, 1, 0};
-    int i199[] = {1, 0, 0, 1, 1, 1, 1};
-    int i200[] = {1, 0, 1, 0, 0, 0, 0};
-    int i201[] = {1, 0, 1, 0, 0, 0, 1};
-    int i202[] = {1, 0, 1, 0, 0, 1, 0};
-    int i203[] = {1, 0, 1, 0, 0, 1, 1};
-    int i204[] = {1, 0, 1, 0, 1, 0, 0};
-    int i205[] = {1, 0, 1, 0, 1, 0, 1};
-    int i206[] = {1, 0, 1, 0, 1, 1, 0};
-    int i207[] = {1, 0, 1, 0, 1, 1, 1};
-    int i208[] = {1, 0, 1, 1, 0, 0, 0};
-    int i209[] = {1, 0, 1, 1, 0, 0, 1};
-    int i210[] = {1, 0, 1, 1, 0, 1, 0};
-    int i211[] = {1, 0, 1, 1, 0, 1, 1};
-    int i212[] = {1, 0, 1, 1, 1, 0, 0};
-    int i213[] = {1, 0, 1, 1, 1, 0, 1};
-    int i214[] = {1, 0, 1, 1, 1, 1, 0};
-    int i215[] = {1, 0, 1, 1, 1, 1, 1};
-    int i216[] = {1, 1, 0, 0, 0, 0, 0};
-    int i217[] = {1, 1, 0, 0, 0, 0, 1};
-    int i218[] = {1, 1, 0, 0, 0, 1, 0};
-    int i219[] = {1, 1, 0, 0, 0, 1, 1};
-    int i220[] = {1, 1, 0, 0, 1, 0, 0};
-    int i221[] = {1, 1, 0, 0, 1, 0, 1};
-    int i222[] = {1, 1, 0, 0, 1, 1, 0};
-    int i223[] = {1, 1, 0, 0, 1, 1, 1};
-    int i224[] = {1, 1, 0, 1, 0, 0, 0};
-    int i225[] = {1, 1, 0, 1, 0, 0, 1};
-    int i226[] = {1, 1, 0, 1, 0, 1, 0};
-    int i227[] = {1, 1, 0, 1, 0, 1, 1};
-    int i228[] = {1, 1, 0, 1, 1, 0, 0};
-    int i229[] = {1, 1, 0, 1, 1, 0, 1};
-    int i230[] = {1, 1, 0, 1, 1, 1, 0};
-    int i231[] = {1, 1, 0, 1, 1, 1, 1};
-    int i232[] = {1, 1, 1, 0, 0, 0, 0};
-    int i233[] = {1, 1, 1, 0, 0, 0, 1};
-    int i234[] = {1, 1, 1, 0, 0, 1, 0};
-    int i235[] = {1, 1, 1, 0, 0, 1, 1};
-    int i236[] = {1, 1, 1, 0, 1, 0, 0};
-    int i237[] = {1, 1, 1, 0, 1, 0, 1};
-    int i238[] = {1, 1, 1, 0, 1, 1, 0};
-    int i239[] = {1, 1, 1, 0, 1, 1, 1};
-    int i240[] = {1, 1, 1, 1, 0, 0, 0};
-    int i241[] = {1, 1, 1, 1, 0, 0, 1};
-    int i242[] = {1, 1, 1, 1, 0, 1, 0};
-    int i243[] = {1, 1, 1, 1, 0, 1, 1};
-    int i244[] = {1, 1, 1, 1, 1, 0, 0};
-    int i245[] = {1, 1, 1, 1, 1, 0, 1};
-    int i246[] = {1, 1, 1, 1, 1, 1, 0};
-    is_heap_until(i120, i120+7).check([&](int *r){ CHECK(r == i120+7); });
-    is_heap_until(i121, i121+7).check([&](int *r){ CHECK(r == i121+6); });
-    is_heap_until(i122, i122+7).check([&](int *r){ CHECK(r == i122+5); });
-    is_heap_until(i123, i123+7).check([&](int *r){ CHECK(r == i123+5); });
-    is_heap_until(i124, i124+7).check([&](int *r){ CHECK(r == i124+4); });
-    is_heap_until(i125, i125+7).check([&](int *r){ CHECK(r == i125+4); });
-    is_heap_until(i126, i126+7).check([&](int *r){ CHECK(r == i126+4); });
-    is_heap_until(i127, i127+7).check([&](int *r){ CHECK(r == i127+4); });
-    is_heap_until(i128, i128+7).check([&](int *r){ CHECK(r == i128+3); });
-    is_heap_until(i129, i129+7).check([&](int *r){ CHECK(r == i129+3); });
-    is_heap_until(i130, i130+7).check([&](int *r){ CHECK(r == i130+3); });
-    is_heap_until(i131, i131+7).check([&](int *r){ CHECK(r == i131+3); });
-    is_heap_until(i132, i132+7).check([&](int *r){ CHECK(r == i132+3); });
-    is_heap_until(i133, i133+7).check([&](int *r){ CHECK(r == i133+3); });
-    is_heap_until(i134, i134+7).check([&](int *r){ CHECK(r == i134+3); });
-    is_heap_until(i135, i135+7).check([&](int *r){ CHECK(r == i135+3); });
-    is_heap_until(i136, i136+7).check([&](int *r){ CHECK(r == i136+2); });
-    is_heap_until(i137, i137+7).check([&](int *r){ CHECK(r == i137+2); });
-    is_heap_until(i138, i138+7).check([&](int *r){ CHECK(r == i138+2); });
-    is_heap_until(i139, i139+7).check([&](int *r){ CHECK(r == i139+2); });
-    is_heap_until(i140, i140+7).check([&](int *r){ CHECK(r == i140+2); });
-    is_heap_until(i141, i141+7).check([&](int *r){ CHECK(r == i141+2); });
-    is_heap_until(i142, i142+7).check([&](int *r){ CHECK(r == i142+2); });
-    is_heap_until(i143, i143+7).check([&](int *r){ CHECK(r == i143+2); });
-    is_heap_until(i144, i144+7).check([&](int *r){ CHECK(r == i144+2); });
-    is_heap_until(i145, i145+7).check([&](int *r){ CHECK(r == i145+2); });
-    is_heap_until(i146, i146+7).check([&](int *r){ CHECK(r == i146+2); });
-    is_heap_until(i147, i147+7).check([&](int *r){ CHECK(r == i147+2); });
-    is_heap_until(i148, i148+7).check([&](int *r){ CHECK(r == i148+2); });
-    is_heap_until(i149, i149+7).check([&](int *r){ CHECK(r == i149+2); });
-    is_heap_until(i150, i150+7).check([&](int *r){ CHECK(r == i150+2); });
-    is_heap_until(i151, i151+7).check([&](int *r){ CHECK(r == i151+2); });
-    is_heap_until(i152, i152+7).check([&](int *r){ CHECK(r == i152+1); });
-    is_heap_until(i153, i153+7).check([&](int *r){ CHECK(r == i153+1); });
-    is_heap_until(i154, i154+7).check([&](int *r){ CHECK(r == i154+1); });
-    is_heap_until(i155, i155+7).check([&](int *r){ CHECK(r == i155+1); });
-    is_heap_until(i156, i156+7).check([&](int *r){ CHECK(r == i156+1); });
-    is_heap_until(i157, i157+7).check([&](int *r){ CHECK(r == i157+1); });
-    is_heap_until(i158, i158+7).check([&](int *r){ CHECK(r == i158+1); });
-    is_heap_until(i159, i159+7).check([&](int *r){ CHECK(r == i159+1); });
-    is_heap_until(i160, i160+7).check([&](int *r){ CHECK(r == i160+1); });
-    is_heap_until(i161, i161+7).check([&](int *r){ CHECK(r == i161+1); });
-    is_heap_until(i162, i162+7).check([&](int *r){ CHECK(r == i162+1); });
-    is_heap_until(i163, i163+7).check([&](int *r){ CHECK(r == i163+1); });
-    is_heap_until(i164, i164+7).check([&](int *r){ CHECK(r == i164+1); });
-    is_heap_until(i165, i165+7).check([&](int *r){ CHECK(r == i165+1); });
-    is_heap_until(i166, i166+7).check([&](int *r){ CHECK(r == i166+1); });
-    is_heap_until(i167, i167+7).check([&](int *r){ CHECK(r == i167+1); });
-    is_heap_until(i168, i168+7).check([&](int *r){ CHECK(r == i168+1); });
-    is_heap_until(i169, i169+7).check([&](int *r){ CHECK(r == i169+1); });
-    is_heap_until(i170, i170+7).check([&](int *r){ CHECK(r == i170+1); });
-    is_heap_until(i171, i171+7).check([&](int *r){ CHECK(r == i171+1); });
-    is_heap_until(i172, i172+7).check([&](int *r){ CHECK(r == i172+1); });
-    is_heap_until(i173, i173+7).check([&](int *r){ CHECK(r == i173+1); });
-    is_heap_until(i174, i174+7).check([&](int *r){ CHECK(r == i174+1); });
-    is_heap_until(i175, i175+7).check([&](int *r){ CHECK(r == i175+1); });
-    is_heap_until(i176, i176+7).check([&](int *r){ CHECK(r == i176+1); });
-    is_heap_until(i177, i177+7).check([&](int *r){ CHECK(r == i177+1); });
-    is_heap_until(i178, i178+7).check([&](int *r){ CHECK(r == i178+1); });
-    is_heap_until(i179, i179+7).check([&](int *r){ CHECK(r == i179+1); });
-    is_heap_until(i180, i180+7).check([&](int *r){ CHECK(r == i180+1); });
-    is_heap_until(i181, i181+7).check([&](int *r){ CHECK(r == i181+1); });
-    is_heap_until(i182, i182+7).check([&](int *r){ CHECK(r == i182+1); });
-    is_heap_until(i183, i183+7).check([&](int *r){ CHECK(r == i183+1); });
-    is_heap_until(i184, i184+7).check([&](int *r){ CHECK(r == i184+7); });
-    is_heap_until(i185, i185+7).check([&](int *r){ CHECK(r == i185+6); });
-    is_heap_until(i186, i186+7).check([&](int *r){ CHECK(r == i186+5); });
-    is_heap_until(i187, i187+7).check([&](int *r){ CHECK(r == i187+5); });
-    is_heap_until(i188, i188+7).check([&](int *r){ CHECK(r == i188+4); });
-    is_heap_until(i189, i189+7).check([&](int *r){ CHECK(r == i189+4); });
-    is_heap_until(i190, i190+7).check([&](int *r){ CHECK(r == i190+4); });
-    is_heap_until(i191, i191+7).check([&](int *r){ CHECK(r == i191+4); });
-    is_heap_until(i192, i192+7).check([&](int *r){ CHECK(r == i192+3); });
-    is_heap_until(i193, i193+7).check([&](int *r){ CHECK(r == i193+3); });
-    is_heap_until(i194, i194+7).check([&](int *r){ CHECK(r == i194+3); });
-    is_heap_until(i195, i195+7).check([&](int *r){ CHECK(r == i195+3); });
-    is_heap_until(i196, i196+7).check([&](int *r){ CHECK(r == i196+3); });
-    is_heap_until(i197, i197+7).check([&](int *r){ CHECK(r == i197+3); });
-    is_heap_until(i198, i198+7).check([&](int *r){ CHECK(r == i198+3); });
-    is_heap_until(i199, i199+7).check([&](int *r){ CHECK(r == i199+3); });
-    is_heap_until(i200, i200+7).check([&](int *r){ CHECK(r == i200+7); });
-    is_heap_until(i201, i201+7).check([&](int *r){ CHECK(r == i201+7); });
-    is_heap_until(i202, i202+7).check([&](int *r){ CHECK(r == i202+7); });
-    is_heap_until(i203, i203+7).check([&](int *r){ CHECK(r == i203+7); });
-    is_heap_until(i204, i204+7).check([&](int *r){ CHECK(r == i204+4); });
-    is_heap_until(i205, i205+7).check([&](int *r){ CHECK(r == i205+4); });
-    is_heap_until(i206, i206+7).check([&](int *r){ CHECK(r == i206+4); });
-    is_heap_until(i207, i207+7).check([&](int *r){ CHECK(r == i207+4); });
-    is_heap_until(i208, i208+7).check([&](int *r){ CHECK(r == i208+3); });
-    is_heap_until(i209, i209+7).check([&](int *r){ CHECK(r == i209+3); });
-    is_heap_until(i210, i210+7).check([&](int *r){ CHECK(r == i210+3); });
-    is_heap_until(i211, i211+7).check([&](int *r){ CHECK(r == i211+3); });
-    is_heap_until(i212, i212+7).check([&](int *r){ CHECK(r == i212+3); });
-    is_heap_until(i213, i213+7).check([&](int *r){ CHECK(r == i213+3); });
-    is_heap_until(i214, i214+7).check([&](int *r){ CHECK(r == i214+3); });
-    is_heap_until(i215, i215+7).check([&](int *r){ CHECK(r == i215+3); });
-    is_heap_until(i216, i216+7).check([&](int *r){ CHECK(r == i216+7); });
-    is_heap_until(i217, i217+7).check([&](int *r){ CHECK(r == i217+6); });
-    is_heap_until(i218, i218+7).check([&](int *r){ CHECK(r == i218+5); });
-    is_heap_until(i219, i219+7).check([&](int *r){ CHECK(r == i219+5); });
-    is_heap_until(i220, i220+7).check([&](int *r){ CHECK(r == i220+7); });
-    is_heap_until(i221, i221+7).check([&](int *r){ CHECK(r == i221+6); });
-    is_heap_until(i222, i222+7).check([&](int *r){ CHECK(r == i222+5); });
-    is_heap_until(i223, i223+7).check([&](int *r){ CHECK(r == i223+5); });
-    is_heap_until(i224, i224+7).check([&](int *r){ CHECK(r == i224+7); });
-    is_heap_until(i225, i225+7).check([&](int *r){ CHECK(r == i225+6); });
-    is_heap_until(i226, i226+7).check([&](int *r){ CHECK(r == i226+5); });
-    is_heap_until(i227, i227+7).check([&](int *r){ CHECK(r == i227+5); });
-    is_heap_until(i228, i228+7).check([&](int *r){ CHECK(r == i228+7); });
-    is_heap_until(i229, i229+7).check([&](int *r){ CHECK(r == i229+6); });
-    is_heap_until(i230, i230+7).check([&](int *r){ CHECK(r == i230+5); });
-    is_heap_until(i231, i231+7).check([&](int *r){ CHECK(r == i231+5); });
-    is_heap_until(i232, i232+7).check([&](int *r){ CHECK(r == i232+7); });
-    is_heap_until(i233, i233+7).check([&](int *r){ CHECK(r == i233+7); });
-    is_heap_until(i234, i234+7).check([&](int *r){ CHECK(r == i234+7); });
-    is_heap_until(i235, i235+7).check([&](int *r){ CHECK(r == i235+7); });
-    is_heap_until(i236, i236+7).check([&](int *r){ CHECK(r == i236+7); });
-    is_heap_until(i237, i237+7).check([&](int *r){ CHECK(r == i237+7); });
-    is_heap_until(i238, i238+7).check([&](int *r){ CHECK(r == i238+7); });
-    is_heap_until(i239, i239+7).check([&](int *r){ CHECK(r == i239+7); });
-    is_heap_until(i240, i240+7).check([&](int *r){ CHECK(r == i240+7); });
-    is_heap_until(i241, i241+7).check([&](int *r){ CHECK(r == i241+7); });
-    is_heap_until(i242, i242+7).check([&](int *r){ CHECK(r == i242+7); });
-    is_heap_until(i243, i243+7).check([&](int *r){ CHECK(r == i243+7); });
-    is_heap_until(i244, i244+7).check([&](int *r){ CHECK(r == i244+7); });
-    is_heap_until(i245, i245+7).check([&](int *r){ CHECK(r == i245+7); });
-    is_heap_until(i246, i246+7).check([&](int *r){ CHECK(r == i246+7); });
-#endif
-}
-
-void test_pred()
-{
-#ifdef IS_HEAP_UNTIL_3
-    auto is_heap_until = ::make_testable_1(ranges::is_heap_until);
-    int i1[] = {0, 0};
-    is_heap_until(i1, i1, std::greater<int>()).check([&](int *r){ CHECK(r == i1); });
-    is_heap_until(i1, i1+1, std::greater<int>()).check([&](int *r){ CHECK(r == i1+1); });
-    int i2[] = {0, 1};
-    int i3[] = {1, 0};
-    is_heap_until(i1, i1+2, std::greater<int>()).check([&](int *r){ CHECK(r == i1+2); });
-    is_heap_until(i2, i2+2, std::greater<int>()).check([&](int *r){ CHECK(r == i2+2); });
-    is_heap_until(i3, i3+2, std::greater<int>()).check([&](int *r){ CHECK(r == i3+1); });
-    int i4[] = {0, 0, 0};
-    int i5[] = {0, 0, 1};
-    int i6[] = {0, 1, 0};
-    int i7[] = {0, 1, 1};
-    int i8[] = {1, 0, 0};
-    int i9[] = {1, 0, 1};
-    int i10[] = {1, 1, 0};
-    is_heap_until(i4, i4+3, std::greater<int>()).check([&](int *r){ CHECK(r == i4+3); });
-    is_heap_until(i5, i5+3, std::greater<int>()).check([&](int *r){ CHECK(r == i5+3); });
-    is_heap_until(i6, i6+3, std::greater<int>()).check([&](int *r){ CHECK(r == i6+3); });
-    is_heap_until(i7, i7+3, std::greater<int>()).check([&](int *r){ CHECK(r == i7+3); });
-    is_heap_until(i8, i8+3, std::greater<int>()).check([&](int *r){ CHECK(r == i8+1); });
-    is_heap_until(i9, i9+3, std::greater<int>()).check([&](int *r){ CHECK(r == i9+1); });
-    is_heap_until(i10, i10+3, std::greater<int>()).check([&](int *r){ CHECK(r == i10+2); });
-    int i11[] = {0, 0, 0, 0};
-    int i12[] = {0, 0, 0, 1};
-    int i13[] = {0, 0, 1, 0};
-    int i14[] = {0, 0, 1, 1};
-    int i15[] = {0, 1, 0, 0};
-    int i16[] = {0, 1, 0, 1};
-    int i17[] = {0, 1, 1, 0};
-    int i18[] = {0, 1, 1, 1};
-    int i19[] = {1, 0, 0, 0};
-    int i20[] = {1, 0, 0, 1};
-    int i21[] = {1, 0, 1, 0};
-    int i22[] = {1, 0, 1, 1};
-    int i23[] = {1, 1, 0, 0};
-    int i24[] = {1, 1, 0, 1};
-    int i25[] = {1, 1, 1, 0};
-    is_heap_until(i11, i11+4, std::greater<int>()).check([&](int *r){ CHECK(r == i11+4); });
-    is_heap_until(i12, i12+4, std::greater<int>()).check([&](int *r){ CHECK(r == i12+4); });
-    is_heap_until(i13, i13+4, std::greater<int>()).check([&](int *r){ CHECK(r == i13+4); });
-    is_heap_until(i14, i14+4, std::greater<int>()).check([&](int *r){ CHECK(r == i14+4); });
-    is_heap_until(i15, i15+4, std::greater<int>()).check([&](int *r){ CHECK(r == i15+3); });
-    is_heap_until(i16, i16+4, std::greater<int>()).check([&](int *r){ CHECK(r == i16+4); });
-    is_heap_until(i17, i17+4, std::greater<int>()).check([&](int *r){ CHECK(r == i17+3); });
-    is_heap_until(i18, i18+4, std::greater<int>()).check([&](int *r){ CHECK(r == i18+4); });
-    is_heap_until(i19, i19+4, std::greater<int>()).check([&](int *r){ CHECK(r == i19+1); });
-    is_heap_until(i20, i20+4, std::greater<int>()).check([&](int *r){ CHECK(r == i20+1); });
-    is_heap_until(i21, i21+4, std::greater<int>()).check([&](int *r){ CHECK(r == i21+1); });
-    is_heap_until(i22, i22+4, std::greater<int>()).check([&](int *r){ CHECK(r == i22+1); });
-    is_heap_until(i23, i23+4, std::greater<int>()).check([&](int *r){ CHECK(r == i23+2); });
-    is_heap_until(i24, i24+4, std::greater<int>()).check([&](int *r){ CHECK(r == i24+2); });
-    is_heap_until(i25, i25+4, std::greater<int>()).check([&](int *r){ CHECK(r == i25+3); });
-    int i26[] = {0, 0, 0, 0, 0};
-    int i27[] = {0, 0, 0, 0, 1};
-    int i28[] = {0, 0, 0, 1, 0};
-    int i29[] = {0, 0, 0, 1, 1};
-    int i30[] = {0, 0, 1, 0, 0};
-    int i31[] = {0, 0, 1, 0, 1};
-    int i32[] = {0, 0, 1, 1, 0};
-    int i33[] = {0, 0, 1, 1, 1};
-    int i34[] = {0, 1, 0, 0, 0};
-    int i35[] = {0, 1, 0, 0, 1};
-    int i36[] = {0, 1, 0, 1, 0};
-    int i37[] = {0, 1, 0, 1, 1};
-    int i38[] = {0, 1, 1, 0, 0};
-    int i39[] = {0, 1, 1, 0, 1};
-    int i40[] = {0, 1, 1, 1, 0};
-    int i41[] = {0, 1, 1, 1, 1};
-    int i42[] = {1, 0, 0, 0, 0};
-    int i43[] = {1, 0, 0, 0, 1};
-    int i44[] = {1, 0, 0, 1, 0};
-    int i45[] = {1, 0, 0, 1, 1};
-    int i46[] = {1, 0, 1, 0, 0};
-    int i47[] = {1, 0, 1, 0, 1};
-    int i48[] = {1, 0, 1, 1, 0};
-    int i49[] = {1, 0, 1, 1, 1};
-    int i50[] = {1, 1, 0, 0, 0};
-    int i51[] = {1, 1, 0, 0, 1};
-    int i52[] = {1, 1, 0, 1, 0};
-    int i53[] = {1, 1, 0, 1, 1};
-    int i54[] = {1, 1, 1, 0, 0};
-    int i55[] = {1, 1, 1, 0, 1};
-    int i56[] = {1, 1, 1, 1, 0};
-    is_heap_until(i26, i26+5, std::greater<int>()).check([&](int *r){ CHECK(r == i26+5); });
-    is_heap_until(i27, i27+5, std::greater<int>()).check([&](int *r){ CHECK(r == i27+5); });
-    is_heap_until(i28, i28+5, std::greater<int>()).check([&](int *r){ CHECK(r == i28+5); });
-    is_heap_until(i29, i29+5, std::greater<int>()).check([&](int *r){ CHECK(r == i29+5); });
-    is_heap_until(i30, i30+5, std::greater<int>()).check([&](int *r){ CHECK(r == i30+5); });
-    is_heap_until(i31, i31+5, std::greater<int>()).check([&](int *r){ CHECK(r == i31+5); });
-    is_heap_until(i32, i32+5, std::greater<int>()).check([&](int *r){ CHECK(r == i32+5); });
-    is_heap_until(i33, i33+5, std::greater<int>()).check([&](int *r){ CHECK(r == i33+5); });
-    is_heap_until(i34, i34+5, std::greater<int>()).check([&](int *r){ CHECK(r == i34+3); });
-    is_heap_until(i35, i35+5, std::greater<int>()).check([&](int *r){ CHECK(r == i35+3); });
-    is_heap_until(i36, i36+5, std::greater<int>()).check([&](int *r){ CHECK(r == i36+4); });
-    is_heap_until(i37, i37+5, std::greater<int>()).check([&](int *r){ CHECK(r == i37+5); });
-    is_heap_until(i38, i38+5, std::greater<int>()).check([&](int *r){ CHECK(r == i38+3); });
-    is_heap_until(i39, i39+5, std::greater<int>()).check([&](int *r){ CHECK(r == i39+3); });
-    is_heap_until(i40, i40+5, std::greater<int>()).check([&](int *r){ CHECK(r == i40+4); });
-    is_heap_until(i41, i41+5, std::greater<int>()).check([&](int *r){ CHECK(r == i41+5); });
-    is_heap_until(i42, i42+5, std::greater<int>()).check([&](int *r){ CHECK(r == i42+1); });
-    is_heap_until(i43, i43+5, std::greater<int>()).check([&](int *r){ CHECK(r == i43+1); });
-    is_heap_until(i44, i44+5, std::greater<int>()).check([&](int *r){ CHECK(r == i44+1); });
-    is_heap_until(i45, i45+5, std::greater<int>()).check([&](int *r){ CHECK(r == i45+1); });
-    is_heap_until(i46, i46+5, std::greater<int>()).check([&](int *r){ CHECK(r == i46+1); });
-    is_heap_until(i47, i47+5, std::greater<int>()).check([&](int *r){ CHECK(r == i47+1); });
-    is_heap_until(i48, i48+5, std::greater<int>()).check([&](int *r){ CHECK(r == i48+1); });
-    is_heap_until(i49, i49+5, std::greater<int>()).check([&](int *r){ CHECK(r == i49+1); });
-    is_heap_until(i50, i50+5, std::greater<int>()).check([&](int *r){ CHECK(r == i50+2); });
-    is_heap_until(i51, i51+5, std::greater<int>()).check([&](int *r){ CHECK(r == i51+2); });
-    is_heap_until(i52, i52+5, std::greater<int>()).check([&](int *r){ CHECK(r == i52+2); });
-    is_heap_until(i53, i53+5, std::greater<int>()).check([&](int *r){ CHECK(r == i53+2); });
-    is_heap_until(i54, i54+5, std::greater<int>()).check([&](int *r){ CHECK(r == i54+3); });
-    is_heap_until(i55, i55+5, std::greater<int>()).check([&](int *r){ CHECK(r == i55+3); });
-    is_heap_until(i56, i56+5, std::greater<int>()).check([&](int *r){ CHECK(r == i56+4); });
-    int i57[] = {0, 0, 0, 0, 0, 0};
-    int i58[] = {0, 0, 0, 0, 0, 1};
-    int i59[] = {0, 0, 0, 0, 1, 0};
-    int i60[] = {0, 0, 0, 0, 1, 1};
-    int i61[] = {0, 0, 0, 1, 0, 0};
-    int i62[] = {0, 0, 0, 1, 0, 1};
-    int i63[] = {0, 0, 0, 1, 1, 0};
-    int i64[] = {0, 0, 0, 1, 1, 1};
-    int i65[] = {0, 0, 1, 0, 0, 0};
-    int i66[] = {0, 0, 1, 0, 0, 1};
-    int i67[] = {0, 0, 1, 0, 1, 0};
-    int i68[] = {0, 0, 1, 0, 1, 1};
-    int i69[] = {0, 0, 1, 1, 0, 0};
-    int i70[] = {0, 0, 1, 1, 0, 1};
-    int i71[] = {0, 0, 1, 1, 1, 0};
-    int i72[] = {0, 0, 1, 1, 1, 1};
-    int i73[] = {0, 1, 0, 0, 0, 0};
-    int i74[] = {0, 1, 0, 0, 0, 1};
-    int i75[] = {0, 1, 0, 0, 1, 0};
-    int i76[] = {0, 1, 0, 0, 1, 1};
-    int i77[] = {0, 1, 0, 1, 0, 0};
-    int i78[] = {0, 1, 0, 1, 0, 1};
-    int i79[] = {0, 1, 0, 1, 1, 0};
-    int i80[] = {0, 1, 0, 1, 1, 1};
-    int i81[] = {0, 1, 1, 0, 0, 0};
-    int i82[] = {0, 1, 1, 0, 0, 1};
-    int i83[] = {0, 1, 1, 0, 1, 0};
-    int i84[] = {0, 1, 1, 0, 1, 1};
-    int i85[] = {0, 1, 1, 1, 0, 0};
-    int i86[] = {0, 1, 1, 1, 0, 1};
-    int i87[] = {0, 1, 1, 1, 1, 0};
-    int i88[] = {0, 1, 1, 1, 1, 1};
-    int i89[] = {1, 0, 0, 0, 0, 0};
-    int i90[] = {1, 0, 0, 0, 0, 1};
-    int i91[] = {1, 0, 0, 0, 1, 0};
-    int i92[] = {1, 0, 0, 0, 1, 1};
-    int i93[] = {1, 0, 0, 1, 0, 0};
-    int i94[] = {1, 0, 0, 1, 0, 1};
-    int i95[] = {1, 0, 0, 1, 1, 0};
-    int i96[] = {1, 0, 0, 1, 1, 1};
-    int i97[] = {1, 0, 1, 0, 0, 0};
-    int i98[] = {1, 0, 1, 0, 0, 1};
-    int i99[] = {1, 0, 1, 0, 1, 0};
-    int i100[] = {1, 0, 1, 0, 1, 1};
-    int i101[] = {1, 0, 1, 1, 0, 0};
-    int i102[] = {1, 0, 1, 1, 0, 1};
-    int i103[] = {1, 0, 1, 1, 1, 0};
-    int i104[] = {1, 0, 1, 1, 1, 1};
-    int i105[] = {1, 1, 0, 0, 0, 0};
-    int i106[] = {1, 1, 0, 0, 0, 1};
-    int i107[] = {1, 1, 0, 0, 1, 0};
-    int i108[] = {1, 1, 0, 0, 1, 1};
-    int i109[] = {1, 1, 0, 1, 0, 0};
-    int i110[] = {1, 1, 0, 1, 0, 1};
-    int i111[] = {1, 1, 0, 1, 1, 0};
-    int i112[] = {1, 1, 0, 1, 1, 1};
-    int i113[] = {1, 1, 1, 0, 0, 0};
-    int i114[] = {1, 1, 1, 0, 0, 1};
-    int i115[] = {1, 1, 1, 0, 1, 0};
-    int i116[] = {1, 1, 1, 0, 1, 1};
-    int i117[] = {1, 1, 1, 1, 0, 0};
-    int i118[] = {1, 1, 1, 1, 0, 1};
-    int i119[] = {1, 1, 1, 1, 1, 0};
-    is_heap_until(i57, i57+6, std::greater<int>()).check([&](int *r){ CHECK(r == i57+6); });
-    is_heap_until(i58, i58+6, std::greater<int>()).check([&](int *r){ CHECK(r == i58+6); });
-    is_heap_until(i59, i59+6, std::greater<int>()).check([&](int *r){ CHECK(r == i59+6); });
-    is_heap_until(i60, i60+6, std::greater<int>()).check([&](int *r){ CHECK(r == i60+6); });
-    is_heap_until(i61, i61+6, std::greater<int>()).check([&](int *r){ CHECK(r == i61+6); });
-    is_heap_until(i62, i62+6, std::greater<int>()).check([&](int *r){ CHECK(r == i62+6); });
-    is_heap_until(i63, i63+6, std::greater<int>()).check([&](int *r){ CHECK(r == i63+6); });
-    is_heap_until(i64, i64+6, std::greater<int>()).check([&](int *r){ CHECK(r == i64+6); });
-    is_heap_until(i65, i65+6, std::greater<int>()).check([&](int *r){ CHECK(r == i65+5); });
-    is_heap_until(i66, i66+6, std::greater<int>()).check([&](int *r){ CHECK(r == i66+6); });
-    is_heap_until(i67, i67+6, std::greater<int>()).check([&](int *r){ CHECK(r == i67+5); });
-    is_heap_until(i68, i68+6, std::greater<int>()).check([&](int *r){ CHECK(r == i68+6); });
-    is_heap_until(i69, i69+6, std::greater<int>()).check([&](int *r){ CHECK(r == i69+5); });
-    is_heap_until(i70, i70+6, std::greater<int>()).check([&](int *r){ CHECK(r == i70+6); });
-    is_heap_until(i71, i71+6, std::greater<int>()).check([&](int *r){ CHECK(r == i71+5); });
-    is_heap_until(i72, i72+6, std::greater<int>()).check([&](int *r){ CHECK(r == i72+6); });
-    is_heap_until(i73, i73+6, std::greater<int>()).check([&](int *r){ CHECK(r == i73+3); });
-    is_heap_until(i74, i74+6, std::greater<int>()).check([&](int *r){ CHECK(r == i74+3); });
-    is_heap_until(i75, i75+6, std::greater<int>()).check([&](int *r){ CHECK(r == i75+3); });
-    is_heap_until(i76, i76+6, std::greater<int>()).check([&](int *r){ CHECK(r == i76+3); });
-    is_heap_until(i77, i77+6, std::greater<int>()).check([&](int *r){ CHECK(r == i77+4); });
-    is_heap_until(i78, i78+6, std::greater<int>()).check([&](int *r){ CHECK(r == i78+4); });
-    is_heap_until(i79, i79+6, std::greater<int>()).check([&](int *r){ CHECK(r == i79+6); });
-    is_heap_until(i80, i80+6, std::greater<int>()).check([&](int *r){ CHECK(r == i80+6); });
-    is_heap_until(i81, i81+6, std::greater<int>()).check([&](int *r){ CHECK(r == i81+3); });
-    is_heap_until(i82, i82+6, std::greater<int>()).check([&](int *r){ CHECK(r == i82+3); });
-    is_heap_until(i83, i83+6, std::greater<int>()).check([&](int *r){ CHECK(r == i83+3); });
-    is_heap_until(i84, i84+6, std::greater<int>()).check([&](int *r){ CHECK(r == i84+3); });
-    is_heap_until(i85, i85+6, std::greater<int>()).check([&](int *r){ CHECK(r == i85+4); });
-    is_heap_until(i86, i86+6, std::greater<int>()).check([&](int *r){ CHECK(r == i86+4); });
-    is_heap_until(i87, i87+6, std::greater<int>()).check([&](int *r){ CHECK(r == i87+5); });
-    is_heap_until(i88, i88+6, std::greater<int>()).check([&](int *r){ CHECK(r == i88+6); });
-    is_heap_until(i89, i89+6, std::greater<int>()).check([&](int *r){ CHECK(r == i89+1); });
-    is_heap_until(i90, i90+6, std::greater<int>()).check([&](int *r){ CHECK(r == i90+1); });
-    is_heap_until(i91, i91+6, std::greater<int>()).check([&](int *r){ CHECK(r == i91+1); });
-    is_heap_until(i92, i92+6, std::greater<int>()).check([&](int *r){ CHECK(r == i92+1); });
-    is_heap_until(i93, i93+6, std::greater<int>()).check([&](int *r){ CHECK(r == i93+1); });
-    is_heap_until(i94, i94+6, std::greater<int>()).check([&](int *r){ CHECK(r == i94+1); });
-    is_heap_until(i95, i95+6, std::greater<int>()).check([&](int *r){ CHECK(r == i95+1); });
-    is_heap_until(i96, i96+6, std::greater<int>()).check([&](int *r){ CHECK(r == i96+1); });
-    is_heap_until(i97, i97+6, std::greater<int>()).check([&](int *r){ CHECK(r == i97+1); });
-    is_heap_until(i98, i98+6, std::greater<int>()).check([&](int *r){ CHECK(r == i98+1); });
-    is_heap_until(i99, i99+6, std::greater<int>()).check([&](int *r){ CHECK(r == i99+1); });
-    is_heap_until(i100, i100+6, std::greater<int>()).check([&](int *r){ CHECK(r == i100+1); });
-    is_heap_until(i101, i101+6, std::greater<int>()).check([&](int *r){ CHECK(r == i101+1); });
-    is_heap_until(i102, i102+6, std::greater<int>()).check([&](int *r){ CHECK(r == i102+1); });
-    is_heap_until(i103, i103+6, std::greater<int>()).check([&](int *r){ CHECK(r == i103+1); });
-    is_heap_until(i104, i104+6, std::greater<int>()).check([&](int *r){ CHECK(r == i104+1); });
-    is_heap_until(i105, i105+6, std::greater<int>()).check([&](int *r){ CHECK(r == i105+2); });
-    is_heap_until(i106, i106+6, std::greater<int>()).check([&](int *r){ CHECK(r == i106+2); });
-    is_heap_until(i107, i107+6, std::greater<int>()).check([&](int *r){ CHECK(r == i107+2); });
-    is_heap_until(i108, i108+6, std::greater<int>()).check([&](int *r){ CHECK(r == i108+2); });
-    is_heap_until(i109, i109+6, std::greater<int>()).check([&](int *r){ CHECK(r == i109+2); });
-    is_heap_until(i110, i110+6, std::greater<int>()).check([&](int *r){ CHECK(r == i110+2); });
-    is_heap_until(i111, i111+6, std::greater<int>()).check([&](int *r){ CHECK(r == i111+2); });
-    is_heap_until(i112, i112+6, std::greater<int>()).check([&](int *r){ CHECK(r == i112+2); });
-    is_heap_until(i113, i113+6, std::greater<int>()).check([&](int *r){ CHECK(r == i113+3); });
-    is_heap_until(i114, i114+6, std::greater<int>()).check([&](int *r){ CHECK(r == i114+3); });
-    is_heap_until(i115, i115+6, std::greater<int>()).check([&](int *r){ CHECK(r == i115+3); });
-    is_heap_until(i116, i116+6, std::greater<int>()).check([&](int *r){ CHECK(r == i116+3); });
-    is_heap_until(i117, i117+6, std::greater<int>()).check([&](int *r){ CHECK(r == i117+4); });
-    is_heap_until(i118, i118+6, std::greater<int>()).check([&](int *r){ CHECK(r == i118+4); });
-    is_heap_until(i119, i119+6, std::greater<int>()).check([&](int *r){ CHECK(r == i119+5); });
-#endif
-#ifdef IS_HEAP_UNTIL_4
-    auto is_heap_until = ::make_testable_1(ranges::is_heap_until);
-    int i120[] = {0, 0, 0, 0, 0, 0, 0};
-    int i121[] = {0, 0, 0, 0, 0, 0, 1};
-    int i122[] = {0, 0, 0, 0, 0, 1, 0};
-    int i123[] = {0, 0, 0, 0, 0, 1, 1};
-    int i124[] = {0, 0, 0, 0, 1, 0, 0};
-    int i125[] = {0, 0, 0, 0, 1, 0, 1};
-    int i126[] = {0, 0, 0, 0, 1, 1, 0};
-    int i127[] = {0, 0, 0, 0, 1, 1, 1};
-    int i128[] = {0, 0, 0, 1, 0, 0, 0};
-    int i129[] = {0, 0, 0, 1, 0, 0, 1};
-    int i130[] = {0, 0, 0, 1, 0, 1, 0};
-    int i131[] = {0, 0, 0, 1, 0, 1, 1};
-    int i132[] = {0, 0, 0, 1, 1, 0, 0};
-    int i133[] = {0, 0, 0, 1, 1, 0, 1};
-    int i134[] = {0, 0, 0, 1, 1, 1, 0};
-    int i135[] = {0, 0, 0, 1, 1, 1, 1};
-    int i136[] = {0, 0, 1, 0, 0, 0, 0};
-    int i137[] = {0, 0, 1, 0, 0, 0, 1};
-    int i138[] = {0, 0, 1, 0, 0, 1, 0};
-    int i139[] = {0, 0, 1, 0, 0, 1, 1};
-    int i140[] = {0, 0, 1, 0, 1, 0, 0};
-    int i141[] = {0, 0, 1, 0, 1, 0, 1};
-    int i142[] = {0, 0, 1, 0, 1, 1, 0};
-    int i143[] = {0, 0, 1, 0, 1, 1, 1};
-    int i144[] = {0, 0, 1, 1, 0, 0, 0};
-    int i145[] = {0, 0, 1, 1, 0, 0, 1};
-    int i146[] = {0, 0, 1, 1, 0, 1, 0};
-    int i147[] = {0, 0, 1, 1, 0, 1, 1};
-    int i148[] = {0, 0, 1, 1, 1, 0, 0};
-    int i149[] = {0, 0, 1, 1, 1, 0, 1};
-    int i150[] = {0, 0, 1, 1, 1, 1, 0};
-    int i151[] = {0, 0, 1, 1, 1, 1, 1};
-    int i152[] = {0, 1, 0, 0, 0, 0, 0};
-    int i153[] = {0, 1, 0, 0, 0, 0, 1};
-    int i154[] = {0, 1, 0, 0, 0, 1, 0};
-    int i155[] = {0, 1, 0, 0, 0, 1, 1};
-    int i156[] = {0, 1, 0, 0, 1, 0, 0};
-    int i157[] = {0, 1, 0, 0, 1, 0, 1};
-    int i158[] = {0, 1, 0, 0, 1, 1, 0};
-    int i159[] = {0, 1, 0, 0, 1, 1, 1};
-    int i160[] = {0, 1, 0, 1, 0, 0, 0};
-    int i161[] = {0, 1, 0, 1, 0, 0, 1};
-    int i162[] = {0, 1, 0, 1, 0, 1, 0};
-    int i163[] = {0, 1, 0, 1, 0, 1, 1};
-    int i164[] = {0, 1, 0, 1, 1, 0, 0};
-    int i165[] = {0, 1, 0, 1, 1, 0, 1};
-    int i166[] = {0, 1, 0, 1, 1, 1, 0};
-    int i167[] = {0, 1, 0, 1, 1, 1, 1};
-    int i168[] = {0, 1, 1, 0, 0, 0, 0};
-    int i169[] = {0, 1, 1, 0, 0, 0, 1};
-    int i170[] = {0, 1, 1, 0, 0, 1, 0};
-    int i171[] = {0, 1, 1, 0, 0, 1, 1};
-    int i172[] = {0, 1, 1, 0, 1, 0, 0};
-    int i173[] = {0, 1, 1, 0, 1, 0, 1};
-    int i174[] = {0, 1, 1, 0, 1, 1, 0};
-    int i175[] = {0, 1, 1, 0, 1, 1, 1};
-    int i176[] = {0, 1, 1, 1, 0, 0, 0};
-    int i177[] = {0, 1, 1, 1, 0, 0, 1};
-    int i178[] = {0, 1, 1, 1, 0, 1, 0};
-    int i179[] = {0, 1, 1, 1, 0, 1, 1};
-    int i180[] = {0, 1, 1, 1, 1, 0, 0};
-    int i181[] = {0, 1, 1, 1, 1, 0, 1};
-    int i182[] = {0, 1, 1, 1, 1, 1, 0};
-    int i183[] = {0, 1, 1, 1, 1, 1, 1};
-    int i184[] = {1, 0, 0, 0, 0, 0, 0};
-    int i185[] = {1, 0, 0, 0, 0, 0, 1};
-    int i186[] = {1, 0, 0, 0, 0, 1, 0};
-    int i187[] = {1, 0, 0, 0, 0, 1, 1};
-    int i188[] = {1, 0, 0, 0, 1, 0, 0};
-    int i189[] = {1, 0, 0, 0, 1, 0, 1};
-    int i190[] = {1, 0, 0, 0, 1, 1, 0};
-    int i191[] = {1, 0, 0, 0, 1, 1, 1};
-    int i192[] = {1, 0, 0, 1, 0, 0, 0};
-    int i193[] = {1, 0, 0, 1, 0, 0, 1};
-    int i194[] = {1, 0, 0, 1, 0, 1, 0};
-    int i195[] = {1, 0, 0, 1, 0, 1, 1};
-    int i196[] = {1, 0, 0, 1, 1, 0, 0};
-    int i197[] = {1, 0, 0, 1, 1, 0, 1};
-    int i198[] = {1, 0, 0, 1, 1, 1, 0};
-    int i199[] = {1, 0, 0, 1, 1, 1, 1};
-    int i200[] = {1, 0, 1, 0, 0, 0, 0};
-    int i201[] = {1, 0, 1, 0, 0, 0, 1};
-    int i202[] = {1, 0, 1, 0, 0, 1, 0};
-    int i203[] = {1, 0, 1, 0, 0, 1, 1};
-    int i204[] = {1, 0, 1, 0, 1, 0, 0};
-    int i205[] = {1, 0, 1, 0, 1, 0, 1};
-    int i206[] = {1, 0, 1, 0, 1, 1, 0};
-    int i207[] = {1, 0, 1, 0, 1, 1, 1};
-    int i208[] = {1, 0, 1, 1, 0, 0, 0};
-    int i209[] = {1, 0, 1, 1, 0, 0, 1};
-    int i210[] = {1, 0, 1, 1, 0, 1, 0};
-    int i211[] = {1, 0, 1, 1, 0, 1, 1};
-    int i212[] = {1, 0, 1, 1, 1, 0, 0};
-    int i213[] = {1, 0, 1, 1, 1, 0, 1};
-    int i214[] = {1, 0, 1, 1, 1, 1, 0};
-    int i215[] = {1, 0, 1, 1, 1, 1, 1};
-    int i216[] = {1, 1, 0, 0, 0, 0, 0};
-    int i217[] = {1, 1, 0, 0, 0, 0, 1};
-    int i218[] = {1, 1, 0, 0, 0, 1, 0};
-    int i219[] = {1, 1, 0, 0, 0, 1, 1};
-    int i220[] = {1, 1, 0, 0, 1, 0, 0};
-    int i221[] = {1, 1, 0, 0, 1, 0, 1};
-    int i222[] = {1, 1, 0, 0, 1, 1, 0};
-    int i223[] = {1, 1, 0, 0, 1, 1, 1};
-    int i224[] = {1, 1, 0, 1, 0, 0, 0};
-    int i225[] = {1, 1, 0, 1, 0, 0, 1};
-    int i226[] = {1, 1, 0, 1, 0, 1, 0};
-    int i227[] = {1, 1, 0, 1, 0, 1, 1};
-    int i228[] = {1, 1, 0, 1, 1, 0, 0};
-    int i229[] = {1, 1, 0, 1, 1, 0, 1};
-    int i230[] = {1, 1, 0, 1, 1, 1, 0};
-    int i231[] = {1, 1, 0, 1, 1, 1, 1};
-    int i232[] = {1, 1, 1, 0, 0, 0, 0};
-    int i233[] = {1, 1, 1, 0, 0, 0, 1};
-    int i234[] = {1, 1, 1, 0, 0, 1, 0};
-    int i235[] = {1, 1, 1, 0, 0, 1, 1};
-    int i236[] = {1, 1, 1, 0, 1, 0, 0};
-    int i237[] = {1, 1, 1, 0, 1, 0, 1};
-    int i238[] = {1, 1, 1, 0, 1, 1, 0};
-    int i239[] = {1, 1, 1, 0, 1, 1, 1};
-    int i240[] = {1, 1, 1, 1, 0, 0, 0};
-    int i241[] = {1, 1, 1, 1, 0, 0, 1};
-    int i242[] = {1, 1, 1, 1, 0, 1, 0};
-    int i243[] = {1, 1, 1, 1, 0, 1, 1};
-    int i244[] = {1, 1, 1, 1, 1, 0, 0};
-    int i245[] = {1, 1, 1, 1, 1, 0, 1};
-    int i246[] = {1, 1, 1, 1, 1, 1, 0};
-    is_heap_until(i120, i120+7, std::greater<int>()).check([&](int *r){ CHECK(r == i120+7); });
-    is_heap_until(i121, i121+7, std::greater<int>()).check([&](int *r){ CHECK(r == i121+7); });
-    is_heap_until(i122, i122+7, std::greater<int>()).check([&](int *r){ CHECK(r == i122+7); });
-    is_heap_until(i123, i123+7, std::greater<int>()).check([&](int *r){ CHECK(r == i123+7); });
-    is_heap_until(i124, i124+7, std::greater<int>()).check([&](int *r){ CHECK(r == i124+7); });
-    is_heap_until(i125, i125+7, std::greater<int>()).check([&](int *r){ CHECK(r == i125+7); });
-    is_heap_until(i126, i126+7, std::greater<int>()).check([&](int *r){ CHECK(r == i126+7); });
-    is_heap_until(i127, i127+7, std::greater<int>()).check([&](int *r){ CHECK(r == i127+7); });
-    is_heap_until(i128, i128+7, std::greater<int>()).check([&](int *r){ CHECK(r == i128+7); });
-    is_heap_until(i129, i129+7, std::greater<int>()).check([&](int *r){ CHECK(r == i129+7); });
-    is_heap_until(i130, i130+7, std::greater<int>()).check([&](int *r){ CHECK(r == i130+7); });
-    is_heap_until(i131, i131+7, std::greater<int>()).check([&](int *r){ CHECK(r == i131+7); });
-    is_heap_until(i132, i132+7, std::greater<int>()).check([&](int *r){ CHECK(r == i132+7); });
-    is_heap_until(i133, i133+7, std::greater<int>()).check([&](int *r){ CHECK(r == i133+7); });
-    is_heap_until(i134, i134+7, std::greater<int>()).check([&](int *r){ CHECK(r == i134+7); });
-    is_heap_until(i135, i135+7, std::greater<int>()).check([&](int *r){ CHECK(r == i135+7); });
-    is_heap_until(i136, i136+7, std::greater<int>()).check([&](int *r){ CHECK(r == i136+5); });
-    is_heap_until(i137, i137+7, std::greater<int>()).check([&](int *r){ CHECK(r == i137+5); });
-    is_heap_until(i138, i138+7, std::greater<int>()).check([&](int *r){ CHECK(r == i138+6); });
-    is_heap_until(i139, i139+7, std::greater<int>()).check([&](int *r){ CHECK(r == i139+7); });
-    is_heap_until(i140, i140+7, std::greater<int>()).check([&](int *r){ CHECK(r == i140+5); });
-    is_heap_until(i141, i141+7, std::greater<int>()).check([&](int *r){ CHECK(r == i141+5); });
-    is_heap_until(i142, i142+7, std::greater<int>()).check([&](int *r){ CHECK(r == i142+6); });
-    is_heap_until(i143, i143+7, std::greater<int>()).check([&](int *r){ CHECK(r == i143+7); });
-    is_heap_until(i144, i144+7, std::greater<int>()).check([&](int *r){ CHECK(r == i144+5); });
-    is_heap_until(i145, i145+7, std::greater<int>()).check([&](int *r){ CHECK(r == i145+5); });
-    is_heap_until(i146, i146+7, std::greater<int>()).check([&](int *r){ CHECK(r == i146+6); });
-    is_heap_until(i147, i147+7, std::greater<int>()).check([&](int *r){ CHECK(r == i147+7); });
-    is_heap_until(i148, i148+7, std::greater<int>()).check([&](int *r){ CHECK(r == i148+5); });
-    is_heap_until(i149, i149+7, std::greater<int>()).check([&](int *r){ CHECK(r == i149+5); });
-    is_heap_until(i150, i150+7, std::greater<int>()).check([&](int *r){ CHECK(r == i150+6); });
-    is_heap_until(i151, i151+7, std::greater<int>()).check([&](int *r){ CHECK(r == i151+7); });
-    is_heap_until(i152, i152+7, std::greater<int>()).check([&](int *r){ CHECK(r == i152+3); });
-    is_heap_until(i153, i153+7, std::greater<int>()).check([&](int *r){ CHECK(r == i153+3); });
-    is_heap_until(i154, i154+7, std::greater<int>()).check([&](int *r){ CHECK(r == i154+3); });
-    is_heap_until(i155, i155+7, std::greater<int>()).check([&](int *r){ CHECK(r == i155+3); });
-    is_heap_until(i156, i156+7, std::greater<int>()).check([&](int *r){ CHECK(r == i156+3); });
-    is_heap_until(i157, i157+7, std::greater<int>()).check([&](int *r){ CHECK(r == i157+3); });
-    is_heap_until(i158, i158+7, std::greater<int>()).check([&](int *r){ CHECK(r == i158+3); });
-    is_heap_until(i159, i159+7, std::greater<int>()).check([&](int *r){ CHECK(r == i159+3); });
-    is_heap_until(i160, i160+7, std::greater<int>()).check([&](int *r){ CHECK(r == i160+4); });
-    is_heap_until(i161, i161+7, std::greater<int>()).check([&](int *r){ CHECK(r == i161+4); });
-    is_heap_until(i162, i162+7, std::greater<int>()).check([&](int *r){ CHECK(r == i162+4); });
-    is_heap_until(i163, i163+7, std::greater<int>()).check([&](int *r){ CHECK(r == i163+4); });
-    is_heap_until(i164, i164+7, std::greater<int>()).check([&](int *r){ CHECK(r == i164+7); });
-    is_heap_until(i165, i165+7, std::greater<int>()).check([&](int *r){ CHECK(r == i165+7); });
-    is_heap_until(i166, i166+7, std::greater<int>()).check([&](int *r){ CHECK(r == i166+7); });
-    is_heap_until(i167, i167+7, std::greater<int>()).check([&](int *r){ CHECK(r == i167+7); });
-    is_heap_until(i168, i168+7, std::greater<int>()).check([&](int *r){ CHECK(r == i168+3); });
-    is_heap_until(i169, i169+7, std::greater<int>()).check([&](int *r){ CHECK(r == i169+3); });
-    is_heap_until(i170, i170+7, std::greater<int>()).check([&](int *r){ CHECK(r == i170+3); });
-    is_heap_until(i171, i171+7, std::greater<int>()).check([&](int *r){ CHECK(r == i171+3); });
-    is_heap_until(i172, i172+7, std::greater<int>()).check([&](int *r){ CHECK(r == i172+3); });
-    is_heap_until(i173, i173+7, std::greater<int>()).check([&](int *r){ CHECK(r == i173+3); });
-    is_heap_until(i174, i174+7, std::greater<int>()).check([&](int *r){ CHECK(r == i174+3); });
-    is_heap_until(i175, i175+7, std::greater<int>()).check([&](int *r){ CHECK(r == i175+3); });
-    is_heap_until(i176, i176+7, std::greater<int>()).check([&](int *r){ CHECK(r == i176+4); });
-    is_heap_until(i177, i177+7, std::greater<int>()).check([&](int *r){ CHECK(r == i177+4); });
-    is_heap_until(i178, i178+7, std::greater<int>()).check([&](int *r){ CHECK(r == i178+4); });
-    is_heap_until(i179, i179+7, std::greater<int>()).check([&](int *r){ CHECK(r == i179+4); });
-    is_heap_until(i180, i180+7, std::greater<int>()).check([&](int *r){ CHECK(r == i180+5); });
-    is_heap_until(i181, i181+7, std::greater<int>()).check([&](int *r){ CHECK(r == i181+5); });
-    is_heap_until(i182, i182+7, std::greater<int>()).check([&](int *r){ CHECK(r == i182+6); });
-    is_heap_until(i183, i183+7, std::greater<int>()).check([&](int *r){ CHECK(r == i183+7); });
-    is_heap_until(i184, i184+7, std::greater<int>()).check([&](int *r){ CHECK(r == i184+1); });
-    is_heap_until(i185, i185+7, std::greater<int>()).check([&](int *r){ CHECK(r == i185+1); });
-    is_heap_until(i186, i186+7, std::greater<int>()).check([&](int *r){ CHECK(r == i186+1); });
-    is_heap_until(i187, i187+7, std::greater<int>()).check([&](int *r){ CHECK(r == i187+1); });
-    is_heap_until(i188, i188+7, std::greater<int>()).check([&](int *r){ CHECK(r == i188+1); });
-    is_heap_until(i189, i189+7, std::greater<int>()).check([&](int *r){ CHECK(r == i189+1); });
-    is_heap_until(i190, i190+7, std::greater<int>()).check([&](int *r){ CHECK(r == i190+1); });
-    is_heap_until(i191, i191+7, std::greater<int>()).check([&](int *r){ CHECK(r == i191+1); });
-    is_heap_until(i192, i192+7, std::greater<int>()).check([&](int *r){ CHECK(r == i192+1); });
-    is_heap_until(i193, i193+7, std::greater<int>()).check([&](int *r){ CHECK(r == i193+1); });
-    is_heap_until(i194, i194+7, std::greater<int>()).check([&](int *r){ CHECK(r == i194+1); });
-    is_heap_until(i195, i195+7, std::greater<int>()).check([&](int *r){ CHECK(r == i195+1); });
-    is_heap_until(i196, i196+7, std::greater<int>()).check([&](int *r){ CHECK(r == i196+1); });
-    is_heap_until(i197, i197+7, std::greater<int>()).check([&](int *r){ CHECK(r == i197+1); });
-    is_heap_until(i198, i198+7, std::greater<int>()).check([&](int *r){ CHECK(r == i198+1); });
-    is_heap_until(i199, i199+7, std::greater<int>()).check([&](int *r){ CHECK(r == i199+1); });
-    is_heap_until(i200, i200+7, std::greater<int>()).check([&](int *r){ CHECK(r == i200+1); });
-    is_heap_until(i201, i201+7, std::greater<int>()).check([&](int *r){ CHECK(r == i201+1); });
-    is_heap_until(i202, i202+7, std::greater<int>()).check([&](int *r){ CHECK(r == i202+1); });
-    is_heap_until(i203, i203+7, std::greater<int>()).check([&](int *r){ CHECK(r == i203+1); });
-    is_heap_until(i204, i204+7, std::greater<int>()).check([&](int *r){ CHECK(r == i204+1); });
-    is_heap_until(i205, i205+7, std::greater<int>()).check([&](int *r){ CHECK(r == i205+1); });
-    is_heap_until(i206, i206+7, std::greater<int>()).check([&](int *r){ CHECK(r == i206+1); });
-    is_heap_until(i207, i207+7, std::greater<int>()).check([&](int *r){ CHECK(r == i207+1); });
-    is_heap_until(i208, i208+7, std::greater<int>()).check([&](int *r){ CHECK(r == i208+1); });
-    is_heap_until(i209, i209+7, std::greater<int>()).check([&](int *r){ CHECK(r == i209+1); });
-    is_heap_until(i210, i210+7, std::greater<int>()).check([&](int *r){ CHECK(r == i210+1); });
-    is_heap_until(i211, i211+7, std::greater<int>()).check([&](int *r){ CHECK(r == i211+1); });
-    is_heap_until(i212, i212+7, std::greater<int>()).check([&](int *r){ CHECK(r == i212+1); });
-    is_heap_until(i213, i213+7, std::greater<int>()).check([&](int *r){ CHECK(r == i213+1); });
-    is_heap_until(i214, i214+7, std::greater<int>()).check([&](int *r){ CHECK(r == i214+1); });
-    is_heap_until(i215, i215+7, std::greater<int>()).check([&](int *r){ CHECK(r == i215+1); });
-    is_heap_until(i216, i216+7, std::greater<int>()).check([&](int *r){ CHECK(r == i216+2); });
-    is_heap_until(i217, i217+7, std::greater<int>()).check([&](int *r){ CHECK(r == i217+2); });
-    is_heap_until(i218, i218+7, std::greater<int>()).check([&](int *r){ CHECK(r == i218+2); });
-    is_heap_until(i219, i219+7, std::greater<int>()).check([&](int *r){ CHECK(r == i219+2); });
-    is_heap_until(i220, i220+7, std::greater<int>()).check([&](int *r){ CHECK(r == i220+2); });
-    is_heap_until(i221, i221+7, std::greater<int>()).check([&](int *r){ CHECK(r == i221+2); });
-    is_heap_until(i222, i222+7, std::greater<int>()).check([&](int *r){ CHECK(r == i222+2); });
-    is_heap_until(i223, i223+7, std::greater<int>()).check([&](int *r){ CHECK(r == i223+2); });
-    is_heap_until(i224, i224+7, std::greater<int>()).check([&](int *r){ CHECK(r == i224+2); });
-    is_heap_until(i225, i225+7, std::greater<int>()).check([&](int *r){ CHECK(r == i225+2); });
-    is_heap_until(i226, i226+7, std::greater<int>()).check([&](int *r){ CHECK(r == i226+2); });
-    is_heap_until(i227, i227+7, std::greater<int>()).check([&](int *r){ CHECK(r == i227+2); });
-    is_heap_until(i228, i228+7, std::greater<int>()).check([&](int *r){ CHECK(r == i228+2); });
-    is_heap_until(i229, i229+7, std::greater<int>()).check([&](int *r){ CHECK(r == i229+2); });
-    is_heap_until(i230, i230+7, std::greater<int>()).check([&](int *r){ CHECK(r == i230+2); });
-    is_heap_until(i231, i231+7, std::greater<int>()).check([&](int *r){ CHECK(r == i231+2); });
-    is_heap_until(i232, i232+7, std::greater<int>()).check([&](int *r){ CHECK(r == i232+3); });
-    is_heap_until(i233, i233+7, std::greater<int>()).check([&](int *r){ CHECK(r == i233+3); });
-    is_heap_until(i234, i234+7, std::greater<int>()).check([&](int *r){ CHECK(r == i234+3); });
-    is_heap_until(i235, i235+7, std::greater<int>()).check([&](int *r){ CHECK(r == i235+3); });
-    is_heap_until(i236, i236+7, std::greater<int>()).check([&](int *r){ CHECK(r == i236+3); });
-    is_heap_until(i237, i237+7, std::greater<int>()).check([&](int *r){ CHECK(r == i237+3); });
-    is_heap_until(i238, i238+7, std::greater<int>()).check([&](int *r){ CHECK(r == i238+3); });
-    is_heap_until(i239, i239+7, std::greater<int>()).check([&](int *r){ CHECK(r == i239+3); });
-    is_heap_until(i240, i240+7, std::greater<int>()).check([&](int *r){ CHECK(r == i240+4); });
-    is_heap_until(i241, i241+7, std::greater<int>()).check([&](int *r){ CHECK(r == i241+4); });
-    is_heap_until(i242, i242+7, std::greater<int>()).check([&](int *r){ CHECK(r == i242+4); });
-    is_heap_until(i243, i243+7, std::greater<int>()).check([&](int *r){ CHECK(r == i243+4); });
-    is_heap_until(i244, i244+7, std::greater<int>()).check([&](int *r){ CHECK(r == i244+5); });
-    is_heap_until(i245, i245+7, std::greater<int>()).check([&](int *r){ CHECK(r == i245+5); });
-    is_heap_until(i246, i246+7, std::greater<int>()).check([&](int *r){ CHECK(r == i246+6); });
-#endif
-}
-
-struct S
-{
-    int i;
-};
-
-int main()
-{
-    test();
-    test_pred();
-
-    // Test projections:
-    S i185[] = {S{1}, S{0}, S{0}, S{0}, S{0}, S{0}, S{1}};
-    ::make_testable_1(ranges::is_heap_until)(i185, i185+7, std::greater<int>(), &S::i)
-        .check([&](S *r){ CHECK(r == i185+1); });
-
-    // Test rvalue range
-#ifndef RANGES_WORKAROUND_MSVC_573728
-    auto res0 = ranges::is_heap_until(std::move(i185), std::greater<int>(), &S::i);
-    CHECK(::is_dangling(res0));
-#endif // RANGES_WORKAROUND_MSVC_573728
-    std::vector<S> vec(ranges::begin(i185), ranges::end(i185));
-    auto res1 = ranges::is_heap_until(std::move(vec), std::greater<int>(), &S::i);
-    CHECK(::is_dangling(res1));
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/is_heap_until1.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/is_heap_until1.cpp
deleted file mode 100644
index 87da2c36..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/is_heap_until1.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define IS_HEAP_UNTIL_1
-#include "./is_heap_until.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/is_heap_until2.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/is_heap_until2.cpp
deleted file mode 100644
index 882e1c89..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/is_heap_until2.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define IS_HEAP_UNTIL_2
-#include "./is_heap_until.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/is_heap_until3.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/is_heap_until3.cpp
deleted file mode 100644
index fb72e0a2..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/is_heap_until3.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define IS_HEAP_UNTIL_3
-#include "./is_heap_until.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/is_heap_until4.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/is_heap_until4.cpp
deleted file mode 100644
index 106d25ee..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/is_heap_until4.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define IS_HEAP_UNTIL_4
-#include "./is_heap_until.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/is_partitioned.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/is_partitioned.cpp
deleted file mode 100644
index 4e800c94..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/is_partitioned.cpp
+++ /dev/null
@@ -1,128 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <memory>
-#include <utility>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/is_partitioned.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-struct is_odd
-{
-    bool operator()(const int& i) const {return i & 1;}
-};
-
-template<class Iter, class Sent = Iter>
-void
-test_iter()
-{
-    {
-        const int ia[] = {1, 2, 3, 4, 5, 6};
-        CHECK(!ranges::is_partitioned(Iter(ranges::begin(ia)),
-                                      Sent(ranges::end(ia)),
-                                      is_odd()));
-    }
-    {
-        const int ia[] = {1, 3, 5, 2, 4, 6};
-        CHECK( ranges::is_partitioned(Iter(ranges::begin(ia)),
-                                      Sent(ranges::end(ia)),
-                                      is_odd()));
-    }
-    {
-        const int ia[] = {2, 4, 6, 1, 3, 5};
-        CHECK(!ranges::is_partitioned(Iter(ranges::begin(ia)),
-                                      Sent(ranges::end(ia)),
-                                      is_odd()));
-    }
-    {
-        const int ia[] = {1, 3, 5, 2, 4, 6, 7};
-        CHECK(!ranges::is_partitioned(Iter(ranges::begin(ia)),
-                                      Sent(ranges::end(ia)),
-                                      is_odd()));
-    }
-    {
-        const int ia[] = {1, 3, 5, 2, 4, 6, 7};
-        CHECK( ranges::is_partitioned(Iter(ranges::begin(ia)),
-                                      Sent(ranges::begin(ia)),
-                                      is_odd()));
-    }
-}
-
-template<class Iter, class Sent = Iter>
-void
-test_range()
-{
-    {
-        const int ia[] = {1, 2, 3, 4, 5, 6};
-        CHECK(!ranges::is_partitioned(ranges::make_subrange(Iter(ranges::begin(ia)),
-                                                    Sent(ranges::end(ia))),
-                                      is_odd()));
-    }
-    {
-        const int ia[] = {1, 3, 5, 2, 4, 6};
-        CHECK( ranges::is_partitioned(ranges::make_subrange(Iter(ranges::begin(ia)),
-                                                    Sent(ranges::end(ia))),
-                                      is_odd()));
-    }
-    {
-        const int ia[] = {2, 4, 6, 1, 3, 5};
-        CHECK(!ranges::is_partitioned(ranges::make_subrange(Iter(ranges::begin(ia)),
-                                                    Sent(ranges::end(ia))),
-                                      is_odd()));
-    }
-    {
-        const int ia[] = {1, 3, 5, 2, 4, 6, 7};
-        CHECK(!ranges::is_partitioned(ranges::make_subrange(Iter(ranges::begin(ia)),
-                                                    Sent(ranges::end(ia))),
-                                      is_odd()));
-    }
-    {
-        const int ia[] = {1, 3, 5, 2, 4, 6, 7};
-        CHECK( ranges::is_partitioned(ranges::make_subrange(Iter(ranges::begin(ia)),
-                                                    Sent(ranges::begin(ia))),
-                                      is_odd()));
-    }
-}
-
-struct S
-{
-    int i;
-};
-
-int main()
-{
-    test_iter<InputIterator<const int*> >();
-    test_iter<InputIterator<const int*>, Sentinel<const int*>>();
-
-    test_range<InputIterator<const int*> >();
-    test_range<InputIterator<const int*>, Sentinel<const int*>>();
-
-    // Test projections
-    const S ia[] = {S{1}, S{3}, S{5}, S{2}, S{4}, S{6}};
-    CHECK( ranges::is_partitioned(ia, is_odd(), &S::i) );
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/is_permutation.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/is_permutation.cpp
deleted file mode 100644
index 27bb753a..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/is_permutation.cpp
+++ /dev/null
@@ -1,854 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <utility>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/permutation.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-RANGES_DIAGNOSTIC_IGNORE_DEPRECATED_DECLARATIONS
-
-int comparison_count = 0;
-
-template<typename T>
-bool counting_equals( T const &a, T const &b )
-{
-    ++comparison_count;
-    return a == b;
-}
-
-struct S
-{
-    int i;
-};
-
-struct T
-{
-    int i;
-};
-
-int main()
-{
-    {
-        const int ia[] = {0};
-        const int ib[] = {0};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + 0),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == true);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == true);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == true);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa - 1),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {0};
-        const int ib[] = {1};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == false);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == false);
-    }
-
-    {
-        const int ia[] = {0, 0};
-        const int ib[] = {0, 0};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == true);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == true);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa - 1),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {0, 0};
-        const int ib[] = {0, 1};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == false);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {0, 0};
-        const int ib[] = {1, 0};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == false);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {0, 0};
-        const int ib[] = {1, 1};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == false);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {0, 1};
-        const int ib[] = {0, 0};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == false);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {0, 1};
-        const int ib[] = {0, 1};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == true);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == true);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa - 1),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {0, 1};
-        const int ib[] = {1, 0};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == true);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == true);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa - 1),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {0, 1};
-        const int ib[] = {1, 1};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == false);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {1, 0};
-        const int ib[] = {0, 0};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == false);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {1, 0};
-        const int ib[] = {0, 1};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == true);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == true);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa - 1),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {1, 0};
-        const int ib[] = {1, 0};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == true);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == true);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa - 1),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {1, 0};
-        const int ib[] = {1, 1};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == false);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {1, 1};
-        const int ib[] = {0, 0};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == false);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {1, 1};
-        const int ib[] = {0, 1};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == false);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {1, 1};
-        const int ib[] = {1, 0};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == false);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {1, 1};
-        const int ib[] = {1, 1};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == true);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == true);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa - 1),
-                                   std::equal_to<const int>()) == false);
-    }
-
-    {
-        const int ia[] = {0, 0, 0};
-        const int ib[] = {1, 0, 0};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == false);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {0, 0, 0};
-        const int ib[] = {1, 0, 1};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == false);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {0, 0, 0};
-        const int ib[] = {1, 0, 2};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == false);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {0, 0, 0};
-        const int ib[] = {1, 1, 0};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == false);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {0, 0, 0};
-        const int ib[] = {1, 1, 1};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == false);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {0, 0, 0};
-        const int ib[] = {1, 1, 2};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == false);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {0, 0, 0};
-        const int ib[] = {1, 2, 0};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == false);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {0, 0, 0};
-        const int ib[] = {1, 2, 1};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == false);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {0, 0, 0};
-        const int ib[] = {1, 2, 2};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == false);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {0, 0, 1};
-        const int ib[] = {1, 0, 0};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == true);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == true);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa - 1),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {0, 0, 1};
-        const int ib[] = {1, 0, 1};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == false);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {0, 1, 2};
-        const int ib[] = {1, 0, 2};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == true);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == true);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa - 1),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {0, 1, 2};
-        const int ib[] = {1, 2, 0};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == true);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == true);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa - 1),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {0, 1, 2};
-        const int ib[] = {2, 1, 0};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == true);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == true);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa - 1),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {0, 1, 2};
-        const int ib[] = {2, 0, 1};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == true);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == true);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa - 1),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {0, 0, 1};
-        const int ib[] = {1, 0, 1};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == false);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {0, 0, 1};
-        const int ib[] = {1, 0, 0};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == true);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == true);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib + 1),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == false);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa - 1),
-                                   std::equal_to<const int>()) == false);
-    }
-    {
-        const int ia[] = {0, 1, 2, 3, 0, 5, 6, 2, 4, 4};
-        const int ib[] = {4, 2, 3, 0, 1, 4, 0, 5, 6, 2};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == true);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == true);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib + 1),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == false);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa - 1),
-                                   std::equal_to<const int>()) == false);
-        comparison_count = 0;
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa - 1),
-                                   counting_equals<const int>) == false);
-        CHECK( comparison_count > 0 );
-        comparison_count = 0;
-        CHECK(ranges::is_permutation(RandomAccessIterator<const int*>(ia),
-                                   RandomAccessIterator<const int*>(ia + sa),
-                                   RandomAccessIterator<const int*>(ib),
-                                   RandomAccessIterator<const int*>(ib + sa - 1),
-                                   counting_equals<const int>) == false);
-        CHECK ( comparison_count == 0 );
-    }
-    {
-        const int ia[] = {0, 1, 2, 3, 0, 5, 6, 2, 4, 4};
-        const int ib[] = {4, 2, 3, 0, 1, 4, 0, 5, 6, 0};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<const int>()) == false);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa),
-                                   std::equal_to<const int>()) == false);
-    }
-
-    // Iterator tests, without predicate:
-    {
-        const int ia[] = {0, 1, 2, 3, 0, 5, 6, 2, 4, 4};
-        const int ib[] = {4, 2, 3, 0, 1, 4, 0, 5, 6, 2};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib)) == true);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa)) == true);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib + 1),
-                                   ForwardIterator<const int*>(ib + sa)) == false);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                   ForwardIterator<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                   ForwardIterator<const int*>(ib + sa - 1)) == false);
-    }
-
-    // Iterator tests, with sentinels:
-    {
-        const int ia[] = {0, 1, 2, 3, 0, 5, 6, 2, 4, 4};
-        const int ib[] = {4, 2, 3, 0, 1, 4, 0, 5, 6, 2};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                    Sentinel<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib)) == true);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                    Sentinel<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                    Sentinel<const int*>(ib + sa)) == true);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                    Sentinel<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib + 1),
-                                    Sentinel<const int*>(ib + sa)) == false);
-        CHECK(ranges::is_permutation(ForwardIterator<const int*>(ia),
-                                    Sentinel<const int*>(ia + sa),
-                                   ForwardIterator<const int*>(ib),
-                                    Sentinel<const int*>(ib + sa - 1)) == false);
-    }
-
-    // common_range tests, with sentinels:
-    {
-        const int ia[] = {0, 1, 2, 3, 0, 5, 6, 2, 4, 4};
-        const int ib[] = {4, 2, 3, 0, 1, 4, 0, 5, 6, 2};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ranges::make_subrange(ForwardIterator<const int*>(ia),
-                                    Sentinel<const int*>(ia + sa)),
-                                   ForwardIterator<const int*>(ib)) == true);
-
-        CHECK(ranges::is_permutation(ranges::make_subrange(ForwardIterator<const int*>(ia),
-                                    Sentinel<const int*>(ia + sa)),
-                                   ranges::make_subrange(ForwardIterator<const int*>(ib),
-                                    Sentinel<const int*>(ib + sa))) == true);
-        CHECK(ranges::is_permutation(ranges::make_subrange(ForwardIterator<const int*>(ia),
-                                    Sentinel<const int*>(ia + sa)),
-                                   ranges::make_subrange(ForwardIterator<const int*>(ib + 1),
-                                    Sentinel<const int*>(ib + sa))) == false);
-        CHECK(ranges::is_permutation(ranges::make_subrange(ForwardIterator<const int*>(ia),
-                                    Sentinel<const int*>(ia + sa)),
-                                   ranges::make_subrange(ForwardIterator<const int*>(ib),
-                                    Sentinel<const int*>(ib + sa - 1))) == false);
-    }
-
-    // common_range tests, with sentinels, with predicate:
-    {
-        const int ia[] = {0, 1, 2, 3, 0, 5, 6, 2, 4, 4};
-        const int ib[] = {4, 2, 3, 0, 1, 4, 0, 5, 6, 2};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ranges::make_subrange(ForwardIterator<const int*>(ia),
-                                    Sentinel<const int*>(ia + sa)),
-                                   ForwardIterator<const int*>(ib),
-                                   std::equal_to<int const>()) == true);
-
-        CHECK(ranges::is_permutation(ranges::make_subrange(ForwardIterator<const int*>(ia),
-                                    Sentinel<const int*>(ia + sa)),
-                                   ranges::make_subrange(ForwardIterator<const int*>(ib),
-                                    Sentinel<const int*>(ib + sa)),
-                                   std::equal_to<int const>()) == true);
-        CHECK(ranges::is_permutation(ranges::make_subrange(ForwardIterator<const int*>(ia),
-                                    Sentinel<const int*>(ia + sa)),
-                                   ranges::make_subrange(ForwardIterator<const int*>(ib + 1),
-                                    Sentinel<const int*>(ib + sa)),
-                                   std::equal_to<int const>()) == false);
-        CHECK(ranges::is_permutation(ranges::make_subrange(ForwardIterator<const int*>(ia),
-                                    Sentinel<const int*>(ia + sa)),
-                                   ranges::make_subrange(ForwardIterator<const int*>(ib),
-                                    Sentinel<const int*>(ib + sa - 1)),
-                                   std::equal_to<int const>()) == false);
-    }
-
-    // common_range tests, with sentinels, with predicate and projections:
-    {
-        const S ia[] = {{0}, {1}, {2}, {3}, {0}, {5}, {6}, {2}, {4}, {4}};
-        const T ib[] = {{4}, {2}, {3}, {0}, {1}, {4}, {0}, {5}, {6}, {2}};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ia, &ib[0], std::equal_to<int const>(), &S::i, &T::i) == true);
-        CHECK(ranges::is_permutation(ia, ib, std::equal_to<int const>(), &S::i, &T::i) == true);
-        CHECK(ranges::is_permutation(ranges::make_subrange(ForwardIterator<const S*>(ia),
-                                    Sentinel<const S*>(ia + sa)),
-                                   ranges::make_subrange(ForwardIterator<const T*>(ib + 1),
-                                    Sentinel<const T*>(ib + sa)),
-                                   std::equal_to<int const>(), &S::i, &T::i) == false);
-        CHECK(ranges::is_permutation(ranges::make_subrange(ForwardIterator<const S*>(ia),
-                                    Sentinel<const S*>(ia + sa)),
-                                   ranges::make_subrange(ForwardIterator<const T*>(ib),
-                                    Sentinel<const T*>(ib + sa - 1)),
-                                   std::equal_to<int const>(), &S::i, &T::i) == false);
-    }
-
-    // Iterator tests, with sentinels, with predicate and projections:
-    {
-        const S ia[] = {{0}, {1}, {2}, {3}, {0}, {5}, {6}, {2}, {4}, {4}};
-        const T ib[] = {{4}, {2}, {3}, {0}, {1}, {4}, {0}, {5}, {6}, {2}};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        CHECK(ranges::is_permutation(ForwardIterator<const S*>(ia),
-                                    Sentinel<const S*>(ia + sa),
-                                   ForwardIterator<const T*>(ib),
-                                   std::equal_to<int const>(), &S::i, &T::i) == true);
-
-        CHECK(ranges::is_permutation(ForwardIterator<const S*>(ia),
-                                    Sentinel<const S*>(ia + sa),
-                                   ForwardIterator<const T*>(ib),
-                                    Sentinel<const T*>(ib + sa),
-                                   std::equal_to<int const>(), &S::i, &T::i) == true);
-        CHECK(ranges::is_permutation(ForwardIterator<const S*>(ia),
-                                    Sentinel<const S*>(ia + sa),
-                                   ForwardIterator<const T*>(ib + 1),
-                                    Sentinel<const T*>(ib + sa),
-                                   std::equal_to<int const>(), &S::i, &T::i) == false);
-        CHECK(ranges::is_permutation(ForwardIterator<const S*>(ia),
-                                    Sentinel<const S*>(ia + sa),
-                                   ForwardIterator<const T*>(ib),
-                                    Sentinel<const T*>(ib + sa - 1),
-                                   std::equal_to<int const>(), &S::i, &T::i) == false);
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/is_sorted.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/is_sorted.cpp
deleted file mode 100644
index 5fcd443c..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/is_sorted.cpp
+++ /dev/null
@@ -1,409 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Gonzalo Brito Gadeschi 2014
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-// Implementation based on the code in libc++
-//   http://http://libcxx.llvm.org/
-
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/is_sorted.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-/// Calls the iterator interface of the algorithm
-template<class Iter>
-struct iter_call
-{
-    using begin_t = Iter;
-    using sentinel_t = typename sentinel_type<Iter>::type;
-
-    template<class B, class E, class... Args>
-    auto operator()(B &&b, E &&e, Args &&... args)
-     -> decltype(ranges::is_sorted(begin_t{b}, sentinel_t{e},
-                                   std::forward<Args>(args)...))
-    {
-        return ranges::is_sorted(begin_t{b}, sentinel_t{e}, std::forward<Args>(args)...);
-    }
-};
-
-/// Calls the range interface of the algorithm
-template<class Iter>
-struct range_call
-{
-    using begin_t = Iter;
-    using sentinel_t = typename sentinel_type<Iter>::type;
-
-    template<class B, class E>
-    auto operator()(B && b, E && e)
-        -> decltype(ranges::is_sorted(ranges::make_subrange(begin_t{b}, sentinel_t{e})))
-    {
-        return ranges::is_sorted(ranges::make_subrange(begin_t{b}, sentinel_t{e}));
-    }
-    template<class B, class E, class A0>
-    auto operator()(B && b, E && e, A0 && a0)
-        -> decltype(ranges::is_sorted(ranges::make_subrange(begin_t{b}, sentinel_t{e}),
-                                      static_cast<A0 &&>(a0)))
-    {
-        return ranges::is_sorted(ranges::make_subrange(begin_t{b}, sentinel_t{e}),
-                                 static_cast<A0 &&>(a0));
-    }
-    template<class B, class E, class A0, class A1>
-    auto operator()(B && b, E && e, A0 && a0, A1 && a1)
-        -> decltype(ranges::is_sorted(ranges::make_subrange(begin_t{b}, sentinel_t{e}),
-                                      static_cast<A0 &&>(a0), static_cast<A1 &&>(a1)))
-    {
-        return ranges::is_sorted(ranges::make_subrange(begin_t{b}, sentinel_t{e}),
-                                 static_cast<A0 &&>(a0),
-                                 static_cast<A1 &&>(a1));
-    }
-};
-
-template<class Fun>
-void test()
-{
-    {
-        int a[] = {0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a));
-        CHECK(Fun{}(a, a + sa));
-    }
-
-    {
-        int a[] = {0, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa));
-    }
-    {
-        int a[] = {0, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa));
-    }
-    {
-        int a[] = {1, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa));
-    }
-    {
-        int a[] = {1, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa));
-    }
-
-    {
-        int a[] = {0, 0, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa));
-    }
-    {
-        int a[] = {0, 0, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa));
-    }
-    {
-        int a[] = {0, 1, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa));
-    }
-    {
-        int a[] = {0, 1, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa));
-    }
-    {
-        int a[] = {1, 0, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa));
-    }
-    {
-        int a[] = {1, 0, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa));
-    }
-    {
-        int a[] = {1, 1, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa));
-    }
-    {
-        int a[] = {1, 1, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa));
-    }
-
-    {
-        int a[] = {0, 0, 0, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa));
-    }
-    {
-        int a[] = {0, 0, 0, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa));
-    }
-    {
-        int a[] = {0, 0, 1, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa));
-    }
-    {
-        int a[] = {0, 0, 1, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa));
-    }
-    {
-        int a[] = {0, 1, 0, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa));
-    }
-    {
-        int a[] = {0, 1, 0, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa));
-    }
-    {
-        int a[] = {0, 1, 1, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa));
-    }
-    {
-        int a[] = {0, 1, 1, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa));
-    }
-    {
-        int a[] = {1, 0, 0, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa));
-    }
-    {
-        int a[] = {1, 0, 0, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa));
-    }
-    {
-        int a[] = {1, 0, 1, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa));
-    }
-    {
-        int a[] = {1, 0, 1, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa));
-    }
-    {
-        int a[] = {1, 1, 0, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa));
-    }
-    {
-        int a[] = {1, 1, 0, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa));
-    }
-    {
-        int a[] = {1, 1, 1, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa));
-    }
-    {
-        int a[] = {1, 1, 1, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa));
-    }
-
-    {
-        int a[] = {0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a));
-        CHECK(Fun{}(a, a + sa, std::greater<int>()));
-    }
-
-    {
-        int a[] = {0, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()));
-    }
-    {
-        int a[] = {0, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa, std::greater<int>()));
-    }
-    {
-        int a[] = {1, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()));
-    }
-    {
-        int a[] = {1, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()));
-    }
-
-    {
-        int a[] = {0, 0, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()));
-    }
-    {
-        int a[] = {0, 0, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa, std::greater<int>()));
-    }
-    {
-        int a[] = {0, 1, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa, std::greater<int>()));
-    }
-    {
-        int a[] = {0, 1, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa, std::greater<int>()));
-    }
-    {
-        int a[] = {1, 0, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()));
-    }
-    {
-        int a[] = {1, 0, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa, std::greater<int>()));
-    }
-    {
-        int a[] = {1, 1, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()));
-    }
-    {
-        int a[] = {1, 1, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()));
-    }
-
-    {
-        int a[] = {0, 0, 0, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()));
-    }
-    {
-        int a[] = {0, 0, 0, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa, std::greater<int>()));
-    }
-    {
-        int a[] = {0, 0, 1, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa, std::greater<int>()));
-    }
-    {
-        int a[] = {0, 0, 1, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa, std::greater<int>()));
-    }
-    {
-        int a[] = {0, 1, 0, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa, std::greater<int>()));
-    }
-    {
-        int a[] = {0, 1, 0, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa, std::greater<int>()));
-    }
-    {
-        int a[] = {0, 1, 1, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa, std::greater<int>()));
-    }
-    {
-        int a[] = {0, 1, 1, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa, std::greater<int>()));
-    }
-    {
-        int a[] = {1, 0, 0, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()));
-    }
-    {
-        int a[] = {1, 0, 0, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa, std::greater<int>()));
-    }
-    {
-        int a[] = {1, 0, 1, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa, std::greater<int>()));
-    }
-    {
-        int a[] = {1, 0, 1, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa, std::greater<int>()));
-    }
-    {
-        int a[] = {1, 1, 0, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()));
-    }
-    {
-        int a[] = {1, 1, 0, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(!Fun{}(a, a + sa, std::greater<int>()));
-    }
-    {
-        int a[] = {1, 1, 1, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()));
-    }
-    {
-        int a[] = {1, 1, 1, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()));
-    }
-}
-
-struct A { int a; };
-
-int main()
-{
-    test<iter_call<ForwardIterator<const int *>>>();
-    test<iter_call<BidirectionalIterator<const int *>>>();
-    test<iter_call<RandomAccessIterator<const int *>>>();
-    test<iter_call<const int *>>();
-
-    test<range_call<ForwardIterator<const int *>>>();
-    test<range_call<BidirectionalIterator<const int *>>>();
-    test<range_call<RandomAccessIterator<const int *>>>();
-    test<range_call<const int *>>();
-
-    /// Projection test:
-    {
-        A as[] = {{0}, {1}, {2}, {3}, {4}};
-        CHECK(ranges::is_sorted(as, std::less<int>{}, &A::a));
-        CHECK(!ranges::is_sorted(as, std::greater<int>{}, &A::a));
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/is_sorted_until.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/is_sorted_until.cpp
deleted file mode 100644
index 4b4254f2..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/is_sorted_until.cpp
+++ /dev/null
@@ -1,452 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Gonzalo Brito Gadeschi 2014
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-// Implementation based on the code in libc++
-//   http://http://libcxx.llvm.org/
-
-#include <vector>
-
-#include <range/v3/algorithm/is_sorted_until.hpp>
-#include <range/v3/core.hpp>
-
-#include "../simple_test.hpp"
-#include "../test_iterators.hpp"
-#include "../test_utils.hpp"
-
-/// Calls the iterator interface of the algorithm
-template<class Iter>
-struct iter_call
-{
-    using begin_t = Iter;
-    using sentinel_t = typename sentinel_type<Iter>::type;
-
-    template<class B, class E, class... Args>
-    auto operator()(B && It, E && e, Args &&... args)
-        -> decltype(ranges::is_sorted_until(begin_t{It}, sentinel_t{e},
-                                            std::forward<Args>(args)...))
-    {
-        return ranges::is_sorted_until(
-            begin_t{It}, sentinel_t{e}, std::forward<Args>(args)...);
-    }
-};
-
-/// Calls the range interface of the algorithm
-template<class Iter>
-struct range_call
-{
-    using begin_t = Iter;
-    using sentinel_t = typename sentinel_type<Iter>::type;
-
-    template<class B, class E, class... Args>
-    static auto _impl(B && It, E && e, Args &&... args)
-        -> decltype(ranges::is_sorted_until(
-            ::as_lvalue(ranges::make_subrange(begin_t{It}, sentinel_t{e})),
-            std::forward<Args>(args)...))
-    {
-        return ranges::is_sorted_until(
-            ::as_lvalue(ranges::make_subrange(begin_t{It}, sentinel_t{e})),
-            std::forward<Args>(args)...);
-    }
-
-    template<class B, class E>
-    auto operator()(B && It, E && e) const -> decltype(ranges::is_sorted_until(
-        ::as_lvalue(ranges::make_subrange(begin_t{It}, sentinel_t{e}))))
-    {
-        return range_call::_impl(static_cast<B &&>(It), static_cast<E &&>(e));
-    }
-
-    template<class B, class E, class A0>
-    auto operator()(B && It, E && e, A0 && a0) const
-        -> decltype(ranges::is_sorted_until(::as_lvalue(
-            ranges::make_subrange(begin_t{It}, sentinel_t{e})), static_cast<A0 &&>(a0)))
-    {
-        return range_call::_impl(
-            static_cast<B &&>(It), static_cast<E &&>(e), static_cast<A0 &&>(a0));
-    }
-
-    template<class B, class E, class A0, class A1>
-    auto operator()(B && It, E && e, A0 && a0, A1 && a1) const
-        -> decltype(ranges::is_sorted_until(::as_lvalue(ranges::make_subrange(
-            begin_t{It}, sentinel_t{e})), static_cast<A0 &&>(a0), static_cast<A1 &&>(a1)))
-    {
-        return range_call::_impl(
-            static_cast<B &&>(It), static_cast<E &&>(e), static_cast<A0 &&>(a0), static_cast<A1 &&>(a1));
-    }
-};
-
-template<class It, template<class> class FunT>
-void test()
-{
-    using Fun = FunT<It>;
-
-    {
-        int a[] = {0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a) == It(a));
-        CHECK(Fun{}(a, a + sa) == It(a + sa));
-    }
-
-    {
-        int a[] = {0, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa) == It(a + sa));
-    }
-    {
-        int a[] = {0, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa) == It(a + sa));
-    }
-    {
-        int a[] = {1, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa) == It(a + 1));
-    }
-    {
-        int a[] = {1, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa) == It(a + sa));
-    }
-
-    {
-        int a[] = {0, 0, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa) == It(a + sa));
-    }
-    {
-        int a[] = {0, 0, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa) == It(a + sa));
-    }
-    {
-        int a[] = {0, 1, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa) == It(a + 2));
-    }
-    {
-        int a[] = {0, 1, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa) == It(a + sa));
-    }
-    {
-        int a[] = {1, 0, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa) == It(a + 1));
-    }
-    {
-        int a[] = {1, 0, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa) == It(a + 1));
-    }
-    {
-        int a[] = {1, 1, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa) == It(a + 2));
-    }
-    {
-        int a[] = {1, 1, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa) == It(a + sa));
-    }
-
-    {
-        int a[] = {0, 0, 0, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa) == It(a + sa));
-    }
-    {
-        int a[] = {0, 0, 0, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa) == It(a + sa));
-    }
-    {
-        int a[] = {0, 0, 1, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa) == It(a + 3));
-    }
-    {
-        int a[] = {0, 0, 1, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa) == It(a + sa));
-    }
-    {
-        int a[] = {0, 1, 0, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa) == It(a + 2));
-    }
-    {
-        int a[] = {0, 1, 0, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa) == It(a + 2));
-    }
-    {
-        int a[] = {0, 1, 1, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa) == It(a + 3));
-    }
-    {
-        int a[] = {0, 1, 1, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa) == It(a + sa));
-    }
-    {
-        int a[] = {1, 0, 0, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa) == It(a + 1));
-    }
-    {
-        int a[] = {1, 0, 0, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa) == It(a + 1));
-    }
-    {
-        int a[] = {1, 0, 1, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa) == It(a + 1));
-    }
-    {
-        int a[] = {1, 0, 1, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa) == It(a + 1));
-    }
-    {
-        int a[] = {1, 1, 0, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa) == It(a + 2));
-    }
-    {
-        int a[] = {1, 1, 0, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa) == It(a + 2));
-    }
-    {
-        int a[] = {1, 1, 1, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa) == It(a + 3));
-    }
-    {
-        int a[] = {1, 1, 1, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa) == It(a + sa));
-    }
-
-    {
-        int a[] = {0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a, std::greater<int>()) == It(a));
-        CHECK(Fun{}(a, a + sa, std::greater<int>()) == It(a + sa));
-    }
-    {
-        int a[] = {0, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()) == It(a + sa));
-    }
-    {
-        int a[] = {0, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()) == It(a + 1));
-    }
-    {
-        int a[] = {1, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()) == It(a + sa));
-    }
-    {
-        int a[] = {1, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()) == It(a + sa));
-    }
-
-    {
-        int a[] = {0, 0, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()) == It(a + sa));
-    }
-    {
-        int a[] = {0, 0, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()) == It(a + 2));
-    }
-    {
-        int a[] = {0, 1, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()) == It(a + 1));
-    }
-    {
-        int a[] = {0, 1, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()) == It(a + 1));
-    }
-    {
-        int a[] = {1, 0, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()) == It(a + sa));
-    }
-    {
-        int a[] = {1, 0, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()) == It(a + 2));
-    }
-    {
-        int a[] = {1, 1, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()) == It(a + sa));
-    }
-    {
-        int a[] = {1, 1, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()) == It(a + sa));
-    }
-
-    {
-        int a[] = {0, 0, 0, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()) == It(a + sa));
-    }
-    {
-        int a[] = {0, 0, 0, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()) == It(a + 3));
-    }
-    {
-        int a[] = {0, 0, 1, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()) == It(a + 2));
-    }
-    {
-        int a[] = {0, 0, 1, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()) == It(a + 2));
-    }
-    {
-        int a[] = {0, 1, 0, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()) == It(a + 1));
-    }
-    {
-        int a[] = {0, 1, 0, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()) == It(a + 1));
-    }
-    {
-        int a[] = {0, 1, 1, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()) == It(a + 1));
-    }
-    {
-        int a[] = {0, 1, 1, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()) == It(a + 1));
-    }
-    {
-        int a[] = {1, 0, 0, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()) == It(a + sa));
-    }
-    {
-        int a[] = {1, 0, 0, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()) == It(a + 3));
-    }
-    {
-        int a[] = {1, 0, 1, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()) == It(a + 2));
-    }
-    {
-        int a[] = {1, 0, 1, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()) == It(a + 2));
-    }
-    {
-        int a[] = {1, 1, 0, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()) == It(a + sa));
-    }
-    {
-        int a[] = {1, 1, 0, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()) == It(a + 3));
-    }
-    {
-        int a[] = {1, 1, 1, 0};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()) == It(a + sa));
-    }
-    {
-        int a[] = {1, 1, 1, 1};
-        unsigned sa = sizeof(a) / sizeof(a[0]);
-        CHECK(Fun{}(a, a + sa, std::greater<int>()) == It(a + sa));
-    }
-}
-
-struct A
-{
-    int a;
-};
-
-int main()
-{
-    test<ForwardIterator<const int *>, iter_call>();
-    test<BidirectionalIterator<const int *>, iter_call>();
-    test<RandomAccessIterator<const int *>, iter_call>();
-    test<const int *, iter_call>();
-
-    test<ForwardIterator<const int *>, range_call>();
-    test<BidirectionalIterator<const int *>, range_call>();
-    test<RandomAccessIterator<const int *>, range_call>();
-    test<const int *, range_call>();
-
-    /// Initializer list test:
-    {
-        std::initializer_list<int> r = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
-        CHECK(ranges::is_sorted_until(r) == ranges::end(r));
-    }
-
-    /// Projection test:
-    {
-        A as[] = {{0}, {1}, {2}, {3}, {4}};
-        CHECK(ranges::is_sorted_until(as, std::less<int>{}, &A::a) == ranges::end(as));
-        CHECK(ranges::is_sorted_until(as, std::greater<int>{}, &A::a) ==
-              ranges::next(ranges::begin(as), 1));
-    }
-
-    /// Rvalue range test:
-    {
-        A as[] = {{0}, {1}, {2}, {3}, {4}};
-#ifndef RANGES_WORKAROUND_MSVC_573728
-        CHECK(::is_dangling(
-            ranges::is_sorted_until(std::move(as), std::less<int>{}, &A::a)));
-        CHECK(::is_dangling(
-            ranges::is_sorted_until(std::move(as), std::greater<int>{}, &A::a)));
-#endif // RANGES_WORKAROUND_MSVC_573728
-        std::vector<A> vec(ranges::begin(as), ranges::end(as));
-        CHECK(::is_dangling(
-            ranges::is_sorted_until(std::move(vec), std::less<int>{}, &A::a)));
-        CHECK(::is_dangling(
-            ranges::is_sorted_until(std::move(vec), std::greater<int>{}, &A::a)));
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/lexicographical_compare.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/lexicographical_compare.cpp
deleted file mode 100644
index 4800e41e..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/lexicographical_compare.cpp
+++ /dev/null
@@ -1,176 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/lexicographical_compare.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-template<class Iter1, class Iter2, class Sent1 = Iter1, class Sent2 = Iter2>
-void
-test_iter1()
-{
-    int ia[] = {1, 2, 3, 4};
-    constexpr auto sa = ranges::size(ia);
-    int ib[] = {1, 2, 3};
-    CHECK(!ranges::lexicographical_compare(Iter1(ia), Sent1(ia+sa), Iter2(ib), Sent2(ib+2)));
-    CHECK(ranges::lexicographical_compare(Iter1(ib), Sent1(ib+2), Iter2(ia), Sent2(ia+sa)));
-    CHECK(!ranges::lexicographical_compare(Iter1(ia), Sent1(ia+sa), Iter2(ib), Sent2(ib+3)));
-    CHECK(ranges::lexicographical_compare(Iter1(ib), Sent1(ib+3), Iter2(ia), Sent2(ia+sa)));
-    CHECK(ranges::lexicographical_compare(Iter1(ia), Sent1(ia+sa), Iter2(ib+1), Sent2(ib+3)));
-    CHECK(!ranges::lexicographical_compare(Iter1(ib+1), Sent1(ib+3), Iter2(ia), Sent2(ia+sa)));
-}
-
-void test_iter()
-{
-    typedef Sentinel<const int*> S;
-
-    test_iter1<InputIterator<const int*>, InputIterator<const int*> >();
-    test_iter1<InputIterator<const int*>, ForwardIterator<const int*> >();
-    test_iter1<InputIterator<const int*>, BidirectionalIterator<const int*> >();
-    test_iter1<InputIterator<const int*>, RandomAccessIterator<const int*> >();
-    test_iter1<InputIterator<const int*>, InputIterator<const int*>, S, S>();
-    test_iter1<InputIterator<const int*>, ForwardIterator<const int*>, S, S>();
-    test_iter1<InputIterator<const int*>, BidirectionalIterator<const int*>, S, S>();
-    test_iter1<InputIterator<const int*>, RandomAccessIterator<const int*>, S, S>();
-    test_iter1<InputIterator<const int*>, const int*>();
-
-    test_iter1<ForwardIterator<const int*>, InputIterator<const int*> >();
-    test_iter1<ForwardIterator<const int*>, ForwardIterator<const int*> >();
-    test_iter1<ForwardIterator<const int*>, BidirectionalIterator<const int*> >();
-    test_iter1<ForwardIterator<const int*>, RandomAccessIterator<const int*> >();
-    test_iter1<ForwardIterator<const int*>, InputIterator<const int*>, S, S>();
-    test_iter1<ForwardIterator<const int*>, ForwardIterator<const int*>, S, S>();
-    test_iter1<ForwardIterator<const int*>, BidirectionalIterator<const int*>, S, S>();
-    test_iter1<ForwardIterator<const int*>, RandomAccessIterator<const int*>, S, S>();
-    test_iter1<ForwardIterator<const int*>, const int*>();
-
-    test_iter1<BidirectionalIterator<const int*>, InputIterator<const int*> >();
-    test_iter1<BidirectionalIterator<const int*>, ForwardIterator<const int*> >();
-    test_iter1<BidirectionalIterator<const int*>, BidirectionalIterator<const int*> >();
-    test_iter1<BidirectionalIterator<const int*>, RandomAccessIterator<const int*> >();
-    test_iter1<BidirectionalIterator<const int*>, InputIterator<const int*>, S, S>();
-    test_iter1<BidirectionalIterator<const int*>, ForwardIterator<const int*>, S, S>();
-    test_iter1<BidirectionalIterator<const int*>, BidirectionalIterator<const int*>, S, S>();
-    test_iter1<BidirectionalIterator<const int*>, RandomAccessIterator<const int*>, S, S>();
-    test_iter1<BidirectionalIterator<const int*>, const int*>();
-
-    test_iter1<RandomAccessIterator<const int*>, InputIterator<const int*> >();
-    test_iter1<RandomAccessIterator<const int*>, ForwardIterator<const int*> >();
-    test_iter1<RandomAccessIterator<const int*>, BidirectionalIterator<const int*> >();
-    test_iter1<RandomAccessIterator<const int*>, RandomAccessIterator<const int*> >();
-    test_iter1<RandomAccessIterator<const int*>, InputIterator<const int*>, S, S>();
-    test_iter1<RandomAccessIterator<const int*>, ForwardIterator<const int*>, S, S>();
-    test_iter1<RandomAccessIterator<const int*>, BidirectionalIterator<const int*>, S, S>();
-    test_iter1<RandomAccessIterator<const int*>, RandomAccessIterator<const int*>, S, S>();
-    test_iter1<RandomAccessIterator<const int*>, const int*>();
-
-    test_iter1<const int*, InputIterator<const int*> >();
-    test_iter1<const int*, ForwardIterator<const int*> >();
-    test_iter1<const int*, BidirectionalIterator<const int*> >();
-    test_iter1<const int*, RandomAccessIterator<const int*> >();
-    test_iter1<const int*, InputIterator<const int*>, const int*, S>();
-    test_iter1<const int*, ForwardIterator<const int*>, const int*, S>();
-    test_iter1<const int*, BidirectionalIterator<const int*>, const int*, S>();
-    test_iter1<const int*, RandomAccessIterator<const int*>, const int*, S>();
-    test_iter1<const int*, const int*>();
-}
-
-template<class Iter1, class Iter2, class Sent1 = Iter1, class Sent2 = Iter2>
-void
-test_iter_comp1()
-{
-    int ia[] = {1, 2, 3, 4};
-    const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-    int ib[] = {1, 2, 3};
-    typedef std::greater<int> C;
-    C c;
-    CHECK(!ranges::lexicographical_compare(Iter1(ia), Sent1(ia+sa), Iter2(ib), Sent2(ib+2), c));
-    CHECK(ranges::lexicographical_compare(Iter1(ib), Sent1(ib+2), Iter2(ia), Sent2(ia+sa), c));
-    CHECK(!ranges::lexicographical_compare(Iter1(ia), Sent1(ia+sa), Iter2(ib), Sent2(ib+3), c));
-    CHECK(ranges::lexicographical_compare(Iter1(ib), Sent1(ib+3), Iter2(ia), Sent2(ia+sa), c));
-    CHECK(!ranges::lexicographical_compare(Iter1(ia), Sent1(ia+sa), Iter2(ib+1), Sent2(ib+3), c));
-    CHECK(ranges::lexicographical_compare(Iter1(ib+1), Sent1(ib+3), Iter2(ia), Sent2(ia+sa), c));
-}
-
-void test_iter_comp()
-{
-    typedef Sentinel<const int*> S;
-
-    test_iter_comp1<InputIterator<const int*>, InputIterator<const int*> >();
-    test_iter_comp1<InputIterator<const int*>, ForwardIterator<const int*> >();
-    test_iter_comp1<InputIterator<const int*>, BidirectionalIterator<const int*> >();
-    test_iter_comp1<InputIterator<const int*>, RandomAccessIterator<const int*> >();
-    test_iter_comp1<InputIterator<const int*>, InputIterator<const int*>, S, S>();
-    test_iter_comp1<InputIterator<const int*>, ForwardIterator<const int*>, S, S>();
-    test_iter_comp1<InputIterator<const int*>, BidirectionalIterator<const int*>, S, S>();
-    test_iter_comp1<InputIterator<const int*>, RandomAccessIterator<const int*>, S, S>();
-    test_iter_comp1<InputIterator<const int*>, const int*>();
-
-    test_iter_comp1<ForwardIterator<const int*>, InputIterator<const int*> >();
-    test_iter_comp1<ForwardIterator<const int*>, ForwardIterator<const int*> >();
-    test_iter_comp1<ForwardIterator<const int*>, BidirectionalIterator<const int*> >();
-    test_iter_comp1<ForwardIterator<const int*>, RandomAccessIterator<const int*> >();
-    test_iter_comp1<ForwardIterator<const int*>, InputIterator<const int*>, S, S>();
-    test_iter_comp1<ForwardIterator<const int*>, ForwardIterator<const int*>, S, S>();
-    test_iter_comp1<ForwardIterator<const int*>, BidirectionalIterator<const int*>, S, S>();
-    test_iter_comp1<ForwardIterator<const int*>, RandomAccessIterator<const int*>, S, S>();
-    test_iter_comp1<ForwardIterator<const int*>, const int*>();
-
-    test_iter_comp1<BidirectionalIterator<const int*>, InputIterator<const int*> >();
-    test_iter_comp1<BidirectionalIterator<const int*>, ForwardIterator<const int*> >();
-    test_iter_comp1<BidirectionalIterator<const int*>, BidirectionalIterator<const int*> >();
-    test_iter_comp1<BidirectionalIterator<const int*>, RandomAccessIterator<const int*> >();
-    test_iter_comp1<BidirectionalIterator<const int*>, InputIterator<const int*>, S, S>();
-    test_iter_comp1<BidirectionalIterator<const int*>, ForwardIterator<const int*>, S, S>();
-    test_iter_comp1<BidirectionalIterator<const int*>, BidirectionalIterator<const int*>, S, S>();
-    test_iter_comp1<BidirectionalIterator<const int*>, RandomAccessIterator<const int*>, S, S>();
-    test_iter_comp1<BidirectionalIterator<const int*>, const int*>();
-
-    test_iter_comp1<RandomAccessIterator<const int*>, InputIterator<const int*> >();
-    test_iter_comp1<RandomAccessIterator<const int*>, ForwardIterator<const int*> >();
-    test_iter_comp1<RandomAccessIterator<const int*>, BidirectionalIterator<const int*> >();
-    test_iter_comp1<RandomAccessIterator<const int*>, RandomAccessIterator<const int*> >();
-    test_iter_comp1<RandomAccessIterator<const int*>, InputIterator<const int*>, S, S>();
-    test_iter_comp1<RandomAccessIterator<const int*>, ForwardIterator<const int*>, S, S>();
-    test_iter_comp1<RandomAccessIterator<const int*>, BidirectionalIterator<const int*>, S, S>();
-    test_iter_comp1<RandomAccessIterator<const int*>, RandomAccessIterator<const int*>, S, S>();
-    test_iter_comp1<RandomAccessIterator<const int*>, const int*>();
-
-    test_iter_comp1<const int*, InputIterator<const int*> >();
-    test_iter_comp1<const int*, ForwardIterator<const int*> >();
-    test_iter_comp1<const int*, BidirectionalIterator<const int*> >();
-    test_iter_comp1<const int*, RandomAccessIterator<const int*> >();
-    test_iter_comp1<const int*, InputIterator<const int*>, const int*, S>();
-    test_iter_comp1<const int*, ForwardIterator<const int*>, const int*, S>();
-    test_iter_comp1<const int*, BidirectionalIterator<const int*>, const int*, S>();
-    test_iter_comp1<const int*, RandomAccessIterator<const int*>, const int*, S>();
-    test_iter_comp1<const int*, const int*>();
-}
-
-
-int main()
-{
-    test_iter();
-    test_iter_comp();
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/lower_bound.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/lower_bound.cpp
deleted file mode 100644
index dcfe7ff7..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/lower_bound.cpp
+++ /dev/null
@@ -1,83 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-#include <utility>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/lower_bound.hpp>
-#include "../simple_test.hpp"
-#include "../test_iterators.hpp"
-
-struct my_int
-{
-    int value;
-};
-
-bool compare(my_int lhs, my_int rhs)
-{
-    return lhs.value < rhs.value;
-}
-
-void not_totally_ordered()
-{
-    // This better compile!
-    std::vector<my_int> vec;
-    ranges::lower_bound(vec, my_int{10}, compare);
-}
-
-int main()
-{
-    using ranges::begin;
-    using ranges::end;
-    using ranges::size;
-    using ranges::less;
-
-    std::pair<int, int> a[] = {{0, 0}, {0, 1}, {1, 2}, {1, 3}, {3, 4}, {3, 5}};
-    const std::pair<int, int> c[] = {{0, 0}, {0, 1}, {1, 2}, {1, 3}, {3, 4}, {3, 5}};
-
-    CHECK(ranges::aux::lower_bound_n(begin(a), size(a), a[0]) == &a[0]);
-    CHECK(ranges::aux::lower_bound_n(begin(a), size(a), a[1], less()) == &a[1]);
-    CHECK(ranges::aux::lower_bound_n(begin(a), size(a), 1, less(), &std::pair<int, int>::first) == &a[2]);
-
-    CHECK(ranges::lower_bound(begin(a), end(a), a[0]) == &a[0]);
-    CHECK(ranges::lower_bound(begin(a), end(a), a[1], less()) == &a[1]);
-    CHECK(ranges::lower_bound(begin(a), end(a), 1, less(), &std::pair<int, int>::first) == &a[2]);
-
-    CHECK(ranges::lower_bound(a, a[2]) == &a[2]);
-    CHECK(ranges::lower_bound(c, c[3]) == &c[3]);
-
-    CHECK(ranges::lower_bound(a, a[4], less()) == &a[4]);
-    CHECK(ranges::lower_bound(c, c[5], less()) == &c[5]);
-
-    CHECK(ranges::lower_bound(a, 1, less(), &std::pair<int, int>::first) == &a[2]);
-    CHECK(ranges::lower_bound(c, 1, less(), &std::pair<int, int>::first) == &c[2]);
-
-    CHECK(ranges::lower_bound(ranges::views::all(a), 1, less(), &std::pair<int, int>::first) == &a[2]);
-    CHECK(ranges::lower_bound(ranges::views::all(c), 1, less(), &std::pair<int, int>::first) == &c[2]);
-#ifndef RANGES_WORKAROUND_MSVC_573728
-    CHECK(::is_dangling(ranges::lower_bound(std::move(a), 1, less(), &std::pair<int, int>::first)));
-    CHECK(::is_dangling(ranges::lower_bound(std::move(c), 1, less(), &std::pair<int, int>::first)));
-#endif // RANGES_WORKAROUND_MSVC_573728
-    {
-        std::vector<std::pair<int, int>> vec_a(ranges::begin(a), ranges::end(a));
-        CHECK(::is_dangling(ranges::lower_bound(std::move(vec_a), 1, less(), &std::pair<int, int>::first)));
-    }
-    {
-        std::vector<std::pair<int, int>> const vec_c(ranges::begin(c), ranges::end(c));
-        CHECK(::is_dangling(ranges::lower_bound(std::move(vec_c), 1, less(), &std::pair<int, int>::first)));
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/make_heap.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/make_heap.cpp
deleted file mode 100644
index 2a874c17..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/make_heap.cpp
+++ /dev/null
@@ -1,212 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <memory>
-#include <random>
-#include <algorithm>
-#include <functional>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/heap_algorithm.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS
-RANGES_DIAGNOSTIC_IGNORE_SIGN_CONVERSION
-
-namespace
-{
-    std::mt19937 gen;
-
-    void test_1(int N)
-    {
-        int* ia = new int [N];
-        for (int i = 0; i < N; ++i)
-            ia[i] = i;
-        std::shuffle(ia, ia+N, gen);
-        CHECK(ranges::make_heap(ia, ia+N) == ia+N);
-        CHECK(std::is_heap(ia, ia+N));
-        delete [] ia;
-    }
-
-    void test_2(int N)
-    {
-        int* ia = new int [N];
-        for (int i = 0; i < N; ++i)
-            ia[i] = i;
-        std::shuffle(ia, ia+N, gen);
-        CHECK(ranges::make_heap(ia, Sentinel<int*>(ia+N)) == ia+N);
-        CHECK(std::is_heap(ia, ia+N));
-        delete [] ia;
-    }
-
-    void test_3(int N)
-    {
-        int* ia = new int [N];
-        for (int i = 0; i < N; ++i)
-            ia[i] = i;
-        std::shuffle(ia, ia+N, gen);
-        CHECK(ranges::make_heap(ranges::make_subrange(ia, ia+N)) == ia+N);
-        CHECK(std::is_heap(ia, ia+N));
-
-        std::shuffle(ia, ia+N, gen);
-        CHECK(::is_dangling(ranges::make_heap(::MakeTestRange(ia, ia+N))));
-        CHECK(std::is_heap(ia, ia+N));
-
-        delete [] ia;
-    }
-
-    void test_4(int N)
-    {
-        int* ia = new int [N];
-        for (int i = 0; i < N; ++i)
-            ia[i] = i;
-        std::shuffle(ia, ia+N, gen);
-        CHECK(ranges::make_heap(ranges::make_subrange(ia, Sentinel<int*>(ia+N))) == ia+N);
-        CHECK(std::is_heap(ia, ia+N));
-
-        std::shuffle(ia, ia+N, gen);
-        CHECK(::is_dangling(ranges::make_heap(::MakeTestRange(ia, Sentinel<int*>(ia+N)))));
-        CHECK(std::is_heap(ia, ia+N));
-
-        delete [] ia;
-    }
-
-    void test_5(int N)
-    {
-        int* ia = new int [N];
-        for (int i = 0; i < N; ++i)
-            ia[i] = i;
-        std::shuffle(ia, ia+N, gen);
-        CHECK(ranges::make_heap(ia, ia+N, std::greater<int>()) == ia+N);
-        CHECK(std::is_heap(ia, ia+N, std::greater<int>()));
-        delete [] ia;
-    }
-
-    void test_6(int N)
-    {
-        int* ia = new int [N];
-        for (int i = 0; i < N; ++i)
-            ia[i] = i;
-        std::shuffle(ia, ia+N, gen);
-        CHECK(ranges::make_heap(ia, Sentinel<int*>(ia+N), std::greater<int>()) == ia+N);
-        CHECK(std::is_heap(ia, ia+N, std::greater<int>()));
-        delete [] ia;
-    }
-
-    void test_7(int N)
-    {
-        int* ia = new int [N];
-        for (int i = 0; i < N; ++i)
-            ia[i] = i;
-        std::shuffle(ia, ia+N, gen);
-        CHECK(ranges::make_heap(ranges::make_subrange(ia, ia+N), std::greater<int>()) == ia+N);
-        CHECK(std::is_heap(ia, ia+N, std::greater<int>()));
-
-        std::shuffle(ia, ia+N, gen);
-        CHECK(::is_dangling(ranges::make_heap(::MakeTestRange(ia, ia+N), std::greater<int>())));
-        CHECK(std::is_heap(ia, ia+N, std::greater<int>()));
-
-        delete [] ia;
-    }
-
-    void test_8(int N)
-    {
-        int* ia = new int [N];
-        for (int i = 0; i < N; ++i)
-            ia[i] = i;
-        std::shuffle(ia, ia+N, gen);
-        CHECK(ranges::make_heap(ranges::make_subrange(ia, Sentinel<int*>(ia+N)), std::greater<int>()) == ia+N);
-        CHECK(std::is_heap(ia, ia+N, std::greater<int>()));
-
-        std::shuffle(ia, ia+N, gen);
-        CHECK(::is_dangling(ranges::make_heap(::MakeTestRange(ia, Sentinel<int*>(ia+N)), std::greater<int>())));
-        CHECK(std::is_heap(ia, ia+N, std::greater<int>()));
-
-        delete [] ia;
-    }
-
-    struct indirect_less
-    {
-        template<class P>
-        bool operator()(const P& x, const P& y)
-            {return *x < *y;}
-    };
-
-    void test_9(int N)
-    {
-        std::unique_ptr<int>* ia = new std::unique_ptr<int> [N];
-        for (int i = 0; i < N; ++i)
-            ia[i].reset(new int(i));
-        std::shuffle(ia, ia+N, gen);
-        CHECK(ranges::make_heap(ia, ia+N, indirect_less()) == ia+N);
-        CHECK(std::is_heap(ia, ia+N, indirect_less()));
-        delete [] ia;
-    }
-
-    struct S
-    {
-        int i;
-    };
-
-    void test_10(int N)
-    {
-        int* ia = new int [N];
-        S* ib = new S [N];
-        for (int i = 0; i < N; ++i)
-            ib[i].i = i;
-        std::shuffle(ia, ia+N, gen);
-        CHECK(ranges::make_heap(ib, ib+N, std::less<int>(), &S::i) == ib+N);
-        std::transform(ib, ib+N, ia, std::mem_fn(&S::i));
-        CHECK(std::is_heap(ia, ia+N));
-        delete [] ia;
-        delete [] ib;
-    }
-
-    void test(int N)
-    {
-        test_1(N);
-        test_2(N);
-        test_3(N);
-        test_4(N);
-        test_5(N);
-        test_6(N);
-        test_7(N);
-        test_8(N);
-    }
-}
-
-int main()
-{
-    test(0);
-    test(1);
-    test(2);
-    test(3);
-    test(10);
-    test(1000);
-    test_9(1000);
-    test_10(1000);
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/max.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/max.cpp
deleted file mode 100644
index 5f0f6f71..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/max.cpp
+++ /dev/null
@@ -1,142 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Casey Carter 2015
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <range/v3/algorithm/max.hpp>
-#include <range/v3/view/subrange.hpp>
-#include <memory>
-#include <numeric>
-#include <random>
-#include <algorithm>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS
-
-namespace
-{
-    std::mt19937 gen;
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter(Iter first, Sent last)
-    {
-        RANGES_ENSURE(first != last);
-        auto rng = ranges::make_subrange(first, last);
-        auto v = ranges::max(rng);
-        for (Iter i = first; i != last; ++i)
-            CHECK(!(v < *i));
-    }
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter(unsigned N)
-    {
-        RANGES_ENSURE(N > 0);
-        std::unique_ptr<int[]> a{new int[N]};
-        std::iota(a.get(), a.get()+N, 0);
-        std::shuffle(a.get(), a.get()+N, gen);
-        test_iter(Iter(a.get()), Sent(a.get()+N));
-    }
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter()
-    {
-        test_iter<Iter, Sent>(1);
-        test_iter<Iter, Sent>(2);
-        test_iter<Iter, Sent>(3);
-        test_iter<Iter, Sent>(10);
-        test_iter<Iter, Sent>(1000);
-    }
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter_comp(Iter first, Sent last)
-    {
-        RANGES_ENSURE(first != last);
-        auto rng = ranges::make_subrange(first, last);
-        auto comp = std::greater<int>();
-        auto v = ranges::max(rng, comp);
-        for (Iter i = first; i != last; ++i)
-            CHECK(!comp(v, *i));
-    }
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter_comp(unsigned N)
-    {
-        RANGES_ENSURE(N > 0);
-        std::unique_ptr<int[]> a{new int[N]};
-        std::iota(a.get(), a.get()+N, 0);
-        std::shuffle(a.get(), a.get()+N, gen);
-        test_iter_comp(Iter(a.get()), Sent(a.get()+N));
-    }
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter_comp()
-    {
-        test_iter_comp<Iter, Sent>(1);
-        test_iter_comp<Iter, Sent>(2);
-        test_iter_comp<Iter, Sent>(3);
-        test_iter_comp<Iter, Sent>(10);
-        test_iter_comp<Iter, Sent>(1000);
-    }
-
-    struct S
-    {
-        int i;
-    };
-}
-
-int main()
-{
-    test_iter<InputIterator<const int*> >();
-    test_iter<ForwardIterator<const int*> >();
-    test_iter<BidirectionalIterator<const int*> >();
-    test_iter<RandomAccessIterator<const int*> >();
-    test_iter<const int*>();
-    test_iter<InputIterator<const int*>, Sentinel<const int*>>();
-    test_iter<ForwardIterator<const int*>, Sentinel<const int*>>();
-    test_iter<BidirectionalIterator<const int*>, Sentinel<const int*>>();
-    test_iter<RandomAccessIterator<const int*>, Sentinel<const int*>>();
-
-    test_iter_comp<InputIterator<const int*> >();
-    test_iter_comp<ForwardIterator<const int*> >();
-    test_iter_comp<BidirectionalIterator<const int*> >();
-    test_iter_comp<RandomAccessIterator<const int*> >();
-    test_iter_comp<const int*>();
-    test_iter_comp<InputIterator<const int*>, Sentinel<const int*>>();
-    test_iter_comp<ForwardIterator<const int*>, Sentinel<const int*>>();
-    test_iter_comp<BidirectionalIterator<const int*>, Sentinel<const int*>>();
-    test_iter_comp<RandomAccessIterator<const int*>, Sentinel<const int*>>();
-
-    // Works with projections?
-    S s[] = {S{1},S{2},S{3},S{4},S{40},S{5},S{6},S{7},S{8},S{9}};
-    S v = ranges::max(s, std::less<int>{}, &S::i);
-    CHECK(v.i == 40);
-
-    // Works with initializer_lists? (Regression test for #1004)
-    CHECK(ranges::max({4,3,1,2,6,5}) == 6);
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/max_element.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/max_element.cpp
deleted file mode 100644
index a1a2b37a..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/max_element.cpp
+++ /dev/null
@@ -1,165 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <memory>
-#include <numeric>
-#include <random>
-#include <algorithm>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/max_element.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS
-
-namespace
-{
-    std::mt19937 gen;
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter(Iter first, Sent last)
-    {
-        Iter i = ranges::max_element(first, last);
-        if (first != last)
-        {
-            for (Iter j = first; j != last; ++j)
-                CHECK(!(*i < *j));
-        }
-        else
-            CHECK(i == last);
-
-        auto rng = ::MakeTestRange(first, last);
-        i = ranges::max_element(rng);
-        if (first != last)
-        {
-            for (Iter j = first; j != last; ++j)
-                CHECK(!(*i < *j));
-        }
-        else
-            CHECK(i == last);
-
-        auto j = ranges::max_element(std::move(rng));
-        CHECK(::is_dangling(j));
-    }
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter(unsigned N)
-    {
-        std::unique_ptr<int[]> a{new int[N]};
-        std::iota(a.get(), a.get()+N, 0);
-        std::shuffle(a.get(), a.get()+N, gen);
-        test_iter(Iter(a.get()), Sent(a.get()+N));
-    }
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter()
-    {
-        test_iter<Iter, Sent>(0);
-        test_iter<Iter, Sent>(1);
-        test_iter<Iter, Sent>(2);
-        test_iter<Iter, Sent>(3);
-        test_iter<Iter, Sent>(10);
-        test_iter<Iter, Sent>(1000);
-    }
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter_comp(Iter first, Sent last)
-    {
-        Iter i = ranges::max_element(first, last, std::greater<int>());
-        if (first != last)
-        {
-            for (Iter j = first; j != last; ++j)
-                CHECK(!std::greater<int>()(*i, *j));
-        }
-        else
-            CHECK(i == last);
-
-        auto rng = ::MakeTestRange(first, last);
-        i = ranges::max_element(rng, std::greater<int>());
-        if (first != last)
-        {
-            for (Iter j = first; j != last; ++j)
-                CHECK(!std::greater<int>()(*i, *j));
-        }
-        else
-            CHECK(i == last);
-
-        auto res = ranges::max_element(std::move(rng), std::greater<int>());
-        CHECK(::is_dangling(res));
-    }
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter_comp(unsigned N)
-    {
-        std::unique_ptr<int[]> a{new int[N]};
-        std::iota(a.get(), a.get()+N, 0);
-        std::shuffle(a.get(), a.get()+N, gen);
-        test_iter_comp(Iter(a.get()), Sent(a.get()+N));
-    }
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter_comp()
-    {
-        test_iter_comp<Iter, Sent>(0);
-        test_iter_comp<Iter, Sent>(1);
-        test_iter_comp<Iter, Sent>(2);
-        test_iter_comp<Iter, Sent>(3);
-        test_iter_comp<Iter, Sent>(10);
-        test_iter_comp<Iter, Sent>(1000);
-    }
-
-    struct S
-    {
-        int i;
-    };
-}
-
-int main()
-{
-    test_iter<ForwardIterator<const int*> >();
-    test_iter<BidirectionalIterator<const int*> >();
-    test_iter<RandomAccessIterator<const int*> >();
-    test_iter<const int*>();
-    test_iter<ForwardIterator<const int*>, Sentinel<const int*>>();
-    test_iter<BidirectionalIterator<const int*>, Sentinel<const int*>>();
-    test_iter<RandomAccessIterator<const int*>, Sentinel<const int*>>();
-
-    test_iter_comp<ForwardIterator<const int*> >();
-    test_iter_comp<BidirectionalIterator<const int*> >();
-    test_iter_comp<RandomAccessIterator<const int*> >();
-    test_iter_comp<const int*>();
-    test_iter_comp<ForwardIterator<const int*>, Sentinel<const int*>>();
-    test_iter_comp<BidirectionalIterator<const int*>, Sentinel<const int*>>();
-    test_iter_comp<RandomAccessIterator<const int*>, Sentinel<const int*>>();
-
-    // Works with projections?
-    S s[] = {S{1},S{2},S{3},S{4},S{40},S{5},S{6},S{7},S{8},S{9}};
-    S const *ps = ranges::max_element(s, std::less<int>{}, &S::i);
-    CHECK(ps->i == 40);
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/merge.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/merge.cpp
deleted file mode 100644
index d56e6664..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/merge.cpp
+++ /dev/null
@@ -1,92 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-#include <memory>
-#include <utility>
-#include <algorithm>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/merge.hpp>
-#include "../simple_test.hpp"
-#include "../test_iterators.hpp"
-
-RANGES_DIAGNOSTIC_IGNORE_SIGN_CONVERSION
-
-int main()
-{
-    {
-        int N = 100000;
-        std::unique_ptr<int[]> ia{new int[N]};
-        std::unique_ptr<int[]> ib{new int[N]};
-        std::unique_ptr<int[]> ic{new int[2 * N]};
-        for(int i = 0; i < N; ++i)
-            ia[i] = 2 * i;
-        for(int i = 0; i < N; ++i)
-            ib[i] = 2 * i + 1;
-        auto r = ranges::merge(ia.get(), ia.get() + N,
-            ib.get(), ib.get() + N, ic.get());
-        CHECK(r.in1 == ia.get() + N);
-        CHECK(r.in2 == ib.get() + N);
-        CHECK(r.out == ic.get() + 2 * N);
-        CHECK(ic[0] == 0);
-        CHECK(ic[2 * N - 1] == 2 * N - 1);
-        CHECK(std::is_sorted(ic.get(), ic.get() + 2 * N));
-    }
-
-    {
-        int N = 100000;
-        std::unique_ptr<int[]> ia{new int[N]};
-        std::unique_ptr<int[]> ib{new int[N]};
-        std::unique_ptr<int[]> ic{new int[2 * N]};
-        for(int i = 0; i < N; ++i)
-            ia[i] = 2 * i;
-        for(int i = 0; i < N; ++i)
-            ib[i] = 2 * i + 1;
-        auto r0 = ranges::make_subrange(ia.get(), ia.get() + N);
-        auto r1 = ranges::make_subrange(ib.get(), ib.get() + N);
-        auto r = ranges::merge(r0, r1, ic.get());
-        CHECK(r.in1 == ia.get() + N);
-        CHECK(r.in2 == ib.get() + N);
-        CHECK(r.out == ic.get() + 2 * N);
-        CHECK(ic[0] == 0);
-        CHECK(ic[2 * N - 1] == 2 * N - 1);
-        CHECK(std::is_sorted(ic.get(), ic.get() + 2 * N));
-    }
-
-
-    {
-        int N = 100000;
-        std::unique_ptr<int[]> ia{new int[N]};
-        std::unique_ptr<int[]> ib{new int[N]};
-        std::unique_ptr<int[]> ic{new int[2 * N]};
-        for(int i = 0; i < N; ++i)
-            ia[i] = 2 * i;
-        for(int i = 0; i < N; ++i)
-            ib[i] = 2 * i + 1;
-        auto r0 = ::MakeTestRange(ia.get(), ia.get() + N);
-        auto r1 = ::MakeTestRange(ib.get(), ib.get() + N);
-        auto r = ranges::merge(std::move(r0), std::move(r1), ic.get());
-        CHECK(::is_dangling(r.in1));
-        CHECK(::is_dangling(r.in2));
-        CHECK(r.out == ic.get() + 2 * N);
-        CHECK(ic[0] == 0);
-        CHECK(ic[2 * N - 1] == 2 * N - 1);
-        CHECK(std::is_sorted(ic.get(), ic.get() + 2 * N));
-
-        static_assert(std::is_same<decltype(r),
-            ranges::merge_result<ranges::dangling, ranges::dangling, int *>>::value, "");
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/min.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/min.cpp
deleted file mode 100644
index c5480248..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/min.cpp
+++ /dev/null
@@ -1,141 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Casey Carter 2015
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <range/v3/algorithm/min.hpp>
-#include <range/v3/view/subrange.hpp>
-#include <memory>
-#include <random>
-#include <numeric>
-#include <algorithm>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS
-
-namespace
-{
-    std::mt19937 gen;
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter(Iter first, Sent last)
-    {
-        RANGES_ENSURE(first != last);
-        auto rng = ranges::make_subrange(first, last);
-        auto v1 = ranges::min(rng);
-        for (Iter i = first; i != last; ++i)
-            CHECK(!(*i < v1));
-    }
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter(unsigned N)
-    {
-        RANGES_ENSURE(N > 0);
-        std::unique_ptr<int[]> a{new int[N]};
-        std::iota(a.get(), a.get()+N, 0);
-        std::shuffle(a.get(), a.get()+N, gen);
-        test_iter(Iter(a.get()), Sent(a.get()+N));
-    }
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter()
-    {
-        test_iter<Iter, Sent>(1);
-        test_iter<Iter, Sent>(2);
-        test_iter<Iter, Sent>(3);
-        test_iter<Iter, Sent>(10);
-        test_iter<Iter, Sent>(1000);
-    }
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter_comp(Iter first, Sent last)
-    {
-        RANGES_ENSURE(first != last);
-        auto rng = ranges::make_subrange(first, last);
-        auto v = ranges::min(rng, std::greater<int>());
-        for (Iter i = first; i != last; ++i)
-            CHECK(!std::greater<int>()(*i, v));
-    }
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter_comp(unsigned N)
-    {
-        RANGES_ENSURE(N > 0);
-        std::unique_ptr<int[]> a{new int[N]};
-        std::iota(a.get(), a.get()+N, 0);
-        std::shuffle(a.get(), a.get()+N, gen);
-        test_iter_comp(Iter(a.get()), Sent(a.get()+N));
-    }
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter_comp()
-    {
-        test_iter_comp<Iter, Sent>(1);
-        test_iter_comp<Iter, Sent>(2);
-        test_iter_comp<Iter, Sent>(3);
-        test_iter_comp<Iter, Sent>(10);
-        test_iter_comp<Iter, Sent>(1000);
-    }
-
-    struct S
-    {
-        int i;
-    };
-}
-
-int main()
-{
-    test_iter<InputIterator<const int*> >();
-    test_iter<ForwardIterator<const int*> >();
-    test_iter<BidirectionalIterator<const int*> >();
-    test_iter<RandomAccessIterator<const int*> >();
-    test_iter<const int*>();
-    test_iter<InputIterator<const int*>, Sentinel<const int*>>();
-    test_iter<ForwardIterator<const int*>, Sentinel<const int*>>();
-    test_iter<BidirectionalIterator<const int*>, Sentinel<const int*>>();
-    test_iter<RandomAccessIterator<const int*>, Sentinel<const int*>>();
-
-    test_iter_comp<InputIterator<const int*> >();
-    test_iter_comp<ForwardIterator<const int*> >();
-    test_iter_comp<BidirectionalIterator<const int*> >();
-    test_iter_comp<RandomAccessIterator<const int*> >();
-    test_iter_comp<const int*>();
-    test_iter_comp<InputIterator<const int*>, Sentinel<const int*>>();
-    test_iter_comp<ForwardIterator<const int*>, Sentinel<const int*>>();
-    test_iter_comp<BidirectionalIterator<const int*>, Sentinel<const int*>>();
-    test_iter_comp<RandomAccessIterator<const int*>, Sentinel<const int*>>();
-
-    // Works with projections?
-    S s[] = {S{1},S{2},S{3},S{4},S{-4},S{5},S{6},S{7},S{8},S{9}};
-    S v = ranges::min(s, std::less<int>{}, &S::i);
-    CHECK(v.i == -4);
-
-    // Works with initializer_lists? (Regression test for #1004)
-    CHECK(ranges::min({4,3,1,2,6,5}) == 1);
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/min_element.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/min_element.cpp
deleted file mode 100644
index 31eb950b..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/min_element.cpp
+++ /dev/null
@@ -1,165 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <memory>
-#include <random>
-#include <numeric>
-#include <algorithm>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/min_element.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS
-
-namespace
-{
-    std::mt19937 gen;
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter(Iter first, Sent last)
-    {
-        Iter i = ranges::min_element(first, last);
-        if (first != last)
-        {
-            for (Iter j = first; j != last; ++j)
-                CHECK(!(*j < *i));
-        }
-        else
-            CHECK(i == last);
-
-        auto rng = ::MakeTestRange(first, last);
-        i = ranges::min_element(rng);
-        if (first != last)
-        {
-            for (Iter j = first; j != last; ++j)
-                CHECK(!(*j < *i));
-        }
-        else
-            CHECK(i == last);
-
-        auto res = ranges::min_element(std::move(rng));
-        CHECK(::is_dangling(res));
-    }
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter(unsigned N)
-    {
-        std::unique_ptr<int[]> a{new int[N]};
-        std::iota(a.get(), a.get()+N, 0);
-        std::shuffle(a.get(), a.get()+N, gen);
-        test_iter(Iter(a.get()), Sent(a.get()+N));
-    }
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter()
-    {
-        test_iter<Iter, Sent>(0);
-        test_iter<Iter, Sent>(1);
-        test_iter<Iter, Sent>(2);
-        test_iter<Iter, Sent>(3);
-        test_iter<Iter, Sent>(10);
-        test_iter<Iter, Sent>(1000);
-    }
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter_comp(Iter first, Sent last)
-    {
-        Iter i = ranges::min_element(first, last, std::greater<int>());
-        if (first != last)
-        {
-            for (Iter j = first; j != last; ++j)
-                CHECK(!std::greater<int>()(*j, *i));
-        }
-        else
-            CHECK(i == last);
-
-        auto rng = ::MakeTestRange(first, last);
-        i = ranges::min_element(rng, std::greater<int>());
-        if (first != last)
-        {
-            for (Iter j = first; j != last; ++j)
-                CHECK(!std::greater<int>()(*j, *i));
-        }
-        else
-            CHECK(i == last);
-
-        auto res = ranges::min_element(std::move(rng), std::greater<int>());
-        CHECK(::is_dangling(res));
-    }
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter_comp(unsigned N)
-    {
-        std::unique_ptr<int[]> a{new int[N]};
-        std::iota(a.get(), a.get()+N, 0);
-        std::shuffle(a.get(), a.get()+N, gen);
-        test_iter_comp(Iter(a.get()), Sent(a.get()+N));
-    }
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter_comp()
-    {
-        test_iter_comp<Iter, Sent>(0);
-        test_iter_comp<Iter, Sent>(1);
-        test_iter_comp<Iter, Sent>(2);
-        test_iter_comp<Iter, Sent>(3);
-        test_iter_comp<Iter, Sent>(10);
-        test_iter_comp<Iter, Sent>(1000);
-    }
-
-    struct S
-    {
-        int i;
-    };
-}
-
-int main()
-{
-    test_iter<ForwardIterator<const int*> >();
-    test_iter<BidirectionalIterator<const int*> >();
-    test_iter<RandomAccessIterator<const int*> >();
-    test_iter<const int*>();
-    test_iter<ForwardIterator<const int*>, Sentinel<const int*>>();
-    test_iter<BidirectionalIterator<const int*>, Sentinel<const int*>>();
-    test_iter<RandomAccessIterator<const int*>, Sentinel<const int*>>();
-
-    test_iter_comp<ForwardIterator<const int*> >();
-    test_iter_comp<BidirectionalIterator<const int*> >();
-    test_iter_comp<RandomAccessIterator<const int*> >();
-    test_iter_comp<const int*>();
-    test_iter_comp<ForwardIterator<const int*>, Sentinel<const int*>>();
-    test_iter_comp<BidirectionalIterator<const int*>, Sentinel<const int*>>();
-    test_iter_comp<RandomAccessIterator<const int*>, Sentinel<const int*>>();
-
-    // Works with projections?
-    S s[] = {S{1},S{2},S{3},S{4},S{-4},S{5},S{6},S{7},S{8},S{9}};
-    S const *ps = ranges::min_element(s, std::less<int>{}, &S::i);
-    CHECK(ps->i == -4);
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/minmax.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/minmax.cpp
deleted file mode 100644
index 4c2d2ae7..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/minmax.cpp
+++ /dev/null
@@ -1,171 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Casey Carter 2015
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <range/v3/algorithm/minmax.hpp>
-#include <range/v3/view/subrange.hpp>
-#include <memory>
-#include <numeric>
-#include <random>
-#include <algorithm>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS
-
-namespace
-{
-    std::mt19937 gen;
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter(Iter first, Sent last)
-    {
-        RANGES_ENSURE(first != last);
-        auto rng = ranges::make_subrange(first, last);
-        auto res = ranges::minmax(rng);
-        for (Iter i = first; i != last; ++i) {
-            CHECK(!(*i < res.min));
-            CHECK(!(res.max < *i));
-        }
-    }
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter(unsigned N)
-    {
-        RANGES_ENSURE(N > 0);
-        std::unique_ptr<int[]> a{new int[N]};
-        std::iota(a.get(), a.get()+N, 0);
-        std::shuffle(a.get(), a.get()+N, gen);
-        test_iter(Iter(a.get()), Sent(a.get()+N));
-    }
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter()
-    {
-        test_iter<Iter, Sent>(1);
-        test_iter<Iter, Sent>(2);
-        test_iter<Iter, Sent>(3);
-        test_iter<Iter, Sent>(10);
-        test_iter<Iter, Sent>(1000);
-    }
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter_comp(Iter first, Sent last)
-    {
-        RANGES_ENSURE(first != last);
-        typedef std::greater<int> Compare;
-        Compare comp;
-        auto rng = ranges::make_subrange(first, last);
-        auto res = ranges::minmax(rng, comp);
-        for (Iter i = first; i != last; ++i) {
-            CHECK(!comp(*i, res.min));
-            CHECK(!comp(res.max, *i));
-        }
-    }
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter_comp(unsigned N)
-    {
-        RANGES_ENSURE(N > 0);
-        std::unique_ptr<int[]> a{new int[N]};
-        std::iota(a.get(), a.get()+N, 0);
-        std::shuffle(a.get(), a.get()+N, gen);
-        test_iter_comp(Iter(a.get()), Sent(a.get()+N));
-    }
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter_comp()
-    {
-        test_iter_comp<Iter, Sent>(1);
-        test_iter_comp<Iter, Sent>(2);
-        test_iter_comp<Iter, Sent>(3);
-        test_iter_comp<Iter, Sent>(10);
-        test_iter_comp<Iter, Sent>(1000);
-    }
-
-    struct S
-    {
-        int value;
-        int index;
-    };
-}
-
-int main()
-{
-    test_iter<InputIterator<const int*> >();
-    test_iter<ForwardIterator<const int*> >();
-    test_iter<BidirectionalIterator<const int*> >();
-    test_iter<RandomAccessIterator<const int*> >();
-    test_iter<const int*>();
-    test_iter<InputIterator<const int*>, Sentinel<const int*>>();
-    test_iter<ForwardIterator<const int*>, Sentinel<const int*>>();
-    test_iter<BidirectionalIterator<const int*>, Sentinel<const int*>>();
-    test_iter<RandomAccessIterator<const int*>, Sentinel<const int*>>();
-
-    test_iter<InputIterator<const int*> >();
-    test_iter<ForwardIterator<const int*> >();
-    test_iter<BidirectionalIterator<const int*> >();
-    test_iter<RandomAccessIterator<const int*> >();
-    test_iter<const int*>();
-    test_iter<InputIterator<const int*>, Sentinel<const int*>>();
-    test_iter<ForwardIterator<const int*>, Sentinel<const int*>>();
-    test_iter<BidirectionalIterator<const int*>, Sentinel<const int*>>();
-    test_iter<RandomAccessIterator<const int*>, Sentinel<const int*>>();
-
-    test_iter_comp<InputIterator<const int*> >();
-    test_iter_comp<ForwardIterator<const int*> >();
-    test_iter_comp<BidirectionalIterator<const int*> >();
-    test_iter_comp<RandomAccessIterator<const int*> >();
-    test_iter_comp<const int*>();
-    test_iter_comp<InputIterator<const int*>, Sentinel<const int*>>();
-    test_iter_comp<ForwardIterator<const int*>, Sentinel<const int*>>();
-    test_iter_comp<BidirectionalIterator<const int*>, Sentinel<const int*>>();
-    test_iter_comp<RandomAccessIterator<const int*>, Sentinel<const int*>>();
-
-    test_iter_comp<InputIterator<const int*> >();
-    test_iter_comp<ForwardIterator<const int*> >();
-    test_iter_comp<BidirectionalIterator<const int*> >();
-    test_iter_comp<RandomAccessIterator<const int*> >();
-    test_iter_comp<const int*>();
-    test_iter_comp<InputIterator<const int*>, Sentinel<const int*>>();
-    test_iter_comp<ForwardIterator<const int*>, Sentinel<const int*>>();
-    test_iter_comp<BidirectionalIterator<const int*>, Sentinel<const int*>>();
-    test_iter_comp<RandomAccessIterator<const int*>, Sentinel<const int*>>();
-
-    // Works with projections?
-    S s[] = {S{1,0},S{2,1},S{3,2},S{4,3},S{-4,4},S{40,5},S{-4,6},S{40,7},S{7,8},S{8,9},S{9,10}};
-    auto res = ranges::minmax(s, std::less<int>{}, &S::value);
-    CHECK(res.min.value == -4);
-    CHECK(res.min.index == 4);
-    CHECK(res.max.value == 40);
-    CHECK(res.max.index == 7);
-
-    // Works with initializer_lists? (Regression test for #1004)
-    CHECK(ranges::minmax({4,3,1,2,6,5}) == ranges::minmax_result<int>{1,6});
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/minmax_element.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/minmax_element.cpp
deleted file mode 100644
index 5f8c47af..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/minmax_element.cpp
+++ /dev/null
@@ -1,241 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <memory>
-#include <numeric>
-#include <random>
-#include <algorithm>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/minmax_element.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS
-
-namespace
-{
-    std::mt19937 gen;
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter(Iter first, Sent last)
-    {
-        ranges::minmax_element_result<Iter> p = ranges::minmax_element(first, last);
-        if (first != last)
-        {
-            for (Iter j = first; j != last; ++j)
-            {
-                CHECK(!(*j < *p.min));
-                CHECK(!(*p.max < *j));
-            }
-        }
-        else
-        {
-            CHECK(p.min == last);
-            CHECK(p.max == last);
-        }
-
-        auto rng = ::MakeTestRange(first, last);
-        p = ranges::minmax_element(rng);
-        if (first != last)
-        {
-            for (Iter j = first; j != last; ++j)
-            {
-                CHECK(!(*j < *p.min));
-                CHECK(!(*p.max < *j));
-            }
-        }
-        else
-        {
-            CHECK(p.min == last);
-            CHECK(p.max == last);
-        }
-
-        auto res = ranges::minmax_element(std::move(rng));
-        if (first != last)
-        {
-            for (Iter j = first; j != last; ++j)
-            {
-                CHECK(is_dangling(res.min));
-                CHECK(!(*p.max < *j));
-            }
-        }
-        else
-        {
-            CHECK(is_dangling(res.min));
-            CHECK(is_dangling(res.max));
-        }
-    }
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter(unsigned N)
-    {
-        std::unique_ptr<int[]> a{new int[N]};
-        std::iota(a.get(), a.get()+N, 0);
-        std::shuffle(a.get(), a.get()+N, gen);
-        test_iter(Iter(a.get()), Sent(a.get()+N));
-    }
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter()
-    {
-        test_iter<Iter, Sent>(0);
-        test_iter<Iter, Sent>(1);
-        test_iter<Iter, Sent>(2);
-        test_iter<Iter, Sent>(3);
-        test_iter<Iter, Sent>(10);
-        test_iter<Iter, Sent>(1000);
-        {
-            const unsigned N = 100;
-            std::unique_ptr<int[]> a{new int[N]};
-            std::fill_n(a.get(), N, 5);
-            std::shuffle(a.get(), a.get()+N, gen);
-            ranges::minmax_element_result<Iter> p = ranges::minmax_element(Iter(a.get()), Sent(a.get()+N));
-            CHECK(base(p.min) == a.get());
-            CHECK(base(p.max) == a.get()+N-1);
-        }
-    }
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter_comp(Iter first, Sent last)
-    {
-        typedef std::greater<int> Compare;
-        Compare comp;
-        ranges::minmax_element_result<Iter> p = ranges::minmax_element(first, last, comp);
-        if (first != last)
-        {
-            for (Iter j = first; j != last; ++j)
-            {
-                CHECK(!comp(*j, *p.min));
-                CHECK(!comp(*p.max, *j));
-            }
-        }
-        else
-        {
-            CHECK(p.min == last);
-            CHECK(p.max == last);
-        }
-
-        auto rng = ::MakeTestRange(first, last);
-        p = ranges::minmax_element(rng, comp);
-        if (first != last)
-        {
-            for (Iter j = first; j != last; ++j)
-            {
-                CHECK(!comp(*j, *p.min));
-                CHECK(!comp(*p.max, *j));
-            }
-        }
-        else
-        {
-            CHECK(p.min == last);
-            CHECK(p.max == last);
-        }
-
-        auto res = ranges::minmax_element(std::move(rng), comp);
-        CHECK(is_dangling(res.min));
-        CHECK(is_dangling(res.max));
-    }
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter_comp(unsigned N)
-    {
-        std::unique_ptr<int[]> a{new int[N]};
-        std::iota(a.get(), a.get()+N, 0);
-        std::shuffle(a.get(), a.get()+N, gen);
-        test_iter_comp(Iter(a.get()), Sent(a.get()+N));
-    }
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter_comp()
-    {
-        test_iter_comp<Iter, Sent>(0);
-        test_iter_comp<Iter, Sent>(1);
-        test_iter_comp<Iter, Sent>(2);
-        test_iter_comp<Iter, Sent>(3);
-        test_iter_comp<Iter, Sent>(10);
-        test_iter_comp<Iter, Sent>(1000);
-        {
-            const unsigned N = 100;
-            std::unique_ptr<int[]> a{new int[N]};
-            std::fill_n(a.get(), N, 5);
-            std::shuffle(a.get(), a.get()+N, gen);
-            typedef std::greater<int> Compare;
-            Compare comp;
-            ranges::minmax_element_result<Iter> p = ranges::minmax_element(Iter(a.get()), Sent(a.get()+N), comp);
-            CHECK(base(p.min) == a.get());
-            CHECK(base(p.max) == a.get()+N-1);
-        }
-    }
-
-    struct S
-    {
-        int i;
-    };
-}
-
-int main()
-{
-    test_iter<ForwardIterator<const int*> >();
-    test_iter<BidirectionalIterator<const int*> >();
-    test_iter<RandomAccessIterator<const int*> >();
-    test_iter<const int*>();
-    test_iter<ForwardIterator<const int*>, Sentinel<const int*>>();
-    test_iter<BidirectionalIterator<const int*>, Sentinel<const int*>>();
-    test_iter<RandomAccessIterator<const int*>, Sentinel<const int*>>();
-
-    test_iter<ForwardIterator<const int*> >();
-    test_iter<BidirectionalIterator<const int*> >();
-    test_iter<RandomAccessIterator<const int*> >();
-    test_iter<const int*>();
-    test_iter<ForwardIterator<const int*>, Sentinel<const int*>>();
-    test_iter<BidirectionalIterator<const int*>, Sentinel<const int*>>();
-    test_iter<RandomAccessIterator<const int*>, Sentinel<const int*>>();
-
-    test_iter_comp<ForwardIterator<const int*> >();
-    test_iter_comp<BidirectionalIterator<const int*> >();
-    test_iter_comp<RandomAccessIterator<const int*> >();
-    test_iter_comp<const int*>();
-    test_iter_comp<ForwardIterator<const int*>, Sentinel<const int*>>();
-    test_iter_comp<BidirectionalIterator<const int*>, Sentinel<const int*>>();
-    test_iter_comp<RandomAccessIterator<const int*>, Sentinel<const int*>>();
-
-    test_iter_comp<ForwardIterator<const int*> >();
-    test_iter_comp<BidirectionalIterator<const int*> >();
-    test_iter_comp<RandomAccessIterator<const int*> >();
-    test_iter_comp<const int*>();
-    test_iter_comp<ForwardIterator<const int*>, Sentinel<const int*>>();
-    test_iter_comp<BidirectionalIterator<const int*>, Sentinel<const int*>>();
-    test_iter_comp<RandomAccessIterator<const int*>, Sentinel<const int*>>();
-
-    // Works with projections?
-    S s[] = {S{1},S{2},S{3},S{4},S{-4},S{5},S{6},S{40},S{7},S{8},S{9}};
-    ranges::minmax_element_result<S const *> ps = ranges::minmax_element(s, std::less<int>{}, &S::i);
-    CHECK(ps.min->i == -4);
-    CHECK(ps.max->i == 40);
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/mismatch.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/mismatch.cpp
deleted file mode 100644
index 02403e18..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/mismatch.cpp
+++ /dev/null
@@ -1,139 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <memory>
-#include <algorithm>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/mismatch.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-RANGES_DIAGNOSTIC_IGNORE_DEPRECATED_DECLARATIONS
-
-template<typename Iter, typename Sent = Iter>
-void test_iter()
-{
-    int ia[] = {0, 1, 2, 2, 0, 1, 2, 3};
-    constexpr auto sa = ranges::size(ia);
-    int ib[] = {0, 1, 2, 3, 0, 1, 2, 3};
-    using Res = ranges::mismatch_result<Iter, Iter>;
-    CHECK(ranges::mismatch(Iter(ia), Sent(ia + sa), Iter(ib)) ==
-                           Res{Iter(ia+3),Iter(ib+3)});
-    CHECK(ranges::mismatch(Iter(ia),Sent(ia + sa),Iter(ib),Sent(ib + sa)) ==
-                           Res{Iter(ia+3),Iter(ib+3)});
-    CHECK(ranges::mismatch(Iter(ia),Sent(ia + sa),Iter(ib),Sent(ib + 2)) ==
-                           Res{Iter(ia+2),Iter(ib+2)});
-
-    CHECK(ranges::mismatch(Iter(ia),Sent(ia + sa),Iter(ib),std::equal_to<int>()) ==
-                           Res{Iter(ia+3),Iter(ib+3)});
-    CHECK(ranges::mismatch(Iter(ia),Sent(ia + sa),Iter(ib),Sent(ib + sa),std::equal_to<int>()) ==
-                           Res{Iter(ia+3),Iter(ib+3)});
-    CHECK(ranges::mismatch(Iter(ia), Sent(ia + sa), Iter(ib), Sent(ib + 2), std::equal_to<int>()) ==
-                           Res{Iter(ia+2),Iter(ib+2)});
-}
-
-template<typename Iter, typename Sent = Iter>
-void test_range()
-{
-    int ia[] = {0, 1, 2, 2, 0, 1, 2, 3};
-    constexpr auto sa = ranges::size(ia);
-    int ib[] = {0, 1, 2, 3, 0, 1, 2, 3};
-    using Res = ranges::mismatch_result<Iter, Iter>;
-    auto rng1 = ::MakeTestRange(Iter(ia), Sent(ia + sa));
-    CHECK(ranges::mismatch(rng1, Iter(ib)) ==
-                           Res{Iter(ia+3),Iter(ib+3)});
-    auto r1 = ranges::mismatch(std::move(rng1), Iter(ib));
-    CHECK(::is_dangling(r1.in1));
-    CHECK(r1.in2 == Iter(ib+3));
-    auto rng2 = ::MakeTestRange(Iter(ia),Sent(ia + sa));
-    auto rng3 = ::MakeTestRange(Iter(ib),Sent(ib + sa));
-    CHECK(ranges::mismatch(rng2,rng3) ==
-                           Res{Iter(ia+3),Iter(ib+3)});
-    auto r2 = ranges::mismatch(std::move(rng2), std::move(rng3));
-    CHECK(::is_dangling(r2.in1));
-    CHECK(::is_dangling(r2.in2));
-    auto r3 = ranges::mismatch(rng2, std::move(rng3));
-    CHECK(r3.in1 == Iter(ia+3));
-    CHECK(::is_dangling(r3.in2));
-    auto r4 = ranges::mismatch(std::move(rng2), rng3);
-    CHECK(::is_dangling(r4.in1));
-    CHECK(r4.in2 == Iter(ib+3));
-    auto rng4 = ::MakeTestRange(Iter(ia),Sent(ia + sa));
-    auto rng5 = ::MakeTestRange(Iter(ib),Sent(ib + 2));
-    CHECK(ranges::mismatch(rng4,rng5) ==
-                           Res{Iter(ia+2),Iter(ib+2)});
-
-    auto rng6 = ::MakeTestRange(Iter(ia),Sent(ia + sa));
-    CHECK(ranges::mismatch(rng6,Iter(ib),std::equal_to<int>()) ==
-                           Res{Iter(ia+3),Iter(ib+3)});
-    auto rng7 = ::MakeTestRange(Iter(ia),Sent(ia + sa));
-    auto rng8 = ::MakeTestRange(Iter(ib),Sent(ib + sa));
-    CHECK(ranges::mismatch(rng7,rng8,std::equal_to<int>()) ==
-                           Res{Iter(ia+3),Iter(ib+3)});
-    auto rng9 = ::MakeTestRange(Iter(ia), Sent(ia + sa));
-    auto rng10 = ::MakeTestRange(Iter(ib), Sent(ib + 2));
-    CHECK(ranges::mismatch(rng9,rng10,std::equal_to<int>()) ==
-                           Res{Iter(ia+2),Iter(ib+2)});
-}
-
-struct S
-{
-    int i;
-};
-
-int main()
-{
-    test_iter<InputIterator<const int*>>();
-    test_iter<ForwardIterator<const int*>>();
-    test_iter<BidirectionalIterator<const int*>>();
-    test_iter<RandomAccessIterator<const int*>>();
-    test_iter<const int*>();
-    test_iter<InputIterator<const int*>, Sentinel<const int*>>();
-    test_iter<ForwardIterator<const int*>, Sentinel<const int*>>();
-    test_iter<BidirectionalIterator<const int*>, Sentinel<const int*>>();
-    test_iter<RandomAccessIterator<const int*>, Sentinel<const int*>>();
-
-    test_range<InputIterator<const int*>>();
-    test_range<ForwardIterator<const int*>>();
-    test_range<BidirectionalIterator<const int*>>();
-    test_range<RandomAccessIterator<const int*>>();
-    test_range<const int*>();
-    test_range<InputIterator<const int*>, Sentinel<const int*>>();
-    test_range<ForwardIterator<const int*>, Sentinel<const int*>>();
-    test_range<BidirectionalIterator<const int*>, Sentinel<const int*>>();
-    test_range<RandomAccessIterator<const int*>, Sentinel<const int*>>();
-
-    // Works with projections?
-    S s1[] = {S{1},S{2},S{3},S{4},S{-4},S{5},S{6},S{40},S{7},S{8},S{9}};
-    int const i1[] = {1,2,3,4,5,6,7,8,9};
-    ranges::mismatch_result<S const *, int const *> ps1
-        = ranges::mismatch(s1, i1, std::equal_to<int>(), &S::i);
-    CHECK(ps1.in1->i == -4);
-    CHECK(*ps1.in2 == 5);
-
-    S s2[] = {S{1},S{2},S{3},S{4},S{5},S{6},S{40},S{7},S{8},S{9}};
-    ranges::mismatch_result<S const *, S const *> ps2
-        = ranges::mismatch(s1, s2, std::equal_to<int>(), &S::i, &S::i);
-    CHECK(ps2.in1->i == -4);
-    CHECK(ps2.in2->i == 5);
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/move.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/move.cpp
deleted file mode 100644
index a6a07fa9..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/move.cpp
+++ /dev/null
@@ -1,241 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <memory>
-#include <algorithm>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/move.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-template<typename InIter, typename OutIter, typename Sent = InIter>
-void
-test()
-{
-    {
-        const int N = 1000;
-        int ia[N];
-        for(int i = 0; i < N; ++i)
-            ia[i] = i;
-        int ib[N] = {0};
-
-        ranges::move_result<InIter, OutIter> r = ranges::move(InIter(ia), Sent(ia+N), OutIter(ib));
-        CHECK(base(r.in) == ia+N);
-        CHECK(base(r.out) == ib+N);
-        for(int i = 0; i < N; ++i)
-            CHECK(ia[i] == ib[i]);
-    }
-
-    {
-        const int N = 1000;
-        int ia[N];
-        for(int i = 0; i < N; ++i)
-            ia[i] = i;
-        int ib[N] = {0};
-
-        ranges::move_result<InIter, OutIter> r = ranges::move(as_lvalue(ranges::make_subrange(InIter(ia), Sent(ia+N))), OutIter(ib));
-        CHECK(base(r.in) == ia+N);
-        CHECK(base(r.out) == ib+N);
-        for(int i = 0; i < N; ++i)
-            CHECK(ia[i] == ib[i]);
-    }
-}
-
-struct S
-{
-    std::unique_ptr<int> p;
-};
-
-template<typename InIter, typename OutIter, typename Sent = InIter>
-void
-test1()
-{
-    {
-        const int N = 100;
-        std::unique_ptr<int> ia[N];
-        for(int i = 0; i < N; ++i)
-            ia[i].reset(new int(i));
-        std::unique_ptr<int> ib[N];
-
-        ranges::move_result<InIter, OutIter> r = ranges::move(InIter(ia), Sent(ia+N), OutIter(ib));
-        CHECK(base(r.in) == ia+N);
-        CHECK(base(r.out) == ib+N);
-        for(int i = 0; i < N; ++i)
-        {
-            CHECK(ia[i].get() == nullptr);
-            CHECK(*ib[i] == i);
-        }
-    }
-
-    {
-        const int N = 100;
-        std::unique_ptr<int> ia[N];
-        for(int i = 0; i < N; ++i)
-            ia[i].reset(new int(i));
-        std::unique_ptr<int> ib[N];
-
-        ranges::move_result<InIter, OutIter> r = ranges::move(as_lvalue(ranges::make_subrange(InIter(ia), Sent(ia+N))), OutIter(ib));
-        CHECK(base(r.in) == ia+N);
-        CHECK(base(r.out) == ib+N);
-        for(int i = 0; i < N; ++i)
-        {
-            CHECK(ia[i].get() == nullptr);
-            CHECK(*ib[i] == i);
-        }
-
-        ranges::move(ib, ib+N, ia);
-
-        auto r2 = ranges::move(ranges::make_subrange(InIter(ia), Sent(ia+N)), OutIter(ib));
-        CHECK(base(r2.in) == ia+N);
-        CHECK(base(r2.out) == ib+N);
-        for(int i = 0; i < N; ++i)
-        {
-            CHECK(ia[i].get() == nullptr);
-            CHECK(*ib[i] == i);
-        }
-    }
-}
-
-int main()
-{
-    test<InputIterator<const int*>, OutputIterator<int*> >();
-    test<InputIterator<const int*>, InputIterator<int*> >();
-    test<InputIterator<const int*>, ForwardIterator<int*> >();
-    test<InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test<InputIterator<const int*>, RandomAccessIterator<int*> >();
-    test<InputIterator<const int*>, int*>();
-
-    test<ForwardIterator<const int*>, OutputIterator<int*> >();
-    test<ForwardIterator<const int*>, InputIterator<int*> >();
-    test<ForwardIterator<const int*>, ForwardIterator<int*> >();
-    test<ForwardIterator<const int*>, BidirectionalIterator<int*> >();
-    test<ForwardIterator<const int*>, RandomAccessIterator<int*> >();
-    test<ForwardIterator<const int*>, int*>();
-
-    test<BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test<BidirectionalIterator<const int*>, InputIterator<int*> >();
-    test<BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test<BidirectionalIterator<const int*>, int*>();
-
-    test<RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test<RandomAccessIterator<const int*>, InputIterator<int*> >();
-    test<RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test<RandomAccessIterator<const int*>, int*>();
-
-    test<const int*, OutputIterator<int*> >();
-    test<const int*, InputIterator<int*> >();
-    test<const int*, ForwardIterator<int*> >();
-    test<const int*, BidirectionalIterator<int*> >();
-    test<const int*, RandomAccessIterator<int*> >();
-    test<const int*, int*>();
-
-    test<InputIterator<const int*>, OutputIterator<int*>, Sentinel<const int*>>();
-    test<InputIterator<const int*>, InputIterator<int*>, Sentinel<const int*> >();
-    test<InputIterator<const int*>, ForwardIterator<int*>, Sentinel<const int*> >();
-    test<InputIterator<const int*>, BidirectionalIterator<int*>, Sentinel<const int*> >();
-    test<InputIterator<const int*>, RandomAccessIterator<int*>, Sentinel<const int*> >();
-
-    test<ForwardIterator<const int*>, OutputIterator<int*>, Sentinel<const int*> >();
-    test<ForwardIterator<const int*>, InputIterator<int*>, Sentinel<const int*> >();
-    test<ForwardIterator<const int*>, ForwardIterator<int*>, Sentinel<const int*> >();
-    test<ForwardIterator<const int*>, BidirectionalIterator<int*>, Sentinel<const int*> >();
-    test<ForwardIterator<const int*>, RandomAccessIterator<int*>, Sentinel<const int*> >();
-
-    test<BidirectionalIterator<const int*>, OutputIterator<int*>, Sentinel<const int*> >();
-    test<BidirectionalIterator<const int*>, InputIterator<int*>, Sentinel<const int*> >();
-    test<BidirectionalIterator<const int*>, ForwardIterator<int*>, Sentinel<const int*> >();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<int*>, Sentinel<const int*> >();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<int*>, Sentinel<const int*> >();
-
-    test<RandomAccessIterator<const int*>, OutputIterator<int*>, Sentinel<const int*> >();
-    test<RandomAccessIterator<const int*>, InputIterator<int*>, Sentinel<const int*> >();
-    test<RandomAccessIterator<const int*>, ForwardIterator<int*>, Sentinel<const int*> >();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<int*>, Sentinel<const int*> >();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<int*>, Sentinel<const int*> >();
-
-    test1<InputIterator<std::unique_ptr<int>*>, OutputIterator<std::unique_ptr<int>*> >();
-    test1<InputIterator<std::unique_ptr<int>*>, InputIterator<std::unique_ptr<int>*> >();
-    test1<InputIterator<std::unique_ptr<int>*>, ForwardIterator<std::unique_ptr<int>*> >();
-    test1<InputIterator<std::unique_ptr<int>*>, BidirectionalIterator<std::unique_ptr<int>*> >();
-    test1<InputIterator<std::unique_ptr<int>*>, RandomAccessIterator<std::unique_ptr<int>*> >();
-    test1<InputIterator<std::unique_ptr<int>*>, std::unique_ptr<int>*>();
-
-    test1<ForwardIterator<std::unique_ptr<int>*>, OutputIterator<std::unique_ptr<int>*> >();
-    test1<ForwardIterator<std::unique_ptr<int>*>, InputIterator<std::unique_ptr<int>*> >();
-    test1<ForwardIterator<std::unique_ptr<int>*>, ForwardIterator<std::unique_ptr<int>*> >();
-    test1<ForwardIterator<std::unique_ptr<int>*>, BidirectionalIterator<std::unique_ptr<int>*> >();
-    test1<ForwardIterator<std::unique_ptr<int>*>, RandomAccessIterator<std::unique_ptr<int>*> >();
-    test1<ForwardIterator<std::unique_ptr<int>*>, std::unique_ptr<int>*>();
-
-    test1<BidirectionalIterator<std::unique_ptr<int>*>, OutputIterator<std::unique_ptr<int>*> >();
-    test1<BidirectionalIterator<std::unique_ptr<int>*>, InputIterator<std::unique_ptr<int>*> >();
-    test1<BidirectionalIterator<std::unique_ptr<int>*>, ForwardIterator<std::unique_ptr<int>*> >();
-    test1<BidirectionalIterator<std::unique_ptr<int>*>, BidirectionalIterator<std::unique_ptr<int>*> >();
-    test1<BidirectionalIterator<std::unique_ptr<int>*>, RandomAccessIterator<std::unique_ptr<int>*> >();
-    test1<BidirectionalIterator<std::unique_ptr<int>*>, std::unique_ptr<int>*>();
-
-    test1<RandomAccessIterator<std::unique_ptr<int>*>, OutputIterator<std::unique_ptr<int>*> >();
-    test1<RandomAccessIterator<std::unique_ptr<int>*>, InputIterator<std::unique_ptr<int>*> >();
-    test1<RandomAccessIterator<std::unique_ptr<int>*>, ForwardIterator<std::unique_ptr<int>*> >();
-    test1<RandomAccessIterator<std::unique_ptr<int>*>, BidirectionalIterator<std::unique_ptr<int>*> >();
-    test1<RandomAccessIterator<std::unique_ptr<int>*>, RandomAccessIterator<std::unique_ptr<int>*> >();
-    test1<RandomAccessIterator<std::unique_ptr<int>*>, std::unique_ptr<int>*>();
-
-    test1<std::unique_ptr<int>*, OutputIterator<std::unique_ptr<int>*> >();
-    test1<std::unique_ptr<int>*, InputIterator<std::unique_ptr<int>*> >();
-    test1<std::unique_ptr<int>*, ForwardIterator<std::unique_ptr<int>*> >();
-    test1<std::unique_ptr<int>*, BidirectionalIterator<std::unique_ptr<int>*> >();
-    test1<std::unique_ptr<int>*, RandomAccessIterator<std::unique_ptr<int>*> >();
-    test1<std::unique_ptr<int>*, std::unique_ptr<int>*>();
-
-    test1<InputIterator<std::unique_ptr<int>*>, OutputIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*> >();
-    test1<InputIterator<std::unique_ptr<int>*>, InputIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*> >();
-    test1<InputIterator<std::unique_ptr<int>*>, ForwardIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*> >();
-    test1<InputIterator<std::unique_ptr<int>*>, BidirectionalIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*> >();
-    test1<InputIterator<std::unique_ptr<int>*>, RandomAccessIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*> >();
-    test1<InputIterator<std::unique_ptr<int>*>, std::unique_ptr<int>*>();
-
-    test1<ForwardIterator<std::unique_ptr<int>*>, OutputIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*> >();
-    test1<ForwardIterator<std::unique_ptr<int>*>, InputIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*> >();
-    test1<ForwardIterator<std::unique_ptr<int>*>, ForwardIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*> >();
-    test1<ForwardIterator<std::unique_ptr<int>*>, BidirectionalIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*> >();
-    test1<ForwardIterator<std::unique_ptr<int>*>, RandomAccessIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*> >();
-    test1<ForwardIterator<std::unique_ptr<int>*>, std::unique_ptr<int>*>();
-
-    test1<BidirectionalIterator<std::unique_ptr<int>*>, OutputIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*> >();
-    test1<BidirectionalIterator<std::unique_ptr<int>*>, InputIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*> >();
-    test1<BidirectionalIterator<std::unique_ptr<int>*>, ForwardIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*> >();
-    test1<BidirectionalIterator<std::unique_ptr<int>*>, BidirectionalIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*> >();
-    test1<BidirectionalIterator<std::unique_ptr<int>*>, RandomAccessIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*> >();
-    test1<BidirectionalIterator<std::unique_ptr<int>*>, std::unique_ptr<int>*>();
-
-    test1<RandomAccessIterator<std::unique_ptr<int>*>, OutputIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*> >();
-    test1<RandomAccessIterator<std::unique_ptr<int>*>, InputIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*> >();
-    test1<RandomAccessIterator<std::unique_ptr<int>*>, ForwardIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*> >();
-    test1<RandomAccessIterator<std::unique_ptr<int>*>, BidirectionalIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*> >();
-    test1<RandomAccessIterator<std::unique_ptr<int>*>, RandomAccessIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*> >();
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/move_backward.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/move_backward.cpp
deleted file mode 100644
index b8baa3ce..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/move_backward.cpp
+++ /dev/null
@@ -1,148 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <memory>
-#include <algorithm>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/move_backward.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-template<typename InIter, typename OutIter>
-void
-test()
-{
-    {
-        const int N = 1000;
-        int ia[N];
-        for(int i = 0; i < N; ++i)
-            ia[i] = i;
-        int ib[N] = {0};
-
-        ranges::move_backward_result<InIter, OutIter> r =
-            ranges::move_backward(InIter(ia), InIter(ia+N), OutIter(ib+N));
-        CHECK(base(r.in) == ia+N);
-        CHECK(base(r.out) == ib);
-        for(int i = 0; i < N; ++i)
-            CHECK(ia[i] == ib[i]);
-    }
-
-    {
-        const int N = 1000;
-        int ia[N];
-        for(int i = 0; i < N; ++i)
-            ia[i] = i;
-        int ib[N] = {0};
-
-        ranges::move_backward_result<InIter, OutIter> r =
-            ranges::move_backward(ranges::make_subrange(InIter(ia), InIter(ia+N)), OutIter(ib+N));
-        CHECK(base(r.in) == ia+N);
-        CHECK(base(r.out) == ib);
-        for(int i = 0; i < N; ++i)
-            CHECK(ia[i] == ib[i]);
-    }
-}
-
-struct S
-{
-    std::unique_ptr<int> p;
-};
-
-template<typename InIter, typename OutIter>
-void
-test1()
-{
-    {
-        const int N = 100;
-        std::unique_ptr<int> ia[N];
-        for(int i = 0; i < N; ++i)
-            ia[i].reset(new int(i));
-        std::unique_ptr<int> ib[N];
-
-        ranges::move_backward_result<InIter, OutIter> r =
-            ranges::move_backward(InIter(ia), InIter(ia+N), OutIter(ib+N));
-        CHECK(base(r.in) == ia+N);
-        CHECK(base(r.out) == ib);
-        for(int i = 0; i < N; ++i)
-        {
-            CHECK(ia[i].get() == nullptr);
-            CHECK(*ib[i] == i);
-        }
-    }
-
-    {
-        const int N = 100;
-        std::unique_ptr<int> ia[N];
-        for(int i = 0; i < N; ++i)
-            ia[i].reset(new int(i));
-        std::unique_ptr<int> ib[N];
-
-        ranges::move_backward_result<InIter, OutIter> r =
-            ranges::move_backward(ranges::make_subrange(InIter(ia), InIter(ia+N)), OutIter(ib+N));
-        CHECK(base(r.in) == ia+N);
-        CHECK(base(r.out) == ib);
-        for(int i = 0; i < N; ++i)
-        {
-            CHECK(ia[i].get() == nullptr);
-            CHECK(*ib[i] == i);
-        }
-
-        ranges::move_backward(ib, ib+N, ia+N);
-
-        auto r2 = ranges::move_backward(ranges::make_subrange(InIter(ia), InIter(ia+N)), OutIter(ib+N));
-        CHECK(base(r2.in) == ia+N);
-        CHECK(base(r2.out) == ib);
-        for(int i = 0; i < N; ++i)
-        {
-            CHECK(ia[i].get() == nullptr);
-            CHECK(*ib[i] == i);
-        }
-    }
-}
-
-int main()
-{
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test<BidirectionalIterator<const int*>, int*>();
-
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test<RandomAccessIterator<const int*>, int*>();
-
-    test<const int*, BidirectionalIterator<int*> >();
-    test<const int*, RandomAccessIterator<int*> >();
-    test<const int*, int*>();
-
-    test1<BidirectionalIterator<std::unique_ptr<int>*>, BidirectionalIterator<std::unique_ptr<int>*> >();
-    test1<BidirectionalIterator<std::unique_ptr<int>*>, RandomAccessIterator<std::unique_ptr<int>*> >();
-    test1<BidirectionalIterator<std::unique_ptr<int>*>, std::unique_ptr<int>*>();
-
-    test1<RandomAccessIterator<std::unique_ptr<int>*>, BidirectionalIterator<std::unique_ptr<int>*> >();
-    test1<RandomAccessIterator<std::unique_ptr<int>*>, RandomAccessIterator<std::unique_ptr<int>*> >();
-    test1<RandomAccessIterator<std::unique_ptr<int>*>, std::unique_ptr<int>*>();
-
-    test1<std::unique_ptr<int>*, BidirectionalIterator<std::unique_ptr<int>*> >();
-    test1<std::unique_ptr<int>*, RandomAccessIterator<std::unique_ptr<int>*> >();
-    test1<std::unique_ptr<int>*, std::unique_ptr<int>*>();
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/next_permutation.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/next_permutation.cpp
deleted file mode 100644
index f6126382..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/next_permutation.cpp
+++ /dev/null
@@ -1,217 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <cstring>
-#include <utility>
-#include <algorithm>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/permutation.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-int factorial(int x)
-{
-    int r = 1;
-    for (; x; --x)
-        r *= x;
-    return r;
-}
-
-template<typename Iter, typename Sent = Iter>
-void test_iter()
-{
-    int ia[] = {1, 2, 3, 4, 5, 6};
-    const int sa = sizeof(ia)/sizeof(ia[0]);
-    int prev[sa];
-    for (int e = 0; e <= sa; ++e)
-    {
-        int count = 0;
-        bool x;
-        do
-        {
-            std::copy(ia, ia+e, prev);
-            x = ranges::next_permutation(Iter(ia), Sent(ia+e));
-            if(e > 1)
-            {
-                if(x)
-                    CHECK(std::lexicographical_compare(prev, prev+e, ia, ia+e));
-                else
-                    CHECK(std::lexicographical_compare(ia, ia+e, prev, prev+e));
-            }
-            ++count;
-        } while(x);
-        CHECK(count == factorial(e));
-    }
-}
-
-template<typename Iter, typename Sent = Iter>
-void test_range()
-{
-    int ia[] = {1, 2, 3, 4, 5, 6};
-    const int sa = sizeof(ia)/sizeof(ia[0]);
-    int prev[sa];
-    for (int e = 0; e <= sa; ++e)
-    {
-        int count = 0;
-        bool x;
-        do
-        {
-            std::copy(ia, ia+e, prev);
-            x = ranges::next_permutation(ranges::make_subrange(Iter(ia), Sent(ia+e)));
-            if(e > 1)
-            {
-                if(x)
-                    CHECK(std::lexicographical_compare(prev, prev+e, ia, ia+e));
-                else
-                    CHECK(std::lexicographical_compare(ia, ia+e, prev, prev+e));
-            }
-            ++count;
-        } while(x);
-        CHECK(count == factorial(e));
-    }
-}
-
-template<typename Iter, typename Sent = Iter>
-void test_iter_comp()
-{
-    typedef std::greater<int> C;
-    int ia[] = {6, 5, 4, 3, 2, 1};
-    const int sa = sizeof(ia)/sizeof(ia[0]);
-    int prev[sa];
-    for(int e = 0; e <= sa; ++e)
-    {
-        int count = 0;
-        bool x;
-        do
-        {
-            std::copy(ia, ia+e, prev);
-            x = ranges::next_permutation(Iter(ia), Sent(ia+e), C());
-            if(e > 1)
-            {
-                if (x)
-                    CHECK(std::lexicographical_compare(prev, prev+e, ia, ia+e, C()));
-                else
-                    CHECK(std::lexicographical_compare(ia, ia+e, prev, prev+e, C()));
-            }
-            ++count;
-        } while (x);
-        CHECK(count == factorial(e));
-    }
-}
-
-template<typename Iter, typename Sent = Iter>
-void test_range_comp()
-{
-    typedef std::greater<int> C;
-    int ia[] = {6, 5, 4, 3, 2, 1};
-    const int sa = sizeof(ia)/sizeof(ia[0]);
-    int prev[sa];
-    for(int e = 0; e <= sa; ++e)
-    {
-        int count = 0;
-        bool x;
-        do
-        {
-            std::copy(ia, ia+e, prev);
-            x = ranges::next_permutation(ranges::make_subrange(Iter(ia), Sent(ia+e)), C());
-            if(e > 1)
-            {
-                if (x)
-                    CHECK(std::lexicographical_compare(prev, prev+e, ia, ia+e, C()));
-                else
-                    CHECK(std::lexicographical_compare(ia, ia+e, prev, prev+e, C()));
-            }
-            ++count;
-        } while (x);
-            CHECK(count == factorial(e));
-    }
-}
-
-struct c_str
-{
-    char const * value;
-
-    friend bool operator==(c_str a, c_str b)
-    {
-        return 0 == std::strcmp(a.value, b.value);
-    }
-
-    friend bool operator!=(c_str a, c_str b)
-    {
-        return !(a == b);
-    }
-};
-
-// For debugging the projection test
-std::ostream &operator<<(std::ostream& sout, std::pair<int, c_str> p)
-{
-    return sout << "{" << p.first << "," << p.second.value << "}";
-}
-
-int main()
-{
-    test_iter<BidirectionalIterator<int*> >();
-    test_iter<RandomAccessIterator<int*> >();
-    test_iter<int*>();
-
-    test_iter<BidirectionalIterator<int*>, Sentinel<int*> >();
-    test_iter<RandomAccessIterator<int*>, Sentinel<int*> >();
-
-    test_iter_comp<BidirectionalIterator<int*> >();
-    test_iter_comp<RandomAccessIterator<int*> >();
-    test_iter_comp<int*>();
-
-    test_iter_comp<BidirectionalIterator<int*>, Sentinel<int*> >();
-    test_iter_comp<RandomAccessIterator<int*>, Sentinel<int*> >();
-
-    test_range<BidirectionalIterator<int*> >();
-    test_range<RandomAccessIterator<int*> >();
-    test_range<int*>();
-
-    test_range<BidirectionalIterator<int*>, Sentinel<int*> >();
-    test_range<RandomAccessIterator<int*>, Sentinel<int*> >();
-
-    test_range_comp<BidirectionalIterator<int*> >();
-    test_range_comp<RandomAccessIterator<int*> >();
-    test_range_comp<int*>();
-
-    test_range_comp<BidirectionalIterator<int*>, Sentinel<int*> >();
-    test_range_comp<RandomAccessIterator<int*>, Sentinel<int*> >();
-
-    // Test projection
-
-    using C = std::greater<int>;
-    using I = std::initializer_list<std::pair<int, c_str>>;
-    std::pair<int, c_str> ia[] = {{6, {"six"}}, {5,{"five"}}, {4,{"four"}}, {3,{"three"}}, {2,{"two"}}, {1,{"one"}}};
-    CHECK(ranges::next_permutation(ia, C(), &std::pair<int,c_str>::first));
-    ::check_equal(ia, I{{6, {"six"}}, {5,{"five"}}, {4,{"four"}}, {3,{"three"}}, {1,{"one"}}, {2,{"two"}}});
-    CHECK(ranges::next_permutation(ia, C(), &std::pair<int,c_str>::first));
-    ::check_equal(ia, I{{6, {"six"}}, {5,{"five"}}, {4,{"four"}}, {2,{"two"}}, {3,{"three"}}, {1,{"one"}}});
-    CHECK(ranges::next_permutation(ia, C(), &std::pair<int,c_str>::first));
-    ::check_equal(ia, I{{6, {"six"}}, {5,{"five"}}, {4,{"four"}}, {2,{"two"}}, {1,{"one"}}, {3,{"three"}}});
-    // etc..
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/none_of.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/none_of.cpp
deleted file mode 100644
index 2ce0ff59..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/none_of.cpp
+++ /dev/null
@@ -1,63 +0,0 @@
-// Range v3 library
-//
-//  Copyright Andrew Sutton 2014
-//  Copyright Gonzalo Brito Gadeschi 2014
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/none_of.hpp>
-#include "../simple_test.hpp"
-
-bool even(int n) { return n % 2 == 0; }
-
-struct S {
-  S(bool p) : test(p) { }
-
-  bool p() const { return test; }
-
-  bool test;
-};
-
-int main()
-{
-  std::vector<int> all_even { 0, 2, 4, 6 };
-  std::vector<int> one_even { 1, 3, 4, 7 };
-  std::vector<int> none_even { 1, 3, 5, 7 };
-  CHECK(!ranges::none_of(all_even.begin(), all_even.end(), even));
-  CHECK(!ranges::none_of(one_even.begin(), one_even.end(), even));
-  CHECK(ranges::none_of(none_even.begin(), none_even.end(), even));
-
-  CHECK(!ranges::none_of(all_even, even));
-  CHECK(!ranges::none_of(one_even, even));
-  CHECK(ranges::none_of(none_even, even));
-
-  using ILI = std::initializer_list<int>;
-  CHECK(!ranges::none_of(ILI{0, 2, 4, 6}, [](int n) { return n % 2 == 0; }));
-  CHECK(!ranges::none_of(ILI{1, 3, 4, 7}, [](int n) { return n % 2 == 0; }));
-  CHECK(ranges::none_of(ILI{1, 3, 5, 7}, [](int n) { return n % 2 == 0; }));
-
-  std::vector<S> all_true { true, true, true };
-  std::vector<S> one_true { false, false, true };
-  std::vector<S> none_true { false, false, false };
-  CHECK(!ranges::none_of(all_true.begin(), all_true.end(), &S::p));
-  CHECK(!ranges::none_of(one_true.begin(), one_true.end(), &S::p));
-  CHECK(ranges::none_of(none_true.begin(), none_true.end(), &S::p));
-
-  CHECK(!ranges::none_of(all_true, &S::p));
-  CHECK(!ranges::none_of(one_true, &S::p));
-  CHECK(ranges::none_of(none_true, &S::p));
-
-  using ILS = std::initializer_list<S>;
-  CHECK(!ranges::none_of(ILS{S(true), S(true), S(true)}, &S::p));
-  CHECK(!ranges::none_of(ILS{S(false), S(true), S(false)}, &S::p));
-  CHECK(ranges::none_of(ILS{S(false), S(false), S(false)}, &S::p));
-
-  return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/nth_element.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/nth_element.cpp
deleted file mode 100644
index fbd1c386..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/nth_element.cpp
+++ /dev/null
@@ -1,103 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <memory>
-#include <random>
-#include <algorithm>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/nth_element.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS
-RANGES_DIAGNOSTIC_IGNORE_SIGN_CONVERSION
-
-namespace
-{
-    std::mt19937 gen;
-
-    void
-    test_one(unsigned N, unsigned M)
-    {
-        RANGES_ENSURE(N != 0);
-        RANGES_ENSURE(M < N);
-        std::unique_ptr<int[]> array{new int[N]};
-        for (int i = 0; (unsigned)i < N; ++i)
-            array[i] = i;
-        std::shuffle(array.get(), array.get()+N, gen);
-        CHECK(ranges::nth_element(array.get(), array.get()+M, array.get()+N) == array.get()+N);
-        CHECK((unsigned)array[M] == M);
-        std::shuffle(array.get(), array.get()+N, gen);
-        CHECK(ranges::nth_element(::as_lvalue(ranges::make_subrange(array.get(), array.get()+N)), array.get()+M) == array.get()+N);
-        CHECK((unsigned)array[M] == M);
-        std::shuffle(array.get(), array.get()+N, gen);
-        CHECK(ranges::nth_element(ranges::make_subrange(array.get(), array.get()+N), array.get()+M) == array.get()+N);
-        CHECK((unsigned)array[M] == M);
-        ranges::nth_element(array.get(), array.get()+N, array.get()+N); // first, last, end
-    }
-
-    void
-    test(unsigned N)
-    {
-        test_one(N, 0);
-        test_one(N, 1);
-        test_one(N, 2);
-        test_one(N, 3);
-        test_one(N, N/2-1);
-        test_one(N, N/2);
-        test_one(N, N/2+1);
-        test_one(N, N-3);
-        test_one(N, N-2);
-        test_one(N, N-1);
-    }
-
-    struct S
-    {
-        int i,j;
-    };
-}
-
-int main()
-{
-    int d = 0;
-    ranges::nth_element(&d, &d, &d);
-    CHECK(d == 0);
-    test(256);
-    test(257);
-    test(499);
-    test(500);
-    test(997);
-    test(1000);
-    test(1009);
-
-    // Works with projections?
-    const int N = 257;
-    const int M = 56;
-    S ia[N];
-    for(int i = 0; i < N; ++i)
-        ia[i].i = ia[i].j = i;
-    std::shuffle(ia, ia+N, gen);
-    ranges::nth_element(ia, ia+M, std::less<int>(), &S::i);
-    CHECK(ia[M].i == M);
-    CHECK(ia[M].j == M);
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/partial_sort.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/partial_sort.cpp
deleted file mode 100644
index b40231ac..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/partial_sort.cpp
+++ /dev/null
@@ -1,183 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <memory>
-#include <random>
-#include <algorithm>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/partial_sort.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS
-RANGES_DIAGNOSTIC_IGNORE_SIGN_CONVERSION
-
-namespace
-{
-    std::mt19937 gen;
-
-    struct indirect_less
-    {
-        template<class P>
-        bool operator()(const P& x, const P& y)
-            {return *x < *y;}
-    };
-
-    void
-    test_larger_sorts(int N, int M)
-    {
-        RANGES_ENSURE(N > 0);
-        RANGES_ENSURE(M >= 0 && M <= N);
-        int* array = new int[N];
-        for(int i = 0; i < N; ++i)
-            array[i] = i;
-
-        using I = RandomAccessIterator<int*>;
-        using S = Sentinel<int*>;
-
-        std::shuffle(array, array+N, gen);
-        int *res = ranges::partial_sort(array, array+M, array+N);
-        CHECK(res == array+N);
-        for(int i = 0; i < M; ++i)
-            CHECK(array[i] == i);
-
-        std::shuffle(array, array+N, gen);
-        I res2 = ranges::partial_sort(I{array}, I{array+M}, S{array+N});
-        CHECK(res2.base() == array+N);
-        for(int i = 0; i < M; ++i)
-            CHECK(array[i] == i);
-
-        std::shuffle(array, array+N, gen);
-        res = ranges::partial_sort(ranges::make_subrange(array, array+N), array+M);
-        CHECK(res == array+N);
-        for(int i = 0; i < M; ++i)
-            CHECK(array[i] == i);
-
-        std::shuffle(array, array+N, gen);
-        res2 = ranges::partial_sort(ranges::make_subrange(I{array}, S{array+N}), I{array+M});
-        CHECK(res2.base() == array+N);
-        for(int i = 0; i < M; ++i)
-            CHECK(array[i] == i);
-
-        std::shuffle(array, array+N, gen);
-        auto res3 = ranges::partial_sort(::MakeTestRange(array, array+N), array+M);
-        CHECK(::is_dangling(res3));
-        for(int i = 0; i < M; ++i)
-            CHECK(array[i] == i);
-
-        std::shuffle(array, array+N, gen);
-        auto res4 = ranges::partial_sort(::MakeTestRange(I{array}, S{array+N}), I{array+M});
-        CHECK(::is_dangling(res4));
-        for(int i = 0; i < M; ++i)
-            CHECK(array[i] == i);
-
-        std::shuffle(array, array+N, gen);
-        res = ranges::partial_sort(array, array+M, array+N, std::greater<int>());
-        CHECK(res == array+N);
-        for(int i = 0; i < M; ++i)
-            CHECK(array[i] == N-i-1);
-
-        std::shuffle(array, array+N, gen);
-        res2 = ranges::partial_sort(I{array}, I{array+M}, S{array+N}, std::greater<int>());
-        CHECK(res2.base() == array+N);
-        for(int i = 0; i < M; ++i)
-            CHECK(array[i] == N-i-1);
-
-        std::shuffle(array, array+N, gen);
-        res = ranges::partial_sort(ranges::make_subrange(array, array+N), array+M, std::greater<int>());
-        CHECK(res == array+N);
-        for(int i = 0; i < M; ++i)
-            CHECK(array[i] == N-i-1);
-
-        std::shuffle(array, array+N, gen);
-        res2 = ranges::partial_sort(ranges::make_subrange(I{array}, S{array+N}), I{array+M}, std::greater<int>());
-        CHECK(res2.base() == array+N);
-        for(int i = 0; i < M; ++i)
-            CHECK(array[i] == N-i-1);
-
-        delete [] array;
-    }
-
-    void
-    test_larger_sorts(int N)
-    {
-        test_larger_sorts(N, 0);
-        test_larger_sorts(N, 1);
-        test_larger_sorts(N, 2);
-        test_larger_sorts(N, 3);
-        test_larger_sorts(N, N/2-1);
-        test_larger_sorts(N, N/2);
-        test_larger_sorts(N, N/2+1);
-        test_larger_sorts(N, N-2);
-        test_larger_sorts(N, N-1);
-        test_larger_sorts(N, N);
-    }
-
-    struct S
-    {
-        int i, j;
-    };
-}
-
-int main()
-{
-    int i = 0;
-    int * res = ranges::partial_sort(&i, &i, &i);
-    CHECK(i == 0);
-    CHECK(res == &i);
-    test_larger_sorts(10);
-    test_larger_sorts(256);
-    test_larger_sorts(257);
-    test_larger_sorts(499);
-    test_larger_sorts(500);
-    test_larger_sorts(997);
-    test_larger_sorts(1000);
-    test_larger_sorts(1009);
-
-    // Check move-only types
-    {
-        std::vector<std::unique_ptr<int> > v(1000);
-        for(int j = 0; j < (int)v.size(); ++j)
-            v[j].reset(new int((int)v.size() - j - 1));
-        ranges::partial_sort(v, v.begin() + v.size()/2, indirect_less());
-        for(int j = 0; j < (int)v.size()/2; ++j)
-            CHECK(*v[j] == j);
-    }
-
-    // Check projections
-    {
-        std::vector<S> v(1000, S{});
-        for(int j = 0; (std::size_t)j < v.size(); ++j)
-        {
-            v[j].i = (int)v.size() - j - 1;
-            v[j].j = j;
-        }
-        ranges::partial_sort(v, v.begin() + v.size()/2, std::less<int>{}, &S::i);
-        for(int j = 0; (std::size_t)j < v.size()/2; ++j)
-        {
-            CHECK(v[j].i == j);
-            CHECK((std::size_t)v[j].j == v.size() - j - 1);
-        }
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/partial_sort_copy.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/partial_sort_copy.cpp
deleted file mode 100644
index f546608b..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/partial_sort_copy.cpp
+++ /dev/null
@@ -1,177 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <algorithm>
-#include <memory>
-#include <random>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/partial_sort_copy.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS
-RANGES_DIAGNOSTIC_IGNORE_SIGN_CONVERSION
-
-namespace
-{
-    std::mt19937 gen;
-
-    template<class Iter>
-    void
-    test_larger_sorts(int N, int M)
-    {
-        auto partial_sort_copy = ::make_testable_2<true, false>(ranges::partial_sort_copy);
-        int* input = new int[N];
-        int* output = new int[M];
-        for (int i = 0; i < N; ++i)
-            input[i] = i;
-        std::shuffle(input, input+N, gen);
-        partial_sort_copy(Iter(input), Iter(input+N), output, output+M).check([&](int* r)
-        {
-            int* e = output + std::min(N, M);
-            CHECK(r == e);
-            int i = 0;
-            for (int* x = output; x < e; ++x, ++i)
-                CHECK(*x == i);
-            std::shuffle(input, input+N, gen);
-        });
-        partial_sort_copy(Iter(input), Iter(input+N), output, output+M, std::greater<int>()).check([&](int* r)
-        {
-            int* e = output + std::min(N, M);
-            CHECK(r == e);
-            int i = N-1;
-            for (int* x = output; x < e; ++x, --i)
-                CHECK(*x == i);
-            std::shuffle(input, input+N, gen);
-        });
-        delete [] output;
-        delete [] input;
-    }
-
-    template<class Iter>
-    void
-    test_larger_sorts(int N)
-    {
-        test_larger_sorts<Iter>(N, 0);
-        test_larger_sorts<Iter>(N, 1);
-        test_larger_sorts<Iter>(N, 2);
-        test_larger_sorts<Iter>(N, 3);
-        test_larger_sorts<Iter>(N, N/2-1);
-        test_larger_sorts<Iter>(N, N/2);
-        test_larger_sorts<Iter>(N, N/2+1);
-        test_larger_sorts<Iter>(N, N-2);
-        test_larger_sorts<Iter>(N, N-1);
-        test_larger_sorts<Iter>(N, N);
-        test_larger_sorts<Iter>(N, N+1000);
-    }
-
-    template<class Iter>
-    void
-    test()
-    {
-        test_larger_sorts<Iter>(0, 100);
-        test_larger_sorts<Iter>(10);
-        test_larger_sorts<Iter>(256);
-        test_larger_sorts<Iter>(257);
-        test_larger_sorts<Iter>(499);
-        test_larger_sorts<Iter>(500);
-        test_larger_sorts<Iter>(997);
-        test_larger_sorts<Iter>(1000);
-        test_larger_sorts<Iter>(1009);
-    }
-
-    struct S
-    {
-        int i;
-    };
-
-    struct U
-    {
-        int i;
-        U & operator=(S s)
-        {
-            i = s.i;
-            return *this;
-        }
-    };
-}
-
-int main()
-{
-    int i = 0;
-    int * r = ranges::partial_sort_copy(&i, &i, &i, &i+5);
-    CHECK(r == &i);
-    CHECK(i == 0);
-    test<InputIterator<const int*> >();
-    test<ForwardIterator<const int*> >();
-    test<BidirectionalIterator<const int*> >();
-    test<RandomAccessIterator<const int*> >();
-    test<const int*>();
-
-    // Check projections
-    {
-        constexpr int N = 256;
-        constexpr int M = N/2-1;
-        S input[N];
-        U output[M];
-        for (int j = 0; j < N; ++j)
-            input[j].i = j;
-        std::shuffle(input, input+N, gen);
-        U * r2 = ranges::partial_sort_copy(input, output, std::less<int>(), &S::i, &U::i);
-        U* e = output + std::min(N, M);
-        CHECK(r2 == e);
-        int i2 = 0;
-        for (U* x = output; x < e; ++x, ++i2)
-            CHECK(x->i == i2);
-    }
-
-    // Check rvalue ranges
-    {
-        constexpr int N = 256;
-        constexpr int M = N/2-1;
-        S input[N];
-        U output[M];
-        for (int j = 0; j < N; ++j)
-            input[j].i = j;
-        std::shuffle(input, input+N, gen);
-        auto r0 = ranges::partial_sort_copy(input, std::move(output), std::less<int>(), &S::i, &U::i);
-        U* e = output + std::min(N, M);
-#ifndef RANGES_WORKAROUND_MSVC_573728
-        CHECK(::is_dangling(r0));
-#endif // RANGES_WORKAROUND_MSVC_573728
-
-        int i2 = 0;
-        for (U* x = output; x < e; ++x, ++i2)
-            CHECK(x->i == i2);
-
-        std::vector<U> vec(M);
-        auto r1 = ranges::partial_sort_copy(input, std::move(vec), std::less<int>(), &S::i, &U::i);
-        e = vec.data() + std::min(N, M);
-        CHECK(::is_dangling(r1));
-
-        i2 = 0;
-        for (U* x = vec.data(); x < e; ++x, ++i2)
-            CHECK(x->i == i2);
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/partition.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/partition.cpp
deleted file mode 100644
index cd55fcd4..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/partition.cpp
+++ /dev/null
@@ -1,223 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <memory>
-#include <utility>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/partition.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-RANGES_DIAGNOSTIC_IGNORE_SIGN_CONVERSION
-
-namespace
-{
-    struct is_odd
-    {
-        bool operator()(const int& i) const {return i & 1;}
-    };
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_iter()
-    {
-        // check mixed
-        int ia[] = {1, 2, 3, 4, 5, 6, 7, 8 ,9};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        Iter r = ranges::partition(Iter(ia), Sent(ia + sa), is_odd());
-        CHECK(base(r) == ia + 5);
-        for (int* i = ia; i < base(r); ++i)
-            CHECK(is_odd()(*i));
-        for (int* i = base(r); i < ia+sa; ++i)
-            CHECK(!is_odd()(*i));
-        // check empty
-        r = ranges::partition(Iter(ia), Sent(ia), is_odd());
-        CHECK(base(r) == ia);
-        // check all false
-        for (unsigned i = 0; i < sa; ++i)
-            ia[i] = 2*i;
-        r = ranges::partition(Iter(ia), Sent(ia+sa), is_odd());
-        CHECK(base(r) == ia);
-        // check all true
-        for (unsigned i = 0; i < sa; ++i)
-            ia[i] = 2*i+1;
-        r = ranges::partition(Iter(ia), Sent(ia+sa), is_odd());
-        CHECK(base(r) == ia+sa);
-        // check all true but last
-        for (unsigned i = 0; i < sa; ++i)
-            ia[i] = 2*i+1;
-        ia[sa-1] = 10;
-        r = ranges::partition(Iter(ia), Sent(ia+sa), is_odd());
-        CHECK(base(r) == ia+sa-1);
-        for (int* i = ia; i < base(r); ++i)
-            CHECK(is_odd()(*i));
-        for (int* i = base(r); i < ia+sa; ++i)
-            CHECK(!is_odd()(*i));
-        // check all true but first
-        for (unsigned i = 0; i < sa; ++i)
-            ia[i] = 2*i+1;
-        ia[0] = 10;
-        r = ranges::partition(Iter(ia), Sent(ia+sa), is_odd());
-        CHECK(base(r) == ia+sa-1);
-        for (int* i = ia; i < base(r); ++i)
-            CHECK(is_odd()(*i));
-        for (int* i = base(r); i < ia+sa; ++i)
-            CHECK(!is_odd()(*i));
-        // check all false but last
-        for (unsigned i = 0; i < sa; ++i)
-            ia[i] = 2*i;
-        ia[sa-1] = 11;
-        r = ranges::partition(Iter(ia), Sent(ia+sa), is_odd());
-        CHECK(base(r) == ia+1);
-        for (int* i = ia; i < base(r); ++i)
-            CHECK(is_odd()(*i));
-        for (int* i = base(r); i < ia+sa; ++i)
-            CHECK(!is_odd()(*i));
-        // check all false but first
-        for (unsigned i = 0; i < sa; ++i)
-            ia[i] = 2*i;
-        ia[0] = 11;
-        r = ranges::partition(Iter(ia), Sent(ia+sa), is_odd());
-        CHECK(base(r) == ia+1);
-        for (int* i = ia; i < base(r); ++i)
-            CHECK(is_odd()(*i));
-        for (int* i = base(r); i < ia+sa; ++i)
-            CHECK(!is_odd()(*i));
-    }
-
-    template<class Iter, class Sent = Iter>
-    void
-    test_range()
-    {
-        // check mixed
-        int ia[] = {1, 2, 3, 4, 5, 6, 7, 8 ,9};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        Iter r = ranges::partition(::as_lvalue(ranges::make_subrange(Iter(ia), Sent(ia + sa))), is_odd());
-        CHECK(base(r) == ia + 5);
-        for (int* i = ia; i < base(r); ++i)
-            CHECK(is_odd()(*i));
-        for (int* i = base(r); i < ia+sa; ++i)
-            CHECK(!is_odd()(*i));
-        // check empty
-        r = ranges::partition(::as_lvalue(ranges::make_subrange(Iter(ia), Sent(ia))), is_odd());
-        CHECK(base(r) == ia);
-        // check all false
-        for (unsigned i = 0; i < sa; ++i)
-            ia[i] = 2*i;
-        r = ranges::partition(::as_lvalue(ranges::make_subrange(Iter(ia), Sent(ia+sa))), is_odd());
-        CHECK(base(r) == ia);
-        // check all true
-        for (unsigned i = 0; i < sa; ++i)
-            ia[i] = 2*i+1;
-        r = ranges::partition(::as_lvalue(ranges::make_subrange(Iter(ia), Sent(ia+sa))), is_odd());
-        CHECK(base(r) == ia+sa);
-        // check all true but last
-        for (unsigned i = 0; i < sa; ++i)
-            ia[i] = 2*i+1;
-        ia[sa-1] = 10;
-        r = ranges::partition(::as_lvalue(ranges::make_subrange(Iter(ia), Sent(ia+sa))), is_odd());
-        CHECK(base(r) == ia+sa-1);
-        for (int* i = ia; i < base(r); ++i)
-            CHECK(is_odd()(*i));
-        for (int* i = base(r); i < ia+sa; ++i)
-            CHECK(!is_odd()(*i));
-        // check all true but first
-        for (unsigned i = 0; i < sa; ++i)
-            ia[i] = 2*i+1;
-        ia[0] = 10;
-        r = ranges::partition(::as_lvalue(ranges::make_subrange(Iter(ia), Sent(ia+sa))), is_odd());
-        CHECK(base(r) == ia+sa-1);
-        for (int* i = ia; i < base(r); ++i)
-            CHECK(is_odd()(*i));
-        for (int* i = base(r); i < ia+sa; ++i)
-            CHECK(!is_odd()(*i));
-        // check all false but last
-        for (unsigned i = 0; i < sa; ++i)
-            ia[i] = 2*i;
-        ia[sa-1] = 11;
-        r = ranges::partition(::as_lvalue(ranges::make_subrange(Iter(ia), Sent(ia+sa))), is_odd());
-        CHECK(base(r) == ia+1);
-        for (int* i = ia; i < base(r); ++i)
-            CHECK(is_odd()(*i));
-        for (int* i = base(r); i < ia+sa; ++i)
-            CHECK(!is_odd()(*i));
-        // check all false but first
-        for (unsigned i = 0; i < sa; ++i)
-            ia[i] = 2*i;
-        ia[0] = 11;
-        r = ranges::partition(::as_lvalue(ranges::make_subrange(Iter(ia), Sent(ia+sa))), is_odd());
-        CHECK(base(r) == ia+1);
-        for (int* i = ia; i < base(r); ++i)
-            CHECK(is_odd()(*i));
-        for (int* i = base(r); i < ia+sa; ++i)
-            CHECK(!is_odd()(*i));
-    }
-
-    struct S
-    {
-        int i;
-    };
-}
-
-int main()
-{
-    test_iter<ForwardIterator<int*> >();
-    test_iter<BidirectionalIterator<int*> >();
-    test_iter<RandomAccessIterator<int*> >();
-    test_iter<int*>();
-    test_iter<ForwardIterator<int*>, Sentinel<int*> >();
-    test_iter<BidirectionalIterator<int*>, Sentinel<int*> >();
-    test_iter<RandomAccessIterator<int*>, Sentinel<int*> >();
-
-    test_range<ForwardIterator<int*> >();
-    test_range<BidirectionalIterator<int*> >();
-    test_range<RandomAccessIterator<int*> >();
-    test_range<int*>();
-    test_range<ForwardIterator<int*>, Sentinel<int*> >();
-    test_range<BidirectionalIterator<int*>, Sentinel<int*> >();
-    test_range<RandomAccessIterator<int*>, Sentinel<int*> >();
-
-    // Test projections
-    S ia[] = {S{1}, S{2}, S{3}, S{4}, S{5}, S{6}, S{7}, S{8} ,S{9}};
-    const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-    S* r = ranges::partition(ia, is_odd(), &S::i);
-    CHECK(r == ia + 5);
-    for (S* i = ia; i < r; ++i)
-        CHECK(is_odd()(i->i));
-    for (S* i = r; i < ia+sa; ++i)
-        CHECK(!is_odd()(i->i));
-
-    // Test rvalue range
-    auto r2 = ranges::partition(std::move(ia), is_odd(), &S::i);
-#ifndef RANGES_WORKAROUND_MSVC_573728
-    CHECK(::is_dangling(r2));
-#endif // RANGES_WORKAROUND_MSVC_573728
-    std::vector<S> vec(ranges::begin(ia), ranges::end(ia));
-    auto r3 = ranges::partition(std::move(vec), is_odd(), &S::i);
-    CHECK(::is_dangling(r3));
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/partition_copy.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/partition_copy.cpp
deleted file mode 100644
index 09039d8d..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/partition_copy.cpp
+++ /dev/null
@@ -1,165 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <tuple>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/partition_copy.hpp>
-#include <range/v3/view/counted.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-struct is_odd
-{
-    bool operator()(const int& i) const {return i & 1;}
-};
-
-template<class Iter, class Sent = Iter>
-void
-test_iter()
-{
-    const int ia[] = {1, 2, 3, 4, 6, 8, 5, 7};
-    int r1[10] = {0};
-    int r2[10] = {0};
-    typedef ranges::partition_copy_result<Iter, OutputIterator<int*>,  int*> P;
-    P p = ranges::partition_copy(Iter(std::begin(ia)),
-                                 Sent(std::end(ia)),
-                                 OutputIterator<int*>(r1), r2, is_odd());
-    CHECK(p.in == Iter(std::end(ia)));
-    CHECK(p.out1.base() == r1 + 4);
-    CHECK(r1[0] == 1);
-    CHECK(r1[1] == 3);
-    CHECK(r1[2] == 5);
-    CHECK(r1[3] == 7);
-    CHECK(p.out2 == r2 + 4);
-    CHECK(r2[0] == 2);
-    CHECK(r2[1] == 4);
-    CHECK(r2[2] == 6);
-    CHECK(r2[3] == 8);
-}
-
-template<class Iter, class Sent = Iter>
-void
-test_range()
-{
-    const int ia[] = {1, 2, 3, 4, 6, 8, 5, 7};
-    int r1[10] = {0};
-    int r2[10] = {0};
-    typedef ranges::partition_copy_result<Iter, OutputIterator<int*>,  int*> P;
-    P p = ranges::partition_copy(::as_lvalue(ranges::make_subrange(Iter(std::begin(ia)),
-                                                           Sent(std::end(ia)))),
-                                 OutputIterator<int*>(r1), r2, is_odd());
-    CHECK(p.in == Iter(std::end(ia)));
-    CHECK(p.out1.base() == r1 + 4);
-    CHECK(r1[0] == 1);
-    CHECK(r1[1] == 3);
-    CHECK(r1[2] == 5);
-    CHECK(r1[3] == 7);
-    CHECK(p.out2 == r2 + 4);
-    CHECK(r2[0] == 2);
-    CHECK(r2[1] == 4);
-    CHECK(r2[2] == 6);
-    CHECK(r2[3] == 8);
-}
-
-struct S
-{
-    int i;
-};
-
-void test_proj()
-{
-    // Test projections
-    const S ia[] = {S{1}, S{2}, S{3}, S{4}, S{6}, S{8}, S{5}, S{7}};
-    S r1[10] = {S{0}};
-    S r2[10] = {S{0}};
-    typedef ranges::partition_copy_result<S const *, S*,  S*> P;
-    P p = ranges::partition_copy(ia, r1, r2, is_odd(), &S::i);
-    CHECK(p.in == std::end(ia));
-    CHECK(p.out1 == r1 + 4);
-    CHECK(r1[0].i == 1);
-    CHECK(r1[1].i == 3);
-    CHECK(r1[2].i == 5);
-    CHECK(r1[3].i == 7);
-    CHECK(p.out2 == r2 + 4);
-    CHECK(r2[0].i == 2);
-    CHECK(r2[1].i == 4);
-    CHECK(r2[2].i == 6);
-    CHECK(r2[3].i == 8);
-}
-
-void test_rvalue()
-{
-    // Test rvalue ranges
-    const S ia[] = {S{1}, S{2}, S{3}, S{4}, S{6}, S{8}, S{5}, S{7}};
-    S r1[10] = {};
-    S r2[10] = {};
-    auto p = ranges::partition_copy(std::move(ia), r1, r2, is_odd(), &S::i);
-#ifndef RANGES_WORKAROUND_MSVC_573728
-    CHECK(::is_dangling(p.in));
-#endif
-    CHECK(p.out1 == r1 + 4);
-    CHECK(r1[0].i == 1);
-    CHECK(r1[1].i == 3);
-    CHECK(r1[2].i == 5);
-    CHECK(r1[3].i == 7);
-    CHECK(p.out2 == r2 + 4);
-    CHECK(r2[0].i == 2);
-    CHECK(r2[1].i == 4);
-    CHECK(r2[2].i == 6);
-    CHECK(r2[3].i == 8);
-
-    std::fill(r1 + 0, r1 + 10, S{});
-    std::fill(r2 + 0, r2 + 10, S{});
-    std::vector<S> vec(ranges::begin(ia), ranges::end(ia));
-    auto q = ranges::partition_copy(std::move(vec), r1, r2, is_odd(), &S::i);
-#ifndef RANGES_WORKAROUND_MSVC_573728
-    CHECK(::is_dangling(q.in));
-#endif
-    CHECK(q.out1 == r1 + 4);
-    CHECK(r1[0].i == 1);
-    CHECK(r1[1].i == 3);
-    CHECK(r1[2].i == 5);
-    CHECK(r1[3].i == 7);
-    CHECK(q.out2 == r2 + 4);
-    CHECK(r2[0].i == 2);
-    CHECK(r2[1].i == 4);
-    CHECK(r2[2].i == 6);
-    CHECK(r2[3].i == 8);
-}
-
-int main()
-{
-    test_iter<InputIterator<const int*> >();
-    test_iter<InputIterator<const int*>, Sentinel<const int*>>();
-
-    test_range<InputIterator<const int*> >();
-    test_range<InputIterator<const int*>, Sentinel<const int*>>();
-
-    test_proj();
-    test_rvalue();
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/partition_point.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/partition_point.cpp
deleted file mode 100644
index bdd2bc4f..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/partition_point.cpp
+++ /dev/null
@@ -1,229 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <memory>
-#include <utility>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/partition_point.hpp>
-#include <range/v3/view/counted.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-struct is_odd
-{
-    bool operator()(const int& i) const {return i & 1;}
-};
-
-template<class Iter, class Sent = Iter>
-void
-test_iter()
-{
-    {
-        const int ia[] = {2, 4, 6, 8, 10};
-        CHECK(ranges::partition_point(Iter(ranges::begin(ia)),
-                                      Sent(ranges::end(ia)),
-                                      is_odd()) == Iter(ia));
-    }
-    {
-        const int ia[] = {1, 2, 4, 6, 8};
-        CHECK(ranges::partition_point(Iter(ranges::begin(ia)),
-                                      Sent(ranges::end(ia)),
-                                      is_odd()) == Iter(ia + 1));
-    }
-    {
-        const int ia[] = {1, 3, 2, 4, 6};
-        CHECK(ranges::partition_point(Iter(ranges::begin(ia)),
-                                      Sent(ranges::end(ia)),
-                                      is_odd()) == Iter(ia + 2));
-    }
-    {
-        const int ia[] = {1, 3, 5, 2, 4, 6};
-        CHECK(ranges::partition_point(Iter(ranges::begin(ia)),
-                                      Sent(ranges::end(ia)),
-                                      is_odd()) == Iter(ia + 3));
-    }
-    {
-        const int ia[] = {1, 3, 5, 7, 2, 4};
-        CHECK(ranges::partition_point(Iter(ranges::begin(ia)),
-                                      Sent(ranges::end(ia)),
-                                      is_odd()) == Iter(ia + 4));
-    }
-    {
-        const int ia[] = {1, 3, 5, 7, 9, 2};
-        CHECK(ranges::partition_point(Iter(ranges::begin(ia)),
-                                      Sent(ranges::end(ia)),
-                                      is_odd()) == Iter(ia + 5));
-    }
-    {
-        const int ia[] = {1, 3, 5, 7, 9, 11};
-        CHECK(ranges::partition_point(Iter(ranges::begin(ia)),
-                                      Sent(ranges::end(ia)),
-                                      is_odd()) == Iter(ia + 6));
-    }
-    {
-        const int ia[] = {1, 3, 5, 2, 4, 6, 7};
-        CHECK(ranges::partition_point(Iter(ranges::begin(ia)),
-                                      Sent(ranges::begin(ia)),
-                                      is_odd()) == Iter(ia));
-    }
-}
-
-template<class Iter, class Sent = Iter>
-void
-test_range()
-{
-    {
-        const int ia[] = {2, 4, 6, 8, 10};
-        CHECK(ranges::partition_point(::as_lvalue(ranges::make_subrange(Iter(ranges::begin(ia)),
-                                                                Sent(ranges::end(ia)))),
-                                      is_odd()) == Iter(ia));
-    }
-    {
-        const int ia[] = {1, 2, 4, 6, 8};
-        CHECK(ranges::partition_point(::as_lvalue(ranges::make_subrange(Iter(ranges::begin(ia)),
-                                                                Sent(ranges::end(ia)))),
-                                      is_odd()) == Iter(ia + 1));
-    }
-    {
-        const int ia[] = {1, 3, 2, 4, 6};
-        CHECK(ranges::partition_point(::as_lvalue(ranges::make_subrange(Iter(ranges::begin(ia)),
-                                                                Sent(ranges::end(ia)))),
-                                      is_odd()) == Iter(ia + 2));
-    }
-    {
-        const int ia[] = {1, 3, 5, 2, 4, 6};
-        CHECK(ranges::partition_point(::as_lvalue(ranges::make_subrange(Iter(ranges::begin(ia)),
-                                                                Sent(ranges::end(ia)))),
-                                      is_odd()) == Iter(ia + 3));
-    }
-    {
-        const int ia[] = {1, 3, 5, 7, 2, 4};
-        CHECK(ranges::partition_point(::as_lvalue(ranges::make_subrange(Iter(ranges::begin(ia)),
-                                                                Sent(ranges::end(ia)))),
-                                      is_odd()) == Iter(ia + 4));
-    }
-    {
-        const int ia[] = {1, 3, 5, 7, 9, 2};
-        CHECK(ranges::partition_point(::as_lvalue(ranges::make_subrange(Iter(ranges::begin(ia)),
-                                                                Sent(ranges::end(ia)))),
-                                      is_odd()) == Iter(ia + 5));
-    }
-    {
-        const int ia[] = {1, 3, 5, 7, 9, 11};
-        CHECK(ranges::partition_point(::as_lvalue(ranges::make_subrange(Iter(ranges::begin(ia)),
-                                                                Sent(ranges::end(ia)))),
-                                      is_odd()) == Iter(ia + 6));
-    }
-    {
-        const int ia[] = {1, 3, 5, 2, 4, 6, 7};
-        CHECK(ranges::partition_point(::as_lvalue(ranges::make_subrange(Iter(ranges::begin(ia)),
-                                                                Sent(ranges::begin(ia)))),
-                                      is_odd()) == Iter(ia));
-    }
-
-    // An rvalue range
-    {
-        const int ia[] = {1, 3, 5, 7, 9, 2};
-        CHECK(ranges::partition_point(ranges::make_subrange(Iter(ranges::begin(ia)),
-                                                         Sent(ranges::end(ia))),
-                                      is_odd()) == Iter(ia + 5));
-    }
-}
-
-template<class Iter>
-void
-test_counted()
-{
-    {
-        const int ia[] = {2, 4, 6, 8, 10};
-        CHECK(ranges::partition_point(::as_lvalue(ranges::views::counted(Iter(ranges::begin(ia)),
-                                                                        ranges::size(ia))),
-                                      is_odd()) == ranges::counted_iterator<Iter>(Iter(ia), ranges::size(ia)));
-    }
-    {
-        const int ia[] = {1, 2, 4, 6, 8};
-        CHECK(ranges::partition_point(::as_lvalue(ranges::views::counted(Iter(ranges::begin(ia)),
-                                                                        ranges::size(ia))),
-                                      is_odd()) == ranges::counted_iterator<Iter>(Iter(ia + 1), ranges::size(ia) - 1));
-    }
-    {
-        const int ia[] = {1, 3, 2, 4, 6};
-        CHECK(ranges::partition_point(::as_lvalue(ranges::views::counted(Iter(ranges::begin(ia)),
-                                                                        ranges::size(ia))),
-                                      is_odd()) == ranges::counted_iterator<Iter>(Iter(ia + 2), ranges::size(ia) - 2));
-    }
-    {
-        const int ia[] = {1, 3, 5, 2, 4, 6};
-        CHECK(ranges::partition_point(::as_lvalue(ranges::views::counted(Iter(ranges::begin(ia)),
-                                                                        ranges::size(ia))),
-                                      is_odd()) == ranges::counted_iterator<Iter>(Iter(ia + 3), ranges::size(ia) - 3));
-    }
-    {
-        const int ia[] = {1, 3, 5, 7, 2, 4};
-        CHECK(ranges::partition_point(::as_lvalue(ranges::views::counted(Iter(ranges::begin(ia)),
-                                                                        ranges::size(ia))),
-                                      is_odd()) == ranges::counted_iterator<Iter>(Iter(ia + 4), ranges::size(ia) - 4));
-    }
-    {
-        const int ia[] = {1, 3, 5, 7, 9, 2};
-        CHECK(ranges::partition_point(::as_lvalue(ranges::views::counted(Iter(ranges::begin(ia)),
-                                                                        ranges::size(ia))),
-                                      is_odd()) == ranges::counted_iterator<Iter>(Iter(ia + 5), ranges::size(ia) - 5));
-    }
-    {
-        const int ia[] = {1, 3, 5, 7, 9, 11};
-        CHECK(ranges::partition_point(::as_lvalue(ranges::views::counted(Iter(ranges::begin(ia)),
-                                                                        ranges::size(ia))),
-                                      is_odd()) == ranges::counted_iterator<Iter>(Iter(ia + 6), ranges::size(ia) - 6));
-    }
-    {
-        const int ia[] = {1, 3, 5, 2, 4, 6, 7};
-        CHECK(ranges::partition_point(::as_lvalue(ranges::views::counted(Iter(ranges::begin(ia)),
-                                                                        0)),
-                                      is_odd()) == ranges::counted_iterator<Iter>(Iter(ia), 0));
-    }
-}
-
-struct S
-{
-    int i;
-};
-
-int main()
-{
-    test_iter<ForwardIterator<const int*> >();
-    test_iter<ForwardIterator<const int*>, Sentinel<const int*>>();
-
-    test_range<ForwardIterator<const int*> >();
-    test_range<ForwardIterator<const int*>, Sentinel<const int*>>();
-
-    test_counted<ForwardIterator<const int*> >();
-
-    // Test projections
-    const S ia[] = {S{1}, S{3}, S{5}, S{2}, S{4}, S{6}};
-    CHECK(ranges::partition_point(ia, is_odd(), &S::i) == ia + 3);
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/pop_heap.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/pop_heap.cpp
deleted file mode 100644
index 873b9849..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/pop_heap.cpp
+++ /dev/null
@@ -1,270 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <memory>
-#include <random>
-#include <algorithm>
-#include <functional>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/heap_algorithm.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS
-RANGES_DIAGNOSTIC_IGNORE_SIGN_CONVERSION
-
-namespace
-{
-    std::mt19937 gen;
-
-    void test_1(int N)
-    {
-        int* ia = new int[N];
-        for (int i = 0; i < N; ++i)
-            ia[i] = i;
-        std::shuffle(ia, ia+N, gen);
-        std::make_heap(ia, ia+N);
-        for (int i = N; i > 0; --i)
-        {
-            CHECK(ranges::pop_heap(ia, ia+i) == ia+i);
-            CHECK(std::is_heap(ia, ia+i-1));
-        }
-        CHECK(ranges::pop_heap(ia, ia) == ia);
-        delete[] ia;
-    }
-
-    void test_2(int N)
-    {
-        int* ia = new int[N];
-        for (int i = 0; i < N; ++i)
-            ia[i] = i;
-        std::shuffle(ia, ia+N, gen);
-        std::make_heap(ia, ia+N);
-        for (int i = N; i > 0; --i)
-        {
-            CHECK(ranges::pop_heap(ia, Sentinel<int*>(ia+i)) == ia+i);
-            CHECK(std::is_heap(ia, ia+i-1));
-        }
-        CHECK(ranges::pop_heap(ia, ia) == ia);
-        delete[] ia;
-    }
-
-    void test_3(int N)
-    {
-        int* ia = new int[N];
-        for (int i = 0; i < N; ++i)
-            ia[i] = i;
-        std::shuffle(ia, ia+N, gen);
-        std::make_heap(ia, ia+N);
-        for (int i = N; i > 0; --i)
-        {
-            CHECK(ranges::pop_heap(::as_lvalue(ranges::make_subrange(ia, ia+i))) == ia+i);
-            CHECK(std::is_heap(ia, ia+i-1));
-        }
-        std::shuffle(ia, ia+N, gen);
-        std::make_heap(ia, ia+N);
-        for (int i = N; i > 0; --i)
-        {
-            CHECK(ranges::pop_heap(ranges::make_subrange(ia, ia+i)) == ia+i);
-            CHECK(std::is_heap(ia, ia+i-1));
-        }
-        CHECK(ranges::pop_heap(ia, ia) == ia);
-        delete[] ia;
-    }
-
-    void test_4(int N)
-    {
-        int* ia = new int[N];
-        for (int i = 0; i < N; ++i)
-            ia[i] = i;
-        std::shuffle(ia, ia+N, gen);
-        std::make_heap(ia, ia+N);
-        for (int i = N; i > 0; --i)
-        {
-            CHECK(ranges::pop_heap(::as_lvalue(ranges::make_subrange(ia, Sentinel<int*>(ia+i)))) == ia+i);
-            CHECK(std::is_heap(ia, ia+i-1));
-        }
-        std::shuffle(ia, ia+N, gen);
-        std::make_heap(ia, ia+N);
-        for (int i = N; i > 0; --i)
-        {
-            CHECK(ranges::pop_heap(ranges::make_subrange(ia, Sentinel<int*>(ia+i))) == ia+i);
-            CHECK(std::is_heap(ia, ia+i-1));
-        }
-        CHECK(ranges::pop_heap(ia, ia) == ia);
-        delete[] ia;
-    }
-
-    void test_5(int N)
-    {
-        int* ia = new int[N];
-        for (int i = 0; i < N; ++i)
-            ia[i] = i;
-        std::shuffle(ia, ia+N, gen);
-        std::make_heap(ia, ia+N, std::greater<int>());
-        for (int i = N; i > 0; --i)
-        {
-            CHECK(ranges::pop_heap(ia, ia+i, std::greater<int>()) == ia+i);
-            CHECK(std::is_heap(ia, ia+i-1, std::greater<int>()));
-        }
-        CHECK(ranges::pop_heap(ia, ia, std::greater<int>()) == ia);
-        delete[] ia;
-    }
-
-    void test_6(int N)
-    {
-        int* ia = new int[N];
-        for (int i = 0; i < N; ++i)
-            ia[i] = i;
-        std::shuffle(ia, ia+N, gen);
-        std::make_heap(ia, ia+N, std::greater<int>());
-        for (int i = N; i > 0; --i)
-        {
-            CHECK(ranges::pop_heap(ia, Sentinel<int*>(ia+i), std::greater<int>()) == ia+i);
-            CHECK(std::is_heap(ia, ia+i-1, std::greater<int>()));
-        }
-        CHECK(ranges::pop_heap(ia, Sentinel<int*>(ia), std::greater<int>()) == ia);
-        delete[] ia;
-    }
-
-    void test_7(int N)
-    {
-        int* ia = new int[N];
-        for (int i = 0; i < N; ++i)
-            ia[i] = i;
-        std::shuffle(ia, ia+N, gen);
-        std::make_heap(ia, ia+N, std::greater<int>());
-        for (int i = N; i > 0; --i)
-        {
-            CHECK(ranges::pop_heap(::as_lvalue(ranges::make_subrange(ia, ia+i)), std::greater<int>()) == ia+i);
-            CHECK(std::is_heap(ia, ia+i-1, std::greater<int>()));
-        }
-        std::shuffle(ia, ia+N, gen);
-        std::make_heap(ia, ia+N, std::greater<int>());
-        for (int i = N; i > 0; --i)
-        {
-            CHECK(ranges::pop_heap(ranges::make_subrange(ia, ia+i), std::greater<int>()) == ia+i);
-            CHECK(std::is_heap(ia, ia+i-1, std::greater<int>()));
-        }
-        CHECK(ranges::pop_heap(ia, ia, std::greater<int>()) == ia);
-        delete[] ia;
-    }
-
-    void test_8(int N)
-    {
-        int* ia = new int[N];
-        for (int i = 0; i < N; ++i)
-            ia[i] = i;
-        std::shuffle(ia, ia+N, gen);
-        std::make_heap(ia, ia+N, std::greater<int>());
-        for (int i = N; i > 0; --i)
-        {
-            CHECK(ranges::pop_heap(::as_lvalue(ranges::make_subrange(ia, Sentinel<int*>(ia+i))), std::greater<int>()) == ia+i);
-            CHECK(std::is_heap(ia, ia+i-1, std::greater<int>()));
-        }
-        std::shuffle(ia, ia+N, gen);
-        std::make_heap(ia, ia+N, std::greater<int>());
-        for (int i = N; i > 0; --i)
-        {
-            CHECK(ranges::pop_heap(ranges::make_subrange(ia, Sentinel<int*>(ia+i)), std::greater<int>()) == ia+i);
-            CHECK(std::is_heap(ia, ia+i-1, std::greater<int>()));
-        }
-        CHECK(ranges::pop_heap(ia, Sentinel<int*>(ia), std::greater<int>()) == ia);
-        delete[] ia;
-    }
-
-    struct indirect_less
-    {
-        template<class P>
-        bool operator()(const P& x, const P& y)
-            {return *x < *y;}
-    };
-
-    void test_9(int N)
-    {
-        std::unique_ptr<int>* ia = new std::unique_ptr<int>[N];
-        for (int i = 0; i < N; ++i)
-            ia[i].reset(new int(i));
-        std::shuffle(ia, ia+N, gen);
-        std::make_heap(ia, ia+N, indirect_less());
-        for (int i = N; i > 0; --i)
-        {
-            CHECK(ranges::pop_heap(ia, ia+i, indirect_less()) == ia+i);
-            CHECK(std::is_heap(ia, ia+i-1, indirect_less()));
-        }
-        delete[] ia;
-    }
-
-    template<typename T>
-    struct construct
-    {
-        template<typename ...Us>
-        T operator()(Us &&... us) const
-        {
-            return T{((Us &&)us)...};
-        }
-    };
-
-    struct S
-    {
-        int i;
-    };
-
-    void test_10(int N)
-    {
-        int* ia = new int[N];
-        S* ib = new S[N];
-        for (int i = 0; i < N; ++i)
-            ia[i] = i;
-        std::shuffle(ia, ia+N, gen);
-        std::make_heap(ia, ia+N);
-        std::transform(ia, ia+N, ib, construct<S>());
-        for (int i = N; i > 0; --i)
-        {
-            CHECK(ranges::pop_heap(ib, ib+i, std::less<int>(), &S::i) == ib+i);
-            std::transform(ib, ib+i, ia, std::mem_fn(&S::i));
-            CHECK(std::is_heap(ia, ia+i-1));
-        }
-        CHECK(ranges::pop_heap(ib, ib, std::less<int>(), &S::i) == ib);
-        delete[] ia;
-        delete[] ib;
-    }
-}
-
-int main()
-{
-    test_1(1000);
-    test_2(1000);
-    test_3(1000);
-    test_4(1000);
-    test_5(1000);
-    test_6(1000);
-    test_7(1000);
-    test_8(1000);
-    test_9(1000);
-    test_10(1000);
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/prev_permutation.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/prev_permutation.cpp
deleted file mode 100644
index 42743925..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/prev_permutation.cpp
+++ /dev/null
@@ -1,217 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <cstring>
-#include <utility>
-#include <algorithm>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/permutation.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-int factorial(int x)
-{
-    int r = 1;
-    for (; x; --x)
-        r *= x;
-    return r;
-}
-
-template<typename Iter, typename Sent = Iter>
-void test_iter()
-{
-    int ia[] = {6, 5, 4, 3, 2, 1};
-    const int sa = sizeof(ia)/sizeof(ia[0]);
-    int prev[sa];
-    for (int e = 0; e <= sa; ++e)
-    {
-        int count = 0;
-        bool x;
-        do
-        {
-            std::copy(ia, ia+e, prev);
-            x = ranges::prev_permutation(Iter(ia), Sent(ia+e));
-            if(e > 1)
-            {
-                if(!x)
-                    CHECK(std::lexicographical_compare(prev, prev+e, ia, ia+e));
-                else
-                    CHECK(std::lexicographical_compare(ia, ia+e, prev, prev+e));
-            }
-            ++count;
-        } while(x);
-        CHECK(count == factorial(e));
-    }
-}
-
-template<typename Iter, typename Sent = Iter>
-void test_range()
-{
-    int ia[] = {6, 5, 4, 3, 2, 1};
-    const int sa = sizeof(ia)/sizeof(ia[0]);
-    int prev[sa];
-    for (int e = 0; e <= sa; ++e)
-    {
-        int count = 0;
-        bool x;
-        do
-        {
-            std::copy(ia, ia+e, prev);
-            x = ranges::prev_permutation(ranges::make_subrange(Iter(ia), Sent(ia+e)));
-            if(e > 1)
-            {
-                if(!x)
-                    CHECK(std::lexicographical_compare(prev, prev+e, ia, ia+e));
-                else
-                    CHECK(std::lexicographical_compare(ia, ia+e, prev, prev+e));
-            }
-            ++count;
-        } while(x);
-        CHECK(count == factorial(e));
-    }
-}
-
-template<typename Iter, typename Sent = Iter>
-void test_iter_comp()
-{
-    typedef std::greater<int> C;
-    int ia[] = {1, 2, 3, 4, 5, 6};
-    const int sa = sizeof(ia)/sizeof(ia[0]);
-    int prev[sa];
-    for(int e = 0; e <= sa; ++e)
-    {
-        int count = 0;
-        bool x;
-        do
-        {
-            std::copy(ia, ia+e, prev);
-            x = ranges::prev_permutation(Iter(ia), Sent(ia+e), C());
-            if(e > 1)
-            {
-                if(!x)
-                    CHECK(std::lexicographical_compare(prev, prev+e, ia, ia+e, C()));
-                else
-                    CHECK(std::lexicographical_compare(ia, ia+e, prev, prev+e, C()));
-            }
-            ++count;
-        } while (x);
-        CHECK(count == factorial(e));
-    }
-}
-
-template<typename Iter, typename Sent = Iter>
-void test_range_comp()
-{
-    typedef std::greater<int> C;
-    int ia[] = {1, 2, 3, 4, 5, 6};
-    const int sa = sizeof(ia)/sizeof(ia[0]);
-    int prev[sa];
-    for(int e = 0; e <= sa; ++e)
-    {
-        int count = 0;
-        bool x;
-        do
-        {
-            std::copy(ia, ia+e, prev);
-            x = ranges::prev_permutation(ranges::make_subrange(Iter(ia), Sent(ia+e)), C());
-            if(e > 1)
-            {
-                if(!x)
-                    CHECK(std::lexicographical_compare(prev, prev+e, ia, ia+e, C()));
-                else
-                    CHECK(std::lexicographical_compare(ia, ia+e, prev, prev+e, C()));
-            }
-            ++count;
-        } while (x);
-            CHECK(count == factorial(e));
-    }
-}
-
-struct c_str
-{
-    char const * value;
-
-    friend bool operator==(c_str a, c_str b)
-    {
-        return 0 == std::strcmp(a.value, b.value);
-    }
-
-    friend bool operator!=(c_str a, c_str b)
-    {
-        return !(a == b);
-    }
-};
-
-// For debugging the projection test
-std::ostream &operator<<(std::ostream& sout, std::pair<int, c_str> p)
-{
-    return sout << "{" << p.first << "," << p.second.value << "}";
-}
-
-int main()
-{
-    test_iter<BidirectionalIterator<int*> >();
-    test_iter<RandomAccessIterator<int*> >();
-    test_iter<int*>();
-
-    test_iter<BidirectionalIterator<int*>, Sentinel<int*> >();
-    test_iter<RandomAccessIterator<int*>, Sentinel<int*> >();
-
-    test_iter_comp<BidirectionalIterator<int*> >();
-    test_iter_comp<RandomAccessIterator<int*> >();
-    test_iter_comp<int*>();
-
-    test_iter_comp<BidirectionalIterator<int*>, Sentinel<int*> >();
-    test_iter_comp<RandomAccessIterator<int*>, Sentinel<int*> >();
-
-    test_range<BidirectionalIterator<int*> >();
-    test_range<RandomAccessIterator<int*> >();
-    test_range<int*>();
-
-    test_range<BidirectionalIterator<int*>, Sentinel<int*> >();
-    test_range<RandomAccessIterator<int*>, Sentinel<int*> >();
-
-    test_range_comp<BidirectionalIterator<int*> >();
-    test_range_comp<RandomAccessIterator<int*> >();
-    test_range_comp<int*>();
-
-    test_range_comp<BidirectionalIterator<int*>, Sentinel<int*> >();
-    test_range_comp<RandomAccessIterator<int*>, Sentinel<int*> >();
-
-    // Test projection
-
-    using C = std::less<int>;
-    using I = std::initializer_list<std::pair<int, c_str>>;
-    std::pair<int, c_str> ia[] = {{6, {"six"}}, {5,{"five"}}, {4,{"four"}}, {3,{"three"}}, {2,{"two"}}, {1,{"one"}}};
-    CHECK(ranges::prev_permutation(ia, C(), &std::pair<int,c_str>::first));
-    ::check_equal(ia, I{{6, {"six"}}, {5,{"five"}}, {4,{"four"}}, {3,{"three"}}, {1,{"one"}}, {2,{"two"}}});
-    CHECK(ranges::prev_permutation(ia, C(), &std::pair<int,c_str>::first));
-    ::check_equal(ia, I{{6, {"six"}}, {5,{"five"}}, {4,{"four"}}, {2,{"two"}}, {3,{"three"}}, {1,{"one"}}});
-    CHECK(ranges::prev_permutation(ia, C(), &std::pair<int,c_str>::first));
-    ::check_equal(ia, I{{6, {"six"}}, {5,{"five"}}, {4,{"four"}}, {2,{"two"}}, {1,{"one"}}, {3,{"three"}}});
-    // etc..
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/push_heap.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/push_heap.cpp
deleted file mode 100644
index 45e344a8..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/push_heap.cpp
+++ /dev/null
@@ -1,154 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-// <algorithm>
-
-// template<random_access_iterator Iter>
-//   requires ShuffleIterator<Iter>
-//         && LessThanComparable<Iter::value_type>
-//   void
-//   push_heap(Iter first, Iter last);
-
-#include <memory>
-#include <random>
-#include <algorithm>
-#include <functional>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/heap_algorithm.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS
-RANGES_DIAGNOSTIC_IGNORE_SIGN_CONVERSION
-
-namespace
-{
-    std::mt19937 gen;
-
-    void test(int N)
-    {
-        auto push_heap = make_testable_1(ranges::push_heap);
-
-        int* ia = new int[N];
-        for (int i = 0; i < N; ++i)
-            ia[i] = i;
-        std::shuffle(ia, ia+N, gen);
-        for (int i = 0; i <= N; ++i)
-        {
-            push_heap(ia, ia+i).check([&](int *r){CHECK(r == ia + i);});
-            CHECK(std::is_heap(ia, ia+i));
-        }
-        delete[] ia;
-    }
-
-    void test_comp(int N)
-    {
-        auto push_heap = make_testable_1(ranges::push_heap);
-
-        int* ia = new int[N];
-        for (int i = 0; i < N; ++i)
-            ia[i] = i;
-        std::shuffle(ia, ia+N, gen);
-        for (int i = 0; i <= N; ++i)
-        {
-            push_heap(ia, ia+i, std::greater<int>()).check([&](int *r){CHECK(r == ia+i);});
-            CHECK(std::is_heap(ia, ia+i, std::greater<int>()));
-        }
-        delete[] ia;
-    }
-
-    struct S
-    {
-        int i;
-    };
-
-    void test_proj(int N)
-    {
-        auto push_heap = make_testable_1(ranges::push_heap);
-
-        S* ia = new S[N];
-        int* ib = new int[N];
-        for (int i = 0; i < N; ++i)
-            ia[i].i = i;
-        std::shuffle(ia, ia+N, gen);
-        for (int i = 0; i <= N; ++i)
-        {
-            push_heap(ia, ia+i, std::greater<int>(), &S::i).check([&](S *r){CHECK(r == ia+i);});
-            std::transform(ia, ia+i, ib, std::mem_fn(&S::i));
-            CHECK(std::is_heap(ib, ib+i, std::greater<int>()));
-        }
-        delete[] ia;
-        delete[] ib;
-    }
-
-    struct indirect_less
-    {
-        template<class P>
-        bool operator()(const P& x, const P& y)
-            {return *x < *y;}
-    };
-
-    void test_move_only(int N)
-    {
-        auto const push_heap = make_testable_1(ranges::push_heap);
-        std::unique_ptr<int>* ia = new std::unique_ptr<int>[N];
-        for (int i = 0; i < N; ++i)
-            ia[i].reset(new int(i));
-        std::shuffle(ia, ia+N, gen);
-        for (int i = 0; i <= N; ++i)
-        {
-            push_heap(ia, ia+i, indirect_less()).check([&](std::unique_ptr<int> *r){CHECK(r == ia+i);});
-            CHECK(std::is_heap(ia, ia+i, indirect_less()));
-        }
-        delete[] ia;
-    }
-}
-
-int main()
-{
-    test(1000);
-    test_comp(1000);
-    test_proj(1000);
-    test_move_only(1000);
-
-    {
-        int const N = 1000;
-        S* ia = new S[N];
-        int* ib = new int[N];
-        for (int i = 0; i < N; ++i)
-            ia[i].i = i;
-        std::shuffle(ia, ia+N, gen);
-        for (int i = 0; i <= N; ++i)
-        {
-            CHECK(ranges::push_heap(ranges::make_subrange(ia, ia+i), std::greater<int>(), &S::i) == ia+i);
-            std::transform(ia, ia+i, ib, std::mem_fn(&S::i));
-            CHECK(std::is_heap(ib, ib+i, std::greater<int>()));
-        }
-        delete[] ia;
-        delete[] ib;
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/remove.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/remove.cpp
deleted file mode 100644
index cdd25624..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/remove.cpp
+++ /dev/null
@@ -1,185 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <memory>
-#include <utility>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/remove.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-template<class Iter, class Sent = Iter>
-void
-test_iter()
-{
-    int ia[] = {0, 1, 2, 3, 4, 2, 3, 4, 2};
-    constexpr auto sa = ranges::size(ia);
-    Iter r = ranges::remove(Iter(ia), Sent(ia+sa), 2);
-    CHECK(base(r) == ia + sa-3);
-    CHECK(ia[0] == 0);
-    CHECK(ia[1] == 1);
-    CHECK(ia[2] == 3);
-    CHECK(ia[3] == 4);
-    CHECK(ia[4] == 3);
-    CHECK(ia[5] == 4);
-}
-
-template<class Iter, class Sent = Iter>
-void
-test_range()
-{
-    int ia[] = {0, 1, 2, 3, 4, 2, 3, 4, 2};
-    constexpr auto sa = ranges::size(ia);
-    Iter r = ranges::remove(ranges::make_subrange(Iter(ia), Sent(ia+sa)), 2);
-    CHECK(base(r) == ia + sa-3);
-    CHECK(ia[0] == 0);
-    CHECK(ia[1] == 1);
-    CHECK(ia[2] == 3);
-    CHECK(ia[3] == 4);
-    CHECK(ia[4] == 3);
-    CHECK(ia[5] == 4);
-}
-
-template<class Iter, class Sent = Iter>
-void
-test_iter_rvalue()
-{
-    constexpr unsigned sa = 9;
-    std::unique_ptr<int> ia[sa];
-    ia[0].reset(new int(0));
-    ia[1].reset(new int(1));
-    ia[3].reset(new int(3));
-    ia[4].reset(new int(4));
-    ia[6].reset(new int(3));
-    ia[7].reset(new int(4));
-    Iter r = ranges::remove(Iter(ia), Sent(ia+sa), std::unique_ptr<int>());
-    CHECK(base(r) == ia + sa-3);
-    CHECK(*ia[0] == 0);
-    CHECK(*ia[1] == 1);
-    CHECK(*ia[2] == 3);
-    CHECK(*ia[3] == 4);
-    CHECK(*ia[4] == 3);
-    CHECK(*ia[5] == 4);
-}
-
-template<class Iter, class Sent = Iter>
-void
-test_range_rvalue()
-{
-    constexpr unsigned sa = 9;
-    std::unique_ptr<int> ia[sa];
-    ia[0].reset(new int(0));
-    ia[1].reset(new int(1));
-    ia[3].reset(new int(3));
-    ia[4].reset(new int(4));
-    ia[6].reset(new int(3));
-    ia[7].reset(new int(4));
-    Iter r = ranges::remove(ranges::make_subrange(Iter(ia), Sent(ia+sa)), std::unique_ptr<int>());
-    CHECK(base(r) == ia + sa-3);
-    CHECK(*ia[0] == 0);
-    CHECK(*ia[1] == 1);
-    CHECK(*ia[2] == 3);
-    CHECK(*ia[3] == 4);
-    CHECK(*ia[4] == 3);
-    CHECK(*ia[5] == 4);
-}
-
-struct S
-{
-    int i;
-};
-
-int main()
-{
-    test_iter<ForwardIterator<int*> >();
-    test_iter<BidirectionalIterator<int*> >();
-    test_iter<RandomAccessIterator<int*> >();
-    test_iter<int*>();
-    test_iter<ForwardIterator<int*>, Sentinel<int*>>();
-    test_iter<BidirectionalIterator<int*>, Sentinel<int*>>();
-    test_iter<RandomAccessIterator<int*>, Sentinel<int*>>();
-
-    test_range<ForwardIterator<int*> >();
-    test_range<BidirectionalIterator<int*> >();
-    test_range<RandomAccessIterator<int*> >();
-    test_range<int*>();
-    test_range<ForwardIterator<int*>, Sentinel<int*>>();
-    test_range<BidirectionalIterator<int*>, Sentinel<int*>>();
-    test_range<RandomAccessIterator<int*>, Sentinel<int*>>();
-
-    test_iter_rvalue<ForwardIterator<std::unique_ptr<int>*> >();
-    test_iter_rvalue<BidirectionalIterator<std::unique_ptr<int>*> >();
-    test_iter_rvalue<RandomAccessIterator<std::unique_ptr<int>*> >();
-    test_iter_rvalue<std::unique_ptr<int>*>();
-    test_iter_rvalue<ForwardIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*>>();
-    test_iter_rvalue<BidirectionalIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*>>();
-    test_iter_rvalue<RandomAccessIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*>>();
-
-    test_range_rvalue<ForwardIterator<std::unique_ptr<int>*> >();
-    test_range_rvalue<BidirectionalIterator<std::unique_ptr<int>*> >();
-    test_range_rvalue<RandomAccessIterator<std::unique_ptr<int>*> >();
-    test_range_rvalue<std::unique_ptr<int>*>();
-    test_range_rvalue<ForwardIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*>>();
-    test_range_rvalue<BidirectionalIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*>>();
-    test_range_rvalue<RandomAccessIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*>>();
-
-    // Check projection
-    S ia[] = {S{0}, S{1}, S{2}, S{3}, S{4}, S{2}, S{3}, S{4}, S{2}};
-    constexpr auto sa = ranges::size(ia);
-    S* r = ranges::remove(ia, 2, &S::i);
-    CHECK(r == ia + sa-3);
-    CHECK(ia[0].i == 0);
-    CHECK(ia[1].i == 1);
-    CHECK(ia[2].i == 3);
-    CHECK(ia[3].i == 4);
-    CHECK(ia[4].i == 3);
-    CHECK(ia[5].i == 4);
-
-    // Check rvalue ranges
-    S ia2[] = {S{0}, S{1}, S{2}, S{3}, S{4}, S{2}, S{3}, S{4}, S{2}};
-    auto r2 = ranges::remove(std::move(ia2), 2, &S::i);
-#ifndef RANGES_WORKAROUND_MSVC_573728
-    CHECK(::is_dangling(r2));
-#endif // RANGES_WORKAROUND_MSVC_573728
-    CHECK(ia2[0].i == 0);
-    CHECK(ia2[1].i == 1);
-    CHECK(ia2[2].i == 3);
-    CHECK(ia2[3].i == 4);
-    CHECK(ia2[4].i == 3);
-    CHECK(ia2[5].i == 4);
-
-    std::vector<S> vec{S{0}, S{1}, S{2}, S{3}, S{4}, S{2}, S{3}, S{4}, S{2}};
-    auto r3 = ranges::remove(std::move(vec), 2, &S::i);
-    CHECK(::is_dangling(r3));
-    CHECK(vec[0].i == 0);
-    CHECK(vec[1].i == 1);
-    CHECK(vec[2].i == 3);
-    CHECK(vec[3].i == 4);
-    CHECK(vec[4].i == 3);
-    CHECK(vec[5].i == 4);
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/remove_copy.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/remove_copy.cpp
deleted file mode 100644
index 28de23ff..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/remove_copy.cpp
+++ /dev/null
@@ -1,188 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <memory>
-#include <utility>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/remove_copy.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-template<class InIter, class OutIter, class Sent = InIter>
-void
-test_iter()
-{
-    int ia[] = {0, 1, 2, 3, 4, 2, 3, 4, 2};
-    constexpr auto sa = ranges::size(ia);
-    int ib[sa];
-    ranges::remove_copy_result<InIter, OutIter> r = ranges::remove_copy(InIter(ia), Sent(ia+sa), OutIter(ib), 2);
-    CHECK(base(r.in) == ia + sa);
-    CHECK(base(r.out) == ib + sa-3);
-    CHECK(ib[0] == 0);
-    CHECK(ib[1] == 1);
-    CHECK(ib[2] == 3);
-    CHECK(ib[3] == 4);
-    CHECK(ib[4] == 3);
-    CHECK(ib[5] == 4);
-}
-
-template<class InIter, class OutIter, class Sent = InIter>
-void
-test_range()
-{
-    int ia[] = {0, 1, 2, 3, 4, 2, 3, 4, 2};
-    constexpr auto sa = ranges::size(ia);
-    int ib[sa];
-    ranges::remove_copy_result<InIter, OutIter> r = ranges::remove_copy(::as_lvalue(ranges::make_subrange(InIter(ia), Sent(ia+sa))), OutIter(ib), 2);
-    CHECK(base(r.in) == ia + sa);
-    CHECK(base(r.out) == ib + sa-3);
-    CHECK(ib[0] == 0);
-    CHECK(ib[1] == 1);
-    CHECK(ib[2] == 3);
-    CHECK(ib[3] == 4);
-    CHECK(ib[4] == 3);
-    CHECK(ib[5] == 4);
-}
-
-template<class InIter, class OutIter, class Sent = InIter>
-void
-test()
-{
-    test_iter<InIter, OutIter, Sent>();
-    test_range<InIter, OutIter, Sent>();
-}
-
-struct S
-{
-    int i;
-};
-
-int main()
-{
-    test<InputIterator<const int*>, OutputIterator<int*>>();
-    test<InputIterator<const int*>, ForwardIterator<int*>>();
-    test<InputIterator<const int*>, BidirectionalIterator<int*>>();
-    test<InputIterator<const int*>, RandomAccessIterator<int*>>();
-    test<InputIterator<const int*>, int*>();
-
-    test<ForwardIterator<const int*>, OutputIterator<int*>>();
-    test<ForwardIterator<const int*>, ForwardIterator<int*>>();
-    test<ForwardIterator<const int*>, BidirectionalIterator<int*>>();
-    test<ForwardIterator<const int*>, RandomAccessIterator<int*>>();
-    test<ForwardIterator<const int*>, int*>();
-
-    test<BidirectionalIterator<const int*>, OutputIterator<int*>>();
-    test<BidirectionalIterator<const int*>, ForwardIterator<int*>>();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<int*>>();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<int*>>();
-    test<BidirectionalIterator<const int*>, int*>();
-
-    test<RandomAccessIterator<const int*>, OutputIterator<int*>>();
-    test<RandomAccessIterator<const int*>, ForwardIterator<int*>>();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<int*>>();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<int*>>();
-    test<RandomAccessIterator<const int*>, int*>();
-
-    test<const int*, OutputIterator<int*>>();
-    test<const int*, ForwardIterator<int*>>();
-    test<const int*, BidirectionalIterator<int*>>();
-    test<const int*, RandomAccessIterator<int*>>();
-    test<const int*, int*>();
-
-    test<InputIterator<const int*>, OutputIterator<int*>, Sentinel<const int*>>();
-    test<InputIterator<const int*>, ForwardIterator<int*>, Sentinel<const int*>>();
-    test<InputIterator<const int*>, BidirectionalIterator<int*>, Sentinel<const int*>>();
-    test<InputIterator<const int*>, RandomAccessIterator<int*>, Sentinel<const int*>>();
-    test<InputIterator<const int*>, int*, Sentinel<const int*>>();
-
-    test<ForwardIterator<const int*>, OutputIterator<int*>, Sentinel<const int*>>();
-    test<ForwardIterator<const int*>, ForwardIterator<int*>, Sentinel<const int*>>();
-    test<ForwardIterator<const int*>, BidirectionalIterator<int*>, Sentinel<const int*>>();
-    test<ForwardIterator<const int*>, RandomAccessIterator<int*>, Sentinel<const int*>>();
-    test<ForwardIterator<const int*>, int*, Sentinel<const int*>>();
-
-    test<BidirectionalIterator<const int*>, OutputIterator<int*>, Sentinel<const int*>>();
-    test<BidirectionalIterator<const int*>, ForwardIterator<int*>, Sentinel<const int*>>();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<int*>, Sentinel<const int*>>();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<int*>, Sentinel<const int*>>();
-    test<BidirectionalIterator<const int*>, int*, Sentinel<const int*>>();
-
-    test<RandomAccessIterator<const int*>, OutputIterator<int*>, Sentinel<const int*>>();
-    test<RandomAccessIterator<const int*>, ForwardIterator<int*>, Sentinel<const int*>>();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<int*>, Sentinel<const int*>>();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<int*>, Sentinel<const int*>>();
-    test<RandomAccessIterator<const int*>, int*, Sentinel<const int*>>();
-
-    // Check projection
-    {
-        S ia[] = {S{0}, S{1}, S{2}, S{3}, S{4}, S{2}, S{3}, S{4}, S{2}};
-        constexpr auto sa = ranges::size(ia);
-        S ib[sa];
-        ranges::remove_copy_result<S*, S*> r = ranges::remove_copy(ia, ib, 2, &S::i);
-        CHECK(r.in == ia + sa);
-        CHECK(r.out == ib + sa-3);
-        CHECK(ib[0].i == 0);
-        CHECK(ib[1].i == 1);
-        CHECK(ib[2].i == 3);
-        CHECK(ib[3].i == 4);
-        CHECK(ib[4].i == 3);
-        CHECK(ib[5].i == 4);
-    }
-
-    // Check rvalue range
-    {
-        S ia[] = {S{0}, S{1}, S{2}, S{3}, S{4}, S{2}, S{3}, S{4}, S{2}};
-        constexpr auto sa = ranges::size(ia);
-        S ib[sa] = {};
-        auto r0 = ranges::remove_copy(std::move(ia), ib, 2, &S::i);
-#ifndef RANGES_WORKAROUND_MSVC_573728
-        static_assert(std::is_same<decltype(r0),
-            ranges::remove_copy_result<ranges::dangling, S *>>::value, "");
-#endif // RANGES_WORKAROUND_MSVC_573728
-        CHECK(r0.out == ib + sa-3);
-        CHECK(ib[0].i == 0);
-        CHECK(ib[1].i == 1);
-        CHECK(ib[2].i == 3);
-        CHECK(ib[3].i == 4);
-        CHECK(ib[4].i == 3);
-        CHECK(ib[5].i == 4);
-
-        std::fill(ranges::begin(ib), ranges::end(ib), S{});
-        std::vector<S> vec(ranges::begin(ia), ranges::end(ia));
-        auto r1 = ranges::remove_copy(std::move(vec), ib, 2, &S::i);
-        static_assert(std::is_same<decltype(r1),
-            ranges::remove_copy_result<ranges::dangling, S *>>::value, "");
-        CHECK(r1.out == ib + sa-3);
-        CHECK(ib[0].i == 0);
-        CHECK(ib[1].i == 1);
-        CHECK(ib[2].i == 3);
-        CHECK(ib[3].i == 4);
-        CHECK(ib[4].i == 3);
-        CHECK(ib[5].i == 4);
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/remove_copy_if.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/remove_copy_if.cpp
deleted file mode 100644
index d31eb345..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/remove_copy_if.cpp
+++ /dev/null
@@ -1,187 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <functional>
-#include <memory>
-#include <utility>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/remove_copy_if.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-template<class InIter, class OutIter, class Sent = InIter>
-void
-test_iter()
-{
-    int ia[] = {0, 1, 2, 3, 4, 2, 3, 4, 2};
-    constexpr auto sa = ranges::size(ia);
-    int ib[sa];
-    ranges::remove_copy_if_result<InIter, OutIter> r = ranges::remove_copy_if(InIter(ia), Sent(ia+sa), OutIter(ib), [](int i){return i == 2;});
-    CHECK(base(r.in) == ia + sa);
-    CHECK(base(r.out) == ib + sa-3);
-    CHECK(ib[0] == 0);
-    CHECK(ib[1] == 1);
-    CHECK(ib[2] == 3);
-    CHECK(ib[3] == 4);
-    CHECK(ib[4] == 3);
-    CHECK(ib[5] == 4);
-}
-
-template<class InIter, class OutIter, class Sent = InIter>
-void
-test_range()
-{
-    int ia[] = {0, 1, 2, 3, 4, 2, 3, 4, 2};
-    constexpr auto sa = ranges::size(ia);
-    int ib[sa];
-    ranges::remove_copy_if_result<InIter, OutIter> r = ranges::remove_copy_if(::as_lvalue(ranges::make_subrange(InIter(ia), Sent(ia+sa))), OutIter(ib), [](int i){return i == 2;});
-    CHECK(base(r.in) == ia + sa);
-    CHECK(base(r.out) == ib + sa-3);
-    CHECK(ib[0] == 0);
-    CHECK(ib[1] == 1);
-    CHECK(ib[2] == 3);
-    CHECK(ib[3] == 4);
-    CHECK(ib[4] == 3);
-    CHECK(ib[5] == 4);
-}
-
-template<class InIter, class OutIter, class Sent = InIter>
-void
-test()
-{
-    test_iter<InIter, OutIter, Sent>();
-    test_range<InIter, OutIter, Sent>();
-}
-
-struct S
-{
-    int i;
-};
-
-int main()
-{
-    test<InputIterator<const int*>, OutputIterator<int*>>();
-    test<InputIterator<const int*>, ForwardIterator<int*>>();
-    test<InputIterator<const int*>, BidirectionalIterator<int*>>();
-    test<InputIterator<const int*>, RandomAccessIterator<int*>>();
-    test<InputIterator<const int*>, int*>();
-
-    test<ForwardIterator<const int*>, OutputIterator<int*>>();
-    test<ForwardIterator<const int*>, ForwardIterator<int*>>();
-    test<ForwardIterator<const int*>, BidirectionalIterator<int*>>();
-    test<ForwardIterator<const int*>, RandomAccessIterator<int*>>();
-    test<ForwardIterator<const int*>, int*>();
-
-    test<BidirectionalIterator<const int*>, OutputIterator<int*>>();
-    test<BidirectionalIterator<const int*>, ForwardIterator<int*>>();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<int*>>();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<int*>>();
-    test<BidirectionalIterator<const int*>, int*>();
-
-    test<RandomAccessIterator<const int*>, OutputIterator<int*>>();
-    test<RandomAccessIterator<const int*>, ForwardIterator<int*>>();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<int*>>();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<int*>>();
-    test<RandomAccessIterator<const int*>, int*>();
-
-    test<const int*, OutputIterator<int*>>();
-    test<const int*, ForwardIterator<int*>>();
-    test<const int*, BidirectionalIterator<int*>>();
-    test<const int*, RandomAccessIterator<int*>>();
-    test<const int*, int*>();
-
-    test<InputIterator<const int*>, OutputIterator<int*>, Sentinel<const int*>>();
-    test<InputIterator<const int*>, ForwardIterator<int*>, Sentinel<const int*>>();
-    test<InputIterator<const int*>, BidirectionalIterator<int*>, Sentinel<const int*>>();
-    test<InputIterator<const int*>, RandomAccessIterator<int*>, Sentinel<const int*>>();
-    test<InputIterator<const int*>, int*, Sentinel<const int*>>();
-
-    test<ForwardIterator<const int*>, OutputIterator<int*>, Sentinel<const int*>>();
-    test<ForwardIterator<const int*>, ForwardIterator<int*>, Sentinel<const int*>>();
-    test<ForwardIterator<const int*>, BidirectionalIterator<int*>, Sentinel<const int*>>();
-    test<ForwardIterator<const int*>, RandomAccessIterator<int*>, Sentinel<const int*>>();
-    test<ForwardIterator<const int*>, int*, Sentinel<const int*>>();
-
-    test<BidirectionalIterator<const int*>, OutputIterator<int*>, Sentinel<const int*>>();
-    test<BidirectionalIterator<const int*>, ForwardIterator<int*>, Sentinel<const int*>>();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<int*>, Sentinel<const int*>>();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<int*>, Sentinel<const int*>>();
-    test<BidirectionalIterator<const int*>, int*, Sentinel<const int*>>();
-
-    test<RandomAccessIterator<const int*>, OutputIterator<int*>, Sentinel<const int*>>();
-    test<RandomAccessIterator<const int*>, ForwardIterator<int*>, Sentinel<const int*>>();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<int*>, Sentinel<const int*>>();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<int*>, Sentinel<const int*>>();
-    test<RandomAccessIterator<const int*>, int*, Sentinel<const int*>>();
-
-    // Check projection
-    {
-        S ia[] = {S{0}, S{1}, S{2}, S{3}, S{4}, S{2}, S{3}, S{4}, S{2}};
-        constexpr auto sa = ranges::size(ia);
-        S ib[sa];
-        ranges::remove_copy_if_result<S*, S*> r = ranges::remove_copy_if(ia, ib, [](int i){return i == 2;}, &S::i);
-        CHECK(r.in == ia + sa);
-        CHECK(r.out == ib + sa-3);
-        CHECK(ib[0].i == 0);
-        CHECK(ib[1].i == 1);
-        CHECK(ib[2].i == 3);
-        CHECK(ib[3].i == 4);
-        CHECK(ib[4].i == 3);
-        CHECK(ib[5].i == 4);
-    }
-
-    // Check rvalue range
-    {
-        S ia[] = {S{0}, S{1}, S{2}, S{3}, S{4}, S{2}, S{3}, S{4}, S{2}};
-        constexpr auto sa = ranges::size(ia);
-        S ib[sa] = {};
-        auto r0 = ranges::remove_copy_if(std::move(ia), ib, [](int i){return i == 2;}, &S::i);
-#ifndef RANGES_WORKAROUND_MSVC_573728
-        CHECK(::is_dangling(r0.in));
-#endif // RANGES_WORKAROUND_MSVC_573728
-        CHECK(r0.out == ib + sa-3);
-        CHECK(ib[0].i == 0);
-        CHECK(ib[1].i == 1);
-        CHECK(ib[2].i == 3);
-        CHECK(ib[3].i == 4);
-        CHECK(ib[4].i == 3);
-        CHECK(ib[5].i == 4);
-
-        std::fill(ranges::begin(ib), ranges::end(ib), S{});
-        std::vector<S> vec(ranges::begin(ia), ranges::end(ia));
-        auto r1 = ranges::remove_copy_if(std::move(vec), ib, [](int i){return i == 2;}, &S::i);
-        CHECK(::is_dangling(r1.in));
-        CHECK(r1.out == ib + sa-3);
-        CHECK(ib[0].i == 0);
-        CHECK(ib[1].i == 1);
-        CHECK(ib[2].i == 3);
-        CHECK(ib[3].i == 4);
-        CHECK(ib[4].i == 3);
-        CHECK(ib[5].i == 4);
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/remove_if.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/remove_if.cpp
deleted file mode 100644
index 8ed65d69..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/remove_if.cpp
+++ /dev/null
@@ -1,206 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <functional>
-#include <iostream>
-#include <memory>
-#include <utility>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/remove_if.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-template<class Iter, class Sent = Iter>
-void
-test_iter()
-{
-    int ia[] = {0, 1, 2, 3, 4, 2, 3, 4, 2};
-    constexpr auto sa = ranges::size(ia);
-    using namespace std::placeholders;
-    Iter r = ranges::remove_if(Iter(ia), Sent(ia+sa), std::bind(std::equal_to<int>(), _1, 2));
-    CHECK(base(r) == ia + sa-3);
-    CHECK(ia[0] == 0);
-    CHECK(ia[1] == 1);
-    CHECK(ia[2] == 3);
-    CHECK(ia[3] == 4);
-    CHECK(ia[4] == 3);
-    CHECK(ia[5] == 4);
-}
-
-template<class Iter, class Sent = Iter>
-void
-test_range()
-{
-    int ia[] = {0, 1, 2, 3, 4, 2, 3, 4, 2};
-    constexpr auto sa = ranges::size(ia);
-    using namespace std::placeholders;
-    Iter r = ranges::remove_if(::as_lvalue(ranges::make_subrange(Iter(ia), Sent(ia+sa))), std::bind(std::equal_to<int>(), _1, 2));
-    CHECK(base(r) == ia + sa-3);
-    CHECK(ia[0] == 0);
-    CHECK(ia[1] == 1);
-    CHECK(ia[2] == 3);
-    CHECK(ia[3] == 4);
-    CHECK(ia[4] == 3);
-    CHECK(ia[5] == 4);
-}
-
-struct pred
-{
-    bool operator()(const std::unique_ptr<int>& i) {return *i == 2;}
-};
-
-template<class Iter, class Sent = Iter>
-void
-test_iter_rvalue()
-{
-    constexpr unsigned sa = 9;
-    std::unique_ptr<int> ia[sa];
-    ia[0].reset(new int(0));
-    ia[1].reset(new int(1));
-    ia[2].reset(new int(2));
-    ia[3].reset(new int(3));
-    ia[4].reset(new int(4));
-    ia[5].reset(new int(2));
-    ia[6].reset(new int(3));
-    ia[7].reset(new int(4));
-    ia[8].reset(new int(2));
-    Iter r = ranges::remove_if(Iter(ia), Sent(ia+sa), pred());
-    CHECK(base(r) == ia + sa-3);
-    CHECK(*ia[0] == 0);
-    CHECK(*ia[1] == 1);
-    CHECK(*ia[2] == 3);
-    CHECK(*ia[3] == 4);
-    CHECK(*ia[4] == 3);
-    CHECK(*ia[5] == 4);
-}
-
-template<class Iter, class Sent = Iter>
-void
-test_range_rvalue()
-{
-    constexpr unsigned sa = 9;
-    std::unique_ptr<int> ia[sa];
-    ia[0].reset(new int(0));
-    ia[1].reset(new int(1));
-    ia[2].reset(new int(2));
-    ia[3].reset(new int(3));
-    ia[4].reset(new int(4));
-    ia[5].reset(new int(2));
-    ia[6].reset(new int(3));
-    ia[7].reset(new int(4));
-    ia[8].reset(new int(2));
-    Iter r = ranges::remove_if(::as_lvalue(ranges::make_subrange(Iter(ia), Sent(ia+sa))), pred());
-    CHECK(base(r) == ia + sa-3);
-    CHECK(*ia[0] == 0);
-    CHECK(*ia[1] == 1);
-    CHECK(*ia[2] == 3);
-    CHECK(*ia[3] == 4);
-    CHECK(*ia[4] == 3);
-    CHECK(*ia[5] == 4);
-}
-
-struct S
-{
-    int i;
-};
-
-int main()
-{
-    test_iter<ForwardIterator<int*> >();
-    test_iter<BidirectionalIterator<int*> >();
-    test_iter<RandomAccessIterator<int*> >();
-    test_iter<int*>();
-    test_iter<ForwardIterator<int*>, Sentinel<int*>>();
-    test_iter<BidirectionalIterator<int*>, Sentinel<int*>>();
-    test_iter<RandomAccessIterator<int*>, Sentinel<int*>>();
-
-    test_range<ForwardIterator<int*> >();
-    test_range<BidirectionalIterator<int*> >();
-    test_range<RandomAccessIterator<int*> >();
-    test_range<int*>();
-    test_range<ForwardIterator<int*>, Sentinel<int*>>();
-    test_range<BidirectionalIterator<int*>, Sentinel<int*>>();
-    test_range<RandomAccessIterator<int*>, Sentinel<int*>>();
-
-    test_iter_rvalue<ForwardIterator<std::unique_ptr<int>*> >();
-    test_iter_rvalue<BidirectionalIterator<std::unique_ptr<int>*> >();
-    test_iter_rvalue<RandomAccessIterator<std::unique_ptr<int>*> >();
-    test_iter_rvalue<std::unique_ptr<int>*>();
-    test_iter_rvalue<ForwardIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*>>();
-    test_iter_rvalue<BidirectionalIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*>>();
-    test_iter_rvalue<RandomAccessIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*>>();
-
-    test_range_rvalue<ForwardIterator<std::unique_ptr<int>*> >();
-    test_range_rvalue<BidirectionalIterator<std::unique_ptr<int>*> >();
-    test_range_rvalue<RandomAccessIterator<std::unique_ptr<int>*> >();
-    test_range_rvalue<std::unique_ptr<int>*>();
-    test_range_rvalue<ForwardIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*>>();
-    test_range_rvalue<BidirectionalIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*>>();
-    test_range_rvalue<RandomAccessIterator<std::unique_ptr<int>*>, Sentinel<std::unique_ptr<int>*>>();
-
-    {
-        // Check projection
-        S ia[] = {S{0}, S{1}, S{2}, S{3}, S{4}, S{2}, S{3}, S{4}, S{2}};
-        constexpr auto sa = ranges::size(ia);
-        using namespace std::placeholders;
-        S* r = ranges::remove_if(ia, std::bind(std::equal_to<int>(), _1, 2), &S::i);
-        CHECK(r == ia + sa-3);
-        CHECK(ia[0].i == 0);
-        CHECK(ia[1].i == 1);
-        CHECK(ia[2].i == 3);
-        CHECK(ia[3].i == 4);
-        CHECK(ia[4].i == 3);
-        CHECK(ia[5].i == 4);
-    }
-
-    {
-        // Check rvalue ranges
-        S ia[] = {S{0}, S{1}, S{2}, S{3}, S{4}, S{2}, S{3}, S{4}, S{2}};
-        using namespace std::placeholders;
-        auto r0 = ranges::remove_if(std::move(ia), std::bind(std::equal_to<int>(), _1, 2), &S::i);
-#ifndef RANGES_WORKAROUND_MSVC_573728
-        static_assert(std::is_same<decltype(r0), ranges::dangling>::value, "");
-#endif // RANGES_WORKAROUND_MSVC_573728
-        CHECK(ia[0].i == 0);
-        CHECK(ia[1].i == 1);
-        CHECK(ia[2].i == 3);
-        CHECK(ia[3].i == 4);
-        CHECK(ia[4].i == 3);
-        CHECK(ia[5].i == 4);
-
-        std::vector<S> vec{S{0}, S{1}, S{2}, S{3}, S{4}, S{2}, S{3}, S{4}, S{2}};
-        auto r1 = ranges::remove_if(std::move(vec), std::bind(std::equal_to<int>(), _1, 2), &S::i);
-        static_assert(std::is_same<decltype(r1), ranges::dangling>::value, "");
-        CHECK(vec[0].i == 0);
-        CHECK(vec[1].i == 1);
-        CHECK(vec[2].i == 3);
-        CHECK(vec[3].i == 4);
-        CHECK(vec[4].i == 3);
-        CHECK(vec[5].i == 4);
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/replace.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/replace.cpp
deleted file mode 100644
index 60ba6244..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/replace.cpp
+++ /dev/null
@@ -1,123 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <utility>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/replace.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-template<typename Iter, typename Sent = Iter>
-void test_iter()
-{
-    int ia[] = {0, 1, 2, 3, 4};
-    const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-    Iter i = ranges::replace(Iter(ia), Sent(ia+sa), 2, 5);
-    CHECK(ia[0] == 0);
-    CHECK(ia[1] == 1);
-    CHECK(ia[2] == 5);
-    CHECK(ia[3] == 3);
-    CHECK(ia[4] == 4);
-    CHECK(base(i) == ia + sa);
-}
-
-template<typename Iter, typename Sent = Iter>
-void test_rng()
-{
-    int ia[] = {0, 1, 2, 3, 4};
-    const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-    auto rng = ranges::make_subrange(Iter(ia), Sent(ia+sa));
-    Iter i = ranges::replace(rng, 2, 5);
-    CHECK(ia[0] == 0);
-    CHECK(ia[1] == 1);
-    CHECK(ia[2] == 5);
-    CHECK(ia[3] == 3);
-    CHECK(ia[4] == 4);
-    CHECK(base(i) == ia + sa);
-}
-
-int main()
-{
-    test_iter<ForwardIterator<int*> >();
-    test_iter<BidirectionalIterator<int*> >();
-    test_iter<RandomAccessIterator<int*> >();
-    test_iter<int*>();
-
-    test_iter<ForwardIterator<int*>, Sentinel<int*> >();
-    test_iter<BidirectionalIterator<int*>, Sentinel<int*> >();
-    test_iter<RandomAccessIterator<int*>, Sentinel<int*> >();
-
-    test_rng<ForwardIterator<int*> >();
-    test_rng<BidirectionalIterator<int*> >();
-    test_rng<RandomAccessIterator<int*> >();
-    test_rng<int*>();
-
-    test_rng<ForwardIterator<int*>, Sentinel<int*> >();
-    test_rng<BidirectionalIterator<int*>, Sentinel<int*> >();
-    test_rng<RandomAccessIterator<int*>, Sentinel<int*> >();
-
-    // test projection
-    {
-        using P = std::pair<int,std::string>;
-        P ia[] = {{0,"0"}, {1,"1"}, {2,"2"}, {3,"3"}, {4,"4"}};
-        P *i = ranges::replace(ia, 2, std::make_pair(42,"42"), &std::pair<int,std::string>::first);
-        CHECK(ia[0] == P{0,"0"});
-        CHECK(ia[1] == P{1,"1"});
-        CHECK(ia[2] == P{42,"42"});
-        CHECK(ia[3] == P{3,"3"});
-        CHECK(ia[4] == P{4,"4"});
-        CHECK(i == ranges::end(ia));
-    }
-
-    // test rvalue ranges
-    {
-        using P = std::pair<int,std::string>;
-        P ia[] = {{0,"0"}, {1,"1"}, {2,"2"}, {3,"3"}, {4,"4"}};
-        auto i = ranges::replace(std::move(ia), 2, std::make_pair(42,"42"), &std::pair<int,std::string>::first);
-#ifndef RANGES_WORKAROUND_MSVC_573728
-        CHECK(::is_dangling(i));
-#endif // RANGES_WORKAROUND_MSVC_573728
-        CHECK(ia[0] == P{0,"0"});
-        CHECK(ia[1] == P{1,"1"});
-        CHECK(ia[2] == P{42,"42"});
-        CHECK(ia[3] == P{3,"3"});
-        CHECK(ia[4] == P{4,"4"});
-    }
-
-    {
-        using P = std::pair<int,std::string>;
-        std::vector<P> ia{{0,"0"}, {1,"1"}, {2,"2"}, {3,"3"}, {4,"4"}};
-        auto i = ranges::replace(std::move(ia), 2, std::make_pair(42,"42"), &std::pair<int,std::string>::first);
-        CHECK(::is_dangling(i));
-        CHECK(ia[0] == P{0,"0"});
-        CHECK(ia[1] == P{1,"1"});
-        CHECK(ia[2] == P{42,"42"});
-        CHECK(ia[3] == P{3,"3"});
-        CHECK(ia[4] == P{4,"4"});
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/replace_copy.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/replace_copy.cpp
deleted file mode 100644
index 1196fa5d..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/replace_copy.cpp
+++ /dev/null
@@ -1,123 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <utility>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/replace_copy.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-template<class InIter, class OutIter, class Sent = InIter>
-void test_iter()
-{
-    int ia[] = {0, 1, 2, 3, 4};
-    const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-    int ib[sa] = {0};
-    ranges::replace_copy_result<InIter, OutIter> r = ranges::replace_copy(InIter(ia), Sent(ia+sa), OutIter(ib), 2, 5);
-    CHECK(base(r.in) == ia + sa);
-    CHECK(base(r.out) == ib + sa);
-    CHECK(ib[0] == 0);
-    CHECK(ib[1] == 1);
-    CHECK(ib[2] == 5);
-    CHECK(ib[3] == 3);
-    CHECK(ib[4] == 4);
-}
-
-template<class InIter, class OutIter, class Sent = InIter>
-void test_rng()
-{
-    int ia[] = {0, 1, 2, 3, 4};
-    const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-    int ib[sa] = {0};
-    auto rng = ranges::make_subrange(InIter(ia), Sent(ia+sa));
-    ranges::replace_copy_result<InIter, OutIter> r = ranges::replace_copy(rng, OutIter(ib), 2, 5);
-    CHECK(base(r.in) == ia + sa);
-    CHECK(base(r.out) == ib + sa);
-    CHECK(ib[0] == 0);
-    CHECK(ib[1] == 1);
-    CHECK(ib[2] == 5);
-    CHECK(ib[3] == 3);
-    CHECK(ib[4] == 4);
-}
-
-template<class InIter, class OutIter>
-void test()
-{
-    using Sent = typename sentinel_type<InIter>::type;
-    test_iter<InIter, OutIter>();
-    test_iter<InIter, OutIter>();
-    test_rng<InIter, OutIter, Sent>();
-    test_rng<InIter, OutIter, Sent>();
-}
-
-int main()
-{
-    test<InputIterator<const int*>, OutputIterator<int*> >();
-    test<InputIterator<const int*>, ForwardIterator<int*> >();
-    test<InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test<InputIterator<const int*>, RandomAccessIterator<int*> >();
-    test<InputIterator<const int*>, int*>();
-
-    test<ForwardIterator<const int*>, OutputIterator<int*> >();
-    test<ForwardIterator<const int*>, ForwardIterator<int*> >();
-    test<ForwardIterator<const int*>, BidirectionalIterator<int*> >();
-    test<ForwardIterator<const int*>, RandomAccessIterator<int*> >();
-    test<ForwardIterator<const int*>, int*>();
-
-    test<BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test<BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test<BidirectionalIterator<const int*>, int*>();
-
-    test<RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test<RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test<RandomAccessIterator<const int*>, int*>();
-
-    test<const int*, OutputIterator<int*> >();
-    test<const int*, ForwardIterator<int*> >();
-    test<const int*, BidirectionalIterator<int*> >();
-    test<const int*, RandomAccessIterator<int*> >();
-    test<const int*, int*>();
-
-    // Test projection
-    {
-        using P = std::pair<int, std::string>;
-        P in[] = {{0, "0"}, {1, "1"}, {2, "2"}, {3, "3"}, {4, "4"}};
-        P out[ranges::size(in)] = {};
-        ranges::replace_copy_result<P *, P *> r = ranges::replace_copy(in, out, 2, P{5, "5"}, &std::pair<int, std::string>::first);
-        CHECK(r.in == ranges::end(in));
-        CHECK(r.out == ranges::end(out));
-        CHECK(out[0] == P{0, "0"});
-        CHECK(out[1] == P{1, "1"});
-        CHECK(out[2] == P{5, "5"});
-        CHECK(out[3] == P{3, "3"});
-        CHECK(out[4] == P{4, "4"});
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/replace_copy_if.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/replace_copy_if.cpp
deleted file mode 100644
index f137cd17..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/replace_copy_if.cpp
+++ /dev/null
@@ -1,126 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <utility>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/replace_copy_if.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-template<class InIter, class OutIter, class Sent = InIter>
-void test_iter()
-{
-    int ia[] = {0, 1, 2, 3, 4};
-    const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-    int ib[sa] = {0};
-    ranges::replace_copy_if_result<InIter, OutIter> r = ranges::replace_copy_if(InIter(ia), Sent(ia+sa), OutIter(ib),
-        [](int i){return 2==i;}, 5);
-    CHECK(base(r.in) == ia + sa);
-    CHECK(base(r.out) == ib + sa);
-    CHECK(ib[0] == 0);
-    CHECK(ib[1] == 1);
-    CHECK(ib[2] == 5);
-    CHECK(ib[3] == 3);
-    CHECK(ib[4] == 4);
-}
-
-template<class InIter, class OutIter, class Sent = InIter>
-void test_rng()
-{
-    int ia[] = {0, 1, 2, 3, 4};
-    const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-    int ib[sa] = {0};
-    auto rng = ranges::make_subrange(InIter(ia), Sent(ia+sa));
-    ranges::replace_copy_if_result<InIter, OutIter> r = ranges::replace_copy_if(rng, OutIter(ib),
-        [](int i){return 2==i;}, 5);
-    CHECK(base(r.in) == ia + sa);
-    CHECK(base(r.out) == ib + sa);
-    CHECK(ib[0] == 0);
-    CHECK(ib[1] == 1);
-    CHECK(ib[2] == 5);
-    CHECK(ib[3] == 3);
-    CHECK(ib[4] == 4);
-}
-
-template<class InIter, class OutIter>
-void test()
-{
-    using Sent = typename sentinel_type<InIter>::type;
-    test_iter<InIter, OutIter>();
-    test_iter<InIter, OutIter>();
-    test_rng<InIter, OutIter, Sent>();
-    test_rng<InIter, OutIter, Sent>();
-}
-
-int main()
-{
-    test<InputIterator<const int*>, OutputIterator<int*> >();
-    test<InputIterator<const int*>, ForwardIterator<int*> >();
-    test<InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test<InputIterator<const int*>, RandomAccessIterator<int*> >();
-    test<InputIterator<const int*>, int*>();
-
-    test<ForwardIterator<const int*>, OutputIterator<int*> >();
-    test<ForwardIterator<const int*>, ForwardIterator<int*> >();
-    test<ForwardIterator<const int*>, BidirectionalIterator<int*> >();
-    test<ForwardIterator<const int*>, RandomAccessIterator<int*> >();
-    test<ForwardIterator<const int*>, int*>();
-
-    test<BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test<BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test<BidirectionalIterator<const int*>, int*>();
-
-    test<RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test<RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test<RandomAccessIterator<const int*>, int*>();
-
-    test<const int*, OutputIterator<int*> >();
-    test<const int*, ForwardIterator<int*> >();
-    test<const int*, BidirectionalIterator<int*> >();
-    test<const int*, RandomAccessIterator<int*> >();
-    test<const int*, int*>();
-
-    // Test projection
-    {
-        using P = std::pair<int, std::string>;
-        P in[] = {{0, "0"}, {1, "1"}, {2, "2"}, {3, "3"}, {4, "4"}};
-        P out[ranges::size(in)] = {};
-        ranges::replace_copy_if_result<P *, P *> r = ranges::replace_copy_if(in, out,
-            [](int i){return 2==i;}, P{5, "5"}, &std::pair<int, std::string>::first);
-        CHECK(r.in == ranges::end(in));
-        CHECK(r.out == ranges::end(out));
-        CHECK(out[0] == P{0, "0"});
-        CHECK(out[1] == P{1, "1"});
-        CHECK(out[2] == P{5, "5"});
-        CHECK(out[3] == P{3, "3"});
-        CHECK(out[4] == P{4, "4"});
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/replace_if.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/replace_if.cpp
deleted file mode 100644
index 682687ed..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/replace_if.cpp
+++ /dev/null
@@ -1,126 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <utility>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/replace_if.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-template<typename Iter, typename Sent = Iter>
-void test_iter()
-{
-    int ia[] = {0, 1, 2, 3, 4};
-    const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-    Iter i = ranges::replace_if(Iter(ia), Sent(ia+sa), [](int j){return j==2;}, 5);
-    CHECK(ia[0] == 0);
-    CHECK(ia[1] == 1);
-    CHECK(ia[2] == 5);
-    CHECK(ia[3] == 3);
-    CHECK(ia[4] == 4);
-    CHECK(base(i) == ia + sa);
-}
-
-template<typename Iter, typename Sent = Iter>
-void test_rng()
-{
-    int ia[] = {0, 1, 2, 3, 4};
-    const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-    auto rng = ranges::make_subrange(Iter(ia), Sent(ia+sa));
-    Iter i = ranges::replace_if(rng, [](int j){return j==2;}, 5);
-    CHECK(ia[0] == 0);
-    CHECK(ia[1] == 1);
-    CHECK(ia[2] == 5);
-    CHECK(ia[3] == 3);
-    CHECK(ia[4] == 4);
-    CHECK(base(i) == ia + sa);
-}
-
-int main()
-{
-    test_iter<ForwardIterator<int*> >();
-    test_iter<BidirectionalIterator<int*> >();
-    test_iter<RandomAccessIterator<int*> >();
-    test_iter<int*>();
-
-    test_iter<ForwardIterator<int*>, Sentinel<int*> >();
-    test_iter<BidirectionalIterator<int*>, Sentinel<int*> >();
-    test_iter<RandomAccessIterator<int*>, Sentinel<int*> >();
-
-    test_rng<ForwardIterator<int*> >();
-    test_rng<BidirectionalIterator<int*> >();
-    test_rng<RandomAccessIterator<int*> >();
-    test_rng<int*>();
-
-    test_rng<ForwardIterator<int*>, Sentinel<int*> >();
-    test_rng<BidirectionalIterator<int*>, Sentinel<int*> >();
-    test_rng<RandomAccessIterator<int*>, Sentinel<int*> >();
-
-    // test projection
-    {
-        using P = std::pair<int,std::string>;
-        P ia[] = {{0,"0"}, {1,"1"}, {2,"2"}, {3,"3"}, {4,"4"}};
-        P *i = ranges::replace_if(ia, [](int j){return j==2;}, std::make_pair(42,"42"),
-            &std::pair<int,std::string>::first);
-        CHECK(ia[0] == P{0,"0"});
-        CHECK(ia[1] == P{1,"1"});
-        CHECK(ia[2] == P{42,"42"});
-        CHECK(ia[3] == P{3,"3"});
-        CHECK(ia[4] == P{4,"4"});
-        CHECK(i == ranges::end(ia));
-    }
-
-    // test rvalue ranges
-    {
-        using P = std::pair<int,std::string>;
-        P ia[] = {{0,"0"}, {1,"1"}, {2,"2"}, {3,"3"}, {4,"4"}};
-        auto i = ranges::replace_if(std::move(ia), [](int j){return j==2;}, std::make_pair(42,"42"),
-            &std::pair<int,std::string>::first);
-#ifndef RANGES_WORKAROUND_MSVC_573728
-        CHECK(::is_dangling(i));
-#endif // RANGES_WORKAROUND_MSVC_573728
-        CHECK(ia[0] == P{0,"0"});
-        CHECK(ia[1] == P{1,"1"});
-        CHECK(ia[2] == P{42,"42"});
-        CHECK(ia[3] == P{3,"3"});
-        CHECK(ia[4] == P{4,"4"});
-    }
-
-    {
-        using P = std::pair<int,std::string>;
-        std::vector<P> ia{{0,"0"}, {1,"1"}, {2,"2"}, {3,"3"}, {4,"4"}};
-        auto i = ranges::replace_if(std::move(ia), [](int j){return j==2;}, std::make_pair(42,"42"),
-            &std::pair<int,std::string>::first);
-        CHECK(::is_dangling(i));
-        CHECK(ia[0] == P{0,"0"});
-        CHECK(ia[1] == P{1,"1"});
-        CHECK(ia[2] == P{42,"42"});
-        CHECK(ia[3] == P{3,"3"});
-        CHECK(ia[4] == P{4,"4"});
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/reverse.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/reverse.cpp
deleted file mode 100644
index 7f017331..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/reverse.cpp
+++ /dev/null
@@ -1,111 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <utility>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/reverse.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-template<class Iter, class Sent = Iter>
-void test()
-{
-    // iterators
-    {
-        int ia[] = {0};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        Iter i0 = ranges::reverse(Iter(ia), Sent(ia));
-        ::check_equal(ia, {0});
-        CHECK(i0 == Iter(ia));
-        Iter i1 = ranges::reverse(Iter(ia), Sent(ia+sa));
-        ::check_equal(ia, {0});
-        CHECK(i1 == Iter(ia+sa));
-
-        int ib[] = {0, 1};
-        const unsigned sb = sizeof(ib)/sizeof(ib[0]);
-        Iter i2 = ranges::reverse(Iter(ib), Sent(ib+sb));
-        ::check_equal(ib, {1, 0});
-        CHECK(i2 == Iter(ib+sb));
-
-        int ic[] = {0, 1, 2};
-        const unsigned sc = sizeof(ic)/sizeof(ic[0]);
-        Iter i3 = ranges::reverse(Iter(ic), Sent(ic+sc));
-        ::check_equal(ic, {2, 1, 0});
-        CHECK(i3 == Iter(ic+sc));
-
-        int id[] = {0, 1, 2, 3};
-        const unsigned sd = sizeof(id)/sizeof(id[0]);
-        Iter i4 = ranges::reverse(Iter(id), Sent(id+sd));
-        ::check_equal(id, {3, 2, 1, 0});
-        CHECK(i4 == Iter(id+sd));
-    }
-
-    // ranges
-    {
-        int ia[] = {0};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        Iter i0 = ranges::reverse(::as_lvalue(ranges::make_subrange(Iter(ia), Sent(ia))));
-        ::check_equal(ia, {0});
-        CHECK(i0 == Iter(ia));
-        Iter i1 = ranges::reverse(::as_lvalue(ranges::make_subrange(Iter(ia), Sent(ia+sa))));
-        ::check_equal(ia, {0});
-        CHECK(i1 == Iter(ia+sa));
-
-        int ib[] = {0, 1};
-        const unsigned sb = sizeof(ib)/sizeof(ib[0]);
-        Iter i2 = ranges::reverse(::as_lvalue(ranges::make_subrange(Iter(ib), Sent(ib+sb))));
-        ::check_equal(ib, {1, 0});
-        CHECK(i2 == Iter(ib+sb));
-
-        int ic[] = {0, 1, 2};
-        const unsigned sc = sizeof(ic)/sizeof(ic[0]);
-        Iter i3 = ranges::reverse(::as_lvalue(ranges::make_subrange(Iter(ic), Sent(ic+sc))));
-        ::check_equal(ic, {2, 1, 0});
-        CHECK(i3 == Iter(ic+sc));
-
-        int id[] = {0, 1, 2, 3};
-        const unsigned sd = sizeof(id)/sizeof(id[0]);
-        Iter i4 = ranges::reverse(::as_lvalue(ranges::make_subrange(Iter(id), Sent(id+sd))));
-        ::check_equal(id, {3, 2, 1, 0});
-        CHECK(i4 == Iter(id+sd));
-
-        // rvalue range
-        auto i5 = ranges::reverse(ranges::make_subrange(Iter(id), Sent(id+sd)));
-        ::check_equal(id, {0, 1, 2, 3});
-        CHECK(i5 == Iter(id+sd));
-    }
-}
-
-int main()
-{
-    test<BidirectionalIterator<int *>>();
-    test<RandomAccessIterator<int *>>();
-    test<int*>();
-
-    test<BidirectionalIterator<int *>, Sentinel<int*>>();
-    test<RandomAccessIterator<int *>, Sentinel<int*>>();
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/reverse_copy.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/reverse_copy.cpp
deleted file mode 100644
index fac1ada9..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/reverse_copy.cpp
+++ /dev/null
@@ -1,162 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <cstring>
-#include <utility>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/reverse_copy.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-template<class Iter, class OutIter, class Sent = Iter>
-void test()
-{
-    using P = ranges::reverse_copy_result<Iter, OutIter>;
-    // iterators
-    {
-        const int ia[] = {0};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        int ja[sa] = {-1};
-        P p0 = ranges::reverse_copy(Iter(ia), Sent(ia), OutIter(ja));
-        ::check_equal(ja, {-1});
-        CHECK(p0.in == Iter(ia));
-        CHECK(base(p0.out) == ja);
-        P p1 = ranges::reverse_copy(Iter(ia), Sent(ia+sa), OutIter(ja));
-        ::check_equal(ja, {0});
-        CHECK(p1.in == Iter(ia+sa));
-        CHECK(base(p1.out) == ja+sa);
-
-        const int ib[] = {0, 1};
-        const unsigned sb = sizeof(ib)/sizeof(ib[0]);
-        int jb[sb] = {-1};
-        P p2 = ranges::reverse_copy(Iter(ib), Sent(ib+sb), OutIter(jb));
-        ::check_equal(jb, {1, 0});
-        CHECK(p2.in == Iter(ib+sb));
-        CHECK(base(p2.out) == jb+sb);
-
-        const int ic[] = {0, 1, 2};
-        const unsigned sc = sizeof(ic)/sizeof(ic[0]);
-        int jc[sc] = {-1};
-        P p3 = ranges::reverse_copy(Iter(ic), Sent(ic+sc), OutIter(jc));
-        ::check_equal(jc, {2, 1, 0});
-        CHECK(p3.in == Iter(ic+sc));
-        CHECK(base(p3.out) == jc+sc);
-
-        const int id[] = {0, 1, 2, 3};
-        const unsigned sd = sizeof(id)/sizeof(id[0]);
-        int jd[sd] = {-1};
-        P p4 = ranges::reverse_copy(Iter(id), Sent(id+sd), OutIter(jd));
-        ::check_equal(jd, {3, 2, 1, 0});
-        CHECK(p4.in == Iter(id+sd));
-        CHECK(base(p4.out) == jd+sd);
-    }
-
-    // ranges
-    {
-        const int ia[] = {0};
-        const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-        int ja[sa] = {-1};
-        P p0 = ranges::reverse_copy(ranges::make_subrange(Iter(ia), Sent(ia)), OutIter(ja));
-        ::check_equal(ja, {-1});
-        CHECK(p0.in == Iter(ia));
-        CHECK(base(p0.out) == ja);
-        P p1 = ranges::reverse_copy(ranges::make_subrange(Iter(ia), Sent(ia+sa)), OutIter(ja));
-        ::check_equal(ja, {0});
-        CHECK(p1.in == Iter(ia+sa));
-        CHECK(base(p1.out) == ja+sa);
-
-        const int ib[] = {0, 1};
-        const unsigned sb = sizeof(ib)/sizeof(ib[0]);
-        int jb[sb] = {-1};
-        P p2 = ranges::reverse_copy(ranges::make_subrange(Iter(ib), Sent(ib+sb)), OutIter(jb));
-        ::check_equal(jb, {1, 0});
-        CHECK(p2.in == Iter(ib+sb));
-        CHECK(base(p2.out) == jb+sb);
-
-        const int ic[] = {0, 1, 2};
-        const unsigned sc = sizeof(ic)/sizeof(ic[0]);
-        int jc[sc] = {-1};
-        P p3 = ranges::reverse_copy(ranges::make_subrange(Iter(ic), Sent(ic+sc)), OutIter(jc));
-        ::check_equal(jc, {2, 1, 0});
-        CHECK(p3.in == Iter(ic+sc));
-        CHECK(base(p3.out) == jc+sc);
-
-        const int id[] = {0, 1, 2, 3};
-        const unsigned sd = sizeof(id)/sizeof(id[0]);
-        int jd[sd] = {-1};
-        P p4 = ranges::reverse_copy(ranges::make_subrange(Iter(id), Sent(id+sd)), OutIter(jd));
-        ::check_equal(jd, {3, 2, 1, 0});
-        CHECK(p4.in == Iter(id+sd));
-        CHECK(base(p4.out) == jd+sd);
-
-        // test rvalue ranges
-        std::memset(jd, 0, sizeof(jd));
-        auto p5 = ranges::reverse_copy(::MakeTestRange(Iter(id), Sent(id+sd)), OutIter(jd));
-        ::check_equal(jd, {3, 2, 1, 0});
-        CHECK(::is_dangling(p5.in));
-        CHECK(base(p4.out) == jd+sd);
-    }
-}
-
-int main()
-{
-    test<BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test<BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test<BidirectionalIterator<const int*>, int*>();
-
-    test<RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test<RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test<RandomAccessIterator<const int*>, int*>();
-
-    test<const int*, OutputIterator<int*> >();
-    test<const int*, ForwardIterator<int*> >();
-    test<const int*, BidirectionalIterator<int*> >();
-    test<const int*, RandomAccessIterator<int*> >();
-    test<const int*, int*>();
-
-    test<BidirectionalIterator<const int*>, OutputIterator<int*>, Sentinel<const int *> >();
-    test<BidirectionalIterator<const int*>, ForwardIterator<int*>, Sentinel<const int *> >();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<int*>, Sentinel<const int *> >();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<int*>, Sentinel<const int *> >();
-    test<BidirectionalIterator<const int*>, int*>();
-
-    test<RandomAccessIterator<const int*>, OutputIterator<int*>, Sentinel<const int *> >();
-    test<RandomAccessIterator<const int*>, ForwardIterator<int*>, Sentinel<const int *> >();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<int*>, Sentinel<const int *> >();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<int*>, Sentinel<const int *> >();
-    test<RandomAccessIterator<const int*>, int*>();
-
-    test<const int*, OutputIterator<int*>, Sentinel<const int *> >();
-    test<const int*, ForwardIterator<int*>, Sentinel<const int *> >();
-    test<const int*, BidirectionalIterator<int*>, Sentinel<const int *> >();
-    test<const int*, RandomAccessIterator<int*>, Sentinel<const int *> >();
-    test<const int*, int*>();
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/rotate.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/rotate.cpp
deleted file mode 100644
index 352397d1..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/rotate.cpp
+++ /dev/null
@@ -1,303 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <utility>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/rotate.hpp>
-#include "../simple_test.hpp"
-#include "../test_iterators.hpp"
-
-template<class Iter, class Sent = Iter>
-void test()
-{
-    using namespace ranges;
-    using Res = subrange<Iter>;
-
-    int ia[] = {0};
-    const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-    Res r = rotate(Iter(ia), Iter(ia), Sent(ia));
-    CHECK(base(r.begin()) == ia);
-    CHECK(base(r.end()) == ia);
-    CHECK(ia[0] == 0);
-    r = rotate(Iter(ia), Iter(ia), Sent(ia+sa));
-    CHECK(base(r.begin()) == ia+sa);
-    CHECK(base(r.end()) == ia+sa);
-    CHECK(ia[0] == 0);
-    r = rotate(Iter(ia), Iter(ia+sa), Sent(ia+sa));
-    CHECK(base(r.begin()) == ia);
-    CHECK(base(r.end()) == ia+sa);
-    CHECK(ia[0] == 0);
-
-    int ib[] = {0, 1};
-    const unsigned sb = sizeof(ib)/sizeof(ib[0]);
-    r = rotate(Iter(ib), Iter(ib), Sent(ib+sb));
-    CHECK(base(r.begin()) == ib+sb);
-    CHECK(base(r.end()) == ib+sb);
-    CHECK(ib[0] == 0);
-    CHECK(ib[1] == 1);
-    r = rotate(Iter(ib), Iter(ib+1), Sent(ib+sb));
-    CHECK(base(r.end()) == ib+sb);
-    CHECK(base(r.begin()) == ib+1);
-    CHECK(ib[0] == 1);
-    CHECK(ib[1] == 0);
-    r = rotate(Iter(ib), Iter(ib+sb), Sent(ib+sb));
-    CHECK(base(r.end()) == ib+sb);
-    CHECK(base(r.begin()) == ib);
-    CHECK(ib[0] == 1);
-    CHECK(ib[1] == 0);
-
-    int ic[] = {0, 1, 2};
-    const unsigned sc = sizeof(ic)/sizeof(ic[0]);
-    r = rotate(Iter(ic), Iter(ic), Sent(ic+sc));
-    CHECK(base(r.begin()) == ic+sc);
-    CHECK(base(r.end()) == ic+sc);
-    CHECK(ic[0] == 0);
-    CHECK(ic[1] == 1);
-    CHECK(ic[2] == 2);
-    r = rotate(Iter(ic), Iter(ic+1), Sent(ic+sc));
-    CHECK(base(r.begin()) == ic+2);
-    CHECK(base(r.end()) == ic+sc);
-    CHECK(ic[0] == 1);
-    CHECK(ic[1] == 2);
-    CHECK(ic[2] == 0);
-    r = rotate(Iter(ic), Iter(ic+2), Sent(ic+sc));
-    CHECK(base(r.begin()) == ic+1);
-    CHECK(base(r.end()) == ic+sc);
-    CHECK(ic[0] == 0);
-    CHECK(ic[1] == 1);
-    CHECK(ic[2] == 2);
-    r = rotate(Iter(ic), Iter(ic+sc), Sent(ic+sc));
-    CHECK(base(r.begin()) == ic);
-    CHECK(base(r.end()) == ic+sc);
-    CHECK(ic[0] == 0);
-    CHECK(ic[1] == 1);
-    CHECK(ic[2] == 2);
-
-    int id[] = {0, 1, 2, 3};
-    const unsigned sd = sizeof(id)/sizeof(id[0]);
-    r = rotate(Iter(id), Iter(id), Sent(id+sd));
-    CHECK(base(r.begin()) == id+sd);
-    CHECK(base(r.end()) == id+sd);
-    CHECK(id[0] == 0);
-    CHECK(id[1] == 1);
-    CHECK(id[2] == 2);
-    CHECK(id[3] == 3);
-    r = rotate(Iter(id), Iter(id+1), Sent(id+sd));
-    CHECK(base(r.begin()) == id+3);
-    CHECK(base(r.end()) == id+sd);
-    CHECK(id[0] == 1);
-    CHECK(id[1] == 2);
-    CHECK(id[2] == 3);
-    CHECK(id[3] == 0);
-    r = rotate(Iter(id), Iter(id+2), Sent(id+sd));
-    CHECK(base(r.begin()) == id+2);
-    CHECK(base(r.end()) == id+sd);
-    CHECK(id[0] == 3);
-    CHECK(id[1] == 0);
-    CHECK(id[2] == 1);
-    CHECK(id[3] == 2);
-    r = rotate(Iter(id), Iter(id+3), Sent(id+sd));
-    CHECK(base(r.begin()) == id+1);
-    CHECK(base(r.end()) == id+sd);
-    CHECK(id[0] == 2);
-    CHECK(id[1] == 3);
-    CHECK(id[2] == 0);
-    CHECK(id[3] == 1);
-    r = rotate(Iter(id), Iter(id+sd), Sent(id+sd));
-    CHECK(base(r.begin()) == id);
-    CHECK(base(r.end()) == id+sd);
-    CHECK(id[0] == 2);
-    CHECK(id[1] == 3);
-    CHECK(id[2] == 0);
-    CHECK(id[3] == 1);
-
-    int ie[] = {0, 1, 2, 3, 4};
-    const unsigned se = sizeof(ie)/sizeof(ie[0]);
-    r = rotate(Iter(ie), Iter(ie), Sent(ie+se));
-    CHECK(base(r.begin()) == ie+se);
-    CHECK(base(r.end()) == ie+se);
-    CHECK(ie[0] == 0);
-    CHECK(ie[1] == 1);
-    CHECK(ie[2] == 2);
-    CHECK(ie[3] == 3);
-    CHECK(ie[4] == 4);
-    r = rotate(Iter(ie), Iter(ie+1), Sent(ie+se));
-    CHECK(base(r.begin()) == ie+4);
-    CHECK(base(r.end()) == ie+se);
-    CHECK(ie[0] == 1);
-    CHECK(ie[1] == 2);
-    CHECK(ie[2] == 3);
-    CHECK(ie[3] == 4);
-    CHECK(ie[4] == 0);
-    r = rotate(Iter(ie), Iter(ie+2), Sent(ie+se));
-    CHECK(base(r.begin()) == ie+3);
-    CHECK(base(r.end()) == ie+se);
-    CHECK(ie[0] == 3);
-    CHECK(ie[1] == 4);
-    CHECK(ie[2] == 0);
-    CHECK(ie[3] == 1);
-    CHECK(ie[4] == 2);
-    r = rotate(Iter(ie), Iter(ie+3), Sent(ie+se));
-    CHECK(base(r.begin()) == ie+2);
-    CHECK(base(r.end()) == ie+se);
-    CHECK(ie[0] == 1);
-    CHECK(ie[1] == 2);
-    CHECK(ie[2] == 3);
-    CHECK(ie[3] == 4);
-    CHECK(ie[4] == 0);
-    r = rotate(Iter(ie), Iter(ie+4), Sent(ie+se));
-    CHECK(base(r.begin()) == ie+1);
-    CHECK(base(r.end()) == ie+se);
-    CHECK(ie[0] == 0);
-    CHECK(ie[1] == 1);
-    CHECK(ie[2] == 2);
-    CHECK(ie[3] == 3);
-    CHECK(ie[4] == 4);
-    r = rotate(Iter(ie), Iter(ie+se), Sent(ie+se));
-    CHECK(base(r.begin()) == ie);
-    CHECK(base(r.end()) == ie+se);
-    CHECK(ie[0] == 0);
-    CHECK(ie[1] == 1);
-    CHECK(ie[2] == 2);
-    CHECK(ie[3] == 3);
-    CHECK(ie[4] == 4);
-
-    int ig[] = {0, 1, 2, 3, 4, 5};
-    const unsigned sg = sizeof(ig)/sizeof(ig[0]);
-    r = rotate(Iter(ig), Iter(ig), Sent(ig+sg));
-    CHECK(base(r.begin()) == ig+sg);
-    CHECK(base(r.end()) == ig+sg);
-    CHECK(ig[0] == 0);
-    CHECK(ig[1] == 1);
-    CHECK(ig[2] == 2);
-    CHECK(ig[3] == 3);
-    CHECK(ig[4] == 4);
-    CHECK(ig[5] == 5);
-    r = rotate(Iter(ig), Iter(ig+1), Sent(ig+sg));
-    CHECK(base(r.begin()) == ig+5);
-    CHECK(base(r.end()) == ig+sg);
-    CHECK(ig[0] == 1);
-    CHECK(ig[1] == 2);
-    CHECK(ig[2] == 3);
-    CHECK(ig[3] == 4);
-    CHECK(ig[4] == 5);
-    CHECK(ig[5] == 0);
-    r = rotate(Iter(ig), Iter(ig+2), Sent(ig+sg));
-    CHECK(base(r.begin()) == ig+4);
-    CHECK(base(r.end()) == ig+sg);
-    CHECK(ig[0] == 3);
-    CHECK(ig[1] == 4);
-    CHECK(ig[2] == 5);
-    CHECK(ig[3] == 0);
-    CHECK(ig[4] == 1);
-    CHECK(ig[5] == 2);
-    r = rotate(Iter(ig), Iter(ig+3), Sent(ig+sg));
-    CHECK(base(r.begin()) == ig+3);
-    CHECK(base(r.end()) == ig+sg);
-    CHECK(ig[0] == 0);
-    CHECK(ig[1] == 1);
-    CHECK(ig[2] == 2);
-    CHECK(ig[3] == 3);
-    CHECK(ig[4] == 4);
-    CHECK(ig[5] == 5);
-    r = rotate(Iter(ig), Iter(ig+4), Sent(ig+sg));
-    CHECK(base(r.begin()) == ig+2);
-    CHECK(base(r.end()) == ig+sg);
-    CHECK(ig[0] == 4);
-    CHECK(ig[1] == 5);
-    CHECK(ig[2] == 0);
-    CHECK(ig[3] == 1);
-    CHECK(ig[4] == 2);
-    CHECK(ig[5] == 3);
-    r = rotate(Iter(ig), Iter(ig+5), Sent(ig+sg));
-    CHECK(base(r.begin()) == ig+1);
-    CHECK(base(r.end()) == ig+sg);
-    CHECK(ig[0] == 3);
-    CHECK(ig[1] == 4);
-    CHECK(ig[2] == 5);
-    CHECK(ig[3] == 0);
-    CHECK(ig[4] == 1);
-    CHECK(ig[5] == 2);
-    r = rotate(Iter(ig), Iter(ig+sg), Sent(ig+sg));
-    CHECK(base(r.begin()) == ig);
-    CHECK(base(r.end()) == ig+sg);
-    CHECK(ig[0] == 3);
-    CHECK(ig[1] == 4);
-    CHECK(ig[2] == 5);
-    CHECK(ig[3] == 0);
-    CHECK(ig[4] == 1);
-    CHECK(ig[5] == 2);
-}
-
-int main()
-{
-    test<ForwardIterator<int *>>();
-    test<BidirectionalIterator<int *>>();
-    test<RandomAccessIterator<int *>>();
-
-    test<ForwardIterator<int *>, Sentinel<int*>>();
-    test<BidirectionalIterator<int *>, Sentinel<int*>>();
-    test<RandomAccessIterator<int *>, Sentinel<int*>>();
-
-    // test rvalue ranges
-    {
-        int rgi[] = {0,1,2,3,4,5};
-        auto r = ranges::rotate(ranges::views::all(rgi), rgi+2);
-        CHECK(r.begin() == rgi+4);
-        CHECK(r.end() == ranges::end(rgi));
-        CHECK(rgi[0] == 2);
-        CHECK(rgi[1] == 3);
-        CHECK(rgi[2] == 4);
-        CHECK(rgi[3] == 5);
-        CHECK(rgi[4] == 0);
-        CHECK(rgi[5] == 1);
-    }
-    {
-        int rgi[] = {0,1,2,3,4,5};
-        auto r = ranges::rotate(std::move(rgi), rgi+2);
-#ifndef RANGES_WORKAROUND_MSVC_573728
-        CHECK(::is_dangling(r));
-#endif // RANGES_WORKAROUND_MSVC_573728
-        CHECK(rgi[0] == 2);
-        CHECK(rgi[1] == 3);
-        CHECK(rgi[2] == 4);
-        CHECK(rgi[3] == 5);
-        CHECK(rgi[4] == 0);
-        CHECK(rgi[5] == 1);
-    }
-    {
-        std::vector<int> rgi{0,1,2,3,4,5};
-        auto r = ranges::rotate(std::move(rgi), rgi.begin()+2);
-        CHECK(::is_dangling(r));
-        CHECK(rgi[0] == 2);
-        CHECK(rgi[1] == 3);
-        CHECK(rgi[2] == 4);
-        CHECK(rgi[3] == 5);
-        CHECK(rgi[4] == 0);
-        CHECK(rgi[5] == 1);
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/rotate_copy.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/rotate_copy.cpp
deleted file mode 100644
index d085bf66..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/rotate_copy.cpp
+++ /dev/null
@@ -1,337 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <utility>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/rotate_copy.hpp>
-#include "../simple_test.hpp"
-#include "../test_iterators.hpp"
-#include "../test_utils.hpp"
-
-template<class InIter, class OutIter, typename Sent = InIter>
-void test_iter()
-{
-    int ia[] = {0, 1, 2, 3};
-    const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-    int ib[sa] = {0};
-
-    ranges::rotate_copy_result<InIter, OutIter> r = ranges::rotate_copy(InIter(ia), InIter(ia), Sent(ia), OutIter(ib));
-    CHECK(base(r.in) == ia);
-    CHECK(base(r.out) == ib);
-
-    r = ranges::rotate_copy(InIter(ia), InIter(ia), Sent(ia+1), OutIter(ib));
-    CHECK(base(r.in) == ia+1);
-    CHECK(base(r.out) == ib+1);
-    CHECK(ib[0] == 0);
-
-    r = ranges::rotate_copy(InIter(ia), InIter(ia+1), Sent(ia+1), OutIter(ib));
-    CHECK(base(r.in) == ia+1);
-    CHECK(base(r.out) == ib+1);
-    CHECK(ib[0] == 0);
-
-    r = ranges::rotate_copy(InIter(ia), InIter(ia), Sent(ia+2), OutIter(ib));
-    CHECK(base(r.in) == ia+2);
-    CHECK(base(r.out) == ib+2);
-    CHECK(ib[0] == 0);
-    CHECK(ib[1] == 1);
-
-    r = ranges::rotate_copy(InIter(ia), InIter(ia+1), Sent(ia+2), OutIter(ib));
-    CHECK(base(r.in) == ia+2);
-    CHECK(base(r.out) == ib+2);
-    CHECK(ib[0] == 1);
-    CHECK(ib[1] == 0);
-
-    r = ranges::rotate_copy(InIter(ia), InIter(ia+2), Sent(ia+2), OutIter(ib));
-    CHECK(base(r.in) == ia+2);
-    CHECK(base(r.out) == ib+2);
-    CHECK(ib[0] == 0);
-    CHECK(ib[1] == 1);
-
-    r = ranges::rotate_copy(InIter(ia), InIter(ia), Sent(ia+3), OutIter(ib));
-    CHECK(base(r.in) == ia+3);
-    CHECK(base(r.out) == ib+3);
-    CHECK(ib[0] == 0);
-    CHECK(ib[1] == 1);
-    CHECK(ib[2] == 2);
-
-    r = ranges::rotate_copy(InIter(ia), InIter(ia+1), Sent(ia+3), OutIter(ib));
-    CHECK(base(r.in) == ia+3);
-    CHECK(base(r.out) == ib+3);
-    CHECK(ib[0] == 1);
-    CHECK(ib[1] == 2);
-    CHECK(ib[2] == 0);
-
-    r = ranges::rotate_copy(InIter(ia), InIter(ia+2), Sent(ia+3), OutIter(ib));
-    CHECK(base(r.in) == ia+3);
-    CHECK(base(r.out) == ib+3);
-    CHECK(ib[0] == 2);
-    CHECK(ib[1] == 0);
-    CHECK(ib[2] == 1);
-
-    r = ranges::rotate_copy(InIter(ia), InIter(ia+3), Sent(ia+3), OutIter(ib));
-    CHECK(base(r.in) == ia+3);
-    CHECK(base(r.out) == ib+3);
-    CHECK(ib[0] == 0);
-    CHECK(ib[1] == 1);
-    CHECK(ib[2] == 2);
-
-    r = ranges::rotate_copy(InIter(ia), InIter(ia), Sent(ia+4), OutIter(ib));
-    CHECK(base(r.in) == ia+4);
-    CHECK(base(r.out) == ib+4);
-    CHECK(ib[0] == 0);
-    CHECK(ib[1] == 1);
-    CHECK(ib[2] == 2);
-    CHECK(ib[3] == 3);
-
-    r = ranges::rotate_copy(InIter(ia), InIter(ia+1), Sent(ia+4), OutIter(ib));
-    CHECK(base(r.in) == ia+4);
-    CHECK(base(r.out) == ib+4);
-    CHECK(ib[0] == 1);
-    CHECK(ib[1] == 2);
-    CHECK(ib[2] == 3);
-    CHECK(ib[3] == 0);
-
-    r = ranges::rotate_copy(InIter(ia), InIter(ia+2), Sent(ia+4), OutIter(ib));
-    CHECK(base(r.in) == ia+4);
-    CHECK(base(r.out) == ib+4);
-    CHECK(ib[0] == 2);
-    CHECK(ib[1] == 3);
-    CHECK(ib[2] == 0);
-    CHECK(ib[3] == 1);
-
-    r = ranges::rotate_copy(InIter(ia), InIter(ia+3), Sent(ia+4), OutIter(ib));
-    CHECK(base(r.in) == ia+4);
-    CHECK(base(r.out) == ib+4);
-    CHECK(ib[0] == 3);
-    CHECK(ib[1] == 0);
-    CHECK(ib[2] == 1);
-    CHECK(ib[3] == 2);
-
-    r = ranges::rotate_copy(InIter(ia), InIter(ia+4), Sent(ia+4), OutIter(ib));
-    CHECK(base(r.in) == ia+4);
-    CHECK(base(r.out) == ib+4);
-    CHECK(ib[0] == 0);
-    CHECK(ib[1] == 1);
-    CHECK(ib[2] == 2);
-    CHECK(ib[3] == 3);
-}
-
-template<class InIter, class OutIter, typename Sent = InIter>
-void test_rng()
-{
-    int ia[] = {0, 1, 2, 3};
-    const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-    int ib[sa] = {0};
-
-    ranges::rotate_copy_result<InIter, OutIter> r = ranges::rotate_copy(::as_lvalue(ranges::make_subrange(InIter(ia), Sent(ia))), InIter(ia), OutIter(ib));
-    CHECK(base(r.in) == ia);
-    CHECK(base(r.out) == ib);
-
-    r = ranges::rotate_copy(::as_lvalue(ranges::make_subrange(InIter(ia), Sent(ia+1))), InIter(ia), OutIter(ib));
-    CHECK(base(r.in) == ia+1);
-    CHECK(base(r.out) == ib+1);
-    CHECK(ib[0] == 0);
-
-    r = ranges::rotate_copy(::as_lvalue(ranges::make_subrange(InIter(ia), Sent(ia+1))), InIter(ia+1), OutIter(ib));
-    CHECK(base(r.in) == ia+1);
-    CHECK(base(r.out) == ib+1);
-    CHECK(ib[0] == 0);
-
-    r = ranges::rotate_copy(::as_lvalue(ranges::make_subrange(InIter(ia), Sent(ia+2))), InIter(ia), OutIter(ib));
-    CHECK(base(r.in) == ia+2);
-    CHECK(base(r.out) == ib+2);
-    CHECK(ib[0] == 0);
-    CHECK(ib[1] == 1);
-
-    r = ranges::rotate_copy(::as_lvalue(ranges::make_subrange(InIter(ia), Sent(ia+2))), InIter(ia+1), OutIter(ib));
-    CHECK(base(r.in) == ia+2);
-    CHECK(base(r.out) == ib+2);
-    CHECK(ib[0] == 1);
-    CHECK(ib[1] == 0);
-
-    r = ranges::rotate_copy(::as_lvalue(ranges::make_subrange(InIter(ia), Sent(ia+2))), InIter(ia+2), OutIter(ib));
-    CHECK(base(r.in) == ia+2);
-    CHECK(base(r.out) == ib+2);
-    CHECK(ib[0] == 0);
-    CHECK(ib[1] == 1);
-
-    r = ranges::rotate_copy(::as_lvalue(ranges::make_subrange(InIter(ia), Sent(ia+3))), InIter(ia), OutIter(ib));
-    CHECK(base(r.in) == ia+3);
-    CHECK(base(r.out) == ib+3);
-    CHECK(ib[0] == 0);
-    CHECK(ib[1] == 1);
-    CHECK(ib[2] == 2);
-
-    r = ranges::rotate_copy(::as_lvalue(ranges::make_subrange(InIter(ia), Sent(ia+3))), InIter(ia+1), OutIter(ib));
-    CHECK(base(r.in) == ia+3);
-    CHECK(base(r.out) == ib+3);
-    CHECK(ib[0] == 1);
-    CHECK(ib[1] == 2);
-    CHECK(ib[2] == 0);
-
-    r = ranges::rotate_copy(::as_lvalue(ranges::make_subrange(InIter(ia), Sent(ia+3))), InIter(ia+2), OutIter(ib));
-    CHECK(base(r.in) == ia+3);
-    CHECK(base(r.out) == ib+3);
-    CHECK(ib[0] == 2);
-    CHECK(ib[1] == 0);
-    CHECK(ib[2] == 1);
-
-    r = ranges::rotate_copy(::as_lvalue(ranges::make_subrange(InIter(ia), Sent(ia+3))), InIter(ia+3), OutIter(ib));
-    CHECK(base(r.in) == ia+3);
-    CHECK(base(r.out) == ib+3);
-    CHECK(ib[0] == 0);
-    CHECK(ib[1] == 1);
-    CHECK(ib[2] == 2);
-
-    r = ranges::rotate_copy(::as_lvalue(ranges::make_subrange(InIter(ia), Sent(ia+4))), InIter(ia), OutIter(ib));
-    CHECK(base(r.in) == ia+4);
-    CHECK(base(r.out) == ib+4);
-    CHECK(ib[0] == 0);
-    CHECK(ib[1] == 1);
-    CHECK(ib[2] == 2);
-    CHECK(ib[3] == 3);
-
-    r = ranges::rotate_copy(::as_lvalue(ranges::make_subrange(InIter(ia), Sent(ia+4))), InIter(ia+1), OutIter(ib));
-    CHECK(base(r.in) == ia+4);
-    CHECK(base(r.out) == ib+4);
-    CHECK(ib[0] == 1);
-    CHECK(ib[1] == 2);
-    CHECK(ib[2] == 3);
-    CHECK(ib[3] == 0);
-
-    r = ranges::rotate_copy(::as_lvalue(ranges::make_subrange(InIter(ia), Sent(ia+4))), InIter(ia+2), OutIter(ib));
-    CHECK(base(r.in) == ia+4);
-    CHECK(base(r.out) == ib+4);
-    CHECK(ib[0] == 2);
-    CHECK(ib[1] == 3);
-    CHECK(ib[2] == 0);
-    CHECK(ib[3] == 1);
-
-    r = ranges::rotate_copy(::as_lvalue(ranges::make_subrange(InIter(ia), Sent(ia+4))), InIter(ia+3), OutIter(ib));
-    CHECK(base(r.in) == ia+4);
-    CHECK(base(r.out) == ib+4);
-    CHECK(ib[0] == 3);
-    CHECK(ib[1] == 0);
-    CHECK(ib[2] == 1);
-    CHECK(ib[3] == 2);
-
-    r = ranges::rotate_copy(::as_lvalue(ranges::make_subrange(InIter(ia), Sent(ia+4))), InIter(ia+4), OutIter(ib));
-    CHECK(base(r.in) == ia+4);
-    CHECK(base(r.out) == ib+4);
-    CHECK(ib[0] == 0);
-    CHECK(ib[1] == 1);
-    CHECK(ib[2] == 2);
-    CHECK(ib[3] == 3);
-}
-
-template<class InIter, class OutIter, typename Sent = InIter>
-void test()
-{
-    test_iter<InIter, OutIter, Sent>();
-    test_rng<InIter, OutIter, Sent>();
-}
-
-struct S
-{
-    int i;
-};
-
-int main()
-{
-    test<ForwardIterator<const int*>, OutputIterator<int*> >();
-    test<ForwardIterator<const int*>, ForwardIterator<int*> >();
-    test<ForwardIterator<const int*>, BidirectionalIterator<int*> >();
-    test<ForwardIterator<const int*>, RandomAccessIterator<int*> >();
-    test<ForwardIterator<const int*>, int*>();
-
-    test<BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test<BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test<BidirectionalIterator<const int*>, int*>();
-
-    test<RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test<RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test<RandomAccessIterator<const int*>, int*>();
-
-    test<ForwardIterator<const int*>, OutputIterator<int*>, Sentinel<const int*> >();
-    test<ForwardIterator<const int*>, ForwardIterator<int*>, Sentinel<const int*> >();
-    test<ForwardIterator<const int*>, BidirectionalIterator<int*>, Sentinel<const int*> >();
-    test<ForwardIterator<const int*>, RandomAccessIterator<int*>, Sentinel<const int*> >();
-    test<ForwardIterator<const int*>, int*, Sentinel<const int*> >();
-
-    test<BidirectionalIterator<const int*>, OutputIterator<int*>, Sentinel<const int*> >();
-    test<BidirectionalIterator<const int*>, ForwardIterator<int*>, Sentinel<const int*> >();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<int*>, Sentinel<const int*> >();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<int*>, Sentinel<const int*> >();
-    test<BidirectionalIterator<const int*>, int*, Sentinel<const int*> >();
-
-    test<RandomAccessIterator<const int*>, OutputIterator<int*>, Sentinel<const int*> >();
-    test<RandomAccessIterator<const int*>, ForwardIterator<int*>, Sentinel<const int*> >();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<int*>, Sentinel<const int*> >();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<int*>, Sentinel<const int*> >();
-    test<RandomAccessIterator<const int*>, int*, Sentinel<const int*> >();
-
-    test<const int*, OutputIterator<int*> >();
-    test<const int*, ForwardIterator<int*> >();
-    test<const int*, BidirectionalIterator<int*> >();
-    test<const int*, RandomAccessIterator<int*> >();
-    test<const int*, int*>();
-
-    // test rvalue ranges
-    {
-        int rgi[] = {0,1,2,3,4,5};
-        int rgo[6] = {0};
-        auto r = ranges::rotate_copy(std::move(rgi), rgi+2, rgo);
-#ifndef RANGES_WORKAROUND_MSVC_573728
-        CHECK(::is_dangling(r.in));
-#endif // RANGES_WORKAROUND_MSVC_573728
-        CHECK(r.out == ranges::end(rgo));
-        CHECK(rgo[0] == 2);
-        CHECK(rgo[1] == 3);
-        CHECK(rgo[2] == 4);
-        CHECK(rgo[3] == 5);
-        CHECK(rgo[4] == 0);
-        CHECK(rgo[5] == 1);
-    }
-
-    {
-        std::vector<int> rgi{0,1,2,3,4,5};
-        int rgo[6] = {0};
-        auto r = ranges::rotate_copy(std::move(rgi), rgi.begin()+2, rgo);
-        CHECK(::is_dangling(r.in));
-        CHECK(r.out == ranges::end(rgo));
-        CHECK(rgo[0] == 2);
-        CHECK(rgo[1] == 3);
-        CHECK(rgo[2] == 4);
-        CHECK(rgo[3] == 5);
-        CHECK(rgo[4] == 0);
-        CHECK(rgo[5] == 1);
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/sample.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/sample.cpp
deleted file mode 100644
index f993167e..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/sample.cpp
+++ /dev/null
@@ -1,281 +0,0 @@
-// Range v3 lbrary
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distrbution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distrbuted under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <array>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/equal.hpp>
-#include <range/v3/algorithm/sample.hpp>
-#include <range/v3/numeric/iota.hpp>
-#include <range/v3/iterator/move_iterators.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-namespace
-{
-    template<typename I, typename S>
-    auto in_sequence(I first, I mid, S last) ->
-        CPP_ret(bool)(
-            requires ranges::sentinel_for<S, I>)
-    {
-        for (; first != mid; ++first)
-            RANGES_ENSURE(first != last);
-        for (; first != last; ++first)
-            ;
-        return true;
-    }
-}
-
-int main()
-{
-    constexpr unsigned N = 100;
-    constexpr unsigned K = 10;
-    {
-        std::array<int, N> i;
-        ranges::iota(i, 0);
-        std::array<int, K> a{}, b{}, c{};
-        std::minstd_rand g1, g2 = g1;
-
-        {
-            auto result = ranges::sample(RandomAccessIterator<int*>(i.data()),
-                Sentinel<int*>(i.data()+N), a.begin(), K, g1);
-            CHECK(in_sequence(i.data(), result.in.base(), i.data() + N));
-            CHECK(result.out == a.end());
-            CHECK(!ranges::equal(a, c));
-        }
-
-        {
-            auto result = ranges::sample(i.begin(), i.end(), b.begin(), K, g1);
-            CHECK(in_sequence(i.begin(), result.in, i.end()));
-            CHECK(result.out == b.end());
-            CHECK(!ranges::equal(a, b));
-            CHECK(!ranges::equal(b, c));
-        }
-
-        {
-            auto result = ranges::sample(i.begin(), i.end(), c.begin(), K, g2);
-            CHECK(in_sequence(i.begin(), result.in, i.end()));
-            CHECK(result.out == c.end());
-            CHECK(ranges::equal(a, c));
-        }
-    }
-
-    {
-        std::array<int, N> i;
-        ranges::iota(i, 0);
-        std::array<int, K> a{}, b{}, c{};
-        std::minstd_rand g1, g2 = g1;
-        auto rng = ranges::make_subrange(RandomAccessIterator<int*>(i.data()), Sentinel<int*>(i.data() + N));
-
-        {
-            auto result = ranges::sample(rng, a.begin(), K, g1);
-            CHECK(in_sequence(ranges::begin(rng), result.in, ranges::end(rng)));
-            CHECK(result.out == a.end());
-            CHECK(!ranges::equal(a, b));
-        }
-
-        {
-            auto result = ranges::sample(i, b.begin(), K, g2);
-            CHECK(in_sequence(i.begin(), result.in, i.end()));
-            CHECK(result.out == b.end());
-            CHECK(ranges::equal(a, b));
-        }
-
-        {
-            auto result = ranges::sample(i, b.begin(), K, g1);
-            CHECK(in_sequence(i.begin(), result.in, i.end()));
-            CHECK(result.out == b.end());
-            CHECK(!ranges::equal(a, b));
-            CHECK(!ranges::equal(b, c));
-        }
-
-        {
-            a.fill(0);
-            auto result = ranges::sample(std::move(rng), a.begin(), K, g1);
-            CHECK(in_sequence(ranges::begin(rng), result.in, ranges::end(rng)));
-            CHECK(result.out == a.end());
-            CHECK(!ranges::equal(a, c));
-        }
-    }
-
-    {
-        std::array<int, N> i;
-        ranges::iota(i, 0);
-        std::array<int, K> a{}, b{}, c{};
-
-        {
-            auto result = ranges::sample(RandomAccessIterator<int*>(i.data()),
-                Sentinel<int*>(i.data() + N), a.begin(), K);
-            CHECK(in_sequence(i.data(), result.in.base(), i.data() + N));
-            CHECK(result.out == a.end());
-            CHECK(!ranges::equal(a, b));
-        }
-
-        {
-            auto result = ranges::sample(i, b.begin(), K);
-            CHECK(in_sequence(i.begin(), result.in, i.end()));
-            CHECK(result.out == b.end());
-            CHECK(!ranges::equal(b, c));
-            CHECK(!ranges::equal(a, b));
-        }
-    }
-
-    {
-        std::array<MoveOnlyString, 10> source;
-        std::array<MoveOnlyString, 4> dest;
-        auto result = ranges::sample(ranges::make_move_iterator(source.begin()),
-            ranges::make_move_sentinel(source.end()),
-            ForwardIterator<MoveOnlyString*>(dest.data()), dest.size());
-        CHECK(in_sequence(ranges::make_move_iterator(source.begin()),
-            result.in,
-            ranges::make_move_sentinel(source.end())));
-        CHECK(result.out == ForwardIterator<MoveOnlyString*>(dest.data() + dest.size()));
-    }
-
-    {
-        std::array<int, N> i;
-        ranges::iota(i, 0);
-        std::array<int, K> a{}, b{}, c{};
-        std::minstd_rand g1, g2 = g1;
-
-        {
-            auto result = ranges::sample(RandomAccessIterator<int*>(i.data()),
-                Sentinel<int*>(i.data()+N), a, g1);
-            CHECK(in_sequence(i.data(), result.in.base(), i.data() + N));
-            CHECK(result.out == a.end());
-            CHECK(!ranges::equal(a, c));
-        }
-
-        {
-            auto result = ranges::sample(i.begin(), i.end(), b, g1);
-            CHECK(in_sequence(i.begin(), result.in, i.end()));
-            CHECK(result.out == b.end());
-            CHECK(!ranges::equal(a, b));
-            CHECK(!ranges::equal(b, c));
-        }
-
-        {
-            auto result = ranges::sample(i.begin(), i.end(), c, g2);
-            CHECK(in_sequence(i.begin(), result.in, i.end()));
-            CHECK(result.out == c.end());
-            CHECK(ranges::equal(a, c));
-        }
-    }
-
-    {
-        std::array<int, N> i;
-        ranges::iota(i, 0);
-        std::array<int, K> a{}, b{}, c{};
-        std::minstd_rand g1, g2 = g1;
-        auto rng = ranges::make_subrange(RandomAccessIterator<int*>(i.data()), Sentinel<int*>(i.data() + N));
-
-        {
-            auto result = ranges::sample(rng, a, g1);
-            CHECK(in_sequence(i.data(), result.in.base(), i.data() + N));
-            CHECK(result.out == a.end());
-            CHECK(!ranges::equal(a, b));
-        }
-
-        {
-            auto result = ranges::sample(i, b, g2);
-            CHECK(in_sequence(i.begin(), result.in, i.end()));
-            CHECK(result.out == b.end());
-            CHECK(ranges::equal(a, b));
-        }
-
-        {
-            auto result = ranges::sample(i, b, g1);
-            CHECK(in_sequence(i.begin(), result.in, i.end()));
-            CHECK(result.out == b.end());
-            CHECK(!ranges::equal(a, b));
-            CHECK(!ranges::equal(b, c));
-        }
-
-        {
-            a.fill(0);
-            auto result = ranges::sample(std::move(rng), a, g1);
-            CHECK(in_sequence(i.data(), result.in.base(), i.data() + N));
-            CHECK(result.out == a.end());
-            CHECK(!ranges::equal(a, c));
-        }
-    }
-
-    {
-        std::array<int, N> i;
-        ranges::iota(i, 0);
-        std::array<int, K> a{}, b{}, c{};
-
-        {
-            auto result = ranges::sample(RandomAccessIterator<int*>(i.data()),
-                Sentinel<int*>(i.data() + N), a);
-            CHECK(in_sequence(i.data(), result.in.base(), i.data() + N));
-            CHECK(result.out == a.end());
-            CHECK(!ranges::equal(a, b));
-        }
-
-        {
-            auto result = ranges::sample(i, b);
-            CHECK(in_sequence(i.begin(), result.in, i.end()));
-            CHECK(result.out == b.end());
-            CHECK(!ranges::equal(b, c));
-            CHECK(!ranges::equal(a, b));
-        }
-    }
-
-    {
-        std::array<MoveOnlyString, 10> source;
-        std::array<MoveOnlyString, 4> dest;
-        auto out = ranges::make_subrange(
-            ForwardIterator<MoveOnlyString*>(dest.data()),
-            Sentinel<MoveOnlyString*, true>(dest.data() + dest.size()));
-        auto result = ranges::sample(ranges::make_move_iterator(source.begin()),
-            ranges::make_move_sentinel(source.end()), out);
-        CHECK(in_sequence(source.begin(), result.in.base(), source.end()));
-        CHECK(result.out == ranges::end(out));
-    }
-
-    {
-        int data[] = {0,1,2,3};
-        int sample[2];
-        std::minstd_rand g;
-        {
-            auto result = ranges::sample(data, sample, g);
-            CHECK(in_sequence(ranges::begin(data), result.in, ranges::end(data)));
-            CHECK(result.out == ranges::end(sample));
-        }
-        {
-            auto result = ranges::sample(data, sample);
-            CHECK(in_sequence(ranges::begin(data), result.in, ranges::end(data)));
-            CHECK(result.out == ranges::end(sample));
-        }
-        {
-            auto result = ranges::sample(data + 0, data + 2, sample + 0, 9999);
-            CHECK(result.in == data + 2);
-            CHECK(result.out == sample + 2);
-        }
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/search.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/search.cpp
deleted file mode 100644
index b166514c..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/search.cpp
+++ /dev/null
@@ -1,237 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/search.hpp>
-#include <range/v3/view/counted.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-template<class Iter1, class Iter2, typename Sent1 = Iter1, typename Sent2 = Iter2>
-void
-test_iter_impl()
-{
-    int ia[] = {0, 1, 2, 3, 4, 5};
-    const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-    CHECK(ranges::search(Iter1(ia), Sent1(ia+sa), Iter2(ia), Sent2(ia)).begin() == Iter1(ia));
-    CHECK(ranges::search(Iter1(ia), Sent1(ia+sa), Iter2(ia), Sent2(ia)).end() == Iter1(ia));
-    CHECK(ranges::search(Iter1(ia), Sent1(ia+sa), Iter2(ia), Sent2(ia+1)).begin() == Iter1(ia));
-    CHECK(ranges::search(Iter1(ia), Sent1(ia+sa), Iter2(ia), Sent2(ia+1)).end() == Iter1(ia+1));
-    CHECK(ranges::search(Iter1(ia), Sent1(ia+sa), Iter2(ia+1), Sent2(ia+2)).begin() == Iter1(ia+1));
-    CHECK(ranges::search(Iter1(ia), Sent1(ia+sa), Iter2(ia+1), Sent2(ia+2)).end() == Iter1(ia+2));
-    CHECK(ranges::search(Iter1(ia), Sent1(ia+sa), Iter2(ia+2), Sent2(ia+2)).begin() == Iter1(ia));
-    CHECK(ranges::search(Iter1(ia), Sent1(ia+sa), Iter2(ia+2), Sent2(ia+2)).end() == Iter1(ia));
-    CHECK(ranges::search(Iter1(ia), Sent1(ia+sa), Iter2(ia+2), Sent2(ia+3)).begin() == Iter1(ia+2));
-    CHECK(ranges::search(Iter1(ia), Sent1(ia+sa), Iter2(ia+2), Sent2(ia+3)).end() == Iter1(ia+3));
-    CHECK(ranges::search(Iter1(ia), Sent1(ia+sa), Iter2(ia+2), Sent2(ia+3)).begin() == Iter1(ia+2));
-    CHECK(ranges::search(Iter1(ia), Sent1(ia+sa), Iter2(ia+2), Sent2(ia+3)).end() == Iter1(ia+3));
-    CHECK(ranges::search(Iter1(ia), Sent1(ia), Iter2(ia+2), Sent2(ia+3)).begin() == Iter1(ia));
-    CHECK(ranges::search(Iter1(ia), Sent1(ia), Iter2(ia+2), Sent2(ia+3)).end() == Iter1(ia));
-    CHECK(ranges::search(Iter1(ia), Sent1(ia+sa), Iter2(ia+sa-1), Sent2(ia+sa)).begin() == Iter1(ia+sa-1));
-    CHECK(ranges::search(Iter1(ia), Sent1(ia+sa), Iter2(ia+sa-1), Sent2(ia+sa)).end() == Iter1(ia+sa));
-    CHECK(ranges::search(Iter1(ia), Sent1(ia+sa), Iter2(ia+sa-3), Sent2(ia+sa)).begin() == Iter1(ia+sa-3));
-    CHECK(ranges::search(Iter1(ia), Sent1(ia+sa), Iter2(ia+sa-3), Sent2(ia+sa)).end() == Iter1(ia+sa));
-    CHECK(ranges::search(Iter1(ia), Sent1(ia+sa), Iter2(ia), Sent2(ia+sa)).begin() == Iter1(ia));
-    CHECK(ranges::search(Iter1(ia), Sent1(ia+sa), Iter2(ia), Sent2(ia+sa)).end() == Iter1(ia+sa));
-    CHECK(ranges::search(Iter1(ia), Sent1(ia+sa-1), Iter2(ia), Sent2(ia+sa)).begin() == Iter1(ia+sa-1));
-    CHECK(ranges::search(Iter1(ia), Sent1(ia+sa-1), Iter2(ia), Sent2(ia+sa)).end() == Iter1(ia+sa-1));
-    CHECK(ranges::search(Iter1(ia), Sent1(ia+1), Iter2(ia), Sent2(ia+sa)).begin() == Iter1(ia+1));
-    CHECK(ranges::search(Iter1(ia), Sent1(ia+1), Iter2(ia), Sent2(ia+sa)).end() == Iter1(ia+1));
-    int ib[] = {0, 1, 2, 0, 1, 2, 3, 0, 1, 2, 3, 4};
-    const unsigned sb = sizeof(ib)/sizeof(ib[0]);
-    int ic[] = {1};
-    CHECK(ranges::search(Iter1(ib), Sent1(ib+sb), Iter2(ic), Sent2(ic+1)).begin() == Iter1(ib+1));
-    CHECK(ranges::search(Iter1(ib), Sent1(ib+sb), Iter2(ic), Sent2(ic+1)).end() == Iter1(ib+2));
-    int id[] = {1, 2};
-    CHECK(ranges::search(Iter1(ib), Sent1(ib+sb), Iter2(id), Sent2(id+2)).begin() == Iter1(ib+1));
-    CHECK(ranges::search(Iter1(ib), Sent1(ib+sb), Iter2(id), Sent2(id+2)).end() == Iter1(ib+3));
-    int ie[] = {1, 2, 3};
-    CHECK(ranges::search(Iter1(ib), Sent1(ib+sb), Iter2(ie), Sent2(ie+3)).begin() == Iter1(ib+4));
-    CHECK(ranges::search(Iter1(ib), Sent1(ib+sb), Iter2(ie), Sent2(ie+3)).end() == Iter1(ib+7));
-    int ig[] = {1, 2, 3, 4};
-    CHECK(ranges::search(Iter1(ib), Sent1(ib+sb), Iter2(ig), Sent2(ig+4)).begin() == Iter1(ib+8));
-    CHECK(ranges::search(Iter1(ib), Sent1(ib+sb), Iter2(ig), Sent2(ig+4)).end() == Iter1(ib+12));
-    int ih[] = {0, 1, 1, 1, 1, 2, 3, 0, 1, 2, 3, 4};
-    const unsigned sh = sizeof(ih)/sizeof(ih[0]);
-    int ii[] = {1, 1, 2};
-    CHECK(ranges::search(Iter1(ih), Sent1(ih+sh), Iter2(ii), Sent2(ii+3)).begin() == Iter1(ih+3));
-    CHECK(ranges::search(Iter1(ih), Sent1(ih+sh), Iter2(ii), Sent2(ii+3)).end() == Iter1(ih+6));
-    int ij[] = {0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0};
-    const unsigned sj = sizeof(ij)/sizeof(ij[0]);
-    int ik[] = {0, 0, 0, 0, 1, 1, 1, 1, 0, 0};
-    const unsigned sk = sizeof(ik)/sizeof(ik[0]);
-    CHECK(ranges::search(Iter1(ij), Sent1(ij+sj), Iter2(ik), Sent2(ik+sk)).begin() == Iter1(ij+6));
-    CHECK(ranges::search(Iter1(ij), Sent1(ij+sj), Iter2(ik), Sent2(ik+sk)).end() == Iter1(ij+6+sk));
-}
-
-template<class Iter1, class Iter2>
-void
-test_iter()
-{
-    using Sent1 = typename sentinel_type<Iter1>::type;
-    using Sent2 = typename sentinel_type<Iter2>::type;
-    test_iter_impl<Iter1, Iter2>();
-    test_iter_impl<Iter1, Iter2, Sent1>();
-    test_iter_impl<Iter1, Iter2, Iter1, Sent2>();
-    test_iter_impl<Iter1, Iter2, Sent1, Sent2>();
-
-    using SizedSent1 = typename sentinel_type<Iter1, true>::type;
-    using SizedSent2 = typename sentinel_type<Iter2, true>::type;
-    test_iter_impl<Iter1, Iter2, SizedSent1, SizedSent2>();
-}
-
-template<class Iter1, class Iter2, typename Sent1 = Iter1, typename Sent2 = Iter2>
-void
-test_range_impl()
-{
-    int ia[] = {0, 1, 2, 3, 4, 5};
-    const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-    CHECK(ranges::search(ranges::make_subrange(Iter1(ia), Sent1(ia+sa)), ranges::make_subrange(Iter2(ia), Sent2(ia))).begin() == Iter1(ia));
-    CHECK(ranges::search(ranges::make_subrange(Iter1(ia), Sent1(ia+sa)), ranges::make_subrange(Iter2(ia), Sent2(ia+1))).begin() == Iter1(ia));
-    CHECK(ranges::search(ranges::make_subrange(Iter1(ia), Sent1(ia+sa)), ranges::make_subrange(Iter2(ia+1), Sent2(ia+2))).begin() == Iter1(ia+1));
-    CHECK(ranges::search(ranges::make_subrange(Iter1(ia), Sent1(ia+sa)), ranges::make_subrange(Iter2(ia+2), Sent2(ia+2))).begin() == Iter1(ia));
-    CHECK(ranges::search(ranges::make_subrange(Iter1(ia), Sent1(ia+sa)), ranges::make_subrange(Iter2(ia+2), Sent2(ia+3))).begin() == Iter1(ia+2));
-    CHECK(ranges::search(ranges::make_subrange(Iter1(ia), Sent1(ia+sa)), ranges::make_subrange(Iter2(ia+2), Sent2(ia+3))).begin() == Iter1(ia+2));
-    CHECK(ranges::search(ranges::make_subrange(Iter1(ia), Sent1(ia)), ranges::make_subrange(Iter2(ia+2), Sent2(ia+3))).begin() == Iter1(ia));
-    CHECK(ranges::search(ranges::make_subrange(Iter1(ia), Sent1(ia+sa)), ranges::make_subrange(Iter2(ia+sa-1), Sent2(ia+sa))).begin() == Iter1(ia+sa-1));
-    CHECK(ranges::search(ranges::make_subrange(Iter1(ia), Sent1(ia+sa)), ranges::make_subrange(Iter2(ia+sa-3), Sent2(ia+sa))).begin() == Iter1(ia+sa-3));
-    CHECK(ranges::search(ranges::make_subrange(Iter1(ia), Sent1(ia+sa)), ranges::make_subrange(Iter2(ia), Sent2(ia+sa))).begin() == Iter1(ia));
-    CHECK(ranges::search(ranges::make_subrange(Iter1(ia), Sent1(ia+sa-1)), ranges::make_subrange(Iter2(ia), Sent2(ia+sa))).begin() == Iter1(ia+sa-1));
-    CHECK(ranges::search(ranges::make_subrange(Iter1(ia), Sent1(ia+1)), ranges::make_subrange(Iter2(ia), Sent2(ia+sa))).begin() == Iter1(ia+1));
-    int ib[] = {0, 1, 2, 0, 1, 2, 3, 0, 1, 2, 3, 4};
-    const unsigned sb = sizeof(ib)/sizeof(ib[0]);
-    int ic[] = {1};
-    CHECK(ranges::search(ranges::make_subrange(Iter1(ib), Sent1(ib+sb)), ranges::make_subrange(Iter2(ic), Sent2(ic+1))).begin() == Iter1(ib+1));
-    int id[] = {1, 2};
-    CHECK(ranges::search(ranges::make_subrange(Iter1(ib), Sent1(ib+sb)), ranges::make_subrange(Iter2(id), Sent2(id+2))).begin() == Iter1(ib+1));
-    int ie[] = {1, 2, 3};
-    CHECK(ranges::search(ranges::make_subrange(Iter1(ib), Sent1(ib+sb)), ranges::make_subrange(Iter2(ie), Sent2(ie+3))).begin() == Iter1(ib+4));
-    int ig[] = {1, 2, 3, 4};
-    CHECK(ranges::search(ranges::make_subrange(Iter1(ib), Sent1(ib+sb)), ranges::make_subrange(Iter2(ig), Sent2(ig+4))).begin() == Iter1(ib+8));
-    int ih[] = {0, 1, 1, 1, 1, 2, 3, 0, 1, 2, 3, 4};
-    const unsigned sh = sizeof(ih)/sizeof(ih[0]);
-    int ii[] = {1, 1, 2};
-    CHECK(ranges::search(ranges::make_subrange(Iter1(ih), Sent1(ih+sh)), ranges::make_subrange(Iter2(ii), Sent2(ii+3))).begin() == Iter1(ih+3));
-    int ij[] = {0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0};
-    const unsigned sj = sizeof(ij)/sizeof(ij[0]);
-    int ik[] = {0, 0, 0, 0, 1, 1, 1, 1, 0, 0};
-    const unsigned sk = sizeof(ik)/sizeof(ik[0]);
-    CHECK(ranges::search(ranges::make_subrange(Iter1(ij), Sent1(ij+sj)), ranges::make_subrange(Iter2(ik), Sent2(ik+sk))).begin() == Iter1(ij+6));
-}
-
-template<class Iter1, class Iter2>
-void
-test_range()
-{
-    using Sent1 = typename sentinel_type<Iter1>::type;
-    using Sent2 = typename sentinel_type<Iter2>::type;
-    test_range_impl<Iter1, Iter2>();
-    test_range_impl<Iter1, Iter2, Sent1>();
-    test_range_impl<Iter1, Iter2, Iter1, Sent2>();
-    test_range_impl<Iter1, Iter2, Sent1, Sent2>();
-
-    using SizedSent1 = typename sentinel_type<Iter1, true>::type;
-    using SizedSent2 = typename sentinel_type<Iter2, true>::type;
-    test_range_impl<Iter1, Iter2, SizedSent1, SizedSent2>();
-}
-
-template<class Iter1, class Iter2>
-void
-test()
-{
-    test_iter<Iter1, Iter2>();
-    test_range<Iter1, Iter2>();
-}
-
-struct S
-{
-    int i;
-};
-
-struct T
-{
-    int i;
-};
-
-int main()
-{
-    test<ForwardIterator<const int*>, ForwardIterator<const int*> >();
-    test<ForwardIterator<const int*>, BidirectionalIterator<const int*> >();
-    test<ForwardIterator<const int*>, RandomAccessIterator<const int*> >();
-    test<BidirectionalIterator<const int*>, ForwardIterator<const int*> >();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<const int*> >();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<const int*> >();
-    test<RandomAccessIterator<const int*>, ForwardIterator<const int*> >();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<const int*> >();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<const int*> >();
-
-    // Test projections:
-    {
-        S const in[] = {{0}, {1}, {2}, {3}, {4}, {5}};
-        T const pat[] = {{2}, {3}};
-
-        S const *p = ranges::search(in, pat, std::equal_to<int>{}, &S::i, &T::i).begin();
-        CHECK(p == in+2);
-    }
-
-    // Test counted ranges
-    {
-        int in[] = {0,1,2,3,4,5};
-        auto rng = ranges::views::counted(BidirectionalIterator<int*>(in), 6);
-        auto sub = ranges::search(rng, std::initializer_list<int>{2,3});
-        CHECK(base(sub.begin().base()) == in+2);
-        CHECK(base(sub.end().base()) == in+4);
-        CHECK(sub.begin().count() == 4);
-        CHECK(sub.end().count() == 2);
-
-        sub = ranges::search(rng, std::initializer_list<int>{5,6});
-        CHECK(base(sub.begin().base()) == in+6);
-        CHECK(base(sub.end().base()) == in+6);
-        CHECK(sub.begin().count() == 0);
-        CHECK(sub.end().count() == 0);
-    }
-
-    // Test rvalue ranges
-    {
-        int ib[] = {0, 1, 2, 0, 1, 2, 3, 0, 1, 2, 3, 4};
-        int ie[] = {1, 2, 3};
-        CHECK(ranges::search(ranges::views::all(ib), ie).begin() == ib+4);
-    }
-#ifndef RANGES_WORKAROUND_MSVC_573728
-    {
-        int ib[] = {0, 1, 2, 0, 1, 2, 3, 0, 1, 2, 3, 4};
-        int ie[] = {1, 2, 3};
-        CHECK(::is_dangling(ranges::search(std::move(ib), ie)));
-    }
-#endif
-    {
-        std::vector<int> ib{0, 1, 2, 0, 1, 2, 3, 0, 1, 2, 3, 4};
-        int ie[] = {1, 2, 3};
-        CHECK(::is_dangling(ranges::search(std::move(ib), ie)));
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/search_n.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/search_n.cpp
deleted file mode 100644
index 6ec12db5..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/search_n.cpp
+++ /dev/null
@@ -1,249 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/search_n.hpp>
-#include <range/v3/view/counted.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-template<class Iter, typename Sent = Iter>
-void
-test_iter_impl()
-{
-    int ia[] = {0, 1, 2, 3, 4, 5};
-    const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-    CHECK(ranges::search_n(Iter(ia), Sent(ia+sa), 0, 0).begin() == Iter(ia));
-    CHECK(ranges::search_n(Iter(ia), Sent(ia+sa), 0, 0).end() == Iter(ia));
-    CHECK(ranges::search_n(Iter(ia), Sent(ia+sa), 1, 0).begin() == Iter(ia+0));
-    CHECK(ranges::search_n(Iter(ia), Sent(ia+sa), 1, 0).end() == Iter(ia+1));
-    CHECK(ranges::search_n(Iter(ia), Sent(ia+sa), 2, 0).begin() == Iter(ia+sa));
-    CHECK(ranges::search_n(Iter(ia), Sent(ia+sa), 2, 0).end() == Iter(ia+sa));
-    CHECK(ranges::search_n(Iter(ia), Sent(ia+sa), sa, 0).begin() == Iter(ia+sa));
-    CHECK(ranges::search_n(Iter(ia), Sent(ia+sa), sa, 0).end() == Iter(ia+sa));
-    CHECK(ranges::search_n(Iter(ia), Sent(ia+sa), 0, 3).begin() == Iter(ia));
-    CHECK(ranges::search_n(Iter(ia), Sent(ia+sa), 0, 3).end() == Iter(ia));
-    CHECK(ranges::search_n(Iter(ia), Sent(ia+sa), 1, 3).begin() == Iter(ia+3));
-    CHECK(ranges::search_n(Iter(ia), Sent(ia+sa), 1, 3).end() == Iter(ia+4));
-    CHECK(ranges::search_n(Iter(ia), Sent(ia+sa), 2, 3).begin() == Iter(ia+sa));
-    CHECK(ranges::search_n(Iter(ia), Sent(ia+sa), 2, 3).end() == Iter(ia+sa));
-    CHECK(ranges::search_n(Iter(ia), Sent(ia+sa), sa, 3).begin() == Iter(ia+sa));
-    CHECK(ranges::search_n(Iter(ia), Sent(ia+sa), sa, 3).end() == Iter(ia+sa));
-    CHECK(ranges::search_n(Iter(ia), Sent(ia+sa), 0, 5).begin() == Iter(ia));
-    CHECK(ranges::search_n(Iter(ia), Sent(ia+sa), 0, 5).end() == Iter(ia));
-    CHECK(ranges::search_n(Iter(ia), Sent(ia+sa), 1, 5).begin() == Iter(ia+5));
-    CHECK(ranges::search_n(Iter(ia), Sent(ia+sa), 1, 5).end() == Iter(ia+6));
-    CHECK(ranges::search_n(Iter(ia), Sent(ia+sa), 2, 5).begin() == Iter(ia+sa));
-    CHECK(ranges::search_n(Iter(ia), Sent(ia+sa), 2, 5).end() == Iter(ia+sa));
-    CHECK(ranges::search_n(Iter(ia), Sent(ia+sa), sa, 5).begin() == Iter(ia+sa));
-    CHECK(ranges::search_n(Iter(ia), Sent(ia+sa), sa, 5).end() == Iter(ia+sa));
-
-    int ib[] = {0, 0, 1, 1, 2, 2};
-    const unsigned sb = sizeof(ib)/sizeof(ib[0]);
-    CHECK(ranges::search_n(Iter(ib), Sent(ib+sb), 0, 0).begin() == Iter(ib));
-    CHECK(ranges::search_n(Iter(ib), Sent(ib+sb), 0, 0).end() == Iter(ib));
-    CHECK(ranges::search_n(Iter(ib), Sent(ib+sb), 1, 0).begin() == Iter(ib+0));
-    CHECK(ranges::search_n(Iter(ib), Sent(ib+sb), 1, 0).end() == Iter(ib+1));
-    CHECK(ranges::search_n(Iter(ib), Sent(ib+sb), 2, 0).begin() == Iter(ib+0));
-    CHECK(ranges::search_n(Iter(ib), Sent(ib+sb), 2, 0).end() == Iter(ib+2));
-    CHECK(ranges::search_n(Iter(ib), Sent(ib+sb), 3, 0).begin() == Iter(ib+sb));
-    CHECK(ranges::search_n(Iter(ib), Sent(ib+sb), 3, 0).end() == Iter(ib+sb));
-    CHECK(ranges::search_n(Iter(ib), Sent(ib+sb), sb, 0).begin() == Iter(ib+sb));
-    CHECK(ranges::search_n(Iter(ib), Sent(ib+sb), sb, 0).end() == Iter(ib+sb));
-    CHECK(ranges::search_n(Iter(ib), Sent(ib+sb), 0, 1).begin() == Iter(ib));
-    CHECK(ranges::search_n(Iter(ib), Sent(ib+sb), 0, 1).end() == Iter(ib));
-    CHECK(ranges::search_n(Iter(ib), Sent(ib+sb), 1, 1).begin() == Iter(ib+2));
-    CHECK(ranges::search_n(Iter(ib), Sent(ib+sb), 1, 1).end() == Iter(ib+3));
-    CHECK(ranges::search_n(Iter(ib), Sent(ib+sb), 2, 1).begin() == Iter(ib+2));
-    CHECK(ranges::search_n(Iter(ib), Sent(ib+sb), 2, 1).end() == Iter(ib+4));
-    CHECK(ranges::search_n(Iter(ib), Sent(ib+sb), 3, 1).begin() == Iter(ib+sb));
-    CHECK(ranges::search_n(Iter(ib), Sent(ib+sb), 3, 1).end() == Iter(ib+sb));
-    CHECK(ranges::search_n(Iter(ib), Sent(ib+sb), sb, 1).begin() == Iter(ib+sb));
-    CHECK(ranges::search_n(Iter(ib), Sent(ib+sb), sb, 1).end() == Iter(ib+sb));
-    CHECK(ranges::search_n(Iter(ib), Sent(ib+sb), 0, 2).begin() == Iter(ib));
-    CHECK(ranges::search_n(Iter(ib), Sent(ib+sb), 0, 2).end() == Iter(ib));
-    CHECK(ranges::search_n(Iter(ib), Sent(ib+sb), 1, 2).begin() == Iter(ib+4));
-    CHECK(ranges::search_n(Iter(ib), Sent(ib+sb), 1, 2).end() == Iter(ib+5));
-    CHECK(ranges::search_n(Iter(ib), Sent(ib+sb), 2, 2).begin() == Iter(ib+4));
-    CHECK(ranges::search_n(Iter(ib), Sent(ib+sb), 2, 2).end() == Iter(ib+6));
-    CHECK(ranges::search_n(Iter(ib), Sent(ib+sb), 3, 2).begin() == Iter(ib+sb));
-    CHECK(ranges::search_n(Iter(ib), Sent(ib+sb), 3, 2).end() == Iter(ib+sb));
-    CHECK(ranges::search_n(Iter(ib), Sent(ib+sb), sb, 2).begin() == Iter(ib+sb));
-    CHECK(ranges::search_n(Iter(ib), Sent(ib+sb), sb, 2).end() == Iter(ib+sb));
-
-    int ic[] = {0, 0, 0};
-    const unsigned sc = sizeof(ic)/sizeof(ic[0]);
-    CHECK(ranges::search_n(Iter(ic), Sent(ic+sc), 0, 0).begin() == Iter(ic));
-    CHECK(ranges::search_n(Iter(ic), Sent(ic+sc), 0, 0).end() == Iter(ic));
-    CHECK(ranges::search_n(Iter(ic), Sent(ic+sc), 1, 0).begin() == Iter(ic));
-    CHECK(ranges::search_n(Iter(ic), Sent(ic+sc), 1, 0).end() == Iter(ic+1));
-    CHECK(ranges::search_n(Iter(ic), Sent(ic+sc), 2, 0).begin() == Iter(ic));
-    CHECK(ranges::search_n(Iter(ic), Sent(ic+sc), 2, 0).end() == Iter(ic+2));
-    CHECK(ranges::search_n(Iter(ic), Sent(ic+sc), 3, 0).begin() == Iter(ic));
-    CHECK(ranges::search_n(Iter(ic), Sent(ic+sc), 3, 0).end() == Iter(ic+3));
-    CHECK(ranges::search_n(Iter(ic), Sent(ic+sc), 4, 0).begin() == Iter(ic+sc));
-    CHECK(ranges::search_n(Iter(ic), Sent(ic+sc), 4, 0).end() == Iter(ic+sc));
-}
-
-template<class Iter, class Iter2>
-void
-test_iter()
-{
-    using Sent = typename sentinel_type<Iter>::type;
-    test_iter_impl<Iter>();
-    test_iter_impl<Iter, Sent>();
-
-    using SizedSent1 = typename sentinel_type<Iter, true>::type;
-    test_iter_impl<Iter, SizedSent1>();
-}
-
-template<class Iter, typename Sent = Iter>
-void
-test_range_impl()
-{
-    int ia[] = {0, 1, 2, 3, 4, 5};
-    const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ia), Sent(ia+sa)), 0, 0).begin() == Iter(ia));
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ia), Sent(ia+sa)), 1, 0).begin() == Iter(ia+0));
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ia), Sent(ia+sa)), 2, 0).begin() == Iter(ia+sa));
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ia), Sent(ia+sa)), sa, 0).begin() == Iter(ia+sa));
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ia), Sent(ia+sa)), 0, 3).begin() == Iter(ia));
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ia), Sent(ia+sa)), 1, 3).begin() == Iter(ia+3));
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ia), Sent(ia+sa)), 2, 3).begin() == Iter(ia+sa));
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ia), Sent(ia+sa)), sa, 3).begin() == Iter(ia+sa));
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ia), Sent(ia+sa)), 0, 5).begin() == Iter(ia));
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ia), Sent(ia+sa)), 1, 5).begin() == Iter(ia+5));
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ia), Sent(ia+sa)), 2, 5).begin() == Iter(ia+sa));
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ia), Sent(ia+sa)), sa, 5).begin() == Iter(ia+sa));
-
-    int ib[] = {0, 0, 1, 1, 2, 2};
-    const unsigned sb = sizeof(ib)/sizeof(ib[0]);
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ib), Sent(ib+sb)), 0, 0).begin() == Iter(ib));
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ib), Sent(ib+sb)), 1, 0).begin() == Iter(ib+0));
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ib), Sent(ib+sb)), 2, 0).begin() == Iter(ib+0));
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ib), Sent(ib+sb)), 3, 0).begin() == Iter(ib+sb));
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ib), Sent(ib+sb)), sb, 0).begin() == Iter(ib+sb));
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ib), Sent(ib+sb)), 0, 1).begin() == Iter(ib));
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ib), Sent(ib+sb)), 1, 1).begin() == Iter(ib+2));
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ib), Sent(ib+sb)), 2, 1).begin() == Iter(ib+2));
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ib), Sent(ib+sb)), 3, 1).begin() == Iter(ib+sb));
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ib), Sent(ib+sb)), sb, 1).begin() == Iter(ib+sb));
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ib), Sent(ib+sb)), 0, 2).begin() == Iter(ib));
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ib), Sent(ib+sb)), 1, 2).begin() == Iter(ib+4));
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ib), Sent(ib+sb)), 2, 2).begin() == Iter(ib+4));
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ib), Sent(ib+sb)), 3, 2).begin() == Iter(ib+sb));
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ib), Sent(ib+sb)), sb, 2).begin() == Iter(ib+sb));
-
-    int ic[] = {0, 0, 0};
-    const unsigned sc = sizeof(ic)/sizeof(ic[0]);
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ic), Sent(ic+sc)), 0, 0).begin() == Iter(ic));
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ic), Sent(ic+sc)), 1, 0).begin() == Iter(ic));
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ic), Sent(ic+sc)), 2, 0).begin() == Iter(ic));
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ic), Sent(ic+sc)), 3, 0).begin() == Iter(ic));
-    CHECK(ranges::search_n(ranges::make_subrange(Iter(ic), Sent(ic+sc)), 4, 0).begin() == Iter(ic+sc));
-}
-
-template<class Iter, class Iter2>
-void
-test_range()
-{
-    using Sent = typename sentinel_type<Iter>::type;
-    test_range_impl<Iter>();
-    test_range_impl<Iter, Sent>();
-
-    using SizedSent1 = typename sentinel_type<Iter, true>::type;
-    test_range_impl<Iter, SizedSent1>();
-}
-
-template<class Iter, class Iter2>
-void
-test()
-{
-    test_iter<Iter, Iter2>();
-    test_range<Iter, Iter2>();
-}
-
-struct S
-{
-    int i;
-};
-
-int main()
-{
-    test<ForwardIterator<const int*>, ForwardIterator<const int*> >();
-    test<ForwardIterator<const int*>, BidirectionalIterator<const int*> >();
-    test<ForwardIterator<const int*>, RandomAccessIterator<const int*> >();
-    test<BidirectionalIterator<const int*>, ForwardIterator<const int*> >();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<const int*> >();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<const int*> >();
-    test<RandomAccessIterator<const int*>, ForwardIterator<const int*> >();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<const int*> >();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<const int*> >();
-
-    // Test projections:
-    {
-        S const in[] = {{0}, {1}, {2}, {2}, {4}, {5}};
-
-        auto sub = ranges::search_n(in, 2, 2, std::equal_to<int>{}, &S::i);
-        CHECK(sub.begin() == in+2);
-        CHECK(sub.end() == in+4);
-    }
-
-    // Test counted ranges
-    {
-        int in[] = {0,1,2,2,4,5};
-        auto rng = ranges::views::counted(BidirectionalIterator<int*>(in), 6);
-        auto sub = ranges::search_n(rng, 2, 2);
-        CHECK(base(sub.begin().base()) == in+2);
-        CHECK(base(sub.end().base()) == in+4);
-        CHECK(sub.begin().count() == 4);
-        CHECK(sub.end().count() == 2);
-
-        auto sub2 = ranges::search_n(rng, 3, 2);
-        CHECK(base(sub2.begin().base()) == in+6);
-        CHECK(base(sub2.end().base()) == in+6);
-        CHECK(sub2.begin().count() == 0);
-        CHECK(sub2.end().count() == 0);
-    }
-
-    // Test rvalue ranges
-    {
-        int ib[] = {0, 0, 1, 1, 2, 2};
-        CHECK(ranges::search_n(ranges::views::all(ib), 2, 1).begin() == ib+2);
-    }
-#ifndef RANGES_WORKAROUND_MSVC_573728
-    {
-        int ib[] = {0, 0, 1, 1, 2, 2};
-        CHECK(::is_dangling(ranges::search_n(std::move(ib), 2, 1)));
-    }
-#endif // RANGES_WORKAROUND_MSVC_573728
-    {
-        std::vector<int> ib{0, 0, 1, 1, 2, 2};
-        CHECK(::is_dangling(ranges::search_n(std::move(ib), 2, 1)));
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/set_difference.hpp b/src/contrib/range-v3-0.11.0/test/algorithm/set_difference.hpp
deleted file mode 100644
index b4988220..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/set_difference.hpp
+++ /dev/null
@@ -1,343 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <algorithm>
-#include <functional>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/fill.hpp>
-#include <range/v3/algorithm/set_algorithm.hpp>
-#include <range/v3/algorithm/lexicographical_compare.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-template<class Iter1, class Iter2, class OutIter>
-void
-test_iter()
-{
-    int ia[] = {1, 2, 2, 3, 3, 3, 4, 4, 4, 4};
-    static const int sa = sizeof(ia)/sizeof(ia[0]);
-    int ib[] = {2, 4, 4, 6};
-    static const int sb = sizeof(ib)/sizeof(ib[0]);
-    int ic[20];
-    int ir[] = {1, 2, 3, 3, 3, 4, 4};
-    static const int sr = sizeof(ir)/sizeof(ir[0]);
-
-    auto set_difference = ::make_testable_2<false, true>(ranges::set_difference);
-
-    set_difference(Iter1(ia), Iter1(ia+sa), Iter2(ib), Iter2(ib+sb), OutIter(ic)).
-        check([&](ranges::set_difference_result<Iter1, OutIter> res)
-        {
-            CHECK((base(res.in1) - ia) == sa);
-            CHECK((base(res.out) - ic) == sr);
-            CHECK(std::lexicographical_compare(ic, base(res.out), ir, ir+sr) == false);
-            ranges::fill(ic, 0);
-        }
-    );
-    int irr[] = {6};
-    static const int srr = sizeof(irr)/sizeof(irr[0]);
-    set_difference(Iter1(ib), Iter1(ib+sb), Iter2(ia), Iter2(ia+sa), OutIter(ic)).
-        check([&](ranges::set_difference_result<Iter1, OutIter> res)
-        {
-            CHECK((base(res.in1) - ib) == sb);
-            CHECK((base(res.out) - ic) == srr);
-            CHECK(std::lexicographical_compare(ic, base(res.out), irr, irr+srr) == false);
-            ranges::fill(ic, 0);
-        }
-    );
-}
-
-template<class Iter1, class Iter2, class OutIter>
-void
-test_comp()
-{
-    int ia[] = {1, 2, 2, 3, 3, 3, 4, 4, 4, 4};
-    static const int sa = sizeof(ia)/sizeof(ia[0]);
-    int ib[] = {2, 4, 4, 6};
-    static const int sb = sizeof(ib)/sizeof(ib[0]);
-    int ic[20];
-    int ir[] = {1, 2, 3, 3, 3, 4, 4};
-    static const int sr = sizeof(ir)/sizeof(ir[0]);
-
-    auto set_difference = ::make_testable_2<false, true>(ranges::set_difference);
-
-    set_difference(Iter1(ia), Iter1(ia+sa), Iter2(ib), Iter2(ib+sb), OutIter(ic), std::less<int>()).
-        check([&](ranges::set_difference_result<Iter1, OutIter> res)
-        {
-            CHECK((base(res.in1) - ia) == sa);
-            CHECK((base(res.out) - ic) == sr);
-            CHECK(std::lexicographical_compare(ic, base(res.out), ir, ir+sr) == false);
-            ranges::fill(ic, 0);
-        }
-    );
-    int irr[] = {6};
-    static const int srr = sizeof(irr)/sizeof(irr[0]);
-    set_difference(Iter1(ib), Iter1(ib+sb), Iter2(ia), Iter2(ia+sa), OutIter(ic), std::less<int>()).
-        check([&](ranges::set_difference_result<Iter1, OutIter> res)
-        {
-            CHECK((base(res.in1) - ib) == sb);
-            CHECK((base(res.out) - ic) == srr);
-            CHECK(std::lexicographical_compare(ic, base(res.out), irr, irr+srr) == false);
-            ranges::fill(ic, 0);
-        }
-    );
-}
-
-template<class Iter1, class Iter2, class OutIter>
-void test()
-{
-    test_iter<Iter1, Iter2, OutIter>();
-    test_comp<Iter1, Iter2, OutIter>();
-}
-
-struct S
-{
-    int i;
-};
-
-struct T
-{
-    int j;
-};
-
-struct U
-{
-    int k;
-    U& operator=(S s) { k = s.i; return *this;}
-    U& operator=(T t) { k = t.j; return *this;}
-};
-
-int main()
-{
-#ifdef SET_DIFFERENCE_1
-    test<InputIterator<const int*>, InputIterator<const int*>, OutputIterator<int*> >();
-    test<InputIterator<const int*>, InputIterator<const int*>, ForwardIterator<int*> >();
-    test<InputIterator<const int*>, InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test<InputIterator<const int*>, InputIterator<const int*>, RandomAccessIterator<int*> >();
-    test<InputIterator<const int*>, InputIterator<const int*>, int*>();
-
-    test<InputIterator<const int*>, ForwardIterator<const int*>, OutputIterator<int*> >();
-    test<InputIterator<const int*>, ForwardIterator<const int*>, ForwardIterator<int*> >();
-    test<InputIterator<const int*>, ForwardIterator<const int*>, BidirectionalIterator<int*> >();
-    test<InputIterator<const int*>, ForwardIterator<const int*>, RandomAccessIterator<int*> >();
-    test<InputIterator<const int*>, ForwardIterator<const int*>, int*>();
-
-    test<InputIterator<const int*>, BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test<InputIterator<const int*>, BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test<InputIterator<const int*>, BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test<InputIterator<const int*>, BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test<InputIterator<const int*>, BidirectionalIterator<const int*>, int*>();
-
-    test<InputIterator<const int*>, RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test<InputIterator<const int*>, RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test<InputIterator<const int*>, RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test<InputIterator<const int*>, RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test<InputIterator<const int*>, RandomAccessIterator<const int*>, int*>();
-
-    test<InputIterator<const int*>, const int*, OutputIterator<int*> >();
-    test<InputIterator<const int*>, const int*, ForwardIterator<int*> >();
-    test<InputIterator<const int*>, const int*, BidirectionalIterator<int*> >();
-    test<InputIterator<const int*>, const int*, RandomAccessIterator<int*> >();
-    test<InputIterator<const int*>, const int*, int*>();
-#endif
-#ifdef SET_DIFFERENCE_2
-    test<ForwardIterator<const int*>, InputIterator<const int*>, OutputIterator<int*> >();
-    test<ForwardIterator<const int*>, InputIterator<const int*>, ForwardIterator<int*> >();
-    test<ForwardIterator<const int*>, InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test<ForwardIterator<const int*>, InputIterator<const int*>, RandomAccessIterator<int*> >();
-    test<ForwardIterator<const int*>, InputIterator<const int*>, int*>();
-
-    test<ForwardIterator<const int*>, ForwardIterator<const int*>, OutputIterator<int*> >();
-    test<ForwardIterator<const int*>, ForwardIterator<const int*>, ForwardIterator<int*> >();
-    test<ForwardIterator<const int*>, ForwardIterator<const int*>, BidirectionalIterator<int*> >();
-    test<ForwardIterator<const int*>, ForwardIterator<const int*>, RandomAccessIterator<int*> >();
-    test<ForwardIterator<const int*>, ForwardIterator<const int*>, int*>();
-
-    test<ForwardIterator<const int*>, BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test<ForwardIterator<const int*>, BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test<ForwardIterator<const int*>, BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test<ForwardIterator<const int*>, BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test<ForwardIterator<const int*>, BidirectionalIterator<const int*>, int*>();
-
-    test<ForwardIterator<const int*>, RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test<ForwardIterator<const int*>, RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test<ForwardIterator<const int*>, RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test<ForwardIterator<const int*>, RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test<ForwardIterator<const int*>, RandomAccessIterator<const int*>, int*>();
-
-    test<ForwardIterator<const int*>, const int*, OutputIterator<int*> >();
-    test<ForwardIterator<const int*>, const int*, ForwardIterator<int*> >();
-    test<ForwardIterator<const int*>, const int*, BidirectionalIterator<int*> >();
-    test<ForwardIterator<const int*>, const int*, RandomAccessIterator<int*> >();
-    test<ForwardIterator<const int*>, const int*, int*>();
-#endif
-#ifdef SET_DIFFERENCE_3
-    test<BidirectionalIterator<const int*>, InputIterator<const int*>, OutputIterator<int*> >();
-    test<BidirectionalIterator<const int*>, InputIterator<const int*>, ForwardIterator<int*> >();
-    test<BidirectionalIterator<const int*>, InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test<BidirectionalIterator<const int*>, InputIterator<const int*>, RandomAccessIterator<int*> >();
-    test<BidirectionalIterator<const int*>, InputIterator<const int*>, int*>();
-
-    test<BidirectionalIterator<const int*>, ForwardIterator<const int*>, OutputIterator<int*> >();
-    test<BidirectionalIterator<const int*>, ForwardIterator<const int*>, ForwardIterator<int*> >();
-    test<BidirectionalIterator<const int*>, ForwardIterator<const int*>, BidirectionalIterator<int*> >();
-    test<BidirectionalIterator<const int*>, ForwardIterator<const int*>, RandomAccessIterator<int*> >();
-    test<BidirectionalIterator<const int*>, ForwardIterator<const int*>, int*>();
-
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<const int*>, int*>();
-
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<const int*>, int*>();
-
-    test<BidirectionalIterator<const int*>, const int*, OutputIterator<int*> >();
-    test<BidirectionalIterator<const int*>, const int*, ForwardIterator<int*> >();
-    test<BidirectionalIterator<const int*>, const int*, BidirectionalIterator<int*> >();
-    test<BidirectionalIterator<const int*>, const int*, RandomAccessIterator<int*> >();
-    test<BidirectionalIterator<const int*>, const int*, int*>();
-#endif
-#ifdef SET_DIFFERENCE_4
-    test<RandomAccessIterator<const int*>, InputIterator<const int*>, OutputIterator<int*> >();
-    test<RandomAccessIterator<const int*>, InputIterator<const int*>, ForwardIterator<int*> >();
-    test<RandomAccessIterator<const int*>, InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<const int*>, InputIterator<const int*>, RandomAccessIterator<int*> >();
-    test<RandomAccessIterator<const int*>, InputIterator<const int*>, int*>();
-
-    test<RandomAccessIterator<const int*>, ForwardIterator<const int*>, OutputIterator<int*> >();
-    test<RandomAccessIterator<const int*>, ForwardIterator<const int*>, ForwardIterator<int*> >();
-    test<RandomAccessIterator<const int*>, ForwardIterator<const int*>, BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<const int*>, ForwardIterator<const int*>, RandomAccessIterator<int*> >();
-    test<RandomAccessIterator<const int*>, ForwardIterator<const int*>, int*>();
-
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<const int*>, int*>();
-
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<const int*>, int*>();
-
-    test<RandomAccessIterator<const int*>, const int*, OutputIterator<int*> >();
-    test<RandomAccessIterator<const int*>, const int*, ForwardIterator<int*> >();
-    test<RandomAccessIterator<const int*>, const int*, BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<const int*>, const int*, RandomAccessIterator<int*> >();
-    test<RandomAccessIterator<const int*>, const int*, int*>();
-#endif
-#ifdef SET_DIFFERENCE_5
-    test<const int*, InputIterator<const int*>, OutputIterator<int*> >();
-    test<const int*, InputIterator<const int*>, BidirectionalIterator<int*> >();    test<const int*, InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test<const int*, InputIterator<const int*>, RandomAccessIterator<int*> >();
-    test<const int*, InputIterator<const int*>, int*>();
-
-    test<const int*, ForwardIterator<const int*>, OutputIterator<int*> >();
-    test<const int*, ForwardIterator<const int*>, ForwardIterator<int*> >();
-    test<const int*, ForwardIterator<const int*>, BidirectionalIterator<int*> >();
-    test<const int*, ForwardIterator<const int*>, RandomAccessIterator<int*> >();
-    test<const int*, ForwardIterator<const int*>, int*>();
-
-    test<const int*, BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test<const int*, BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test<const int*, BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test<const int*, BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test<const int*, BidirectionalIterator<const int*>, int*>();
-
-    test<const int*, RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test<const int*, RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test<const int*, RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test<const int*, RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test<const int*, RandomAccessIterator<const int*>, int*>();
-
-    test<const int*, const int*, OutputIterator<int*> >();
-    test<const int*, const int*, ForwardIterator<int*> >();
-    test<const int*, const int*, BidirectionalIterator<int*> >();
-    test<const int*, const int*, RandomAccessIterator<int*> >();
-    test<const int*, const int*, int*>();
-#endif
-#ifdef SET_DIFFERENCE_6
-    // Test projections
-    {
-        S ia[] = {S{1}, S{2}, S{2}, S{3}, S{3}, S{3}, S{4}, S{4}, S{4}, S{4}};
-        static const int sa = sizeof(ia)/sizeof(ia[0]);
-        T ib[] = {T{2}, T{4}, T{4}, T{6}};
-        static const int sb = sizeof(ib)/sizeof(ib[0]);
-        U ic[20];
-        int ir[] = {1, 2, 3, 3, 3, 4, 4};
-        static const int sr = sizeof(ir)/sizeof(ir[0]);
-
-        ranges::set_difference_result<S *, U *> res = ranges::set_difference(ia, ib, ic, std::less<int>(), &S::i, &T::j);
-        CHECK((res.in1 - ia) == sa);
-        CHECK((res.out - ic) == sr);
-        CHECK(ranges::lexicographical_compare(ic, res.out, ir, ir+sr, std::less<int>(), &U::k) == false);
-        ranges::fill(ic, U{0});
-
-        int irr[] = {6};
-        static const int srr = sizeof(irr)/sizeof(irr[0]);
-        ranges::set_difference_result<T *, U *> res2 = ranges::set_difference(ib, ia, ic, std::less<int>(), &T::j, &S::i);
-        CHECK((res2.in1 - ib) == sb);
-        CHECK((res2.out - ic) == srr);
-        CHECK(ranges::lexicographical_compare(ic, res2.out, ir, irr+srr, std::less<int>(), &U::k) == false);
-    }
-
-    // Test rvalue ranges
-    {
-        S ia[] = {S{1}, S{2}, S{2}, S{3}, S{3}, S{3}, S{4}, S{4}, S{4}, S{4}};
-        T ib[] = {T{2}, T{4}, T{4}, T{6}};
-        static const int sb = sizeof(ib)/sizeof(ib[0]);
-        U ic[20];
-        int ir[] = {1, 2, 3, 3, 3, 4, 4};
-        static const int sr = sizeof(ir)/sizeof(ir[0]);
-
-        auto res = ranges::set_difference(std::move(ia), ranges::views::all(ib), ic, std::less<int>(), &S::i, &T::j);
-#ifndef RANGES_WORKAROUND_MSVC_573728
-        CHECK(::is_dangling(res.in1));
-#endif // RANGES_WORKAROUND_MSVC_573728
-        CHECK((res.out - ic) == sr);
-        CHECK(ranges::lexicographical_compare(ic, res.out, ir, ir+sr, std::less<int>(), &U::k) == false);
-
-        ranges::fill(ic, U{0});
-        int irr[] = {6};
-        static const int srr = sizeof(irr)/sizeof(irr[0]);
-        auto res2 = ranges::set_difference(ranges::views::all(ib), ranges::views::all(ia), ic, std::less<int>(), &T::j, &S::i);
-        CHECK((res2.in1 - ib) == sb);
-        CHECK((res2.out - ic) == srr);
-        CHECK(ranges::lexicographical_compare(ic, res2.out, ir, irr+srr, std::less<int>(), &U::k) == false);
-
-        ranges::fill(ic, U{0});
-        std::vector<S> vec{S{1}, S{2}, S{2}, S{3}, S{3}, S{3}, S{4}, S{4}, S{4}, S{4}};
-        auto res3 = ranges::set_difference(std::move(vec), ranges::views::all(ib), ic, std::less<int>(), &S::i, &T::j);
-        CHECK(::is_dangling(res3.in1));
-        CHECK((res3.out - ic) == sr);
-        CHECK(ranges::lexicographical_compare(ic, res3.out, ir, ir+sr, std::less<int>(), &U::k) == false);
-    }
-#endif
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/set_difference1.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/set_difference1.cpp
deleted file mode 100644
index 1c65892b..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/set_difference1.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define SET_DIFFERENCE_1
-#include "./set_difference.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/set_difference2.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/set_difference2.cpp
deleted file mode 100644
index ecb3b49c..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/set_difference2.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define SET_DIFFERENCE_2
-#include "./set_difference.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/set_difference3.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/set_difference3.cpp
deleted file mode 100644
index ecf298a9..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/set_difference3.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define SET_DIFFERENCE_3
-#include "./set_difference.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/set_difference4.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/set_difference4.cpp
deleted file mode 100644
index 1d4d5a02..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/set_difference4.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define SET_DIFFERENCE_4
-#include "./set_difference.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/set_difference5.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/set_difference5.cpp
deleted file mode 100644
index 69250c4e..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/set_difference5.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define SET_DIFFERENCE_5
-#include "./set_difference.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/set_difference6.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/set_difference6.cpp
deleted file mode 100644
index 0d3de449..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/set_difference6.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define SET_DIFFERENCE_6
-#include "./set_difference.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/set_intersection.hpp b/src/contrib/range-v3-0.11.0/test/algorithm/set_intersection.hpp
deleted file mode 100644
index daa0e365..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/set_intersection.hpp
+++ /dev/null
@@ -1,267 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <algorithm>
-#include <functional>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/fill.hpp>
-#include <range/v3/algorithm/set_algorithm.hpp>
-#include <range/v3/algorithm/lexicographical_compare.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-template<class Iter1, class Iter2, class OutIter>
-void
-test()
-{
-    int ia[] = {1, 2, 2, 3, 3, 3, 4, 4, 4, 4};
-    static const int sa = sizeof(ia)/sizeof(ia[0]);
-    int ib[] = {2, 4, 4, 6};
-    static const int sb = sizeof(ib)/sizeof(ib[0]);
-    int ic[20];
-    int ir[] = {2, 4, 4};
-    static const int sr = sizeof(ir)/sizeof(ir[0]);
-
-    auto set_intersection = ::make_testable_2<true, true>(ranges::set_intersection);
-
-    set_intersection(Iter1(ia), Iter1(ia+sa),
-                     Iter2(ib), Iter2(ib+sb), OutIter(ic)).check([&](OutIter ce)
-        {
-            CHECK((base(ce) - ic) == sr);
-            CHECK(std::lexicographical_compare(ic, base(ce), ir, ir+sr) == false);
-            ranges::fill(ic, 0);
-        });
-    set_intersection(Iter1(ib), Iter1(ib+sb),
-                     Iter2(ia), Iter2(ia+sa), OutIter(ic)).check([&](OutIter ce)
-        {
-            CHECK((base(ce) - ic) == sr);
-            CHECK(std::lexicographical_compare(ic, base(ce), ir, ir+sr) == false);
-            ranges::fill(ic, 0);
-        });
-
-
-    set_intersection(Iter1(ia), Iter1(ia+sa),
-                     Iter2(ib), Iter2(ib+sb), OutIter(ic), std::less<int>()).check([&](OutIter ce)
-        {
-            CHECK((base(ce) - ic) == sr);
-            CHECK(std::lexicographical_compare(ic, base(ce), ir, ir+sr) == false);
-            ranges::fill(ic, 0);
-        });
-    set_intersection(Iter1(ib), Iter1(ib+sb),
-                     Iter2(ia), Iter2(ia+sa), OutIter(ic), std::less<int>()).check([&](OutIter ce)
-        {
-            CHECK((base(ce) - ic) == sr);
-            CHECK(std::lexicographical_compare(ic, base(ce), ir, ir+sr) == false);
-            ranges::fill(ic, 0);
-        });
-}
-
-struct S
-{
-    int i;
-};
-
-struct T
-{
-    int j;
-};
-
-struct U
-{
-    int k;
-    U& operator=(S s) { k = s.i; return *this;}
-    U& operator=(T t) { k = t.j; return *this;}
-};
-
-int main()
-{
-#ifdef SET_INTERSECTION_1
-    test<InputIterator<const int*>, InputIterator<const int*>, OutputIterator<int*> >();
-    test<InputIterator<const int*>, InputIterator<const int*>, ForwardIterator<int*> >();
-    test<InputIterator<const int*>, InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test<InputIterator<const int*>, InputIterator<const int*>, RandomAccessIterator<int*> >();
-    test<InputIterator<const int*>, InputIterator<const int*>, int*>();
-
-    test<InputIterator<const int*>, ForwardIterator<const int*>, OutputIterator<int*> >();
-    test<InputIterator<const int*>, ForwardIterator<const int*>, ForwardIterator<int*> >();
-    test<InputIterator<const int*>, ForwardIterator<const int*>, BidirectionalIterator<int*> >();
-    test<InputIterator<const int*>, ForwardIterator<const int*>, RandomAccessIterator<int*> >();
-    test<InputIterator<const int*>, ForwardIterator<const int*>, int*>();
-
-    test<InputIterator<const int*>, BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test<InputIterator<const int*>, BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test<InputIterator<const int*>, BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test<InputIterator<const int*>, BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test<InputIterator<const int*>, BidirectionalIterator<const int*>, int*>();
-
-    test<InputIterator<const int*>, RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test<InputIterator<const int*>, RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test<InputIterator<const int*>, RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test<InputIterator<const int*>, RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test<InputIterator<const int*>, RandomAccessIterator<const int*>, int*>();
-
-    test<InputIterator<const int*>, const int*, OutputIterator<int*> >();
-    test<InputIterator<const int*>, const int*, ForwardIterator<int*> >();
-    test<InputIterator<const int*>, const int*, BidirectionalIterator<int*> >();
-    test<InputIterator<const int*>, const int*, RandomAccessIterator<int*> >();
-    test<InputIterator<const int*>, const int*, int*>();
-#endif
-#ifdef SET_INTERSECTION_2
-    test<ForwardIterator<const int*>, InputIterator<const int*>, OutputIterator<int*> >();
-    test<ForwardIterator<const int*>, InputIterator<const int*>, ForwardIterator<int*> >();
-    test<ForwardIterator<const int*>, InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test<ForwardIterator<const int*>, InputIterator<const int*>, RandomAccessIterator<int*> >();
-    test<ForwardIterator<const int*>, InputIterator<const int*>, int*>();
-
-    test<ForwardIterator<const int*>, ForwardIterator<const int*>, OutputIterator<int*> >();
-    test<ForwardIterator<const int*>, ForwardIterator<const int*>, ForwardIterator<int*> >();
-    test<ForwardIterator<const int*>, ForwardIterator<const int*>, BidirectionalIterator<int*> >();
-    test<ForwardIterator<const int*>, ForwardIterator<const int*>, RandomAccessIterator<int*> >();
-    test<ForwardIterator<const int*>, ForwardIterator<const int*>, int*>();
-
-    test<ForwardIterator<const int*>, BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test<ForwardIterator<const int*>, BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test<ForwardIterator<const int*>, BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test<ForwardIterator<const int*>, BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test<ForwardIterator<const int*>, BidirectionalIterator<const int*>, int*>();
-
-    test<ForwardIterator<const int*>, RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test<ForwardIterator<const int*>, RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test<ForwardIterator<const int*>, RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test<ForwardIterator<const int*>, RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test<ForwardIterator<const int*>, RandomAccessIterator<const int*>, int*>();
-
-    test<ForwardIterator<const int*>, const int*, OutputIterator<int*> >();
-    test<ForwardIterator<const int*>, const int*, ForwardIterator<int*> >();
-    test<ForwardIterator<const int*>, const int*, BidirectionalIterator<int*> >();
-    test<ForwardIterator<const int*>, const int*, RandomAccessIterator<int*> >();
-    test<ForwardIterator<const int*>, const int*, int*>();
-#endif
-#ifdef SET_INTERSECTION_3
-    test<BidirectionalIterator<const int*>, InputIterator<const int*>, OutputIterator<int*> >();
-    test<BidirectionalIterator<const int*>, InputIterator<const int*>, ForwardIterator<int*> >();
-    test<BidirectionalIterator<const int*>, InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test<BidirectionalIterator<const int*>, InputIterator<const int*>, RandomAccessIterator<int*> >();
-    test<BidirectionalIterator<const int*>, InputIterator<const int*>, int*>();
-
-    test<BidirectionalIterator<const int*>, ForwardIterator<const int*>, OutputIterator<int*> >();
-    test<BidirectionalIterator<const int*>, ForwardIterator<const int*>, ForwardIterator<int*> >();
-    test<BidirectionalIterator<const int*>, ForwardIterator<const int*>, BidirectionalIterator<int*> >();
-    test<BidirectionalIterator<const int*>, ForwardIterator<const int*>, RandomAccessIterator<int*> >();
-    test<BidirectionalIterator<const int*>, ForwardIterator<const int*>, int*>();
-
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<const int*>, int*>();
-
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<const int*>, int*>();
-
-    test<BidirectionalIterator<const int*>, const int*, OutputIterator<int*> >();
-    test<BidirectionalIterator<const int*>, const int*, ForwardIterator<int*> >();
-    test<BidirectionalIterator<const int*>, const int*, BidirectionalIterator<int*> >();
-    test<BidirectionalIterator<const int*>, const int*, RandomAccessIterator<int*> >();
-    test<BidirectionalIterator<const int*>, const int*, int*>();
-#endif
-#ifdef SET_INTERSECTION_4
-    test<RandomAccessIterator<const int*>, InputIterator<const int*>, OutputIterator<int*> >();
-    test<RandomAccessIterator<const int*>, InputIterator<const int*>, ForwardIterator<int*> >();
-    test<RandomAccessIterator<const int*>, InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<const int*>, InputIterator<const int*>, RandomAccessIterator<int*> >();
-    test<RandomAccessIterator<const int*>, InputIterator<const int*>, int*>();
-
-    test<RandomAccessIterator<const int*>, ForwardIterator<const int*>, OutputIterator<int*> >();
-    test<RandomAccessIterator<const int*>, ForwardIterator<const int*>, ForwardIterator<int*> >();
-    test<RandomAccessIterator<const int*>, ForwardIterator<const int*>, BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<const int*>, ForwardIterator<const int*>, RandomAccessIterator<int*> >();
-    test<RandomAccessIterator<const int*>, ForwardIterator<const int*>, int*>();
-
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<const int*>, int*>();
-
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<const int*>, int*>();
-
-    test<RandomAccessIterator<const int*>, const int*, OutputIterator<int*> >();
-    test<RandomAccessIterator<const int*>, const int*, ForwardIterator<int*> >();
-    test<RandomAccessIterator<const int*>, const int*, BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<const int*>, const int*, RandomAccessIterator<int*> >();
-    test<RandomAccessIterator<const int*>, const int*, int*>();
-#endif
-#ifdef SET_INTERSECTION_5
-    test<const int*, InputIterator<const int*>, OutputIterator<int*> >();
-    test<const int*, InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test<const int*, InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test<const int*, InputIterator<const int*>, RandomAccessIterator<int*> >();
-    test<const int*, InputIterator<const int*>, int*>();
-
-    test<const int*, ForwardIterator<const int*>, OutputIterator<int*> >();
-    test<const int*, ForwardIterator<const int*>, ForwardIterator<int*> >();
-    test<const int*, ForwardIterator<const int*>, BidirectionalIterator<int*> >();
-    test<const int*, ForwardIterator<const int*>, RandomAccessIterator<int*> >();
-    test<const int*, ForwardIterator<const int*>, int*>();
-
-    test<const int*, BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test<const int*, BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test<const int*, BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test<const int*, BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test<const int*, BidirectionalIterator<const int*>, int*>();
-
-    test<const int*, RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test<const int*, RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test<const int*, RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test<const int*, RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test<const int*, RandomAccessIterator<const int*>, int*>();
-
-    test<const int*, const int*, OutputIterator<int*> >();
-    test<const int*, const int*, ForwardIterator<int*> >();
-    test<const int*, const int*, BidirectionalIterator<int*> >();
-    test<const int*, const int*, RandomAccessIterator<int*> >();
-    test<const int*, const int*, int*>();
-#endif
-#ifdef SET_INTERSECTION_6
-    // Test projections
-    {
-        S ia[] = {S{1}, S{2}, S{2}, S{3}, S{3}, S{3}, S{4}, S{4}, S{4}, S{4}};
-        T ib[] = {T{2}, T{4}, T{4}, T{6}};
-        U ic[20];
-        int ir[] = {2, 4, 4};
-        static const int sr = sizeof(ir)/sizeof(ir[0]);
-
-        U * res = ranges::set_intersection(ranges::views::all(ia), ranges::views::all(ib), ic, std::less<int>(), &S::i, &T::j);
-        CHECK((res - ic) == sr);
-        CHECK(ranges::lexicographical_compare(ic, res, ir, ir+sr, std::less<int>(), &U::k) == false);
-    }
-#endif
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/set_intersection1.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/set_intersection1.cpp
deleted file mode 100644
index 9a09481a..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/set_intersection1.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define SET_INTERSECTION_1
-#include "./set_intersection.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/set_intersection2.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/set_intersection2.cpp
deleted file mode 100644
index ab46bb66..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/set_intersection2.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define SET_INTERSECTION_2
-#include "./set_intersection.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/set_intersection3.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/set_intersection3.cpp
deleted file mode 100644
index a8d25ff9..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/set_intersection3.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define SET_INTERSECTION_3
-#include "./set_intersection.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/set_intersection4.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/set_intersection4.cpp
deleted file mode 100644
index 4fa15e93..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/set_intersection4.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define SET_INTERSECTION_4
-#include "./set_intersection.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/set_intersection5.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/set_intersection5.cpp
deleted file mode 100644
index b2811215..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/set_intersection5.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define SET_INTERSECTION_5
-#include "./set_intersection.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/set_intersection6.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/set_intersection6.cpp
deleted file mode 100644
index bcd5ece7..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/set_intersection6.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define SET_INTERSECTION_6
-#include "./set_intersection.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/set_symmetric_difference.hpp b/src/contrib/range-v3-0.11.0/test/algorithm/set_symmetric_difference.hpp
deleted file mode 100644
index a0c28e1e..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/set_symmetric_difference.hpp
+++ /dev/null
@@ -1,350 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <algorithm>
-#include <functional>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/fill.hpp>
-#include <range/v3/algorithm/set_algorithm.hpp>
-#include <range/v3/algorithm/lexicographical_compare.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-template<class Iter1, class Iter2, class OutIter>
-void
-test_iter()
-{
-    int ia[] = {1, 2, 2, 3, 3, 3, 4, 4, 4, 4};
-    static const int sa = sizeof(ia)/sizeof(ia[0]);
-    int ib[] = {2, 4, 4, 6};
-    static const int sb = sizeof(ib)/sizeof(ib[0]);
-    int ic[20];
-    int ir[] = {1, 2, 3, 3, 3, 4, 4, 6};
-    static const int sr = sizeof(ir)/sizeof(ir[0]);
-
-    auto set_symmetric_difference = ::make_testable_2(ranges::set_symmetric_difference);
-
-    set_symmetric_difference(Iter1(ia), Iter1(ia+sa), Iter2(ib), Iter2(ib+sb), OutIter(ic)).
-        check([&](ranges::set_symmetric_difference_result<Iter1, Iter2, OutIter> res)
-        {
-            CHECK((base(res.out) - ic) == sr);
-            CHECK(std::lexicographical_compare(ic, base(res.out), ir, ir+sr) == false);
-            ranges::fill(ic, 0);
-        }
-    );
-
-    set_symmetric_difference(Iter1(ib), Iter1(ib+sb), Iter2(ia), Iter2(ia+sa), OutIter(ic)).
-        check([&](ranges::set_symmetric_difference_result<Iter1, Iter2, OutIter> res)
-        {
-            CHECK((base(res.out) - ic) == sr);
-            CHECK(std::lexicographical_compare(ic, base(res.out), ir, ir+sr) == false);
-            ranges::fill(ic, 0);
-        }
-    );
-}
-
-template<class Iter1, class Iter2, class OutIter>
-void
-test_comp()
-{
-    int ia[] = {1, 2, 2, 3, 3, 3, 4, 4, 4, 4};
-    static const int sa = sizeof(ia)/sizeof(ia[0]);
-    int ib[] = {2, 4, 4, 6};
-    static const int sb = sizeof(ib)/sizeof(ib[0]);
-    int ic[20];
-    int ir[] = {1, 2, 3, 3, 3, 4, 4, 6};
-    static const int sr = sizeof(ir)/sizeof(ir[0]);
-
-    auto set_symmetric_difference = ::make_testable_2(ranges::set_symmetric_difference);
-
-    set_symmetric_difference(Iter1(ia), Iter1(ia+sa), Iter2(ib), Iter2(ib+sb), OutIter(ic), std::less<int>()).
-        check([&](ranges::set_symmetric_difference_result<Iter1, Iter2, OutIter> res)
-        {
-            CHECK((base(res.out) - ic) == sr);
-            CHECK(std::lexicographical_compare(ic, base(res.out), ir, ir+sr) == false);
-            ranges::fill(ic, 0);
-        }
-    );
-
-    set_symmetric_difference(Iter1(ib), Iter1(ib+sb), Iter2(ia), Iter2(ia+sa), OutIter(ic), std::less<int>()).
-        check([&](ranges::set_symmetric_difference_result<Iter1, Iter2, OutIter> res)
-        {
-            CHECK((base(res.out) - ic) == sr);
-            CHECK(std::lexicographical_compare(ic, base(res.out), ir, ir+sr) == false);
-            ranges::fill(ic, 0);
-        }
-    );
-}
-
-template<class Iter1, class Iter2, class OutIter>
-void test()
-{
-    test_iter<Iter1, Iter2, OutIter>();
-    test_comp<Iter1, Iter2, OutIter>();
-}
-
-struct S
-{
-    int i;
-};
-
-struct T
-{
-    int j;
-};
-
-struct U
-{
-    int k;
-    U& operator=(S s) { k = s.i; return *this;}
-    U& operator=(T t) { k = t.j; return *this;}
-};
-
-int main()
-{
-#ifdef SET_SYMMETRIC_DIFFERENCE_1
-    test<InputIterator<const int*>, InputIterator<const int*>, OutputIterator<int*> >();
-    test<InputIterator<const int*>, InputIterator<const int*>, ForwardIterator<int*> >();
-    test<InputIterator<const int*>, InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test<InputIterator<const int*>, InputIterator<const int*>, RandomAccessIterator<int*> >();
-    test<InputIterator<const int*>, InputIterator<const int*>, int*>();
-
-    test<InputIterator<const int*>, ForwardIterator<const int*>, OutputIterator<int*> >();
-    test<InputIterator<const int*>, ForwardIterator<const int*>, ForwardIterator<int*> >();
-    test<InputIterator<const int*>, ForwardIterator<const int*>, BidirectionalIterator<int*> >();
-    test<InputIterator<const int*>, ForwardIterator<const int*>, RandomAccessIterator<int*> >();
-    test<InputIterator<const int*>, ForwardIterator<const int*>, int*>();
-
-    test<InputIterator<const int*>, BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test<InputIterator<const int*>, BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test<InputIterator<const int*>, BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test<InputIterator<const int*>, BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test<InputIterator<const int*>, BidirectionalIterator<const int*>, int*>();
-
-    test<InputIterator<const int*>, RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test<InputIterator<const int*>, RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test<InputIterator<const int*>, RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test<InputIterator<const int*>, RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test<InputIterator<const int*>, RandomAccessIterator<const int*>, int*>();
-
-    test<InputIterator<const int*>, const int*, OutputIterator<int*> >();
-    test<InputIterator<const int*>, const int*, ForwardIterator<int*> >();
-    test<InputIterator<const int*>, const int*, BidirectionalIterator<int*> >();
-    test<InputIterator<const int*>, const int*, RandomAccessIterator<int*> >();
-    test<InputIterator<const int*>, const int*, int*>();
-#endif
-#ifdef SET_SYMMETRIC_DIFFERENCE_2
-    test<ForwardIterator<const int*>, InputIterator<const int*>, OutputIterator<int*> >();
-    test<ForwardIterator<const int*>, InputIterator<const int*>, ForwardIterator<int*> >();
-    test<ForwardIterator<const int*>, InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test<ForwardIterator<const int*>, InputIterator<const int*>, RandomAccessIterator<int*> >();
-    test<ForwardIterator<const int*>, InputIterator<const int*>, int*>();
-
-    test<ForwardIterator<const int*>, ForwardIterator<const int*>, OutputIterator<int*> >();
-    test<ForwardIterator<const int*>, ForwardIterator<const int*>, ForwardIterator<int*> >();
-    test<ForwardIterator<const int*>, ForwardIterator<const int*>, BidirectionalIterator<int*> >();
-    test<ForwardIterator<const int*>, ForwardIterator<const int*>, RandomAccessIterator<int*> >();
-    test<ForwardIterator<const int*>, ForwardIterator<const int*>, int*>();
-
-    test<ForwardIterator<const int*>, BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test<ForwardIterator<const int*>, BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test<ForwardIterator<const int*>, BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test<ForwardIterator<const int*>, BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test<ForwardIterator<const int*>, BidirectionalIterator<const int*>, int*>();
-
-    test<ForwardIterator<const int*>, RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test<ForwardIterator<const int*>, RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test<ForwardIterator<const int*>, RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test<ForwardIterator<const int*>, RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test<ForwardIterator<const int*>, RandomAccessIterator<const int*>, int*>();
-
-    test<ForwardIterator<const int*>, const int*, OutputIterator<int*> >();
-    test<ForwardIterator<const int*>, const int*, ForwardIterator<int*> >();
-    test<ForwardIterator<const int*>, const int*, BidirectionalIterator<int*> >();
-    test<ForwardIterator<const int*>, const int*, RandomAccessIterator<int*> >();
-    test<ForwardIterator<const int*>, const int*, int*>();
-#endif
-#ifdef SET_SYMMETRIC_DIFFERENCE_3
-    test<BidirectionalIterator<const int*>, InputIterator<const int*>, OutputIterator<int*> >();
-    test<BidirectionalIterator<const int*>, InputIterator<const int*>, ForwardIterator<int*> >();
-    test<BidirectionalIterator<const int*>, InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test<BidirectionalIterator<const int*>, InputIterator<const int*>, RandomAccessIterator<int*> >();
-    test<BidirectionalIterator<const int*>, InputIterator<const int*>, int*>();
-
-    test<BidirectionalIterator<const int*>, ForwardIterator<const int*>, OutputIterator<int*> >();
-    test<BidirectionalIterator<const int*>, ForwardIterator<const int*>, ForwardIterator<int*> >();
-    test<BidirectionalIterator<const int*>, ForwardIterator<const int*>, BidirectionalIterator<int*> >();
-    test<BidirectionalIterator<const int*>, ForwardIterator<const int*>, RandomAccessIterator<int*> >();
-    test<BidirectionalIterator<const int*>, ForwardIterator<const int*>, int*>();
-
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<const int*>, int*>();
-
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<const int*>, int*>();
-
-    test<BidirectionalIterator<const int*>, const int*, OutputIterator<int*> >();
-    test<BidirectionalIterator<const int*>, const int*, ForwardIterator<int*> >();
-    test<BidirectionalIterator<const int*>, const int*, BidirectionalIterator<int*> >();
-    test<BidirectionalIterator<const int*>, const int*, RandomAccessIterator<int*> >();
-    test<BidirectionalIterator<const int*>, const int*, int*>();
-#endif
-#ifdef SET_SYMMETRIC_DIFFERENCE_4
-    test<RandomAccessIterator<const int*>, InputIterator<const int*>, OutputIterator<int*> >();
-    test<RandomAccessIterator<const int*>, InputIterator<const int*>, ForwardIterator<int*> >();
-    test<RandomAccessIterator<const int*>, InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<const int*>, InputIterator<const int*>, RandomAccessIterator<int*> >();
-    test<RandomAccessIterator<const int*>, InputIterator<const int*>, int*>();
-
-    test<RandomAccessIterator<const int*>, ForwardIterator<const int*>, OutputIterator<int*> >();
-    test<RandomAccessIterator<const int*>, ForwardIterator<const int*>, ForwardIterator<int*> >();
-    test<RandomAccessIterator<const int*>, ForwardIterator<const int*>, BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<const int*>, ForwardIterator<const int*>, RandomAccessIterator<int*> >();
-    test<RandomAccessIterator<const int*>, ForwardIterator<const int*>, int*>();
-
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<const int*>, int*>();
-
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<const int*>, int*>();
-
-    test<RandomAccessIterator<const int*>, const int*, OutputIterator<int*> >();
-    test<RandomAccessIterator<const int*>, const int*, ForwardIterator<int*> >();
-    test<RandomAccessIterator<const int*>, const int*, BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<const int*>, const int*, RandomAccessIterator<int*> >();
-    test<RandomAccessIterator<const int*>, const int*, int*>();
-#endif
-#ifdef SET_SYMMETRIC_DIFFERENCE_5
-    test<const int*, InputIterator<const int*>, OutputIterator<int*> >();
-    test<const int*, InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test<const int*, InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test<const int*, InputIterator<const int*>, RandomAccessIterator<int*> >();
-    test<const int*, InputIterator<const int*>, int*>();
-
-    test<const int*, ForwardIterator<const int*>, OutputIterator<int*> >();
-    test<const int*, ForwardIterator<const int*>, ForwardIterator<int*> >();
-    test<const int*, ForwardIterator<const int*>, BidirectionalIterator<int*> >();
-    test<const int*, ForwardIterator<const int*>, RandomAccessIterator<int*> >();
-    test<const int*, ForwardIterator<const int*>, int*>();
-
-    test<const int*, BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test<const int*, BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test<const int*, BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test<const int*, BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test<const int*, BidirectionalIterator<const int*>, int*>();
-
-    test<const int*, RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test<const int*, RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test<const int*, RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test<const int*, RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test<const int*, RandomAccessIterator<const int*>, int*>();
-
-    test<const int*, const int*, OutputIterator<int*> >();
-    test<const int*, const int*, ForwardIterator<int*> >();
-    test<const int*, const int*, BidirectionalIterator<int*> >();
-    test<const int*, const int*, RandomAccessIterator<int*> >();
-    test<const int*, const int*, int*>();
-#endif
-#ifdef SET_SYMMETRIC_DIFFERENCE_6
-    // Test projections
-    {
-        S ia[] = {S{1}, S{2}, S{2}, S{3}, S{3}, S{3}, S{4}, S{4}, S{4}, S{4}};
-        T ib[] = {T{2}, T{4}, T{4}, T{6}};
-        U ic[20];
-        int ir[] = {1, 2, 3, 3, 3, 4, 4, 6};
-        static const int sr = sizeof(ir)/sizeof(ir[0]);
-
-        ranges::set_symmetric_difference_result<S *, T *, U *> res1 =
-            ranges::set_symmetric_difference(ia, ib, ic, std::less<int>(), &S::i, &T::j);
-        CHECK((res1.out - ic) == sr);
-        CHECK(ranges::lexicographical_compare(ic, res1.out, ir, ir+sr, std::less<int>(), &U::k) == false);
-        ranges::fill(ic, U{0});
-
-        ranges::set_symmetric_difference_result<T *, S *, U *> res2 =
-            ranges::set_symmetric_difference(ib, ia, ic, std::less<int>(), &T::j, &S::i);
-        CHECK((res2.out - ic) == sr);
-        CHECK(ranges::lexicographical_compare(ic, res2.out, ir, ir+sr, std::less<int>(), &U::k) == false);
-    }
-
-    // Test rvalue ranges
-#ifndef RANGES_WORKAROUND_MSVC_573728
-    {
-        S ia[] = {S{1}, S{2}, S{2}, S{3}, S{3}, S{3}, S{4}, S{4}, S{4}, S{4}};
-        T ib[] = {T{2}, T{4}, T{4}, T{6}};
-        U ic[20];
-        int ir[] = {1, 2, 3, 3, 3, 4, 4, 6};
-        static const int sr = sizeof(ir)/sizeof(ir[0]);
-
-        auto res1 =
-            ranges::set_symmetric_difference(std::move(ia), ranges::views::all(ib), ic, std::less<int>(), &S::i, &T::j);
-        CHECK(::is_dangling(res1.in1));
-        CHECK(res1.in2 == ranges::end(ib));
-        CHECK((res1.out - ic) == sr);
-        CHECK(ranges::lexicographical_compare(ic, res1.out, ir, ir+sr, std::less<int>(), &U::k) == false);
-
-        ranges::fill(ic, U{0});
-        auto res2 =
-            ranges::set_symmetric_difference(ranges::views::all(ib), std::move(ia), ic, std::less<int>(), &T::j, &S::i);
-        CHECK(res2.in1 == ranges::end(ib));
-        CHECK(::is_dangling(res2.in2));
-        CHECK((res2.out - ic) == sr);
-        CHECK(ranges::lexicographical_compare(ic, res2.out, ir, ir+sr, std::less<int>(), &U::k) == false);
-    }
-#endif // RANGES_WORKAROUND_MSVC_573728
-    {
-        std::vector<S> ia{S{1}, S{2}, S{2}, S{3}, S{3}, S{3}, S{4}, S{4}, S{4}, S{4}};
-        std::vector<T> ib{T{2}, T{4}, T{4}, T{6}};
-        U ic[20];
-        int ir[] = {1, 2, 3, 3, 3, 4, 4, 6};
-        static const int sr = sizeof(ir)/sizeof(ir[0]);
-
-        auto res1 =
-            ranges::set_symmetric_difference(std::move(ia), ranges::views::all(ib), ic, std::less<int>(), &S::i, &T::j);
-        CHECK(::is_dangling(res1.in1));
-        CHECK(res1.in2 == ranges::end(ib));
-        CHECK((res1.out - ic) == sr);
-        CHECK(ranges::lexicographical_compare(ic, res1.out, ir, ir+sr, std::less<int>(), &U::k) == false);
-
-        ranges::fill(ic, U{0});
-        auto res2 =
-            ranges::set_symmetric_difference(ranges::views::all(ib), std::move(ia), ic, std::less<int>(), &T::j, &S::i);
-        CHECK(res2.in1 == ranges::end(ib));
-        CHECK(::is_dangling(res2.in2));
-        CHECK((res2.out - ic) == sr);
-        CHECK(ranges::lexicographical_compare(ic, res2.out, ir, ir+sr, std::less<int>(), &U::k) == false);
-    }
-#endif
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/set_symmetric_difference1.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/set_symmetric_difference1.cpp
deleted file mode 100644
index 43dda6c1..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/set_symmetric_difference1.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define SET_SYMMETRIC_DIFFERENCE_1
-#include "./set_symmetric_difference.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/set_symmetric_difference2.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/set_symmetric_difference2.cpp
deleted file mode 100644
index bf09d1a6..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/set_symmetric_difference2.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define SET_SYMMETRIC_DIFFERENCE_2
-#include "./set_symmetric_difference.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/set_symmetric_difference3.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/set_symmetric_difference3.cpp
deleted file mode 100644
index e0fd036d..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/set_symmetric_difference3.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define SET_SYMMETRIC_DIFFERENCE_3
-#include "./set_symmetric_difference.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/set_symmetric_difference4.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/set_symmetric_difference4.cpp
deleted file mode 100644
index a620e67d..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/set_symmetric_difference4.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define SET_SYMMETRIC_DIFFERENCE_4
-#include "./set_symmetric_difference.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/set_symmetric_difference5.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/set_symmetric_difference5.cpp
deleted file mode 100644
index fe039263..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/set_symmetric_difference5.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define SET_SYMMETRIC_DIFFERENCE_5
-#include "./set_symmetric_difference.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/set_symmetric_difference6.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/set_symmetric_difference6.cpp
deleted file mode 100644
index a264651b..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/set_symmetric_difference6.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define SET_SYMMETRIC_DIFFERENCE_6
-#include "./set_symmetric_difference.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/set_union.hpp b/src/contrib/range-v3-0.11.0/test/algorithm/set_union.hpp
deleted file mode 100644
index 7c8a00c2..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/set_union.hpp
+++ /dev/null
@@ -1,306 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <algorithm>
-#include <functional>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/fill.hpp>
-#include <range/v3/algorithm/set_algorithm.hpp>
-#include <range/v3/algorithm/lexicographical_compare.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-template<class Iter1, class Iter2, class OutIter>
-void
-test()
-{
-    int ia[] = {1, 2, 2, 3, 3, 3, 4, 4, 4, 4};
-    static const int sa = sizeof(ia)/sizeof(ia[0]);
-    int ib[] = {2, 4, 4, 6};
-    static const int sb = sizeof(ib)/sizeof(ib[0]);
-    int ic[20];
-    int ir[] = {1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 6};
-    static const int sr = sizeof(ir)/sizeof(ir[0]);
-
-    using R = ranges::set_union_result<Iter1, Iter2, OutIter>;
-    auto set_union = make_testable_2(ranges::set_union);
-
-    auto checker = [&](R res)
-    {
-        CHECK((base(res.out) - ic) == sr);
-        CHECK(std::lexicographical_compare(ic, base(res.out), ir, ir+sr) == false);
-        ranges::fill(ic, 0);
-    };
-
-    set_union(Iter1(ia), Iter1(ia+sa),
-        Iter2(ib), Iter2(ib+sb), OutIter(ic)).check(checker);
-    set_union(Iter1(ib), Iter1(ib+sb),
-        Iter2(ia), Iter2(ia+sa), OutIter(ic)).check(checker);
-
-    set_union(Iter1(ia), Iter1(ia+sa),
-        Iter2(ib), Iter2(ib+sb), OutIter(ic), std::less<int>()).check(checker);
-    set_union(Iter1(ib), Iter1(ib+sb),
-        Iter2(ia), Iter2(ia+sa), OutIter(ic), std::less<int>()).check(checker);
-}
-
-struct S
-{
-    int i;
-};
-
-struct T
-{
-    int j;
-};
-
-struct U
-{
-    int k;
-    U& operator=(S s) { k = s.i; return *this;}
-    U& operator=(T t) { k = t.j; return *this;}
-};
-
-int main()
-{
-#ifdef SET_UNION_1
-    test<InputIterator<const int*>, InputIterator<const int*>, OutputIterator<int*> >();
-    test<InputIterator<const int*>, InputIterator<const int*>, ForwardIterator<int*> >();
-    test<InputIterator<const int*>, InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test<InputIterator<const int*>, InputIterator<const int*>, RandomAccessIterator<int*> >();
-    test<InputIterator<const int*>, InputIterator<const int*>, int*>();
-
-    test<InputIterator<const int*>, ForwardIterator<const int*>, OutputIterator<int*> >();
-    test<InputIterator<const int*>, ForwardIterator<const int*>, ForwardIterator<int*> >();
-    test<InputIterator<const int*>, ForwardIterator<const int*>, BidirectionalIterator<int*> >();
-    test<InputIterator<const int*>, ForwardIterator<const int*>, RandomAccessIterator<int*> >();
-    test<InputIterator<const int*>, ForwardIterator<const int*>, int*>();
-
-    test<InputIterator<const int*>, BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test<InputIterator<const int*>, BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test<InputIterator<const int*>, BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test<InputIterator<const int*>, BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test<InputIterator<const int*>, BidirectionalIterator<const int*>, int*>();
-
-    test<InputIterator<const int*>, RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test<InputIterator<const int*>, RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test<InputIterator<const int*>, RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test<InputIterator<const int*>, RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test<InputIterator<const int*>, RandomAccessIterator<const int*>, int*>();
-
-    test<InputIterator<const int*>, const int*, OutputIterator<int*> >();
-    test<InputIterator<const int*>, const int*, ForwardIterator<int*> >();
-    test<InputIterator<const int*>, const int*, BidirectionalIterator<int*> >();
-    test<InputIterator<const int*>, const int*, RandomAccessIterator<int*> >();
-    test<InputIterator<const int*>, const int*, int*>();
-#endif
-#ifdef SET_UNION_2
-    test<ForwardIterator<const int*>, InputIterator<const int*>, OutputIterator<int*> >();
-    test<ForwardIterator<const int*>, InputIterator<const int*>, ForwardIterator<int*> >();
-    test<ForwardIterator<const int*>, InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test<ForwardIterator<const int*>, InputIterator<const int*>, RandomAccessIterator<int*> >();
-    test<ForwardIterator<const int*>, InputIterator<const int*>, int*>();
-
-    test<ForwardIterator<const int*>, ForwardIterator<const int*>, OutputIterator<int*> >();
-    test<ForwardIterator<const int*>, ForwardIterator<const int*>, ForwardIterator<int*> >();
-    test<ForwardIterator<const int*>, ForwardIterator<const int*>, BidirectionalIterator<int*> >();
-    test<ForwardIterator<const int*>, ForwardIterator<const int*>, RandomAccessIterator<int*> >();
-    test<ForwardIterator<const int*>, ForwardIterator<const int*>, int*>();
-
-    test<ForwardIterator<const int*>, BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test<ForwardIterator<const int*>, BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test<ForwardIterator<const int*>, BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test<ForwardIterator<const int*>, BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test<ForwardIterator<const int*>, BidirectionalIterator<const int*>, int*>();
-
-    test<ForwardIterator<const int*>, RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test<ForwardIterator<const int*>, RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test<ForwardIterator<const int*>, RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test<ForwardIterator<const int*>, RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test<ForwardIterator<const int*>, RandomAccessIterator<const int*>, int*>();
-
-    test<ForwardIterator<const int*>, const int*, OutputIterator<int*> >();
-    test<ForwardIterator<const int*>, const int*, ForwardIterator<int*> >();
-    test<ForwardIterator<const int*>, const int*, BidirectionalIterator<int*> >();
-    test<ForwardIterator<const int*>, const int*, RandomAccessIterator<int*> >();
-    test<ForwardIterator<const int*>, const int*, int*>();
-#endif
-#ifdef SET_UNION_3
-    test<BidirectionalIterator<const int*>, InputIterator<const int*>, OutputIterator<int*> >();
-    test<BidirectionalIterator<const int*>, InputIterator<const int*>, ForwardIterator<int*> >();
-    test<BidirectionalIterator<const int*>, InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test<BidirectionalIterator<const int*>, InputIterator<const int*>, RandomAccessIterator<int*> >();
-    test<BidirectionalIterator<const int*>, InputIterator<const int*>, int*>();
-
-    test<BidirectionalIterator<const int*>, ForwardIterator<const int*>, OutputIterator<int*> >();
-    test<BidirectionalIterator<const int*>, ForwardIterator<const int*>, ForwardIterator<int*> >();
-    test<BidirectionalIterator<const int*>, ForwardIterator<const int*>, BidirectionalIterator<int*> >();
-    test<BidirectionalIterator<const int*>, ForwardIterator<const int*>, RandomAccessIterator<int*> >();
-    test<BidirectionalIterator<const int*>, ForwardIterator<const int*>, int*>();
-
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<const int*>, int*>();
-
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<const int*>, int*>();
-
-    test<BidirectionalIterator<const int*>, const int*, OutputIterator<int*> >();
-    test<BidirectionalIterator<const int*>, const int*, ForwardIterator<int*> >();
-    test<BidirectionalIterator<const int*>, const int*, BidirectionalIterator<int*> >();
-    test<BidirectionalIterator<const int*>, const int*, RandomAccessIterator<int*> >();
-    test<BidirectionalIterator<const int*>, const int*, int*>();
-#endif
-#ifdef SET_UNION_4
-    test<RandomAccessIterator<const int*>, InputIterator<const int*>, OutputIterator<int*> >();
-    test<RandomAccessIterator<const int*>, InputIterator<const int*>, ForwardIterator<int*> >();
-    test<RandomAccessIterator<const int*>, InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<const int*>, InputIterator<const int*>, RandomAccessIterator<int*> >();
-    test<RandomAccessIterator<const int*>, InputIterator<const int*>, int*>();
-
-    test<RandomAccessIterator<const int*>, ForwardIterator<const int*>, OutputIterator<int*> >();
-    test<RandomAccessIterator<const int*>, ForwardIterator<const int*>, ForwardIterator<int*> >();
-    test<RandomAccessIterator<const int*>, ForwardIterator<const int*>, BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<const int*>, ForwardIterator<const int*>, RandomAccessIterator<int*> >();
-    test<RandomAccessIterator<const int*>, ForwardIterator<const int*>, int*>();
-
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<const int*>, int*>();
-
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<const int*>, int*>();
-
-    test<RandomAccessIterator<const int*>, const int*, OutputIterator<int*> >();
-    test<RandomAccessIterator<const int*>, const int*, ForwardIterator<int*> >();
-    test<RandomAccessIterator<const int*>, const int*, BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<const int*>, const int*, RandomAccessIterator<int*> >();
-    test<RandomAccessIterator<const int*>, const int*, int*>();
-#endif
-#ifdef SET_UNION_5
-    test<const int*, InputIterator<const int*>, OutputIterator<int*> >();
-    test<const int*, InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test<const int*, InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test<const int*, InputIterator<const int*>, RandomAccessIterator<int*> >();
-    test<const int*, InputIterator<const int*>, int*>();
-
-    test<const int*, ForwardIterator<const int*>, OutputIterator<int*> >();
-    test<const int*, ForwardIterator<const int*>, ForwardIterator<int*> >();
-    test<const int*, ForwardIterator<const int*>, BidirectionalIterator<int*> >();
-    test<const int*, ForwardIterator<const int*>, RandomAccessIterator<int*> >();
-    test<const int*, ForwardIterator<const int*>, int*>();
-
-    test<const int*, BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test<const int*, BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test<const int*, BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test<const int*, BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test<const int*, BidirectionalIterator<const int*>, int*>();
-
-    test<const int*, RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test<const int*, RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test<const int*, RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test<const int*, RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test<const int*, RandomAccessIterator<const int*>, int*>();
-
-    test<const int*, const int*, OutputIterator<int*> >();
-    test<const int*, const int*, ForwardIterator<int*> >();
-    test<const int*, const int*, BidirectionalIterator<int*> >();
-    test<const int*, const int*, RandomAccessIterator<int*> >();
-    test<const int*, const int*, int*>();
-#endif
-#ifdef SET_UNION_6
-    // Test projections
-    {
-        S ia[] = {S{1}, S{2}, S{2}, S{3}, S{3}, S{3}, S{4}, S{4}, S{4}, S{4}};
-        T ib[] = {T{2}, T{4}, T{4}, T{6}};
-        U ic[20];
-        int ir[] = {1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 6};
-        static const int sr = sizeof(ir)/sizeof(ir[0]);
-
-        using R = ranges::set_union_result<S *, T*, U*>;
-        R res = ranges::set_union(ia, ib, ic, std::less<int>(), &S::i, &T::j);
-        CHECK((res.out - ic) == sr);
-        CHECK(ranges::lexicographical_compare(ic, res.out, ir, ir+sr, std::less<int>(), &U::k) == false);
-        ranges::fill(ic, U{0});
-
-        using R2 = ranges::set_union_result<T *, S*, U*>;
-        R2 res2 = ranges::set_union(ib, ia, ic, std::less<int>(), &T::j, &S::i);
-        CHECK((res2.out - ic) == sr);
-        CHECK(ranges::lexicographical_compare(ic, res2.out, ir, ir+sr, std::less<int>(), &U::k) == false);
-    }
-
-    // Test projections
-#ifndef RANGES_WORKAROUND_MSVC_573728
-    {
-        S ia[] = {S{1}, S{2}, S{2}, S{3}, S{3}, S{3}, S{4}, S{4}, S{4}, S{4}};
-        T ib[] = {T{2}, T{4}, T{4}, T{6}};
-        U ic[20];
-        int ir[] = {1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 6};
-        static const int sr = sizeof(ir)/sizeof(ir[0]);
-
-        auto res = ranges::set_union(std::move(ia), ranges::views::all(ib), ic, std::less<int>(), &S::i, &T::j);
-        CHECK(::is_dangling(res.in1));
-        CHECK(res.in2 == ranges::end(ib));
-        CHECK((res.out - ic) == sr);
-        CHECK(ranges::lexicographical_compare(ic, res.out, ir, ir+sr, std::less<int>(), &U::k) == false);
-
-        ranges::fill(ic, U{0});
-        auto res2 = ranges::set_union(std::move(ib), ranges::views::all(ia), ic, std::less<int>(), &T::j, &S::i);
-        CHECK(res2.in2 == ranges::end(ia));
-        CHECK(::is_dangling(res2.in1));
-        CHECK((res2.out - ic) == sr);
-        CHECK(ranges::lexicographical_compare(ic, res2.out, ir, ir+sr, std::less<int>(), &U::k) == false);
-    }
-#endif // RANGES_WORKAROUND_MSVC_573728
-    {
-        std::vector<S> ia{S{1}, S{2}, S{2}, S{3}, S{3}, S{3}, S{4}, S{4}, S{4}, S{4}};
-        std::vector<T> ib{T{2}, T{4}, T{4}, T{6}};
-        U ic[20];
-        int ir[] = {1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 6};
-        static const int sr = sizeof(ir)/sizeof(ir[0]);
-
-        auto res = ranges::set_union(std::move(ia), ranges::views::all(ib), ic, std::less<int>(), &S::i, &T::j);
-        CHECK(::is_dangling(res.in1));
-        CHECK(res.in2 == ranges::end(ib));
-        CHECK((res.out - ic) == sr);
-        CHECK(ranges::lexicographical_compare(ic, res.out, ir, ir+sr, std::less<int>(), &U::k) == false);
-
-        ranges::fill(ic, U{0});
-        auto res2 = ranges::set_union(std::move(ib), ranges::views::all(ia), ic, std::less<int>(), &T::j, &S::i);
-        CHECK(res2.in2 == ranges::end(ia));
-        CHECK(::is_dangling(res2.in1));
-        CHECK((res2.out - ic) == sr);
-        CHECK(ranges::lexicographical_compare(ic, res2.out, ir, ir+sr, std::less<int>(), &U::k) == false);
-    }
-#endif
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/set_union1.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/set_union1.cpp
deleted file mode 100644
index 3527b353..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/set_union1.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define SET_UNION_1
-#include "./set_union.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/set_union2.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/set_union2.cpp
deleted file mode 100644
index c3e36720..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/set_union2.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define SET_UNION_2
-#include "./set_union.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/set_union3.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/set_union3.cpp
deleted file mode 100644
index 1c81f109..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/set_union3.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define SET_UNION_3
-#include "./set_union.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/set_union4.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/set_union4.cpp
deleted file mode 100644
index 3ecd6580..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/set_union4.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define SET_UNION_4
-#include "./set_union.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/set_union5.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/set_union5.cpp
deleted file mode 100644
index f56705df..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/set_union5.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define SET_UNION_5
-#include "./set_union.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/set_union6.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/set_union6.cpp
deleted file mode 100644
index 1f43a55f..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/set_union6.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#define SET_UNION_6
-#include "./set_union.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/shuffle.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/shuffle.cpp
deleted file mode 100644
index 571d3bd0..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/shuffle.cpp
+++ /dev/null
@@ -1,95 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <array>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/equal.hpp>
-#include <range/v3/algorithm/shuffle.hpp>
-#include <range/v3/numeric/iota.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-int main()
-{
-    constexpr unsigned N = 100;
-    {
-        std::array<int, N> a, b, c;
-        for (auto p : {&a, &b, &c})
-            ranges::iota(*p, 0);
-        std::minstd_rand g1, g2 = g1;
-        ranges::shuffle(RandomAccessIterator<int*>(a.data()), Sentinel<int*>(a.data()+N), g1);
-        CHECK(!ranges::equal(a, b));
-
-        CHECK(ranges::shuffle(b.begin(), b.end(), g1) == b.end());
-        CHECK(!ranges::equal(a, b));
-
-        CHECK(ranges::shuffle(c.begin(), c.end(), g2) == c.end());
-        CHECK(ranges::equal(a, c));
-        CHECK(!ranges::equal(b, c));
-    }
-
-    {
-        std::array<int, N> a, b, c;
-        for (auto p : {&a, &b, &c})
-            ranges::iota(*p, 0);
-        std::minstd_rand g1, g2 = g1;
-        auto rng = ::MakeTestRange(RandomAccessIterator<int*>(a.data()), Sentinel<int*>(a.data() + N));
-        ranges::shuffle(rng, g1);
-        CHECK(!ranges::equal(a, b));
-
-        CHECK(ranges::shuffle(b, g2) == b.end());
-        CHECK(ranges::equal(a, b));
-
-        CHECK(ranges::shuffle(b, g1) == b.end());
-        CHECK(!ranges::equal(a, b));
-        CHECK(!ranges::equal(b, c));
-
-        ranges::iota(a, 0);
-        CHECK(::is_dangling(ranges::shuffle(std::move(rng), g1)));
-        CHECK(!ranges::equal(a, c));
-    }
-
-    {
-        std::array<int, N> a, b, c;
-        for (auto p : {&a, &b, &c})
-            ranges::iota(*p, 0);
-        ranges::shuffle(RandomAccessIterator<int*>(a.data()), Sentinel<int*>(a.data() + N));
-        CHECK(!ranges::equal(a, c));
-
-        ranges::shuffle(b);
-        CHECK(!ranges::equal(b, c));
-        CHECK(!ranges::equal(a, b));
-    }
-
-    {
-        std::array<int, N> a, b;
-        for (auto p : {&a, &b})
-            ranges::iota(*p, 0);
-        ranges::shuffle(a);
-        CHECK(!ranges::equal(a, b));
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/sort.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/sort.cpp
deleted file mode 100644
index bfc159ac..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/sort.cpp
+++ /dev/null
@@ -1,338 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <memory>
-#include <random>
-#include <vector>
-#include <algorithm>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/sort.hpp>
-#include <range/v3/algorithm/copy.hpp>
-#include <range/v3/view/for_each.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/repeat_n.hpp>
-#include <range/v3/view/reverse.hpp>
-#include <range/v3/view/zip.hpp>
-#include <range/v3/view/transform.hpp>
-#include <range/v3/range/conversion.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS
-RANGES_DIAGNOSTIC_IGNORE_SIGN_CONVERSION
-RANGES_DIAGNOSTIC_IGNORE_UNNEEDED_INTERNAL
-
-// BUGBUG
-namespace std
-{
-    template<typename F, typename S>
-    std::ostream & operator<<(std::ostream &sout, std::pair<F,S> const & p)
-    {
-        return sout << '[' << p.first << ',' << p.second << ']';
-    }
-}
-
-namespace
-{
-    std::mt19937 gen;
-
-    struct indirect_less
-    {
-        template<class P>
-        bool operator()(const P& x, const P& y)
-            {return *x < *y;}
-    };
-
-    template<class RI>
-    void
-    test_sort_helper(RI f, RI l)
-    {
-        using value_type = ranges::iter_value_t<RI>;
-        auto sort = make_testable_1<false>(ranges::sort);
-        if (f != l)
-        {
-            auto len = l - f;
-            value_type* save(new value_type[len]);
-            do
-            {
-                std::copy(f, l, save);
-                sort(save, save+len).check([&](int *res)
-                {
-                    CHECK(res == save+len);
-                    CHECK(std::is_sorted(save, save+len));
-                    std::copy(f, l, save);
-                });
-                sort(save, save+len, std::greater<int>{}).check([&](int *res)
-                {
-                    CHECK(res == save+len);
-                    CHECK(std::is_sorted(save, save+len, std::greater<int>{}));
-                    std::copy(f, l, save);
-                });
-            } while (std::next_permutation(f, l));
-            delete [] save;
-        }
-    }
-
-    template<class RI>
-    void
-    test_sort_driver_driver(RI f, RI l, int start, RI real_last)
-    {
-        for (RI i = l; i > f + start;)
-        {
-            *--i = start;
-            if (f == i)
-            {
-                test_sort_helper(f, real_last);
-            }
-            if (start > 0)
-                test_sort_driver_driver(f, i, start-1, real_last);
-        }
-    }
-
-    template<class RI>
-    void
-    test_sort_driver(RI f, RI l, int start)
-    {
-        test_sort_driver_driver(f, l, start, l);
-    }
-
-    template<int sa>
-    void
-    test_sort_()
-    {
-        int ia[sa];
-        for (int i = 0; i < sa; ++i)
-        {
-            test_sort_driver(ia, ia+sa, i);
-        }
-    }
-
-    void
-    test_larger_sorts(int N, int M)
-    {
-        RANGES_ENSURE(N > 0);
-        RANGES_ENSURE(M > 0);
-        // create array length N filled with M different numbers
-        int* array = new int[N];
-        int x = 0;
-        for (int i = 0; i < N; ++i)
-        {
-            array[i] = x;
-            if (++x == M)
-                x = 0;
-        }
-
-        // test saw tooth pattern
-        CHECK(ranges::sort(array, array+N) == array+N);
-        CHECK(std::is_sorted(array, array+N));
-        // test random pattern
-        std::shuffle(array, array+N, gen);
-        CHECK(ranges::sort(array, array+N) == array+N);
-        CHECK(std::is_sorted(array, array+N));
-        // test sorted pattern
-        CHECK(ranges::sort(array, array+N) == array+N);
-        CHECK(std::is_sorted(array, array+N));
-        // test reverse sorted pattern
-        std::reverse(array, array+N);
-        CHECK(ranges::sort(array, array+N) == array+N);
-        CHECK(std::is_sorted(array, array+N));
-        // test swap ranges 2 pattern
-        std::swap_ranges(array, array+N/2, array+N/2);
-        CHECK(ranges::sort(array, array+N) == array+N);
-        CHECK(std::is_sorted(array, array+N));
-        // test reverse swap ranges 2 pattern
-        std::reverse(array, array+N);
-        std::swap_ranges(array, array+N/2, array+N/2);
-        CHECK(ranges::sort(array, array+N) == array+N);
-        CHECK(std::is_sorted(array, array+N));
-        delete [] array;
-    }
-
-    void
-    test_larger_sorts(unsigned N)
-    {
-        test_larger_sorts(N, 1);
-        test_larger_sorts(N, 2);
-        test_larger_sorts(N, 3);
-        test_larger_sorts(N, N/2-1);
-        test_larger_sorts(N, N/2);
-        test_larger_sorts(N, N/2+1);
-        test_larger_sorts(N, N-2);
-        test_larger_sorts(N, N-1);
-        test_larger_sorts(N, N);
-    }
-
-    struct S
-    {
-        int i, j;
-    };
-
-    struct Int
-    {
-        using difference_type = int;
-        int i_;
-        Int(int i = 0) : i_(i) {}
-        Int(Int && that) : i_(that.i_) { that.i_ = 0; }
-        Int(Int const &) = delete;
-        Int & operator=(Int && that)
-        {
-            i_ = that.i_;
-            that.i_ = 0;
-            return *this;
-        }
-        friend bool operator==(Int const &a, Int const &b)
-        {
-            return a.i_ == b.i_;
-        }
-        friend bool operator!=(Int const &a, Int const &b)
-        {
-            return !(a == b);
-        }
-        friend bool operator<(Int const &a, Int const &b)
-        {
-            return a.i_ < b.i_;
-        }
-        friend bool operator>(Int const &a, Int const &b)
-        {
-            return a.i_ > b.i_;
-        }
-        friend bool operator<=(Int const &a, Int const &b)
-        {
-            return a.i_ <= b.i_;
-        }
-        friend bool operator>=(Int const &a, Int const &b)
-        {
-            return a.i_ >= b.i_;
-        }
-    };
-    CPP_assert(ranges::default_constructible<Int>);
-    CPP_assert(ranges::movable<Int>);
-    CPP_assert(ranges::totally_ordered<Int>);
-}
-
-int main()
-{
-    // test null range
-    int d = 0;
-    ranges::sort(&d, &d);
-    // exhaustively test all possibilities up to length 8
-    test_sort_<1>();
-    test_sort_<2>();
-    test_sort_<3>();
-    test_sort_<4>();
-    test_sort_<5>();
-    test_sort_<6>();
-    test_sort_<7>();
-    test_sort_<8>();
-
-    test_larger_sorts(15);
-    test_larger_sorts(16);
-    test_larger_sorts(17);
-    test_larger_sorts(256);
-    test_larger_sorts(257);
-    test_larger_sorts(499);
-    test_larger_sorts(500);
-    test_larger_sorts(997);
-    test_larger_sorts(1000);
-    test_larger_sorts(1009);
-
-    // Check move-only types
-    {
-        std::vector<std::unique_ptr<int> > v(1000);
-        for(int i = 0; (std::size_t)i < v.size(); ++i)
-            v[i].reset(new int((int)v.size() - i - 1));
-        ranges::sort(v, indirect_less());
-        for(int i = 0; (std::size_t)i < v.size(); ++i)
-            CHECK(*v[i] == i);
-    }
-
-    // Check projections
-    {
-        std::vector<S> v(1000, S{});
-        for(int i = 0; (std::size_t)i < v.size(); ++i)
-        {
-            v[i].i = (int)v.size() - i - 1;
-            v[i].j = i;
-        }
-        ranges::sort(v, std::less<int>{}, &S::i);
-        for(int i = 0; (std::size_t)i < v.size(); ++i)
-        {
-            CHECK(v[i].i == i);
-            CHECK((std::size_t)v[i].j == v.size() - i - 1);
-        }
-    }
-
-    // Check rvalue range
-    {
-        std::vector<S> v(1000, S{});
-        for(int i = 0; (std::size_t)i < v.size(); ++i)
-        {
-            v[i].i = (int)v.size() - i - 1;
-            v[i].j = i;
-        }
-        CHECK(ranges::sort(ranges::views::all(v), std::less<int>{}, &S::i) == v.end());
-        for(int i = 0; (std::size_t)i < v.size(); ++i)
-        {
-            CHECK(v[i].i == i);
-            CHECK((std::size_t)v[i].j == v.size() - i - 1);
-        }
-    }
-    {
-        std::vector<S> v(1000, S{});
-        for(int i = 0; (std::size_t)i < v.size(); ++i)
-        {
-            v[i].i = (int)v.size() - i - 1;
-            v[i].j = i;
-        }
-        CHECK(::is_dangling(ranges::sort(std::move(v), std::less<int>{}, &S::i)));
-        for(int i = 0; (std::size_t)i < v.size(); ++i)
-        {
-            CHECK(v[i].i == i);
-            CHECK((std::size_t)v[i].j == v.size() - i - 1);
-        }
-    }
-
-    // Check sorting a zip view, which uses iter_move
-    {
-        using namespace ranges;
-        auto v0 =
-            views::for_each(views::ints(1,6) | views::reverse, [](int i){
-                return ranges::yield_from(views::repeat_n(i,i));
-            }) | to<std::vector>();
-        auto v1 = ranges::to<std::vector<Int>>(
-            {1,2,2,3,3,3,4,4,4,4,5,5,5,5,5});
-        auto rng = views::zip(v0, v1);
-        ::check_equal(v0,{5,5,5,5,5,4,4,4,4,3,3,3,2,2,1});
-        ::check_equal(v1,{1,2,2,3,3,3,4,4,4,4,5,5,5,5,5});
-        using Rng = decltype(rng);
-        using CR = range_common_reference_t<Rng>;
-        auto proj = [](CR r) { return r; };
-        auto pred = [](CR r1, CR r2) { return r1 < r2; };
-        sort(rng, pred, proj);
-        ::check_equal(v0,{1,2,2,3,3,3,4,4,4,4,5,5,5,5,5});
-        ::check_equal(v1,{5,5,5,4,5,5,3,4,4,4,1,2,2,3,3});
-
-        // Check that this compiles, too:
-        sort(rng);
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/sort_heap.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/sort_heap.cpp
deleted file mode 100644
index 6f458640..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/sort_heap.cpp
+++ /dev/null
@@ -1,204 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <memory>
-#include <random>
-#include <algorithm>
-#include <functional>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/heap_algorithm.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS
-RANGES_DIAGNOSTIC_IGNORE_SIGN_CONVERSION
-
-namespace
-{
-    std::mt19937 gen;
-
-    void test_1(int N)
-    {
-        int* ia = new int[N];
-        for (int i = 0; i < N; ++i)
-            ia[i] = i;
-        std::shuffle(ia, ia+N, gen);
-        std::make_heap(ia, ia+N);
-        CHECK(ranges::sort_heap(ia, ia+N) == ia+N);
-        CHECK(std::is_sorted(ia, ia+N));
-        delete[] ia;
-    }
-
-    void test_2(int N)
-    {
-        int* ia = new int[N];
-        for (int i = 0; i < N; ++i)
-            ia[i] = i;
-        std::shuffle(ia, ia+N, gen);
-        std::make_heap(ia, ia+N);
-        CHECK(ranges::sort_heap(ia, Sentinel<int*>(ia+N)) == ia+N);
-        CHECK(std::is_sorted(ia, ia+N));
-        delete[] ia;
-    }
-
-    void test_3(int N)
-    {
-        int* ia = new int[N];
-        for (int i = 0; i < N; ++i)
-            ia[i] = i;
-        std::shuffle(ia, ia+N, gen);
-        std::make_heap(ia, ia+N);
-        CHECK(ranges::sort_heap(::as_lvalue(ranges::make_subrange(ia, ia+N))) == ia+N);
-        CHECK(std::is_sorted(ia, ia+N));
-        delete[] ia;
-    }
-
-    void test_4(int N)
-    {
-        int* ia = new int[N];
-        for (int i = 0; i < N; ++i)
-            ia[i] = i;
-        std::shuffle(ia, ia+N, gen);
-        std::make_heap(ia, ia+N);
-        CHECK(ranges::sort_heap(::as_lvalue(ranges::make_subrange(ia, Sentinel<int*>(ia+N)))) == ia+N);
-        CHECK(std::is_sorted(ia, ia+N));
-        delete[] ia;
-    }
-
-    void test_5(int N)
-    {
-        int* ia = new int[N];
-        for (int i = 0; i < N; ++i)
-            ia[i] = i;
-        std::shuffle(ia, ia+N, gen);
-        std::make_heap(ia, ia+N, std::greater<int>());
-        CHECK(ranges::sort_heap(ia, ia+N, std::greater<int>()) == ia+N);
-        CHECK(std::is_sorted(ia, ia+N, std::greater<int>()));
-        delete[] ia;
-    }
-
-    void test_6(int N)
-    {
-        int* ia = new int[N];
-        for (int i = 0; i < N; ++i)
-            ia[i] = i;
-        std::shuffle(ia, ia+N, gen);
-        std::make_heap(ia, ia+N, std::greater<int>());
-        CHECK(ranges::sort_heap(ia, Sentinel<int*>(ia+N), std::greater<int>()) == ia+N);
-        CHECK(std::is_sorted(ia, ia+N, std::greater<int>()));
-        delete[] ia;
-    }
-
-    void test_7(int N)
-    {
-        int* ia = new int[N];
-        for (int i = 0; i < N; ++i)
-            ia[i] = i;
-        std::shuffle(ia, ia+N, gen);
-        std::make_heap(ia, ia+N, std::greater<int>());
-        CHECK(ranges::sort_heap(::as_lvalue(ranges::make_subrange(ia, ia+N)), std::greater<int>()) == ia+N);
-        CHECK(std::is_sorted(ia, ia+N, std::greater<int>()));
-        delete[] ia;
-    }
-
-    void test_8(int N)
-    {
-        int* ia = new int[N];
-        for (int i = 0; i < N; ++i)
-            ia[i] = i;
-        std::shuffle(ia, ia+N, gen);
-        std::make_heap(ia, ia+N, std::greater<int>());
-        CHECK(ranges::sort_heap(ranges::make_subrange(ia, Sentinel<int*>(ia+N)), std::greater<int>()) == ia+N);
-        CHECK(std::is_sorted(ia, ia+N, std::greater<int>()));
-
-        delete[] ia;
-    }
-
-    struct indirect_less
-    {
-        template<class P>
-        bool operator()(const P& x, const P& y)
-            {return *x < *y;}
-    };
-
-    void test_9(int N)
-    {
-        std::unique_ptr<int>* ia = new std::unique_ptr<int>[N];
-        for (int i = 0; i < N; ++i)
-            ia[i].reset(new int(i));
-        std::shuffle(ia, ia+N, gen);
-        std::make_heap(ia, ia+N, indirect_less());
-        CHECK(ranges::sort_heap(ia, ia+N, indirect_less()) == ia+N);
-        CHECK(std::is_sorted(ia, ia+N, indirect_less()));
-        delete[] ia;
-    }
-
-    struct S
-    {
-        int i;
-    };
-
-    void test_10(int N)
-    {
-        S* ia = new S[N];
-        int* ib = new int[N];
-        for (int i = 0; i < N; ++i)
-            ib[i] = i;
-        std::shuffle(ib, ib+N, gen);
-        std::make_heap(ib, ib+N);
-        std::transform(ib, ib+N, ia, [](int i){return S{i};});
-        CHECK(ranges::sort_heap(ia, ia+N, std::less<int>(), &S::i) == ia+N);
-        std::transform(ia, ia+N, ib, std::mem_fn(&S::i));
-        CHECK(std::is_sorted(ib, ib+N));
-        delete[] ia;
-        delete[] ib;
-    }
-
-    void test(int N)
-    {
-        test_1(N);
-        test_2(N);
-        test_3(N);
-        test_4(N);
-        test_5(N);
-        test_6(N);
-        test_7(N);
-        test_8(N);
-    }
-}
-
-int main()
-{
-    test(0);
-    test(1);
-    test(2);
-    test(3);
-    test(10);
-    test(1000);
-    test_9(1000);
-    test_10(1000);
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/sort_n_with_buffer.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/sort_n_with_buffer.cpp
deleted file mode 100644
index 8f173341..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/sort_n_with_buffer.cpp
+++ /dev/null
@@ -1,49 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#include <range/v3/algorithm/aux_/sort_n_with_buffer.hpp>
-#include <functional>
-#include <iostream>
-#include <utility>
-#include <range/v3/range/primitives.hpp>
-#include "../simple_test.hpp"
-
-// BUGBUGBUG
-namespace std {
-    template<typename F, typename S>
-    ostream& operator<<(ostream& os, std::pair<F, S> const& p)
-    {
-        return os << '{' << p.first << ", " << p.second << '}';
-    }
-}
-
-int main()
-{
-    std::pair<int, int> some_pairs[] = {
-        {0, 3}, {1, 2}, {2, 1}, {3, 0}
-    };
-    std::pair<int, int> space[2];
-
-    ranges::aux::sort_n_with_buffer(some_pairs + 0, ranges::size(some_pairs), space + 0, std::less<int>{}, &std::pair<int, int>::second);
-    CHECK(some_pairs[0] == std::make_pair(3, 0));
-    CHECK(some_pairs[1] == std::make_pair(2, 1));
-    CHECK(some_pairs[2] == std::make_pair(1, 2));
-    CHECK(some_pairs[3] == std::make_pair(0, 3));
-
-    ranges::aux::sort_n_with_buffer(some_pairs + 0, ranges::size(some_pairs), space + 0, std::less<int>{}, &std::pair<int, int>::first);
-    CHECK(some_pairs[0] == std::make_pair(0, 3));
-    CHECK(some_pairs[1] == std::make_pair(1, 2));
-    CHECK(some_pairs[2] == std::make_pair(2, 1));
-    CHECK(some_pairs[3] == std::make_pair(3, 0));
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/stable_partition.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/stable_partition.cpp
deleted file mode 100644
index e2587694..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/stable_partition.cpp
+++ /dev/null
@@ -1,464 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <memory>
-#include <utility>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/stable_partition.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-struct is_odd
-{
-    bool operator()(const int& i) const
-    {
-        return i & 1;
-    }
-};
-
-struct odd_first
-{
-    bool operator()(const std::pair<int,int>& p) const
-    {
-        return p.first & 1;
-    }
-};
-
-template<class Iter, class Sent = Iter>
-void
-test_iter()
-{
-    using P = std::pair<int, int>;
-    {  // check mixed
-        P ap[] = { {0, 1}, {0, 2}, {1, 1}, {1, 2}, {2, 1}, {2, 2}, {3, 1}, {3, 2}, {4, 1}, {4, 2} };
-        std::size_t size = ranges::size(ap);
-        Iter r = ranges::stable_partition(Iter(ap), Sent(ap+size), odd_first());
-        CHECK(base(r) == ap + 4);
-        CHECK(ap[0] == P{1, 1});
-        CHECK(ap[1] == P{1, 2});
-        CHECK(ap[2] == P{3, 1});
-        CHECK(ap[3] == P{3, 2});
-        CHECK(ap[4] == P{0, 1});
-        CHECK(ap[5] == P{0, 2});
-        CHECK(ap[6] == P{2, 1});
-        CHECK(ap[7] == P{2, 2});
-        CHECK(ap[8] == P{4, 1});
-        CHECK(ap[9] == P{4, 2});
-    }
-    {
-        P ap[] = { {0, 1}, {0, 2}, {1, 1}, {1, 2}, {2, 1}, {2, 2}, {3, 1}, {3, 2}, {4, 1}, {4, 2} };
-        std::size_t size = ranges::size(ap);
-        Iter r = ranges::stable_partition(Iter(ap), Sent(ap+size), odd_first());
-        CHECK(base(r) == ap + 4);
-        CHECK(ap[0] == P{1, 1});
-        CHECK(ap[1] == P{1, 2});
-        CHECK(ap[2] == P{3, 1});
-        CHECK(ap[3] == P{3, 2});
-        CHECK(ap[4] == P{0, 1});
-        CHECK(ap[5] == P{0, 2});
-        CHECK(ap[6] == P{2, 1});
-        CHECK(ap[7] == P{2, 2});
-        CHECK(ap[8] == P{4, 1});
-        CHECK(ap[9] == P{4, 2});
-        // check empty
-        r = ranges::stable_partition(Iter(ap), Sent(ap), odd_first());
-        CHECK(base(r) == ap);
-        // check one true
-        r = ranges::stable_partition(Iter(ap), Sent(ap+1), odd_first());
-        CHECK(base(r) == ap+1);
-        CHECK(ap[0] == P{1, 1});
-        // check one false
-        r = ranges::stable_partition(Iter(ap+4), Sent(ap+5), odd_first());
-        CHECK(base(r) == ap+4);
-        CHECK(ap[4] == P{0, 1});
-    }
-    {  // check all false
-        P ap[] = { {0, 1}, {0, 2}, {2, 1}, {2, 2}, {4, 1}, {4, 2}, {6, 1}, {6, 2}, {8, 1}, {8, 2} };
-        std::size_t size = ranges::size(ap);
-        Iter r = ranges::stable_partition(Iter(ap), Sent(ap+size), odd_first());
-        CHECK(base(r) == ap);
-        CHECK(ap[0] == P{0, 1});
-        CHECK(ap[1] == P{0, 2});
-        CHECK(ap[2] == P{2, 1});
-        CHECK(ap[3] == P{2, 2});
-        CHECK(ap[4] == P{4, 1});
-        CHECK(ap[5] == P{4, 2});
-        CHECK(ap[6] == P{6, 1});
-        CHECK(ap[7] == P{6, 2});
-        CHECK(ap[8] == P{8, 1});
-        CHECK(ap[9] == P{8, 2});
-    }
-    {  // check all true
-        P ap[] = { {1, 1}, {1, 2}, {3, 1}, {3, 2}, {5, 1}, {5, 2}, {7, 1}, {7, 2}, {9, 1}, {9, 2} };
-        std::size_t size = ranges::size(ap);
-        Iter r = ranges::stable_partition(Iter(ap), Sent(ap+size), odd_first());
-        CHECK(base(r) == ap + size);
-        CHECK(ap[0] == P{1, 1});
-        CHECK(ap[1] == P{1, 2});
-        CHECK(ap[2] == P{3, 1});
-        CHECK(ap[3] == P{3, 2});
-        CHECK(ap[4] == P{5, 1});
-        CHECK(ap[5] == P{5, 2});
-        CHECK(ap[6] == P{7, 1});
-        CHECK(ap[7] == P{7, 2});
-        CHECK(ap[8] == P{9, 1});
-        CHECK(ap[9] == P{9, 2});
-    }
-    {  // check all false but first true
-        P ap[] = { {1, 1}, {0, 2}, {2, 1}, {2, 2}, {4, 1}, {4, 2}, {6, 1}, {6, 2}, {8, 1}, {8, 2} };
-        std::size_t size = ranges::size(ap);
-        Iter r = ranges::stable_partition(Iter(ap), Sent(ap+size), odd_first());
-        CHECK(base(r) == ap + 1);
-        CHECK(ap[0] == P{1, 1});
-        CHECK(ap[1] == P{0, 2});
-        CHECK(ap[2] == P{2, 1});
-        CHECK(ap[3] == P{2, 2});
-        CHECK(ap[4] == P{4, 1});
-        CHECK(ap[5] == P{4, 2});
-        CHECK(ap[6] == P{6, 1});
-        CHECK(ap[7] == P{6, 2});
-        CHECK(ap[8] == P{8, 1});
-        CHECK(ap[9] == P{8, 2});
-    }
-    {  // check all false but last true
-        P ap[] = { {0, 1}, {0, 2}, {2, 1}, {2, 2}, {4, 1}, {4, 2}, {6, 1}, {6, 2}, {8, 1}, {1, 2} };
-        std::size_t size = ranges::size(ap);
-        Iter r = ranges::stable_partition(Iter(ap), Sent(ap+size), odd_first());
-        CHECK(base(r) == ap + 1);
-        CHECK(ap[0] == P{1, 2});
-        CHECK(ap[1] == P{0, 1});
-        CHECK(ap[2] == P{0, 2});
-        CHECK(ap[3] == P{2, 1});
-        CHECK(ap[4] == P{2, 2});
-        CHECK(ap[5] == P{4, 1});
-        CHECK(ap[6] == P{4, 2});
-        CHECK(ap[7] == P{6, 1});
-        CHECK(ap[8] == P{6, 2});
-        CHECK(ap[9] == P{8, 1});
-    }
-    {  // check all true but first false
-        P ap[] = { {0, 1}, {1, 2}, {3, 1}, {3, 2}, {5, 1}, {5, 2}, {7, 1}, {7, 2}, {9, 1}, {9, 2} };
-        std::size_t size = ranges::size(ap);
-        Iter r = ranges::stable_partition(Iter(ap), Sent(ap+size), odd_first());
-        CHECK(base(r) == ap + size-1);
-        CHECK(ap[0] == P{1, 2});
-        CHECK(ap[1] == P{3, 1});
-        CHECK(ap[2] == P{3, 2});
-        CHECK(ap[3] == P{5, 1});
-        CHECK(ap[4] == P{5, 2});
-        CHECK(ap[5] == P{7, 1});
-        CHECK(ap[6] == P{7, 2});
-        CHECK(ap[7] == P{9, 1});
-        CHECK(ap[8] == P{9, 2});
-        CHECK(ap[9] == P{0, 1});
-    }
-    {  // check all true but last false
-        P ap[] = { {1, 1}, {1, 2}, {3, 1}, {3, 2}, {5, 1}, {5, 2}, {7, 1}, {7, 2}, {9, 1}, {0, 2} };
-        std::size_t size = ranges::size(ap);
-        Iter r = ranges::stable_partition(Iter(ap), Sent(ap+size), odd_first());
-        CHECK(base(r) == ap + size-1);
-        CHECK(ap[0] == P{1, 1});
-        CHECK(ap[1] == P{1, 2});
-        CHECK(ap[2] == P{3, 1});
-        CHECK(ap[3] == P{3, 2});
-        CHECK(ap[4] == P{5, 1});
-        CHECK(ap[5] == P{5, 2});
-        CHECK(ap[6] == P{7, 1});
-        CHECK(ap[7] == P{7, 2});
-        CHECK(ap[8] == P{9, 1});
-        CHECK(ap[9] == P{0, 2});
-    }
-}
-
-template<class Iter, class Sent = Iter>
-void
-test_range()
-{
-    using P = std::pair<int, int>;
-    {  // check mixed
-        P ap[] = { {0, 1}, {0, 2}, {1, 1}, {1, 2}, {2, 1}, {2, 2}, {3, 1}, {3, 2}, {4, 1}, {4, 2} };
-        std::size_t size = ranges::size(ap);
-        Iter r = ranges::stable_partition(::as_lvalue(ranges::make_subrange(Iter(ap), Sent(ap+size))), odd_first());
-        CHECK(base(r) == ap + 4);
-        CHECK(ap[0] == P{1, 1});
-        CHECK(ap[1] == P{1, 2});
-        CHECK(ap[2] == P{3, 1});
-        CHECK(ap[3] == P{3, 2});
-        CHECK(ap[4] == P{0, 1});
-        CHECK(ap[5] == P{0, 2});
-        CHECK(ap[6] == P{2, 1});
-        CHECK(ap[7] == P{2, 2});
-        CHECK(ap[8] == P{4, 1});
-        CHECK(ap[9] == P{4, 2});
-    }
-    {
-        P ap[] = { {0, 1}, {0, 2}, {1, 1}, {1, 2}, {2, 1}, {2, 2}, {3, 1}, {3, 2}, {4, 1}, {4, 2} };
-        std::size_t size = ranges::size(ap);
-        Iter r = ranges::stable_partition(::as_lvalue(ranges::make_subrange(Iter(ap), Sent(ap+size))), odd_first());
-        CHECK(base(r) == ap + 4);
-        CHECK(ap[0] == P{1, 1});
-        CHECK(ap[1] == P{1, 2});
-        CHECK(ap[2] == P{3, 1});
-        CHECK(ap[3] == P{3, 2});
-        CHECK(ap[4] == P{0, 1});
-        CHECK(ap[5] == P{0, 2});
-        CHECK(ap[6] == P{2, 1});
-        CHECK(ap[7] == P{2, 2});
-        CHECK(ap[8] == P{4, 1});
-        CHECK(ap[9] == P{4, 2});
-        // check empty
-        r = ranges::stable_partition(::as_lvalue(ranges::make_subrange(Iter(ap), Sent(ap))), odd_first());
-        CHECK(base(r) == ap);
-        // check one true
-        r = ranges::stable_partition(::as_lvalue(ranges::make_subrange(Iter(ap), Sent(ap+1))), odd_first());
-        CHECK(base(r) == ap+1);
-        CHECK(ap[0] == P{1, 1});
-        // check one false
-        r = ranges::stable_partition(::as_lvalue(ranges::make_subrange(Iter(ap+4), Sent(ap+5))), odd_first());
-        CHECK(base(r) == ap+4);
-        CHECK(ap[4] == P{0, 1});
-    }
-    {  // check all false
-        P ap[] = { {0, 1}, {0, 2}, {2, 1}, {2, 2}, {4, 1}, {4, 2}, {6, 1}, {6, 2}, {8, 1}, {8, 2} };
-        std::size_t size = ranges::size(ap);
-        Iter r = ranges::stable_partition(::as_lvalue(ranges::make_subrange(Iter(ap), Sent(ap+size))), odd_first());
-        CHECK(base(r) == ap);
-        CHECK(ap[0] == P{0, 1});
-        CHECK(ap[1] == P{0, 2});
-        CHECK(ap[2] == P{2, 1});
-        CHECK(ap[3] == P{2, 2});
-        CHECK(ap[4] == P{4, 1});
-        CHECK(ap[5] == P{4, 2});
-        CHECK(ap[6] == P{6, 1});
-        CHECK(ap[7] == P{6, 2});
-        CHECK(ap[8] == P{8, 1});
-        CHECK(ap[9] == P{8, 2});
-    }
-    {  // check all true
-        P ap[] = { {1, 1}, {1, 2}, {3, 1}, {3, 2}, {5, 1}, {5, 2}, {7, 1}, {7, 2}, {9, 1}, {9, 2} };
-        std::size_t size = ranges::size(ap);
-        Iter r = ranges::stable_partition(::as_lvalue(ranges::make_subrange(Iter(ap), Sent(ap+size))), odd_first());
-        CHECK(base(r) == ap + size);
-        CHECK(ap[0] == P{1, 1});
-        CHECK(ap[1] == P{1, 2});
-        CHECK(ap[2] == P{3, 1});
-        CHECK(ap[3] == P{3, 2});
-        CHECK(ap[4] == P{5, 1});
-        CHECK(ap[5] == P{5, 2});
-        CHECK(ap[6] == P{7, 1});
-        CHECK(ap[7] == P{7, 2});
-        CHECK(ap[8] == P{9, 1});
-        CHECK(ap[9] == P{9, 2});
-    }
-    {  // check all false but first true
-        P ap[] = { {1, 1}, {0, 2}, {2, 1}, {2, 2}, {4, 1}, {4, 2}, {6, 1}, {6, 2}, {8, 1}, {8, 2} };
-        std::size_t size = ranges::size(ap);
-        Iter r = ranges::stable_partition(::as_lvalue(ranges::make_subrange(Iter(ap), Sent(ap+size))), odd_first());
-        CHECK(base(r) == ap + 1);
-        CHECK(ap[0] == P{1, 1});
-        CHECK(ap[1] == P{0, 2});
-        CHECK(ap[2] == P{2, 1});
-        CHECK(ap[3] == P{2, 2});
-        CHECK(ap[4] == P{4, 1});
-        CHECK(ap[5] == P{4, 2});
-        CHECK(ap[6] == P{6, 1});
-        CHECK(ap[7] == P{6, 2});
-        CHECK(ap[8] == P{8, 1});
-        CHECK(ap[9] == P{8, 2});
-    }
-    {  // check all false but last true
-        P ap[] = { {0, 1}, {0, 2}, {2, 1}, {2, 2}, {4, 1}, {4, 2}, {6, 1}, {6, 2}, {8, 1}, {1, 2} };
-        std::size_t size = ranges::size(ap);
-        Iter r = ranges::stable_partition(::as_lvalue(ranges::make_subrange(Iter(ap), Sent(ap+size))), odd_first());
-        CHECK(base(r) == ap + 1);
-        CHECK(ap[0] == P{1, 2});
-        CHECK(ap[1] == P{0, 1});
-        CHECK(ap[2] == P{0, 2});
-        CHECK(ap[3] == P{2, 1});
-        CHECK(ap[4] == P{2, 2});
-        CHECK(ap[5] == P{4, 1});
-        CHECK(ap[6] == P{4, 2});
-        CHECK(ap[7] == P{6, 1});
-        CHECK(ap[8] == P{6, 2});
-        CHECK(ap[9] == P{8, 1});
-    }
-    {  // check all true but first false
-        P ap[] = { {0, 1}, {1, 2}, {3, 1}, {3, 2}, {5, 1}, {5, 2}, {7, 1}, {7, 2}, {9, 1}, {9, 2} };
-        std::size_t size = ranges::size(ap);
-        Iter r = ranges::stable_partition(::as_lvalue(ranges::make_subrange(Iter(ap), Sent(ap+size))), odd_first());
-        CHECK(base(r) == ap + size-1);
-        CHECK(ap[0] == P{1, 2});
-        CHECK(ap[1] == P{3, 1});
-        CHECK(ap[2] == P{3, 2});
-        CHECK(ap[3] == P{5, 1});
-        CHECK(ap[4] == P{5, 2});
-        CHECK(ap[5] == P{7, 1});
-        CHECK(ap[6] == P{7, 2});
-        CHECK(ap[7] == P{9, 1});
-        CHECK(ap[8] == P{9, 2});
-        CHECK(ap[9] == P{0, 1});
-    }
-    {  // check all true but last false
-        P ap[] = { {1, 1}, {1, 2}, {3, 1}, {3, 2}, {5, 1}, {5, 2}, {7, 1}, {7, 2}, {9, 1}, {0, 2} };
-        std::size_t size = ranges::size(ap);
-        Iter r = ranges::stable_partition(::as_lvalue(ranges::make_subrange(Iter(ap), Sent(ap+size))), odd_first());
-        CHECK(base(r) == ap + size-1);
-        CHECK(ap[0] == P{1, 1});
-        CHECK(ap[1] == P{1, 2});
-        CHECK(ap[2] == P{3, 1});
-        CHECK(ap[3] == P{3, 2});
-        CHECK(ap[4] == P{5, 1});
-        CHECK(ap[5] == P{5, 2});
-        CHECK(ap[6] == P{7, 1});
-        CHECK(ap[7] == P{7, 2});
-        CHECK(ap[8] == P{9, 1});
-        CHECK(ap[9] == P{0, 2});
-    }
-}
-
-struct move_only
-{
-    static int count;
-    int i;
-    move_only() = delete;
-    move_only(int j) : i(j) { ++count; }
-    move_only(move_only &&that) : i(that.i) {  ++count; }
-    move_only(move_only const &) = delete;
-    ~move_only() { --count; }
-    move_only &operator=(move_only &&) = default;
-    move_only &operator=(move_only const &) = delete;
-};
-
-int move_only::count = 0;
-
-template<class Iter>
-void
-test_move_only()
-{
-    const unsigned size = 5;
-    move_only array[size] = { 1, 2, 3, 4, 5 };
-    Iter r = ranges::stable_partition(Iter(array), Iter(array+size), is_odd{}, &move_only::i);
-    CHECK(base(r) == array + 3);
-    CHECK(array[0].i == 1);
-    CHECK(array[1].i == 3);
-    CHECK(array[2].i == 5);
-    CHECK(array[3].i == 2);
-    CHECK(array[4].i == 4);
-}
-
-struct S
-{
-    std::pair<int,int> p;
-};
-
-int main()
-{
-    test_iter<BidirectionalIterator<std::pair<int,int>*> >();
-    test_iter<RandomAccessIterator<std::pair<int,int>*> >();
-    test_iter<std::pair<int,int>*>();
-    test_iter<BidirectionalIterator<std::pair<int,int>*>, Sentinel<std::pair<int,int>*> >();
-    test_iter<RandomAccessIterator<std::pair<int,int>*>, Sentinel<std::pair<int,int>*> >();
-
-    test_range<BidirectionalIterator<std::pair<int,int>*> >();
-    test_range<RandomAccessIterator<std::pair<int,int>*> >();
-    test_range<std::pair<int,int>*>();
-    test_range<BidirectionalIterator<std::pair<int,int>*>, Sentinel<std::pair<int,int>*> >();
-    test_range<RandomAccessIterator<std::pair<int,int>*>, Sentinel<std::pair<int,int>*> >();
-
-    CHECK(move_only::count == 0);
-    test_move_only<BidirectionalIterator<move_only*> >();
-    CHECK(move_only::count == 0);
-
-    // Test projections
-    using P = std::pair<int, int>;
-    {  // check mixed
-        S ap[] = { {{0, 1}}, {{0, 2}}, {{1, 1}}, {{1, 2}}, {{2, 1}}, {{2, 2}}, {{3, 1}}, {{3, 2}}, {{4, 1}}, {{4, 2}} };
-        S* r = ranges::stable_partition(ap, odd_first(), &S::p);
-        CHECK(r == ap + 4);
-        CHECK(ap[0].p == P{1, 1});
-        CHECK(ap[1].p == P{1, 2});
-        CHECK(ap[2].p == P{3, 1});
-        CHECK(ap[3].p == P{3, 2});
-        CHECK(ap[4].p == P{0, 1});
-        CHECK(ap[5].p == P{0, 2});
-        CHECK(ap[6].p == P{2, 1});
-        CHECK(ap[7].p == P{2, 2});
-        CHECK(ap[8].p == P{4, 1});
-        CHECK(ap[9].p == P{4, 2});
-    }
-
-    // Test rvalue ranges
-    using P = std::pair<int, int>;
-    {  // check mixed
-        S ap[] = { {{0, 1}}, {{0, 2}}, {{1, 1}}, {{1, 2}}, {{2, 1}}, {{2, 2}}, {{3, 1}}, {{3, 2}}, {{4, 1}}, {{4, 2}} };
-        auto r = ranges::stable_partition(ranges::views::all(ap), odd_first(), &S::p);
-        CHECK(r == ap + 4);
-        CHECK(ap[0].p == P{1, 1});
-        CHECK(ap[1].p == P{1, 2});
-        CHECK(ap[2].p == P{3, 1});
-        CHECK(ap[3].p == P{3, 2});
-        CHECK(ap[4].p == P{0, 1});
-        CHECK(ap[5].p == P{0, 2});
-        CHECK(ap[6].p == P{2, 1});
-        CHECK(ap[7].p == P{2, 2});
-        CHECK(ap[8].p == P{4, 1});
-        CHECK(ap[9].p == P{4, 2});
-    }
-    {  // check mixed
-        S ap[] = { {{0, 1}}, {{0, 2}}, {{1, 1}}, {{1, 2}}, {{2, 1}}, {{2, 2}}, {{3, 1}}, {{3, 2}}, {{4, 1}}, {{4, 2}} };
-        auto r = ranges::stable_partition(std::move(ap), odd_first(), &S::p);
-#ifndef RANGES_WORKAROUND_MSVC_573728
-        CHECK(::is_dangling(r));
-#endif // RANGES_WORKAROUND_MSVC_573728
-        CHECK(ap[0].p == P{1, 1});
-        CHECK(ap[1].p == P{1, 2});
-        CHECK(ap[2].p == P{3, 1});
-        CHECK(ap[3].p == P{3, 2});
-        CHECK(ap[4].p == P{0, 1});
-        CHECK(ap[5].p == P{0, 2});
-        CHECK(ap[6].p == P{2, 1});
-        CHECK(ap[7].p == P{2, 2});
-        CHECK(ap[8].p == P{4, 1});
-        CHECK(ap[9].p == P{4, 2});
-    }
-    {  // check mixed
-        std::vector<S> ap{ {{0, 1}}, {{0, 2}}, {{1, 1}}, {{1, 2}}, {{2, 1}}, {{2, 2}}, {{3, 1}}, {{3, 2}}, {{4, 1}}, {{4, 2}} };
-        auto r = ranges::stable_partition(std::move(ap), odd_first(), &S::p);
-        CHECK(::is_dangling(r));
-        CHECK(ap[0].p == P{1, 1});
-        CHECK(ap[1].p == P{1, 2});
-        CHECK(ap[2].p == P{3, 1});
-        CHECK(ap[3].p == P{3, 2});
-        CHECK(ap[4].p == P{0, 1});
-        CHECK(ap[5].p == P{0, 2});
-        CHECK(ap[6].p == P{2, 1});
-        CHECK(ap[7].p == P{2, 2});
-        CHECK(ap[8].p == P{4, 1});
-        CHECK(ap[9].p == P{4, 2});
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/stable_sort.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/stable_sort.cpp
deleted file mode 100644
index ddc5a674..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/stable_sort.cpp
+++ /dev/null
@@ -1,260 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <memory>
-#include <random>
-#include <vector>
-#include <algorithm>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/stable_sort.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS
-RANGES_DIAGNOSTIC_IGNORE_SIGN_CONVERSION
-
-namespace
-{
-    std::mt19937 gen;
-
-#if !defined(__clang__) || !defined(_MSVC_STL_VERSION) // Avoid #890
-    struct indirect_less
-    {
-        template<class P>
-        bool operator()(const P& x, const P& y)
-            {return *x < *y;}
-    };
-#endif // Avoid #890
-
-    template<class RI>
-    void
-    test_sort_helper(RI f, RI l)
-    {
-        using value_type = ranges::iter_value_t<RI>;
-        auto stable_sort = make_testable_1<false>(ranges::stable_sort);
-        if (f != l)
-        {
-            auto len = l - f;
-            value_type* save(new value_type[len]);
-            do
-            {
-                std::copy(f, l, save);
-                stable_sort(save, save+len).check([&](int *res)
-                {
-                    CHECK(res == save+len);
-                    CHECK(std::is_sorted(save, save+len));
-                    std::copy(f, l, save);
-                });
-                stable_sort(save, save+len, std::greater<int>{}).check([&](int *res)
-                {
-                    CHECK(res == save+len);
-                    CHECK(std::is_sorted(save, save+len, std::greater<int>{}));
-                    std::copy(f, l, save);
-                });
-            } while (std::next_permutation(f, l));
-            delete [] save;
-        }
-    }
-
-    template<class RI>
-    void
-    test_sort_driver_driver(RI f, RI l, int start, RI real_last)
-    {
-        for (RI i = l; i > f + start;)
-        {
-            *--i = start;
-            if (f == i)
-            {
-                test_sort_helper(f, real_last);
-            }
-            if (start > 0)
-                test_sort_driver_driver(f, i, start-1, real_last);
-        }
-    }
-
-    template<class RI>
-    void
-    test_sort_driver(RI f, RI l, int start)
-    {
-        test_sort_driver_driver(f, l, start, l);
-    }
-
-    template<int sa>
-    void
-    test_sort_()
-    {
-        int ia[sa];
-        for (int i = 0; i < sa; ++i)
-        {
-            test_sort_driver(ia, ia+sa, i);
-        }
-    }
-
-    void
-    test_larger_sorts(int N, int M)
-    {
-        RANGES_ENSURE(N > 0);
-        RANGES_ENSURE(M > 0);
-        // create array length N filled with M different numbers
-        int* array = new int[N];
-        int x = 0;
-        for (int i = 0; i < N; ++i)
-        {
-            array[i] = x;
-            if (++x == M)
-                x = 0;
-        }
-
-        // test saw tooth pattern
-        CHECK(ranges::stable_sort(array, array+N) == array+N);
-        CHECK(std::is_sorted(array, array+N));
-        // test random pattern
-        std::shuffle(array, array+N, gen);
-        CHECK(ranges::stable_sort(array, array+N) == array+N);
-        CHECK(std::is_sorted(array, array+N));
-        // test sorted pattern
-        CHECK(ranges::stable_sort(array, array+N) == array+N);
-        CHECK(std::is_sorted(array, array+N));
-        // test reverse sorted pattern
-        std::reverse(array, array+N);
-        CHECK(ranges::stable_sort(array, array+N) == array+N);
-        CHECK(std::is_sorted(array, array+N));
-        // test swap ranges 2 pattern
-        std::swap_ranges(array, array+N/2, array+N/2);
-        CHECK(ranges::stable_sort(array, array+N) == array+N);
-        CHECK(std::is_sorted(array, array+N));
-        // test reverse swap ranges 2 pattern
-        std::reverse(array, array+N);
-        std::swap_ranges(array, array+N/2, array+N/2);
-        CHECK(ranges::stable_sort(array, array+N) == array+N);
-        CHECK(std::is_sorted(array, array+N));
-        delete [] array;
-    }
-
-    void
-    test_larger_sorts(unsigned N)
-    {
-        test_larger_sorts(N, 1);
-        test_larger_sorts(N, 2);
-        test_larger_sorts(N, 3);
-        test_larger_sorts(N, N/2-1);
-        test_larger_sorts(N, N/2);
-        test_larger_sorts(N, N/2+1);
-        test_larger_sorts(N, N-2);
-        test_larger_sorts(N, N-1);
-        test_larger_sorts(N, N);
-    }
-
-    struct S
-    {
-        int i, j;
-    };
-}
-
-int main()
-{
-    // test null range
-    int d = 0;
-    int * r = ranges::stable_sort(&d, &d);
-    CHECK(r == &d);
-    // exhaustively test all possibilities up to length 8
-    test_sort_<1>();
-    test_sort_<2>();
-    test_sort_<3>();
-    test_sort_<4>();
-    test_sort_<5>();
-    test_sort_<6>();
-    test_sort_<7>();
-    test_sort_<8>();
-
-    test_larger_sorts(15);
-    test_larger_sorts(16);
-    test_larger_sorts(17);
-    test_larger_sorts(256);
-    test_larger_sorts(257);
-    test_larger_sorts(499);
-    test_larger_sorts(500);
-    test_larger_sorts(997);
-    test_larger_sorts(1000);
-    test_larger_sorts(1009);
-
-#if !defined(__clang__) || !defined(_MSVC_STL_VERSION) // Avoid #890
-    // Check move-only types
-    {
-        std::vector<std::unique_ptr<int> > v(1000);
-        for(int i = 0; (std::size_t)i < v.size(); ++i)
-            v[i].reset(new int((int)v.size() - i - 1));
-        ranges::stable_sort(v, indirect_less());
-        for(int i = 0; (std::size_t)i < v.size(); ++i)
-            CHECK(*v[i] == i);
-    }
-
-    // Check projections
-    {
-        std::vector<S> v(1000, S{});
-        for(int i = 0; (std::size_t)i < v.size(); ++i)
-        {
-            v[i].i = (int)v.size() - i - 1;
-            v[i].j = i;
-        }
-        ranges::stable_sort(v, std::less<int>{}, &S::i);
-        for(int i = 0; (std::size_t)i < v.size(); ++i)
-        {
-            CHECK(v[i].i == i);
-            CHECK((std::size_t)v[i].j == v.size() - i - 1);
-        }
-    }
-
-    // Check rvalue container
-    {
-        std::vector<S> v(1000, S{});
-        for(int i = 0; (std::size_t)i < v.size(); ++i)
-        {
-            v[i].i = (int)v.size() - i - 1;
-            v[i].j = i;
-        }
-        CHECK(::is_dangling(ranges::stable_sort(std::move(v), std::less<int>{}, &S::i)));
-        for(int i = 0; (std::size_t)i < v.size(); ++i)
-        {
-            CHECK(v[i].i == i);
-            CHECK((std::size_t)v[i].j == v.size() - i - 1);
-        }
-    }
-
-    // Check rvalue forwarding range
-    {
-        std::vector<S> v(1000, S{});
-        for(int i = 0; (std::size_t)i < v.size(); ++i)
-        {
-            v[i].i = (int)v.size() - i - 1;
-            v[i].j = i;
-        }
-        CHECK(ranges::stable_sort(ranges::views::all(v), std::less<int>{}, &S::i) == v.end());
-        for(int i = 0; (std::size_t)i < v.size(); ++i)
-        {
-            CHECK(v[i].i == i);
-            CHECK((std::size_t)v[i].j == v.size() - i - 1);
-        }
-    }
-#endif // Avoid #890
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/starts_with.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/starts_with.cpp
deleted file mode 100644
index b8e9bbe5..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/starts_with.cpp
+++ /dev/null
@@ -1,124 +0,0 @@
-// Range v3 library
-//
-//  Copyright 2019 Christopher Di Bella
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-#include <range/v3/algorithm/starts_with.hpp>
-
-#include "../simple_test.hpp"
-#include "../test_iterators.hpp"
-#include <forward_list>
-#include <range/v3/range/conversion.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/slice.hpp>
-#include <range/v3/view/take_exactly.hpp>
-#include <range/v3/view/istream.hpp>
-#include <sstream>
-#include <vector>
-
-void test_defaults()
-{
-   using namespace ranges;
-   { // checks starts_with works for input ranges
-      constexpr auto full_latin_alphabet = "a b c d e f g h i j k l m n o p q r s t u v w x y z";
-      auto const partial_latin_alphabet = "a b c d";
-
-      {
-         auto long_stream = std::istringstream{full_latin_alphabet};
-         auto short_stream = std::istringstream{partial_latin_alphabet};
-
-         auto r1 = istream<char>(long_stream);
-         auto r2 = istream<char>(short_stream);
-         CHECK(starts_with(begin(r1), end(r1), begin(r2), end(r2)));
-      }
-      {
-         auto long_stream = std::istringstream{full_latin_alphabet};
-         auto short_stream = std::istringstream{partial_latin_alphabet};
-
-         auto r1 = istream<char>(long_stream);
-         auto r2 = istream<char>(short_stream);
-         CHECK(!starts_with(begin(r2), end(r2), begin(r1), end(r1)));
-      }
-      {
-         auto long_stream = std::istringstream{full_latin_alphabet};
-         auto short_stream = std::istringstream{partial_latin_alphabet};
-         CHECK(starts_with(istream<char>(long_stream), istream<char>(short_stream)));
-      }
-      {
-         auto long_stream = std::istringstream{full_latin_alphabet};
-         auto short_stream = std::istringstream{partial_latin_alphabet};
-         CHECK(!starts_with(istream<char>(short_stream), istream<char>(long_stream)));
-      }
-   }
-   { // checks starts_with works for random-access ranges
-#ifdef RANGES_WORKAROUND_MSVC_779708
-      auto const long_range = views::iota(0, 100) | to<std::vector>();
-      auto const short_range = views::iota(0, 10) | to<std::vector>();
-#else // ^^^ workaround / no workaround vvv
-      auto const long_range = views::iota(0, 100) | to<std::vector>;
-      auto const short_range = views::iota(0, 10) | to<std::vector>;
-#endif // RANGES_WORKAROUND_MSVC_779708
-
-      CHECK(starts_with(begin(long_range), end(long_range), begin(short_range), end(short_range)));
-      CHECK(starts_with(long_range, short_range));
-
-      CHECK(!starts_with(begin(short_range), end(short_range), begin(long_range), end(long_range)));
-      CHECK(!starts_with(short_range, long_range));
-   }
-   { // checks starts_with works for random-access ranges with arbitrary sentinels
-      auto const long_range = views::iota(0);
-      auto const short_range = views::iota(0) | views::take_exactly(100);
-
-      CHECK(starts_with(begin(long_range), end(long_range), begin(short_range), end(short_range)));
-      CHECK(starts_with(long_range, short_range));
-
-      CHECK(!starts_with(begin(short_range), end(short_range), begin(long_range), end(long_range)));
-      CHECK(!starts_with(short_range, long_range));
-   }
-   { // checks starts_with identifies a subrange
-      auto const range = views::iota(0) | views::slice(50, 100);
-      auto const offset = views::iota(50, 100);
-
-      CHECK(starts_with(begin(range), end(range), begin(offset), end(offset)));
-      CHECK(starts_with(range, offset));
-
-      CHECK(starts_with(begin(offset), end(offset), begin(range), end(range)));
-      CHECK(starts_with(offset, range));
-   }
-   { // checks starts_with identifies when two ranges don't have the same start sequence
-      auto const first = views::iota(0, 1'000);
-      auto const second = views::iota(10, 1'000);
-
-      CHECK(!starts_with(begin(first), end(first), begin(second), end(second)));
-      CHECK(!starts_with(first, second));
-
-      CHECK(!starts_with(begin(second), end(second), begin(first), end(first)));
-      CHECK(!starts_with(second, first));
-   }
-}
-
-void test_comparison()
-{
-   using namespace ranges;
-   auto const long_range = views::iota(0, 100);
-   auto const short_range = views::iota(1, 51);
-   CHECK(starts_with(begin(long_range), end(long_range), begin(short_range), end(short_range),
-      less{}));
-   CHECK(starts_with(long_range, short_range, less{}));
-
-   CHECK(!starts_with(begin(long_range), end(long_range), begin(short_range), end(short_range),
-      greater{}));
-   CHECK(!starts_with(long_range, short_range, greater{}));
-}
-
-int main()
-{
-   ::test_defaults();
-   ::test_comparison();
-   return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/swap_ranges.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/swap_ranges.cpp
deleted file mode 100644
index a6dd1cce..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/swap_ranges.cpp
+++ /dev/null
@@ -1,247 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <array>
-#include <memory>
-#include <algorithm>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/swap_ranges.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-template<class Iter1, class Iter2>
-void test_iter_3()
-{
-    int i[3] = {1, 2, 3};
-    int j[3] = {4, 5, 6};
-    ranges::swap_ranges_result<Iter1, Iter2> r =
-        ranges::swap_ranges(Iter1(i), Iter1(i+3), Iter2(j));
-    CHECK(base(r.in1) == i+3);
-    CHECK(base(r.in2) == j+3);
-    CHECK(i[0] == 4);
-    CHECK(i[1] == 5);
-    CHECK(i[2] == 6);
-    CHECK(j[0] == 1);
-    CHECK(j[1] == 2);
-    CHECK(j[2] == 3);
-
-    using Sent1 = typename sentinel_type<Iter1>::type;
-    r = ranges::swap_ranges(Iter1(j), Sent1(j+3), Iter2(i));
-    CHECK(base(r.in1) == j+3);
-    CHECK(base(r.in2) == i+3);
-    CHECK(i[0] == 1);
-    CHECK(i[1] == 2);
-    CHECK(i[2] == 3);
-    CHECK(j[0] == 4);
-    CHECK(j[1] == 5);
-    CHECK(j[2] == 6);
-}
-
-template<class Iter1, class Iter2>
-void test_iter_4()
-{
-    int i[3] = {1, 2, 3};
-    int j[4] = {4, 5, 6, 7};
-    ranges::swap_ranges_result<Iter1, Iter2> r =
-        ranges::swap_ranges(Iter1(i), Iter1(i+3), Iter2(j), Iter2(j+4));
-    CHECK(base(r.in1) == i+3);
-    CHECK(base(r.in2) == j+3);
-    CHECK(i[0] == 4);
-    CHECK(i[1] == 5);
-    CHECK(i[2] == 6);
-    CHECK(j[0] == 1);
-    CHECK(j[1] == 2);
-    CHECK(j[2] == 3);
-    CHECK(j[3] == 7);
-
-    using Sent1 = typename sentinel_type<Iter1>::type;
-    using Sent2 = typename sentinel_type<Iter2>::type;
-    r = ranges::swap_ranges(Iter1(j), Sent1(j+4), Iter2(i), Sent2(i+3));
-    CHECK(base(r.in1) == j+3);
-    CHECK(base(r.in2) == i+3);
-    CHECK(i[0] == 1);
-    CHECK(i[1] == 2);
-    CHECK(i[2] == 3);
-    CHECK(j[0] == 4);
-    CHECK(j[1] == 5);
-    CHECK(j[2] == 6);
-    CHECK(j[3] == 7);
-}
-
-template<class Iter1, class Iter2>
-void test_rng_3()
-{
-    int i[3] = {1, 2, 3};
-    int j[3] = {4, 5, 6};
-    ranges::swap_ranges_result<Iter1, Iter2> r =
-        ranges::swap_ranges(as_lvalue(ranges::make_subrange(Iter1(i), Iter1(i+3))), Iter2(j));
-    CHECK(base(r.in1) == i+3);
-    CHECK(base(r.in2) == j+3);
-    CHECK(i[0] == 4);
-    CHECK(i[1] == 5);
-    CHECK(i[2] == 6);
-    CHECK(j[0] == 1);
-    CHECK(j[1] == 2);
-    CHECK(j[2] == 3);
-
-    using Sent1 = typename sentinel_type<Iter1>::type;
-    r = ranges::swap_ranges(as_lvalue(ranges::make_subrange(Iter1(j), Sent1(j+3))), Iter2(i));
-    CHECK(base(r.in1) == j+3);
-    CHECK(base(r.in2) == i+3);
-    CHECK(i[0] == 1);
-    CHECK(i[1] == 2);
-    CHECK(i[2] == 3);
-    CHECK(j[0] == 4);
-    CHECK(j[1] == 5);
-    CHECK(j[2] == 6);
-}
-
-template<class Iter1, class Iter2>
-void test_rng_4()
-{
-    int i[3] = {1, 2, 3};
-    int j[4] = {4, 5, 6, 7};
-    ranges::swap_ranges_result<Iter1, Iter2> r = ranges::swap_ranges(
-        as_lvalue(ranges::make_subrange(Iter1(i), Iter1(i+3))),
-        as_lvalue(ranges::make_subrange(Iter2(j), Iter2(j+4))));
-    CHECK(base(r.in1) == i+3);
-    CHECK(base(r.in2) == j+3);
-    CHECK(i[0] == 4);
-    CHECK(i[1] == 5);
-    CHECK(i[2] == 6);
-    CHECK(j[0] == 1);
-    CHECK(j[1] == 2);
-    CHECK(j[2] == 3);
-    CHECK(j[3] == 7);
-
-    using Sent1 = typename sentinel_type<Iter1>::type;
-    using Sent2 = typename sentinel_type<Iter2>::type;
-    r = ranges::swap_ranges(
-        as_lvalue(ranges::make_subrange(Iter1(j), Sent1(j+4))),
-        as_lvalue(ranges::make_subrange(Iter2(i), Sent2(i+3))));
-    CHECK(base(r.in1) == j+3);
-    CHECK(base(r.in2) == i+3);
-    CHECK(i[0] == 1);
-    CHECK(i[1] == 2);
-    CHECK(i[2] == 3);
-    CHECK(j[0] == 4);
-    CHECK(j[1] == 5);
-    CHECK(j[2] == 6);
-    CHECK(j[3] == 7);
-
-    auto r2 = ranges::swap_ranges(
-        ranges::make_subrange(Iter1(j), Sent1(j+4)),
-        ranges::make_subrange(Iter2(i), Sent2(i+3)));
-    CHECK(base(r2.in1) == j+3);
-    CHECK(base(r2.in2) == i+3);
-    CHECK(i[0] == 4);
-    CHECK(i[1] == 5);
-    CHECK(i[2] == 6);
-    CHECK(j[0] == 1);
-    CHECK(j[1] == 2);
-    CHECK(j[2] == 3);
-    CHECK(j[3] == 7);
-}
-
-template<class Iter1, class Iter2>
-void test_move_only()
-{
-    std::unique_ptr<int> i[3];
-    for (int k = 0; k < 3; ++k)
-        i[k].reset(new int(k+1));
-    std::unique_ptr<int> j[3];
-    for (int k = 0; k < 3; ++k)
-        j[k].reset(new int(k+4));
-    ranges::swap_ranges_result<Iter1, Iter2> r =
-        ranges::swap_ranges(Iter1(i), Iter1(i+3), Iter2(j));
-    CHECK(base(r.in1) == i+3);
-    CHECK(base(r.in2) == j+3);
-    CHECK(*i[0] == 4);
-    CHECK(*i[1] == 5);
-    CHECK(*i[2] == 6);
-    CHECK(*j[0] == 1);
-    CHECK(*j[1] == 2);
-    CHECK(*j[2] == 3);
-}
-
-template<class Iter1, class Iter2>
-void test()
-{
-    test_iter_3<Iter1, Iter2>();
-    test_iter_4<Iter1, Iter2>();
-    test_rng_3<Iter1, Iter2>();
-    test_rng_4<Iter1, Iter2>();
-}
-
-int main()
-{
-    test<ForwardIterator<int*>, ForwardIterator<int*> >();
-    test<ForwardIterator<int*>, BidirectionalIterator<int*> >();
-    test<ForwardIterator<int*>, RandomAccessIterator<int*> >();
-    test<ForwardIterator<int*>, int*>();
-
-    test<BidirectionalIterator<int*>, ForwardIterator<int*> >();
-    test<BidirectionalIterator<int*>, BidirectionalIterator<int*> >();
-    test<BidirectionalIterator<int*>, RandomAccessIterator<int*> >();
-    test<BidirectionalIterator<int*>, int*>();
-
-    test<RandomAccessIterator<int*>, ForwardIterator<int*> >();
-    test<RandomAccessIterator<int*>, BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<int*>, RandomAccessIterator<int*> >();
-    test<RandomAccessIterator<int*>, int*>();
-
-    test<int*, ForwardIterator<int*> >();
-    test<int*, BidirectionalIterator<int*> >();
-    test<int*, RandomAccessIterator<int*> >();
-    test<int*, int*>();
-
-    test_move_only<ForwardIterator<std::unique_ptr<int>*>, ForwardIterator<std::unique_ptr<int>*> >();
-    test_move_only<ForwardIterator<std::unique_ptr<int>*>, BidirectionalIterator<std::unique_ptr<int>*> >();
-    test_move_only<ForwardIterator<std::unique_ptr<int>*>, RandomAccessIterator<std::unique_ptr<int>*> >();
-    test_move_only<ForwardIterator<std::unique_ptr<int>*>, std::unique_ptr<int>*>();
-
-    test_move_only<BidirectionalIterator<std::unique_ptr<int>*>, ForwardIterator<std::unique_ptr<int>*> >();
-    test_move_only<BidirectionalIterator<std::unique_ptr<int>*>, BidirectionalIterator<std::unique_ptr<int>*> >();
-    test_move_only<BidirectionalIterator<std::unique_ptr<int>*>, RandomAccessIterator<std::unique_ptr<int>*> >();
-    test_move_only<BidirectionalIterator<std::unique_ptr<int>*>, std::unique_ptr<int>*>();
-
-    test_move_only<RandomAccessIterator<std::unique_ptr<int>*>, ForwardIterator<std::unique_ptr<int>*> >();
-    test_move_only<RandomAccessIterator<std::unique_ptr<int>*>, BidirectionalIterator<std::unique_ptr<int>*> >();
-    test_move_only<RandomAccessIterator<std::unique_ptr<int>*>, RandomAccessIterator<std::unique_ptr<int>*> >();
-    test_move_only<RandomAccessIterator<std::unique_ptr<int>*>, std::unique_ptr<int>*>();
-
-    test_move_only<std::unique_ptr<int>*, ForwardIterator<std::unique_ptr<int>*> >();
-    test_move_only<std::unique_ptr<int>*, BidirectionalIterator<std::unique_ptr<int>*> >();
-    test_move_only<std::unique_ptr<int>*, RandomAccessIterator<std::unique_ptr<int>*> >();
-    test_move_only<std::unique_ptr<int>*, std::unique_ptr<int>*>();
-
-    {
-        int a[4] = {1, 2, 3, 4};
-        int b[4] = {5, 6, 7, 8};
-        ranges::swap_ranges(a, a + 4, b);
-        ::check_equal(a, {5, 6, 7, 8});
-        ::check_equal(b, {1, 2, 3, 4});
-        ranges::swap_ranges(std::array<int, 2>{{3,4}}, a+2);
-        ::check_equal(a, {5, 6, 3, 4});
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/transform.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/transform.cpp
deleted file mode 100644
index 3de0cd84..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/transform.cpp
+++ /dev/null
@@ -1,430 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <functional>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/transform.hpp>
-#include <range/v3/view/unbounded.hpp>
-#include "../simple_test.hpp"
-#include "../test_iterators.hpp"
-
-using namespace std::placeholders;
-
-RANGES_DIAGNOSTIC_IGNORE_DEPRECATED_DECLARATIONS
-
-template<class InIter, class OutIter>
-void
-test1()
-{
-    {
-        int ia[] = {0, 1, 2, 3, 4};
-        constexpr auto sa = ranges::size(ia);
-        int ib[sa] = {0};
-        ranges::unary_transform_result<InIter, OutIter> r =
-            ranges::transform(InIter(ia), Sentinel<int const *>(ia+sa), OutIter(ib),
-                              std::bind(std::plus<int>(), _1, 1));
-        CHECK(base(r.in) == ia + sa);
-        CHECK(base(r.out) == ib + sa);
-        CHECK(ib[0] == 1);
-        CHECK(ib[1] == 2);
-        CHECK(ib[2] == 3);
-        CHECK(ib[3] == 4);
-        CHECK(ib[4] == 5);
-    }
-
-    {
-        int ia[] = {0, 1, 2, 3, 4};
-        constexpr auto sa = ranges::size(ia);
-        int ib[sa] = {0};
-        auto rng = ranges::make_subrange(InIter(ia), Sentinel<int const *>(ia + sa));
-        ranges::unary_transform_result<InIter, OutIter> r =
-            ranges::transform(rng, OutIter(ib),
-                              std::bind(std::plus<int>(), _1, 1));
-        CHECK(base(r.in) == ia + sa);
-        CHECK(base(r.out) == ib + sa);
-        CHECK(ib[0] == 1);
-        CHECK(ib[1] == 2);
-        CHECK(ib[2] == 3);
-        CHECK(ib[3] == 4);
-        CHECK(ib[4] == 5);
-    }
-
-    {
-        int ia[] = {0, 1, 2, 3, 4};
-        constexpr auto sa = ranges::size(ia);
-        int ib[sa] = {0};
-        auto rng = ranges::make_subrange(InIter(ia), Sentinel<int const *>(ia + sa));
-        auto r =
-            ranges::transform(std::move(rng), OutIter(ib),
-                              std::bind(std::plus<int>(), _1, 1));
-        CHECK(base(r.in) == ia + sa);
-        CHECK(base(r.out) == ib + sa);
-        CHECK(ib[0] == 1);
-        CHECK(ib[1] == 2);
-        CHECK(ib[2] == 3);
-        CHECK(ib[3] == 4);
-        CHECK(ib[4] == 5);
-    }
-}
-
-template<class InIter1, class InIter2, class OutIter>
-void
-test2()
-{
-    {
-        int ia[] = {0, 1, 2, 3, 4};
-        constexpr auto sa = ranges::size(ia);
-        int ib[sa] = {1, 2, 3, 4, 5};
-        ranges::binary_transform_result<InIter1, InIter2, OutIter> r =
-            ranges::transform(InIter1(ib), Sentinel<int const *>(ib + sa), InIter2(ia),
-                              OutIter(ib), std::minus<int>());
-        CHECK(base(r.in1) == ib + sa);
-        CHECK(base(r.in2) == ia + sa);
-        CHECK(base(r.out) == ib + sa);
-        CHECK(ib[0] == 1);
-        CHECK(ib[1] == 1);
-        CHECK(ib[2] == 1);
-        CHECK(ib[3] == 1);
-        CHECK(ib[4] == 1);
-    }
-
-    {
-        int ia[] = {0, 1, 2, 3, 4};
-        constexpr auto sa = ranges::size(ia);
-        int ib[sa] = {1, 2, 3, 4, 5};
-        ranges::binary_transform_result<InIter1, InIter2, OutIter> r =
-            ranges::transform(InIter1(ib), Sentinel<int const *>(ib + sa),
-                              InIter2(ia), Sentinel<int const *>(ia + sa),
-                              OutIter(ib), std::minus<int>());
-        CHECK(base(r.in1) == ib + sa);
-        CHECK(base(r.in2) == ia + sa);
-        CHECK(base(r.out) == ib + sa);
-        CHECK(ib[0] == 1);
-        CHECK(ib[1] == 1);
-        CHECK(ib[2] == 1);
-        CHECK(ib[3] == 1);
-        CHECK(ib[4] == 1);
-    }
-
-    {
-        int ia[] = {0, 1, 2, 3, 4};
-        constexpr auto sa = ranges::size(ia);
-        int ib[sa] = {1, 2, 3, 4, 5};
-        auto rng0 = ranges::make_subrange(InIter1(ib), Sentinel<int const *>(ib + sa));
-        ranges::binary_transform_result<InIter1, InIter2, OutIter> r =
-            ranges::transform(rng0, InIter2(ia),
-                              OutIter(ib), std::minus<int>());
-        CHECK(base(r.in1) == ib + sa);
-        CHECK(base(r.in2) == ia + sa);
-        CHECK(base(r.out) == ib + sa);
-        CHECK(ib[0] == 1);
-        CHECK(ib[1] == 1);
-        CHECK(ib[2] == 1);
-        CHECK(ib[3] == 1);
-        CHECK(ib[4] == 1);
-    }
-
-    {
-        int ia[] = {0, 1, 2, 3, 4};
-        constexpr auto sa = ranges::size(ia);
-        int ib[sa] = {1, 2, 3, 4, 5};
-        auto rng0 = ranges::make_subrange(InIter1(ib), Sentinel<int const *>(ib + sa));
-        auto r =
-            ranges::transform(std::move(rng0), InIter2(ia),
-                              OutIter(ib), std::minus<int>());
-        CHECK(base(r.in1) == ib + sa);
-        CHECK(base(r.in2) == ia + sa);
-        CHECK(base(r.out) == ib + sa);
-        CHECK(ib[0] == 1);
-        CHECK(ib[1] == 1);
-        CHECK(ib[2] == 1);
-        CHECK(ib[3] == 1);
-        CHECK(ib[4] == 1);
-    }
-
-    {
-        int ia[] = {0, 1, 2, 3, 4};
-        constexpr auto sa = ranges::size(ia);
-        int ib[sa] = {1, 2, 3, 4, 5};
-        auto rng0 = ranges::make_subrange(InIter1(ib), Sentinel<int const *>(ib + sa));
-        auto rng1 = ranges::make_subrange(InIter2(ia), Sentinel<int const *>(ia + sa));
-        ranges::binary_transform_result<InIter1, InIter2, OutIter> r =
-            ranges::transform(rng0, rng1, OutIter(ib), std::minus<int>());
-        CHECK(base(r.in1) == ib + sa);
-        CHECK(base(r.in2) == ia + sa);
-        CHECK(base(r.out) == ib + sa);
-        CHECK(ib[0] == 1);
-        CHECK(ib[1] == 1);
-        CHECK(ib[2] == 1);
-        CHECK(ib[3] == 1);
-        CHECK(ib[4] == 1);
-    }
-
-    {
-        int ia[] = {0, 1, 2, 3, 4};
-        constexpr auto sa = ranges::size(ia);
-        int ib[sa] = {1, 2, 3, 4, 5};
-        auto rng0 = ranges::make_subrange(InIter1(ib), Sentinel<int const *>(ib + sa));
-        auto rng1 = ranges::make_subrange(InIter2(ia), Sentinel<int const *>(ia + sa));
-        auto r =
-            ranges::transform(std::move(rng0), std::move(rng1), OutIter(ib), std::minus<int>());
-        CHECK(base(r.in1) == ib + sa);
-        CHECK(base(r.in2) == ia + sa);
-        CHECK(base(r.out) == ib + sa);
-        CHECK(ib[0] == 1);
-        CHECK(ib[1] == 1);
-        CHECK(ib[2] == 1);
-        CHECK(ib[3] == 1);
-        CHECK(ib[4] == 1);
-    }
-}
-
-struct S
-{
-    int i;
-};
-
-int main()
-{
-    test1<InputIterator<const int*>, OutputIterator<int*> >();
-    test1<InputIterator<const int*>, InputIterator<int*> >();
-    test1<InputIterator<const int*>, ForwardIterator<int*> >();
-    test1<InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test1<InputIterator<const int*>, RandomAccessIterator<int*> >();
-    test1<InputIterator<const int*>, int*>();
-
-    test1<ForwardIterator<const int*>, OutputIterator<int*> >();
-    test1<ForwardIterator<const int*>, InputIterator<int*> >();
-    test1<ForwardIterator<const int*>, ForwardIterator<int*> >();
-    test1<ForwardIterator<const int*>, BidirectionalIterator<int*> >();
-    test1<ForwardIterator<const int*>, RandomAccessIterator<int*> >();
-    test1<ForwardIterator<const int*>, int*>();
-
-    test1<BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test1<BidirectionalIterator<const int*>, InputIterator<int*> >();
-    test1<BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test1<BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test1<BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test1<BidirectionalIterator<const int*>, int*>();
-
-    test1<RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test1<RandomAccessIterator<const int*>, InputIterator<int*> >();
-    test1<RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test1<RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test1<RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test1<RandomAccessIterator<const int*>, int*>();
-
-    test1<const int*, OutputIterator<int*> >();
-    test1<const int*, InputIterator<int*> >();
-    test1<const int*, ForwardIterator<int*> >();
-    test1<const int*, BidirectionalIterator<int*> >();
-    test1<const int*, RandomAccessIterator<int*> >();
-    test1<const int*, int*>();
-
-
-    test2<InputIterator<const int*>, InputIterator<const int*>, OutputIterator<int*> >();
-    test2<InputIterator<const int*>, InputIterator<const int*>, InputIterator<int*> >();
-    test2<InputIterator<const int*>, InputIterator<const int*>, ForwardIterator<int*> >();
-    test2<InputIterator<const int*>, InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test2<InputIterator<const int*>, InputIterator<const int*>, RandomAccessIterator<int*> >();
-    test2<InputIterator<const int*>, InputIterator<const int*>, int*>();
-
-    test2<InputIterator<const int*>, ForwardIterator<const int*>, OutputIterator<int*> >();
-    test2<InputIterator<const int*>, ForwardIterator<const int*>, InputIterator<int*> >();
-    test2<InputIterator<const int*>, ForwardIterator<const int*>, ForwardIterator<int*> >();
-    test2<InputIterator<const int*>, ForwardIterator<const int*>, BidirectionalIterator<int*> >();
-    test2<InputIterator<const int*>, ForwardIterator<const int*>, RandomAccessIterator<int*> >();
-    test2<InputIterator<const int*>, ForwardIterator<const int*>, int*>();
-
-    test2<InputIterator<const int*>, BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test2<InputIterator<const int*>, BidirectionalIterator<const int*>, InputIterator<int*> >();
-    test2<InputIterator<const int*>, BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test2<InputIterator<const int*>, BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test2<InputIterator<const int*>, BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test2<InputIterator<const int*>, BidirectionalIterator<const int*>, int*>();
-
-    test2<InputIterator<const int*>, RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test2<InputIterator<const int*>, RandomAccessIterator<const int*>, InputIterator<int*> >();
-    test2<InputIterator<const int*>, RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test2<InputIterator<const int*>, RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test2<InputIterator<const int*>, RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test2<InputIterator<const int*>, RandomAccessIterator<const int*>, int*>();
-
-    test2<InputIterator<const int*>, const int*, OutputIterator<int*> >();
-    test2<InputIterator<const int*>, const int*, InputIterator<int*> >();
-    test2<InputIterator<const int*>, const int*, ForwardIterator<int*> >();
-    test2<InputIterator<const int*>, const int*, BidirectionalIterator<int*> >();
-    test2<InputIterator<const int*>, const int*, RandomAccessIterator<int*> >();
-    test2<InputIterator<const int*>, const int*, int*>();
-
-    test2<ForwardIterator<const int*>, InputIterator<const int*>, OutputIterator<int*> >();
-    test2<ForwardIterator<const int*>, InputIterator<const int*>, InputIterator<int*> >();
-    test2<ForwardIterator<const int*>, InputIterator<const int*>, ForwardIterator<int*> >();
-    test2<ForwardIterator<const int*>, InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test2<ForwardIterator<const int*>, InputIterator<const int*>, RandomAccessIterator<int*> >();
-    test2<ForwardIterator<const int*>, InputIterator<const int*>, int*>();
-
-    test2<ForwardIterator<const int*>, ForwardIterator<const int*>, OutputIterator<int*> >();
-    test2<ForwardIterator<const int*>, ForwardIterator<const int*>, InputIterator<int*> >();
-    test2<ForwardIterator<const int*>, ForwardIterator<const int*>, ForwardIterator<int*> >();
-    test2<ForwardIterator<const int*>, ForwardIterator<const int*>, BidirectionalIterator<int*> >();
-    test2<ForwardIterator<const int*>, ForwardIterator<const int*>, RandomAccessIterator<int*> >();
-    test2<ForwardIterator<const int*>, ForwardIterator<const int*>, int*>();
-
-    test2<ForwardIterator<const int*>, BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test2<ForwardIterator<const int*>, BidirectionalIterator<const int*>, InputIterator<int*> >();
-    test2<ForwardIterator<const int*>, BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test2<ForwardIterator<const int*>, BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test2<ForwardIterator<const int*>, BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test2<ForwardIterator<const int*>, BidirectionalIterator<const int*>, int*>();
-
-    test2<ForwardIterator<const int*>, RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test2<ForwardIterator<const int*>, RandomAccessIterator<const int*>, InputIterator<int*> >();
-    test2<ForwardIterator<const int*>, RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test2<ForwardIterator<const int*>, RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test2<ForwardIterator<const int*>, RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test2<ForwardIterator<const int*>, RandomAccessIterator<const int*>, int*>();
-
-    test2<ForwardIterator<const int*>, const int*, OutputIterator<int*> >();
-    test2<ForwardIterator<const int*>, const int*, InputIterator<int*> >();
-    test2<ForwardIterator<const int*>, const int*, ForwardIterator<int*> >();
-    test2<ForwardIterator<const int*>, const int*, BidirectionalIterator<int*> >();
-    test2<ForwardIterator<const int*>, const int*, RandomAccessIterator<int*> >();
-    test2<ForwardIterator<const int*>, const int*, int*>();
-
-    test2<BidirectionalIterator<const int*>, InputIterator<const int*>, OutputIterator<int*> >();
-    test2<BidirectionalIterator<const int*>, InputIterator<const int*>, InputIterator<int*> >();
-    test2<BidirectionalIterator<const int*>, InputIterator<const int*>, ForwardIterator<int*> >();
-    test2<BidirectionalIterator<const int*>, InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test2<BidirectionalIterator<const int*>, InputIterator<const int*>, RandomAccessIterator<int*> >();
-    test2<BidirectionalIterator<const int*>, InputIterator<const int*>, int*>();
-
-    test2<BidirectionalIterator<const int*>, ForwardIterator<const int*>, OutputIterator<int*> >();
-    test2<BidirectionalIterator<const int*>, ForwardIterator<const int*>, InputIterator<int*> >();
-    test2<BidirectionalIterator<const int*>, ForwardIterator<const int*>, ForwardIterator<int*> >();
-    test2<BidirectionalIterator<const int*>, ForwardIterator<const int*>, BidirectionalIterator<int*> >();
-    test2<BidirectionalIterator<const int*>, ForwardIterator<const int*>, RandomAccessIterator<int*> >();
-    test2<BidirectionalIterator<const int*>, ForwardIterator<const int*>, int*>();
-
-    test2<BidirectionalIterator<const int*>, BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test2<BidirectionalIterator<const int*>, BidirectionalIterator<const int*>, InputIterator<int*> >();
-    test2<BidirectionalIterator<const int*>, BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test2<BidirectionalIterator<const int*>, BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test2<BidirectionalIterator<const int*>, BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test2<BidirectionalIterator<const int*>, BidirectionalIterator<const int*>, int*>();
-
-    test2<BidirectionalIterator<const int*>, RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test2<BidirectionalIterator<const int*>, RandomAccessIterator<const int*>, InputIterator<int*> >();
-    test2<BidirectionalIterator<const int*>, RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test2<BidirectionalIterator<const int*>, RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test2<BidirectionalIterator<const int*>, RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test2<BidirectionalIterator<const int*>, RandomAccessIterator<const int*>, int*>();
-
-    test2<BidirectionalIterator<const int*>, const int*, OutputIterator<int*> >();
-    test2<BidirectionalIterator<const int*>, const int*, InputIterator<int*> >();
-    test2<BidirectionalIterator<const int*>, const int*, ForwardIterator<int*> >();
-    test2<BidirectionalIterator<const int*>, const int*, BidirectionalIterator<int*> >();
-    test2<BidirectionalIterator<const int*>, const int*, RandomAccessIterator<int*> >();
-    test2<BidirectionalIterator<const int*>, const int*, int*>();
-
-    test2<RandomAccessIterator<const int*>, InputIterator<const int*>, OutputIterator<int*> >();
-    test2<RandomAccessIterator<const int*>, InputIterator<const int*>, InputIterator<int*> >();
-    test2<RandomAccessIterator<const int*>, InputIterator<const int*>, ForwardIterator<int*> >();
-    test2<RandomAccessIterator<const int*>, InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test2<RandomAccessIterator<const int*>, InputIterator<const int*>, RandomAccessIterator<int*> >();
-    test2<RandomAccessIterator<const int*>, InputIterator<const int*>, int*>();
-
-    test2<RandomAccessIterator<const int*>, ForwardIterator<const int*>, OutputIterator<int*> >();
-    test2<RandomAccessIterator<const int*>, ForwardIterator<const int*>, InputIterator<int*> >();
-    test2<RandomAccessIterator<const int*>, ForwardIterator<const int*>, ForwardIterator<int*> >();
-    test2<RandomAccessIterator<const int*>, ForwardIterator<const int*>, BidirectionalIterator<int*> >();
-    test2<RandomAccessIterator<const int*>, ForwardIterator<const int*>, RandomAccessIterator<int*> >();
-    test2<RandomAccessIterator<const int*>, ForwardIterator<const int*>, int*>();
-
-    test2<RandomAccessIterator<const int*>, BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test2<RandomAccessIterator<const int*>, BidirectionalIterator<const int*>, InputIterator<int*> >();
-    test2<RandomAccessIterator<const int*>, BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test2<RandomAccessIterator<const int*>, BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test2<RandomAccessIterator<const int*>, BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test2<RandomAccessIterator<const int*>, BidirectionalIterator<const int*>, int*>();
-
-    test2<RandomAccessIterator<const int*>, RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test2<RandomAccessIterator<const int*>, RandomAccessIterator<const int*>, InputIterator<int*> >();
-    test2<RandomAccessIterator<const int*>, RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test2<RandomAccessIterator<const int*>, RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test2<RandomAccessIterator<const int*>, RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test2<RandomAccessIterator<const int*>, RandomAccessIterator<const int*>, int*>();
-
-    test2<RandomAccessIterator<const int*>, const int*, OutputIterator<int*> >();
-    test2<RandomAccessIterator<const int*>, const int*, InputIterator<int*> >();
-    test2<RandomAccessIterator<const int*>, const int*, ForwardIterator<int*> >();
-    test2<RandomAccessIterator<const int*>, const int*, BidirectionalIterator<int*> >();
-    test2<RandomAccessIterator<const int*>, const int*, RandomAccessIterator<int*> >();
-    test2<RandomAccessIterator<const int*>, const int*, int*>();
-
-    test2<const int*, InputIterator<const int*>, OutputIterator<int*> >();
-    test2<const int*, InputIterator<const int*>, InputIterator<int*> >();
-    test2<const int*, InputIterator<const int*>, ForwardIterator<int*> >();
-    test2<const int*, InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test2<const int*, InputIterator<const int*>, RandomAccessIterator<int*> >();
-    test2<const int*, InputIterator<const int*>, int*>();
-
-    test2<const int*, ForwardIterator<const int*>, OutputIterator<int*> >();
-    test2<const int*, ForwardIterator<const int*>, InputIterator<int*> >();
-    test2<const int*, ForwardIterator<const int*>, ForwardIterator<int*> >();
-    test2<const int*, ForwardIterator<const int*>, BidirectionalIterator<int*> >();
-    test2<const int*, ForwardIterator<const int*>, RandomAccessIterator<int*> >();
-    test2<const int*, ForwardIterator<const int*>, int*>();
-
-    test2<const int*, BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test2<const int*, BidirectionalIterator<const int*>, InputIterator<int*> >();
-    test2<const int*, BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test2<const int*, BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test2<const int*, BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test2<const int*, BidirectionalIterator<const int*>, int*>();
-
-    test2<const int*, RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test2<const int*, RandomAccessIterator<const int*>, InputIterator<int*> >();
-    test2<const int*, RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test2<const int*, RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test2<const int*, RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test2<const int*, RandomAccessIterator<const int*>, int*>();
-
-    test2<const int*, const int*, OutputIterator<int*> >();
-    test2<const int*, const int*, InputIterator<int*> >();
-    test2<const int*, const int*, ForwardIterator<int*> >();
-    test2<const int*, const int*, BidirectionalIterator<int*> >();
-    test2<const int*, const int*, RandomAccessIterator<int*> >();
-    test2<const int*, const int*, int*>();
-
-    int *p = nullptr;
-    auto unary = [](int i){return i + 1; };
-    auto binary = [](int i, int j){return i + j; };
-    S const s[] = {S{1}, S{2}, S{3}, S{4}};
-    int const i[] = {1, 2, 3, 4};
-    static_assert(std::is_same<ranges::unary_transform_result<S const*, int*>,
-        decltype(ranges::transform(s, p, unary, &S::i))>::value, "");
-    static_assert(std::is_same<ranges::binary_transform_result<S const*, int const *, int*>,
-        decltype(ranges::transform(s, i, p, binary, &S::i))>::value, "");
-    static_assert(std::is_same<ranges::binary_transform_result<S const*, S const *, int*>,
-        decltype(ranges::transform(s, s, p, binary, &S::i, &S::i))>::value, "");
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/unique.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/unique.cpp
deleted file mode 100644
index 077e4904..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/unique.cpp
+++ /dev/null
@@ -1,180 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-// Implementation based on the code in libc++
-//   http://http://libcxx.llvm.org/
-
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/unique.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-/// Calls the iterator interface of the algorithm
-template<class Iter>
-struct iter_call
-{
-    using begin_t = Iter;
-    using sentinel_t = typename sentinel_type<Iter>::type;
-
-    template<class B, class E, class... Args>
-    auto operator()(B &&It, E &&e, Args &&... args) const
-     -> decltype(ranges::unique(begin_t{It}, sentinel_t{e}, std::forward<Args>(args)...))
-    {
-        return ranges::unique(begin_t{It}, sentinel_t{e}, std::forward<Args>(args)...);
-    }
-};
-
-/// Calls the range interface of the algorithm
-template<class Iter>
-struct range_call
-{
-    using begin_t = Iter;
-    using sentinel_t = typename sentinel_type<Iter>::type;
-
-    template<class B, class E, class... Args>
-    auto operator()(B &&It, E &&e, Args &&... args) const
-     -> ranges::iterator_t<decltype(ranges::make_subrange(begin_t{It}, sentinel_t{e}))>
-    {
-        auto rng = ranges::make_subrange(begin_t{It}, sentinel_t{e});
-        return ranges::unique(rng, std::forward<Args>(args)...);
-    }
-};
-
-template<class T> using identity_t = T;
-
-template<class It, template<class> class FunT>
-void test()
-{
-    using Fun = FunT<It>;
-
-    {
-        int a[] = {0};
-        const unsigned sa = sizeof(a) / sizeof(a[0]);
-        auto r = Fun{}(a, a + sa);
-        CHECK(r == It(a + sa));
-        CHECK(a[0] == 0);
-    }
-    {
-        int a[] = {0, 1};
-        const unsigned sa = sizeof(a) / sizeof(a[0]);
-        auto r = Fun{}(a, a + sa);
-        CHECK(r == It(a + sa));
-        CHECK(a[0] == 0);
-        CHECK(a[1] == 1);
-    }
-    {
-        int a[] = {0, 0};
-        const unsigned sa = sizeof(a) / sizeof(a[0]);
-        auto r = Fun{}(a, a + sa);
-        CHECK(r == It(a + 1));
-        CHECK(a[0] == 0);
-    }
-    {
-        int a[] = {0, 0, 1};
-        const unsigned sa = sizeof(a) / sizeof(a[0]);
-        auto r = Fun{}(a, a + sa);
-        CHECK(r == It(a + 2));
-        CHECK(a[0] == 0);
-        CHECK(a[1] == 1);
-    }
-    {
-        int a[] = {0, 0, 1, 0};
-        const unsigned sa = sizeof(a) / sizeof(a[0]);
-        auto r = Fun{}(a, a + sa);
-        CHECK(r == It(a + 3));
-        CHECK(a[0] == 0);
-        CHECK(a[1] == 1);
-        CHECK(a[2] == 0);
-    }
-    {
-        int a[] = {0, 0, 1, 1};
-        const unsigned sa = sizeof(a) / sizeof(a[0]);
-        auto r = Fun{}(a, a + sa);
-        CHECK(r == It(a + 2));
-        CHECK(a[0] == 0);
-        CHECK(a[1] == 1);
-    }
-    {
-        int a[] = {0, 1, 1};
-        const unsigned sa = sizeof(a) / sizeof(a[0]);
-        auto r = Fun{}(a, a + sa);
-        CHECK(r == It(a + 2));
-        CHECK(a[0] == 0);
-        CHECK(a[1] == 1);
-    }
-    {
-        int a[] = {0, 1, 1, 1, 2, 2, 2};
-        const unsigned sa = sizeof(a) / sizeof(a[0]);
-        auto r = Fun{}(a, a + sa);
-        CHECK(r == It(a + 3));
-        CHECK(a[0] == 0);
-        CHECK(a[1] == 1);
-        CHECK(a[2] == 2);
-    }
-}
-
-int main()
-{
-    test<ForwardIterator<int*>, iter_call>();
-    test<BidirectionalIterator<int*>, iter_call>();
-    test<RandomAccessIterator<int*>, iter_call>();
-    test<int*, iter_call>();
-
-    test<ForwardIterator<int*>, range_call>();
-    test<BidirectionalIterator<int*>, range_call>();
-    test<RandomAccessIterator<int*>, range_call>();
-    test<int*, range_call>();
-
-    // Test rvalue range
-    {
-        int a[] = {0, 1, 1, 1, 2, 2, 2};
-        auto r = ranges::unique(ranges::views::all(a));
-        CHECK(r == a + 3);
-        CHECK(a[0] == 0);
-        CHECK(a[1] == 1);
-        CHECK(a[2] == 2);
-    }
-    {
-        int a[] = {0, 1, 1, 1, 2, 2, 2};
-        auto r = ranges::unique(std::move(a));
-#ifndef RANGES_WORKAROUND_MSVC_573728
-        CHECK(::is_dangling(r));
-#endif // RANGES_WORKAROUND_MSVC_573728
-        CHECK(a[0] == 0);
-        CHECK(a[1] == 1);
-        CHECK(a[2] == 2);
-    }
-    {
-        std::vector<int> a{0, 1, 1, 1, 2, 2, 2};
-        auto r = ranges::unique(std::move(a));
-        CHECK(::is_dangling(r));
-        CHECK(a[0] == 0);
-        CHECK(a[1] == 1);
-        CHECK(a[2] == 2);
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/unique_copy.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/unique_copy.cpp
deleted file mode 100644
index 6a530ae1..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/unique_copy.cpp
+++ /dev/null
@@ -1,325 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-// Implementation based on the code in libc++
-//   http://http://libcxx.llvm.org/
-
-#include <cstring>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/unique_copy.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-struct count_equal
-{
-    static unsigned count;
-    template<class T>
-    bool operator()(const T& x, const T& y)
-        {++count; return x == y;}
-};
-
-unsigned count_equal::count = 0;
-
-template<class InIter, class OutIter, typename Sent = InIter>
-void
-test_iter()
-{
-    const int ia[] = {0};
-    const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-    int ja[sa] = {-1};
-    count_equal::count = 0;
-    ranges::unique_copy_result<InIter, OutIter> r = ranges::unique_copy(InIter(ia), Sent(ia+sa), OutIter(ja), count_equal());
-    CHECK(base(r.in) == ia + sa);
-    CHECK(base(r.out) == ja + sa);
-    CHECK(ja[0] == 0);
-    CHECK(count_equal::count == sa-1);
-
-    const int ib[] = {0, 1};
-    const unsigned sb = sizeof(ib)/sizeof(ib[0]);
-    int jb[sb] = {-1};
-    count_equal::count = 0;
-    r = ranges::unique_copy(InIter(ib), Sent(ib+sb), OutIter(jb), count_equal());
-    CHECK(base(r.in) == ib + sb);
-    CHECK(base(r.out) == jb + sb);
-    CHECK(jb[0] == 0);
-    CHECK(jb[1] == 1);
-    CHECK(count_equal::count == sb-1);
-
-    const int ic[] = {0, 0};
-    const unsigned sc = sizeof(ic)/sizeof(ic[0]);
-    int jc[sc] = {-1};
-    count_equal::count = 0;
-    r = ranges::unique_copy(InIter(ic), Sent(ic+sc), OutIter(jc), count_equal());
-    CHECK(base(r.in) == ic + sc);
-    CHECK(base(r.out) == jc + 1);
-    CHECK(jc[0] == 0);
-    CHECK(count_equal::count == sc-1);
-
-    const int id[] = {0, 0, 1};
-    const unsigned sd = sizeof(id)/sizeof(id[0]);
-    int jd[sd] = {-1};
-    count_equal::count = 0;
-    r = ranges::unique_copy(InIter(id), Sent(id+sd), OutIter(jd), count_equal());
-    CHECK(base(r.in) == id + sd);
-    CHECK(base(r.out) == jd + 2);
-    CHECK(jd[0] == 0);
-    CHECK(jd[1] == 1);
-    CHECK(count_equal::count == sd-1);
-
-    const int ie[] = {0, 0, 1, 0};
-    const unsigned se = sizeof(ie)/sizeof(ie[0]);
-    int je[se] = {-1};
-    count_equal::count = 0;
-    r = ranges::unique_copy(InIter(ie), Sent(ie+se), OutIter(je), count_equal());
-    CHECK(base(r.in) == ie + se);
-    CHECK(base(r.out) == je + 3);
-    CHECK(je[0] == 0);
-    CHECK(je[1] == 1);
-    CHECK(je[2] == 0);
-    CHECK(count_equal::count == se-1);
-
-    const int ig[] = {0, 0, 1, 1};
-    const unsigned sg = sizeof(ig)/sizeof(ig[0]);
-    int jg[sg] = {-1};
-    count_equal::count = 0;
-    r = ranges::unique_copy(InIter(ig), Sent(ig+sg), OutIter(jg), count_equal());
-    CHECK(base(r.in) == ig + sg);
-    CHECK(base(r.out) == jg + 2);
-    CHECK(jg[0] == 0);
-    CHECK(jg[1] == 1);
-    CHECK(count_equal::count == sg-1);
-
-    const int ih[] = {0, 1, 1};
-    const unsigned sh = sizeof(ih)/sizeof(ih[0]);
-    int jh[sh] = {-1};
-    count_equal::count = 0;
-    r = ranges::unique_copy(InIter(ih), Sent(ih+sh), OutIter(jh), count_equal());
-    CHECK(base(r.in) == ih + sh);
-    CHECK(base(r.out) == jh + 2);
-    CHECK(jh[0] == 0);
-    CHECK(jh[1] == 1);
-    CHECK(count_equal::count == sh-1);
-
-    const int ii[] = {0, 1, 1, 1, 2, 2, 2};
-    const unsigned si = sizeof(ii)/sizeof(ii[0]);
-    int ji[si] = {-1};
-    count_equal::count = 0;
-    r = ranges::unique_copy(InIter(ii), Sent(ii+si), OutIter(ji), count_equal());
-    CHECK(base(r.in) == ii + si);
-    CHECK(base(r.out) == ji + 3);
-    CHECK(ji[0] == 0);
-    CHECK(ji[1] == 1);
-    CHECK(ji[2] == 2);
-    CHECK(count_equal::count == si-1);
-}
-
-template<class InIter, class OutIter, typename Sent = InIter>
-void
-test_range()
-{
-    const int ia[] = {0};
-    const unsigned sa = sizeof(ia)/sizeof(ia[0]);
-    int ja[sa] = {-1};
-    count_equal::count = 0;
-    ranges::unique_copy_result<InIter, OutIter> r = ranges::unique_copy(::as_lvalue(ranges::make_subrange(InIter(ia), Sent(ia+sa))), OutIter(ja), count_equal());
-    CHECK(base(r.in) == ia + sa);
-    CHECK(base(r.out) == ja + sa);
-    CHECK(ja[0] == 0);
-    CHECK(count_equal::count == sa-1);
-
-    const int ib[] = {0, 1};
-    const unsigned sb = sizeof(ib)/sizeof(ib[0]);
-    int jb[sb] = {-1};
-    count_equal::count = 0;
-    r = ranges::unique_copy(::as_lvalue(ranges::make_subrange(InIter(ib), Sent(ib+sb))), OutIter(jb), count_equal());
-    CHECK(base(r.in) == ib + sb);
-    CHECK(base(r.out) == jb + sb);
-    CHECK(jb[0] == 0);
-    CHECK(jb[1] == 1);
-    CHECK(count_equal::count == sb-1);
-
-    const int ic[] = {0, 0};
-    const unsigned sc = sizeof(ic)/sizeof(ic[0]);
-    int jc[sc] = {-1};
-    count_equal::count = 0;
-    r = ranges::unique_copy(::as_lvalue(ranges::make_subrange(InIter(ic), Sent(ic+sc))), OutIter(jc), count_equal());
-    CHECK(base(r.in) == ic + sc);
-    CHECK(base(r.out) == jc + 1);
-    CHECK(jc[0] == 0);
-    CHECK(count_equal::count == sc-1);
-
-    const int id[] = {0, 0, 1};
-    const unsigned sd = sizeof(id)/sizeof(id[0]);
-    int jd[sd] = {-1};
-    count_equal::count = 0;
-    r = ranges::unique_copy(::as_lvalue(ranges::make_subrange(InIter(id), Sent(id+sd))), OutIter(jd), count_equal());
-    CHECK(base(r.in) == id + sd);
-    CHECK(base(r.out) == jd + 2);
-    CHECK(jd[0] == 0);
-    CHECK(jd[1] == 1);
-    CHECK(count_equal::count == sd-1);
-
-    const int ie[] = {0, 0, 1, 0};
-    const unsigned se = sizeof(ie)/sizeof(ie[0]);
-    int je[se] = {-1};
-    count_equal::count = 0;
-    r = ranges::unique_copy(::as_lvalue(ranges::make_subrange(InIter(ie), Sent(ie+se))), OutIter(je), count_equal());
-    CHECK(base(r.in) == ie + se);
-    CHECK(base(r.out) == je + 3);
-    CHECK(je[0] == 0);
-    CHECK(je[1] == 1);
-    CHECK(je[2] == 0);
-    CHECK(count_equal::count == se-1);
-
-    const int ig[] = {0, 0, 1, 1};
-    const unsigned sg = sizeof(ig)/sizeof(ig[0]);
-    int jg[sg] = {-1};
-    count_equal::count = 0;
-    r = ranges::unique_copy(::as_lvalue(ranges::make_subrange(InIter(ig), Sent(ig+sg))), OutIter(jg), count_equal());
-    CHECK(base(r.in) == ig + sg);
-    CHECK(base(r.out) == jg + 2);
-    CHECK(jg[0] == 0);
-    CHECK(jg[1] == 1);
-    CHECK(count_equal::count == sg-1);
-
-    const int ih[] = {0, 1, 1};
-    const unsigned sh = sizeof(ih)/sizeof(ih[0]);
-    int jh[sh] = {-1};
-    count_equal::count = 0;
-    r = ranges::unique_copy(::as_lvalue(ranges::make_subrange(InIter(ih), Sent(ih+sh))), OutIter(jh), count_equal());
-    CHECK(base(r.in) == ih + sh);
-    CHECK(base(r.out) == jh + 2);
-    CHECK(jh[0] == 0);
-    CHECK(jh[1] == 1);
-    CHECK(count_equal::count == sh-1);
-
-    const int ii[] = {0, 1, 1, 1, 2, 2, 2};
-    const unsigned si = sizeof(ii)/sizeof(ii[0]);
-    int ji[si] = {-1};
-    count_equal::count = 0;
-    r = ranges::unique_copy(::as_lvalue(ranges::make_subrange(InIter(ii), Sent(ii+si))), OutIter(ji), count_equal());
-    CHECK(base(r.in) == ii + si);
-    CHECK(base(r.out) == ji + 3);
-    CHECK(ji[0] == 0);
-    CHECK(ji[1] == 1);
-    CHECK(ji[2] == 2);
-    CHECK(count_equal::count == si-1);
-}
-
-template<class InIter, class OutIter>
-void test()
-{
-    using Sent = typename sentinel_type<InIter>::type;
-    test_iter<InIter, OutIter>();
-    test_iter<InIter, OutIter, Sent>();
-
-    test_range<InIter, OutIter>();
-    test_range<InIter, OutIter, Sent>();
-}
-
-struct S
-{
-    int i,j;
-};
-
-bool operator==(S l, S r)
-{
-    return l.i == r.i && l.j == r.j;
-}
-
-int main()
-{
-    test<InputIterator<const int*>, OutputIterator<int*> >();
-    test<InputIterator<const int*>, ForwardIterator<int*> >();
-    test<InputIterator<const int*>, BidirectionalIterator<int*> >();
-    test<InputIterator<const int*>, RandomAccessIterator<int*> >();
-    test<InputIterator<const int*>, int*>();
-
-    test<ForwardIterator<const int*>, OutputIterator<int*> >();
-    test<ForwardIterator<const int*>, ForwardIterator<int*> >();
-    test<ForwardIterator<const int*>, BidirectionalIterator<int*> >();
-    test<ForwardIterator<const int*>, RandomAccessIterator<int*> >();
-    test<ForwardIterator<const int*>, int*>();
-
-    test<BidirectionalIterator<const int*>, OutputIterator<int*> >();
-    test<BidirectionalIterator<const int*>, ForwardIterator<int*> >();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<int*> >();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<int*> >();
-    test<BidirectionalIterator<const int*>, int*>();
-
-    test<RandomAccessIterator<const int*>, OutputIterator<int*> >();
-    test<RandomAccessIterator<const int*>, ForwardIterator<int*> >();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<int*> >();
-    test<RandomAccessIterator<const int*>, int*>();
-
-    test<const int*, OutputIterator<int*> >();
-    test<const int*, ForwardIterator<int*> >();
-    test<const int*, BidirectionalIterator<int*> >();
-    test<const int*, RandomAccessIterator<int*> >();
-    test<const int*, int*>();
-
-    // Test projections:
-    {
-        S const ia[] = {{1,1},{2,2},{3,3},{3,4},{4,5},{5,6},{5,7},{5,8},{6,9},{7,10}};
-        S ib[ranges::size(ia)];
-        ranges::unique_copy_result<S const *, S *> r = ranges::unique_copy(ia, ib, ranges::equal_to(), &S::i);
-        CHECK(r.in == ranges::end(ia));
-        CHECK(r.out == ib + 7);
-        check_equal(ranges::make_subrange(ib, ib+7), {S{1,1},S{2,2},S{3,3},S{4,5},S{5,6},S{6,9},S{7,10}});
-    }
-
-    // Test rvalue ranges:
-    {
-        S const ia[] = {{1,1},{2,2},{3,3},{3,4},{4,5},{5,6},{5,7},{5,8},{6,9},{7,10}};
-        S ib[ranges::size(ia)];
-        auto r = ranges::unique_copy(ranges::views::all(ia), ib, ranges::equal_to(), &S::i);
-        CHECK(r.in == ranges::end(ia));
-        CHECK(r.out == ib + 7);
-        check_equal(ranges::make_subrange(ib, ib+7), {S{1,1},S{2,2},S{3,3},S{4,5},S{5,6},S{6,9},S{7,10}});
-    }
-#ifndef RANGES_WORKAROUND_MSVC_573728
-    {
-        S const ia[] = {{1,1},{2,2},{3,3},{3,4},{4,5},{5,6},{5,7},{5,8},{6,9},{7,10}};
-        S ib[ranges::size(ia)];
-        auto r = ranges::unique_copy(std::move(ia), ib, ranges::equal_to(), &S::i);
-        CHECK(::is_dangling(r.in));
-        CHECK(r.out == ib + 7);
-        check_equal(ranges::make_subrange(ib, ib+7), {S{1,1},S{2,2},S{3,3},S{4,5},S{5,6},S{6,9},S{7,10}});
-    }
-#endif // RANGES_WORKAROUND_MSVC_573728
-    {
-        std::vector<S> const ia{{1,1},{2,2},{3,3},{3,4},{4,5},{5,6},{5,7},{5,8},{6,9},{7,10}};
-        S ib[10];
-        RANGES_ENSURE(ranges::size(ia) == ranges::size(ib));
-        auto r = ranges::unique_copy(std::move(ia), ib, ranges::equal_to(), &S::i);
-        CHECK(::is_dangling(r.in));
-        CHECK(r.out == ib + 7);
-        check_equal(ranges::make_subrange(ib, ib+7), {S{1,1},S{2,2},S{3,3},S{4,5},S{5,6},S{6,9},S{7,10}});
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/algorithm/upper_bound.cpp b/src/contrib/range-v3-0.11.0/test/algorithm/upper_bound.cpp
deleted file mode 100644
index f0c46e83..00000000
--- a/src/contrib/range-v3-0.11.0/test/algorithm/upper_bound.cpp
+++ /dev/null
@@ -1,100 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-//  Copyright 2005 - 2007 Adobe Systems Incorporated
-//  Distributed under the MIT License(see accompanying file LICENSE_1_0_0.txt
-//  or a copy at http://stlab.adobe.com/licenses.html)
-
-#include <utility>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/upper_bound.hpp>
-#include "../simple_test.hpp"
-#include "../test_iterators.hpp"
-
-struct my_int
-{
-    int value;
-};
-
-bool compare(my_int lhs, my_int rhs)
-{
-    return lhs.value < rhs.value;
-}
-
-void not_totally_ordered()
-{
-    // This better compile!
-    std::vector<my_int> vec;
-    ranges::upper_bound(vec, my_int{10}, compare);
-}
-
-int main()
-{
-    using ranges::begin;
-    using ranges::end;
-    using ranges::size;
-    using ranges::less;
-
-    using P = std::pair<int, int>;
-
-    P a[] = {{0, 0}, {0, 1}, {1, 2}, {1, 3}, {3, 4}, {3, 5}};
-    P const c[] = {{0, 0}, {0, 1}, {1, 2}, {1, 3}, {3, 4}, {3, 5}};
-
-    CHECK(ranges::aux::upper_bound_n(begin(a), size(a), a[0]) == &a[1]);
-    CHECK(ranges::aux::upper_bound_n(begin(a), size(a), a[1], less()) == &a[2]);
-    CHECK(ranges::aux::upper_bound_n(begin(a), size(a), 1, less(), &std::pair<int, int>::first) == &a[4]);
-
-    CHECK(ranges::upper_bound(begin(a), end(a), a[0]) == &a[1]);
-    CHECK(ranges::upper_bound(begin(a), end(a), a[1], less()) == &a[2]);
-    CHECK(ranges::upper_bound(begin(a), end(a), 1, less(), &std::pair<int, int>::first) == &a[4]);
-
-    CHECK(ranges::upper_bound(a, a[2]) == &a[3]);
-    CHECK(ranges::upper_bound(c, c[3]) == &c[4]);
-
-    CHECK(ranges::upper_bound(a, a[4], less()) == &a[5]);
-    CHECK(ranges::upper_bound(c, c[5], less()) == &c[6]);
-
-    CHECK(ranges::upper_bound(a, 1, less(), &std::pair<int, int>::first) == &a[4]);
-    CHECK(ranges::upper_bound(c, 1, less(), &std::pair<int, int>::first) == &c[4]);
-
-    std::vector<P> vec_a(ranges::begin(a), ranges::end(a));
-    std::vector<P> const vec_c(ranges::begin(c), ranges::end(c));
-
-    CHECK(ranges::upper_bound(ranges::views::all(a), a[2]) == &a[3]);
-    CHECK(ranges::upper_bound(ranges::views::all(c), c[3]) == &c[4]);
-#ifndef RANGES_WORKAROUND_MSVC_573728
-    CHECK(::is_dangling(ranges::upper_bound(std::move(a), a[2])));
-    CHECK(::is_dangling(ranges::upper_bound(std::move(c), c[3])));
-#endif // RANGES_WORKAROUND_MSVC_573728
-    CHECK(::is_dangling(ranges::upper_bound(std::move(vec_a), vec_a[2])));
-    CHECK(::is_dangling(ranges::upper_bound(std::move(vec_c), vec_c[3])));
-
-    CHECK(ranges::upper_bound(ranges::views::all(a), a[4], less()) == &a[5]);
-    CHECK(ranges::upper_bound(ranges::views::all(c), c[5], less()) == &c[6]);
-#ifndef RANGES_WORKAROUND_MSVC_573728
-    CHECK(::is_dangling(ranges::upper_bound(std::move(a), a[4], less())));
-    CHECK(::is_dangling(ranges::upper_bound(std::move(c), c[5], less())));
-#endif // RANGES_WORKAROUND_MSVC_573728
-    CHECK(::is_dangling(ranges::upper_bound(std::move(vec_a), vec_a[4], less())));
-    CHECK(::is_dangling(ranges::upper_bound(std::move(vec_c), vec_c[5], less())));
-
-    CHECK(ranges::upper_bound(ranges::views::all(a), 1, less(), &std::pair<int, int>::first) == &a[4]);
-    CHECK(ranges::upper_bound(ranges::views::all(c), 1, less(), &std::pair<int, int>::first) == &c[4]);
-#ifndef RANGES_WORKAROUND_MSVC_573728
-    CHECK(::is_dangling(ranges::upper_bound(std::move(a), 1, less(), &std::pair<int, int>::first)));
-    CHECK(::is_dangling(ranges::upper_bound(std::move(c), 1, less(), &std::pair<int, int>::first)));
-#endif // RANGES_WORKAROUND_MSVC_573728
-    CHECK(::is_dangling(ranges::upper_bound(std::move(vec_a), 1, less(), &std::pair<int, int>::first)));
-    CHECK(::is_dangling(ranges::upper_bound(std::move(vec_c), 1, less(), &std::pair<int, int>::first)));
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/array.hpp b/src/contrib/range-v3-0.11.0/test/array.hpp
deleted file mode 100644
index 3a7bd4c4..00000000
--- a/src/contrib/range-v3-0.11.0/test/array.hpp
+++ /dev/null
@@ -1,301 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-// The implementation of array has been adapted from libc++
-// (http://libcxx.llvm.org).
-//
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef RANGES_V3_TEST_ARRAY_HPP
-#define RANGES_V3_TEST_ARRAY_HPP
-
-#include <stdexcept>
-#include <range/v3/range_fwd.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/algorithm/fill_n.hpp>
-#include <range/v3/algorithm/swap_ranges.hpp>
-#include <range/v3/algorithm/equal.hpp>
-#include <range/v3/algorithm/lexicographical_compare.hpp>
-#include <range/v3/utility/swap.hpp>
-
-namespace test {
-
-    /// \addtogroup group-utility
-    /// A std::array with constexpr support
-    template<typename T, std::size_t N>
-    struct array
-    {
-        using self = array;
-        using value_type = T;
-        using reference = value_type&;
-        using const_reference = value_type const&;
-        using iterator = value_type*;
-        using const_iterator = value_type const*;
-        using pointer = value_type*;
-        using const_pointer = value_type const*;
-        using size_type = std::size_t;
-        using difference_type = std::ptrdiff_t;
-        using reverse_iterator = ranges::reverse_iterator<iterator>;
-        using const_reverse_iterator = ranges::reverse_iterator<const_iterator>;
-
-        value_type elems_[N > 0 ? N : 1];
-
-        constexpr /*c++14*/ void fill(const value_type& u)
-        {
-            ranges::fill_n(elems_, N, u);
-        }
-        constexpr /*c++14*/
-        void swap(array& a) noexcept(ranges::is_nothrow_swappable<T>::value)
-        {
-            ranges::swap_ranges(elems_, elems_ + N, a.elems_);
-        }
-         // iterators:
-        constexpr /*c++14*/
-        iterator begin() noexcept
-        {
-            return iterator(elems_);
-        }
-        constexpr /*c++14*/
-        const_iterator begin() const noexcept
-        {
-            return const_iterator(elems_);
-        }
-        constexpr /*c++14*/
-        iterator end() noexcept
-        {
-            return iterator(elems_ + N);
-        }
-        constexpr /*c++14*/
-        const_iterator end() const noexcept
-        {
-            return const_iterator(elems_ + N);
-        }
-        constexpr /*c++14*/
-        reverse_iterator rbegin() noexcept
-        {
-            return reverse_iterator(end());
-        }
-        constexpr /*c++14*/
-        const_reverse_iterator rbegin() const noexcept
-        {
-            return const_reverse_iterator(end());
-        }
-        constexpr /*c++14*/
-        reverse_iterator rend() noexcept
-        {
-            return reverse_iterator(begin());
-        }
-        constexpr /*c++14*/
-        const_reverse_iterator rend() const noexcept
-        {
-            return const_reverse_iterator(begin());
-        }
-        constexpr /*c++14*/
-        const_iterator cbegin() const noexcept
-        {
-            return begin();
-        }
-        constexpr /*c++14*/
-        const_iterator cend() const noexcept
-        {
-            return end();
-        }
-        constexpr /*c++14*/
-        const_reverse_iterator crbegin() const noexcept
-        {
-            return rbegin();
-        }
-        constexpr /*c++14*/
-        const_reverse_iterator crend() const noexcept
-        {
-            return rend();
-        }
-        // capacity:
-        constexpr /*c++14*/
-        size_type size() const noexcept
-        {
-            return N;
-        }
-        constexpr /*c++14*/
-        size_type max_size() const noexcept
-        {
-            return N;
-        }
-        constexpr /*c++14*/
-        bool empty() const noexcept
-        {
-            return N == 0;
-        }
-         // element access:
-        constexpr /*c++14*/ reference operator[](size_type n)
-        {
-            return elems_[n];
-        }
-        constexpr /*c++14*/ const_reference operator[](size_type n) const
-        {
-            return elems_[n];
-        }
-        constexpr /*c++14*/ reference at(size_type n)
-        {
-            if (n >= N)
-                throw std::out_of_range("array::at");
-            return elems_[n];
-        }
-        constexpr /*c++14*/ const_reference at(size_type n) const
-        {
-            if (n >= N)
-                throw std::out_of_range("array::at");
-            return elems_[n];
-        }
-        constexpr /*c++14*/ reference front()
-        {
-            return elems_[0];
-        }
-        constexpr /*c++14*/ const_reference front() const
-        {
-            return elems_[0];
-        }
-        constexpr /*c++14*/ reference back()
-        {
-            return elems_[N > 0 ? N-1 : 0];
-        }
-        constexpr /*c++14*/ const_reference back() const
-        {
-            return elems_[N > 0 ? N-1 : 0];
-        }
-        constexpr /*c++14*/
-        value_type* data() noexcept
-        {
-            return elems_;
-        }
-        constexpr /*c++14*/
-        const value_type* data() const noexcept
-        {
-            return elems_;
-        }
-    };
-
-    template<class T, size_t N>
-    constexpr /*c++14*/
-    bool
-    operator==(const array<T, N>& x, const array<T, N>& y)
-    {
-        return ranges::equal(x.elems_, x.elems_ + N, y.elems_);
-    }
-    template<class T, size_t N>
-    constexpr /*c++14*/
-    bool
-    operator!=(const array<T, N>& x, const array<T, N>& y)
-    {
-        return !(x == y);
-    }
-    template<class T, size_t N>
-    constexpr /*c++14*/
-    bool
-    operator<(const array<T, N>& x, const array<T, N>& y)
-    {
-        return ranges::lexicographical_compare(x.elems_, x.elems_ + N, y.elems_, y.elems_ + N);
-    }
-    template<class T, size_t N>
-    constexpr /*c++14*/
-    bool
-    operator>(const array<T, N>& x, const array<T, N>& y)
-    {
-        return y < x;
-    }
-    template<class T, size_t N>
-    constexpr /*c++14*/
-    bool
-    operator<=(const array<T, N>& x, const array<T, N>& y)
-    {
-        return !(y < x);
-    }
-
-    template<class T, size_t N>
-    constexpr /*c++14*/
-    bool
-    operator>=(const array<T, N>& x, const array<T, N>& y)
-    {
-         return !(x < y);
-    }
-
-    template<class T, size_t N>
-    constexpr /*c++14*/
-    auto swap(array<T, N>& x, array<T, N>& y)
-    noexcept(ranges::is_nothrow_swappable<T>::value)
-    -> typename std::enable_if<ranges::is_swappable<T>::value, void>::type
-    {
-        x.swap(y);
-    }
-
-    template<size_t I, class T, size_t N>
-    constexpr /*c++14*/
-    T& get(array<T, N>& a) noexcept
-    {
-        static_assert(I < N, "Index out of bounds in ranges::get<> (ranges::array)");
-        return a.elems_[I];
-    }
-
-    template<size_t I, class T, size_t N>
-    constexpr /*c++14*/
-    const T& get(const array<T, N>& a) noexcept
-    {
-        static_assert(I < N, "Index out of bounds in ranges::get<> (const ranges::array)");
-        return a.elems_[I];
-    }
-
-    template<size_t I, class T, size_t N>
-    constexpr /*c++14*/
-    T && get(array<T, N>&& a) noexcept
-    {
-        static_assert(I < N, "Index out of bounds in ranges::get<> (ranges::array &&)");
-        return std::move(a.elems_[I]);
-    }
-
-    template<class T, std::size_t N>
-    constexpr /*c++14*/ void swap(array<T, N>& a, array<T, N>& b) {
-        for(std::size_t i = 0; i != N; ++i) {
-            auto tmp = std::move(a[i]);
-            a[i] = std::move(b[i]);
-            b[i] = std::move(tmp);
-        }
-    }
-}  // namespace test
-
-RANGES_DIAGNOSTIC_PUSH
-RANGES_DIAGNOSTIC_IGNORE_MISMATCHED_TAGS
-
-namespace std
-{
-
-template<class T, size_t N>
-class tuple_size<test::array<T, N>>
-    : public integral_constant<size_t, N> {};
-
-template<size_t I, class T, size_t N>
-class tuple_element<I, test::array<T, N> >
-{
- public:
-    using type = T;
-};
-
-}  // namespace std
-
-RANGES_DIAGNOSTIC_POP
-
-#endif // RANGES_V3_TEST_ARRAY_HPP
diff --git a/src/contrib/range-v3-0.11.0/test/bug1322.cpp b/src/contrib/range-v3-0.11.0/test/bug1322.cpp
deleted file mode 100644
index ff3f0b74..00000000
--- a/src/contrib/range-v3-0.11.0/test/bug1322.cpp
+++ /dev/null
@@ -1,19 +0,0 @@
-#include <concepts/concepts.hpp>
-
-struct S
-{};
-
-template <typename T>
-void foobar(T &&) {}
-
-#if CPP_CXX_CONCEPTS
-template <typename T>
-    requires concepts::totally_ordered<T>
-void foobar(T &&) {}
-#endif
-
-int main()
-{
-    std::pair<S, int> p;
-    foobar(p);
-}
diff --git a/src/contrib/range-v3-0.11.0/test/bug1335.cpp b/src/contrib/range-v3-0.11.0/test/bug1335.cpp
deleted file mode 100644
index 5af7c0ed..00000000
--- a/src/contrib/range-v3-0.11.0/test/bug1335.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-#include <vector>
-#include <range/v3/action/sort.hpp>
-
-template<typename A, typename B>
-constexpr auto operator-(A a, B)
-{
-    return a;
-}
-
-int main()
-{
-    std::vector<int> data;
-    data |= ranges::actions::sort;
-}
diff --git a/src/contrib/range-v3-0.11.0/test/bug474.cpp b/src/contrib/range-v3-0.11.0/test/bug474.cpp
deleted file mode 100644
index cca730b0..00000000
--- a/src/contrib/range-v3-0.11.0/test/bug474.cpp
+++ /dev/null
@@ -1,32 +0,0 @@
-// Range v3 library
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <vector>
-#include <range/v3/view/any_view.hpp>
-#include <range/v3/algorithm/for_each.hpp>
-
-struct Foo {
-    Foo() = default;
-    Foo(Foo const&) = default;
-    virtual ~Foo() = default;
-    virtual void foo() = 0;
-};
-
-struct Bar : public Foo {
-    virtual void foo() override {}
-};
-
-int main()
-{
-    std::vector<Bar> bars { Bar() };
-    ranges::any_view<Foo &> foos = bars;
-    ranges::for_each(foos, [] (Foo & foo) {
-        foo.foo();
-    });
-}
diff --git a/src/contrib/range-v3-0.11.0/test/bug566.cpp b/src/contrib/range-v3-0.11.0/test/bug566.cpp
deleted file mode 100644
index 3bb6fb2b..00000000
--- a/src/contrib/range-v3-0.11.0/test/bug566.cpp
+++ /dev/null
@@ -1,36 +0,0 @@
-// Range v3 library
-//
-//  Copyright Filip Matner 2017
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <vector>
-#include <memory>
-#include <range/v3/view/for_each.hpp>
-#include <range/v3/view/move.hpp>
-#include "./simple_test.hpp"
-#include "./test_utils.hpp"
-
-using namespace ranges;
-
-int main()
-{
-    std::vector<std::unique_ptr<int>> d;
-    d.emplace_back(std::unique_ptr<int>(new int(1)));
-    d.emplace_back(std::unique_ptr<int>(new int(5)));
-    d.emplace_back(std::unique_ptr<int>(new int(4)));
-
-    auto rng = d | views::move | views::for_each([](std::unique_ptr<int> ptr)
-    {
-        return yield(*ptr);
-    });
-
-    check_equal(rng, {1, 5, 4});
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/config.cpp b/src/contrib/range-v3-0.11.0/test/config.cpp
deleted file mode 100644
index 72770f9c..00000000
--- a/src/contrib/range-v3-0.11.0/test/config.cpp
+++ /dev/null
@@ -1,19 +0,0 @@
-// Range v3 library
-//
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <range/v3/detail/config.hpp>
-
-RANGES_DEPRECATED("compile test for \"RANGES_DEPRECATED\"") void foo() {}
-
-int main()
-{
-    return 0;
-}
diff --git a/src/contrib/range-v3-0.11.0/test/constexpr_core.cpp b/src/contrib/range-v3-0.11.0/test/constexpr_core.cpp
deleted file mode 100644
index 9db5b076..00000000
--- a/src/contrib/range-v3-0.11.0/test/constexpr_core.cpp
+++ /dev/null
@@ -1,300 +0,0 @@
-// Range v3 library
-//
-//  Copyright Gonzalo Brito Gadeschi 2015
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <range/v3/detail/config.hpp>
-
-#if RANGES_CXX_CONSTEXPR >= RANGES_CXX_CONSTEXPR_14
-
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/operations.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/utility/addressof.hpp>
-
-#include "array.hpp"
-#include "test_iterators.hpp"
-
-// Test sequence 1,2,3,4
-template<typename It>
-constexpr /*c++14*/ auto test_it_back(It, It last,
-    std::bidirectional_iterator_tag) -> bool
-{
-    auto end_m1_2 = It{ranges::prev(last, 1)};
-    if (*end_m1_2 != 4) { return false; }
-    return true;
-}
-
-template<typename It, typename Concept>
-constexpr /*c++14*/ auto test_it_back(It, It, Concept) -> bool
-{
-    return true;
-}
-
-template<typename It>
-constexpr /*c++14*/ auto test_it_(It beg, It last) -> bool
-{
-    if (*beg != 1) { return false; }
-    if (ranges::distance(beg, last) != 4) { return false; }
-    if (ranges::next(beg, 4) != last) { return false; }
-    auto end_m1 = It{ranges::next(beg, 3)};
-    if (*end_m1 != 4) { return false; }
-
-    if (!test_it_back(beg, last, ranges::iterator_tag_of<It>{})) { return false; }
-    auto end2 = beg;
-    ranges::advance(end2, last);
-    if (end2 != last) { return false; }
-    auto end3 = beg;
-    ranges::advance(end3, 4);
-    if (end3 != last) { return false; }
-    if (ranges::iter_enumerate(beg, last) != std::pair<std::ptrdiff_t, It>{4, last})
-    {
-        return false;
-    }
-    if (ranges::iter_distance(beg, last) != 4) { return false; }
-    if (ranges::iter_distance_compare(beg, last, 4) != 0) { return false; }
-    if (ranges::iter_distance_compare(beg, last, 3) != 1) { return false; }
-    if (ranges::iter_distance_compare(beg, last, 5) != -1) { return false; }
-    return true;
-}
-
-// Test sequence 4,3,2,1 (for reverse iterators)
-template<typename It>
-constexpr /*c++14*/ auto test_rit_(It beg, It last) -> bool
-{
-    if (ranges::distance(beg, last) != 4) { return false; }
-    if (ranges::next(beg, 4) != last) { return false; }
-    auto end_m1 = It{ranges::next(beg, 3)};
-    if (*end_m1 != 1) { return false; }
-    if (ranges::detail::is_convertible<ranges::iterator_tag_of<It>,
-                                       std::bidirectional_iterator_tag>{})
-    {
-        auto end_m1_2 = It{ranges::prev(last, 1)};
-        if (*end_m1_2 != 1) { return false; }
-    }
-    auto end2 = beg;
-    ranges::advance(end2, last);
-    if (end2 != last) { return false; }
-    auto end3 = beg;
-    ranges::advance(end3, 4);
-    if (end3 != last) { return false; }
-    using D = ranges::iter_difference_t<It>;
-    if (ranges::iter_enumerate(beg, last) != std::pair<D, It>{4, last})
-    {
-        return false;
-    }
-    if (ranges::iter_distance(beg, last) != 4) { return false; }
-    if (ranges::iter_distance_compare(beg, last, 4) != 0) { return false; }
-    if (ranges::iter_distance_compare(beg, last, 3) != 1) { return false; }
-    if (ranges::iter_distance_compare(beg, last, 5) != -1) { return false; }
-    return true;
-}
-
-template<typename It, typename Sequence1234>
-constexpr /*c++14*/ auto test_it(Sequence1234&& a) -> bool
-{
-    auto beg = It{ranges::begin(a)};
-    auto last = It{ranges::end(a)};
-    return test_it_(beg, last);
-}
-
-template<typename Sequence1234>
-constexpr /*c++14*/ auto test_its_c(Sequence1234&& a) -> bool
-{
-    return     test_it<InputIterator<int const *>>(a)
-            && test_it<ForwardIterator<int const *>>(a)
-            && test_it<BidirectionalIterator<int const *>>(a)
-            && test_it<RandomAccessIterator<int const *>>(a);
-
-}
-
-template<typename Sequence1234>
-constexpr /*c++14*/ auto test_its(Sequence1234&& a) -> bool
-{
-    return     test_it<InputIterator<int *>>(a)
-            && test_it<ForwardIterator<int *>>(a)
-            && test_it<BidirectionalIterator<int *>>(a)
-            && test_it<RandomAccessIterator<int *>>(a)
-            && test_its_c(a);
-
-}
-
-template<typename It, typename Sequence1234>
-constexpr /*c++14*/ auto test_rit(Sequence1234&& a) -> bool
-{
-    auto beg = It{ranges::rbegin(a)};
-    auto last = It{ranges::rend(a)};
-    return test_rit_(beg, last);
-}
-
-template<typename Sequence1234>
-constexpr /*c++14*/ auto test_rits(Sequence1234&& a) -> bool
-{
-    using rit = decltype(ranges::rbegin(a));
-    return     test_rit<BidirectionalIterator<rit>>(a)
-            && test_rit<BidirectionalIterator<rit>>(a);
-}
-
-template<typename It, typename Sequence1234>
-constexpr /*c++14*/ auto test_cit(Sequence1234&& a) -> bool
-{
-    auto beg = It{ranges::cbegin(a)};
-    auto last = It{ranges::cend(a)};
-    return test_it_(beg, last);
-}
-
-template<typename Sequence1234>
-constexpr /*c++14*/ auto test_cits(Sequence1234&& a) -> bool
-{
-    return     test_cit<InputIterator<int const *>>(a)
-            && test_cit<ForwardIterator<int const *>>(a)
-            && test_cit<BidirectionalIterator<int const *>>(a)
-            && test_cit<RandomAccessIterator<int const *>>(a);
-}
-
-
-template<typename It, typename Sequence1234>
-constexpr /*c++14*/ auto test_crit(Sequence1234&& a) -> bool
-{
-    auto beg = It{ranges::crbegin(a)};
-    auto last = It{ranges::crend(a)};
-    return test_rit_(beg, last);
-}
-
-template<typename Sequence1234>
-constexpr /*c++14*/ auto test_crits(Sequence1234&& a) -> bool
-{
-    using rit = decltype(ranges::crbegin(a));
-    return     test_crit<BidirectionalIterator<rit>>(a)
-            && test_crit<RandomAccessIterator<rit>>(a);
-}
-
-template<typename Sequence1234>
-constexpr /*c++14*/ auto test_non_member_f(Sequence1234&& a) -> bool
-{
-    if (ranges::empty(a)) { return false; }
-    if (ranges::front(a) != 1) { return false; }
-    if (ranges::back(a) != 4) { return false; }
-    if (ranges::index(a, 2) != 3) { return false; }
-    if (ranges::at(a, 2) != 3) { return false; }
-    if (ranges::size(a) != 4) { return false; }
-    return true;
-}
-
-constexpr /*c++14*/ auto test_array() -> bool
-{
-    test::array<int, 4> a{{1, 2, 3, 4}};
-
-    auto beg = ranges::begin(a);
-    auto three = ranges::next(beg, 2);
-
-    if ((false)) {
-      ranges::iter_swap(beg, three);
-      if (*beg != 3) { return false; }
-      if (*three != 1) { return false; }
-      ranges::iter_swap(beg, three);
-    }
-
-    if (!test_its(a)) { return false; }
-    if (!test_cits(a)) { return false; }
-    if (!test_rits(a)) { return false; }
-    if (!test_crits(a)) { return false; }
-    if (!test_non_member_f(a)) { return false; }
-
-    // This can be worked around but is just bad:
-    test::array<int, 4> b{{5, 6, 7, 8}};
-    ranges::swap(a, b);
-    if (a[0] != 5 || b[0] != 1 || a[3] != 8 || b[3] != 4) { return false; }
-
-    return true;
-}
-
-constexpr /*c++14*/ auto test_c_array() -> bool
-{
-    int a[4]{1, 2, 3, 4};
-    if (!test_its(a)) { return false; }
-    if (!test_cits(a)) { return false; }
-    if (!test_rits(a)) { return false; }
-    if (!test_crits(a)) { return false; }
-    if (!test_non_member_f(a)) { return false; }
-
-    // C-arrays have no associated namespace, so this can't work:
-    // int b[4]{5, 6, 7, 8};
-    // ranges::swap(a, b);
-    // if (a[0] != 5 || b[0] != 1 || a[3] != 8 || b[3] != 4) { return false; }
-
-    return true;
-}
-
-constexpr /*c++14*/ auto test_init_list() -> bool
-{
-    std::initializer_list<int> a{1, 2, 3, 4};
-    if (!test_its_c(a)) { return false; }
-    if (!test_cits(a)) { return false; }
-    if (!test_rits(a)) { return false; }
-    if (!test_crits(a)) { return false; }
-    if (!test_non_member_f(a)) { return false; }
-
-    std::initializer_list<int> b{5, 6, 7, 8};
-    ranges::swap(a, b);
-    if (ranges::at(a, 0) != 5 || ranges::at(b, 0) != 1
-        || ranges::at(a, 3) != 8 || ranges::at(b, 3) != 4)
-    {
-        return false;
-    }
-
-    return true;
-}
-
-#ifdef __cpp_lib_addressof_constexpr
-#define ADDR_CONSTEXPR constexpr
-#else
-#define ADDR_CONSTEXPR
-#endif
-
-namespace addr {
-    struct Good { };
-    struct Bad { void operator&() const; };
-    struct Bad2 { friend void operator&(Bad2); };
-}
-
-void test_constexpr_addressof() {
-    static constexpr int i = 0;
-    static constexpr int const* pi = ranges::detail::addressof(i);
-    static_assert(&i == pi, "");
-
-    static constexpr addr::Good g = {};
-    static constexpr addr::Good const* pg = ranges::detail::addressof(g);
-    static_assert(&g == pg, "");
-
-    static constexpr addr::Bad b = {};
-    static ADDR_CONSTEXPR addr::Bad const* pb = ranges::detail::addressof(b);
-
-    static constexpr addr::Bad2 b2 = {};
-    static ADDR_CONSTEXPR addr::Bad2 const* pb2 = ranges::detail::addressof(b2);
-
-#ifdef __cpp_lib_addressof_constexpr
-    static_assert(std::addressof(b) == pb, "");
-    static_assert(std::addressof(b2) == pb2, "");
-#else
-    (void)pb;
-    (void)pb2;
-#endif
-}
-
-int main()
-{
-    static_assert(test_array(), "");
-    static_assert(test_c_array(), "");
-    static_assert(test_init_list(), "");
-}
-
-#else
-int main() {}
-#endif
diff --git a/src/contrib/range-v3-0.11.0/test/debug_view.hpp b/src/contrib/range-v3-0.11.0/test/debug_view.hpp
deleted file mode 100644
index 940098e7..00000000
--- a/src/contrib/range-v3-0.11.0/test/debug_view.hpp
+++ /dev/null
@@ -1,182 +0,0 @@
-// Range v3 library
-//
-//  Copyright Casey Carter 2017
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#ifndef RANGES_TEST_DEBUG_VIEW_HPP
-#define RANGES_TEST_DEBUG_VIEW_HPP
-
-#include <cstddef>
-#include <atomic>
-#include <memory>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/utility/swap.hpp>
-
-template<typename T, bool Sized = true>
-struct debug_input_view : ranges::view_base
-{
-    static_assert(std::is_object<T>::value, "");
-
-    using index_t = std::ptrdiff_t;
-    using version_t = long;
-
-    struct data
-    {
-        T *const first_;
-        index_t const n_;
-        std::atomic<index_t> offset_ {-1};
-
-        data(T *p, index_t n)
-          : first_(p), n_(n)
-        {
-            RANGES_ENSURE(n >= 0);
-            RANGES_ENSURE(p || !n);
-        }
-    };
-    std::shared_ptr<data> data_{};
-    version_t version_ = 0;
-
-    debug_input_view() = default;
-    debug_input_view(T* p, index_t size)
-      : data_(std::make_shared<data>(p, size))
-    {}
-    template<index_t N>
-    debug_input_view(T (&data)[N])
-      : debug_input_view{data, N}
-    {}
-    debug_input_view(debug_input_view const &that) = default;
-    debug_input_view &operator=(debug_input_view const &that)
-    {
-        data_ = that.data_;
-        ++version_; // invalidate outstanding iterators
-        return *this;
-    }
-
-    struct sentinel
-    {
-        debug_input_view *view_ = nullptr;
-        version_t version_ = 0;
-
-        sentinel() = default;
-        explicit constexpr sentinel(debug_input_view &view) noexcept
-          : view_{&view}, version_{view.version_}
-        {}
-    };
-    struct iterator
-    {
-        using iterator_category = std::input_iterator_tag;
-        using value_type = meta::_t<std::remove_cv<T>>;
-        using difference_type = index_t;
-        using reference = T &;
-        using pointer = T *;
-
-        debug_input_view *view_ = nullptr;
-        version_t version_ = 0;
-        index_t offset_ = -1;
-
-        iterator() = default;
-        explicit constexpr iterator(debug_input_view &view) noexcept
-          : view_{&view}, version_{view.version_}
-          , offset_{view.data_ ? view.data_->offset_.load() : -1}
-        {}
-
-        void check_current() const noexcept
-        {
-            RANGES_ENSURE(view_);
-            RANGES_ENSURE(view_->version_ == version_);
-            RANGES_ENSURE(view_->data_);
-            RANGES_ENSURE(view_->data_->offset_ == offset_);
-        }
-
-        void check_dereferenceable() const noexcept
-        {
-            check_current();
-            RANGES_ENSURE(view_->data_->offset_ < view_->data_->n_);
-        }
-
-        reference operator*() const noexcept
-        {
-            check_dereferenceable();
-            return view_->data_->first_[offset_];
-        }
-        iterator &operator++() noexcept
-        {
-            check_dereferenceable();
-            RANGES_ENSURE(view_->data_->offset_.compare_exchange_strong(offset_, offset_ + 1));
-            ++offset_;
-            return *this;
-        }
-        void operator++(int) noexcept
-        {
-            ++*this;
-        }
-
-        friend bool operator==(iterator const &i, sentinel const &s)
-        {
-            RANGES_ENSURE(i.view_ == s.view_);
-            RANGES_ENSURE(i.version_ == s.version_);
-            i.check_current();
-            return i.offset_ == i.view_->data_->n_;
-        }
-        friend bool operator==(sentinel const &s, iterator const &i)
-        {
-            return i == s;
-        }
-        friend bool operator!=(iterator const &i, sentinel const &s)
-        {
-            return !(i == s);
-        }
-        friend bool operator!=(sentinel const &s, iterator const &i)
-        {
-            return !(i == s);
-        }
-        CPP_member
-        friend auto operator-(sentinel const& s, iterator const& i) ->
-            CPP_ret(difference_type)(
-                /// \pre
-                requires Sized)
-        {
-            RANGES_ENSURE(i.view_ == s.view_);
-            RANGES_ENSURE(i.version_ == s.version_);
-            i.check_current();
-            return i.view_->data_->n_ - i.offset_;
-        }
-        CPP_member
-        friend auto operator-(iterator const& i, sentinel const& s) ->
-            CPP_ret(difference_type)(
-                /// \pre
-                requires Sized)
-        {
-            return -(s - i);
-        }
-    };
-    iterator begin() noexcept
-    {
-        RANGES_ENSURE(data_);
-        index_t tmp = -1;
-        RANGES_ENSURE(data_->offset_.compare_exchange_strong(tmp, 0));
-        return iterator{*this};
-    }
-    sentinel end() noexcept
-    {
-        RANGES_ENSURE(data_);
-        return sentinel{*this};
-    }
-    CPP_member
-    auto size() const noexcept -> CPP_ret(std::size_t)(
-        /// \pre
-        requires Sized)
-    {
-        RANGES_ENSURE(data_);
-        RANGES_ENSURE(data_->offset_ == -1);
-        return static_cast<std::size_t>(data_->n_);
-    }
-};
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/test/experimental/CMakeLists.txt b/src/contrib/range-v3-0.11.0/test/experimental/CMakeLists.txt
deleted file mode 100644
index de2d7f24..00000000
--- a/src/contrib/range-v3-0.11.0/test/experimental/CMakeLists.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-set(CMAKE_FOLDER "${CMAKE_FOLDER}/experimental")
-
-add_subdirectory(utility)
-add_subdirectory(view)
diff --git a/src/contrib/range-v3-0.11.0/test/experimental/utility/CMakeLists.txt b/src/contrib/range-v3-0.11.0/test/experimental/utility/CMakeLists.txt
deleted file mode 100644
index f466442b..00000000
--- a/src/contrib/range-v3-0.11.0/test/experimental/utility/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set(CMAKE_FOLDER "${CMAKE_FOLDER}/utility")
-
-if (RANGE_V3_COROUTINE_FLAGS)
-  rv3_add_test(test.generator generator generator.cpp)
-endif()
diff --git a/src/contrib/range-v3-0.11.0/test/experimental/utility/generator.cpp b/src/contrib/range-v3-0.11.0/test/experimental/utility/generator.cpp
deleted file mode 100644
index 084b5ce1..00000000
--- a/src/contrib/range-v3-0.11.0/test/experimental/utility/generator.cpp
+++ /dev/null
@@ -1,292 +0,0 @@
-// Range v3 library
-//
-//  Copyright Casey Carter 2017
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#include <range/v3/detail/config.hpp>
-#include <iostream>
-#include <vector>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range_for.hpp>
-#include <range/v3/algorithm/copy.hpp>
-#include <range/v3/algorithm/count.hpp>
-#include <range/v3/algorithm/equal.hpp>
-#include <range/v3/experimental/utility/generator.hpp>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/utility/swap.hpp>
-#include <range/v3/view/filter.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/move.hpp>
-#include <range/v3/view/take_exactly.hpp>
-#include <range/v3/view/transform.hpp>
-#include "../../simple_test.hpp"
-#include "../../test_utils.hpp"
-
-#ifdef __clang__
-#pragma GCC diagnostic ignored "-Wunused-const-variable"
-#endif
-
-#if RANGES_CXX_COROUTINES < RANGES_CXX_COROUTINES_TS1
-#error This test uses coroutines.
-#endif
-
-template<bool Condition>
-using maybe_sized_generator = meta::if_c<Condition,
-    meta::quote<ranges::experimental::sized_generator>,
-    meta::quote<ranges::experimental::generator>>;
-
-template<typename T>
-constexpr bool is_copy_constructible_or_ref() noexcept
-{
-    return std::is_reference<T>::value ||(bool) ranges::copy_constructible<T>;
-}
-
-struct coro_fn
-{
-private:
-    template<typename V>
-    using generator_for = meta::invoke<
-        maybe_sized_generator<(bool) ranges::sized_range<V>>,
-        ranges::range_reference_t<V>,
-        ranges::range_value_t<V>>;
-
-    CPP_template(typename V)(
-        requires ranges::input_range<V> && ranges::view_<V> &&
-            (is_copy_constructible_or_ref<ranges::range_reference_t<V>>()))
-    static generator_for<V> impl(V v)
-    {
-        if(RANGES_CONSTEXPR_IF(ranges::sized_range<V>))
-            co_await static_cast<ranges::experimental::generator_size>((std::size_t)ranges::distance(v));
-        auto first = ranges::begin(v);
-        auto const last = ranges::end(v);
-        for (; first != last; ++first)
-            co_yield *first;
-    }
-public:
-    CPP_template(typename Rng)(
-        requires (
-            !meta::is<ranges::uncvref_t<Rng>, ranges::experimental::generator>::value &&
-            !meta::is<ranges::uncvref_t<Rng>, ranges::experimental::sized_generator>::value &&
-            ranges::input_range<Rng> &&
-            is_copy_constructible_or_ref<ranges::range_reference_t<Rng>>()))
-    generator_for<ranges::views::all_t<Rng>> operator()(Rng &&rng) const
-    {
-        return impl(ranges::views::all(static_cast<Rng &&>(rng)));
-    }
-    template<typename R, typename V>
-    ranges::experimental::generator<R, V>
-    operator()(ranges::experimental::generator<R, V> g) const noexcept
-    {
-        return g;
-    }
-    template<typename R, typename V>
-    ranges::experimental::sized_generator<R, V>
-    operator()(ranges::experimental::sized_generator<R, V> g) const noexcept
-    {
-        return g;
-    }
-};
-
-inline namespace function_objects
-{
-    RANGES_INLINE_VARIABLE(coro_fn, coro)
-}
-
-auto f(int const n)
-{
-    return ::coro(ranges::views::iota(0, n));
-}
-
-ranges::experimental::sized_generator<int> g(int const n)
-{
-    co_await static_cast<ranges::experimental::generator_size>((std::size_t) (n > 0 ? n : 0));
-    for (int i = 0; i < n; ++i)
-        co_yield i;
-}
-
-ranges::experimental::sized_generator<int &> h(int const n)
-{
-    co_await static_cast<ranges::experimental::generator_size>((std::size_t) (n > 0 ? n : 0));
-    for (int i = 0; i < n; ++i)
-        co_yield i;
-}
-
-CPP_template(class T)(
-    requires ranges::weakly_incrementable<T>)
-ranges::experimental::generator<T> iota_generator(T t)
-{
-    for (;; ++t)
-        co_yield t;
-}
-
-CPP_template(class T, class S)(
-    requires (ranges::weakly_incrementable<T> &&
-        ranges::detail::weakly_equality_comparable_with_<T, S> &&
-        !ranges::sized_sentinel_for<S, T> && !(ranges::integral<T> && ranges::integral<S>)))
-ranges::experimental::generator<T> iota_generator(T t, S const s)
-{
-    for (; t != s; ++t)
-        co_yield t;
-}
-
-CPP_template(class T, class S)(
-    requires ranges::sized_sentinel_for<S, T> || (ranges::integral<T> && ranges::integral<S>))
-ranges::experimental::sized_generator<T> iota_generator(T t, S const s)
-{
-    co_await static_cast<ranges::experimental::generator_size>((std::size_t) (s - t));
-    for (; t != s; ++t)
-        co_yield t;
-}
-
-CPP_template(class V, class F)(
-    requires ranges::input_range<V> && ranges::view_<V> &&
-        ranges::indirect_unary_predicate<F, ranges::iterator_t<V>>)
-ranges::experimental::generator<ranges::range_reference_t<V>, ranges::range_value_t<V>>
-filter(V view, F f)
-{
-    RANGES_FOR(auto &&i, view)
-    {
-        if (ranges::invoke(f, i))
-            co_yield i;
-    }
-}
-
-CPP_template(class V, class F)(
-    requires ranges::input_range<V> && ranges::view_<V> &&
-        ranges::indirectly_unary_invocable<F, ranges::iterator_t<V>>)
-meta::invoke<
-    maybe_sized_generator<(bool) ranges::sized_range<V>>,
-    ranges::indirect_result_t<F &, ranges::iterator_t<V>>>
-transform(V view, F f)
-{
-    if(RANGES_CONSTEXPR_IF(ranges::sized_range<V>))
-        co_await static_cast<ranges::experimental::generator_size>((std::size_t) ranges::distance(view));
-    RANGES_FOR(auto &&i, view)
-        co_yield ranges::invoke(f, i);
-}
-
-struct MoveInt
-{
-    int i_;
-
-    MoveInt(int i = 42) : i_{i}
-    {}
-    MoveInt(MoveInt &&that) noexcept
-      : i_{ranges::exchange(that.i_, 0)}
-    {}
-    MoveInt &operator=(MoveInt &&that) noexcept
-    {
-        i_ = ranges::exchange(that.i_, 0);
-        return *this;
-    }
-
-    friend bool operator==(MoveInt const &x, MoveInt const &y)
-    {
-        return x.i_ == y.i_;
-    }
-    friend bool operator!=(MoveInt const &x, MoveInt const &y)
-    {
-        return !(x == y);
-    }
-
-    friend std::ostream &operator<<(std::ostream &os, MoveInt const &mi)
-    {
-        return os << mi.i_;
-    }
-};
-
-int main()
-{
-    using namespace ranges;
-
-    auto even = [](int i){ return i % 2 == 0; };
-
-#ifndef RANGES_WORKAROUND_MSVC_835948
-    {
-        auto rng = ::iota_generator(0, 10);
-        CPP_assert(sized_range<decltype(rng)>);
-        CHECK(size(rng) == 10u);
-        ::check_equal(rng, {0,1,2,3,4,5,6,7,8,9});
-    }
-    {
-        auto rng = ::coro(::coro(::coro(::iota_generator(0, 10))));
-        ::has_type<decltype(::iota_generator(0, 10)) &>(rng);
-        CPP_assert(sized_range<decltype(rng)>);
-        CHECK(size(rng) == 10u);
-        ::check_equal(rng, {0,1,2,3,4,5,6,7,8,9});
-    }
-    {
-        auto rng = ::coro(views::ints | views::filter(even) | views::take_exactly(10));
-        CPP_assert(sized_range<decltype(rng)>);
-        CHECK(size(rng) == 10u);
-        ::check_equal(rng, {0,2,4,6,8,10,12,14,16,18});
-    }
-    {
-        auto const control = {1, 2, 3};
-        MoveInt a[] = {{1}, {2}, {3}};
-        MoveInt b[3];
-        CHECK(equal(a, control, std::equal_to<int>{}, &MoveInt::i_));
-        CHECK(count(b, 42, &MoveInt::i_) == 3);
-        auto rng = ::coro(views::move(a));
-        CPP_assert(sized_range<decltype(rng)>);
-        CHECK(size(rng) == 3u);
-        copy(rng, b);
-        CHECK(equal(b, control, std::equal_to<int>{}, &MoveInt::i_));
-        CHECK(count(a, 0, &MoveInt::i_) == 3);
-    }
-    {
-        int some_ints[] = {0,1,2};
-        auto rng = ::coro(some_ints);
-        CPP_assert(sized_range<decltype(rng)>);
-        CHECK(size(rng) == 3u);
-        auto i = begin(rng);
-        auto e = end(rng);
-        CHECK(i != e);
-        CHECK(&*i == &some_ints[0]);
-        ++i;
-        CHECK(i != e);
-        CHECK(&*i == &some_ints[1]);
-        ++i;
-        CHECK(i != e);
-        CHECK(&*i == &some_ints[2]);
-        ++i;
-        CHECK(i == e);
-    }
-    {
-        std::vector<bool> vec(3, false);
-        auto rng = ::coro(vec);
-        CPP_assert(sized_range<decltype(rng)>);
-        CHECK(size(rng) == 3u);
-        ::check_equal(rng, {false,false,false});
-    }
-
-    ::check_equal(f(42), g(42));
-    ::check_equal(f(42), h(42));
-
-    {
-        auto rng = h(20) | views::transform([](int &x) { return ++x; });
-        ::check_equal(rng, {1,3,5,7,9,11,13,15,17,19});
-    }
-
-    {
-        auto rng = f(20) | views::filter(even);
-        ::check_equal(rng, {0,2,4,6,8,10,12,14,16,18});
-    }
-#endif // RANGES_WORKAROUND_MSVC_835948
-
-    {
-        auto square = [](int i) { return i * i; };
-
-        int const some_ints[] = {0,1,2,3,4,5,6,7};
-        auto rng = ::transform(::filter(debug_input_view<int const>{some_ints}, even), square);
-        ::check_equal(rng, {0,4,16,36});
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/experimental/view/CMakeLists.txt b/src/contrib/range-v3-0.11.0/test/experimental/view/CMakeLists.txt
deleted file mode 100644
index 115c9750..00000000
--- a/src/contrib/range-v3-0.11.0/test/experimental/view/CMakeLists.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-set(CMAKE_FOLDER "${CMAKE_FOLDER}/view")
-
-rv3_add_test(test.view.shared view.shared shared.cpp)
diff --git a/src/contrib/range-v3-0.11.0/test/experimental/view/shared.cpp b/src/contrib/range-v3-0.11.0/test/experimental/view/shared.cpp
deleted file mode 100644
index a9c6d2aa..00000000
--- a/src/contrib/range-v3-0.11.0/test/experimental/view/shared.cpp
+++ /dev/null
@@ -1,144 +0,0 @@
-// Range v3 library
-//
-//  Copyright Filip Matzner 2017
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <list>
-#include <memory>
-#include <tuple>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/for_each.hpp>
-#include <range/v3/view/cycle.hpp>
-#include <range/v3/view/for_each.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/join.hpp>
-#include <range/v3/view/remove_if.hpp>
-#include <range/v3/view/repeat.hpp>
-#include <range/v3/view/reverse.hpp>
-#include <range/v3/experimental/view/shared.hpp>
-#include <range/v3/view/take.hpp>
-#include "../../simple_test.hpp"
-#include "../../test_utils.hpp"
-
-using namespace ranges;
-
-template<typename T>
-void check_shared_contents()
-{
-    // build two instances sharing the same range
-    experimental::shared_view<T> view1 = experimental::views::shared(T{1, 1, 1, 2, 3, 4, 4});
-    experimental::shared_view<T> view2 = view1;
-
-    // check the length of the views
-    CHECK(view1.size() == 7u);
-    CHECK(view2.size() == 7u);
-
-    // check the stored numbers
-    auto check_values = [](experimental::shared_view<T> & rng) {
-      ::check_equal(views::cycle(rng) | views::take(10), {1, 1, 1, 2, 3, 4, 4, 1, 1, 1});
-      ::check_equal(views::all(rng) | views::take(5), {1, 1, 1, 2, 3});
-      ::check_equal(rng | views::take(5), {1, 1, 1, 2, 3});
-      ::check_equal(rng, {1, 1, 1, 2, 3, 4, 4});
-    };
-    check_values(view1);
-    check_values(view2);
-
-    // check that changes are shared
-    *(++begin(view1)) = 7;
-    CHECK(*(++begin(view2)) == 7);
-    *begin(view2) = 3;
-    CHECK(*begin(view1) == 3);
-}
-
-int main()
-{
-    // check shared random access range
-    check_shared_contents<std::vector<int>>();
-    // check shared bidirectional range
-    check_shared_contents<std::list<int>>();
-
-    {
-        // check the piped construction from an rvalue
-        std::vector<int> base_vec = {1, 2, 2, 8, 2, 7};
-        auto vec_view = std::move(base_vec) | experimental::views::shared;
-        CHECK(vec_view.size() == 6u);
-        ::check_equal(vec_view, {1, 2, 2, 8, 2, 7});
-    }
-
-    {
-        // test bidirectional range
-        auto list_view = std::list<int>{1, 2, 3} | experimental::views::shared;
-
-        CHECK(list_view.size() == 3u);
-        has_type<int &>(*begin(list_view));
-        CPP_assert(sized_range<decltype(list_view)>);
-        CPP_assert(common_range<decltype(list_view)>);
-        CPP_assert(bidirectional_range<decltype(list_view)>);
-        CPP_assert(!random_access_range<decltype(list_view)>);
-
-        // test bidirectional range iterator
-        CHECK(*begin(list_view) == 1);
-        CHECK(*prev(end(list_view)) == 3);
-    }
-
-    {
-        // test random access range
-        auto vec_view = std::vector<int>{1, 2, 3} | experimental::views::shared;
-
-        CHECK(vec_view.size() == 3u);
-        has_type<int &>(*begin(vec_view));
-        CPP_assert(sized_range<decltype(vec_view)>);
-        CPP_assert(common_range<decltype(vec_view)>);
-        CPP_assert(random_access_range<decltype(vec_view)>);
-        CHECK(vec_view[0] == 1);
-        CHECK(vec_view[1] == 2);
-        CHECK(vec_view[2] == 3);
-    }
-
-    {
-        // check temporary value in views::transform
-        auto f = [](unsigned a){ return std::vector<unsigned>(a, a); };
-
-        auto vec_view =
-            views::iota(1u)
-          | views::transform(f)
-          | views::transform(experimental::views::shared)
-          | views::join
-          | views::take(10);
-
-        ::check_equal(vec_view, {1u, 2u, 2u, 3u, 3u, 3u, 4u, 4u, 4u, 4u});
-    }
-
-    {
-        // check temporary value in views::for_each
-        std::vector<int> base_vec{1, 2, 3};
-        auto vec_view =
-            views::repeat(base_vec)
-          | views::for_each([](std::vector<int> tmp) {
-                return yield_from(std::move(tmp) | experimental::views::shared | views::reverse);
-            })
-          | views::take(7);
-        ::check_equal(vec_view, {3, 2, 1, 3, 2, 1, 3});
-    }
-
-    {
-        // check temporary value in views::for_each without the yield_from
-        std::vector<int> base_vec{1, 2, 3};
-        auto vec_view =
-            views::repeat(base_vec)
-          | views::for_each([](std::vector<int> tmp) {
-                return std::move(tmp) | experimental::views::shared | views::reverse;
-            })
-          | views::take(7);
-        ::check_equal(vec_view, {3, 2, 1, 3, 2, 1, 3});
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/functional/CMakeLists.txt b/src/contrib/range-v3-0.11.0/test/functional/CMakeLists.txt
deleted file mode 100644
index 718718c9..00000000
--- a/src/contrib/range-v3-0.11.0/test/functional/CMakeLists.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-set(CMAKE_FOLDER "${CMAKE_FOLDER}/algorithm")
-
-rv3_add_test(test.fun.bind_back fun.bind_back bind_back.cpp)
diff --git a/src/contrib/range-v3-0.11.0/test/functional/bind_back.cpp b/src/contrib/range-v3-0.11.0/test/functional/bind_back.cpp
deleted file mode 100644
index 05d60177..00000000
--- a/src/contrib/range-v3-0.11.0/test/functional/bind_back.cpp
+++ /dev/null
@@ -1,36 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2020
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <range/v3/functional/bind_back.hpp>
-#include <range/v3/functional/concepts.hpp>
-#include "../simple_test.hpp"
-
-using namespace ranges;
-
-int* test(int & i)
-{
-    return &i;
-}
-
-int main()
-{
-    int i = 42;
-    auto fn = bind_back(test, i);
-    int* pi = fn();
-    CHECK(pi != &i);
-    CHECK(*pi == i);
-
-    CPP_assert(!invocable<decltype(fn)>);
-    CPP_assert(invocable<decltype(fn) &>);
-    CPP_assert(!invocable<decltype(fn) const &>);
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/iterator/CMakeLists.txt b/src/contrib/range-v3-0.11.0/test/iterator/CMakeLists.txt
deleted file mode 100644
index a357933a..00000000
--- a/src/contrib/range-v3-0.11.0/test/iterator/CMakeLists.txt
+++ /dev/null
@@ -1,7 +0,0 @@
-set(CMAKE_FOLDER "${CMAKE_FOLDER}/iterator")
-
-rv3_add_test(test.iter.basic_iterator iter.basic_iterator basic_iterator.cpp)
-rv3_add_test(test.iter.diffmax_t iter.diffmax_t diffmax_t.cpp)
-rv3_add_test(test.iter.iterator iter.iterator iterator.cpp)
-rv3_add_test(test.iter.common_iterator iter.common_iterator common_iterator.cpp)
-rv3_add_test(test.iter.reverse_iterator iter.reverse_iterator reverse_iterator.cpp)
diff --git a/src/contrib/range-v3-0.11.0/test/iterator/basic_iterator.cpp b/src/contrib/range-v3-0.11.0/test/iterator/basic_iterator.cpp
deleted file mode 100644
index ca2c04ff..00000000
--- a/src/contrib/range-v3-0.11.0/test/iterator/basic_iterator.cpp
+++ /dev/null
@@ -1,601 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <cstring>
-#include <tuple>
-
-#include <range/v3/iterator/basic_iterator.hpp>
-#include <range/v3/utility/common_tuple.hpp>
-
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-template<typename T>
-using iter_cat_t = typename T::iterator_category;
-template<typename T>
-using has_iter_cat = meta::is_trait<meta::defer<iter_cat_t, T>>;
-
-namespace test_weak_input
-{
-    template<typename I>
-    struct cursor
-    {
-        I it_;
-        struct mixin : ranges::basic_mixin<cursor>
-        {
-            mixin() = default;
-            //using ranges::basic_mixin<cursor>::basic_mixin;
-            explicit mixin(cursor && cur)
-              : ranges::basic_mixin<cursor>(static_cast<cursor &&>(cur))
-            {}
-            explicit mixin(cursor const & cur)
-              : ranges::basic_mixin<cursor>(cur)
-            {}
-            mixin(I i)
-              : mixin(cursor{i})
-            {}
-        };
-        cursor() = default;
-        explicit cursor(I i)
-          : it_(i)
-        {}
-        CPP_template(class J)(
-            /// \pre
-            requires ranges::convertible_to<J, I>)  //
-        cursor(cursor<J> that)
-          : it_(std::move(that.it_))
-        {}
-
-        auto read() const -> decltype(*it_)
-        {
-            return *it_;
-        }
-        void next()
-        {
-            ++it_;
-        }
-    };
-
-    CPP_assert(ranges::detail::input_cursor<cursor<char *>>);
-    CPP_assert(!ranges::detail::sentinel_for_cursor<cursor<char *>, cursor<char *>>);
-
-    template<class I>
-    using iterator = ranges::basic_iterator<cursor<I>>;
-    CPP_assert(ranges::indirectly_readable<iterator<char *>>);
-    CPP_assert(ranges::input_iterator<iterator<char *>>);
-
-    static_assert(!has_iter_cat<iterator<char *>>::value, "");
-    static_assert(!has_iter_cat<std::iterator_traits<iterator<char *>>>::value, "");
-    static_assert(
-        std::is_same<iterator<char *>::iterator_concept, std::input_iterator_tag>::value,
-        "");
-    static_assert(!ranges::equality_comparable<iterator<char *>>, "");
-
-    void test()
-    {
-        using namespace ranges;
-        using I = iterator<char const *>;
-        CPP_assert(std::is_same<std::iterator_traits<I>::pointer, char const *>{});
-
-        static char const sz[] = "hello world";
-        I i{sz};
-        CHECK(*i == 'h');
-        CHECK(&*i == i.operator->());
-        ++i;
-        CHECK(*i == 'e');
-        CHECK(&*i == i.operator->());
-    }
-} // namespace test_weak_input
-
-namespace test_random_access
-{
-    template<typename I>
-    struct cursor
-    {
-        I it_;
-        struct mixin : ranges::basic_mixin<cursor>
-        {
-            mixin() = default;
-            //using ranges::basic_mixin<cursor>::basic_mixin;
-            explicit mixin(cursor && cur)
-              : ranges::basic_mixin<cursor>(static_cast<cursor &&>(cur))
-            {}
-            explicit mixin(cursor const & cur)
-              : ranges::basic_mixin<cursor>(cur)
-            {}
-            mixin(I i)
-              : mixin(cursor{i})
-            {}
-        };
-        cursor() = default;
-        explicit cursor(I i)
-          : it_(i)
-        {}
-        CPP_template(class J)(
-            /// \pre
-            requires ranges::convertible_to<J, I>)  //
-        cursor(cursor<J> that)
-          : it_(std::move(that.it_))
-        {}
-
-        auto read() const -> decltype(*it_)
-        {
-            return *it_;
-        }
-        CPP_template(class J)(
-            /// \pre
-            requires ranges::sentinel_for<J, I>)    //
-        bool equal(cursor<J> const & that) const
-        {
-            return that.it_ == it_;
-        }
-        void next()
-        {
-            ++it_;
-        }
-        void prev()
-        {
-            --it_;
-        }
-        void advance(ranges::iter_difference_t<I> n)
-        {
-            it_ += n;
-        }
-        CPP_template(class J)(
-            /// \pre
-            requires ranges::sized_sentinel_for<J, I>)  //
-        ranges::iter_difference_t<I> distance_to(cursor<J> const & that) const
-        {
-            return that.it_ - it_;
-        }
-    };
-
-    CPP_assert(ranges::detail::random_access_cursor<cursor<char *>>);
-
-    template<class I>
-    using iterator = ranges::basic_iterator<cursor<I>>;
-
-    static_assert(std::is_same<iterator<char *>::iterator_category,
-                               std::random_access_iterator_tag>::value,
-                  "");
-
-    void test()
-    {
-        using namespace ranges;
-
-        iterator<char *> a(nullptr);
-        iterator<char const *> b(nullptr);
-        iterator<char const *> c(a);
-
-        CPP_assert(
-            std::is_same<std::iterator_traits<iterator<char *>>::pointer, char *>{});
-
-        b = a;
-        bool d = a == b;
-        d = (a != b);
-
-        detail::ignore_unused(
-            d,      //
-            a < b,  //
-            a <= b, //
-            a > b,  //
-            a >= b, //
-            (a-b),  //
-            (b-a),  //
-            (a-a),  //
-            (b-b)); //
-    }
-} // namespace test_random_access
-
- namespace test_weak_output
-{
-    template<typename I>
-    struct cursor
-    {
-        struct mixin : ranges::basic_mixin<cursor>
-        {
-            mixin() = default;
-            // using ranges::basic_mixin<cursor>::basic_mixin;
-            explicit mixin(cursor && cur)
-              : ranges::basic_mixin<cursor>(static_cast<cursor &&>(cur))
-            {}
-            explicit mixin(cursor const & cur)
-              : ranges::basic_mixin<cursor>(cur)
-            {}
-            explicit mixin(I i)
-              : mixin(cursor{i})
-            {}
-        };
-
-        cursor() = default;
-        explicit cursor(I i)
-          : it_(i)
-        {}
-
-        void write(ranges::iter_value_t<I> v) const
-        {
-            *it_ = v;
-        }
-        void next()
-        {
-            ++it_;
-        }
-
-    private:
-        I it_;
-    };
-
-    CPP_assert(ranges::detail::output_cursor<cursor<char *>, char>);
-    CPP_assert(!ranges::detail::sentinel_for_cursor<cursor<char *>, cursor<char *>>);
-
-    template<class I>
-    using iterator = ranges::basic_iterator<cursor<I>>;
-
-    CPP_assert(ranges::output_iterator<iterator<char *>, char>);
-    CPP_assert(!ranges::equality_comparable<iterator<char *>>);
-
-    void test()
-    {
-        char buf[10];
-        iterator<char *> i(buf);
-        *i = 'h';
-        ++i;
-        *i = 'e';
-        ++i;
-        *i = 'l';
-        ++i;
-        *i = 'l';
-        ++i;
-        *i = 'o';
-        ++i;
-        *i = '\0';
-        CHECK(0 == std::strcmp(buf, "hello"));
-    }
-} // namespace test_weak_output
-
- namespace test_output
-{
-    template<typename I>
-    struct cursor
-    {
-        I it_;
-        struct mixin : ranges::basic_mixin<cursor>
-        {
-            mixin() = default;
-            //using ranges::basic_mixin<cursor>::basic_mixin;
-            explicit mixin(cursor && cur)
-              : ranges::basic_mixin<cursor>(static_cast<cursor &&>(cur))
-            {}
-            explicit mixin(cursor const & cur)
-              : ranges::basic_mixin<cursor>(cur)
-            {}
-            mixin(I i)
-              : mixin(cursor{i})
-            {}
-        };
-        cursor() = default;
-        explicit cursor(I i)
-          : it_(i)
-        {}
-        CPP_template(class J)(
-            /// \pre
-            requires ranges::convertible_to<J, I>)  //
-        cursor(cursor<J> that)
-          : it_(std::move(that.it_))
-        {}
-
-        using value_type = ranges::iter_value_t<I>;
-        value_type read() const
-        {
-            return *it_;
-        }
-        void write(value_type v) const
-        {
-            *it_ = v;
-        }
-        I arrow() const
-        {
-            return it_;
-        }
-        void next()
-        {
-            ++it_;
-        }
-        bool equal(cursor const & that) const
-        {
-            return it_ == that.it_;
-        }
-    };
-
-    CPP_assert(ranges::detail::output_cursor<cursor<char *>, char>);
-    CPP_assert(ranges::detail::forward_cursor<cursor<char *>>);
-
-    template<class I>
-    using iterator = ranges::basic_iterator<cursor<I>>;
-
-    CPP_assert(ranges::output_iterator<iterator<char *>, char>);
-    CPP_assert(ranges::forward_iterator<iterator<char *>>);
-
-    CPP_assert(std::is_same<std::iterator_traits<iterator<char *>>::pointer, char *>());
-
-    void test()
-    {
-        char buf[10];
-        iterator<char *> i(buf);
-        *i = 'h';
-        CHECK(*i == 'h');
-        CHECK(*i == *i);
-        ++i;
-        *i = 'e';
-        CHECK('e' == *i);
-        ++i;
-        *i = 'l';
-        ++i;
-        *i = 'l';
-        ++i;
-        *i = 'o';
-        ++i;
-        *i = '\0';
-        CHECK(0 == std::strcmp(buf, "hello"));
-        CHECK(i == iterator<char *>{buf + 5});
-        ++i;
-        CHECK(i != iterator<char *>{buf + 5});
-        CHECK(i == iterator<char *>{buf + 6});
-    }
-} // namespace test_output
-
- namespace test_move_only
-{
-    struct MoveOnly
-    {
-        MoveOnly() = default;
-        MoveOnly(MoveOnly &&) = default;
-        MoveOnly(MoveOnly const &) = delete;
-        MoveOnly & operator=(MoveOnly &&) = default;
-        MoveOnly & operator=(MoveOnly const &) = delete;
-    };
-
-    template<typename I>
-    struct zip1_cursor
-    {
-        I it_;
-        struct mixin : ranges::basic_mixin<zip1_cursor>
-        {
-            mixin() = default;
-            // using ranges::basic_mixin<zip1_cursor>::basic_mixin;
-            explicit mixin(zip1_cursor && cur)
-              : ranges::basic_mixin<zip1_cursor>(static_cast<zip1_cursor &&>(cur))
-            {}
-            explicit mixin(zip1_cursor const & cur)
-              : ranges::basic_mixin<zip1_cursor>(cur)
-            {}
-            mixin(I i)
-              : mixin(zip1_cursor{i})
-            {}
-        };
-        zip1_cursor() = default;
-        explicit zip1_cursor(I i)
-          : it_(i)
-        {}
-        CPP_template(class J)(
-            /// \pre
-            requires ranges::convertible_to<J, I>)  //
-        zip1_cursor(zip1_cursor<J> that)
-          : it_(std::move(that.it_))
-        {}
-
-        using value_type = std::tuple<ranges::iter_value_t<I>>;
-        using reference = ranges::common_tuple<ranges::iter_reference_t<I>>;
-        using rvalue_reference = ranges::common_tuple<ranges::iter_rvalue_reference_t<I>>;
-        reference read() const
-        {
-            return reference{*it_};
-        }
-        rvalue_reference move() const
-        {
-            return rvalue_reference{ranges::iter_move(it_)};
-        }
-        void write(reference const & v) const
-        {
-            reference{ *it_} = v;
-        }
-        void write(value_type && v) const
-        {
-            reference{ *it_} = std::move(v);
-        }
-        void next()
-        {
-            ++it_;
-        }
-        bool equal(zip1_cursor const & that) const
-        {
-            return it_ == that.it_;
-        }
-    };
-
-    CPP_assert(
-        ranges::detail::output_cursor<zip1_cursor<MoveOnly *>, std::tuple<MoveOnly>
-        &&>);
-    CPP_assert(ranges::detail::forward_cursor<zip1_cursor<MoveOnly *>>);
-
-    template<class I>
-    using iterator = ranges::basic_iterator<zip1_cursor<I>>;
-
-    CPP_assert(ranges::output_iterator<iterator<MoveOnly *>, std::tuple<MoveOnly> &&>);
-    CPP_assert(ranges::forward_iterator<iterator<MoveOnly *>>);
-
-    void test()
-    {
-        MoveOnly buf[10] = {};
-        iterator<MoveOnly *> i(buf);
-        *i = std::tuple<MoveOnly>{};
-        ranges::common_tuple<MoveOnly &> x = *i;
-        (void)x;
-        std::tuple<MoveOnly> v = ranges::iter_move(i);
-        *i = std::move(v);
-    }
-} // namespace test_move_only
-
- namespace test_forward_sized
-{
-    template<typename I>
-    struct cursor
-    {
-        I it_;
-        struct mixin : ranges::basic_mixin<cursor>
-        {
-            mixin() = default;
-            // using ranges::basic_mixin<cursor>::basic_mixin;
-            explicit mixin(cursor && cur)
-              : ranges::basic_mixin<cursor>(static_cast<cursor &&>(cur))
-            {}
-            explicit mixin(cursor const & cur)
-              : ranges::basic_mixin<cursor>(cur)
-            {}
-            mixin(I i)
-              : mixin(cursor{i})
-            {}
-        };
-        cursor() = default;
-        explicit cursor(I i)
-          : it_(i)
-        {}
-        CPP_template(class J)(
-            /// \pre
-            requires ranges::convertible_to<J, I>)  //
-        cursor(cursor<J> that)
-          : it_(std::move(that.it_))
-        {}
-
-        auto read() const -> decltype(*it_)
-        {
-            return *it_;
-        }
-        CPP_template(class J)(
-            /// \pre
-            requires ranges::sentinel_for<J, I>)    //
-        bool equal(cursor<J> const & that) const
-        {
-            return that.it_ == it_;
-        }
-        void next()
-        {
-            ++it_;
-        }
-        CPP_template(class J)(
-            /// \pre
-            requires ranges::sized_sentinel_for<J, I>)  //
-        ranges::iter_difference_t<I> distance_to(cursor<J> const & that) const
-        {
-            return that.it_ - it_;
-        }
-    };
-
-    CPP_assert(ranges::detail::sized_sentinel_for_cursor<cursor<char *>, cursor<char *>>);
-    CPP_assert(ranges::detail::forward_cursor<cursor<char *>>);
-
-    template<class I>
-    using iterator = ranges::basic_iterator<cursor<I>>;
-
-    static_assert(std::is_same<iterator<char *>::iterator_category,
-                               std::forward_iterator_tag>::value,
-                  "");
-
-    void test()
-    {
-        using namespace ranges;
-
-        iterator<char *> a(nullptr);
-        iterator<char const *> b(nullptr);
-        iterator<char const *> c(a);
-
-        b = a;
-        bool d = a == b;
-        d = (a != b);
-
-        detail::ignore_unused(
-            d,      //
-            a < b,  //
-            a <= b, //
-            a > b,  //
-            a >= b, //
-            (a-b),  //
-            (b-a),  //
-            (a-a),  //
-            (b-b)); //
-    }
-} // namespace test_forward_sized
-
-RANGES_DIAGNOSTIC_IGNORE_UNNEEDED_MEMBER
-
-void test_box()
-{
-    struct A : ranges::box<int>
-    {};
-    CHECK(sizeof(A) == sizeof(int));
-    struct empty
-    {};
-    struct B : ranges::box<empty>
-    {
-        int i;
-    };
-    CHECK(sizeof(B) == sizeof(int));
-    B b1, b2;
-    if(ranges::detail::box_compression<empty>() == ranges::detail::box_compress::coalesce)
-        CHECK((&b1.get() == &b2.get()));
-    struct nontrivial
-    {
-        nontrivial()
-        {}
-    };
-    struct C : ranges::box<nontrivial>
-    {
-        int i;
-    };
-    CHECK(sizeof(C) == sizeof(int));
-    C c1, c2;
-    CHECK((&c1.get() != &c2.get()));
-
-    {
-        // empty but not trivial cursor that defines value_type:
-        struct cursor
-        {
-            using value_type = int;
-            cursor()
-            {}
-            int read() const
-            {
-                return 42;
-            }
-            void next()
-            {}
-        };
-        CPP_assert(ranges::detail::box_compression<cursor>() ==
-                   ranges::detail::box_compress::ebo);
-        CPP_assert(ranges::same_as<int, ranges::basic_iterator<cursor>::value_type>);
-    }
-}
-
-int main()
-{
-    using namespace ranges;
-    std::cout << "\nTesting basic_iterator\n";
-
-    ::test_weak_input::test();
-    ::test_random_access::test();
-    ::test_weak_output::test();
-    ::test_output::test();
-    ::test_move_only::test();
-    ::test_forward_sized::test();
-    ::test_box();
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/iterator/common_iterator.cpp b/src/contrib/range-v3-0.11.0/test/iterator/common_iterator.cpp
deleted file mode 100644
index 7ee828c2..00000000
--- a/src/contrib/range-v3-0.11.0/test/iterator/common_iterator.cpp
+++ /dev/null
@@ -1,155 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2015-present
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#include <algorithm>
-#include <numeric>
-#include <range/v3/iterator/common_iterator.hpp>
-#include <range/v3/iterator/unreachable_sentinel.hpp>
-#include "../simple_test.hpp"
-#include "../test_iterators.hpp"
-
-RANGES_DIAGNOSTIC_IGNORE_UNNEEDED_MEMBER
-
-namespace {
-    struct silly_arrow_cursor {
-        int read() const { return 0; }
-        void next() {}
-        int arrow() const { return 42; }
-    };
-
-    int forty_two = 42;
-    struct lvalue_iterator {
-        using difference_type = int;
-        using value_type = int;
-        int& operator*() const { return forty_two; }
-        lvalue_iterator& operator++() & { return *this; }
-        lvalue_iterator operator++(int) & { return *this; }
-    };
-    struct xvalue_iterator : lvalue_iterator {
-        int&& operator*() const { return std::move(forty_two); }
-        xvalue_iterator& operator++() & { return *this; }
-        xvalue_iterator operator++(int) & { return *this; }
-    };
-
-    struct proxy_cursor {
-        int read() const { return 42; }
-        void next() {}
-    };
-
-    void test_operator_arrow() {
-        // I is a pointer type
-        {
-            int i = 42;
-            auto ci = ranges::common_iterator<int*, ranges::unreachable_sentinel_t>{&i};
-            CPP_assert(ranges::same_as<int*, decltype(ci.operator->())>);
-            CHECK(ci.operator->() == &i);
-        }
-        // the expression i.operator->() is well-formed
-        {
-            using I = ranges::basic_iterator<silly_arrow_cursor>;
-            auto ci = ranges::common_iterator<I, ranges::unreachable_sentinel_t>{};
-            CPP_assert(ranges::same_as<I, decltype(ci.operator->())>);
-            CHECK(ci.operator->().operator->() == 42);
-        }
-        // the expression *i is a glvalue [lvalue case]
-        {
-            auto ci = ranges::common_iterator<lvalue_iterator, ranges::unreachable_sentinel_t>{};
-            CPP_assert(ranges::same_as<int*, decltype(ci.operator->())>);
-            CHECK(ci.operator->() == &forty_two);
-        }
-        // the expression *i is a glvalue [xvalue case]
-        {
-            auto ci = ranges::common_iterator<xvalue_iterator, ranges::unreachable_sentinel_t>{};
-            CPP_assert(ranges::same_as<int*, decltype(ci.operator->())>);
-            CHECK(ci.operator->() == &forty_two);
-        }
-        // Otherwise, returns a proxy object
-        {
-            using I = ranges::basic_iterator<proxy_cursor>;
-            auto ci = ranges::common_iterator<I, ranges::unreachable_sentinel_t>{};
-            using A = decltype(ci.operator->());
-            CPP_assert(std::is_class<A>::value);
-            CPP_assert(!std::is_same<I, A>::value);
-            CHECK(*ci.operator->().operator->() == 42);
-        }
-    }
-}
-
-int main() {
-    {
-        CPP_assert(
-            ranges::forward_iterator<
-                ranges::common_iterator<
-                    BidirectionalIterator<const char *>,
-                    Sentinel<const char *>>>);
-        CPP_assert(
-            !ranges::bidirectional_iterator<
-                ranges::common_iterator<
-                    BidirectionalIterator<const char *>,
-                    Sentinel<const char *>>>);
-        CPP_assert(
-            std::is_same<
-                ranges::common_reference<
-                    ranges::common_iterator<
-                        BidirectionalIterator<const char *>,
-                        Sentinel<const char *>
-                    >&,
-                    ranges::common_iterator<
-                        BidirectionalIterator<const char *>,
-                        Sentinel<const char *>
-                    >
-                >::type,
-                ranges::common_iterator<
-                    BidirectionalIterator<const char *>,
-                    Sentinel<const char *>
-                >
-            >::value);
-        // Sized iterator range tests
-        CPP_assert(
-            !ranges::sized_sentinel_for<
-                ranges::common_iterator<
-                    ForwardIterator<int*>,
-                    Sentinel<int*, true> >,
-                ranges::common_iterator<
-                    ForwardIterator<int*>,
-                    Sentinel<int*, true> > >);
-        CPP_assert(
-            ranges::sized_sentinel_for<
-                ranges::common_iterator<
-                    RandomAccessIterator<int*>,
-                    Sentinel<int*, true> >,
-                ranges::common_iterator<
-                    RandomAccessIterator<int*>,
-                    Sentinel<int*, true> > >);
-        CPP_assert(
-            !ranges::sized_sentinel_for<
-                ranges::common_iterator<
-                    RandomAccessIterator<int*>,
-                    Sentinel<int*, false> >,
-                ranges::common_iterator<
-                    RandomAccessIterator<int*>,
-                    Sentinel<int*, false> > >);
-    }
-    {
-        int rgi[] {0,1,2,3,4,5,6,7,8,9};
-        using CI = ranges::common_iterator<
-            RandomAccessIterator<int*>,
-            Sentinel<int*>>;
-        CI first{RandomAccessIterator<int*>{rgi}};
-        CI last{Sentinel<int*>{rgi+10}};
-        CHECK(std::accumulate(first, last, 0, std::plus<int>{}) == 45);
-    }
-
-    test_operator_arrow();
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/iterator/diffmax_t.cpp b/src/contrib/range-v3-0.11.0/test/iterator/diffmax_t.cpp
deleted file mode 100644
index e21cff8d..00000000
--- a/src/contrib/range-v3-0.11.0/test/iterator/diffmax_t.cpp
+++ /dev/null
@@ -1,72 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2019-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <range/v3/iterator/diffmax_t.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-#include <iomanip>
-#include <functional>
-using ranges::detail::diffmax_t;
-
-template<template<typename> class Op>
-void check_1(std::ptrdiff_t a, std::ptrdiff_t b)
-{
-    // std::cout << std::dec;
-    // std::cout << a << "&" << b << " == " << (a&b) << std::endl;
-    // std::cout << std::hex;
-    // std::cout << a << "&" << b << " == " << (a&b) << std::endl;
-    CHECK(Op<diffmax_t>{}(a, b) == Op<std::ptrdiff_t>{}(a, b));
-}
-template<>
-void check_1<std::divides>(std::ptrdiff_t a, std::ptrdiff_t b)
-{
-    if(b)
-        CHECK(std::divides<diffmax_t>{}(a, b) == std::divides<std::ptrdiff_t>{}(a, b));
-}
-template<>
-void check_1<std::modulus>(std::ptrdiff_t a, std::ptrdiff_t b)
-{
-    if(b)
-        CHECK(std::modulus<diffmax_t>{}(a, b) == std::modulus<std::ptrdiff_t>{}(a, b));
-}
-
-template<template<typename> class Op>
-void check()
-{
-    check_1<Op>(0, 0);
-    check_1<Op>(-1, 0);
-    check_1<Op>(0, -1);
-    check_1<Op>(1, 0);
-    check_1<Op>(0, 1);
-    check_1<Op>(1, 1);
-    check_1<Op>(-1, -1);
-    check_1<Op>(-5, -4);
-    check_1<Op>(-4, -5);
-    check_1<Op>(5, -4);
-    check_1<Op>(-4, 5);
-    check_1<Op>(-5, 4);
-    check_1<Op>(4, -5);
-}
-
-int main()
-{
-    check<std::plus>();
-    check<std::minus>();
-    check<std::multiplies>();
-    check<std::divides>();
-    check<std::modulus>();
-    check<std::bit_and>();
-    check<std::bit_or>();
-    check<std::bit_xor>();
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/iterator/iterator.cpp b/src/contrib/range-v3-0.11.0/test/iterator/iterator.cpp
deleted file mode 100644
index e09b71d5..00000000
--- a/src/contrib/range-v3-0.11.0/test/iterator/iterator.cpp
+++ /dev/null
@@ -1,445 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014, 2016
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <list>
-#include <ostream>
-#include <sstream>
-#include <string>
-#include <vector>
-#include <meta/meta.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/move_iterators.hpp>
-#include <range/v3/iterator/insert_iterators.hpp>
-#include <range/v3/iterator/stream_iterators.hpp>
-#include <range/v3/algorithm/copy.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-using namespace ranges;
-
-struct MoveOnlyReadable
-{
-    using value_type = std::unique_ptr<int>;
-    value_type operator*() const;
-};
-
-CPP_assert(indirectly_readable<MoveOnlyReadable>);
-
-void test_insert_iterator()
-{
-    CPP_assert(output_iterator<insert_iterator<std::vector<int>>, int&&>);
-    CPP_assert(!equality_comparable<insert_iterator<std::vector<int>>>);
-    std::vector<int> vi{5,6,7,8};
-    copy(std::initializer_list<int>{1,2,3,4}, inserter(vi, vi.begin()+2));
-    ::check_equal(vi, {5,6,1,2,3,4,7,8});
-}
-
-void test_ostream_joiner()
-{
-    std::ostringstream oss;
-    std::vector<int> vi{};
-    copy(vi, make_ostream_joiner(oss, ","));
-    ::check_equal(oss.str(), std::string{""});
-    vi = {1,2,3,4};
-    copy(vi, make_ostream_joiner(oss, ","));
-    ::check_equal(oss.str(), std::string{"1,2,3,4"});
-}
-
-void test_move_iterator()
-{
-    std::vector<MoveOnlyString> in;
-    in.emplace_back("this");
-    in.emplace_back("is");
-    in.emplace_back("his");
-    in.emplace_back("face");
-    std::vector<MoveOnlyString> out;
-    auto first = ranges::make_move_iterator(in.begin());
-    using I = decltype(first);
-    CPP_assert(input_iterator<I>);
-    CPP_assert(!forward_iterator<I>);
-    CPP_assert(same_as<I, ranges::move_iterator<std::vector<MoveOnlyString>::iterator>>);
-    auto last = ranges::make_move_sentinel(in.end());
-    using S = decltype(last);
-    CPP_assert(sentinel_for<S, I>);
-    CPP_assert(sized_sentinel_for<I, I>);
-    CHECK((first - first) == 0);
-    CPP_assert(sized_sentinel_for<S, I>);
-    CHECK(static_cast<std::size_t>(last - first) == in.size());
-    ranges::copy(first, last, ranges::back_inserter(out));
-    ::check_equal(in, {"","","",""});
-    ::check_equal(out, {"this","is","his","face"});
-}
-
-template<class I>
-using RI = std::reverse_iterator<I>;
-
-void issue_420_regression()
-{
-    // Verify that sized_sentinel_for<std::reverse_iterator<S>, std::reverse_iterator<I>>
-    // properly requires sized_sentinel_for<I, S>
-    CPP_assert(sized_sentinel_for<RI<int*>, RI<int*>>);
-    CPP_assert(!sized_sentinel_for<RI<int*>, RI<float*>>);
-    using BI = BidirectionalIterator<int*>;
-    CPP_assert(!sized_sentinel_for<RI<BI>, RI<BI>>);
-}
-
-struct value_type_tester_thingy {};
-
-namespace ranges
-{
-    template<>
-    struct indirectly_readable_traits<::value_type_tester_thingy>
-    {
-        using value_type = int;
-    };
-}
-
-template<typename T>
-struct with_value_type { using value_type = T; };
-template<typename T>
-struct with_element_type { using element_type = T; };
-
-// arrays of known bound
-CPP_assert(same_as<int, ranges::indirectly_readable_traits<int[4]>::value_type>);
-CPP_assert(same_as<int, ranges::indirectly_readable_traits<const int[4]>::value_type>);
-CPP_assert(same_as<int*, ranges::indirectly_readable_traits<int*[4]>::value_type>);
-CPP_assert(same_as<with_value_type<int>, ranges::indirectly_readable_traits<with_value_type<int>[4]>::value_type>);
-
-#if !defined(__GNUC__) || defined(__clang__)
-// arrays of unknown bound
-CPP_assert(same_as<int, ranges::indirectly_readable_traits<int[]>::value_type>);
-CPP_assert(same_as<int, ranges::indirectly_readable_traits<const int[]>::value_type>);
-#endif
-
-template<typename T>
-using readable_traits_value_type_t = typename ranges::indirectly_readable_traits<T>::value_type;
-template<typename T>
-using readable_traits_value_type = meta::defer<readable_traits_value_type_t, T>;
-
-// object pointer types
-CPP_assert(same_as<int, ranges::indirectly_readable_traits<int*>::value_type>);
-CPP_assert(same_as<int, ranges::indirectly_readable_traits<int*const>::value_type>);
-CPP_assert(same_as<int, ranges::indirectly_readable_traits<int const*>::value_type>);
-CPP_assert(same_as<int, ranges::indirectly_readable_traits<int const*const>::value_type>);
-CPP_assert(same_as<int[4], ranges::indirectly_readable_traits<int(*)[4]>::value_type>);
-CPP_assert(same_as<int[4], ranges::indirectly_readable_traits<const int(*)[4]>::value_type>);
-struct incomplete;
-CPP_assert(same_as<incomplete, ranges::indirectly_readable_traits<incomplete*>::value_type>);
-static_assert(!meta::is_trait<readable_traits_value_type<void*>>::value, "");
-static_assert(!meta::is_trait<readable_traits_value_type<void const*>>::value, "");
-
-// class types with member value_type
-CPP_assert(same_as<int, ranges::indirectly_readable_traits<with_value_type<int>>::value_type>);
-CPP_assert(same_as<int, ranges::indirectly_readable_traits<with_value_type<int> const>::value_type>);
-CPP_assert(same_as<int, ranges::indirectly_readable_traits<value_type_tester_thingy>::value_type>);
-CPP_assert(same_as<int, ranges::indirectly_readable_traits<value_type_tester_thingy const>::value_type>);
-CPP_assert(same_as<int[4], ranges::indirectly_readable_traits<with_value_type<int[4]>>::value_type>);
-CPP_assert(same_as<int[4], ranges::indirectly_readable_traits<with_value_type<int[4]> const>::value_type>);
-static_assert(!meta::is_trait<readable_traits_value_type<with_value_type<void>>>::value, "");
-static_assert(!meta::is_trait<readable_traits_value_type<with_value_type<int(int)>>>::value, "");
-static_assert(!meta::is_trait<readable_traits_value_type<with_value_type<int&>>>::value, "");
-
-// class types with member element_type
-CPP_assert(same_as<int, ranges::indirectly_readable_traits<with_element_type<int>>::value_type>);
-CPP_assert(same_as<int, ranges::indirectly_readable_traits<with_element_type<int> const>::value_type>);
-CPP_assert(same_as<int, ranges::indirectly_readable_traits<with_element_type<int const>>::value_type>);
-CPP_assert(same_as<int[4], ranges::indirectly_readable_traits<with_element_type<int[4]>>::value_type>);
-CPP_assert(same_as<int[4], ranges::indirectly_readable_traits<with_element_type<int[4]> const>::value_type>);
-CPP_assert(same_as<int[4], ranges::indirectly_readable_traits<with_element_type<int const[4]>>::value_type>);
-static_assert(!meta::is_trait<readable_traits_value_type<with_element_type<void>>>::value, "");
-static_assert(!meta::is_trait<readable_traits_value_type<with_element_type<void const>>>::value, "");
-static_assert(!meta::is_trait<readable_traits_value_type<with_element_type<void> const>>::value, "");
-static_assert(!meta::is_trait<readable_traits_value_type<with_element_type<int(int)>>>::value, "");
-static_assert(!meta::is_trait<readable_traits_value_type<with_element_type<int&>>>::value, "");
-
-// cv-void
-static_assert(!meta::is_trait<readable_traits_value_type<void>>::value, "");
-static_assert(!meta::is_trait<readable_traits_value_type<void const>>::value, "");
-// reference types
-static_assert(!meta::is_trait<readable_traits_value_type<int&>>::value, "");
-static_assert(!meta::is_trait<readable_traits_value_type<int&&>>::value, "");
-static_assert(!meta::is_trait<readable_traits_value_type<int*&>>::value, "");
-static_assert(!meta::is_trait<readable_traits_value_type<int*&&>>::value, "");
-static_assert(!meta::is_trait<readable_traits_value_type<int(&)(int)>>::value, "");
-static_assert(!meta::is_trait<readable_traits_value_type<std::ostream&>>::value, "");
-
-CPP_assert(indirectly_swappable<int *, int *>);
-CPP_assert(indirectly_movable<int const *, int *>);
-CPP_assert(!indirectly_swappable<int const *, int const *>);
-CPP_assert(!indirectly_movable<int const *, int const *>);
-
-namespace Boost
-{
-    struct S {}; // just to have a type from Boost namespace
-    template<typename I, typename D>
-    void advance(I&, D)
-    {}
-}
-
-// Regression test for https://github.com/ericniebler/range-v3/issues/845
-void test_845()
-{
-    std::list<std::pair<Boost::S, int>> v = { {Boost::S{}, 0} };
-    auto itr = v.begin();
-    ranges::advance(itr, 1); // Should not create ambiguity
-}
-
-// Test for https://github.com/ericniebler/range-v3/issues/1110
-void test_1110()
-{
-    // this should not trigger assertation error
-    std::vector<int> v = {1,2,3};
-    auto e = ranges::end(v);
-    ranges::advance(e, 0, ranges::begin(v));
-}
-
-// Test the deep integration with the STL
-#if defined(RANGES_DEEP_STL_INTEGRATION) && RANGES_DEEP_STL_INTEGRATION
-
-struct X
-{
-    int& operator*() const;
-    X & operator++();
-    struct proxy { operator int() const; };
-    proxy operator++(int);
-};
-
-namespace std
-{
-    template <>
-    struct iterator_traits<::X>
-    {
-        using value_type = int;
-        using reference = int&;
-        using pointer = int*;
-        using difference_type = ptrdiff_t;
-        using iterator_category = std::input_iterator_tag;
-    };
-}
-
-static_assert(ranges::input_iterator<X>, "");
-
-struct Y
-{
-    using value_type = int;
-    using difference_type = std::ptrdiff_t;
-    using iterator_category = std::bidirectional_iterator_tag;
-    using reference = int&;
-    using pointer = int*;
-    int& operator*() const noexcept;
-};
-
-static_assert(std::is_same<std::add_pointer_t<int&>, int*>::value, "");
-
-struct Z
-{
-    using difference_type = std::ptrdiff_t;
-    using iterator_category = std::bidirectional_iterator_tag;
-    int& operator*() const noexcept;
-    Z& operator++();
-    Z operator++(int);
-    bool operator==(Z) const;
-    bool operator!=(Z) const;
-};
-
-namespace ranges
-{
-    template <>
-    struct indirectly_readable_traits<::Z>
-    {
-        using value_type = int;
-    };
-}
-
-// Looks like an STL2 forward iterator, but the conformance beyond
-// input is "accidental".
-struct WouldBeFwd
-{
-    using value_type = struct S{ };
-    using difference_type = std::ptrdiff_t;
-    S & operator*() const;
-    WouldBeFwd& operator++();
-    WouldBeFwd operator++(int);
-    //S* operator->() const;
-    bool operator==(WouldBeFwd) const;
-    bool operator!=(WouldBeFwd) const;
-};
-
-namespace std
-{
-    template <>
-    struct iterator_traits<::WouldBeFwd>
-    {
-        using value_type = ::WouldBeFwd::value_type;
-        using difference_type = ::WouldBeFwd::difference_type;
-        using reference = iter_reference_t<::WouldBeFwd>;
-        using pointer = add_pointer_t<reference>;
-        // Explicit opt-out of stl2's forward_iterator concept:
-        using iterator_category = std::input_iterator_tag; // STL1-style iterator category
-    };
-}
-
-// Looks like an STL2 bidirectional iterator, but the conformance beyond
-// forward is "accidental".
-struct WouldBeBidi
-{
-    using value_type = struct S{ };
-    using difference_type = std::ptrdiff_t;
-    // using iterator_category = std::input_iterator_tag;
-    // using iterator_concept = std::forward_iterator_tag;
-    S operator*() const; // by value!
-    WouldBeBidi& operator++();
-    WouldBeBidi operator++(int);
-    WouldBeBidi& operator--();
-    WouldBeBidi operator--(int);
-    //S* operator->() const;
-    bool operator==(WouldBeBidi) const;
-    bool operator!=(WouldBeBidi) const;
-};
-
-namespace std
-{
-    template <>
-    struct iterator_traits<::WouldBeBidi>
-    {
-        using value_type = ::WouldBeBidi::value_type;
-        using difference_type = ::WouldBeBidi::difference_type;
-        using reference = value_type;
-        using pointer = value_type*;
-        using iterator_category = std::input_iterator_tag; // STL1-style iterator category
-        // Explicit opt-out of stl2's bidirectional_iterator concept:
-        using iterator_concept = std::forward_iterator_tag; // STL2-style iterator category
-    };
-}
-
-struct OutIter
-{
-    using difference_type = std::ptrdiff_t;
-    OutIter& operator=(int);
-    OutIter& operator*();
-    OutIter& operator++();
-    OutIter& operator++(int);
-};
-
-// proxy iterator
-struct bool_iterator
-{
-    using value_type = bool;
-    struct reference
-    {
-        operator bool() const { return true; }
-        reference();
-        reference(reference const &);
-        reference& operator=(reference);
-        reference& operator=(bool);
-    };
-    using difference_type = std::ptrdiff_t;
-    reference operator*() const;
-    bool_iterator& operator++();
-    bool_iterator operator++(int);
-    bool operator==(bool_iterator) const;
-    bool operator!=(bool_iterator) const;
-    friend reference iter_move(bool_iterator i) { return *i; }
-    friend void iter_swap(bool_iterator, bool_iterator) { }
-};
-
-void deep_integration_test()
-{
-    using std::is_same;
-    using std::iterator_traits;
-    using ranges::iter_value_t;
-    using ranges::iter_difference_t;
-    static_assert(is_same<iter_difference_t<std::int_least16_t>, int>::value, "");
-    static_assert(is_same<iter_difference_t<std::uint_least16_t>, int>::value, "");
-    static_assert(is_same<iter_difference_t<std::int_least32_t>, std::int_least32_t>::value, "");
-    static_assert(is_same<iter_difference_t<std::uint_least32_t>, meta::_t<std::make_signed<std::uint_least32_t>>>::value, "");
-    static_assert(is_same<iter_difference_t<std::uint_least64_t>, meta::_t<std::make_signed<std::uint_least64_t>>>::value, "");
-
-    static_assert(is_same<iter_value_t<const int*>, int>::value, "");
-    static_assert(is_same<iter_difference_t<const int*>, ptrdiff_t>::value, "");
-    static_assert(is_same<iter_difference_t<int* const>, ptrdiff_t>::value, "");
-
-    static_assert(detail::is_std_iterator_traits_specialized_v<X>, "");
-    static_assert(is_same<iterator_traits<X>::value_type, int>::value, "");
-    static_assert(is_same<iter_value_t<X>, int>::value, "");
-
-    static_assert(!detail::is_std_iterator_traits_specialized_v<Y>, "");
-    static_assert(is_same<iterator_traits<Y>::value_type, int>::value, "");
-    static_assert(is_same<iter_value_t<Y>, int>::value, "");
-
-    // libc++ has a broken std::iterator_traits primary template
-    // https://bugs.llvm.org/show_bug.cgi?id=39619
-#ifndef _LIBCPP_VERSION
-    // iterator_traits uses specializations of ranges::indirectly_readable_traits:
-    static_assert(!detail::is_std_iterator_traits_specialized_v<Z>, "");
-    static_assert(is_same<iterator_traits<Z>::value_type, int>::value, "");
-    static_assert(is_same<iter_value_t<Z>, int>::value, "");
-    static_assert(is_same<iterator_traits<Z>::iterator_category,
-                          std::bidirectional_iterator_tag>::value, "");
-#endif
-
-    static_assert(ranges::input_iterator<WouldBeFwd>, "");
-    static_assert(!ranges::forward_iterator<WouldBeFwd>, "");
-    static_assert(is_same<iterator_traits<WouldBeFwd>::iterator_category,
-                           std::input_iterator_tag>::value, "");
-
-    static_assert(ranges::forward_iterator<WouldBeBidi>, "");
-    static_assert(!ranges::bidirectional_iterator<WouldBeBidi>, "");
-    static_assert(is_same<iterator_traits<WouldBeBidi>::iterator_category,
-                          std::input_iterator_tag>::value, "");
-
-    static_assert(ranges::input_or_output_iterator<OutIter>, "");
-    static_assert(!ranges::input_iterator<OutIter>, "");
-    static_assert(is_same<iterator_traits<OutIter>::difference_type,
-                          std::ptrdiff_t>::value, "");
-    static_assert(is_same<iterator_traits<OutIter>::iterator_category,
-                          std::output_iterator_tag>::value, "");
-
-    static_assert(ranges::contiguous_iterator<int volatile *>, "");
-
-    static_assert(ranges::forward_iterator<bool_iterator>, "");
-    static_assert(is_same<iterator_traits<bool_iterator>::iterator_category,
-                          std::input_iterator_tag>::value, "");
-    // static_assert(_Cpp98InputIterator<int volatile*>);
-    // static_assert(_Cpp98InputIterator<bool_iterator>);
-
-    // // Test subsumption:
-    // test(WouldBeFwd{});
-    // test(WouldBeBidi{});
-    // test(meta::detail::nullptr_v<int>);
-
-    // // Test subsumption:
-    // test2(OutIter{});
-    // test2(meta::detail::nullptr_v<int>);
-
-    // // Test subsumption:
-    // test3(WouldBeFwd{}, WouldBeFwd{});
-    // test3(meta::detail::nullptr_v<int>, meta::detail::nullptr_v<int>);
-}
-
-#endif
-
-int main()
-{
-    test_insert_iterator();
-    test_move_iterator();
-    test_ostream_joiner();
-    issue_420_regression();
-    test_1110();
-
-    {
-        struct S { using value_type = int; };
-        CPP_assert(same_as<int, ranges::indirectly_readable_traits<S const>::value_type>);
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/iterator/reverse_iterator.cpp b/src/contrib/range-v3-0.11.0/test/iterator/reverse_iterator.cpp
deleted file mode 100644
index 0071851b..00000000
--- a/src/contrib/range-v3-0.11.0/test/iterator/reverse_iterator.cpp
+++ /dev/null
@@ -1,480 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-// These tests of reverse_iterator have been adapted from libc++
-// (http://libcxx.llvm.org).
-//
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <range/v3/range/access.hpp>
-#include <range/v3/view/iota.hpp>
-#include "../simple_test.hpp"
-#include "../test_iterators.hpp"
-
-template<class It> void test() { ranges::reverse_iterator<It>{}; }
-
-template<class It> void test2(It i) {
-  ranges::reverse_iterator<It> r(i);
-  CHECK(r.base() == i);
-}
-
-template<class It, class U> void test3(U u) {
-  const ranges::reverse_iterator<U> r2(u);
-  ranges::reverse_iterator<It> r1 = ranges::reverse_iterator<It>(r2);
-  CHECK(r1.base() == u);
-}
-
-struct Base {};
-struct Derived : Base {};
-
-template<class It> void test4(It i) {
-  const ranges::reverse_iterator<It> r = ranges::make_reverse_iterator(i);
-  CHECK(r.base() == i);
-}
-
-template<class It> void test5(It l, It r, bool x) {
-  const ranges::reverse_iterator<It> r1(l);
-  const ranges::reverse_iterator<It> r2(r);
-  CHECK((r1 != r2) == x);
-}
-
-template<class It> void test6(It i, It x) {
-  ranges::reverse_iterator<It> r(i);
-  ranges::reverse_iterator<It> rr = r++;
-  CHECK(r.base() == x);
-  CHECK(rr.base() == i);
-}
-
-template<class It> void test7(It i, It x) {
-  ranges::reverse_iterator<It> r(i);
-  ranges::reverse_iterator<It> &rr = ++r;
-  CHECK(r.base() == x);
-  CHECK(&rr == &r);
-}
-
-template<class It>
-void test8(It i, ranges::iter_difference_t<It> n, It x) {
-  const ranges::reverse_iterator<It> r(i);
-  ranges::reverse_iterator<It> rr = r + n;
-  CHECK(rr.base() == x);
-}
-
-template<class It>
-void test9(It i, ranges::iter_difference_t<It> n, It x) {
-  ranges::reverse_iterator<It> r(i);
-  ranges::reverse_iterator<It> &rr = r += n;
-  CHECK(r.base() == x);
-  CHECK(&rr == &r);
-}
-
-template<class It> void test10(It i, It x) {
-  ranges::reverse_iterator<It> r(i);
-  ranges::reverse_iterator<It> rr = r--;
-  CHECK(r.base() == x);
-  CHECK(rr.base() == i);
-}
-template<class It> void test11(It i, It x) {
-  ranges::reverse_iterator<It> r(i);
-  ranges::reverse_iterator<It> &rr = --r;
-  CHECK(r.base() == x);
-  CHECK(&rr == &r);
-}
-template<class It>
-void test12(It i, ranges::iter_difference_t<It> n, It x) {
-  const ranges::reverse_iterator<It> r(i);
-  ranges::reverse_iterator<It> rr = r - n;
-  CHECK(rr.base() == x);
-}
-
-template<class It>
-void test13(It i, ranges::iter_difference_t<It> n, It x) {
-  ranges::reverse_iterator<It> r(i);
-  ranges::reverse_iterator<It> &rr = r -= n;
-  CHECK(r.base() == x);
-  CHECK(&rr == &r);
-}
-
-class A {
-  int data_ = 1;
-
-public:
-  A() = default;
-
-  friend bool operator==(const A &x, const A &y) { return x.data_ == y.data_; }
-};
-
-template<class It> void test14(It i, ranges::iter_value_t<It> x) {
-  ranges::reverse_iterator<It> r(i);
-  CHECK(*r == x);
-}
-
-template<class It, class U> void test15(U u) {
-  const ranges::reverse_iterator<U> r2(u);
-  ranges::reverse_iterator<It> r1;
-  ranges::reverse_iterator<It> &rr = r1 = r2;
-  CHECK(r1.base() == u);
-  CHECK(&rr == &r1);
-}
-template<class It> void test16(It l, It r, bool x) {
-  const ranges::reverse_iterator<It> r1(l);
-  const ranges::reverse_iterator<It> r2(r);
-  CHECK((r1 == r2) == x);
-}
-
-template<class It1, class It2> void test17(It1 l, It2 r, std::ptrdiff_t x) {
-   const ranges::reverse_iterator<It1> r1(l);
-   const ranges::reverse_iterator<It2> r2(r);
-   CHECK((r1 - r2) == x);
-}
-
-template<class It> void test18(It l, It r, bool x) {
-  const ranges::reverse_iterator<It> r1(l);
-  const ranges::reverse_iterator<It> r2(r);
-  CHECK((r1 > r2) == x);
-}
-
-template<class It> void test19(It l, It r, bool x) {
-  const ranges::reverse_iterator<It> r1(l);
-  const ranges::reverse_iterator<It> r2(r);
-  CHECK((r1 >= r2) == x);
-}
-
-template<class It>
-void test20(It i, ranges::iter_difference_t<It> n,
-            ranges::iter_value_t<It> x) {
-  const ranges::reverse_iterator<It> r(i);
-  ranges::iter_value_t<It> rr = r[n];
-  CHECK(rr == x);
-}
-
-template<class It> void test21(It l, It r, bool x) {
-  const ranges::reverse_iterator<It> r1(l);
-  const ranges::reverse_iterator<It> r2(r);
-  CHECK((r1 < r2) == x);
-}
-
-template<class It>
-void
-test22(It l, It r, bool x)
-{
-    const ranges::reverse_iterator<It> r1(l);
-    const ranges::reverse_iterator<It> r2(r);
-    CHECK((r1 < r2) == x);
-}
-
-template<class It>
-void
-test23(It l, It r, bool x)
-{
-    const ranges::reverse_iterator<It> r1(l);
-    const ranges::reverse_iterator<It> r2(r);
-    CHECK((r1 <= r2) == x);
-}
-
-
-class B
-{
-    int data_ = 1;
-  public:
-    B() = default;
-
-    int get() const {return data_;}
-
-    friend bool operator==(const B& x, const B& y)
-    {return x.data_ == y.data_;}
-};
-
-template<class It>
-void
-test24(It i, ranges::iter_value_t<It> x)
-{
-    ranges::reverse_iterator<It> r(i);
-    CHECK((*r).get() == x.get());
-}
-
-
-class C
-{
-    int data_ = 1;
-  public:
-    C(int d) : data_(d) {}
-    C() = default;
-
-    int get() const {return data_;}
-
-    friend bool operator==(const C& x, const C& y)
-    {return x.data_ == y.data_;}
-    const C *operator&() const { return nullptr; }
-    C       *operator&()       { return nullptr; }
-};
-
-template<class It>
-void
-test25(It i, ranges::iter_difference_t<It> n, It x)
-{
-    const ranges::reverse_iterator<It> r(i);
-    ranges::reverse_iterator<It> rr = n + r;
-    CHECK(rr.base() == x);
-}
-
-int main()
-{
-  {
-    static_assert(
-        ranges::detail::bidirectional_cursor<
-        ranges::detail::reverse_cursor<BidirectionalIterator<const char *>>>,
-        "");
-    static_assert(
-        ranges::detail::bidirectional_cursor<
-        ranges::detail::reverse_cursor<RandomAccessIterator<const char *>>>,
-        "");
-    static_assert(
-        ranges::detail::random_access_cursor<
-        ranges::detail::reverse_cursor<RandomAccessIterator<const char *>>>,
-        "");
-    static_assert(
-        ranges::bidirectional_iterator<
-            ranges::reverse_iterator<BidirectionalIterator<const char *>>>,
-        "");
-    static_assert(
-        ranges::random_access_iterator<
-            ranges::reverse_iterator<RandomAccessIterator<const char *>>>,
-        "");
-  }
-  { // test
-    test<BidirectionalIterator<const char *>>();
-    test<RandomAccessIterator<char *>>();
-    test<char *>();
-    test<const char *>();
-  }
-  { // test 2
-    const char s[] = "123";
-    test2(BidirectionalIterator<const char *>(s));
-    test2(RandomAccessIterator<const char *>(s));
-  }
-  { // test3
-    Derived d;
-    test3<BidirectionalIterator<Base *>>(
-        BidirectionalIterator<Derived *>(&d));
-    //test3<RandomAccessIterator<const Base *>>(
-    //    RandomAccessIterator<Derived *>(&d));
-  }
-  //{ // test4
-  //  const char *s = "1234567890";
-  //  RandomAccessIterator<const char *> b(s);
-  //  RandomAccessIterator<const char *> e(s + 10);
-  //  while (b != e)
-  //    test4(b++);
-  //}
-  //{ // test5
-  //  const char *s = "1234567890";
-  //  test5(BidirectionalIterator<const char *>(s),
-  //        BidirectionalIterator<const char *>(s), false);
-  //  test5(BidirectionalIterator<const char *>(s),
-  //        BidirectionalIterator<const char *>(s + 1), true);
-  //  test5(RandomAccessIterator<const char *>(s),
-  //        RandomAccessIterator<const char *>(s), false);
-  //  test5(RandomAccessIterator<const char *>(s),
-  //        RandomAccessIterator<const char *>(s + 1), true);
-  //  test5(s, s, false);
-  //  test5(s, s + 1, true);
-  //}
-  //{
-  //  const char *s = "123";
-  //  test6(BidirectionalIterator<const char *>(s + 1),
-  //        BidirectionalIterator<const char *>(s));
-  //  test6(RandomAccessIterator<const char *>(s + 1),
-  //        RandomAccessIterator<const char *>(s));
-  //  test6(s + 1, s);
-  //}
-  //{
-  //  const char *s = "123";
-  //  test7(BidirectionalIterator<const char *>(s + 1),
-  //        BidirectionalIterator<const char *>(s));
-  //  test7(RandomAccessIterator<const char *>(s + 1),
-  //        RandomAccessIterator<const char *>(s));
-  //  test7(s + 1, s);
-  //}
-  //{
-  //  const char *s = "1234567890";
-  //  test8(RandomAccessIterator<const char *>(s + 5), 5,
-  //        RandomAccessIterator<const char *>(s));
-  //  test8(s + 5, 5, s);
-  //}
-  //{
-  //  const char *s = "1234567890";
-  //  test9(RandomAccessIterator<const char *>(s + 5), 5,
-  //        RandomAccessIterator<const char *>(s));
-  //  test9(s + 5, 5, s);
-  //}
-  //{
-  //  const char *s = "123";
-  //  test10(BidirectionalIterator<const char *>(s + 1),
-  //         BidirectionalIterator<const char *>(s + 2));
-  //  test10(RandomAccessIterator<const char *>(s + 1),
-  //         RandomAccessIterator<const char *>(s + 2));
-  //  test10(s + 1, s + 2);
-  //}
-  //{
-  //  const char *s = "123";
-  //  test11(BidirectionalIterator<const char *>(s + 1),
-  //         BidirectionalIterator<const char *>(s + 2));
-  //  test11(RandomAccessIterator<const char *>(s + 1),
-  //         RandomAccessIterator<const char *>(s + 2));
-  //  test11(s + 1, s + 2);
-  //}
-  //{
-  //  const char *s = "1234567890";
-  //  test12(RandomAccessIterator<const char *>(s + 5), 5,
-  //         RandomAccessIterator<const char *>(s + 10));
-  //  test12(s + 5, 5, s + 10);
-  //}
-  //{
-  //  const char *s = "1234567890";
-  //  test13(RandomAccessIterator<const char *>(s + 5), 5,
-  //         RandomAccessIterator<const char *>(s + 10));
-  //  test13(s + 5, 5, s + 10);
-  //}
-  //{
-  //  A a;
-  //  test14(&a + 1, A());
-  //}
-  //{
-  //  Derived d;
-
-  //  test15<BidirectionalIterator<Base *>>(
-  //      BidirectionalIterator<Derived *>(&d));
-  //  test15<RandomAccessIterator<const Base *>>(
-  //      RandomAccessIterator<Derived *>(&d));
-  //  test15<Base *>(&d);
-  //}
-  //{
-  //  const char *s = "1234567890";
-  //  test16(BidirectionalIterator<const char *>(s),
-  //         BidirectionalIterator<const char *>(s), true);
-  //  test16(BidirectionalIterator<const char *>(s),
-  //         BidirectionalIterator<const char *>(s + 1), false);
-  //  test16(RandomAccessIterator<const char *>(s),
-  //         RandomAccessIterator<const char *>(s), true);
-  //  test16(RandomAccessIterator<const char *>(s),
-  //         RandomAccessIterator<const char *>(s + 1), false);
-  //  test16(s, s, true);
-  //  test16(s, s + 1, false);
-  //}
-  //{
-  //  char s[3] = {0};
-  //  test17(RandomAccessIterator<const char *>(s),
-  //         RandomAccessIterator<char *>(s), 0);
-  //  RandomAccessIterator<char *> inp1(s);
-  //  test17(RandomAccessIterator<char *>(s),
-  //         RandomAccessIterator<const char *>(s + 1), 1);
-  //  test17(RandomAccessIterator<const char *>(s + 1),
-  //         RandomAccessIterator<char *>(s), -1);
-  //  test17(s, s, 0);
-  //  test17(s, s + 1, 1);
-  //  test17(s + 1, s, -1);
-  //}
-  //{
-  //  const char *s = "1234567890";
-  //  test18(RandomAccessIterator<const char *>(s),
-  //         RandomAccessIterator<const char *>(s), false);
-  //  test18(RandomAccessIterator<const char *>(s),
-  //         RandomAccessIterator<const char *>(s + 1), true);
-  //  test18(RandomAccessIterator<const char *>(s + 1),
-  //         RandomAccessIterator<const char *>(s), false);
-  //  test18(s, s, false);
-  //  test18(s, s + 1, true);
-  //  test18(s + 1, s, false);
-  //}
-  //{
-  //  const char *s = "1234567890";
-  //  test19(RandomAccessIterator<const char *>(s),
-  //         RandomAccessIterator<const char *>(s), true);
-  //  test19(RandomAccessIterator<const char *>(s),
-  //         RandomAccessIterator<const char *>(s + 1), true);
-  //  test19(RandomAccessIterator<const char *>(s + 1),
-  //         RandomAccessIterator<const char *>(s), false);
-  //  test19(s, s, true);
-  //  test19(s, s + 1, true);
-  //  test19(s + 1, s, false);
-  //}
-  //{
-  //  const char *s = "1234567890";
-  //  test20(RandomAccessIterator<const char *>(s + 5), 4, '1');
-  //  test20(s + 5, 4, '1');
-  //}
-  //{
-  //  const char *s = "1234567890";
-  //  test21(RandomAccessIterator<const char *>(s),
-  //       RandomAccessIterator<const char *>(s), false);
-  //  test21(RandomAccessIterator<const char *>(s),
-  //       RandomAccessIterator<const char *>(s + 1), false);
-  //  test21(RandomAccessIterator<const char *>(s + 1),
-  //       RandomAccessIterator<const char *>(s), true);
-  //  test21(s, s, false);
-  //  test21(s, s + 1, false);
-  //  test21(s + 1, s, true);
-  //}
-  //{
-  //    const char* s = "1234567890";
-  //    test22(RandomAccessIterator<const char*>(s), RandomAccessIterator<const char*>(s), false);
-  //    test22(RandomAccessIterator<const char*>(s), RandomAccessIterator<const char*>(s+1), false);
-  //    test22(RandomAccessIterator<const char*>(s+1), RandomAccessIterator<const char*>(s), true);
-  //    test22(s, s, false);
-  //    test22(s, s+1, false);
-  //    test22(s+1, s, true);
-  //}
-  //{
-  //    const char* s = "1234567890";
-  //    test23(RandomAccessIterator<const char*>(s), RandomAccessIterator<const char*>(s), true);
-  //    test23(RandomAccessIterator<const char*>(s), RandomAccessIterator<const char*>(s+1), false);
-  //    test23(RandomAccessIterator<const char*>(s+1), RandomAccessIterator<const char*>(s), true);
-  //    test23(s, s, true);
-  //    test23(s, s+1, false);
-  //    test23(s+1, s, true);
-  //}
-  //{
-  //    B a;
-  //    test24(&a+1, B());
-  //}
-  //{
-  //    C l[3] = {C(0), C(1), C(2)};
-
-  //    auto ri = ranges::rbegin(l);
-  //    CHECK ( ri->get() == 2 );
-  //    CHECK ( (*ri).get() == 2 );
-  //    CHECK ( ri.operator->() == ranges::prev(ri.base()) );
-  //    ++ri;
-  //    CHECK ( ri->get() == 1 );
-  //    CHECK ( (*ri).get() == 1 );
-  //    CHECK ( ri.operator->() == ranges::prev(ri.base()) );
-  //    ++ri;
-  //    CHECK ( ri->get() == 0 );
-  //    CHECK ( (*ri).get() == 0 );
-  //    CHECK ( ri.operator->() == ranges::prev(ri.base()) );
-  //    ++ri;
-  //    CHECK ( ri == ranges::rend(l));
-  //}
-  //{
-  //    const char* s = "1234567890";
-  //    test25(RandomAccessIterator<const char*>(s+5), 5, RandomAccessIterator<const char*>(s));
-  //    test25(s+5, 5, s);
-  //}
-
-  return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/multiple1.cpp b/src/contrib/range-v3-0.11.0/test/multiple1.cpp
deleted file mode 100644
index 81a37f0c..00000000
--- a/src/contrib/range-v3-0.11.0/test/multiple1.cpp
+++ /dev/null
@@ -1,15 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <range/v3/all.hpp>
-#include "./simple_test.hpp"
-#include "./test_utils.hpp"
-#include "./test_iterators.hpp"
diff --git a/src/contrib/range-v3-0.11.0/test/multiple2.cpp b/src/contrib/range-v3-0.11.0/test/multiple2.cpp
deleted file mode 100644
index e4e209d9..00000000
--- a/src/contrib/range-v3-0.11.0/test/multiple2.cpp
+++ /dev/null
@@ -1,20 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <range/v3/all.hpp>
-#include "./simple_test.hpp"
-#include "./test_utils.hpp"
-#include "./test_iterators.hpp"
-
-int main()
-{
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/numeric/CMakeLists.txt b/src/contrib/range-v3-0.11.0/test/numeric/CMakeLists.txt
deleted file mode 100644
index 51bb98ae..00000000
--- a/src/contrib/range-v3-0.11.0/test/numeric/CMakeLists.txt
+++ /dev/null
@@ -1,7 +0,0 @@
-set(CMAKE_FOLDER "${CMAKE_FOLDER}/numeric")
-
-rv3_add_test(test.num.accumulate num.accumulate accumulate.cpp)
-rv3_add_test(test.num.adjacent_difference num.adjacent_difference adjacent_difference.cpp)
-rv3_add_test(test.num.inner_product num.inner_product inner_product.cpp)
-rv3_add_test(test.num.iota num.iota iota.cpp)
-rv3_add_test(test.num.partial_sum num.partial_sum partial_sum.cpp)
diff --git a/src/contrib/range-v3-0.11.0/test/numeric/accumulate.cpp b/src/contrib/range-v3-0.11.0/test/numeric/accumulate.cpp
deleted file mode 100644
index 07626dcf..00000000
--- a/src/contrib/range-v3-0.11.0/test/numeric/accumulate.cpp
+++ /dev/null
@@ -1,75 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <range/v3/core.hpp>
-#include <range/v3/numeric/accumulate.hpp>
-#include "../simple_test.hpp"
-#include "../test_iterators.hpp"
-
-struct S
-{
-    int i;
-    S add(int j) const
-    {
-        return S{i + j};
-    }
-};
-
-template<class Iter, class Sent = Iter>
-void test()
-{
-    int ia[] = {1, 2, 3, 4, 5, 6};
-    constexpr auto sc = ranges::size(ia);
-    CHECK(ranges::accumulate(Iter(ia), Sent(ia), 0) == 0);
-    CHECK(ranges::accumulate(Iter(ia), Sent(ia), 10) == 10);
-    CHECK(ranges::accumulate(Iter(ia), Sent(ia+1), 0) == 1);
-    CHECK(ranges::accumulate(Iter(ia), Sent(ia+1), 10) == 11);
-    CHECK(ranges::accumulate(Iter(ia), Sent(ia+2), 0) == 3);
-    CHECK(ranges::accumulate(Iter(ia), Sent(ia+2), 10) == 13);
-    CHECK(ranges::accumulate(Iter(ia), Sent(ia+sc), 0) == 21);
-    CHECK(ranges::accumulate(Iter(ia), Sent(ia+sc), 10) == 31);
-
-    using ranges::make_subrange;
-    CHECK(ranges::accumulate(make_subrange(Iter(ia), Sent(ia)), 0) == 0);
-    CHECK(ranges::accumulate(make_subrange(Iter(ia), Sent(ia)), 10) == 10);
-    CHECK(ranges::accumulate(make_subrange(Iter(ia), Sent(ia+1)), 0) == 1);
-    CHECK(ranges::accumulate(make_subrange(Iter(ia), Sent(ia+1)), 10) == 11);
-    CHECK(ranges::accumulate(make_subrange(Iter(ia), Sent(ia+2)), 0) == 3);
-    CHECK(ranges::accumulate(make_subrange(Iter(ia), Sent(ia+2)), 10) == 13);
-    CHECK(ranges::accumulate(make_subrange(Iter(ia), Sent(ia+sc)), 0) == 21);
-    CHECK(ranges::accumulate(make_subrange(Iter(ia), Sent(ia+sc)), 10) == 31);
-}
-
-int main()
-{
-    test<InputIterator<const int*> >();
-    test<ForwardIterator<const int*> >();
-    test<BidirectionalIterator<const int*> >();
-    test<RandomAccessIterator<const int*> >();
-    test<const int*>();
-
-    test<InputIterator<const int*>, Sentinel<const int*> >();
-    test<ForwardIterator<const int*>, Sentinel<const int*> >();
-    test<BidirectionalIterator<const int*>, Sentinel<const int*> >();
-    test<RandomAccessIterator<const int*>, Sentinel<const int*> >();
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/numeric/adjacent_difference.cpp b/src/contrib/range-v3-0.11.0/test/numeric/adjacent_difference.cpp
deleted file mode 100644
index bf129c75..00000000
--- a/src/contrib/range-v3-0.11.0/test/numeric/adjacent_difference.cpp
+++ /dev/null
@@ -1,179 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Gonzalo Brito Gadeschi 2014
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-// Implementation based on the code in libc++
-//   http://http://libcxx.llvm.org/
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <range/v3/core.hpp>
-#include <range/v3/numeric/adjacent_difference.hpp>
-#include "../simple_test.hpp"
-#include "../test_iterators.hpp"
-
-struct S
-{
-    int i;
-};
-
-template<class InIter, class OutIter, class InSent = InIter> void test()
-{
-    using ranges::adjacent_difference;
-    using ranges::make_subrange;
-    { // iterator
-        int ia[] = {15, 10, 6, 3, 1};
-        int ir[] = {15, -5, -4, -3, -2};
-        const unsigned s = sizeof(ia) / sizeof(ia[0]);
-        int ib[s] = {0};
-        auto r = adjacent_difference(InIter(ia), InSent(ia + s), OutIter(ib));
-        CHECK(base(r.in) == ia + s);
-        CHECK(base(r.out) == ib + s);
-        for(unsigned i = 0; i < s; ++i)
-        {
-            CHECK(ib[i] == ir[i]);
-        }
-    }
-
-    { // range + output iterator
-        int ia[] = {15, 10, 6, 3, 1};
-        int ir[] = {15, -5, -4, -3, -2};
-        const unsigned s = sizeof(ia) / sizeof(ia[0]);
-        int ib[s] = {0};
-        auto rng = make_subrange(InIter(ia), InSent(ia + s));
-        auto r = adjacent_difference(rng, OutIter(ib));
-        CHECK(base(r.in) == ia + s);
-        CHECK(base(r.out) == ib + s);
-        for(unsigned i = 0; i < s; ++i)
-        {
-            CHECK(ib[i] == ir[i]);
-        }
-    }
-
-    { // range + output range
-        int ia[] = {15, 10, 6, 3, 1};
-        int ir[] = {15, -5, -4, -3, -2};
-        const unsigned s = sizeof(ia) / sizeof(ia[0]);
-        int ib[s] = {0};
-        auto rng = make_subrange(InIter(ia), InSent(ia + s));
-        auto orng = make_subrange(OutIter(ib), OutIter(ib + s));
-        auto r = adjacent_difference(rng, orng);
-        CHECK(base(r.in) == ia + s);
-        CHECK(base(r.out) == ib + s);
-        for(unsigned i = 0; i < s; ++i)
-        {
-            CHECK(ib[i] == ir[i]);
-        }
-    }
-
-    {
-        int ia[] = {15, 10, 6, 3, 1};
-        int ir[] = {15, 25, 16, 9, 4};
-        const unsigned s = sizeof(ia) / sizeof(ia[0]);
-        int ib[s] = {0};
-        auto rng = make_subrange(InIter(ia), InSent(ia + s));
-        auto orng = make_subrange(OutIter(ib), OutIter(ib + s));
-        auto r = adjacent_difference(rng, orng, std::plus<int>());
-        CHECK(base(r.in) == ia + s);
-        CHECK(base(r.out) == ib + s);
-        for(unsigned i = 0; i < s; ++i)
-        {
-            CHECK(ib[i] == ir[i]);
-        }
-    }
-}
-
-int main()
-{
-    test<InputIterator<const int *>, InputIterator<int *>>();
-    test<InputIterator<const int *>, ForwardIterator<int *>>();
-    test<InputIterator<const int *>, BidirectionalIterator<int *>>();
-    test<InputIterator<const int *>, RandomAccessIterator<int *>>();
-    test<InputIterator<const int *>, int *>();
-
-    test<ForwardIterator<const int *>, InputIterator<int *>>();
-    test<ForwardIterator<const int *>, ForwardIterator<int *>>();
-    test<ForwardIterator<const int *>, BidirectionalIterator<int *>>();
-    test<ForwardIterator<const int *>, RandomAccessIterator<int *>>();
-    test<ForwardIterator<const int *>, int *>();
-
-    test<BidirectionalIterator<const int *>, InputIterator<int *>>();
-    test<BidirectionalIterator<const int *>, ForwardIterator<int *>>();
-    test<BidirectionalIterator<const int *>, BidirectionalIterator<int *>>();
-    test<BidirectionalIterator<const int *>, RandomAccessIterator<int *>>();
-    test<BidirectionalIterator<const int *>, int *>();
-
-    test<RandomAccessIterator<const int *>, InputIterator<int *>>();
-    test<RandomAccessIterator<const int *>, ForwardIterator<int *>>();
-    test<RandomAccessIterator<const int *>, BidirectionalIterator<int *>>();
-    test<RandomAccessIterator<const int *>, RandomAccessIterator<int *>>();
-    test<RandomAccessIterator<const int *>, int *>();
-
-    test<const int *, InputIterator<int *>>();
-    test<const int *, ForwardIterator<int *>>();
-    test<const int *, BidirectionalIterator<int *>>();
-    test<const int *, RandomAccessIterator<int *>>();
-    test<const int *, int *>();
-
-    using ranges::adjacent_difference;
-
-    { // Test projections
-        S ia[] = {{15}, {10}, {6}, {3}, {1}};
-        int ir[] = {15, -5, -4, -3, -2};
-        const unsigned s = sizeof(ir) / sizeof(ir[0]);
-        int ib[s] = {0};
-        auto r = adjacent_difference(ranges::begin(ia), ranges::begin(ia) + s,
-                                     ranges::begin(ib), std::minus<int>(), &S::i);
-        CHECK(base(r.in) == ia + s);
-        CHECK(base(r.out) == ib + s);
-        for(unsigned i = 0; i < s; ++i)
-        {
-            CHECK(ib[i] == ir[i]);
-        }
-    }
-
-    { // Test BinaryOp
-        int ia[] = {15, 10, 6, 3, 1};
-        int ir[] = {15, 25, 16, 9, 4};
-        const unsigned s = sizeof(ir) / sizeof(ir[0]);
-        int ib[s] = {0};
-        auto r = adjacent_difference(ia, ranges::begin(ib), std::plus<int>());
-        CHECK(base(r.in) == ia + s);
-        CHECK(base(r.out) == ib + s);
-        for(unsigned i = 0; i < s; ++i)
-        {
-            CHECK(ib[i] == ir[i]);
-        }
-    }
-
-    { // Test calling it with an array
-        int ia[] = {15, 10, 6, 3, 1};
-        int ir[] = {15, 25, 16, 9, 4};
-        const unsigned s = sizeof(ir) / sizeof(ir[0]);
-        int ib[s] = {0};
-        auto r = adjacent_difference(ia, ib, std::plus<int>());
-        CHECK(base(r.in) == ia + s);
-        CHECK(base(r.out) == ib + s);
-        for(unsigned i = 0; i < s; ++i)
-        {
-            CHECK(ib[i] == ir[i]);
-        }
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/numeric/inner_product.cpp b/src/contrib/range-v3-0.11.0/test/numeric/inner_product.cpp
deleted file mode 100644
index cdca35a9..00000000
--- a/src/contrib/range-v3-0.11.0/test/numeric/inner_product.cpp
+++ /dev/null
@@ -1,191 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Gonzalo Brito Gadeschi 2014
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-// Implementation based on the code in libc++
-//   http://http://libcxx.llvm.org/
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <range/v3/core.hpp>
-#include <range/v3/numeric/inner_product.hpp>
-#include <range/v3/algorithm/equal.hpp>
-#include "../simple_test.hpp"
-#include "../test_iterators.hpp"
-
-RANGES_DIAGNOSTIC_IGNORE_SIGN_CONVERSION
-
-namespace
-{
-  struct S
-  {
-      int i;
-  };
-
-  template<class Iter1, class Iter2, class Sent1 = Iter1>
-  void test()
-  {
-      int a[] = {1, 2, 3, 4, 5, 6};
-      int b[] = {6, 5, 4, 3, 2, 1};
-      unsigned sa = sizeof(a) / sizeof(a[0]);
-
-      // iterator test:
-      auto it3 = [](int* b1, int l1, int* b2, int i)
-      {
-        return ranges::inner_product(Iter1(b1), Sent1(b1+l1), Iter2(b2), i);
-      };
-      CHECK(it3(a, 0, b, 0) == 0);
-      CHECK(it3(a, 0, b, 10) == 10);
-      CHECK(it3(a, 1, b, 0) == 6);
-      CHECK(it3(a, 1, b, 10) == 16);
-      CHECK(it3(a, 2, b, 0) == 16);
-      CHECK(it3(a, 2, b, 10) == 26);
-      CHECK(it3(a, sa, b, 0) == 56);
-      CHECK(it3(a, sa, b, 10) == 66);
-
-      auto it4 = [](int* b1, int l1, int* b2, int i)
-      {
-        return ranges::inner_product(Iter1(b1), Sent1(b1+l1), Iter2(b2), Iter2(b2+l1), i);
-      };
-      CHECK(it4(a, 0, b, 0) == 0);
-      CHECK(it4(a, 0, b, 10) == 10);
-      CHECK(it4(a, 1, b, 0) == 6);
-      CHECK(it4(a, 1, b, 10) == 16);
-      CHECK(it4(a, 2, b, 0) == 16);
-      CHECK(it4(a, 2, b, 10) == 26);
-      CHECK(it4(a, sa, b, 0) == 56);
-      CHECK(it4(a, sa, b, 10) == 66);
-
-      // rng test:
-      auto rng3 = [](int* b1, int l1, int* b2, int i)
-      {
-        return ranges::inner_product(ranges::make_subrange(Iter1(b1), Sent1(b1+l1)), Iter2(b2), i);
-      };
-      CHECK(rng3(a, 0, b, 0) == 0);
-      CHECK(rng3(a, 0, b, 10)  == 10);
-      CHECK(rng3(a, 1, b, 0) == 6);
-      CHECK(rng3(a, 1, b, 10) == 16);
-      CHECK(rng3(a, 2, b, 0) == 16);
-      CHECK(rng3(a, 2, b, 10) == 26);
-      CHECK(rng3(a, sa, b, 0) == 56);
-      CHECK(rng3(a, sa, b, 10) == 66);
-
-      auto rng4 = [](int* b1, int l1, int* b2, int i)
-      {
-        return ranges::inner_product(ranges::make_subrange(Iter1(b1), Sent1(b1+l1)),
-                                    ranges::make_subrange(Iter2(b2), Iter2(b2+l1)), i);
-      };
-      CHECK(rng4(a, 0, b, 0) == 0);
-      CHECK(rng4(a, 0, b, 10)  == 10);
-      CHECK(rng4(a, 1, b, 0) == 6);
-      CHECK(rng4(a, 1, b, 10) == 16);
-      CHECK(rng4(a, 2, b, 0) == 16);
-      CHECK(rng4(a, 2, b, 10) == 26);
-      CHECK(rng4(a, sa, b, 0) == 56);
-      CHECK(rng4(a, sa, b, 10) == 66);
-
-      // rng + bops:
-      auto bops = [](int* b1, int l1, int* b2, int i)
-      {
-        return ranges::inner_product(ranges::make_subrange(Iter1(b1), Sent1(b1+l1)),
-                                    ranges::make_subrange(Iter2(b2), Iter2(b2+l1)), i,
-                                    std::multiplies<int>(), std::plus<int>());
-      };
-      CHECK(bops(a, 0, b, 1) == 1);
-      CHECK(bops(a, 0, b, 10) == 10);
-      CHECK(bops(a, 1, b, 1) == 7);
-      CHECK(bops(a, 1, b, 10) == 70);
-      CHECK(bops(a, 2, b, 1) == 49);
-      CHECK(bops(a, 2, b, 10) == 490);
-      CHECK(bops(a, sa, b, 1) == 117649);
-      CHECK(bops(a, sa, b, 10) == 1176490);
-  }
-}
-
-int main()
-{
-    test<InputIterator<const int*>, InputIterator<const int*> >();
-    test<InputIterator<const int*>, ForwardIterator<const int*> >();
-    test<InputIterator<const int*>, BidirectionalIterator<const int*> >();
-    test<InputIterator<const int*>, RandomAccessIterator<const int*> >();
-    test<InputIterator<const int*>, const int*>();
-
-    test<ForwardIterator<const int*>, InputIterator<const int*> >();
-    test<ForwardIterator<const int*>, ForwardIterator<const int*> >();
-    test<ForwardIterator<const int*>, BidirectionalIterator<const int*> >();
-    test<ForwardIterator<const int*>, RandomAccessIterator<const int*> >();
-    test<ForwardIterator<const int*>, const int*>();
-
-    test<BidirectionalIterator<const int*>, InputIterator<const int*> >();
-    test<BidirectionalIterator<const int*>, ForwardIterator<const int*> >();
-    test<BidirectionalIterator<const int*>, BidirectionalIterator<const int*> >();
-    test<BidirectionalIterator<const int*>, RandomAccessIterator<const int*> >();
-    test<BidirectionalIterator<const int*>, const int*>();
-
-    test<RandomAccessIterator<const int*>, InputIterator<const int*> >();
-    test<RandomAccessIterator<const int*>, ForwardIterator<const int*> >();
-    test<RandomAccessIterator<const int*>, BidirectionalIterator<const int*> >();
-    test<RandomAccessIterator<const int*>, RandomAccessIterator<const int*> >();
-    test<RandomAccessIterator<const int*>, const int*>();
-
-    test<const int*, InputIterator<const int*> >();
-    test<const int*, ForwardIterator<const int*> >();
-    test<const int*, BidirectionalIterator<const int*> >();
-    test<const int*, RandomAccessIterator<const int*> >();
-    test<const int*, const int*>();
-
-    // test projections:
-    {
-      S a[] = {{1}, {2}, {3}, {4}, {5}, {6}};
-      S b[] = {{6}, {5}, {4}, {3}, {2}, {1}};
-      unsigned sa = sizeof(a) / sizeof(a[0]);
-
-      using Iter1 = InputIterator<const S*>;
-      using Sent1 = InputIterator<const S*>;
-      using Iter2 = Iter1;
-
-      // rng + bops:
-      auto bops = [&](S* b1, int l1, S* b2, int i)
-      {
-        return ranges::inner_product(ranges::make_subrange(Iter1(b1), Sent1(b1+l1)),
-                                     ranges::make_subrange(Iter2(b2), Iter2(b2+l1)), i,
-                                     std::multiplies<int>(), std::plus<int>(),
-                                     &S::i, &S::i);
-      };
-
-      CHECK(bops(a, 0, b, 1) == 1);
-      CHECK(bops(a, 0, b, 10) == 10);
-      CHECK(bops(a, 1, b, 1) == 7);
-      CHECK(bops(a, 1, b, 10) == 70);
-      CHECK(bops(a, 2, b, 1) == 49);
-      CHECK(bops(a, 2, b, 10) == 490);
-      CHECK(bops(a, sa, b, 1) == 117649);
-      CHECK(bops(a, sa, b, 10) == 1176490);
-    }
-
-    {
-        int a[] = {1, 2, 3, 4, 5, 6};
-        int b[] = {6, 5, 4, 3, 2, 1};
-
-        // raw array test:
-        CHECK(ranges::inner_product(a, b, 0) == 56);
-        CHECK(ranges::inner_product(a, b, 10) == 66);
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/numeric/iota.cpp b/src/contrib/range-v3-0.11.0/test/numeric/iota.cpp
deleted file mode 100644
index 58ddc6cb..00000000
--- a/src/contrib/range-v3-0.11.0/test/numeric/iota.cpp
+++ /dev/null
@@ -1,64 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Gonzalo Brito Gadeschi 2014
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-// Implementation based on the code in libc++
-//   http://http://libcxx.llvm.org/
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <range/v3/core.hpp>
-#include <range/v3/numeric/iota.hpp>
-#include <range/v3/algorithm/equal.hpp>
-#include "../simple_test.hpp"
-#include "../test_iterators.hpp"
-
-template<class Iter, class Sent = Iter>
-void test()
-{
-    int ir[] = {5, 6, 7, 8, 9};
-    constexpr auto s = ranges::size(ir);
-    {
-        int ia[] = {1, 2, 3, 4, 5};
-        ranges::iota(Iter(ia), Sent(ia + s), 5);
-        CHECK(ranges::equal(ia, ir));
-    }
-
-    {
-        int ia[] = {1, 2, 3, 4, 5};
-        auto rng = ranges::make_subrange(Iter(ia), Sent(ia + s));
-        ranges::iota(rng, 5);
-        CHECK(ranges::equal(ia, ir));
-    }
-}
-
-int main()
-{
-    test<InputIterator<int*> >();
-    test<ForwardIterator<int*> >();
-    test<BidirectionalIterator<int*> >();
-    test<RandomAccessIterator<int*> >();
-    test<int*>();
-
-    test<InputIterator<int*>, Sentinel<int*> >();
-    test<ForwardIterator<int*>, Sentinel<int*> >();
-    test<BidirectionalIterator<int*>, Sentinel<int*> >();
-    test<RandomAccessIterator<int*>, Sentinel<int*> >();
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/numeric/partial_sum.cpp b/src/contrib/range-v3-0.11.0/test/numeric/partial_sum.cpp
deleted file mode 100644
index 9f02d7d0..00000000
--- a/src/contrib/range-v3-0.11.0/test/numeric/partial_sum.cpp
+++ /dev/null
@@ -1,198 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Gonzalo Brito Gadeschi 2014
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-// Implementation based on the code in libc++
-//   http://http://libcxx.llvm.org/
-
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include <range/v3/core.hpp>
-#include <range/v3/numeric/partial_sum.hpp>
-#include <range/v3/view/zip.hpp>
-#include "../simple_test.hpp"
-#include "../test_iterators.hpp"
-
-struct S
-{
-    int i;
-};
-
-template<class InIter, class OutIter, class InSent = InIter> void test()
-{
-    using ranges::partial_sum;
-    using ranges::make_subrange;
-    { // iterator
-        int ir[] = {1, 3, 6, 10, 15};
-        const unsigned s = sizeof(ir) / sizeof(ir[0]);
-        int ia[] = {1, 2, 3, 4, 5};
-        int ib[s] = {0};
-        auto r = partial_sum(InIter(ia), InSent(ia + s), OutIter(ib));
-        CHECK(base(r.in) == ia + s);
-        CHECK(base(r.out) == ib + s);
-        for(unsigned i = 0; i < s; ++i)
-        {
-            CHECK(ib[i] == ir[i]);
-        }
-    }
-
-    { // range + output iterator
-        int ir[] = {1, 3, 6, 10, 15};
-        const unsigned s = sizeof(ir) / sizeof(ir[0]);
-        int ia[] = {1, 2, 3, 4, 5};
-        int ib[s] = {0};
-        auto rng = make_subrange(InIter(ia), InSent(ia + s));
-        auto r = partial_sum(rng, OutIter(ib));
-        CHECK(base(r.in) == ia + s);
-        CHECK(base(r.out) == ib + s);
-        for(unsigned i = 0; i < s; ++i)
-        {
-            CHECK(ib[i] == ir[i]);
-        }
-    }
-
-    { // range + output range
-        int ir[] = {1, 3, 6, 10, 15};
-        const unsigned s = sizeof(ir) / sizeof(ir[0]);
-        int ia[] = {1, 2, 3, 4, 5};
-        int ib[s] = {0};
-        auto rng = make_subrange(InIter(ia), InSent(ia + s));
-        auto orng = make_subrange(OutIter(ib), OutIter(ib + s));
-        auto r = partial_sum(rng, orng);
-        CHECK(base(r.in) == ia + s);
-        CHECK(base(r.out) == ib + s);
-        for(unsigned i = 0; i < s; ++i)
-        {
-            CHECK(ib[i] == ir[i]);
-        }
-    }
-
-    {
-        int ia[] = {1, 2, 3, 4, 5};
-        int ir[] = {1, -1, -4, -8, -13};
-        const unsigned s = sizeof(ia) / sizeof(ia[0]);
-        int ib[s] = {0};
-        auto rng = make_subrange(InIter(ia), InSent(ia + s));
-        auto orng = make_subrange(OutIter(ib), OutIter(ib + s));
-        auto r = partial_sum(rng, orng, std::minus<int>());
-        CHECK(base(r.in) == ia + s);
-        CHECK(base(r.out) == ib + s);
-        for(unsigned i = 0; i < s; ++i)
-        {
-            CHECK(ib[i] == ir[i]);
-        }
-    }
-}
-
-int main()
-{
-    test<InputIterator<const int *>, InputIterator<int *>>();
-    test<InputIterator<const int *>, ForwardIterator<int *>>();
-    test<InputIterator<const int *>, BidirectionalIterator<int *>>();
-    test<InputIterator<const int *>, RandomAccessIterator<int *>>();
-    test<InputIterator<const int *>, int *>();
-
-    test<ForwardIterator<const int *>, InputIterator<int *>>();
-    test<ForwardIterator<const int *>, ForwardIterator<int *>>();
-    test<ForwardIterator<const int *>, BidirectionalIterator<int *>>();
-    test<ForwardIterator<const int *>, RandomAccessIterator<int *>>();
-    test<ForwardIterator<const int *>, int *>();
-
-    test<BidirectionalIterator<const int *>, InputIterator<int *>>();
-    test<BidirectionalIterator<const int *>, ForwardIterator<int *>>();
-    test<BidirectionalIterator<const int *>, BidirectionalIterator<int *>>();
-    test<BidirectionalIterator<const int *>, RandomAccessIterator<int *>>();
-    test<BidirectionalIterator<const int *>, int *>();
-
-    test<RandomAccessIterator<const int *>, InputIterator<int *>>();
-    test<RandomAccessIterator<const int *>, ForwardIterator<int *>>();
-    test<RandomAccessIterator<const int *>, BidirectionalIterator<int *>>();
-    test<RandomAccessIterator<const int *>, RandomAccessIterator<int *>>();
-    test<RandomAccessIterator<const int *>, int *>();
-
-    test<const int *, InputIterator<int *>>();
-    test<const int *, ForwardIterator<int *>>();
-    test<const int *, BidirectionalIterator<int *>>();
-    test<const int *, RandomAccessIterator<int *>>();
-    test<const int *, int *>();
-
-    using ranges::partial_sum;
-
-    { // Test projections
-        S ia[] = {{1}, {2}, {3}, {4}, {5}};
-        int ir[] = {1, 3, 6, 10, 15};
-        const unsigned s = sizeof(ir) / sizeof(ir[0]);
-        int ib[s] = {0};
-        auto r = partial_sum(ranges::begin(ia), ranges::begin(ia) + s, ranges::begin(ib),
-                             std::plus<int>(), &S::i);
-        CHECK(base(r.in) == ia + s);
-        CHECK(base(r.out) == ib + s);
-        for(unsigned i = 0; i < s; ++i)
-        {
-            CHECK(ib[i] == ir[i]);
-        }
-    }
-
-    { // Test BinaryOp
-        int ia[] = {1, 2, 3, 4, 5};
-        int ir[] = {1, 2, 6, 24, 120};
-        const unsigned s = sizeof(ir) / sizeof(ir[0]);
-        int ib[s] = {0};
-        auto r = partial_sum(ia, ranges::begin(ib), std::multiplies<int>());
-        CHECK(base(r.in) == ia + s);
-        CHECK(base(r.out) == ib + s);
-        for(unsigned i = 0; i < s; ++i)
-        {
-            CHECK(ib[i] == ir[i]);
-        }
-    }
-
-    { // Test calling it with an array
-        int ia[] = {1, 2, 3, 4, 5};
-        int ir[] = {1, 2, 6, 24, 120};
-        const unsigned s = sizeof(ir) / sizeof(ir[0]);
-        int ib[s] = {0};
-        auto r = partial_sum(ia, ib, std::multiplies<int>());
-        CHECK(base(r.in) == ia + s);
-        CHECK(base(r.out) == ib + s);
-        for(unsigned i = 0; i < s; ++i)
-        {
-            CHECK(ib[i] == ir[i]);
-        }
-    }
-
-    { // Test calling it with proxy iterators
-        using namespace ranges;
-        int ia[] = {1, 2, 3, 4, 5};
-        int ib[] = {99, 99, 99, 99, 99};
-        int ir[] = {1, 2, 6, 24, 120};
-        const unsigned s = sizeof(ir) / sizeof(ir[0]);
-        int ic[s] = {0};
-        auto rng = views::zip(ia, ib);
-        using CR = iter_common_reference_t<iterator_t<decltype(rng)>>;
-        auto r = partial_sum(rng, ic, std::multiplies<int>(), [](CR p) {return p.first;});
-        CHECK(base(r.in) == ranges::begin(rng) + s);
-        CHECK(base(r.out) == ic + s);
-        for(unsigned i = 0; i < s; ++i)
-        {
-            CHECK(ic[i] == ir[i]);
-        }
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/range/CMakeLists.txt b/src/contrib/range-v3-0.11.0/test/range/CMakeLists.txt
deleted file mode 100644
index a529c91a..00000000
--- a/src/contrib/range-v3-0.11.0/test/range/CMakeLists.txt
+++ /dev/null
@@ -1,6 +0,0 @@
-set(CMAKE_FOLDER "${CMAKE_FOLDER}/range")
-
-rv3_add_test(test.range.access range.access access.cpp)
-rv3_add_test(test.range.conversion range.conversion conversion.cpp)
-rv3_add_test(test.range.index range.index index.cpp)
-rv3_add_test(test.range.operations range.operations operations.cpp)
diff --git a/src/contrib/range-v3-0.11.0/test/range/access.cpp b/src/contrib/range-v3-0.11.0/test/range/access.cpp
deleted file mode 100644
index 634b342c..00000000
--- a/src/contrib/range-v3-0.11.0/test/range/access.cpp
+++ /dev/null
@@ -1,316 +0,0 @@
-// Range v3 library
-//
-//  Copyright Casey Carter 2016
-//  Copyright Eric Niebler 2018
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/view/subrange.hpp>
-#include <range/v3/view/ref.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/algorithm/find.hpp>
-#include <vector>
-#include "../simple_test.hpp"
-
-#if defined(__clang__)
-RANGES_DIAGNOSTIC_IGNORE("-Wunused-const-variable")
-#endif
-
-void test_range_access_ambiguity()
-{
-    std::vector<ranges::reverse_iterator<int*>> vri{};
-    using namespace ranges;
-    (void)begin(vri);
-    (void)end(vri);
-    (void)cbegin(vri);
-    (void)cend(vri);
-    (void)rbegin(vri);
-    (void)rend(vri);
-    (void)crbegin(vri);
-    (void)crend(vri);
-}
-
-void test_initializer_list()
-{
-    std::initializer_list<int> il = {0,1,2};
-    {
-        int count = 0;
-        for(auto p = ranges::begin(il), e = ranges::end(il); p != e; ++p) {
-            CHECK(*p == count++);
-        }
-    }
-    {
-        int count = 3;
-        for(auto p = ranges::rbegin(il), e = ranges::rend(il); p != e; ++p) {
-            CHECK(*p == --count);
-        }
-    }
-    CHECK(ranges::size(il) == std::size_t{3});
-    CHECK(ranges::data(il) == &*il.begin());
-    CHECK(ranges::empty(il) == false);
-}
-
-template<class Value, typename T, T... Is>
-void test_array(std::integer_sequence<T, Is...>)
-{
-    Value a[sizeof...(Is)] = { Is... };
-    {
-        int count = 0;
-        for(auto p = ranges::begin(a), e = ranges::end(a); p != e; ++p) {
-            CHECK(*p == count++);
-        }
-    }
-    {
-        int count = sizeof...(Is);
-        for(auto p = ranges::rbegin(a), e = ranges::rend(a); p != e; ++p) {
-            CHECK(*p == --count);
-        }
-    }
-    CHECK(ranges::size(a) == sizeof...(Is));
-    CHECK(ranges::data(a) == a + 0);
-    CHECK(ranges::empty(a) == false);
-}
-
-namespace begin_testing
-{
-    template<class R>
-    CPP_requires(can_begin_,
-        requires(R&& r) //
-        (
-            ranges::begin((R &&) r)
-        ));
-    template<class R>
-    CPP_concept can_begin =
-        CPP_requires_ref(can_begin_, R);
-
-    template<class R>
-    CPP_requires(can_cbegin_,
-        requires(R&& r) //
-        (
-            ranges::cbegin((R &&) r)
-        ));
-    template<class R>
-    CPP_concept can_cbegin =
-        CPP_requires_ref(can_cbegin_, R);
-
-    struct A
-    {
-        int* begin();
-        int* end();
-        int const * begin() const;
-        int const * end() const;
-    };
-
-    struct B : A {};
-    void* begin(B&);
-
-    struct C : A {};
-    void begin(C&);
-
-    struct D : A {};
-    char* begin(D&);
-
-    void test()
-    {
-        // Valid
-        CPP_assert(can_begin<int(&)[2]>);
-        CPP_assert(ranges::same_as<decltype(ranges::begin(std::declval<int(&)[2]>())), int*>);
-        CPP_assert(can_begin<int const(&)[2]>);
-        CPP_assert(ranges::same_as<decltype(ranges::begin(std::declval<int const(&)[2]>())), int const *>);
-
-        CPP_assert(can_cbegin<int(&)[2]>);
-        CPP_assert(ranges::same_as<decltype(ranges::cbegin(std::declval<int(&)[2]>())), int const *>);
-        CPP_assert(can_cbegin<int const(&)[2]>);
-        CPP_assert(ranges::same_as<decltype(ranges::cbegin(std::declval<int const(&)[2]>())), int const *>);
-
-#ifndef RANGES_WORKAROUND_MSVC_573728
-        // Ill-formed: array rvalue
-        CPP_assert(!can_begin<int(&&)[2]>);
-        CPP_assert(!can_begin<int const(&&)[2]>);
-
-        CPP_assert(!can_cbegin<int(&&)[2]>);
-        CPP_assert(!can_cbegin<int const(&&)[2]>);
-#endif // RANGES_WORKAROUND_MSVC_573728
-
-        // Valid: only member begin
-        CPP_assert(can_begin<A&>);
-        CPP_assert(!can_begin<A>);
-        CPP_assert(ranges::same_as<decltype(ranges::begin(std::declval<A&>())), int*>);
-        CPP_assert(can_begin<const A&>);
-        CPP_assert(!can_begin<const A>);
-        CPP_assert(ranges::same_as<decltype(ranges::begin(std::declval<const A&>())), int const *>);
-
-        // Valid: Both member and non-member begin, but non-member returns non-Iterator.
-        CPP_assert(can_begin<B&>);
-        CPP_assert(!can_begin<B>);
-        CPP_assert(ranges::same_as<decltype(ranges::begin(std::declval<B&>())), int*>);
-        CPP_assert(can_begin<const B&>);
-        CPP_assert(!can_begin<const B>);
-        CPP_assert(ranges::same_as<decltype(ranges::begin(std::declval<const B&>())), int const *>);
-
-        // Valid: Both member and non-member begin, but non-member returns non-Iterator.
-        CPP_assert(can_begin<C&>);
-        CPP_assert(!can_begin<C>);
-        CPP_assert(can_begin<const C&>);
-        CPP_assert(!can_begin<const C>);
-
-        // Valid: Prefer member begin
-        CPP_assert(can_begin<D&>);
-        CPP_assert(!can_begin<D>);
-        CPP_assert(ranges::same_as<int*, decltype(ranges::begin(std::declval<D&>()))>);
-        CPP_assert(can_begin<const D&>);
-        CPP_assert(!can_begin<const D>);
-        CPP_assert(ranges::same_as<int const *, decltype(ranges::begin(std::declval<const D&>()))>);
-
-        {
-            using T = std::initializer_list<int>;
-            // Valid: begin accepts lvalue initializer_list
-            CPP_assert(ranges::same_as<int const *, decltype(ranges::begin(std::declval<T&>()))>);
-            CPP_assert(ranges::same_as<int const *, decltype(ranges::begin(std::declval<const T&>()))>);
-            CPP_assert(!can_begin<T>);
-            CPP_assert(!can_begin<T const>);
-        }
-
-        CPP_assert(can_begin<ranges::subrange<int*, int*>&>);
-        CPP_assert(can_begin<const ranges::subrange<int*, int*>&>);
-        CPP_assert(can_begin<ranges::subrange<int*, int*>>);
-        CPP_assert(can_begin<const ranges::subrange<int*, int*>>);
-
-        CPP_assert(can_cbegin<ranges::subrange<int*, int*>&>);
-        CPP_assert(can_cbegin<const ranges::subrange<int*, int*>&>);
-        CPP_assert(can_cbegin<ranges::subrange<int*, int*>>);
-        CPP_assert(can_cbegin<const ranges::subrange<int*, int*>>);
-
-        CPP_assert(can_begin<ranges::ref_view<int[5]>&>);
-        CPP_assert(can_begin<const ranges::ref_view<int[5]>&>);
-        CPP_assert(can_begin<ranges::ref_view<int[5]>>);
-        CPP_assert(can_begin<const ranges::ref_view<int[5]>>);
-
-        CPP_assert(can_cbegin<ranges::ref_view<int[5]>&>);
-        CPP_assert(can_cbegin<const ranges::ref_view<int[5]>&>);
-        CPP_assert(can_cbegin<ranges::ref_view<int[5]>>);
-        CPP_assert(can_cbegin<const ranges::ref_view<int[5]>>);
-
-        // TODO
-        // CPP_assert(can_begin<ranges::iota_view<int, int>&>);
-        // CPP_assert(can_begin<const ranges::iota_view<int, int>&>);
-        // CPP_assert(can_begin<ranges::iota_view<int, int>>);
-        // CPP_assert(can_begin<const ranges::iota_view<int, int>>);
-
-        // CPP_assert(can_cbegin<ranges::iota_view<int, int>&>);
-        // CPP_assert(can_cbegin<const ranges::iota_view<int, int>&>);
-        // CPP_assert(can_cbegin<ranges::iota_view<int, int>>);
-        // CPP_assert(can_cbegin<const ranges::iota_view<int, int>>);
-    }
-} // namespace begin_testing
-
-namespace X
-{
-    template<class T, std::size_t N>
-    struct array
-    {
-        T elements_[N];
-
-        constexpr bool empty() const noexcept { return N == 0; }
-        constexpr T* data() noexcept { return elements_; }
-        constexpr T const *data() const noexcept { return elements_; }
-    };
-
-    template<class T, std::size_t N>
-    constexpr T* begin(array<T, N> &a) noexcept { return a.elements_; }
-    template<class T, std::size_t N>
-    constexpr T* end(array<T, N> &a) noexcept { return a.elements_ + N; }
-    template<class T, std::size_t N>
-    constexpr T const *begin(array<T, N> const &a) noexcept { return a.elements_; }
-    template<class T, std::size_t N>
-    constexpr T const *end(array<T, N> const &a) noexcept { return a.elements_ + N; }
-} // namespace X
-
-using I = int*;
-using CI = int const *;
-CPP_assert(ranges::input_or_output_iterator<I>);
-CPP_assert(ranges::input_or_output_iterator<CI>);
-
-#if defined(__cpp_lib_string_view) && __cpp_lib_string_view > 0
-void test_string_view_p0970()
-{
-    // basic_string_views are non-dangling
-    using I2 = ranges::iterator_t<std::string_view>;
-    CPP_assert(ranges::same_as<I2, decltype(ranges::begin(std::declval<std::string_view>()))>);
-    CPP_assert(ranges::same_as<I2, decltype(ranges::end(std::declval<std::string_view>()))>);
-    CPP_assert(ranges::same_as<I2, decltype(ranges::begin(std::declval<const std::string_view>()))>);
-    CPP_assert(ranges::same_as<I2, decltype(ranges::end(std::declval<const std::string_view>()))>);
-
-    {
-        const char hw[] = "Hello, World!";
-        auto result = ranges::find(std::string_view{hw}, 'W');
-        CPP_assert(ranges::same_as<I2, decltype(result)>);
-        CHECK(result == std::string_view{hw}.begin() + 7);
-    }
-}
-#endif
-
-int main()
-{
-    using namespace ranges;
-
-    static constexpr X::array<int, 4> some_ints = {{0,1,2,3}};
-    CPP_assert(begin_testing::can_begin<X::array<int, 4> &>);
-    CPP_assert(begin_testing::can_begin<X::array<int, 4> const &>);
-    CPP_assert(!begin_testing::can_begin<X::array<int, 4>>);
-    CPP_assert(!begin_testing::can_begin<X::array<int, 4> const>);
-    CPP_assert(begin_testing::can_cbegin<X::array<int, 4> &>);
-    CPP_assert(begin_testing::can_cbegin<X::array<int, 4> const &>);
-    CPP_assert(!begin_testing::can_cbegin<X::array<int, 4>>);
-    CPP_assert(!begin_testing::can_cbegin<X::array<int, 4> const>);
-
-    constexpr auto first = begin(some_ints);
-    constexpr auto last = end(some_ints);
-    CPP_assert(ranges::same_as<const CI, decltype(first)>);
-    CPP_assert(ranges::same_as<const CI, decltype(last)>);
-    static_assert(first == cbegin(some_ints), "");
-    static_assert(last == cend(some_ints), "");
-
-    static_assert(noexcept(begin(some_ints)), "");
-    static_assert(noexcept(end(some_ints)), "");
-    static_assert(noexcept(cbegin(some_ints)), "");
-    static_assert(noexcept(cend(some_ints)), "");
-    static_assert(noexcept(empty(some_ints)), "");
-    static_assert(noexcept(data(some_ints)), "");
-
-    constexpr bool output = false;
-    static_assert(!empty(some_ints), "");
-    if(output)
-        std::cout << '{';
-    auto is_first = true;
-    auto count = 0;
-    for(auto&& i : some_ints)
-    {
-        CHECK(i == count++);
-        if(is_first)
-            is_first = false;
-        else
-            if(output) std::cout << ", ";
-        if(output) std::cout << i;
-    }
-    if(output)
-        std::cout << "}\n";
-
-    test_initializer_list();
-    test_array<int>(std::make_integer_sequence<int, 3>{});
-    test_array<int const>(std::make_integer_sequence<int, 3>{});
-    begin_testing::test();
-
-#if defined(__cpp_lib_string_view) && __cpp_lib_string_view > 0
-    test_string_view_p0970();
-#endif
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/range/conversion.cpp b/src/contrib/range-v3-0.11.0/test/range/conversion.cpp
deleted file mode 100644
index dd17b245..00000000
--- a/src/contrib/range-v3-0.11.0/test/range/conversion.cpp
+++ /dev/null
@@ -1,217 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <list>
-#include <map>
-#include <vector>
-
-#include <range/v3/action/sort.hpp>
-#include <range/v3/core.hpp>
-#include <range/v3/range/conversion.hpp>
-#include <range/v3/view/indices.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/take.hpp>
-#include <range/v3/view/transform.hpp>
-#include <range/v3/view/zip.hpp>
-#include <range/v3/view/reverse.hpp>
-
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-template<typename T>
-struct vector_like
-{
-private:
-    std::vector<T> data_;
-public:
-    using size_type = std::size_t;
-    using allocator_type = std::allocator<T>;
-
-    vector_like() = default;
-    template<typename I>
-    vector_like(I first, I last)
-      : data_(first, last)
-    {}
-    template<typename I>
-    void assign(I first, I last)
-    {
-        data_.assign(first, last);
-    }
-
-    auto begin()
-    {
-        return data_.begin();
-    }
-    auto end()
-    {
-        return data_.end();
-    }
-    auto begin() const
-    {
-        return data_.begin();
-    }
-    auto end() const
-    {
-        return data_.end();
-    }
-    size_type size() const
-    {
-        return data_.size();
-    }
-    size_type capacity() const
-    {
-        return data_.capacity();
-    }
-    size_type max_size() const
-    {
-        return data_.max_size();
-    }
-    auto& operator[](size_type n)
-    {
-        return data_[n];
-    }
-    auto& operator[](size_type n) const
-    {
-        return data_[n];
-    }
-
-    size_type last_reservation{};
-    size_type reservation_count{};
-
-    void reserve(size_type n)
-    {
-        data_.reserve(n);
-        last_reservation = n;
-        ++reservation_count;
-    }
-};
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-template<typename I>
-vector_like(I, I) -> vector_like<ranges::iter_value_t<I>>;
-
-template<typename Rng, typename CI = ranges::range_common_iterator_t<Rng>,
-         typename = decltype(std::map{CI{}, CI{}})>
-void test_zip_to_map(Rng && rng, int)
-{
-    using namespace ranges;
-#ifdef RANGES_WORKAROUND_MSVC_779708
-    auto m = static_cast<Rng &&>(rng) | to<std::map>();
-#else  // ^^^ workaround / no workaround vvv
-    auto m = static_cast<Rng &&>(rng) | to<std::map>;
-#endif // RANGES_WORKAROUND_MSVC_779708
-    CPP_assert(same_as<decltype(m), std::map<int, int>>);
-}
-#endif
-template<typename Rng>
-void test_zip_to_map(Rng &&, long)
-{}
-
-int main()
-{
-    using namespace ranges;
-
-    {
-        auto lst0 = views::ints | views::transform([](int i) { return i * i; }) |
-                    views::take(10) | to<std::list>();
-        CPP_assert(same_as<decltype(lst0), std::list<int>>);
-        ::check_equal(lst0, {0, 1, 4, 9, 16, 25, 36, 49, 64, 81});
-    }
-
-#ifndef RANGES_WORKAROUND_MSVC_779708 // "workaround" is a misnomer; there's no
-                                      // workaround.
-    {
-        auto lst1 = views::ints | views::transform([](int i) { return i * i; }) |
-                    views::take(10) | to<std::list>;
-        CPP_assert(same_as<decltype(lst1), std::list<int>>);
-        ::check_equal(lst1, {0, 1, 4, 9, 16, 25, 36, 49, 64, 81});
-    }
-#endif // RANGES_WORKAROUND_MSVC_779708
-
-    {
-        auto vec0 = views::ints | views::transform([](int i) { return i * i; }) |
-                    views::take(10) | to_vector | actions::sort(std::greater<int>{});
-        CPP_assert(same_as<decltype(vec0), std::vector<int>>);
-        ::check_equal(vec0, {81, 64, 49, 36, 25, 16, 9, 4, 1, 0});
-    }
-
-    {
-        auto vec1 = views::ints | views::transform([](int i) { return i * i; }) |
-                    views::take(10) | to<std::vector<long>>() |
-                    actions::sort(std::greater<long>{});
-        CPP_assert(same_as<decltype(vec1), std::vector<long>>);
-        ::check_equal(vec1, {81, 64, 49, 36, 25, 16, 9, 4, 1, 0});
-    }
-
-#ifndef RANGES_WORKAROUND_MSVC_779708
-    {
-        auto vec2 = views::ints | views::transform([](int i) { return i * i; }) |
-                    views::take(10) | to<std::vector<long>> |
-                    actions::sort(std::greater<long>{});
-        CPP_assert(same_as<decltype(vec2), std::vector<long>>);
-        ::check_equal(vec2, {81, 64, 49, 36, 25, 16, 9, 4, 1, 0});
-    }
-#endif // RANGES_WORKAROUND_MSVC_779708
-
-    {
-        const std::size_t N = 4096;
-        auto vl = views::iota(0, int{N}) | to<vector_like<int>>();
-        CPP_assert(same_as<decltype(vl), vector_like<int>>);
-        CHECK(vl.reservation_count == std::size_t{1});
-        CHECK(vl.last_reservation == N);
-    }
-
-    // https://github.com/ericniebler/range-v3/issues/1145
-    {
-        auto r1 = views::indices(std::uintmax_t{100});
-        auto r2 = views::zip(r1, r1);
-
-#ifdef RANGES_WORKAROUND_MSVC_779708
-        auto m = r2 | ranges::to<std::map<std::uintmax_t, std::uintmax_t>>();
-#else // ^^^ workaround / no workaround vvv
-        auto m = r2 | ranges::to<std::map<std::uintmax_t, std::uintmax_t>>;
-#endif // RANGES_WORKAROUND_MSVC_779708
-        CPP_assert(same_as<decltype(m), std::map<std::uintmax_t, std::uintmax_t>>);
-    }
-
-    // Transform a range-of-ranges into a container of containers
-    {
-        auto r = views::ints(1, 4) |
-                 views::transform([](int i) { return views::ints(i, i + 3); });
-
-        auto m = r | ranges::to<std::vector<std::vector<int>>>();
-        CPP_assert(same_as<decltype(m), std::vector<std::vector<int>>>);
-        CHECK(m.size() == 3u);
-        check_equal(m[0], {1, 2, 3});
-        check_equal(m[1], {2, 3, 4});
-        check_equal(m[2], {3, 4, 5});
-    }
-
-    // Use ranges::to in a closure with an action
-    {
-#ifdef RANGES_WORKAROUND_MSVC_779708
-        auto closure = ranges::to<std::vector>() | actions::sort;
-#else // ^^^ workaround / no workaround vvv
-        auto closure = ranges::to<std::vector> | actions::sort;
-#endif // RANGES_WORKAROUND_MSVC_779708
-
-        auto r = views::ints(1, 4) | views::reverse;
-        auto m = r | closure;
-
-        CPP_assert(same_as<decltype(m), std::vector<int>>);
-        CHECK(m.size() == 3u);
-        check_equal(m, {1, 2, 3});
-    }
-
-    test_zip_to_map(views::zip(views::ints, views::iota(0, 10)), 0);
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/range/index.cpp b/src/contrib/range-v3-0.11.0/test/range/index.cpp
deleted file mode 100644
index 70c482c6..00000000
--- a/src/contrib/range-v3-0.11.0/test/range/index.cpp
+++ /dev/null
@@ -1,132 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Gonzalo Brito Gadeschi 2017
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <vector>
-#include <range/v3/algorithm/equal.hpp>
-#include <range/v3/view/c_str.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/core.hpp>
-#include "../simple_test.hpp"
-
-int main()
-{
-    {
-        std::vector<int> vi{1,2,3,4};
-        CHECK(ranges::index(vi, 0) == 1);
-        CHECK(ranges::index(vi, 1) == 2);
-        CHECK(ranges::index(vi, 2) == 3);
-        CHECK(ranges::index(vi, 3) == 4);
-
-        CHECK(ranges::at(vi, 0) == 1);
-        CHECK(ranges::at(vi, 1) == 2);
-        CHECK(ranges::at(vi, 2) == 3);
-        CHECK(ranges::at(vi, 3) == 4);
-
-        try
-        {
-            ranges::at(vi, 4);
-            CHECK(false);
-        }
-        catch(std::out_of_range const& e)
-        {
-            CHECK(ranges::equal(ranges::views::c_str(e.what()),
-                                ranges::views::c_str("ranges::at")));
-        }
-
-        try
-        {
-            ranges::at(vi, -1);
-            CHECK(false);
-        }
-        catch(std::out_of_range const& e)
-        {
-            CHECK(ranges::equal(ranges::views::c_str(e.what()),
-                                ranges::views::c_str("ranges::at")));
-        }
-
-        auto viv = ranges::make_subrange(vi.begin(), vi.end());
-        CHECK(viv.at(0) == 1);
-        CHECK(viv.at(1) == 2);
-        CHECK(viv.at(2) == 3);
-        CHECK(viv.at(3) == 4);
-
-        try
-        {
-            viv.at(4);
-            CHECK(false);
-        }
-        catch(std::out_of_range const& e)
-        {
-            CHECK(ranges::equal(ranges::views::c_str(e.what()),
-                                ranges::views::c_str("view_interface::at")));
-        }
-
-        try
-        {
-            viv.at(-1);
-            CHECK(false);
-        }
-        catch(std::out_of_range const& e)
-        {
-            CHECK(ranges::equal(ranges::views::c_str(e.what()),
-                                ranges::views::c_str("view_interface::at")));
-        }
-
-        const auto cviv = viv;
-        CHECK(cviv.at(0) == 1);
-        CHECK(cviv.at(1) == 2);
-        CHECK(cviv.at(2) == 3);
-        CHECK(cviv.at(3) == 4);
-
-        try
-        {
-            cviv.at(4);
-            CHECK(false);
-        }
-        catch(std::out_of_range const& e)
-        {
-            CHECK(ranges::equal(ranges::views::c_str(e.what()),
-                                ranges::views::c_str("view_interface::at")));
-        }
-
-        try
-        {
-            cviv.at(-1);
-            CHECK(false);
-        }
-        catch(std::out_of_range const& e)
-        {
-            CHECK(ranges::equal(ranges::views::c_str(e.what()),
-                                ranges::views::c_str("view_interface::at")));
-        }
-    }
-
-    {
-        auto rng = ranges::views::ints(std::int64_t{0}, std::numeric_limits<std::int64_t>::max());
-        CHECK(ranges::index(rng, std::numeric_limits<std::int64_t>::max() - 1) ==
-              std::numeric_limits<std::int64_t>::max() - 1);
-        CHECK(ranges::at(rng, std::numeric_limits<std::int64_t>::max() - 1) ==
-              std::numeric_limits<std::int64_t>::max() - 1);
-    }
-
-    #if RANGES_CXX_CONSTEXPR >= RANGES_CXX_CONSTEXPR_14
-    {
-        constexpr int vi[4] = {1, 2, 3, 4};
-        constexpr int vi0 = ranges::index(vi, 0);
-        static_assert(vi0 == 1, "");
-        constexpr int vi1 = ranges::at(vi, 1);
-        static_assert(vi1 == 2, "");
-    }
-    #endif
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/range/operations.cpp b/src/contrib/range-v3-0.11.0/test/range/operations.cpp
deleted file mode 100644
index 784534a1..00000000
--- a/src/contrib/range-v3-0.11.0/test/range/operations.cpp
+++ /dev/null
@@ -1,121 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Michel Morin 2014
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <forward_list>
-#include <list>
-#include <vector>
-#include <limits>
-#include <range/v3/core.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/take_while.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-template<typename I, typename S>
-void test_iterators(I first, S last, ranges::iter_difference_t<I> n)
-{
-    using namespace ranges;
-
-    CHECK(distance(first, last) == n);
-    CHECK(distance_compare(first, last, n) == 0);
-    CHECK(distance_compare(first, last, n - 1) > 0);
-    CHECK(distance_compare(first, last, n + 1) < 0);
-    CHECK(distance_compare(first, last, (std::numeric_limits<iter_difference_t<I>>::min)()) > 0);
-    CHECK(distance_compare(first, last, (std::numeric_limits<iter_difference_t<I>>::max)()) < 0);
-}
-
-template<typename Rng>
-void test_range(Rng&& rng, ranges::range_difference_t<Rng> n)
-{
-    using namespace ranges;
-
-    CHECK(distance(rng) == n);
-    CHECK(distance_compare(rng, n) == 0);
-    CHECK(distance_compare(rng, n - 1) > 0);
-    CHECK(distance_compare(rng, n + 1) < 0);
-    CHECK(distance_compare(rng, (std::numeric_limits<range_difference_t<Rng>>::min)()) > 0);
-    CHECK(distance_compare(rng, (std::numeric_limits<range_difference_t<Rng>>::max)()) < 0);
-}
-
-template<typename Rng>
-void test_infinite_range(Rng&& rng)
-{
-    using namespace ranges;
-
-    CHECK(distance_compare(rng, 0) > 0);
-    CHECK(distance_compare(rng,-1) > 0);
-    CHECK(distance_compare(rng, 1) > 0);
-    CHECK(distance_compare(rng, (std::numeric_limits<range_difference_t<Rng>>::min)()) > 0);
-    if (is_infinite<Rng>::value) {
-        // For infinite ranges that can be detected by is_infinite<Rng> traits,
-        // distance_compare can compute the result in constant time.
-        CHECK(distance_compare(rng, (std::numeric_limits<range_difference_t<Rng>>::max)()) > 0);
-    }
-    else {
-        // For other infinite ranges, comparing to a huge number might take too much time.
-        // Thus commented out the test.
-        // CHECK(distance_compare(rng, (std::numeric_limits<range_difference_t<Rng>>::max)()) > 0);
-    }
-}
-
-int main()
-{
-    using namespace ranges;
-
-    {
-        using cont_t = std::vector<int>;
-        cont_t c {1, 2, 3, 4};
-        test_range(c, 4);
-        test_iterators(c.begin(), c.end(), 4);
-
-        c.clear();
-        test_range(c, 0);
-        test_iterators(c.begin(), c.end(), 0);
-    }
-
-    {
-        using cont_t = std::list<int>;
-        cont_t c {1, 2, 3, 4};
-        test_range(c, 4);
-        test_iterators(c.begin(), c.end(), 4);
-
-        c.clear();
-        test_range(c, 0);
-        test_iterators(c.begin(), c.end(), 0);
-    }
-
-    {
-        using cont_t = std::forward_list<int>;
-        cont_t c {1, 2, 3, 4};
-        test_range(c, 4);
-        test_iterators(c.begin(), c.end(), 4);
-
-        c.clear();
-        test_range(c, 0);
-        test_iterators(c.begin(), c.end(), 0);
-    }
-
-    {
-        int a[] = {1, 2, 3, 4};
-        test_iterators(a + 4, a, -4);
-    }
-
-    {
-         test_range(views::iota(0) | views::take_while([](int i) { return i < 4; }), 4);
-    }
-
-    {
-        test_infinite_range(views::iota(0u));
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/simple_test.hpp b/src/contrib/range-v3-0.11.0/test/simple_test.hpp
deleted file mode 100644
index d4749d4d..00000000
--- a/src/contrib/range-v3-0.11.0/test/simple_test.hpp
+++ /dev/null
@@ -1,171 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-
-#ifndef RANGES_SIMPLE_TEST_HPP
-#define RANGES_SIMPLE_TEST_HPP
-
-#include <cstdlib>
-#include <utility>
-#include <iostream>
-
-namespace test_impl
-{
-    inline int &test_failures()
-    {
-        static int test_failures = 0;
-        return test_failures;
-    }
-
-    template<typename T>
-    struct streamable_base
-    {};
-
-    template<typename T>
-    std::ostream &operator<<(std::ostream &sout, streamable_base<T> const &)
-    {
-        return sout << "<non-streamable type>";
-    }
-
-    template<typename T>
-    struct streamable : streamable_base<T>
-    {
-    private:
-        T const &t_;
-    public:
-        explicit streamable(T const &t) : t_(t) {}
-        template<typename U = T>
-        friend auto operator<<(std::ostream &sout, streamable const &s) ->
-            decltype(sout << std::declval<U const &>())
-        {
-            return sout << s.t_;
-        }
-    };
-
-    template<typename T>
-    streamable<T> stream(T const &t)
-    {
-        return streamable<T>{t};
-    }
-
-    template<typename T>
-    struct R
-    {
-    private:
-        char const *filename_;
-        int lineno_;
-        char const *expr_;
-        T t_;
-        bool dismissed_ = false;
-
-        template<typename U>
-        void oops(U const &u) const
-        {
-            std::cerr
-                << "> ERROR: CHECK failed \"" << expr_ << "\"\n"
-                << "> \t" << filename_ << '(' << lineno_ << ')' << '\n';
-            if(dismissed_)
-                std::cerr
-                    << "> \tEXPECTED: " << stream(u) << "\n> \tACTUAL: " << stream(t_) << '\n';
-            ++test_failures();
-        }
-        void dismiss()
-        {
-            dismissed_ = true;
-        }
-        template<typename V = T>
-        auto eval_(int) -> decltype(!std::declval<V&>())
-        {
-            return !t_;
-        }
-        bool eval_(long)
-        {
-            return true;
-        }
-    public:
-        R(char const *filename, int lineno, char const *expr, T &&t)
-          : filename_(filename), lineno_(lineno), expr_(expr)
-          , t_(std::forward<T>(t))
-        {}
-        R(R const&) = delete;
-        ~R()
-        {
-            if(!dismissed_ && eval_(42))
-                this->oops(42);
-        }
-        template<typename U>
-        void operator==(U const &u)
-        {
-            dismiss();
-            if(!(t_ == u)) this->oops(u);
-        }
-        template<typename U>
-        void operator!=(U const &u)
-        {
-            dismiss();
-            if(!(t_ != u)) this->oops(u);
-        }
-        template<typename U>
-        void operator<(U const &u)
-        {
-            dismiss();
-            if(!(t_ < u)) this->oops(u);
-        }
-        template<typename U>
-        void operator<=(U const &u)
-        {
-            dismiss();
-            if(!(t_ <= u)) this->oops(u);
-        }
-        template<typename U>
-        void operator>(U const &u)
-        {
-            dismiss();
-            if(!(t_ > u)) this->oops(u);
-        }
-        template<typename U>
-        void operator>=(U const &u)
-        {
-            dismiss();
-            if(!(t_ >= u)) this->oops(u);
-        }
-    };
-
-    struct S
-    {
-    private:
-        char const *filename_;
-        int lineno_;
-        char const *expr_;
-    public:
-        S(char const *filename, int lineno, char const *expr)
-          : filename_(filename), lineno_(lineno), expr_(expr)
-        {}
-        template<typename T>
-        R<T> operator->*(T &&t)
-        {
-            return {filename_, lineno_, expr_, std::forward<T>(t)};
-        }
-    };
-}
-
-inline int test_result()
-{
-    return ::test_impl::test_failures() ? EXIT_FAILURE : EXIT_SUCCESS;
-}
-
-#define CHECK_LINE(file, line, ...)                                          \
-    (void)(::test_impl::S{file, line, #__VA_ARGS__} ->* __VA_ARGS__)         \
-    /**/
-
-#define CHECK(...) CHECK_LINE(__FILE__, __LINE__, __VA_ARGS__)
-
-template<class>
-struct undef;
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/test/test_iterators.hpp b/src/contrib/range-v3-0.11.0/test/test_iterators.hpp
deleted file mode 100644
index c7ccc65a..00000000
--- a/src/contrib/range-v3-0.11.0/test/test_iterators.hpp
+++ /dev/null
@@ -1,447 +0,0 @@
-//===----------------------------------------------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef RANGES_TEST_ITERATORS_HPP
-#define RANGES_TEST_ITERATORS_HPP
-
-#include <iterator>
-#include <range/v3/range/dangling.hpp>
-
-template<class It, bool Sized = false>
-class Sentinel;
-
-template<class It>
-class OutputIterator;
-
-template<class It, bool Sized = false>
-class InputIterator;
-
-template<class It, bool Sized = false>
-class ForwardIterator;
-
-template<class It, bool Sized = false>
-class BidirectionalIterator;
-
-template<class It>
-class RandomAccessIterator;
-
-
-template<class Iter, bool Sized>
-constexpr /*c++14*/ Iter base(Sentinel<Iter, Sized> i) { return i.base(); }
-
-template<class Iter>
-constexpr /*c++14*/ Iter base(OutputIterator<Iter> i) { return i.base(); }
-
-template<class Iter, bool Sized>
-constexpr /*c++14*/ Iter base(InputIterator<Iter, Sized> i) { return i.base(); }
-
-template<class Iter, bool Sized>
-constexpr /*c++14*/ Iter base(ForwardIterator<Iter, Sized> i) { return i.base(); }
-
-template<class Iter, bool Sized>
-constexpr /*c++14*/ Iter base(BidirectionalIterator<Iter, Sized> i) { return i.base(); }
-
-template<class Iter>
-constexpr /*c++14*/ Iter base(RandomAccessIterator<Iter> i) { return i.base(); }
-
-template<class Iter>    // everything else
-constexpr /*c++14*/ Iter base(Iter i) { return i; }
-
-
-template<class It, bool Sized>
-class Sentinel
-{
-    It it_;
-public:
-    constexpr /*c++14*/ Sentinel() : it_() {}
-    constexpr /*c++14*/ explicit Sentinel(It it) : it_(it) {}
-    constexpr /*c++14*/ It base() const { return it_; }
-    constexpr /*c++14*/ friend bool operator==(const Sentinel& x, const Sentinel& y)
-    {
-        RANGES_ENSURE(x.it_ == y.it_);
-        return true;
-    }
-    constexpr /*c++14*/ friend bool operator!=(const Sentinel& x, const Sentinel& y)
-    {
-        RANGES_ENSURE(x.it_ == y.it_);
-        return false;
-    }
-    template<typename I>
-    constexpr /*c++14*/ friend bool operator==(const I& x, const Sentinel& y)
-    {
-        using ::base;
-        return base(x) == y.it_;
-    }
-    template<typename I>
-    constexpr /*c++14*/ friend bool operator!=(const I& x, const Sentinel& y)
-    {
-        return !(x == y);
-    }
-    template<typename I>
-    constexpr /*c++14*/ friend bool operator==(const Sentinel& x, const I& y)
-    {
-        using ::base;
-        return x.it_ == base(y);
-    }
-    template<typename I>
-    constexpr /*c++14*/ friend bool operator!=(const Sentinel& x, const I& y)
-    {
-        return !(x == y);
-    }
-};
-
-// For making sized iterator ranges:
-template<template<typename> class I, typename It>
-constexpr /*c++14*/
-auto CPP_auto_fun(operator-)(Sentinel<It, true> last, I<It> first)
-(
-    return base(last) - base(first)
-)
-template<template<typename> class I, typename It>
-constexpr /*c++14*/
-auto CPP_auto_fun(operator-)(I<It> first, Sentinel<It, true> last)
-(
-    return base(first) - base(last)
-)
-
-template<class It>
-class OutputIterator
-{
-    It it_;
-
-    template<class U> friend class OutputIterator;
-public:
-    typedef          std::output_iterator_tag                  iterator_category;
-    typedef void                                               value_type;
-    typedef typename std::iterator_traits<It>::difference_type difference_type;
-    typedef It                                                 pointer;
-    typedef typename std::iterator_traits<It>::reference       reference;
-
-    constexpr /*c++14*/ It base() const {return it_;}
-
-    constexpr /*c++14*/ OutputIterator () {}
-    constexpr /*c++14*/ explicit OutputIterator(It it) : it_(it) {}
-    template<class U, class = typename std::enable_if<std::is_convertible<U, It>{}>::type>
-    constexpr /*c++14*/
-    OutputIterator(const OutputIterator<U>& u) :it_(u.it_) {}
-
-    constexpr /*c++14*/ reference operator*() const {return *it_;}
-
-    constexpr /*c++14*/ OutputIterator& operator++() {++it_; return *this;}
-    constexpr /*c++14*/ OutputIterator operator++(int)
-    {OutputIterator tmp(*this); ++(*this); return tmp;}
-};
-
-template<class It, bool Sized>
-class InputIterator
-{
-    It it_;
-
-    template<class, bool> friend class InputIterator;
-public:
-    typedef          std::input_iterator_tag                   iterator_category;
-    typedef typename std::iterator_traits<It>::value_type      value_type;
-    typedef typename std::iterator_traits<It>::difference_type difference_type;
-    typedef It                                                 pointer;
-    typedef typename std::iterator_traits<It>::reference       reference;
-
-    constexpr /*c++14*/ It base() const {return it_;}
-
-    constexpr /*c++14*/ InputIterator() : it_() {}
-    constexpr /*c++14*/ explicit InputIterator(It it) : it_(it) {}
-    template<class U, bool USized>
-    constexpr /*c++14*/ CPP_ctor(InputIterator)(const InputIterator<U, USized>& u)(
-        requires (std::is_convertible<U, It>::value)) :it_(u.it_) {}
-
-    constexpr /*c++14*/ reference operator*() const {return *it_;}
-    constexpr /*c++14*/ pointer operator->() const {return it_;}
-
-    constexpr /*c++14*/ InputIterator& operator++() {++it_; return *this;}
-    constexpr /*c++14*/ InputIterator operator++(int)
-        {InputIterator tmp(*this); ++(*this); return tmp;}
-
-    constexpr /*c++14*/
-    friend bool operator==(const InputIterator& x, const InputIterator& y)
-        {return x.it_ == y.it_;}
-    constexpr /*c++14*/
-    friend bool operator!=(const InputIterator& x, const InputIterator& y)
-        {return !(x == y);}
-
-    template<bool B = Sized, meta::if_c<B, int> = 42>
-    constexpr /*c++14*/
-    friend difference_type operator-(const InputIterator& x, const InputIterator& y)
-        {return x.it_ - y.it_;}
-};
-
-template<class T, bool TSized, class U, bool USized>
-constexpr /*c++14*/
-bool
-operator==(const InputIterator<T, TSized>& x, const InputIterator<U, USized>& y)
-{
-    return x.base() == y.base();
-}
-
-template<class T, bool TSized, class U, bool USized>
-constexpr /*c++14*/
-bool
-operator!=(const InputIterator<T, TSized>& x, const InputIterator<U, USized>& y)
-{
-    return !(x == y);
-}
-
-template<class It, bool Sized>
-class ForwardIterator
-{
-    It it_;
-
-    template<class, bool> friend class ForwardIterator;
-public:
-    typedef          std::forward_iterator_tag                 iterator_category;
-    typedef typename std::iterator_traits<It>::value_type      value_type;
-    typedef typename std::iterator_traits<It>::difference_type difference_type;
-    typedef It                                                 pointer;
-    typedef typename std::iterator_traits<It>::reference       reference;
-
-    constexpr /*c++14*/ It base() const {return it_;}
-
-    constexpr /*c++14*/ ForwardIterator() : it_() {}
-    constexpr /*c++14*/ explicit ForwardIterator(It it) : it_(it) {}
-    template<class U, bool USized>
-    constexpr /*c++14*/ CPP_ctor(ForwardIterator)(const ForwardIterator<U, USized>& u)(
-        requires (std::is_convertible<U, It>::value)) :it_(u.it_) {}
-
-    constexpr /*c++14*/ reference operator*() const {return *it_;}
-    constexpr /*c++14*/ pointer operator->() const {return it_;}
-
-    constexpr /*c++14*/ ForwardIterator& operator++() {++it_; return *this;}
-    constexpr /*c++14*/ ForwardIterator operator++(int)
-    {ForwardIterator tmp(*this); ++(*this); return tmp;}
-
-    constexpr /*c++14*/
-    friend bool operator==(const ForwardIterator& x, const ForwardIterator& y)
-    {return x.it_ == y.it_;}
-    constexpr /*c++14*/
-    friend bool operator!=(const ForwardIterator& x, const ForwardIterator& y)
-    {return !(x == y);}
-};
-
-template<class T, bool TSized, class U, bool USized>
-constexpr /*c++14*/
-bool
-operator==(const ForwardIterator<T, TSized>& x, const ForwardIterator<U, USized>& y)
-{
-    return x.base() == y.base();
-}
-
-template<class T, bool TSized, class U, bool USized>
-constexpr /*c++14*/
-bool
-operator!=(const ForwardIterator<T, TSized>& x, const ForwardIterator<U, USized>& y)
-{
-    return !(x == y);
-}
-
-template<class It, bool Sized>
-class BidirectionalIterator
-{
-    It it_;
-
-    template<class, bool> friend class BidirectionalIterator;
-public:
-    typedef          std::bidirectional_iterator_tag           iterator_category;
-    typedef typename std::iterator_traits<It>::value_type      value_type;
-    typedef typename std::iterator_traits<It>::difference_type difference_type;
-    typedef It                                                 pointer;
-    typedef typename std::iterator_traits<It>::reference       reference;
-
-    constexpr /*c++14*/ It base() const {return it_;}
-
-    constexpr /*c++14*/ BidirectionalIterator() : it_() {}
-    constexpr /*c++14*/ explicit BidirectionalIterator(It it) : it_(it) {}
-    template<class U, bool USized>
-    constexpr /*c++14*/ CPP_ctor(BidirectionalIterator)(const BidirectionalIterator<U, USized>& u)(
-        requires (std::is_convertible<U, It>::value)) :it_(u.it_) {}
-
-    constexpr /*c++14*/ reference operator*() const {return *it_;}
-    constexpr /*c++14*/ pointer operator->() const {return it_;}
-
-    constexpr /*c++14*/ BidirectionalIterator& operator++() {++it_; return *this;}
-    constexpr /*c++14*/ BidirectionalIterator operator++(int)
-    {BidirectionalIterator tmp(*this); ++(*this); return tmp;}
-
-    constexpr /*c++14*/ BidirectionalIterator& operator--() {--it_; return *this;}
-    constexpr /*c++14*/ BidirectionalIterator operator--(int)
-    {BidirectionalIterator tmp(*this); --(*this); return tmp;}
-};
-
-template<class T, bool TSized, class U, bool USized>
-constexpr /*c++14*/
-bool
-operator==(const BidirectionalIterator<T, TSized>& x, const BidirectionalIterator<U, USized>& y)
-{
-    return x.base() == y.base();
-}
-
-template<class T, bool TSized, class U, bool USized>
-constexpr /*c++14*/
-bool
-operator!=(const BidirectionalIterator<T, TSized>& x, const BidirectionalIterator<U, USized>& y)
-{
-    return !(x == y);
-}
-
-template<class It>
-class RandomAccessIterator
-{
-    It it_;
-
-    template<class U> friend class RandomAccessIterator;
-public:
-    typedef          std::random_access_iterator_tag           iterator_category;
-    typedef typename std::iterator_traits<It>::value_type      value_type;
-    typedef typename std::iterator_traits<It>::difference_type difference_type;
-    typedef It                                                 pointer;
-    typedef typename std::iterator_traits<It>::reference       reference;
-
-    constexpr /*c++14*/ It base() const {return it_;}
-
-    constexpr /*c++14*/ RandomAccessIterator() : it_() {}
-    constexpr /*c++14*/ explicit RandomAccessIterator(It it) : it_(it) {}
-    template<class U>
-    constexpr /*c++14*/ CPP_ctor(RandomAccessIterator)(const RandomAccessIterator<U>& u)(
-        requires (std::is_convertible<U, It>::value)) :it_(u.it_) {}
-
-    constexpr /*c++14*/ reference operator*() const {return *it_;}
-    constexpr /*c++14*/ pointer operator->() const {return it_;}
-
-    constexpr /*c++14*/ RandomAccessIterator& operator++() {++it_; return *this;}
-    constexpr /*c++14*/ RandomAccessIterator operator++(int)
-    {RandomAccessIterator tmp(*this); ++(*this); return tmp;}
-
-    constexpr /*c++14*/ RandomAccessIterator& operator--() {--it_; return *this;}
-    constexpr /*c++14*/ RandomAccessIterator operator--(int)
-    {RandomAccessIterator tmp(*this); --(*this); return tmp;}
-
-    constexpr /*c++14*/
-    RandomAccessIterator& operator+=(difference_type n) {it_ += n; return *this;}
-    constexpr /*c++14*/
-    RandomAccessIterator operator+(difference_type n) const
-    {RandomAccessIterator tmp(*this); tmp += n; return tmp;}
-    constexpr /*c++14*/
-    friend RandomAccessIterator operator+(difference_type n, RandomAccessIterator x)
-    {x += n; return x;}
-    constexpr /*c++14*/
-    RandomAccessIterator& operator-=(difference_type n) {return *this += -n;}
-    constexpr /*c++14*/
-    RandomAccessIterator operator-(difference_type n) const
-    {RandomAccessIterator tmp(*this); tmp -= n; return tmp;}
-
-    constexpr /*c++14*/
-    reference operator[](difference_type n) const {return it_[n];}
-};
-
-template<class T, class U>
-constexpr /*c++14*/
-bool
-operator==(const RandomAccessIterator<T>& x, const RandomAccessIterator<U>& y)
-{
-    return x.base() == y.base();
-}
-
-template<class T, class U>
-constexpr /*c++14*/
-bool
-operator!=(const RandomAccessIterator<T>& x, const RandomAccessIterator<U>& y)
-{
-    return !(x == y);
-}
-
-template<class T, class U>
-constexpr /*c++14*/
-bool
-operator<(const RandomAccessIterator<T>& x, const RandomAccessIterator<U>& y)
-{
-    return x.base() < y.base();
-}
-
-template<class T, class U>
-constexpr /*c++14*/
-bool
-operator<=(const RandomAccessIterator<T>& x, const RandomAccessIterator<U>& y)
-{
-    return !(y < x);
-}
-
-template<class T, class U>
-constexpr /*c++14*/
-bool
-operator>(const RandomAccessIterator<T>& x, const RandomAccessIterator<U>& y)
-{
-    return y < x;
-}
-
-template<class T, class U>
-constexpr /*c++14*/
-bool
-operator>=(const RandomAccessIterator<T>& x, const RandomAccessIterator<U>& y)
-{
-    return !(x < y);
-}
-
-template<class T, class U>
-constexpr /*c++14*/
-auto CPP_auto_fun(operator-)(const RandomAccessIterator<T>& x, const RandomAccessIterator<U>& y)
-(
-    return x.base() - y.base()
-)
-
-template<typename It, bool Sized = false>
-struct sentinel_type
-{
-    using type = It;
-};
-
-template<typename T, bool Sized>
-struct sentinel_type<T*, Sized>
-{
-    using type = Sentinel<T*, Sized>;
-};
-
-template<template<typename> class I, typename It, bool Sized>
-struct sentinel_type<I<It>, Sized>
-{
-    using type = Sentinel<It, Sized>;
-};
-
-template<class I, class S>
-struct TestRange
-{
-    I first;
-    S second;
-    constexpr I begin() const { return first; }
-    constexpr S end() const { return second; }
-};
-
-template<class I, class S>
-TestRange<I, S> MakeTestRange(I i, S s)
-{
-    return {i, s};
-}
-
-template<typename T>
-constexpr bool is_dangling(T)
-{
-    return false;
-}
-constexpr bool is_dangling(::ranges::dangling)
-{
-    return true;
-}
-
-#endif  // RANGES_TEST_ITERATORS_HPP
diff --git a/src/contrib/range-v3-0.11.0/test/test_utils.hpp b/src/contrib/range-v3-0.11.0/test/test_utils.hpp
deleted file mode 100644
index e9ab0ceb..00000000
--- a/src/contrib/range-v3-0.11.0/test/test_utils.hpp
+++ /dev/null
@@ -1,338 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-
-#ifndef RANGES_TEST_UTILS_HPP
-#define RANGES_TEST_UTILS_HPP
-
-#include <algorithm>
-#include <cstring>
-#include <functional>
-#include <initializer_list>
-#include <ostream>
-
-#include <meta/meta.hpp>
-
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/view/subrange.hpp>
-
-#include "./debug_view.hpp"
-#include "./simple_test.hpp"
-#include "./test_iterators.hpp"
-
-#if defined(__clang__) || defined(__GNUC__)
-#if defined(__has_builtin)
-#if __has_builtin(__builtin_FILE) && \
-    __has_builtin(__builtin_LINE) && \
-    __has_builtin(__builtin_FUNCTION)
-#define RANGES_CXX_HAS_SLOC_BUILTINS
-#endif
-#endif
-#else
-#define RANGES_CXX_HAS_SLOC_BUILTINS
-#endif
-
-#if defined(RANGES_CXX_HAS_SLOC_BUILTINS) && defined(__has_include)
-#if __has_include(<source_location>)
-#include <source_location>
-#if __cpp_lib_source_location
-#define RANGES_HAS_SLOC 1
-using source_location = std::source_location;
-#endif
-#elif __has_include(<experimental/source_location>)
-#include <experimental/source_location>
-#if __cpp_lib_experimental_source_location
-#define RANGES_HAS_SLOC 1
-using source_location = std::experimental::source_location;
-#endif
-#endif
-#endif
-
-#ifndef RANGES_HAS_SLOC
-struct source_location
-{
-    static source_location current()
-    {
-        return {};
-    }
-};
-#define CHECK_SLOC(sloc, ...) \
-    do                        \
-    {                         \
-        (void)sloc;           \
-        CHECK(__VA_ARGS__);   \
-    } while(false)
-#else
-#define CHECK_SLOC(sloc, ...) CHECK_LINE(sloc.file_name(), (int)sloc.line(), __VA_ARGS__)
-#endif
-
-RANGES_DIAGNOSTIC_PUSH
-RANGES_DIAGNOSTIC_IGNORE_DEPRECATED_THIS_CAPTURE
-
-template<typename T, typename U>
-CPP_concept both_ranges = ranges::input_range<T> && ranges::input_range<U>;
-
-struct check_equal_fn
-{
-    CPP_template(typename T, typename U)(
-        /// \pre
-        requires(!both_ranges<T, U>))     //
-    void operator()(
-        T && actual, U && expected,
-        source_location sloc = source_location::current()) const
-    {
-        CHECK_SLOC(sloc, (T &&) actual == (U &&) expected);
-    }
-
-    CPP_template(typename Rng1, typename Rng2)(
-        /// \pre
-        requires both_ranges<Rng1, Rng2>)
-    void operator()(
-        Rng1 && actual, Rng2 && expected,
-        source_location sloc = source_location::current()) const
-    {
-        auto begin0 = ranges::begin(actual);
-        auto end0 = ranges::end(actual);
-        auto begin1 = ranges::begin(expected);
-        auto end1 = ranges::end(expected);
-        for(; begin0 != end0 && begin1 != end1; ++begin0, ++begin1)
-            (*this)(*begin0, *begin1, sloc);
-        CHECK_SLOC(sloc, begin0 == end0);
-        CHECK_SLOC(sloc, begin1 == end1);
-    }
-
-    CPP_template(typename Rng, typename Val)(
-        /// \pre
-        requires ranges::input_range<Rng>)
-    void operator()(
-        Rng && actual, std::initializer_list<Val> && expected,
-        source_location sloc = source_location::current()) const
-    {
-        (*this)(actual, expected, sloc);
-    }
-};
-
-inline namespace function_objects
-{
-    RANGES_INLINE_VARIABLE(check_equal_fn, check_equal)
-}
-
-template<typename Expected, typename Actual>
-void has_type(Actual &&)
-{
-    static_assert(std::is_same<Expected, Actual>::value, "Not the same");
-}
-
-template<ranges::cardinality Expected, 
-         typename Rng, 
-         ranges::cardinality Actual = ranges::range_cardinality<Rng>::value>
-void has_cardinality(Rng &&)
-{
-    static_assert(Actual == Expected, "Unexpected cardinality");
-}
-
-template<typename T>
-T & as_lvalue(T && t)
-{
-    return t;
-}
-
-// A simple, light-weight, non-owning reference to a type-erased function.
-template<typename Sig>
-struct function_ref;
-
-template<typename Ret, typename... Args>
-struct function_ref<Ret(Args...)>
-{
-private:
-    void const * data_{nullptr};
-    Ret (*pfun_)(void const *, Args...){nullptr};
-    template<typename Fun>
-    static Ret apply_(void const * data, Args... args)
-    {
-        return (*static_cast<Fun const *>(data))(args...);
-    }
-
-public:
-    function_ref() = default;
-    template<typename T>
-    function_ref(T const & t)
-      : data_(&t)
-      , pfun_(&apply_<T>)
-    {}
-    Ret operator()(Args... args) const
-    {
-        return (*pfun_)(data_, args...);
-    }
-};
-
-template<typename T>
-struct checker
-{
-private:
-    std::function<void(function_ref<void(T)>)> algo_;
-
-public:
-    explicit checker(std::function<void(function_ref<void(T)>)> algo)
-      : algo_(std::move(algo))
-    {}
-    void check(function_ref<void(T)> const & check) const
-    {
-        algo_(check);
-    }
-};
-
-template<bool B, typename T>
-meta::if_c<B, T, T const &> rvalue_if(T const & t)
-{
-    return t;
-}
-
-template<typename Algo, bool RvalueOK = false>
-struct test_range_algo_1
-{
-private:
-    Algo algo_;
-
-    template<typename I, typename... Rest>
-    static auto _impl(Algo algo, I first, I last, Rest &&... rest)
-        -> ::checker<decltype(algo(first, last, rest...))>
-    {
-        using S = meta::_t<sentinel_type<I>>;
-        using R = decltype(algo(first, last, rest...));
-        auto check_algo = [algo, first, last, rest...](
-                              function_ref<void(R)> const & check) {
-            check(algo(first, last, rest...));
-            check(algo(first, S{base(last)}, rest...));
-            check(
-                algo(::rvalue_if<RvalueOK>(ranges::make_subrange(first, last)), rest...));
-            check(algo(::rvalue_if<RvalueOK>(ranges::make_subrange(first, S{base(last)})),
-                       rest...));
-        };
-        return ::checker<R>{check_algo};
-    }
-
-public:
-    explicit test_range_algo_1(Algo algo)
-      : algo_(algo)
-    {}
-    template<typename I>
-    auto operator()(I first, I last) const -> ::checker<decltype(algo_(first, last))>
-    {
-        return test_range_algo_1::_impl(algo_, first, last);
-    }
-    template<typename I, typename T>
-    auto operator()(I first, I last, T t) const -> ::checker<decltype(algo_(first, last, t))>
-    {
-        return test_range_algo_1::_impl(algo_, first, last, t);
-    }
-    template<typename I, typename T, typename U>
-    auto operator()(I first, I last, T t, U u) const
-        -> ::checker<decltype(algo_(first, last, t, u))>
-    {
-        return test_range_algo_1::_impl(algo_, first, last, t, u);
-    }
-    template<typename I, typename T, typename U, typename V>
-    auto operator()(I first, I last, T t, U u, V v) const
-        -> ::checker<decltype(algo_(first, last, t, u, v))>
-    {
-        return test_range_algo_1::_impl(algo_, first, last, t, u, v);
-    }
-};
-
-template<bool RvalueOK = false, typename Algo>
-test_range_algo_1<Algo, RvalueOK> make_testable_1(Algo algo)
-{
-    return test_range_algo_1<Algo, RvalueOK>{algo};
-}
-
-template<typename Algo, bool RvalueOK1 = false, bool RvalueOK2 = false>
-struct test_range_algo_2
-{
-private:
-    Algo algo_;
-
-public:
-    explicit test_range_algo_2(Algo algo)
-      : algo_(algo)
-    {}
-    template<typename I1, typename I2, typename... Rest>
-    auto operator()(I1 begin1, I1 end1, I2 begin2, I2 end2, Rest &&... rest) const
-        -> checker<decltype(algo_(begin1, end1, begin2, end2, rest...))>
-    {
-        using S1 = meta::_t<sentinel_type<I1>>;
-        using S2 = meta::_t<sentinel_type<I2>>;
-        using R = decltype(algo_(begin1, end1, begin2, end2, rest...));
-        return checker<R>{[algo = algo_, begin1, end1, begin2, end2, rest...](
-                              function_ref<void(R)> const & check) {
-            check(algo(begin1, end1, begin2, end2, rest...));
-            check(algo(begin1, S1{base(end1)}, begin2, S2{base(end2)}, rest...));
-            check(algo(::rvalue_if<RvalueOK1>(ranges::make_subrange(begin1, end1)),
-                       ::rvalue_if<RvalueOK2>(ranges::make_subrange(begin2, end2)),
-                       rest...));
-            check(algo(
-                ::rvalue_if<RvalueOK1>(ranges::make_subrange(begin1, S1{base(end1)})),
-                ::rvalue_if<RvalueOK2>(ranges::make_subrange(begin2, S2{base(end2)})),
-                rest...));
-        }};
-    }
-};
-
-template<bool RvalueOK1 = false, bool RvalueOK2 = false, typename Algo>
-test_range_algo_2<Algo, RvalueOK1, RvalueOK2> make_testable_2(Algo algo)
-{
-    return test_range_algo_2<Algo, RvalueOK1, RvalueOK2>{algo};
-}
-
-// a simple type to test move semantics
-struct MoveOnlyString
-{
-    char const * sz_;
-
-    MoveOnlyString(char const * sz = "")
-      : sz_(sz)
-    {}
-    MoveOnlyString(MoveOnlyString && that)
-      : sz_(that.sz_)
-    {
-        that.sz_ = "";
-    }
-    MoveOnlyString(MoveOnlyString const &) = delete;
-    MoveOnlyString & operator=(MoveOnlyString && that)
-    {
-        sz_ = that.sz_;
-        that.sz_ = "";
-        return *this;
-    }
-    MoveOnlyString & operator=(MoveOnlyString const &) = delete;
-    bool operator==(MoveOnlyString const & that) const
-    {
-        return 0 == std::strcmp(sz_, that.sz_);
-    }
-    bool operator<(const MoveOnlyString & that) const
-    {
-        return std::strcmp(sz_, that.sz_) < 0;
-    }
-    bool operator!=(MoveOnlyString const & that) const
-    {
-        return !(*this == that);
-    }
-    friend std::ostream & operator<<(std::ostream & sout, MoveOnlyString const & str)
-    {
-        return sout << '"' << str.sz_ << '"';
-    }
-};
-
-RANGES_DIAGNOSTIC_POP
-
-#endif
diff --git a/src/contrib/range-v3-0.11.0/test/utility/CMakeLists.txt b/src/contrib/range-v3-0.11.0/test/utility/CMakeLists.txt
deleted file mode 100644
index f987a4d1..00000000
--- a/src/contrib/range-v3-0.11.0/test/utility/CMakeLists.txt
+++ /dev/null
@@ -1,12 +0,0 @@
-set(CMAKE_FOLDER "${CMAKE_FOLDER}/utility")
-
-rv3_add_test(test.utility.box utility.box box.cpp)
-rv3_add_test(test.utility.concepts utility.concepts concepts.cpp)
-rv3_add_test(test.utility.common_type utility.common_type common_type.cpp)
-rv3_add_test(test.utility.compare utility.compare compare.cpp)
-rv3_add_test(test.utility.functional utility.functional functional.cpp)
-rv3_add_test(test.utility.swap utility.swap swap.cpp)
-rv3_add_test(test.utility.variant utility.variant variant.cpp)
-rv3_add_test(test.utility.meta utility.meta meta.cpp)
-rv3_add_test(test.utility.scope_exit utility.scope_exit scope_exit.cpp)
-rv3_add_test(test.utility.semiregular_box utility.semiregular_box semiregular_box.cpp)
diff --git a/src/contrib/range-v3-0.11.0/test/utility/box.cpp b/src/contrib/range-v3-0.11.0/test/utility/box.cpp
deleted file mode 100644
index 7c59429b..00000000
--- a/src/contrib/range-v3-0.11.0/test/utility/box.cpp
+++ /dev/null
@@ -1,41 +0,0 @@
-// Range v3 library
-//
-//  Copyright Andrey Diduh 2019
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <range/v3/utility/compressed_pair.hpp>
-#include "../simple_test.hpp"
-
-using namespace ranges;
-
-// #https://github.com/ericniebler/range-v3/issues/1093
-void test_1093()
-{
-    struct Op {};
-    struct Op2 {};
-
-    struct payload { void* v; };
-    struct base_adaptor {};
-
-    struct RANGES_EMPTY_BASES A : base_adaptor, private box<Op, A> {};
-    struct RANGES_EMPTY_BASES B : base_adaptor, private box<Op2, B> {};
-
-    using P  = compressed_pair<A, payload>;
-    using P2 = compressed_pair<B, P>;
-
-    CHECK(sizeof(P) == sizeof(payload));
-    CHECK(sizeof(P2) == sizeof(P));
-}
-
-int main()
-{
-    test_1093();
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/utility/common_type.cpp b/src/contrib/range-v3-0.11.0/test/utility/common_type.cpp
deleted file mode 100644
index 29e7802f..00000000
--- a/src/contrib/range-v3-0.11.0/test/utility/common_type.cpp
+++ /dev/null
@@ -1,149 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <utility>
-#include <type_traits>
-#include <range/v3/utility/common_type.hpp>
-#include <range/v3/utility/common_tuple.hpp>
-
-struct B {};
-struct D : B {};
-
-struct noncopyable
-{
-    noncopyable() = default;
-    noncopyable(noncopyable const &) = delete;
-    noncopyable(noncopyable &&) = default;
-    noncopyable &operator=(noncopyable const &) = delete;
-    noncopyable &operator=(noncopyable &&) = default;
-};
-
-struct noncopyable2 : noncopyable
-{};
-
-struct X {};
-struct Y {};
-struct Z {};
-namespace concepts
-{
-    template<>
-    struct common_type<X, Y>
-    {
-        using type = Z;
-    };
-    template<>
-    struct common_type<Y, X>
-    {
-        using type = Z;
-    };
-}
-
-template<typename T>
-struct ConvTo
-{
-    operator T();
-};
-
-// Whoops, fails:
-static_assert(std::is_same<
-    ranges::common_type_t<ConvTo<int>, int>,
-    int
->::value, "");
-
-int main()
-{
-    using namespace ranges;
-    using namespace detail;
-    static_assert(std::is_same<common_reference_t<B &, D &>, B &>::value, "");
-    static_assert(std::is_same<common_reference_t<B &, D const &>, B const &>::value, "");
-    static_assert(std::is_same<common_reference_t<B &, D const &, D &>, B const &>::value, "");
-    static_assert(std::is_same<common_reference_t<B const &, D &>, B const &>::value, "");
-    static_assert(std::is_same<common_reference_t<B &, D &, B &, D &>, B &>::value, "");
-
-    static_assert(std::is_same<common_reference_t<B &&, D &&>, B &&>::value, "");
-    static_assert(std::is_same<common_reference_t<B const &&, D &&>, B const &&>::value, "");
-    static_assert(std::is_same<common_reference_t<B &&, D const &&>, B const &&>::value, "");
-
-    static_assert(std::is_same<common_reference_t<B &, D &&>, B const &>::value, "");
-    static_assert(std::is_same<common_reference_t<B &, D const &&>, B const &>::value, "");
-    static_assert(std::is_same<common_reference_t<B const &, D &&>, B const &>::value, "");
-
-    static_assert(std::is_same<common_reference_t<B &&, D &>, B const &>::value, "");
-    static_assert(std::is_same<common_reference_t<B &&, D const &>, B const &>::value, "");
-    static_assert(std::is_same<common_reference_t<B const &&, D &>, B const &>::value, "");
-
-    static_assert(std::is_same<common_reference_t<int, short>, int>::value, "");
-    static_assert(std::is_same<common_reference_t<int, short &>, int>::value, "");
-    static_assert(std::is_same<common_reference_t<int &, short &>, int>::value, "");
-    static_assert(std::is_same<common_reference_t<int &, short>, int>::value, "");
-
-    // tricky volatile reference case
-    static_assert(std::is_same<common_reference_t<int &&, int volatile &>, int>::value, "");
-    static_assert(std::is_same<common_reference_t<int volatile &, int &&>, int>::value, "");
-    static_assert(std::is_same<common_reference_t<int const volatile &&, int volatile &&>, int const volatile &&>::value, "");
-    static_assert(std::is_same<common_reference_t<int &&, int const &, int volatile &>, int const volatile &>(), "");
-
-    // Array types?? Yup!
-    static_assert(std::is_same<common_reference_t<int (&)[10], int (&&)[10]>, int const(&)[10]>::value, "");
-    static_assert(std::is_same<common_reference_t<int const (&)[10], int volatile (&)[10]>, int const volatile(&)[10]>::value, "");
-    static_assert(std::is_same<common_reference_t<int (&)[10], int (&)[11]>, int *>::value, "");
-
-    // Some tests for common_pair with common_reference
-    static_assert(std::is_same<
-        common_reference_t<std::pair<int &, int &>, common_pair<int,int> const &>,
-        common_pair<int const &, int const &>
-    >::value, "");
-
-    // BUGBUG TODO Is a workaround possible?
-#if !defined(__GNUC__) || __GNUC__ != 4 || __GNUC_MINOR__ > 8
-    static_assert(std::is_same<
-        common_reference_t<common_pair<int const &, int const &>, std::pair<int, int>>,
-        common_pair<int, int>
-    >::value, "");
-
-    static_assert(std::is_same<
-        ::concepts::detail::_builtin_common_t<common_pair<int, int> const &, std::pair<int, int> &>,
-        std::pair<int, int> const &
-    >::value, "");
-#endif
-
-    static_assert(std::is_same<
-        common_reference_t<common_pair<int, int> const &, std::pair<int, int> &>,
-        std::pair<int, int> const &
-    >::value, "");
-
-    // Some tests with noncopyable types
-    static_assert(std::is_same<
-        ::concepts::detail::_builtin_common_t<noncopyable const &, noncopyable>,
-        noncopyable
-    >::value, "");
-
-    static_assert(std::is_same<
-        ::concepts::detail::_builtin_common_t<noncopyable2 const &, noncopyable>,
-        noncopyable
-    >::value, "");
-
-    static_assert(std::is_same<
-        ::concepts::detail::_builtin_common_t<noncopyable const &, noncopyable2>,
-        noncopyable
-    >::value, "");
-
-    static_assert(std::is_same<
-        common_reference_t<X &, Y const &>,
-        Z
-    >::value, "");
-
-    {
-        // Regression test for #367
-        using CP = common_pair<int, int>;
-        CPP_assert(same_as<common_type_t<CP, CP>, CP>);
-    }
-}
diff --git a/src/contrib/range-v3-0.11.0/test/utility/compare.cpp b/src/contrib/range-v3-0.11.0/test/utility/compare.cpp
deleted file mode 100644
index f9d6205b..00000000
--- a/src/contrib/range-v3-0.11.0/test/utility/compare.cpp
+++ /dev/null
@@ -1,41 +0,0 @@
-/// \file
-//  CPP, the Concepts PreProcessor library
-//
-//  Copyright Eric Niebler 2018-present
-//  Copyright (c) 2020-present, Google LLC.
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// This source code is licensed under the MIT license found in the
-// LICENSE file in the root directory of this source tree.
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#if __cplusplus > 201703L && defined(__cpp_impl_three_way_comparison) && __has_include(<compare>)
-
-#include <compare>
-#include <range/v3/compare.hpp>
-#include <range/v3/range_fwd.hpp>
-
-using ranges::same_as;
-using ranges::common_comparison_category_t;
-
-static_assert(same_as<common_comparison_category_t<std::partial_ordering>, std::partial_ordering>);
-static_assert(same_as<common_comparison_category_t<std::weak_ordering>, std::weak_ordering>);
-static_assert(same_as<common_comparison_category_t<std::strong_ordering>, std::strong_ordering>);
-
-static_assert(same_as<common_comparison_category_t<std::partial_ordering, std::strong_ordering>, std::partial_ordering>);
-static_assert(same_as<common_comparison_category_t<std::weak_ordering, std::strong_ordering>, std::weak_ordering>);
-static_assert(same_as<common_comparison_category_t<std::strong_ordering, std::strong_ordering>, std::strong_ordering>);
-static_assert(same_as<common_comparison_category_t<std::weak_ordering, std::strong_ordering, std::partial_ordering>, std::partial_ordering>);
-
-static_assert(same_as<common_comparison_category_t<ranges::less, std::partial_ordering>, void>);
-static_assert(same_as<common_comparison_category_t<ranges::less*, std::strong_ordering>, void>);
-static_assert(same_as<common_comparison_category_t<ranges::less&, std::strong_ordering, std::partial_ordering>, void>);
-static_assert(same_as<common_comparison_category_t<ranges::less(*)(), std::strong_ordering, std::partial_ordering>, void>);
-#endif // __cplusplus
-
-int main() {}
diff --git a/src/contrib/range-v3-0.11.0/test/utility/concepts.cpp b/src/contrib/range-v3-0.11.0/test/utility/concepts.cpp
deleted file mode 100644
index 2fd6cff4..00000000
--- a/src/contrib/range-v3-0.11.0/test/utility/concepts.cpp
+++ /dev/null
@@ -1,340 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Google LLC 2020-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-//#define RANGES_USE_LEGACY_CONCEPTS 1
-
-#include <sstream>
-#include <vector>
-#include <concepts/concepts.hpp>
-#include <range/v3/iterator/concepts.hpp>
-#include <range/v3/iterator/traits.hpp>
-#include <range/v3/range/concepts.hpp>
-#include <range/v3/range/traits.hpp>
-#include <range/v3/view/istream.hpp>
-#include <range/v3/iterator/common_iterator.hpp>
-#include "../simple_test.hpp"
-
-struct moveonly
-{
-    moveonly(moveonly&&) = default;
-    moveonly& operator=(moveonly&&) = default;
-};
-
-struct nonmovable
-{
-    nonmovable(nonmovable const &) = delete;
-    nonmovable& operator=(nonmovable const &) = delete;
-};
-
-struct nondefaultconstructible
-{
-    nondefaultconstructible(int) {}
-};
-
-struct NotDestructible
-{
-    ~NotDestructible() = delete;
-};
-
-struct IntComparable
-{
-    operator int() const;
-
-    friend bool operator==(IntComparable, IntComparable);
-    friend bool operator!=(IntComparable, IntComparable);
-
-    friend bool operator<(IntComparable, IntComparable);
-    friend bool operator>(IntComparable, IntComparable);
-    friend bool operator<=(IntComparable, IntComparable);
-    friend bool operator>=(IntComparable, IntComparable);
-
-    friend bool operator==(int, IntComparable);
-    friend bool operator!=(int, IntComparable);
-    friend bool operator==(IntComparable, int);
-    friend bool operator!=(IntComparable, int);
-
-    friend bool operator<(int, IntComparable);
-    friend bool operator<(IntComparable, int);
-    friend bool operator>(int, IntComparable);
-    friend bool operator>(IntComparable, int);
-    friend bool operator<=(int, IntComparable);
-    friend bool operator<=(IntComparable, int);
-    friend bool operator>=(int, IntComparable);
-    friend bool operator>=(IntComparable, int);
-};
-
-struct IntSwappable
-{
-    operator int() const;
-
-    friend void swap(int &, IntSwappable);
-    friend void swap(IntSwappable, int &);
-    friend void swap(IntSwappable, IntSwappable);
-};
-
-static_assert(ranges::same_as<int, int>, "");
-static_assert(ranges::same_as<void, void>, "");
-static_assert(ranges::same_as<void const, void const>, "");
-static_assert(!ranges::same_as<int&, int>, "");
-static_assert(!ranges::same_as<void, void const>, "");
-static_assert(!ranges::same_as<void(), void(*)()>, "");
-
-static_assert(ranges::convertible_to<int, int>, "");
-static_assert(ranges::convertible_to<short&, short const&>, "");
-static_assert(ranges::convertible_to<int, short>, "");
-static_assert(!ranges::convertible_to<int&, short&>, "");
-static_assert(!ranges::convertible_to<int, void>, "");
-static_assert(!ranges::convertible_to<int, int&>, "");
-
-static_assert(ranges::unsigned_integral<unsigned>, "");
-static_assert(!ranges::unsigned_integral<int>, "");
-
-static_assert(ranges::assignable_from<int&, int>, "");
-static_assert(!ranges::assignable_from<int const&, int>, "");
-static_assert(!ranges::assignable_from<int, int>, "");
-
-static_assert(ranges::destructible<int>, "");
-static_assert(ranges::destructible<const int>, "");
-static_assert(!ranges::destructible<void>, "");
-static_assert(ranges::destructible<int&>, "");
-static_assert(!ranges::destructible<void()>, "");
-static_assert(ranges::destructible<void(*)()>, "");
-static_assert(ranges::destructible<void(&)()>, "");
-static_assert(!ranges::destructible<int[]>, "");
-static_assert(ranges::destructible<int[2]>, "");
-static_assert(ranges::destructible<int(*)[2]>, "");
-static_assert(ranges::destructible<int(&)[2]>, "");
-static_assert(ranges::destructible<moveonly>, "");
-static_assert(ranges::destructible<nonmovable>, "");
-static_assert(!ranges::destructible<NotDestructible>, "");
-
-static_assert(ranges::constructible_from<int>, "");
-static_assert(ranges::constructible_from<int const>, "");
-static_assert(!ranges::constructible_from<void>, "");
-static_assert(!ranges::constructible_from<int const &>, "");
-static_assert(!ranges::constructible_from<int ()>, "");
-static_assert(!ranges::constructible_from<int(&)()>, "");
-static_assert(!ranges::constructible_from<int[]>, "");
-static_assert(ranges::constructible_from<int[5]>, "");
-static_assert(!ranges::constructible_from<nondefaultconstructible>, "");
-static_assert(ranges::constructible_from<int const(&)[5], int(&)[5]>, "");
-static_assert(!ranges::constructible_from<int, int(&)[3]>, "");
-
-static_assert(ranges::constructible_from<int, int>, "");
-static_assert(ranges::constructible_from<int, int&>, "");
-static_assert(ranges::constructible_from<int, int&&>, "");
-static_assert(ranges::constructible_from<int, const int>, "");
-static_assert(ranges::constructible_from<int, const int&>, "");
-static_assert(ranges::constructible_from<int, const int&&>, "");
-
-static_assert(!ranges::constructible_from<int&, int>, "");
-static_assert(ranges::constructible_from<int&, int&>, "");
-static_assert(!ranges::constructible_from<int&, int&&>, "");
-static_assert(!ranges::constructible_from<int&, const int>, "");
-static_assert(!ranges::constructible_from<int&, const int&>, "");
-static_assert(!ranges::constructible_from<int&, const int&&>, "");
-
-static_assert(ranges::constructible_from<const int&, int>, "");
-static_assert(ranges::constructible_from<const int&, int&>, "");
-static_assert(ranges::constructible_from<const int&, int&&>, "");
-static_assert(ranges::constructible_from<const int&, const int>, "");
-static_assert(ranges::constructible_from<const int&, const int&>, "");
-static_assert(ranges::constructible_from<const int&, const int&&>, "");
-
-static_assert(ranges::constructible_from<int&&, int>, "");
-static_assert(!ranges::constructible_from<int&&, int&>, "");
-static_assert(ranges::constructible_from<int&&, int&&>, "");
-static_assert(!ranges::constructible_from<int&&, const int>, "");
-static_assert(!ranges::constructible_from<int&&, const int&>, "");
-static_assert(!ranges::constructible_from<int&&, const int&&>, "");
-
-static_assert(ranges::constructible_from<const int&&, int>, "");
-static_assert(!ranges::constructible_from<const int&&, int&>, "");
-static_assert(ranges::constructible_from<const int&&, int&&>, "");
-static_assert(ranges::constructible_from<const int&&, const int>, "");
-static_assert(!ranges::constructible_from<const int&&, const int&>, "");
-static_assert(ranges::constructible_from<const int&&, const int&&>, "");
-
-struct XXX
-{
-    XXX() = default;
-    XXX(XXX&&) = delete;
-    explicit XXX(int) {}
-};
-
-static_assert(ranges::constructible_from<XXX, int>, "");
-static_assert(!ranges::move_constructible<XXX>, "");
-static_assert(!ranges::movable<XXX>, "");
-static_assert(!ranges::semiregular<XXX>, "");
-static_assert(!ranges::regular<XXX>, "");
-
-static_assert(ranges::default_constructible<int>, "");
-static_assert(ranges::default_constructible<int const>, "");
-static_assert(!ranges::default_constructible<int const &>, "");
-static_assert(!ranges::default_constructible<int ()>, "");
-static_assert(!ranges::default_constructible<int(&)()>, "");
-static_assert(!ranges::default_constructible<int[]>, "");
-static_assert(ranges::default_constructible<int[5]>, "");
-static_assert(!ranges::default_constructible<nondefaultconstructible>, "");
-
-static_assert(ranges::move_constructible<int>, "");
-static_assert(ranges::move_constructible<const int>, "");
-static_assert(ranges::move_constructible<int &>, "");
-static_assert(ranges::move_constructible<int &&>, "");
-static_assert(ranges::move_constructible<const int &>, "");
-static_assert(ranges::move_constructible<const int &&>, "");
-static_assert(ranges::destructible<moveonly>, "");
-static_assert(ranges::constructible_from<moveonly, moveonly>, "");
-static_assert(ranges::move_constructible<moveonly>, "");
-static_assert(!ranges::move_constructible<nonmovable>, "");
-static_assert(ranges::move_constructible<nonmovable &>, "");
-static_assert(ranges::move_constructible<nonmovable &&>, "");
-static_assert(ranges::move_constructible<const nonmovable &>, "");
-static_assert(ranges::move_constructible<const nonmovable &&>, "");
-
-static_assert(ranges::copy_constructible<int>, "");
-static_assert(ranges::copy_constructible<const int>, "");
-static_assert(ranges::copy_constructible<int &>, "");
-static_assert(!ranges::copy_constructible<int &&>, "");
-static_assert(ranges::copy_constructible<const int &>, "");
-static_assert(!ranges::copy_constructible<const int &&>, "");
-static_assert(!ranges::copy_constructible<moveonly>, "");
-static_assert(!ranges::copy_constructible<nonmovable>, "");
-static_assert(ranges::copy_constructible<nonmovable &>, "");
-static_assert(!ranges::copy_constructible<nonmovable &&>, "");
-static_assert(ranges::copy_constructible<const nonmovable &>, "");
-static_assert(!ranges::copy_constructible<const nonmovable &&>, "");
-
-static_assert(ranges::movable<int>, "");
-static_assert(!ranges::movable<int const>, "");
-static_assert(ranges::movable<moveonly>, "");
-static_assert(!ranges::movable<nonmovable>, "");
-
-static_assert(ranges::copyable<int>, "");
-static_assert(!ranges::copyable<int const>, "");
-static_assert(!ranges::copyable<moveonly>, "");
-static_assert(!ranges::copyable<nonmovable>, "");
-
-// static_assert(ranges::predicate<std::less<int>, int, int>, "");
-// static_assert(!ranges::predicate<std::less<int>, char*, int>, "");
-
-static_assert(ranges::input_iterator<int*>, "");
-static_assert(!ranges::input_iterator<int>, "");
-
-static_assert(ranges::forward_iterator<int*>, "");
-static_assert(!ranges::forward_iterator<int>, "");
-
-static_assert(ranges::bidirectional_iterator<int*>, "");
-static_assert(!ranges::bidirectional_iterator<int>, "");
-
-static_assert(ranges::random_access_iterator<int*>, "");
-static_assert(!ranges::random_access_iterator<int>, "");
-
-static_assert(ranges::contiguous_iterator<int*>, "");
-static_assert(!ranges::contiguous_iterator<int>, "");
-
-static_assert(ranges::view_<ranges::istream_view<int>>, "");
-static_assert(ranges::input_iterator<ranges::iterator_t<ranges::istream_view<int>>>, "");
-static_assert(!ranges::view_<int>, "");
-
-static_assert(ranges::common_range<std::vector<int> >, "");
-static_assert(ranges::common_range<std::vector<int> &>, "");
-static_assert(!ranges::view_<std::vector<int>>, "");
-static_assert(!ranges::view_<std::vector<int> &>, "");
-static_assert(ranges::random_access_iterator<ranges::iterator_t<std::vector<int> const &>>, "");
-static_assert(!ranges::common_range<ranges::istream_view<int>>, "");
-
-static_assert(ranges::predicate<std::less<int>, int, int>, "");
-static_assert(!ranges::predicate<std::less<int>, char*, int>, "");
-
-static_assert(ranges::output_iterator<int *, int>, "");
-static_assert(!ranges::output_iterator<int const *, int>, "");
-
-static_assert(ranges::swappable<int &>, "");
-static_assert(ranges::swappable<int>, "");
-static_assert(!ranges::swappable<int const &>, "");
-static_assert(ranges::swappable<IntSwappable>, "");
-static_assert(ranges::swappable_with<IntSwappable, int &>, "");
-static_assert(!ranges::swappable_with<IntSwappable, int const &>, "");
-
-static_assert(ranges::totally_ordered<int>, "");
-static_assert(ranges::common_with<int, IntComparable>, "");
-static_assert(ranges::common_reference_with<int &, IntComparable &>, "");
-static_assert(ranges::totally_ordered_with<int, IntComparable>, "");
-static_assert(ranges::totally_ordered_with<IntComparable, int>, "");
-static_assert(ranges::detail::weakly_equality_comparable_with_<int, int>, "");
-static_assert(ranges::equality_comparable<int>, "");
-static_assert(ranges::equality_comparable_with<int, int>, "");
-static_assert(ranges::equality_comparable_with<int, IntComparable>, "");
-static_assert(ranges::equality_comparable_with<int &, IntComparable &>, "");
-
-#if __cplusplus > 201703L && defined(__cpp_impl_three_way_comparison) && __has_include(<compare>)
-#include <compare>
-
-static_assert(ranges::three_way_comparable<int>);
-static_assert(ranges::three_way_comparable<int, std::partial_ordering>);
-static_assert(ranges::three_way_comparable<int, std::weak_ordering>);
-static_assert(ranges::three_way_comparable<int, std::strong_ordering>);
-
-static_assert(ranges::three_way_comparable_with<int, IntComparable>);
-static_assert(ranges::three_way_comparable_with<int, IntComparable, std::partial_ordering>);
-static_assert(ranges::three_way_comparable_with<int, IntComparable, std::weak_ordering>);
-static_assert(ranges::three_way_comparable_with<int, IntComparable, std::strong_ordering>);
-static_assert(ranges::three_way_comparable_with<IntComparable, int>);
-static_assert(ranges::three_way_comparable_with<IntComparable, int, std::partial_ordering>);
-static_assert(ranges::three_way_comparable_with<IntComparable, int, std::weak_ordering>);
-static_assert(ranges::three_way_comparable_with<IntComparable, int, std::strong_ordering>);
-#endif // supports spaceship
-
-static_assert(
-    std::is_same<
-        ranges::common_range_tag_of<std::vector<int>>,
-        ranges::common_range_tag
-    >::value, "");
-
-static_assert(
-    std::is_same<
-        ranges::sized_range_tag_of<std::vector<int>>,
-        ranges::sized_range_tag
-    >::value, "");
-
-static_assert(ranges::view_<ranges::istream_view<int>>, "");
-static_assert(!ranges::common_range<ranges::istream_view<int>>, "");
-static_assert(!ranges::sized_range<ranges::istream_view<int>>, "");
-
-struct myview : ranges::view_base {
-    const char *begin();
-    const char *end();
-};
-CPP_assert(ranges::view_<myview>);
-
-CPP_template(class T)
-    (requires ranges::regular<T>)
-constexpr bool is_regular(T&&)
-{
-    return true;
-}
-
-CPP_template(class T)
-    (requires (!ranges::regular<T>))
-constexpr bool is_regular(T&&)
-{
-    return false;
-}
-
-static_assert(is_regular(42), "");
-static_assert(!is_regular(XXX{}), "");
-
-int main()
-{
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/utility/functional.cpp b/src/contrib/range-v3-0.11.0/test/utility/functional.cpp
deleted file mode 100644
index 2ceddf05..00000000
--- a/src/contrib/range-v3-0.11.0/test/utility/functional.cpp
+++ /dev/null
@@ -1,253 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Casey Carter 2015
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <memory>
-#include <range/v3/functional/invoke.hpp>
-#include <range/v3/functional/not_fn.hpp>
-#include <range/v3/view/filter.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-CPP_assert(ranges::constructible_from<ranges::reference_wrapper<int>, int&>);
-CPP_assert(!ranges::constructible_from<ranges::reference_wrapper<int>, int&&>);
-CPP_assert(!ranges::constructible_from<ranges::reference_wrapper<int &&>, int&>);
-CPP_assert(ranges::constructible_from<ranges::reference_wrapper<int &&>, int&&>);
-
-namespace
-{
-    struct Integer
-    {
-        int i;
-        operator int() const { return i; }
-        bool odd() const { return (i % 2) != 0; }
-    };
-
-    enum class kind { lvalue, const_lvalue, rvalue, const_rvalue };
-
-    std::ostream &operator<<(std::ostream &os, kind k)
-    {
-        const char* message = nullptr;
-        switch (k) {
-            case kind::lvalue:
-                message = "lvalue";
-                break;
-            case kind::const_lvalue:
-                message = "const_lvalue";
-                break;
-            case kind::rvalue:
-                message = "rvalue";
-                break;
-            case kind::const_rvalue:
-                message = "const_rvalue";
-                break;
-        }
-        return os << message;
-    }
-
-    kind last_call;
-
-    template<kind DisableKind>
-    struct fn
-    {
-        bool operator()() &
-        {
-            last_call = kind::lvalue;
-            return DisableKind != kind::lvalue;
-        }
-        bool operator()() const &
-        {
-            last_call = kind::const_lvalue;
-            return DisableKind != kind::const_lvalue;
-        }
-        bool operator()() &&
-        {
-            last_call = kind::rvalue;
-            return DisableKind != kind::rvalue;
-        }
-        bool operator()() const &&
-        {
-            last_call = kind::const_rvalue;
-            return DisableKind != kind::const_rvalue;
-        }
-    };
-
-    constexpr struct {
-        template<typename T>
-        constexpr T&& operator()(T&& arg) const noexcept {
-            return (T&&)arg;
-        }
-    } h = {};
-
-    struct A {
-        int i = 13;
-        constexpr int f() const noexcept { return 42; }
-        constexpr /*c++14*/ int g(int j) { return 2 * j; }
-    };
-
-    constexpr int f() noexcept { return 13; }
-    constexpr int g(int i) { return 2 * i + 1; }
-
-    void test_invoke()
-    {
-        CHECK(ranges::invoke(f) == 13);
-        // CHECK(noexcept(ranges::invoke(f) == 13));
-        CHECK(ranges::invoke(g, 2) == 5);
-        CHECK(ranges::invoke(h, 42) == 42);
-        CHECK(noexcept(ranges::invoke(h, 42) == 42));
-        {
-            int i = 13;
-            CHECK(&ranges::invoke(h, i) == &i);
-            CHECK(noexcept(&ranges::invoke(h, i) == &i));
-        }
-
-        CHECK(ranges::invoke(&A::f, A{}) == 42);
-        // CHECK(noexcept(ranges::invoke(&A::f, A{}) == 42));
-        CHECK(ranges::invoke(&A::g, A{}, 2) == 4);
-        {
-            A a;
-            const auto& ca = a;
-            CHECK(ranges::invoke(&A::f, a) == 42);
-            // CHECK(noexcept(ranges::invoke(&A::f, a) == 42));
-            CHECK(ranges::invoke(&A::f, ca) == 42);
-            // CHECK(noexcept(ranges::invoke(&A::f, ca) == 42));
-            CHECK(ranges::invoke(&A::g, a, 2) == 4);
-        }
-
-        {
-            A a;
-            const auto& ca = a;
-            CHECK(ranges::invoke(&A::f, &a) == 42);
-            // CHECK(noexcept(ranges::invoke(&A::f, &a) == 42));
-            CHECK(ranges::invoke(&A::f, &ca) == 42);
-            // CHECK(noexcept(ranges::invoke(&A::f, &ca) == 42));
-            CHECK(ranges::invoke(&A::g, &a, 2) == 4);
-        }
-        {
-            std::unique_ptr<A> up(new A);
-            CHECK(ranges::invoke(&A::f, up) == 42);
-            CHECK(ranges::invoke(&A::g, up, 2) == 4);
-        }
-        {
-            auto sp = std::make_shared<A>();
-            CHECK(ranges::invoke(&A::f, sp) == 42);
-            // CHECK(noexcept(ranges::invoke(&A::f, sp) == 42));
-            CHECK(ranges::invoke(&A::g, sp, 2) == 4);
-        }
-
-        CHECK(ranges::invoke(&A::i, A{}) == 13);
-        // CHECK(noexcept(ranges::invoke(&A::i, A{}) == 13));
-        { int&& tmp = ranges::invoke(&A::i, A{}); (void)tmp; }
-
-        {
-            A a;
-            const auto& ca = a;
-            CHECK(ranges::invoke(&A::i, a) == 13);
-            // CHECK(noexcept(ranges::invoke(&A::i, a) == 13));
-            CHECK(ranges::invoke(&A::i, ca) == 13);
-            // CHECK(noexcept(ranges::invoke(&A::i, ca) == 13));
-            CHECK(ranges::invoke(&A::i, &a) == 13);
-            // CHECK(noexcept(ranges::invoke(&A::i, &a) == 13));
-            CHECK(ranges::invoke(&A::i, &ca) == 13);
-            // CHECK(noexcept(ranges::invoke(&A::i, &ca) == 13));
-
-            ranges::invoke(&A::i, a) = 0;
-            CHECK(a.i == 0);
-            ranges::invoke(&A::i, &a) = 1;
-            CHECK(a.i == 1);
-            CPP_assert(ranges::same_as<decltype(ranges::invoke(&A::i, ca)), const int&>);
-            CPP_assert(ranges::same_as<decltype(ranges::invoke(&A::i, &ca)), const int&>);
-        }
-
-        {
-            std::unique_ptr<A> up(new A);
-            CHECK(ranges::invoke(&A::i, up) == 13);
-            ranges::invoke(&A::i, up) = 0;
-            CHECK(up->i == 0);
-        }
-
-        {
-            auto sp = std::make_shared<A>();
-            CHECK(ranges::invoke(&A::i, sp) == 13);
-            ranges::invoke(&A::i, sp) = 0;
-            CHECK(sp->i == 0);
-        }
-
-        // {
-        //     struct B { int i = 42; constexpr int f() const { return i; } };
-        //     constexpr B b;
-        //     static_assert(b.i == 42, "");
-        //     static_assert(b.f() == 42, "");
-        //     static_assert(ranges::invoke_detail::impl(&B::i, b) == 42, "");
-        //     static_assert(ranges::invoke_detail::impl(&B::i, &b) == 42, "");
-        //     static_assert(ranges::invoke_detail::impl(&B::i, B{}) == 42, "");
-        //     static_assert(ranges::invoke_detail::impl(&B::f, b) == 42, "");
-        //     static_assert(ranges::invoke_detail::impl(&B::f, &b) == 42, "");
-        //     static_assert(ranges::invoke_detail::impl(&B::f, B{}) == 42, "");
-        // }
-    }
-
-} // unnamed namespace
-
-
-
-int main()
-{
-    {
-        // Check that not_fn works with callables
-        Integer some_ints[] = {{0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}};
-        ::check_equal(some_ints | ranges::views::filter(ranges::not_fn(&Integer::odd)),
-                      {0,2,4,6});
-    }
-
-    // Check that not_fn forwards value category
-    {
-        constexpr auto k = kind::lvalue;
-        using F = fn<k>;
-        auto f = ranges::not_fn(F{});
-        CHECK(f() == true);
-        CHECK(last_call == k);
-    }
-    {
-        constexpr auto k = kind::const_lvalue;
-        using F = fn<k>;
-        auto const f = ranges::not_fn(F{});
-        CHECK(f() == true);
-        CHECK(last_call == k);
-    }
-    {
-        constexpr auto k = kind::rvalue;
-        using F = fn<k>;
-        auto f = ranges::not_fn(F{});
-        CHECK(std::move(f)() == true); // xvalue
-        CHECK(last_call == k);
-
-        CHECK(decltype(f){}() == true); // prvalue
-        CHECK(last_call == k);
-    }
-
-#ifdef _WIN32
-    {
-        // Ensure that invocable accepts pointers to functions with non-default calling conventions.
-        CPP_assert(ranges::invocable<void(__cdecl*)()>);
-        CPP_assert(ranges::invocable<void(__stdcall*)()>);
-        CPP_assert(ranges::invocable<void(__fastcall*)()>);
-        CPP_assert(ranges::invocable<void(__thiscall*)()>);
-#ifndef __MINGW32__
-        CPP_assert(ranges::invocable<void(__vectorcall*)()>);
-#endif
-    }
-#endif // _WIN32
-
-    test_invoke();
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/utility/meta.cpp b/src/contrib/range-v3-0.11.0/test/utility/meta.cpp
deleted file mode 100644
index dade70b5..00000000
--- a/src/contrib/range-v3-0.11.0/test/utility/meta.cpp
+++ /dev/null
@@ -1,434 +0,0 @@
-/// \file meta.cpp Tests for Meta: a tiny metaprogramming library
-// Meta: a tiny metaprogramming library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Acknowledgements: Thanks for Paul Fultz for the suggestions that
-//                   concepts can be ordinary Boolean metafunctions.
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-#include <tuple>
-#include <meta/meta.hpp>
-#include "../simple_test.hpp"
-
-using namespace meta;
-
-// An implementation of tuple_cat gives Range v3's meta-programming and list
-// utilities a good workout. It's a good compiler stress test, too.
-
-namespace tc_detail
-{
-    template<typename Ret, typename... Is, typename... Ks, typename Tuples>
-    Ret tuple_cat_(list<Is...>, list<Ks...>, Tuples tpls)
-    {
-        return Ret{std::get<Ks::value>(std::get<Is::value>(tpls))...};
-    }
-}
-
-template<typename... Tuples,
-          typename Res = apply<quote<std::tuple>, concat<as_list<Tuples>...>>>
-Res tuple_cat(Tuples &&... tpls)
-{
-    static constexpr std::size_t N = sizeof...(Tuples);
-    // E.g. [0,0,0,2,2,2,3,3]
-    using inner = join<
-        transform<list<as_list<Tuples>...>,
-                  transform<as_list<make_index_sequence<N>>, quote<id>>, quote<transform>>>;
-    // E.g. [0,1,2,0,1,2,0,1]
-    using outer = join<
-        transform<list<as_list<Tuples>...>,
-                  compose<quote<as_list>, quote_i<std::size_t, make_index_sequence>, quote<size>>>>;
-    return tc_detail::tuple_cat_<Res>(inner{}, outer{},
-                                      std::forward_as_tuple(std::forward<Tuples>(tpls)...));
-}
-
-void test_tuple_cat()
-{
-    std::tuple<int, short, long> t1;
-    std::tuple<> t2;
-    std::tuple<float, double, long double> t3;
-    std::tuple<void *, char *> t4;
-
-    auto x = ::tuple_cat(t1, t2, t3, t4);
-    using expected_type = std::tuple<int, short, long, float, double, long double, void *, char *>;
-    static_assert(std::is_same<decltype(x), expected_type>::value, "");
-}
-
-// Other misc tests
-static_assert(std::is_same<reverse<list<int, short, double>>, list<double, short, int>>::value, "");
-static_assert(std::is_same<reverse<list<int, short, double, float>>, list<float, double, short, int>>::value, "");
-static_assert(std::is_same<reverse<list<int[1], int[2], int[3], int[4], int[5], int[6], int[7], int[8], int[9], int[10], int[11], int[12], int[13], int[14], int[15], int[16], int[17]>>, list<int[17], int[16], int[15], int[14], int[13], int[12], int[11], int[10], int[9], int[8], int[7], int[6], int[5], int[4], int[3], int[2], int[1]>>::value, "");
-
-static_assert(all_of<list<int, short, long>, quote<std::is_integral>>::value, "");
-static_assert(none_of<list<int, short, long>, quote<std::is_floating_point>>::value, "");
-static_assert(!any_of<list<int, short, long>, quote<std::is_floating_point>>::value, "");
-static_assert(any_of<list<int, short, long, float>, quote<std::is_floating_point>>::value, "");
-
-static_assert(std::is_same<invoke<uncurry<curry<quote_trait<id>>>, std::tuple<int, short, double>>,
-                           list<int, short, double>>::value,
-              "");
-
-template<typename, typename, typename = void>
-struct can_invoke_ : std::false_type
-{
-};
-
-template<typename F, typename... As>
-struct can_invoke_<F, meta::list<As...>, meta::void_<meta::invoke<F, As...>>> : std::true_type
-{
-};
-
-template<typename F, typename... As>
-struct can_invoke : can_invoke_<F, meta::list<As...>>
-{
-};
-
-static_assert(can_invoke<meta::quote<std::pair>, int, int>::value, "");
-// I'm guessing this failure is due to GCC #64970
-// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=64970
-#if !defined(__GNUC__) || defined(__clang__) || __GNUC__ >= 5
-static_assert(!can_invoke<meta::quote<std::pair>, int, int, int>::value, "");
-#endif
-
-// Sanity-check meta::lambda
-using Lambda0 = lambda<_a, _b, std::pair<_a, _b>>;
-using Lambda1 = lambda<_a, _b, std::pair<_b, _a>>;
-using Lambda2 = lambda<_a, _b, std::pair<_b, std::pair<_a, _a>>>;
-using Pair0 = invoke<Lambda0, int, short>;
-using Pair1 = invoke<Lambda1, int, short>;
-using Pair2 = invoke<Lambda2, int, short>;
-static_assert(std::is_same<Pair0, std::pair<int, short>>::value, "");
-static_assert(std::is_same<Pair1, std::pair<short, int>>::value, "");
-static_assert(std::is_same<Pair2, std::pair<short, std::pair<int, int>>>::value, "");
-
-// Not saying you should do it this way, but it's a good test.
-namespace l = meta::lazy;
-template<class L>
-using cart_prod = reverse_fold<
-    L, list<list<>>,
-    lambda<
-        _a, _b,
-        l::join<l::transform<
-            _b, lambda<_c, l::join<l::transform<_a, lambda<_d, list<l::push_front<_d, _c>>>>>>>>>>;
-
-using CartProd = cart_prod<meta::list<meta::list<int, short>, meta::list<float, double>>>;
-static_assert(
-    std::is_same<CartProd, meta::list<meta::list<int, float>, meta::list<int, double>,
-                                      meta::list<short, float>, meta::list<short, double>>>::value,
-    "");
-
-static_assert(can_invoke<lambda<_a, lazy::if_<std::is_integral<_a>, _a>>, int>::value, "");
-// I'm guessing this failure is due to GCC #64970
-// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=64970
-#if !defined(__GNUC__) || defined(__clang__) || __GNUC__ >= 5
-static_assert(!can_invoke<lambda<_a, lazy::if_<std::is_integral<_a>, _a>>, float>::value, "");
-#endif
-
-template<typename List>
-using rev = reverse_fold<List, list<>, lambda<_a, _b, defer<push_back, _a, _b>>>;
-static_assert(std::is_same<rev<list<int, short, double>>, list<double, short, int>>::value, "");
-
-using uncvref_fn = lambda<_a, l::_t<std::remove_cv<l::_t<std::remove_reference<_a>>>>>;
-static_assert(std::is_same<invoke<uncvref_fn, int const &>, int>::value, "");
-
-using L = list<int, short, int, float>;
-static_assert(std::is_same<find<L, int>, list<int, short, int, float>>::value, "");
-static_assert(std::is_same<find_if<L, bind_front<quote<std::is_same>, int>>, list<int, short, int, float>>::value, "");
-static_assert(std::is_same<find_if<L, bind_front<quote<std::is_same>, double>>, list<>>::value, "");
-static_assert(std::is_same<reverse_find<L, int>, list<int, float>>::value, "");
-static_assert(std::is_same<reverse_find_if<L, bind_front<quote<std::is_same>, int>>, list<int, float>>::value, "");
-static_assert(std::is_same<reverse_find_if<L, bind_front<quote<std::is_same>, double>>, list<>>::value, "");
-
-struct check_integral
-{
-    template<class T>
-    constexpr T operator()(T &&i) const
-    {
-        static_assert(std::is_integral<T>{}, "");
-        return i;
-    }
-};
-
-// Test for meta::let
-template<typename T, typename List>
-using find_index_ = let<
-    var<_a, List>, var<_b, lazy::find<_a, T>>,
-    lazy::if_<std::is_same<_b, list<>>, meta::npos, lazy::minus<lazy::size<_a>, lazy::size<_b>>>>;
-static_assert(find_index_<int, list<short, int, float>>{} == 1, "");
-static_assert(find_index_<double, list<short, int, float>>{} == meta::npos{}, "");
-
-// Test that the unselected branch does not get evaluated:
-template<typename T>
-using test_lazy_if_ = let<lazy::if_<std::is_void<T>, T, defer<std::pair, T>>>;
-static_assert(std::is_same<test_lazy_if_<void>, void>::value, "");
-
-// Test that and_ gets short-circuited:
-template<typename T>
-using test_lazy_and_ = let<lazy::and_<std::is_void<T>, defer<std::is_convertible, T>>>;
-static_assert(std::is_same<test_lazy_and_<int>, std::false_type>::value, "");
-
-// Test that and_ gets short-circuited:
-template<typename T>
-using test_lazy_or_ = let<lazy::or_<std::is_void<T>, defer<std::is_convertible, T>>>;
-static_assert(std::is_same<test_lazy_or_<void>, std::true_type>::value, "");
-
-template<typename A, int B = 0>
-struct lambda_test
-{
-};
-
-template<typename N>
-struct fact
-    : let<lazy::if_c<(N::value > 0), lazy::multiplies<N, defer<fact, dec<N>>>, meta::size_t<1>>>
-{
-};
-
-static_assert(fact<meta::size_t<0>>::value == 1, "");
-static_assert(fact<meta::size_t<1>>::value == 1, "");
-static_assert(fact<meta::size_t<2>>::value == 2, "");
-static_assert(fact<meta::size_t<3>>::value == 6, "");
-static_assert(fact<meta::size_t<4>>::value == 24, "");
-
-template<std::size_t N>
-struct fact2
-    : let<lazy::if_c<(N > 0), lazy::multiplies<meta::size_t<N>, defer_i<std::size_t, fact2, N - 1>>,
-                     meta::size_t<1>>>
-{
-};
-
-static_assert(fact2<0>::value == 1, "");
-static_assert(fact2<1>::value == 1, "");
-static_assert(fact2<2>::value == 2, "");
-static_assert(fact2<3>::value == 6, "");
-static_assert(fact2<4>::value == 24, "");
-
-template<typename N>
-struct factorial
-    : let<if_c<N::value == 0, meta::size_t<1>, lazy::multiplies<N, factorial<lazy::dec<N>>>>>
-{
-};
-
-static_assert(factorial<meta::size_t<0>>::value == 1, "");
-static_assert(factorial<meta::size_t<1>>::value == 1, "");
-static_assert(factorial<meta::size_t<2>>::value == 2, "");
-static_assert(factorial<meta::size_t<3>>::value == 6, "");
-static_assert(factorial<meta::size_t<4>>::value == 24, "");
-
-int main()
-{
-    // meta::sizeof_
-    static_assert(meta::sizeof_<int>{} == sizeof(int), "");
-
-    // meta::min
-    static_assert(meta::min<meta::size_t<0>, meta::size_t<1>>{} == 0, "");
-    static_assert(meta::min<meta::size_t<0>, meta::size_t<0>>{} == 0, "");
-    static_assert(meta::min<meta::size_t<1>, meta::size_t<0>>{} == 0, "");
-
-    // meta::max
-    static_assert(meta::max<meta::size_t<0>, meta::size_t<1>>{} == 1, "");
-    static_assert(meta::max<meta::size_t<1>, meta::size_t<0>>{} == 1, "");
-    static_assert(meta::max<meta::size_t<1>, meta::size_t<1>>{} == 1, "");
-
-    // meta::filter
-    {
-        using l = meta::list<int, double, short, float, long, char>;
-        using il = meta::list<int, short, long, char>;
-        using fl = meta::list<double, float>;
-
-        static_assert(std::is_same<il, meta::filter<l, meta::quote<std::is_integral>>>{}, "");
-        static_assert(std::is_same<fl, meta::filter<l, meta::quote<std::is_floating_point>>>{}, "");
-    }
-
-    // meta::for_each
-    {
-        using l = meta::list<int, long, short>;
-        constexpr auto r = meta::for_each(l{}, check_integral());
-        static_assert(std::is_same<meta::_t<std::remove_cv<decltype(r)>>, check_integral>::value,
-                      "");
-    }
-
-    // meta::find_index
-    {
-        using l = meta::list<int, long, short, int>;
-        static_assert(meta::find_index<l, int>{} == 0, "");
-        static_assert(meta::find_index<l, long>{} == 1, "");
-        static_assert(meta::find_index<l, short>{} == 2, "");
-        static_assert(meta::find_index<l, double>{} == meta::npos{}, "");
-        static_assert(meta::find_index<l, float>{} == meta::npos{}, "");
-
-        using l2 = meta::list<>;
-        static_assert(meta::find_index<l2, double>{} == meta::npos{}, "");
-
-        using namespace meta::placeholders;
-
-        using lambda = meta::lambda<_a, _b, meta::lazy::find_index<_b, _a>>;
-        using result = meta::invoke<lambda, long, l>;
-        static_assert(result{} == 1, "");
-    }
-
-    // meta::reverse_find_index
-    {
-        using l = meta::list<int, long, short, int>;
-
-        static_assert(meta::reverse_find_index<l, int>{} == 3, "");
-        static_assert(meta::reverse_find_index<l, long>{} == 1, "");
-        static_assert(meta::reverse_find_index<l, short>{} == 2, "");
-        static_assert(meta::reverse_find_index<l, double>{} == meta::npos{}, "");
-        static_assert(meta::reverse_find_index<l, float>{} == meta::npos{}, "");
-
-        using l2 = meta::list<>;
-        static_assert(meta::reverse_find_index<l2, double>{} == meta::npos{}, "");
-
-        using lambda = meta::lambda<_a, _b, meta::lazy::reverse_find_index<_b, _a>>;
-        using result = meta::invoke<lambda, long, l>;
-        static_assert(result{} == 1, "");
-    }
-
-    // meta::count
-    {
-        using l = meta::list<int, long, short, int>;
-        static_assert(meta::count<l, int>{} == 2, "");
-        static_assert(meta::count<l, short>{} == 1, "");
-        static_assert(meta::count<l, double>{} == 0, "");
-    }
-
-    // meta::count_if
-    {
-        using l = meta::list<int, long, short, int>;
-        static_assert(meta::count_if<l, lambda<_a, std::is_same<_a, int>>>{} == 2, "");
-        static_assert(meta::count_if<l, lambda<_b, std::is_same<_b, short>>>{} == 1, "");
-        static_assert(meta::count_if<l, lambda<_c, std::is_same<_c, double>>>{} == 0, "");
-    }
-
-    // pathological lambda test
-    {
-        using X = invoke<lambda<_a, lambda_test<_a>>, int>;
-        static_assert(std::is_same<X, lambda_test<_a>>::value, "");
-    }
-
-    // meta::unique
-    {
-        using l = meta::list<int, short, int, double, short, double, double>;
-        static_assert(std::is_same<meta::unique<l>, list<int, short, double>>::value, "");
-    }
-
-    // meta::in
-    {
-        static_assert(in<list<int, int, short, float>, int>::value, "");
-        static_assert(in<list<int, int, short, float>, short>::value, "");
-        static_assert(in<list<int, int, short, float>, float>::value, "");
-        static_assert(!in<list<int, int, short, float>, double>::value, "");
-    }
-
-    // lambda with variadic placeholders
-    {
-        using X = invoke<lambda<_args, list<_args>>, int, short, double>;
-        static_assert(std::is_same<X, list<int, short, double>>::value, "");
-
-        using X2 = invoke<lambda<_a, lambda_test<_a>>, int>;
-        static_assert(std::is_same<X2, lambda_test<_a>>::value, "");
-
-        using Y = invoke<lambda<_args, defer<std::pair, _args>>, int, short>;
-        static_assert(std::is_same<Y, std::pair<int, short>>::value, "");
-
-        using Y2 = invoke<lambda<_args, list<_args, list<_args>>>, int, short>;
-        static_assert(std::is_same<Y2, list<int, short, list<int, short>>>::value, "");
-
-        using Z = invoke<lambda<_a, _args, list<int, _args, double, _a>>, short *, short, float>;
-        static_assert(std::is_same<Z, list<int, short, float, double, short *>>::value, "");
-
-        // Nesting variadic lambdas in non-variadic lambdas:
-        using A = invoke<lambda<_a, lazy::invoke<lambda<_b, _args, list<_args, _b>>, _a,
-                                               lazy::_t<std::add_pointer<_a>>,
-                                               lazy::_t<std::add_lvalue_reference<_a>>>>,
-                        int>;
-        static_assert(std::is_same<A, list<int *, int &, int>>::value, "");
-
-        // Nesting non-variadic lambdas in variadic lambdas:
-        using B = invoke<lambda<_a, _args, lazy::invoke<lambda<_b, list<_b, _args, _a>>, _a>>, int,
-                        short, double>;
-        static_assert(std::is_same<B, list<int, short, double, int>>::value, "");
-
-        // Nesting variadic lambdas in variadic lambdas:
-        using ZZ = invoke<
-            lambda<_a, _args_a,
-                   lazy::invoke<lambda<_b, _args_b, list<_b, _a, list<_args_b>, list<_args_a>>>,
-                               _args_a>>,
-            int, short, float, double>;
-        static_assert(
-            std::is_same<ZZ,
-                         list<short, int, list<float, double>, list<short, float, double>>>::value,
-            "");
-
-// I'm guessing this failure is due to GCC #64970
-// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=64970
-#if !defined(__GNUC__) || defined(__clang__) || __GNUC__ >= 5
-        static_assert(!can_invoke<lambda<_args, defer<std::pair, _args>>, int>::value, "");
-        static_assert(!can_invoke<lambda<_args, defer<std::pair, _args>>, int, short, double>::value,
-                      "");
-        static_assert(!can_invoke<lambda<_a, defer<std::pair, _a, _a>>, int, short>::value, "");
-        static_assert(!can_invoke<lambda<_a, _b, _c, _args, defer<std::pair, _a, _a>>>::value, "");
-#endif
-    }
-
-    // Test for meta::sort
-    {
-        using L0 = list<char[5], char[3], char[2], char[6], char[1], char[5], char[10]>;
-        using L2 = meta::sort<L0, lambda<_a, _b, lazy::less<lazy::sizeof_<_a>, lazy::sizeof_<_b>>>>;
-        static_assert(
-            std::is_same<
-                L2, list<char[1], char[2], char[3], char[5], char[5], char[6], char[10]>>::value,
-            "");
-    }
-
-    // Check the _z user-defined literal:
-    static_assert(42_z == 42, "");
-
-    // Check integer_range
-    {
-        constexpr std::size_t a = meta::fold<meta::as_list<meta::integer_range<std::size_t, 0, 5>>,
-                                             meta::size_t<0>, meta::quote<meta::plus>>{};
-
-        static_assert(a == 10, "");
-
-        constexpr std::size_t b = meta::fold<meta::as_list<meta::integer_range<std::size_t, 5, 10>>,
-                                             meta::size_t<0>, meta::quote<meta::plus>>{};
-
-        static_assert(b == 35, "");
-
-        constexpr std::size_t c = meta::fold<meta::as_list<meta::integer_range<std::size_t, 0, 20>>,
-                                             meta::size_t<0>, meta::quote<meta::plus>>{};
-
-        static_assert(c == 190, "");
-
-        using d = meta::integer_range<std::size_t, 5, 10>;
-        static_assert(std::is_same<d, meta::integer_sequence<std::size_t, 5, 6, 7, 8, 9>>{}, "");
-    }
-
-    // Check reverse_fold
-    {
-        constexpr std::size_t a = meta::reverse_fold<meta::as_list<meta::integer_range<std::size_t, 0, 5>>,
-                                             meta::size_t<0>, meta::quote<meta::plus>>{};
-
-        static_assert(a == 10, "");
-
-        constexpr std::size_t b = meta::reverse_fold<meta::as_list<meta::integer_range<std::size_t, 5, 10>>,
-                                             meta::size_t<0>, meta::quote<meta::plus>>{};
-
-        static_assert(b == 35, "");
-
-        constexpr std::size_t c = meta::reverse_fold<meta::as_list<meta::integer_range<std::size_t, 0, 20>>,
-                                             meta::size_t<0>, meta::quote<meta::plus>>{};
-
-        static_assert(c == 190, "");
-    }
-
-    test_tuple_cat();
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/utility/scope_exit.cpp b/src/contrib/range-v3-0.11.0/test/utility/scope_exit.cpp
deleted file mode 100644
index ad182265..00000000
--- a/src/contrib/range-v3-0.11.0/test/utility/scope_exit.cpp
+++ /dev/null
@@ -1,85 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2017-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <range/v3/utility/scope_exit.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-RANGES_DIAGNOSTIC_IGNORE_UNNEEDED_MEMBER
-
-namespace
-{
-    int i = 0;
-
-    struct NoexceptFalse
-    {
-        NoexceptFalse() {}
-        NoexceptFalse(NoexceptFalse const &) noexcept(false)
-        {}
-
-        NoexceptFalse(NoexceptFalse &&) noexcept(false)
-        {
-            CHECK(false);
-        }
-
-        void operator()() const
-        {
-            ++i;
-        }
-    };
-
-    struct ThrowingCopy
-    {
-        ThrowingCopy() {}
-        [[noreturn]] ThrowingCopy(ThrowingCopy const &) noexcept(false)
-        {
-            throw 42;
-        }
-
-        ThrowingCopy(ThrowingCopy &&) noexcept(false)
-        {
-            CHECK(false);
-        }
-
-        void operator()() const
-        {
-            ++i;
-        }
-    };
-}
-
-int main()
-{
-    std::cout << "\nTesting scope_exit\n";
-
-    {
-        auto guard = ranges::make_scope_exit([&]{++i;});
-        CHECK(i == 0);
-    }
-    CHECK(i == 1);
-
-    {
-        auto guard = ranges::make_scope_exit(NoexceptFalse{});
-        CHECK(i == 1);
-    }
-    CHECK(i == 2);
-
-    try
-    {
-        auto guard = ranges::make_scope_exit(ThrowingCopy{});
-        CHECK(false);
-    }
-    catch(int)
-    {}
-    CHECK(i == 3);
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/utility/semiregular_box.cpp b/src/contrib/range-v3-0.11.0/test/utility/semiregular_box.cpp
deleted file mode 100644
index 5d6cc9c8..00000000
--- a/src/contrib/range-v3-0.11.0/test/utility/semiregular_box.cpp
+++ /dev/null
@@ -1,33 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2020-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <range/v3/utility/semiregular_box.hpp>
-#include "../simple_test.hpp"
-
-using namespace ranges;
-
-// #https://github.com/ericniebler/range-v3/issues/1499
-void test_1499()
-{
-    ranges::semiregular_box_t<int> box1;
-    ranges::semiregular_box_t<int &> box2;
-
-    detail::ignore_unused(
-        box1,  //
-        box2); //
-}
-
-int main()
-{
-    test_1499();
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/utility/swap.cpp b/src/contrib/range-v3-0.11.0/test/utility/swap.cpp
deleted file mode 100644
index 924b7922..00000000
--- a/src/contrib/range-v3-0.11.0/test/utility/swap.cpp
+++ /dev/null
@@ -1,113 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Acknowledgements: Thanks for Paul Fultz for the suggestions that
-//                   concepts can be ordinary Boolean metafunctions.
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#include <iostream>
-#include <tuple>
-#include <memory>
-#include <vector>
-#include <complex>
-#include <concepts/concepts.hpp>
-#include <range/v3/utility/swap.hpp>
-#include <range/v3/view/zip.hpp>
-#include <range/v3/range/conversion.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-template<typename T>
-struct S
-{
-    T t;
-};
-
-
-int main()
-{
-    int a=0,b=42;
-    ranges::swap(a,b);
-    CHECK(a == 42);
-    CHECK(b == 0);
-
-    CPP_assert(!ranges::swappable_with<std::pair<int,int>&&,std::pair<int,int>&&>);
-    CPP_assert(ranges::swappable_with<std::pair<int&,int&>&&,std::pair<int&,int&>&&>);
-
-    int c=24,d=82;
-    ranges::swap(std::tie(a,b),std::tie(c,d));
-    CHECK(a == 24);
-    CHECK(b == 82);
-    CHECK(c == 42);
-    CHECK(d == 0);
-
-    // Swap pairs of tuple proxies
-    int e=1,f=2,g=3,h=4;
-    ranges::swap(std::make_pair(std::tie(a,b), std::tie(c,d)), std::make_pair(std::tie(e,f), std::tie(g,h)));
-    CHECK(a == 1);
-    CHECK(b == 2);
-    CHECK(c == 3);
-    CHECK(d == 4);
-    CHECK(e == 24);
-    CHECK(f == 82);
-    CHECK(g == 42);
-    CHECK(h == 0);
-
-#ifndef _LIBCPP_VERSION
-    // Swap tuples of pair proxies
-    ranges::swap(std::make_tuple(std::make_pair(std::ref(a),std::ref(b)), std::make_pair(std::ref(c),std::ref(d))),
-                 std::make_tuple(std::make_pair(std::ref(e),std::ref(f)), std::make_pair(std::ref(g),std::ref(h))));
-    CHECK(a == 24);
-    CHECK(b == 82);
-    CHECK(c == 42);
-    CHECK(d == 0);
-    CHECK(e == 1);
-    CHECK(f == 2);
-    CHECK(g == 3);
-    CHECK(h == 4);
-#endif
-
-    int aa=24,bb=82;
-    ranges::iter_swap(&aa, &bb);
-    CHECK(aa == 82);
-    CHECK(bb == 24);
-
-    std::unique_ptr<int> u0{new int{1}};
-    std::unique_ptr<int> u1{new int{2}};
-    int *p0 = u0.get();
-    int *p1 = u1.get();
-    ranges::iter_swap(&u0, &u1);
-    CHECK(u0.get() == p1);
-    CHECK(u1.get() == p0);
-
-    {
-        using namespace ranges;
-        auto v0 = to<std::vector<MoveOnlyString>>({"a","b","c"});
-        auto v1 = to<std::vector<MoveOnlyString>>({"x","y","z"});
-        auto rng = views::zip(v0, v1);
-        ranges::iter_swap(rng.begin(), rng.begin()+2);
-        ::check_equal(v0, {"c","b","a"});
-        ::check_equal(v1, {"z","y","x"});
-    }
-
-    {
-        using T = std::complex<float>;
-        T s,t;
-        ranges::swap(s,t);
-    }
-    {
-        using T = S<std::complex<float>>;
-        T s,t;
-        ranges::swap(s,t);
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/utility/variant.cpp b/src/contrib/range-v3-0.11.0/test/utility/variant.cpp
deleted file mode 100644
index 03a9c533..00000000
--- a/src/contrib/range-v3-0.11.0/test/utility/variant.cpp
+++ /dev/null
@@ -1,200 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2015-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <vector>
-#include <sstream>
-#include <iostream>
-#include <range/v3/functional/overload.hpp>
-#include <range/v3/numeric/accumulate.hpp>
-#include <range/v3/utility/variant.hpp>
-#include <range/v3/view/concat.hpp>
-#include <range/v3/view/partial_sum.hpp>
-#include <range/v3/view/transform.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-void bug_1217()
-{
-    std::vector<int> vec;
-
-    if(auto tx = vec | ranges::views::transform( [](int){ return 0; } ))
-    {
-        auto positions_visited = ranges::views::concat( tx, tx ) | ranges::views::partial_sum;
-        ranges::accumulate( positions_visited, 0 );
-    }
-}
- 
-int main()
-{
-    using namespace ranges;
-
-    // Simple variant and access.
-    {
-        variant<int, short> v;
-        CHECK(v.index() == 0u);
-        auto v2 = v;
-        CHECK(v2.index() == 0u);
-        v.emplace<1>((short)2);
-        CHECK(v.index() == 1u);
-        CHECK(get<1>(v) == (short)2);
-        try
-        {
-            get<0>(v);
-            CHECK(false);
-        }
-        catch(const bad_variant_access&)
-        {}
-        catch(...)
-        {
-            CHECK(!(bool)"unknown exception");
-        }
-        v = v2;
-        CHECK(v.index() == 0u);
-    }
-
-    // variant of void
-    {
-        variant<void, void> v;
-        CHECK(v.index() == 0u);
-        v.emplace<0>();
-        CHECK(v.index() == 0u);
-        try
-        {
-            // Will only compile if get returns void
-            v.index() == 0 ? void() : get<0>(v);
-        }
-        catch(...)
-        {
-            CHECK(false);
-        }
-        v.emplace<1>();
-        CHECK(v.index() == 1u);
-        try
-        {
-            get<0>(v);
-            CHECK(false);
-        }
-        catch(const bad_variant_access&)
-        {}
-        catch(...)
-        {
-            CHECK(!(bool)"unknown exception");
-        }
-    }
-
-    // variant of references
-    {
-        int i = 42;
-        std::string s = "hello world";
-        variant<int&, std::string&> v{emplaced_index<0>, i};
-        CPP_assert(!default_constructible<variant<int&, std::string&>>);
-        CHECK(v.index() == 0u);
-        CHECK(get<0>(v) == 42);
-        CHECK(&get<0>(v) == &i);
-        auto const & cv = v;
-        get<0>(cv) = 24;
-        CHECK(i == 24);
-        v.emplace<1>(s);
-        CHECK(v.index() == 1u);
-        CHECK(get<1>(v) == "hello world");
-        CHECK(&get<1>(v) == &s);
-        get<1>(cv) = "goodbye";
-        CHECK(s == "goodbye");
-    }
-
-    // Move test 1
-    {
-        variant<int, MoveOnlyString> v{emplaced_index<1>, "hello world"};
-        CHECK(get<1>(v) == "hello world");
-        MoveOnlyString s = get<1>(std::move(v));
-        CHECK(s == "hello world");
-        CHECK(get<1>(v) == "");
-        v.emplace<1>("goodbye");
-        CHECK(get<1>(v) == "goodbye");
-        auto v2 = std::move(v);
-        CHECK(get<1>(v2) == "goodbye");
-        CHECK(get<1>(v) == "");
-        v = std::move(v2);
-        CHECK(get<1>(v) == "goodbye");
-        CHECK(get<1>(v2) == "");
-    }
-
-    // Move test 2
-    {
-        MoveOnlyString s = "hello world";
-        variant<MoveOnlyString&> v{emplaced_index<0>, s};
-        CHECK(get<0>(v) == "hello world");
-        MoveOnlyString &s2 = get<0>(std::move(v));
-        CHECK(&s2 == &s);
-    }
-
-    // Apply test 1
-    {
-        std::stringstream sout;
-        variant<int, std::string> v{emplaced_index<1>, "hello"};
-        auto fun = overload(
-            [&sout](int&) {sout << "int";},
-            [&sout](std::string&)->int {sout << "string"; return 42;});
-        variant<void, int> x = v.visit(fun);
-        CHECK(sout.str() == "string");
-        CHECK(x.index() == 1u);
-        CHECK(get<1>(x) == 42);
-    }
-
-    // Apply test 2
-    {
-        std::stringstream sout;
-        std::string s = "hello";
-        variant<int, std::string&> const v{emplaced_index<1>, s};
-        auto fun = overload(
-            [&sout](int const&) {sout << "int";},
-            [&sout](std::string&)->int {sout << "string"; return 42;});
-        variant<void, int> x = v.visit(fun);
-        CHECK(sout.str() == "string");
-        CHECK(x.index() == 1u);
-        CHECK(get<1>(x) == 42);
-    }
-
-    // constexpr variant
-    {
-        constexpr variant<int, short> v{emplaced_index<1>, (short)2};
-        static_assert(v.index() == 1,"");
-        static_assert(v.valid(),"");
-    }
-
-    // Variant and arrays
-    {
-        variant<int[5], std::vector<int>> v{emplaced_index<0>, {1,2,3,4,5}};
-        int (&rgi)[5] = get<0>(v);
-        check_equal(rgi, {1,2,3,4,5});
-
-        variant<int[5], std::vector<int>> v2{emplaced_index<0>, {}};
-        int (&rgi2)[5] = get<0>(v2);
-        check_equal(rgi2, {0,0,0,0,0});
-
-        v2 = v;
-        check_equal(rgi2, {1,2,3,4,5});
-
-        struct T
-        {
-            T() = delete;
-            T(int) {}
-            T(T const &) = default;
-            T &operator=(T const &) = default;
-        };
-
-        // Should compile and not assert at runtime.
-        variant<T[5]> vrgt{emplaced_index<0>, {T{42},T{42},T{42},T{42},T{42}}};
-        (void) vrgt;
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/CMakeLists.txt b/src/contrib/range-v3-0.11.0/test/view/CMakeLists.txt
deleted file mode 100644
index e03c4373..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/CMakeLists.txt
+++ /dev/null
@@ -1,69 +0,0 @@
-set(CMAKE_FOLDER "${CMAKE_FOLDER}/view")
-
-rv3_add_test(test.view.adaptor view.adaptor adaptor.cpp)
-rv3_add_test(test.view.addressof view.addressof addressof.cpp)
-rv3_add_test(test.view.adjacent_remove_if view.adjacent_remove_if adjacent_remove_if.cpp)
-rv3_add_test(test.view.all view.all all.cpp)
-rv3_add_test(test.view.any_view view.any_view any_view.cpp)
-rv3_add_test(test.view.common view.common common.cpp)
-rv3_add_test(test.view.cache1 view.cache1 cache1.cpp)
-rv3_add_test(test.view.cartesian_product view.cartesian_product cartesian_product.cpp)
-rv3_add_test(test.view.chunk view.chunk chunk.cpp)
-rv3_add_test(test.view.concat view.concat concat.cpp)
-rv3_add_test(test.view.const view.const const.cpp)
-rv3_add_test(test.view.conversion view.conversion conversion.cpp)
-rv3_add_test(test.view.counted view.counted counted.cpp)
-rv3_add_test(test.view.cycle view.cycle cycle.cpp)
-rv3_add_test(test.view.delimit view.delimit delimit.cpp)
-rv3_add_test(test.view.drop view.drop drop.cpp)
-rv3_add_test(test.view.drop_exactly view.drop_exactly drop_exactly.cpp)
-rv3_add_test(test.view.drop_while view.drop_while drop_while.cpp)
-rv3_add_test(test.view.drop_last view.drop_last drop_last.cpp)
-rv3_add_test(test.view.enumerate view.enumerate enumerate.cpp)
-rv3_add_test(test.view.exclusive_scan view.exclusive_scan exclusive_scan.cpp)
-rv3_add_test(test.view.facade view.facade facade.cpp)
-rv3_add_test(test.view.generate view.generate generate.cpp)
-rv3_add_test(test.view.generate_n view.generate_n generate_n.cpp)
-rv3_add_test(test.view.getlines view.getlines getlines.cpp)
-rv3_add_test(test.view.group_by view.group_by group_by.cpp)
-rv3_add_test(test.view.indirect view.indirect indirect.cpp)
-rv3_add_test(test.view.intersperse view.intersperse intersperse.cpp)
-rv3_add_test(test.view.iota view.iota iota.cpp)
-rv3_add_test(test.view.istream view.istream istream.cpp)
-rv3_add_test(test.view.iterator_range view.iterator_range iterator_range.cpp)
-rv3_add_test(test.view.join view.join join.cpp)
-rv3_add_test(test.view.linear_distribute view.linear_distribute linear_distribute.cpp)
-rv3_add_test(test.view.map view.map keys_value.cpp)
-rv3_add_test(test.view.move view.move move.cpp)
-rv3_add_test(test.view.partial_sum view.partial_sum partial_sum.cpp)
-# rv3_add_test(test.view.partial_sum_depr view.partial_sum_depr partial_sum_depr.cpp)
-rv3_add_test(test.view.repeat view.repeat repeat.cpp)
-rv3_add_test(test.view.remove view.remove remove.cpp)
-rv3_add_test(test.view.remove_if view.remove_if remove_if.cpp)
-rv3_add_test(test.view.replace view.replace replace.cpp)
-rv3_add_test(test.view.replace_if view.replace_if replace_if.cpp)
-rv3_add_test(test.view.reverse view.reverse reverse.cpp)
-rv3_add_test(test.view.sample view.sample sample.cpp)
-rv3_add_test(test.view.set_difference view.set_difference set_difference.cpp)
-rv3_add_test(test.view.set_intersection view.set_intersection set_intersection.cpp)
-rv3_add_test(test.view.set_symmetric_difference view.set_symmetric_difference set_symmetric_difference.cpp)
-rv3_add_test(test.view.set_union view.set_union set_union.cpp)
-rv3_add_test(test.view.slice view.slice slice.cpp)
-rv3_add_test(test.view.sliding view.sliding sliding.cpp)
-rv3_add_test(test.view.span view.span span.cpp)
-rv3_add_test(test.view.split view.split split.cpp)
-rv3_add_test(test.view.stride view.stride stride.cpp)
-rv3_add_test(test.view.subrange view.subrange subrange.cpp)
-rv3_add_test(test.view.tail view.tail tail.cpp)
-rv3_add_test(test.view.take view.take take.cpp)
-rv3_add_test(test.view.take_exactly view.take_exactly take_exactly.cpp)
-rv3_add_test(test.view.take_last view.take_last take_last.cpp)
-rv3_add_test(test.view.take_while view.take_while take_while.cpp)
-rv3_add_test(test.view.tokenize view.tokenize tokenize.cpp)
-rv3_add_test(test.view.transform view.transform transform.cpp)
-rv3_add_test(test.view.trim view.trim trim.cpp)
-rv3_add_test(test.view.unique view.unique unique.cpp)
-rv3_add_test(test.view.view view.view view.cpp)
-rv3_add_test(test.view.zip view.zip zip.cpp)
-
-target_compile_definitions(view.iterator_range PRIVATE RANGES_DISABLE_DEPRECATED_WARNINGS)
diff --git a/src/contrib/range-v3-0.11.0/test/view/adaptor.cpp b/src/contrib/range-v3-0.11.0/test/view/adaptor.cpp
deleted file mode 100644
index 95b60688..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/adaptor.cpp
+++ /dev/null
@@ -1,172 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <list>
-#include <vector>
-#include <sstream>
-#include <range/v3/core.hpp>
-#include <range/v3/utility/copy.hpp>
-#include <range/v3/view/delimit.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-template<typename BidiRange>
-struct my_reverse_view
-  : ranges::view_adaptor<my_reverse_view<BidiRange>, BidiRange>
-{
-private:
-    CPP_assert(ranges::bidirectional_range<BidiRange>);
-    CPP_assert(ranges::common_range<BidiRange>);
-    friend ranges::range_access;
-    using base_iterator_t = ranges::iterator_t<BidiRange>;
-
-    struct adaptor : ranges::adaptor_base
-    {
-        template<class base_mixin>
-        struct mixin : base_mixin
-        {
-            mixin() = default;
-            using base_mixin::base_mixin;
-
-            int mixin_int = 120;
-
-            int base_plus_adaptor() const
-            {
-                int y = this->get().t;
-                return *this->base() + y;
-            }
-        };
-
-        int t = 20;
-
-        // Cross-wire begin and end.
-        base_iterator_t begin(my_reverse_view const &rng) const
-        {
-            return ranges::end(rng.base());
-        }
-        base_iterator_t end(my_reverse_view const &rng) const
-        {
-            return ranges::begin(rng.base());
-        }
-        void next(base_iterator_t &it) const
-        {
-            --it;
-        }
-        void prev(base_iterator_t &it) const
-        {
-            ++it;
-        }
-        ranges::range_reference_t<BidiRange> read(base_iterator_t it) const
-        {
-            return *ranges::prev(it);
-        }
-        CPP_member
-        auto advance(base_iterator_t &it,
-            ranges::range_difference_t<BidiRange> n) const ->
-            CPP_ret(void)(
-                requires ranges::random_access_range<BidiRange>)
-        {
-            it -= n;
-        }
-        CPP_member
-        auto distance_to(base_iterator_t const &here,
-            base_iterator_t const &there) const ->
-            CPP_ret(ranges::range_difference_t<BidiRange>)(
-                requires ranges::sized_sentinel_for<base_iterator_t, base_iterator_t>)
-        {
-            return here - there;
-        }
-    };
-    adaptor begin_adaptor() const
-    {
-        return {};
-    }
-    adaptor end_adaptor() const
-    {
-        return {};
-    }
-public:
-    using my_reverse_view::view_adaptor::view_adaptor;
-};
-
-struct my_delimited_range
-  : ranges::view_adaptor<
-        my_delimited_range,
-        ranges::delimit_view<ranges::istream_view<int>, int>>
-{
-    using view_adaptor::view_adaptor;
-
-    struct adaptor : ranges::adaptor_base
-    {
-        template<class base_mixin>
-        struct mixin : base_mixin
-        {
-            mixin() = default;
-            using base_mixin::base_mixin;
-
-            int mixin_int = 120;
-
-            int adaptor_access_test() const
-            {
-                int y = this->get().t;
-                return y;
-            }
-        };
-
-        int t = 20;
-    };
-    adaptor begin_adaptor() const
-    {
-        return {};
-    }
-    adaptor end_adaptor() const
-    {
-        return {};
-    }
-};
-
-int main()
-{
-    using namespace ranges;
-    std::vector<int> v{1, 2, 3, 4};
-    my_reverse_view<std::vector<int>&> retro{v};
-    CPP_assert(common_range<decltype(retro)>);
-    CPP_assert(view_<decltype(retro)>);
-    CPP_assert(random_access_iterator<decltype(retro.begin())>);
-    ::check_equal(retro, {4, 3, 2, 1});
-
-    // test cursor mixin
-    CHECK( retro.begin().mixin_int == 120 );
-    CHECK( *((retro.begin()+1).base()) == 4 );
-    CHECK( (retro.begin()+1).base_plus_adaptor() == 24 );
-
-    std::list<int> l{1, 2, 3, 4};
-    my_reverse_view<std::list<int>& > retro2{l};
-    CPP_assert(common_range<decltype(retro2)>);
-    CPP_assert(view_<decltype(retro2)>);
-    CPP_assert(bidirectional_iterator<decltype(retro2.begin())>);
-    CPP_assert(!random_access_iterator<decltype(retro2.begin())>);
-    ::check_equal(retro2, {4, 3, 2, 1});
-
-    std::stringstream sinx("1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 42 6 7 8 9 ");
-    my_delimited_range r{views::delimit(istream<int>(sinx), 42)};
-    CPP_assert(view_<decltype(r)>);
-    CPP_assert(!common_range<decltype(r)>);
-    CPP_assert(input_iterator<decltype(r.begin())>);
-    CPP_assert(!forward_iterator<decltype(r.begin())>);
-    ::check_equal(r, {1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4});
-
-    // test sentinel mixin
-    CHECK(r.end().mixin_int == 120);
-    CHECK(r.end().adaptor_access_test() == 20);
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/addressof.cpp b/src/contrib/range-v3-0.11.0/test/view/addressof.cpp
deleted file mode 100644
index 75fd0ba5..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/addressof.cpp
+++ /dev/null
@@ -1,129 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Andrey Diduh 2019
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#include <sstream>
-#include <vector>
-
-#include <range/v3/core.hpp>
-#include <range/v3/view/addressof.hpp>
-#include <range/v3/view/facade.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/take.hpp>
-
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-using namespace ranges;
-
-void simple_test()
-{
-    std::vector<int> list = {1,2,3};
-
-    auto out = list | views::addressof;
-
-    check_equal(out, {&list[0], &list[1], &list[2]});
-}
-
-struct test_istream_range
-  : view_facade<test_istream_range, unknown>
-{
-private:
-    friend range_access;
-
-    std::vector<int> *list;
-
-    struct cursor
-    {
-    private:
-        std::size_t i = 0;
-        std::vector<int> *list = nullptr;
-    public:
-        cursor() = default;
-        explicit cursor(std::vector<int> &list_)
-          : list(&list_)
-        {}
-        void next()
-        {
-            ++i;
-        }
-        int &read() const noexcept
-        {
-            return (*list)[i];
-        }
-        bool equal(default_sentinel_t) const
-        {
-            return i == list->size();
-        }
-    };
-
-    cursor begin_cursor()
-    {
-        return cursor{*list};
-    }
-public:
-    test_istream_range() = default;
-    explicit test_istream_range(std::vector<int> &list_)
-      : list(&list_)
-    {}
-};
-
-void test_input_range()
-{
-    // It is implementation dependent,
-    // for how long returned reference remains valid.
-    // It should be valid at least until next read.
-    // For test purposes we use custom input range.
-
-    std::vector<int> list{1, 2, 3};
-    auto rng = test_istream_range(list);
-    CPP_assert(input_range<decltype(rng)>);
-
-    auto out = rng | views::addressof;
-    check_equal(out, {&list[0], &list[1], &list[2]});
-}
-
-struct test_xvalue_range
-  : view_facade<test_xvalue_range, unknown>
-{
-private:
-    friend range_access;
-
-    struct cursor
-    {
-        cursor() = default;
-        void next();
-        int &&read() const noexcept;
-        bool equal(default_sentinel_t) const;
-    };
-
-    cursor begin_cursor();
-};
-
-template<typename, typename = void>
-constexpr bool can_view = false;
-template<typename R>
-constexpr bool can_view<R,
-    meta::void_<decltype(views::addressof(std::declval<R>()))>> = true;
-
-// prvalue ranges cannot be passed to views::addressof
-CPP_assert(!can_view<decltype(views::iota(0, 3))>);
-// xvalue ranges cannot be passed to views::addressof
-CPP_assert(!can_view<test_xvalue_range>);
-
-int main()
-{
-    simple_test();
-    test_input_range();
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/adjacent_remove_if.cpp b/src/contrib/range-v3-0.11.0/test/view/adjacent_remove_if.cpp
deleted file mode 100644
index 5c61a48e..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/adjacent_remove_if.cpp
+++ /dev/null
@@ -1,117 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <vector>
-#include <iterator>
-#include <functional>
-#include <range/v3/core.hpp>
-#include <range/v3/view/adjacent_remove_if.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/counted.hpp>
-#include <range/v3/utility/copy.hpp>
-#include <range/v3/algorithm/copy.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/insert_iterators.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    int const rgi[] = {1, 1, 1, 2, 3, 4, 4};
-    std::vector<int> out;
-
-    {
-        auto rng = rgi | views::adjacent_remove_if(std::equal_to<int>{});
-        has_type<int const &>(*begin(rng));
-        CPP_assert(view_<decltype(rng)>);
-        CPP_assert(common_range<decltype(rng)>);
-        CPP_assert(!sized_range<decltype(rng)>);
-        CPP_assert(bidirectional_iterator<decltype(begin(rng))>);
-        CPP_assert(!random_access_iterator<decltype(begin(rng))>);
-        CPP_assert(output_iterator<decltype(ranges::back_inserter(out)), int>);
-        CPP_assert(!equality_comparable<decltype(ranges::back_inserter(out))>);
-        copy(rng, ranges::back_inserter(out));
-        ::check_equal(out, {1, 2, 3, 4});
-    }
-
-    {
-        auto rng2 = views::counted(rgi, 7)
-          | views::adjacent_remove_if([&](int i, int j) { return i == j; });
-        has_type<int const &>(*begin(rng2));
-        CPP_assert(view_<decltype(rng2)>);
-        CPP_assert(forward_range<decltype(rng2)>);
-        CPP_assert(common_range<decltype(rng2)>);
-        CPP_assert(!sized_range<decltype(rng2)>);
-        CPP_assert(bidirectional_iterator<decltype(begin(rng2))>);
-        CPP_assert(!random_access_iterator<decltype(begin(rng2))>);
-        ::check_equal(rng2, {1, 2, 3, 4});
-    }
-
-    {
-        auto rng3 = views::counted(ForwardIterator<int const*>(rgi), 7)
-            | views::adjacent_remove_if(std::equal_to<int>{});
-        has_type<int const &>(*begin(rng3));
-        CPP_assert(view_<decltype(rng3)>);
-        CPP_assert(forward_range<decltype(rng3)>);
-        CPP_assert(!common_range<decltype(rng3)>);
-        CPP_assert(!sized_range<decltype(rng3)>);
-        CPP_assert(forward_iterator<decltype(begin(rng3))>);
-        CPP_assert(!bidirectional_iterator<decltype(begin(rng3))>);
-        ::check_equal(rng3, {1, 2, 3, 4});
-    }
-
-    {
-        auto rng4 = views::counted(ForwardIterator<int const*>(rgi), 7)
-          | views::adjacent_remove_if([](int,int){return true;});
-        has_type<int const &>(*begin(rng4));
-        CHECK(*begin(rng4) == 4);
-        CPP_assert(view_<decltype(rng4)>);
-        CPP_assert(forward_range<decltype(rng4)>);
-        CPP_assert(!common_range<decltype(rng4)>);
-        CPP_assert(!sized_range<decltype(rng4)>);
-        CPP_assert(forward_iterator<decltype(begin(rng4))>);
-        CPP_assert(!bidirectional_iterator<decltype(begin(rng4))>);
-        ::check_equal(rng4, {4});
-    }
-
-    {
-        auto is_odd_then_even = [](int i, int j){return 1==i%2 && 0 == j%2;};
-        auto rng5 = views::iota(0, 11) | views::adjacent_remove_if(is_odd_then_even);
-        has_type<int>(*begin(rng5));
-        CPP_assert(view_<decltype(rng5)>);
-        CPP_assert(forward_range<decltype(rng5)>);
-        CPP_assert(common_range<decltype(rng5)>);
-        CPP_assert(!sized_range<decltype(rng5)>);
-        CPP_assert(bidirectional_iterator<decltype(begin(rng5))>);
-        CPP_assert(!random_access_iterator<decltype(begin(rng5))>);
-        ::check_equal(rng5, {0,2,4,6,8,10});
-    }
-
-    {
-        // Verify that forward and backward traversal both select the same elements.
-        auto rng = views::adjacent_remove_if(rgi, std::equal_to<int>{});
-        std::vector<int const*> pointers;
-        for(auto& i : rng)
-            pointers.push_back(&i);
-        auto pos = ranges::end(rng);
-        for(auto i = pointers.size(); i != 0;)
-        {
-            CHECK(pos != ranges::begin(rng));
-            CHECK(&*--pos == pointers[--i]);
-        }
-        CHECK(pos == ranges::begin(rng));
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/all.cpp b/src/contrib/range-v3-0.11.0/test/view/all.cpp
deleted file mode 100644
index 2efe7219..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/all.cpp
+++ /dev/null
@@ -1,54 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <list>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/all.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    int rgi[] = {1, 1, 1, 2, 3, 4, 4};
-    std::vector<int> vi(begin(rgi), end(rgi));
-    std::list<int> li(begin(rgi), end(rgi));
-
-    ref_view<int[7]> x = views::all(rgi);
-    ref_view<std::vector<int>> y = views::all(vi);
-    ref_view<std::list<int>> z = views::all(li);
-
-    CPP_assert(sized_range<decltype(x)> && view_<decltype(x)>);
-    CPP_assert(sized_range<decltype(y)> && view_<decltype(y)>);
-    CPP_assert(sized_range<decltype(z)> && view_<decltype(z)>);
-
-    x = views::all(x);
-    y = views::all(y);
-    z = views::all(z);
-
-    CHECK(x.size() == 7u);
-    CHECK(y.size() == 7u);
-    CHECK(z.size() == 7u);
-
-    {
-        auto v = views::all(debug_input_view<int const>{rgi});
-        CHECK(v.size() == size(rgi));
-        CHECK(v.data_->first_ == rgi);
-        auto v2 = views::all(views::all(views::all(std::move(v))));
-        CPP_assert(same_as<decltype(v), decltype(v2)>);
-        CHECK(v2.size() == size(rgi));
-        CHECK(v2.data_->first_ == rgi);
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/any_view.cpp b/src/contrib/range-v3-0.11.0/test/view/any_view.cpp
deleted file mode 100644
index c69c43b9..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/any_view.cpp
+++ /dev/null
@@ -1,227 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <map>
-#include <vector>
-
-#include <range/v3/core.hpp>
-#include <range/v3/utility/copy.hpp>
-#include <range/v3/view/any_view.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/map.hpp>
-#include <range/v3/view/reverse.hpp>
-#include <range/v3/view/tail.hpp>
-#include <range/v3/view/take.hpp>
-#include <range/v3/view/take_exactly.hpp>
-
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-namespace
-{
-    template<typename S, typename T, typename = void>
-    struct can_convert_to : std::false_type
-    {};
-    template<typename S, typename T>
-    struct can_convert_to<
-        S, T, meta::void_<decltype(ranges::polymorphic_downcast<T>(std::declval<S>()))>>
-      : std::true_type
-    {};
-
-    void test_polymorphic_downcast()
-    {
-        struct A
-        {
-            virtual ~A() = default;
-        };
-        struct B : A
-        {};
-        struct unrelated
-        {};
-        struct incomplete;
-
-        CPP_assert(can_convert_to<B *, void *>());
-        CPP_assert(can_convert_to<A *, void *>());
-        CPP_assert(can_convert_to<B *, A *>());
-        CPP_assert(can_convert_to<A *, B *>());
-        CPP_assert(!can_convert_to<int, int>());
-        CPP_assert(!can_convert_to<A const *, A *>());
-        CPP_assert(!can_convert_to<A *, unrelated *>());
-        CPP_assert(!can_convert_to<unrelated *, A *>());
-        CPP_assert(!can_convert_to<incomplete *, incomplete *>());
-
-        CPP_assert(can_convert_to<B &, A &>());
-        CPP_assert(can_convert_to<A &, B &>());
-        CPP_assert(!can_convert_to<A &, unrelated &>());
-        CPP_assert(!can_convert_to<unrelated &, A &>());
-        CPP_assert(!can_convert_to<incomplete &, incomplete &>());
-
-#if !defined(__GNUC__) || defined(__clang__) || __GNUC__ > 4
-        CPP_assert(can_convert_to<B &&, A &&>());
-        CPP_assert(can_convert_to<B &, A &&>());
-#endif // old GCC dynamic_cast bug
-        CPP_assert(!can_convert_to<B &&, A &>());
-        CPP_assert(can_convert_to<A &&, B &&>());
-        CPP_assert(!can_convert_to<A &&, B &>());
-        CPP_assert(can_convert_to<A &, B &&>());
-        CPP_assert(!can_convert_to<A &&, unrelated &&>());
-        CPP_assert(!can_convert_to<A &&, unrelated &>());
-        CPP_assert(!can_convert_to<A &, unrelated &&>());
-        CPP_assert(!can_convert_to<unrelated &&, A &&>());
-        CPP_assert(!can_convert_to<unrelated &&, A &>());
-        CPP_assert(!can_convert_to<unrelated &, A &&>());
-        CPP_assert(!can_convert_to<incomplete &&, incomplete &&>());
-        CPP_assert(!can_convert_to<incomplete &&, incomplete &>());
-        CPP_assert(!can_convert_to<incomplete &, incomplete &&>());
-    }
-} // unnamed namespace
-
-int main()
-{
-    using namespace ranges;
-    auto const ten_ints = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
-
-    {
-        any_view<int> ints = views::ints;
-        CPP_assert(input_range<decltype(ints)> && view_<decltype(ints)>);
-        CPP_assert(!(forward_range<decltype(ints)> && view_<decltype(ints)>));
-        ::check_equal(std::move(ints) | views::take(10), ten_ints);
-    }
-    {
-        any_view<int> ints = views::ints | views::take_exactly(5);
-        CPP_assert(input_range<decltype(ints)> && view_<decltype(ints)>);
-        CPP_assert(!(random_access_range<decltype(ints)> && view_<decltype(ints)>));
-        CPP_assert(!(sized_range<decltype(ints)> && view_<decltype(ints)>));
-        static_assert((get_categories<decltype(ints)>() & category::random_access) ==
-                          category::input,
-                      "");
-        static_assert(
-            (get_categories<decltype(ints)>() & category::sized) == category::none, "");
-    }
-    {
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-#if defined(__clang__) && __clang_major__ < 6
-        // Workaround https://bugs.llvm.org/show_bug.cgi?id=33314
-        RANGES_DIAGNOSTIC_PUSH
-        RANGES_DIAGNOSTIC_IGNORE_UNDEFINED_FUNC_TEMPLATE
-#endif
-        any_view ints = views::ints | views::take_exactly(5);
-#if defined(__clang__) && __clang_major__ < 6
-        RANGES_DIAGNOSTIC_POP
-#endif
-#else
-        any_view<int, category::random_access | category::sized> ints =
-            views::ints | views::take_exactly(5);
-#endif
-        CPP_assert(random_access_range<decltype(ints)> && view_<decltype(ints)>);
-        CPP_assert(sized_range<decltype(ints)> && view_<decltype(ints)>);
-        static_assert((get_categories<decltype(ints)>() & category::random_access) ==
-                          category::random_access,
-                      "");
-        static_assert(
-            (get_categories<decltype(ints)>() & category::sized) == category::sized, "");
-    }
-    {
-        any_view<int, category::input | category::sized> ints =
-            views::ints | views::take_exactly(10);
-        CPP_assert(input_range<decltype(ints)> && view_<decltype(ints)>);
-        CPP_assert(sized_range<decltype(ints)> && view_<decltype(ints)>);
-        static_assert(
-            (get_categories<decltype(ints)>() & category::input) == category::input, "");
-        static_assert(
-            (get_categories<decltype(ints)>() & category::sized) == category::sized, "");
-    }
-    {
-        any_view<int, category::bidirectional> ints = views::ints;
-        CPP_assert(bidirectional_range<decltype(ints)> && view_<decltype(ints)>);
-        CPP_assert(!(random_access_range<decltype(ints)> && view_<decltype(ints)>));
-        static_assert((get_categories<decltype(ints)>() & category::random_access) ==
-                          category::bidirectional,
-                      "");
-    }
-    {
-        any_view<int> ints2 = views::ints | views::take(10);
-        ::check_equal(ints2, ten_ints);
-        ::check_equal(ints2, ten_ints);
-    }
-    {
-        any_view<int, category::random_access> ints3 = views::ints | views::take(10);
-        CPP_assert(view_<decltype(ints3)>);
-        CPP_assert(random_access_range<decltype(ints3)>);
-        CPP_assert(!common_range<decltype(ints3)>);
-        ::check_equal(ints3, ten_ints);
-        ::check_equal(ints3, ten_ints);
-        ::check_equal(aux::copy(ints3), ten_ints);
-        ::check_equal(ints3 | views::reverse, {9, 8, 7, 6, 5, 4, 3, 2, 1, 0});
-    }
-    {
-        any_view<int&> e;
-        CHECK(e.begin() == e.begin());
-        CHECK(e.begin() == e.end());
-    }
-    {
-        iterator_t<any_view<int&, category::random_access>> i{},j{};
-        sentinel_t<any_view<int&, category::random_access>> k{};
-        CHECK(i == j);
-        CHECK(i == k);
-        CHECK((i - j) == 0);
-    }
-    
-    // Regression test for #446
-    {
-        auto vec = std::vector<short>{begin(ten_ints), end(ten_ints)};
-        ::check_equal(any_view<int>{vec}, ten_ints);
-        ::check_equal(any_view<int>{ranges::detail::as_const(vec)}, ten_ints);
-    
-        struct Int
-        {
-            int i_;
-    
-            Int(int i) : i_{i} {}
-            operator int() const { return i_; }
-        };
-        auto vec2 = std::vector<Int>{begin(ten_ints), end(ten_ints)};
-        ::check_equal(any_view<int>{vec2}, ten_ints);
-    }
-    
-    {
-        auto v = any_view<int>{debug_input_view<int const>{
-            ten_ints.begin(), std::ptrdiff_t(ten_ints.size())
-        }};
-        ::check_equal(v, ten_ints);
-    }
-    
-    // Regression test for #880
-    {
-        using namespace ranges;
-        std::map<int, int> mm{ {0, 1}, {2, 3} };
-        any_view<int, category::forward | category::sized> as_any =
-            mm | views::keys;
-        (void)as_any;
-    }
-    
-    // Regression test for #1101
-    {
-        using namespace ranges;
-        std::vector<int> v = { 1, 2, 3, 4, 5 };
-    
-        using SizedAnyView =
-            any_view<int, category::random_access | category::sized>;
-    
-        SizedAnyView av1 = v;
-        SizedAnyView av2 = av1 | views::transform( [](auto){ return 0; } ); // fail
-        SizedAnyView av3 = av1 | views::tail; // fail
-    }
-    
-    test_polymorphic_downcast();
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/cache1.cpp b/src/contrib/range-v3-0.11.0/test/view/cache1.cpp
deleted file mode 100644
index 24d26d75..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/cache1.cpp
+++ /dev/null
@@ -1,151 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-2014.
-//  Copyright Casey Carter 2017.
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#include <vector>
-#include <range/v3/view/cache1.hpp>
-#include <range/v3/view/transform.hpp>
-#include <range/v3/view/c_str.hpp>
-#include <range/v3/view/move.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-using namespace ranges;
-
-int main()
-{
-    {
-        int count = 0;
-        std::vector<int> v{1,2,3};
-        auto rng = v | views::transform([&count](int i){ ++count; return i;})
-            | views::cache1;
-        using Rng = decltype(rng);
-        CPP_assert(!range<Rng const>);
-        CPP_assert(input_range<Rng>);
-        CPP_assert(!forward_range<Rng>);
-        CPP_assert(common_range<Rng>);
-        CPP_assert(view_<Rng>);
-        CPP_assert(sized_range<Rng>);
-        CPP_assert(sized_sentinel_for<sentinel_t<Rng>, iterator_t<Rng>>);
-        CPP_assert(same_as<range_value_t<Rng>, int>);
-        CPP_assert(same_as<range_reference_t<Rng>, int &&>);
-        CPP_assert(same_as<range_rvalue_reference_t<Rng>, int &&>);
-        CHECK(count == 0);
-        auto it = ranges::begin(rng);
-        CHECK(count == 0);
-        auto last = ranges::end(rng);
-        CHECK(it != last);
-        CHECK(count == 0);
-        CHECK(*it == 1);
-        CHECK(count == 1);
-        CHECK(*it == 1);
-        CHECK(count == 1);
-        ++it;
-        CHECK(it != last);
-        CHECK(count == 1);
-        CHECK(*it == 2);
-        CHECK(count == 2);
-        CHECK(*it == 2);
-        CHECK(count == 2);
-        ++it;
-        CHECK(it != last);
-        CHECK(count == 2);
-        CHECK(*it == 3);
-        CHECK(count == 3);
-        CHECK(*it == 3);
-        CHECK(count == 3);
-        ++it;
-        CHECK(count == 3);
-        CHECK(it == last);
-    }
-
-    {
-        int count = 0;
-        char const * hi = "hi";
-        auto rng = views::c_str(hi)
-            | views::transform([&count](char ch){ ++count; return ch;})
-            | views::cache1;
-        using Rng = decltype(rng);
-        CPP_assert(!range<Rng const>);
-        CPP_assert(input_range<Rng>);
-        CPP_assert(!forward_range<Rng>);
-        CPP_assert(!common_range<Rng>);
-        CPP_assert(view_<Rng>);
-        CPP_assert(!sized_range<Rng>);
-        CPP_assert(!sized_sentinel_for<sentinel_t<Rng>, iterator_t<Rng>>);
-        CPP_assert(same_as<range_value_t<Rng>, char>);
-        CPP_assert(same_as<range_reference_t<Rng>, char &&>);
-        CPP_assert(same_as<range_rvalue_reference_t<Rng>, char &&>);
-        CHECK(count == 0);
-        auto it = ranges::begin(rng);
-        CHECK(count == 0);
-        auto last = ranges::end(rng);
-        CHECK(it != last);
-        CHECK(count == 0);
-        CHECK(*it == 'h');
-        CHECK(count == 1);
-        CHECK(*it == 'h');
-        CHECK(count == 1);
-        ++it;
-        CHECK(it != last);
-        CHECK(count == 1);
-        CHECK(*it == 'i');
-        CHECK(count == 2);
-        CHECK(*it == 'i');
-        CHECK(count == 2);
-        ++it;
-        CHECK(count == 2);
-        CHECK(it == last);
-    }
-
-    {
-        int count = 0;
-        MoveOnlyString rg[] = {"hello", "world"};
-        auto rng = rg
-            | views::move
-            | views::transform([&count](auto s){ ++count; RANGES_ENSURE(s != ""); return s;})
-            | views::cache1;
-        using Rng = decltype(rng);
-        CPP_assert(!range<Rng const>);
-        CPP_assert(input_range<Rng>);
-        CPP_assert(!forward_range<Rng>);
-        CPP_assert(common_range<Rng>);
-        CPP_assert(view_<Rng>);
-        CPP_assert(sized_range<Rng>);
-        CPP_assert(sized_sentinel_for<sentinel_t<Rng>, iterator_t<Rng>>);
-        CPP_assert(same_as<range_value_t<Rng>, MoveOnlyString>);
-        CPP_assert(same_as<range_reference_t<Rng>, MoveOnlyString &&>);
-        CPP_assert(same_as<range_rvalue_reference_t<Rng>, MoveOnlyString &&>);
-        CHECK(count == 0);
-        auto it = ranges::begin(rng);
-        CHECK(count == 0);
-        auto last = ranges::end(rng);
-        CHECK(it != last);
-        CHECK(count == 0);
-        CHECK((*it == "hello"));
-        CHECK(count == 1);
-        CHECK((*it == "hello"));
-        CHECK(count == 1);
-        ++it;
-        CHECK(it != last);
-        CHECK(count == 1);
-        CHECK((*it == "world"));
-        CHECK(count == 2);
-        CHECK((*it == "world"));
-        CHECK(count == 2);
-        ++it;
-        CHECK(count == 2);
-        CHECK(it == last);
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/cartesian_product.cpp b/src/contrib/range-v3-0.11.0/test/view/cartesian_product.cpp
deleted file mode 100644
index 6d02ad52..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/cartesian_product.cpp
+++ /dev/null
@@ -1,354 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-2014.
-//  Copyright Casey Carter 2017.
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#include <climits>
-#include <iostream>
-#include <range/v3/range/access.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/range_for.hpp>
-#include <range/v3/view/span.hpp>
-#include <range/v3/utility/tuple_algorithm.hpp>
-#include <range/v3/view/cartesian_product.hpp>
-#include <range/v3/view/chunk.hpp>
-#include <range/v3/view/empty.hpp>
-#include <range/v3/view/filter.hpp>
-#include <range/v3/view/indices.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/reverse.hpp>
-#include <range/v3/view/single.hpp>
-#include <range/v3/view/take_exactly.hpp>
-#include <range/v3/view/transform.hpp>
-#include <range/v3/view/filter.hpp>
-#include <range/v3/view/enumerate.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-RANGES_DIAGNOSTIC_IGNORE_RANGE_LOOP_ANALYSIS
-
-using namespace ranges;
-
-struct printer
-{
-    std::ostream &os_;
-    bool &first_;
-
-    template<typename T>
-    void operator()(T const &t) const
-    {
-        if (first_) first_ = false;
-        else os_ << ',';
-        os_ << t;
-    }
-};
-
-namespace std
-{
-    template<typename... Ts>
-    std::ostream &operator<<(std::ostream &os, std::tuple<Ts...> const &t)
-    {
-        os << '(';
-        auto first = true;
-        ::ranges::tuple_for_each(t, ::printer{os, first});
-        os << ')';
-        return os;
-    }
-}
-
-void test_empty_set()
-{
-    auto rng = views::cartesian_product();
-    using Rng = decltype(rng);
-    CPP_assert(range_cardinality<Rng>::value ==
-        static_cast<cardinality>(0));
-
-    CPP_assert(random_access_range<Rng> && view_<Rng>);
-    CPP_assert(common_range<Rng>);
-    CPP_assert(sized_range<Rng>);
-    CHECK(size(rng) == 0u);
-    CHECK(empty(rng));
-
-    CPP_assert(std::is_same<
-        range_value_t<Rng>,
-        std::tuple<>>());
-    CPP_assert(std::is_same<
-        range_reference_t<Rng>,
-        std::tuple<>&>());
-
-    std::initializer_list<common_tuple<>> control{};
-    ::check_equal(rng, control);
-    ::check_equal(views::reverse(rng), views::reverse(control));
-
-    auto const first = begin(rng);
-    auto const last = end(rng);
-    CHECK(decltype(size(rng))(last - first) == size(rng));
-    for(auto i = 0; i <= distance(rng); ++i)
-    {
-        for(auto j = 0; j <= distance(rng); ++j)
-        {
-            CHECK((next(first, i) - next(first, j)) == i - j);
-        }
-    }
-}
-
-void test_empty_range()
-{
-    int some_ints[] = {0,1,2,3};
-    auto e = views::empty<char>;
-    auto rng = views::cartesian_product(
-        span<int, size(some_ints)>{some_ints},
-        e
-    );
-    using Rng = decltype(rng);
-    CPP_assert(range_cardinality<Rng>::value ==
-        static_cast<cardinality>(0));
-
-    CPP_assert(random_access_range<Rng> && view_<Rng>);
-    CPP_assert(common_range<Rng>);
-    CPP_assert(sized_range<Rng>);
-    CHECK(size(rng) == 0u);
-
-    CPP_assert(std::is_same<
-        range_value_t<Rng>,
-        std::tuple<int, char>>());
-    CPP_assert(std::is_same<
-        range_reference_t<Rng>,
-        common_tuple<int &, char &>>());
-
-    using CT = common_tuple<int, char>;
-    std::initializer_list<CT> control = {};
-
-    ::check_equal(rng, control);
-    ::check_equal(views::reverse(rng), views::reverse(control));
-
-    auto const first = begin(rng);
-    auto const last = end(rng);
-    CHECK((last - first) == (std::intmax_t) size(rng));
-    for(auto i = 0; i <= distance(rng); ++i)
-    {
-        for(auto j = 0; j <= distance(rng); ++j)
-        {
-            CHECK((next(first, i) - next(first, j)) == i - j);
-        }
-    }
-}
-
-void test_bug_820()
-{
-    // https://github.com/ericniebler/range-v3/issues/820
-    using CT = common_tuple<int, int>;
-    std::initializer_list<CT> control = {
-        CT{0, 0}, CT{0, 1}, CT{0, 2},
-        CT{1, 0}, CT{1, 1}, CT{1, 2},
-        CT{2, 0}, CT{2, 1}, CT{2, 2}
-    };
-
-    auto x = ranges::views::iota(0) | ranges::views::take_exactly(3);
-    auto y = ranges::views::cartesian_product(x, x);
-    ::check_equal(y, control);
-}
-
-void test_bug_823()
-{
-    // https://github.com/ericniebler/range-v3/issues/823
-    auto three = ranges::views::iota(0) | ranges::views::take_exactly(3);
-    CPP_assert(ranges::random_access_range<decltype(three)> && ranges::view_<decltype(three)>);
-    CPP_assert(!(ranges::random_access_range<const decltype(three)> && ranges::view_<const decltype(three)>));
-
-    auto prod = ranges::views::cartesian_product(three, three);
-    CPP_assert(ranges::random_access_range<decltype(prod)> && ranges::view_<decltype(prod)>);
-    CPP_assert(!(ranges::random_access_range<const decltype(prod)> && ranges::view_<const decltype(prod)>));
-    CPP_assert(ranges::sized_range<decltype(prod)>);
-    CHECK(ranges::size(prod) == 9u);
-
-    {
-        int i = 0;
-        RANGES_FOR(auto&& x, prod) {
-            (void)x;
-            RANGES_ENSURE(i++ < 3 * 3);
-        }
-        CHECK(i == 3 * 3);
-    }
-
-    auto twoD = prod | ranges::views::chunk(3);
-    CPP_assert(ranges::random_access_range<decltype(twoD)> && ranges::view_<decltype(twoD)>);
-    CPP_assert(!(ranges::random_access_range<const decltype(twoD)> && ranges::view_<const decltype(twoD)>));
-
-    {
-        int i = 0;
-        RANGES_FOR(auto&& row, twoD) {
-            (void)row;
-            RANGES_ENSURE(i++ < 3);
-        }
-        CHECK(i == 3);
-    }
-
-    {
-        int i = 0;
-        RANGES_FOR(auto&& row, twoD) {
-            RANGES_ENSURE(i++ < 3);
-            int j = 0;
-            RANGES_FOR(auto&& col, row) {
-                (void)col;
-                RANGES_ENSURE(j++ < 3);
-            }
-            CHECK(j == 3);
-        }
-        CHECK(i == 3);
-    }
-}
-
-void test_bug_919()
-{
-    // https://github.com/ericniebler/range-v3/issues/919
-    int some_ints[] = {0,1,2,3};
-    char const * some_strings[] = {"John", "Paul", "George", "Ringo"};
-    auto rng = views::cartesian_product(
-        span<int, size(some_ints)>{some_ints},
-        span<char const*, size(some_strings)>{some_strings}
-    );
-    constexpr std::intmax_t n = size(rng);
-    static_assert(n == 16, "");
-
-    for (std::intmax_t i = 0; i <= n; ++i) {
-        auto const x = rng.begin() + i;
-        CHECK((x == rng.end() - (n - i)));
-        for (std::intmax_t j = 0; j <= n; ++j)
-            CHECK((rng.begin() + j == x + (j - i)));
-    }
-}
-
-void test_bug_978()
-{
-    // https://github.com/ericniebler/range-v3/issues/978
-    int rgi[] = {1};
-    ranges::views::cartesian_product(
-        rgi | ranges::views::filter([](int){ return true; }),
-        rgi
-    );
-}
-
-void test_bug_1269()
-{
-    // https://github.com/ericniebler/range-v3/issues/1269
-    int data0[2]{}, data1[3]{}, data2[5]{}, data3[7]{};
-    constexpr std::size_t N = ranges::size(data0) * ranges::size(data1) *
-        ranges::size(data2) * ranges::size(data3);
-    CPP_assert(N < INT_MAX);
-
-    auto rng = ranges::views::cartesian_product(data0, data1, data2, data3);
-    CPP_assert(ranges::sized_range<decltype(rng)>);
-    CHECK(ranges::size(rng) == N);
-
-    CPP_assert(ranges::random_access_range<decltype(rng)>);
-    CPP_assert(ranges::sized_sentinel_for<ranges::sentinel_t<decltype(rng)>, ranges::iterator_t<decltype(rng)>>);
-    for (int i = 0; i < int{N}; ++i)
-    {
-        auto pos = ranges::begin(rng) + i;
-        CHECK((ranges::end(rng) - pos) == std::intmax_t{N} - i);
-    }
-}
-
-void test_bug_1279()
-{
-    // https://github.com/ericniebler/range-v3/issues/1279
-    auto const xs = ranges::views::indices(std::size_t{0}, std::size_t{10});
-    auto const ys = ranges::views::indices(std::size_t{0}, std::size_t{10});
-
-    for(auto r : ranges::views::cartesian_product(ys, xs))
-    {
-        (void) r;
-    }
-}
-
-void test_bug_1296()
-{
-    // https://github.com/ericniebler/range-v3/issues/1296
-    auto v = ranges::views::cartesian_product(ranges::views::single(42))
-        | ranges::views::transform([](std::tuple<int> a) {
-            return std::get<0>(a);
-        });
-
-    CHECK(ranges::size(v) == 1u);
-    CHECK(*ranges::begin(v) == 42);
-}
-
-// https://github.com/ericniebler/range-v3/issues/1422
-void test_1422()
-{
-    int v1[] = {1,2,3};
-    auto e = v1 | ranges::views::enumerate;
-    auto cp = ranges::views::cartesian_product(e, e);
-    using CP = decltype(cp);
-    CPP_assert(ranges::input_range<CP>);
-}
-
-int main()
-{
-    int some_ints[] = {0,1,2,3};
-    char const * some_strings[] = {"John", "Paul", "George", "Ringo"};
-    auto rng = views::cartesian_product(
-        span<int, size(some_ints)>{some_ints},
-        span<char const*, size(some_strings)>{some_strings}
-    );
-    using Rng = decltype(rng);
-    CPP_assert(range_cardinality<Rng>::value ==
-        range_cardinality<decltype(some_ints)>::value *
-        range_cardinality<decltype(some_strings)>::value);
-
-    CPP_assert(random_access_range<Rng> && view_<Rng>);
-    CPP_assert(common_range<Rng>);
-    CPP_assert(sized_range<Rng>);
-    CHECK(size(rng) == size(some_ints) * size(some_strings));
-
-    CPP_assert(std::is_same<
-        range_value_t<Rng>,
-        std::tuple<int, char const *>>());
-    CPP_assert(std::is_same<
-        range_reference_t<Rng>,
-        common_tuple<int &, char const * &>>());
-
-    using CT = common_tuple<int, std::string>;
-    std::initializer_list<CT> control = {
-        CT{0, "John"}, CT{0, "Paul"}, CT{0, "George"}, CT{0, "Ringo"},
-        CT{1, "John"}, CT{1, "Paul"}, CT{1, "George"}, CT{1, "Ringo"},
-        CT{2, "John"}, CT{2, "Paul"}, CT{2, "George"}, CT{2, "Ringo"},
-        CT{3, "John"}, CT{3, "Paul"}, CT{3, "George"}, CT{3, "Ringo"}
-    };
-
-    ::check_equal(rng, control);
-    ::check_equal(views::reverse(rng), views::reverse(control));
-
-    auto const first = begin(rng);
-    auto const last = end(rng);
-    CHECK((last - first) == (std::intmax_t) size(rng));
-    for(auto i = 0; i <= distance(rng); ++i)
-    {
-        for(auto j = 0; j <= distance(rng); ++j)
-        {
-            CHECK((next(first, i) - next(first, j)) == i - j);
-        }
-    }
-
-    test_empty_set();
-    test_empty_range();
-    test_bug_820();
-    test_bug_823();
-    test_bug_919();
-    test_bug_978();
-    test_bug_1269();
-    test_bug_1279();
-    test_bug_1296();
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/chunk.cpp b/src/contrib/range-v3-0.11.0/test/view/chunk.cpp
deleted file mode 100644
index 83daac8f..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/chunk.cpp
+++ /dev/null
@@ -1,236 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <iostream>
-#include <forward_list>
-#include <list>
-#include <vector>
-#include <range/v3/range/conversion.hpp>
-#include <range/v3/view/chunk.hpp>
-#include <range/v3/view/cycle.hpp>
-#include <range/v3/view/filter.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/join.hpp>
-#include <range/v3/view/move.hpp>
-#include <range/v3/view/repeat.hpp>
-#include <range/v3/view/reverse.hpp>
-#include "../simple_test.hpp"
-#include "../test_iterators.hpp"
-#include "../test_utils.hpp"
-
-using namespace ranges;
-
-namespace
-{
-    void test_input_ranges()
-    {
-        int const ints[] = {0,1,2,3,4};
-        static constexpr auto N = ranges::size(ints);
-        static constexpr auto K = 2;
-        auto make_range = [&]{ return debug_input_view<int const>{ints} | views::chunk(K); };
-        auto rng = make_range();
-        using Rng = decltype(rng);
-        CPP_assert(input_range<Rng>);
-        CPP_assert(view_<Rng>);
-        CPP_assert(!forward_range<Rng>);
-        CPP_assert(sized_range<Rng>);
-        CHECK(ranges::size(rng) == (N + K - 1) / K);
-        CPP_assert(sized_sentinel_for<sentinel_t<Rng>, iterator_t<Rng>>);
-        CHECK((ranges::end(rng) - ranges::begin(rng)) == int((N + K - 1) / K));
-
-        rng = make_range();
-        auto i = ranges::begin(rng);
-        auto e = ranges::end(rng);
-        CHECK(i != e);
-        if (i == e) return;
-        {
-            auto r = *i;
-            CHECK(ranges::size(r) == 2u);
-            auto ii = ranges::begin(r);
-            auto ee = ranges::end(r);
-            CHECK(ii != ee);
-            if (ii == ee) return;
-            CHECK((ee - ii) == 2);
-            CHECK(*ii == 0);
-            CHECK(++ii != ee);
-            if (ii == ee) return;
-            CHECK((ee - ii) == 1);
-            CHECK(*ii == 1);
-            CHECK(++ii == ee);
-            CHECK((ee - ii) == 0);
-        }
-        CHECK(++i != e);
-        if (i == e) return;
-        ::check_equal(*i, {2,3});
-        CHECK(++i != e);
-        if (i != e)
-        {
-            ::check_equal(*i, {4});
-            CHECK(++i == e);
-        }
-    }
-}
-
-int main()
-{
-    {
-        auto v = views::iota(0,11) | to<std::vector>();
-        auto rng1 = v | views::chunk(3);
-        CPP_assert(random_access_range<decltype(rng1)>);
-        CPP_assert(sized_range<decltype(rng1)>);
-        auto it1 = ranges::begin(rng1);
-        ::check_equal(*it1++, {0,1,2});
-        ::check_equal(*it1++, {3,4,5});
-        ::check_equal(*it1++, {6,7,8});
-        ::check_equal(*it1++, {9,10});
-        CHECK(it1 == ranges::end(rng1));
-        ::check_equal(*ranges::next(it1, -3), {3,4,5});
-        CHECK(size(rng1), 4u);
-        CHECK(sizeof(rng1.begin()) == sizeof(v.begin()) * 2 + sizeof(std::ptrdiff_t) * 2);
-    }
-
-    {
-        auto l = views::iota(0,11) | to<std::forward_list>();
-        auto rng2 = l | views::chunk(3);
-        CPP_assert(forward_range<decltype(rng2)>);
-        CPP_assert(!bidirectional_range<decltype(rng2)>);
-        CPP_assert(!sized_range<decltype(rng2)>);
-        auto it2 = ranges::begin(rng2);
-        ::check_equal(*it2++, {0,1,2});
-        ::check_equal(*it2++, {3,4,5});
-        ::check_equal(*it2++, {6,7,8});
-        ::check_equal(*it2++, {9,10});
-        CHECK(it2 == ranges::end(rng2));
-        CHECK(sizeof(rng2.begin()) == sizeof(l.begin()) * 2 + sizeof(std::ptrdiff_t));
-    }
-
-    {
-        // An infinite, cyclic range with cycle length == 1
-        auto fives = views::repeat(5);
-        CPP_assert(random_access_range<decltype(fives)>);
-        auto rng = fives | views::chunk(3);
-        CPP_assert(random_access_range<decltype(rng)>);
-        auto it = rng.begin();
-        auto it2 = next(it,3);
-        CHECK((it2 - it) == 3);
-        ::check_equal(*it, {5,5,5});
-        ::check_equal(*it2, {5,5,5});
-    }
-
-    {
-        // An infinite, cyclic range with cycle length == 3
-        int const ints[] = {0,1,2};
-        auto cyc = ints | views::cycle;
-        //[0,1],[2,0],[1,2],[0,1],[2,0],[1,2],
-        auto rng = cyc | views::chunk(2);
-        CPP_assert(random_access_range<decltype(rng)>);
-        auto it = rng.begin();
-        auto it2 = next(it,2);
-        ::check_equal(*it, {0,1});
-        ::check_equal(*it2, {1,2});
-        CHECK((it - it) == 0);
-        CHECK((next(it,1) - it) == 1);
-        CHECK((next(it,2) - it) == 2);
-        CHECK((next(it,3) - it) == 3);
-        CHECK((next(it,4) - it) == 4);
-        CHECK((next(it,5) - it) == 5);
-        CHECK((next(it,6) - it) == 6);
-        CHECK((next(it,7) - it) == 7    );
-    }
-
-    {
-        // An infinite, cyclic range with cycle length == 3
-        int const ints[] = {0,1,2};
-        auto cyc = ints | views::cycle;
-        //[0,1,2,0],[1,2,0,1],[2,0,1,2],...
-        auto rng = cyc | views::chunk(4);
-        CPP_assert(random_access_range<decltype(rng)>);
-        auto it = rng.begin();
-        auto it2 = next(it,2);
-        ::check_equal(*it, {0,1,2,0});
-        ::check_equal(*it2, {2,0,1,2});
-        // Strange, but not wrong necessarily:
-        CHECK((it - it) == 0);
-        CHECK((next(it,1) - it) == 1);
-        CHECK((next(it,2) - it) == 2);
-        CHECK((next(it,3) - it) == 3);
-        CHECK((next(it,4) - it) == 4);
-        CHECK((next(it,5) - it) == 5);
-        CHECK((next(it,6) - it) == 6);
-        CHECK((next(it,7) - it) == 7);
-    }
-
-    {
-        // An infinite, cyclic range with cycle length == 10
-        int const ints[] = {0,1,2,3,4,5,6,7,8,9};
-        auto cyc = ints | views::cycle;
-        auto rng = cyc | views::chunk(3);
-        CPP_assert(random_access_range<decltype(rng)>);
-        //[0,1,2],[3,4,5],[6,7,8],[9,0,1],[2,3,4],...
-        auto it = rng.begin();
-        auto it2 = next(it,2);
-        ::check_equal(*it, {0,1,2});
-        ::check_equal(*it2, {6,7,8});
-        // Strange, but not wrong necessarily:
-        CHECK((it - it) == 0);
-        CHECK((next(it,1) - it) == 1);
-        CHECK((next(it,2) - it) == 2);
-        CHECK((next(it,3) - it) == 3);
-        CHECK((next(it,4) - it) == 4);
-        CHECK((next(it,5) - it) == 5);
-        CHECK((next(it,6) - it) == 6);
-        CHECK((next(it,7) - it) == 7);
-        CHECK((next(it,8) - it) == 8);
-        CHECK((next(it,9) - it) == 9);
-        CHECK((next(it,10) - it) == 10);
-        CHECK((next(it,11) - it) == 11);
-        CHECK((next(it,12) - it) == 12);
-        CHECK((next(it,13) - it) == 13);
-    }
-
-    test_input_ranges();
-
-    {
-        // Regression test for #567
-        std::vector<std::vector<int>> vec{{1, 2, 3}, {4, 5, 6}};
-        auto rng = vec | views::join | views::chunk(2);
-        CPP_assert(input_range<decltype(rng)>);
-        CPP_assert(input_range<range_reference_t<decltype(rng)>>);
-        int const expected[][2] = {{1, 2}, {3, 4}, {5, 6}};
-        ::check_equal(rng, expected);
-    }
-
-    {
-        // Regression test for not-exactly #567 (https://github.com/ericniebler/range-v3/issues/567#issuecomment-315148392)
-        int some_ints[] = {0,1,2,3};
-        int const expected[][2] = {{0, 1}, {2, 3}};
-        auto rng = views::all(some_ints);
-        ::check_equal(rng | views::chunk(2), expected);
-    }
-
-    {
-        // Regression test for https://stackoverflow.com/questions/49210190
-        auto rng = views::closed_iota(1,25)
-            | views::filter([](int item){ return item % 10 != 0; })
-            | views::chunk(10);
-        auto it = ranges::begin(rng);
-        auto last = ranges::end(rng);
-        CHECK(it != last);
-        ::check_equal(*it, {1,2,3,4,5,6,7,8,9,11});
-        CHECK(++it != last);
-        ::check_equal(*it, {12,13,14,15,16,17,18,19,21,22});
-        CHECK(++it != last);
-        ::check_equal(*it, {23,24,25});
-        CHECK(++it == last);
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/common.cpp b/src/contrib/range-v3-0.11.0/test/view/common.cpp
deleted file mode 100644
index 707f7943..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/common.cpp
+++ /dev/null
@@ -1,125 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <list>
-#include <vector>
-#include <sstream>
-#include <range/v3/core.hpp>
-#include <range/v3/view/common.hpp>
-#include <range/v3/view/counted.hpp>
-#include <range/v3/view/delimit.hpp>
-#include <range/v3/view/repeat_n.hpp>
-#include <range/v3/utility/copy.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    {
-        std::stringstream sinx("1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 42 6 7 8 9 ");
-        auto rng1 = istream<int>(sinx) | views::delimit(42); // | views::common;
-        CPP_assert(!common_range<decltype(rng1)>);
-        CPP_assert(input_range<decltype(rng1)>);
-        CPP_assert(!forward_range<decltype(rng1)>);
-        auto const& crng1 = rng1;
-        CPP_assert(!range<decltype(crng1)>);
-        auto rng2 = rng1 | views::common;
-        CPP_assert(view_<decltype(rng2)>);
-        CPP_assert(common_range<decltype(rng2)>);
-        CPP_assert(input_iterator<decltype(rng2.begin())>);
-        CPP_assert(same_as<typename std::iterator_traits<decltype(rng2.begin())>::iterator_category,
-                            std::input_iterator_tag>);
-        CPP_assert(!forward_iterator<decltype(rng2.begin())>);
-        ::check_equal(rng2, {1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4});
-    }
-
-    std::vector<int> v{1,2,3,4,5,6,7,8,9,0,42,64};
-    {
-        auto rng1 = v | views::delimit(42) | views::common;
-        CPP_assert(view_<decltype(rng1)>);
-        CPP_assert(common_range<decltype(rng1)>);
-        CPP_assert(!sized_range<decltype(rng1)>);
-        CPP_assert(forward_iterator<decltype(rng1.begin())>);
-        CPP_assert(!bidirectional_iterator<decltype(rng1.begin())>);
-        auto const & crng1 = rng1;
-        auto i = rng1.begin(); // non-const
-        auto j = crng1.begin(); // const
-        j = i;
-        ::check_equal(rng1, {1, 2, 3, 4, 5, 6, 7, 8, 9, 0});
-    }
-
-    {
-        std::list<int> l{1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0};
-        auto rng3 = views::counted(l.begin(), 10) | views::common;
-        CPP_assert(view_<decltype(rng3)>);
-        CPP_assert(common_range<decltype(rng3)>);
-        CPP_assert(sized_range<decltype(rng3)>);
-        CPP_assert(forward_iterator<decltype(rng3.begin())>);
-        CPP_assert(!bidirectional_iterator<decltype(rng3.begin())>);
-        CPP_assert(sized_sentinel_for<decltype(rng3.begin()), decltype(rng3.end())>);
-        auto b = begin(rng3);
-        auto e = end(rng3);
-        CHECK((e-b) == 10);
-        CHECK((b-e) == -10);
-        CHECK((e-e) == 0);
-        CHECK((next(b)-b) == 1);
-
-        // Pass-through of already-common ranges is OK:
-        rng3 = rng3 | views::common;
-    }
-
-    {
-        auto rng4 = views::counted(begin(v), 8) | views::common;
-        CPP_assert(view_<decltype(rng4)>);
-        CPP_assert(common_range<decltype(rng4)>);
-        CPP_assert(sized_range<decltype(rng4)>);
-        CPP_assert(random_access_iterator<decltype(begin(rng4))>);
-        ::check_equal(rng4, {1, 2, 3, 4, 5, 6, 7, 8});
-    }
-
-    {
-        // Regression test for issue#504:
-        auto rng1 = views::repeat_n( 0, 10 );
-        CPP_assert(view_<decltype(rng1)>);
-        CPP_assert(!common_range<decltype(rng1)>);
-        CPP_assert(random_access_range<decltype(rng1)>);
-        CPP_assert(sized_range<decltype(rng1)>);
-        auto const& crng1 = rng1;
-        CPP_assert(random_access_range<decltype(crng1)>);
-        CPP_assert(sized_range<decltype(crng1)>);
-
-        auto rng2 = rng1 | views::common;
-        CPP_assert(view_<decltype(rng2)>);
-        CPP_assert(common_range<decltype(rng2)>);
-        CPP_assert(random_access_range<decltype(rng2)>);
-        CPP_assert(sized_range<decltype(rng2)>);
-        auto const& crng2 = rng2;
-        CPP_assert(common_range<decltype(crng2)>);
-        CPP_assert(random_access_range<decltype(crng2)>);
-        CPP_assert(sized_range<decltype(crng2)>);
-
-        ::check_equal(rng2, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0});
-    }
-
-    {
-        int const rgi[] = {1,2,3,4};
-        auto rng = debug_input_view<int const>{rgi} | views::common;
-        using Rng = decltype(rng);
-        CPP_assert(input_range<Rng> && view_<Rng>);
-        CPP_assert(!forward_range<Rng>);
-        CPP_assert(common_range<Rng>);
-        ::check_equal(rng, {1,2,3,4});
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/concat.cpp b/src/contrib/range-v3-0.11.0/test/view/concat.cpp
deleted file mode 100644
index ed18b9d6..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/concat.cpp
+++ /dev/null
@@ -1,106 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <array>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/concat.hpp>
-#include <range/v3/view/generate.hpp>
-#include <range/v3/view/reverse.hpp>
-#include <range/v3/view/remove_if.hpp>
-#include <range/v3/view/take_while.hpp>
-#include <range/v3/algorithm/equal.hpp>
-#include <range/v3/utility/copy.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    std::vector<std::string> his_face{"this", "is", "his", "face"};
-    std::vector<std::string> another_mess{"another", "fine", "mess"};
-    auto joined = views::concat(his_face, another_mess);
-    CPP_assert(view_<decltype(joined)>);
-    CPP_assert(random_access_range<decltype(joined)>);
-    static_assert(std::is_same<range_reference_t<decltype(joined)>, std::string &>::value, "");
-    CHECK(joined.size() == 7u);
-    CHECK((joined.end() - joined.begin()) == 7);
-    ::check_equal(joined | views::reverse, {"mess", "fine", "another", "face", "his", "is", "this"});
-
-    auto revjoin = joined | views::reverse;
-    CHECK((revjoin.end() - revjoin.begin()) == 7);
-
-    auto first = joined.begin();
-    CHECK(*(first+0) == "this");
-    CHECK(*(first+1) == "is");
-    CHECK(*(first+2) == "his");
-    CHECK(*(first+3) == "face");
-    CHECK(*(first+4) == "another");
-    CHECK(*(first+5) == "fine");
-    CHECK(*(first+6) == "mess");
-
-    CHECK(*(first) == "this");
-    CHECK(*(first+=1) == "is");
-    CHECK(*(first+=1) == "his");
-    CHECK(*(first+=1) == "face");
-    CHECK(*(first+=1) == "another");
-    CHECK(*(first+=1) == "fine");
-    CHECK(*(first+=1) == "mess");
-
-    auto last = joined.end();
-    CHECK(*(last-1) == "mess");
-    CHECK(*(last-2) == "fine");
-    CHECK(*(last-3) == "another");
-    CHECK(*(last-4) == "face");
-    CHECK(*(last-5) == "his");
-    CHECK(*(last-6) == "is");
-    CHECK(*(last-7) == "this");
-
-    CHECK(*(last-=1) == "mess");
-    CHECK(*(last-=1) == "fine");
-    CHECK(*(last-=1) == "another");
-    CHECK(*(last-=1) == "face");
-    CHECK(*(last-=1) == "his");
-    CHECK(*(last-=1) == "is");
-    CHECK(*(last-=1) == "this");
-
-    {
-        const std::array<int, 3> a{{0, 1, 2}};
-        const std::array<int, 2> b{{3, 4}};
-        check_equal(views::concat(a, b), {0, 1, 2, 3, 4});
-
-        auto odd = [](int i) { return i % 2 != 0; };
-        auto even_filter = ranges::views::remove_if(odd);
-
-        auto f_rng0 = a | even_filter;
-        auto f_rng1 = b | even_filter;
-
-        check_equal(views::concat(f_rng0, f_rng1), {0, 2, 4});
-    }
-
-    // Regression test for http://github.com/ericniebler/range-v3/issues/395.
-    {
-        int i = 0;
-        auto rng = ranges::views::concat(ranges::views::generate([&]{ return i++; }))
-            | ranges::views::take_while([](int j){ return j < 30; });
-        CHECK(ranges::distance(ranges::begin(rng), ranges::end(rng)) == 30);
-    }
-
-    {
-        int const rgi[] = {0,1,2,3};
-        auto dv = [&]{ return debug_input_view<int const>{rgi}; };
-        auto rng = views::concat(dv(), dv(), dv());
-        ::check_equal(rng, {0,1,2,3,0,1,2,3,0,1,2,3});
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/const.cpp b/src/contrib/range-v3-0.11.0/test/view/const.cpp
deleted file mode 100644
index 41a2cfcf..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/const.cpp
+++ /dev/null
@@ -1,99 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <iterator>
-#include <functional>
-#include <range/v3/core.hpp>
-#include <range/v3/view/const.hpp>
-#include <range/v3/view/counted.hpp>
-#include <range/v3/view/zip.hpp>
-#include <range/v3/view/move.hpp>
-#include <range/v3/utility/copy.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    int rgi[] = {1, 2, 3, 4};
-
-    {
-        auto rng = rgi | views::const_;
-        has_type<int &>(*begin(rgi));
-        has_type<int const &>(*begin(rng));
-        CPP_assert(same_as<range_rvalue_reference_t<decltype(rng)>, int const &&>);
-        CPP_assert(view_<decltype(rng)>);
-        CPP_assert(common_range<decltype(rng)>);
-        CPP_assert(sized_range<decltype(rng)>);
-        CPP_assert(random_access_range<decltype(rng)>);
-        ::check_equal(rng, {1, 2, 3, 4});
-        CHECK(&*begin(rng) == &rgi[0]);
-        CHECK(rng.size() == 4u);
-    }
-
-    {
-        auto rng2 = views::counted(ForwardIterator<int*>(rgi), 4) | views::const_;
-        has_type<int const &>(*begin(rng2));
-        CPP_assert(same_as<range_rvalue_reference_t<decltype(rng2)>, int const &&>);
-        CPP_assert(view_<decltype(rng2)>);
-        CPP_assert(forward_range<decltype(rng2)>);
-        CPP_assert(!bidirectional_range<decltype(rng2)>);
-        CPP_assert(!common_range<decltype(rng2)>);
-        CPP_assert(sized_range<decltype(rng2)>);
-        ::check_equal(rng2, {1, 2, 3, 4});
-        CHECK(&*begin(rng2) == &rgi[0]);
-        CHECK(rng2.size() == 4u);
-    }
-
-    {
-        auto zip = views::zip(rgi, rgi);
-        auto rng3 = zip | views::const_;
-        has_type<common_pair<int &, int &>>(*begin(zip));
-        has_type<common_pair<int &&, int &&>>(iter_move(begin(zip)));
-        has_type<common_pair<int const &, int const &>>(*begin(rng3));
-        has_type<common_pair<int const &&, int const &&>>(iter_move(begin(rng3)));
-        CPP_assert(view_<decltype(rng3)>);
-        CPP_assert(random_access_range<decltype(rng3)>);
-        CPP_assert(common_range<decltype(rng3)>);
-        CPP_assert(sized_range<decltype(rng3)>);
-        using P = std::pair<int,int>;
-        ::check_equal(rng3, {P{1,1}, P{2,2}, P{3,3}, P{4,4}});
-        CHECK(&(*begin(rng3)).first == &rgi[0]);
-        CHECK(rng3.size() == 4u);
-    }
-
-    {
-        auto zip2 = views::zip(rgi, rgi) | views::move;
-        auto rng4 = zip2 | views::const_;
-        has_type<common_pair<int &&, int &&>>(*begin(zip2));
-        has_type<common_pair<int &&, int &&>>(iter_move(begin(zip2)));
-        has_type<common_pair<int const &&, int const &&>>(*begin(rng4));
-        has_type<common_pair<int const &&, int const &&>>(iter_move(begin(rng4)));
-        CPP_assert(view_<decltype(rng4)>);
-        CPP_assert(random_access_range<decltype(rng4)>);
-        CPP_assert(common_range<decltype(rng4)>);
-        CPP_assert(sized_range<decltype(rng4)>);
-        using P = std::pair<int,int>;
-        ::check_equal(rng4, {P{1,1}, P{2,2}, P{3,3}, P{4,4}});
-        CHECK(&(*begin(rng4)).first == &rgi[0]);
-        CHECK(rng4.size() == 4u);
-    }
-
-    {
-        auto rng = debug_input_view<int>{rgi} | views::const_;
-        CPP_assert(same_as<int const&, range_reference_t<decltype(rng)>>);
-        ::check_equal(rng, rgi);
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/conversion.cpp b/src/contrib/range-v3-0.11.0/test/view/conversion.cpp
deleted file mode 100644
index 85478a4d..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/conversion.cpp
+++ /dev/null
@@ -1,99 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <utility> // for std::swap on C++14.
-#include <map>
-#include <set>
-#include <list>
-#include <sstream>
-#include <string>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/any_view.hpp>
-#include <range/v3/view/concat.hpp>
-#include <range/v3/view/drop.hpp>
-#include <range/v3/view/take.hpp>
-#include <range/v3/view/repeat.hpp>
-#include <range/v3/view/reverse.hpp>
-#include <range/v3/view/transform.hpp>
-#include <range/v3/view/for_each.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/zip.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    // 1-d vector
-
-    auto v = views::ints | views::take(10) | to<std::vector>();
-    ::check_equal(v, {0,1,2,3,4,5,6,7,8,9});
-
-    v = views::iota(10) | views::take(10) | views::reverse | to<std::vector>();
-    ::check_equal(v, {19,18,17,16,15,14,13,12,11,10});
-
-    // 1-d list
-
-    auto l = views::ints | views::take(10) | to<std::list>();
-    ::check_equal(l, {0,1,2,3,4,5,6,7,8,9});
-
-    l = views::iota(10) | views::take(10) | views::reverse | to<std::list>();
-    ::check_equal(l, {19,18,17,16,15,14,13,12,11,10});
-
-    // 2-d vector
-
-    auto vv = views::repeat_n(views::ints(0, 8), 10) | to<std::vector<std::vector<int>>>();
-    ::check_equal(vv, std::vector<std::vector<int>>(10, {0,1,2,3,4,5,6,7}));
-
-    // issue #556
-
-    {
-        std::string s{"abc"};
-        any_view<any_view<char, category::random_access>, category::random_access> v1 =
-            views::single(s | views::drop(1));
-        any_view<any_view<char, category::random_access>, category::random_access> v2 =
-            views::single(s | views::drop(2));
-        auto v3 = views::concat(v1, v2);
-
-        auto owner1 = v3 | to<std::vector<std::vector<char>>>();
-        auto owner2 = v3 | to<std::vector<std::string>>();
-
-        ::check_equal(owner1, std::vector<std::vector<char>>{{'b', 'c'}, {'c'}});
-        ::check_equal(owner2, std::vector<std::string>{{"bc"}, {"c"}});
-    }
-
-    // map
-
-    auto to_string = [](int i){ std::stringstream str; str << i; return str.str(); };
-    auto m = views::zip(views::ints, views::ints | views::transform(to_string)) |
-        views::take(5) | to<std::map<int, std::string>>();
-    using P = std::pair<int const, std::string>;
-    ::check_equal(m, {P{0,"0"}, P{1,"1"}, P{2,"2"}, P{3,"3"}, P{4,"4"}});
-
-    // Another way to say the same thing, but with a range comprehension:
-    m = views::for_each(views::ints(0,5), [&](int i) {
-            return yield(std::make_pair(i, to_string(i)));
-        }) | to<std::map<int, std::string>>();
-    ::check_equal(m, {P{0,"0"}, P{1,"1"}, P{2,"2"}, P{3,"3"}, P{4,"4"}});
-
-    // set
-
-    CPP_assert(range<std::set<int>>);
-    CPP_assert(!view_<std::set<int>>);
-    auto s = views::ints | views::take(10) | to<std::set<int>>();
-    ::check_equal(s, {0,1,2,3,4,5,6,7,8,9});
-
-    static_assert(!view_<std::initializer_list<int>>, "");
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/counted.cpp b/src/contrib/range-v3-0.11.0/test/view/counted.cpp
deleted file mode 100644
index 76d84cf6..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/counted.cpp
+++ /dev/null
@@ -1,75 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <list>
-#include <range/v3/core.hpp>
-#include <range/v3/view/counted.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-struct fortytwo_erator {
-    using difference_type = int;
-    using value_type = int;
-    fortytwo_erator() = default;
-    int operator*() const { return 42; }
-    fortytwo_erator& operator++() { return *this; }
-    void operator++(int) {}
-};
-
-int main()
-{
-    using namespace ranges;
-    std::cout << "\nTesting counted\n";
-
-    {
-        int rgi[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
-        auto rng = views::counted(ForwardIterator<int*>{rgi}, 10);
-        rng.size();
-        CPP_assert(sized_range<decltype(rng)> && view_<decltype(rng)>);
-        auto i = rng.begin();
-        auto b = i.base();
-        auto c = i.count();
-        decltype(i) j{b, c};
-        ::check_equal(rng, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10});
-        static_assert(std::is_same<decltype(i), counted_iterator<ForwardIterator<int*>>>::value, "");
-    }
-
-    {
-        std::list<int> l;
-        counted_iterator<std::list<int>::iterator> a(l.begin(), 0);
-        counted_iterator<std::list<int>::const_iterator> b(l.begin(), 0);
-
-        detail::ignore_unused(
-            a-a,
-            b-b,
-            a-b,
-            b-a);
-
-        counted_iterator<char*> c(nullptr, 0);
-        counted_iterator<char const*> d(nullptr, 0);
-        detail::ignore_unused(
-            c-c,
-            d-d,
-            c-d,
-            d-c);
-    }
-
-    {
-        // Regression test: ensure that we can post-increment a counted_iterator<I>
-        // when decltype(declval<I &>()++) is void.
-        CPP_assert(ranges::input_iterator<fortytwo_erator>);
-        ranges::counted_iterator<fortytwo_erator> c{{}, 42};
-        c++;
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/cycle.cpp b/src/contrib/range-v3-0.11.0/test/view/cycle.cpp
deleted file mode 100644
index f8287be0..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/cycle.cpp
+++ /dev/null
@@ -1,347 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//  Copyright Gonzalo Brito Gadeschi 2015
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <list>
-#include <array>
-#include <vector>
-#include <memory>
-#include <forward_list>
-#include <range/v3/range_for.hpp>
-#include <range/v3/algorithm/count_if.hpp>
-#include <range/v3/view/cycle.hpp>
-#include <range/v3/view/take.hpp>
-#include <range/v3/view/take_exactly.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/reverse.hpp>
-#include <range/v3/view/slice.hpp>
-#include <range/v3/view/c_str.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-using namespace ranges;
-
-template<typename Rng>
-void test_const_forward_range(Rng const &rng)
-{
-    auto r = rng | views::cycle;
-    static_assert(is_infinite<decltype(r)>{}, "");
-    static_assert(!common_range<decltype(r)>, "");
-    CHECK(distance(r | views::take_exactly(0)) == 0);
-    CHECK(distance(r | views::take_exactly(1)) == 1);
-    CHECK(distance(r | views::take_exactly(2)) == 2);
-    CHECK(distance(r | views::take_exactly(3)) == 3);
-    CHECK(distance(r | views::take_exactly(4)) == 4);
-    CHECK(distance(r | views::take_exactly(6)) == 6);
-    CHECK(distance(r | views::take_exactly(7)) == 7);
-    CHECK(count_if(r | views::take_exactly(7), [](int) { return true; }) == 7);
-
-    ::check_equal(r | views::take_exactly(0), std::array<int, 0>{});
-    ::check_equal(r | views::take_exactly(1), {0});
-    ::check_equal(r | views::take_exactly(2), {0, 1});
-    ::check_equal(r | views::take_exactly(3), {0, 1, 2});
-    ::check_equal(r | views::take_exactly(4), {0, 1, 2, 0});
-    ::check_equal(r | views::take_exactly(6), {0, 1, 2, 0, 1, 2});
-    ::check_equal(r | views::take_exactly(7), {0, 1, 2, 0, 1, 2, 0});
-
-    CHECK(distance(r | views::take(0)) == 0);
-    CHECK(distance(r | views::take(1)) == 1);
-    CHECK(distance(r | views::take(2)) == 2);
-    CHECK(distance(r | views::take(3)) == 3);
-    CHECK(distance(r | views::take(4)) == 4);
-    CHECK(distance(r | views::take(6)) == 6);
-    CHECK(distance(r | views::take(7)) == 7);
-    CHECK(count_if(r | views::take(7), [](int) { return true; }) == 7);
-
-    ::check_equal(r | views::take(0), std::array<int, 0>{});
-    ::check_equal(r | views::take(1), {0});
-    ::check_equal(r | views::take(2), {0, 1});
-    ::check_equal(r | views::take(3), {0, 1, 2});
-    ::check_equal(r | views::take(4), {0, 1, 2, 0});
-    ::check_equal(r | views::take(6), {0, 1, 2, 0, 1, 2});
-    ::check_equal(r | views::take(7), {0, 1, 2, 0, 1, 2, 0});
-}
-
-template<typename Rng>
-void test_const_forward_reversed_range(Rng const &rng)
-{
-    test_const_forward_range(rng);
-
-    auto r = rng | views::reverse | views::cycle;
-    static_assert(is_infinite<decltype(r)>{}, "");
-    static_assert(!common_range<decltype(r)>, "");
-
-    CHECK(distance(r | views::take_exactly(0)) == 0);
-    CHECK(distance(r | views::take_exactly(1)) == 1);
-    CHECK(distance(r | views::take_exactly(2)) == 2);
-    CHECK(distance(r | views::take_exactly(3)) == 3);
-    CHECK(distance(r | views::take_exactly(4)) == 4);
-    CHECK(distance(r | views::take_exactly(6)) == 6);
-    CHECK(distance(r | views::take_exactly(7)) == 7);
-    CHECK(count_if(r | views::take_exactly(7), [](int) { return true; }) == 7);
-
-    ::check_equal(r | views::take_exactly(0), std::array<int, 0>{});
-    ::check_equal(r | views::take_exactly(1), {2});
-    ::check_equal(r | views::take_exactly(2), {2, 1});
-    ::check_equal(r | views::take_exactly(3), {2, 1, 0});
-    ::check_equal(r | views::take_exactly(4), {2, 1, 0, 2});
-    ::check_equal(r | views::take_exactly(6), {2, 1, 0, 2, 1, 0});
-    ::check_equal(r | views::take_exactly(7), {2, 1, 0, 2, 1, 0, 2});
-
-    CHECK(distance(r | views::take(0)) == 0);
-    CHECK(distance(r | views::take(1)) == 1);
-    CHECK(distance(r | views::take(2)) == 2);
-    CHECK(distance(r | views::take(3)) == 3);
-    CHECK(distance(r | views::take(4)) == 4);
-    CHECK(distance(r | views::take(6)) == 6);
-    CHECK(distance(r | views::take(7)) == 7);
-    CHECK(count_if(r | views::take(7), [](int) { return true; }) == 7);
-
-    ::check_equal(r | views::take(0), std::array<int, 0>{});
-    ::check_equal(r | views::take(1), {2});
-    ::check_equal(r | views::take(2), {2, 1});
-    ::check_equal(r | views::take(3), {2, 1, 0});
-    ::check_equal(r | views::take(4), {2, 1, 0, 2});
-    ::check_equal(r | views::take(6), {2, 1, 0, 2, 1, 0});
-    ::check_equal(r | views::take(7), {2, 1, 0, 2, 1, 0, 2});
-}
-
-template<typename Rng>
-void test_mutable_forward_range_reversed(Rng &rng)
-{
-    test_const_forward_reversed_range(rng);
-    int count = 2;
-    RANGES_FOR(auto &&i, rng | views::cycle | views::take_exactly(6)) { i = ++count; }
-    ::check_equal(rng | views::take_exactly(3), {6, 7, 8});
-}
-
-template<typename Rng>
-void test_forward_it(Rng const &rng)
-{
-    auto r = rng | views::cycle;
-    static_assert(forward_range<decltype(r)>, "");
-    auto f = begin(r);
-    static_assert(forward_iterator<decltype(f)>, "");
-
-    CHECK((*f) == 0);
-    auto n = next(f, 1);
-    CHECK((*n) == 1);
-}
-
-template<typename Rng>
-void test_bidirectional_it(Rng const &rng)
-{
-    test_forward_it(rng);
-    auto r = rng | views::cycle;
-    static_assert(bidirectional_range<decltype(r)>, "");
-    auto f = begin(r);
-    static_assert(bidirectional_iterator<decltype(f)>, "");
-
-    CHECK((*f) == 0);
-    auto n = next(f, 1);
-    CHECK((*n) == 1);
-    CHECK((--n) == f);
-}
-
-template<typename Rng>
-void test_random_access_it(Rng const &rng)
-{
-    test_bidirectional_it(rng);
-    auto r = rng | views::cycle;
-    static_assert(random_access_range<decltype(r)>, "");
-    auto f = begin(r);
-    static_assert(random_access_iterator<decltype(f)>, "");
-    auto m = begin(r) + 1;
-    auto l = begin(r) + 2;
-    auto f1 = begin(r) + 3;
-    auto f2 = begin(r) + 6;
-
-    CHECK(r[0] == 0);
-    CHECK(r[1] == 1);
-    CHECK(r[2] == 2);
-    CHECK(r[3] == 0);
-    CHECK(r[4] == 1);
-    CHECK(r[5] == 2);
-
-    CHECK((f + 3) == f1);
-    CHECK((f + 6) == f2);
-    CHECK((f1 + 3) == f2);
-    CHECK((f2 - 3) == f1);
-    CHECK((f2 - 6) == f);
-
-    auto e = end(r);
-
-    CHECK(*f == 0);
-    CHECK(f[0] == 0);
-    CHECK(f[1] == 1);
-    CHECK(f[2] == 2);
-    CHECK(f[3] == 0);
-    CHECK(f[4] == 1);
-    CHECK(f[5] == 2);
-
-    CHECK(*m == 1);
-    CHECK(m[0] == 1);
-    CHECK(m[1] == 2);
-    CHECK(m[2] == 0);
-    CHECK(m[3] == 1);
-    CHECK(m[4] == 2);
-    CHECK(m[5] == 0);
-
-    CHECK(m[-1] == 0);
-
-    CHECK(*l == 2);
-    CHECK(l[0] == 2);
-    CHECK(l[1] == 0);
-    CHECK(l[2] == 1);
-    CHECK(l[3] == 2);
-    CHECK(l[4] == 0);
-    CHECK(l[5] == 1);
-
-    CHECK(l[-1] == 1);
-    CHECK(l[-2] == 0);
-
-    CHECK(f != e);
-
-    auto cur = f;
-    for (int i = 0; i < 100; ++i, ++cur)
-    {
-        CHECK((next(begin(r), i) - f) == i);
-        CHECK((cur - f) == i);
-        if(i > 0)
-            CHECK((cur - m) == i - 1);
-        if(i > 1)
-            CHECK((cur - l) == i - 2);
-    }
-}
-
-int main()
-{
-    // initializer list
-    {
-        auto il = {0, 1, 2};
-        test_random_access_it(il);
-        test_const_forward_reversed_range(il);
-
-        const auto cil = {0, 1, 2};
-        test_random_access_it(cil);
-        test_const_forward_reversed_range(cil);
-    }
-
-    // array
-    {
-        std::array<int, 3> a = {{0, 1, 2}};
-        test_random_access_it(a);
-        test_mutable_forward_range_reversed(a);
-
-        const std::array<int, 3> ca = {{0, 1, 2}};
-        test_random_access_it(ca);
-        test_const_forward_reversed_range(ca);
-    }
-
-    // list
-    {
-        std::list<int> l = {0, 1, 2};
-        test_bidirectional_it(l);
-        test_mutable_forward_range_reversed(l);
-
-        const std::list<int> cl = {0, 1, 2};
-        test_bidirectional_it(cl);
-        test_const_forward_reversed_range(cl);
-    }
-
-    // forward list
-    {
-        std::forward_list<int> l = {0, 1, 2};
-        test_forward_it(l);
-        test_const_forward_range(l);
-
-        const std::forward_list<int> cl = {0, 1, 2};
-        test_forward_it(cl);
-        test_const_forward_range(cl);
-    }
-
-    // move-only types
-    {
-        std::array<std::unique_ptr<int>, 3> a = {{
-            std::unique_ptr<int>(new int(0)),
-            std::unique_ptr<int>(new int(1)),
-            std::unique_ptr<int>(new int(2))
-        }};
-        auto r = a | views::cycle;
-        auto b = iter_move(r.begin() + 4);
-        CHECK((*(b)) == 1);
-    }
-
-    // infinite
-    {
-        int count = 0;
-        auto il = {0, 1, 2};
-        auto v = 10;
-        RANGES_FOR(auto&& i, il | views::cycle)
-        {
-            if (count == 42) { break; }
-            v = i;
-            ++count;
-        }
-        CHECK(count == 42);
-        CHECK(v == 2);
-    }
-
-    // non-bounded
-    {
-        auto sz = views::c_str((char const *)"hi! ");
-        ::check_equal(
-            sz | views::cycle | views::take(10),
-            {'h','i','!',' ','h','i','!',' ','h','i'} );
-
-        auto rng = sz | views::cycle;
-        auto it = ranges::begin(rng);
-        CHECK(*it == 'h');
-        CHECK(*++it == 'i');
-        CHECK(*++it == '!');
-        CHECK(*++it == ' ');
-        CHECK(*++it == 'h');
-        CHECK(*--it == ' ');
-        CHECK(*--it == '!');
-        CHECK(*--it == 'i');
-        CHECK(*--it == 'h');
-
-        rng = sz | views::cycle;
-        it = ranges::begin(rng);
-        it += 4;
-        CHECK(*it == 'h');
-    }
-
-    // Cycle of an infinite range,
-    // https://github.com/ericniebler/range-v3/issues/780
-    {
-        auto view = ranges::views::iota(0)
-                    | ranges::views::cycle;
-        CHECK(view[5] == 5);
-    }
-
-    // Composing ranges::views::cycle with ranges::views::slice
-    // https://github.com/ericniebler/range-v3/issues/778
-    {
-        const auto length = 512;
-        const auto k = 16;
-
-        std::vector<int> input(length);
-
-        auto output = ranges::views::cycle(input)
-                    | ranges::views::slice(length + k, 2 * length + k);
-
-        CHECK(bool(ranges::begin(output) != ranges::end(output)));
-        CHECK(ranges::size(output) == 512u);
-        CHECK(ranges::distance(output) == 512);
-    }
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/delimit.cpp b/src/contrib/range-v3-0.11.0/test/view/delimit.cpp
deleted file mode 100644
index 4d2b1ab0..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/delimit.cpp
+++ /dev/null
@@ -1,53 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/delimit.hpp>
-#include <range/v3/algorithm/for_each.hpp>
-#include <range/v3/utility/copy.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    auto rng0 = views::iota(10) | views::delimit(25);
-    ::check_equal(rng0, {10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24});
-    CPP_assert(view_<decltype(rng0)>);
-    CPP_assert(!common_range<decltype(rng0)>);
-    CPP_assert(random_access_iterator<decltype(rng0.begin())>);
-    CPP_assert(view_<delimit_view<views::all_t<std::vector<int> &>, int>>);
-    CPP_assert(random_access_range<delimit_view<views::all_t<std::vector<int> &>, int>>);
-
-    std::vector<int> vi{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
-    auto rng1 = vi | views::delimit(50);
-    ::check_equal(rng1, {0, 1, 2, 3, 4, 5, 6, 7, 8, 9});
-
-    auto rng2 = views::delimit(vi.begin(), 8);
-    ::check_equal(rng2, {0, 1, 2, 3, 4, 5, 6, 7});
-
-    {
-        int const some_ints[] = {1,2,3,0,4,5,6};
-        auto rng = debug_input_view<const int>{some_ints} | views::delimit(0);
-        ::check_equal(rng, {1,2,3});
-    }
-
-    {
-        int const some_ints[] = {1,2,3};
-        auto rng = views::delimit(some_ints, 0);
-        ::check_equal(rng, {1,2,3});
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/drop.cpp b/src/contrib/range-v3-0.11.0/test/view/drop.cpp
deleted file mode 100644
index 3158510a..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/drop.cpp
+++ /dev/null
@@ -1,159 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <list>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/chunk.hpp>
-#include <range/v3/view/drop.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/join.hpp>
-#include <range/v3/view/reverse.hpp>
-#include <range/v3/view/take.hpp>
-#include <range/v3/view/transform.hpp>
-#include <range/v3/utility/copy.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    int rgi[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
-
-    {
-        auto rng0 = rgi | views::drop(6);
-        has_type<int &>(*begin(rng0));
-        CPP_assert(view_<decltype(rng0)>);
-        CPP_assert(common_range<decltype(rng0)>);
-        CPP_assert(sized_range<decltype(rng0)>);
-        CPP_assert(random_access_iterator<decltype(begin(rng0))>);
-        ::check_equal(rng0, {6, 7, 8, 9, 10});
-        CHECK(size(rng0) == 5u);
-
-        auto rng1 = rng0 | views::reverse;
-        has_type<int &>(*begin(rng1));
-        CPP_assert(view_<decltype(rng1)>);
-        CPP_assert(common_range<decltype(rng1)>);
-        CPP_assert(sized_range<decltype(rng1)>);
-        CPP_assert(random_access_iterator<decltype(begin(rng1))>);
-        ::check_equal(rng1, {10, 9, 8, 7, 6});
-    }
-
-    {
-        std::vector<int> v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
-        auto rng2 = v | views::drop(6) | views::reverse;
-        has_type<int &>(*begin(rng2));
-        CPP_assert(view_<decltype(rng2)>);
-        CPP_assert(common_range<decltype(rng2)>);
-        CPP_assert(sized_range<decltype(rng2)>);
-        CPP_assert(random_access_iterator<decltype(begin(rng2))>);
-        ::check_equal(rng2, {10, 9, 8, 7, 6});
-    }
-
-    {
-        std::list<int> l{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
-        auto rng3 = l | views::drop(6);
-        has_type<int &>(*begin(rng3));
-        CPP_assert(view_<decltype(rng3)>);
-        CPP_assert(common_range<decltype(rng3)>);
-        CPP_assert(sized_range<decltype(rng3)>);
-        CPP_assert(bidirectional_iterator<decltype(begin(rng3))>);
-        CPP_assert(!random_access_iterator<decltype(begin(rng3))>);
-        ::check_equal(rng3, {6, 7, 8, 9, 10});
-    }
-
-    {
-        auto rng4 = views::iota(10) | views::drop(10);
-        CPP_assert(view_<decltype(rng4)>);
-        CPP_assert(!common_range<decltype(rng4)>);
-        CPP_assert(!sized_range<decltype(rng4)>);
-        static_assert(ranges::is_infinite<decltype(rng4)>::value, "");
-        auto b = ranges::begin(rng4);
-        CHECK(*b == 20);
-        CHECK(*(b+1) == 21);
-    }
-
-    {
-        auto rng5 = views::iota(10) | views::drop(10) | views::take(10) | views::reverse;
-        CPP_assert(view_<decltype(rng5)>);
-        CPP_assert(common_range<decltype(rng5)>);
-        CPP_assert(sized_range<decltype(rng5)>);
-        static_assert(!ranges::is_infinite<decltype(rng5)>::value, "");
-        ::check_equal(rng5, {29, 28, 27, 26, 25, 24, 23, 22, 21, 20});
-        CHECK(size(rng5) == 10u);
-    }
-
-    {
-        int some_ints[] = {0,1,2};
-        auto rng = make_subrange(some_ints + 0, some_ints + 1);
-        auto rng2 = views::drop(rng, 2);
-        CHECK(begin(rng2) == some_ints + 1);
-        CHECK(size(rng2) == 0u);
-    }
-
-    {
-        // Regression test for https://github.com/ericniebler/range-v3/issues/413
-        auto skips = [](std::vector<int> xs) {
-            return views::ints(0, (int)xs.size())
-                | views::transform([&](int n) {
-                    return xs | views::chunk(n + 1)
-                              | views::transform(views::drop(n))
-                              | views::join;
-                })
-                | to<std::vector<std::vector<int>>>();
-        };
-        auto skipped = skips({1,2,3,4,5,6,7,8});
-        CHECK(skipped.size() == 8u);
-        if(skipped.size() >= 8u)
-        {
-            ::check_equal(skipped[0], {1,2,3,4,5,6,7,8});
-            ::check_equal(skipped[1], {2,4,6,8});
-            ::check_equal(skipped[2], {3,6});
-            ::check_equal(skipped[3], {4,8});
-            ::check_equal(skipped[4], {5});
-            ::check_equal(skipped[5], {6});
-            ::check_equal(skipped[6], {7});
-            ::check_equal(skipped[7], {8});
-        }
-    }
-
-    {
-        static int const some_ints[] = {0,1,2,3};
-        auto rng = debug_input_view<int const>{some_ints} | views::drop(2);
-        using R = decltype(rng);
-        CPP_assert(input_range<R> && view_<R>);
-        CPP_assert(!forward_range<R>);
-        CPP_assert(same_as<int const&, range_reference_t<R>>);
-        ::check_equal(rng, {2,3});
-    }
-
-    {
-        // regression test for #728
-        auto rng1 = views::iota(1) | views::chunk(6) | views::take(3);
-        int i = 2;
-        RANGES_FOR(auto o1, rng1)
-        {
-            auto rng2 = o1 | views::drop(1);
-            ::check_equal(rng2, {i, i+1, i+2, i+3, i+4});
-            i += 6;
-        }
-    }
-
-    {
-        // regression test for #813
-        static int const some_ints[] = {0,1,2,3};
-        auto rng = some_ints | views::drop(10);
-        CHECK(empty(rng));
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/drop_exactly.cpp b/src/contrib/range-v3-0.11.0/test/view/drop_exactly.cpp
deleted file mode 100644
index 3c596c01..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/drop_exactly.cpp
+++ /dev/null
@@ -1,103 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <list>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/chunk.hpp>
-#include <range/v3/view/drop_exactly.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/join.hpp>
-#include <range/v3/view/reverse.hpp>
-#include <range/v3/view/take.hpp>
-#include <range/v3/view/transform.hpp>
-#include <range/v3/utility/copy.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    int rgi[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
-
-    auto rng0 = rgi | views::drop_exactly(6);
-    has_type<int &>(*begin(rng0));
-    CPP_assert(view_<decltype(rng0)>);
-    CPP_assert(common_range<decltype(rng0)>);
-    CPP_assert(sized_range<decltype(rng0)>);
-    CPP_assert(random_access_iterator<decltype(begin(rng0))>);
-    ::check_equal(rng0, {6, 7, 8, 9, 10});
-    CHECK(size(rng0) == 5u);
-
-    auto rng1 = rng0 | views::reverse;
-    has_type<int &>(*begin(rng1));
-    CPP_assert(view_<decltype(rng1)>);
-    CPP_assert(common_range<decltype(rng1)>);
-    CPP_assert(sized_range<decltype(rng1)>);
-    CPP_assert(random_access_iterator<decltype(begin(rng1))>);
-    ::check_equal(rng1, {10, 9, 8, 7, 6});
-
-    std::vector<int> v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
-    auto rng2 = v | views::drop_exactly(6) | views::reverse;
-    has_type<int &>(*begin(rng2));
-    CPP_assert(view_<decltype(rng2)>);
-    CPP_assert(common_range<decltype(rng2)>);
-    CPP_assert(sized_range<decltype(rng2)>);
-    CPP_assert(random_access_iterator<decltype(begin(rng2))>);
-    ::check_equal(rng2, {10, 9, 8, 7, 6});
-
-    std::list<int> l{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
-    auto rng3 = l | views::drop_exactly(6);
-    has_type<int &>(*begin(rng3));
-    CPP_assert(view_<decltype(rng3)>);
-    CPP_assert(common_range<decltype(rng3)>);
-    CPP_assert(sized_range<decltype(rng3)>);
-    CPP_assert(bidirectional_iterator<decltype(begin(rng3))>);
-    CPP_assert(!random_access_iterator<decltype(begin(rng3))>);
-    ::check_equal(rng3, {6, 7, 8, 9, 10});
-
-    auto rng4 = views::iota(10) | views::drop_exactly(10);
-    CPP_assert(view_<decltype(rng4)>);
-    CPP_assert(!common_range<decltype(rng4)>);
-    CPP_assert(!sized_range<decltype(rng4)>);
-    static_assert(ranges::is_infinite<decltype(rng4)>::value, "");
-    auto b = ranges::begin(rng4);
-    CHECK(*b == 20);
-    CHECK(*(b+1) == 21);
-
-    auto rng5 = views::iota(10) | views::drop_exactly(10) | views::take(10) | views::reverse;
-    CPP_assert(view_<decltype(rng5)>);
-    CPP_assert(common_range<decltype(rng5)>);
-    CPP_assert(sized_range<decltype(rng5)>);
-    static_assert(!ranges::is_infinite<decltype(rng5)>::value, "");
-    ::check_equal(rng5, {29, 28, 27, 26, 25, 24, 23, 22, 21, 20});
-    CHECK(size(rng5) == 10u);
-
-    {
-        // drop_exactly should work with random-access mutable-only Views.
-        auto odds = views::iota(0) |
-            views::chunk(2) |
-            views::transform(views::drop_exactly(1)) |
-            views::join;
-        (void)odds;
-    }
-
-    {
-        auto rng = debug_input_view<int const>{rgi} | views::drop_exactly(5);
-        using Rng = decltype(rng);
-        CPP_assert(input_range<Rng> && view_<Rng>);
-        CPP_assert(sized_range<Rng>);
-        ::check_equal(rng, {5,6,7,8,9,10});
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/drop_last.cpp b/src/contrib/range-v3-0.11.0/test/view/drop_last.cpp
deleted file mode 100644
index 8a995386..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/drop_last.cpp
+++ /dev/null
@@ -1,207 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Andrey Diduh 2019
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-#include <type_traits>
-#include <vector>
-#include <list>
-#include <forward_list>
-
-#include <range/v3/view/drop_last.hpp>
-#include <range/v3/view/take_exactly.hpp>
-#include <range/v3/view/transform.hpp>
-#include <range/v3/view/generate_n.hpp>
-
-using namespace ranges;
-
-template<class Rng>
-struct view_non_const_only
-  : view_adaptor<view_non_const_only<Rng>, Rng>
-{
-private:
-    friend range_access;
-
-    adaptor_base begin_adaptor() { return {}; }
-    adaptor_base end_adaptor()   { return {}; }
-public:
-    using view_non_const_only::view_adaptor::view_adaptor;
-
-    CPP_member
-    auto CPP_fun(size)() (
-        requires sized_range<Rng>)
-    {
-        return ranges::size(this->base());
-    }
-};
-
-template<class Rng>
-view_non_const_only<views::all_t<Rng>> non_const_only(Rng &&rng)
-{
-    return view_non_const_only<views::all_t<Rng>>{views::all(static_cast<Rng&&>(rng))};
-}
-
-template<class Rng>
-void test_range(Rng&& src)
-{
-    // additional src copy for InputStream
-    {
-        auto src_ = src;
-        ::check_equal(src_, {1,2,3,4});
-    }
-    {
-        auto src_ = src;
-        auto list = src_ | views::drop_last(2);
-        ::check_equal(list, {1,2});
-    }
-    {
-        auto src_ = src;
-        auto list = src_ | views::drop_last(0);
-        ::check_equal(list, {1,2,3,4});
-    }
-    {
-        auto src_ = src;
-        auto list = src_ | views::drop_last(4);
-        CHECK(list.empty());
-    }
-}
-
-template<class Rng>
-void test_size(Rng&& src)
-{
-    CHECK( (src | views::drop_last(0)).size() == std::size_t(4) );
-    CHECK( (src | views::drop_last(2)).size() == std::size_t(2) );
-    CHECK( (src | views::drop_last(4)).size() == std::size_t(0) );
-}
-
-template<class Rng>
-void test_non_convert_range(Rng&& src)
-{
-    // test non-convertible const<=>non-const range
-    test_range(src | views::transform([](const int& i) -> const int& {return i;}));
-}
-
-void random_acccess_test()
-{
-    using Src = std::vector<int>;
-    static_assert(
-        ranges::random_access_range<Src>
-        , "Must be exactly RA.");
-    static_assert(
-        std::is_same<
-            drop_last_view<views::all_t<Src&>>,
-            drop_last_view<views::all_t<Src&>, detail::drop_last_view::mode_bidi>
-        >::value
-        , "Must have correct view.");
-
-    Src src = {1,2,3,4};
-
-    test_range(src);
-    test_range(non_const_only(src));
-    test_size(src);
-    test_non_convert_range(src);
-}
-
-void bidirectional_test()
-{
-    using Src = std::list<int>;
-    static_assert(
-        !ranges::random_access_range<Src> &&
-        ranges::bidirectional_range<Src>
-        , "Must be exactly bidirectional.");
-    static_assert(
-        std::is_same<
-            /* mode_sized for max_performance profile.
-             * mode_bidi  for compatible profile.
-             * See aux::drop_last::get_mode */
-            drop_last_view<views::all_t<Src&>>,
-            drop_last_view<views::all_t<Src&>, detail::drop_last_view::mode_bidi>
-        >::value
-        , "Must have correct view.");
-
-    Src src = {1,2,3,4};
-
-    test_range(src);
-    test_range(non_const_only(src));
-    test_size(src);
-    test_non_convert_range(src);
-}
-
-void forward_test()
-{
-    using Src = std::forward_list<int>;
-    static_assert(
-        !ranges::bidirectional_range<Src> &&
-        ranges::forward_range<Src>
-        , "Must be exactly forward.");
-    static_assert(
-        std::is_same<
-            drop_last_view<views::all_t<Src&>>,
-            drop_last_view<views::all_t<Src&>, detail::drop_last_view::mode_forward>
-        >::value
-        , "Must have correct view.");
-
-    Src src = {1,2,3,4};
-
-    test_range(src);
-    test_range(non_const_only(src));
-    test_size(src | views::take_exactly(4));
-    test_non_convert_range(src);
-}
-
-void sized_test()
-{
-    int i = 0;
-    auto src  = views::generate_n([i]() mutable -> int { return ++i;}, 4);
-    using Src = decltype(src);
-    static_assert(
-        !ranges::forward_range<Src> &&
-        ranges::input_range<Src>
-        , "Must be exactly input.");
-
-    static_assert(
-        std::is_same<
-            drop_last_view<views::all_t<Src>>,
-            drop_last_view<views::all_t<Src>, detail::drop_last_view::mode_sized>
-        >::value
-        , "Must have correct view.");
-
-    {
-        // always non-const
-        auto src_ = src;
-        test_range(src_);
-    }
-    {
-        auto src_ = src;
-        test_size(src_);
-    }
-    {
-        auto src_ = src;
-        test_range(non_const_only(std::move(src_)));
-    }
-    {
-        auto src_ = src;
-        test_non_convert_range(src_);
-    }
-}
-
-int main()
-{
-    random_acccess_test();
-    bidirectional_test();
-    forward_test();
-    sized_test();
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/drop_while.cpp b/src/contrib/range-v3-0.11.0/test/view/drop_while.cpp
deleted file mode 100644
index be5f812e..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/drop_while.cpp
+++ /dev/null
@@ -1,93 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <list>
-#include <range/v3/core.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/take.hpp>
-#include <range/v3/view/drop_while.hpp>
-#include <range/v3/utility/copy.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-struct my_data
-{
-    int i;
-};
-
-bool operator==(my_data left, my_data right)
-{
-    return left.i == right.i;
-}
-
-int main()
-{
-    using namespace ranges;
-
-    auto rng0 = views::iota(10) | views::drop_while([](int i) { return i < 25; });
-    CPP_assert(range_cardinality<decltype(rng0)>::value == unknown);
-    CPP_assert(view_<decltype(rng0)>);
-    CPP_assert(random_access_range<decltype(rng0)>);
-    CPP_assert(!common_range<decltype(rng0)>);
-    CPP_assert(!sized_range<decltype(rng0)>);
-    CPP_assert(random_access_iterator<decltype(rng0.begin())>);
-    auto b = rng0.begin();
-    CHECK(*b == 25);
-    CHECK(*(b+1) == 26);
-    ::check_equal(rng0 | views::take(10), {25, 26, 27, 28, 29, 30, 31, 32, 33, 34});
-
-    std::list<int> vi{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
-    auto rng1 = vi | views::drop_while([](int i) { return i != 50; });
-    CPP_assert(range_cardinality<decltype(rng1)>::value == ranges::finite);
-    CPP_assert(view_<decltype(rng1)>);
-    CPP_assert(bidirectional_range<decltype(rng1)>);
-    CPP_assert(common_range<decltype(rng1)>);
-    CPP_assert(!sized_range<decltype(rng1)>);
-    CPP_assert(bidirectional_iterator<decltype(rng1.begin())>);
-    CHECK(rng1.begin() == rng1.end());
-
-    // Check with a mutable predicate
-    static int const rgi[] = {0,1,2,3,4,5,6,7,8,9};
-    int cnt = 0;
-    auto mutable_only = views::drop_while(rgi, [cnt](int) mutable { return ++cnt <= 5;});
-    ::check_equal(mutable_only, {5,6,7,8,9});
-    CPP_assert(view_<decltype(mutable_only)>);
-    CPP_assert(!view_<decltype(mutable_only) const>);
-
-    {
-        auto rng = debug_input_view<const int>{rgi} | views::drop_while([](int i){ return i < 4; });
-        using R = decltype(rng);
-        CPP_assert(input_range<R> && view_<R>);
-        CPP_assert(!forward_range<R>);
-        CPP_assert(!common_range<R>);
-        CPP_assert(!sized_range<R>);
-        CPP_assert(same_as<int const&, range_reference_t<R>>);
-        ::check_equal(rng, {4,5,6,7,8,9});
-    }
-
-    {
-        // with projection
-        const std::list<my_data> data_list{{1}, {2}, {3}, {1}};
-        auto rng = data_list | views::drop_while([](int i){ return i <= 2; }, &my_data::i);
-        ::check_equal(rng, std::list<my_data>{{3}, {1}});
-    }
-
-    auto rng2 = rgi | views::drop_while([](int i) { return i != 50; });
-    CPP_assert(range_cardinality<decltype(rng2)>::value == ranges::finite);
-    CPP_assert(view_<decltype(rng2)>);
-    CPP_assert(contiguous_range<decltype(rng2)>);
-    CPP_assert(common_range<decltype(rng2)>);
-    CPP_assert(!sized_range<decltype(rng2)>);
-    CPP_assert(contiguous_iterator<decltype(rng2.begin())>);
-    CHECK(ranges::size(rng2) == 0u);
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/enumerate.cpp b/src/contrib/range-v3-0.11.0/test/view/enumerate.cpp
deleted file mode 100644
index 205446c8..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/enumerate.cpp
+++ /dev/null
@@ -1,104 +0,0 @@
-// Range v3 library
-//
-//  Copyright MikeGitb 2018-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <range/v3/view/enumerate.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/indices.hpp>
-#include <range/v3/view/transform.hpp>
-
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-#include <list>
-#include <vector>
-#include <tuple>
-#include <iterator>
-
-using std::begin;
-
-template<class RangeT>
-void test_enumerate_with(RangeT &&range)
-{
-    auto enumerated_range = ranges::views::enumerate(range);
-
-    std::size_t idx_ref = 0;
-    auto it_ref = begin( range );
-
-    for(auto it = enumerated_range.begin(); it != enumerated_range.end(); ++it)
-    {
-        const auto idx = std::get<0>(*it);
-        const auto value = std::get<1>(*it);
-
-        CHECK(idx == idx_ref++);
-        CHECK(value == *it_ref++);
-    }
-}
-
-int main()
-{
-    { // test array
-        int const es[] = { 9,8,7,6,5,4,3,2,1,0 };
-        test_enumerate_with(es);
-    }
-
-    { // test with vector of complex value type
-        std::vector<std::list<int>> range{ {1, 2, 3}, { 3,5,6,7 }, { 10,5,6,1 }, { 1,2,3,4 } };
-        const auto rcopy = range;
-
-        test_enumerate_with(range);
-
-        // check that range hasn't accidentially been modified
-        CHECK(rcopy == range);
-
-        // check with empty range
-        range.clear();
-        test_enumerate_with(range);
-    }
-
-    { // test with list
-        std::list<int> range{ 9,8,7,6,5,4,3,2,1 };
-        test_enumerate_with(range);
-
-        range.clear();
-        test_enumerate_with(range);
-    }
-
-    { // test with initializer_list
-        test_enumerate_with(std::initializer_list<int>{9, 8, 7, 6, 5, 4, 3, 2, 1});
-    }
-
-    {
-        auto range = ranges::views::iota(0, 0);
-        test_enumerate_with(range);
-
-        range = ranges::views::iota(-10000, 10000);
-        test_enumerate_with(range);
-    }
-
-    {
-        auto range = ranges::views::iota((std::uintmax_t)0, (std::uintmax_t)0);
-        test_enumerate_with(range);
-
-        auto range2 = ranges::views::iota((std::intmax_t) -10000, (std::intmax_t) 10000);
-        test_enumerate_with(range2);
-    }
-
-    // https://github.com/ericniebler/range-v3/issues/1141
-    {
-        using namespace ranges;
-        auto x = views::indices( std::uintmax_t( 100 ) )
-          | views::transform([](std::uintmax_t) { return "";})
-          | views::enumerate;
-        using X = decltype(x);
-        CPP_assert(same_as<range_difference_t<X>, detail::diffmax_t>);
-        CPP_assert(same_as<range_value_t<X>, std::pair<detail::diffmax_t, char const*>>);
-    }
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/exclusive_scan.cpp b/src/contrib/range-v3-0.11.0/test/view/exclusive_scan.cpp
deleted file mode 100644
index e05ab51a..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/exclusive_scan.cpp
+++ /dev/null
@@ -1,57 +0,0 @@
-// Range v3 library
-//
-//  Copyright Mitsutaka Takeda 2018-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#include <vector>
-#include <range/v3/utility/copy.hpp>
-#include <range/v3/view/exclusive_scan.hpp>
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    {// For non empty range.
-        int rgi[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
-
-        {
-            auto rng = rgi | views::exclusive_scan(0);
-            has_type<int &>(*begin(rgi));
-            has_type<int>(*begin(rng));
-            CPP_assert(view_<decltype(rng)>);
-            CPP_assert(sized_range<decltype(rng)>);
-            CPP_assert(forward_range<decltype(rng)>);
-            CPP_assert(!bidirectional_range<decltype(rng)>);
-            ::check_equal(rng, {0, 1, 3, 6, 10, 15, 21, 28, 36, 45});
-        }
-
-        {// Test exclusive_scan with a mutable lambda
-            int cnt = 0;
-            auto mutable_rng = views::exclusive_scan(rgi, 0, [cnt](int i, int j) mutable {return i + j + cnt++;});
-            ::check_equal(mutable_rng, {0, 1, 4, 9, 16, 25, 36, 49, 64, 81});
-            CPP_assert(view_<decltype(mutable_rng)>);
-            CPP_assert(!view_<decltype(mutable_rng) const>);
-        }
-    }
-
-    {// For an empty range.
-        std::vector<int> rgi;
-        auto rng = rgi | views::exclusive_scan(0);
-        has_type<int>(*begin(rng));
-        CPP_assert(view_<decltype(rng)>);
-        CPP_assert(sized_range<decltype(rng)>);
-        CPP_assert(forward_range<decltype(rng)>);
-        CPP_assert(!bidirectional_range<decltype(rng)>);
-        CHECK(empty(rng));
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/facade.cpp b/src/contrib/range-v3-0.11.0/test/view/facade.cpp
deleted file mode 100644
index 215828ef..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/facade.cpp
+++ /dev/null
@@ -1,109 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/utility/copy.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-struct MyRange
-  : ranges::view_facade<MyRange>
-{
-private:
-    friend ranges::range_access;
-    std::vector<int> ints_;
-    struct cursor
-    {
-    private:
-        std::vector<int>::const_iterator iter;
-    public:
-        using contiguous = std::true_type;
-        cursor() = default;
-        cursor(std::vector<int>::const_iterator it)
-          : iter(it)
-        {}
-        int const & read() const
-        {
-            return *iter;
-        }
-        bool equal(cursor const &that) const
-        {
-            return iter == that.iter;
-        }
-        void next()
-        {
-            ++iter;
-        }
-        void prev()
-        {
-            --iter;
-        }
-        std::ptrdiff_t distance_to(cursor const &that) const
-        {
-            return that.iter - iter;
-        }
-        void advance(std::ptrdiff_t n)
-        {
-            iter += n;
-        }
-    };
-    cursor begin_cursor() const
-    {
-        return {ints_.begin()};
-    }
-    cursor end_cursor() const
-    {
-        return {ints_.end()};
-    }
-public:
-    MyRange()
-      : ints_{1, 2, 3, 4, 5, 6, 7}
-    {}
-};
-
-int main()
-{
-    using namespace ranges;
-    {
-        auto r = MyRange{};
-        CPP_assert(view_<decltype(r)>);
-        CPP_assert(common_range<decltype(r)>);
-        CPP_assert(sized_range<decltype(r)>);
-        CPP_assert(contiguous_range<decltype(r)>);
-        ::check_equal(r, {1, 2, 3, 4, 5, 6, 7});
-
-        CHECK(7u == r.size());
-        CHECK(1 == r.front());
-        CHECK(7 == r.back());
-        CHECK(&*r.begin() == r.data());
-        CHECK(r[1] == 2);
-        CHECK(r[5] == 6);
-    }
-
-    {
-        const auto r = MyRange{};
-        CPP_assert(common_range<decltype(r)>);
-        CPP_assert(sized_range<decltype(r)>);
-        CPP_assert(random_access_range<decltype(r)>);
-        CPP_assert(contiguous_range<decltype(r)>);
-        ::check_equal(r, {1, 2, 3, 4, 5, 6, 7});
-
-        CHECK(7u == r.size());
-        CHECK(1 == r.front());
-        CHECK(7 == r.back());
-        CHECK(&*r.begin() == r.data());
-        CHECK(r[1] == 2);
-        CHECK(r[5] == 6);
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/generate.cpp b/src/contrib/range-v3-0.11.0/test/view/generate.cpp
deleted file mode 100644
index 7a7f7a08..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/generate.cpp
+++ /dev/null
@@ -1,102 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <range/v3/core.hpp>
-#include <range/v3/view/generate.hpp>
-#include <range/v3/view/drop_exactly.hpp>
-#include <range/v3/view/take_exactly.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-namespace views = ranges::views;
-
-int main()
-{
-    // Test for constant generator functions
-    {
-        int i = 0, j = 1;
-        auto fib = views::generate([&]()->int{int tmp = i; i += j; std::swap(i, j); return tmp;});
-        CPP_assert(ranges::input_range<decltype(fib)> && ranges::view_<decltype(fib)>);
-        check_equal(fib | views::take_exactly(10), {0,1,1,2,3,5,8,13,21,34});
-    }
-
-    // Test for mutable-only generator functions
-    {
-        int i = 0, j = 1;
-        auto fib = views::generate([=]()mutable->int{int tmp = i; i += j; std::swap(i, j); return tmp;});
-        CPP_assert(ranges::input_range<decltype(fib)> && ranges::view_<decltype(fib)>);
-        check_equal(fib | views::take_exactly(10), {0,1,1,2,3,5,8,13,21,34});
-        // The generator cannot be called when it's const-qualified, so "fib const"
-        // does not model View.
-        CPP_assert(!ranges::view_<decltype(fib) const>);
-    }
-
-    // Test for generator functions that return move-only types
-    // https://github.com/ericniebler/range-v3/issues/905
-    {
-        char str[] = "gi";
-        auto rng = views::generate([&]{str[0]++; return MoveOnlyString{str};}) | views::take_exactly(2);
-        auto i = rng.begin();
-        CHECK(bool(*i == MoveOnlyString{"hi"}));
-        CHECK(bool(*i == MoveOnlyString{"hi"}));
-        CHECK(bool(*rng.begin() == MoveOnlyString{"hi"}));
-        CHECK(bool(*rng.begin() == MoveOnlyString{"hi"}));
-        CPP_assert(ranges::input_range<decltype(rng)> && ranges::view_<decltype(rng)>);
-        check_equal(rng, {MoveOnlyString{"hi"}, MoveOnlyString{"ii"}});
-        static_assert(std::is_same<ranges::range_reference_t<decltype(rng)>, MoveOnlyString &&>::value, "");
-    }
-
-    // Test for generator functions that return internal references
-    // https://github.com/ericniebler/range-v3/issues/807
-    {
-        int i = 42;
-        auto rng = views::generate([i]{return &i;});
-        auto rng2 = std::move(rng);
-        auto it = rng2.begin();
-        auto p = *it;
-        auto p2 = *++it;
-        CHECK(p == p2);
-    }
-
-    // Test that we only call the function once for each dereferenceable position
-    // https://github.com/ericniebler/range-v3/issues/819
-    {
-        int i = 0;
-        auto rng = views::generate([&i]{return ++i;});
-        auto rng2 = std::move(rng);
-        auto it = rng2.begin();
-        CHECK(i == 0);
-        CHECK(*it == 1);
-        CHECK(i == 1);
-        ++it;
-        CHECK(i == 1);
-        CHECK(*it == 2);
-        CHECK(i == 2);
-    }
-
-    // Test that skipping past positions works correctly
-    // https://github.com/ericniebler/range-v3/issues/1258
-    {
-        auto fib = [p = std::make_pair(0, 1)]() mutable -> int {
-            auto a = p.first;
-            p = {p.second, p.first + p.second};
-            return a;
-        };
-
-        auto rng = ranges::views::generate(fib)
-            | ranges::views::drop_exactly(3)
-            | ranges::views::take_exactly(5);
-
-        check_equal(rng, {2,3,5,8,13});
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/generate_n.cpp b/src/contrib/range-v3-0.11.0/test/view/generate_n.cpp
deleted file mode 100644
index a96265df..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/generate_n.cpp
+++ /dev/null
@@ -1,110 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <range/v3/core.hpp>
-#include <range/v3/view/drop_exactly.hpp>
-#include <range/v3/view/generate_n.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-namespace views = ranges::views;
-
-int main()
-{
-    // Test for constant generator functions
-    {
-        int i = 0, j = 1;
-        auto fib = views::generate_n([&]()->int{int tmp = i; i += j; std::swap(i, j); return tmp;}, 10);
-        CPP_assert(ranges::input_range<decltype(fib)> && ranges::view_<decltype(fib)>);
-        check_equal(fib, {0,1,1,2,3,5,8,13,21,34});
-    }
-
-    // Test for mutable-only generator functions
-    {
-        int i = 0, j = 1;
-        auto fib = views::generate_n([=]()mutable->int{int tmp = i; i += j; std::swap(i, j); return tmp;}, 10);
-        CPP_assert(ranges::input_range<decltype(fib)> && ranges::view_<decltype(fib)>);
-        check_equal(fib, {0,1,1,2,3,5,8,13,21,34});
-        // The generator cannot be called when it's const-qualified, so "fib const"
-        // does not model View.
-        CPP_assert(!ranges::view_<decltype(fib) const>);
-    }
-
-    // Test for generator functions that return move-only types
-    // https://github.com/ericniebler/range-v3/issues/905
-    {
-        char str[] = "gi";
-        auto rng = views::generate_n([&]{str[0]++; return MoveOnlyString{str};}, 2);
-        CPP_assert(ranges::input_range<decltype(rng)> && ranges::view_<decltype(rng)>);
-        auto i = rng.begin();
-        CHECK(bool(*i == MoveOnlyString{"hi"}));
-        CHECK(bool(*i == MoveOnlyString{"hi"}));
-        CHECK(bool(*rng.begin() == MoveOnlyString{"hi"}));
-        CHECK(bool(*rng.begin() == MoveOnlyString{"hi"}));
-        CPP_assert(ranges::input_range<decltype(rng)> && ranges::view_<decltype(rng)>);
-        check_equal(rng, {MoveOnlyString{"hi"}, MoveOnlyString{"ii"}});
-        static_assert(std::is_same<ranges::range_reference_t<decltype(rng)>, MoveOnlyString &&>::value, "");
-    }
-
-    // Test for generator functions that return internal references
-    // https://github.com/ericniebler/range-v3/issues/807
-    {
-        int i = 42;
-        auto rng = views::generate_n([i]{return &i;}, 2);
-        auto rng2 = std::move(rng);
-        auto it = rng2.begin();
-        auto p = *it;
-        auto p2 = *++it;
-        CHECK(p == p2);
-    }
-
-    // Test that we only call the function once for each dereferenceable position
-    // https://github.com/ericniebler/range-v3/issues/819
-    {
-        int i = 0;
-        auto rng = views::generate_n([&i]{return ++i;}, 2);
-        auto rng2 = std::move(rng);
-        auto it = rng2.begin();
-        CHECK(i == 0);
-        CHECK(*it == 1);
-        CHECK(i == 1);
-        ++it;
-        CHECK(i == 1);
-        CHECK(*it == 2);
-        CHECK(i == 2);
-    }
-
-    // Test view_interaface sized()-based empty()
-    // https://github.com/ericniebler/range-v3/issues/1147
-    {
-        int i = 0;
-        auto rng = views::generate_n([&i]{return ++i;}, 2);
-        CHECK(!rng.empty());
-    }
-
-
-    // Test that skipping past positions works correctly
-    // https://github.com/ericniebler/range-v3/issues/1258
-    {
-        auto fib = [p = std::make_pair(0, 1)]() mutable -> int {
-            auto a = p.first;
-            p = {p.second, p.first + p.second};
-            return a;
-        };
-
-        auto rng = ranges::views::generate_n(fib, 8)
-            | ranges::views::drop_exactly(3);
-
-        check_equal(rng, {2,3,5,8,13});
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/getlines.cpp b/src/contrib/range-v3-0.11.0/test/view/getlines.cpp
deleted file mode 100644
index d71adb0b..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/getlines.cpp
+++ /dev/null
@@ -1,39 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <sstream>
-#include <range/v3/core.hpp>
-#include <range/v3/range/traits.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-using namespace ranges;
-
-int main()
-{
-    const char* text =
-R"(Now is
-the time
-for all
-good men
-)";
-
-    std::stringstream sin{text};
-    auto rng = getlines(sin);
-    ::check_equal(rng, {"Now is", "the time", "for all", "good men"});
-
-    using Rng = decltype(rng);
-    CPP_assert(input_range<Rng> && view_<Rng>);
-    CPP_assert(!(forward_range<Rng> && view_<Rng>));
-    CPP_assert(same_as<range_rvalue_reference_t<Rng>, std::string &&>);
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/group_by.cpp b/src/contrib/range-v3-0.11.0/test/view/group_by.cpp
deleted file mode 100644
index 9ece668d..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/group_by.cpp
+++ /dev/null
@@ -1,157 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <list>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/counted.hpp>
-#include <range/v3/view/cycle.hpp>
-#include <range/v3/view/group_by.hpp>
-#include <range/v3/view/remove_if.hpp>
-#include <range/v3/view/take.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-RANGES_DIAGNOSTIC_IGNORE_SIGN_CONVERSION
-
-int main()
-{
-    using namespace ranges;
-    using P = std::pair<int,int>;
-
-    std::vector<std::pair<int, int>> v =
-    {
-        {1,1},
-        {1,1},
-        {1,2},
-        {1,2},
-        {1,2},
-        {1,2},
-        {2,2},
-        {2,2},
-        {2,3},
-        {2,3},
-        {2,3},
-        {2,3}
-    };
-
-    {
-        auto rng0 = v | views::group_by([](P p0, P p1) {return p0.second == p1.second;});
-        CPP_assert(forward_range<decltype(rng0)>);
-        CPP_assert(!bidirectional_range<decltype(rng0)>);
-        CHECK(distance(rng0) == 3);
-        check_equal(*rng0.begin(), {P{1,1},P{1,1}});
-        check_equal(*next(rng0.begin()), {P{1,2},P{1,2},P{1,2},P{1,2},P{2,2},P{2,2}});
-        check_equal(*next(rng0.begin(), 2), {P{2,3},P{2,3},P{2,3},P{2,3}});
-
-        auto rng1 = v | views::group_by([](P p0, P p1) {return p0.first == p1.first;});
-        CPP_assert(forward_range<decltype(rng1)>);
-        CPP_assert(!bidirectional_range<decltype(rng1)>);
-        CHECK(distance(rng1) == 2);
-        check_equal(*rng1.begin(), {P{1,1},P{1,1},P{1,2},P{1,2},P{1,2},P{1,2}});
-        check_equal(*next(rng1.begin()), {P{2,2},P{2,2},P{2,3},P{2,3},P{2,3},P{2,3}});
-    }
-
-    {
-        ForwardIterator<std::vector<P>::iterator> b{v.begin()};
-        auto rng0 = views::counted(b, v.size())
-            | views::group_by([](P p0, P p1) {return p0.second == p1.second;});
-        CPP_assert(forward_range<decltype(rng0)>);
-        CPP_assert(!bidirectional_range<decltype(rng0)>);
-        CHECK(distance(rng0) == 3);
-        check_equal(*rng0.begin(), {P{1,1},P{1,1}});
-        check_equal(*next(rng0.begin()), {P{1,2},P{1,2},P{1,2},P{1,2},P{2,2},P{2,2}});
-        check_equal(*next(rng0.begin(), 2), {P{2,3},P{2,3},P{2,3},P{2,3}});
-
-        auto rng1 = views::counted(b, v.size())
-            | views::group_by([](P p0, P p1) {return p0.first == p1.first;});
-        CPP_assert(forward_range<decltype(rng1)>);
-        CPP_assert(!bidirectional_range<decltype(rng1)>);
-        CHECK(distance(rng1) == 2);
-        check_equal(*rng1.begin(), {P{1,1},P{1,1},P{1,2},P{1,2},P{1,2},P{1,2}});
-        check_equal(*next(rng1.begin()), {P{2,2},P{2,2},P{2,3},P{2,3},P{2,3},P{2,3}});
-    }
-
-    {
-        int a[] = {0, 1, 2, 3, 4, 5};
-        auto rng = a | views::remove_if([](int n) { return n % 2 == 0; })
-          | views::group_by([](int, int) { return true; });
-        check_equal(*rng.begin(), {1, 3, 5});
-    }
-
-    {
-        std::vector<int> v2 {0,1,2,3,4,5,6,7,8,9};
-        auto rng0 = ranges::views::group_by(v2, [](int i, int j){ return j - i < 3; });
-        check_equal(*rng0.begin(), {0, 1, 2});
-        check_equal(*next(rng0.begin()), {3, 4, 5});
-        check_equal(*next(rng0.begin(), 2), {6, 7, 8});
-        check_equal(*next(rng0.begin(), 3), {9});
-        CHECK(distance(rng0) == 4);
-    }
-
-    {
-        std::vector<int> v3{1, 2, 3, 4, 5};
-        int count_invoc = 0;
-        auto rng = views::group_by(v3, [&](int, int) {
-            ++count_invoc;
-            return false;
-        });
-
-        CHECK(distance(rng) == 5);
-        CHECK(count_invoc == 4);
-
-        auto it = rng.begin();
-        check_equal(*it, {1});
-        check_equal(*++it, {2});
-        check_equal(*++it, {3});
-        check_equal(*++it, {4});
-        check_equal(*++it, {5});
-        // 7, not 8, because caching in begin()
-        CHECK(count_invoc == 7);
-    }
-
-    {
-        std::vector<int> v4 = {2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 0};
-        auto rng = v4 | views::group_by(std::less<>{});
-        CHECK(distance(rng) == 4);
-        check_equal(*rng.begin(), {2, 3, 4, 5});
-        check_equal(*next(rng.begin()), {0, 1, 2, 3, 4, 5, 6});
-        check_equal(*next(rng.begin(), 2), {0, 1, 2, 3});
-        check_equal(*next(rng.begin(), 3), {0});
-    }
-
-    {
-        std::vector<int> v5 = { 0, 1, 2 };
-        auto rng = views::cycle(v5) | views::take(6) | views::group_by(std::less<>{});
-        CHECK(distance(rng) == 2);
-        check_equal(*rng.begin(), v5);
-        check_equal(*next(rng.begin()), v5);
-    }
-
-    {
-        std::vector<int> e;
-        auto rng = e | views::group_by(std::less<>{});
-        CHECK(distance(rng) == 0);
-    }
-
-    {
-        std::vector<int> single{2};
-        auto rng = single | views::group_by([](int, int) -> bool {
-            throw 0;
-        });
-
-        CHECK(distance(rng) == 1);
-        check_equal(*rng.begin(), {2});
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/indirect.cpp b/src/contrib/range-v3-0.11.0/test/view/indirect.cpp
deleted file mode 100644
index 3361cb4a..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/indirect.cpp
+++ /dev/null
@@ -1,78 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <vector>
-#include <memory>
-#include <range/v3/core.hpp>
-#include <range/v3/view/indirect.hpp>
-#include <range/v3/view/transform.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    {
-        std::vector<std::shared_ptr<int>> vp;
-        for(int i = 0; i < 10; ++i)
-            vp.push_back(std::make_shared<int>(i));
-        auto && rng = vp | views::indirect;
-        CHECK(&*begin(rng) == vp[0].get());
-        ::check_equal(rng, {0, 1, 2, 3, 4, 5, 6, 7, 8, 9});
-    }
-
-    {
-        int const some_ints[] = {0,1,2,3};
-        int const *some_int_pointers[] = {
-            some_ints + 0, some_ints + 1, some_ints + 2, some_ints + 3
-        };
-        auto make_range = [&]{
-            return debug_input_view<int const *>{some_int_pointers} | views::indirect;
-        };
-        auto rng = make_range();
-        ::check_equal(rng, some_ints);
-        rng = make_range();
-        CHECK(&*begin(rng) == some_ints + 0);
-    }
-
-#if RANGES_CXX_RETURN_TYPE_DEDUCTION >= RANGES_CXX_RETURN_TYPE_DEDUCTION_14
-    {
-        // regression test for #946
-        class Data;
-
-        struct Test
-        {
-            std::vector<Data*> m_list;
-
-            auto list()
-            {
-                return m_list | ranges::views::indirect;
-            }
-        };
-
-        class Data
-        {};
-
-        CHECK(Test{std::vector<Data*>(42)}.list().size() == 42u);
-    }
-#endif // RANGES_CXX_RETURN_TYPE_DEDUCTION
-
-    {
-        // regression test for #952
-        int some_ints[42]{};
-        auto a = some_ints | views::transform([](int& i) { return &i; })
-                           | views::indirect;
-        (void) a.begin();
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/intersperse.cpp b/src/contrib/range-v3-0.11.0/test/view/intersperse.cpp
deleted file mode 100644
index b7382c66..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/intersperse.cpp
+++ /dev/null
@@ -1,166 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <sstream>
-#include <range/v3/core.hpp>
-#include <range/v3/view/intersperse.hpp>
-#include <range/v3/view/delimit.hpp>
-#include <range/v3/view/reverse.hpp>
-#include <range/v3/range/conversion.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-#ifdef RANGES_WORKAROUND_MSVC_790554
-template<std::size_t N>
-auto c_str(char const (&sz)[N])
-{
-    return ranges::subrange<char const*>{&sz[0], &sz[N-1]};
-}
-#else // ^^^ workaround / no workaround vvv
-template<std::size_t N>
-ranges::subrange<char const*> c_str(char const (&sz)[N])
-{
-    return {&sz[0], &sz[N-1]};
-}
-#endif // RANGES_WORKAROUND_MSVC_790554
-
-ranges::delimit_view<ranges::subrange<char const *, ranges::unreachable_sentinel_t>, char>
-c_str_(char const *sz)
-{
-    return ranges::views::delimit(sz, '\0');
-}
-
-int main()
-{
-    using namespace ranges;
-
-    {
-        auto r0 = views::intersperse(c_str("abcde"), ',');
-        CPP_assert(common_range<decltype(r0)>);
-        CHECK((r0.end() - r0.begin()) == 9);
-        CHECK(to<std::string>(r0) == "a,b,c,d,e");
-        CHECK(r0.size() == 9u);
-
-        auto r1 = views::intersperse(c_str(""), ',');
-        CPP_assert(common_range<decltype(r1)>);
-        CHECK(to<std::string>(r1) == "");
-        CHECK(r1.size() == 0u);
-
-        auto r2 = views::intersperse(c_str("a"), ',');
-        CPP_assert(common_range<decltype(r2)>);
-        CHECK(to<std::string>(r2) == "a");
-        CHECK(r2.size() == 1u);
-
-        auto r3 = views::intersperse(c_str("ab"), ',');
-        CPP_assert(common_range<decltype(r3)>);
-        CHECK(to<std::string>(r3) == "a,b");
-        CHECK(r3.size() == 3u);
-    }
-
-    {
-        auto r0 = views::intersperse(c_str("abcde"), ',') | views::reverse;
-        CPP_assert(common_range<decltype(r0)>);
-        CHECK(to<std::string>(r0) == "e,d,c,b,a");
-
-        auto r1 = views::intersperse(c_str(""), ',') | views::reverse;
-        CPP_assert(common_range<decltype(r1)>);
-        CHECK(to<std::string>(r1) == "");
-
-        auto r2 = views::intersperse(c_str("a"), ',') | views::reverse;
-        CPP_assert(common_range<decltype(r2)>);
-        CHECK(to<std::string>(r2) == "a");
-
-        auto r3 = views::intersperse(c_str("ab"), ',') | views::reverse;
-        CPP_assert(common_range<decltype(r3)>);
-        CHECK(to<std::string>(r3) == "b,a");
-    }
-
-    {
-        auto r0 = views::intersperse(c_str_("abcde"), ',');
-        CPP_assert(!common_range<decltype(r0)>);
-        CHECK(to<std::string>(r0) == "a,b,c,d,e");
-
-        auto r1 = views::intersperse(c_str_(""), ',');
-        CPP_assert(!common_range<decltype(r1)>);
-        CHECK(to<std::string>(r1) == "");
-
-        auto r2 = views::intersperse(c_str_("a"), ',');
-        CPP_assert(!common_range<decltype(r2)>);
-        CHECK(to<std::string>(r2) == "a");
-
-        auto r3 = views::intersperse(c_str_("ab"), ',');
-        CPP_assert(!common_range<decltype(r3)>);
-        CHECK(to<std::string>(r3) == "a,b");
-    }
-
-    {
-        auto r0 = views::intersperse(c_str("abcde"), ',');
-        auto it = r0.begin();
-        CHECK(*(it+0) == 'a');
-        CHECK(*(it+1) == ',');
-        CHECK(*(it+2) == 'b');
-        CHECK(*(it+3) == ',');
-        CHECK(*(it+4) == 'c');
-        CHECK(*(it+5) == ',');
-        CHECK(*(it+6) == 'd');
-        CHECK(*(it+7) == ',');
-        CHECK(*(it+8) == 'e');
-        CHECK((it+9) == r0.end());
-
-        it = r0.end();
-        CHECK(*(it-9) == 'a');
-        CHECK(*(it-8) == ',');
-        CHECK(*(it-7) == 'b');
-        CHECK(*(it-6) == ',');
-        CHECK(*(it-5) == 'c');
-        CHECK(*(it-4) == ',');
-        CHECK(*(it-3) == 'd');
-        CHECK(*(it-2) == ',');
-        CHECK(*(it-1) == 'e');
-
-        it = r0.begin();
-        CHECK(((it+0)-it) == 0);
-        CHECK(((it+1)-it) == 1);
-        CHECK(((it+2)-it) == 2);
-        CHECK(((it+3)-it) == 3);
-        CHECK(((it+4)-it) == 4);
-        CHECK(((it+5)-it) == 5);
-        CHECK(((it+6)-it) == 6);
-        CHECK(((it+7)-it) == 7);
-        CHECK(((it+8)-it) == 8);
-        CHECK(((it+9)-it) == 9);
-
-        CHECK((it-(it+0)) == 0);
-        CHECK((it-(it+1)) == -1);
-        CHECK((it-(it+2)) == -2);
-        CHECK((it-(it+3)) == -3);
-        CHECK((it-(it+4)) == -4);
-        CHECK((it-(it+5)) == -5);
-        CHECK((it-(it+6)) == -6);
-        CHECK((it-(it+7)) == -7);
-        CHECK((it-(it+8)) == -8);
-        CHECK((it-(it+9)) == -9);
-    }
-
-    {
-        std::stringstream str{"1 2 3 4 5"};
-        auto r0 = istream<int>(str) | views::intersperse(42);
-        check_equal(r0, {1,42,2,42,3,42,4,42,5});
-    }
-
-    {
-        int const some_ints[] = {1,2,3,4,5};
-        auto rng = debug_input_view<int const>{some_ints} | views::intersperse(42);
-        check_equal(rng, {1,42,2,42,3,42,4,42,5});
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/iota.cpp b/src/contrib/range-v3-0.11.0/test/view/iota.cpp
deleted file mode 100644
index 7b4623e8..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/iota.cpp
+++ /dev/null
@@ -1,228 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#include <range/v3/core.hpp>
-#include <range/v3/utility/copy.hpp>
-#include <range/v3/view/c_str.hpp>
-#include <range/v3/view/indices.hpp>
-#include <range/v3/view/indirect.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/take.hpp>
-#include <range/v3/view/drop_exactly.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-struct Int
-{
-    using difference_type = int;
-    int i = 0;
-    Int() = default;
-    explicit Int(int j) : i(j) {}
-    Int & operator++() {++i; CHECK(i <= 10); return *this;}
-    Int operator++(int) {auto tmp = *this; ++*this; return tmp;}
-    bool operator==(Int j) const { return i == j.i; }
-    bool operator!=(Int j) const { return i != j.i; }
-};
-
-CPP_template(typename I)(
-    requires ranges::integral<I>)
-void test_iota_distance()
-{
-    using namespace ranges;
-    using D = iter_difference_t<I>;
-    I max = std::numeric_limits<I>::max();
-
-    CHECK(detail::iota_distance_(I(0), I(0)) == D(0));
-    CHECK(detail::iota_distance_(I(1), I(0)) == D(-1));
-    CHECK(detail::iota_distance_(I(0), I(1)) ==  D(1));
-    CHECK(detail::iota_distance_(I(1), I(1)) == D(0));
-
-    CHECK(detail::iota_distance_(I(max - I(1)), I(max - I(1))) == D(0));
-    CHECK(detail::iota_distance_(I(max), I(max - I(1))) == D(-1));
-    CHECK(detail::iota_distance_(I(max - I(1)), I(max)) == D(1));
-    CHECK(detail::iota_distance_(I(max), I(max)) == D(0));
-}
-
-int main()
-{
-    using namespace ranges;
-
-    {
-        CPP_assert(random_access_range<decltype(views::iota((unsigned short)0))>);
-        CPP_assert(random_access_range<decltype(views::iota(0))>);
-        static_assert(is_infinite<decltype(views::iota(0))>::value, "");
-        static_assert(is_infinite<decltype(views::drop_exactly(views::iota(0),0))>::value, "");
-        static_assert(!sized_range<decltype(views::iota(0))>, "");
-    }
-
-    {
-        char const *sz = "hello world";
-        ::check_equal(views::iota(ForwardIterator<char const*>(sz)) | views::take(10) | views::indirect,
-            {'h','e','l','l','o',' ','w','o','r','l'});
-
-        ::check_equal(views::ints | views::take(10), {0,1,2,3,4,5,6,7,8,9});
-        ::check_equal(views::ints(0,unreachable) | views::take(10), {0,1,2,3,4,5,6,7,8,9});
-        ::check_equal(views::ints(0,9), {0,1,2,3,4,5,6,7,8});
-        ::check_equal(views::closed_indices(0,9), {0,1,2,3,4,5,6,7,8,9});
-        ::check_equal(views::ints(1,10), {1,2,3,4,5,6,7,8,9});
-        ::check_equal(views::closed_indices(1,10), {1,2,3,4,5,6,7,8,9,10});
-    }
-
-    {
-        auto chars = views::ints(std::numeric_limits<signed char>::min(),
-                                std::numeric_limits<signed char>::max());
-        CPP_assert(random_access_range<decltype(chars)>);
-        CPP_assert(same_as<int, range_difference_t<decltype(chars)>>);
-        CPP_assert(view_<decltype(chars)>);
-        CPP_assert(random_access_range<decltype(chars)>);
-        CPP_assert(common_range<decltype(chars)>);
-        CHECK(distance(chars.begin(), chars.end()) == (long) CHAR_MAX - (long) CHAR_MIN);
-        CHECK(chars.size() == (unsigned)((long) CHAR_MAX - (long) CHAR_MIN));
-    }
-
-    {
-        auto ushorts = views::ints(std::numeric_limits<unsigned short>::min(),
-                                std::numeric_limits<unsigned short>::max());
-        CPP_assert(view_<decltype(ushorts)>);
-        CPP_assert(common_range<decltype(ushorts)>);
-        CPP_assert(same_as<int, range_difference_t<decltype(ushorts)>>);
-        CPP_assert(same_as<unsigned int, range_size_t<decltype(ushorts)>>);
-        CHECK(distance(ushorts.begin(), ushorts.end()) == (int) USHRT_MAX);
-        CHECK(ushorts.size() == (unsigned) USHRT_MAX);
-    }
-
-    {
-        auto uints = views::closed_indices(
-            std::numeric_limits<std::uint_least32_t>::min(),
-            std::numeric_limits<std::uint_least32_t>::max() - 1);
-        CPP_assert(view_<decltype(uints)>);
-        CPP_assert(common_range<decltype(uints)>);
-        CPP_assert(same_as<std::int_fast64_t, range_difference_t<decltype(uints)>>);
-        CPP_assert(same_as<std::uint_fast64_t, range_size_t<decltype(uints)>>);
-        CHECK(uints.size() == std::numeric_limits<std::uint32_t>::max());
-    }
-
-    {
-        auto is = views::closed_indices(
-            std::numeric_limits<std::int_least32_t>::min(),
-            std::numeric_limits<std::int_least32_t>::max() - 1);
-        CPP_assert(same_as<std::int_fast64_t, range_difference_t<decltype(is)>>);
-        CPP_assert(same_as<std::uint_fast64_t, range_size_t<decltype(is)>>);
-        CHECK(is.size() == std::numeric_limits<std::uint32_t>::max());
-    }
-
-    {
-        auto sints = views::ints(std::numeric_limits<int>::min(),
-                                std::numeric_limits<int>::max());
-        CPP_assert(random_access_range<decltype(sints)>);
-        CPP_assert(same_as<std::int_fast64_t, range_difference_t<decltype(sints)>>);
-        CPP_assert(view_<decltype(sints)>);
-        CPP_assert(random_access_range<decltype(sints)>);
-        CPP_assert(common_range<decltype(sints)>);
-        CHECK(distance(sints.begin(), sints.end()) == (std::int_fast64_t) INT_MAX - (std::int_fast64_t) INT_MIN);
-        CHECK(sints.size() == (std::uint_fast64_t)((std::int_fast64_t) INT_MAX - (std::int_fast64_t) INT_MIN));
-    }
-
-    {
-        auto is = views::closed_iota(Int{0}, Int{10});
-        ::check_equal(is, {Int{0},Int{1},Int{2},Int{3},Int{4},Int{5},Int{6},Int{7},Int{8},Int{9},Int{10}});
-        CPP_assert(view_<decltype(is)>);
-        CPP_assert(common_range<decltype(is)>);
-        CPP_assert(!sized_range<decltype(is)>);
-        CPP_assert(forward_range<decltype(is)>);
-        CPP_assert(!bidirectional_range<decltype(is)>);
-    }
-
-    {
-        auto is = views::closed_iota(0, 10);
-        ::check_equal(is, {0,1,2,3,4,5,6,7,8,9,10});
-        CPP_assert(view_<decltype(is)>);
-        CPP_assert(common_range<decltype(is)>);
-        CPP_assert(sized_range<decltype(is)>);
-        CPP_assert(random_access_range<decltype(is)>);
-        CHECK(size(is) == 11u);
-        auto it = is.begin(), e = is.end(), be = e;
-        --be;
-        using D = range_difference_t<decltype(is)>;
-        // CHECK op++ and op-
-        for(D i = 0; ; ++i)
-        {
-            CHECK((e - it) == (11 - i));
-            CHECK((it - e) == -(11 - i));
-            CHECK((be - it) == (10 - i));
-            CHECK((it - be) == -(10 - i));
-            if(i == 11) break;
-            ++it;
-        }
-        // CHECK op-- and op-
-        for(D i = 11; ; --i)
-        {
-            CHECK((e - it) == (11 - i));
-            CHECK((it - e) == -(11 - i));
-            CHECK((be - it) == (10 - i));
-            CHECK((it - be) == -(10 - i));
-            if(i == 0) break;
-            --it;
-        }
-        // CHECK op+= and op-
-        for(D i = 0; ; ++i)
-        {
-            it = next(is.begin(), i);
-            CHECK((e - it) == (11 - i));
-            CHECK((it - e) == -(11 - i));
-            CHECK((be - it) == (10 - i));
-            CHECK((it - be) == -(10 - i));
-            if(i == 11) break;
-        }
-        // CHECK op-
-        CHECK((e - 0) == e);
-        CHECK((be - 0) == be);
-        CHECK((e - 1) == be);
-        CHECK((be - 1) == is.begin() + 9);
-    }
-
-    {  // iota distance tests
-        test_iota_distance<int8_t>();
-        test_iota_distance<int16_t>();
-        test_iota_distance<int32_t>();
-        test_iota_distance<int64_t>();
-
-        test_iota_distance<uint8_t>();
-        test_iota_distance<uint16_t>();
-        test_iota_distance<uint32_t>();
-        test_iota_distance<uint64_t>();
-    }
-
-    {
-        // https://github.com/ericniebler/range-v3/issues/506
-        auto cstr = views::c_str((const char*)"hello world");
-        auto cstr2 = views::iota(cstr.begin(), cstr.end()) | views::indirect;
-        ::check_equal(cstr2, std::string("hello world"));
-        auto i = cstr2.begin();
-        i += 4;
-        CHECK(*i == 'o');
-        CHECK((i - cstr2.begin()) == 4);
-    }
-
-    {  // test views::indices/closed_indices
-        ::check_equal(views::indices | views::take(10), std::initializer_list<std::size_t>{0,1,2,3,4,5,6,7,8,9});
-
-        ::check_equal(views::indices(0, 10), {0,1,2,3,4,5,6,7,8,9});
-        ::check_equal(views::closed_indices(0, 10), {0,1,2,3,4,5,6,7,8,9,10});
-
-        ::check_equal(views::indices(10), {0,1,2,3,4,5,6,7,8,9});
-        ::check_equal(views::closed_indices(10), {0,1,2,3,4,5,6,7,8,9,10});
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/istream.cpp b/src/contrib/range-v3-0.11.0/test/view/istream.cpp
deleted file mode 100644
index 5312ea40..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/istream.cpp
+++ /dev/null
@@ -1,25 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <range/v3/view/istream.hpp>
-#include <range/v3/view/subrange.hpp>
-#include <sstream>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    static const char test[] = "abcd3210";
-    std::istringstream ss{test};
-    ::check_equal(ranges::istream<char>(ss),
-                  ranges::make_subrange(test, test + sizeof(test) - 1));
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/iterator_range.cpp b/src/contrib/range-v3-0.11.0/test/view/iterator_range.cpp
deleted file mode 100644
index 9b155072..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/iterator_range.cpp
+++ /dev/null
@@ -1,75 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <list>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/utility/copy.hpp>
-#include <range/v3/iterator/unreachable_sentinel.hpp>
-#include <range/v3/iterator_range.hpp>
-#include <range/v3/view/all.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-struct empty
-{};
-
-int main()
-{
-    std::vector<int> vi{1,2,3,4};
-
-    using namespace ranges;
-    iterator_range<std::vector<int>::iterator> r0 {vi.begin(), vi.end()};
-    CPP_assert(view_<decltype(r0)>);
-    CPP_assert(sized_range<decltype(r0)>);
-    CHECK(r0.size() == 4u);
-    CHECK(r0.begin() == vi.begin());
-    CHECK(r0.end() == vi.end());
-    CHECK(ranges::get<0>(r0) == vi.begin());
-    CHECK(ranges::get<1>(r0) == vi.end());
-    ++r0.begin();
-    CHECK(r0.size() == 3u);
-
-    std::pair<std::vector<int>::iterator, std::vector<int>::iterator> p0 = r0;
-    CHECK(p0.first == vi.begin()+1);
-    CHECK(p0.second == vi.end());
-
-    iterator_range<std::vector<int>::iterator, unreachable_sentinel_t> r1 { r0.begin(), {} };
-    CPP_assert(view_<decltype(r1)>);
-    CPP_assert(!sized_range<decltype(r1)>);
-    CHECK(r1.begin() == vi.begin()+1);
-    r1.end() = unreachable;
-
-    ++r0.begin();
-    CHECK(r0.begin() == vi.begin()+2);
-    CHECK(r0.size() == 2u);
-    --r0.end();
-    CHECK(r0.end() == vi.end()-1);
-    CHECK(r0.size() == 1u);
-    CHECK(r0.front() == 3);
-    CHECK(r0.back() == 3);
-
-    std::pair<std::vector<int>::iterator, unreachable_sentinel_t> p1 = r1;
-    CHECK(p1.first == vi.begin()+1);
-
-    iterator_range<std::vector<int>::iterator, unreachable_sentinel_t> r2 { p1 };
-    CHECK(r1.begin() == vi.begin()+1);
-
-    std::list<int> li{1,2,3,4};
-    sized_iterator_range<std::list<int>::iterator> l0 {li.begin(), li.end(), li.size()};
-    CPP_assert(view_<decltype(l0)>);
-    CPP_assert(sized_range<decltype(l0)>);
-    CHECK(l0.begin() == li.begin());
-    CHECK(l0.end() == li.end());
-    CHECK(l0.size() == li.size());
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/join.cpp b/src/contrib/range-v3-0.11.0/test/view/join.cpp
deleted file mode 100644
index 3743ee6f..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/join.cpp
+++ /dev/null
@@ -1,276 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <iterator>
-#include <forward_list>
-#include <functional>
-#include <vector>
-
-#include <range/v3/core.hpp>
-#include <range/v3/view/join.hpp>
-#include <range/v3/view/split.hpp>
-#include <range/v3/view/generate_n.hpp>
-#include <range/v3/view/repeat_n.hpp>
-#include <range/v3/view/cache1.hpp>
-#include <range/v3/view/chunk.hpp>
-#include <range/v3/view/concat.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/single.hpp>
-#include <range/v3/view/transform.hpp>
-#include <range/v3/view/filter.hpp>
-
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS
-
-namespace
-{
-    template<typename T, std::size_t N>
-    struct input_array
-    {
-        T elements_[N];
-
-        InputIterator<T*> begin() { return InputIterator<T*>{elements_ + 0}; }
-        InputIterator<T*> end() { return InputIterator<T*>{elements_ + N}; }
-        constexpr std::size_t size() const { return N; }
-    };
-
-    static int N = 0;
-    auto make_input_rng()
-    {
-        using ranges::views::generate_n;
-        return generate_n([](){
-            return generate_n([](){
-                return N++;
-            },3);
-        },3);
-    }
-
-    template<typename T>
-    constexpr auto twice(T t)
-    {
-        return ranges::views::concat(
-            ranges::views::single(t),
-            ranges::views::single(t));
-    }
-
-#ifdef __clang__
-RANGES_DIAGNOSTIC_IGNORE_PRAGMAS
-RANGES_DIAGNOSTIC_IGNORE("-Wunneeded-member-function")
-RANGES_DIAGNOSTIC_IGNORE("-Wunused-member-function")
-#endif
-
-    // https://github.com/ericniebler/range-v3/issues/283
-    void test_issue_283()
-    {
-        const std::vector<std::vector<int>> nums =
-        {
-            { 1, 2, 3 },
-            { 4, 5, 6 }
-        };
-        const auto flat_nums = ranges::views::join( nums ) | ranges::to<std::vector>();
-        ::check_equal(flat_nums, {1,2,3,4,5,6});
-    }
-
-    // https://github.com/ericniebler/range-v3/issues/1414
-    void test_issue_1414()
-    {
-        std::forward_list<char> u2; // this can also be a vector
-        std::vector<char> i2;
-        auto v2 = u2 | ranges::views::chunk(3) | ranges::views::join(i2);
-        CPP_assert(ranges::input_range<decltype(v2)>);
-    }
-}
-
-int main()
-{
-    using namespace ranges;
-
-    // Test that we can join an input range of input ranges:
-    {
-        auto rng0 = make_input_rng() | views::join;
-        static_assert(range_cardinality<decltype(rng0)>::value == ranges::finite, "");
-        CPP_assert(input_range<decltype(rng0)>);
-        CPP_assert(!forward_range<decltype(rng0)>);
-        CPP_assert(!common_range<decltype(rng0)>);
-        CPP_assert(!sized_range<decltype(rng0)>);
-        check_equal(rng0, {0,1,2,3,4,5,6,7,8});
-    }
-
-    // Joining with a value
-    {
-        N = 0;
-        auto rng1 = make_input_rng() | views::join(42);
-        static_assert(range_cardinality<decltype(rng1)>::value == ranges::finite, "");
-        CPP_assert(input_range<decltype(rng1)>);
-        CPP_assert(!forward_range<decltype(rng1)>);
-        CPP_assert(!common_range<decltype(rng1)>);
-        CPP_assert(!sized_range<decltype(rng1)>);
-        check_equal(rng1, {0,1,2,42,3,4,5,42,6,7,8});
-    }
-
-    // Joining with a range
-    {
-        N = 0;
-        int rgi[] = {42,43};
-        auto rng2 = make_input_rng() | views::join(rgi);
-        static_assert(range_cardinality<decltype(rng2)>::value == ranges::finite, "");
-        CPP_assert(input_range<decltype(rng2)>);
-        CPP_assert(!forward_range<decltype(rng2)>);
-        CPP_assert(!common_range<decltype(rng2)>);
-        CPP_assert(!sized_range<decltype(rng2)>);
-        check_equal(rng2, {0,1,2,42,43,3,4,5,42,43,6,7,8});
-    }
-
-    // Just for fun:
-    {
-        std::string str = "Now,is,the,time,for,all,good,men,to,come,to,the,aid,of,their,country";
-        auto res = str | views::split(',') | views::join(' ') | to<std::string>();
-        CHECK(res == "Now is the time for all good men to come to the aid of their country");
-        static_assert(range_cardinality<decltype(res)>::value == ranges::finite, "");
-    }
-
-    {
-        std::vector<std::string> vs{"This","is","his","face"};
-        auto rng3 = views::join(vs);
-        static_assert(range_cardinality<decltype(rng3)>::value == ranges::finite, "");
-        CPP_assert(!sized_range<decltype(rng3)>);
-        CPP_assert(!sized_sentinel_for<decltype(end(rng3)), decltype(begin(rng3))>);
-        CHECK(to<std::string>(rng3) == "Thisishisface");
-
-        auto rng4 = views::join(vs, ' ');
-        static_assert(range_cardinality<decltype(rng3)>::value == ranges::finite, "");
-        CPP_assert(!sized_range<decltype(rng4)>);
-        CPP_assert(!sized_sentinel_for<decltype(end(rng4)), decltype(begin(rng4))>);
-        CHECK(to<std::string>(rng4) == "This is his face");
-    }
-
-    {
-        auto rng5 = views::join(twice(twice(42)));
-        static_assert(range_cardinality<decltype(rng5)>::value == 4, "");
-        CPP_assert(sized_range<decltype(rng5)>);
-        CHECK(rng5.size() == 4u);
-        check_equal(rng5, {42,42,42,42});
-    }
-
-    {
-        auto rng6 = views::join(twice(views::repeat_n(42, 2)));
-        static_assert(range_cardinality<decltype(rng6)>::value == ranges::finite, "");
-        CPP_assert(sized_range<decltype(rng6)>);
-        CHECK(rng6.size() == 4u);
-        check_equal(rng6, {42,42,42,42});
-    }
-
-    {
-        input_array<std::string, 4> some_strings = {{"This","is","his","face"}};
-        CPP_assert(input_range<decltype(some_strings)>);
-        CPP_assert(sized_range<decltype(some_strings)>);
-        CPP_assert(!sized_range<decltype(some_strings | views::join)>);
-    }
-
-    {
-        int const some_int_pairs[3][2] = {{0,1},{2,3},{4,5}};
-        auto rng = debug_input_view<int const[2]>{some_int_pairs} | views::join;
-        check_equal(rng, {0,1,2,3,4,5});
-    }
-
-    {
-        std::vector<std::string> vs{"this","is","his","face"};
-        join_view<ref_view<std::vector<std::string>>> jv{vs};
-        check_equal(jv, {'t','h','i','s','i','s','h','i','s','f','a','c','e'});
-        CPP_assert(bidirectional_range<decltype(jv)>);
-        CPP_assert(bidirectional_range<const decltype(jv)>);
-        CPP_assert(common_range<decltype(jv)>);
-        CPP_assert(common_range<const decltype(jv)>);
-    }
-
-    {
-        auto rng = views::iota(0,4)
-            | views::transform([](int i) {return views::iota(0,i);})
-            | views::join;
-        check_equal(rng, {0,0,1,0,1,2});
-        CPP_assert(input_range<decltype(rng)>);
-        CPP_assert(!range<const decltype(rng)>);
-        CPP_assert(!forward_range<decltype(rng)>);
-        CPP_assert(!common_range<decltype(rng)>);
-    }
-
-    {
-        auto rng = views::iota(0,4)
-            | views::transform([](int i) {return views::iota(0,i);})
-            | views::filter([](auto){ return true; })
-            | views::join;
-        check_equal(rng, {0,0,1,0,1,2});
-        CPP_assert(input_range<decltype(rng)>);
-        CPP_assert(!range<const decltype(rng)>);
-        CPP_assert(!forward_range<decltype(rng)>);
-        CPP_assert(!common_range<decltype(rng)>);
-    }
-
-    {
-        auto rng = views::iota(0,4)
-            | views::transform([](int i) {return std::string((std::size_t) i, char('a'+i));})
-            | views::cache1
-            | views::join;
-        check_equal(rng, {'b','c','c','d','d','d'});
-        CPP_assert(input_range<decltype(rng)>);
-        CPP_assert(!range<const decltype(rng)>);
-        CPP_assert(!forward_range<decltype(rng)>);
-        CPP_assert(!common_range<decltype(rng)>);
-    }
-
-    {
-        auto rng = views::iota(0,4)
-            | views::transform([](int i) {return std::string((std::size_t) i, char('a'+i));})
-            | views::cache1
-            | views::join('-');
-        check_equal(rng, {'-','b','-','c','c','-','d','d','d'});
-        CPP_assert(input_range<decltype(rng)>);
-        CPP_assert(!range<const decltype(rng)>);
-        CPP_assert(!forward_range<decltype(rng)>);
-        CPP_assert(!common_range<decltype(rng)>);
-    }
-
-    // https://github.com/ericniebler/range-v3/issues/1320
-    {
-        auto op = [](auto & input, int i, auto & ins)
-        {
-            return input | ranges::views::chunk(i)
-                         | ranges::views::join(ins);
-        };
-        std::string input{"foobarbaxbat"};
-        std::string insert{"X"};
-        auto rng = op(input, 2, insert);
-        std::cout << rng << '\n';
-        ::check_equal(rng, {'f','o','X','o','b','X','a','r','X','b','a','X','x','b','X',
-            'a','t'});
-    }
-
-    {
-        auto op = [](auto & input, int i, auto & ins)
-        {
-            return input | ranges::views::chunk(i)
-                         | ranges::views::join(ins);
-        };
-        std::vector<std::string> input{"foo","bar","bax","bat"};
-        std::string insert{"XX"};
-        auto rng = op(input, 2, insert);
-        std::cout << rng << '\n';
-        ::check_equal(rng, {"foo","bar","XX","bax","bat"});
-    }
-
-    test_issue_283();
-    test_issue_1414();
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/keys_value.cpp b/src/contrib/range-v3-0.11.0/test/view/keys_value.cpp
deleted file mode 100644
index c22a6749..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/keys_value.cpp
+++ /dev/null
@@ -1,79 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <map>
-#include <string>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/map.hpp>
-#include <range/v3/view/zip.hpp>
-#include <range/v3/utility/copy.hpp>
-#include <range/v3/algorithm/find.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-    std::map<std::string, int> m = {
-        {"this", 0},
-        {"that", 1},
-        {"other", 2}};
-    auto keys = m | views::keys;
-    has_type<std::string const &>(*begin(keys));
-    CPP_assert(view_<decltype(keys)>);
-    CPP_assert(sized_range<decltype(keys)>);
-    CPP_assert(common_range<decltype(keys)>);
-    CPP_assert(bidirectional_iterator<decltype(begin(keys))>);
-    CHECK(&*begin(keys) == &m.begin()->first);
-    ::check_equal(keys, {"other", "that", "this"});
-
-    auto values = m | views::values;
-    has_type<int &>(*begin(values));
-    CPP_assert(sized_range<decltype(values)>);
-    CPP_assert(common_range<decltype(values)>);
-    CPP_assert(bidirectional_iterator<decltype(begin(values))>);
-    CHECK(&*begin(values) == &m.begin()->second);
-    ::check_equal(values, {2, 1, 0});
-
-    {
-        // regression test for #526
-        auto f = detail::get_first{};
-        CPP_assert(same_as<int, decltype(f(std::declval<std::pair<int,int>>()))>);
-        CPP_assert(same_as<int&, decltype(f(std::declval<std::pair<int,int>&>()))>);
-        CPP_assert(same_as<int&, decltype(f(std::declval<std::pair<int&,int&>>()))>);
-        CPP_assert(same_as<int&, decltype(f(std::declval<std::pair<int&,int&>&>()))>);
-        CPP_assert(same_as<int, decltype(f(std::declval<std::pair<int&&,int&&>>()))>);
-        CPP_assert(same_as<int&, decltype(f(std::declval<std::pair<int&&,int&&>&>()))>);
-
-        std::vector<int> xs = {42, 100, -1234};
-        auto exs = views::zip(views::ints, xs);
-        ::check_equal(views::keys(exs), {0, 1, 2});
-    }
-
-    {
-        std::pair<int, int> const rgp[] = {{0, 2}, {1, 1}, {2, 0}};
-        auto key_range = debug_input_view<std::pair<int, int> const>{rgp} | views::keys;
-        check_equal(key_range, {0,1,2});
-        auto value_range = debug_input_view<std::pair<int, int> const>{rgp} | views::values;
-        check_equal(value_range, {2,1,0});
-    }
-
-    {
-        auto it = find(m | views::keys, "other");
-        CHECK(it.base()->second == 2);
-        auto it2 = find(m | views::values, 1);
-        CHECK(it2.base()->first == "that");
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/linear_distribute.cpp b/src/contrib/range-v3-0.11.0/test/view/linear_distribute.cpp
deleted file mode 100644
index b2770c72..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/linear_distribute.cpp
+++ /dev/null
@@ -1,91 +0,0 @@
-// Range v3 library
-//
-//  Gonzalo Brito Gadeschi 2017
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-#include <cmath>
-#include <range/v3/algorithm/equal.hpp>
-#include <range/v3/functional/arithmetic.hpp>
-#include <range/v3/view/linear_distribute.hpp>
-#include <range/v3/view/transform.hpp>
-#include <range/v3/view/iota.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using ranges::views::linear_distribute;
-
-    auto float_eq = [](double a, double b) {
-        return (int)std::floor(std::abs(a - b)) == 0;
-    };
-
-    {
-        auto irng = linear_distribute(0, 1, 2);
-        CHECK(ranges::size(irng) == std::size_t{2});
-        CPP_assert(ranges::forward_range<decltype(irng)>);
-        CPP_assert(ranges::sized_range<decltype(irng)>);
-        auto il = {0, 1};
-        check_equal(irng, il);
-    }
-    {
-        auto irng = linear_distribute(1, 3, 3);
-        auto il = {1, 2, 3};
-        check_equal(irng, il);
-        CHECK(ranges::size(irng) == std::size_t{3});
-    }
-    {
-        auto irng = linear_distribute(0, 21, 22);
-        auto frng = linear_distribute(0., 21., 22);
-        check_equal(irng, frng | ranges::views::transform(ranges::convert_to<int>{}));
-    }
-    {
-        auto frng = linear_distribute(0.0, 1.0, 11);
-        CPP_assert(ranges::forward_range<decltype(frng)>);
-        CPP_assert(ranges::sized_range<decltype(frng)>);
-        CHECK(ranges::size(frng) == std::size_t{11});
-        auto il = {0., 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0};
-        CHECK(ranges::size(il) == std::size_t{11});
-        CHECK(ranges::equal(frng, il, float_eq));
-    }
-    {
-        using ILD = std::initializer_list<double>;
-        auto frng = linear_distribute(1.0, 3.0, 21);
-        CHECK(ranges::equal(frng,
-                            ILD{1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9,
-                                2.0, 2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9,
-                                3.0},
-                            float_eq));
-    }
-    {   // empty interval
-        auto irng = linear_distribute(0, 0, 1);
-        CHECK(ranges::size(irng) == std::size_t{1});
-        check_equal(irng, {0});
-
-        auto irng1 = linear_distribute(0, 0, 10);
-        CHECK(ranges::size(irng1) == std::size_t{10});
-        check_equal(irng1, {0,0,0,0,0,0,0,0,0,0});
-
-        auto irng2 = linear_distribute(1, 1, 3);
-        CHECK(ranges::size(irng2) == std::size_t{3});
-        check_equal(irng2, {1,1,1});
-
-        auto frng = linear_distribute(0., 0., 3);
-        CHECK(ranges::size(frng) == std::size_t{3});
-        CHECK(ranges::equal(frng, std::initializer_list<double>{0.,0.,0.}, float_eq));
-    }
-
-    {   // regression test for #1088
-        auto ld = linear_distribute(1, 10, 10);
-        auto const first = ranges::begin(ld);
-        auto const i = ranges::next(first, 4);
-        CHECK(ranges::distance(first, i) == 4);
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/move.cpp b/src/contrib/range-v3-0.11.0/test/view/move.cpp
deleted file mode 100644
index a7ffa4d6..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/move.cpp
+++ /dev/null
@@ -1,63 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <cstring>
-#include <string>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/move.hpp>
-#include <range/v3/algorithm/copy.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/utility/copy.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-    static const char * const data[] = {"'allo", "'allo", "???"};
-    std::vector<MoveOnlyString> vs(begin(data), end(data));
-    auto x = vs | views::move;
-
-    {
-        CPP_assert(common_range<decltype(x)>);
-        CPP_assert(sized_range<decltype(x)>);
-        CPP_assert(view_<decltype(x)>);
-        CPP_assert(common_range<decltype(x)>);
-        CPP_assert(sized_range<decltype(x)>);
-        CPP_assert(random_access_iterator<decltype(x.begin())>);
-        using I = decltype(x.begin());
-        CPP_assert(same_as<iterator_tag_of<I>, std::random_access_iterator_tag>);
-        CPP_assert(same_as<
-            typename std::iterator_traits<I>::iterator_category,
-            std::random_access_iterator_tag>);
-
-        CHECK(bool(*x.begin() == "'allo"));
-    }
-
-    {
-        std::vector<MoveOnlyString> vs2(x.begin(), x.end());
-        static_assert(std::is_same<MoveOnlyString&&, decltype(*x.begin())>::value, "");
-        ::check_equal(vs2, {"'allo", "'allo", "???"});
-        ::check_equal(vs, {"", "", ""});
-    }
-
-    {
-        MoveOnlyString rgs[] = {"can", "you", "hear", "me", "now?"};
-        auto rng = debug_input_view<MoveOnlyString>{rgs} | views::move;
-        MoveOnlyString target[sizeof(rgs) / sizeof(rgs[0])];
-        copy(rng, target);
-        ::check_equal(rgs, {"", "", "", "", ""});
-        ::check_equal(target, {"can", "you", "hear", "me", "now?"});
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/partial_sum.cpp b/src/contrib/range-v3-0.11.0/test/view/partial_sum.cpp
deleted file mode 100644
index 6715bb51..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/partial_sum.cpp
+++ /dev/null
@@ -1,72 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <functional>
-#include <iterator>
-#include <range/v3/core.hpp>
-#include <range/v3/utility/copy.hpp>
-#include <range/v3/view/counted.hpp>
-#include <range/v3/view/partial_sum.hpp>
-#include <range/v3/view/reverse.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    int rgi[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
-
-    {
-        auto rng = rgi | views::partial_sum;
-        has_type<int &>(*begin(rgi));
-        has_type<int>(*begin(rng));
-        CPP_assert(view_<decltype(rng)>);
-        CPP_assert(sized_range<decltype(rng)>);
-        CPP_assert(forward_range<decltype(rng)>);
-        CPP_assert(!bidirectional_range<decltype(rng)>);
-        ::check_equal(rng, {1, 3, 6, 10, 15, 21, 28, 36, 45, 55});
-
-        auto it = begin(rng);
-        CHECK(*it == 1);
-        auto it2 = next(it);
-        CHECK(*it == 1);
-        CHECK(*it2 == 3);
-        it2 = it;
-        CHECK(*it2 == 1);
-        ++it2;
-        CHECK(*it2 == 3);
-    }
-
-    {
-        // Test partial_sum with a mutable lambda
-        int cnt = 0;
-        auto mutable_rng = views::partial_sum(rgi, [cnt](int i, int j) mutable { return i + j + cnt++;});
-        ::check_equal(mutable_rng, {1, 3, 7, 13, 21, 31, 43, 57, 73, 91});
-        CHECK(cnt == 0);
-        CPP_assert(view_<decltype(mutable_rng)>);
-        CPP_assert(!view_<decltype(mutable_rng) const>);
-    }
-
-    {
-        auto rng = debug_input_view<int const>{rgi} | views::partial_sum;
-        ::check_equal(rng, {1, 3, 6, 10, 15, 21, 28, 36, 45, 55});
-    }
-
-    {
-        static int const some_ints[] = {0,1,2,3,4};
-        auto t1 = ranges::views::partial_sum(some_ints);
-        auto t2 = some_ints | ranges::views::partial_sum;
-        ::check_equal(t1, t2);
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/partial_sum_depr.cpp b/src/contrib/range-v3-0.11.0/test/view/partial_sum_depr.cpp
deleted file mode 100644
index 453ac4ce..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/partial_sum_depr.cpp
+++ /dev/null
@@ -1,25 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <range/v3/core.hpp>
-RANGES_DIAGNOSTIC_IGNORE_DEPRECATED_DECLARATIONS
-#include <range/v3/view/partial_sum.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    static int const some_ints[] = {0,1,2,3,4};
-    auto rng = some_ints | ranges::views::partial_sum();
-    ::check_equal(rng, {0,1,3,6,10});
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/remove.cpp b/src/contrib/range-v3-0.11.0/test/view/remove.cpp
deleted file mode 100644
index 9dfaddbf..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/remove.cpp
+++ /dev/null
@@ -1,56 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Andrey Diduh 2019
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#include <vector>
-
-#include <range/v3/view/remove.hpp>
-#include <range/v3/view/remove_if.hpp>
-
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-using namespace ranges;
-
-void test_straight()
-{
-    std::vector<int> vec = {1,2,3,4,5};
-    auto out = vec | views::remove(2);
-
-    ::check_equal(out, {1,3,4,5});
-}
-
-struct Int
-{
-    int i;
-};
-bool operator==(Int left, Int right)
-{
-    return left.i == right.i;
-}
-void test_proj()
-{
-    const std::vector<Int> vec{ Int{1}, Int{2}, Int{3}, Int{4}, Int{5} };
-    auto out = vec | views::remove(2, &Int::i);
-
-    ::check_equal(out, {Int{1}, Int{3}, Int{4}, Int{5}});
-}
-
-int main()
-{
-    // simple interface tests.
-    // All other already tested in remove_if.
-    test_straight();
-    test_proj();
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/remove_if.cpp b/src/contrib/range-v3-0.11.0/test/view/remove_if.cpp
deleted file mode 100644
index 30b61564..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/remove_if.cpp
+++ /dev/null
@@ -1,184 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <array>
-#include <vector>
-#include <iterator>
-#include <functional>
-#include <range/v3/core.hpp>
-#include <range/v3/functional/not_fn.hpp>
-#include <range/v3/view/remove_if.hpp>
-#include <range/v3/view/filter.hpp>
-#include <range/v3/view/counted.hpp>
-#include <range/v3/view/concat.hpp>
-#include <range/v3/view/reverse.hpp>
-#include <range/v3/view/subrange.hpp>
-#include <range/v3/utility/copy.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-struct is_odd
-{
-    constexpr bool operator()(int i) const
-    {
-        return (i % 2) == 1;
-    }
-};
-
-struct is_even
-{
-    constexpr bool operator()(int i) const
-    {
-        return (i % 2) == 0;
-    }
-};
-
-struct my_data
-{
-    int i;
-};
-
-constexpr bool operator==(my_data left, my_data right)
-{
-    return left.i == right.i;
-}
-
-int main()
-{
-    using namespace ranges;
-
-    int rgi[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
-
-    {
-        auto rng = rgi | views::remove_if(is_even());
-        has_type<int &>(*begin(rgi));
-        has_type<int &>(*begin(rng));
-        CPP_assert(view_<decltype(rng)>);
-        CPP_assert(common_range<decltype(rng)>);
-        CPP_assert(!sized_range<decltype(rng)>);
-        CPP_assert(bidirectional_range<decltype(rng)>);
-        CPP_assert(!random_access_range<decltype(rng)>);
-        ::check_equal(rng, {1,3,5,7,9});
-        ::check_equal(rng | views::reverse, {9,7,5,3,1});
-        auto tmp = rng | views::reverse;
-        CHECK(&*begin(tmp) == &rgi[8]);
-    }
-
-    {
-        auto rng2 = views::counted(rgi, 10) | views::remove_if(not_fn(is_odd()));
-        has_type<int &>(*begin(rng2));
-        CPP_assert(view_<decltype(rng2)>);
-        CPP_assert(bidirectional_range<decltype(rng2)>);
-        CPP_assert(!random_access_range<decltype(rng2)>);
-        CPP_assert(common_range<decltype(rng2)>);
-        CPP_assert(!sized_range<decltype(rng2)>);
-        ::check_equal(rng2, {1,3,5,7,9});
-        CHECK(&*begin(rng2) == &rgi[0]);
-    }
-
-    {
-        auto rng3 = views::counted(BidirectionalIterator<int*>{rgi}, 10) | views::remove_if(is_even());
-        has_type<int &>(*begin(rng3));
-        CPP_assert(view_<decltype(rng3)>);
-        CPP_assert(bidirectional_range<decltype(rng3)>);
-        CPP_assert(!random_access_range<decltype(rng3)>);
-        CPP_assert(!common_range<decltype(rng3)>);
-        CPP_assert(!sized_range<decltype(rng3)>);
-        ::check_equal(rng3, {1,3,5,7,9});
-        CHECK(&*begin(rng3) == &rgi[0]);
-        CHECK(&*prev(next(begin(rng3))) == &rgi[0]);
-    }
-
-    {
-        // Test remove_if with a mutable lambda
-        bool flag = true;
-        auto mutable_rng = views::remove_if(rgi, [flag](int) mutable { return flag = !flag;});
-        ::check_equal(mutable_rng, {1,3,5,7,9});
-        CPP_assert(view_<decltype(mutable_rng)>);
-        CPP_assert(!view_<decltype(mutable_rng) const>);
-    }
-
-    {
-        const std::array<int, 3> a{{0, 1, 2}};
-        const std::vector<int> b{3, 4, 5, 6};
-
-        auto r = views::concat(a, b);
-        auto f = [](int i) { return i != 1 && i != 5; };
-        auto r2 = r | views::remove_if(f);
-        ::check_equal(r2, {1,5});
-    }
-
-    {
-        auto rng = debug_input_view<int const>{rgi} | views::remove_if(is_even{});
-        ::check_equal(rng, {1,3,5,7,9});
-    }
-
-    {
-        // Defend against regression of #793
-        int const some_ints[] = {1, 2, 3};
-        auto a = some_ints | ranges::views::remove_if([](int val) { return val > 0; });
-        CHECK(a.empty());
-    }
-
-    {
-        // with projection
-        const std::vector<my_data> some_my_datas{{1}, {2}, {3}, {4}};
-
-        {
-            // views::remove_if without pipe
-            auto rng = ranges::views::remove_if(some_my_datas, is_even(), &my_data::i);
-            ::check_equal(rng, std::vector<my_data>{{1}, {3}});
-        }
-
-        {
-            // views::remove_if with pipe
-            auto rng = some_my_datas | ranges::views::remove_if(is_even(), &my_data::i);
-            ::check_equal(rng, std::vector<my_data>{{1}, {3}});
-        }
-
-        {
-            // views::filter without pipe
-            auto rng = ranges::views::filter(some_my_datas, is_even(), &my_data::i);
-            ::check_equal(rng, std::vector<my_data>{{2}, {4}});
-        }
-
-        {
-            // views::filter with pipe
-            auto rng = some_my_datas | ranges::views::filter(is_even(), &my_data::i);
-            ::check_equal(rng, std::vector<my_data>{{2}, {4}});
-        }
-    }
-
-    // test constexpr binding
-    {
-        using namespace ranges;
-        constexpr std::array<int, 4> is = {{1,2,3,4}};
-        constexpr auto filter = views::remove_if(is_even()) | views::remove_if(is_odd());
-        auto rng = is | filter;
-        CHECK(rng.empty());
-    }
-    {
-        const std::vector<my_data> some_my_datas{{1}, {2}, {3}, {4}};
-        constexpr auto filter = views::remove_if(is_even(), &my_data::i) | views::remove_if(is_odd(), &my_data::i);
-        auto rng = some_my_datas | filter;
-        CHECK(rng.empty());
-    }
-
-    // test issue #1424 <https://github.com/ericniebler/range-v3/issues/1424>
-    {
-        std::vector<int> v{1, 2, 3, 4};
-        auto rng = views::filter(v, is_odd());
-        ::check_equal(rng, {1, 3});
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/repeat.cpp b/src/contrib/range-v3-0.11.0/test/view/repeat.cpp
deleted file mode 100644
index 68c5a13b..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/repeat.cpp
+++ /dev/null
@@ -1,30 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/take.hpp>
-#include <range/v3/view/repeat.hpp>
-#include <range/v3/utility/copy.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-    auto rng = views::repeat(9) | views::take(10);
-    CPP_assert(view_<decltype(rng)>);
-    CPP_assert(sized_range<decltype(rng)>);
-    CPP_assert(random_access_iterator<decltype(rng.begin())>);
-    ::check_equal(rng, {9, 9, 9, 9, 9, 9, 9, 9, 9, 9});
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/replace.cpp b/src/contrib/range-v3-0.11.0/test/view/replace.cpp
deleted file mode 100644
index b1b572ca..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/replace.cpp
+++ /dev/null
@@ -1,101 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <string>
-#include <sstream>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/istream.hpp>
-#include <range/v3/functional/reference_wrapper.hpp>
-#include <range/v3/utility/copy.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/replace.hpp>
-#include <range/v3/view/common.hpp>
-#include <range/v3/view/take.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    std::string str{"1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 "};
-    std::stringstream sin{str};
-
-    {
-        auto rng = istream<int>(sin) | views::replace(1, 42);
-        CPP_assert(same_as<range_value_t<decltype((rng))>, int>);
-        has_type<int const &>(*begin(rng));
-        CPP_assert(view_<decltype(rng)>);
-        CPP_assert(!sized_range<decltype(rng)>);
-        CPP_assert(!common_range<decltype(rng)>);
-        CPP_assert(input_iterator<decltype(begin(rng))>);
-        CPP_assert(!forward_iterator<decltype(begin(rng))>);
-
-        auto tmp = rng | views::common;
-        CPP_assert(same_as<range_value_t<decltype((tmp))>, int>);
-        has_type<int const &>(*begin(tmp));
-        CPP_assert(view_<decltype(tmp)>);
-        CPP_assert(common_range<decltype(tmp)>);
-        CPP_assert(!sized_range<decltype(tmp)>);
-        CPP_assert(input_iterator<decltype(begin(tmp))>);
-        CPP_assert(!forward_iterator<decltype(begin(tmp))>);
-        std::vector<int> actual{begin(tmp), end(tmp)};
-        ::check_equal(actual, {42, 2, 3, 4, 5, 6, 7, 8, 9, 42, 2, 3, 4, 5, 6, 7, 8, 9, 42, 2, 3, 4, 5, 6, 7, 8, 9});
-    }
-
-    std::vector<int> rgi{1,2,3,4,5,6,7,8,9};
-
-    {
-        auto rng2 = rgi | views::replace(5, 42);
-        CPP_assert(same_as<range_value_t<decltype((rng2))>, int>);
-        has_type<int const &>(*begin(rng2));
-        has_type<int const &>(iter_move(begin(rng2)));
-        CPP_assert(view_<decltype(rng2)>);
-        CPP_assert(sized_range<decltype(rng2)>);
-        CPP_assert(common_range<decltype(rng2)>);
-        CPP_assert(random_access_iterator<decltype(begin(rng2))>);
-        ::check_equal(rng2, {1,2,3,4,42,6,7,8,9});
-    }
-
-    {
-        int forty_two = 42;
-        auto rng3 = rgi | views::replace(5, ref(forty_two));
-        CPP_assert(same_as<range_value_t<decltype((rng3))>, int>);
-        has_type<int &>(*begin(rng3));
-        has_type<int const &>(iter_move(begin(rng3)));
-        CPP_assert(view_<decltype(rng3)>);
-        CPP_assert(sized_range<decltype(rng3)>);
-        CPP_assert(common_range<decltype(rng3)>);
-        CPP_assert(random_access_iterator<decltype(begin(rng3))>);
-        ::check_equal(rng3, {1,2,3,4,42,6,7,8,9});
-    }
-
-    {
-        auto rng4 = views::ints | views::replace(5,42) | views::take(10);
-        CPP_assert(same_as<range_value_t<decltype((rng4))>, int>);
-        has_type<int>(*begin(rng4));
-        has_type<int>(iter_move(begin(rng4)));
-        CPP_assert(view_<decltype(rng4)>);
-        CPP_assert(sized_range<decltype(rng4)>);
-        CPP_assert(!common_range<decltype(rng4)>);
-        CPP_assert(random_access_iterator<decltype(begin(rng4))>);
-        ::check_equal(rng4, {0,1,2,3,4,42,6,7,8,9});
-    }
-
-    {
-        int const some_ints[] = {1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9};
-        auto rng = debug_input_view<int const>{some_ints} | views::replace(1, 42);
-        ::check_equal(rng, {42,2,3,4,5,6,7,8,9,42,2,3,4,5,6,7,8,9,42,2,3,4,5,6,7,8,9});
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/replace_if.cpp b/src/contrib/range-v3-0.11.0/test/view/replace_if.cpp
deleted file mode 100644
index 55e49625..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/replace_if.cpp
+++ /dev/null
@@ -1,116 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-// HACKHACKHACK silence false positive:
-//   error: <anonymous>.ranges::istream_view<int>::cursor::rng_ may be used uninitialized in this function
-// triggered on line 39.
-#if defined(__GNUC__) && !defined(__clang__) && __GNUC__ >= 7
-#include <range/v3/detail/config.hpp>
-RANGES_DIAGNOSTIC_IGNORE("-Wmaybe-uninitialized")
-#endif
-
-#include <string>
-#include <sstream>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/istream.hpp>
-#include <range/v3/functional/reference_wrapper.hpp>
-#include <range/v3/utility/copy.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/take.hpp>
-#include <range/v3/view/replace_if.hpp>
-#include <range/v3/view/common.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    std::string str{"1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 "};
-    std::stringstream sin{str};
-
-    {
-        auto rng = istream<int>(sin) | views::replace_if([](int i){return i == 1; }, 42);
-        has_type<int const &>(*begin(rng));
-        CPP_assert(view_<decltype(rng)>);
-        CPP_assert(!sized_range<decltype(rng)>);
-        CPP_assert(!common_range<decltype(rng)>);
-        CPP_assert(input_iterator<decltype(begin(rng))>);
-        CPP_assert(!forward_iterator<decltype(begin(rng))>);
-
-        auto tmp = rng | views::common;
-        has_type<int const &>(*begin(tmp));
-        CPP_assert(view_<decltype(tmp)>);
-        CPP_assert(common_range<decltype(tmp)>);
-        CPP_assert(!sized_range<decltype(tmp)>);
-        CPP_assert(input_iterator<decltype(begin(tmp))>);
-        CPP_assert(!forward_iterator<decltype(begin(tmp))>);
-        std::vector<int> actual{begin(tmp), end(tmp)};
-        ::check_equal(actual, {42, 2, 3, 4, 5, 6, 7, 8, 9, 42, 2, 3, 4, 5, 6, 7, 8, 9, 42, 2, 3, 4, 5, 6, 7, 8, 9});
-    }
-
-    {
-        std::vector<int> vi{1,2,3,4,5,6,7,8,9};
-        auto rng2 = vi | views::replace_if([](int i){return i == 5;}, 42);
-        CPP_assert(same_as<range_value_t<decltype(rng2)>, int>);
-        has_type<int const &>(*begin(rng2));
-        has_type<int const &>(iter_move(begin(rng2)));
-        CPP_assert(view_<decltype(rng2)>);
-        CPP_assert(sized_range<decltype(rng2)>);
-        CPP_assert(common_range<decltype(rng2)>);
-        CPP_assert(random_access_iterator<decltype(begin(rng2))>);
-        ::check_equal(rng2, {1,2,3,4,42,6,7,8,9});
-
-        int forty_two = 42;
-        auto rng3 = vi | views::replace_if([](int i){return i == 5;}, ref(forty_two));
-        CPP_assert(same_as<range_value_t<decltype(rng3)>, int>);
-        has_type<int &>(*begin(rng3));
-        has_type<int const &>(iter_move(begin(rng3)));
-        CPP_assert(view_<decltype(rng3)>);
-        CPP_assert(sized_range<decltype(rng3)>);
-        CPP_assert(common_range<decltype(rng3)>);
-        CPP_assert(random_access_iterator<decltype(begin(rng3))>);
-        ::check_equal(rng3, {1,2,3,4,42,6,7,8,9});
-    }
-
-    {
-        auto rng4 = views::ints | views::replace_if([](int i){return i == 5;},42) | views::take(10);
-        CPP_assert(same_as<range_value_t<decltype(rng4)>, int>);
-        has_type<int>(*begin(rng4));
-        has_type<int>(iter_move(begin(rng4)));
-        CPP_assert(view_<decltype(rng4)>);
-        CPP_assert(sized_range<decltype(rng4)>);
-        CPP_assert(!common_range<decltype(rng4)>);
-        CPP_assert(random_access_iterator<decltype(begin(rng4))>);
-        ::check_equal(rng4, {0,1,2,3,4,42,6,7,8,9});
-    }
-
-    {
-        // Check with a mutable predicate
-        int rgi[] = {0,1,2,3,4,5,6,7,8,9};
-        bool flag = false;
-        auto mutable_only = views::replace_if(rgi, [flag](int) mutable { return flag = !flag;}, 42);
-        ::check_equal(mutable_only, {42,1,42,3,42,5,42,7,42,9});
-        CPP_assert(view_<decltype(mutable_only)>);
-        CPP_assert(!view_<decltype(mutable_only) const>);
-    }
-
-    {
-        int const some_ints[] = {1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9};
-
-        auto rng = debug_input_view<int const>{some_ints} |
-            views::replace_if([](int i){ return i == 1; }, 42);
-        ::check_equal(rng, {42,2,3,4,5,6,7,8,9,42,2,3,4,5,6,7,8,9,42,2,3,4,5,6,7,8,9});
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/reverse.cpp b/src/contrib/range-v3-0.11.0/test/view/reverse.cpp
deleted file mode 100644
index 7746741e..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/reverse.cpp
+++ /dev/null
@@ -1,156 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2015-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <list>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/take.hpp>
-#include <range/v3/view/take_exactly.hpp>
-#include <range/v3/view/reverse.hpp>
-#include <range/v3/view/counted.hpp>
-#include <range/v3/view/delimit.hpp>
-#include <range/v3/view/filter.hpp>
-#include <range/v3/view/c_str.hpp>
-#include <range/v3/utility/copy.hpp>
-#include <range/v3/algorithm/find.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    // Reverse a random-access, common, sized range
-    std::vector<int> rgv{0,1,2,3,4,5,6,7,8,9};
-    auto const rng0 = rgv | views::reverse;
-    CPP_assert(view_<std::remove_const_t<decltype(rng0)>>);
-    CPP_assert(random_access_range<decltype(rng0)>);
-    CPP_assert(common_range<decltype(rng0)>);
-    CPP_assert(sized_range<decltype(rng0)>);
-    CHECK(rng0.size() == 10u);
-    ::check_equal(rng0, {9,8,7,6,5,4,3,2,1,0});
-    ::check_equal(rng0 | views::reverse, {0,1,2,3,4,5,6,7,8,9});
-    ::check_equal(rng0 | views::reverse | views::reverse, {9,8,7,6,5,4,3,2,1,0});
-    ::check_equal(rng0 | views::reverse | views::reverse | views::reverse, {0,1,2,3,4,5,6,7,8,9});
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-#if defined(__clang__) && __clang_major__ < 6
-    // Workaround https://bugs.llvm.org/show_bug.cgi?id=33314
-    RANGES_DIAGNOSTIC_PUSH
-    RANGES_DIAGNOSTIC_IGNORE_UNDEFINED_FUNC_TEMPLATE
-#endif
-    {
-        ranges::reverse_view dg0{rgv};
-        ::check_equal(dg0, {9, 8, 7, 6, 5, 4, 3, 2, 1, 0});
-        ranges::reverse_view dg1{dg0};
-#ifdef RANGES_WORKAROUND_MSVC_934330
-        ::check_equal(dg1, {9, 8, 7, 6, 5, 4, 3, 2, 1, 0});
-#else // ^^^ "workaround" / no "workaround" vvv
-        ::check_equal(dg1, {0, 1, 2, 3, 4, 5, 6, 7, 8, 9});
-#endif // RANGES_WORKAROUND_MSVC_934330
-    }
-#if defined(__clang__) && __clang_major__ < 6
-    RANGES_DIAGNOSTIC_POP
-#endif // clang bug workaround
-#endif // use deduction guides
-
-    // Reverse another random-access, non-common, sized range
-    auto cnt = counted_view<std::vector<int>::iterator>(rgv.begin(), 10);
-    CPP_assert(!common_range<decltype(cnt)>);
-    auto const rng1 = rgv | views::reverse;
-    CPP_assert(view_<std::remove_const_t<decltype(rng1)>>);
-    CPP_assert(random_access_range<decltype(rng1)>);
-    CPP_assert(common_range<decltype(rng1)>);
-    CPP_assert(sized_range<decltype(rng1)>);
-    CHECK(rng1.size() == 10u);
-    ::check_equal(rng1, {9,8,7,6,5,4,3,2,1,0});
-    ::check_equal(rng1 | views::reverse, {0,1,2,3,4,5,6,7,8,9});
-
-    // Reverse a random-access, non-common, non-sized range
-    auto sz = views::c_str((char const*)"hello");
-    auto rng2 = sz | views::reverse;
-    CPP_assert(view_<decltype(rng2)>);
-    CPP_assert(random_access_range<decltype(rng2)>);
-    CPP_assert(common_range<decltype(rng2)>);
-    CPP_assert(!sized_range<decltype(detail::as_const(rng2))>);
-    CPP_assert(sized_range<decltype(rng2)>);
-    auto const & crng2 = rng2;
-    CPP_assert(!range<decltype(crng2)>);
-    ::check_equal(rng2, {'o','l','l','e','h'});
-    ::check_equal(rng2 | views::reverse, {'h','e','l','l','o'});
-
-    // Reverse a bidirectional, common, sized range
-    std::list<int> rgl{0,1,2,3,4,5,6,7,8,9};
-    auto const rng3 = rgl | views::reverse;
-    CPP_assert(view_<std::remove_const_t<decltype(rng3)>>);
-    CPP_assert(bidirectional_range<decltype(rng3)>);
-    CPP_assert(!random_access_range<decltype(rng3)>);
-    CPP_assert(common_range<decltype(rng3)>);
-    CPP_assert(sized_range<decltype(rng3)>);
-    CHECK(rng3.size() == 10u);
-    ::check_equal(rng3, {9,8,7,6,5,4,3,2,1,0});
-    ::check_equal(rng3 | views::reverse, {0,1,2,3,4,5,6,7,8,9});
-
-    // Reverse a bidirectional, weak, sized range
-    auto cnt2 = views::counted(rgl.begin(), 10);
-    auto rng4 = cnt2 | views::reverse;
-    CPP_assert(view_<decltype(rng4)>);
-    CPP_assert(bidirectional_range<decltype(rng4)>);
-    CPP_assert(!random_access_range<decltype(rng4)>);
-    CPP_assert(common_range<decltype(rng4)>);
-    CPP_assert(sized_range<decltype(rng4)>);
-    CHECK(rng4.size() == 10u);
-    auto const & crng4 = rng4;
-    CPP_assert(!range<decltype(crng4)>);
-    ::check_equal(rng4, {9,8,7,6,5,4,3,2,1,0});
-    ::check_equal(rng4 | views::reverse, {0,1,2,3,4,5,6,7,8,9});
-
-    // Reverse a bidirectional, weak, non-sized range
-    auto dlm = views::delimit(rgl.begin(), 9);
-    CPP_assert(!common_range<decltype(dlm)>);
-    auto rng5 = dlm | views::reverse;
-    CPP_assert(view_<decltype(rng5)>);
-    CPP_assert(bidirectional_range<decltype(rng5)>);
-    CPP_assert(!random_access_range<decltype(rng5)>);
-    CPP_assert(common_range<decltype(rng5)>);
-    CPP_assert(!sized_range<decltype(rng5)>);
-    auto const & crng5 = rng5;
-    CPP_assert(!range<decltype(crng5)>);
-    ::check_equal(rng5, {8,7,6,5,4,3,2,1,0});
-    ::check_equal(rng5 | views::reverse, {0,1,2,3,4,5,6,7,8});
-
-    // Reverse a bidirectional, weak, non-sized range
-    auto dlm2 = views::delimit(rgl, 10);
-    CPP_assert(!common_range<decltype(dlm2)>);
-    auto rng6 = dlm2 | views::reverse;
-    CPP_assert(view_<decltype(rng6)>);
-    CPP_assert(bidirectional_range<decltype(rng6)>);
-    CPP_assert(!random_access_range<decltype(rng6)>);
-    CPP_assert(common_range<decltype(rng6)>);
-    CPP_assert(!sized_range<decltype(rng6)>);
-    auto const & crng6 = rng6;
-    CPP_assert(!range<decltype(crng6)>);
-    ::check_equal(rng6, {9,8,7,6,5,4,3,2,1,0});
-    ::check_equal(rng6 | views::reverse, {0,1,2,3,4,5,6,7,8,9});
-
-    {
-        std::vector<int> v = {1, 2, 3, 4, 5};
-        auto b = find(v, 2);
-        auto e = find(v | views::reverse, 4).base();
-        ::check_equal(make_subrange(b, e), {2, 3, 4});
-
-        auto e2 = find(v | views::filter([](int i){ return i%2 == 0;})
-                         | views::reverse, 4);
-        CHECK(::is_dangling(e2));
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/sample.cpp b/src/contrib/range-v3-0.11.0/test/view/sample.cpp
deleted file mode 100644
index 3088be22..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/sample.cpp
+++ /dev/null
@@ -1,42 +0,0 @@
-#include <range/v3/view/sample.hpp>
-#include <range/v3/algorithm/equal.hpp>
-#include <numeric>
-#include <vector>
-#include <random>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-using namespace ranges;
-
-int main ()
-{
-    std::mt19937 engine;
-
-    std::vector<int> pop(100);
-    std::iota(std::begin(pop), std::end(pop), 0);
-    {
-        constexpr int N = 32;
-        std::array<int, N> tmp;
-        auto rng = pop | views::sample(N, engine);
-        using Rng = decltype(rng);
-        CPP_assert(input_range<Rng> && view_<Rng>);
-        CPP_assert(!forward_range<Rng>);
-        ranges::copy(rng, tmp.begin());
-        rng = pop | views::sample(N, engine);
-        CHECK(!ranges::equal(rng, tmp));
-        engine = decltype(engine){};
-        rng = pop | views::sample(N, engine);
-        CHECK(ranges::equal(rng, tmp));
-    }
-
-    {
-        int const some_ints[] = {0,1,2,3,4,5,6,7,8};
-        auto rng = debug_input_view<int const>{some_ints} | views::sample(4, engine);
-        using Rng = decltype(rng);
-        CPP_assert(input_range<Rng> && view_<Rng>);
-        CPP_assert(!forward_range<Rng>);
-        CHECK(ranges::distance(rng) == 4);
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/set_difference.cpp b/src/contrib/range-v3-0.11.0/test/view/set_difference.cpp
deleted file mode 100644
index e1dc19fc..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/set_difference.cpp
+++ /dev/null
@@ -1,269 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Tomislav Ivek 2015-2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <vector>
-#include <sstream>
-#include <range/v3/core.hpp>
-#include <range/v3/range_for.hpp>
-#include <range/v3/algorithm/set_algorithm.hpp>
-#include <range/v3/algorithm/move.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/insert_iterators.hpp>
-#include <range/v3/iterator/move_iterators.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/utility/copy.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/const.hpp>
-#include <range/v3/view/drop_while.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/move.hpp>
-#include <range/v3/view/reverse.hpp>
-#include <range/v3/view/set_algorithm.hpp>
-#include <range/v3/view/stride.hpp>
-#include <range/v3/view/take.hpp>
-#include <range/v3/view/transform.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    int i1_finite[] = {1, 2, 2, 3, 3, 3, 4, 4, 4, 4};
-    int i2_finite[] = { -3, 2, 4, 4, 6, 9};
-
-    auto i1_infinite = views::ints | views::stride(3);
-    auto i2_infinite = views::ints | views::transform([](int x)
-    {
-        return x * x;
-    });
-
-    // difference between two finite ranges/sets
-    {
-        auto res = views::set_difference(i1_finite, i2_finite);
-
-        CPP_assert(view_<decltype(res)>);
-        CPP_assert(forward_range<decltype(res)>);
-        CPP_assert(!random_access_range<decltype(res)>);
-        CPP_assert(!common_range<decltype(res)>);
-
-        using R = decltype(res);
-
-        CPP_assert(same_as<range_value_t<R>, int>);
-        CPP_assert(same_as<range_reference_t<R>, int&>);
-        CPP_assert(same_as<decltype(iter_move(begin(res))), int &&>);
-
-        static_assert(range_cardinality<R>::value == ranges::finite, "Cardinality of difference between two finite ranges should be finite!");
-
-        ::check_equal(res, {1, 2, 3, 3, 3, 4, 4});
-
-        // check if the final result agrees with the greedy algorithm
-        std::vector<int> diff;
-        set_difference(i1_finite, i2_finite, back_inserter(diff));
-        ::check_equal(res, diff);
-
-        CHECK(&*begin(res) == &*(begin(i1_finite)));
-    }
-
-    // difference between two infinite ranges
-    {
-        auto res = views::set_difference(i1_infinite, i2_infinite);
-
-        CPP_assert(view_<decltype(res)>);
-        CPP_assert(forward_range<decltype(res)>);
-        CPP_assert(!random_access_range<decltype(res)>);
-        CPP_assert(!common_range<decltype(res)>);
-
-        using R = decltype(res);
-
-        CPP_assert(same_as<range_value_t<R>, int>);
-        CPP_assert(same_as<range_reference_t<R>, range_reference_t<decltype(i1_infinite)>>);
-        CPP_assert(same_as<decltype(iter_move(begin(res))), range_rvalue_reference_t<decltype(i1_infinite)>>);
-
-        static_assert(range_cardinality<R>::value == ranges::unknown, "Cardinality of difference of infinite ranges should be unknown!");
-
-        ::check_equal(res | views::take(5), {3, 6, 12, 15, 18});
-
-        // check if the final result agrees with the greedy algorithm
-        std::vector<int> diff;
-        set_difference(i1_infinite | views::take(1000), i2_infinite | views::take(1000), back_inserter(diff));
-        ::check_equal(res | views::take(5), diff | views::take(5));
-    }
-
-    // difference between a finite and an infinite range
-    {
-        auto res = views::set_difference(i1_finite, i2_infinite);
-
-        CPP_assert(view_<decltype(res)>);
-        CPP_assert(forward_range<decltype(res)>);
-        CPP_assert(!random_access_range<decltype(res)>);
-        CPP_assert(!common_range<decltype(res)>);
-
-        using R = decltype(res);
-
-        CPP_assert(same_as<range_value_t<R>, int>);
-        CPP_assert(same_as<range_reference_t<R>, range_reference_t<decltype(i1_finite)>>);
-        CPP_assert(same_as<decltype(iter_move(begin(res))), range_rvalue_reference_t<decltype(i1_finite)>>);
-
-        static_assert(range_cardinality<R>::value == ranges::finite, "Cardinality of difference between a finite range and any other range should be finite!");
-
-        ::check_equal(res, {2, 2, 3, 3, 3, 4, 4, 4});
-    }
-
-    // difference between an infinite and a finite range
-    {
-        auto res = views::set_difference(i1_infinite, i2_finite);
-
-        CPP_assert(view_<decltype(res)>);
-        CPP_assert(forward_range<decltype(res)>);
-        CPP_assert(!random_access_range<decltype(res)>);
-        CPP_assert(!common_range<decltype(res)>);
-
-        using R = decltype(res);
-
-        CPP_assert(same_as<range_value_t<R>, int>);
-        CPP_assert(same_as<range_reference_t<R>, range_reference_t<decltype(i1_infinite)>>);
-        CPP_assert(same_as<range_rvalue_reference_t<R>, range_rvalue_reference_t<decltype(i1_infinite)>>);
-
-        static_assert(range_cardinality<R>::value == ranges::infinite, "Cardinality of difference between an infinite and finite range should be infinite!");
-
-        ::check_equal(res | views::take(5), {0, 3, 12, 15, 18});
-    }
-
-    // differences involving unknown cardinalities
-    {
-        auto rng0 = views::iota(10) | views::drop_while([](int i)
-        {
-            return i < 25;
-        });
-        static_assert(range_cardinality<decltype(rng0)>::value == ranges::unknown, "");
-
-        auto res1 = views::set_difference(i2_finite, rng0);
-        static_assert(range_cardinality<decltype(res1)>::value == ranges::finite, "Difference between a finite and unknown cardinality set should have finite cardinality!");
-
-        auto res2 = views::set_difference(rng0, i2_finite);
-        static_assert(range_cardinality<decltype(res2)>::value == ranges::unknown, "Difference between an unknown cardinality and finite set should have unknown cardinality!");
-
-        auto res3 = views::set_difference(i1_infinite, rng0);
-        static_assert(range_cardinality<decltype(res3)>::value == ranges::unknown, "Difference between an unknown cardinality and finite set should have unknown cardinality!");
-
-        auto res4 = views::set_difference(rng0, i1_infinite);
-        static_assert(range_cardinality<decltype(res4)>::value == ranges::unknown, "Difference between an unknown and infinite cardinality set should have unknown cardinality!");
-
-    }
-
-    // test const ranges
-    {
-        auto res1 = views::set_difference(views::const_(i1_finite), views::const_(i2_finite));
-        using R1 = decltype(res1);
-        CPP_assert(same_as<range_value_t<R1>, int>);
-        CPP_assert(same_as<range_reference_t<R1>, const int&>);
-        CPP_assert(same_as<range_rvalue_reference_t<R1>, const int&&>);
-
-        auto res2 = views::set_difference(views::const_(i1_finite), i2_finite);
-        using R2 = decltype(res2);
-        CPP_assert(same_as<range_value_t<R2>, int>);
-        CPP_assert(same_as<range_reference_t<R2>, const int&>);
-        CPP_assert(same_as<range_rvalue_reference_t<R2>, const int&&>);
-    }
-
-    // test different orderings
-    {
-        auto res = views::set_difference(views::reverse(i1_finite), views::reverse(i2_finite), [](int a, int b)
-        {
-            return a > b;
-        });
-        ::check_equal(res, {4, 4, 3, 3, 3, 2, 1});
-    }
-
-    // test projections and sets with different element types
-    struct S
-    {
-        int val;
-        bool operator==(const S& other) const
-        {
-            return val == other.val;
-        }
-    };
-
-    S s_finite[] = {S{-20}, S{-10}, S{1}, S{3}, S{3}, S{6}, S{8}, S{20}};
-
-    {
-        auto res1 = views::set_difference(s_finite, views::ints(-2, 10),
-                                         less(),
-                                         &S::val,
-                                         identity()
-                                        );
-        using R1 = decltype(res1);
-        CPP_assert(same_as<range_value_t<R1>, S>);
-        CPP_assert(same_as<range_reference_t<R1>, S&>);
-        CPP_assert(same_as<range_rvalue_reference_t<R1>, S&&>);
-        ::check_equal(res1, {S{-20}, S{-10}, S{3}, S{20}});
-
-        auto res2 = views::set_difference(views::ints(-2, 10), s_finite,
-                                         less(),
-                                         identity(),
-                                         [](const S& x){ return x.val; }
-                                        );
-        using R2 = decltype(res2);
-        CPP_assert(same_as<range_value_t<R2>, int>);
-        CPP_assert(same_as<range_reference_t<R2>, int>);
-        CPP_assert(same_as<range_rvalue_reference_t<R2>, int>);
-        ::check_equal(res2, {-2, -1, 0, 2, 4, 5, 7, 9});
-    }
-
-    // move
-    {
-        auto v0 = to<std::vector<MoveOnlyString>>({"a","b","b","c","x","x"});
-        auto v1 = to<std::vector<MoveOnlyString>>({"b","x","y","z"});
-        auto res = views::set_difference(v0, v1, [](const MoveOnlyString& a, const MoveOnlyString& b){return a<b;});
-
-        std::vector<MoveOnlyString> expected;
-        move(res, back_inserter(expected));
-
-        ::check_equal(expected, {"a","b","c","x"});
-        ::check_equal(v1, {"b","x","y","z"});
-        ::check_equal(v0, {"","b","","","x",""});
-
-        auto v0_greedy = to<std::vector<MoveOnlyString>>({"a","b","b","c","x","x"});
-        auto v1_greedy = to<std::vector<MoveOnlyString>>({"b","x","y","z"});
-        std::vector<MoveOnlyString> expected_greedy;
-        set_difference(v0_greedy, v1_greedy,
-                       move_into(back_inserter(expected_greedy)),
-                       [](const MoveOnlyString& a, const MoveOnlyString& b){return a<b;});
-        ::check_equal(expected_greedy, expected);
-        ::check_equal(v0_greedy, v0);
-        ::check_equal(v1_greedy, v1);
-
-        using R = decltype(res);
-
-        CPP_assert(same_as<range_value_t<R>, MoveOnlyString>);
-        CPP_assert(same_as<range_reference_t<R>, MoveOnlyString &>);
-        CPP_assert(same_as<range_rvalue_reference_t<R>, MoveOnlyString &&>);
-    }
-
-    // WARNING: set_difference between two infinite ranges can create infinite loops!
-    // {
-    //     auto empty_range = views::set_difference(views::ints, views::ints);
-    //     begin(empty_range); // infinite loop!
-    // }
-
-    {
-        auto rng = views::set_difference(
-            debug_input_view<int const>{i1_finite},
-            debug_input_view<int const>{i2_finite}
-        );
-        ::check_equal(rng, {1, 2, 3, 3, 3, 4, 4});
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/set_intersection.cpp b/src/contrib/range-v3-0.11.0/test/view/set_intersection.cpp
deleted file mode 100644
index f607e1f3..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/set_intersection.cpp
+++ /dev/null
@@ -1,228 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Tomislav Ivek 2015-2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <vector>
-#include <sstream>
-#include <range/v3/core.hpp>
-#include <range/v3/range_for.hpp>
-#include <range/v3/algorithm/set_algorithm.hpp>
-#include <range/v3/algorithm/move.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/insert_iterators.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/utility/copy.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/const.hpp>
-#include <range/v3/view/drop_while.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/reverse.hpp>
-#include <range/v3/view/set_algorithm.hpp>
-#include <range/v3/view/stride.hpp>
-#include <range/v3/view/take.hpp>
-#include <range/v3/view/transform.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    int i1_finite[] = {1, 2, 2, 3, 3, 3, 4, 4, 4, 4};
-    int i2_finite[] = { -3, 2, 4, 4, 6, 9};
-
-    auto i1_infinite = views::ints | views::stride(3);
-    auto i2_infinite = views::ints | views::transform([](int x)
-    {
-        return x * x;
-    });
-
-    // intersection of two finite ranges
-    {
-        auto res = views::set_intersection(i1_finite, i2_finite);
-
-        CPP_assert(view_<decltype(res)>);
-        CPP_assert(forward_range<decltype(res)>);
-        CPP_assert(!random_access_range<decltype(res)>);
-        CPP_assert(!common_range<decltype(res)>);
-
-        using R = decltype(res);
-
-        CPP_assert(same_as<range_value_t<R>, int>);
-        CPP_assert(same_as<range_reference_t<R>, int&>);
-        CPP_assert(same_as<decltype(iter_move(begin(res))), int &&>);
-
-        static_assert(range_cardinality<R>::value == ranges::finite, "Cardinality of intersection with a finite range should be finite!");
-
-        ::check_equal(res, {2, 4, 4});
-
-        CHECK(&*begin(res) == &*(begin(i1_finite) + 1));
-    }
-
-    // intersection of two infinite ranges
-    {
-        auto res = views::set_intersection(i1_infinite, i2_infinite);
-
-        CPP_assert(view_<decltype(res)>);
-        CPP_assert(forward_range<decltype(res)>);
-        CPP_assert(!random_access_range<decltype(res)>);
-        CPP_assert(!common_range<decltype(res)>);
-
-        using R = decltype(res);
-
-        CPP_assert(same_as<range_value_t<R>, int>);
-        CPP_assert(same_as<range_reference_t<R>, range_reference_t<decltype(i1_infinite)>>);
-        CPP_assert(same_as<decltype(iter_move(begin(res))), range_rvalue_reference_t<decltype(i1_infinite)>>);
-
-        static_assert(range_cardinality<R>::value == ranges::unknown, "Cardinality of intersection of infinite ranges should be unknown!");
-
-        ::check_equal(res | views::take(5), {0, 9, 36, 81, 144});
-    }
-
-    // intersection of a finite and infinite range
-    {
-        auto res = views::set_intersection(i1_finite, i2_infinite);
-
-        CPP_assert(view_<decltype(res)>);
-        CPP_assert(forward_range<decltype(res)>);
-        CPP_assert(!random_access_range<decltype(res)>);
-        CPP_assert(!common_range<decltype(res)>);
-
-        using R = decltype(res);
-
-        CPP_assert(same_as<range_value_t<R>, int>);
-        CPP_assert(same_as<range_reference_t<R>, range_reference_t<decltype(i1_finite)>>);
-        CPP_assert(same_as<decltype(iter_move(begin(res))), range_rvalue_reference_t<decltype(i1_finite)>>);
-
-        static_assert(range_cardinality<R>::value == ranges::finite, "Cardinality of intersection with a finite range should be finite!");
-
-        ::check_equal(res | views::take(500), {1, 4});
-
-        auto res2 = views::set_intersection(i1_infinite, i2_finite);
-
-        CPP_assert(view_<decltype(res2)>);
-        CPP_assert(forward_range<decltype(res2)>);
-        CPP_assert(!random_access_range<decltype(res2)>);
-        CPP_assert(!common_range<decltype(res2)>);
-
-        using R2 = decltype(res2);
-
-        CPP_assert(same_as<range_value_t<R2>, int>);
-        CPP_assert(same_as<range_reference_t<R2>, range_reference_t<decltype(i1_infinite)>>);
-        CPP_assert(same_as<range_rvalue_reference_t<R2>, range_rvalue_reference_t<decltype(i1_infinite)>>);
-
-        static_assert(range_cardinality<decltype(res2)>::value == ranges::finite, "Cardinality of intersection with a finite range should be finite!");
-
-        ::check_equal(res2 | views::take(500), {6, 9});
-    }
-
-    // intersection of a set of unknown cardinality
-    {
-        auto rng0 = views::iota(10) | views::drop_while([](int i)
-        {
-            return i < 25;
-        });
-        static_assert(range_cardinality<decltype(rng0)>::value == ranges::unknown, "");
-
-        auto res = views::set_intersection(i1_finite, rng0);
-        static_assert(range_cardinality<decltype(res)>::value == ranges::unknown, "Intersection with a set of unknown cardinality should have unknown cardinality!");
-    }
-
-    // test const ranges
-    {
-        auto res1 = views::set_intersection(views::const_(i1_finite), views::const_(i2_finite));
-        using R1 = decltype(res1);
-        CPP_assert(same_as<range_value_t<R1>, int>);
-        CPP_assert(same_as<range_reference_t<R1>, const int&>);
-        CPP_assert(same_as<range_rvalue_reference_t<R1>, const int&&>);
-
-        auto res2 = views::set_intersection(views::const_(i1_finite), i2_finite);
-        using R2 = decltype(res2);
-        CPP_assert(same_as<range_value_t<R2>, int>);
-        CPP_assert(same_as<range_reference_t<R2>, const int&>);
-        CPP_assert(same_as<range_rvalue_reference_t<R2>, const int&&>);
-    }
-
-    // test different orderings
-    {
-        auto res = views::set_intersection(views::reverse(i1_finite), views::reverse(i2_finite), [](int a, int b)
-        {
-            return a > b;
-        });
-        ::check_equal(res, {4, 4, 2});
-    }
-
-    // test projections and sets with different element types
-    struct S
-    {
-        int val;
-        bool operator==(const S& other) const
-        {
-            return val == other.val;
-        }
-    };
-
-    S s_finite[] = {S{-20}, S{-10}, S{1}, S{3}, S{3}, S{6}, S{8}, S{20}};
-
-    {
-        auto res1 = views::set_intersection(s_finite, views::ints(-2, 10),
-                                           less(),
-                                           &S::val,
-                                           identity()
-                                          );
-        using R1 = decltype(res1);
-        CPP_assert(same_as<range_value_t<R1>, S>);
-        CPP_assert(same_as<range_reference_t<R1>, S&>);
-        CPP_assert(same_as<range_rvalue_reference_t<R1>, S&&>);
-        ::check_equal(res1, {S{1}, S{3}, S{6}, S{8}});
-
-        auto res2 = views::set_intersection(views::ints(-2, 10), s_finite,
-                                           less(),
-                                           identity(),
-                                           [](const S& x){ return x.val; }
-                                          );
-        using R2 = decltype(res2);
-        CPP_assert(same_as<range_value_t<R2>, int>);
-        CPP_assert(same_as<range_reference_t<R2>, int>);
-        CPP_assert(same_as<range_rvalue_reference_t<R2>, int>);
-        ::check_equal(res2, {1, 3, 6, 8});
-    }
-
-    // move
-    {
-        auto v0 = to<std::vector<MoveOnlyString>>({"a","b","b","c","x","x"});
-        auto v1 = to<std::vector<MoveOnlyString>>({"b","x","y","z"});
-        auto res = views::set_intersection(v0, v1, [](const MoveOnlyString& a, const MoveOnlyString& b){return a<b;});
-
-        std::vector<MoveOnlyString> expected;
-        move(res, back_inserter(expected));
-
-        ::check_equal(expected, {"b","x"});
-        ::check_equal(v0, {"a","","b","c","","x"});
-        ::check_equal(v1, {"b","x","y","z"});
-
-        using R = decltype(res);
-
-        CPP_assert(same_as<range_value_t<R>, MoveOnlyString>);
-        CPP_assert(same_as<range_reference_t<R>, MoveOnlyString &>);
-        CPP_assert(same_as<range_rvalue_reference_t<R>, MoveOnlyString &&>);
-    }
-
-    {
-        auto rng = views::set_intersection(
-            debug_input_view<int const>{i1_finite},
-            debug_input_view<int const>{i2_finite}
-        );
-        ::check_equal(rng, {2, 4, 4});
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/set_symmetric_difference.cpp b/src/contrib/range-v3-0.11.0/test/view/set_symmetric_difference.cpp
deleted file mode 100644
index 86f9d3bf..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/set_symmetric_difference.cpp
+++ /dev/null
@@ -1,324 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Tomislav Ivek 2015-2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <vector>
-#include <sstream>
-#include <range/v3/core.hpp>
-#include <range/v3/range_for.hpp>
-#include <range/v3/algorithm/set_algorithm.hpp>
-#include <range/v3/algorithm/move.hpp>
-#include <range/v3/utility/common_type.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/insert_iterators.hpp>
-#include <range/v3/iterator/move_iterators.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/const.hpp>
-#include <range/v3/view/drop_while.hpp>
-#include <range/v3/view/empty.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/reverse.hpp>
-#include <range/v3/view/set_algorithm.hpp>
-#include <range/v3/view/stride.hpp>
-#include <range/v3/view/take.hpp>
-#include <range/v3/view/transform.hpp>
-#include <range/v3/view/zip.hpp>
-#include <range/v3/utility/copy.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    int i1_finite[] = {1, 2, 2, 3, 3, 3, 4, 4, 4, 4};
-    int i2_finite[] = { -3, 2, 4, 4, 6, 9};
-
-    auto i1_infinite = views::ints | views::stride(3);
-    auto i2_infinite = views::ints | views::transform([](int x)
-    {
-        return x * x;
-    });
-
-    // symmetric difference between two finite ranges/sets
-    {
-        auto res = views::set_symmetric_difference(i1_finite, i2_finite);
-
-        CPP_assert(view_<decltype(res)>);
-        CPP_assert(forward_range<decltype(res)>);
-        CPP_assert(!random_access_range<decltype(res)>);
-        CPP_assert(!common_range<decltype(res)>);
-
-        using R = decltype(res);
-
-        CPP_assert(same_as<range_value_t<R>, int>);
-        CPP_assert(same_as<range_reference_t<R>, int&>);
-        CPP_assert(same_as<decltype(iter_move(begin(res))), int&&>);
-
-        static_assert(range_cardinality<R>::value == ranges::finite, "Cardinality of symmetric difference of finite ranges should be finite!");
-
-        ::check_equal(res, {-3, 1, 2, 3, 3, 3, 4, 4, 6, 9});
-
-        // check if the final result agrees with the greedy algorithm
-        std::vector<int> greedy_sd;
-        set_symmetric_difference(i1_finite, i2_finite, back_inserter(greedy_sd));
-        ::check_equal(res, greedy_sd);
-
-        auto it = begin(res);
-        CHECK(&*it == &*(begin(i2_finite)));
-        ++it;
-        CHECK(&*it == &*(begin(i1_finite)));
-    }
-
-    // symmetric difference between two infinite ranges
-    {
-        auto res = views::set_symmetric_difference(i1_infinite, i2_infinite);
-
-        CPP_assert(view_<decltype(res)>);
-        CPP_assert(forward_range<decltype(res)>);
-        CPP_assert(!random_access_range<decltype(res)>);
-        CPP_assert(!common_range<decltype(res)>);
-
-        using R = decltype(res);
-
-        CPP_assert(same_as<range_value_t<R>,
-                            common_type_t<range_value_t<decltype(i1_infinite)>,
-                                          range_value_t<decltype(i2_infinite)>>>);
-        CPP_assert(same_as<range_reference_t<R>,
-                            common_reference_t<range_reference_t<decltype(i1_infinite)>,
-                                               range_reference_t<decltype(i2_infinite)>>
-                           >);
-        CPP_assert(same_as<range_rvalue_reference_t<R>,
-                            common_reference_t<range_rvalue_reference_t<decltype(i1_infinite)>,
-                                               range_rvalue_reference_t<decltype(i2_infinite)>>
-                           >);
-
-        static_assert(range_cardinality<R>::value == ranges::unknown, "Cardinality of symmetric difference between infinite ranges should be unknown!");
-
-        ::check_equal(res | views::take(6), {1, 3, 4, 6, 12, 15});
-
-        // check if the final result agrees with the greedy algorithm
-        std::vector<int> greedy_sd;
-        set_symmetric_difference(i1_infinite | views::take(10), i2_infinite | views::take(10), back_inserter(greedy_sd));
-        ::check_equal(res | views::take(6), greedy_sd | views::take(6));
-    }
-
-    // symmetric difference between a finite and an infinite range
-    {
-        auto res1 = views::set_symmetric_difference(i1_finite, i2_infinite);
-
-        CPP_assert(view_<decltype(res1)>);
-        CPP_assert(forward_range<decltype(res1)>);
-        CPP_assert(!random_access_range<decltype(res1)>);
-        CPP_assert(!common_range<decltype(res1)>);
-
-        using R1 = decltype(res1);
-
-        CPP_assert(same_as<range_value_t<R1>, int>);
-        CPP_assert(same_as<range_reference_t<R1>, int>); // our infinite range does not give out references
-        CPP_assert(same_as<range_rvalue_reference_t<R1>, int>);
-
-        static_assert(range_cardinality<R1>::value == ranges::infinite, "Cardinality of symmetric difference between a finite and an infinite range should be infinite!");
-
-        ::check_equal(res1 | views::take(10), {0, 2, 2, 3, 3, 3, 4, 4, 4, 9});
-
-        // now swap the operands:
-        auto res2 = views::set_symmetric_difference(i2_infinite, i1_finite);
-
-        CPP_assert(view_<decltype(res2)>);
-        CPP_assert(forward_range<decltype(res2)>);
-        CPP_assert(!random_access_range<decltype(res2)>);
-        CPP_assert(!common_range<decltype(res2)>);
-
-        using R2 = decltype(res2);
-
-        CPP_assert(same_as<range_value_t<R2>, int>);
-        CPP_assert(same_as<range_reference_t<R2>, int>); // our infinite range does not give out references
-        CPP_assert(same_as<range_rvalue_reference_t<R2>, int>);
-
-        static_assert(range_cardinality<R2>::value == ranges::infinite, "Cardinality of symmetric difference between a finite and an infinite range should be infinite!");
-
-        ::check_equal(res1 | views::take(10), res2 | views::take(10));
-    }
-
-    // symmetric differences involving unknown cardinalities
-    {
-        auto rng0 = views::iota(10) | views::drop_while([](int i)
-        {
-            return i < 25;
-        });
-        static_assert(range_cardinality<decltype(rng0)>::value == ranges::unknown, "");
-
-        auto res1 = views::set_symmetric_difference(i2_finite, rng0);
-        static_assert(range_cardinality<decltype(res1)>::value == ranges::unknown, "Symmetric difference between a finite and unknown cardinality set should have unknown cardinality!");
-
-        auto res2 = views::set_symmetric_difference(rng0, i2_finite);
-        static_assert(range_cardinality<decltype(res2)>::value == ranges::unknown, "Symmetric difference between an unknown and finite cardinality set should have unknown cardinality!");
-
-        auto res3 = views::set_symmetric_difference(i1_infinite, rng0);
-        static_assert(range_cardinality<decltype(res3)>::value == ranges::unknown, "Symmetric difference between an infinite and unknown cardinality set should have unknown cardinality!");
-
-        auto res4 = views::set_symmetric_difference(rng0, i1_infinite);
-        static_assert(range_cardinality<decltype(res4)>::value == ranges::unknown, "Symmetric difference between an unknown and infinite cardinality set should have infinite cardinality!");
-
-        auto res5 = views::set_symmetric_difference(rng0, rng0);
-        static_assert(range_cardinality<decltype(res5)>::value == ranges::unknown, "Symmetric difference between two unknown cardinality sets should have unknown cardinality!");
-    }
-
-    // test const ranges
-    {
-        auto res1 = views::set_symmetric_difference(views::const_(i1_finite), views::const_(i2_finite));
-        using R1 = decltype(res1);
-        CPP_assert(same_as<range_value_t<R1>, int>);
-        CPP_assert(same_as<range_reference_t<R1>, const int&>);
-        CPP_assert(same_as<range_rvalue_reference_t<R1>, const int&&>);
-
-        auto res2 = views::set_symmetric_difference(views::const_(i1_finite), i2_finite);
-        using R2 = decltype(res2);
-        CPP_assert(same_as<range_value_t<R2>, int>);
-        CPP_assert(same_as<range_reference_t<R2>, const int&>);
-        CPP_assert(same_as<range_rvalue_reference_t<R2>, const int&&>);
-    }
-
-    // test different orderings
-    {
-        auto res = views::set_symmetric_difference(views::reverse(i1_finite), views::reverse(i2_finite), [](int a, int b)
-        {
-            return a > b;
-        });
-        ::check_equal(res, {9, 6, 4, 4, 3, 3, 3, 2, 1, -3});
-        CHECK(&*begin(res) == &*(begin(i2_finite) + 5));
-    }
-
-    struct B
-    {
-        int val;
-        B(int i): val{i} {}
-        bool operator==(const B& other) const
-        {
-            return val == other.val;
-        }
-    };
-
-    struct D: public B
-    {
-        D(int i): B{i} {}
-        D(B b): B{std::move(b)} {}
-    };
-
-    B b_finite[] = {B{-20}, B{-10}, B{1}, B{3}, B{3}, B{6}, B{8}, B{20}};
-    D d_finite[] = {D{0}, D{2}, D{4}, D{6}};
-
-    // sets with different element types, custom orderings
-    {
-        auto res = views::set_symmetric_difference(b_finite, d_finite, [](const B& a, const D& b){ return a.val < b.val; });
-        CPP_assert(same_as<range_value_t<decltype(res)>, B>);
-        CPP_assert(same_as<range_reference_t<decltype(res)>, B&>);
-        CPP_assert(same_as<range_rvalue_reference_t<decltype(res)>, B&&>);
-        ::check_equal(res, {B{-20}, B{-10}, B{0}, B{1}, B{2}, B{3}, B{3}, B{4}, B{8}, B{20}});
-        auto it = begin(res);
-        CHECK(&*it == &*begin(b_finite));
-        advance(it, 2);
-        CHECK(&*it == &*begin(d_finite));
-    }
-
-    // projections
-    {
-        auto res1 = views::set_symmetric_difference(b_finite, d_finite,
-                                                   less(),
-                                                   &B::val,
-                                                   &D::val
-                                                  );
-        CPP_assert(same_as<range_value_t<decltype(res1)>, B>);
-        CPP_assert(same_as<range_reference_t<decltype(res1)>, B&>);
-        CPP_assert(same_as<range_rvalue_reference_t<decltype(res1)>, B&&>);
-        ::check_equal(res1, {B{-20}, B{-10}, B{0}, B{1}, B{2}, B{3}, B{3}, B{4}, B{8}, B{20}});
-
-        auto res2 = views::set_symmetric_difference(views::ints(-2, 10), b_finite,
-                                                   less(),
-                                                   identity(),
-                                                   [](const B& x){ return x.val; }
-                                                  );
-        CPP_assert(same_as<range_value_t<decltype(res2)>, B>);
-        CPP_assert(same_as<range_reference_t<decltype(res2)>, B>);
-        CPP_assert(same_as<range_rvalue_reference_t<decltype(res2)>, B>);
-        ::check_equal(res2, {B{-20}, B{-10}, B{-2}, B{-1}, B{0}, B{2}, B{3}, B{4}, B{5}, B{7}, B{9}, B{20}});
-    }
-
-    // move
-    {
-        auto v0 = to<std::vector<MoveOnlyString>>({"a","b","b","c","x","x"});
-        auto v1 = to<std::vector<MoveOnlyString>>({"b","x","y","z"});
-        auto res = views::set_symmetric_difference(v0, v1, [](const MoveOnlyString& a, const MoveOnlyString& b){return a<b;});
-
-        std::vector<MoveOnlyString> expected;
-        move(res, back_inserter(expected));
-
-        ::check_equal(expected, {"a","b","c","x","y","z"});
-        ::check_equal(v1, {"b","x","",""});
-        ::check_equal(v0, {"","b","","","x",""});
-
-        auto v0_greedy = to<std::vector<MoveOnlyString>>({"a","b","b","c","x","x"});
-        auto v1_greedy = to<std::vector<MoveOnlyString>>({"b","x","y","z"});
-        std::vector<MoveOnlyString> expected_greedy;
-        set_symmetric_difference(v0_greedy, v1_greedy,
-                                 move_into(back_inserter(expected_greedy)),
-                                 [](const MoveOnlyString& a, const MoveOnlyString& b){return a<b;});
-        ::check_equal(expected_greedy, expected);
-        ::check_equal(v0_greedy, v0);
-        ::check_equal(v1_greedy, v1);
-
-        using R = decltype(res);
-
-        CPP_assert(same_as<range_value_t<R>, MoveOnlyString>);
-        CPP_assert(same_as<range_reference_t<R>, MoveOnlyString &>);
-        CPP_assert(same_as<range_rvalue_reference_t<R>, MoveOnlyString &&>);
-    }
-
-    // WARNING: set_symmetric_difference between two infinite ranges can create infinite loops!
-    // {
-    //     auto empty_range = views::set_symmetric_difference(views::ints, views::ints);
-    //     begin(empty_range); // infinite loop!
-    // }
-
-    // iterator (in)equality
-    {
-        int r1[] = {1, 2, 3};
-        int r2[] = {   2, 3, 4, 5};
-        auto res = views::set_symmetric_difference(r1, r2); // 1, 4, 5
-
-        auto it1 = ranges::next(res.begin()); // *it1 == 4, member iterator into r1 points to r1.end()
-        auto it2 = ranges::next(it1);         // *it2 == 5, member iterator into r1 also points to r1.end()
-        auto sentinel = res.end();
-
-        CHECK(*it1 == 4);
-        CHECK(*it2 == 5);
-
-        CHECK(it1 != it2); // should be different even though member iterators into r1 are the same
-
-        CHECK(it1 != sentinel);
-        CHECK(ranges::next(it1, 2) == sentinel);
-
-        CHECK(it2 != sentinel);
-        CHECK(ranges::next(it2, 1) == sentinel);
-    }
-
-    {
-        auto rng = views::set_symmetric_difference(
-            debug_input_view<int const>{i1_finite},
-            debug_input_view<int const>{i2_finite}
-        );
-        ::check_equal(rng, {-3, 1, 2, 3, 3, 3, 4, 4, 6, 9});
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/set_union.cpp b/src/contrib/range-v3-0.11.0/test/view/set_union.cpp
deleted file mode 100644
index e54c826e..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/set_union.cpp
+++ /dev/null
@@ -1,315 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//  Copyright Tomislav Ivek 2015-2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <vector>
-#include <sstream>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/set_algorithm.hpp>
-#include <range/v3/algorithm/move.hpp>
-#include <range/v3/functional/identity.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/insert_iterators.hpp>
-#include <range/v3/utility/common_type.hpp>
-#include <range/v3/utility/copy.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/const.hpp>
-#include <range/v3/view/drop_while.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/move.hpp>
-#include <range/v3/view/reverse.hpp>
-#include <range/v3/view/set_algorithm.hpp>
-#include <range/v3/view/stride.hpp>
-#include <range/v3/view/take.hpp>
-#include <range/v3/view/transform.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    int i1_finite[] = {1, 2, 2, 3, 3, 3, 4, 4, 4, 4};
-    int i2_finite[] = { -3, 2, 4, 4, 6, 9};
-
-    auto i1_infinite = views::ints | views::stride(3);
-    auto i2_infinite = views::ints | views::transform([](int x)
-    {
-        return x * x;
-    });
-
-    // simple identity check
-    {
-        ::check_equal(views::set_union(i1_infinite, i1_infinite) | views::take(100), i1_infinite | views::take(100));
-    }
-
-    // union of two finite ranges/sets
-    {
-        auto res = views::set_union(i1_finite, i2_finite);
-
-        CPP_assert(view_<decltype(res)>);
-        CPP_assert(forward_range<decltype(res)>);
-        CPP_assert(!random_access_range<decltype(res)>);
-        CPP_assert(!common_range<decltype(res)>);
-
-        using R = decltype(res);
-
-        CPP_assert(same_as<range_value_t<R>, int>);
-        CPP_assert(same_as<range_reference_t<R>, int&>);
-        CPP_assert(same_as<decltype(iter_move(begin(res))), int&&>);
-
-        static_assert(range_cardinality<R>::value == ranges::finite, "Cardinality of union of finite ranges should be finite!");
-
-        ::check_equal(res, {-3, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 6, 9});
-
-        // check if the final result agrees with the greedy algorithm
-        std::vector<int> greedy_union;
-        set_union(i1_finite, i2_finite, back_inserter(greedy_union));
-        ::check_equal(res, greedy_union);
-
-        auto it = begin(res);
-        CHECK(&*it == &*(begin(i2_finite)));
-        ++it;
-        CHECK(&*it == &*(begin(i1_finite)));
-    }
-
-    // union of two infinite ranges
-    {
-        auto res = views::set_union(i1_infinite, i2_infinite);
-
-        CPP_assert(view_<decltype(res)>);
-        CPP_assert(forward_range<decltype(res)>);
-        CPP_assert(!random_access_range<decltype(res)>);
-        CPP_assert(!common_range<decltype(res)>);
-
-        using R = decltype(res);
-
-        CPP_assert(same_as<range_value_t<R>,
-                            common_type_t<range_value_t<decltype(i1_infinite)>,
-                                          range_value_t<decltype(i2_infinite)>>>);
-        CPP_assert(same_as<range_reference_t<R>,
-                            common_reference_t<range_reference_t<decltype(i1_infinite)>,
-                                               range_reference_t<decltype(i2_infinite)>>
-                           >);
-        CPP_assert(same_as<range_rvalue_reference_t<R>,
-                            common_reference_t<range_rvalue_reference_t<decltype(i1_infinite)>,
-                                               range_rvalue_reference_t<decltype(i2_infinite)>>
-                           >);
-
-        static_assert(range_cardinality<R>::value == ranges::infinite, "Cardinality of union of infinite ranges should be infinite!");
-
-        ::check_equal(res | views::take(6), {0, 1, 3, 4, 6, 9});
-
-        // check if the final result agrees with the greedy algorithm
-        std::vector<int> greedy_union;
-        set_union(i1_infinite | views::take(10), i2_infinite | views::take(10), back_inserter(greedy_union));
-        ::check_equal(res | views::take(6), greedy_union | views::take(6));
-    }
-
-    // union of a finite and an infinite range
-    {
-        auto res = views::set_union(i1_finite, i2_infinite);
-
-        CPP_assert(view_<decltype(res)>);
-        CPP_assert(forward_range<decltype(res)>);
-        CPP_assert(!random_access_range<decltype(res)>);
-        CPP_assert(!common_range<decltype(res)>);
-
-        using R = decltype(res);
-
-        CPP_assert(same_as<range_value_t<R>, int>);
-        CPP_assert(same_as<range_reference_t<R>, int>); // our infinite range does not give out references
-        CPP_assert(same_as<range_rvalue_reference_t<R>, int>);
-
-        static_assert(range_cardinality<R>::value == ranges::infinite, "Cardinality of union with an infinite range should be infinite!");
-
-        ::check_equal(res | views::take(5), {0, 1, 2, 2, 3});
-    }
-
-    // union of an infinite and a finite range
-    {
-        auto res = views::set_union(i1_infinite, i2_finite);
-
-        CPP_assert(view_<decltype(res)>);
-        CPP_assert(forward_range<decltype(res)>);
-        CPP_assert(!random_access_range<decltype(res)>);
-        CPP_assert(!common_range<decltype(res)>);
-
-        using R = decltype(res);
-
-        CPP_assert(same_as<range_value_t<R>, int>);
-        CPP_assert(same_as<range_reference_t<R>, int>); // our infinite range does not give out references
-        CPP_assert(same_as<range_rvalue_reference_t<R>, int>);
-
-        static_assert(range_cardinality<R>::value == ranges::infinite, "Cardinality of union with an infinite range should be infinite!");
-
-        ::check_equal(res | views::take(7), {-3, 0, 2, 3, 4, 4, 6});
-    }
-
-    // unions involving unknown cardinalities
-    {
-        auto rng0 = views::iota(10) | views::drop_while([](int i)
-        {
-            return i < 25;
-        });
-        static_assert(range_cardinality<decltype(rng0)>::value == ranges::unknown, "");
-
-        auto res1 = views::set_union(i2_finite, rng0);
-        static_assert(range_cardinality<decltype(res1)>::value == ranges::unknown, "Union of a finite and unknown cardinality set should have unknown cardinality!");
-
-        auto res2 = views::set_union(rng0, i2_finite);
-        static_assert(range_cardinality<decltype(res2)>::value == ranges::unknown, "Union of an unknown and finite cardinality set should have unknown cardinality!");
-
-        auto res3 = views::set_union(i1_infinite, rng0);
-        static_assert(range_cardinality<decltype(res3)>::value == ranges::infinite, "Union of an infinite and unknown cardinality set should have infinite cardinality!");
-
-        auto res4 = views::set_union(rng0, i1_infinite);
-        static_assert(range_cardinality<decltype(res4)>::value == ranges::infinite, "Union of an unknown and infinite cardinality set should have infinite cardinality!");
-
-        auto res5 = views::set_union(rng0, rng0);
-        static_assert(range_cardinality<decltype(res5)>::value == ranges::unknown, "Union of two unknown cardinality sets should have unknown cardinality!");
-        ::check_equal(res5 | views::take(100), rng0 | views::take(100));
-    }
-
-    // test const ranges
-    {
-        auto res1 = views::set_union(views::const_(i1_finite), views::const_(i2_finite));
-        using R1 = decltype(res1);
-        CPP_assert(same_as<range_value_t<R1>, int>);
-        CPP_assert(same_as<range_reference_t<R1>, const int&>);
-        CPP_assert(same_as<range_rvalue_reference_t<R1>, const int&&>);
-
-        auto res2 = views::set_union(views::const_(i1_finite), i2_finite);
-        using R2 = decltype(res2);
-        CPP_assert(same_as<range_value_t<R2>, int>);
-        CPP_assert(same_as<range_reference_t<R2>, const int&>);
-        CPP_assert(same_as<range_rvalue_reference_t<R2>, const int&&>);
-    }
-
-    // test different orderings
-    {
-        auto res = views::set_union(views::reverse(i1_finite), views::reverse(i2_finite), [](int a, int b)
-        {
-            return a > b;
-        });
-        ::check_equal(res, {9, 6, 4, 4, 4, 4, 3, 3, 3, 2, 2, 1, -3});
-    }
-
-    struct B
-    {
-        int val;
-        B(int i): val{i} {}
-        bool operator==(const B& other) const
-        {
-            return val == other.val;
-        }
-    };
-
-    struct D: public B
-    {
-        D(int i): B{i} {}
-        D(B b): B{std::move(b)} {}
-    };
-
-    B b_finite[] = {B{-20}, B{-10}, B{1}, B{3}, B{3}, B{6}, B{8}, B{20}};
-    D d_finite[] = {D{0}, D{2}, D{4}, D{6}};
-
-    // sets with different element types, custom orderings
-    {
-        auto res = views::set_union(b_finite, d_finite, [](const B& a, const D& b){ return a.val < b.val; });
-        using R = decltype(res);
-        CPP_assert(same_as<range_value_t<R>, B>);
-        CPP_assert(same_as<range_reference_t<R>, B&>);
-        CPP_assert(same_as<range_rvalue_reference_t<R>, B&&>);
-        ::check_equal(res, {B{-20}, B{-10}, B{0}, B{1}, B{2}, B{3}, B{3}, B{4}, B{6}, B{8}, B{20}});
-        auto it = begin(res);
-        CHECK(&*it == &*begin(b_finite));
-        advance(it, 2);
-        CHECK(&*it == &*begin(d_finite));
-    }
-
-    // projections
-    {
-        auto res1 = views::set_union(b_finite, d_finite,
-                                    less(),
-                                    &B::val,
-                                    &D::val
-                                   );
-        using R1 = decltype(res1);
-        CPP_assert(same_as<range_value_t<R1>, B>);
-        CPP_assert(same_as<range_reference_t<R1>, B&>);
-        CPP_assert(same_as<range_rvalue_reference_t<R1>, B&&>);
-        ::check_equal(res1, {B{-20}, B{-10}, B{0}, B{1}, B{2}, B{3}, B{3}, B{4}, B{6}, B{8}, B{20}});
-
-        auto res2 = views::set_union(views::ints(-2, 10), b_finite,
-                                    less(),
-                                    identity(),
-                                    [](const B& x){ return x.val; }
-                                   );
-        using R2 = decltype(res2);
-        CPP_assert(same_as<range_value_t<R2>, B>);
-        CPP_assert(same_as<range_reference_t<R2>, B>);
-        CPP_assert(same_as<range_rvalue_reference_t<R2>, B>);
-        ::check_equal(res2, {B{-20}, B{-10}, B{-2}, B{-1}, B{0}, B{1}, B{2}, B{3}, B{3}, B{4}, B{5}, B{6}, B{7}, B{8}, B{9}, B{20}});
-    }
-
-    // move
-    {
-        auto v0 = to<std::vector<MoveOnlyString>>({"a","b","c","x"});
-        auto v1 = to<std::vector<MoveOnlyString>>({"b","x","y","z"});
-        auto res = views::set_union(v0, v1, [](const MoveOnlyString& a, const MoveOnlyString& b){return a<b;});
-
-        std::vector<MoveOnlyString> expected;
-        move(res, back_inserter(expected));
-
-        ::check_equal(expected, {"a","b","c","x","y","z"});
-        ::check_equal(v0, {"","","",""});
-        ::check_equal(v1, {"b","x","",""});
-
-        using R = decltype(res);
-
-        CPP_assert(same_as<range_value_t<R>, MoveOnlyString>);
-        CPP_assert(same_as<range_reference_t<R>, MoveOnlyString &>);
-        CPP_assert(same_as<range_rvalue_reference_t<R>, MoveOnlyString &&>);
-    }
-
-    // iterator (in)equality
-    {
-        int r1[] = {1, 2, 3};
-        int r2[] = {   2, 3, 4, 5};
-        auto res = views::set_union(r1, r2); // 1, 2, 3, 4, 5
-
-        auto it1 = ranges::next(res.begin(), 3); // *it1 == 4, member iterator into r1 points to r1.end()
-        auto it2 = ranges::next(it1);            // *it2 == 5, member iterator into r1 also points to r1.end()
-        auto sentinel = res.end();
-
-        CHECK(*it1 == 4);
-        CHECK(*it2 == 5);
-
-        CHECK(it1 != it2); // should be different even though member iterators into r1 are the same
-
-        CHECK(it1 != sentinel);
-        CHECK(ranges::next(it1, 2) == sentinel);
-
-        CHECK(it2 != sentinel);
-        CHECK(ranges::next(it2, 1) == sentinel);
-    }
-
-    {
-        auto rng = views::set_union(
-            debug_input_view<int const>{i1_finite},
-            debug_input_view<int const>{i2_finite}
-        );
-        ::check_equal(rng, {-3, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 6, 9});
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/slice.cpp b/src/contrib/range-v3-0.11.0/test/view/slice.cpp
deleted file mode 100644
index 2832a50d..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/slice.cpp
+++ /dev/null
@@ -1,138 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <list>
-#include <vector>
-#include <string>
-#include <sstream>
-#include <range/v3/core.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/istream.hpp>
-#include <range/v3/view/slice.hpp>
-#include <range/v3/view/reverse.hpp>
-#include <range/v3/utility/copy.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    int rgi[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
-
-    auto rng0 = rgi | views::slice(3, 9);
-    has_type<int &>(*begin(rng0));
-    CPP_assert(view_<decltype(rng0)>);
-    CPP_assert(common_range<decltype(rng0)>);
-    CPP_assert(sized_range<decltype(rng0)>);
-    CPP_assert(random_access_iterator<decltype(begin(rng0))>);
-    ::check_equal(rng0, {3, 4, 5, 6, 7, 8});
-
-    auto rng1 = rng0 | views::reverse;
-    has_type<int &>(*begin(rng1));
-    CPP_assert(view_<decltype(rng1)>);
-    CPP_assert(common_range<decltype(rng1)>);
-    CPP_assert(sized_range<decltype(rng1)>);
-    CPP_assert(random_access_iterator<decltype(begin(rng1))>);
-    ::check_equal(rng1, {8, 7, 6, 5, 4, 3});
-
-    std::vector<int> v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
-    auto rng2 = v | views::slice(3, 9) | views::reverse;
-    has_type<int &>(*begin(rng2));
-    CPP_assert(view_<decltype(rng2)>);
-    CPP_assert(common_range<decltype(rng2)>);
-    CPP_assert(sized_range<decltype(rng2)>);
-    CPP_assert(random_access_iterator<decltype(begin(rng2))>);
-    ::check_equal(rng2, {8, 7, 6, 5, 4, 3});
-
-    std::list<int> l{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
-    auto rng3 = l | views::slice(3, 9);
-    has_type<int &>(*begin(rng3));
-    CPP_assert(view_<decltype(rng3)>);
-    CPP_assert(!common_range<decltype(rng3)>);
-    CPP_assert(sized_range<decltype(rng3)>);
-    CPP_assert(bidirectional_iterator<decltype(begin(rng3))>);
-    CPP_assert(!random_access_iterator<decltype(begin(rng3))>);
-    ::check_equal(rng3, {3, 4, 5, 6, 7, 8});
-
-    auto rng4 = views::iota(10) | views::slice(10, 20);
-    CPP_assert(view_<decltype(rng4)>);
-    CPP_assert(common_range<decltype(rng4)>);
-    CPP_assert(sized_range<decltype(rng4)>);
-    static_assert(!ranges::is_infinite<decltype(rng4)>::value, "");
-    ::check_equal(rng4, {20, 21, 22, 23, 24, 25, 26, 27, 28, 29});
-
-    auto rng5 = views::iota(10)[{10, 20}];
-    CPP_assert(view_<decltype(rng5)>);
-    CPP_assert(common_range<decltype(rng5)>);
-    CPP_assert(sized_range<decltype(rng5)>);
-    static_assert(!ranges::is_infinite<decltype(rng5)>::value, "");
-    ::check_equal(rng5, {20, 21, 22, 23, 24, 25, 26, 27, 28, 29});
-
-    auto rng6 = views::all(l)[{3, 9}];
-    has_type<int &>(*begin(rng6));
-    CPP_assert(view_<decltype(rng6)>);
-    CPP_assert(!common_range<decltype(rng6)>);
-    CPP_assert(sized_range<decltype(rng6)>);
-    CPP_assert(bidirectional_iterator<decltype(begin(rng6))>);
-    CPP_assert(!random_access_iterator<decltype(begin(rng6))>);
-    ::check_equal(rng6, {3, 4, 5, 6, 7, 8});
-
-    auto rng7 = views::all(l)[{3, end}];
-    has_type<int &>(*begin(rng7));
-    CPP_assert(view_<decltype(rng7)>);
-    CPP_assert(common_range<decltype(rng7)>);
-    CPP_assert(sized_range<decltype(rng7)>);
-    CPP_assert(bidirectional_iterator<decltype(begin(rng7))>);
-    CPP_assert(!random_access_iterator<decltype(begin(rng7))>);
-    ::check_equal(rng7, {3, 4, 5, 6, 7, 8, 9, 10});
-
-    auto rng8 = views::all(l)[{end-5,end-2}];
-    has_type<int &>(*begin(rng8));
-    CPP_assert(view_<decltype(rng8)>);
-    CPP_assert(!common_range<decltype(rng8)>);
-    CPP_assert(sized_range<decltype(rng8)>);
-    CPP_assert(bidirectional_iterator<decltype(begin(rng8))>);
-    CPP_assert(!random_access_iterator<decltype(begin(rng8))>);
-    ::check_equal(rng8, {6, 7, 8});
-
-    auto rng9 = views::iota(0)[{0,end}];
-    static_assert(is_infinite<decltype(rng9)>::value, "should be infinite");
-
-    {
-        std::string str{"0 1 2 3 4 5 6 7 8 9"};
-        std::stringstream sin{str};
-        auto rng10 = istream<int>(sin)[{3,9}];
-        ::check_equal(rng10, {3, 4, 5, 6, 7, 8});
-    }
-
-    {
-        std::string str{"0 1 2 3 4 5 6 7 8 9"};
-        std::stringstream sin{str};
-        auto rng11 = istream<int>(sin)[{3,end}];
-        ::check_equal(rng11, {3, 4, 5, 6, 7, 8, 9});
-    }
-
-    {
-        auto letters = views::closed_iota('a','g');
-        static_assert(random_access_range<decltype(letters)> && view_<decltype(letters)>, "");
-        static_assert(common_range<decltype(letters)> && view_<decltype(letters)>, "");
-        ::check_equal(letters[{2,end-2}], {'c','d','e'});
-    }
-
-    {
-        int const some_ints[] = {0,1,2,3,4,5,6,7,8,9};
-        auto rng = debug_input_view<int const>{some_ints} | views::slice(3,10);
-        ::check_equal(rng, {3, 4, 5, 6, 7, 8, 9});
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/sliding.cpp b/src/contrib/range-v3-0.11.0/test/view/sliding.cpp
deleted file mode 100644
index b375d216..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/sliding.cpp
+++ /dev/null
@@ -1,224 +0,0 @@
-// Range v3 library
-//
-//  Copyright Tobias Mayer 2016
-//  Copyright Casey Carter 2016
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <forward_list>
-#include <list>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/cycle.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/repeat.hpp>
-#include <range/v3/view/repeat_n.hpp>
-#include <range/v3/view/reverse.hpp>
-#include <range/v3/view/sliding.hpp>
-#include <range/v3/view/zip.hpp>
-#include <range/v3/view/group_by.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-using namespace ranges;
-
-namespace
-{
-    namespace ebo_test
-    {
-        struct empty1 {};
-        struct empty2 {};
-        struct refines : empty1, empty2 {};
-    }
-    constexpr bool broken_ebo = sizeof(ebo_test::refines) > sizeof(ebo_test::empty1);
-
-    constexpr auto N = 7;
-    constexpr auto K = 3;
-    CPP_assert(K < N);
-
-    template<typename Adapted>
-    void test_size(Adapted& a, std::true_type)
-    {
-        CPP_assert(sized_range<decltype(a)>);
-        CHECK(size(a), unsigned(N - K + 1));
-    }
-    template<typename Adapted>
-    void test_size(Adapted&, std::false_type)
-    {}
-
-    template<typename Adapted>
-    void test_common(Adapted& a, std::true_type)
-    {
-        CPP_assert(common_range<decltype(a)>);
-    }
-    // template<typename Adapted>
-    // void test_common(Adapted&, std::false_type)
-    // {}
-
-    template<typename Adapted>
-    void test_prev(Adapted& a, iterator_t<Adapted> const& it, std::true_type)
-    {
-        CPP_assert(bidirectional_range<decltype(a)>);
-        ::check_equal(*ranges::prev(it, 3), views::iota(N - K - 2, N - 2));
-    }
-    template<typename Adapted>
-    void test_prev(Adapted&, iterator_t<Adapted> const&, std::false_type)
-    {}
-
-    template<typename Rng, bool>
-    struct size_compare_
-    {
-        iterator_t<Rng> iter1_;
-        iterator_t<Rng> iter2_;
-        range_difference_t<Rng> dist_;
-    };
-    template<typename Rng>
-    struct size_compare_<Rng, true>
-    {
-        iterator_t<Rng> iter1_;
-        range_difference_t<Rng> dist_;
-    };
-
-    template<typename Rng>
-    using size_compare =
-        size_compare_<Rng, random_access_range<Rng> || (bidirectional_range<Rng> && common_range<Rng>)>;
-
-    template<typename ToBase>
-    void test_finite(ToBase to_base)
-    {
-        auto v = to_base(views::iota(0,N));
-        using Base = decltype(v);
-        auto rng = v | views::sliding(K);
-        using Adapted = decltype(rng);
-        test_size(rng, meta::bool_<sized_range<Base>>{});
-
-        using IterTagOfBase = 
-            meta::if_c<contiguous_iterator<iterator_t<Base>>,
-                std::random_access_iterator_tag,
-                iterator_tag_of<iterator_t<Base>>>;
-
-        CPP_assert(same_as<
-            IterTagOfBase,
-            iterator_tag_of<iterator_t<Adapted>>>);
-
-        auto it = ranges::begin(rng);
-        test_common(rng, meta::bool_<common_range<Base>>{});
-
-        for (auto i = 0; i <= N - K; ++i)
-        {
-            ::check_equal(*it++, views::iota(i, i + K));
-        }
-        CHECK(it == ranges::end(rng));
-
-        test_prev(rng, it, meta::bool_<bidirectional_range<Base>>{});
-
-        if (!broken_ebo)
-        {
-            CHECK(sizeof(it) == sizeof(size_compare<Base>));
-        }
-    }
-}
-
-void bug_975()
-{
-    std::vector<double> v{2.0, 2.0, 3.0, 1.0};
-    std::vector<int> i{1, 2, 1, 2};
-    std::vector<int> t{1, 1, 2, 2};
-    {
-        using namespace ranges;
-        auto vals = views::zip(v, i, t);
-        using T = std::tuple<double, int, int>;
-        auto g = vals | views::group_by(
-            [](T t1, T t2)
-            {
-                return std::get<2>(t1) == std::get<2>(t2);
-            }
-        );
-
-        auto windows = views::sliding(g, 2);
-        auto it = std::begin(windows);
-        (void)it;
-    }
-}
-
-int main()
-{
-    test_finite(to<std::forward_list<int>>());
-    test_finite(to<std::list<int>>());
-    test_finite(to<std::vector<int>>());
-    test_finite(identity{});
-
-    {
-        // An infinite, cyclic range with cycle length == 1
-        auto rng = views::repeat(5) | views::sliding(K);
-        CPP_assert(random_access_range<decltype(rng)>);
-        auto it = rng.begin();
-        CPP_assert(random_access_iterator<decltype(it)>);
-#if defined(__GNUC__) && !defined(__clang__) && \
-    ((__GNUC__ == 6 && __GNUC_MINOR__ < 3) || __GNUC__ < 6)
-        // Avoid https://gcc.gnu.org/bugzilla/show_bug.cgi?id=78047
-        {
-            auto deref = *it;
-            auto i = deref.begin();
-            for (auto n = 0; n < K; ++n) {
-                RANGES_ENSURE(i != deref.end());
-                CHECK(*i == 5);
-                ++i;
-            }
-            CHECK(i == deref.end());
-        }
-        auto it2 = next(it, 42);
-        CHECK(it != it2);
-        {
-            auto deref = *it;
-            auto i = deref.begin();
-            for (auto n = 0; n < K; ++n) {
-                RANGES_ENSURE(i != deref.end());
-                CHECK(*i == 5);
-                ++i;
-            }
-            CHECK(i == deref.end());
-        }
-#else
-        ::check_equal(*it, views::repeat_n(5, K));
-        auto it2 = next(it, 42);
-        CHECK(it != it2);
-        ::check_equal(*it2, views::repeat_n(5, K));
-#endif
-    }
-
-    {
-        // An infinite, cyclic range with cycle length == K
-        auto rng = views::iota(0, K) | views::cycle | views::sliding(K);
-        CPP_assert(random_access_range<decltype(rng)>);
-        auto it = rng.begin();
-        CPP_assert(random_access_iterator<decltype(it)>);
-        for (auto i = 0; i < 42; ++i)
-        {
-            ::check_equal(*it++, {0,1,2});
-            ::check_equal(*it++, {1,2,0});
-            ::check_equal(*it++, {2,0,1});
-        }
-        auto it2 = next(it, 42 * K);
-        ::check_equal(*it2, {0,1,2});
-    }
-
-    {
-        // An infinite, cyclic range with cycle length > K
-        auto rng = views::iota(0,7) | views::cycle | views::sliding(K);
-        //[0,1,2],[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,0],[6,0,1],...
-        auto it = rng.begin();
-        CPP_assert(random_access_iterator<decltype(it)>);
-        ::check_equal(*it, {0,1,2});
-        ::check_equal(*next(it, 2), {2,3,4});
-        ::check_equal(*next(it,16), {2,3,4});
-        ::check_equal(*next(it,27), {6,0,1});
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/span.cpp b/src/contrib/range-v3-0.11.0/test/view/span.cpp
deleted file mode 100644
index 0d78aee7..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/span.cpp
+++ /dev/null
@@ -1,1099 +0,0 @@
-///////////////////////////////////////////////////////////////////////////////
-//
-// Copyright (c) 2015 Microsoft Corporation. All rights reserved.
-//
-// This code is licensed under the MIT License (MIT).
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-// THE SOFTWARE.
-//
-///////////////////////////////////////////////////////////////////////////////
-
-#include <range/v3/view/span.hpp>
-
-#include <array>
-#include <iostream>
-#include <list>
-#include <map>
-#include <memory>
-#include <regex>
-#include <string>
-#include <vector>
-#include "../simple_test.hpp"
-
-using ranges::span;
-using ranges::dynamic_extent;
-using ranges::make_span;
-using ranges::as_bytes;
-using ranges::as_writeable_bytes;
-using ranges::detail::narrow_cast;
-
-RANGES_DIAGNOSTIC_IGNORE_MISSING_BRACES
-
-namespace {
-    struct BaseClass {};
-    struct DerivedClass : BaseClass {};
-}
-
-void test_case_default_constructor()
-{
-    {
-        span<int> s;
-        CHECK((s.size() == 0 && s.data() == nullptr));
-
-        span<const int> cs;
-        CHECK((cs.size() == 0 && cs.data() == nullptr));
-    }
-
-    {
-        span<int, 0> s;
-        CHECK((s.size() == 0 && s.data() == nullptr));
-
-        span<const int, 0> cs;
-        CHECK((cs.size() == 0 && cs.data() == nullptr));
-    }
-
-    {
-        span<int, 1> s;
-        CHECK((s.size() == 1 && s.data() == nullptr));
-    }
-
-    {
-        span<int> s{};
-        CHECK((s.size() == 0 && s.data() == nullptr));
-
-        span<const int> cs{};
-        CHECK((cs.size() == 0 && cs.data() == nullptr));
-    }
-}
-
-void test_case_size_optimization()
-{
-    {
-        span<int> s;
-        CHECK(sizeof(s) == sizeof(int*) + sizeof(std::ptrdiff_t));
-    }
-
-    {
-        span<int, 0> s;
-        CHECK(sizeof(s) == sizeof(int*));
-    }
-}
-
-void test_case_from_nullptr_constructor()
-{
-    // This implementation doesn't support the silly nullptr_t constructor.
-    CPP_assert(!std::is_constructible<span<int>, std::nullptr_t>::value);
-    CPP_assert(!std::is_constructible<span<const int>, std::nullptr_t>::value);
-
-    CPP_assert(!std::is_constructible<span<int, 0>, std::nullptr_t>::value);
-    CPP_assert(!std::is_constructible<span<const int, 0>, std::nullptr_t>::value);
-
-    CPP_assert(!std::is_constructible<span<int, 1>, std::nullptr_t>::value);
-    CPP_assert(!std::is_constructible<span<const int, 1>, std::nullptr_t>::value);
-}
-
-void test_case_from_nullptr_size_constructor()
-{
-    {
-        span<int> s{nullptr, static_cast<span<int>::index_type>(0)};
-        CHECK((s.size() == 0 && s.data() == nullptr));
-
-        span<const int> cs{nullptr, static_cast<span<int>::index_type>(0)};
-        CHECK((cs.size() == 0 && cs.data() == nullptr));
-    }
-
-    {
-        span<int, 0> s{nullptr, static_cast<span<int>::index_type>(0)};
-        CHECK((s.size() == 0 && s.data() == nullptr));
-
-        span<const int, 0> cs{nullptr, static_cast<span<int>::index_type>(0)};
-        CHECK((cs.size() == 0 && cs.data() == nullptr));
-    }
-
-    {
-        span<int*> s{nullptr, static_cast<span<int>::index_type>(0)};
-        CHECK((s.size() == 0 && s.data() == nullptr));
-
-        span<const int*> cs{nullptr, static_cast<span<int>::index_type>(0)};
-        CHECK((cs.size() == 0 && cs.data() == nullptr));
-    }
-}
-
-void test_case_from_pointer_size_constructor()
-{
-    int arr[4] = {1, 2, 3, 4};
-
-    {
-        span<int> s{&arr[0], 2};
-        CHECK((s.size() == 2 && s.data() == &arr[0]));
-        CHECK((s[0] == 1 && s[1] == 2));
-    }
-
-    {
-        span<int, 2> s{&arr[0], 2};
-        CHECK((s.size() == 2 && s.data() == &arr[0]));
-        CHECK((s[0] == 1 && s[1] == 2));
-    }
-
-    {
-        int* p = nullptr;
-        span<int> s{p, static_cast<span<int>::index_type>(0)};
-        CHECK((s.size() == 0 && s.data() == nullptr));
-    }
-
-    {
-        auto s = make_span(&arr[0], 2);
-        CHECK((s.size() == 2 && s.data() == &arr[0]));
-        CHECK((s[0] == 1 && s[1] == 2));
-    }
-
-    {
-        int* p = nullptr;
-        auto s = make_span(p, static_cast<span<int>::index_type>(0));
-        CHECK((s.size() == 0 && s.data() == nullptr));
-    }
-
-    {
-        int i = 42;
-        span<int> s{&i, 0};
-        CHECK((s.size() == 0 && s.data() == &i));
-
-        span<const int> cs{&i, 0};
-        CHECK((s.size() == 0 && s.data() == &i));
-    }
-}
-
-void test_case_from_pointer_pointer_constructor()
-{
-    int arr[4] = {1, 2, 3, 4};
-
-    {
-        span<int> s{&arr[0], &arr[2]};
-        CHECK((s.size() == 2 && s.data() == &arr[0]));
-        CHECK((s[0] == 1 && s[1] == 2));
-    }
-
-    {
-        span<int, 2> s{&arr[0], &arr[2]};
-        CHECK((s.size() == 2 && s.data() == &arr[0]));
-        CHECK((s[0] == 1 && s[1] == 2));
-    }
-
-    {
-        span<int> s{&arr[0], &arr[0]};
-        CHECK((s.size() == 0 && s.data() == &arr[0]));
-    }
-
-    {
-        span<int, 0> s{&arr[0], &arr[0]};
-        CHECK((s.size() == 0 && s.data() == &arr[0]));
-    }
-
-    {
-        int* p = nullptr;
-        span<int> s{p, p};
-        CHECK((s.size() == 0 && s.data() == nullptr));
-    }
-
-    {
-        int* p = nullptr;
-        span<int, 0> s{p, p};
-        CHECK((s.size() == 0 && s.data() == nullptr));
-    }
-
-    {
-        auto s = make_span(&arr[0], &arr[2]);
-        CHECK((s.size() == 2 && s.data() == &arr[0]));
-        CHECK((s[0] == 1 && s[1] == 2));
-    }
-
-    {
-        auto s = make_span(&arr[0], &arr[0]);
-        CHECK((s.size() == 0 && s.data() == &arr[0]));
-    }
-
-    {
-        int* p = nullptr;
-        auto s = make_span(p, p);
-        CHECK((s.size() == 0 && s.data() == nullptr));
-    }
-}
-
-void test_case_from_array_constructor()
-{
-    int arr[5] = {1, 2, 3, 4, 5};
-
-    {
-        span<int> s{arr};
-        CHECK((s.size() == 5 && s.data() == &arr[0]));
-    }
-
-    {
-        span<int, 5> s{arr};
-        CHECK((s.size() == 5 && s.data() == &arr[0]));
-    }
-
-    int arr2d[2][3] = {1, 2, 3, 4, 5, 6};
-
-    CPP_assert(!std::is_constructible<span<int, 6>, int(&)[5]>::value);
-    CPP_assert(!std::is_constructible<span<int, 0>, int(&)[5]>::value);
-    CPP_assert(!std::is_constructible<span<int>, decltype((arr2d))>::value);
-    CPP_assert(!std::is_constructible<span<int, 0>, decltype((arr2d))>::value);
-    CPP_assert(!std::is_constructible<span<int, 6>, decltype((arr2d))>::value);
-
-    {
-        span<int[3]> s{&(arr2d[0]), 1};
-        CHECK((s.size() == 1 && s.data() == &arr2d[0]));
-    }
-
-    int arr3d[2][3][2] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
-
-    CPP_assert(!std::is_constructible<span<int>, decltype((arr3d))>::value);
-    CPP_assert(!std::is_constructible<span<int, 0>, decltype((arr3d))>::value);
-    CPP_assert(!std::is_constructible<span<int, 11>, decltype((arr3d))>::value);
-    CPP_assert(!std::is_constructible<span<int, 12>, decltype((arr3d))>::value);
-
-    {
-        span<int[3][2]> s{&arr3d[0], 1};
-        CHECK((s.size() == 1 && s.data() == &arr3d[0]));
-    }
-
-    {
-        auto s = make_span(arr);
-        CHECK((s.size() == 5 && s.data() == &arr[0]));
-    }
-
-    {
-        auto s = make_span(&(arr2d[0]), 1);
-        CHECK((s.size() == 1 && s.data() == &arr2d[0]));
-    }
-
-    {
-        auto s = make_span(&arr3d[0], 1);
-        CHECK((s.size() == 1 && s.data() == &arr3d[0]));
-    }
-}
-
-void test_case_from_std_array_constructor()
-{
-    std::array<int, 4> arr = {1, 2, 3, 4};
-
-    {
-        span<int> s{arr};
-        CHECK((s.size() == narrow_cast<std::ptrdiff_t>(arr.size()) && s.data() == arr.data()));
-
-        span<const int> cs{arr};
-        CHECK((cs.size() == narrow_cast<std::ptrdiff_t>(arr.size()) && cs.data() == arr.data()));
-    }
-
-    {
-        span<int, 4> s{arr};
-        CHECK((s.size() == narrow_cast<std::ptrdiff_t>(arr.size()) && s.data() == arr.data()));
-
-        span<const int, 4> cs{arr};
-        CHECK((cs.size() == narrow_cast<std::ptrdiff_t>(arr.size()) && cs.data() == arr.data()));
-    }
-
-    CPP_assert(!std::is_constructible<span<int, 2>, decltype((arr))>::value);
-    CPP_assert(!std::is_constructible<span<const int, 2>, decltype((arr))>::value);
-    CPP_assert(!std::is_constructible<span<int, 0>, decltype((arr))>::value);
-    CPP_assert(!std::is_constructible<span<const int, 0>, decltype((arr))>::value);
-    CPP_assert(!std::is_constructible<span<int, 5>, decltype((arr))>::value);
-
-    {
-        auto get_an_array = []() -> std::array<int, 4> { return {1, 2, 3, 4}; };
-        auto take_a_span = [](span<int>) {};
-        take_a_span(get_an_array());
-    }
-
-    {
-        auto get_an_array = []() -> std::array<int, 4> { return {1, 2, 3, 4}; };
-        auto take_a_span = [](span<const int>) {};
-        take_a_span(get_an_array());
-    }
-
-    {
-        auto s = make_span(arr);
-        CHECK((s.size() == narrow_cast<std::ptrdiff_t>(arr.size()) && s.data() == arr.data()));
-    }
-}
-
-void test_case_from_const_std_array_constructor()
-{
-    const std::array<int, 4> arr = {1, 2, 3, 4};
-
-    {
-        span<const int> s{arr};
-        CHECK((s.size() == narrow_cast<std::ptrdiff_t>(arr.size()) && s.data() == arr.data()));
-    }
-
-    {
-        span<const int, 4> s{arr};
-        CHECK((s.size() == narrow_cast<std::ptrdiff_t>(arr.size()) && s.data() == arr.data()));
-    }
-
-    CPP_assert(!std::is_constructible<span<const int, 2>, decltype((arr))>::value);
-    CPP_assert(!std::is_constructible<span<const int, 0>, decltype((arr))>::value);
-    CPP_assert(!std::is_constructible<span<const int, 5>, decltype((arr))>::value);
-
-    {
-        auto get_an_array = []() -> const std::array<int, 4> { return {1, 2, 3, 4}; };
-        auto take_a_span = [](span<const int>) {};
-        take_a_span(get_an_array());
-    }
-
-    {
-        auto s = make_span(arr);
-        CHECK((s.size() == narrow_cast<std::ptrdiff_t>(arr.size()) && s.data() == arr.data()));
-    }
-}
-
-void test_case_from_std_array_const_constructor()
-{
-    std::array<const int, 4> arr = {1, 2, 3, 4};
-
-    {
-        span<const int> s{arr};
-        CHECK((s.size() == narrow_cast<std::ptrdiff_t>(arr.size()) && s.data() == arr.data()));
-    }
-
-    {
-        span<const int, 4> s{arr};
-        CHECK((s.size() == narrow_cast<std::ptrdiff_t>(arr.size()) && s.data() == arr.data()));
-    }
-
-    CPP_assert(!std::is_constructible<span<const int, 2>, decltype((arr))>::value);
-    CPP_assert(!std::is_constructible<span<const int, 0>, decltype((arr))>::value);
-    CPP_assert(!std::is_constructible<span<const int, 5>, decltype((arr))>::value);
-    CPP_assert(!std::is_constructible<span<int, 4>, decltype((arr))>::value);
-
-    {
-        auto s = make_span(arr);
-        CHECK((s.size() == narrow_cast<std::ptrdiff_t>(arr.size()) && s.data() == arr.data()));
-    }
-}
-
-void test_case_from_container_constructor()
-{
-    std::vector<int> v = {1, 2, 3};
-    const std::vector<int> cv = v;
-
-    {
-        span<int> s{v};
-        CHECK((s.size() == narrow_cast<std::ptrdiff_t>(v.size()) && s.data() == v.data()));
-
-        span<const int> cs{v};
-        CHECK((cs.size() == narrow_cast<std::ptrdiff_t>(v.size()) && cs.data() == v.data()));
-    }
-
-    std::string str = "hello";
-    const std::string cstr = "hello";
-
-    {
-        span<char> s{str};
-        CHECK((s.size() == narrow_cast<std::ptrdiff_t>(str.size()) && s.data() == str.data()));
-    }
-
-    {
-        auto get_temp_string = []() -> std::string { return {}; };
-        auto use_span = [](span<char>) {};
-        use_span(get_temp_string());
-    }
-
-    {
-        span<const char> cs{str};
-        CHECK((cs.size() == narrow_cast<std::ptrdiff_t>(str.size()) && cs.data() == str.data()));
-    }
-
-    {
-        auto get_temp_string = []() -> std::string { return {}; };
-        auto use_span = [](span<const char>) {};
-        use_span(get_temp_string());
-    }
-
-    {
-        CPP_assert(!std::is_constructible<span<char>, decltype((cstr))>::value);
-        span<const char> cs{cstr};
-        CHECK((cs.size() == narrow_cast<std::ptrdiff_t>(cstr.size()) &&
-              cs.data() == cstr.data()));
-    }
-
-    {
-        auto get_temp_vector = []() -> std::vector<int> { return {}; };
-        auto use_span = [](span<int>) {};
-        use_span(get_temp_vector());
-    }
-
-    {
-        auto get_temp_vector = []() -> std::vector<int> { return {}; };
-        auto use_span = [](span<const int>) {};
-        use_span(get_temp_vector());
-    }
-
-    CPP_assert(!ranges::detail::is_convertible<const std::vector<int>, span<const char>>::value);
-
-    {
-        auto get_temp_string = []() -> const std::string { return {}; };
-        auto use_span = [](span<const char> s) { static_cast<void>(s); };
-        use_span(get_temp_string());
-    }
-
-    CPP_assert(!std::is_constructible<span<int>, std::map<int, int>&>::value);
-
-    {
-        auto s = make_span(v);
-        CHECK((s.size() == narrow_cast<std::ptrdiff_t>(v.size()) && s.data() == v.data()));
-
-        auto cs = make_span(cv);
-        CHECK((cs.size() == narrow_cast<std::ptrdiff_t>(cv.size()) && cs.data() == cv.data()));
-    }
-}
-
-void test_case_from_convertible_span_constructor()
-{
-    {
-        span<DerivedClass> avd;
-        span<const DerivedClass> avcd = avd;
-        static_cast<void>(avcd);
-    }
-
-    CPP_assert(!std::is_constructible<span<BaseClass>, span<DerivedClass>>::value);
-    CPP_assert(!std::is_constructible<span<DerivedClass>, span<BaseClass>>::value);
-    CPP_assert(!std::is_constructible<span<unsigned int>, span<int>>::value);
-    CPP_assert(!std::is_constructible<span<const unsigned int>, span<int>>::value);
-    CPP_assert(!std::is_constructible<span<short>, span<int>>::value);
-}
-
-void test_case_copy_move_and_assignment()
-{
-    span<int> s1;
-    CHECK(s1.empty());
-
-    int arr[] = {3, 4, 5};
-
-    span<const int> s2 = arr;
-    CHECK((s2.size() == 3 && s2.data() == &arr[0]));
-
-    s2 = s1;
-    CHECK(s2.empty());
-
-    auto get_temp_span = [&]() -> span<int> { return {&arr[1], 2}; };
-    auto use_span = [&](span<const int> s) { CHECK((s.size() == 2 && s.data() == &arr[1])); };
-    use_span(get_temp_span());
-
-    s1 = get_temp_span();
-    CHECK((s1.size() == 2 && s1.data() == &arr[1]));
-}
-
-void test_case_class_template_argument_deduction()
-{
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-#if defined(__clang__) && __clang_major__ < 6
-// Workaround https://bugs.llvm.org/show_bug.cgi?id=33314
-RANGES_DIAGNOSTIC_PUSH
-RANGES_DIAGNOSTIC_IGNORE_UNDEFINED_FUNC_TEMPLATE
-#endif
-    {
-        int arr[] = {1, 2, 3, 4, 5};
-        {
-            span s{arr};
-            CPP_assert(std::is_same<span<int, 5>, decltype(s)>::value);
-        }
-        {
-            span s{ranges::data(arr), ranges::size(arr)};
-            CPP_assert(std::is_same<span<int>, decltype(s)>::value);
-        }
-        {
-            span s{ranges::begin(arr), ranges::end(arr)};
-            CPP_assert(std::is_same<span<int>, decltype(s)>::value);
-        }
-    }
-    {
-        std::array<int, 5> arr = {1, 2, 3, 4, 5};
-        {
-            span s{arr};
-            CPP_assert(std::is_same<span<int, 5>, decltype(s)>::value);
-        }
-    }
-    {
-        std::vector<int> vec = {1, 2, 3, 4, 5};
-        {
-            span s{vec};
-            CPP_assert(std::is_same<span<int>, decltype(s)>::value);
-        }
-    }
-#if defined(__clang__) && __clang_major__ < 6
-RANGES_DIAGNOSTIC_POP
-#endif // clang bug workaround
-#endif // use deduction guides
-}
-
-void test_case_first()
-{
-    int arr[5] = {1, 2, 3, 4, 5};
-
-    {
-        span<int, 5> av = arr;
-        CHECK(av.first<2>().size() == 2);
-        CHECK(av.first(2).size() == 2);
-    }
-
-    {
-        span<int, 5> av = arr;
-        CHECK(av.first<0>().size() == 0);
-        CHECK(av.first(0).size() == 0);
-    }
-
-    {
-        span<int, 5> av = arr;
-        CHECK(av.first<5>().size() == 5);
-        CHECK(av.first(5).size() == 5);
-    }
-
-    {
-        span<int> av;
-        CHECK(av.first<0>().size() == 0);
-        CHECK(av.first(0).size() == 0);
-    }
-}
-
-void test_case_last()
-{
-    int arr[5] = {1, 2, 3, 4, 5};
-
-    {
-        span<int, 5> av = arr;
-        CHECK(av.last<2>().size() == 2);
-        CHECK(av.last(2).size() == 2);
-    }
-
-    {
-        span<int, 5> av = arr;
-        CHECK(av.last<0>().size() == 0);
-        CHECK(av.last(0).size() == 0);
-    }
-
-    {
-        span<int, 5> av = arr;
-        CHECK(av.last<5>().size() == 5);
-        CHECK(av.last(5).size() == 5);
-    }
-
-    {
-        span<int> av;
-        CHECK(av.last<0>().size() == 0);
-        CHECK(av.last(0).size() == 0);
-    }
-}
-
-void test_case_subspan()
-{
-    int arr[5] = {1, 2, 3, 4, 5};
-
-    {
-        span<int, 5> av = arr;
-        CHECK((av.subspan<2, 2>().size() == 2));
-        CHECK(av.subspan(2, 2).size() == 2);
-        CHECK(av.subspan(2, 3).size() == 3);
-    }
-
-    {
-        span<int, 5> av = arr;
-        CHECK((av.subspan<0, 0>().size() == 0));
-        CHECK(av.subspan(0, 0).size() == 0);
-    }
-
-    {
-        span<int, 5> av = arr;
-        CHECK((av.subspan<0, 5>().size() == 5));
-        CHECK(av.subspan(0, 5).size() == 5);
-    }
-
-    {
-        span<int, 5> av = arr;
-        CHECK((av.subspan<4, 0>().size() == 0));
-        CHECK(av.subspan(4, 0).size() == 0);
-        CHECK(av.subspan(5, 0).size() == 0);
-    }
-
-    {
-        span<int> av;
-        CHECK((av.subspan<0, 0>().size() == 0));
-        CHECK(av.subspan(0, 0).size() == 0);
-    }
-
-    {
-        span<int> av;
-        CHECK(av.subspan(0).size() == 0);
-    }
-
-    {
-        span<int> av = arr;
-        CHECK(av.subspan(0).size() == 5);
-        CHECK(av.subspan(1).size() == 4);
-        CHECK(av.subspan(4).size() == 1);
-        CHECK(av.subspan(5).size() == 0);
-        const auto av2 = av.subspan(1);
-        for (int i = 0; i < 4; ++i) CHECK(av2[i] == i + 2);
-    }
-
-    {
-        span<int, 5> av = arr;
-        CHECK(av.subspan(0).size() == 5);
-        CHECK(av.subspan(1).size() == 4);
-        CHECK(av.subspan(4).size() == 1);
-        CHECK(av.subspan(5).size() == 0);
-        const auto av2 = av.subspan(1);
-        for (int i = 0; i < 4; ++i) CHECK(av2[i] == i + 2);
-    }
-
-    {
-        span<int, 5> av = arr;
-        CHECK(decltype(av.subspan<0, dynamic_extent>())::extent == 5);
-        CHECK((av.subspan<0, dynamic_extent>().size() == 5));
-        CHECK(decltype(av.subspan<1, dynamic_extent>())::extent == 4);
-        CHECK((av.subspan<1, dynamic_extent>().size() == 4));
-        CHECK(decltype(av.subspan<2, dynamic_extent>())::extent == 3);
-        CHECK((av.subspan<2, dynamic_extent>().size() == 3));
-        CHECK(decltype(av.subspan<3, dynamic_extent>())::extent == 2);
-        CHECK((av.subspan<3, dynamic_extent>().size() == 2));
-        CHECK(decltype(av.subspan<4, dynamic_extent>())::extent == 1);
-        CHECK((av.subspan<4, dynamic_extent>().size() == 1));
-        CHECK(decltype(av.subspan<5, dynamic_extent>())::extent == 0);
-        CHECK((av.subspan<5, dynamic_extent>().size() == 0));
-    }
-
-    {
-        span<int> av = arr;
-        CHECK(decltype(av.subspan<0, dynamic_extent>())::extent == dynamic_extent);
-        CHECK((av.subspan<0, dynamic_extent>().size() == 5));
-        CHECK(decltype(av.subspan<1, dynamic_extent>())::extent == dynamic_extent);
-        CHECK((av.subspan<1, dynamic_extent>().size() == 4));
-        CHECK(decltype(av.subspan<2, dynamic_extent>())::extent == dynamic_extent);
-        CHECK((av.subspan<2, dynamic_extent>().size() == 3));
-        CHECK(decltype(av.subspan<3, dynamic_extent>())::extent == dynamic_extent);
-        CHECK((av.subspan<3, dynamic_extent>().size() == 2));
-        CHECK(decltype(av.subspan<4, dynamic_extent>())::extent == dynamic_extent);
-        CHECK((av.subspan<4, dynamic_extent>().size() == 1));
-        CHECK(decltype(av.subspan<5, dynamic_extent>())::extent == dynamic_extent);
-        CHECK((av.subspan<5, dynamic_extent>().size() == 0));
-    }
-}
-
-void test_case_iterator_value_init()
-{
-    span<int>::iterator it1{};
-    span<int>::iterator it2{};
-    CHECK(it1 == it2);
-}
-void test_case_iterator_comparisons()
-{
-    int a[] = {1, 2, 3, 4};
-    {
-        span<int> s = a;
-        auto it = s.begin();
-        CPP_assert(ranges::same_as<decltype(it), span<int>::iterator>);
-        auto it2 = it + 1;
-
-        CHECK(it == it);
-
-        CHECK(it != it2);
-        CHECK(it2 != it);
-        CHECK(it != s.end());
-        CHECK(it2 != s.end());
-        CHECK(s.end() != it);
-
-        CHECK(it < it2);
-        CHECK(it <= it2);
-        CHECK(it2 <= s.end());
-        CHECK(it < s.end());
-
-        CHECK(it2 > it);
-        CHECK(it2 >= it);
-        CHECK(s.end() > it2);
-        CHECK(s.end() >= it2);
-    }
-}
-
-void test_case_begin_end()
-{
-    {
-        int a[] = {1, 2, 3, 4};
-        span<int> s = a;
-
-        span<int>::iterator it = s.begin();
-        span<int>::iterator it2 = ranges::begin(s);
-        CHECK(it == it2);
-
-        it = s.end();
-        it2 = ranges::end(s);
-        CHECK(it == it2);
-    }
-
-    {
-        int a[] = {1, 2, 3, 4};
-        span<int> s = a;
-
-        auto it = s.begin();
-        auto first = it;
-        CHECK(it == first);
-        CHECK(*it == 1);
-
-        auto beyond = s.end();
-        CHECK(it != beyond);
-
-        CHECK((beyond - first) == 4);
-        CHECK((first - first) == 0);
-        CHECK((beyond - beyond) == 0);
-
-        ++it;
-        CHECK((it - first) == 1);
-        CHECK(*it == 2);
-        *it = 22;
-        CHECK(*it == 22);
-        CHECK((beyond - it) == 3);
-
-        it = first;
-        CHECK(it == first);
-        while (it != s.end()) {
-            *it = 5;
-            ++it;
-        }
-
-        CHECK(it == beyond);
-        CHECK((it - beyond) == 0);
-
-        for (const auto& n : s) {
-            CHECK(n == 5);
-        }
-    }
-}
-
-void test_case_rbegin_rend()
-{
-    {
-        int a[] = {1, 2, 3, 4};
-        span<int> s = a;
-
-        auto it = s.rbegin();
-        auto first = it;
-        CHECK(it == first);
-        CHECK(*it == 4);
-
-        auto beyond = s.rend();
-        CHECK(it != beyond);
-
-        CHECK((beyond - first) == 4);
-        CHECK((first - first) == 0);
-        CHECK((beyond - beyond) == 0);
-
-        ++it;
-        CHECK((it - first) == 1);
-        CHECK(*it == 3);
-        *it = 22;
-        CHECK(*it == 22);
-        CHECK((beyond - it) == 3);
-
-        it = first;
-        CHECK(it == first);
-        while (it != s.rend()) {
-            *it = 5;
-            ++it;
-        }
-
-        CHECK(it == beyond);
-        CHECK((it - beyond) == 0);
-
-        for (const auto& n : s) {
-            CHECK(n == 5);
-        }
-    }
-}
-
-void test_case_comparison_operators()
-{
-    {
-        span<int> s1;
-        span<int> s2;
-        CHECK(s1 == s2);
-        CHECK(!(s1 != s2));
-        CHECK(!(s1 < s2));
-        CHECK(s1 <= s2);
-        CHECK(!(s1 > s2));
-        CHECK(s1 >= s2);
-        CHECK(s2 == s1);
-        CHECK(!(s2 != s1));
-        CHECK(!(s2 < s1));
-        CHECK(s2 <= s1);
-        CHECK(!(s2 > s1));
-        CHECK(s2 >= s1);
-    }
-
-    {
-        int arr[] = {2, 1};
-        span<int> s1 = arr;
-        span<int> s2 = arr;
-
-        CHECK(s1 == s2);
-        CHECK(!(s1 != s2));
-        CHECK(!(s1 < s2));
-        CHECK(s1 <= s2);
-        CHECK(!(s1 > s2));
-        CHECK(s1 >= s2);
-        CHECK(s2 == s1);
-        CHECK(!(s2 != s1));
-        CHECK(!(s2 < s1));
-        CHECK(s2 <= s1);
-        CHECK(!(s2 > s1));
-        CHECK(s2 >= s1);
-    }
-
-    {
-        int arr[] = {2, 1}; // bigger
-
-        span<int> s1;
-        span<int> s2 = arr;
-
-        CHECK(s1 != s2);
-        CHECK(s2 != s1);
-        CHECK(!(s1 == s2));
-        CHECK(!(s2 == s1));
-        CHECK(s1 < s2);
-        CHECK(!(s2 < s1));
-        CHECK(s1 <= s2);
-        CHECK(!(s2 <= s1));
-        CHECK(s2 > s1);
-        CHECK(!(s1 > s2));
-        CHECK(s2 >= s1);
-        CHECK(!(s1 >= s2));
-    }
-
-    {
-        int arr1[] = {1, 2};
-        int arr2[] = {1, 2};
-        span<int> s1 = arr1;
-        span<int> s2 = arr2;
-
-        CHECK(s1 == s2);
-        CHECK(!(s1 != s2));
-        CHECK(!(s1 < s2));
-        CHECK(s1 <= s2);
-        CHECK(!(s1 > s2));
-        CHECK(s1 >= s2);
-        CHECK(s2 == s1);
-        CHECK(!(s2 != s1));
-        CHECK(!(s2 < s1));
-        CHECK(s2 <= s1);
-        CHECK(!(s2 > s1));
-        CHECK(s2 >= s1);
-    }
-
-    {
-        int arr[] = {1, 2, 3};
-
-        span<int> s1 = {&arr[0], 2}; // shorter
-        span<int> s2 = arr;          // longer
-
-        CHECK(s1 != s2);
-        CHECK(s2 != s1);
-        CHECK(!(s1 == s2));
-        CHECK(!(s2 == s1));
-        CHECK(s1 < s2);
-        CHECK(!(s2 < s1));
-        CHECK(s1 <= s2);
-        CHECK(!(s2 <= s1));
-        CHECK(s2 > s1);
-        CHECK(!(s1 > s2));
-        CHECK(s2 >= s1);
-        CHECK(!(s1 >= s2));
-    }
-
-    {
-        int arr1[] = {1, 2}; // smaller
-        int arr2[] = {2, 1}; // bigger
-
-        span<int> s1 = arr1;
-        span<int> s2 = arr2;
-
-        CHECK(s1 != s2);
-        CHECK(s2 != s1);
-        CHECK(!(s1 == s2));
-        CHECK(!(s2 == s1));
-        CHECK(s1 < s2);
-        CHECK(!(s2 < s1));
-        CHECK(s1 <= s2);
-        CHECK(!(s2 <= s1));
-        CHECK(s2 > s1);
-        CHECK(!(s1 > s2));
-        CHECK(s2 >= s1);
-        CHECK(!(s1 >= s2));
-    }
-}
-
-void test_case_as_bytes()
-{
-    int a[] = {1, 2, 3, 4};
-
-    {
-        const span<const int> s = a;
-        CHECK(s.size() == 4);
-        const auto bs = as_bytes(s);
-        CHECK(static_cast<const void*>(bs.data()) == static_cast<const void*>(s.data()));
-        CHECK(bs.size() == s.size_bytes());
-    }
-
-    {
-        span<int> s;
-        const auto bs = as_bytes(s);
-        CHECK(bs.size() == s.size());
-        CHECK(bs.size() == 0);
-        CHECK(bs.size_bytes() == 0);
-        CHECK(static_cast<const void*>(bs.data()) == static_cast<const void*>(s.data()));
-        CHECK(bs.data() == nullptr);
-    }
-
-    {
-        span<int> s = a;
-        const auto bs = as_bytes(s);
-        CHECK(static_cast<const void*>(bs.data()) == static_cast<const void*>(s.data()));
-        CHECK(bs.size() == s.size_bytes());
-    }
-}
-
-void test_case_as_writeable_bytes()
-{
-    int a[] = {1, 2, 3, 4};
-
-    {
-        span<int> s;
-        const auto bs = as_writeable_bytes(s);
-        CHECK(bs.size() == s.size());
-        CHECK(bs.size() == 0);
-        CHECK(bs.size_bytes() == 0);
-        CHECK(static_cast<void*>(bs.data()) == static_cast<void*>(s.data()));
-        CHECK(bs.data() == nullptr);
-    }
-
-    {
-        span<int> s = a;
-        const auto bs = as_writeable_bytes(s);
-        CHECK(static_cast<void*>(bs.data()) == static_cast<void*>(s.data()));
-        CHECK(bs.size() == s.size_bytes());
-    }
-}
-
-void test_case_fixed_size_conversions()
-{
-    int arr[] = {1, 2, 3, 4};
-
-    // converting to an span from an equal size array is ok
-    span<int, 4> s4 = arr;
-    CHECK(s4.size() == 4);
-
-    // converting to dynamic_range is always ok
-    {
-        span<int> s = s4;
-        CHECK(s.size() == s4.size());
-        static_cast<void>(s);
-    }
-
-    // initialization or assignment to static span that REDUCES size is NOT ok
-    CPP_assert(!ranges::detail::is_convertible<decltype((arr)), span<int, 2>>::value);
-    CPP_assert(!ranges::detail::is_convertible<span<int, 4>, span<int, 2>>::value);
-
-
-    // you can convert statically
-    {
-        const span<int, 2> s2 = {arr, 2};
-        static_cast<void>(s2);
-    }
-    {
-        const span<int, 1> s1 = s4.first<1>();
-        static_cast<void>(s1);
-    }
-
-    // ...or dynamically
-    {
-        // NB: implicit conversion to span<int,1> from span<int>
-        span<int, 1> s1 = s4.first(1);
-        static_cast<void>(s1);
-    }
-
-    // initialization or assignment to static span that requires size INCREASE is not ok.
-    int arr2[2] = {1, 2};
-    (void)arr2;
-
-    CPP_assert(!std::is_constructible<span<int, 4>, decltype((arr2))>::value);
-    CPP_assert(!std::is_constructible<span<int, 4>, span<int, 2>>::value);
-}
-
-void test_case_interop_with_std_regex()
-{
-    char lat[] = {'1', '2', '3', '4', '5', '6', 'E', 'F', 'G'};
-    span<char> s = lat;
-    const auto f_it = s.begin() + 7;
-
-    std::match_results<span<char>::iterator> match;
-
-    std::regex_match(s.begin(), s.end(), match, std::regex(".*"));
-    CHECK(match.ready());
-    CHECK(!match.empty());
-    CHECK(match[0].matched);
-    CHECK(match[0].first == s.begin());
-    CHECK(match[0].second == s.end());
-
-    std::regex_search(s.begin(), s.end(), match, std::regex("F"));
-    CHECK(match.ready());
-    CHECK(!match.empty());
-    CHECK(match[0].matched);
-    CHECK(match[0].first == f_it);
-    CHECK(match[0].second == (f_it + 1));
-}
-
-void test_case_default_constructible()
-{
-    CHECK((std::is_default_constructible<span<int>>::value));
-    CHECK((std::is_default_constructible<span<int, 0>>::value));
-    CHECK((std::is_default_constructible<span<int, 42>>::value));
-}
-
-int main() {
-    test_case_default_constructor();
-    test_case_size_optimization();
-    test_case_from_nullptr_constructor();
-    test_case_from_nullptr_size_constructor();
-    test_case_from_pointer_size_constructor();
-    test_case_from_pointer_pointer_constructor();
-    test_case_from_array_constructor();
-    test_case_from_std_array_constructor();
-    test_case_from_const_std_array_constructor();
-    test_case_from_std_array_const_constructor();
-    test_case_from_container_constructor();
-    test_case_from_convertible_span_constructor();
-    test_case_copy_move_and_assignment();
-    test_case_class_template_argument_deduction();
-    test_case_first();
-    test_case_last();
-    test_case_subspan();
-    test_case_iterator_value_init();
-    test_case_iterator_comparisons();
-    test_case_begin_end();
-    test_case_rbegin_rend();
-    test_case_comparison_operators();
-    test_case_as_bytes();
-    test_case_as_writeable_bytes();
-    test_case_fixed_size_conversions();
-    test_case_interop_with_std_regex();
-    test_case_default_constructible();
-
-    CPP_assert(ranges::view_<span<int>>);
-    CPP_assert(ranges::contiguous_range<span<int>>);
-    CPP_assert(ranges::view_<span<int, 42>>);
-    CPP_assert(ranges::contiguous_range<span<int, 42>>);
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/split.cpp b/src/contrib/range-v3-0.11.0/test/view/split.cpp
deleted file mode 100644
index f7bd4e30..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/split.cpp
+++ /dev/null
@@ -1,425 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <string>
-#include <cctype>
-#include <sstream>
-#include <range/v3/core.hpp>
-#include <range/v3/view/counted.hpp>
-#include <range/v3/view/c_str.hpp>
-#include <range/v3/view/empty.hpp>
-#include <range/v3/view/remove_if.hpp>
-#include <range/v3/view/split.hpp>
-#include <range/v3/view/split_when.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-RANGES_DIAGNOSTIC_IGNORE_SIGN_CONVERSION
-
-#if defined(__clang__) && __clang_major__ < 6
-// Workaround https://bugs.llvm.org/show_bug.cgi?id=33314
-RANGES_DIAGNOSTIC_IGNORE_UNDEFINED_FUNC_TEMPLATE
-#endif
-
-namespace
-{
-    struct starts_with_g
-    {
-        template<typename I, typename S>
-        std::pair<bool, I> operator()(I b, S) const
-        {
-            return {*b == 'g', b};
-        }
-    };
-
-#ifdef RANGES_WORKAROUND_MSVC_790554
-    template<std::size_t N>
-    auto c_str(char const (&sz)[N])
-    {
-        return ranges::subrange<char const*>{&sz[0], &sz[N-1]};
-    }
-#else // ^^^ workaround / no workaround vvv
-    template<std::size_t N>
-    ranges::subrange<char const*> c_str(char const (&sz)[N])
-    {
-        return {&sz[0], &sz[N-1]};
-    }
-#endif // RANGES_WORKAROUND_MSVC_790554
-}
-
-void moar_tests()
-{
-    using namespace ranges;
-    std::string greeting = "now is the time";
-    std::string pattern = " ";
-
-    {
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-        split_view sv{greeting, pattern};
-#else
-        split_view<views::all_t<std::string&>, views::all_t<std::string&>> sv{greeting, pattern};
-#endif
-        auto i = sv.begin();
-        check_equal(*i, {'n','o','w'});
-        ++i;
-        CHECK(i != sv.end());
-        check_equal(*i, {'i','s'});
-        ++i;
-        CHECK(i != sv.end());
-        check_equal(*i, {'t','h','e'});
-        ++i;
-        CHECK(i != sv.end());
-        check_equal(*i, {'t','i','m','e'});
-        ++i;
-        CHECK(i == sv.end());
-
-        using R = decltype(sv);
-        CPP_assert(forward_range<R>);
-        CPP_assert(forward_range<R const>);
-    }
-
-    {
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-        split_view sv{greeting, ' '};
-#else
-        split_view<views::all_t<std::string&>, single_view<char>> sv{greeting, ' '};
-#endif
-        auto i = sv.begin();
-        CHECK(i != sv.end());
-        check_equal(*i, {'n','o','w'});
-        ++i;
-        CHECK(i != sv.end());
-        check_equal(*i, {'i','s'});
-        ++i;
-        CHECK(i != sv.end());
-        check_equal(*i, {'t','h','e'});
-        ++i;
-        CHECK(i != sv.end());
-        check_equal(*i, {'t','i','m','e'});
-        ++i;
-        CHECK(i == sv.end());
-
-        using R = decltype(sv);
-        CPP_assert(forward_range<R>);
-        CPP_assert(forward_range<R const>);
-    }
-
-    {
-        std::stringstream sin{greeting};
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-        auto rng = subrange{
-            std::istreambuf_iterator<char>{sin},
-            std::istreambuf_iterator<char>{}};
-#else
-        auto rng = make_subrange(
-            std::istreambuf_iterator<char>{sin},
-            std::istreambuf_iterator<char>{});
-#endif
-
-        auto sv = views::split(rng, ' ');
-        auto i = sv.begin();
-        CHECK(i != sv.end());
-        check_equal(*i, {'n','o','w'});
-        ++i;
-        CHECK(i != sv.end());
-        check_equal(*i, {'i','s'});
-        ++i;
-        CHECK(i != sv.end());
-        check_equal(*i, {'t','h','e'});
-        ++i;
-        CHECK(i != sv.end());
-        check_equal(*i, {'t','i','m','e'});
-        ++i;
-        CHECK(i == sv.end());
-
-        using R = decltype(sv);
-        CPP_assert(input_range<R>);
-        CPP_assert(!forward_range<R>);
-        CPP_assert(!input_range<R const>);
-    }
-
-    {
-        std::string list{"eggs,milk,,butter"};
-        auto sv = views::split(list, ',');
-        auto i = sv.begin();
-        CHECK(i != sv.end());
-        check_equal(*i, {'e','g','g','s'});
-        ++i;
-        CHECK(i != sv.end());
-        check_equal(*i, {'m','i','l','k'});
-        ++i;
-        CHECK(i != sv.end());
-        check_equal(*i, views::empty<char>);
-        ++i;
-        CHECK(i != sv.end());
-        check_equal(*i, {'b','u','t','t','e','r'});
-        ++i;
-        CHECK(i == sv.end());
-    }
-
-    {
-        std::string list{"eggs,milk,,butter"};
-        std::stringstream sin{list};
-        auto rng = make_subrange(
-            std::istreambuf_iterator<char>{sin},
-            std::istreambuf_iterator<char>{});
-        auto sv = rng | views::split(',');
-        auto i = sv.begin();
-        CHECK(i != sv.end());
-        check_equal(*i, {'e','g','g','s'});
-        ++i;
-        CHECK(i != sv.end());
-        check_equal(*i, {'m','i','l','k'});
-        ++i;
-        CHECK(i != sv.end());
-        check_equal(*i, views::empty<char>);
-        ++i;
-        CHECK(i != sv.end());
-        check_equal(*i, {'b','u','t','t','e','r'});
-        ++i;
-        CHECK(i == sv.end());
-    }
-
-    {
-        std::string hello("hello");
-        auto sv = views::split(hello, views::empty<char>);
-        auto i = sv.begin();
-        CHECK(i != sv.end());
-        check_equal(*i, single_view<char>{'h'});
-        ++i;
-        CHECK(i != sv.end());
-        check_equal(*i, single_view<char>{'e'});
-        ++i;
-        CHECK(i != sv.end());
-        check_equal(*i, single_view<char>{'l'});
-        ++i;
-        CHECK(i != sv.end());
-        check_equal(*i, single_view<char>{'l'});
-        ++i;
-        CHECK(i != sv.end());
-        check_equal(*i, single_view<char>{'o'});
-        ++i;
-        CHECK(i == sv.end());
-    }
-
-    {
-        std::string hello{"hello"};
-        std::stringstream sin{hello};
-        auto rng = make_subrange(
-            std::istreambuf_iterator<char>{sin},
-            std::istreambuf_iterator<char>{});
-        auto sv = views::split(rng, views::empty<char>);
-        auto i = sv.begin();
-        CHECK(i != sv.end());
-        check_equal(*i, single_view<char>{'h'});
-        ++i;
-        CHECK(i != sv.end());
-        check_equal(*i, single_view<char>{'e'});
-        ++i;
-        CHECK(i != sv.end());
-        check_equal(*i, single_view<char>{'l'});
-        ++i;
-        CHECK(i != sv.end());
-        check_equal(*i, single_view<char>{'l'});
-        ++i;
-        CHECK(i != sv.end());
-        check_equal(*i, single_view<char>{'o'});
-        ++i;
-        CHECK(i == sv.end());
-    }
-
-    {
-        std::string hello{"hello"};
-        auto sv = views::split(hello, views::empty<char>);
-        auto i = sv.begin();
-        CHECK(i != sv.end());
-        ++i;
-        CHECK(i != sv.end());
-        ++i;
-        CHECK(i != sv.end());
-        check_equal(*i, single_view<char>{'l'});
-        ++i;
-        CHECK(i != sv.end());
-        check_equal(*i, single_view<char>{'l'});
-        ++i;
-        CHECK(i != sv.end());
-        ++i;
-        CHECK(i == sv.end());
-    }
-
-    {
-        std::string hello{"hello"};
-        std::stringstream sin{hello};
-        auto rng = make_subrange(
-            std::istreambuf_iterator<char>{sin},
-            std::istreambuf_iterator<char>{});
-        auto sv = views::split(rng, views::empty<char>);
-        auto i = sv.begin();
-        CHECK(i != sv.end());
-        ++i;
-        CHECK(i != sv.end());
-        ++i;
-        CHECK(i != sv.end());
-        check_equal(*i, single_view<char>{'l'});
-        ++i;
-        CHECK(i != sv.end());
-        check_equal(*i, single_view<char>{'l'});
-        ++i;
-        CHECK(i != sv.end());
-        ++i;
-        CHECK(i == sv.end());
-    }
-}
-
-int main()
-{
-    using namespace ranges;
-
-    {
-        std::string str("Now is the time for all good men to come to the aid of their country.");
-        auto rng = views::split(str, ' ');
-        CHECK(distance(rng) == 16);
-        if(distance(rng) == 16)
-        {
-            check_equal(*(next(begin(rng),0)), c_str("Now"));
-            check_equal(*(next(begin(rng),1)), c_str("is"));
-            check_equal(*(next(begin(rng),2)), c_str("the"));
-            check_equal(*(next(begin(rng),3)), c_str("time"));
-            check_equal(*(next(begin(rng),4)), c_str("for"));
-            check_equal(*(next(begin(rng),5)), c_str("all"));
-            check_equal(*(next(begin(rng),6)), c_str("good"));
-            check_equal(*(next(begin(rng),7)), c_str("men"));
-            check_equal(*(next(begin(rng),8)), c_str("to"));
-            check_equal(*(next(begin(rng),9)), c_str("come"));
-            check_equal(*(next(begin(rng),10)), c_str("to"));
-            check_equal(*(next(begin(rng),11)), c_str("the"));
-            check_equal(*(next(begin(rng),12)), c_str("aid"));
-            check_equal(*(next(begin(rng),13)), c_str("of"));
-            check_equal(*(next(begin(rng),14)), c_str("their"));
-            check_equal(*(next(begin(rng),15)), c_str("country."));
-        }
-    }
-
-    {
-        std::string str("Now is the time for all good men to come to the aid of their country.");
-        auto rng = views::split(str, c_str(" "));
-        CHECK(distance(rng) == 16);
-        if(distance(rng) == 16)
-        {
-            check_equal(*(next(begin(rng),0)), c_str("Now"));
-            check_equal(*(next(begin(rng),1)), c_str("is"));
-            check_equal(*(next(begin(rng),2)), c_str("the"));
-            check_equal(*(next(begin(rng),3)), c_str("time"));
-            check_equal(*(next(begin(rng),4)), c_str("for"));
-            check_equal(*(next(begin(rng),5)), c_str("all"));
-            check_equal(*(next(begin(rng),6)), c_str("good"));
-            check_equal(*(next(begin(rng),7)), c_str("men"));
-            check_equal(*(next(begin(rng),8)), c_str("to"));
-            check_equal(*(next(begin(rng),9)), c_str("come"));
-            check_equal(*(next(begin(rng),10)), c_str("to"));
-            check_equal(*(next(begin(rng),11)), c_str("the"));
-            check_equal(*(next(begin(rng),12)), c_str("aid"));
-            check_equal(*(next(begin(rng),13)), c_str("of"));
-            check_equal(*(next(begin(rng),14)), c_str("their"));
-            check_equal(*(next(begin(rng),15)), c_str("country."));
-        }
-    }
-
-    {
-        std::string str("Now is the time for all ggood men to come to the aid of their country.");
-        auto rng = views::split_when(str, starts_with_g{});
-        CHECK(distance(rng) == 3);
-        if(distance(rng) == 3)
-        {
-            check_equal(*begin(rng), c_str("Now is the time for all "));
-            check_equal(*next(begin(rng)), c_str("g"));
-            check_equal(*(next(begin(rng),2)), c_str("good men to come to the aid of their country."));
-        }
-    }
-
-    {
-        std::string str("Now is the time for all ggood men to come to the aid of their country.");
-        ForwardIterator<std::string::iterator> i {str.begin()};
-        auto rng = views::counted(i, str.size()) | views::split_when(starts_with_g{});
-        CHECK(distance(rng) == 3);
-        if(distance(rng) == 3)
-        {
-            check_equal(*begin(rng), c_str("Now is the time for all "));
-            check_equal(*next(begin(rng)), c_str("g"));
-            check_equal(*(next(begin(rng),2)), c_str("good men to come to the aid of their country."));
-        }
-    }
-
-    {
-        std::string str("meow");
-        auto rng = views::split(str, views::empty<char>);
-        CHECK(distance(rng) == 4);
-        if(distance(rng) == 4)
-        {
-            check_equal(*(next(begin(rng),0)), c_str("m"));
-            check_equal(*(next(begin(rng),1)), c_str("e"));
-            check_equal(*(next(begin(rng),2)), c_str("o"));
-            check_equal(*(next(begin(rng),3)), c_str("w"));
-        }
-    }
-
-    {
-        int a[] = {0, 2, 3, 1, 4, 5, 1, 6, 7};
-        auto rng = a | views::remove_if([](int i) { return i % 2 == 0; });
-        auto srng = views::split(rng, 1);
-        CHECK(distance(srng) == 3);
-        check_equal(*begin(srng), {3});
-        check_equal(*next(begin(srng), 1), {5});
-        check_equal(*next(begin(srng), 2), {7});
-    }
-
-    {
-        std::string str("now  is \t the\ttime");
-        auto rng = views::split_when(str, (int(*)(int))&std::isspace);
-        CHECK(distance(rng) == 4);
-        if(distance(rng) == 4)
-        {
-            check_equal(*(next(begin(rng),0)), c_str("now"));
-            check_equal(*(next(begin(rng),1)), c_str("is"));
-            check_equal(*(next(begin(rng),2)), c_str("the"));
-            check_equal(*(next(begin(rng),3)), c_str("time"));
-        }
-    }
-
-    {   // Regression test for https://stackoverflow.com/questions/49015671
-        auto const str = "quick brown fox";
-        auto rng = views::c_str(str) | views::split(' ');
-        CPP_assert(forward_range<decltype(rng)>);
-    }
-
-    {   // Regression test for #986
-        std::string s;
-        s | ranges::views::split_when([](char) { return true; });
-    }
-
-    moar_tests();
-
-    {   // Regression test for #1041
-        auto is_escape = [](auto first, auto last) {
-            return std::make_pair(next(first) != last, first);
-        };
-
-        auto escapes = views::split_when(views::c_str(R"(\t)"), is_escape);
-        CPP_assert(forward_range<decltype(escapes)>);
-
-        auto const first = begin(escapes);
-        CHECK(first != end(escapes));
-        CHECK(first != next(first));
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/stride.cpp b/src/contrib/range-v3-0.11.0/test/view/stride.cpp
deleted file mode 100644
index ada52839..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/stride.cpp
+++ /dev/null
@@ -1,193 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <list>
-#include <vector>
-#include <sstream>
-#include <range/v3/core.hpp>
-#include <range/v3/view/istream.hpp>
-#include <range/v3/view/move.hpp>
-#include <range/v3/view/partial_sum.hpp>
-#include <range/v3/view/reverse.hpp>
-#include <range/v3/view/stride.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/algorithm/copy.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/insert_iterators.hpp>
-#include <range/v3/iterator/stream_iterators.hpp>
-#include <range/v3/numeric.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-// https://github.com/ericniebler/range-v3/issues/1291
-void bug_1291()
-{
-    std::vector<int> vec;
-
-    auto tx = vec | ranges::views::stride( 2 ) | ranges::views::partial_sum;
-    ranges::accumulate( tx, 0 );
-}
-
-int main()
-{
-    using namespace ranges;
-
-    auto const v = []
-    {
-        std::vector<int> vec(50);
-        iota(vec, 0);
-        return vec;
-    }();
-    {
-        auto rng = v | views::stride(3);
-        using R = decltype(rng);
-        CPP_assert(random_access_range<R> && view_<R>);
-        CPP_assert(!contiguous_range<R>);
-        CPP_assert(common_range<R>);
-        CPP_assert(sized_range<R>);
-        CPP_assert(range<R const>);
-        ::check_equal(rng | views::reverse,
-                    {48, 45, 42, 39, 36, 33, 30, 27, 24, 21, 18, 15, 12, 9, 6, 3, 0});
-    }
-
-    {
-        std::stringstream str;
-        copy(v, ostream_iterator<int>{str, " "});
-        auto rng = istream<int>(str) | views::stride(3);
-        using R = decltype(rng);
-        CPP_assert(input_range<R> && view_<R>);
-        CPP_assert(!forward_range<R>);
-        CPP_assert(!common_range<R>);
-        CPP_assert(!sized_range<R>);
-        CPP_assert(!range<R const>);
-        check_equal(rng, {0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48});
-    }
-
-    {
-        std::list<int> li;
-        copy(v, back_inserter(li));
-        auto rng = li | views::stride(3);
-        using R = decltype(rng);
-        CPP_assert(bidirectional_range<R> && view_<R>);
-        CPP_assert(!random_access_range<R>);
-        CPP_assert(common_range<R>);
-        CPP_assert(sized_range<R>);
-        CPP_assert(range<R const>);
-        ::check_equal(rng,
-                    {0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48});
-        ::check_equal(rng | views::reverse,
-                    {48, 45, 42, 39, 36, 33, 30, 27, 24, 21, 18, 15, 12, 9, 6, 3, 0});
-
-        for(int i : rng | views::reverse)
-            std::cout << i << ' ';
-        std::cout << '\n';
-    }
-
-    {
-        auto x2 = v | views::stride(3);
-        CHECK(ranges::distance(x2) == 17);
-
-        auto it0 = x2.begin();
-        auto it1 = std::next(it0, 10);
-        CHECK((it1 - it0) == 10);
-        CHECK((it0 - it1) == -10);
-        CHECK((it0 - it0) == 0);
-        CHECK((it1 - it1) == 0);
-    }
-
-    {
-        const auto n = 4;
-        auto rng = v | views::move | views::stride(2);
-        CHECK((next(begin(rng), n) - begin(rng)) == n);
-    }
-
-    {
-        // Regression test #368
-        int n = 42;
-        (void)ranges::views::stride(n);
-    }
-
-    {
-        int const some_ints[] = {0,1,2,3,4,5,6,7};
-        auto rng = debug_input_view<int const>{some_ints} | views::stride(2);
-        using R = decltype(rng);
-        CPP_assert(input_range<R> && view_<R>);
-        CPP_assert(!forward_range<R>);
-        CPP_assert(!common_range<R>);
-        CPP_assert(sized_range<R>);
-        CPP_assert(!range<R const>);
-        ::check_equal(rng, {0,2,4,6});
-    }
-
-    {
-        std::list<int> li;
-        copy(v, back_inserter(li));
-        subrange<std::list<int>::const_iterator> tmp{li.begin(), li.end()};
-        auto rng = tmp | views::stride(3);
-        using R = decltype(rng);
-        CPP_assert(bidirectional_range<R> && view_<R>);
-        CPP_assert(!random_access_range<R>);
-        CPP_assert(!common_range<R>);
-        CPP_assert(!sized_range<R>);
-        CPP_assert(!range<R const>);
-        ::check_equal(rng,
-                    {0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48});
-        ::check_equal(rng | views::reverse,
-                    {48, 45, 42, 39, 36, 33, 30, 27, 24, 21, 18, 15, 12, 9, 6, 3, 0});
-    }
-
-    {
-        std::list<int> li;
-        copy(v, back_inserter(li));
-        using CLI = std::list<int>::const_iterator;
-        subrange<CLI, CLI, subrange_kind::sized> tmp{li};
-        auto rng = tmp | views::stride(3);
-        using R = decltype(rng);
-        CPP_assert(bidirectional_range<R> && view_<R>);
-        CPP_assert(!random_access_range<R>);
-        CPP_assert(common_range<R>);
-        CPP_assert(sized_range<R>);
-        CPP_assert(range<R const>);
-        CHECK((*--rng.end()) == 48);
-        ::check_equal(rng,
-                    {0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48});
-        ::check_equal(rng | views::reverse,
-                    {48, 45, 42, 39, 36, 33, 30, 27, 24, 21, 18, 15, 12, 9, 6, 3, 0});
-    }
-
-    // https://github.com/ericniebler/range-v3/issues/901
-    {
-        auto r = views::iota( 0, 12 );
-
-        // Evenly divisible stride:
-        auto strided1 = r | views::stride(3);
-        ::check_equal(strided1, {0, 3, 6, 9});
-        CHECK(strided1.size() == 4u);
-        CHECK(strided1.front() == 0);
-        CHECK(strided1[0] == 0);
-        CHECK(strided1.back() == 9);
-        CHECK(strided1[3] == 9);
-        CHECK(strided1[(int)strided1.size() - 1] == 9);
-
-        // Not evenly divisible stride:
-        auto strided2 = r | views::stride(5);
-        ::check_equal(strided2, {0, 5, 10});
-        CHECK(strided2.size() == 3u);
-        CHECK(strided2.front() == 0);
-        CHECK(strided2[0] == 0);
-        CHECK(strided2.back() == 10);
-        CHECK(strided2[2] == 10);
-        CHECK(strided2[(int)strided2.size() - 1] == 10);
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/subrange.cpp b/src/contrib/range-v3-0.11.0/test/view/subrange.cpp
deleted file mode 100644
index 26c157ae..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/subrange.cpp
+++ /dev/null
@@ -1,207 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2017-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <list>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/all.hpp>
-#include <range/v3/view/ref.hpp>
-#include <range/v3/view/subrange.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-CPP_template(class Rng)(
-    requires ranges::range<Rng>)
-ranges::borrowed_subrange_t<Rng> algorithm(Rng &&rng);
-
-struct Base {};
-struct Derived : Base {};
-
-int main()
-{
-    using namespace ranges;
-
-    std::vector<int> vi{1,2,3,4};
-
-    ////////////////////////////////////////////////////////////////////////////
-    // borrowed_subrange_t tests:
-
-    // lvalues are ReferenceableRanges and do not dangle:
-    CPP_assert(same_as<subrange<int*>,
-        decltype(::algorithm(std::declval<int(&)[42]>()))>);
-    CPP_assert(same_as<subrange<std::vector<int>::iterator>,
-        decltype(::algorithm(vi))>);
-
-    // subrange and ref_view are ReferenceableRanges and do not dangle:
-    CPP_assert(same_as<subrange<int*>,
-        decltype(::algorithm(std::declval<subrange<int*>>()))>);
-    CPP_assert(same_as<subrange<int*>,
-        decltype(::algorithm(std::declval<ref_view<int[42]>>()))>);
-
-    // non-ReferenceableRange rvalue ranges dangle:
-    CPP_assert(same_as<dangling,
-        decltype(::algorithm(std::declval<std::vector<int>>()))>);
-    CPP_assert(same_as<dangling,
-        decltype(::algorithm(std::move(vi)))>);
-
-    // Test that slicing conversions are not allowed.
-    CPP_assert(constructible_from<subrange<Base*, Base*>, Base*, Base*>);
-    CPP_assert(!constructible_from<subrange<Base*, Base*>, Derived*, Derived*>);
-    CPP_assert(constructible_from<subrange<const Base*, const Base*>, Base*, Base*>);
-    CPP_assert(!constructible_from<subrange<const Base*, const Base*>, Derived*, Derived*>);
-    CPP_assert(!constructible_from<subrange<Base*, Base*>, subrange<Derived*, Derived*>>);
-
-    CPP_assert(constructible_from<subrange<Base*, unreachable_sentinel_t>, Base*, unreachable_sentinel_t>);
-    CPP_assert(!constructible_from<subrange<Base*, unreachable_sentinel_t>, Derived*, unreachable_sentinel_t>);
-    CPP_assert(constructible_from<subrange<const Base*, unreachable_sentinel_t>, Base*, unreachable_sentinel_t>);
-    CPP_assert(!constructible_from<subrange<const Base*, unreachable_sentinel_t>, Derived*, unreachable_sentinel_t>);
-    CPP_assert(!constructible_from<subrange<Base*, unreachable_sentinel_t>, subrange<Derived*, unreachable_sentinel_t>>);
-
-    CPP_assert(constructible_from<subrange<Base*, Base*, subrange_kind::sized>, Base*, Base*, std::size_t>);
-    CPP_assert(!constructible_from<subrange<Base*, Base*, subrange_kind::sized>, Derived*, Base*, std::size_t>);
-    CPP_assert(constructible_from<subrange<const Base*, const Base*, subrange_kind::sized>, Base*, const Base*, std::size_t>);
-    CPP_assert(!constructible_from<subrange<const Base*, const Base*, subrange_kind::sized>, Derived*, const Base*, std::size_t>);
-    CPP_assert(!constructible_from<subrange<Base*, Base*, subrange_kind::sized>, subrange<Derived*, Base*>, std::size_t>);
-
-    CPP_assert(convertible_to<subrange<Base*, Base*>, std::pair<const Base*, const Base*>>);
-    CPP_assert(!convertible_to<subrange<Derived*, Derived*>, std::pair<Base*, Base*>>);
-
-    subrange<std::vector<int>::iterator> r0 {vi.begin(), vi.end()};
-    static_assert(std::tuple_size<decltype(r0)>::value == 2, "");
-    CPP_assert(same_as<std::vector<int>::iterator,
-        std::tuple_element<0, decltype(r0)>::type>);
-    CPP_assert(same_as<std::vector<int>::iterator,
-        std::tuple_element<1, decltype(r0)>::type>);
-    CPP_assert(sized_range<decltype(r0)>);
-    CHECK(r0.size() == 4u);
-    CHECK(r0.begin() == vi.begin());
-    CHECK(get<0>(r0) == vi.begin());
-    CHECK(r0.end() == vi.end());
-    CHECK(get<1>(r0) == vi.end());
-    r0 = r0.next();
-    CHECK(r0.size() == 3u);
-
-    {
-        subrange<std::vector<int>::iterator> rng {vi.begin(), vi.end(), ranges::size(vi)};
-        CHECK(rng.size() == 4u);
-        CHECK(rng.begin() == vi.begin());
-        CHECK(rng.end() == vi.end());
-    }
-
-    std::pair<std::vector<int>::iterator, std::vector<int>::iterator> p0 = r0;
-    CHECK(p0.first == vi.begin()+1);
-    CHECK(p0.second == vi.end());
-
-    subrange<std::vector<int>::iterator, unreachable_sentinel_t> r1 { r0.begin(), {} };
-    static_assert(std::tuple_size<decltype(r1)>::value == 2, "");
-    CPP_assert(same_as<std::vector<int>::iterator,
-        std::tuple_element<0, decltype(r1)>::type>);
-    CPP_assert(same_as<unreachable_sentinel_t,
-        std::tuple_element<1, decltype(r1)>::type>);
-    CPP_assert(view_<decltype(r1)>);
-    CPP_assert(!sized_range<decltype(r1)>);
-    CHECK(r1.begin() == vi.begin()+1);
-    r1.end() = unreachable;
-
-    r0 = r0.next();
-    ++r0.begin();
-    CHECK(r0.begin() == vi.begin()+2);
-    CHECK(r0.size() == 2u);
-    r0 = {r0.begin(), --r0.end()}; // --r0.end();
-    CHECK(r0.end() == vi.end()-1);
-    CHECK(r0.size() == 1u);
-    CHECK(r0.front() == 3);
-    CHECK(r0.back() == 3);
-
-    std::pair<std::vector<int>::iterator, unreachable_sentinel_t> p1 = r1;
-    CHECK(p1.first == vi.begin()+1);
-
-    std::list<int> li{1,2,3,4};
-    using LI = std::list<int>::iterator;
-    subrange<LI, LI, subrange_kind::sized> l0 {li.begin(), li.end(), li.size()};
-    CPP_assert(view_<decltype(l0)> && sized_range<decltype(l0)>);
-    CHECK(l0.begin() == li.begin());
-    CHECK(l0.end() == li.end());
-    CHECK(l0.size() == li.size());
-    l0 = l0.next();
-    CHECK(l0.begin() == next(li.begin()));
-    CHECK(l0.end() == li.end());
-    CHECK(l0.size() == li.size() - 1u);
-
-    l0 = views::all(li);
-
-    subrange<std::list<int>::iterator> l1 = l0;
-    CPP_assert(!sized_range<decltype(l1)>);
-    CHECK(l1.begin() == li.begin());
-    CHECK(l1.end() == li.end());
-
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-#if defined(__clang__) && __clang_major__ < 6
-// Workaround https://bugs.llvm.org/show_bug.cgi?id=33314
-RANGES_DIAGNOSTIC_PUSH
-RANGES_DIAGNOSTIC_IGNORE_UNDEFINED_FUNC_TEMPLATE
-#endif
-    {
-        subrange s0{vi.begin(), vi.end()};
-        subrange s1{li.begin(), li.end()};
-        CPP_assert(same_as<decltype(r0), decltype(s0)>);
-        CPP_assert(same_as<decltype(l1), decltype(s1)>);
-    }
-    {
-        subrange s0{vi.begin(), vi.end(), ranges::size(vi)};
-        subrange s1{li.begin(), li.end(), ranges::size(li)};
-        CPP_assert(same_as<decltype(r0), decltype(s0)>);
-        CPP_assert(same_as<decltype(l0), decltype(s1)>);
-    }
-    {
-        subrange s0{vi};
-        subrange s1{li};
-        subrange s2{views::all(vi)};
-        subrange s3{views::all(li)};
-        CPP_assert(same_as<decltype(r0), decltype(s0)>);
-        CPP_assert(same_as<decltype(l0), decltype(s1)>);
-        CPP_assert(same_as<decltype(r0), decltype(s2)>);
-        CPP_assert(same_as<decltype(l0), decltype(s3)>);
-    }
-    {
-        subrange s0{r0};
-        subrange s1{l0};
-        subrange s2{l1};
-        CPP_assert(same_as<decltype(r0), decltype(s0)>);
-        CPP_assert(same_as<decltype(l0), decltype(s1)>);
-        CPP_assert(same_as<decltype(l1), decltype(s2)>);
-    }
-    {
-        subrange s0{vi, ranges::size(vi)};
-        subrange s1{li, ranges::size(li)};
-        subrange s2{views::all(vi), ranges::size(vi)};
-        subrange s3{views::all(li), ranges::size(li)};
-        CPP_assert(same_as<decltype(r0), decltype(s0)>);
-        CPP_assert(same_as<decltype(l0), decltype(s1)>);
-        CPP_assert(same_as<decltype(r0), decltype(s2)>);
-        CPP_assert(same_as<decltype(l0), decltype(s3)>);
-    }
-    {
-        subrange s0{r0, size(r0)};
-        subrange s1{l0, size(l0)};
-        subrange s2{l1, size(l0)};
-        CPP_assert(same_as<decltype(r0), decltype(s0)>);
-        CPP_assert(same_as<decltype(l0), decltype(s1)>);
-        CPP_assert(same_as<decltype(l0), decltype(s2)>);
-    }
-#if defined(__clang__) && __clang_major__ < 6
-RANGES_DIAGNOSTIC_POP
-#endif // clang bug workaround
-#endif // use deduction guides
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/tail.cpp b/src/contrib/range-v3-0.11.0/test/view/tail.cpp
deleted file mode 100644
index 7d176940..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/tail.cpp
+++ /dev/null
@@ -1,72 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2017-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <list>
-#include <vector>
-#include <sstream>
-#include <range/v3/core.hpp>
-#include <range/v3/view/tail.hpp>
-#include <range/v3/view/empty.hpp>
-#include <range/v3/view/single.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-#include "../test_iterators.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    {
-        std::vector<int> v{0,1,2,3};
-        auto rng = views::tail(v);
-        check_equal(rng, {1,2,3});
-        CHECK(size(rng) == 3u);
-    }
-
-    {
-        std::vector<int> v{};
-        auto rng = views::tail(v);
-        CHECK(empty(rng));
-        CHECK(size(rng) == 0u);
-    }
-
-    {
-        std::stringstream sin{"1 2 3 4"};
-        istream_view<int> is(sin);
-        auto rng = views::tail(is);
-        check_equal(rng, {2,3,4});
-    }
-
-    {
-        std::stringstream sin{""};
-        istream_view<int> is(sin);
-        auto rng = views::tail(is);
-        CHECK(rng.begin() == rng.end());
-    }
-
-    {
-        auto rng = views::empty<int> | views::tail;
-        static_assert(0 == size(rng), "");
-        CPP_assert(same_as<empty_view<int>, decltype(rng)>);
-    }
-
-    {
-        tail_view<empty_view<int>> const rng(views::empty<int>);
-        static_assert(0 == size(rng), "");
-    }
-
-    {
-        auto const rng = views::single(1) | views::tail;
-        static_assert(0 == size(rng), "");
-    }
-
-    return ::test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/take.cpp b/src/contrib/range-v3-0.11.0/test/view/take.cpp
deleted file mode 100644
index 556c7d5f..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/take.cpp
+++ /dev/null
@@ -1,154 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <list>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/take.hpp>
-#include <range/v3/view/reverse.hpp>
-#include <range/v3/view/delimit.hpp>
-#include <range/v3/utility/copy.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    int rgi[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
-
-    auto rng0 = rgi | views::take(6);
-    has_type<int &>(*begin(rng0));
-    CPP_assert(view_<decltype(rng0)>);
-    CPP_assert(common_range<decltype(rng0)>);
-    CPP_assert(sized_range<decltype(rng0)>);
-    CPP_assert(random_access_iterator<decltype(begin(rng0))>);
-    CPP_assert(range<decltype(detail::as_const(rng0))>);
-    check_equal(rng0, {0, 1, 2, 3, 4, 5});
-    CHECK(size(rng0) == 6u);
-
-    auto rng0b = rgi | views::take(20);
-    has_type<int &>(*begin(rng0b));
-    CPP_assert(view_<decltype(rng0b)>);
-    CPP_assert(common_range<decltype(rng0b)>);
-    CPP_assert(sized_range<decltype(rng0b)>);
-    CPP_assert(random_access_iterator<decltype(begin(rng0b))>);
-    CPP_assert(range<decltype(detail::as_const(rng0b))>);
-    check_equal(rng0b, {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10});
-    CHECK(size(rng0b) == 11u);
-
-    auto rng1 = rng0 | views::reverse;
-    has_type<int &>(*begin(rng1));
-    CPP_assert(view_<decltype(rng1)>);
-    CPP_assert(common_range<decltype(rng1)>);
-    CPP_assert(sized_range<decltype(rng1)>);
-    CPP_assert(random_access_iterator<decltype(begin(rng1))>);
-    CPP_assert(range<decltype(detail::as_const(rng1))>);
-    check_equal(rng1, {5, 4, 3, 2, 1, 0});
-
-    std::vector<int> v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
-    auto rng2 = v | views::take(6) | views::reverse;
-    has_type<int &>(*begin(rng2));
-    CPP_assert(view_<decltype(rng2)>);
-    CPP_assert(common_range<decltype(rng2)>);
-    CPP_assert(sized_range<decltype(rng2)>);
-    CPP_assert(random_access_iterator<decltype(begin(rng2))>);
-    CPP_assert(range<decltype(detail::as_const(rng2))>);
-    check_equal(rng2, {5, 4, 3, 2, 1, 0});
-
-    std::list<int> l{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
-    auto rng3 = l | views::take(6);
-    has_type<int &>(*begin(rng3));
-    CPP_assert(view_<decltype(rng3)>);
-    CPP_assert(!common_range<decltype(rng3)>);
-    CPP_assert(sized_range<decltype(rng3)>);
-    CPP_assert(bidirectional_iterator<decltype(begin(rng3))>);
-    CPP_assert(!random_access_iterator<decltype(begin(rng3))>);
-    CPP_assert(range<decltype(detail::as_const(rng3))>);
-    ::check_equal(rng3, {0, 1, 2, 3, 4, 5});
-    CHECK(size(rng3) == 6u);
-
-    auto rng3b = l | views::take(20);
-    has_type<int &>(*begin(rng3b));
-    CPP_assert(view_<decltype(rng3b)>);
-    CPP_assert(!common_range<decltype(rng3b)>);
-    CPP_assert(sized_range<decltype(rng3b)>);
-    CPP_assert(bidirectional_iterator<decltype(begin(rng3b))>);
-    CPP_assert(!random_access_iterator<decltype(begin(rng3b))>);
-    CPP_assert(range<decltype(detail::as_const(rng3b))>);
-    check_equal(rng3b, {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10});
-    CHECK(size(rng3b) == 11u);
-
-    auto rng4 = views::iota(10) | views::take(10);
-    CPP_assert(view_<decltype(rng4)>);
-    CPP_assert(!common_range<decltype(rng4)>);
-    CPP_assert(sized_range<decltype(rng4)>);
-    CPP_assert(range<decltype(detail::as_const(rng4))>);
-    static_assert(!ranges::is_infinite<decltype(rng4)>::value, "");
-    check_equal(rng4, {10, 11, 12, 13, 14, 15, 16, 17, 18, 19});
-    CHECK(size(rng4) == 10u);
-
-    auto rng5 = views::iota(10) | views::take(10) | views::reverse;
-    CPP_assert(view_<decltype(rng5)>);
-    CPP_assert(common_range<decltype(rng5)>);
-    CPP_assert(sized_range<decltype(rng5)>);
-    CPP_assert(!range<decltype(detail::as_const(rng5))>);
-    static_assert(!ranges::is_infinite<decltype(rng5)>::value, "");
-    check_equal(rng5, {19, 18, 17, 16, 15, 14, 13, 12, 11, 10});
-    CHECK(size(rng5) == 10u);
-
-    auto c_str = views::delimit("hello world", '\0');
-    CPP_assert(random_access_range<decltype(c_str)>);
-    CPP_assert(!sized_range<decltype(c_str)>);
-
-    auto rng6 = c_str | views::take(5);
-    CPP_assert(view_<decltype(rng6)>);
-    CPP_assert(random_access_range<decltype(rng6)>);
-    CPP_assert(!common_range<decltype(rng6)>);
-    CPP_assert(!sized_range<decltype(rng6)>);
-    CPP_assert(range<decltype(detail::as_const(rng6))>);
-    check_equal(rng6, {'h','e','l','l','o'});
-
-    auto rng7 = c_str | views::take(20);
-    check_equal(rng7, {'h','e','l','l','o',' ','w','o','r','l','d'});
-
-    subrange<std::list<int>::iterator> rl{l.begin(), l.end()};
-    CPP_assert(view_<decltype(rl)>);
-    CPP_assert(bidirectional_range<decltype(rl)>);
-    CPP_assert(common_range<decltype(rl)>);
-    CPP_assert(!sized_range<decltype(rl)>);
-    CPP_assert(range<decltype(detail::as_const(rl))>);
-
-    auto rng8 = rl | views::take(5);
-    CPP_assert(view_<decltype(rng8)>);
-    CPP_assert(bidirectional_range<decltype(rng8)>);
-    CPP_assert(!common_range<decltype(rng8)>);
-    CPP_assert(!sized_range<decltype(rng8)>);
-    CPP_assert(range<decltype(detail::as_const(rng8))>);
-    check_equal(rng8, {0, 1, 2, 3, 4});
-
-    auto rng9 = rl | views::take(20);
-    CPP_assert(view_<decltype(rng9)>);
-    CPP_assert(bidirectional_range<decltype(rng9)>);
-    CPP_assert(!common_range<decltype(rng9)>);
-    CPP_assert(!sized_range<decltype(rng9)>);
-    CPP_assert(range<decltype(detail::as_const(rng9))>);
-    check_equal(rng9, {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10});
-
-    {
-        auto rng = debug_input_view<int const>{rgi} | views::take(6);
-        CPP_assert(!range<decltype(detail::as_const(rng))>);
-        check_equal(rng, {0, 1, 2, 3, 4, 5});
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/take_exactly.cpp b/src/contrib/range-v3-0.11.0/test/view/take_exactly.cpp
deleted file mode 100644
index 54bae90d..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/take_exactly.cpp
+++ /dev/null
@@ -1,86 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <list>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/take_exactly.hpp>
-#include <range/v3/view/reverse.hpp>
-#include <range/v3/utility/copy.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    int rgi[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
-
-    auto rng0 = rgi | views::take_exactly(6);
-    has_type<int &>(*begin(rng0));
-    CPP_assert(view_<decltype(rng0)>);
-    CPP_assert(common_range<decltype(rng0)>);
-    CPP_assert(sized_range<decltype(rng0)>);
-    CPP_assert(random_access_iterator<decltype(begin(rng0))>);
-    ::check_equal(rng0, {0, 1, 2, 3, 4, 5});
-    CHECK(size(rng0) == 6u);
-
-    auto rng1 = rng0 | views::reverse;
-    has_type<int &>(*begin(rng1));
-    CPP_assert(view_<decltype(rng1)>);
-    CPP_assert(common_range<decltype(rng1)>);
-    CPP_assert(sized_range<decltype(rng1)>);
-    CPP_assert(random_access_iterator<decltype(begin(rng1))>);
-    ::check_equal(rng1, {5, 4, 3, 2, 1, 0});
-
-    std::vector<int> v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
-    auto rng2 = v | views::take_exactly(6) | views::reverse;
-    has_type<int &>(*begin(rng2));
-    CPP_assert(view_<decltype(rng2)>);
-    CPP_assert(common_range<decltype(rng2)>);
-    CPP_assert(sized_range<decltype(rng2)>);
-    CPP_assert(random_access_iterator<decltype(begin(rng2))>);
-    ::check_equal(rng2, {5, 4, 3, 2, 1, 0});
-
-    std::list<int> l{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
-    auto rng3 = l | views::take_exactly(6);
-    has_type<int &>(*begin(rng3));
-    CPP_assert(view_<decltype(rng3)>);
-    CPP_assert(!common_range<decltype(rng3)>);
-    CPP_assert(sized_range<decltype(rng3)>);
-    CPP_assert(bidirectional_iterator<decltype(begin(rng3))>);
-    CPP_assert(!random_access_iterator<decltype(begin(rng3))>);
-    ::check_equal(rng3, {0, 1, 2, 3, 4, 5});
-
-    auto rng4 = views::iota(10) | views::take_exactly(10);
-    CPP_assert(view_<decltype(rng4)>);
-    CPP_assert(common_range<decltype(rng4)>);
-    CPP_assert(sized_range<decltype(rng4)>);
-    static_assert(!ranges::is_infinite<decltype(rng4)>::value, "");
-    ::check_equal(rng4, {10, 11, 12, 13, 14, 15, 16, 17, 18, 19});
-    CHECK(size(rng4) == 10u);
-
-    auto rng5 = views::iota(10) | views::take_exactly(10) | views::reverse;
-    CPP_assert(view_<decltype(rng5)>);
-    CPP_assert(common_range<decltype(rng5)>);
-    CPP_assert(sized_range<decltype(rng5)>);
-    static_assert(!ranges::is_infinite<decltype(rng5)>::value, "");
-    ::check_equal(rng5, {19, 18, 17, 16, 15, 14, 13, 12, 11, 10});
-    CHECK(size(rng5) == 10u);
-
-    {
-        auto rng = debug_input_view<int const>{rgi} | views::take_exactly(6);
-        ::check_equal(rng, {0, 1, 2, 3, 4, 5});
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/take_last.cpp b/src/contrib/range-v3-0.11.0/test/view/take_last.cpp
deleted file mode 100644
index 2b6bed51..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/take_last.cpp
+++ /dev/null
@@ -1,35 +0,0 @@
-// Range v3 library
-//
-//  Copyright Barry Revzin 2019-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <range/v3/utility/copy.hpp>
-#include <range/v3/view/take_last.hpp>
-
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    int rgi[] = {0, 1, 2, 3, 4, 5};
-
-    auto rng0 = rgi | views::take_last(3);
-    has_type<int &>(*begin(rng0));
-    CPP_assert(view_<decltype(rng0)>);
-    CPP_assert(common_range<decltype(rng0)>);
-    CPP_assert(sized_range<decltype(rng0)>);
-    CPP_assert(random_access_iterator<decltype(begin(rng0))>);
-    ::check_equal(rng0, {3, 4, 5});
-    CHECK(size(rng0) == 3u);
-
-    auto rng1 = rgi | views::take_last(7);
-    ::check_equal(rng1, {0, 1, 2, 3, 4, 5});
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/take_while.cpp b/src/contrib/range-v3-0.11.0/test/view/take_while.cpp
deleted file mode 100644
index 0cceebcc..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/take_while.cpp
+++ /dev/null
@@ -1,90 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/generate.hpp>
-#include <range/v3/view/take_while.hpp>
-#include <range/v3/utility/copy.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-struct my_data
-{
-    int i;
-};
-
-bool operator==(my_data left, my_data right)
-{
-    return left.i == right.i;
-}
-
-int main()
-{
-    using namespace ranges;
-    auto rng0 = views::iota(10) | views::take_while([](int i) { return i != 25; });
-    ::check_equal(rng0, {10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24});
-    CPP_assert(view_<decltype(rng0)>);
-    CPP_assert(!common_range<decltype(rng0)>);
-    CPP_assert(random_access_iterator<decltype(rng0.begin())>);
-
-    std::vector<int> vi{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
-    auto rng1 = vi | views::take_while([](int i) { return i != 50; });
-    CPP_assert(view_<decltype(rng1)>);
-    CPP_assert(random_access_range<decltype(rng1)>);
-    ::check_equal(rng1, {0, 1, 2, 3, 4, 5, 6, 7, 8, 9});
-
-    // Check with a mutable predicate
-    int rgi[] = {0,1,2,3,4,5,6,7,8,9};
-    int cnt = 0;
-    auto mutable_only = views::take_while(rgi, [cnt](int) mutable { return ++cnt <= 5;});
-    ::check_equal(mutable_only, {0,1,2,3,4});
-    CPP_assert(view_<decltype(mutable_only)>);
-    CPP_assert(!view_<decltype(mutable_only) const>);
-
-    {
-        auto ns = views::generate([]() mutable {
-            static int N;
-            return ++N;
-        });
-        auto rng = ns | views::take_while([](int i) { return i < 5; });
-        ::check_equal(rng, {1,2,3,4});
-    }
-
-    {
-        auto ns = views::generate([]() mutable {
-            static int N;
-            return ++N;
-        });
-        auto rng = ns | views::take_while([](int i) mutable { return i < 5; });
-        ::check_equal(rng, {1,2,3,4});
-    }
-
-    {
-        auto rng = debug_input_view<int const>{rgi} | views::take_while([](int i) {
-            return i != 5;
-        });
-        ::check_equal(rng, {0,1,2,3,4});
-    }
-
-    {
-        auto ns = views::generate([]() {
-            static int N;
-            return my_data{++N};
-        });
-        auto rng = ns | views::take_while([](int i) { return i < 5; },
-                                         &my_data::i);
-        ::check_equal(rng, std::vector<my_data>{{1},{2},{3},{4}});
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/tokenize.cpp b/src/contrib/range-v3-0.11.0/test/view/tokenize.cpp
deleted file mode 100644
index b36d834f..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/tokenize.cpp
+++ /dev/null
@@ -1,39 +0,0 @@
-#include <range/v3/core.hpp>
-#include <range/v3/view/tokenize.hpp>
-#include <range/v3/utility/copy.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-
-    // GCC 4.8 doesn't do regex
-#if !defined(__GNUC__) || defined(__clang__) || __GNUC__ > 4 || __GNUC_MINOR__ > 8
-    std::string txt{"abc\ndef\tghi"};
-    const std::regex rx{R"delim(([\w]+))delim"};
-    auto rng = txt | views::tokenize(rx,1);
-    const auto crng = txt | views::tokenize(rx,1);
-
-    ::check_equal(rng, {"abc","def","ghi"});
-    ::check_equal(crng, {"abc","def","ghi"});
-
-    ::has_type<const std::sub_match<std::string::iterator>&>(*ranges::begin(rng));
-    ::has_type<const std::sub_match<std::string::iterator>&>(*ranges::begin(crng));
-
-    CPP_assert(common_range<decltype(rng)>);
-    CPP_assert(forward_range<decltype(rng)>);
-    CPP_assert(!bidirectional_range<decltype(rng)>);
-    CPP_assert(!sized_range<decltype(rng)>);
-
-    CPP_assert(common_range<decltype(crng)>);
-    CPP_assert(forward_range<decltype(crng)>);
-    CPP_assert(!bidirectional_range<decltype(crng)>);
-    CPP_assert(!sized_range<decltype(crng)>);
-
-    CPP_assert(view_<decltype(rng)>);
-    CPP_assert(!view_<decltype(crng)>);
-#endif
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/transform.cpp b/src/contrib/range-v3-0.11.0/test/view/transform.cpp
deleted file mode 100644
index 16983b07..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/transform.cpp
+++ /dev/null
@@ -1,226 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <string>
-#include <vector>
-#include <iterator>
-#include <functional>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/move.hpp>
-#include <range/v3/functional/overload.hpp>
-#include <range/v3/iterator/insert_iterators.hpp>
-#include <range/v3/utility/copy.hpp>
-#include <range/v3/view/transform.hpp>
-#include <range/v3/view/counted.hpp>
-#include <range/v3/view/reverse.hpp>
-#include <range/v3/view/span.hpp>
-#include <range/v3/view/zip.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-struct is_odd
-{
-    bool operator()(int i) const
-    {
-        return (i % 2) == 1;
-    }
-};
-
-// https://github.com/ericniebler/range-v3/issues/996
-void bug_996()
-{
-    std::vector<int> buff(12, -1);
-    ::ranges::span<int> sp(buff.data(), 12);
-
-    auto x = ::ranges::views::transform(sp, [](int a) { return a > 3 ? a : 42; });
-    auto y = ::ranges::views::transform(x, sp, [](int a, int b) { return a + b; });
-    auto rng = ::ranges::views::transform(y, [](int a) { return a + 1; });
-    (void)rng;
-}
-
-int main()
-{
-    using namespace ranges;
-
-    int rgi[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
-    std::pair<int, int> rgp[] = {{1,1}, {2,2}, {3,3}, {4,4}, {5,5}, {6,6}, {7,7}, {8,8}, {9,9}, {10,10}};
-
-    {
-        auto rng = rgi | views::transform(is_odd());
-        has_type<int &>(*begin(rgi));
-        has_type<bool>(*begin(rng));
-        CPP_assert(view_<decltype(rng)>);
-        CPP_assert(sized_range<decltype(rng)>);
-        CPP_assert(random_access_range<decltype(rng)>);
-        ::check_equal(rng, {true, false, true, false, true, false, true, false, true, false});
-    }
-
-    {
-        auto rng2 = rgp | views::transform(&std::pair<int,int>::first);
-        has_type<int &>(*begin(rng2));
-        CPP_assert(same_as<range_value_t<decltype(rng2)>, int>);
-        CPP_assert(same_as<decltype(iter_move(begin(rng2))), int &&>);
-        CPP_assert(view_<decltype(rng2)>);
-        CPP_assert(common_range<decltype(rng2)>);
-        CPP_assert(sized_range<decltype(rng2)>);
-        CPP_assert(random_access_range<decltype(rng2)>);
-        ::check_equal(rng2, {1,2,3,4,5,6,7,8,9,10});
-        ::check_equal(rng2 | views::reverse, {10,9,8,7,6,5,4,3,2,1});
-        CHECK(&*begin(rng2) == &rgp[0].first);
-        CHECK(rng2.size() == 10u);
-    }
-
-    {
-
-        auto rng3 = views::counted(rgp, 10) | views::transform(&std::pair<int,int>::first);
-        has_type<int &>(*begin(rng3));
-        CPP_assert(view_<decltype(rng3)>);
-        CPP_assert(common_range<decltype(rng3)>);
-        CPP_assert(sized_range<decltype(rng3)>);
-        CPP_assert(random_access_range<decltype(rng3)>);
-        ::check_equal(rng3, {1,2,3,4,5,6,7,8,9,10});
-        CHECK(&*begin(rng3) == &rgp[0].first);
-        CHECK(rng3.size() == 10u);
-    }
-
-    {
-        auto rng4 = views::counted(ForwardIterator<std::pair<int, int>*>{rgp}, 10)
-                        | views::transform(&std::pair<int,int>::first);
-        has_type<int &>(*begin(rng4));
-        CPP_assert(view_<decltype(rng4)>);
-        CPP_assert(!common_range<decltype(rng4)>);
-        CPP_assert(sized_range<decltype(rng4)>);
-        CPP_assert(forward_range<decltype(rng4)>);
-        CPP_assert(!bidirectional_range<decltype(rng4)>);
-        ::check_equal(rng4, {1,2,3,4,5,6,7,8,9,10});
-        CHECK(&*begin(rng4) == &rgp[0].first);
-        CHECK(rng4.size() == 10u);
-
-        counted_iterator<ForwardIterator<std::pair<int, int>*>> i = begin(rng4).base();
-        (void)i;
-    }
-
-    // Test transform with a mutable lambda
-    {
-        int cnt = 100;
-        auto mutable_rng = views::transform(rgi, [cnt](int) mutable { return cnt++;});
-        ::check_equal(mutable_rng, {100,101,102,103,104,105,106,107,108,109});
-        CHECK(cnt == 100);
-        CPP_assert(view_<decltype(mutable_rng)>);
-        CPP_assert(!view_<decltype(mutable_rng) const>);
-    }
-
-    // Test iter_transform by transforming a zip view to select one element.
-    {
-        auto v0 = to<std::vector<MoveOnlyString>>({"a","b","c"});
-        auto v1 = to<std::vector<MoveOnlyString>>({"x","y","z"});
-
-        auto rng1 = views::zip(v0, v1);
-        CPP_assert(random_access_range<decltype(rng1)>);
-
-        std::vector<MoveOnlyString> res;
-        using R1 = decltype(rng1);
-        using I1 = iterator_t<R1>;
-        // Needlessly verbose -- a simple transform would do the same, but this
-        // is an interesting test.
-        auto proj = overload(
-            [](I1 i1) -> MoveOnlyString& {return (*i1).first;},
-            [](copy_tag, I1) -> MoveOnlyString {return {};},
-            [](move_tag, I1 i1) -> MoveOnlyString&& {return std::move((*i1).first);}
-        );
-        auto rng2 = rng1 | views::iter_transform(proj);
-        move(rng2, ranges::back_inserter(res));
-        ::check_equal(res, {"a","b","c"});
-        ::check_equal(v0, {"","",""});
-        ::check_equal(v1, {"x","y","z"});
-        using R2 = decltype(rng2);
-        CPP_assert(same_as<range_value_t<R2>, MoveOnlyString>);
-        CPP_assert(same_as<range_reference_t<R2>, MoveOnlyString &>);
-        CPP_assert(same_as<range_rvalue_reference_t<R2>, MoveOnlyString &&>);
-    }
-
-    // two range transform
-    {
-        auto v0 = to<std::vector<std::string>>({"a","b","c"});
-        auto v1 = to<std::vector<std::string>>({"x","y","z"});
-
-        auto rng = views::transform(v0, v1, [](std::string& s0, std::string& s1){return std::tie(s0, s1);});
-        using R = decltype(rng);
-        CPP_assert(same_as<range_value_t<R>, std::tuple<std::string&, std::string&>>);
-        CPP_assert(same_as<range_reference_t<R>, std::tuple<std::string&, std::string&>>);
-        CPP_assert(same_as<range_rvalue_reference_t<R>, std::tuple<std::string&, std::string&>>);
-
-        using T = std::tuple<std::string, std::string>;
-        ::check_equal(rng, {T{"a","x"}, T{"b","y"}, T{"c","z"}});
-    }
-
-    // two range indirect transform
-    {
-        auto v0 = to<std::vector<std::string>>({"a","b","c"});
-        auto v1 = to<std::vector<std::string>>({"x","y","z"});
-        using I = std::vector<std::string>::iterator;
-
-        auto fun = overload(
-            [](I i, I j)           { return std::tie(*i, *j); },
-            [](copy_tag, I, I)     { return std::tuple<std::string, std::string>{}; },
-            [](move_tag, I i, I j) { return common_tuple<std::string&&, std::string&&>{
-                std::move(*i), std::move(*j)}; } );
-
-        auto rng = views::iter_transform(v0, v1, fun);
-        using R = decltype(rng);
-        CPP_assert(same_as<range_value_t<R>, std::tuple<std::string, std::string>>);
-        CPP_assert(same_as<range_reference_t<R>, std::tuple<std::string&, std::string&>>);
-        CPP_assert(same_as<range_rvalue_reference_t<R>, common_tuple<std::string&&, std::string&&>>);
-
-        using T = std::tuple<std::string, std::string>;
-        ::check_equal(rng, {T{"a","x"}, T{"b","y"}, T{"c","z"}});
-    }
-
-    {
-        auto rng = debug_input_view<int const>{rgi} | views::transform(is_odd{});
-        ::check_equal(rng, {true, false, true, false, true, false, true, false, true, false});
-    }
-
-    {
-        auto v0 = to<std::vector<std::string>>({"a","b","c"});
-        auto v1 = to<std::vector<std::string>>({"x","y","z"});
-
-        auto r0 = debug_input_view<std::string>{v0.data(), distance(v0)};
-        auto r1 = debug_input_view<std::string>{v1.data(), distance(v1)};
-        auto rng = views::transform(std::move(r0), std::move(r1),
-            [](std::string &s0, std::string &s1){ return std::tie(s0, s1); });
-        using R = decltype(rng);
-        CPP_assert(same_as<range_value_t<R>, std::tuple<std::string &, std::string &>>);
-        CPP_assert(same_as<range_reference_t<R>, std::tuple<std::string &, std::string &>>);
-        CPP_assert(same_as<range_rvalue_reference_t<R>, std::tuple<std::string &, std::string &>>);
-
-        using T = std::tuple<std::string, std::string>;
-        ::check_equal(rng, {T{"a","x"}, T{"b","y"}, T{"c","z"}});
-    }
-
-    {
-#if RANGES_CXX_DEDUCTION_GUIDES >= RANGES_CXX_DEDUCTION_GUIDES_17
-#if defined(__clang__) && __clang_major__ < 6
-        // Workaround https://bugs.llvm.org/show_bug.cgi?id=33314
-        RANGES_DIAGNOSTIC_PUSH
-        RANGES_DIAGNOSTIC_IGNORE_UNDEFINED_FUNC_TEMPLATE
-#endif
-        std::vector<int> vi = {1, 2, 3};
-        ranges::transform_view times_ten{vi, [](int i) { return i * 10; }};
-        ::check_equal(times_ten, {10, 20, 30});
-#if defined(__clang__) && __clang_major__ < 6
-        RANGES_DIAGNOSTIC_POP
-#endif // clang bug workaround
-#endif // use deduction guides
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/trim.cpp b/src/contrib/range-v3-0.11.0/test/view/trim.cpp
deleted file mode 100644
index f0ad62f3..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/trim.cpp
+++ /dev/null
@@ -1,97 +0,0 @@
-// Range v3 library
-//
-//  Copyright Johel Guerrero 2019
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#include <concepts/concepts.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/range/operations.hpp>
-#include <range/v3/range/primitives.hpp>
-#include <range/v3/range_fwd.hpp>
-#include <range/v3/utility/copy.hpp>
-#include <range/v3/view/addressof.hpp>
-#include <range/v3/view/drop.hpp>
-#include <range/v3/view/drop_while.hpp>
-#include <range/v3/view/reverse.hpp>
-#include <range/v3/view/subrange.hpp>
-#include <range/v3/view/tail.hpp>
-#include <range/v3/view/trim.hpp>
-
-#include "../test_iterators.hpp"
-#include "../test_utils.hpp"
-
-int main()
-{
-    using namespace ranges;
-    int ia[] = {0, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 0};
-    int ib[] =             {4, 3, 2, 1, 2, 3, 4};
-    constexpr auto bs = distance(ib);
-    auto p = [](int i) { return i < 4; };
-
-    auto rng = views::trim(ia, p);
-    static_assert(same_as<iterator_t<decltype(rng)>, iterator_t<decltype(ia)>>, "");
-    CPP_assert(view_<decltype(rng)>);
-    CPP_assert(contiguous_range<decltype(rng)>);
-    CPP_assert(common_range<decltype(rng)>);
-    CPP_assert(!sized_range<decltype(rng)>);
-    check_equal(rng, ib);
-
-    auto && rng2 = views::trim(ib, p);
-    check_equal(views::addressof(rng2), views::addressof(ib));
-
-    auto rng3 = ia | views::drop(4) | views::trim(p);
-    static_assert(same_as<iterator_t<decltype(rng3)>, iterator_t<decltype(rng3.base())>>, "");
-    CPP_assert(view_<decltype(rng3)>);
-    CPP_assert(contiguous_range<decltype(rng3)>);
-    CPP_assert(common_range<decltype(rng3)>);
-    CPP_assert(!sized_range<decltype(rng3)>);
-    check_equal(rng3, ib);
-
-    auto rng4 = ia | views::reverse | views::drop(4) | views::trim(p);
-    static_assert(same_as<iterator_t<decltype(rng4)>, iterator_t<decltype(rng4.base())>>, "");
-    CPP_assert(view_<decltype(rng4)>);
-    CPP_assert(random_access_range<decltype(rng4)>);
-    CPP_assert(common_range<decltype(rng4)>);
-    CPP_assert(!sized_range<decltype(rng4)>);
-    check_equal(rng4, ib);
-
-    check_equal(views::trim(ia, p), ia | views::drop_while(p) | views::reverse | views::drop_while(p));
-
-    auto rng5 = make_subrange(ib + 1, ib + bs - 1) | views::trim(p);
-    static_assert(same_as<iterator_t<decltype(rng5)>, iterator_t<decltype(rng5.base())>>, "");
-    CPP_assert(view_<decltype(rng5)>);
-    CPP_assert(contiguous_range<decltype(rng5)>);
-    CPP_assert(common_range<decltype(rng5)>);
-    CPP_assert(!sized_range<decltype(rng5)>);
-    CHECK(empty(rng5));
-
-    auto rng6 = make_subrange(ib, ib + bs - 1) | views::trim(p);
-    CHECK(distance(rng6) == 1);
-    check_equal(&front(rng6), ib);
-
-    auto rng7 = ib | views::tail | views::trim(p);
-    static_assert(same_as<iterator_t<decltype(rng7)>, iterator_t<decltype(rng7.base())>>, "");
-    CPP_assert(view_<decltype(rng7)>);
-    CPP_assert(contiguous_range<decltype(rng7)>);
-    CPP_assert(common_range<decltype(rng7)>);
-    CPP_assert(!sized_range<decltype(rng7)>);
-    CHECK(distance(rng7) == 1);
-    check_equal(&front(rng7), ib + bs - 1);
-
-    auto rng8 = make_subrange(BidirectionalIterator<const int*>(ia),
-        BidirectionalIterator<const int*>(ia + distance(ia))) | views::trim(p);
-    static_assert(same_as<iterator_t<decltype(rng8)>, iterator_t<decltype(rng8.base())>>, "");
-    CPP_assert(view_<decltype(rng8)>);
-    CPP_assert(bidirectional_range<decltype(rng8)>);
-    CPP_assert(common_range<decltype(rng8)>);
-    CPP_assert(!sized_range<decltype(rng8)>);
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/unique.cpp b/src/contrib/range-v3-0.11.0/test/view/unique.cpp
deleted file mode 100644
index e3db163c..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/unique.cpp
+++ /dev/null
@@ -1,155 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <cctype>
-#include <string>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/copy.hpp>
-#include <range/v3/view/delimit.hpp>
-#include <range/v3/view/reverse.hpp>
-#include <range/v3/view/transform.hpp>
-#include <range/v3/view/unique.hpp>
-#include <range/v3/utility/copy.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/insert_iterators.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-using std::toupper;
-
-// from http://stackoverflow.com/a/2886589/195873
-struct ci_char_traits : std::char_traits<char>
-{
-    static bool eq(char c1, char c2) { return toupper(c1) == toupper(c2); }
-    static bool ne(char c1, char c2) { return toupper(c1) != toupper(c2); }
-    static bool lt(char c1, char c2) { return toupper(c1) <  toupper(c2); }
-    static int compare(const char* s1, const char* s2, std::size_t n)
-    {
-        for(; n != 0; ++s1, ++s2, --n)
-        {
-            if(toupper(*s1) < toupper(*s2))
-                return -1;
-            if(toupper(*s1) > toupper(*s2))
-                return 1;
-        }
-        return 0;
-    }
-    static const char* find(const char* s, int n, char a)
-    {
-        for(; n-- > 0; ++s)
-            if(toupper(*s) == toupper(a))
-                break;
-        return s;
-    }
-};
-
-using ci_string = std::basic_string<char, ci_char_traits>;
-
-int main()
-{
-    using namespace ranges;
-
-    {
-        int rgi[] = {1, 1, 1, 2, 3, 4, 4};
-        std::vector<int> out;
-
-        auto rng = rgi | views::unique;
-        has_type<int &>(*begin(rng));
-        CPP_assert(view_<decltype(rng)>);
-        CPP_assert(bidirectional_range<decltype(rng)>);
-        CPP_assert(!random_access_range<decltype(rng)>);
-        CPP_assert(common_range<decltype(rng)>);
-        CPP_assert(!sized_range<decltype(rng)>);
-        CPP_assert(range<decltype(rng) const>);
-        copy(rng, ranges::back_inserter(out));
-        ::check_equal(out, {1, 2, 3, 4});
-        ::check_equal(views::reverse(out), {4, 3, 2, 1});
-    }
-
-    {
-        std::vector<ci_string> rgs{"hello", "HELLO", "bye", "Bye", "BYE"};
-        auto rng = rgs | views::unique;
-        has_type<ci_string &>(*begin(rng));
-        CPP_assert(view_<decltype(rng)>);
-        CPP_assert(bidirectional_range<decltype(rng)>);
-        CPP_assert(!random_access_range<decltype(rng)>);
-        CPP_assert(common_range<decltype(rng)>);
-        CPP_assert(!sized_range<decltype(rng)>);
-        CPP_assert(range<decltype(rng) const>);
-        auto fs = rng | views::transform([](ci_string s){return std::string(s.data(), s.size());});
-        CPP_assert(view_<decltype(fs)>);
-        CPP_assert(bidirectional_range<decltype(fs)>);
-        ::check_equal(fs, {"hello","bye"});
-        ::check_equal(views::reverse(fs), {"bye","hello"});
-    }
-
-    {
-        int const rgi[] = {1, 1, 1, 2, 3, 4, 4, 42, 7};
-        auto rng0 = views::delimit(rgi, 42) | views::reverse;
-        // rng0 is mutable-only...
-        CPP_assert(forward_range<decltype(rng0)>);
-        CPP_assert(!forward_range<decltype(rng0) const>);
-        // ...and composable
-        auto rng = rng0 | views::unique(equal_to{});
-        CPP_assert(view_<decltype(rng)>);
-        CPP_assert(bidirectional_range<decltype(rng)>);
-        CPP_assert(!random_access_range<decltype(rng)>);
-        CPP_assert(common_range<decltype(rng)>);
-        CPP_assert(!sized_range<decltype(rng)>);
-        ::check_equal(rng, {4, 3, 2, 1});
-    }
-
-    {
-        auto const caseInsensitiveCompare = [](const std::string& s1, const std::string& s2){
-            if (s1.size() != s2.size())
-                return false;
-            for (unsigned i = 0; i < s1.size(); i++)
-                if (toupper(s1[i]) != toupper(s2[i]))
-                    return false;
-
-            return true;
-        };
-
-        std::vector<std::string> rgs{"hello", "HELLO", "bye", "Bye", "BYE"};
-        auto rng = rgs | views::unique(caseInsensitiveCompare);
-        has_type<std::string &>(*begin(rng));
-        CPP_assert(view_<decltype(rng)>);
-        CPP_assert(bidirectional_range<decltype(rng)>);
-        CPP_assert(!random_access_range<decltype(rng)>);
-        CPP_assert(common_range<decltype(rng)>);
-        CPP_assert(!sized_range<decltype(rng)>);
-        CPP_assert(range<decltype(rng) const>);
-        CPP_assert(view_<decltype(rng)>);
-        CPP_assert(bidirectional_range<decltype(rng)>);
-        ::check_equal(rng, {"hello","bye"});
-        ::check_equal(views::reverse(rng), {"bye","hello"});
-    }
-
-    {
-        int const rgi[] = {-1, 1, -1, 2, 3, 4, -4, 42, 7};
-        auto rng0 = views::delimit(rgi, 42) | views::reverse;
-        // rng0 is mutable-only...
-        CPP_assert(forward_range<decltype(rng0)>);
-        CPP_assert(!forward_range<decltype(rng0) const>);
-        // ...and composable
-        auto rng = rng0 | views::unique([](const int& n1, const int& n2){ return n1==n2 || n1==-n2; })
-                        | views::transform([](const int& n){ return n > 0 ? n: -n;});
-        CPP_assert(view_<decltype(rng)>);
-        CPP_assert(bidirectional_range<decltype(rng)>);
-        CPP_assert(!random_access_range<decltype(rng)>);
-        CPP_assert(common_range<decltype(rng)>);
-        CPP_assert(!sized_range<decltype(rng)>);
-        ::check_equal(rng, {4, 3, 2, 1});
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/view.cpp b/src/contrib/range-v3-0.11.0/test/view/view.cpp
deleted file mode 100644
index 2b91d0a0..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/view.cpp
+++ /dev/null
@@ -1,49 +0,0 @@
-#include <vector>
-
-#include <range/v3/view/drop.hpp>
-#include <range/v3/view/view.hpp>
-
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-using namespace ranges;
-
-struct my_drop_base_fn
-{
-    template<typename Rng>
-    auto operator()(Rng && rng, range_difference_t<Rng> n) const
-    {
-        return drop_view<views::all_t<Rng>>(views::all(static_cast<Rng &&>(rng)), n);
-    }
-};
-struct my_drop_fn : my_drop_base_fn
-{
-    using my_drop_base_fn::operator();
-
-    template<typename Int>
-    constexpr auto operator()(Int n) const
-    {
-        return make_view_closure([=](auto && rng) {
-            return my_drop_base_fn{}(std::forward<decltype(rng)>(rng), n); });
-    }
-};
-RANGES_INLINE_VARIABLE(my_drop_fn, my_drop)
-
-/// #https://github.com/ericniebler/range-v3/issues/1169
-void constexpr_test_1169()
-{
-#if RANGES_CXX_CONSTEXPR >= RANGES_CXX_CONSTEXPR_LAMBDAS
-    constexpr auto const drop1 = my_drop(1);
-    constexpr auto const drop3 = drop1 | my_drop(2);
-
-    std::vector<int> vec = {1, 2, 3, 4};
-    check_equal(vec | drop3, {4});
-#endif
-    (void)my_drop;
-}
-
-int main()
-{
-    constexpr_test_1169();
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test/view/zip.cpp b/src/contrib/range-v3-0.11.0/test/view/zip.cpp
deleted file mode 100644
index 5793e5ee..00000000
--- a/src/contrib/range-v3-0.11.0/test/view/zip.cpp
+++ /dev/null
@@ -1,304 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2014-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-
-#include <algorithm>
-#include <memory>
-#include <sstream>
-#include <string>
-#include <vector>
-#include <range/v3/core.hpp>
-#include <range/v3/algorithm/copy.hpp>
-#include <range/v3/algorithm/move.hpp>
-#include <range/v3/algorithm/find_if.hpp>
-#include <range/v3/utility/copy.hpp>
-#include <range/v3/iterator/operations.hpp>
-#include <range/v3/iterator/insert_iterators.hpp>
-#include <range/v3/view/common.hpp>
-#include <range/v3/view/filter.hpp>
-#include <range/v3/view/for_each.hpp>
-#include <range/v3/view/iota.hpp>
-#include <range/v3/view/map.hpp>
-#include <range/v3/view/move.hpp>
-#include <range/v3/view/stride.hpp>
-#include <range/v3/view/take_while.hpp>
-#include <range/v3/view/take.hpp>
-#include <range/v3/view/zip.hpp>
-#include <range/v3/view/zip_with.hpp>
-#include "../simple_test.hpp"
-#include "../test_utils.hpp"
-
-#if defined(__cpp_lib_ranges) && __cpp_lib_ranges >= 201911
-// See https://github.com/ericniebler/range-v3/issues/1480
-void test_bug1480()
-{
-    std::vector<char> const first{};
-    std::vector<char> const second{};
-
-    auto zip_view = ::ranges::views::zip(first, second);
-    auto fn = [&] ([[maybe_unused]] auto && ch)
-    {
-    };
-    std::ranges::for_each(zip_view, fn);
-}
-#endif
-
-int main()
-{
-    using namespace ranges;
-
-    std::vector<int> vi{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
-    std::vector<std::string> const vs{"hello", "goodbye", "hello", "goodbye"};
-
-    // All common ranges, but one single-pass
-    {
-        std::stringstream str{"john paul george ringo"};
-        using V = std::tuple<int, std::string, std::string>;
-        auto rng = views::zip(vi, vs, istream<std::string>(str) | views::common);
-        using Rng = decltype(rng);
-        CPP_assert(view_<decltype(rng)>);
-        CPP_assert(!common_range<decltype(rng)>);
-        CPP_assert(!sized_range<decltype(rng)>);
-        CPP_assert(same_as<
-            range_value_t<Rng>,
-            std::tuple<int, std::string, std::string>>);
-        CPP_assert(same_as<
-            range_reference_t<Rng>,
-            common_tuple<int &, std::string const &, std::string &>>);
-        CPP_assert(same_as<
-            range_rvalue_reference_t<Rng>,
-            common_tuple<int &&, std::string const &&, std::string &&>>);
-        CPP_assert(convertible_to<range_value_t<Rng> &&,
-            range_rvalue_reference_t<Rng>>);
-        CPP_assert(input_iterator<decltype(begin(rng))>);
-        CPP_assert(!forward_iterator<decltype(begin(rng))>);
-        has_cardinality<cardinality::finite>(rng);
-        auto expected = to_vector(rng);
-        ::check_equal(expected, {V{0, "hello", "john"},
-                                 V{1, "goodbye", "paul"},
-                                 V{2, "hello", "george"},
-                                 V{3, "goodbye", "ringo"}});
-    }
-
-    // Mixed ranges and common ranges
-    {
-        std::stringstream str{"john paul george ringo"};
-        using V = std::tuple<int, std::string, std::string>;
-        auto rng = views::zip(vi, vs, istream<std::string>(str));
-        CPP_assert(view_<decltype(rng)>);
-        CPP_assert(!sized_range<decltype(rng)>);
-        CPP_assert(!common_range<decltype(rng)>);
-        CPP_assert(input_iterator<decltype(begin(rng))>);
-        CPP_assert(!forward_iterator<decltype(begin(rng))>);
-        has_cardinality<cardinality::finite>(rng);
-        std::vector<V> expected;
-        copy(rng, ranges::back_inserter(expected));
-        ::check_equal(expected, {V{0, "hello", "john"},
-                                 V{1, "goodbye", "paul"},
-                                 V{2, "hello", "george"},
-                                 V{3, "goodbye", "ringo"}});
-    }
-
-    auto rnd_rng = views::zip(vi, vs);
-    using Ref = range_reference_t<decltype(rnd_rng)>;
-    static_assert(std::is_same<Ref, common_pair<int &,std::string const &>>::value, "");
-    CPP_assert(view_<decltype(rnd_rng)>);
-    CPP_assert(common_range<decltype(rnd_rng)>);
-    CPP_assert(sized_range<decltype(rnd_rng)>);
-    CPP_assert(random_access_iterator<decltype(begin(rnd_rng))>);
-    has_cardinality<cardinality::finite>(rnd_rng);
-    auto tmp = cbegin(rnd_rng) + 3;
-    CHECK(std::get<0>(*tmp) == 3);
-    CHECK(std::get<1>(*tmp) == "goodbye");
-
-    CHECK((rnd_rng.end() - rnd_rng.begin()) == 4);
-    CHECK((rnd_rng.begin() - rnd_rng.end()) == -4);
-    CHECK(rnd_rng.size() == 4u);
-
-    // zip_with
-    {
-        std::vector<std::string> v0{"a","b","c"};
-        std::vector<std::string> v1{"x","y","z"};
-
-        auto rng = views::zip_with(std::plus<std::string>{}, v0, v1);
-        std::vector<std::string> expected;
-        copy(rng, ranges::back_inserter(expected));
-        ::check_equal(expected, {"ax","by","cz"});
-    }
-
-    // Move from a zip view
-    {
-        auto v0 = to<std::vector<MoveOnlyString>>({"a","b","c"});
-        auto v1 = to<std::vector<MoveOnlyString>>({"x","y","z"});
-
-        auto rng = views::zip(v0, v1);
-        CPP_assert(random_access_range<decltype(rng)>);
-        std::vector<std::pair<MoveOnlyString, MoveOnlyString>> expected;
-        move(rng, ranges::back_inserter(expected));
-        ::check_equal(expected | views::keys, {"a","b","c"});
-        ::check_equal(expected | views::values, {"x","y","z"});
-        ::check_equal(v0, {"","",""});
-        ::check_equal(v1, {"","",""});
-
-        move(expected, rng.begin());
-        ::check_equal(expected | views::keys, {"","",""});
-        ::check_equal(expected | views::values, {"","",""});
-        ::check_equal(v0, {"a","b","c"});
-        ::check_equal(v1, {"x","y","z"});
-
-        std::vector<MoveOnlyString> res;
-        using R = decltype(rng);
-        auto proj =
-            [](range_reference_t<R> p) -> MoveOnlyString& {return p.first;};
-        auto rng2 = rng | views::transform(proj);
-        move(rng2, ranges::back_inserter(res));
-        ::check_equal(res, {"a","b","c"});
-        ::check_equal(v0, {"","",""});
-        ::check_equal(v1, {"x","y","z"});
-        using R2 = decltype(rng2);
-        CPP_assert(same_as<range_value_t<R2>, MoveOnlyString>);
-        CPP_assert(same_as<range_reference_t<R2>, MoveOnlyString &>);
-        CPP_assert(same_as<range_rvalue_reference_t<R2>, MoveOnlyString &&>);
-    }
-
-    {
-        auto const v = to<std::vector<MoveOnlyString>>({"a","b","c"});
-        auto rng = views::zip(v, v);
-        using Rng = decltype(rng);
-        using I = iterator_t<Rng>;
-        CPP_assert(indirectly_readable<I>);
-        CPP_assert(same_as<
-            range_value_t<Rng>,
-            std::pair<MoveOnlyString, MoveOnlyString>>);
-        CPP_assert(same_as<
-            range_reference_t<Rng>,
-            common_pair<MoveOnlyString const &, MoveOnlyString const &>>);
-        CPP_assert(same_as<
-            range_rvalue_reference_t<Rng>,
-            common_pair<MoveOnlyString const &&, MoveOnlyString const &&>>);
-        CPP_assert(same_as<
-            range_common_reference_t<Rng>,
-            common_pair<MoveOnlyString const &, MoveOnlyString const &>>);
-    }
-
-    {
-        std::vector<int> v{1,2,3,4};
-        auto moved = v | views::move;
-        using Moved = decltype(moved);
-        CPP_assert(same_as<range_reference_t<Moved>, int &&>);
-        auto zipped = views::zip(moved);
-        using Zipped = decltype(zipped);
-        CPP_assert(same_as<range_reference_t<Zipped>, common_tuple<int &&> >);
-    }
-
-    // This is actually a test of the logic of view_adaptor. Since the stride view
-    // does not redefine the current member function, the base range's iter_move
-    // function gets picked up automatically.
-    {
-        auto rng0 = views::zip(vi, vs);
-        auto rng1 = views::stride(rng0, 2);
-        CPP_assert(same_as<range_rvalue_reference_t<decltype(rng1)>, range_rvalue_reference_t<decltype(rng0)>>);
-        CPP_assert(same_as<range_value_t<decltype(rng1)>, range_value_t<decltype(rng0)>>);
-    }
-
-    // Test for noexcept iter_move
-    {
-        static_assert(noexcept(std::declval<std::unique_ptr<int>&>() = std::declval<std::unique_ptr<int>&&>()), "");
-        std::unique_ptr<int> rg1[10], rg2[10];
-        auto x = views::zip(rg1, rg2);
-        std::pair<std::unique_ptr<int>, std::unique_ptr<int>> p = iter_move(x.begin());
-        auto it = x.begin();
-        static_assert(noexcept(iter_move(it)), "");
-    }
-
-    // Really a test for common_iterator's iter_move, but this is a good place for it.
-    {
-        std::unique_ptr<int> rg1[10], rg2[10];
-        auto rg3 = rg2 | views::take_while([](std::unique_ptr<int> &){return true;});
-        auto x = views::zip(rg1, rg3);
-        CPP_assert(!common_range<decltype(x)>);
-        auto y = x | views::common;
-        std::pair<std::unique_ptr<int>, std::unique_ptr<int>> p = iter_move(y.begin());
-        auto it = x.begin();
-        static_assert(noexcept(iter_move(it)), "");
-    }
-
-    // Regression test for #439.
-    {
-        std::vector<int> vec{0,1,2};
-        auto rng = vec | views::for_each([](int i) { return ranges::yield(i); });
-        ranges::distance(views::zip(views::iota(0), rng) | views::common);
-    }
-
-    {
-        int const i1[] = {0,1,2,3};
-        int const i2[] = {4,5,6,7};
-        auto rng = views::zip(
-            debug_input_view<int const>{i1},
-            debug_input_view<int const>{i2}
-        );
-        using P = std::pair<int, int>;
-        has_cardinality<cardinality::finite>(rng);
-        ::check_equal(rng, {P{0,4},P{1,5}, P{2,6}, P{3,7}});
-    }
-
-    {
-        // Test with no ranges
-        auto rng = views::zip();
-        using R = decltype(rng);
-        CPP_assert(same_as<range_value_t<R>, std::tuple<>>);
-        CPP_assert(contiguous_range<R>);
-        has_cardinality<cardinality(0)>(rng);
-        CHECK(ranges::begin(rng) == ranges::end(rng));
-        CHECK(ranges::size(rng) == 0u);
-    }
-
-    {
-        // test dangling
-        auto true_ = [](auto&&){ return true; };
-
-        CHECK(!::is_dangling(ranges::find_if(views::zip(vi, vs), true_)));
-        CHECK(!::is_dangling(ranges::find_if(views::zip(
-            vi | views::move,
-            vs | views::common
-            ), true_)));
-        CHECK(::is_dangling(ranges::find_if(views::zip(
-            vi | views::filter(true_)), true_)));
-    }
-
-    {
-        // test zip with infinite range
-        int const i1[] = {0,1,2,3};
-        auto rng = views::zip(i1, views::iota(4));
-
-        has_cardinality<cardinality(4)>(rng);
-        using P = std::pair<int, int>;
-        ::check_equal(rng, {P{0,4},P{1,5}, P{2,6}, P{3,7}});
-    }
-
-    {
-        // test zip with infinite ranges only
-        auto rng = views::zip(views::iota(0), views::iota(4));
-
-        has_cardinality<cardinality::infinite>(rng);
-        using P = std::pair<int, int>;
-        ::check_equal(rng | views::take(4), {P{0,4},P{1,5}, P{2,6}, P{3,7}});
-    }
-
-    {
-        // test unknown cardinality
-        std::stringstream str{};
-        auto rng = views::zip(istream<std::string>(str));
-
-        has_cardinality<cardinality::unknown>(rng);
-    }
-
-    return test_result();
-}
diff --git a/src/contrib/range-v3-0.11.0/test_package/CMakeLists.txt b/src/contrib/range-v3-0.11.0/test_package/CMakeLists.txt
deleted file mode 100644
index 3ef81b85..00000000
--- a/src/contrib/range-v3-0.11.0/test_package/CMakeLists.txt
+++ /dev/null
@@ -1,23 +0,0 @@
-# Range v3 library
-#
-#  Copyright Luis Martinez de Bartolome Izquierdo 2016
-#
-#  Use, modification and distribution is subject to the
-#  Boost Software License, Version 1.0. (See accompanying
-#  file LICENSE_1_0.txt or copy at
-#  http://www.boost.org/LICENSE_1_0.txt)
-#
-# Project home: https://github.com/ericniebler/range-v3
-#
-
-PROJECT(PackageTest)
-cmake_minimum_required(VERSION 3.1.0 FATAL_ERROR)
-
-include(${CMAKE_BINARY_DIR}/conanbuildinfo.cmake)
-conan_basic_setup()
-
-add_executable(example example.cpp)
-
-target_link_libraries(example ${CONAN_LIBS})
-
-set_property(TARGET example PROPERTY CXX_STANDARD 17)
diff --git a/src/contrib/range-v3-0.11.0/test_package/conanfile.py b/src/contrib/range-v3-0.11.0/test_package/conanfile.py
deleted file mode 100644
index 4a8c78db..00000000
--- a/src/contrib/range-v3-0.11.0/test_package/conanfile.py
+++ /dev/null
@@ -1,33 +0,0 @@
-# Range v3 library
-#
-#  Copyright Luis Martinez de Bartolome Izquierdo 2016
-#
-#  Use, modification and distribution is subject to the
-#  Boost Software License, Version 1.0. (See accompanying
-#  file LICENSE_1_0.txt or copy at
-#  http://www.boost.org/LICENSE_1_0.txt)
-#
-# Project home: https://github.com/ericniebler/range-v3
-#
-
-
-from conans import ConanFile, CMake
-import os
-
-
-class Rangev3TestConan(ConanFile):
-    settings = "os", "compiler", "build_type", "arch"
-    generators = "cmake"
-
-    def build(self):
-        cmake = CMake(self)
-        cmake.configure()
-        cmake.build()
-
-    def imports(self):
-        self.copy("*.dll", "bin", "bin")
-        self.copy("*.dylib", "bin", "bin")
-
-    def test(self):
-        os.chdir("bin")
-        self.run(".%sexample" % os.sep)
diff --git a/src/contrib/range-v3-0.11.0/test_package/example.cpp b/src/contrib/range-v3-0.11.0/test_package/example.cpp
deleted file mode 100644
index bee0b2ab..00000000
--- a/src/contrib/range-v3-0.11.0/test_package/example.cpp
+++ /dev/null
@@ -1,43 +0,0 @@
-// Range v3 library
-//
-//  Copyright Eric Niebler 2013-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-
-
-#include <range/v3/all.hpp>
-#include <iostream>
-
-using namespace ranges;
-
-// A range that iterates over all the characters in a
-// null-terminated string.
-class c_string_range
-  : public view_facade<c_string_range>
-{
-    friend range_access;
-    char const * sz_;
-    char const & read() const { return *sz_; }
-    bool equal(default_sentinel_t) const { return *sz_ == '\0'; }
-    void next() { ++sz_; }
-public:
-    c_string_range() = default;
-    explicit c_string_range(char const *sz) : sz_(sz)
-    {
-        assert(sz != nullptr);
-    }
-};
-
-int main()
-{
-    c_string_range r("hello world");
-    // Iterate over all the characters and print them out
-    ranges::for_each(r, [](char ch){
-        std::cout << ch << ' ';
-    });
-    // prints: h e l l o   w o r l d
-}
diff --git a/src/contrib/range-v3-0.11.0/version.hpp.in b/src/contrib/range-v3-0.11.0/version.hpp.in
deleted file mode 100644
index bd51b8df..00000000
--- a/src/contrib/range-v3-0.11.0/version.hpp.in
+++ /dev/null
@@ -1,24 +0,0 @@
-/// \file
-// Range v3 library
-//
-//  Copyright Eric Niebler 2017-present
-//
-//  Use, modification and distribution is subject to the
-//  Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-// Project home: https://github.com/ericniebler/range-v3
-//
-
-#ifndef RANGES_V3_VERSION_HPP
-#define RANGES_V3_VERSION_HPP
-
-#define RANGE_V3_MAJOR @RANGE_V3_MAJOR@
-#define RANGE_V3_MINOR @RANGE_V3_MINOR@
-#define RANGE_V3_PATCHLEVEL @RANGE_V3_PATCHLEVEL@
-
-#define RANGE_V3_VERSION \
-    (RANGE_V3_MAJOR * 10000 + RANGE_V3_MINOR * 100 + RANGE_V3_PATCHLEVEL)
-
-#endif
